
            //
            NdisIMCopySendPerPacketInfo(pNewPkt, pSentPkt);

            //
            // Copy the Media specific information
            //
            NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(pSentPkt,
                                                &MediaSpecificInfo,
                                                &MediaSpecificInfoSize);

            if (MediaSpecificInfo || MediaSpecificInfoSize)
            {
                NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(pNewPkt,
                                                    MediaSpecificInfo,
                                                    MediaSpecificInfoSize);
            }

        
        }
        else
        {
            pNewPkt = NULL;
        }

    } while (FALSE);

    
    pSendStruct->pNewPacket = pNewPkt;

    TRACE (TL_T, TM_Send, ("<==epvcGetSendPkt  pSentPkt %p ppNewPkt %p",pSentPkt, pSendStruct->pNewPacket ));
    EXIT()
    return;
}


NDIS_STATUS
epvcAdapterSend(
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET pPkt,
    PRM_STACK_RECORD pSR
    )
{
    BOOLEAN         fDoSend = FALSE;
    PEPVC_ADAPTER   pAdapter  = pMiniport->pAdapter;
    NDIS_STATUS     Status = NDIS_STATUS_FAILURE;

    ENTER("epvcAdapterSend", 0x5b014909)


    TRACE (TL_T, TM_Send, (" ==>epvcAdapterSend" ) )

    do
    {
        //
        // Check to see if we have a valid Send Case
        //
        LOCKOBJ (pMiniport, pSR);
        
        fDoSend = MiniportTestFlag (pMiniport, fMP_MakeCallSucceeded);

        if (fDoSend == FALSE)
        {
            TRACE (TL_V, TM_Send,("Send - MakeCall Not Succeeded"));
        }

        //
        // Add an association while holding the lock
        //
        if (fDoSend == TRUE)
        {
            epvcRefSendPkt(pPkt, &pMiniport->Hdr);
        }
        
        UNLOCKOBJ (pMiniport, pSR);

        if (fDoSend == TRUE)
        {
            epvcCoSendPackets(pMiniport->vc.VcHandle,
                                       &pPkt,
                                       1    
                                       );

            Status = NDIS_STATUS_PENDING;                                      
        }
        else
        {
            Status = NDIS_STATUS_FAILURE;
        }



    } while (FALSE);



    TRACE (TL_T, TM_Send, (" <==epvcAdapterSend fDoSend %x, Status %x", fDoSend, Status ) )
    return Status;
}



VOID
epvcFormulateArpResponse (
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PEPVC_ARP_CONTEXT pArpContext,
    IN PRM_STACK_RECORD pSR
    )
/*++
Routine Description:

    This allocates an Arp Packet, looks at the Arp Request, formulates
    a response and sends it up back to the protocol

Arguments:
    pMiniport - which the packet was sent to
    pArpContext - Contains all the information relating to the Arp. 
                  the Context Is Allocated on the stack

Return:

--*/    
{
    ENTER("epvcFormulateArpResponse",  0x7a763fce)
    PEPVC_ARP_PACKET pResponse = NULL;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    PTASK_ARP pTask = NULL;


    TRACE (TL_T, TM_Send, ("==>epvcFormulateArpResponse pMiniport %x, pArpContext %x",
                             pMiniport, pArpContext))
    do
    {
        //
        // Allocate a buffer from a lookaside list 
        //

        Status = epvcAllocateTask(
                &pMiniport->Hdr,        // pParentObject,
                epvcTaskRespondToArp,   // pfnHandler,
                0,                          // Timeout,
                "Task: Arp Response",   // szDescription
                &(PRM_TASK)pTask,
                pSR
                );

        if (FAIL(Status))
        {
            pTask = NULL;
            break;
        }

        //
        // Set up Arp Response
        //

        pResponse = &pTask->Pkt;
        EPVC_ZEROSTRUCT (pResponse);

        {
            //
            // Construct the Ethernet Header 
            //
        
            PEPVC_ETH_HEADER  pRespHeader = &pResponse->Header;
            PEPVC_ETH_HEADER  pSrcHeader = (PEPVC_ETH_HEADER)pArpContext->pEthHeader;

            ASSERT (pSrcHeader != NULL);
            ASSERT (pRespHeader  != NULL);

            //
            // set up the Eth header
            //
            NdisMoveMemory (&pRespHeader->eh_daddr, 
                            &pSrcHeader->eh_saddr, 
                            ARP_802_ADDR_LENGTH ) ;

            NdisMoveMemory ( &pRespHeader->eh_saddr,                            
                             &pMiniport->info.MacAddressDummy, 
                             ARP_802_ADDR_LENGTH );

            pRespHeader->eh_type = pSrcHeader->eh_type;  // copy 08 06 over
                                                        
            
        }           


        
        {

            //
            // Construct the Arp Response
            //

            PEPVC_ARP_BODY pRespBody = &pResponse->Body;
            PEPVC_ARP_BODY pSrcBody = pArpContext ->pBody;

            ASSERT (pRespBody != NULL);


            ASSERT (pSrcBody  != NULL);


            
            pRespBody->hw = pSrcBody->hw;                                       // Hardware address space. = 00 01

            pRespBody->pro = pSrcBody->pro;                                 // Protocol address space. = 08 00

            pRespBody->hlen = ARP_802_ADDR_LENGTH; // 6

            pRespBody->plen = sizeof (IP_ADDR); // 4
            
            pRespBody->opcode = net_short(ARP_RESPONSE);                        // Opcode.


            pRespBody->SenderHwAddr= pMiniport->info.MacAddressDummy;           // Source HW address.

            pRespBody->SenderIpAddr = pSrcBody->DestIPAddr ;                    // Source protocol address.

            pRespBody->DestHwAddr = pSrcBody->SenderHwAddr;                     // Destination HW address.

            pRespBody->DestIPAddr = pSrcBody->SenderIpAddr;                     // Destination protocol address.

        }



        //
        // So we have the packet ready for transmission.
        //

        RmStartTask ((PRM_TASK)pTask, 0 , pSR);

    } while (FALSE);
    
    TRACE (TL_T, TM_Send, ("<==epvcFormulateArpResponse "))

}



NDIS_STATUS
epvcTaskRespondToArp(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
Routine Description:

    This function queues a zero timeout timer and indicates a receive


Arguments:


Return:

--*/    
{
    ENTER("epvcTaskRespondToArp", 0xd05c4942)
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    PEPVC_I_MINIPORT    pMiniport   = (PEPVC_I_MINIPORT ) RM_PARENT_OBJECT(pTask);
    PTASK_ARP           pTaskArp    = (PTASK_ARP) pTask;
    PEPVC_ADAPTER       pAdapter    = (PEPVC_ADAPTER)pMiniport->Hdr.pParentObject;


    enum 
    {
        Stage_Start =0, // default
        Stage_DoAllocations,
        Stage_QueuedTimer,
        Stage_PacketReturned,
        Stage_TaskCompleted,
        Stage_End       
    
    
    }; // To be used in pTask->Hdr.State to indicate the state of the Task

    TRACE ( TL_T, TM_Pt, ("==> epvcTaskRespondToArp %x",pTask->Hdr.State  ) );

    switch (pTask->Hdr.State)
    {
        case Stage_Start:
        {
            LOCKOBJ (pMiniport, pSR);
            
            if (epvcIsThisTaskPrimary ( pTask, &(PRM_TASK)(pMiniport->arps.pTask)) == FALSE)
            {
                PRM_TASK pOtherTask = (PRM_TASK)(pMiniport->arps.pTask);
                
                RmTmpReferenceObject (&pOtherTask->Hdr, pSR);

                //
                // Set The state so we restart this code after main task completes 
                //

                pTask->Hdr.State = Stage_Start;
                UNLOCKOBJ(pMiniport, pSR);

                

                RmPendTaskOnOtherTask (pTask, 0, pOtherTask, pSR);

                RmTmpDereferenceObject(&pOtherTask->Hdr,pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // We are the primary task
            //
            //
            // Check to see if the miniport is still active. 
            // If it is halting, then we don't need to do any work
            //
            if (MiniportTestFlag(pMiniport,  fMP_MiniportInitialized) == FALSE)
            {
                //
                // Our work had been done. So break out and complete the task
                //
                Status = NDIS_STATUS_SUCCESS;
                
                pTask->Hdr.State = Stage_TaskCompleted;
                UNLOCKOBJ(pMiniport, pSR);
                break;
            }


            UNLOCKOBJ(pMiniport, pSR);

            pTask->Hdr.State = Stage_DoAllocations;

            FALL_THROUGH
        }

        case Stage_DoAllocations:
        {
            PNDIS_BUFFER pBuffer = NULL;
            
            TRACE (TL_V, TM_Send, ("epvcTaskRespondToArp Stage_DoAllocations Task %p", pTask) );

            //
            // Allocate An NDis Buffer
            //
            epvcAllocateBuffer(&Status,
                               &pBuffer,
                               NULL,  // Pool Handle
                               (PVOID)&pTaskArp->Pkt,
                                sizeof(pTaskArp->Pkt) ); //Length

            ASSERT (sizeof(pTaskArp->Pkt)  == 0x2a);
            
            if (FAIL(Status) == TRUE)                               
            {
                pBuffer = NULL;
                pTask->Hdr.State = Stage_TaskCompleted;


                ASSERTAndBreak (!FAIL(Status));
                break;
            }
            


            //
            // Allocate An Ndis Packet
            //


            epvcAllocatePacket (&Status,
                                &pTaskArp->pNdisPacket,
                                &pMiniport->PktPool.Recv);

            if (FAIL(Status) == TRUE)
            {
                pTask->Hdr.State = Stage_TaskCompleted;
                pTaskArp->pNdisPacket = NULL;

                //
                // Undo allocations 
                //
                epvcFreeBuffer (pBuffer);

                ASSERTAndBreak( !FAIL(Status) );
                
            }

            //
            //  Set up the Ndis Buffer within the NdisPacket
            //
            {
                PNDIS_PACKET_PRIVATE    pPktPriv = &pTaskArp->pNdisPacket->Private;

                pPktPriv->Head = pBuffer;
                pPktPriv->Tail = pBuffer;
                pBuffer->Next = NULL;
            }

            //
            // Set up the Arp response
            //



            //
            // Queue the timer
            //

            NdisMInitializeTimer ( &pTaskArp->Timer,
                                   pMiniport->ndis.MiniportAdapterHandle,
                                   epvcArpTimer,
                                   pTaskArp );

            pTask->Hdr.State = Stage_QueuedTimer;

            //
            // Now prepare to be called back througha timer to do the 
            // receive indication
            //
            RmSuspendTask(pTask, 0,pSR);
            Status = NDIS_STATUS_PENDING;
            
            NdisMSetTimer (&pTaskArp->Timer, 0); // Zero timeout

            break;
        }

        case Stage_QueuedTimer:
        {

            TRACE (TL_V, TM_Send, ("epvcTaskRespondToArp Stage_QueuedTimer Task %p", pTask) );

            //
            // The miniport could have been halted during the timer 
            //
            if (MiniportTestFlag (pMiniport, fMP_MiniportInitialized) == FALSE)
            {
                
                pTask->Hdr.State = Stage_TaskCompleted;
                ASSERTAndBreak(MiniportTestFlag (pMiniport, fMP_MiniportInitialized) == TRUE);
            }

            NDIS_SET_PACKET_HEADER_SIZE(pTaskArp->pNdisPacket       ,
                                      sizeof (pMiniport->RcvEnetHeader)) ; 
            
            NDIS_SET_PACKET_STATUS (pTaskArp->pNdisPacket, NDIS_STATUS_RESOURCES);

            pTask->Hdr.State = Stage_PacketReturned;


            epvcMIndicateReceivePacket (pMiniport,
                                        &pTaskArp->pNdisPacket,
                                        1 );


            FALL_THROUGH
        }

        case Stage_PacketReturned:      
        {
                            
            pTask->Hdr.State = Stage_TaskCompleted;
            Status = NDIS_STATUS_SUCCESS;
            break;
            

        }

        case Stage_TaskCompleted:
        case Stage_End      :
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }
        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }

    }

    if (pTask->Hdr.State == Stage_TaskCompleted)
    {
        //
        // Free the packet 
        //
        pTask->Hdr.State = Stage_End;
        
        if (pTaskArp->pNdisPacket != NULL)
        {
            //
            // Free the buffer
            //
            PNDIS_PACKET_PRIVATE pPrivate = & pTaskArp->pNdisPacket->Private;
            
            if (pPrivate -> Head != NULL)
            {
                
                epvcFreeBuffer (pPrivate->Head );
                pPrivate->Head = pPrivate->Tail = NULL;
            }

            //
            // free the arp packet
            //
            epvcFreePacket (pTaskArp->pNdisPacket , &pMiniport->PktPool.Recv);
            
            pTaskArp->pNdisPacket = NULL;
        }

        LOCKOBJ (pMiniport, pSR);

        epvcClearPrimaryTask  (&(PRM_TASK)(pMiniport->arps.pTask));

        UNLOCKOBJ (pMiniport, pSR);
            

        Status = NDIS_STATUS_SUCCESS;

    }
    TRACE ( TL_T, TM_Pt, ("<== epvcTaskRespondToArp %x",Status) );

    return Status;
}


VOID
epvcArpTimer(
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    )
/*++
Routine Description:

    Resume the epvcTaskRespondToArp Task


Arguments:


Return:

--*/    
{
    ENTER ("epvcArpTimer",0xf2adae0e)
    PRM_TASK pTask =  (PRM_TASK) FunctionContext;
    
    RM_DECLARE_STACK_RECORD (SR);


    RmResumeTask (pTask,0,&SR);


    EXIT()
}


BOOLEAN
epvcCheckAndReturnArps (
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PNDIS_PACKET pPkt,
    IN PEPVC_SEND_STRUCT pSendStruct,
    IN PRM_STACK_RECORD pSR
    )
/*++
Routine Description:
    Looks at the packet that is being sent. If it is an Arp request, 
    then it formulates a responses and queues a timer of timeout zero to
    return the Arp

Arguments:
    pMiniport - which the packet was sent to
    pPkt - the packet being sent


Return:
    True - if this is an Arp Request. 
--*/    
{
    ENTER("epvcCheckAndReturnArps ", 0xb8e6a3c4)
    EPVC_ARP_CONTEXT ArpContext;
    TRACE (TL_T, TM_Send, ("==>epvcCheckAndReturnArps "));

    
    EPVC_ZEROSTRUCT (&ArpContext);
    
    do
    {

        ArpContext.pFirstBuffer  = pPkt->Private.Head;


        //
        // Do some sanity checks 
        //
        if (ArpContext.pFirstBuffer == NULL)
        {
            break;
        }

        NdisQueryBufferSafe( ArpContext.pFirstBuffer , 
                             &(PVOID)ArpContext.pEthHeader, 
                             &ArpContext.BufferLength, 
                             LowPagePriority );

        if (ArpContext.pEthHeader == NULL)
        {
            break;
        }

        //
        // It the is not an ARP request then ignore it -- 
        // during testing only
        //
        if (ArpContext.pEthHeader->eh_daddr.Byte[0] == 0xff &&
            ArpContext.pEthHeader->eh_daddr.Byte[1] == 0xff )
        {
            pSendStruct->fNonUnicastPacket = TRUE;      
        }
        
        
        
        if (ARP_ETYPE_ARP != net_short(ArpContext.pEthHeader->eh_type))
        {
            //
            //  This is not an Arp packet. Is this an IPv4 packet
            //
            if (IP_PROT_TYPE != net_short(ArpContext.pEthHeader->eh_type))
            {
                // If this is not an IPv4 packet, then mark it so that it can
                // be discarded
                pSendStruct->fNotIPv4Pkt = TRUE;
            }

           break;                            
        }

        //
        // We'll parse the structure using pre-defined structs
        //
        ArpContext.pArpPkt =  (PEPVC_ARP_PACKET)ArpContext.pEthHeader;

        ASSERT (ArpContext.BufferLength >= sizeof (EPVC_ARP_PACKET));

        if (ArpContext.BufferLength < sizeof (EPVC_ARP_PACKET))
        {
            //
            // TODO : Add Code to handle this case.
            // 
            break;
        }
        
        ArpContext.pBody =  (PEPVC_ARP_BODY)&ArpContext.pArpPkt->Body; 

        TRACE (TL_V, TM_Send, ("Received an ARP %p, Body %x\n", ArpContext.pEthHeader, ArpContext.pBody));


        //
        // Validate the Opcode, the prot type,  hard size, prot size
        //

        if (ARP_REQUEST  != net_short (ArpContext.pBody->opcode ))
        {
            //
            // This is not an Arp request
            //
            break;
        }


        if (IP_PROT_TYPE != net_short(ArpContext.pBody->pro) ||
            ARP_802_ADDR_LENGTH != ArpContext.pBody->hlen ||
            sizeof (IP_ADDR) != ArpContext.pBody->plen )
        {
            //
            // these are just sanity checks
            //
            ASSERT (!"Invalid ARP Packet");
            break;

        }

        //
        // We have a valid ArpRequest
        //
        ArpContext.fIsThisAnArp  = TRUE;

        //
        // If tcp/ip is arping for itself, then do not respond... but return
        //  TRUE, so that this packet is not sent on the wire
        //
        
        if (ArpContext.pArpPkt->Body.SenderIpAddr == ArpContext.pArpPkt->Body.DestIPAddr)
        {
            break;
        }

        //
        // Formulate and indicate an Arp Response
        //
        
        epvcFormulateArpResponse (pMiniport, &ArpContext, pSR);
        

    } while (FALSE);

    EXIT()

    return ArpContext.fIsThisAnArp ;
    TRACE (TL_T, TM_Send, ("<==epvcCheckAndReturnArps "));

}


NDIS_STATUS 
epvcRemoveEthernetHeader(
    PEPVC_SEND_STRUCT pSendStruct,  
    IN PRM_STACK_RECORD pSR
    )
/*++
Routine Description:

    Expects that the new packet is already set up with 
    the Ndis Bufferz

Arguments:
    pSendStruct - Contains all the arguments that are needed.

Return:
    True - if this is an Arp Request. 
--*/    
{
    ENTER ("epvcAddLLCEncapsulation" , 0x3ec589c9) 

    BOOLEAN             fUsedPktStack   = pSendStruct->fUsingStacks;
    NDIS_STATUS         NdisStatus      = NDIS_STATUS_FAILURE;
    PNDIS_PACKET        pNewPkt         = pSendStruct->pNewPacket; 
    PEPVC_I_MINIPORT    pMiniport       = pSendStruct->pMiniport;
    
    TRACE (TL_T, TM_Send, ("==>epvcRemoveEthernetHeader  "));




    do
    {
        ULONG BufferLength = 0; 
        PNDIS_BUFFER pBuffer = NULL;

        if (pMiniport->fDoIpEncapsulation == FALSE)
        {
            NdisStatus      = NDIS_STATUS_SUCCESS;

            break; // we are done
        }

        //
        // There are three ways we can be given a ether net header
        // 1. In a seperate MDL - most often 
        // 2. As part of a large MDL - We need to adhust the Virtual address
        // 3. EthernetHeader is seperated across multiple 
        //                      MDLs - not implemented or expected
        //

        pBuffer  = pNewPkt->Private.Head;

        BufferLength = NdisBufferLength (pBuffer);

        if (BufferLength < sizeof (EPVC_ETH_HEADER) )
        {
            
            ASSERTAndBreak (BufferLength >= sizeof (EPVC_ETH_HEADER)) ; // we are done 
        

        }

        //
        // At this point the first  buffer is going to be replaced so keep a record of it
        //
        pSendStruct->Context.Stack.ipv4Send.pOldHeadNdisBuffer = pBuffer;

        //
        // New we check to see if all we need to do is make the 
        // Packet->Private.Head point to the next MDL
        //
        if (BufferLength == sizeof (EPVC_ETH_HEADER))
        {
            //
            // These are error conditions that should not 
            // be handled in our software
            //
            ASSERT (pBuffer->Next != NULL); // no tcp header after the Eth header

            pNewPkt->Private.Head = pBuffer->Next;

            NdisStatus = NDIS_STATUS_SUCCESS;

            break ; // we are done

        }
        
        if (BufferLength > sizeof (EPVC_ETH_HEADER))
        {
            //
            // Allocate a new NDIS Buffer pointing to start of the IP header w
            // within the current Head (pBuffer)
            //
            PNDIS_BUFFER    pNewBuffer = NULL;
            PUCHAR          pIpHeader = NdisBufferVirtualAddress(pBuffer);
            UINT            LenRemaining = BufferLength - sizeof (EPVC_ETH_HEADER);

            if (pIpHeader == NULL)
            {
                //
                // we did not get the virtual address from the system.
                // Start to fail this packet
                //
                ASSERTAndBreak(pIpHeader != NULL);

            }

            //
            // Now move the Ip Header past the Ethernet Header (where it currently points to)
            //
            pIpHeader += sizeof (EPVC_ETH_HEADER)  ;

            //
            // Now allocate the new NdisBuffer
            //
            epvcAllocateBuffer ( &NdisStatus,
                                 &pNewBuffer,
                                 NULL,
                                 pIpHeader,
                                 LenRemaining);

            if (NdisStatus != NDIS_STATUS_SUCCESS) 
            {
                pNewBuffer  = NULL;
                ASSERTAndBreak (!"Ndis Buffer Allocation failed");
            }

            //
            // Make the New Buffer the Head of the new packet
            //
            // We might have to make it the tail if there is 
            // only one ndis buffer in the packet
            //
            if (pNewPkt->Private.Head  == pNewPkt->Private.Tail)
            {
                pNewPkt->Private.Tail = pNewBuffer;
            }

            pNewBuffer->Next= pNewPkt->Private.Head->Next;
            pNewPkt->Private.Head = pNewBuffer;
            

            NdisStatus = NDIS_STATUS_SUCCESS;

            break ; // we are done
        }



    } while (FALSE);


    TRACE (TL_T, TM_Send, ("<==epvcRemoveEthernetHeader  "));

    return NdisStatus ;

}


VOID
epvcSetPacketContext (
    IN PEPVC_SEND_STRUCT pSendStruct, 
    PRM_STACK_RECORD pSR
    )
/*++
Routine Description:

    No allocations, just add a few pointers and exit

Arguments:
    pSendStruct - Contains all the arguments that are needed.

Return:
    None:
    
--*/    
    
{

    PNDIS_PACKET        pPkt = pSendStruct->pNewPacket;
    PEPVC_PKT_CONTEXT pContext = NULL;
    PEPVC_STACK_CONTEXT pStack = NULL;
    //
    // first point the context to  the correct place 
    // in the new ndis pakcet
    //

    if (pSendStruct->fUsingStacks == TRUE)
    {   
        pStack = (PEPVC_STACK_CONTEXT)(&pSendStruct->pPktStack->IMReserved[0]);
    }
    else
    {
        PEPVC_PKT_CONTEXT pContext = NULL;

        pContext = (PEPVC_PKT_CONTEXT   )(&pPkt->ProtocolReserved[0]);

        pContext->pOriginalPacket = pSendStruct->pOldPacket;

        pStack = &pContext->Stack;

    }


    //
    // Update the packet
    //
    ASSERT (sizeof (pStack) <= (2 *sizeof (PVOID)  ));

    //
    // Now copy the stack portion of the context over
    // into the packet
    //
    *pStack = pSendStruct->Context.Stack;

    
}



NDIS_STATUS
epvcAddLLCEncapsulation (
    PEPVC_I_MINIPORT pMiniport , 
    PNDIS_PACKET pOldPkt,
    PNDIS_PACKET pNewPkt,
    PRM_STACK_RECORD pSR
    )
/*++
Routine Description:

    Expects that the new packet is already set up with 
    the Ndis Bufferz

Arguments:
    pSendStruct - Contains all the arguments that are needed.

Return:
    True - if this is an Arp Request. 
--*/    
{
    ENTER ("epvcAddLLCEncapsulation" , 0x3ec589c9) 
    BOOLEAN         fDoSend = TRUE;
    BOOLEAN         fUsedPktStack = (pOldPkt == pNewPkt);
    NDIS_STATUS     NdisStatus = NDIS_STATUS_SUCCESS;
    PNDIS_BUFFER    pNewBuffer = NULL;
    
    TRACE (TL_T, TM_Send, ("==>epvcAddLLCEncapsulation "));

    do
    {
        if (pMiniport->fAddLLCHeader == FALSE)
        {
            break; // we are done
        }
        

        //
        // Allocate an MDL that points to the LLC Header
        //
        epvcAllocateBuffer ( &NdisStatus,
                             &pNewBuffer,
                             NULL,
                             pMiniport->pLllcHeader,
                             pMiniport->LlcHeaderLength);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            pNewBuffer = NULL;
            break;
        }
        

        //
        // Insert the New Buffer as the Head of the new Packet
        //
        pNewBuffer->Next = pNewPkt->Private.Head;
        pNewPkt->Private.Head = pNewBuffer;

        pNewPkt->Private.ValidCounts= FALSE;

        NdisStatus = NDIS_STATUS_SUCCESS;
        
    } while (FALSE);

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {   
        if (pNewBuffer!= NULL)
        {
            epvcFreeBuffer (pNewBuffer);
            pNewBuffer = NULL;
        }

    }

    TRACE (TL_T, TM_Send, ("<==epvcAddLLCEncapsulation "));

    return NdisStatus ;
}



NDIS_STATUS
epvcRemoveSendEncapsulation (
    PEPVC_I_MINIPORT pMiniport , 
    PNDIS_PACKET pNewPkt
    )
{

    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
epvcRemoveRecvEncapsulation (
    PEPVC_I_MINIPORT pMiniport , 
    PNDIS_PACKET pNewPkt
    )
{

    return NDIS_STATUS_SUCCESS;
}


VOID
epvcDumpPkt (
    IN PNDIS_PACKET pPkt
    )
{

    PNDIS_BUFFER pPrevBuffer;

    do
    {
        PNDIS_BUFFER pBuffer = NULL;
    
        if (g_bDumpPackets == FALSE)
        {
            
            break;

        }

        pBuffer = pPkt->Private.Head;

        //
        // Now iterate through all the buffers 
        // and print out the packet. 
        //
        TRACE (TL_A, TM_Mp, ("pPkt %p, Head %p, tail %p\n ", 
                pPkt, pPkt->Private.Head, pPkt->Private.Tail));

        //
        // As we always expect the first buffer to be present
        // I do not check
        //
        do
        {
            PVOID pVa = NULL;
            ULONG Len = 0;
            pPrevBuffer = NULL;
            
            Len = NdisBufferLength (pBuffer);

            pVa = NdisBufferVirtualAddress(pBuffer);

            pPrevBuffer = pBuffer;
            pBuffer = pBuffer->Next;

            
            if (pVa == NULL)
            {
                continue;
            }

            DbgPrint ("Mdl %p, Va %p. Len %x\n", pPrevBuffer, pVa,Len);
            Dump( (CHAR* )pVa, Len, 0, 1 );                           

 
        } while (pBuffer != NULL);

    } while (FALSE);
}



NDIS_STATUS
epvcMiniportReadConfig(
    IN PEPVC_I_MINIPORT pMiniport,
    NDIS_HANDLE     WrapperConfigurationContext,
    PRM_STACK_RECORD pSR
    )
{   
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    NDIS_HANDLE     ConfigurationHandle;
    PMP_REG_ENTRY   pRegEntry;
    UINT            i;
    UINT            value;
    PUCHAR          pointer;
    PNDIS_CONFIGURATION_PARAMETER ReturnedValue;
    PUCHAR          NetworkAddress;
    UINT            Length;

    // Open the registry for this pMiniport
    NdisOpenConfiguration(
        &Status,
        &ConfigurationHandle,
        WrapperConfigurationContext);
    if(Status != NDIS_STATUS_SUCCESS)
    {
        TRACE (TL_I, TM_Mp,("NdisOpenConfiguration failed\n"));
        return Status;
    }

    // read all the registry values 
    for(i = 0, pRegEntry = NICRegTable; i < NIC_NUM_REG_PARAMS; i++, pRegEntry++)
    {
        pointer = (PUCHAR) pMiniport + pRegEntry->FieldOffset;


        // Get the configuration value for a specific parameter.  Under NT the
        // parameters are all read in as DWORDs.
        NdisReadConfiguration(
            &Status,
            &ReturnedValue,
            ConfigurationHandle,
            &pRegEntry->RegName,
            NdisParameterInteger);


        // If the parameter was present, then check its value for validity.
        if(Status == NDIS_STATUS_SUCCESS)
        {
            // Check that param value is not too small or too large
            if(ReturnedValue->ParameterData.IntegerData < pRegEntry->Min ||
                ReturnedValue->ParameterData.IntegerData > pRegEntry->Max)
            {
                value = pRegEntry->Default;
            }
            else
            {
                value = ReturnedValue->ParameterData.IntegerData;
            }

            TRACE (TL_I, TM_Mp, ("= 0x%x", value));
        }
        else if(pRegEntry->bRequired)
        {
            TRACE (TL_I, TM_Mp,(" -- failed"));

            ASSERT(FALSE);

            Status = NDIS_STATUS_FAILURE;
            break;
        }
        else
        {
            value = pRegEntry->Default;
            TRACE (TL_I, TM_Mp,("= 0x%x (default)", value));
            Status = NDIS_STATUS_SUCCESS;
        }

        // Store the value in the pMiniport structure.
        switch(pRegEntry->FieldSize)
        {
            case 1:
                *((PUCHAR) pointer) = (UCHAR) value;
                break;

            case 2:
                *((PUSHORT) pointer) = (USHORT) value;
                break;

            case 4:
                *((PULONG) pointer) = (ULONG) value;
                break;

            default:
                TRACE (TL_I,TM_Mp, ("Bogus field size %d", pRegEntry->FieldSize));
                break;
        }
    }

    // Read NetworkAddress registry value 
    // Use it as the current address if any

    // Close the registry
    NdisCloseConfiguration(ConfigurationHandle);

    TRACE (TL_I, TM_Mp,("vci %d\n", pMiniport->config.vci));
    TRACE (TL_I, TM_Mp,("vpi %d\n", pMiniport->config.vpi));
    TRACE (TL_I, TM_Mp,("Encap Type %x\n", pMiniport->Encap));
    
    TRACE (TL_T, TM_Mp, ("<-- NICReadRegParameters, Status=%x", Status));

    return Status;
}

ULONG gDbgMpFlags =0;;
ULONG gRmFlags = 0;

NDIS_STATUS
epvcTaskCloseAddressFamily(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )

/*++

Routine Description:

    This is the task used to close the Af. It Deinitializes the miniport
    then calls the Close Miniport Task to Close the Af.

Arguments:

    ProtocolBindingContext  Pointer to the adapter structure
    Status                  Completion status

Return Value:

    None.

--*/

{
    ENTER ("epvcTaskCloseAddressFamily", 0x20a02c3f)
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    PEPVC_I_MINIPORT    pMiniport   = (PEPVC_I_MINIPORT ) RM_PARENT_OBJECT(pTask);
    PTASK_AF            pAfTask     = (PTASK_AF) pTask;
    BOOLEAN             fNeedToHalt  = FALSE;
    BOOLEAN             fNeedToCancel = FALSE;
    BOOLEAN             fCloseAf  = FALSE;
    ULONG               State;

    enum 
    {
        Stage_Start =0, // default
        Stage_MiniportHalted,
        Stage_CloseAfComplete,
        Stage_TaskCompleted,
        Stage_End       
    
    }; // To be used in pTask->Hdr.State to indicate the state of the Task

    

    TRACE ( TL_T, TM_Pt, ("==> epvcTaskCloseAddressFamily  State %x", pTask->Hdr.State) );

    State = pTask->Hdr.State;
    
    switch(State)
    {
        case Stage_Start:
        {
            //
            // Check to see if the miniport has already opened an address family.
            // If so exit
            //
            LOCKOBJ (pMiniport, pSR );

            gDbgMpFlags  = pMiniport->Hdr.State;
            
            if (epvcIsThisTaskPrimary ( pTask, &(PRM_TASK)(pMiniport->af.pCloseAfTask)) == FALSE)
            {
                PRM_TASK pOtherTask = (PRM_TASK)(pMiniport->af.pCloseAfTask);
                

                TRACE (TL_I, TM_Mp, (" Task is not primary\n"));

                RmTmpReferenceObject (&pOtherTask->Hdr, pSR);
                
            
                //
                // Set The state so we restart this code after main task completes 
                //

                pTask->Hdr.State = Stage_Start;
                UNLOCKOBJ(pMiniport, pSR);

                

                RmPendTaskOnOtherTask (pTask, 0, pOtherTask, pSR);

                RmTmpDereferenceObject(&pOtherTask->Hdr,pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // We are the primary task
            //
            ASSERT (pMiniport->af.pCloseAfTask == pAfTask);
            //
            // Check to see if our work is already done
            //


            if (MiniportTestFlag (pMiniport, fMP_AddressFamilyOpened) == FALSE)
            {
                //
                // quietly exit as the address family is already closed
                //
                UNLOCKOBJ(pMiniport, pSR);
                ASSERT (MiniportTestFlag (pMiniport, fMP_AddressFamilyOpened) == TRUE);
                State = Stage_TaskCompleted;   // we're finished.
                Status = NDIS_STATUS_FAILURE; // Exit
                gRmFlags  = pTask->Hdr.RmState;
                break;
            }

            
            

            //
            // Now do we need to halt the miniport.
            //
            if (MiniportTestFlag (pMiniport, fMP_MiniportInitialized) == TRUE)
            {
                //
                // Our Halt Handler has not been called,
                //
                fNeedToHalt = TRUE;
                
            }
            else
            {
                //
                // We are not in the middle of a halt, so this probably
                // an unbind or Af_Close before the Init Handler.
                //
                // This task is not part of the halt code path
                //
                ASSERT (pAfTask->Cause != TaskCause_MiniportHalt);
                fNeedToCancel = TRUE;
            
            }

            if (fNeedToHalt || fNeedToCancel)
            {
                MiniportClearFlag (pMiniport, fMP_DevInstanceInitialized);

            }

            UNLOCKOBJ(pMiniport,pSR);

            
            //
            // Call Ndis to Deinitialize the miniport, The miniport is already Refed
            //
            TRACE ( TL_T, TM_Pt, ("epvcTaskCloseAddressFamily  ----") );

            if (TRUE == fNeedToHalt )
            {
                epvcIMDeInitializeDeviceInstance (pMiniport);
            }

            if (TRUE == fNeedToCancel )
            {
                epvcCancelDeviceInstance (pMiniport, pSR);
            }

            //
            // If the dev instance was not halted, then this thread has to close the Af
            //
            pTask->Hdr.State = Stage_MiniportHalted;
            
            if (fNeedToHalt == TRUE )
            {
                //
                // otherwise the work is over, the halt will close the address family
                //
                State = Stage_TaskCompleted;
                break;
            }

                
            FALL_THROUGH
        }
        
        case Stage_MiniportHalted:
        {   
            //
            // If the Af is still open, and the miniport halt was never fired, then 
            // issue the close Af
            //

            fCloseAf = (MiniportTestFlag(pMiniport, fMP_AddressFamilyOpened) == TRUE);
                                

            if (fCloseAf == TRUE)
            {
 
                PRM_TASK pAfTask = NULL;
                //
                // We need to start a task to complete the Close Call And DeleteVC
                //

                Status = epvcAllocateTask(
                    &pMiniport->Hdr,            // pParentObject,
                    epvcTaskCloseIMiniport, // pfnHandler,
                    0,                          // Timeout,
                    "Task: Close Miniport", // szDescription
                    &pAfTask ,
                    pSR
                    );

                if (FAIL(Status))
                {   
                    State = Stage_TaskCompleted;

                    pAfTask  = NULL;
                    ASSERT (Status == NDIS_STATUS_SUCCESS);
                    break;
                }

                ((PTASK_AF)pAfTask)->Cause = TaskCause_AfCloseRequest;

                //
                // Now we will pend the halt on the completion of the delete VC
                // task
                //
                pTask->Hdr.State = Stage_CloseAfComplete;

                
                
                RmPendTaskOnOtherTask(pTask,
                                      0,
                                      pAfTask,
                                      pSR
                                      );

                //
                // Start the Af TearDown
                //
                RmStartTask (pAfTask , 0, pSR);

                //
                // Exit - We expect to complete this task in another thread
                //
                Status = NDIS_STATUS_PENDING;
                break;
                                                    

            }
            else // Close Af == FALSE
            {
                State = Stage_TaskCompleted;
            }
            
            
            
            break;
                    
        }
        case Stage_CloseAfComplete:
        {
            State = Stage_TaskCompleted ;
            break;
        
        }

        case Stage_End:
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        

    }


    if (Stage_TaskCompleted == State )
    {
        pTask->Hdr.State = Stage_End;
        Status = NDIS_STATUS_SUCCESS;


        //
        // Clear the task here
        //
        
        LOCKOBJ(pMiniport, pSR);

        pMiniport->af.pCloseAfTask= NULL;

        UNLOCKOBJ(pMiniport, pSR);

        //
        // Set the complete event here
        //
            
        if (pAfTask->Cause == TaskCause_ProtocolUnbind)
        {
            epvcSetEvent (&pAfTask->CompleteEvent);

        }


    }


    RM_ASSERT_NOLOCKS(pSR);

    TRACE ( TL_T, TM_Pt, ("<== epvcTaskCloseAddressFamily Status %x", Status) );
    
    EXIT();
    return Status;


    
}


VOID
epvcInitializeMiniportLookasideLists (
    IN PEPVC_I_MINIPORT pMiniport
    )
/*++

Routine Description:

    Initialize all the lookaside lists in the adapter block

Arguments:


Return Value:

    None.

--*/
    
{
    USHORT DefaultDepth = 15;
    extern const UINT MaxEthernetFrameSize ;

    TRACE( TL_T, TM_Mp, ( "==> nicInitializeMiniportLookasideLists pMiniport %x ", pMiniport ) );


    switch (pMiniport->Encap) 
    {
        case IPV4_ENCAP_TYPE:
        case IPV4_LLC_SNAP_ENCAP_TYPE:
        {

            epvcInitializeLookasideList ( &pMiniport->arps.LookasideList,
                                        sizeof (EPVC_TASK),
                                        TAG_TASK,
                                        DefaultDepth );                                


            
            epvcInitializeLookasideList ( &pMiniport->rcv.LookasideList,
                                        sizeof (EPVC_IP_RCV_BUFFER),
                                        TAG_RCV ,
                                        DefaultDepth );                                




            break;
        }
    
        case ETHERNET_ENCAP_TYPE:
        case ETHERNET_LLC_SNAP_ENCAP_TYPE:
        {

            break;
        }

        default: 
        {


        }




    }

    TRACE( TL_T, TM_Mp, ( "<== nicInitializeMiniportLookasideLists  " ) );

}



VOID
epvcDeleteMiniportLookasideLists (
    IN PEPVC_I_MINIPORT pMiniport
    )
/*++

Routine Description:

    Delete all the lookaside lists in the adapter block

Arguments:


Return Value:

    None.

--*/

{
    TRACE( TL_T, TM_Mp, ( "== epvcDeleteMiniportLookasideLists pMiniport %x ", pMiniport) );


    //
    // Deletes the lookaside lists if they have been allocated
    //
    epvcDeleteLookasideList (&pMiniport->rcv.LookasideList);

    epvcDeleteLookasideList (&pMiniport->arps.LookasideList);




}



NDIS_STATUS
epvcInitializeMiniportPacketPools (
    IN PEPVC_I_MINIPORT pMiniport
    )

/*++

Routine Description:

    Initializr all the packet pools in the miniport 

Arguments:


Return Value:

    None.

--*/
    
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    
    TRACE( TL_T, TM_Mp, ( "==> epvcInitializeMiniportPacketPools  pMiniport %x ", pMiniport ) );

    do
    {

        epvcAllocatePacketPool (&Status,
                                &pMiniport->PktPool.Send,
                                MIN_PACKET_POOL_SIZE,
                                MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
                                sizeof(EPVC_PKT_CONTEXT));

        if (Status != NDIS_STATUS_SUCCESS)
        {
            EPVC_ZEROSTRUCT (&pMiniport->PktPool.Send);
            ASSERT (Status == NDIS_STATUS_SUCCESS);
            break;
        }

 

        epvcAllocatePacketPool (&Status,
                                &pMiniport->PktPool.Recv,
                                MIN_PACKET_POOL_SIZE,
                                MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
                                PROTOCOL_RESERVED_SIZE_IN_PACKET);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            EPVC_ZEROSTRUCT (&pMiniport->PktPool.Recv);
            ASSERT (Status == NDIS_STATUS_SUCCESS);
            break;
        }

    } while ( FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        epvcDeleteMiniportPacketPools (pMiniport);
        
    }

    TRACE( TL_T, TM_Mp, ( "<== epvcInitializeMiniportPacketPools  Status %x ", Status ) );

    return Status;
}



VOID
epvcDeleteMiniportPacketPools (
    IN PEPVC_I_MINIPORT pMiniport
    )
/*++

Routine Description:

    Delete all the packet pools in the miniport block

Arguments:


Return Value:

    None.

--*/
    
{
    
    TRACE( TL_T, TM_Mp, ( "== epvcDeleteMiniportPacketPools  pMiniport %x ", pMiniport ) );



        //
        // Freeing packet pools
        //
        if (pMiniport->PktPool.Recv.Handle != NULL)
        {
            epvcFreePacketPool (&pMiniport->PktPool.Recv);
        }

        if (pMiniport->PktPool.Send.Handle != NULL)
        {
            epvcFreePacketPool (&pMiniport->PktPool.Send);

        }
}



VOID
epvcInitializeMiniportParameters(
    PEPVC_I_MINIPORT pMiniport
    )
{

    //ipv4 - 0
    //ipv4 with llc header = 1
    //Ethernet - 2
    //Ethernet with llc header- 3

    //
    // Defaults for all flags are FALSE
    //
        
    pMiniport->fDoIpEncapsulation = FALSE;
    pMiniport->fAddLLCHeader  = FALSE;

    
    switch (pMiniport->Encap )
    {

        case IPV4_ENCAP_TYPE:
        {
            pMiniport->fDoIpEncapsulation = TRUE;
            pMiniport->MinAcceptablePkt =sizeof (IPHeader) ;
            pMiniport->MaxAcceptablePkt = EPVC_MAX_FRAME_SIZE -EPVC_ETH_HEADERSIZE ;

            break;
        }

        case IPV4_LLC_SNAP_ENCAP_TYPE:
        {
            pMiniport->fAddLLCHeader = TRUE;
            pMiniport->fDoIpEncapsulation = TRUE;
            pMiniport->pLllcHeader = &LLCSnapIpv4[0];
            pMiniport->LlcHeaderLength = sizeof(LLCSnapIpv4);
            pMiniport->MinAcceptablePkt = sizeof (IPHeader) + sizeof(LLCSnapIpv4);
            pMiniport->MaxAcceptablePkt = EPVC_MAX_FRAME_SIZE  + sizeof(LLCSnapIpv4)-EPVC_ETH_HEADERSIZE ;

            break;
        }

        case ETHERNET_LLC_SNAP_ENCAP_TYPE:
        {
            pMiniport->fAddLLCHeader = TRUE;
            pMiniport->pLllcHeader = &LLCSnapEthernet[0];
            pMiniport->LlcHeaderLength = sizeof(LLCSnapEthernet);
            pMiniport->MinAcceptablePkt = MIN_ETHERNET_SIZE + sizeof(LLCSnapEthernet);
            pMiniport->MaxAcceptablePkt = EPVC_MAX_FRAME_SIZE +sizeof(LLCSnapEthernet);

            break;
        }

        case ETHERNET_ENCAP_TYPE:
        {

            pMiniport->MinAcceptablePkt = MIN_ETHERNET_SIZE;
            pMiniport->MaxAcceptablePkt = EPVC_MAX_FRAME_SIZE + EPVC_ETH_ENCAP_SIZE;
            break;
        }
            
        default: 
        {
            ASSERT (!"Not supported - defaulting to Ethernet Encapsulation");
            
        }



    }

}





NDIS_STATUS
epvcTaskHaltMiniport(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler for opening address families on an underlying adapters.
    The number of address families instantiated is determined by the 
    configuration read in the registry

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : UnbindContext

--*/
{
    ENTER("epvcTaskHaltMiniport", 0xaac34d81)
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    PEPVC_I_MINIPORT    pMiniport   = (PEPVC_I_MINIPORT ) RM_PARENT_OBJECT(pTask);
    PEPVC_ADAPTER       pAdapter = pMiniport->pAdapter;
    PTASK_HALT          pTaskHalt = (PTASK_HALT)pTask;
    BOOLEAN             fTaskCompleted = FALSE; 
    ULONG               State;  

    enum 
    {
        Stage_Start =0, // default
        Stage_DeleteVc,
        Stage_CloseAfComplete, 
        Stage_TaskCompleted,
        Stage_End       
    
    }; // To be used in pTask->Hdr.State to indicate the state of the Task

    TRACE(TL_T, TM_Mp, ("==>epvcTaskHaltMiniport State %x", pTask->Hdr.State));

    State = pTask->Hdr.State;
    
    switch (pTask->Hdr.State)
    {   
        case Stage_Start:
        {
            TRACE (TL_V, TM_Mp, (" Task Halt miniport Stage_Start"));


            //
            // Check to see if the miniport has already halting.
            // If so exit
            //
            LOCKOBJ (pMiniport, pSR );

            
            if (epvcIsThisTaskPrimary ( pTask, &(PRM_TASK)(pMiniport->pnp.pTaskHalt)) == FALSE)
            {
                PRM_TASK pOtherTask = (PRM_TASK)(pMiniport->pnp.pTaskHalt);

                RmTmpReferenceObject (&pOtherTask->Hdr, pSR);

                //
                // Set The state so we restart this code after main task completes 
                //

                pTask->Hdr.State = Stage_Start;
                UNLOCKOBJ(pMiniport, pSR);

                

                RmPendTaskOnOtherTask (pTask, 0, pOtherTask, pSR);

                RmTmpDereferenceObject(&pOtherTask->Hdr,pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            // We are the primary task and we have the lock
            //
            
            ASSERT (pMiniport->pnp.pTaskHalt == pTaskHalt);
            //
            // Lets close the Call and Delete the Vc
            //
            UNLOCKOBJ (pMiniport, pSR);
            

            if (MiniportTestFlag (pMiniport, fMP_MakeCallSucceeded) == TRUE)
            {
                PRM_TASK pVcTask = NULL;
                //
                // We need to start a task to complete the Close Call And DeleteVC
                //

                Status = epvcAllocateTask(
                    &pMiniport->Hdr,            // pParentObject,
                    epvcTaskVcTeardown, // pfnHandler,
                    0,                          // Timeout,
                    "Task: TearDown Vc",    // szDescription
                    &pVcTask ,
                    pSR
                    );

                if (FAIL(Status))
                {
                    fTaskCompleted = TRUE;

                    pVcTask  = NULL;
                    ASSERT (Status == NDIS_STATUS_SUCCESS);
                    break;
                }

                //
                // Now we will pend the halt on the completion of the delete VC
                // task
                //
                pTask->Hdr.State = Stage_DeleteVc;


                
                RmPendTaskOnOtherTask(pTask,
                                      0,
                                      pVcTask,
                                      pSR
                                      );

                //
                // Start the Vc TearDown
                //
                RmStartTask (pVcTask , 0, pSR);

                //
                // Exit - We expect to complete this task in another thread
                //
                Status = NDIS_STATUS_PENDING;
                break;

            }
            else //if (MiniportTestFlag (pMiniport, fMP_MakeCallSucceeded) == TRUE)
            {
                pTask->Hdr.State = Stage_DeleteVc;
                //
                // Continue On - the Vc has already been deleted
                //

            }
            

        }

        case Stage_DeleteVc:
        {
            //
            // Now we check to see if the address family is still
            // open for this miniport
            //
            TRACE (TL_V, TM_Mp, (" Task Halt miniport Stage_DeleteVc"));


            if (MiniportTestFlag(pMiniport, fMP_AddressFamilyOpened) == TRUE)
            {
                PRM_TASK pAfTask = NULL;
                //
                // We need to start a task to complete the Close Call And DeleteVC
                //

                Status = epvcAllocateTask(
                    &pMiniport->Hdr,            // pParentObject,
                    epvcTaskCloseIMiniport, // pfnHandler,
                    0,                          // Timeout,
                    "Task: Close Miniport", // szDescription
                    &pAfTask ,
                    pSR
                    );

                if (FAIL(Status))
                {
                    fTaskCompleted = TRUE;

                    pAfTask  = NULL;
                    ASSERT (Status == NDIS_STATUS_SUCCESS);
                    break;
                }

                ((PTASK_AF)pAfTask)->Cause = TaskCause_MiniportHalt;

                //
                // Now we will pend the halt on the completion of the delete VC
                // task
                //
                pTask->Hdr.State = Stage_CloseAfComplete;

                
                
                RmPendTaskOnOtherTask(pTask,
                                      0,
                                      pAfTask,
                                      pSR
                                      );

                //
                // Start the Af TearDown
                //
                RmStartTask (pAfTask , 0, pSR);

                //
                // Exit - We expect to complete this task in another thread
                //
                Status = NDIS_STATUS_PENDING;
                break;

            }
            else //if (MiniportTestFlag (pMiniport, fMP_MakeCallSucceeded) == TRUE)
            {

                pTask->Hdr.State = Stage_CloseAfComplete;

                //
                // Continue On - the Af has already been deleted
                //

            }
            
    
        }
        case Stage_CloseAfComplete: 
        {
            //
            // Free all miniport resources here .- packet pools etc.
            //
            TRACE (TL_V, TM_Mp, (" Task Halt miniport Stage_CloseAfComplete"));

            //
            // Freeing Lookaside lists
            //
            epvcDeleteMiniportLookasideLists (pMiniport);

            //
            // Freeing packet pools
            //
            epvcDeleteMiniportPacketPools(pMiniport);
            
            //
            // If the miniport is halting we do not shut down the protocol's adapter 
            // object
            //
            fTaskCompleted = TRUE;
            Status = NDIS_STATUS_SUCCESS;
            break;


        }

        case Stage_TaskCompleted:
        {
            ASSERT(0);
            break;
        }
        case Stage_End:     
        {
            TRACE (TL_V, TM_Mp, (" Task Halt miniport Stage_End"));
            Status = NDIS_STATUS_SUCCESS;
            break;
        }
        default:
        {
            ASSERT (pTask->Hdr.State <= Stage_End);
        }


    } // end of switch 


    //
    // if this thread has completed the postprocessing,
    // then signal the event.
    //

    if (TRUE == fTaskCompleted)
    {
        BOOLEAN fSetWaitEvent = FALSE;
        TRACE (TL_V, TM_Mp, ("Task Halt Miniport - Stage End"));
        pTask->Hdr.State = Stage_End;
        if (FAIL(Status))
        {

            ASSERT (0);
        }

        LOCKOBJ (pMiniport, pSR);

        pMiniport->pnp.pTaskHalt = NULL;

        if (MiniportTestFlag (pMiniport, fMP_WaitingForHalt)== TRUE)
        {
            MiniportClearFlag (pMiniport, fMP_WaitingForHalt);
            fSetWaitEvent = TRUE;
        }
        
        UNLOCKOBJ (pMiniport, pSR);

        // 
        //  This first event is for the MiniportHalt handler 
        // which fired off this task
        // 
        epvcSetEvent (&pTaskHalt->CompleteEvent);

        //
        // This second event is for the epvcMiniportDoUnbind
        // which wants to wait until the Halt is complete ,
        // before it shuts off the lower binding to the phy. adapter
        //
        if (fSetWaitEvent)
        {
            epvcSetEvent (&pMiniport->pnp.HaltCompleteEvent);
        }
  

        Status = NDIS_STATUS_SUCCESS;
    }

    
    TRACE(TL_T, TM_Mp, ("<==epvcTaskHaltMiniport Status %x", Status));



    EXIT()
    RM_ASSERT_NOLOCKS(pSR);
    return Status;
}


NDIS_STATUS 
epvcAddEthernetTail(
    PEPVC_SEND_STRUCT pSendStruct,  
    IN PRM_STACK_RECORD pSR
    )
/*++
Routine Description:

    Makes sure the ethernet packet is greater than 64 bytes

Arguments:
    pSendStruct - Contains all the arguments that are needed.

Return:
    Success -   if the padding was not needed or the MDL 
                was successfully appended
--*/    
{
    ENTER ("epvcAddEthernetTail" , 0x3ec589c9) 

    NDIS_STATUS         NdisStatus      = NDIS_STATUS_FAILURE;
    PNDIS_PACKET        pNewPkt         = pSendStruct->pNewPacket; 
    PEPVC_I_MINIPORT    pMiniport       = pSendStruct->pMiniport;
    ULONG               PacketLength   = 0;
    ULONG               LengthRemaining = 0;
    PNDIS_BUFFER        pNewTailBuffer = NULL;
    PNDIS_BUFFER        pLastBuffer;
    
    TRACE (TL_T, TM_Send, ("==>epvcAddEthernetTail"));



    do
    {
        ULONG BufferLength = 0; 
        PNDIS_BUFFER pBuffer = NULL;

        if (pMiniport->fDoIpEncapsulation == TRUE)
        {
            NdisStatus      = NDIS_STATUS_SUCCESS;

            break; // we are done
        }

        //
        // Check the length of the Ethernet packet
        //
        NdisQueryPacketLength(pNewPkt, &PacketLength);

        //
        // Is the packet length greater than 64
        //
        if (PacketLength >= MINIMUM_ETHERNET_LENGTH)
        {
            NdisStatus= NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // Add padding to fill up the minimum Ethernet frame length.
        // This is a new buffer that is appended to the original
        // NDIS_BUFFER chain.
        //
        LengthRemaining = MINIMUM_ETHERNET_LENGTH - PacketLength;

        NdisAllocateBuffer(&NdisStatus, &pNewTailBuffer, NULL, &gPaddingBytes,LengthRemaining);

        if (NdisStatus != NDIS_STATUS_SUCCESS || pNewTailBuffer == NULL)
        {
            pNewTailBuffer = NULL;
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // Append the new buffer to the tail of the packet.
        //

        //
        // Locate the last NDIS_BUFFER in the packet. Do it the hard
        // way since Packet->Private.Tail is not reliable:
        //
        pLastBuffer = pNewPkt->Private.Head;

        while (pLastBuffer->Next != NULL)
        {
            pLastBuffer = pLastBuffer->Next;
        }

    
        //
        // Save a pointer to this last MDL so that we can set its
        // Next field back to NULL when we complete this send.
        //
        pSendStruct->Context.Stack.EthernetSend.pOldLastNdisBuffer = pLastBuffer;

        //
        // Append the new buffer to the tail of the chain.
        //
        pLastBuffer->Next = pNewTailBuffer;
        pNewTailBuffer->Next = NULL;


        //
        // Update our packet.
        //
        pNewPkt->Private.Tail = pNewTailBuffer;
        pNewPkt->Private.ValidCounts = FALSE;
        
        NdisStatus = NDIS_STATUS_SUCCESS;

        break ; // we are done

    } while (FALSE);

    if (NdisStatus != NDIS_STATUS_SUCCESS && pNewTailBuffer != NULL)
    {
        NdisFreeBuffer (pNewTailBuffer);
    }


    TRACE (TL_T, TM_Send, ("<==epvcAddEthernetTail  "));

    return NdisStatus ;

}



VOID
epvcRemoveEthernetTail (
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET pPacket,
    IN PEPVC_PKT_CONTEXT pContext
    )
/*++
Routine Description:

    Removes the extra MDL that was added to make 
    this packet greater than MINIUMUM_ETHERNET_SIZE

    Used for Ethernet , Eth +LLC Encapsulations only 
    
Arguments:
    pMiniport - Miniport structure
    pPacket - Packet allocated by EPVC
    pContext - Context of the packet - used to store the original last mdl

    
Return:
    None
--*/    
{
    PNDIS_BUFFER pOldLastNdisBuffer = NULL;

    do
    {

        //
        // Ethernet encapsulation ? If not, then exit
        //
            
        if (pMiniport->fDoIpEncapsulation == TRUE)
        {
            break; // there was no ethernet encapsulation, so exit
        }

        //                    
        // if there is no old buffer, then we can exit
        //
        pOldLastNdisBuffer = pContext->Stack.EthernetSend.pOldLastNdisBuffer;
        
        if (pOldLastNdisBuffer == NULL)
        {
            break;
        }

        //
        // Free the last buffer in the packet (this is the padding
        // we added for a runt packet).
        //
        NdisFreeBuffer(pPacket->Private.Tail);

        //
        // Set the Next pointer of the original "last buffer" to NULL.
        //
        pOldLastNdisBuffer->Next = NULL;
        
                
    } while (FALSE);

}



NDIS_STATUS 
epvcAddEthernetPad(
    PEPVC_SEND_STRUCT pSendStruct,  
    IN PRM_STACK_RECORD pSR
    )
/*++
Routine Description:

    Makes sure the ethernet packet w/o LLC header has a pad of 
    0x00, 0x00 

Arguments:
    pSendStruct - Contains all the arguments that are needed.

Return:
    Success -   if the padding was not needed or the MDL 
                was successfully added
--*/    
{
    ENTER ("epvcAddEthernetPad" , 0x3ec589c9) 

    NDIS_STATUS         NdisStatus      = NDIS_STATUS_FAILURE;
    PNDIS_PACKET        pNewPkt         = pSendStruct->pNewPacket; 
    PEPVC_I_MINIPORT    pMiniport       = pSendStruct->pMiniport;
    PNDIS_BUFFER        pPaddingBuffer = NULL;
    
    TRACE (TL_T, TM_Send, ("==>epvcAddEthernetPad"));



    do
    {
        ULONG BufferLength = 0; 
        PNDIS_BUFFER pBuffer = NULL;

        if (pMiniport->Encap != ETHERNET_ENCAP_TYPE)
        {
            NdisStatus      = NDIS_STATUS_SUCCESS;
            break; // we are done
        }

        //
        // It is pure Ethernet. We need to precede the packet
        // with a 00,00
        //

        NdisAllocateBuffer(&NdisStatus, 
                        &pPaddingBuffer, 
                        NULL, 
                        &gPaddingBytes,
                        ETHERNET_PADDING_LENGTH);

        if (NdisStatus != NDIS_STATUS_SUCCESS || pPaddingBuffer == NULL)
        {
            pPaddingBuffer = NULL;
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // no more allocations - we cannot fail from here
        //
        NdisStatus = NDIS_STATUS_SUCCESS;

        //
        // Add  the new buffer to the head of the packet
        //
        NdisChainBufferAtFront(pNewPkt,pPaddingBuffer);

 
        break ; // we are done
        


    } while (FALSE);

    if (NdisStatus != NDIS_STATUS_SUCCESS && pPaddingBuffer != NULL)
    {
        NdisFreeBuffer (pPaddingBuffer);
    }


    TRACE (TL_T, TM_Send, ("<==epvcAddEthernetPad  "));

    return NdisStatus ;

}


VOID
epvcRemoveEthernetPad (
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET pPacket
    )
/*++
Routine Description:

    Removes the padding  that was added to the 
    head of the packet Ethernet Head
    
    Used for Ethernet Encapsulation only 
    
Arguments:
    pMiniport - Miniport structure
    pPacket - Packet
    
Return:
    None
--*/    
{
    PNDIS_BUFFER pPaddingBuffer= NULL;

    do
    {

        if (pMiniport->Encap != ETHERNET_ENCAP_TYPE)
        {
            break; // we are done
        }

        //                    
        // it is in pure ethernet mode - remove the Padding
        //

        //
        // First - a simple sanity check
        //
        {
            PNDIS_BUFFER pBuffer = pPacket->Private.Head;
            ULONG PaddingLength = NdisBufferLength(pBuffer);
            
            if (PaddingLength !=ETHERNET_PADDING_LENGTH)
            {
                // this is not our MDL 
                ASSERT (PaddingLength !=ETHERNET_PADDING_LENGTH);
                break;
            }
        } 
        
        //
        // Free the padding buffer at the front of the Packet
        //
        
        NdisUnchainBufferAtFront(pPacket,&pPaddingBuffer );

        NdisFreeBuffer (pPaddingBuffer );
        
        
    } while (FALSE);


}



VOID
epvcCancelDeviceInstance(
    IN PEPVC_I_MINIPORT pMiniport ,
    IN PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    This function cancels an outstanding Device Instance. 
    If the NDIS call fails. it waits for an event in the miniprot to fire. 
    After that it goes ahead and DeInitializes the Device Instance
    
Arguments:
    pMiniport - Miniport in question.

Return Value:
    Success
--*/
{
    ENTER("epvcCancelDeviceInstance", 0x0e42d778)
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;        
    UINT iteration =0;
    BOOLEAN bWaitSuccess = FALSE;
    BOOLEAN fNeedToInitEvent = FALSE;

    do
    {
        LOCKOBJ (pMiniport, pSR);

        // Prepare the event, and mark the structure as being Canceled
        epvcResetEvent (&pMiniport->pnp.DeInitEvent);

        // Set the flag to mark it as cancelled           
        MiniportSetFlag (pMiniport, fMP_MiniportCancelInstance);

        UNLOCKOBJ (pMiniport, pSR);

        // Cancel the device instance
        Status = epvcIMCancelInitializeDeviceInstance(pMiniport);
                                                      

        if (Status == NDIS_STATUS_SUCCESS)
        {
            break;
        }   

            
        //
        // If the Cancel has not Succeeded then we should wait for 
        // the Initialize to complete
        //
        {
            BOOLEAN bWaitSuccessful;

            
            bWaitSuccessful = epvcWaitEvent (&pMiniport->pnp.DeInitEvent,WAIT_INFINITE);                                    


            if (bWaitSuccessful == FALSE)
            {
                ASSERT (bWaitSuccessful == TRUE);
            }
            

        }
        //
        // If cancel fails. Wait for the miniport to be initialized
        //
        
        ASSERT (pMiniport->ndis.MiniportAdapterHandle != NULL);

        //
        // If cancel fails. Wait for the miniport to be initialized
        //

        TRACE (TL_N, TM_Mp, ("Call DeInit after Cancel failed %p , ",pMiniport));
        
        epvcIMDeInitializeDeviceInstance (pMiniport);
        
        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    LOCKOBJ(pMiniport, pSR);

    MiniportClearFlag (pMiniport, fMP_MiniportCancelInstance);

    UNLOCKOBJ (pMiniport, pSR);

    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\sys\priv.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    priv.h

Abstract:

    Common header file for ATM Epvc IM miniport.

Author:

    ADube 03/23/2000
    
Environment:


Revision History:

 
--*/


#ifndef _PRIV_H

#define _PRIV_H


//advance declaration
typedef struct _EPVC_I_MINIPORT     _ADAPT, ADAPT, *PADAPT;
typedef struct _EPVC_I_MINIPORT     EPVC_I_MINIPORT,    *PEPVC_I_MINIPORT   ;
typedef struct _EPVC_GLOBALS        EPVC_GLOBALS,   *PEPVC_GLOBALS;
typedef struct _EPVC_ARP_PACKET     EPVC_ARP_PACKET, *PEPVC_ARP_PACKET      ;
typedef struct _EPVC_NDIS_REQUEST   EPVC_NDIS_REQUEST, *PEPVC_NDIS_REQUEST;
        



extern LIST_ENTRY g_ProtocolList;
//
// Temp declarations
//
extern NDIS_HANDLE ProtHandle, DriverHandle;




extern EPVC_GLOBALS EpvcGlobals;



//--------------------------------------------------------------------------------
//                                                                              //
//  Driver Functions - Prototypes                                               //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------

extern
NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT          DriverObject,
    IN  PUNICODE_STRING         RegistryPath
    );

extern
VOID
EpvcUnload(
    IN  PDRIVER_OBJECT              pDriverObject
    ); 

//--------------------------------------------------------------------------------
//                                                                              //
//  Protocol Functions - Prototypes                                             //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------


extern
VOID
EpvcResetComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status
    );


extern
VOID
PtStatus(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    );

extern
VOID
PtStatusComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext
    );


extern
VOID
PtTransferDataComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status,
    IN  UINT                    BytesTransferred
    );

extern
NDIS_STATUS
PtReceive(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookAheadBuffer,
    IN  UINT                    LookaheadBufferSize,
    IN  UINT                    PacketSize
    );

extern
VOID
PtReceiveComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext
    );

extern
INT
PtReceivePacket(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_PACKET            Packet
    );

    
VOID
EpvcUnload(
    IN  PDRIVER_OBJECT          DriverObject
    );




extern
VOID
EpvcAfRegisterNotify(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PCO_ADDRESS_FAMILY      AddressFamily
    );
   
VOID
epvcOidCloseAfWorkItem(
    IN PRM_OBJECT_HEADER pObj,
    IN NDIS_STATUS Status,
    IN PRM_STACK_RECORD pSR
    );

    

//--------------------------------------------------------------------------------
//                                                                              //
//  Miniport Functions - Prototypes                                             //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------



NDIS_STATUS
MPTransferData(
    OUT PNDIS_PACKET            Packet,
    OUT PUINT                   BytesTransferred,
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_HANDLE             MiniportReceiveContext,
    IN  UINT                    ByteOffset,
    IN  UINT                    BytesToTransfer
    );


NDIS_STATUS
MPReset(
    OUT PBOOLEAN                AddressingReset,
    IN  NDIS_HANDLE             MiniportAdapterContext
    );








#define DBGPRINT(Fmt)                                       \
    {                                                       \
        DbgPrint("*** %s (%d) *** ", __FILE__, __LINE__);   \
        DbgPrint (Fmt);                                     \
    }

#define NUM_PKTS_IN_POOL    256




extern  NDIS_PHYSICAL_ADDRESS           HighestAcceptableMax;
extern  NDIS_HANDLE                     ProtHandle, DriverHandle;
extern  NDIS_MEDIUM                     MediumArray[1];

//
// Custom Macros to be used by the passthru driver 
//
/*
bool
IsIMDeviceStateOn(
   PADAPT 
   )

*/
#define IsIMDeviceStateOn(_pP)      ((_pP)->MPDeviceState == NdisDeviceStateD0 && (_pP)->PTDeviceState == NdisDeviceStateD0 ) 

//--------------------------------------------------------------------------------
//                                                                              //
//  New stuff for atmepvc starts here                                           //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------
//                                                                                 //
//   Arp Packet Parsing structs                                                    //
//                                                                                 //
//-----------------------------------------------------------------------------------

//
// Len of an Ethernet Header.
//
#define ARP_802_ADDR_LENGTH 6

//
// HwType should be one of the two below.
//
#define ARP_HW_ENET     1
#define ARP_HW_802      6

//
// Ip Address
//
typedef ULONG        IP_ADDR;

#define ARP_ETYPE_ARP   0x806
#define ARP_REQUEST     1
#define ARP_RESPONSE    2
#define ARP_HW_ENET     1
#define IP_PROT_TYPE   0x800

//
// As these data structs are used to parse data off the wire.
// make sure it is packed at 1
//
#pragma pack( push, enter_include1, 1 )

//
//  The following object is a convenient way to 
//  store and access an IEEE 48-bit MAC address.
//
typedef struct _MAC_ADDRESS
{
    UCHAR   Byte[ARP_802_ADDR_LENGTH];
} MAC_ADDRESS, *PMAC_ADDRESS;


//
// Structure of the Ethernet Arp packet. The 14 byte ethernet header is not here.
//

typedef struct _EPVC_ETH_HEADER{

    MAC_ADDRESS         eh_daddr;
    MAC_ADDRESS         eh_saddr;
    USHORT              eh_type;

} EPVC_ETH_HEADER, *PEPVC_ETH_HEADER;


// Structure of an ARP header.
typedef struct _EPVC_ARP_BODY {
    USHORT      hw;                      // Hardware address space. = 00 01
    USHORT      pro;                     // Protocol address space. = 08 00
    UCHAR       hlen;                    // Hardware address length. = 06
    UCHAR       plen;                    // Protocol address length.  = 04
    USHORT      opcode;                  // Opcode.
    MAC_ADDRESS SenderHwAddr; // Source HW address.
    IP_ADDR     SenderIpAddr;                  // Source protocol address.
    MAC_ADDRESS DestHwAddr; // Destination HW address.
    IP_ADDR     DestIPAddr;                  // Destination protocol address.

} EPVC_ARP_BODY, *PEPVC_ARP_BODY;




//
// Complete Arp Packet
//

typedef struct _EPVC_ARP_PACKET
{
    //
    // The first fourteen bytes
    // 
    EPVC_ETH_HEADER Header;

    //
    // The body of the Arp packets
    //
    EPVC_ARP_BODY   Body;

} EPVC_ARP_PACKET, *PEPVC_ARP_PACKET;



//
// This is the struct that is allocated 
// by the Rcv Code path if The Rcv packet 
// is to be copied into a local buffer
//

typedef struct _EPVC_IP_RCV_BUFFER
{

    //
    // The Old Head in the Packet that was indicated
    // to our Rcv Handler
    // 
    PNDIS_BUFFER pOldHead;
    
    //
    // The Old Tail in the Packet that was indiacated to 
    // our Rcv Hnadler
    //

    PNDIS_BUFFER pOldTail;

    //
    // The actual Ethernet packet is copied into the 
    // memory below
    //
    union 
    {
        UCHAR Byte[MAX_ETHERNET_FRAME    ];

        struct
        {
            EPVC_ETH_HEADER Eth;

            //
            // the ip portion of the packet begins here.
            //
            UCHAR ip[1];



        }Pkt;

    } u;


} EPVC_IP_RCV_BUFFER, *PEPVC_IP_RCV_BUFFER;


//* IP Header format.
typedef struct IPHeader {
    UCHAR       iph_verlen;             // Version and length.
    UCHAR       iph_tos;                // Type of service.
    USHORT      iph_length;             // Total length of datagram.
    USHORT      iph_id;                 // Identification.
    USHORT      iph_offset;             // Flags and fragment offset.
    UCHAR       iph_ttl;                // Time to live.
    UCHAR       iph_protocol;           // Protocol.
    USHORT      iph_xsum;               // Header checksum.
    IPAddr      iph_src;                // Source address.
    IPAddr      iph_dest;               // Destination address.
} IPHeader;



//
// Restore the Pack value to the original
//

#pragma pack( pop, enter_include1 )



//
// The structure all the info required to process 
// an arp.
//

typedef struct _EPVC_ARP_CONTEXT
{

    //
    // Data about the Ndis Packet
    //
    BOOLEAN                 fIsThisAnArp ;
    BOOLEAN                 Pad[3];
    PNDIS_BUFFER            pFirstBuffer ;


    //
    // Data about the Current Ndis Buffer
    //
    UINT BufferLength ;


    //
    // Virtual Addresses'. Pointers to 
    // the Header and the Body of the 
    // Arp Pkt
    //
    PEPVC_ARP_PACKET pArpPkt;
    PEPVC_ETH_HEADER pEthHeader ;
    PEPVC_ARP_BODY   pBody;

}EPVC_ARP_CONTEXT, *PEPVC_ARP_CONTEXT;


//
// This is stored in the Packet Stack and should be of the 
// size of 2 Ulong_Ptrs
//
typedef union _EPVC_STACK_CONTEXT
{

    
    
    struct
    {
        //
        // 1st containing the Buffer 
        //
        PNDIS_BUFFER            pOldHeadNdisBuffer;

    } ipv4Send;

    struct
    {
        PEPVC_IP_RCV_BUFFER     pIpBuffer;
    
    } ipv4Recv;

    struct
    {
        //
        // Head and tail of the original packet . Used in recv
        //
        PNDIS_BUFFER pOldHead;
        PNDIS_BUFFER pOldTail;

    }EthLLC;

    struct
    {
        //
        // Keep track of the last NDIS buffer in original
        // chain of buffers in a sent packet, when we pad
        // the end of a runt packet.
        //
        PNDIS_BUFFER            pOldLastNdisBuffer;

    }EthernetSend;

} EPVC_STACK_CONTEXT, *PEPVC_STACK_CONTEXT;


//
// Protocol reserved part of the packet, only in case the 
// packet is allocated by us
//

typedef struct _EPVC_PKT_CONTEXT
{
    //
    // Contains the miniport and the old ndis buffer
    //
    EPVC_STACK_CONTEXT Stack;

    //
    // Original packet which is being repackaged
    //
    PNDIS_PACKET pOriginalPacket;

}EPVC_PKT_CONTEXT, *PEPVC_PKT_CONTEXT;



//
// This a struct that tracks a send packets
// as it is sent down to physical miniport
//

typedef struct _EPVC_SEND_STRUCT 
{

    //
    // Old Ndis PAcket
    //
    PNDIS_PACKET pOldPacket;

    //
    // New Ndis Packet
    //
    PNDIS_PACKET pNewPacket;

    PNDIS_PACKET_STACK pPktStack;

    //
    // Are we using the Packet Stack
    //
    BOOLEAN fUsingStacks;

    //
    // is this an arp packet
    //
    BOOLEAN fIsThisAnArp;

    BOOLEAN fNonUnicastPacket; 

    BOOLEAN fNotIPv4Pkt;
    
    //
    // Old Packet's first NdisBuffer (Head)
    //
    PNDIS_BUFFER pHeadOldNdisBuffer;


    //
    // Context to be set up in the packet
    //
    EPVC_PKT_CONTEXT Context;

    //
    // EpvcMiniport
    //
    PEPVC_I_MINIPORT        pMiniport;

} EPVC_SEND_STRUCT , *PEPVC_SEND_STRUCT ;


typedef struct _EPVC_SEND_COMPLETE
{
    PNDIS_PACKET_STACK      pStack;

    PNDIS_PACKET            pOrigPkt;

    PNDIS_PACKET            pPacket;

    PEPVC_PKT_CONTEXT       pPktContext;

    BOOLEAN                 fUsedPktStack ;

    PEPVC_STACK_CONTEXT     pContext;

} EPVC_SEND_COMPLETE, *PEPVC_SEND_COMPLETE;


typedef struct _EPVC_RCV_STRUCT
{

    //
    // pPacket that was indicated to us
    //
    PNDIS_PACKET            pPacket;

    //
    // Packet that was allocated by us
    //
    PNDIS_PACKET            pNewPacket;

    //
    // Packet STack, if stacks were used
    //
    PNDIS_PACKET_STACK      pStack;


    //
    // This points to the  context for the 
    // Rcv Indication 
    //
    PEPVC_PKT_CONTEXT       pPktContext;
    
    //
    // Tells me if stacks were used
    //
    BOOLEAN                 fUsedPktStacks;

    //
    // Tels me if a stack still  remains 
    //
    BOOLEAN                 fRemaining;

    //
    // Was an LLC header a part of the indicated packet
    //
    BOOLEAN                 fLLCHeader;

    //
    // Old Packet Status
    //
    NDIS_STATUS             OldPacketStatus;

    //
    // pNew Buffer that is allocated
    // 
    PNDIS_BUFFER            pNewBuffer;


    //
    // Start of valid data within the old packet
    //
    PUCHAR                  pStartOfValidData   ;

    //
    // Number of bytes that were copied
    //
    ULONG                   BytesCopied;

    //
    // Contains some ndis buffers and the memory
    // where packets will be copied into
    //
    PEPVC_IP_RCV_BUFFER     pIpBuffer;

    //
    // Local Memory where the rcvd packet 
    // is copied into . - a part of ip buffer
    //
    PUCHAR                  pLocalMemory;

    
} EPVC_RCV_STRUCT, *PEPVC_RCV_STRUCT;


//--------------------------------------------------------------------------------
//                                                                              //
//  Structures used by the Protocol and miniport                                //
//  These need to declared before the Miniprot and the Protocol Blocks          //
//                                                                              //
//--------------------------------------------------------------------------------

typedef VOID (*REQUEST_COMPLETION)(PEPVC_NDIS_REQUEST, NDIS_STATUS);


// This structure is used when calling NdisRequest.
//
typedef struct _EPVC_NDIS_REQUEST
{
    NDIS_REQUEST        Request;            // The NDIS request structure.
    NDIS_EVENT          Event;              // Event to signal when done.
    NDIS_STATUS         Status;             // Status of completed request.
    REQUEST_COMPLETION  pFunc;          // Completion function
    BOOLEAN             fPendedRequest ; // Set to true if a pended request caused this request
    BOOLEAN             fSet;           // Was the orig. request a query
    USHORT              Pad;
    PEPVC_I_MINIPORT    pMiniport; 
    
} EPVC_NDIS_REQUEST, *PEPVC_NDIS_REQUEST;



//------------------------------------------------------------------------------//
//  Structures used to wrap Ndis Wrapper structures                             //
//                                                                              //
//------------------------------------------------------------------------------//


//
// The Ndis miniport's wrapper around the Packet Pool
//
typedef struct _EPVC_PACKET_POOL
{
    ULONG AllocatedPackets;

    NDIS_HANDLE Handle;


} EPVC_PACKET_POOL, *PEPVC_PACKET_POOL;



//
// The structure that defines the lookaside list used by this miniport
//
typedef struct _EPVC_NPAGED_LOOKASIDE_LIST 
{
    //
    // The lookaside list structure
    //
    NPAGED_LOOKASIDE_LIST   List;   

    //
    // The size of an individual buffer
    //

    
    ULONG Size;

    //
    // Outstanding Fragments - Interlocked access only
    //
    ULONG OutstandingPackets;

    //
    // Verifies if this lookaside list has been allocated
    //

    BOOLEAN bIsAllocated;

    UCHAR Pad[3];
    
} EPVC_NPAGED_LOOKASIDE_LIST , *PEPVC_NPAGED_LOOKASIDE_LIST ;

typedef 
VOID    
(*PEVPC_WORK_ITEM_FUNC)(
    PRM_OBJECT_HEADER, 
    NDIS_STATUS,
    PRM_STACK_RECORD 
    );


typedef union _EPVC_WORK_ITEM_CONTEXT
{
    struct
    {
        //
        // Oid for the request
        //
        NDIS_OID Oid;

        //
        // Currently the only data is 1 Dword long
        //
        ULONG Data;

    }Request;

}EPVC_WORK_ITEM_CONTEXT, *PEPVC_WORK_ITEM_CONTEXT;


typedef struct _EPVC_WORK_ITEM 
{
    //
    // Normal NdisWork Item - Do not move from 
    // the top of this structure
    //
    NDIS_WORK_ITEM WorkItem;

    //
    // Miniport or Adapter to whom this adapter belongs
    //
    PRM_OBJECT_HEADER pParentObj;

    PEVPC_WORK_ITEM_FUNC pFn;
    //
    // Status of async task that was completed
    //
    NDIS_STATUS ReturnStatus;


} EPVC_WORK_ITEM, *PEPVC_WORK_ITEM;


//--------------------------------------------------------------------------------
//                                                                              //
//  Tasks used in the Atmepvc driver                                            //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------

typedef enum _TASK_CAUSE
{
    TaskCause_Invalid=0,

    TaskCause_NdisRequest,

    TaskCause_MediaConnect,

    TaskCause_MediaDisconnect,

    TaskCause_MiniportHalt,

    TaskCause_AfNotify,

    TaskCause_ProtocolUnbind,

    TaskCause_AfCloseRequest,

    TaskCause_ProtocolBind,

    TaskCause_IncomingClose

} TASK_CAUSE, *PTASK_CAUSE;

typedef struct
{
    RM_TASK                     TskHdr;

    // Used to save the true return status (typically a failure status,
    // which we don't want to forget during async cleanup).
    //
    NDIS_STATUS ReturnStatus;

} TASK_ADAPTERINIT, *PTASK_ADAPTERINIT;

typedef struct
{
    RM_TASK             TskHdr;

} TASK_ADAPTERACTIVATE, *PTASK_ADAPTERACTIVATE;

typedef struct
{
    RM_TASK             TskHdr;
    NDIS_HANDLE         pUnbindContext;
    TASK_CAUSE          Cause;

} TASK_ADAPTERSHUTDOWN, *PTASK_ADAPTERSHUTDOWN;

typedef struct
{
    RM_TASK                 TskHdr;
    NDIS_STATUS             ReturnStatus;
    TASK_CAUSE              Cause;
    PCO_ADDRESS_FAMILY      pAf;
    union
    {
        PNDIS_REQUEST           pRequest;
        NDIS_EVENT              CompleteEvent;
    };
    
} TASK_AF, *PTASK_AF;

typedef struct _TASK_VC
{
    RM_TASK             TskHdr;
    NDIS_STATUS         ReturnStatus;
    ULONG               FailureState;
    TASK_CAUSE          Cause;
    ULONG               PacketFilter;

} TASK_VC, *PTASK_VC;


typedef struct _TASK_HALT
{
    RM_TASK             TskHdr;
    NDIS_EVENT          CompleteEvent;  

}TASK_HALT, *PTASK_HALT;



typedef struct _TASK_ARP
{
    //
    // Rm Task associated with the Arp
    //
    RM_TASK                     TskHdr;

        
    //
    // Back pointer to the miniport
    //
    PEPVC_I_MINIPORT            pMiniport;

    //
    // Timer to fire - this does the receive indication
    //
    NDIS_MINIPORT_TIMER         Timer;

    //
    // Arp Packet that will be indicated up. 
    //
    EPVC_ARP_PACKET             Pkt;

    //
    // NdisPacket to wrap the ArpPkt
    //
    PNDIS_PACKET                pNdisPacket; 

} TASK_ARP, *PTASK_ARP;



//
// EPVC_TASK is the union of all tasks structures used in atmepvc.
// arpAllocateTask allocates memory of sizeof(EPVC_TASK), which is 
// guaranteed to be large enough to hold any task.
// 
typedef union
{
    RM_TASK                 TskHdr;
    TASK_ADAPTERINIT        AdapterInit;
    TASK_ADAPTERACTIVATE    AdapterActivate;
    TASK_ADAPTERSHUTDOWN    AdapterShutdown;
    TASK_AF                 OpenAf;
    TASK_HALT               MiniportHalt;
    TASK_ARP                Arp;
    
}  EPVC_TASK, *PEPVC_TASK;




//--------------------------------------------------------------------------------
//                                                                              //
//  Epvc Adapter block.                                                         //
//  There is one epvc_adapter per underlying adapter                            //
//                                                                              //
//--------------------------------------------------------------------------------

//
// PRIMARY_STATE flags (in Hdr.State)
//
//  PRIMARY_STATE is the primary state of the adapter.
//

#define EPVC_AD_PS_MASK                 0x00f
#define EPVC_AD_PS_DEINITED             0x000
#define EPVC_AD_PS_INITED               0x001
#define EPVC_AD_PS_FAILEDINIT           0x002
#define EPVC_AD_PS_INITING              0x003
#define EPVC_AD_PS_REINITING            0x004
#define EPVC_AD_PS_DEINITING            0x005

#define SET_AD_PRIMARY_STATE(_pAD, _IfState) \
            RM_SET_STATE(_pAD, EPVC_AD_PS_MASK, _IfState)

#define CHECK_AD_PRIMARY_STATE(_pAD, _IfState) \
            RM_CHECK_STATE(_pAD, EPVC_AD_PS_MASK, _IfState)

#define GET_AD_PRIMARY_STATE(_pAD) \
            RM_GET_STATE(_pAD, EPVC_AD_PS_MASK)


//
// ACTIVE_STATE flags (in Hdr.State)
//
// ACTIVE_STATE is a secondary state of the adapter.
// Primary state takes precedence over secondary sate. For example,
// the interface is REINITING and ACTIVE, one should not actively use the
// interface.
//
// NOTE: When the primary state is INITED, the secondary state WILL be
// ACTIVATED. It is thus usually only necessary to look at the primary state.
//

#define EPVC_AD_AS_MASK                 0x0f0
#define EPVC_AD_AS_DEACTIVATED          0x000
#define EPVC_AD_AS_ACTIVATED            0x010
#define EPVC_AD_AS_FAILEDACTIVATE       0x020
#define EPVC_AD_AS_DEACTIVATING         0x030
#define EPVC_AD_AS_ACTIVATING           0x040

#define SET_AD_ACTIVE_STATE(_pAD, _IfState) \
            RM_SET_STATE(_pAD, EPVC_AD_AS_MASK, _IfState)

#define CHECK_AD_ACTIVE_STATE(_pAD, _IfState) \
            RM_CHECK_STATE(_pAD, EPVC_AD_AS_MASK, _IfState)

#define GET_AD_ACTIVE_STATE(_pAD) \
            RM_GET_STATE(_pAD, EPVC_AD_AS_MASK)

#define EPVC_AD_INFO_AD_CLOSED          0X10000000


typedef struct _EPVC_ADAPTER
{


    RM_OBJECT_HEADER            Hdr;            // RM Object header
    RM_LOCK                     Lock;           // RM Lock 

    //
    // Flags
    //
    ULONG Flags;
    //
    // List of instantiated protocols
    //
    
    LIST_ENTRY PtListEntry;

    //
    // NDIS bind info.
    //
    struct
    {
        
        // Init/Deinit/Reinit task
        //
        PRM_TASK pPrimaryTask;

        // Activate/Deactivate task
        //
        PRM_TASK pSecondaryTask;
        //
        // Device Name of the adapter
        //
        NDIS_STRING                 DeviceName;


        NDIS_HANDLE                 BindingHandle;  // To the lower miniport

        //
        // Bind Context - used in async completion of 
        // the bind adapter routine
        //
        NDIS_HANDLE                 BindContext;

        //
        // pConfig Name - Only to be used in the context of the Bind adapter call.
        //
        PNDIS_STRING                pEpvcConfigName;

        //
        // Copy of the ConfigName
        //
        NDIS_STRING                EpvcConfigName;
    
        //
        // Device Name - Name of the underlying adapter
        //
        PNDIS_STRING            pAdapterDeviceName;

        
    } bind;


    struct 
    {
        CO_ADDRESS_FAMILY      AddressFamily;
        
    }af;

    struct
    {
        //
        // Mac Address of the underlying adapter
        //
        MAC_ADDRESS             MacAddress;
        //
        // Max AAL5 PAcket Size - used in determining Lookahead
        //
        ULONG                   MaxAAL5PacketSize;

        //
        // Link speed of the ATM adapter. We'll use the same link speed
        // for the miniport
        //
        NDIS_CO_LINK_SPEED      LinkSpeed;

        //
        // Number of miniports instatiated by this adapter
        //
        ULONG                   NumberOfMiniports;

        //
        // MEdia State // default disconnected
        //

        NDIS_MEDIA_STATE        MediaState;

    }info;
    //  Group containing local ip addresses, of type  EPVC_I_MINIPORT
    //
    RM_GROUP MiniportsGroup;

}EPVC_ADAPTER, *PEPVC_ADAPTER;


//------------------------------------------------------------------------------------
//                                                                                  //
// The Epvc ADapter Params is used as a constructor for the adapter block           //  
// It contains all the parameters that are to be initialized in the adapter block   //
//                                                                                  //
//------------------------------------------------------------------------------------


typedef struct _EPVC_ADAPTER_PARAMS
{

    PNDIS_STRING pDeviceName;
    PNDIS_STRING pEpvcConfigName;
    NDIS_HANDLE BindContext;

}EPVC_ADAPTER_PARAMS, *PEPVC_ADAPTER_PARAMS;


//------------------------------------------------------------------------------------
//                                                                                  //
// The Epvc Miniports Params is used as a constructor for the miniport block        //  
// It contains all the parameters that are to be initialized in the miniport block  //
//                                                                                  //
//------------------------------------------------------------------------------------


typedef struct _EPVC_I_MINIPORT_PARAMS
{

    PNDIS_STRING        pDeviceName;
    PEPVC_ADAPTER       pAdapter;
    ULONG               CurLookAhead ;
    ULONG               NumberOfMiniports;
    NDIS_CO_LINK_SPEED  LinkSpeed;
    MAC_ADDRESS         MacAddress;
    NDIS_MEDIA_STATE    MediaState;
        

}EPVC_I_MINIPORT_PARAMS, *PEPVC_I_MINIPORT_PARAMS       ;


//--------------------------------------------------------------------------------
//                                                                              //
//  Epvc Miniport block.                                                        //
//                                                                              //
//  There is one Miniport structure for each address family                     //
//                                                                              //
//--------------------------------------------------------------------------------

#define fMP_AddressFamilyOpened             0x00000001
#define fMP_DevInstanceInitialized          0x00000010
#define fMP_MiniportInitialized             0x00000020
#define fMP_MiniportCancelInstance      0x00000080
#define fMP_MiniportVcSetup             0x00000100
#define fMP_MakeCallSucceeded           0x00000200
#define fMP_WaitingForHalt              0x00000400


//
// Informational flags
//
#define fMP_InfoClosingCall             0x10000000
#define fMP_InfoCallClosed              0x20000000
#define fMP_InfoMakingCall              0x40000000
#define fMP_InfoHalting                 0x80000000
#define fMP_InfoAfClosed                0x01000000

typedef struct _EPVC_I_MINIPORT
{
    RM_OBJECT_HEADER            Hdr;            // RM Object header
    RM_LOCK                     Lock;           // RM Lock 

    PEPVC_ADAPTER pAdapter;
    struct 
    {
        //
        // Flags of the address family
        //
        ULONG AfFlags;

        //
        // Af Handle
        //
        NDIS_HANDLE AfHandle;

        //
        // Open/Close Miniport Task 
        //
        PTASK_AF  pAfTask;

        //
        // Close Address Family Workitem
        // 
        EPVC_WORK_ITEM CloseAfWorkItem;

        //
        // CloseAF RequestTask
        //
        PTASK_AF pCloseAfTask;



    }af;

    struct 
    {   
        //
        // Task used in creating/deleting Vcs and Open/Close Make Calls
        //
        PTASK_VC pTaskVc;           

        //
        // Vc Handle
        //
        NDIS_HANDLE VcHandle;
        
        //
        // Close Address Family Workitem
        // 
        NDIS_WORK_ITEM PacketFilterWorkItem;

        //
        // New filter
        //
        ULONG NewFilter;

        //
        // Work item for CloseCall and Delete VC
        //
        EPVC_WORK_ITEM CallVcWorkItem;
    } vc;

    struct 
    {

        //
        // Device Name 
        //
        NDIS_STRING     DeviceName;

        //
        // Ndis' context
        //
        NDIS_HANDLE MiniportAdapterHandle;

        //
        // Lookahead size
        //
        ULONG CurLookAhead;
    }ndis;

    struct 
    {
        //
        // Task to Halt the miniport
        //
        PTASK_HALT pTaskHalt;

        //
        // Task to Init the miniport
        //
        PTASK_HALT pTaskInit;

        //
        // Halt Complete Event
        //
        NDIS_EVENT HaltCompleteEvent;

        //
        // DeInitialize Event used to wait for
        // InitializeHandler to compelte in 
        // the CancelDevInst code path
        //
        NDIS_EVENT DeInitEvent;


        

    } pnp;

    //
    // Information used to keep state in the miniport
    //
    struct
    {

        //
        // Current Packet filter on this miniport instance
        //
        ULONG               PacketFilter;


        //
        // Media State - Connected or disconnected
        //
        NDIS_MEDIA_STATE    MediaState;

        //
        // Mac Address of the miniport
        //
        MAC_ADDRESS         MacAddressEth;

        //
        // Fake Mac Address used in IP encapsulation
        //
        MAC_ADDRESS         MacAddressDummy;

        //
        // Mac Address destination  - used in indicating packets
        //
        MAC_ADDRESS         MacAddressDest;


        //
        // Size of the header that will be attached to packets that are sent out
        // by the miniport
        //
        ULONG               MaxHeaderLength;

        //
        // # of this miniport
        //
        ULONG               NumberOfMiniports;

        //
        // Lookahead length
        //
        ULONG               CurLookAhead;

        //
        // Muticast Info
        //
        MAC_ADDRESS         McastAddrs[MCAST_LIST_SIZE];    

        //
        // Number of MCast addresses present
        //
        ULONG               McastAddrCount; 

        //
        // Link Speed of the ATM adapter. We'll use it for our speed as well
        //

        ULONG               LinkSpeed;
        

        //
        // Indicating Receives
        //
        BOOLEAN             IndicateRcvComplete;
        
    }info;

    //
    // Mac Address of the miniport
    //
    MAC_ADDRESS         MacAddressEth;

    //
    // Ethernet Header for incoming packets
    //
    EPVC_ETH_HEADER     RcvEnetHeader;

    //
    // LLC Header, address and length 
    //
    PUCHAR              pLllcHeader;

    ULONG               LlcHeaderLength;

    // Minimum length of an incoming packet
    //
    ULONG               MinAcceptablePkt;

    // Maximum length of an incoming packet
    //
    ULONG               MaxAcceptablePkt;

    struct 
    {
        ULONG vpi;

        ULONG vci;

    
        ULONG MaxPacketSize;

        USHORT Gap;
        
    } config;

    ULONG Encap;

    BOOLEAN fAddLLCHeader;

    BOOLEAN fDoIpEncapsulation;



    struct 
    {
        ULONG FramesXmitOk;

        ULONG FramesRecvOk;

        ULONG RecvDropped;


    }count;

    struct
    {
        //
        // Send and Recv Packet Pools
        //
        EPVC_PACKET_POOL            Send;
        
        EPVC_PACKET_POOL            Recv;
    
    } PktPool;


    struct 
    {
        EPVC_NPAGED_LOOKASIDE_LIST LookasideList;

        PTASK_ARP                   pTask;

    } arps;


    struct 
    {
        EPVC_NPAGED_LOOKASIDE_LIST LookasideList;

    } rcv;

    // This maintains miniport-wide information relevant to the send path.
    //
    struct
    {
        // Lock used exclusively for sending.
        // Protects the following:
        //      ??? this->sendinfo.listPktsWaitingForHeaders
        //      ??? this->sendinfo.NumSendPacketsWaiting
        //      pLocalIp->sendinfo
        //      pDest->sendinfo
        //
        //
        RM_LOCK     Lock;

        // List of send packets waiting for header buffers to become available.
        //
        LIST_ENTRY  listPktsWaitingForHeaders;

        // Length of the above list
        //
        UINT        NumSendPacketsWaiting;

    } sendinfo;

#if 0 
    //
    // Temporary stuff
    // 
    NDIS_HANDLE                 SendPacketPoolHandle;
    NDIS_HANDLE                 RecvPacketPoolHandle;
    NDIS_STATUS                 Status;         // Open Status
    NDIS_EVENT                  Event;          // Used by bind/halt for Open/Close Adapter synch.
    NDIS_MEDIUM                 Medium;
    NDIS_REQUEST                Request;        // This is used to wrap a request coming down
                                                // to us. This exploits the fact that requests
                                                // are serialized down to us.
    PULONG                      BytesNeeded;
    PULONG                      BytesReadOrWritten;
    BOOLEAN                     IndicateRcvComplete;
    
    BOOLEAN                     OutstandingRequests;    //True - if a request has been passed to the miniport below the IM protocol 
    BOOLEAN                     QueuedRequest;          //True - if a request is queued with the IM miniport and needs to be either
                                                        // failed or sent to the miniport below the IM Protocol

    BOOLEAN                     StandingBy;             // True - When the miniport or protocol is transitioning from a D0 to Standby (>D0) State
                                                        // False - At all other times, - Flag is cleared after a transition to D0

    NDIS_DEVICE_POWER_STATE     MPDeviceState;          // Miniport's Device State 
    NDIS_DEVICE_POWER_STATE     PTDeviceState;          // Protocol's Device State 

    BOOLEAN                     isSecondary;            // Set if miniport is secondary of a bundle
    NDIS_STRING                 BundleUniString;        // Strores the bundleid
    PADAPT                      pPrimaryAdapt;          // Pointer to the primary
    PADAPT                      pSecondaryAdapt;        // Pointer to Secondary's structure
    KSPIN_LOCK                  SpinLock;               // Spin Lock to protect the global list
    PADAPT                      Next;
#endif

}EPVC_I_MINIPORT, *PEPVC_I_MINIPORT;




//--------------------------------------------------------------------------------
//                                                                              //
//  Epvc Global Block.                                                          //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------


typedef struct _EPVC_GLOBALS
{

    RM_OBJECT_HEADER            Hdr;

    RM_LOCK                     Lock;

    // Driver global state
    //
    struct
    {
        // Handle to Driver Object for ATMEPVC
        //
        PVOID                   pDriverObject;
    
        // Handle to the single device object representing this driver.
        //
        PVOID pDeviceObject;

        //
        // Registry path 
        //
        PUNICODE_STRING         pRegistryPath;

        //
        // Wrapper Handle
        //
        NDIS_HANDLE             WrapperHandle;      

        //
        // Protocol Handle 
        //

        NDIS_HANDLE             ProtocolHandle;

        //
        // Driver Handle
        //
        NDIS_HANDLE             DriverHandle;
    
    } driver;



    struct 
    {
        RM_GROUP Group;
    } adapters;

    struct 
    {
        NDIS_CLIENT_CHARACTERISTICS CC;
        
    }ndis;
    


} EPVC_GLOBALS, *PEPVC_GLOBALS;

//--------------------------------------------------------------------------------
//                                                                              //
//  Enumerated types    .                                                       //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------

//
// This is an enumeration that is used in acquiring locks in a particular order.
// If lock A needs to be acquired before lock B, this enumeration will enforce the 
// order
//
enum
{
    LOCKLEVEL_GLOBAL=1, // Must start > 0.
    LOCKLEVEL_ADAPTER,
    LOCKLEVEL_MINIPORT,
    LOCKLEVEL_SEND

};

// (debug only) Enumeration of types of associations.
//
enum
{
    EPVC_ASSOC_AD_PRIMARY_TASK,
    EPVC_ASSOC_ACTDEACT_AD_TASK,
    EPVC_ASSOC_MINIPORT_OPEN_VC,
    EPVC_ASSOC_MINIPORT_OPEN_AF,
    EPVC_ASSOC_MINIPORT_ADAPTER_HANDLE,
    EPVC_ASSOC_ADAPTER_MEDIA_WORKITEM,
    EPVC_ASSOC_EXTLINK_PKT_TO_SEND,
    EPVC_ASSOC_CLOSE_AF_WORKITEM,
    EPVC_ASSOC_SET_FILTER_WORKITEM,
    EPVC_ASSOC_EXTLINK_INDICATED_PKT,
    EPVC_ASSOC_WORKITEM,
    EPVC_ASSOC_MINIPORT_REQUEST
    
};



enum 
{
    IPV4_ENCAP_TYPE,
    IPV4_LLC_SNAP_ENCAP_TYPE,
    ETHERNET_ENCAP_TYPE,
    ETHERNET_LLC_SNAP_ENCAP_TYPE


};

//--------------------------------------------------------------------------------
//                                                                              //
//  WorkItems                                                                   //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------

typedef struct _EPVC_WORKITEM_MEDIA_EVENT
{
    NDIS_WORK_ITEM WorkItem;

    NDIS_STATUS State;

    PEPVC_ADAPTER pAdapter;


}EPVC_WORKITEM_MEDIA_EVENT, *PEPVC_WORKITEM_MEDIA_EVENT;



typedef union
{
    NDIS_WORK_ITEM WorkItem;
    EPVC_WORKITEM_MEDIA_EVENT Media;
        

} EPVC_WORKITEM, *PEPVC_WORKITEM;


//
// Local declarations for reading the registry
//


typedef struct _MP_REG_ENTRY
{
    NDIS_STRING RegName;                // variable name text
    BOOLEAN     bRequired;              // 1 -> required, 0 -> optional
    UINT        FieldOffset;            // offset to MP_ADAPTER field
    UINT        FieldSize;              // size (in bytes) of the field
    UINT        Default;                // default value to use
    UINT        Min;                    // minimum value allowed
    UINT        Max;                    // maximum value allowed
} MP_REG_ENTRY, *PMP_REG_ENTRY;


#define NIC_NUM_REG_PARAMS (sizeof (NICRegTable) / sizeof(MP_REG_ENTRY))


 #endif // _PRIV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\sys\protocol.h ===
#ifndef _PROTOCOL_H
#define PROTOCOL_H


//----------------------------------------------------------//
// Local structures                                         //
//----------------------------------------------------------//

typedef struct _STATUS_INDICATION_CONTEXT
{
    PVOID               StatusBuffer;
    UINT                StatusBufferSize;
    NDIS_STATUS         GeneralStatus;

} STATUS_INDICATION_CONTEXT, *PSTATUS_INDICATION_CONTEXT;



//----------------------------------------------------------//
//  epvc protocol helper functions                          //
//----------------------------------------------------------//



VOID
epvcAdapterDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    );

PRM_OBJECT_HEADER
epvcAdapterCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    psr
        );

    
ULONG
epvcAdapterHash(
    PVOID           pKey
    );

BOOLEAN
epvcAdapterCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    );

NDIS_STATUS
epvcTaskInitializeAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
epvcTaskActivateAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );


NDIS_STATUS
epvcTaskDeactivateAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS 
epvcReadIntermediateMiniportConfiguration( 
    IN PEPVC_ADAPTER pAdapter, 
    IN NDIS_HANDLE MiniportListConfigName,
    IN PRM_STACK_RECORD pSR
    );
    

NDIS_STATUS
epvcReadAdapterConfiguration(
    PEPVC_ADAPTER       pAdapter,
    PRM_STACK_RECORD pSR
    );

NDIS_STATUS
epvcTaskShutdownAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
epvcTaskStartIMiniport(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

INT
epvcAfInitEnumerate(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,  // Unused
        PRM_STACK_RECORD    pSR
        );


VOID
epvcInstantiateMiniport(
    IN PEPVC_ADAPTER pAdapter, 
    NDIS_HANDLE MIniportConfigHandle,
    PRM_STACK_RECORD pSR
    );

VOID
epvcGetAdapterInfo(
    IN  PEPVC_ADAPTER           pAdapter,
    IN  PRM_STACK_RECORD            pSR,
    IN  PRM_TASK                    pTask               // OPTIONAL
    );
    
INT
epvcProcessStatusIndication (
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        );



VOID
epvcMediaWorkItem(
    PNDIS_WORK_ITEM pWorkItem, 
    PVOID Context
    );


NDIS_STATUS
epvcTaskCloseIMiniport(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

INT
epvcReconfigureMiniport (
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        );

NDIS_STATUS
epvcPtNetEventReconfigure(
    IN  PEPVC_ADAPTER           pAdapter,
    IN  PVOID                   pBuffer,
    IN PRM_STACK_RECORD         pSR
    
    );


INT
epvcMiniportDoUnbind(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        );


INT
epvcMiniportCloseAf(
        IN PEPVC_I_MINIPORT pMiniport,
        PRM_STACK_RECORD    pSR
        );

NDIS_STATUS
epvcProcessOidCloseAf(
    PEPVC_I_MINIPORT pMiniport,
    PRM_STACK_RECORD pSR
    );

VOID
nicCloseAfWotkItem(
    IN PNDIS_WORK_ITEM pWorkItem,   
    IN PVOID Context 
    );
    
//----------------------------------------------------------//
//  epvc protocol entry functions                           //
//----------------------------------------------------------//

VOID
EpvcRequestComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_REQUEST       NdisRequest,
    IN  NDIS_STATUS         Status
    );

VOID
EpvcUnbindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 UnbindContext
    );


VOID
EpvcOpenAdapterComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 Status,
    IN  NDIS_STATUS                 OpenErrorStatus
);



VOID
EpvcCloseAdapterComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 Status
);

VOID
EpvcBindAdapter(
    OUT PNDIS_STATUS            pStatus,
    IN  NDIS_HANDLE             BindContext,
    IN  PNDIS_STRING            pDeviceName,
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   SystemSpecific2
    );



NDIS_STATUS
EpvcPtPNPHandler(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    );


VOID
EpvcPtSendComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNDIS_PACKET            Packet
    );

UINT
EpvcPtCoReceive(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNDIS_PACKET            Packet
    );

VOID
EpvcPtReceiveComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext
    );


VOID
epvcRemoveExtraNdisBuffers (
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PEPVC_SEND_COMPLETE pStruct
    );


VOID
epvcExtractSendCompleteInfo (
    OUT PEPVC_SEND_COMPLETE     pStruct,
    PEPVC_I_MINIPORT        pMiniport,
    PNDIS_PACKET            pPacket 
    );

NDIS_STATUS
epvcGetRecvPkt (
    IN PEPVC_RCV_STRUCT pRcvStruct,
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET Packet
    );


NDIS_STATUS
epvcAddEthHeaderToNewPacket (
    IN PEPVC_RCV_STRUCT pRcvStruct, 
    IN PEPVC_I_MINIPORT pMiniport
    );


NDIS_STATUS
epvcStripLLCHeaderFromNewPacket (
    IN PEPVC_RCV_STRUCT pRcvStruct, 
    IN PEPVC_I_MINIPORT pMiniport
    );

VOID
epvcReturnPacketToOriginalState (
    IN PEPVC_RCV_STRUCT pRcvStruct, 
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET Packet
    );

UINT
EpvcCoReceive(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNDIS_PACKET            Packet
    );


NDIS_STATUS
epvcCopyNdisBufferChain (
    IN PEPVC_RCV_STRUCT pRcvStruct, 
    IN PNDIS_BUFFER pInBuffer,
    IN PUCHAR pCurrOffset 
    );

VOID
epvcValidatePacket (
    IN PNDIS_PACKET pPacket
    );


INT
epvcReconfigureAdapter(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        );

BOOLEAN
epvcIsPacketLengthAcceptable (
    IN PNDIS_PACKET Packet, 
    IN PEPVC_I_MINIPORT pMiniport
    );

VOID
EpvcStatus(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_STATUS         GeneralStatus,
    IN  PVOID               StatusBuffer,
    IN  UINT                StatusBufferSize
    );

NDIS_STATUS
epvcStripHeaderFromNewPacket (
    IN PEPVC_RCV_STRUCT pRcvStruct, 
    IN PEPVC_I_MINIPORT pMiniport
    ); 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\sys\rm.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    rm.c

Abstract:

    Implementation of the "Resource Manager" APIs.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     11-18-98    Created

Notes:

--*/
#include <precomp.h>

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_RM

//=========================================================================
//                  U T I L I T Y     M A C R O S
//=========================================================================

#define RM_ALLOC(_pp, _size, _tag) \
                NdisAllocateMemoryWithTag((_pp), (_size), (_tag))

#define RM_ALLOCSTRUCT(_p, _tag) \
                NdisAllocateMemoryWithTag(&(_p), sizeof(*(_p)), (_tag))

#define RM_FREE(_p)         NdisFreeMemory((_p), 0, 0)

#define RM_ZEROSTRUCT(_p) \
                NdisZeroMemory((_p), sizeof(*(_p)))

#define RM_PRIVATE_UNLINK_NEXT_HASH(_pHashTable, _ppLink) \
            ((*(_ppLink) = (*(_ppLink))->pNext), ((_pHashTable)->NumItems--))

#define SET_RM_STATE(_pHdr, _Mask, _Val)    \
            (((_pHdr)->RmState) = (((_pHdr)->RmState) & ~(_Mask)) | (_Val))

#define CHECK_RM_STATE(_pHdr, _Mask, _Val)  \
            ((((_pHdr)->RmState) & (_Mask)) == (_Val))

#define RMISALLOCATED(_pHdr) \
                CHECK_RM_STATE((_pHdr), RMOBJSTATE_ALLOCMASK, RMOBJSTATE_ALLOCATED)

#define SET_RM_TASK_STATE(_pTask, _pState) \
    SET_RM_STATE(&(_pTask)->Hdr, RMTSKSTATE_MASK, (_pState))

#define CHECK_RM_TASK_STATE(_pTask, _pState) \
    CHECK_RM_STATE(&(_pTask)->Hdr, RMTSKSTATE_MASK, (_pState))

#define GET_RM_TASK_STATE(_pTask) \
        ((_pTask)->Hdr.RmState &  RMTSKSTATE_MASK)

#if RM_EXTRA_CHECKING
    #define RMPRIVATELOCK(_pobj, _psr) \
         rmLock(&(_pobj)->RmPrivateLock, 0, rmPrivateLockVerifier, (_pobj), (_psr))
#else // !RM_EXTRA_CHECKING
    #define RMPRIVATELOCK(_pobj, _psr) \
        rmLock(&(_pobj)->RmPrivateLock, (_psr))
#endif // !RM_EXTRA_CHECKING

#define RMPRIVATEUNLOCK(_pobj, _psr) \
        rmUnlock(&(_pobj)->RmPrivateLock, (_psr))
        

#if 0
    #define RM_TEST_SIG          0x59dcfd36
    #define RM_TEST_DEALLOC_SIG  0x21392147
    #define RM_OBJECT_IS_ALLOCATED(_pobj) \
                    ((_pobj)->Sig == RM_TEST_SIG)
    #define RM_MARK_OBJECT_AS_DEALLOCATED(_pobj) \
                    ((_pobj)->Sig = RM_TEST_DEALLOC_SIG)
#else
    #define RM_OBJECT_IS_ALLOCATED(_pobj)  0x1
    #define RM_MARK_OBJECT_AS_DEALLOCATED(_pobj)  (0)
#endif

//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================

#if RM_EXTRA_CHECKING

// The lowest AssociationID used internal to the RM API implementation.
//
#define RM_PRIVATE_ASSOC_BASE (0x1<<31)

// Association types internal to RM API impmenentation.
//
enum
{
    RM_PRIVATE_ASSOC_LINK =  RM_PRIVATE_ASSOC_BASE,
    RM_PRIVATE_ASSOC_LINK_CHILDOF,
    RM_PRIVATE_ASSOC_LINK_PARENTOF,
    RM_PRIVATE_ASSOC_LINK_TASKPENDINGON,
    RM_PRIVATE_ASSOC_LINK_TASKBLOCKS,
    RM_PRIVATE_ASSOC_INITGROUP,
    RM_PRIVATE_ASSOC_RESUME_TASK_ASYNC,
    RM_PRIVATE_ASSOC_RESUME_TASK_DELAYED
};


const char *szASSOCFORMAT_LINK                  = "    Linked  to 0x%p (%s)\n";
const char *szASSOCFORMAT_LINK_CHILDOF          = "    Child   of 0x%p (%s)\n";
const char *szASSOCFORMAT_LINK_PARENTOF         = "    Parent  of 0x%p (%s)\n";
const char *szASSOCFORMAT_LINK_TASKPENDINGON    = "    Pending on 0x%p (%s)\n";
const char *szASSOCFORMAT_LINK_TASKBLOCKS       = "    Blocks     0x%p (%s)\n";
const char *szASSOCFORMAT_INITGROUP             = "    Owns group 0x%p (%s)\n";
const char *szASSOCFORMAT_RESUME_TASK_ASYNC     = "    Resume async (param=0x%p)\n";
const char *szASSOCFORMAT_RESUME_TASK_DELAYED   = "    Resume delayed (param=0x%p)\n";

//  Linked to 0x098889(LocalIP)
//  Parent of 0x098889(InitIPTask)
//  Child  of 0x098889(Interface)

#endif // RM_EXTRA_CHECKING

// Private RM task to unload all objects in a group.
//
typedef struct
{
    RM_TASK             TskHdr;             // Common task header
    PRM_GROUP           pGroup;         // Group being unloaded
    UINT                uIndex;             // Index of hash-table currently being
                                            // unloaded.
    NDIS_EVENT          BlockEvent;         // Event to optionally signal when done.
    BOOLEAN             fUseEvent;          // TRUE IFF event is to be signaled.
    PFN_RM_TASK_HANDLER             pfnTaskUnloadObjectHandler; // ...
                                             // Object's unload task.
    PFN_RM_TASK_ALLOCATOR   pfnUnloadTaskAllocator;

} TASK_UNLOADGROUP;


//
// RM_PRIVATE_TASK is the union of all tasks structures used intenally in rm.c.
// rmAllocateTask allocates memory of sizeof(RM_PRIVATE_TASK), which is guaranteed
// to be large enough to hold any task internal to rm.c
// 
typedef union
{
    RM_TASK                 TskHdr;
    TASK_UNLOADGROUP        UnloadGroup;

}  RM_PRIVATE_TASK;


#if RM_EXTRA_CHECKING

VOID
rmDbgInitializeDiagnosticInfo(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    );

VOID
rmDbgDeinitializeDiagnosticInfo(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    );

VOID
rmDbgPrintOneAssociation (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    );

VOID
rmDefaultDumpEntry (
    char *szFormatString,
    UINT_PTR Param1,
    UINT_PTR Param2,
    UINT_PTR Param3,
    UINT_PTR Param4
);

UINT
rmSafeAppend(
    char *szBuf,
    const char *szAppend,
    UINT cbBuf
);

#endif // RM_EXTRA_CHECKING


NDIS_STATUS
rmTaskUnloadGroup(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );


NDIS_STATUS
rmAllocatePrivateTask(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription,      OPTIONAL
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
rmWorkItemHandler_ResumeTaskAsync(
    IN  PNDIS_WORK_ITEM             pWorkItem,
    IN  PVOID                       pTaskToResume
    );


VOID
rmTimerHandler_ResumeTaskDelayed(
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );

VOID
rmPrivateTaskDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    );

VOID
rmDerefObject(
    PRM_OBJECT_HEADER       pObject,
    PRM_STACK_RECORD        pSR
    );

VOID
rmLock(
    PRM_LOCK                pLock,
#if RM_EXTRA_CHECKING
    UINT                    uLocID,
    PFNLOCKVERIFIER         pfnVerifier,
    PVOID                   pVerifierContext,
#endif //RM_EXTRA_CHECKING
    PRM_STACK_RECORD        pSR
    );

VOID
rmUnlock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    );

#if RM_EXTRA_CHECKING
ULONG
rmPrivateLockVerifier(
        PRM_LOCK            pLock,
        BOOLEAN             fLock,
        PVOID               pContext,
        PRM_STACK_RECORD    pSR
        );

ULONG
rmVerifyObjectState(
        PRM_LOCK            pLock,
        BOOLEAN             fLock,
        PVOID               pContext,
        PRM_STACK_RECORD    pSR
        );

RM_DBG_LOG_ENTRY *
rmDbgAllocateLogEntry(VOID);

VOID
rmDbgDeallocateLogEntry(
        RM_DBG_LOG_ENTRY *pLogEntry
        );

#endif // RM_EXTRA_CHECKING

VOID
rmEndTask(
    PRM_TASK            pTask,
    NDIS_STATUS         Status,
    PRM_STACK_RECORD    pSR
    );


VOID
rmUpdateHashTableStats(
    PULONG pStats,
    ULONG   LinksTraversed
    );

typedef struct
{
    PFN_RM_GROUP_ENUMERATOR pfnObjEnumerator;
    PVOID pvCallerContext;
    INT   fContinue;

} RM_STRONG_ENUMERATION_CONTEXT, *PRM_STRONG_ENUMERATION_CONTEXT;


typedef struct
{
    PRM_OBJECT_HEADER *ppCurrent;
    PRM_OBJECT_HEADER *ppEnd;

} RM_WEAK_ENUMERATION_CONTEXT, *PRM_WEAK_ENUMERATION_CONTEXT;


VOID
rmEnumObjectInGroupHashTable (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    );

VOID
rmConstructGroupSnapshot (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    );

//=========================================================================
//                  L O C A L       D A T A
//=========================================================================

// Global struture for the RM apis.
//
struct
{
    // Accessed via interlocked operation.
    //
    ULONG           Initialized;

    RM_OS_LOCK          GlobalOsLock;
    LIST_ENTRY      listGlobalLog;
    UINT            NumGlobalLogEntries;

}   RmGlobals;


RM_STATIC_OBJECT_INFO
RmPrivateTasks_StaticInfo = 
{
    0, // TypeUID
    0, // TypeFlags
    "RM Private Task",  // TypeName
    0, // Timeout

    NULL, // pfnCreate
    rmPrivateTaskDelete, // pfnDelete
    NULL,   // LockVerifier

    0,   // length of resource table
    NULL // Resource Table
};


// TODO: make constant
static
RM_STATIC_OBJECT_INFO
RmTask_StaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "Task", // TypeName
    0, // Timeout

    NULL, // Create
    NULL, // Delete
    NULL, // LockVerifier

    0,   // ResourceTable size
    NULL // ResourceTable
};


//=========================================================================
//                  R M         A P I S
//=========================================================================


#define RM_INITIALIZATION_STARTING 1
#define RM_INITIALIZATION_COMPLETE 2

VOID
RmInitializeRm(VOID)
/*++
    Must be called before any RM APIs are called.
    TODO: replace by registration mechanism.
          See notes.txt  03/07/1999  entry "Registering root objects with RM".
--*/
{
    ENTER("RmInitializeRm", 0x29f5d167)

    if (InterlockedCompareExchange(
            &RmGlobals.Initialized, RM_INITIALIZATION_STARTING, 0)==0)
    {
        TR_INFO(("Initializing RM APIs Global Info\n"));
        NdisAllocateSpinLock(&RmGlobals.GlobalOsLock);
        InitializeListHead(&RmGlobals.listGlobalLog);

        InterlockedExchange(&RmGlobals.Initialized, RM_INITIALIZATION_COMPLETE);
    }
    else
    {
        // Spin waiting for it to get to RM_INITIALIZATION_COMPLETE (allocated).
        TR_INFO(("Spinning, waiting for initialization to complete.\n"));
        while (RmGlobals.Initialized != RM_INITIALIZATION_COMPLETE)
        {
            // spin
        }
    }

    EXIT()
}


VOID
RmDeinitializeRm(VOID)
/*++
    Must be called to deinitialze, after last RM api is called and all async
    activity is over.
    TODO: replace by deregistration mechanism.
          See notes.txt  03/07/1999  entry "Registering root objects with RM".
--*/
{
    ENTER("RmDeinitializeRm", 0x9a8407e9)

    ASSERT(RmGlobals.Initialized == RM_INITIALIZATION_COMPLETE);
    TR_INFO(("Deinitializing RM APIs Global Info\n"));

    // Make sure global log list is empty. Acquiring the GLobalOsLock is
    // not necessary here because all activity has stopped by now.
    //
    ASSERT(IsListEmpty(&RmGlobals.listGlobalLog));

    EXIT()
}


VOID
RmInitializeHeader(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  UINT                        Sig,
    IN  PRM_LOCK                    pLock,
    IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,
    IN  const char *                szDescription,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Initialize the RM_OBJECT_HEADER portion of an object.

Arguments:

    pParentObject       - NULL for a root object.
    pObject             - Object to be initialized.
    Sig                 - Signature of the object.
    pLock               - Lock used to serialize access to the object.
    pStaticInfo         - Static informatation about the object.
    szDescription       - A discriptive string (for debugging only) to be associated
                          with this object.
--*/
{
    ENTER("RmInitializeHeader", 0x47dea382)

    NdisZeroMemory(pObject, sizeof(*pObject));

    if (szDescription == NULL)
    {
        szDescription = pStaticInfo->szTypeName;
    }

    TR_VERB(("Initializing header 0x%p (%s)\n", pObject, szDescription));

    pObject->Sig = Sig;
    pObject->pLock = pLock;
    pObject->pStaticInfo = pStaticInfo;
    pObject->szDescription = szDescription;
    SET_RM_STATE(pObject, RMOBJSTATE_ALLOCMASK, RMOBJSTATE_ALLOCATED);

    // The private lock is set to level (UINT)-1, which is the highest
    // possible level.
    //
    RmInitializeLock(&pObject->RmPrivateLock, (UINT)-1);

#if RM_EXTRA_CHECKING
    rmDbgInitializeDiagnosticInfo(pObject, pSR);
#endif //RM_EXTRA_CHECKING

    // Link to parent if non NULL.
    //

    if (pParentObject != NULL)
    {
        pObject->pParentObject = pParentObject;
        pObject->pRootObject =  pParentObject->pRootObject;

    #if RM_EXTRA_CHECKING
        RmLinkObjectsEx(
            pObject,
            pParentObject,
            0x11f25620,
            RM_PRIVATE_ASSOC_LINK_CHILDOF,
            szASSOCFORMAT_LINK_CHILDOF,
            RM_PRIVATE_ASSOC_LINK_PARENTOF,
            szASSOCFORMAT_LINK_PARENTOF,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmLinkObjects(pObject, pParentObject, pSR);
    #endif // !RM_EXTRA_CHECKING


    }
    else
    {
        pObject->pRootObject = pObject;
    }


    // We increment the total-ref count once for the allocation. This
    // reference is removed in the call to RmDeallocateObject.
    // Note that this reference is in addition to the reference implicitly
    // added by the call to RmLinkObjects above.
    //
    NdisInterlockedIncrement(&pObject->TotRefs);

#if RM_TRACK_OBJECT_TREE

    // Initialize our list of children.
    //
    InitializeListHead(&pObject->listChildren);

    if (pParentObject != NULL)
    {
        // Insert ourselves into our parent's list of children.
        //
        RMPRIVATELOCK(pParentObject, pSR);
        InsertHeadList(&pParentObject->listChildren, &pObject->linkSiblings);
        RMPRIVATEUNLOCK(pParentObject, pSR);
    }
#endif //  RM_TRACK_OBJECT_TREE

    EXIT()
    return;
}


VOID
RmDeallocateObject(
    IN  PRM_OBJECT_HEADER           pObject,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Logically deallocate the object pObject. We don't actually unlink it from
    its parent or deallocate if there are non zero references to it.

--*/
{
    UINT Refs;
    ENTER("RmDeallocateObject", 0xa87fdf4a)
    TR_INFO(("0x%p (%s)\n", pObject, pObject->szDescription));

    RMPRIVATELOCK(pObject, pSR);

    RETAILASSERTEX(RMISALLOCATED(pObject), pObject);


    // Set state to deallocated.
    //
    SET_RM_STATE(pObject, RMOBJSTATE_ALLOCMASK, RMOBJSTATE_DEALLOCATED);

    RMPRIVATEUNLOCK(pObject, pSR);

    // Remove the ref explicitly added in RmInitializeAllocateObject.
    // rmDerefObject will remove the link to the parent, if any, if the
    // ref count drop to 1.
    //
    rmDerefObject(pObject, pSR);

    EXIT()
}


VOID
RmInitializeLock(
    IN PRM_LOCK pLock,
    IN UINT     Level
    )
/*++

Routine Description:

    Initialize a lock.

Arguments:

    pLock       - Unitialized memory to hold a struct of type RM_LOCK.
    Level       - Level to be associated with this lock. Locks must be acquired
                  in strictly increasing order of the locks' "Level" values.
--*/
{
    ASSERT(Level > 0);
    NdisAllocateSpinLock(&pLock->OsLock);
    pLock->Level = Level;
    
#if RM_EXTRA_CHECKING
    pLock->pDbgInfo = &pLock->DbgInfo;
    NdisZeroMemory(&pLock->DbgInfo, sizeof(pLock->DbgInfo));
#endif //  RM_EXTRA_CHECKING
}


VOID
RmDoWriteLock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Acquire (write lock) lock pLock.

--*/
{
    rmLock(
        pLock,
    #if RM_EXTRA_CHECKING
        0x16323980, // uLocID,
        NULL,
        NULL,
    #endif //RM_EXTRA_CHECKING
        pSR
        );
}


VOID
RmDoUnlock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Unlock lock pLock.

--*/
{
    rmUnlock(
        pLock,
        pSR
        );
}

#if TODO // Currently RmReadLockObject is a macro defined to be RmWriteLockObject.
         // TODO: Verifier need to to also make sure that object hasn't changed state
         //       *while* the object has been read-locked.
VOID
RmReadLockObject(
    IN  PRM_OBJECT_HEADER           pObj,
#if RM_EXTRA_CHECKING
    UINT                            uLocID,
#endif //RM_EXTRA_CHECKING
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Acquire (read lock)  lock pLock.

--*/
{
    ASSERT(!"Unimplemented");
}
#endif //TODO


VOID
RmWriteLockObject(
    IN  PRM_OBJECT_HEADER           pObj,
#if RM_EXTRA_CHECKING
    UINT                            uLocID,
#endif //RM_EXTRA_CHECKING
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Acquire (write lock) the lock associated with object pObj.

Arguments:

    pObj        --      Object whose lock to acquire.
    uLocID      --      Arbitrary UINT identifying static location from which this
                        call is made.

--*/
{
    ENTER("RmWriteLockObject", 0x590ed543)
    TR_VERB(("Locking 0x%p (%s)\n", pObj, pObj->szDescription));

    rmLock(
        pObj->pLock,
    #if RM_EXTRA_CHECKING
        uLocID,
        // pObj->pStaticInfo->pfnLockVerifier,
        rmVerifyObjectState,
        pObj,
    #endif //RM_EXTRA_CHECKING
        pSR
        );
    EXIT()
}


VOID
RmUnlockObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Release the lock associated with object pObj.

--*/
{
    ENTER("RmUnLockObject", 0x0307dd84)
    TR_VERB(("Unlocking 0x%p (%s)\n", pObj, pObj->szDescription));

#if RM_EXTRA_CHECKING
    //
    // Make sure that pObject is the object that is *supposed* to be freed.
    //
    ASSERT(pSR->LockInfo.pNextFree[-1].pVerifierContext  == (PVOID) pObj);
#endif // RM_EXTRA_CHECKING

    rmUnlock(
        pObj->pLock,
        pSR
        );

    EXIT()
}


VOID
RmUnlockAll(
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Unlocks all currently held locks as recorded in pSR.
    If the locks are associated with objects, RmUnlockObject is called for
    each of the held locks. Otherwise the raw unlock is performed.

--*/
{
    ENTER("RmUnLockObject", 0x9878be96)
    TR_VERB(("Unlocking all\n"));

    while (pSR->LockInfo.CurrentLevel != 0)
    {
        rmUnlock(
            pSR->LockInfo.pNextFree[-1].pLock,
            pSR
            );
    }

    EXIT()
}


VOID
RmDbgChangeLockScope(
    IN  PRM_OBJECT_HEADER           pPreviouslyLockedObject,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG                       LocID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    (Debug only)

    Munge things so that the following sequence works:
    Rm[Read|Write]LockObject(pPreviouslyLockedObject, pSR);
    RmChangeLockScope(pPreviouslyLockedObject, pSR);
    RmUnlockObject(pObject, pSR);

    Of course, we require that the two objects have the same lock!

    NOTE: We only support changing scope of the MOST RECENTLY 
    acquired lock.


Arguments:

    pPreviouslyLockedObject     - Currently locked object.
    pObject                     - Object to transfer lock scope to.
    LocID                       - Arbitrary UINT identifying static location from
                                  which this call is made.
--*/
{
    //
    // This is a NOOP unless extra-checking is enabled.
    // TODO: make this inline in the fre build.
    //
#if RM_EXTRA_CHECKING
    RM_LOCKING_INFO * pLI = pSR->LockInfo.pNextFree-1;
    PRM_LOCK        pLock =  pPreviouslyLockedObject->pLock;
    ASSERT(
            pLock->Level == pSR->LockInfo.CurrentLevel
        &&  pLock == pObject->pLock
        &&  pLock == pLI->pLock
        &&  pLI->pVerifierContext == (PVOID) pPreviouslyLockedObject);

    ASSERT(pLI->pfnVerifier == rmVerifyObjectState);

    rmVerifyObjectState(pLock, FALSE, pLI->pVerifierContext, pSR);
    pLI->pVerifierContext   =  pObject;
    pLock->DbgInfo.uLocID   =  LocID;
    rmVerifyObjectState(pLock, TRUE, pLI->pVerifierContext, pSR);
    
#endif // RM_EXTRA_CHECING

}


VOID
RmLinkObjects(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  PRM_STACK_RECORD            pSr
    )
/*++

Routine Description:

        Link object pObj1 to object pObj2. Basically, this function refs both
        objects.

        OK to call with some locks held, including RmPrivateLock.
        TODO: remove arp pSr above -- we don't need it.
--*/
{
    ENTER("RmLinkObjects", 0xfe2832dd)

    // Maybe we're being too harsh here -- if required, remove this...
    // This could happen where a task is linked at the point where the object
    // is being deallocated, so I'm changing the following  to debug asserts
    // (used to be retail asserts).
    //
    ASSERT(RMISALLOCATED(pObj1));
    ASSERT(RMISALLOCATED(pObj2));

    TR_INFO(("0x%p (%s) linked to 0x%p (%s)\n",
                 pObj1,
                 pObj1->szDescription,
                 pObj2,
                 pObj2->szDescription
                ));

    NdisInterlockedIncrement(&pObj1->TotRefs);
    NdisInterlockedIncrement(&pObj2->TotRefs);

}


VOID
RmLinkObjectsEx(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  ULONG                       LocID,
    IN  ULONG                       AssocID,
    IN  const char *                szAssociationFormat,
    IN  ULONG                       InvAssocID,
    IN  const char *                szInvAssociationFormat,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

        Same as RmLinkObjects, execpt that (debug only) it also sets up  association
          (pObj2, pObj2->szDescription, AssocID)
        on pObj1, and association
            (pObj1, pObj1->szDescription, InvAssocID)
        on object pObj2

Arguments:

    pObj1                   - Object whose lock to acquire.
    pObj2                   - Object whose lock to acquire.
    LocID                   - Arbitrary UINT identifying static location from which
                              this call is made.
    AssocID                 - ID of the association (see RmDbgAddAssociation) that
                              represents the link from pObj1 to pObj2.
    szAssociationFormat     - Format of the association (see RmDbgAddAssociation)
    InvAssocId              - ID of the inverse association (i.e., represents
                              link from pObj2 to pObj1).
    szInvAssociationFormat  - Format of the inverse association.

--*/
{
    ENTER("RmLinkObjectsEx", 0xef50263b)

#if RM_EXTRA_CHECKING

    RmDbgAddAssociation(
        LocID,                              // Location ID
        pObj1,                              // pObject
        (UINT_PTR) pObj2,                   // Instance1
        (UINT_PTR) (pObj2->szDescription),  // Instance2
        AssocID,                            // AssociationID
        szAssociationFormat,
        pSR
        );

    RmDbgAddAssociation(
        LocID,                              // Location ID
        pObj2,                              // pObject
        (UINT_PTR) pObj1,                   // Instance1
        (UINT_PTR) (pObj1->szDescription),  // Instance2
        InvAssocID,                         // AssociationID
        szInvAssociationFormat,
        pSR
        );
    
#endif // RM_EXTRA_CHECKING

    RmLinkObjects(
        pObj1,
        pObj2,
        pSR
        );
}


VOID
RmUnlinkObjects(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:
    
    Unlink objects pObj1 and pObj2 (i.e., undo the effect of
    RmLinkObjects(pObj1, pObj2, pSR)).

--*/
{
    ENTER("RmUnlinkObjects", 0x7c64356a)
    TR_INFO(("0x%p (%s) unlinked from 0x%p (%s)\n",
                 pObj1,
                 pObj1->szDescription,
                 pObj2,
                 pObj2->szDescription
                ));
#if RM_EXTRA_CHECKING
    //
    // TODO: remove explict link
    //
#endif // RM_EXTRA_CHECKING

    // Remove link refs.
    //
    rmDerefObject(pObj1, pSR);
    rmDerefObject(pObj2, pSR);
}


VOID
RmUnlinkObjectsEx(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  ULONG                       LocID,
    IN  ULONG                       AssocID,
    IN  ULONG                       InvAssocID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

        Same as RmUnlinkObjects, execpt that it also removes the  association
          (pObj2, pObj2->szDescription, AssocID)
        on pObj1, and association
            (pObj1, pObj1->szDescription, InvAssocID)
        object pObj2

Arguments:

        See RmLinkObjectsEx.

--*/
{
    ENTER("RmUnlinkObjectsEx", 0x65d3536c)

#if RM_EXTRA_CHECKING

    RmDbgDeleteAssociation(
        LocID,                              // Location ID
        pObj1,                              // pObject
        (UINT_PTR) pObj2,                   // Instance1
        (UINT_PTR) (pObj2->szDescription),  // Instance2
        AssocID,                            // AssociationID
        pSR
        );

    RmDbgDeleteAssociation(
        LocID,                              // Location ID
        pObj2,                              // pObject
        (UINT_PTR) pObj1,                   // Instance1
        (UINT_PTR) (pObj1->szDescription),  // Instance2
        InvAssocID,                         // AssociationID
        pSR
        );
    
#endif // RM_EXTRA_CHECKING

    RmUnlinkObjects(
        pObj1,
        pObj2,
        pSR
        );
}


VOID
RmLinkToExternalEx(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  ULONG                       LocID,
    IN  UINT_PTR                    ExternalEntity,
    IN  ULONG                       AssocID,
    IN  const char *                szAssociationFormat,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Links object pObj to external entity ExternalEntity. Basically, this function
    adds a reference to pObj. In addition (debug only) this function sets up
    an association on pObj that links the external entity to pObj. pObj can be
    linked to ExternalEntity with the specified association ID AssocID only ONCE
    at any particular point of time.

    Once this link is setup, an attempt to deallocate pObj without removing the
    link results in an assertion failure.

    RmUnlinkFromExternalEx is the inverse function.

Arguments:

    pObj                        - Object to be linked to an external entity.

    (following are for debug only...)

    LocID                       - Arbitrary UINT identifying static location from
                                  which this call is made.
    ExternalEntity              - Opaque value representing the external entity.
    AssocID                     - Association ID representing the linkage.
    szAssociationFormat         - Association format for the linkage.

--*/
{
    ENTER("RmLinkToExternalEx", 0x9aeaca74)

#if RM_EXTRA_CHECKING

    RmDbgAddAssociation(
        LocID,                              // Location ID
        pObj,                               // pObject
        (UINT_PTR) ExternalEntity,          // Instance1
        (UINT_PTR) 0,                       // Instance2 (unused)
        AssocID,                            // AssociationID
        szAssociationFormat,
        pSR
        );

#endif // RM_EXTRA_CHECKING

    RmLinkToExternalFast(pObj);

    EXIT()
}


VOID
RmUnlinkFromExternalEx(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  ULONG                       LocID,
    IN  UINT_PTR                    ExternalEntity,
    IN  ULONG                       AssocID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Inverse of RmUnlinkFromExternalEx -- removes the link set up between
    pObj and ExternalEntity.

Arguments:

    See RmLinkToExternalEx.

--*/
{
    ENTER("RmUnlinkFromExternalEx", 0x9fb084c3)

#if RM_EXTRA_CHECKING

    RmDbgDeleteAssociation(
        LocID,                              // Location ID
        pObj,                               // pObject
        (UINT_PTR) ExternalEntity,          // Instance1
        (UINT_PTR) 0,                       // Instance2 (unused)
        AssocID,                            // AssociationID
        pSR
        );

#endif // RM_EXTRA_CHECKING

    RmUnlinkFromExternalFast(pObj);

    EXIT()
}


VOID
RmLinkToExternalFast( // TODO make inline
    IN  PRM_OBJECT_HEADER           pObj
    )
/*++

Routine Description:

    Fast version of RmLinkToExternalEx -- same behavior in retail. No associations
    are setup.

Arguments:

    See RmLinkToExternalEx.

--*/
{
    NdisInterlockedIncrement(&pObj->TotRefs);
}


VOID
RmUnlinkFromExternalFast(   // TODO make inline
    IN  PRM_OBJECT_HEADER           pObj
    )
/*++
Routine Description:

    Inverse of RmUnlinkFromExternalFast -- removes the link set up between
    pObj and ExternalEntity.

    TODO -- we need a fast implementation for the case that the object is
    not going to go away. For now we actually declare a stack record here each
    time, becaues rmDerefObject wants one! Bad bad.

Arguments:

    See RmLinkToExternalFast.

--*/
{
    RM_DECLARE_STACK_RECORD(sr)
    rmDerefObject(pObj, &sr);
}


VOID
RmTmpReferenceObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Add a temporary reference to object pObj.
    (Debug only) Increments the count of tmprefs maintained in pSR.

--*/
{
    ENTER("RmTmpReferenceObject", 0xdd981024)
    TR_VERB(("RmTmpReferenceObject 0x%p (%s) %x\n", pObj, pObj->szDescription, pObj->TotRefs+1));

    ASSERT(RM_OBJECT_IS_ALLOCATED(pObj));

    pSR->TmpRefs++;

    

    NdisInterlockedIncrement(&pObj->TotRefs);
    NdisInterlockedIncrement(&pObj->TempRefs);

}


VOID
RmTmpDereferenceObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Remove a temporary reference to object pObj.
    (Debug only) Decrements the count of tmprefs maintained in pSR.

--*/
{
    ENTER("RmTmpDereferenceObject", 0xd1630c11)
    TR_VERB(("RmTmpDereferenceObject 0x%p (%s) %x\n", pObj, pObj->szDescription, pObj->TotRefs-1));

    RETAILASSERTEX(pSR->TmpRefs>0, pSR);
    pSR->TmpRefs--;
    NdisInterlockedDecrement (&pObj->TempRefs);
    
    rmDerefObject(pObj, pSR);
}


VOID
RmDbgAddAssociation(
    IN  ULONG                       LocID,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG_PTR                   Entity1,
    IN  ULONG_PTR                   Entity2,
    IN  ULONG                       AssociationID,
    IN  const char *                szFormatString, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    )
/*++


Routine Description:

        Add an arbitrary association, for debugging purposes, under
        object pObject. The association is defined by the triple
        (Entity1, Entity2, AssociationID) -- only ONE such tuple may
        be registered at any time with object pParentObject.
        Note: It is valid for both of the following to be registered at the same
        time: (a, b, 1) and (a, b, 2)

        No association should exist at the point the object is deleted.

Arguments:

        LocID           -   Arbitrary ID, typically representing the source location
                        -   from which this function is called.
        pObject         -   Object to add the association.
        Entity1         -   The 1st entity making up the association. May be NULL.
        Entity2         -   The 2nd entity making up the association. May be NULL.
        AssociationID   -   ID defining the association. 
                            NOTE: AssociationID must not have the high-bit set.
                            Associations with the high bit set are reserved for
                            internal use of the Rm API implementation.

--*/
{
#if RM_EXTRA_CHECKING
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;
    ENTER("RmDbgAddAssociation", 0x512192eb)

    if (pDiagInfo)
    {

        //
        // Allocate an association and  enter it into the hash table.
        // Assert if it already exists.
        //

        RM_PRIVATE_DBG_ASSOCIATION *pA;
        RM_ALLOCSTRUCT(pA, MTAG_DBGINFO); // TODO use lookaside lists.
    
        if (pA == NULL)
        {
            //
            // Allocation failed. Record this fact, so that
            // RmDbgDeleteAssociation doesn't assert
            // if an attempt is made to remove an assertion which doesn't exist.
            //
            NdisAcquireSpinLock(&pDiagInfo->OsLock);
            pDiagInfo->AssociationTableAllocationFailure = TRUE;
            NdisReleaseSpinLock(&pDiagInfo->OsLock);
        }
        else
        {
            BOOLEAN fFound;
            PRM_HASH_LINK *ppLink;
            RM_ZEROSTRUCT(pA);

            pA->Entity1 = Entity1;
            pA->Entity2 = Entity2;
            pA->AssociationID = AssociationID;

            if (szFormatString == NULL)
            {
                // Put in the default description format string.
                //
                szFormatString = "    Association (E1=0x%x, E2=0x%x, T=0x%x)\n";
            }

            TR_VERB((" Obj:0x%p (%s)...\n", pObject, pObject->szDescription));
            TRACE0(TL_INFO,((char*)szFormatString, Entity1, Entity2, AssociationID));

            pA->szFormatString = szFormatString;

            NdisAcquireSpinLock(&pDiagInfo->OsLock);
    
            fFound = RmLookupHashTable(
                            &pDiagInfo->AssociationTable,
                            &ppLink,
                            pA      // We use pA as the key.
                            );
    
            if (fFound)
            {
                ASSERTEX(
                    !"Association already exists:",
                    CONTAINING_RECORD(*ppLink, RM_PRIVATE_DBG_ASSOCIATION, HashLink)
                    );
                RM_FREE(pA);
                pA = NULL;
            }
            else
            {
                //
                // Enter the association into the hash table.
                //
    
                RmAddHashItem(
                    &pDiagInfo->AssociationTable,
                    ppLink,
                    &pA->HashLink,
                    pA      // We use pA as the key
                    );
            }
            NdisReleaseSpinLock(&pDiagInfo->OsLock);

            // Now, just for grins, make a note of this in the object's log.
            // TODO/TODO....
            // WARNING: Although pEntity1/2 may contain pointers, 
            // we expect the the format string is such that if there are any
            // references to regular or unicode strings, those strings will
            // be valid for the life of the object (typically these strings
            // are statically-allocated strings).
            //
            // We  COULD use the more conservative format string to display the
            // log entry, but it's useful to have the information displayed
            // properly.
            //
            // Note-- we could also do different things depending on the type
            // of association.
            //
            #if 0 // conservative format
            RmDbgLogToObject(
                    pObject,
            "    Add association (E1=0x%x, E2=0x%x, T=0x%x)\n",
                    Entity1,
                    Entity2,
                    AssociationID,
                    0, // Param4  // (UINT_PTR) szFormatString,
                    NULL,
                    NULL
                    );
            #else // aggresive format
            {
                #define szADDASSOC "    Add assoc:"

#if OBSOLETE        //  This doesn't work because rgMungedFormat is on the stack!
                char rgMungedFormat[128];
                UINT uLength;
                rgMungedFormat[0]=0;
                rmSafeAppend(rgMungedFormat, szADDASSOC, sizeof(rgMungedFormat));
                uLength = rmSafeAppend(
                            rgMungedFormat,
                            szFormatString,
                            sizeof(rgMungedFormat)
                            );
                if (uLength && rgMungedFormat[uLength-1] != '\n')
                {
                    rgMungedFormat[uLength-1] = '\n';
                }
                RmDbgLogToObject(
                        pObject,
                        rgMungedFormat,
                        Entity1,
                        Entity2,
                        AssociationID,
                        0,
                        NULL,
                        NULL
                        );
#endif // OBSOLETE

                RmDbgLogToObject(
                        pObject,
                        szADDASSOC,
                        (char*)szFormatString,
                        Entity1,
                        Entity2,
                        AssociationID,
                        0,
                        NULL,
                        NULL
                        );
            }
            #endif // aggressive format
        }
    }

    EXIT()
#endif // RM_EXTRA_CHECKING
}


VOID
RmDbgDeleteAssociation(
    IN  ULONG                       LocID,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG_PTR                   Entity1,
    IN  ULONG_PTR                   Entity2,
    IN  ULONG                       AssociationID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

        Removes the previously-added association (Entity1, Entity2, Association)
        from object pObject. See the description of RmDbgAddAssociation for
        details.

Arguments:

        See RmDbgAddAssociation.

--*/
{

#if RM_EXTRA_CHECKING
    ENTER("RmDbgDelAssociation", 0x8354559f)
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;

    if (pDiagInfo)
    {
        BOOLEAN fFound;
        PRM_HASH_LINK *ppLink;
        RM_PRIVATE_DBG_ASSOCIATION TrueKey;

        // Only the following 3 fields of TrueKey make up the key
        //
        TrueKey.Entity1 = Entity1;
        TrueKey.Entity2 = Entity2;
        TrueKey.AssociationID = AssociationID;

        NdisAcquireSpinLock(&pDiagInfo->OsLock);

        fFound = RmLookupHashTable(
                        &pDiagInfo->AssociationTable,
                        &ppLink,
                        &TrueKey
                        );

        if (fFound)
        {
            RM_PRIVATE_DBG_ASSOCIATION *pA =
                    CONTAINING_RECORD(*ppLink, RM_PRIVATE_DBG_ASSOCIATION, HashLink);

            TR_VERB((" Obj:0x%p (%s)...\n", pObject, pObject->szDescription));
            /*TRACE0(TL_INFO,
                ((char*)pA->szFormatString,
                 pA->Entity1,
                 pA->Entity2,
                 pA->AssociationID));
            */
            //
            // Now, just for grins, make a note of this in the oject's log.
            // Note that of pEntity1/2 contain pointers, we can't expect them
            // to be valid for as long as the object is alive, so we use
            // the more conservative format string to display the log entry.
            //
            //  TODO/BUGUG -- see comments under RmDbgAddAssociation
            //                  about the risk of directly passing szFormat
            //
            
        #if 0 // conservative
                RmDbgLogToObject(
                        pObject,
                        NULL,
                "    Deleted Association (E1=0x%x, E2=0x%x, T=0x%x)\n",
                        pA->Entity1,
                        pA->Entity2,
                        pA->AssociationID,
                        0,
                        NULL,
                        NULL
                        );
        #else // aggressive
                #define szDELASSOC "    Del assoc:"
                RmDbgLogToObject(
                        pObject,
                        szDELASSOC,
                        (char*) pA->szFormatString,
                        pA->Entity1,
                        pA->Entity2,
                        pA->AssociationID,
                        0, // Param4  // (UINT_PTR) szFormatString,
                        NULL,
                        NULL
                        );
        #endif // aggressive

            //
            // Remove the association and free it.
            //

            RM_PRIVATE_UNLINK_NEXT_HASH( &pDiagInfo->AssociationTable, ppLink );

            RM_FREE(pA);
        }
        else
        {
            if  (!pDiagInfo->AssociationTableAllocationFailure)
            {
                ASSERT(!"Association doesn't exist");
            }
        }
        NdisReleaseSpinLock(&pDiagInfo->OsLock);


    }
    EXIT()
#endif // RM_EXTRA_CHECKING

}


VOID
RmDbgPrintAssociations(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    (Debug only) Dumps the associations on object pObject.

--*/
{
#if RM_EXTRA_CHECKING
    ENTER("RmPrintAssociations", 0x8354559f)
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;

    if (pDiagInfo)
    {
        TR_INFO((
            "Obj 0x%p (%s):\n",
            pObject,
            pObject->szDescription
            ));

        NdisAcquireSpinLock(&pDiagInfo->OsLock);

        RmEnumHashTable(
                    &pDiagInfo->AssociationTable,
                    rmDbgPrintOneAssociation,   // pfnEnumerator
                    pObject,        // context
                    pSR
                    );

        NdisReleaseSpinLock(&pDiagInfo->OsLock);
    }
    EXIT()
#endif // RM_EXTRA_CHECKING
}


//
// Diagnostic per-object logging.
//

VOID
RmDbgLogToObject(
    IN  PRM_OBJECT_HEADER       pObject,
    IN  char *                  szPrefix,       OPTIONAL
    IN  char *                  szFormatString,
    IN  UINT_PTR                Param1,
    IN  UINT_PTR                Param2,
    IN  UINT_PTR                Param3,
    IN  UINT_PTR                Param4,
    IN  PFN_DBG_DUMP_LOG_ENTRY  pfnDumpEntry,   OPTIONAL
    IN  PVOID                   pvBuf           OPTIONAL
    )
/*++

Routine Description:

    Make one log entry in pObject's log.

    TODO: See notes.txt  entry "03/07/1999 ... Registering root objects with RM"
    on how we will find the deallocator function fo pvBuf. For now we simply
    use NdisFreeMemory.

    TODO: need to implement trimming of log when we reach a maximum. Currently we
    just stop logging. 

Arguments:
        pfnDumpEntry    - Function to be used for dumping the log.
                          If NULL, a default function is used, which interprets
                          szFormatString as the standard printf format string.

        szFormatString  - Format string for log display -- 1st arg to pfnDumpEntry

        Param1-4        - Remaining args to pfnDumpEntry;

        pvBuf           - If non-NULL, piece of memory to be freed when the log entry
                          is freed.

        NOTE:   If Param1-4 contain pointers, the memory they refer to is assumed
        to be valid for as long as the object is alive. If the entities being logged
        may go away before the object is deallocated, the caller should
        allocate a buffer to hold a copy of the entities, and pass the pointer to
        that buffer as pvBuf.

--*/
{
#if RM_EXTRA_CHECKING
    ENTER("RmDbgLogToObject", 0x2b2015b5)

    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;

    if (pDiagInfo && RmGlobals.NumGlobalLogEntries < 4000)
    {
        RM_DBG_LOG_ENTRY *pLogEntry;

        NdisAcquireSpinLock(&RmGlobals.GlobalOsLock);

        pLogEntry = rmDbgAllocateLogEntry();

        if (pLogEntry != NULL)
        {
            if (pfnDumpEntry == NULL)
            {
                pfnDumpEntry = rmDefaultDumpEntry;
            }

            pLogEntry->pObject      = pObject;
            pLogEntry->pfnDumpEntry = pfnDumpEntry;
            pLogEntry->szPrefix = szPrefix;
            pLogEntry->szFormatString = szFormatString;
            pLogEntry->Param1 = Param1;
            pLogEntry->Param2 = Param2;
            pLogEntry->Param3 = Param3;
            pLogEntry->Param4 = Param4;
            pLogEntry->pvBuf  = pvBuf;

            // Insert item at head of object log.
            //
            InsertHeadList(&pDiagInfo->listObjectLog, &pLogEntry->linkObjectLog);

            // Insert item at head of global log.
            //
            InsertHeadList(&RmGlobals.listGlobalLog, &pLogEntry->linkGlobalLog);


            pDiagInfo->NumObjectLogEntries++;
            RmGlobals.NumGlobalLogEntries++;
        }

        NdisReleaseSpinLock(&RmGlobals.GlobalOsLock);

    #if 0
        pfnDumpEntry(
                szFormatString,
                Param1,
                Param2,
                Param3,
                Param4
                );
    #endif // 0
    }
    else
    {
        // TODO/TODO -- free pvBuf if NON NULL.
    }
    EXIT()
#endif // RM_EXTRA_CHECKING

}


VOID
RmDbgPrintObjectLog(
    IN PRM_OBJECT_HEADER pObject
    )
/*++

Routine Description:

    (Debug only) Dumps object pObject's log.

--*/
{
#if RM_EXTRA_CHECKING
    ENTER("RmPrintObjectLog", 0xe06507e5)
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;

    TR_INFO((" pObj=0x%p (%s)\n", pObject, pObject->szDescription));


    if (pDiagInfo != NULL)
    {
        LIST_ENTRY          *pLink=NULL;
        LIST_ENTRY *        pObjectLog =  &pDiagInfo->listObjectLog;
        
        NdisAcquireSpinLock(&RmGlobals.GlobalOsLock);
    
        for(
            pLink =  pObjectLog->Flink;
            pLink != pObjectLog;
            pLink = pLink->Flink)
        {
            RM_DBG_LOG_ENTRY    *pLE;
    
            pLE = CONTAINING_RECORD(pLink,  RM_DBG_LOG_ENTRY,  linkObjectLog);

            if (pLE->szPrefix != NULL)
            {
                // Print the prefix.
                DbgPrint(pLE->szPrefix);
            }
    
            // Call the dump function for this entry.
            //
            // 
            pLE->pfnDumpEntry(
                            pLE->szFormatString,
                            pLE->Param1,
                            pLE->Param2,
                            pLE->Param3,
                            pLE->Param4
                            );
    
        }
        NdisReleaseSpinLock(&RmGlobals.GlobalOsLock);
    }
    EXIT()

#endif // RM_EXTRA_CHECKING
}


VOID
RmDbgPrintGlobalLog(VOID)
/*++

Routine Description:

    (Debug only) Dumps the global log (which contains entries from all object's
    logs.

--*/
{
#if RM_EXTRA_CHECKING
    ENTER("RmPrintGlobalLog", 0xe9915066)
    LIST_ENTRY          *pLink=NULL;
    LIST_ENTRY          *pGlobalLog =  &RmGlobals.listGlobalLog;

    TR_INFO(("Enter\n"));

    NdisAcquireSpinLock(&RmGlobals.GlobalOsLock);

    for(
        pLink =  pGlobalLog->Flink;
        pLink != pGlobalLog;
        pLink = pLink->Flink)
    {
        RM_DBG_LOG_ENTRY    *pLE;

        pLE = CONTAINING_RECORD(pLink,  RM_DBG_LOG_ENTRY,  linkGlobalLog);

        // Print the ptr and name of the object whose entry this is...
        //
        DbgPrint(
            "Entry for 0x%p (%s):\n",
            pLE->pObject,
            pLE->pObject->szDescription
            );

        if (pLE->szPrefix != NULL)
        {
            // Print the prefix.
            DbgPrint(pLE->szPrefix);
        }

        // Call the dump function for this entry.
        //
        // 
        pLE->pfnDumpEntry(
                        pLE->szFormatString,
                        pLE->Param1,
                        pLE->Param2,
                        pLE->Param3,
                        pLE->Param4
                        );

    }
    NdisReleaseSpinLock(&RmGlobals.GlobalOsLock);

    EXIT()

#endif // RM_EXTRA_CHECKING
}


RM_STATUS
RmLoadGenericResource(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  UINT                        GenericResourceID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    TODO This function is going away...

--*/
{
    PRM_STATIC_OBJECT_INFO pSI = pObj->pStaticInfo;
    RM_STATUS              Status;

    // The resource ID should be less than number of bits in the ResourceMap
    //
    ASSERT(GenericResourceID < 8*sizeof(pObj->ResourceMap));


    RMPRIVATELOCK(pObj, pSR);

    do
    {
        UINT ResFlag = 1<<GenericResourceID;

        if (!RMISALLOCATED(pObj))
        {
            Status = NDIS_STATUS_FAILURE;
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        if (pSI->NumResourceTableEntries <= GenericResourceID)
        {
            ASSERTEX(!"Invalid GenericResourceID", pObj);
            Status = NDIS_STATUS_FAILURE;
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        // The resource entry indexed must have its ID == GenericResourceID
        //
        //
        if (pSI->pResourceTable[GenericResourceID].ID != GenericResourceID)
        {
            ASSERTEX(!"Resource ID doesn't match table entry", pObj);
            Status = NDIS_STATUS_FAILURE;
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        if ( ResFlag & pObj->ResourceMap)
        {
            ASSERTEX(!"Resource already allocated", pObj);
            Status = NDIS_STATUS_FAILURE;
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        pObj->ResourceMap |= ResFlag;

        RMPRIVATEUNLOCK(pObj, pSR);

        Status = pSI->pResourceTable[GenericResourceID].pfnHandler(
                            pObj,
                            RM_RESOURCE_OP_LOAD,
                            NULL, // pvUserParams (unused)
                            pSR
                            );

        if (FAIL(Status))
        {
            // Clear the resource map bit on failure.
            //
            RMPRIVATELOCK(pObj, pSR);
            ASSERTEX(ResFlag & pObj->ResourceMap, pObj);
            pObj->ResourceMap &= ~ResFlag;
            RMPRIVATEUNLOCK(pObj, pSR);
        }

    } while (FALSE);

    return Status;
}


VOID
RmUnloadGenericResource(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  UINT                        GenericResourceID,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    TODO This function is going away...

--*/
{
    PRM_STATIC_OBJECT_INFO pSI = pObj->pStaticInfo;
    RM_STATUS              Status;

    // The resource ID should be less than number of bits in the ResourceMap
    //
    ASSERT(GenericResourceID < 8*sizeof(pObj->ResourceMap));

    RMPRIVATELOCK(pObj, pSR);

    do
    {
        UINT ResFlag = 1<<GenericResourceID;

        if (pSI->NumResourceTableEntries <= GenericResourceID)
        {
            ASSERTEX(!"Invalid GenericResourceID", pObj);
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        if ( !(ResFlag & pObj->ResourceMap))
        {
            ASSERTEX(!"Resource not allocated", pObj);
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }

        // Clear the resource flag.
        //
        pObj->ResourceMap &= ~ResFlag;

        RMPRIVATEUNLOCK(pObj, pSR);

        pSI->pResourceTable[GenericResourceID].pfnHandler(
                            pObj,
                            RM_RESOURCE_OP_UNLOAD,
                            NULL, // pvUserParams (unused)
                            pSR
                            );

    } while (FALSE);

}


VOID
RmUnloadAllGenericResources(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
    Synchronously unload all previously loaded resources for this object,
    in reverse order to which they were loaded.

    TODO this function is going away...
--*/
{
    PRM_STATIC_OBJECT_INFO pSI = pObj->pStaticInfo;
    RM_STATUS              Status;
    UINT                   u;

    RMPRIVATELOCK(pObj, pSR);

    for(u = pSI->NumResourceTableEntries;
        u && pObj->ResourceMap;
        u--)
    {
        UINT  ResID = u-1;
        UINT ResFlag = 1<<ResID;
        if ( !(ResFlag & pObj->ResourceMap))
        {
            continue;
        }

        if (pSI->NumResourceTableEntries <= ResID)
        {
            ASSERTEX(!"Corrupt ResourceMap", pObj);
            RMPRIVATEUNLOCK(pObj, pSR);
            break;
        }


        // Clear the resource flag.
        //
        pObj->ResourceMap &= ~ResFlag;

        RMPRIVATEUNLOCK(pObj, pSR);

        pSI->pResourceTable[ResID].pfnHandler(
                            pObj,
                            RM_RESOURCE_OP_UNLOAD,
                            NULL, // pvUserParams (unused)
                            pSR
                            );

        RMPRIVATELOCK(pObj, pSR);

    }

    ASSERTEX(!pObj->ResourceMap, pObj);

    RMPRIVATEUNLOCK(pObj, pSR);

}


VOID
RmInitializeGroup(
    IN  PRM_OBJECT_HEADER           pOwningObject,
    IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,
    IN  PRM_GROUP                   pGroup,
    IN  const char*                 szDescription,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Initialize a group structure.

Arguments:

    pOwningObject   - Object that will own the group.
    pStaticInfo     - Static information about objects IN the group.
    pGroup          - Uninitialized memory that is to hold the group structure. It
                      will be initialized on return from this function.
    szDescription   - (Debug only) descriptive name for this group.

    TODO: make pStaticInfo const.

--*/
{
    NdisZeroMemory(pGroup, sizeof(*pGroup));

    RMPRIVATELOCK(pOwningObject, pSR);

    do
    {
        if (!RMISALLOCATED(pOwningObject))
        {
            ASSERT(!"pObject not allocated");
            break;
        }

        if (pStaticInfo->pHashInfo == NULL)
        {
            ASSERT(!"NULL pHashInfo");
            // Static info MUST have non-NULL pHashInfo in order
            // for it to be used for groups.
            //
            break;
        }

    
        RmInitializeHashTable(
            pStaticInfo->pHashInfo,
            pOwningObject,  // pAllocationContext
            &pGroup->HashTable
            );


        pGroup->pOwningObject = pOwningObject;
        pGroup->pStaticInfo = pStaticInfo;
        pGroup->szDescription = szDescription;

        NdisAllocateSpinLock(&pGroup->OsLock);
        pGroup->fEnabled = TRUE;

    #if RM_EXTRA_CHECKING
        RmDbgAddAssociation(
            0xc0e5362f,                         // Location ID
            pOwningObject,                      // pObject
            (UINT_PTR) pGroup,                  // Instance1
            (UINT_PTR) (pGroup->szDescription), // Instance2
            RM_PRIVATE_ASSOC_INITGROUP,         // AssociationID
            szASSOCFORMAT_INITGROUP,            // szAssociationFormat
            pSR
            );
    #endif // RM_EXTRA_CHECKING

    } while (FALSE);

    RMPRIVATEUNLOCK(pOwningObject, pSR);

}


VOID
RmDeinitializeGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Deinitialize group structure pGroup. Must only be called when there are no
    members in the group.

--*/
{

#if RM_EXTRA_CHECKING
    RmDbgDeleteAssociation(
        0x1486def9,                         // Location ID
        pGroup->pOwningObject,              // pObject
        (UINT_PTR) pGroup,                  // Instance1
        (UINT_PTR) (pGroup->szDescription), // Instance2
        RM_PRIVATE_ASSOC_INITGROUP,         // AssociationID
        pSR
        );
#endif // RM_EXTRA_CHECKING

    NdisAcquireSpinLock(&pGroup->OsLock);

    RmDeinitializeHashTable(&pGroup->HashTable);

    NdisReleaseSpinLock(&pGroup->OsLock);
    NdisFreeSpinLock(&pGroup->OsLock);
    NdisZeroMemory(pGroup, sizeof(*pGroup));

}


RM_STATUS
RmLookupObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  ULONG                       Flags, // create, remove, lock
    IN  PVOID                       pvKey,
    IN  PVOID                       pvCreateParams,
    OUT PRM_OBJECT_HEADER *         ppObject,
    OUT INT *                       pfCreated, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    )
/*++
Routine Description:

    TODO: split this into a pure lookup and a lookupand/orcreate function..

    Lookup and/or create an object in the specified group.


#if OBSOLETE // Must allow fCreate w/o locking -- see notes.txt  entry:
               //   03/04/1999   JosephJ  Problems with deadlock when using Groups.
        MUST ONLY be NON-NULL if the fLOCKED flag is specified.
        Why? Because if the lock is not held on exit, it would be possible
        for someone else to pick up the object in the freshly-created state.
        We want to discourage that situation.
#endif // OBSOLETE

         Typically the caller specifes the
        fRM_LOCKED|fRM_CREATE flags as well as non-null pfCreated. On return, if
        *pfCreated is TRUE, the caller then would go on to do some more
        initialization before releasing the lock.

        FUNDAMENTAL ASSUMPTION: The key of an object doesn't change once
        it's in the group. Based on this assumption, we don't try to claim
        the object's lock when looking for the object with a matching key.

Arguments:

    pGroup          - Group in which to lookup/create object.
    Flags           - One or more of fRM_LOCKED, fRM_CREATE, fRM_NEW
    pvKey           - Key used to lookup object.
    pvCreateParams  - If object is to be created, parameters to be passed to the
                      object's creation function.
    ppObject        - Place to store pointer to the found/created object.
    pfCreated       - If non-NULL, *pfCreated is set to TRUE IFF the object was
                      created.

Return Value:

    NDIS_STATUS_SUCCESS     If the operation succeeded.
    NDIS_STATUS_RESOURCES   If a new object could not be created.
    NDIS_STATUS_RFAILURE    If the object was not found.

--*/
{
    RM_STATUS           Status          = NDIS_STATUS_FAILURE;
    BOOLEAN             fUnlockOutOfOrder = FALSE;
    PRM_OBJECT_HEADER   pOwningObject   = pGroup->pOwningObject;
    PRM_OBJECT_HEADER   pObject;

#if DBG
    KIRQL EntryIrql =  KeGetCurrentIrql();
#endif // DBG
    ENTER("RmLookupObjectInGroup",  0xd2cd6379)

    ASSERT(pOwningObject!=NULL);
    // OBSOLETE -- see comments above: ASSERT(pfCreated==NULL || (Flags&RM_LOCKED));

    if (pfCreated != NULL) *pfCreated = FALSE;

    NdisAcquireSpinLock(&pGroup->OsLock);

    do
    {
        BOOLEAN fFound;
        PRM_HASH_LINK *ppLink = NULL;

        if (!RMISALLOCATED(pGroup->pOwningObject)) break;

        if (pGroup->fEnabled != TRUE)   break;

        fFound = RmLookupHashTable(
                        &pGroup->HashTable,
                        &ppLink,
                        pvKey
                        );

        if (fFound)
        {
            if (Flags & RM_NEW)
            {
                // Caller wanted us to created a new object, but the object already
                // exists, so we fail...
                //
                // TODO: return appropriate error code.
                //
                break;
            }

            // Go from hash-link to object.
            //  TODO: once HashLink goes away, need some other way to get
            //       to the object.
            //
            pObject = CONTAINING_RECORD(*ppLink, RM_OBJECT_HEADER, HashLink);
            ASSERT(pObject->pStaticInfo == pGroup->pStaticInfo);

        }
        else
        {
            if (!(Flags & RM_CREATE))
            {
                // Couldn't find it, and caller doesn't want us to create one, so
                // we fail...
                break;
            }
            
            // Create object...
            //
            ASSERTEX(pGroup->pStaticInfo->pfnCreate!=NULL, pGroup);
            pObject = pGroup->pStaticInfo->pfnCreate(
                                                pOwningObject,
                                                pvCreateParams,
                                                pSR
                                                );
            
            if (pObject == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            TR_INFO((
                "Created 0x%p (%s) in Group 0x%p (%s)\n",
                pObject,
                pObject->szDescription,
                pGroup,
                pGroup->szDescription
                ));

            ASSERTEX(RMISALLOCATED(pObject), pObject);

            // Now enter it into the hash table.
            //
            RmAddHashItem(
                &pGroup->HashTable,
                ppLink,
                &pObject->HashLink,
                pvKey
                );
            if (pfCreated != NULL)
            {
                *pfCreated = TRUE;
            }

        }

        if (Flags & RM_LOCKED)
        {
            RmWriteLockObject(
                    pObject,
                #if RM_EXTRA_CHECKING
                    0x6197fdda,
                #endif //RM_EXTRA_CHECKING
                    pSR
                    );

            if  (!RMISALLOCATED(pObject))
            {
                // We don't allow this...
                RmUnlockObject(
                    pObject,
                    pSR
                    );
                break;
            }

            fUnlockOutOfOrder = TRUE;
        }

        RmTmpReferenceObject(pObject, pSR);

        Status = NDIS_STATUS_SUCCESS;

    } while(FALSE);

    if (fUnlockOutOfOrder)
    {
        //
        // WARNING WARNING WARNING -- this code breaks rules --
        // This is so we can unlock out-of order....
        //
    #if !TESTPROGRAM
        pObject->pLock->OsLock.OldIrql = pGroup->OsLock.OldIrql;
    #endif // !TESTPROGRAM
        NdisDprReleaseSpinLock(&pGroup->OsLock);
    }
    else
    {
        NdisReleaseSpinLock(&pGroup->OsLock);
    }

    if (FAIL(Status))
    {
        *ppObject = NULL;
    }
    else
    {
        *ppObject = pObject;
    }

#if DBG
    {
        KIRQL ExitIrql =  KeGetCurrentIrql();
        TR_VERB(("Exiting. EntryIrql=%lu, ExitIrql = %lu\n", EntryIrql, ExitIrql));
    }
#endif //DBG

    return Status;
}


RM_STATUS
RmGetNextObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_OBJECT_HEADER           pCurrentObject, // OPTIONAL
    OUT PRM_OBJECT_HEADER *         ppNextObject,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Get the 1st object in group (if pCurrentObject == NULL), or the object
    "after" pCurrentObject (if pCurrentObject != NULL).
    
    The definition of "after" is hidden -- the only guarantee is if this
    function is 1st called with NULL pCurrentObject and subsequently with
    pCurrentObject set to the value previously returned in ppNextObject, until
    the function returns NDIS_STATUS_FAILURE, all objects in the group will
    be returned once and only once. This guarantee is only valid if no objects
    are added or removed during the enumeration process.

    On success, the "next" object is tmpref'd a pointer to it is saved in
    *ppNextObject.

Arguments:

    pGroup          - The group
    pCurrentObject  - (OPTIONAL) An object in the group.
    ppNextObject    - Place to return the the object  "after" pCurrentObject
                      (see RoutineDescription for details.)
                     

Return Value:

    NDIS_STATUS_SUCCESS if we could find a "next" object.
    NDIS_STATUS_FAILURE otherwise

--*/
{
    RM_STATUS           Status          = NDIS_STATUS_FAILURE;
    PRM_OBJECT_HEADER   pOwningObject   = pGroup->pOwningObject;
    PRM_OBJECT_HEADER   pObject;

    ENTER("RmGetNextObjectInGroup",  0x11523db7)

    ASSERT(pOwningObject!=NULL);

    NdisAcquireSpinLock(&pGroup->OsLock);

    do
    {
        BOOLEAN fFound;
        PRM_HASH_LINK pLink = NULL;
        PRM_HASH_LINK pCurrentLink = NULL;

        if (!RMISALLOCATED(pGroup->pOwningObject)) break;

        if (pGroup->fEnabled != TRUE)   break;

        if (pCurrentObject != NULL)
        {
            pCurrentLink = &pCurrentObject->HashLink;
        }

        fFound =  RmNextHashTableItem(
                        &pGroup->HashTable,
                        pCurrentLink,   // pCurrentLink
                        &pLink  // pNextLink
                        );

        if (fFound)
        {

            // Go from hash-link to object.
            //  TODO: once HashLink goes away, need some other way to get
            //       to the object.
            //
            pObject = CONTAINING_RECORD(pLink, RM_OBJECT_HEADER, HashLink);
            ASSERT(pObject->pStaticInfo == pGroup->pStaticInfo);

        }
        else
        {
            // Couldn't find one.
            // we fail...
            break;
        }

        RmTmpReferenceObject(pObject, pSR);

        Status = NDIS_STATUS_SUCCESS;

    } while(FALSE);

    NdisReleaseSpinLock(&pGroup->OsLock);

    if (FAIL(Status))
    {
        *ppNextObject = NULL;
    }
    else
    {
        *ppNextObject = pObject;
    }

    return Status;
}


VOID
RmFreeObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  struct _RM_TASK             *pTask, OPTIONAL  // Unused. TODO: remove this.
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Remove object pObject from group pGroup and deallocate pObject.

--*/
{
    ENTER("RmFreeObjectInGroup",  0xd2cd6379)
    PRM_OBJECT_HEADER pOwningObject = pGroup->pOwningObject;

    ASSERTEX(pOwningObject!=NULL, pGroup);
    ASSERTEX(pTask==NULL, pGroup);

    NdisAcquireSpinLock(&pGroup->OsLock);

    // TODO: what if at this time, someone else is doing FreeAllObjects in Group?
    //
    TR_INFO((
        "Freeing 0x%p (%s) in Group 0x%p (%s)\n",
        pObject,
        pObject->szDescription,
        pGroup,
        pGroup->szDescription
        ));

    ASSERTEX(RMISALLOCATED(pObject), pObject);

    RmRemoveHashItem(
            &pGroup->HashTable,
            &pObject->HashLink
            );

    NdisReleaseSpinLock(&pGroup->OsLock);

    // Deallocate the object.
    //
    RmDeallocateObject(
                pObject,
                pSR
                );

    EXIT()
}


VOID
RmFreeAllObjectsInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  struct _RM_TASK             *pTask, OPTIONAL // Unused. TODO: remove this.
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Remove and deallocate all object in pGroup.

--*/
{
    PRM_HASH_LINK *ppLink, *ppLinkEnd;
    NdisAcquireSpinLock(&pGroup->OsLock);
    if (pGroup->fEnabled)
    {
        pGroup->fEnabled = FALSE;
    }
    else
    {
        NdisReleaseSpinLock(&pGroup->OsLock);
        return;                                 // EARLY RETURN
    }

    //
    // With fEnabled set to FALSE by us, we expect the following:
    // (a) pHashTable->pTable is going to stay the same size.
    // (b) No items are going to be added or removed by anyone else.
    //

    ppLink      = pGroup->HashTable.pTable;
    ppLinkEnd   = ppLink + pGroup->HashTable.TableLength;

    for ( ; ppLink < ppLinkEnd; ppLink++)
    {
        while (*ppLink != NULL)
        {
            PRM_HASH_LINK pLink =  *ppLink;
            PRM_OBJECT_HEADER pObj;
    
            // Remove it from the bucket list.
            //
            *ppLink = pLink->pNext;
            pLink->pNext = NULL;
            pGroup->HashTable.NumItems--;
    
            NdisReleaseSpinLock(&pGroup->OsLock);
    
            pObj = CONTAINING_RECORD(pLink, RM_OBJECT_HEADER, HashLink);
            ASSERT(pObj->pStaticInfo == pGroup->pStaticInfo);
    
            // Deallocate the object.
            //
            RmDeallocateObject(
                        pObj,
                        pSR
                        );
        
            NdisAcquireSpinLock(&pGroup->OsLock);
        }
    }

    NdisReleaseSpinLock(&pGroup->OsLock);
}


VOID
RmUnloadAllObjectsInGroup(
    IN  PRM_GROUP                   pGroup,
    PFN_RM_TASK_ALLOCATOR           pfnUnloadTaskAllocator,
    PFN_RM_TASK_HANDLER             pfnUnloadTaskHandler,
    PVOID                           pvUserParam,
    IN  struct _RM_TASK             *pTask, OPTIONAL
    IN  UINT                        uTaskPendCode,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Stops new objects from being added and unloads(see below) all objects
    currently in the group.

    "Unload" consists of allocating and starting a pfnUnloadTaskHask task
    on each object. The unload task is responsible for
    removing and deallocating the object from the group.

    If pTask if non-NULL, it will be resumed on completion of the unload.
    Otherwise, this function will BLOCK until the unload is complete.

Arguments:

    pGroup                  - Group to unload.
    pfnUnloadTaskAllocator  - Use to allocate the object-unload tasks.
    pfnTaskAllocator        - Function used to allocate the unload task.
    pfnUnloadTaskHandler    - The handler of the unload task
    pvUserParam             - Task creation user-param. 
                            WARNING: this param must be valid for the duration
                            of the unload process, not just until this
                            function returns. Of course, if pTask is NULL,
                            the two cases are equivalent.
    pTask                   - (OPTIONAL) Task to resume when unload is complete.
                            If NULL, this function will block until the
                            unload is complete.
    uTaskPendCode           - (OPTIONAL) PendCode to use when resuming pTask.
        
--*/
{
    PRM_TASK    pUnloadTask;
    NDIS_STATUS Status;

    NdisAcquireSpinLock(&pGroup->OsLock);

    //
    // We don't check if there is already an unload task active for this group.
    // Instead we go ahead and allocate and start an unload task. This latter
    // task will pend on the already running unload task if there is on.
    //

    // Allocate a private task to coordinate the unloading of all the objects.
    //
    Status =    rmAllocatePrivateTask(
                            pGroup->pOwningObject,
                            rmTaskUnloadGroup,
                            0,
                            "Task:UnloadAllObjectsInGroup",
                            &pUnloadTask,
                            pSR
                            );

    if (FAIL(Status))
    {
        //
        // Ouch -- ugly failure...
        //
        ASSERT(FALSE);

        NdisReleaseSpinLock(&pGroup->OsLock);

    }
    else
    {
        TASK_UNLOADGROUP *pUGTask =  (TASK_UNLOADGROUP *) pUnloadTask;

        pUGTask->pGroup                     = pGroup;
        pUGTask->pfnTaskUnloadObjectHandler =    pfnUnloadTaskHandler;
        pUGTask->pfnUnloadTaskAllocator     =   pfnUnloadTaskAllocator;

        if (pTask == NULL)
        {

            // Set up an event which we'll wait on. The event will be signaled
            // by pUnloadTask when it completes.
            //
            NdisInitializeEvent(&pUGTask->BlockEvent);
            pUGTask->fUseEvent = TRUE;

            // Tmpref it so pUnloadTask will stay around even afer it's
            // completed -- because we wait on the event that's actually
            // located in the task memory.
            //
            RmTmpReferenceObject(&pUnloadTask->Hdr, pSR);
        }

        NdisReleaseSpinLock(&pGroup->OsLock);

        if (pTask != NULL)
        {
            RmPendTaskOnOtherTask(
                    pTask,
                    uTaskPendCode,
                    pUnloadTask,
                    pSR
                    );
        }

        Status = RmStartTask(pUnloadTask, 0, pSR);

        if (pTask == NULL)
        {
            NdisWaitEvent(&pUGTask->BlockEvent, 0);
            RmTmpDereferenceObject(&pUnloadTask->Hdr, pSR);
        }
    }
}

VOID
RmEnableGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

    TODO: need better name for this.

Routine Description:

    Enables items to be added to a group.
    This function is typically called with a group which has completed
    RmUnloadAllObjectsFromGroup or RmFreeAllObjectsInGroup.
    On return from this call items may once more be added to this group.

    This call must only be called after UnloadAllObjectsInGroup or
    RmFreeAllObjectsInGroup have completed (synchronously or asynchronously).

    If there are items in in group or there is an unload
    task associated with the group at the time this function is called,
    the group is NOT reinited and the DBG version will assert.

    This function and may be called with an already enabled group, provided
    the condition above is met (no items in group, no unload task).

--*/
{
    NdisAcquireSpinLock(&pGroup->OsLock);
    if (    pGroup->pUnloadTask == NULL 
        &&  pGroup->HashTable.NumItems == 0)
    {
        pGroup->fEnabled = TRUE;
    }
    else
    {
        ASSERT("invalid state.");
    }
    NdisReleaseSpinLock(&pGroup->OsLock);
}


VOID
RmInitializeTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,    OPTIONAL
    IN  const char *                szDescription,  OPTIONAL
    IN  UINT                        Timeout,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Initialize the specified task.

    The task is tempref'd. It is the responsibility of the caller to
    de-ref it when done. Typically this is implicitly done by calling
    RmStartTask.

Arguments:

    pTask           -   points to unitialized memory to hold the task.
    pParentObject   -   will be the parent of the task.
    pfnHandler      -   task's handler function.
    pStaticInfo     -   (OPTIONAL) Static information about the task.
    szDescription   -   (debug only, OPTIONAL) description of the task
    Timeout         -   unused
        
--*/
{
    ASSERT(!Timeout); // TODO: Timeouts unimplemented.

    NdisZeroMemory(pTask, sizeof(*pTask));

    RmInitializeHeader(
            pParentObject,
            &pTask->Hdr,
            MTAG_TASK,
            pParentObject->pLock,
            (pStaticInfo) ? pStaticInfo : &RmTask_StaticInfo,
            szDescription,
            pSR
            );
    pTask->pfnHandler = pfnHandler;
    SET_RM_TASK_STATE(pTask, RMTSKSTATE_IDLE);
    InitializeListHead(&pTask->listTasksPendingOnMe);

    RmTmpReferenceObject(&pTask->Hdr, pSR);

}


VOID
RmAbortTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_STACK_RECORD            pSR
    )
{
    ASSERT(!"Unimplemented");
}



RM_STATUS
RmStartTask(
    IN  PRM_TASK                    pTask,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Start the specified task.

    NO locks should be held on entry and none are held on exit.
    pTask is expected to have a tmp-ref which is deref'd here.
    The task is automatically deallocated on completion (either  synchronous
    or asynchronous completion, either successful or failed completion).
    Unless the caller is explicitly added a reference to pTask before calling
    this function, the caller should not assume that pTask is still valid
    on return from this function.

Arguments:

    pTask           -   points to the task to be started.
    UserParam       -   opaque value passed to the task handler with the
                        RM_TASKOP_START message.
        
--*/
{
    ENTER("RmStartTask", 0xf80502d5)
    NDIS_STATUS Status;
    RM_ASSERT_NOLOCKS(pSR);

    RMPRIVATELOCK(&pTask->Hdr, pSR);
    if (!CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_IDLE))
    {
        ASSERTEX(!"Invalid state", pTask);
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
        Status = NDIS_STATUS_FAILURE;
    }
    else
    {
        if (!RMISALLOCATED(pTask->Hdr.pParentObject))
        {
            //
            // TODO: consider not calling the handler if the parent object is
            // deallocated, but that may be confusing.
            // Consider not allowing children to be linked to an object
            // (RmInitializeHeader returns failure) if the parent object is
            // deallocated.
            //
            TR_WARN((
                "Starting task 0x%p (%s) with DEALLOCATED parent 0x%p (%s).\n",
                pTask,
                pTask->Hdr.szDescription,
                pTask->Hdr.pParentObject,
                pTask->Hdr.pParentObject->szDescription
                ));
        }

        SET_RM_TASK_STATE(pTask, RMTSKSTATE_STARTING);
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);

        TR_INFO((
            "STARTING Task 0x%p (%s); UserParam = 0x%lx\n",
            pTask,
            pTask->Hdr.szDescription,
            UserParam
            ));

        Status = pTask->pfnHandler(
                            pTask,
                            RM_TASKOP_START,
                            UserParam,
                            pSR
                            );

        RM_ASSERT_NOLOCKS(pSR);

        RMPRIVATELOCK(&pTask->Hdr, pSR);
        switch(GET_RM_TASK_STATE(pTask))
        {
        case RMTSKSTATE_STARTING:

            // This task is completing synchronously.
            //
            ASSERT(Status != NDIS_STATUS_PENDING);
            SET_RM_TASK_STATE(pTask, RMTSKSTATE_ENDING);
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            rmEndTask(pTask, Status, pSR);
            RmDeallocateObject(&pTask->Hdr, pSR);
            break;

        case RMTSKSTATE_PENDING:
            ASSERTEX(Status == NDIS_STATUS_PENDING, pTask);
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            break;

        case RMTSKSTATE_ENDING:
            // This task is completing synchronously and the RM_TASKOP_END
            // notification has already been sent.
            //
            // ??? ASSERT(Status != NDIS_STATUS_PENDING);
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            // ??? RmDeallocateObject(&pTask->Hdr, pSR);
            break;

        default:
            ASSERTEX(FALSE, pTask);
            // Fall through ...

        case RMTSKSTATE_ACTIVE:
            // This can happen if the task is in the process of being resumed
            // in the context of some other thread. Nothing to do here...
            // (This actually happens sometimes on a MP machine).
            //
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            break;
        }
        
    }

    // Remove the tmp ref added when the task was allocated.
    //
    RmTmpDereferenceObject(
                &pTask->Hdr,
                pSR
                );

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()

    return Status;
}


VOID
RmDbgDumpTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_STACK_RECORD            pSR
)
{
}


RM_STATUS
RmSuspendTask(
    IN  PRM_TASK                    pTask,
    IN  UINT                        SuspendContext,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Suspends the specified task.

    RmSuspendTask is always called in the context of a task handler.
    pTask is may be locked on entry -- we don't care.

Arguments:

    pTask           -   task to be suspended.
    SuspendContext  -   context to be presented to the task's handler when
                        the task is subsequently resumed. Specifically, this 
                        context may be accessed using the RM_PEND_CODE macro,
                        when the task's handler is called with code
                        RM_TASKOP_PENDCOMPLETE.
        
--*/
{
    ENTER("RmSuspendTask", 0xd80fdc00)
    NDIS_STATUS Status;
    // RM_ASSERT_NOLOCKS(pSR);

    RMPRIVATELOCK(&pTask->Hdr, pSR);

    TR_INFO((
        "SUSPENDING Task 0x%p (%s); SuspendContext = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        SuspendContext
        ));

    if (    !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_STARTING)
        &&  !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_ACTIVE))
    {
        ASSERTEX(!"Invalid state", pTask);
        Status = NDIS_STATUS_FAILURE;
    }
    else
    {
        SET_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING);
        pTask->SuspendContext = SuspendContext;
        Status = NDIS_STATUS_SUCCESS;
    }

    RMPRIVATEUNLOCK(&pTask->Hdr, pSR);

    // RM_ASSERT_NOLOCKS(pSR);

    EXIT()

    return Status;
}


VOID
RmUnsuspendTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Undoes the effect of a previous call to RmSuspendTask.

    Task MUST be in the pending state and MUST NOT be pending on another task.
    Debug version will ASSERT if above conditions are not met.

    RmUnsuspendTask is always called in the context of a task handler.
    pTask is may be locked on entry -- we don't care.

Arguments:

    pTask           -   task to be suspended.
        
--*/
{
    ENTER("RmUnsuspendTask", 0xcf713639)

    RMPRIVATELOCK(&pTask->Hdr, pSR);

    TR_INFO((
        "UN-SUSPENDING Task 0x%p (%s). SuspendContext = 0x%x\n",
        pTask,
        pTask->Hdr.szDescription,
        pTask->SuspendContext
        ));

    ASSERT(CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING));
    ASSERT(pTask->pTaskIAmPendingOn == NULL);
    SET_RM_TASK_STATE(pTask, RMTSKSTATE_ACTIVE);
    pTask->SuspendContext = 0;

    RMPRIVATEUNLOCK(&pTask->Hdr, pSR);

    EXIT()
}


VOID
RmResumeTask(
    IN  PRM_TASK                    pTask,
    IN  UINT_PTR                    SuspendCompletionParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Resume a previously-suspended task.

    No locks held on entry or exit.
    
    SuspendCompletionParam is user-defined, and must be agreed upon between
    the caller of RmUnpendTask and the task that's being unpended.
    The Task's handler is ALWAYS called in the context of the caller of RmUnpendTask.
    So it is ok for the caller to declare a structure on the stack and pass
    a pointer to it as SuspendCompletionParam.

    WARNING: pTask could well be invalid (deallocate) by the time we return
    from this function. The caller is responsible for tmprefing pTask if it needs
    to access after return from this function.

Arguments:

    pTask                   -   task to be resumed.
    SuspendCompletionParam  -   arbitrary value that is passed on to the task's
                                handler as "UserParan" when the handler is called
                                with code RM_TASKOP_PENDCOMPLETE.
--*/
{
    ENTER("RmResumeTask", 0xd261f3c6)
    NDIS_STATUS Status;
    RM_ASSERT_NOLOCKS(pSR);

    RMPRIVATELOCK(&pTask->Hdr, pSR);

    TR_INFO((
        "RESUMING Task 0x%p (%s); SuspendCompletionParam = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        SuspendCompletionParam
        ));

    if (!CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING))
    {
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
        ASSERTEX(!"Invalid state", pTask);
    }
    else
    {
        // Add tmp ref, because we need to look at pTask after the return
        // from calling pfnHandler.
        //
        RmTmpReferenceObject(&pTask->Hdr, pSR);

        SET_RM_TASK_STATE(pTask, RMTSKSTATE_ACTIVE);
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
        Status = pTask->pfnHandler(
                            pTask,
                            RM_TASKOP_PENDCOMPLETE,
                            SuspendCompletionParam,
                            pSR
                            );

        RM_ASSERT_NOLOCKS(pSR);

        RMPRIVATELOCK(&pTask->Hdr, pSR);
        switch(GET_RM_TASK_STATE(pTask))
        {
        case RMTSKSTATE_ACTIVE:

            // This task is completing here (maybe)
            //
            if (Status != NDIS_STATUS_PENDING)
            {
                SET_RM_TASK_STATE(pTask, RMTSKSTATE_ENDING);
                RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
                rmEndTask(pTask, Status, pSR);
                RmDeallocateObject(&pTask->Hdr, pSR);
            }
            else
            {
                // It could be returning pending, but the state could
                // by now be active because it was completed elsewhere.
                // ASSERT(Status != NDIS_STATUS_PENDING);
                RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            }
            break;

        case RMTSKSTATE_PENDING:
            ASSERTEX(Status == NDIS_STATUS_PENDING, pTask);
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            break;

        case RMTSKSTATE_ENDING:
            // This task is completing synchronously and the RM_TASKOP_END
            // notification has already been sent.
            //
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
            break;

        default:
            ASSERTEX(FALSE, pTask);
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
        }
        
        // Remove tmpref added above. pTask may well go away now...
        //
        RmTmpDereferenceObject(&pTask->Hdr, pSR);
    }

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()
}


VOID
RmResumeTaskAsync(
    IN  PRM_TASK                    pTask,
    IN  UINT_PTR                    SuspendCompletionParam,
    IN  OS_WORK_ITEM            *   pOsWorkItem,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Similar to RmResumeTask, except that the task is resumed in the context
    of a work-item thread.

Arguments:
    pTask                   - see RmResumeTask
    SuspendCompletionParam  - see RmResumeTask
    pOsWorkItem             - caller supplied UNitialized work item (must stay
                              around until the task is resumed). Typically this
                              will be located within the user-specific portion
                              of pTask
--*/
{
    NDIS_STATUS Status;

    RM_ASSERT_NOLOCKS(pSR);

#if RM_EXTRA_CHECKING
    //  This may seem paranoid, but is such a powerful check that it's worth it.
    //
    RmDbgAddAssociation(
        0x33d63ece,                         // Location ID
        &pTask->Hdr,                        // pObject
        (UINT_PTR) SuspendCompletionParam,  // Instance1
        (UINT_PTR) pOsWorkItem,             // Instance2
        RM_PRIVATE_ASSOC_RESUME_TASK_ASYNC, // AssociationID
        szASSOCFORMAT_RESUME_TASK_ASYNC,    // szAssociationFormat
        pSR
        );
#endif // RM_EXTRA_CHECKING

    // We don't need to grab the private lock to set this, because only one
    // entity can call RmResumeTaskAsync. Note that we also ensure things are clean
    // (in the debug case) by the association added above.
    //
    pTask->AsyncCompletionParam = SuspendCompletionParam;

    NdisInitializeWorkItem(
        pOsWorkItem,
        rmWorkItemHandler_ResumeTaskAsync,
        pTask
        );

    Status = NdisScheduleWorkItem(pOsWorkItem);
    if (FAIL(Status))
    {
        ASSERT(!"NdisStatusWorkItem failed.");

        // It so happens that NdisScheudleWorkItem (current implementation
        // doesn't fail. Nevertheless, we do the best we can and actually
        // resume the task. If the caller was at dpc level and was expecting
        // the task to resume at passive, they're out of luck.
        //
        RmResumeTask(pTask, SuspendCompletionParam, pSR);
    }
}


VOID
RmResumeTaskDelayed(
    IN  PRM_TASK                    pTask,
    IN  UINT_PTR                    SuspendCompletionParam,
    IN  ULONG                       MsDelay,
    IN  OS_TIMER                *   pOsTimer,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Similar to RmResumeTask, except that the task is resumed in the context
    of a os timer handler which is set to fire after MsDelay milliseconds
    from the time RmResumeTaskDelayed is called.

    EXCEPTION: if someone has previously called RmResumeDelayedTaskNow, this
    task could be resumed in the context of this function call itself.

    Abort implementation notes: see notes.txt  07/14/1999 entry.

Arguments:

    pTask                   - see RmResumeTask
    SuspendCompletionParam  - see RmResumeTask
    pOsTimer                - caller supplied UNitialized timer
                              (must stay around until the task is resumed).
                              Typically this will be located within the
                              user-specific portion of pTask.
--*/
{
    NDIS_STATUS Status;

    RM_ASSERT_NOLOCKS(pSR);

#if RM_EXTRA_CHECKING
    //  This may seem paranoid, but is such a powerful check that it's worth it.
    //
    RmDbgAddAssociation(
        0x33d63ece,                             // Location ID
        &pTask->Hdr,                            // pObject
        (UINT_PTR) SuspendCompletionParam,      // Instance1
        (UINT_PTR) NULL,                        // Instance2
        RM_PRIVATE_ASSOC_RESUME_TASK_DELAYED,   // AssociationID
        szASSOCFORMAT_RESUME_TASK_DELAYED,      // szAssociationFormat
        pSR
        );
#endif // RM_EXTRA_CHECKING

    // Ddk states that it's best to call this function at passive level.
    //
    NdisInitializeTimer(
        pOsTimer,
        rmTimerHandler_ResumeTaskDelayed,
        pTask
        );

    RMPRIVATELOCK(&pTask->Hdr, pSR);

    // The task-del state should NOT be "delayed"
    //
    ASSERT(RM_CHECK_STATE(pTask, RMTSKDELSTATE_MASK, 0));
    pTask->AsyncCompletionParam = SuspendCompletionParam;
    RM_SET_STATE(pTask, RMTSKDELSTATE_MASK, RMTSKDELSTATE_DELAYED);

    if (RM_CHECK_STATE(pTask, RMTSKABORTSTATE_MASK, RMTSKABORTSTATE_ABORT_DELAY))
    {
        // Oops, the delay has been aborted -- we call the tick handler now!
        //
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);

        rmTimerHandler_ResumeTaskDelayed(
                NULL, // SystemSpecific1,
                pTask, // FunctionContext,
                NULL,  // SystemSpecific2,
                NULL   // SystemSpecific3
                );

    }
    else
    {
        //
        // Not currently aborting, let's set the timer.
        //
        NdisSetTimer(pOsTimer, MsDelay);

        // Very important to unlock the private lock AFTER calling set timer,
        // other wise someone could call RmResumeDelayedTaskNow BEFORE we call
        // NdisSetTimer, in which we would not end up aborting the delayed task.
        //
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
    }

}


VOID
RmResumeDelayedTaskNow(
    IN  PRM_TASK                    pTask,
    IN  OS_TIMER                *   pOsTimer,
    OUT PUINT                       pTaskResumed,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Cut's short the delay and resumes the task immediately.

    Implementation notes:  see notes.txt  07/14/1999 entry.

Arguments:

    pTask                   - see RmResumeTask
    pOsTimer                - caller supplied initialized timer
                              (must stay around until the task is resumed).
                              Typically this will be located within the
                              user-specific portion of pTask.
    pTaskResumed            - Points to a caller-supplied variable.
                              RmResumeDelayedTask sets this variable to TRUE if the
                              task was resumed as a consequence of this call, or to
                              FALSE if the task was resumed due to some other reason.
--*/
{
    UINT_PTR    CompletionParam = pTask->AsyncCompletionParam;

    *pTaskResumed = FALSE;
    ASSERTEX(RMISALLOCATED(&pTask->Hdr), pTask);

    RMPRIVATELOCK(&pTask->Hdr, pSR);

    RM_SET_STATE(pTask, RMTSKABORTSTATE_MASK, RMTSKABORTSTATE_ABORT_DELAY);

    if (RM_CHECK_STATE(pTask, RMTSKDELSTATE_MASK, RMTSKDELSTATE_DELAYED))
    {
        BOOLEAN     TimerCanceled = FALSE;

        //
        // The task is actually delayed. Let's go ahead and cancel the timer
        // and resume the task now (which we do indirectly by calling
        // the timer handler ourselves).
        //
        NdisCancelTimer(pOsTimer, &TimerCanceled);
        if (TimerCanceled)
        {
            //
            // The timer was actually canceled -- so we call the timer handler
            // ourselves.
            //
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
    
            rmTimerHandler_ResumeTaskDelayed(
                    NULL, // SystemSpecific1,
                    pTask, // FunctionContext,
                    NULL,  // SystemSpecific2,
                    NULL   // SystemSpecific3
                    );
            *pTaskResumed = TRUE;
        }
        else
        {
            //
            // Hmm -- the timer is not enabled. This is either because
            // the timer handler has just been called (and not yet cleared
            // the "DELAY" state) OR someone has previously called
            // RmResumeDelayedTaskNow.
            //
            //
            // Nothing to do.
            //
            RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
        }
    }
    else
    {
        //
        // The task state is not delayed -- so we just set the abort state
        // and go away.
        //
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);
    }
}


RM_STATUS
RmPendTaskOnOtherTask(
    IN  PRM_TASK                    pTask,
    IN  UINT                        SuspendContext,
    IN  PRM_TASK                    pOtherTask,
    IN  PRM_STACK_RECORD            pSR
    )

/*++

Routine Description:

    Pend task pTask on task pOtherTask.

    Note: RmPendTaskOnOtherTask will cause pTask's pend operation to be
    completed in the context of this call itself, if pOtherTask is already
    in the completed state.
    03/26/1999 -- see RmPendTaskOnOtherTaskV2, and also
    03/26/1999 notes.txt entry "Some proposed ..."

Arguments:

    pTask           -   task to be suspended.
    SuspendContext  -   Context associated with the suspend (see
                        RmSuspendTask for details).
    pOtherTask      -   task that pTask is to pend on.

Return Value:

    NDIS_STATUS_SUCCESS on success.
    NDIS_STATUS_FAILURE on failure (typically because pTask is not in as
                        position to be suspended.)
--*/
{
    ENTER("RmPendTaskOnOtherTask", 0x0416873e)
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    BOOLEAN fResumeTask = FALSE;
    RM_ASSERT_NOLOCKS(pSR);

    TR_INFO((
        "PENDING Task 0x%p (%s) on Task 0x%p (%s). SuspendCompletionParam = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        pOtherTask,
        pOtherTask->Hdr.szDescription,
        SuspendContext
        ));
    //
    // WARNING: we break the locking rules here  by getting the lock on
    // both pTask and pOtherTask.
    // TODO: consider acquiring them in order of increasing numerical value.
    //
    ASSERT(pTask != pOtherTask);
    NdisAcquireSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    NdisAcquireSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));

    do
    {
        // Break if we can't pend pTask on pOtherTask.
        //
        {
            if (    !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_STARTING)
                &&  !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_ACTIVE))
            {
                ASSERTEX(!"Invalid state", pTask);
                break;
            }

            // Non-NULL pTaskIAmPendingOn implies that pTask is already pending on
            // some other task!
            //
            if (pTask->pTaskIAmPendingOn != NULL)
            {
                ASSERTEX(!"Invalid state", pTask);
                break;
            }
        }

        Status = NDIS_STATUS_SUCCESS;

        SET_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING);
        pTask->SuspendContext = SuspendContext;

        if (CHECK_RM_TASK_STATE(pOtherTask, RMTSKSTATE_ENDING))
        {
            //
            // Other task is done -- so we resume pTask before returning...
            //
            fResumeTask = TRUE;
            break;
        }

        //
        // pOtherTask is not ended -- add pTask to the list of tasks pending
        // on pOtherTask.
        //
        pTask->pTaskIAmPendingOn  = pOtherTask;

    #if RM_EXTRA_CHECKING
        RmLinkObjectsEx(
            &pTask->Hdr,
            &pOtherTask->Hdr,
            0x77c488ca,
            RM_PRIVATE_ASSOC_LINK_TASKPENDINGON,
            szASSOCFORMAT_LINK_TASKPENDINGON,
            RM_PRIVATE_ASSOC_LINK_TASKBLOCKS,
            szASSOCFORMAT_LINK_TASKBLOCKS,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmLinkObjects(&pTask->Hdr, &pOtherTask->Hdr, pSR);
    #endif // !RM_EXTRA_CHECKING

        ASSERTEX(pTask->linkFellowPendingTasks.Blink == NULL, pTask);
        ASSERTEX(pTask->linkFellowPendingTasks.Flink == NULL, pTask);
        InsertHeadList(
                &pOtherTask->listTasksPendingOnMe,
                &pTask->linkFellowPendingTasks
                );

    } while(FALSE);

    NdisReleaseSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));
    NdisReleaseSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    
    if (fResumeTask)
    {
            RmResumeTask(
                pTask,
                NDIS_STATUS_SUCCESS, // SuspendCompletionParam. TODO: put real code.
                pSR
                );
    }

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
    return Status;
}


RM_STATUS
RmPendOnOtherTaskV2(
    IN  PRM_TASK                    pTask,
    IN  UINT                        SuspendContext,
    IN  PRM_TASK                    pOtherTask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    if pOtherTask is not complete, Pend task pTask on task pOtherTask and return
    NDIS_STATUS_PENDING. However, if pOtherTask is already complete,
    then don't pend and instead return NDIS_STATUS_SUCCESS.

    See  03/26/1999 notes.txt entry "Some proposed ...". This function
    is currently used only by rmTaskUnloadGroup, to avoid the problem describted
    in the above-referenced notes.txt entry.

    TODO: Eventually get rid of RmPendTaskOnOtherTask.

Arguments:

    See RmPendTaskOnOtherTask
    
Return Value:

    NDIS_STATUS_PENDING if pTask is pending on pOtherTask
    NDIS_STATUS_SUCCESS if pOtherTask is complete.
    NDIS_STATUS_FAILURE if there was some failure (typically pTask is not
                        in a position to be pended.)
--*/
{
    ENTER("RmPendTaskOnOtherTaskV2", 0x0e7d1b89)
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    RM_ASSERT_NOLOCKS(pSR);

    TR_INFO((
        "PENDING(V2) Task 0x%p (%s) on Task 0x%p (%s). SuspendCompletionParam = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        pOtherTask,
        pOtherTask->Hdr.szDescription,
        SuspendContext
        ));

    // This is not a useless assert -- I'e had a bug elsewhere which caused this
    // assert to get hit.
    //
    ASSERT(pTask != pOtherTask);
    //
    // WARNING: we break the locking rules here  by getting the lock on
    // both pTask and pOtherTask.
    // TODO: consider acquiring them in order of increasing numerical value.
    //
    NdisAcquireSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    NdisAcquireSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));

    do
    {
        // Break if we can't pend pTask on pOtherTask.
        //
        {
            if (    !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_STARTING)
                &&  !CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_ACTIVE))
            {
                ASSERTEX(!"Invalid state", pTask);
                break;
            }

            // Non-NULL pTaskIAmPendingOn implies that pTask is already pending on
            // some other task!
            //
            if (pTask->pTaskIAmPendingOn != NULL)
            {
                ASSERTEX(!"Invalid state", pTask);
                break;
            }
        }


        if (CHECK_RM_TASK_STATE(pOtherTask, RMTSKSTATE_ENDING))
        {
            //
            // Other task is done -- so we simply return success...
            //
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // pOtherTask is not ended -- set pTask state to pending, and
        // add it to the list of tasks pending on pOtherTask.
        //
        SET_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING);
        pTask->SuspendContext       = SuspendContext;
        pTask->pTaskIAmPendingOn    = pOtherTask;

    #if RM_EXTRA_CHECKING
        RmLinkObjectsEx(
            &pTask->Hdr,
            &pOtherTask->Hdr,
            0x77c488ca,
            RM_PRIVATE_ASSOC_LINK_TASKPENDINGON,
            szASSOCFORMAT_LINK_TASKPENDINGON,
            RM_PRIVATE_ASSOC_LINK_TASKBLOCKS,
            szASSOCFORMAT_LINK_TASKBLOCKS,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmLinkObjects(&pTask->Hdr, &pOtherTask->Hdr, pSR);
    #endif // !RM_EXTRA_CHECKING

        ASSERTEX(pTask->linkFellowPendingTasks.Blink == NULL, pTask);
        ASSERTEX(pTask->linkFellowPendingTasks.Flink == NULL, pTask);
        InsertHeadList(
                &pOtherTask->listTasksPendingOnMe,
                &pTask->linkFellowPendingTasks
                );
        Status = NDIS_STATUS_PENDING;

    } while(FALSE);

    NdisReleaseSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));
    NdisReleaseSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    
    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
    return Status;
}


VOID
RmCancelPendOnOtherTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_TASK                    pOtherTask,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Resume task pTask which is currently pending on pOtherTask.

    Since no locks are held, pOtherTask needs to be specified, to make sure
    that pTask is indeed pending on pOtherTask before canceling the pend.

    If pTask is indeed pending on pOtherTask, this function will cause the
    completion of the pend status with the specified user param.

    Has no effect if the task is not pending.

Arguments:

    pTask       - Task to be "unpended"
    pOtherTask  - Task pTask is currently pending on.
    UserParam   - Passed to pTask's handler if and when pTask is resumed.

--*/
{
    ENTER("RmCancelPendOnOtherTask", 0x6e113266)
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    BOOLEAN fResumeTask = FALSE;
    RM_ASSERT_NOLOCKS(pSR);

    //
    // WARNING: we break the locking rules here  by getting the lock on
    // both pTask and pOtherTask.
    // TODO: consider acquiring them in order of increasing numerical value.
    //

    TR_INFO((
        "CANCEL PEND of Task 0x%p (%s) on other Task 0x%p (%s); UserParam = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        pOtherTask,
        pOtherTask->Hdr.szDescription,
        UserParam
        ));

    // With pTask locked, tmp ref the task it is pending on, if any...
    //
    {
        NdisAcquireSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));
        if (pOtherTask == pTask->pTaskIAmPendingOn)
        {
            RmTmpReferenceObject(&(pOtherTask->Hdr), pSR);
        }
        else
        {
            // Oops -- pTask is not pending on pOtherTask ...
            //
            pOtherTask = NULL;
        }
        NdisReleaseSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));
    }

    if (pOtherTask == NULL) return;                 // EARLY RETURN


    NdisAcquireSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    NdisAcquireSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));

    do
    {
        // Now that we have both task's locks, check again if pTask is pending
        // on pOtherTask
        //
        if (pTask->pTaskIAmPendingOn != pOtherTask)
        {
            // Oops -- the situation is different than when we started -- quietly
            // get out of here...
            //
            break;
        }

        pTask->pTaskIAmPendingOn = NULL;

    #if RM_EXTRA_CHECKING
        RmUnlinkObjectsEx(
            &pTask->Hdr,
            &pOtherTask->Hdr,
            0x6992b7a1,
            RM_PRIVATE_ASSOC_LINK_TASKPENDINGON,
            RM_PRIVATE_ASSOC_LINK_TASKBLOCKS,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmUnlinkObjects(&pTask->Hdr, &pOtherTask->Hdr, pSR);
    #endif // !RM_EXTRA_CHECKING

        RemoveEntryList(&pTask->linkFellowPendingTasks);
        pTask->linkFellowPendingTasks.Flink = NULL;
        pTask->linkFellowPendingTasks.Blink = NULL;

        if (CHECK_RM_TASK_STATE(pTask, RMTSKSTATE_PENDING))
        {
            fResumeTask = TRUE;
        }
        else
        {
            //
            // We shouldn't get here -- after we are pending on another task...
            //
            ASSERTEX(!"Invalid state", pTask);
            break;
        }

    } while (FALSE);

    NdisReleaseSpinLock(&(pTask->Hdr.RmPrivateLock.OsLock));
    NdisReleaseSpinLock(&(pOtherTask->Hdr.RmPrivateLock.OsLock));
    RmTmpDereferenceObject(&(pOtherTask->Hdr), pSR);
    
    if (fResumeTask)
    {
            RmResumeTask(
                pTask,
                UserParam, // SuspendCompletionParam
                pSR
                );
    }

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
}



VOID
RmInitializeHashTable(
    PRM_HASH_INFO pHashInfo,
    PVOID         pAllocationContext,
    PRM_HASH_TABLE pHashTable
    )
/*++

Routine Description:

    Initialize a hash table data structure.
    Caller is responsible for serializing access to the hash table structure.

Arguments:

    pHashInfo           - Points to static information about the hash table
    pAllocationContext  - Passed to the allocation and deallocation functions
                          (pHashInfo->pfnTableAllocator and
                          pHashInfo0->pfnTableDeallocator) which are used to
                          dynamically grow /shrink the hash table.
    pHashTable          - Points to uninitialized memory that is to contain the
                          hash table.
--*/
{

    NdisZeroMemory(pHashTable, sizeof(*pHashTable));

    pHashTable->pHashInfo = pHashInfo;
    pHashTable->pAllocationContext = pAllocationContext;
    pHashTable->pTable =  pHashTable->InitialTable;
    pHashTable->TableLength = sizeof(pHashTable->InitialTable)
                                /sizeof(pHashTable->InitialTable[0]);
}

VOID
RmDeinitializeHashTable(
    PRM_HASH_TABLE pHashTable
    )
/*++

Routine Description:

    Deinitialize a previously-initialized a hash table data structure.
    There must be no items in the hash table when this function is called.

    Caller is responsible for serializing access to the hash table structure.

Arguments:

    pHashTable          - Hash table to be deinitialized.

--*/
{
    PRM_HASH_LINK *pTable = pHashTable->pTable;
    
    ASSERTEX(pHashTable->NumItems == 0, pHashTable);

    if (pTable != pHashTable->InitialTable)
    {
        NdisZeroMemory(pTable, pHashTable->TableLength*sizeof(*pTable));

        pHashTable->pHashInfo->pfnTableDeallocator(
                                    pTable,
                                    pHashTable->pAllocationContext
                                    );
    }

    NdisZeroMemory(pHashTable, sizeof(*pHashTable));

}


BOOLEAN
RmLookupHashTable(
    PRM_HASH_TABLE      pHashTable,
    PRM_HASH_LINK **    pppLink,
    PVOID               pvRealKey
    )
/*++

Routine Description:

    Lookup an item in the hash table and/or find the place where the item
    is to be inserted.

    Caller is expected to serialize access to the hash table.
    OK to use read-locks to serialize access.

    Return value: TRUE if item found; false otherwise.
    On return, *pppLink is set to a the location containing a pointer to
    a RM_HASH_LINK. If the return value is TRUE, the latter pointer points
    to the found RM_HASH_LINK. If the return value is FALSE, the location
    is where the item is to be inserted, if required.

Arguments:

    pHashTable          - Hash table to look up
    pppLink             - place to store a pointer to a link which points
                          to an item (see above for details).
    pvRealKey           - Key used to lookup item.

Return Value:
    
    TRUE    if item is found
    FALSE   otherwise.

--*/
{
    PRM_HASH_LINK *ppLink, pLink;
    UINT LinksTraversed = 0;
    UINT TableLength = pHashTable->TableLength;
    PFN_RM_COMPARISON_FUNCTION pfnCompare =  pHashTable->pHashInfo->pfnCompare;
    BOOLEAN fRet = FALSE;
    ULONG               uHash = pHashTable->pHashInfo->pfnHash(pvRealKey);

    for (
        ppLink = pHashTable->pTable + (uHash%TableLength);
        (pLink = *ppLink) != NULL;
        ppLink = &(pLink->pNext), LinksTraversed++)
    {
        if (pLink->uHash == uHash
            && pfnCompare(pvRealKey, pLink))
        {
            // found it
            //
            fRet = TRUE;
            break;
        }
    }

    // Update stats
    //
    rmUpdateHashTableStats(&pHashTable->Stats, LinksTraversed);
    
    *pppLink = ppLink;

    return fRet;
}


BOOLEAN
RmNextHashTableItem(
    PRM_HASH_TABLE      pHashTable,
    PRM_HASH_LINK       pCurrentLink,   // OPTIONAL
    PRM_HASH_LINK *    ppNextLink
    )
/*++

Routine Description:

    Find the first (if pCurrentLink is NULL) or "next" (if pCurrentLink is not NULL)
    item in the hash table.

    Caller is expected to serialize access to the hash table.
    OK to use read-locks to serialize access.

    NOTE: The "next" item returned is in no particular order.

Arguments:

    pHashTable          - Hash table to look up
    pCurrentLink        - if non-NULL, points to an existing hash link in the
                          hash table.
    ppLinkLink          - place to store a pointer to the link "after"
                          pCurrentLink, or the first link (if pCurrentLink is NULL).

Return Value:
    
    TRUE    if there is a "next" item.
    FALSE   otherwise.

--*/
{
    PRM_HASH_LINK pLink, *ppLink, *ppLinkEnd;
    UINT TableLength;

    ppLink      = pHashTable->pTable;
    TableLength = pHashTable->TableLength;
    ppLinkEnd   = ppLink + TableLength;

    if (pCurrentLink != NULL)
    {

    #if DBG
        {
            // Make sure this link is valid!
            pLink =  *(ppLink + (pCurrentLink->uHash % TableLength));
            while (pLink != NULL && pLink != pCurrentLink)
            {
                pLink = pLink->pNext;
            }
            if (pLink != pCurrentLink)
            {
                ASSERTEX(!"Invalid pCurrentLink", pCurrentLink);
                *ppNextLink = NULL;
                return FALSE;                           // EARLY RETURN
            }
        }
    #endif // DBG

        if (pCurrentLink->pNext != NULL)
        {
            // Found a next link.
            //
            *ppNextLink = pCurrentLink->pNext;
            return TRUE;                            // EARLY RETURN
        }
        else
        {
            // End of current bucket, move to next one.
            // We check later if we've gone past the end of the table.
            //
            ppLink +=  (pCurrentLink->uHash % TableLength) + 1;
        }
    }


    // Look for next non-null item.
    //
    for ( ; ppLink < ppLinkEnd; ppLink++)
    {
        pLink =  *ppLink;
        if (pLink != NULL)
        {
            *ppNextLink = pLink;
            return TRUE;                        // EARLY RETURN
        }
    }

    *ppNextLink = NULL;
    return FALSE;
}


VOID
RmAddHashItem(
    PRM_HASH_TABLE  pHashTable,
    PRM_HASH_LINK * ppLink,
    PRM_HASH_LINK   pLink,
    PVOID           pvKey
    )
/*++

Routine Description:

    Add an item to the hash table at the specified location.
    Caller is expected to serialize access to the hash table.

Arguments:

    pHashTable      - Hash table in which to add item.
    ppLink          - Points to place within table to add new item.
    pLink           - New item to add.
    pvKey           - key associated with the item.

    TODO: pvKey is only used to compute uHash -- consider passing in uHash directly.

--*/
{
    pLink->uHash = pHashTable->pHashInfo->pfnHash(pvKey);
    pLink->pNext = *ppLink;
    *ppLink = pLink;

    pHashTable->NumItems++;

    // TODO: if required, resize
}

VOID
RmRemoveHashItem(
    PRM_HASH_TABLE  pHashTable,
    PRM_HASH_LINK   pLinkToRemove
    )
/*++

Routine Description:

    Remove an item from the hash table.
    Caller is expected to serialize access to the hash table.

    (debug only): Asserts if pLinkToRemove is no in the hash table.

Arguments:

    pHashTable      - Hash table in which to add item.
    pLinkToRemove   - Link to remove.

--*/
{
    PRM_HASH_LINK *ppLink, pLink;
    UINT TableLength = pHashTable->TableLength;
    ULONG uHash = pLinkToRemove->uHash;
    BOOLEAN     fFound = FALSE;

    for (
        ppLink = pHashTable->pTable + (uHash%TableLength);
        (pLink = *ppLink) != NULL;
        ppLink = &(pLink->pNext))
    {
        if (pLink == pLinkToRemove)
        {
            // found it -- remove it and get out.
            //
            RM_PRIVATE_UNLINK_NEXT_HASH(pHashTable, ppLink);
            pLink->pNext = NULL; // Important, so that enumeration works.
            fFound=TRUE;
            break;
        }
    }

    // TODO: if required, resize

    ASSERT(fFound);
}


VOID
RmEnumHashTable(
    PRM_HASH_TABLE          pHashTable,
    PFN_ENUM_HASH_TABLE     pfnEnumerator,
    PVOID                   pvContext,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Calls function pfnEnumerator for each item in the hash table.
    Caller is expected to serialize access to the hash table.

Arguments:

    pHashTable      - Hash table to enumerate.
    pfnEnumerator   - Enumerator function.
    pvContext       - Opaque context passed to enumerator function.

--*/
{
    PRM_HASH_LINK *ppLink, *ppLinkEnd;

    ppLink      = pHashTable->pTable;
    ppLinkEnd   = ppLink + pHashTable->TableLength;

    for ( ; ppLink < ppLinkEnd; ppLink++)
    {
        PRM_HASH_LINK pLink =  *ppLink;
        while (pLink != NULL)
        {

            pfnEnumerator(
                pLink,
                pvContext,
                pSR 
                );
    
            pLink = pLink->pNext;
        }
    }
}


VOID
RmEnumerateObjectsInGroup(
    PRM_GROUP               pGroup,
    PFN_RM_GROUP_ENUMERATOR pfnEnumerator,
    PVOID                   pvContext,
    INT                     fStrong,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Calls function pfnEnumerator for each item in the group, until
    the funcition return FALSE.

    WARNING: Enumeration is "STRONG" -- the group lock
    is held during the whole enumeration process. The
    enumerator function is therefore called at DPR level, and more importantly,
    the enumerator function avoid locking anything to avoid risk of deadlock.
    Specifically, the enumerator function MUST NOT lock the object -- if any other
    thread has called a group-related RM function with the object's lock held,
    we WILL deadlock.

    This function should only be used to access parts of the object that do
    not need to be protected by the objects lock.

    If locking needs to be performed, use RmWeakEnumerateObjectsInGroup.

Arguments:

    pGroup          - Hash table to enumerate.
    pfnEnumerator   - Enumerator function.
    pvContext       - Opaque context passed to enumerator function.
    fStrong         - MUST be TRUE.
--*/
{

    if (fStrong)
    {
        RM_STRONG_ENUMERATION_CONTEXT Ctxt;
        Ctxt.pfnObjEnumerator = pfnEnumerator;
        Ctxt.pvCallerContext = pvContext;
        Ctxt.fContinue           = TRUE;

        NdisAcquireSpinLock(&pGroup->OsLock);

        RmEnumHashTable(
                    &pGroup->HashTable,
                    rmEnumObjectInGroupHashTable,   // pfnEnumerator
                    &Ctxt,                          // context
                    pSR
                    );

        NdisReleaseSpinLock(&pGroup->OsLock);
    }
    else
    {
        ASSERT(!"Unimplemented");
    }

}


VOID
RmWeakEnumerateObjectsInGroup(
    PRM_GROUP               pGroup,
    PFN_RM_GROUP_ENUMERATOR pfnEnumerator,
    PVOID                   pvContext,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Calls function pfnEnumerator for each item in the group, until
    the funcition return FALSE.

    Enumeration is "WEAK" -- the group lock is
    NOT held the whole time, and is not held when the enumerator
    function is called.

    A snapshot of the entire group is first taken with the group lock held,
    and each object is tempref'd. The group lock is then released and the
    enumerator function is called for each object in the snapshot. 
    The objects are then derefd.

    NOTE: It is possible that when the enumeration function is called for an
    object, the object is no longer in the group. The enumeration function can
    lock the object and check its internal state to determine if it is still
    relevant to process the object.

Arguments:

    pGroup          - Hash table to enumerate.
    pfnEnumerator   - Enumerator function.
    pvContext       - Opaque context passed to enumerator function.


--*/
{
    #define RM_SMALL_GROUP_SIZE         10
    #define RM_MAX_ENUM_GROUP_SIZE      100000
    PRM_OBJECT_HEADER *ppSnapshot = NULL;
    PRM_OBJECT_HEADER SmallSnapshot[RM_SMALL_GROUP_SIZE];
    UINT NumItems = pGroup->HashTable.NumItems;

    do
    {
        RM_WEAK_ENUMERATION_CONTEXT Ctxt;

        if (NumItems <= RM_SMALL_GROUP_SIZE)
        {
            if (NumItems == 0) break;
            ppSnapshot = SmallSnapshot;
        }
        else if (NumItems > RM_MAX_ENUM_GROUP_SIZE)
        {
            // TODO: LOG_RETAIL_ERROR
            ASSERT(FALSE);
        }
        else
        {
            RM_ALLOC(
                    &(void* )ppSnapshot,
                    NumItems,
                    MTAG_RMINTERNAL
                    );

            if (ppSnapshot == NULL)
            {
                ASSERT(FALSE);
                break;
            }
        }

        Ctxt.ppCurrent = ppSnapshot;
        Ctxt.ppEnd     = ppSnapshot+NumItems;

        NdisAcquireSpinLock(&pGroup->OsLock);
    
        RmEnumHashTable(
                    &pGroup->HashTable,
                    rmConstructGroupSnapshot,   // pfnEnumerator
                    &Ctxt,                      // context
                    pSR
                    );
    
        NdisReleaseSpinLock(&pGroup->OsLock);

        ASSERT(Ctxt.ppCurrent >= ppSnapshot);
        ASSERT(Ctxt.ppCurrent <= Ctxt.ppEnd);

        // Fix up ppEnd to point to the last actually-filled pointer.
        //
        Ctxt.ppEnd = Ctxt.ppCurrent;
        Ctxt.ppCurrent = ppSnapshot;

        for  (;Ctxt.ppCurrent < Ctxt.ppEnd; Ctxt.ppCurrent++)
        {
            pfnEnumerator(
                    *Ctxt.ppCurrent,
                    pvContext,
                    pSR
                    );
            RmTmpDereferenceObject(*Ctxt.ppCurrent, pSR);
        }

        if (ppSnapshot != SmallSnapshot)
        {
            RM_FREE(ppSnapshot);
            ppSnapshot = NULL;
        }

    } while (FALSE);
}


//=========================================================================
//                  L O C A L   F U N C T I O N S
//=========================================================================


VOID
rmDerefObject(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Dereference object pObject. Deallocate it if the reference count goes to zero.

--*/
{
    ULONG Refs;
    ENTER("rmDerefObject", 0x5f9d81dd)

    ASSERT(RM_OBJECT_IS_ALLOCATED(pObject));

    //
    // On entry, the ref count should be at-least 2 -- one the
    // explicit ref added in RmAllocateObject, and the 2nd the ref due to
    // the link to the parent.
    //
    // Exception to the above: if the object has no parent, the refcount should be
    // at-least 1.
    //

    // Deref the ref added in RmAllocateObject, and if the ref count is now <=1, 
    // we actually unlink and free the object.
    //
    Refs = NdisInterlockedDecrement(&pObject->TotRefs);

    if (Refs <= 1)
    {
        PRM_OBJECT_HEADER pParentObject;
        RMPRIVATELOCK(pObject, pSR);

        //
        // Unlink from parent, if there is one...
        //
    
        pParentObject =  pObject->pParentObject;
        pObject->pParentObject = NULL;

    #if RM_TRACK_OBJECT_TREE
        // Verify that there are no siblings...
        //
        RETAILASSERTEX(IsListEmpty(&pObject->listChildren), pObject);
    #endif // RM_TRACK_OBJECT_TREE

        RMPRIVATEUNLOCK(pObject, pSR);

        if (pParentObject != NULL)
        {
            ASSERTEX(!RMISALLOCATED(pObject), pObject);

            ASSERTEX(Refs == 1, pObject);

        #if RM_TRACK_OBJECT_TREE
            RMPRIVATELOCK(pParentObject, pSR);

            // Remove object from parent's list of children.
            //
            RETAILASSERTEX(
                !IsListEmpty(&pParentObject->listChildren),
                pObject);
            RemoveEntryList(&pObject->linkSiblings);

            RMPRIVATEUNLOCK(pParentObject, pSR);
        #endif // RM_TRACK_OBJECT_TREE

    #if RM_EXTRA_CHECKING
        RmUnlinkObjectsEx(
            pObject,
            pParentObject,
            0xac73e169,
            RM_PRIVATE_ASSOC_LINK_CHILDOF,
            RM_PRIVATE_ASSOC_LINK_PARENTOF,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
            RmUnlinkObjects(pObject, pParentObject, pSR);
    #endif // !RM_EXTRA_CHECKING

        }
        else if (Refs == 0)
        {
            //
            // Free to deallocate this thing...
            //

            ASSERTEX(!RMISALLOCATED(pObject), pObject);

            #if RM_EXTRA_CHECKING
            rmDbgDeinitializeDiagnosticInfo(pObject, pSR);
            #endif // RM_EXTRA_CHECKING

            RM_MARK_OBJECT_AS_DEALLOCATED(pObject);

            if (pObject->pStaticInfo->pfnDelete!= NULL)
            {

                TR_INFO((
                    "Actually freeing 0x%p (%s)\n",
                    pObject,
                    pObject->szDescription
                    ));

                pObject->pStaticInfo->pfnDelete(pObject, pSR);
            }
        }
    }

    EXIT()
}

VOID
rmLock(
    PRM_LOCK                pLock,
#if RM_EXTRA_CHECKING
    UINT                    uLocID,
    PFNLOCKVERIFIER         pfnVerifier,
    PVOID                   pVerifierContext,
#endif //RM_EXTRA_CHECKING
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Lock pLock.

Arguments:

    pLock               - Lock to lock.
    LocID               - Arbitrary ID, typically representing the source location
                          from which this function is called.
    
    Following are for debug only:

    pfnVerifier         - Optional function that is called just after locking
    pfnVerifierContext  - Passed in call to pfnVerifier

--*/
{
    //UINT Level  = pSR->LockInfo.CurrentLevel;
    RM_LOCKING_INFO li;

    RETAILASSERTEX(pLock->Level > pSR->LockInfo.CurrentLevel, pLock);
    RETAILASSERTEX(pSR->LockInfo.pNextFree < pSR->LockInfo.pLast, pLock);

    pSR->LockInfo.CurrentLevel = pLock->Level;

    // Save information about this lock in the stack record.
    //
    li.pLock = pLock;
#if RM_EXTRA_CHECKING
    li.pfnVerifier = pfnVerifier;
    li.pVerifierContext = pVerifierContext;
#endif //RM_EXTRA_CHECKING
    *(pSR->LockInfo.pNextFree++) = li; // struct copy.

    // Get the lock.
    // TODO: uncomment the following optimization...
    //if (Level)
    //{
    //  NdisDprAcquireSpinLock(&pLock->OsLock);
    //}
    //else
    //{
    NdisAcquireSpinLock(&pLock->OsLock);
    //}

#if RM_EXTRA_CHECKING

    ASSERTEX(pLock->DbgInfo.uLocID == 0, pLock);
    ASSERTEX(pLock->DbgInfo.pSR == NULL, pLock);
    pLock->DbgInfo.uLocID = uLocID;
    pLock->DbgInfo.pSR = pSR;
    // Call the verifier routine if there is one.
    //
    if (pfnVerifier)
    {
        pfnVerifier(pLock, TRUE, pVerifierContext, pSR);
    }
#endif //RM_EXTRA_CHECKING

}


VOID
rmUnlock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Unlock pLock.

    Debug only: if there is a verifier function associated with this lock
    we call it just before unlocking pLock.

Arguments:

    pLock               - Lock to unlock.

--*/
{
    RM_LOCKING_INFO * pLI;
    pSR->LockInfo.pNextFree--;
    pLI = pSR->LockInfo.pNextFree;
    RETAILASSERTEX(pLI->pLock == pLock, pLock);

    ASSERTEX(pLock->DbgInfo.pSR == pSR, pLock);
    ASSERTEX(pLock->Level == pSR->LockInfo.CurrentLevel, pLock);

    pLI->pLock = NULL;

    if (pLI > pSR->LockInfo.pFirst)
    {
        PRM_LOCK pPrevLock =  (pLI-1)->pLock;
        pSR->LockInfo.CurrentLevel = pPrevLock->Level;
        ASSERTEX(pPrevLock->DbgInfo.pSR == pSR, pPrevLock);
    }
    else
    {
        pSR->LockInfo.CurrentLevel = 0;
    }


#if RM_EXTRA_CHECKING

    // Call the verifier routine if there is one.
    //
    if (pLI->pfnVerifier)
    {
        pLI->pfnVerifier(pLock, FALSE, pLI->pVerifierContext, pSR);
        pLI->pfnVerifier = NULL;
        pLI->pVerifierContext = NULL;
    }
    pLock->DbgInfo.uLocID = 0;
    pLock->DbgInfo.pSR = NULL;

#endif //RM_EXTRA_CHECKING


    // Release the lock.
    //
    NdisReleaseSpinLock(&pLock->OsLock);
}


#if RM_EXTRA_CHECKING
ULONG
rmPrivateLockVerifier(
        PRM_LOCK            pLock,
        BOOLEAN             fLock,
        PVOID               pContext,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    (Debug only)

    The Verifier function for an object's RmPrivateLock.

Arguments:

    pLock               - Lock being locked/unlocked
    fLock               - TRUE if lock has just been locked.
                          FALSE if lock is about to be unlocked.
Return Value:

    Unused: TODO make return value VOID.

--*/
{
    ENTER("rmPrivateLockVerifier", 0xc3b63ac5)
    TR_VERB(("Called with pLock=0x%p, fLock=%lu, pContext=%p\n",
                pLock, fLock, pContext, pSR));
    EXIT()

    return 0;
}

ULONG
rmVerifyObjectState(
        PRM_LOCK            pLock,
        BOOLEAN             fLock,
        PVOID               pContext,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    (Debug only)

    Uses the object's verification function (if there is one) to
    compute a signature that is checked each time the object is locked,
    and is updated each time the object is unlocked. Assert if this signature
    has changed while the object was supposedly unlocked.

    Also: Update RM_OBJECT_HEADER.pDiagInfo->PrevState if there is been a
    change of state while the object was locked.

Arguments:

    pLock               - Lock being locked/unlocked
    fLock               - TRUE if lock has just been locked.
                          FALSE if lock is about to be unlocked.
    pContext            - Actually pointer to object being locked.

Return Value:

    Unused: TODO make return value VOID.

--*/
{
    PRM_OBJECT_HEADER pObj = (PRM_OBJECT_HEADER) pContext;
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObj->pDiagInfo;
    ULONG NewChecksum;
    ENTER("rmVerifyObjectState", 0xb8ff7a67)
    TR_VERB(("Called with pLock=0x%p, fLock=%lu, pObj=%p\n",
                pLock, fLock, pObj, pSR));

    if (pDiagInfo != NULL
        && !(pDiagInfo->DiagState & fRM_PRIVATE_DISABLE_LOCK_CHECKING))

    {
        
        // Compute the new checksum and as part of that call the
        // object-specific verifier if there is one....
        //
        {
            PFNLOCKVERIFIER         pfnVerifier;

            // We verify that the objset-specific state was not modified
            // without the lock held. This is done by including the object-specific
            // state in the checksum computation.
            //
            NewChecksum = pObj->State;
    
            // Then, if the object has a verifier function, we call it, and 
            // fold in the return value into the checkum.
            //
            pfnVerifier = pObj->pStaticInfo->pfnLockVerifier;
            if (pfnVerifier != NULL)
            {
                NewChecksum ^= pfnVerifier(pLock, fLock, pObj, pSR);
    
            }
        }

        if (fLock)  // We've just locked the object.
        {

            // First thing we do is to save the current value of pObj->State in
            // the TmpState location -- we'll look at it again on unlocking.
            //
            pDiagInfo->TmpState = pObj->State;


            // Now we compare the new checksum value with the value that wase
            // saved the last time this object was locked...
            // Special case: old Checksum was 0 -- as it is on initialization.
            //
            if (NewChecksum != pDiagInfo->Checksum && pDiagInfo->Checksum)
            {
                TR_WARN((
                    "Object 0x%p (%s) possibly modified without lock held!\n",
                    pObj,
                    pObj->szDescription
                    ));

            // Unfortunately we hit this assert because there are places where
            // the same lock is shared by many objects and 
            #if 0
                // Give users the option to ignore further validation on this 
                // object.
                //
                TR_FATAL((
                    "To skip this assert, type \"ed 0x%p %lx; g\"\n",
                    &pDiagInfo->DiagState,
                    pDiagInfo->DiagState | fRM_PRIVATE_DISABLE_LOCK_CHECKING
                    ));
                ASSERTEX(!"Object was modified without lock held!", pObj);
            #endif // 0
            }
        }
        else    // We're just about to unlock the object....
        {
            // Update the signature...
            //
            pDiagInfo->Checksum = NewChecksum;

            // If there has been a change in state between locking and unlockng
            // this object, save the previous state.
            //
            if (pDiagInfo->TmpState != pObj->State)
            {
                pDiagInfo->PrevState = pDiagInfo->TmpState;
            }
        }
    }


    EXIT()

    return 0;
}
#endif // RM_EXTRA_CHECKING

VOID
rmEndTask(
    PRM_TASK            pTask,
    NDIS_STATUS         Status,
    PRM_STACK_RECORD    pSR
)
/*++

Routine Description:

    Send the RM_TASKOP_END to the task handler, and resume any tasks pending on
    pTask.

Arguments:

    pTask       - Task to end.
    Status      - Completion status -- passed on to the task handler.

--*/
{
    ENTER("rmEndtask", 0x5060d952)
    PRM_TASK pPendingTask;
    RM_ASSERT_NOLOCKS(pSR);

    TR_INFO((
        "ENDING Task 0x%p (%s); Status = 0x%lx\n",
        pTask,
        pTask->Hdr.szDescription,
        Status
        ));

    // TODO: could change behavior so that we use the return value, but
    // currently we ignore it...
    //
    pTask->pfnHandler(
                pTask,
                RM_TASKOP_END,
                Status, // UserParam is overloaded here.
                pSR
                );

    RM_ASSERT_NOLOCKS(pSR);

    do
    {
        pPendingTask = NULL;
    
        RMPRIVATELOCK(&pTask->Hdr, pSR);
        if (!IsListEmpty(&pTask->listTasksPendingOnMe))
        {
            pPendingTask = CONTAINING_RECORD(
                                (pTask->listTasksPendingOnMe.Flink),
                                RM_TASK,
                                linkFellowPendingTasks
                                );
            RmTmpReferenceObject(&pPendingTask->Hdr, pSR);
        }
        RMPRIVATEUNLOCK(&pTask->Hdr, pSR);

        if (pPendingTask != NULL)
        {

            RmCancelPendOnOtherTask(
                pPendingTask,
                pTask,
                Status,
                pSR
                );
            RmTmpDereferenceObject(&pPendingTask->Hdr, pSR);
        }
    
    }
    while(pPendingTask != NULL);

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
}


NDIS_STATUS
rmAllocatePrivateTask(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription,      OPTIONAL
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Allocate and initialize a task of subtype RM_PRIVATE_TASK.

Arguments:

    pParentObject       - Object that is to be the parent of the allocated task.
    pfnHandler          - The task handler for the task.
    Timeout             - Unused.
    szDescription       - Text describing this task.
    ppTask              - Place to store pointer to the new task.

Return Value:

    NDIS_STATUS_SUCCESS if we could allocate and initialize the task.
    NDIS_STATUS_RESOURCES otherwise

--*/
{
    RM_PRIVATE_TASK *pRmTask;
    NDIS_STATUS Status;

    RM_ALLOCSTRUCT(pRmTask, MTAG_TASK); // TODO use lookaside lists.
        
    *ppTask = NULL;

    if (pRmTask != NULL)
    {
        RM_ZEROSTRUCT(pRmTask);

        RmInitializeTask(
                &(pRmTask->TskHdr),
                pParentObject,
                pfnHandler,
                &RmPrivateTasks_StaticInfo,
                szDescription,
                Timeout,
                pSR
                );
        *ppTask = &(pRmTask->TskHdr);
        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;
    }

    return Status;
}


NDIS_STATUS
rmTaskUnloadGroup(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    This task is responsible for unloading all the objects in the group.

    pTask is a pointer to TASK_UNLOADGROUP, and that structure is expected
    to be initialized, including containing the  pGroup to unload.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    TASK_UNLOADGROUP    *pMyTask = (TASK_UNLOADGROUP*) pTask;
    PRM_GROUP           pGroup = pMyTask->pGroup;
    BOOLEAN             fContinueUnload = FALSE;
    ENTER("TaskUnloadGroup", 0x964ee422)


    enum
    {
        PEND_WaitOnOtherTask,
        PEND_UnloadObject
    };

    switch(Code)
    {

        case RM_TASKOP_START:
        {
            // If there is already an unload task bound to pGroup, we
            // pend on it.
            //
            NdisAcquireSpinLock(&pGroup->OsLock);
            if (pGroup->pUnloadTask != NULL)
            {
                PRM_TASK pOtherTask = pGroup->pUnloadTask;
                TR_WARN(("unload task 0x%p already bound to pGroup 0x%p; pending on it.\n",
                pOtherTask, pGroup));

                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                NdisReleaseSpinLock(&pGroup->OsLock);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_WaitOnOtherTask,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }
            else if (!pGroup->fEnabled)
            {
                //
                // Presumably this group has already been unloaded of all objects
                // and is simply sitting around. We complete right away.
                //
                Status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                //
                // We're the 1st ones here -- continue on to unloading objects, if
                // any...
                //
                pGroup->pUnloadTask = pTask;
                pGroup->fEnabled = FALSE; // This will prevent new objects from
                                        // being added and from the hash table
                                        // itself from changing size.
                pMyTask->uIndex = 0;    // This keeps track of where we are in the
                                    // hash table.
                                            
                fContinueUnload = TRUE;
            }
            NdisReleaseSpinLock(&pGroup->OsLock);
        }
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {

            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_WaitOnOtherTask:
                {
                    //
                    // Nothing to do -- finish task.
                    //
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;

                case  PEND_UnloadObject:
                {
                    //
                    // Just done unloading an object; unload another if required.
                    //
                    fContinueUnload = TRUE;
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;

                default:
                ASSERTEX(!"Unknown pend code!", pTask);
                break;
            }

        }
        break;


        case  RM_TASKOP_END:
        {
            BOOLEAN fSignal;
            NdisAcquireSpinLock(&pGroup->OsLock);

            // Clear ourselves from pGroup, if we're there.
            //
            if (pGroup->pUnloadTask == pTask)
            {
                pGroup->pUnloadTask = NULL;
            }
            fSignal = pMyTask->fUseEvent;
            pMyTask->fUseEvent = FALSE;
            NdisReleaseSpinLock(&pGroup->OsLock);

            if (fSignal)
            {
                NdisSetEvent(&pMyTask->BlockEvent);
            }
            Status = NDIS_STATUS_SUCCESS;
        }
        break;

        default:
        ASSERTEX(!"Unknown task op", pTask);
        break;

    } // switch (Code)


    if (fContinueUnload)
    {
        do {
            PRM_HASH_LINK *ppLink, *ppLinkEnd;
            UINT uIndex;
            PRM_HASH_LINK pLink;
            PRM_OBJECT_HEADER pObj;
            PRM_TASK pUnloadObjectTask;

            NdisAcquireSpinLock(&pGroup->OsLock);
    
            uIndex = pMyTask->uIndex;

            //
            // With fEnabled set to FALSE by us, we expect the following:
            // (a) pHashTable->pTable is going to stay the same size.
            // (b) No items are going to be added or removed by anyone else.
            //

            // Find the next non-empty hash table entry, starting at
            // offset pMyTask->uIndex.
            //
            ASSERTEX(!pGroup->fEnabled, pGroup);
            ASSERTEX(uIndex <= pGroup->HashTable.TableLength, pGroup);
            ppLinkEnd = ppLink      = pGroup->HashTable.pTable;
            ppLink      += uIndex;
            ppLinkEnd   += pGroup->HashTable.TableLength;
            while (ppLink < ppLinkEnd && *ppLink == NULL)
            {
                ppLink++;
            }

            // Update index to our current position in the hash table.
            //
            pMyTask->uIndex =  (UINT)(ppLink - pGroup->HashTable.pTable);

            if (ppLink >= ppLinkEnd)
            {
                //
                // We're done...
                //
                NdisReleaseSpinLock(&pGroup->OsLock);
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            //
            // Found another object to unload...
            // We'll allocate a task (pUnloadObjectTask) to unload that object,
            // pend ourselves on it, and then start it.
            //
            //

            pLink =  *ppLink;
            pObj = CONTAINING_RECORD(pLink, RM_OBJECT_HEADER, HashLink);
            RmTmpReferenceObject(pObj, pSR);
            ASSERT(pObj->pStaticInfo == pGroup->pStaticInfo);
            NdisReleaseSpinLock(&pGroup->OsLock);

            Status = pMyTask->pfnUnloadTaskAllocator(
                        pObj,                                   // pParentObject,
                        pMyTask->pfnTaskUnloadObjectHandler,    // pfnHandler,
                        0,                                      // Timeout,
                        "Task:Unload Object",
                        &pUnloadObjectTask,
                        pSR
                        );
            if (FAIL(Status))
            {
                // Aargh... we couldn't allocate a task to unload this object.
                // We'll return quietly, leaving the other objects intact...
                //
                ASSERTEX(!"Couldn't allocat unload task for object.", pObj);
                RmTmpDereferenceObject(pObj, pSR);
                break;
            }

            RmTmpDereferenceObject(pObj, pSR);
    
    #if OBSOLETE // See  03/26/1999 notes.txt entry "Some proposed ..."

            RmPendTaskOnOtherTask(
                pTask,
                PEND_UnloadObject,
                pUnloadObjectTask,              // task to pend on
                pSR
                );
    
            (void)RmStartTask(
                        pUnloadObjectTask,
                        0, // UserParam (unused)
                        pSR
                        );

            Status = NDIS_STATUS_PENDING;

    #else   // !OBSOLETE
            RmTmpReferenceObject(&pUnloadObjectTask->Hdr, pSR);
            RmStartTask(
                pUnloadObjectTask,
                0, // UserParam (unused)
                pSR
                );
            Status = RmPendOnOtherTaskV2(
                        pTask,
                        PEND_UnloadObject,
                        pUnloadObjectTask,
                        pSR
                        );
            RmTmpDereferenceObject(&pUnloadObjectTask->Hdr, pSR);
            if (PEND(Status))
            {
                break;
            }
    #endif  // !OBSOLETE
    
        }
    #if OBSOLETE // See  03/26/1999 notes.txt entry "Some proposed ..."
        while (FALSE);
    #else   // !OBSOLETE
        while (TRUE);
    #endif  // !OBSOLETE

    }   // if(fContinueUnload)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}

#if RM_EXTRA_CHECKING

BOOLEAN
rmDbgAssociationCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    )
/*++

Routine Description:

    Comparison function used to test for exact equality of items
    in the debug association table.

Arguments:

    pKey        - Actually  a pointer to an RM_PRIVATE_DBG_ASSOCIATION structure.
    pItem       - Points to RM_PRIVATE_DBG_ASSOCIATION.HashLink.

Return Value:

    TRUE IFF the (Entity1, Entity2 and AssociationID) fields of the key
    exactly match the corresponding fields of 
    CONTAINING_RECORD(pItem, RM_PRIVATE_DBG_ASSOCIATION, HashLink);

--*/
{
    RM_PRIVATE_DBG_ASSOCIATION *pA =
             CONTAINING_RECORD(pItem, RM_PRIVATE_DBG_ASSOCIATION, HashLink);

    // pKey is actually a RM_PRIVATE_DBG_ASSOCIATION structure.
    //
    RM_PRIVATE_DBG_ASSOCIATION *pTrueKey = (RM_PRIVATE_DBG_ASSOCIATION *) pKey;


    if (    pA->Entity1 == pTrueKey->Entity1
        &&  pA->Entity2 == pTrueKey->Entity2
        &&  pA->AssociationID == pTrueKey->AssociationID)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
    
}


ULONG
rmDbgAssociationHash(
    PVOID           pKey
    )
/*++

Routine Description:

    Hash generating function used to compute a ULONG-sized hash from
    key, which is actually  a pointer to an RM_PRIVATE_DBG_ASSOCIATION structure.

Arguments:

    pKey        - Actually  a pointer to an RM_PRIVATE_DBG_ASSOCIATION structure.

Return Value:

    ULONG-sized hash generated from the (Entity1, Entity2 and AssociationID)
    fields of the key.

--*/
{
    // pKey is actually a RM_PRIVATE_DBG_ASSOCIATION structure.
    //
    RM_PRIVATE_DBG_ASSOCIATION *pTrueKey = (RM_PRIVATE_DBG_ASSOCIATION *) pKey;
    ULONG_PTR big_hash;

    big_hash =   pTrueKey->Entity1;
    big_hash ^=  pTrueKey->Entity2;
    big_hash ^=  pTrueKey->AssociationID;

    // Warning: Below, the return value would be truncated in 64-bit.
    // That tolerable because after all this is just a hash.
    // TODO: for 64-bit, consider  xoring hi- and lo- DWORD instead of truncationg.
    //

    return (ULONG) big_hash;
}


// Static hash information use for the hash table (in the diagnostic information
// of each object) that keeps track of associations.
//
RM_HASH_INFO
rmDbgAssociation_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    rmDbgAssociationCompareKey, // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    rmDbgAssociationHash        // pfnHash

};


VOID
rmDbgInitializeDiagnosticInfo(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Allocate and initialize the diagnostic information associated with
    object pObject. This includes initializing the hash table used to keep
    track of arbitrary associations.

--*/
{
    ENTER("InitializeDiagnosticInfo",  0x55db57a2)
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo;

    TR_VERB(("   pObj=0x%p\n", pObject));
    // TODO: use lookaside lists for the allocation of these objects.
    //
    RM_ALLOCSTRUCT(pDiagInfo,   MTAG_DBGINFO);
    if (pDiagInfo != NULL)
    {
        RM_ZEROSTRUCT(pDiagInfo);

        NdisAllocateSpinLock(&pDiagInfo->OsLock);
        RmInitializeHashTable(
            &rmDbgAssociation_HashInfo,
            NULL,   // pAllocationContext
            &pDiagInfo->AssociationTable
            );
        pObject->pDiagInfo  = pDiagInfo;
        pDiagInfo->pOwningObject = pObject;

        // Initialize the per-object log list.
        //
        InitializeListHead(&pDiagInfo->listObjectLog);
    }
}


VOID
rmDbgFreeObjectLogEntries(
        LIST_ENTRY *pObjectLog
)
/*++

Routine Description:

    Remove and free all items from the object log pObjectLog.
    It is assumed that no one is trying  to add items to this log at this time.

--*/
{
    LIST_ENTRY          *pLink=NULL, *pNextLink=NULL;
    
    if (IsListEmpty(pObjectLog))    return;             // EARLY RETURN 

    NdisAcquireSpinLock(&RmGlobals.GlobalOsLock);

    for(
        pLink = pObjectLog->Flink;
        pLink != pObjectLog;
        pLink = pNextLink)
    {
        RM_DBG_LOG_ENTRY    *pLogEntry;
        LIST_ENTRY          *pLinkGlobalLog;

        pLogEntry = CONTAINING_RECORD(pLink,  RM_DBG_LOG_ENTRY,  linkObjectLog);
        pLinkGlobalLog =  &pLogEntry->linkGlobalLog;

        // Remove entry from global log.
        // We don't bother removing the entry from the local log list, because
        //  it's going away anyway.
        //
        RemoveEntryList(pLinkGlobalLog);

        // Move to next entry in object's log (which may not be the next entry
        // in the global log).
        //
        pNextLink = pLink->Flink;

        // Free the buffer in the log entry, if any.
        // TODO: need to use log buffer deallocation function --
        //      See notes.txt  03/07/1999  entry "Registering root objects with RM".
        // For now we assume the this memory was allocated using
        // NdisAllocateMemory[WithTag].
        //
        if (pLogEntry->pvBuf != NULL)
        {
            NdisFreeMemory(pLogEntry->pvBuf, 0, 0);
        }

        // Free the log entry itself.
        //
        rmDbgDeallocateLogEntry(pLogEntry);
        
    }
    NdisReleaseSpinLock(&RmGlobals.GlobalOsLock);
}


VOID
rmDbgDeinitializeDiagnosticInfo(
    PRM_OBJECT_HEADER pObject,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

        (Debug only)

        Deinitialize and free  the diagnostic information associated with
        object pObject. This includes verifying that there are no remaining
        associations and links.
--*/
{
    ENTER("DeinitializeDiagnosticInfo", 0xa969291f)
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo = pObject->pDiagInfo;

    TR_VERB((" pObj=0x%p\n", pObject));
    if (pDiagInfo != NULL)
    {

        // Free all the per-object log entries.
        // Note: no one should be trying to add items to this log at this time
        // because we're aboute to deallocate this object.
        //
        {
            rmDbgFreeObjectLogEntries(&pDiagInfo->listObjectLog);
            RM_ZEROSTRUCT(&pDiagInfo->listObjectLog);
        }


        if (pDiagInfo->AssociationTable.NumItems != 0)
        {
            //
            // Ouch! Associations still left. We print out the associations and then
            // DebugBreak.
            //

            TR_FATAL((
                "FATAL: Object 0x%p still has some associations left!\n",
                pObject
                ));
            RmDbgPrintAssociations(pObject, pSR);
            ASSERT(!"Object has associations left at deallocation time.");
        }

        pObject->pDiagInfo = NULL;

        RmDeinitializeHashTable(
            &pDiagInfo->AssociationTable
            );

        //
        // Add any other checks here...
        //

        NdisFreeSpinLock(&pDiagInfo->OsLock);
        RM_FREE(pDiagInfo);
    }
}


VOID
rmDbgPrintOneAssociation (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Dump a single association.

Arguments:

    pLink       -  Points to RM_PRIVATE_DBG_ASSOCIATION.HashLink.
    pvContext   -  Unused

--*/
{
    RM_PRIVATE_DBG_ASSOCIATION *pA =
                    CONTAINING_RECORD(pLink, RM_PRIVATE_DBG_ASSOCIATION, HashLink);
    DbgPrint(
        (char*) (pA->szFormatString),
        pA->Entity1,
        pA->Entity2,
        pA->AssociationID
        );
}


VOID
rmDefaultDumpEntry (
    char *szFormatString,
    UINT_PTR Param1,
    UINT_PTR Param2,
    UINT_PTR Param3,
    UINT_PTR Param4
)
/*++

Routine Description:

    Default function to dump the contents of an association.

--*/
{
    DbgPrint(
        szFormatString,
        Param1,
        Param2,
        Param3,
        Param4
        );
}

UINT
rmSafeAppend(
    char *szBuf,
    const char *szAppend,
    UINT cbBuf
)
/*++

Routine Description:

    Append szAppend to szBuf, but don't exceed cbBuf, and make sure the 
    resulting string is null-terminated.

Return Value:

    Total length of string (excluding null termination) after append.

--*/
{
    UINT uRet;
    char *pc = szBuf;
    char *pcEnd = szBuf+cbBuf-1;    // possible overflow, but we check below.
    const char *pcFrom = szAppend;

    if (cbBuf==0) return 0;             // EARLY RETURN;

    // Skip to end of szBuf
    //
    while (pc < pcEnd && *pc!=0)
    {
        pc++;
    }

    // Append szAppend
    while (pc < pcEnd && *pcFrom!=0)
    {
        *pc++ = *pcFrom++;  
    }

    // Append final zero 
    //
    *pc=0;

    return (UINT) (UINT_PTR) (pc-szBuf);
}

#endif //RM_EXTRA_CHECKING

VOID
rmWorkItemHandler_ResumeTaskAsync(
    IN  PNDIS_WORK_ITEM             pWorkItem,
    IN  PVOID                       pTaskToResume
    )
/*++

Routine Description:

    NDIS work item handler which resumes the give task.

Arguments:

    pWorkItem           - Work item associated with the handler.
    pTaskToResume       - Actually a pointer to the task to resume.

--*/
{
    PRM_TASK pTask  = pTaskToResume;
    UINT_PTR CompletionParam = pTask->AsyncCompletionParam;
    RM_DECLARE_STACK_RECORD(sr)

    ASSERTEX(RMISALLOCATED(&pTask->Hdr), pTask);

#if RM_EXTRA_CHECKING
    //  Undo the association added in RmResumeTasyAsync...
    //
    RmDbgDeleteAssociation(
        0xfc39a878,                             // Location ID
        &pTask->Hdr,                            // pObject
        CompletionParam,                        // Instance1
        (UINT_PTR) pWorkItem,                   // Instance2
        RM_PRIVATE_ASSOC_RESUME_TASK_ASYNC,     // AssociationID
        &sr
        );
#endif // RM_EXTRA_CHECKING

    // Actually resume the task.
    //
    RmResumeTask(pTask, CompletionParam, &sr);

    RM_ASSERT_CLEAR(&sr)
}


VOID
rmTimerHandler_ResumeTaskDelayed(
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    )
/*++

Routine Description:

    NDIS timer handler which resumes the give task.

    WARNING: This handler is also called internally by the RM APIs.
    Implementation notes: -- see notes.txt  07/14/1999 entry.

Arguments:

    SystemSpecific1     - Unused
    FunctionContext     - Actually a pointer to the task to be resumed.
    SystemSpecific2     - Unused
    SystemSpecific3     - Unused

--*/
{
    PRM_TASK pTask  = FunctionContext;
    UINT_PTR CompletionParam = pTask->AsyncCompletionParam;
    RM_DECLARE_STACK_RECORD(sr)

    ASSERTEX(RMISALLOCATED(&pTask->Hdr), pTask);

#if RM_EXTRA_CHECKING
    //  Undo the association added in RmResumeTasyDelayed...
    //
    RmDbgDeleteAssociation(
        0xfc39a878,                             // Location ID
        &pTask->Hdr,                            // pObject
        CompletionParam,                        // Instance1
        (UINT_PTR) NULL,                        // Instance2
        RM_PRIVATE_ASSOC_RESUME_TASK_DELAYED,   // AssociationID
        &sr
        );
#endif // RM_EXTRA_CHECKING

    RMPRIVATELOCK(&pTask->Hdr, &sr);
    ASSERT(RM_CHECK_STATE(pTask, RMTSKDELSTATE_MASK, RMTSKDELSTATE_DELAYED));
    RM_SET_STATE(pTask, RMTSKDELSTATE_MASK, 0);
    RM_SET_STATE(pTask, RMTSKABORTSTATE_MASK, 0);
    RMPRIVATEUNLOCK(&pTask->Hdr, &sr);

    // Actually resume the task.
    //
    RmResumeTask(pTask, CompletionParam, &sr);

    RM_ASSERT_CLEAR(&sr)
}


VOID
rmPrivateTaskDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    )
/*++

Routine Description:

    Free a private task (which was allocated using  rmAllocatePrivateTask.

Arguments:

    pObj    - Actually a pointer to a task of subtype RM_PRIVATE_TASK.

--*/
{
    RM_FREE(pObj);
}


#if RM_EXTRA_CHECKING


RM_DBG_LOG_ENTRY *
rmDbgAllocateLogEntry(VOID)
/*++

Routine Description:

    Allocate an object log entry.

    TODO use lookaside lists, and implement per-component global logs.
    See notes.txt  03/07/1999  entry "Registering root objects with RM".

--*/
{
    RM_DBG_LOG_ENTRY *pLE;
    RM_ALLOCSTRUCT(pLE, MTAG_DBGINFO);
    return  pLE;
}

VOID
rmDbgDeallocateLogEntry(
        RM_DBG_LOG_ENTRY *pLogEntry
        )
/*++

Routine Description:

    Free an object log entry.

    TODO use lookaside lists, and implement per-component global logs.
    See notes.txt  03/07/1999  entry "Registering root objects with RM".

--*/
{
    RM_FREE(pLogEntry);
}
#endif // RM_EXTRA_CHECKING


VOID
rmUpdateHashTableStats(
    PULONG pStats,
    ULONG   LinksTraversed
    )
/*++

Routine Description:

    Update the stats (loword == links traversed, hiword == num accesses)

--*/
{
    ULONG OldStats;
    ULONG Stats;
    
    // Clip LinksTraversed to 2^13, or 8192 
    //
    if (LinksTraversed > (1<<13))
    {
        LinksTraversed = 1<<13;
    }
    
    Stats = OldStats = *pStats;
    
    // If either the loword or hiword of Stats is greater-than 2^13, we
    // intiger-devide both by 2. We're really only interested in the ratio
    // of the two, which is preserved by the division.
    //
    #define rmSTATS_MASK (0x11<<30|0x11<<14)
    if (OldStats & rmSTATS_MASK)
    {
        Stats >>= 1;
        Stats &= ~rmSTATS_MASK;
    }

    // Compute the updated value of stats..
    //  "1<<16" below means "one access"
    //
    Stats += LinksTraversed | (1<<16);

    // Update the stats, but only if they haven't already been updated by
    // someone else. Note that if they HAVE been updated, we will lose this
    // update. Not a big deal as we are not looking for 100% exact statistics here.
    //
    InterlockedCompareExchange(pStats, Stats, OldStats);
}


VOID
rmEnumObjectInGroupHashTable (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    )
/*++
    Hash table enumerator to implement "STRONG" enumeration -- see
    RmEnumerateObjectsInGroup.
--*/
{
    PRM_STRONG_ENUMERATION_CONTEXT pCtxt = (PRM_STRONG_ENUMERATION_CONTEXT)pvContext;

    if (pCtxt->fContinue)
    {
        PRM_OBJECT_HEADER pHdr;
        pHdr = CONTAINING_RECORD(pLink, RM_OBJECT_HEADER, HashLink);
        pCtxt->fContinue = pCtxt->pfnObjEnumerator(
                                    pHdr,
                                    pCtxt->pvCallerContext,
                                    pSR
                                    );
    }
}


VOID
rmConstructGroupSnapshot (
    PRM_HASH_LINK pLink,
    PVOID pvContext,
    PRM_STACK_RECORD pSR
    )
/*++
    Hash table enumerator to construct a snapshot of a group for weak enumeration.
    See RmWeakEnumerateObjectsInGroup.
--*/
{
    PRM_WEAK_ENUMERATION_CONTEXT pCtxt = (PRM_WEAK_ENUMERATION_CONTEXT)pvContext;

    if (pCtxt->ppCurrent < pCtxt->ppEnd)
    {
        PRM_OBJECT_HEADER pHdr;
        pHdr = CONTAINING_RECORD(pLink, RM_OBJECT_HEADER, HashLink);
        RmTmpReferenceObject(pHdr, pSR);
        *pCtxt->ppCurrent = pHdr;
        pCtxt->ppCurrent++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\sys\protocol.c ===
/*++

Copyright(c) 1992  Microsoft Corporation

Module Name:

    protocol.c

Abstract:

    ATM Ethernet PVC driver.

Author:
    ADube - created 


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop


const WCHAR c_szIMMiniportList[]            = L"IMMiniportList";
const WCHAR c_szUpperBindings[]         = L"UpperBindings";


#define MAX_PACKET_POOL_SIZE 0x0000FFFF
#define MIN_PACKET_POOL_SIZE 0x000000FF





VOID
EpvcResetComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_STATUS         Status
    )
/*++

Routine Description:

    Completion for the reset.

Arguments:

    ProtocolBindingContext  Pointer to the adapter structure
    Status                  Completion status

Return Value:

    None.

--*/
{
    PADAPT  pAdapt =(PADAPT)ProtocolBindingContext;

    //
    // We never issue a reset, so we should not be here.
    //
    ASSERT(0);
}



VOID
EpvcRequestComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_REQUEST       pNdisRequest,
    IN  NDIS_STATUS         Status
    )
/*++

Routine Description:

    Completion handler for the previously posted request. All OIDS are completed by and sent to
    the same miniport that they were requested for.
    If Oid == OID_PNP_QUERY_POWER then the data structure needs to returned with all entries =
    NdisDeviceStateUnspecified

Arguments:

    ProtocolBindingContext  Pointer to the adapter structure
    NdisRequest             The posted request
    Status                  Completion status

Return Value:

    None

--*/
{
    ENTER("EpvcRequestComplete", 0x44a78b21)
    
    PEPVC_ADAPTER       pAdapter =(PEPVC_ADAPTER)ProtocolBindingContext;
    PEPVC_NDIS_REQUEST  pEpvcRequest = (PEPVC_NDIS_REQUEST  )pNdisRequest;

    RM_DECLARE_STACK_RECORD(sr)

    pEpvcRequest = CONTAINING_RECORD(pNdisRequest, EPVC_NDIS_REQUEST, Request);
    pEpvcRequest->Status = Status;

    if (pEpvcRequest->pFunc == NULL)
    {
        //
        // Unblock the calling thread
        //
        NdisSetEvent(&pEpvcRequest ->Event);
    }
    else
    {

        //
        // Invoke the REquest completion handler
        //
        (pEpvcRequest->pFunc) (pEpvcRequest, Status);

    }

    EXIT()
    RM_ASSERT_CLEAR(&sr);
}



VOID
PtStatus(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_STATUS         GeneralStatus,
    IN  PVOID               StatusBuffer,
    IN  UINT                StatusBufferSize
    )
/*++

Routine Description:

    Status handler for the lower-edge(protocol).

Arguments:

    ProtocolBindingContext  Pointer to the adapter structure
    GeneralStatus           Status code
    StatusBuffer            Status buffer
    StatusBufferSize        Size of the status buffer

Return Value:

    None

--*/
{
    PEPVC_ADAPTER     pAdapter =(PEPVC_ADAPTER)ProtocolBindingContext;
    TRACE (TL_T, TM_Pt, ("== PtStatus Status %x", GeneralStatus));

}


VOID
EpvcStatus(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_STATUS         GeneralStatus,
    IN  PVOID               StatusBuffer,
    IN  UINT                StatusBufferSize
    )
/*++

Routine Description:

    Status handler for the lower-edge(protocol).

    Call the Status indication function of all the miniports
    associated with this adapter
    
Arguments:

    ProtocolBindingContext  Pointer to the adapter structure
    GeneralStatus           Status code
    StatusBuffer            Status buffer
    StatusBufferSize        Size of the status buffer

Return Value:

    None

--*/
{

    ENTER ("EpvcStatus",0x733e2f9e)     
    PEPVC_ADAPTER               pAdapter =(PEPVC_ADAPTER)ProtocolBindingContext;
    PEPVC_WORKITEM              pWorkItem = NULL;
    STATUS_INDICATION_CONTEXT   Context;
    BOOLEAN                     bDoNotProcess = FALSE;
    BOOLEAN                     bIsMediaEvent = FALSE;
    NDIS_MEDIA_STATE            NewMediaState;
    
    RM_DECLARE_STACK_RECORD(SR);

    //
    // Store the parameter, these will be passed to the miniports
    // 
    Context.StatusBuffer = StatusBuffer ;
    Context.StatusBufferSize = StatusBufferSize;
    Context.GeneralStatus = GeneralStatus;

    do
    {
        LOCKOBJ(pAdapter, &SR);

        //
        // Check for 2 conditions i Is it a Media event and 
        // 2) if it is a  repeat indication
        //
        bIsMediaEvent = (GeneralStatus == NDIS_STATUS_MEDIA_CONNECT  ||
                         GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT );

        //
        // Check for repitions next
        //

        if (GeneralStatus == NDIS_STATUS_MEDIA_CONNECT && 
            pAdapter->info.MediaState == NdisMediaStateConnected)
        {
            bDoNotProcess = TRUE;
        }


        if (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT && 
            pAdapter->info.MediaState == NdisMediaStateDisconnected)
        {
            bDoNotProcess = TRUE;
        }

        //
        // Convert the Media Status into an NdisMediaState
        //
        if (bIsMediaEvent == TRUE && bDoNotProcess == FALSE)
        {
            if (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT )
            {
                pAdapter->info.MediaState = NdisMediaStateDisconnected;
            }
            if (GeneralStatus == NDIS_STATUS_MEDIA_CONNECT)
            {
                pAdapter->info.MediaState = NdisMediaStateConnected;
            }
            
        }

        
        //
        // Update the Media state, if we have a new state
        //

        UNLOCKOBJ(pAdapter, &SR);


        if (bDoNotProcess == TRUE)
        {
            break;
        }

        
        epvcEnumerateObjectsInGroup(&pAdapter->MiniportsGroup, 
                                      epvcProcessStatusIndication ,
                                      (PVOID)&Context, 
                                      &SR);

    } while (FALSE);
                                      

    RM_ASSERT_CLEAR(&SR);
    EXIT()
    return;
}


INT
epvcProcessStatusIndication (
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    Status handler for the lower-edge(protocol).

    If we get a media connect, we queue a task to do the Vc Setup

    If we get a media disconnect, we queue a task to tear the VC down

Arguments:

    ProtocolBindingContext  Pointer to the adapter structure
    GeneralStatus           Status code
    StatusBuffer            Status buffer
    StatusBufferSize        Size of the status buffer

Return Value:

    None

--*/
{
    PEPVC_I_MINIPORT            pMiniport           = (PEPVC_I_MINIPORT)pHdr;
    PEPVC_ADAPTER               pAdapter            = pMiniport->pAdapter;
    BOOLEAN                     fIsMiniportActive   = FALSE;
    PSTATUS_INDICATION_CONTEXT  pContext            = (PSTATUS_INDICATION_CONTEXT)pvContext ;
    NDIS_STATUS                 GeneralStatus       = pContext->GeneralStatus;

    
    do
    {
        //
        // if this is not a media indication pass it up to ndis.
        //

        fIsMiniportActive  = MiniportTestFlag(pMiniport, fMP_MiniportInitialized);


        if (fIsMiniportActive == FALSE)
        {
            break;
        }

  
        //
        //  Only pass up an indication if the miniport has been initialized
        //


        //
        // Filter out a duplicate Indication
        //
        if (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT && 
            pMiniport->info.MediaState == NdisMediaStateDisconnected)
        {
            break;
        }

        
        if (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT && 
            pMiniport->info.MediaState == NdisMediaStateDisconnected)
        {
            break;
        }

        //
        // Record the status and indicate it up to the protocols
        //
        if (GeneralStatus == NDIS_STATUS_MEDIA_CONNECT)
        {
            pMiniport->info.MediaState = NdisMediaStateConnected;
        }
        
        if (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT ) 
        {
            pMiniport->info.MediaState = NdisMediaStateDisconnected;
        }
     
        epvcMIndicateStatus(pMiniport,
                                 GeneralStatus,
                                 pContext->StatusBuffer, 
                                 pContext->StatusBufferSize
                                 );
     


    } while (FALSE);

    //
    // As we continue the iteration, return TRUE
    //
    return TRUE;
}


VOID
epvcMediaWorkItem(
    PNDIS_WORK_ITEM pWorkItem, 
    PVOID Context
    )
/*++

Routine Description:

    Status handler for the lower-edge(protocol).

    If we get a media connect, we queue a task to do the Vc Setup

    If we get a media disconnect, we queue a task to tear the VC down

Arguments:

    ProtocolBindingContext  Pointer to the adapter structure
    GeneralStatus           Status code
    StatusBuffer            Status buffer
    StatusBufferSize        Size of the status buffer

Return Value:

    None

--*/
{

    ASSERT (0);
}




INT
epvcMiniportIndicateStatusComplete(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

 Indicate the status upto the protocols

Arguments:


Return Value:


--*/
{
    PEPVC_I_MINIPORT pMiniport = (PEPVC_I_MINIPORT) pHdr;

    BOOLEAN fIsMiniportActive  = MiniportTestFlag(pMiniport, fMP_MiniportInitialized);

    //
    //  Only pass up an indication if the miniport has been initialized
    //
    
    if (fIsMiniportActive  == TRUE )
    {   
        NdisMIndicateStatusComplete(pMiniport->ndis.MiniportAdapterHandle);
    }   

    return TRUE;
}



VOID
PtStatusComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    ENTER("PtStatusComplete", 0x5729d194)
    PEPVC_ADAPTER pAdapter = (PEPVC_ADAPTER) ProtocolBindingContext;
    RM_DECLARE_STACK_RECORD(SR);
    
    //
    // Iterate through all the miniports and stop them
    //

    epvcEnumerateObjectsInGroup (&pAdapter->MiniportsGroup,
                                  epvcMiniportIndicateStatusComplete,
                                  NULL,
                                  &SR   );



}






VOID
PtTransferDataComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_PACKET        Packet,
    IN  NDIS_STATUS         Status,
    IN  UINT                BytesTransferred
    )
/*++

Routine Description:


Arguments:

Return Value:

--*/
{
    PEPVC_I_MINIPORT pMiniport =(PEPVC_I_MINIPORT )ProtocolBindingContext;

    
    if(pMiniport->ndis.MiniportAdapterHandle)
    {
          NdisMTransferDataComplete(pMiniport->ndis.MiniportAdapterHandle,
                                             Packet,
                                             Status,
                                             BytesTransferred);
    }
}






NDIS_STATUS
PtReceive(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_HANDLE         MacReceiveContext,
    IN  PVOID               HeaderBuffer,
    IN  UINT                HeaderBufferSize,
    IN  PVOID               LookAheadBuffer,
    IN  UINT                LookAheadBufferSize,
    IN  UINT                PacketSize
    )
/*++

Routine Description:
LBFO - need to use primary for all receives

Arguments:


Return Value:

--*/
{
    PADAPT          pAdapt =(PADAPT)ProtocolBindingContext;
    PNDIS_PACKET    MyPacket, Packet;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;

    if(!pAdapt->ndis.MiniportAdapterHandle)
    {
        Status = NDIS_STATUS_FAILURE;
    }

    return Status;
}


VOID
PtReceiveComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext
    )
/*++

Routine Description:

    Called by the adapter below us when it is done indicating a batch of received buffers.

Arguments:

    ProtocolBindingContext  Pointer to our adapter structure.

Return Value:

    None

--*/
{
    PADAPT      pAdapt =(PADAPT)ProtocolBindingContext;

}


INT
PtReceivePacket(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_PACKET        Packet
    )
/*++

Routine Description:

    ReceivePacket handler. Called up by the miniport below when it supports NDIS 4.0 style receives.
    Re-package the packet and hand it back to NDIS for protocols above us. The re-package part is
    important since NDIS uses the WrapperReserved part of the packet for its own book-keeping. Also
    the re-packaging works differently when packets flow-up or down. In the up-path(here) the protocol
    reserved is owned by the protocol above. We need to use the miniport reserved here.

Arguments:

    ProtocolBindingContext  Pointer to our adapter structure.
    Packet - Pointer to the packet

Return Value:

    == 0 -> We are done with the packet
    != 0 -> We will keep the packet and call NdisReturnPackets() this many times when done.
--*/
{
    PADAPT          pAdapt =(PADAPT)ProtocolBindingContext;
    NDIS_STATUS Status;
    PNDIS_PACKET    MyPacket;
    PEPVC_PKT_CONTEXT           Resvd;

          return 0;
}






//--------------------------------------------------------------------------------
//                                                                              //
//  Address Family - Entry points and Tasks                                     //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------



VOID
EpvcAfRegisterNotify(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PCO_ADDRESS_FAMILY      pAddressFamily
    )
/*++

Routine Description:

    This informs us that the Call manager is bound to a NIC. and that the call 
    manager is telling us that it is ready to accepts calls.

    We expect there to be one interesting Address Family per underlying adapter
    
Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : UnbindContext

--*/
{
    ENTER("EpvcAfRegisterNotify", 0xaea79b12)

    PEPVC_ADAPTER pAdapter = (PEPVC_ADAPTER) ProtocolBindingContext;
    
    RM_DECLARE_STACK_RECORD(SR);

    TRACE (TL_T, TM_Pt,("==>EpvcAfRegisterNotify\n"));


    do 
    {
        
        if (pAddressFamily->AddressFamily != CO_ADDRESS_FAMILY_Q2931)
        {
            //
            // The call manager is not indicating the address family for an atm 
            // miniport. We are not interested 
            //
            break;
        }

        LOCKOBJ(pAdapter, &SR);

        RmTmpReferenceObject(&pAdapter->Hdr, &SR);


        pAdapter->af.AddressFamily = *pAddressFamily;

        //
        //Begin a task that will call NdisClOpenAddressFamily asynchronously
        //
        UNLOCKOBJ(pAdapter, &SR);

        epvcEnumerateObjectsInGroup(&pAdapter->MiniportsGroup,
                                    epvcAfInitEnumerate,
                                    NULL, // Context
                                    &SR );

        LOCKOBJ(pAdapter, &SR);

        RmTmpDereferenceObject(&pAdapter->Hdr, &SR);
        
        UNLOCKOBJ(pAdapter, &SR);

    } while (FALSE);




    TRACE (TL_T, TM_Pt, ("<==EpvcAfRegisterNotify\n"));

    RM_ASSERT_CLEAR(&SR);

    EXIT()

}


// Enum function
//
INT
epvcAfInitEnumerate(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,  // Unused
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    We have been notified of an acceptable address family

    Iterate through all the miniort structures and open the address family
    and InitDeviceInstance on each of the miniports

    
Arguments:
    

--*/

{
    ENTER("epvcAfInitEnumerate ",0x72eb5b98 )
    PEPVC_I_MINIPORT pMiniport = (PEPVC_I_MINIPORT) pHdr; 
    //
    // Get miniport lock and tmpref it.
    //
    LOCKOBJ(pMiniport, pSR);
    RmTmpReferenceObject(&pMiniport->Hdr, pSR);

    
    do
    {
        NDIS_STATUS Status = NDIS_STATUS_FAILURE;
        PRM_TASK    pTask= NULL;
        PEPVC_ADAPTER pAdapter = (PEPVC_ADAPTER)pMiniport->Hdr.pParentObject;

        ASSERT (pAdapter->Hdr.Sig == TAG_ADAPTER);

        //
        // Allocate task to  complete the unbind.
        //
        Status = epvcAllocateTask(
                    &pMiniport->Hdr,            // pParentObject,
                    epvcTaskStartIMiniport, // pfnHandler,
                    0,                          // Timeout,
                    "Task: Open address Family",    // szDescription
                    &pTask,
                    pSR
                    );
    
        if (FAIL(Status))
        {
            // Ugly situation. We'll just leave things as they are...
            //
            pTask = NULL;
            TR_WARN(("FATAL: couldn't allocate unbind task!\n"));
            break;
        }
    
        // Start the task to complete the Open Address Family.
        // No locks must be held. RmStartTask uses up the tmpref on the task
        // which was added by epvcAllocateTask.
        //
        UNLOCKOBJ(pMiniport, pSR);
        
        ((PTASK_AF) pTask)->pAf= &pAdapter->af.AddressFamily ;
        ((PTASK_AF) pTask)->Cause = TaskCause_AfNotify;
        RmStartTask(pTask, 0, pSR);

        LOCKOBJ(pMiniport, pSR);
    
    } while(FALSE);

    UNLOCKOBJ(pMiniport, pSR);
    RmTmpDereferenceObject(&pMiniport->Hdr, pSR);
    EXIT()

    //
    // As we want the enumeration to cotinue
    //
    return TRUE;

}



NDIS_STATUS
epvcTaskStartIMiniport(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler for opening address families on an underlying adapters.
    The number of address families instantiated is determined by the 
    configuration read in the registry

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : UnbindContext

--*/
{

    ENTER("epvcTaskStartIMiniport", 0xaac34d81)
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    PEPVC_I_MINIPORT    pMiniport   = (PEPVC_I_MINIPORT ) RM_PARENT_OBJECT(pTask);
    NDIS_STATUS         InitStatus  = NDIS_STATUS_SUCCESS;
    PTASK_AF            pAfTask     = (PTASK_AF) pTask;
    NDIS_HANDLE         NdisAfHandle = NULL;
    PEPVC_ADAPTER       pAdapter = pMiniport->pAdapter;
    ULONG               State = pTask->Hdr.State;

    enum 
    {
        Stage_Start =0, // default
        Stage_OpenAfComplete,
        Stage_CloseAfComplete, // In case of failure
        Stage_TaskCompleted,
        Stage_End       
    
    }; // To be used in pTask->Hdr.State to indicate the state of the Task


    TRACE ( TL_T, TM_Pt, ("==>epvcTaskStartIMiniport Code %x", Code) );
    
    TRACE (TL_V, TM_Pt, ("epvcTaskStartIMiniport Task %p Task is in state %x\n", pTask, pTask->Hdr.State));

    
    switch(pTask->Hdr.State)
    {
    
        case Stage_Start:
        {
            //
            // is there another open address family task active
            //
            LOCKOBJ (pMiniport, pSR);
            
            if (epvcIsThisTaskPrimary ( pTask, &(PRM_TASK)(pMiniport->af.pAfTask)) == FALSE)
            {
                PRM_TASK pOtherTask = (PRM_TASK)(pMiniport->af.pAfTask);
                
                RmTmpReferenceObject (&pOtherTask->Hdr, pSR);

                //
                // Set The state so we restart this code after main task completes 
                //

                pTask->Hdr.State = Stage_Start;
                UNLOCKOBJ(pMiniport, pSR);

                

                RmPendTaskOnOtherTask (pTask, 0, pOtherTask, pSR);

                RmTmpDereferenceObject(&pOtherTask->Hdr,pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // We are the primary task
            //
            ASSERT (pMiniport->af.pAfTask == pAfTask);

            //
            // make sure we are bound to the adapter below. If not exit
            //
            if (CHECK_AD_PRIMARY_STATE (pAdapter, EPVC_AD_PS_INITED) == FALSE &&
                pAdapter->bind.BindingHandle == NULL)
            {
                //
                // quietly exit as the protocol is not bound to the adapter below
                //
                UNLOCKOBJ(pMiniport, pSR);
                pTask->Hdr.State = Stage_TaskCompleted;   // we're finished.
                Status = NDIS_STATUS_SUCCESS; // Exit
                break;
            }

            //
            // Check to see if our work is already done
            //


            if (MiniportTestFlag (pMiniport, fMP_AddressFamilyOpened) == TRUE)
            {
                //
                // quietly exit as the address family is already Opened
                //
                UNLOCKOBJ(pMiniport, pSR);
                pTask->Hdr.State = Stage_TaskCompleted;   // we're finished.
                Status = NDIS_STATUS_SUCCESS; // Exit
                break;
            }


            UNLOCKOBJ(pMiniport,pSR);
            
            //
            // Get Ready to suspend the task.
            // First update the state so that the resume
            // will take it to the correct place
            //
            pTask->Hdr.State = Stage_OpenAfComplete;
            RmSuspendTask(  pTask, 0 ,pSR);

            //
            // Call Ndis  to open address family
            //
            Status = epvcClOpenAddressFamily(pAdapter->bind.BindingHandle,
                                             &pAdapter->af.AddressFamily,
                                             (NDIS_HANDLE)pMiniport,
                                             &EpvcGlobals.ndis.CC,
                                             sizeof (EpvcGlobals.ndis.CC),
                                             &NdisAfHandle
                                             );

            if (PEND(Status)== FALSE)
            {
                //
                // Call the completion handler
                //
                EpvcCoOpenAfComplete(Status,
                                   pMiniport,
                                   NdisAfHandle );
                                   
                Status = NDIS_STATUS_PENDING;                                   
            }
            //
            // Now let this thread exit. Make the Async
            // Completion handler complete the task
            //
            
            break;
        }


        case Stage_OpenAfComplete:
        {
            InitStatus = NDIS_STATUS_SUCCESS;

            // 
            // If the status is success then initialize the miniport
            //

            do 
            {
                
                if (pAfTask->ReturnStatus != NDIS_STATUS_SUCCESS)
                {

                    break;
                }

                //
                // Success, so Now initialize the miniport
                //
            
                LOCKOBJ (pMiniport, pSR);
                
                //
                // Set the appropriate flag
                //
                MiniportSetFlag(pMiniport, fMP_DevInstanceInitialized);

                UNLOCKOBJ (pMiniport, pSR);

                RM_ASSERT_NOLOCKS(pSR);

                InitStatus  = NdisIMInitializeDeviceInstanceEx( EpvcGlobals.driver.DriverHandle,
                                                               &pMiniport->ndis.DeviceName,
                                                               pMiniport);  
            } while (FALSE);
            
            //
            // Handle Failure
            //

            if (FAIL(InitStatus) || FAIL(pAfTask->ReturnStatus))
            {
                
                TRACE (TL_V, TM_Mp, ("epvcStartImMiniport Failed Status %x, InitStatus %x",Status, InitStatus));
                
                LOCKOBJ (pMiniport, pSR);

                //
                // Clear the appropriate flags
                //
                
                
                if (MiniportTestFlag(pMiniport, fMP_AddressFamilyOpened)== TRUE)
                {
                    MiniportClearFlag (pMiniport, fMP_AddressFamilyOpened);
                }
                else
                {
                    ASSERT (pMiniport->af.AfHandle == NULL);
                }
                
                UNLOCKOBJ (pMiniport, pSR);

                //
                // Close the Af if there was one.
                //

                if (pMiniport->af.AfHandle != NULL)
                {
                    pTask->Hdr.State = Stage_CloseAfComplete;
                    //
                    // Prepare to so an Async Close Af
                    //
                    RmSuspendTask (pTask, 0, pSR);
                    //
                    // Close Address Family
                    //

                    Status = epvcClCloseAddressFamily(pMiniport->af.AfHandle);

                    if (Status != NDIS_STATUS_PENDING)
                    {
                     
                        EpvcCoCloseAfComplete(Status,pMiniport );

                        Status = NDIS_STATUS_PENDING;                                       



                    }

                    break;

                }
            }

            //
            // We've finished task;
            //


            //
            // Fall through
            //
        }
        case Stage_CloseAfComplete: 
        {
            pTask->Hdr.State = Stage_TaskCompleted;
            Status = NDIS_STATUS_SUCCESS;


        }
        case Stage_End:
        {
            Status = NDIS_STATUS_SUCCESS;   
            break;
        }

        
        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        



    }

    if (pTask->Hdr.State == Stage_TaskCompleted)
    {
        pTask->Hdr.State = Stage_End;

        
        LOCKOBJ(pMiniport, pSR);

        pMiniport->af.pAfTask   = NULL;

        UNLOCKOBJ(pMiniport, pSR);

        ASSERT (Status == NDIS_STATUS_SUCCESS);
    }
    


    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    TRACE ( TL_T, TM_Pt, ("<==epvcTaskStartIMiniport Status %x", Status) );


    return Status;
}



NDIS_STATUS
epvcTaskCloseIMiniport(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )

/*++

Routine Description:

    This is the task that Closes the miniport, the Device Instance and 
    the Address Family/

    There are three reason that the task could be called.
    1) Miniport Halt -MiniportInstance functions need not be called
    2) Protocol Unbind- MiniportInstance functions HAVE to be called
    3) CloseAddress Family - Miniport function are already called

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : UnbindContext

--*/

{
    ENTER ("epvcTaskCloseIMiniport", 0x83342651)
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    PEPVC_I_MINIPORT    pMiniport   = (PEPVC_I_MINIPORT ) RM_PARENT_OBJECT(pTask);
    PTASK_AF            pAfTask     = (PTASK_AF) pTask;
    BOOLEAN             fNeedToHalt  = FALSE;
    BOOLEAN             fNeedToCancel = FALSE;
    ULONG               State;
    BOOLEAN             fAddressFamilyOpened = FALSE;
    BOOLEAN             fIsDevInstanceInitialized = FALSE;
    BOOLEAN             fIsMiniportHalting = FALSE;

    enum 
    {
        Stage_Start =0, // default
        Stage_CloseAddressFamilyCompleted,
        Stage_TaskCompleted,
        Stage_End       
    
    }; // To be used in pTask->Hdr.State to indicate the state of the Task

    TRACE ( TL_T, TM_Pt, ("==> epvcTaskCloseIMiniport State %x", pTask->Hdr.State) );

    State = pTask->Hdr.State;
    
    switch(pTask->Hdr.State)
    {
        case Stage_Start:
        {
            //
            // Check to see if the miniport has already opened an address family.
            // If so exit
            //
            LOCKOBJ (pMiniport, pSR );

            
            if (epvcIsThisTaskPrimary ( pTask, &(PRM_TASK)(pMiniport->af.pAfTask)) == FALSE)
            {
                PRM_TASK pOtherTask = (PRM_TASK)(pMiniport->af.pAfTask);
                

                RmTmpReferenceObject (&pOtherTask->Hdr, pSR);
                
            
                //
                // Set The state so we restart this code after main task completes 
                //

                pTask->Hdr.State = Stage_Start;
                UNLOCKOBJ(pMiniport, pSR);

                

                RmPendTaskOnOtherTask (pTask, 0, pOtherTask, pSR);

                RmTmpDereferenceObject(&pOtherTask->Hdr,pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // We are the primary task
            //
            ASSERT (pMiniport->af.pAfTask == pAfTask);
            //
            // Check to see if our work is already done
            //


            if (MiniportTestFlag (pMiniport, fMP_AddressFamilyOpened) == FALSE)
            {
                //
                // quietly exit as the address family is already closed
                //
                UNLOCKOBJ(pMiniport, pSR);
                State = Stage_TaskCompleted;   // we're finished.
                Status = NDIS_STATUS_FAILURE; // Exit
                break;
            }

            fIsDevInstanceInitialized  = MiniportTestFlag (pMiniport, fMP_DevInstanceInitialized);            

            fIsMiniportHalting  = (pAfTask->Cause == TaskCause_MiniportHalt );
            
            //
            // Now do we need to halt the miniport. - 
            // Q1. Are we are in the middle of a Halt 
            // Q2. Has Our Miniport Instance been initialized  - 
            //        Has miniportInitialize been called - then DeInit the miniport
            //        If not then - cancel the Device Instance
            //
            if ((TRUE == fIsDevInstanceInitialized ) && 
                ( FALSE ==fIsMiniportHalting) )
            {
                if (MiniportTestFlag (pMiniport, fMP_MiniportInitialized) == TRUE)
                {
                    //
                    // Our Halt Handler has not been called,
                    //
                    fNeedToHalt = TRUE;
                    
                }
                else
                {
                    //
                    // Our miniport's initalized handler has not been called 
                    //
                    //
                    // We are not in the middle of a halt, so this probably
                    // an unbind .
                    //
                    fNeedToCancel = TRUE;
                
                }
                
                //
                // Clear the Device Instance flag.
                //
                MiniportClearFlag (pMiniport, fMP_DevInstanceInitialized);

            }                

            //
            // Mark the address family as closed ,because this task will close it.
            //

            fAddressFamilyOpened = MiniportTestFlag (pMiniport, fMP_AddressFamilyOpened);

            MiniportClearFlag (pMiniport, fMP_AddressFamilyOpened);
    

            UNLOCKOBJ(pMiniport,pSR);

            
            //
            // Call Ndis to Deinitialize the miniport, The miniport is already Refed
            //
            TRACE ( TL_T, TM_Pt, ("epvcTaskCloseIMiniport  ----") );

            if (TRUE == fNeedToHalt )
            {
                epvcIMDeInitializeDeviceInstance(pMiniport);
            }
            
            if (TRUE== fNeedToCancel)
            {
                ASSERT (!" Need To cancel in Task close Miniport");
                epvcCancelDeviceInstance(pMiniport, pSR);
            }

            //
            // Now close the address family asynchronously. 
            // First suspend this task
            //
            pTask->Hdr.State = Stage_CloseAddressFamilyCompleted;
            RmSuspendTask (pTask, 0 , pSR);

            if (fAddressFamilyOpened == TRUE)
            {
                
                //
                // We need to start a task to complete the Close Call And DeleteVC
                //

                Status = epvcClCloseAddressFamily(pMiniport->af.AfHandle);

                if (Status != NDIS_STATUS_PENDING)
                {
                    EpvcCoCloseAfComplete(Status, pMiniport);
                    Status = NDIS_STATUS_PENDING;
                }
                
                
            }
            else
            {
                State = Stage_TaskCompleted;   // we're finished.
                Status = NDIS_STATUS_SUCCESS; // Exit


            }
                
            //
            // End this thread. If this thread is closing the addres family
            // then we exit. If not, then we do the cleanup below
            //
            break;
                
        }
        case Stage_CloseAddressFamilyCompleted:
        {
            Status = pAfTask->ReturnStatus;

            State = Stage_TaskCompleted ;
            break;
        
        }

        case Stage_End:
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        

    }


    if (Stage_TaskCompleted == State )
    {
        pTask->Hdr.State = Stage_End;
        Status = NDIS_STATUS_SUCCESS;


        //
        // Clear the task here
        //
        
        LOCKOBJ (pMiniport, pSR);

        pMiniport->af.pAfTask   = NULL;

        UNLOCKOBJ (pMiniport, pSR);


        //
        // Set the complete event here
        //
            
        if (pAfTask->Cause == TaskCause_ProtocolUnbind)
        {
            epvcSetEvent (&pAfTask->CompleteEvent);

        }

        if (pAfTask->Cause == TaskCause_AfCloseRequest)
        {
            //
            // Nothing to do 
            //
    
        }

    }


    RM_ASSERT_NOLOCKS(pSR);

    TRACE ( TL_T, TM_Pt, ("<== epvcTaskCloseIMiniport Status %x", Status) );
    
    EXIT();
    return Status;
}



VOID
epvcInstantiateMiniport(
    IN PEPVC_ADAPTER pAdapter, 
    NDIS_HANDLE MIniportConfigHandle,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    This routine goes to the registry and reads the device name for the IM miniport. 
    It then allocates a structure for it. 

    If the allocation fails, it quietly returns as there is no more work to be done. 
    (Maybe we should deregister the protocol)

Arguments:


Return Value:

    None.

--*/
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE; 
    PEPVC_I_MINIPORT    pMiniport = NULL;
    NDIS_STRING UpperBindings;
    PNDIS_CONFIGURATION_PARAMETER pParameterValue = NULL;
    EPVC_I_MINIPORT_PARAMS Params;

    TRACE (TL_T, TM_Mp, ("==> epvcInstantiateMiniport pAdapter %p KeyName %p \n", pAdapter));

    do
    {

        


        //
        // Now read the upper bindings
        //

        NdisInitUnicodeString(&UpperBindings, c_szUpperBindings);

        NdisReadConfiguration(
                &NdisStatus,
                &pParameterValue,
                MIniportConfigHandle,
                &UpperBindings,
                NdisParameterString);



        if (NDIS_STATUS_SUCCESS != NdisStatus)
        {
            TRACE (TL_T, TM_Mp, (" epvcInstantiateMiniport NdisReadConfiguration Failed"));
            break;

        }

        TRACE (TL_I, TM_Pt, ("Creating Miniport Adapter %x, KeyName: len %d, max %d, name: [%ws]\n",
                       pAdapter,
                       pParameterValue->ParameterData.StringData.Length,
                       pParameterValue->ParameterData.StringData.MaximumLength,
                       (unsigned char*)pParameterValue->ParameterData.StringData.Buffer)); 

        //
        // Check and see if we already have a miniport
        //
        
        RmLookupObjectInGroup(  &pAdapter->MiniportsGroup, 
                                0 , // no flags (not locked)
                                &pParameterValue->ParameterData.StringData,
                                NULL,
                                &(PRM_OBJECT_HEADER)pMiniport,
                                NULL,
                                pSR
                                );
        if (pMiniport!= NULL)
        {
            //
            // we already have a miniport, therefore exit.
            //
            break;
        }

        //
        // Create and Initialize the miniport here
        //

        
        Params.pDeviceName = &pParameterValue->ParameterData.StringData;
        Params.pAdapter = pAdapter;
        Params.CurLookAhead = pAdapter->info.MaxAAL5PacketSize;
        Params.NumberOfMiniports = (NdisInterlockedIncrement (&pAdapter->info.NumberOfMiniports) - 1);
        Params.LinkSpeed = pAdapter->info.LinkSpeed;
        Params.MacAddress = pAdapter->info.MacAddress;
        Params.MediaState = pAdapter->info.MediaState;
        
        NdisStatus =  RM_CREATE_AND_LOCK_OBJECT_IN_GROUP(
                        &pAdapter->MiniportsGroup,
                        Params.pDeviceName,     // Key
                        &Params,                    // Init params
                        &((PRM_OBJECT_HEADER)pMiniport),
                        NULL,   // pfCreated
                        pSR
                        );

                        
        if (FAIL(NdisStatus))
        {
            TR_WARN(("FATAL: Couldn't create adapter object\n"));
            pMiniport = NULL;
            break;
        }
            
        UNLOCKOBJ(pMiniport,pSR);       
        
        //
        // Initalize new miniport specific events here
        //
        epvcInitializeEvent (&pMiniport->pnp.HaltCompleteEvent);
        epvcInitializeEvent (&pMiniport->pnp.DeInitEvent);

    } while (FALSE);

    if (FAIL(NdisStatus ) == TRUE)
    {
        //
        // Do nothing
        //
        ASSERT (FAIL(NdisStatus ) == FALSE);

    }
    else
    {
        RmTmpDereferenceObject(&pMiniport->Hdr, pSR);
    }

    TRACE (TL_T, TM_Mp, ("<== epvcInstantiateMiniport pMiniport %p \n", pMiniport));

}












//--------------------------------------------------------------------------------
//                                                                              //
//  Adapter RM Object - Create, Delete, Hash and Compare functions              //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------



PRM_OBJECT_HEADER
epvcAdapterCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    psr
        )
/*++

Routine Description:

    Allocate and initialize an object of type EPVC_ADAPTER.

Arguments:

    pParentObject   - Object that is to be the parent of the adapter.
    pCreateParams   - Actually a pointer to a EPVC_ADAPTER_PARAMS structure,
                      which contains information required to create the adapter.

Return Value:

    Pointer to the allocated and initialized object on success.
    NULL otherwise.

--*/
{
    PEPVC_ADAPTER               pA;
    PEPVC_ADAPTER_PARAMS        pBindParams = (PEPVC_ADAPTER_PARAMS)pCreateParams;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    extern RM_STATIC_OBJECT_INFO EpvcGlobals_AdapterStaticInfo; 
    extern RM_STATIC_OBJECT_INFO EpvcGlobals_I_MiniportStaticInfo ;

    ENTER("AdapterCreate", 0x9cb433f4);

    
    TRACE (TL_V, TM_Pt, ("--> epvcAdapterCreate") );

    EPVC_ALLOCSTRUCT(pA,     TAG_PROTOCOL);
    do
    {


        if (pA == NULL)
        {
            break;
        }

        EPVC_ZEROSTRUCT(pA);

        //
        // Do all the initialization work here
        //

        pA->Hdr.Sig = TAG_ADAPTER; 

        RmInitializeLock(
            &pA->Lock,
            LOCKLEVEL_ADAPTER
            );

        RmInitializeHeader(
            pParentObject,
            &pA->Hdr,
            TAG_ADAPTER,
            &pA->Lock,
            &EpvcGlobals_AdapterStaticInfo,
            NULL,
            psr
            );

        //
        // Now initialize the adapter structure with the parameters 
        // that were passed in.
        //

        // Create up-cased version of the DeviceName and save it.
        //
        //
        Status = epvcCopyUnicodeString(
                            &(pA->bind.DeviceName),
                            pBindParams->pDeviceName,
                            TRUE                        // Upcase
                            );

        if (FAIL(Status))
        {
            pA->bind.DeviceName.Buffer=NULL; // so we don't try to free it later
            break;
        }

        pA->bind.pEpvcConfigName = pBindParams->pEpvcConfigName;

        Status = epvcCopyUnicodeString(
                            &(pA->bind.EpvcConfigName),
                            pBindParams->pEpvcConfigName,
                            FALSE
                            );
                            
        pA->bind.BindContext  = pBindParams->BindContext;

        //
        // Initialize and allocate a group for all the intermediate miniports that 
        // will be instantiated over this physical adapter
        //


        RmInitializeGroup(
                        &pA->Hdr,                               // pOwningObject
                        &EpvcGlobals_I_MiniportStaticInfo ,
                        &(pA->MiniportsGroup),
                        "Intermediate miniports",                       // szDescription
                        psr
                        );



        Status = NDIS_STATUS_SUCCESS;
    }
    while(FALSE);

    if (FAIL(Status))
    {
        if (pA != NULL)
        {
            epvcAdapterDelete ((PRM_OBJECT_HEADER) pA, psr);
            pA = NULL;
        }
    }

    TRACE (TL_V, TM_Pt, ("<-- epvcAdapterCreate pAdpater. %p",pA) );

    return (PRM_OBJECT_HEADER) pA;
}


VOID
epvcAdapterDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Free an object of type EPVC_ADAPTER.

Arguments:

    pHdr    - Actually a pointer to the EPVC_ADAPTER to be deleted.

--*/
{
    PEPVC_ADAPTER pAdapter = (PEPVC_ADAPTER) pObj;

    TRACE (TL_V, TM_Pt, ("-- epvcAdapterDelete  pAdapter %p",pAdapter) );

    pAdapter->Hdr.Sig = TAG_FREED; 


    EPVC_FREE   (pAdapter);
}




BOOLEAN
epvcAdapterCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    )
/*++

Routine Description:

    Hash comparison function for EPVC_ADAPTER.

Arguments:

    pKey        - Points to a Epvc Protocol object.
    pItem       - Points to EPVC_ADAPTER.Hdr.HashLink.

Return Value:

    TRUE IFF the key (adapter name) exactly matches the key of the specified 
    adapter object.

--*/
{
    PEPVC_ADAPTER pA = NULL;
    PNDIS_STRING pName = (PNDIS_STRING) pKey;
    BOOLEAN fCompare;

    pA  = CONTAINING_RECORD(pItem, EPVC_ADAPTER, Hdr.HashLink);

    //
    // TODO: maybe case-insensitive compare?
    //

    if (   (pA->bind.DeviceName.Length == pName->Length)
        && NdisEqualMemory(pA->bind.DeviceName.Buffer, pName->Buffer, pName->Length))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
    

    TRACE (TL_V, TM_Pt, ("-- epvcProtocolCompareKey pAdapter %p, pKey, return %x",pA, pKey, fCompare ) );

    return fCompare;
}



ULONG
epvcAdapterHash(
    PVOID           pKey
    )
/*++

Routine Description:

    Hash function responsible for returning a hash of pKey, which
    we expect to be a pointer to an Epvc Protocol block.

Return Value:

    ULONG-sized hash of the string.
    

--*/
{

    
    PNDIS_STRING pName = (PNDIS_STRING) pKey;
    WCHAR *pwch = pName->Buffer;
    WCHAR *pwchEnd = pName->Buffer + pName->Length/sizeof(*pwch);
    ULONG Hash  = 0;

    for (;pwch < pwchEnd; pwch++)
    {
        Hash ^= (Hash<<1) ^ *pwch;
    }

    return Hash;
}





//--------------------------------------------------------------------------------
//                                                                              //
//  Bind Adapter - Entry Points and Tasks                                       //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------

VOID
EpvcBindAdapter(
    OUT PNDIS_STATUS            pStatus,
    IN  NDIS_HANDLE             BindContext,
    IN  PNDIS_STRING            pDeviceName,
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   SystemSpecific2
    )


/*++

Routine Description:

    This is called by NDIS when it has an adapter for which there is a
    binding to the Epvc Protocol.

    We first allocate an Adapter structure. Then we open our configuration
    section for this adapter and save the handle in the Adapter structure.
    Finally, we open the adapter.

    We then read the registry and find out how many intermediate Miniports are 
    sitting on top of this adapter. Data structures are initialized for these Miniports

    We don't do anything more for this adapter until NDIS notifies us of
    the presence of a Call manager (via our AfRegisterNotify handler).

Arguments:

    pStatus             - Place to return status of this call
    BindContext         - Not used, because we don't pend this call 
    pDeviceName         - The name of the adapter we are requested to bind to
    SystemSpecific1     - Opaque to us; to be used to access configuration info
    SystemSpecific2     - Opaque to us; not used.

Return Value:

    Always TRUE. We set *pStatus to an error code if something goes wrong before 
we
    call NdisOpenAdapter, otherwise NDIS_STATUS_PENDING.

--*/
{
    NDIS_STATUS         Status;
    EPVC_ADAPTER        *pAdapter;
#if DBG
    KIRQL EntryIrql =  KeGetCurrentIrql();
#endif // DBG

    ENTER("BindAdapter", 0xa830f919)
    RM_DECLARE_STACK_RECORD(SR)
    TIMESTAMP("==>BindAdapter");

    

    do 
    {
        PRM_TASK            pTask;
        EPVC_ADAPTER_PARAMS BindParams;

        // Setup initialization parameters
        //
        BindParams.pDeviceName          = pDeviceName;
        BindParams.pEpvcConfigName      = (PNDIS_STRING) SystemSpecific1;
        BindParams.BindContext          = BindContext;


        // Allocate and initialize adapter object.
        // This also sets up ref counts for all linkages, plus one
        // tempref for us, which we must deref when done.
        //
        Status =  RM_CREATE_AND_LOCK_OBJECT_IN_GROUP(
                            &EpvcGlobals.adapters.Group,
                            pDeviceName,                // Key
                            &BindParams,                // Init params
                            &((PRM_OBJECT_HEADER)pAdapter),
                            NULL,   // pfCreated
                            &SR
                            );
        if (FAIL(Status))
        {
            TR_WARN(("FATAL: Couldn't create adapter object\n"));
            pAdapter = NULL;
            break;
        }
    
        // Allocate task to  complete the initialization.
        // The task is tmp ref'd for us, and we must deref it when we're done here.
        // We implicitly do this by calling RmStartTask below.
        //
        Status = epvcAllocateTask(
                    &pAdapter->Hdr,             // pParentObject,
                    epvcTaskInitializeAdapter,  // pfnHandler,
                    0,                          // Timeout,
                    "Task: Initialize Adapter", // szDescription
                    &pTask,
                    &SR
                    );

        if (FAIL(Status))
        {
            pTask = NULL;
            break;
        }

        UNLOCKOBJ(pAdapter, &SR);

        // Start the task to complete this initialization.
        // NO locks must be held at this time.
        // RmStartTask expect's a tempref on the task, which it deref's when done.
        // RmStartTask will free the task automatically, whether it completes
        // synchronously or asynchronously.
        //
        RmStartTask(pTask, 0, &SR);

        TRACE (TL_V, TM_Pt, ("Task InitializeAdapter - Start Task returned %x", Status));
        LOCKOBJ(pAdapter, &SR);

    } while(FALSE);

    if (pAdapter)
    {
        UNLOCKOBJ(pAdapter, &SR);

        if (!PEND(Status) && FAIL(Status))
        {
            // At this point the adapter should be a "zombie object."
            //
            ASSERTEX(RM_IS_ZOMBIE(pAdapter), pAdapter);
        }

        RmTmpDereferenceObject(&pAdapter->Hdr, &SR);

        *pStatus = NDIS_STATUS_PENDING;

    }
    else
    {
        //
        // Fail the bind as the adapter was not allocated
        //
        *pStatus = NDIS_STATUS_FAILURE;
    }
    



#if DBG
    {
        KIRQL ExitIrql =  KeGetCurrentIrql();
        TR_INFO(("Exiting. EntryIrql=%lu, ExitIrql = %lu\n", EntryIrql, ExitIrql));
    }
#endif //DBG

    RM_ASSERT_CLEAR(&SR);
    EXIT()
    TIMESTAMP("<==BindAdapter");
    TRACE (TL_T, TM_Pt, ("<==BindAdapter %x", *pStatus));

    RM_ASSERT_CLEAR(&SR);

    return ;
}



NDIS_STATUS
epvcTaskInitializeAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for initializing an adapter.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    PEPVC_ADAPTER       pAdapter = (PEPVC_ADAPTER) RM_PARENT_OBJECT(pTask);
    PTASK_ADAPTERINIT pAdapterInitTask;

    enum
    {
        STAGE_BecomePrimaryTask,
        STAGE_ActivateAdapterComplete,
        STAGE_DeactivateAdapterComplete,
        STAGE_End

    } Stage;

    ENTER("TaskInitializeAdapter", 0x18f9277a)

    pAdapterInitTask = (PTASK_ADAPTERINIT) pTask;

    TRACE (TL_T, TM_Pt, ("==>epvcTaskInitializeAdapter Code %x \n", Code));

    // 
    // Message normalizing code
    //
    switch(Code)
    {

        case RM_TASKOP_START:
            Stage = STAGE_BecomePrimaryTask;
            break;

        case  RM_TASKOP_PENDCOMPLETE:
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            Stage = RM_PEND_CODE(pTask);
            break;

        case RM_TASKOP_END:
            Status = (NDIS_STATUS) UserParam;
            Stage= STAGE_End;
            break;

        default:
            ASSERT(FALSE);
            return NDIS_STATUS_FAILURE;                 // ** EARLY RETURN **

    }

    ASSERTEX(!PEND(Status), pTask);
        
    switch(Stage)
    {

        case  STAGE_BecomePrimaryTask:
        {
            // If there is a primary task, pend on it, else make ourselves
            // the primary task.
            //
            LOCKOBJ(pAdapter, pSR);
            if (pAdapter->bind.pPrimaryTask == NULL)
            {
                epvcSetPrimaryAdapterTask(pAdapter, pTask, EPVC_AD_PS_INITING, pSR);
                UNLOCKOBJ(pAdapter, pSR);
            }
            else
            {
                PRM_TASK pOtherTask =  pAdapter->bind.pPrimaryTask;
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pAdapter, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    STAGE_BecomePrimaryTask, // we'll try again...
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }
        
            //
            // We're now the  primary task. Since we're starting out,
            // there should be NO activate/deactivate task.
            // (Note: we don't bother getting the adapter lock for these asserts).
            //
            ASSERT(pAdapter->bind.pPrimaryTask == pTask);
            ASSERT(pAdapter->bind.pSecondaryTask == NULL);

            //
            // Allocate and start the activate adapter task.
            //
            {
                PRM_TASK pActivateTask;

                Status = epvcAllocateTask(
                            &pAdapter->Hdr,             // pParentObject,
                            epvcTaskActivateAdapter,        // pfnHandler,
                            0,                          // Timeout,
                            "Task: Activate Adapter(init)", // szDescription
                            &pActivateTask,
                            pSR
                            );
            
                if (FAIL(Status))
                {
                    pActivateTask = NULL;
                    TR_WARN(("FATAL: couldn't alloc activate task!\n"));
                }
                else
                {
                    RmPendTaskOnOtherTask(
                        pTask,
                        STAGE_ActivateAdapterComplete,
                        pActivateTask,              // task to pend on
                        pSR
                        );
            
                    // RmStartTask uses up the tmpref on the task
                    // which was added by arpAllocateTask.
                    //
                    Status = RmStartTask(
                                pActivateTask,
                                0, // UserParam (unused)
                                pSR
                                );
                }
            }
         }


        if (PEND(Status)) break;
        
        // FALL THROUGH TO NEXT STAGE

        case STAGE_ActivateAdapterComplete:
        {
            //
            // We've run the active-adapter task. On failure, we need to
            // cleanup state by calling the deactivate-adapter task.
            //

            // Save away the failure code for later...
            //
            pAdapterInitTask->ReturnStatus = Status;

            if (FAIL(Status))
            {
                PRM_TASK pDeactivateTask;

                Status = epvcAllocateTask(
                                &pAdapter->Hdr,             // pParentObject,
                                epvcTaskDeactivateAdapter,      // pfnHandler,
                                0,                          // Timeout,
                                "Task: Deactivate Adapter(init)", // szDescription
                                &pDeactivateTask,
                                pSR
                                );
            
                if (FAIL(Status))
                {
                    pDeactivateTask = NULL;
                    ASSERT(FALSE); // TODO: use special dealloc task pool for this.
                    TR_WARN(("FATAL: couldn't alloc deactivate task!\n"));
                }
                else
                {

                    RmPendTaskOnOtherTask(
                        pTask,
                        STAGE_DeactivateAdapterComplete,
                        pDeactivateTask,                // task to pend on
                        pSR
                        );
            
                    //
                    // RmStartTask uses up the tmpref on the task
                    // which was added by arpAllocateTask.
                    //
                    Status = RmStartTask(
                                pDeactivateTask,
                                0, // UserParam (unused)
                                pSR
                                );
                }
            }
        }
        break;

        case STAGE_DeactivateAdapterComplete:
        {
        
            //
            // We've completed the deactivate adapter task which we started
            // because of some init-adapter failure.
            //

            // In general, we don't expect the deactivate task to return failure.
            //
            ASSERT(!FAIL(Status));

            // We expect the original status of the init to be a failure (that's
            // why we started the deinit in the first place!
            //
            ASSERT(FAIL(pAdapterInitTask->ReturnStatus));
            Status = pAdapterInitTask->ReturnStatus;

        }
        break;

        case STAGE_End:
        {
            NDIS_HANDLE                 BindContext;

            //
            // We HAVE to be the primary task at this point, becase we simply
            // wait and retry until we become one.
            //

            // Clear the primary task in the adapter object.
            //
            LOCKOBJ(pAdapter, pSR);
            {
                ULONG InitState;
                InitState = FAIL(Status) ? EPVC_AD_PS_FAILEDINIT : EPVC_AD_PS_INITED;
                epvcClearPrimaryAdapterTask(pAdapter, pTask, InitState, pSR);
            }
            BindContext = pAdapter->bind.BindContext;
            UNLOCKOBJ(pAdapter, pSR);


            // On failure, pAdapter should be deallocated.
            //
            if (FAIL(Status))
            {
                if(RM_IS_ZOMBIE(pAdapter))
                {
                    TR_WARN(("END: pAdapter is already deallocated.\n"));
                }
                else
                {
                    //
                    // On failure, free the adapter here itself, because we're
                    // not going to call the shutdown task.
                    //
                    RmFreeObjectInGroup(
                        &EpvcGlobals.adapters.Group,
                        &(pAdapter->Hdr),
                        NULL,               // NULL pTask == synchronous.
                        pSR
                        );
                        
                    pAdapter = NULL;                        
                }
            }

            //
            // Clear out the variables that are valid only
            // during the BindAdapter Call
            //
            if (pAdapter != NULL)
            {
                pAdapter->bind.pEpvcConfigName = NULL;
            }
            // Signal Ndis that the bind is complete.
            //
            NdisCompleteBindAdapter(BindContext ,
                                  Status,
                                  NDIS_STATUS_PENDING);
            TIMESTAMP("== Completing the Adapter Bind");
            RM_ASSERT_NOLOCKS(pSR);

        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    TRACE (TL_T, TM_Pt, ("<==epvcTaskInitializeAdapter Status %x\n", Status));

    return Status;
}


NDIS_STATUS
epvcTaskActivateAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for initializing an adapter.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    PEPVC_ADAPTER       pAdapter = (PEPVC_ADAPTER) RM_PARENT_OBJECT(pTask);

    enum
    {
        PEND_OpenAdapter,
        PEND_GetAdapterInfo
    };
    ENTER("TaskInitializeAdapter", 0xb6ada31d)
    TRACE (TL_T, TM_Pt, ("==>epvcTaskActivateAdapter pAdapter %p Code %x",pAdapter, Code ));

    switch(Code)
    {

        case RM_TASKOP_START:
        {
        
            NDIS_MEDIUM                 Medium = NdisMediumAtm;


            UINT                        SelMediumIndex = 0;
            NDIS_STATUS                 OpenStatus;

            TRACE (TL_T, TM_Pt, (" epvcTaskActivateAdapter RM_TASKOP_START "));


            // Set ourselves as the secondary task.
            //
            LOCKOBJ(pAdapter, pSR);
            epvcSetSecondaryAdapterTask(pAdapter, pTask, EPVC_AD_AS_ACTIVATING, pSR);
            UNLOCKOBJ(pAdapter, pSR);

            //
            // Suspend task and call NdisOpenAdapter...
            //

            RmSuspendTask(pTask, PEND_OpenAdapter, pSR);
            RM_ASSERT_NOLOCKS(pSR);

            epvcOpenAdapter(
                &Status,
                &OpenStatus,
                &pAdapter->bind.BindingHandle,
                &SelMediumIndex,                    // selected medium index
                &Medium,                            // Array of medium types
                1,                                  // Size of Media list
                EpvcGlobals.driver.ProtocolHandle,
                (NDIS_HANDLE)pAdapter,              // our adapter bind context
                &pAdapter->bind.DeviceName,         // pDeviceName
                0,                                  // Open options
                (PSTRING)NULL,                      // Addressing Info...
                pSR);
            
            if (Status != NDIS_STATUS_PENDING)
            {
                EpvcOpenAdapterComplete(
                        (NDIS_HANDLE)pAdapter,
                        Status,
                        OpenStatus
                        );
            }
            Status = NDIS_STATUS_PENDING;
        }
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            PTASK_ADAPTERACTIVATE pAdapterInitTask;
            pAdapterInitTask = (PTASK_ADAPTERACTIVATE) pTask;
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            ASSERT(sizeof(TASK_ADAPTERACTIVATE) <= sizeof(EPVC_TASK));

            
            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_OpenAdapter:
        
                    //
                    // The open adapter operation is complete. Get adapter
                    // information and notify IP on success. On failure,
                    // shutdown the adapter if required, and notify IP of
                    // the failure.
                    //

                    TRACE (TL_T, TM_Pt, (" epvcTaskActivateAdapter RM_TASKOP_PENDCOMPLETE - PEND_OpenAdapter "));


                    if (FAIL(Status))
                    {
                        // Set adapter handle to null -- it may not be hull.
                        // even though the open adapter has succeeded.
                        //
                        pAdapter->bind.BindingHandle = NULL;
                        break;
                    }

                    ASSERT (pAdapter->bind.BindingHandle != NULL);

                    // FALL THROUGH on synchronous completion of arpGetAdapterInfo...

                case PEND_GetAdapterInfo:

                    //
                    // Done with getting adapter info.
                    // We need to switch to passive before going further
                    //
                    TRACE (TL_T, TM_Pt, (" epvcTaskActivateAdapter RM_TASKOP_PENDCOMPLETE - PEND_GetAdapterInfo "));

                    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
                    if (!EPVC_ATPASSIVE())
                    {
                        ASSERT (!"Should not be here");
                        
                        // We're not at passive level, but we need to be when we
                        // call IP's add interface. So we switch to passive...
                        // NOTE: we specify completion code PEND_GetAdapterInfo
                        //       because we want to get back here (except
                        //       we'll be at passive).
                        //
                        /*RmSuspendTask(pTask, PEND_GetAdapterInfo, pSR);
                        RmResumeTaskAsync(
                            pTask,
                            Status,
                            &pAdapterInitTask->WorkItem,
                            pSR
                            );
                        Status = NDIS_STATUS_PENDING;*/
                        break;
                    }
            
                    if (Status == NDIS_STATUS_SUCCESS)
                    {
                        //
                        // Copy over adapter info into pAdapter->info...
                        // Then read configuration information.
                        //

                        //
                        // Query the ATM adapter for HW specific Info
                        //
                        epvcGetAdapterInfo(pAdapter, pSR, NULL);

                        // Read Adapter Configuration Information
                        //
                        Status =  epvcReadAdapterConfiguration(pAdapter, pSR);

                        Status = NDIS_STATUS_SUCCESS;
                    }

                    //
                    // NOTE: if we fail, a higher level task is responsible
                    // for "running the compensating transaction", i.e., running
                    // epvcTaskDeactivateAdapter.
                    //

                // end case  PEND_OpenAdapter, PEND_GetAdapterInfo
                
                break;
    
                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))


        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            
            TRACE (TL_T, TM_Pt, (" epvcTaskActivateAdapter RM_TASKOP_END"));
            Status = (NDIS_STATUS) UserParam;

            // We're done -- the status had better not be pending!
            //
            ASSERTEX(!PEND(Status), pTask);

            // Clear ourselves as the secondary task in the adapter object.
            //
            {
                ULONG InitState;
                LOCKOBJ(pAdapter, pSR);
                InitState = FAIL(Status)
                             ? EPVC_AD_AS_FAILEDACTIVATE
                             : EPVC_AD_AS_ACTIVATED;
                epvcClearSecondaryAdapterTask(pAdapter, pTask, InitState, pSR);
                UNLOCKOBJ(pAdapter, pSR);
            }
            Status = NDIS_STATUS_SUCCESS;
            
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    TRACE (TL_T, TM_Pt, ("<==epvcTaskActivateAdapter Status %x", Status ));

    return Status;
}


VOID
EpvcOpenAdapterComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 Status,
    IN  NDIS_STATUS                 OpenErrorStatus
)
/*++

Routine Description:

    This is called by NDIS when a previous call to NdisOpenAdapter
    that had pended has completed. We now complete the BindAdapter
    that lead to this.

Arguments:

    ProtocolBindingContext  - Our context for this adapter binding, which
                              is a pointer to an EPVC_ADAPTER structure.
    Status                  - Status of OpenAdapter
    OpenErrorStatus         - Error code in case of failure.

--*/
{
    ENTER("OpenAdapterComplete", 0x06d9342c)


    EPVC_ADAPTER    *   pAdapter = (EPVC_ADAPTER*) ProtocolBindingContext;
    RM_DECLARE_STACK_RECORD(SR)


    TIMESTAMP("==>OpenAdapterComplete");
    TRACE ( TL_T, TM_Mp, ("==>OpenAdapterComplete"));

    // We expect a nonzero task here (the bind task), which we unpend.
    // No need to grab locks or anything at this stage.
    //
    {
        TR_INFO((
            "BindCtxt=0x%p, status=0x%p, OpenErrStatus=0x%p",
            ProtocolBindingContext,
            Status,
            OpenErrorStatus
            ));

        // We don't pass on OpenErrorStatus, so we have just the status
        // to pass on, which we do directly as the UINT_PTR "Param".
        //
        RmResumeTask(pAdapter->bind.pSecondaryTask, (UINT_PTR) Status, &SR);
    }

    RM_ASSERT_CLEAR(&SR)
    EXIT()
    TRACE ( TL_T, TM_Mp, ("<==OpenAdapterComplete"));
    TIMESTAMP("<==OpenAdapterComplete");

    RM_ASSERT_CLEAR(&SR);
}



NDIS_STATUS
epvcTaskDeactivateAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for shutting down an IP interface.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : UnbindContext

--*/

{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    EPVC_ADAPTER    *   pAdapter = (EPVC_ADAPTER*) RM_PARENT_OBJECT(pTask);
    BOOLEAN             fContinueShutdown = FALSE;
    enum
    {
        PEND_CloseAdapter
    };
    ENTER("TaskShutdownAdapter", 0xe262e828)
    TRACE ( TL_T, TM_Pt, ("==>epvcTaskDeactivateAdapter Code %x", Code) );

    switch(Code)
    {

        case RM_TASKOP_START:
        {
            NDIS_HANDLE NdisAdapterHandle;

            LOCKOBJ(pAdapter, pSR);
            epvcSetSecondaryAdapterTask(pAdapter, pTask, EPVC_AD_AS_DEACTIVATING, pSR);
            UNLOCKOBJ(pAdapter, pSR);
            fContinueShutdown = TRUE;

            //
            // Iterate through all the miniports and stop them
            //

            epvcEnumerateObjectsInGroup (&pAdapter->MiniportsGroup,
                                          epvcMiniportDoUnbind,
                                          NULL,
                                          pSR   );


            //
            // Close the adapter below
            // 
            LOCKOBJ(pAdapter, pSR);
    
    
            NdisAdapterHandle = pAdapter->bind.BindingHandle;
            pAdapter->bind.BindingHandle = NULL;
            
            UNLOCKOBJ(pAdapter, pSR);

            if (NdisAdapterHandle != NULL)
            {
                //
                // Suspend task and call NdisCloseAdapter...
                //
            
                RmSuspendTask(pTask, PEND_CloseAdapter, pSR);
                RM_ASSERT_NOLOCKS(pSR);

                epvcCloseAdapter(
                    &Status,
                    NdisAdapterHandle,
                    pSR
                    );
            
                if (Status != NDIS_STATUS_PENDING)
                {
                    EpvcCloseAdapterComplete(
                            (NDIS_HANDLE)pAdapter,
                            Status
                            );
                }
                Status = NDIS_STATUS_PENDING;
                    

            }

            break;
        }
        case  RM_TASKOP_PENDCOMPLETE:
        {

            switch(RM_PEND_CODE(pTask))
            {
                case PEND_CloseAdapter:
                {

                    //
                    // The close adapter operation is complete. Free the the
                    // adapter and if there is an unbind context, notify NDIS
                    // of unbind completion.
                    //
                    
                    ASSERTEX(pAdapter->bind.BindingHandle == NULL, pAdapter);

        
                    Status = (NDIS_STATUS) UserParam;
        
                    // Status of the completed operation can't itself be pending!
                    //
                    ASSERT(Status != NDIS_STATUS_PENDING);
                }
                break;

            }
        }
        break;


        case  RM_TASKOP_END:
        {
            Status = (NDIS_STATUS) UserParam;

            // Clear the secondary task in the adapter object.
            //
            LOCKOBJ(pAdapter, pSR);
            epvcClearSecondaryAdapterTask(pAdapter, pTask, EPVC_AD_AS_DEACTIVATED, pSR);
            UNLOCKOBJ(pAdapter, pSR);
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)



    RM_ASSERT_NOLOCKS(pSR);
    EXIT()
    TRACE ( TL_T, TM_Pt, ("<==epvcTaskDeactivateAdapter Status %x", Status) );

    return Status;
}




VOID
EpvcCloseAdapterComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 Status
)
/*++

Routine Description:

    This is called by NDIS when a previous call to NdisCloseAdapter
    that had pended has completed. The task that called NdisCloseAdapter
    would have suspended itself, so we simply resume it now.

Arguments:

    ProtocolBindingContext  - Our context for this adapter binding, which
                              is a pointer to an EPVC_ADAPTER structure.
    Status                  - Status of CloseAdapter

Return Value:

    None

--*/
{
    ENTER("CloseAdapterComplete", 0xe23bfba7)
    PEPVC_ADAPTER       pAdapter = (PEPVC_ADAPTER) ProtocolBindingContext;
    RM_DECLARE_STACK_RECORD(sr)

    TIMESTAMP("==>CloseAdapterComplete");
    TRACE (TL_T, TM_Pt, ("== EpvcCloseAdapterComplete"));

    LOCKOBJ (pAdapter, &sr);

    AdapterSetFlag (pAdapter,EPVC_AD_INFO_AD_CLOSED);

    UNLOCKOBJ (pAdapter, &sr);
    // We expect a nonzero task here (UNbind task), which we unpend.
    // No need to grab locks or anything at this stage.
    //
    RmResumeTask(pAdapter->bind.pSecondaryTask, (UINT_PTR) Status, &sr);

    TIMESTAMP("<==CloseAdapterComplete");

    RM_ASSERT_CLEAR(&sr)
    EXIT()
}




NDIS_STATUS
epvcReadAdapterConfiguration(
    PEPVC_ADAPTER       pAdapter,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    This function can only be called from the BindAdapter function

Arguments:
    pAdapter - Underlying adapter whose configuration is being read/
    pSR - Stack Record

Return Value:

    None
++*/
{
    NDIS_HANDLE                     AdaptersConfigHandle = NULL;
    NDIS_HANDLE                     MiniportListConfigHandle = NULL;
    NDIS_STRING                     MiniportListKeyName;
    NDIS_STATUS                     NdisStatus = NDIS_STATUS_FAILURE;

    ENTER("ReadAdapterConfiguration", 0x83c48ad8)

    TRACE(TL_T, TM_Pt, ("==> epvcReadAdapterConfigurationpAdapter %p", pAdapter));
    

    do
    {
        //
        // Start off by opening the config section and reading our instance which we want
        // to export for this binding
        //
        epvcOpenProtocolConfiguration(&NdisStatus,
                                     &AdaptersConfigHandle ,
                                     &pAdapter->bind.EpvcConfigName,
                                     pSR);

        if (NDIS_STATUS_SUCCESS != NdisStatus )
        {
            AdaptersConfigHandle = NULL;
            TRACE_BREAK(TM_Pt, ("epvcOpenProtocolConfiguration failed " ) );
        }


        //
        // this should get us to the protocol\paramters\adapters\guid section in the registry
        //

        //
        //  Open the Elan List configuration key.
        //
        NdisInitUnicodeString(&MiniportListKeyName, c_szIMMiniportList);

        epvcOpenConfigurationKeyByName(
                &NdisStatus,
                AdaptersConfigHandle ,
                &MiniportListKeyName,
                &MiniportListConfigHandle,
                pSR);

        if (NDIS_STATUS_SUCCESS != NdisStatus)
        {
            MiniportListConfigHandle = NULL;
            NdisStatus = NDIS_STATUS_FAILURE;
        
            TRACE_BREAK(TM_Pt, ("NdisOpenConfigurationKeyByName failed " ) );
        }

        

        //
        // Allocate and initialize all IM miniport instances that are present 
        // in the registry under this adapter
        //
        (VOID)epvcReadIntermediateMiniportConfiguration( pAdapter, 
                                                MiniportListConfigHandle,
                                                pSR);
         


    } while (FALSE);


    if (MiniportListConfigHandle!= NULL)
    {
        NdisCloseConfiguration(MiniportListConfigHandle);
        MiniportListConfigHandle = NULL;
    }
    
    if (AdaptersConfigHandle  != NULL)
    {
        NdisCloseConfiguration(AdaptersConfigHandle );
        AdaptersConfigHandle = NULL;
    }

    if (STATUS_NO_MORE_ENTRIES == NdisStatus )
    {
        NdisStatus = NDIS_STATUS_SUCCESS;
    }

    TRACE(TL_T, TM_Pt, ("<== epvcReadAdapterConfiguration Status %x", NdisStatus));
    EXIT()
    return NdisStatus;
    


}


NDIS_STATUS
epvcReadIntermediateMiniportConfiguration(
    IN PEPVC_ADAPTER pAdapter,
    IN NDIS_HANDLE MiniportListConfigHandle,
    IN PRM_STACK_RECORD pSR
    )
{
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;

    ENTER ("ReadMiniportConfiguration", 0xb974a6fa)
    
    TRACE(TL_T, TM_Pt, ("==> epvcReadIntermediateMiniportConfiguration pAdapter %p", pAdapter));
    

    {   
        NDIS_HANDLE MiniportConfigHandle;
        NDIS_STRING MiniportKeyName;
        PEPVC_I_MINIPORT pMiniport = NULL;
    
        UINT Index = 0;
        //
        //  Iterate thru the configured Miniport
        //
        for (Index = 0;
            ;           // Stop only on error or no more Elans
             Index++)
        {
            EPVC_I_MINIPORT_PARAMS Params;
            //
            //  Open the "next" Miniport key
            //
            epvcOpenConfigurationKeyByIndex(
                        &NdisStatus,
                        MiniportListConfigHandle,
                        Index,
                        &MiniportKeyName,
                        &MiniportConfigHandle,
                        pSR
                        );

            if (NDIS_STATUS_SUCCESS != NdisStatus)
            {
                MiniportConfigHandle = NULL;
                
            }
            
            //
            //  If NULL handle, assume no more Miniports.
            //
            if (MiniportConfigHandle == NULL)
            {
                break;
            }

            //
            //  Creating this Miniport
            //
            epvcInstantiateMiniport (pAdapter, 
                                     MiniportConfigHandle,
                                     pSR);

            
            
            NdisCloseConfiguration(MiniportConfigHandle);
            MiniportConfigHandle = NULL;
        }   


        //
        //  Close config handles
        //      
        if (NULL != MiniportConfigHandle)
        {
            NdisCloseConfiguration(MiniportConfigHandle);
            MiniportConfigHandle = NULL;
        }

    }

    if (STATUS_NO_MORE_ENTRIES == NdisStatus )
    {
        NdisStatus = NDIS_STATUS_SUCCESS;
    }


    TRACE(TL_T, TM_Pt, ("<== epvcReadIntermediateMiniportConfiguration NdisStatus %x", NdisStatus));
    EXIT()
    return NdisStatus;
}
        






VOID
EpvcUnbindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 UnbindContext
)
/*++

Routine Description:

    This routine is called by NDIS when it wants us to unbind
    from an adapter. Or, this may be called from within our Unload
    handler. We undo the sequence of operations we performed
    in our BindAdapter handler.

Arguments:

    pStatus                 - Place to return status of this operation
    ProtocolBindingContext  - Our context for this adapter binding, which
                              is a pointer to an ATMEPVC Adapter structure.
    UnbindContext           - This is NULL if this routine is called from
                              within our Unload handler. Otherwise (i.e.
                              NDIS called us), we retain this for later use
                              when calling NdisCompleteUnbindAdapter.

Return Value:

    None. We set *pStatus to NDIS_STATUS_PENDING always.

--*/
{
    ENTER("UnbindAdapter", 0x3f25396e)
    EPVC_ADAPTER    *   pAdapter = (EPVC_ADAPTER*) ProtocolBindingContext;
    RM_DECLARE_STACK_RECORD(sr)

    TIMESTAMP("==>UnbindAdapter");

    TRACE ( TL_T, TM_Pt, ("==>UnbindAdapter ProtocolBindingContext %x\n", ProtocolBindingContext) );

    //
    // Get adapter lock and tmpref it.
    //
    LOCKOBJ(pAdapter, &sr);
    RmTmpReferenceObject(&pAdapter->Hdr, &sr);
    

    do
    {
        NDIS_STATUS Status;
        PRM_TASK    pTask;

        // Allocate task to  complete the unbind.
        //
        Status = epvcAllocateTask(
                    &pAdapter->Hdr,             // pParentObject,
                    epvcTaskShutdownAdapter,        // pfnHandler,
                    0,                          // Timeout,
                    "Task: Shutdown Adapter",   // szDescription
                    &pTask,
                    &sr
                    );
    
        if (FAIL(Status))
        {
            // Ugly situation. We'll just leave things as they are...
            //
            pTask = NULL;
            TR_WARN(("FATAL: couldn't allocate unbind task!\n"));
            break;
        }
    
        // Start the task to complete the unbind.
        // No locks must be held. RmStartTask uses up the tmpref on the task
        // which was added by arpAllocateTask.
        //
        UNLOCKOBJ(pAdapter, &sr);

        ((PTASK_ADAPTERSHUTDOWN) pTask)->pUnbindContext = UnbindContext;
        RmStartTask(pTask, (UINT_PTR) UnbindContext, &sr);

        LOCKOBJ(pAdapter, &sr);
    
    } while(FALSE);

    UNLOCKOBJ(pAdapter, &sr);
    RmTmpDereferenceObject(&pAdapter->Hdr, &sr);
    *pStatus = NDIS_STATUS_PENDING;

    RM_ASSERT_CLEAR(&sr);
    TIMESTAMP("<==UnbindAdapter");
    EXIT()
}




NDIS_STATUS
epvcTaskShutdownAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for shutting down an ATMEPVC adapter.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : UnbindContext

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    EPVC_ADAPTER    *   pAdapter = (EPVC_ADAPTER*) RM_PARENT_OBJECT(pTask);
    TASK_ADAPTERSHUTDOWN *pMyTask = (TASK_ADAPTERSHUTDOWN*) pTask;
    enum
    {
        STAGE_BecomePrimaryTask,
        STAGE_DeactivateAdapterComplete,
        STAGE_End
    } Stage;

    ENTER("TaskShutdownAdapter", 0x3f25396e)

    TRACE (TL_T, TM_Pt, ("==>epvcTaskShutdownAdapter Code %x", Code));

    // 
    // Message normalizing code
    //
    switch(Code)
    {

        case RM_TASKOP_START:
            Stage = STAGE_BecomePrimaryTask;

            // Save away the UnbindContext (which we get as UserParam) in
            // the task's private context, for use later.
            //
            pMyTask->pUnbindContext = (NDIS_HANDLE) UserParam;

            break;

        case  RM_TASKOP_PENDCOMPLETE:
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            Stage = RM_PEND_CODE(pTask);
            break;

        case RM_TASKOP_END:
            Status = (NDIS_STATUS) UserParam;
            Stage= STAGE_End;
            break;

        default:
            ASSERT(FALSE);
            return NDIS_STATUS_FAILURE;                 // ** EARLY RETURN **
    }

    ASSERTEX(!PEND(Status), pTask);

    switch(Stage)
    {

        case  STAGE_BecomePrimaryTask:
        {
            // If there is a primary task, pend on it, else make ourselves
            // the primary task.
            // We could get in this situation if someone does a
            // "net stop arp1394" while we're in the middle of initializing or
            // shutting down the adapter.
            //
            //
            TRACE (TL_V, TM_Pt, ("   epvcTaskShutdownAdapter STAGE_BecomePrimaryTask" ));

            LOCKOBJ(pAdapter, pSR);
            if (pAdapter->bind.pPrimaryTask == NULL)
            {
                epvcSetPrimaryAdapterTask(pAdapter, pTask, EPVC_AD_PS_DEINITING, pSR);
                UNLOCKOBJ(pAdapter, pSR);
            }
            else
            {
                PRM_TASK pOtherTask =  pAdapter->bind.pPrimaryTask;
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pAdapter, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    STAGE_BecomePrimaryTask, // we'll try again...
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }
        
            //
            // We're now the  primary task. Since we're starting out,
            // there should be NO activate/deactivate task.
            // (Note: we don't bother getting the adapter lock for these asserts).
            //
            ASSERT(pAdapter->bind.pPrimaryTask == pTask);
            ASSERT(pAdapter->bind.pSecondaryTask == NULL);

            //
            // Allocate and start the deactivate adapter task.
            //
            {
                PRM_TASK pDeactivateTask;

                Status = epvcAllocateTask(
                            &pAdapter->Hdr,             // pParentObject,
                            epvcTaskDeactivateAdapter,      // pfnHandler,
                            0,                          // Timeout,
                            "Task: Deactivate Adapter(shutdown)",   // szDescription
                            &pDeactivateTask,
                            pSR
                            );
            
                if (FAIL(Status))
                {
                    pDeactivateTask = NULL;
                    TR_WARN(("FATAL: couldn't alloc deactivate task!\n"));
                }
                else
                {
                    RmPendTaskOnOtherTask(
                        pTask,
                        STAGE_DeactivateAdapterComplete,
                        pDeactivateTask,                // task to pend on
                        pSR
                        );
            
                    // RmStartTask uses up the tmpref on the task
                    // which was added by arpAllocateTask.
                    //
                    Status = RmStartTask(
                                pDeactivateTask,
                                0, // UserParam (unused)
                                pSR
                                );
                }
            }
         }
         break;

        case STAGE_DeactivateAdapterComplete:
        {
            TRACE (TL_V, TM_Pt,( "   epvcTaskShutdownAdapter STAGE_DeactivateAdapterComplete" ));

            // Nothing to do here -- we clean  up in STAGE_End.
            //
            break;
        }

        case STAGE_End:
        {
            TRACE (TL_V, TM_Pt, ("  epvcTaskShutdownAdapter STAGE_End" ));

            //
            // We HAVE to be the primary task at this point, becase we simply
            // wait and retry until we become one.
            //
            ASSERT(pAdapter->bind.pPrimaryTask == pTask);

            // Clear the primary task in the adapter object.
            //
            LOCKOBJ(pAdapter, pSR);
            epvcClearPrimaryAdapterTask(pAdapter, pTask, EPVC_AD_PS_DEINITED, pSR);
            UNLOCKOBJ(pAdapter, pSR);

            if(RM_IS_ZOMBIE(pAdapter))
            {
                TR_WARN(("END: pAdapter is already deallocated.\n"));
            }
            else
            {
                // Free the adapter.
                // (pAdapter will be allocated, but it will be in a "zombie" state).
                //
                RmDeinitializeGroup(&(pAdapter->MiniportsGroup), pSR);

                RmFreeObjectInGroup(
                    &EpvcGlobals.adapters.Group,
                    &(pAdapter->Hdr),
                    NULL,               // NULL pTask == synchronous.
                    pSR
                    );
            }
            // If there is an unbind-context, signal NDIS that the unbind is
            //  complete.
            //
            if (pMyTask->pUnbindContext)
            {
                TR_WARN(("END: Calling NdisCompleteUnbindAdapter. Status= 0x%lx\n",
                            Status));
                RM_ASSERT_NOLOCKS(pSR);
                TIMESTAMP("===Calling NdisCompleteUnbindAdapter");
                NdisCompleteUnbindAdapter(
                                pMyTask->pUnbindContext,
                                Status
                            );
            }

        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}



VOID
epvcGetAdapterInfo(
    IN  PEPVC_ADAPTER           pAdapter,
    IN  PRM_STACK_RECORD            pSR,
    IN  PRM_TASK                    pTask               // OPTIONAL

    )
/*++

Routine Description:

    Query an adapter for hardware-specific information that we need:
        - burnt in hardware address (ESI part)
        - Max packet size
        - line rate

Arguments:

    pAdapter        - Pointer to EPVC adapter structure

Return Value:

    None

--*/
{
    NDIS_STATUS             Status  = NDIS_STATUS_FAILURE;
    EPVC_NDIS_REQUEST       Request;
    NDIS_MEDIA_STATE        MediaState=  NdisMediaStateDisconnected;

    do
    {
        //
        //  Initialize.
        //
        NdisZeroMemory(&pAdapter->info.MacAddress, sizeof(MAC_ADDRESS));
        pAdapter->info.MediaState = MediaState;
        pAdapter->info.MaxAAL5PacketSize   =  ATMEPVC_DEF_MAX_AAL5_PDU_SIZE;
        pAdapter->info.LinkSpeed.Outbound = pAdapter->info.LinkSpeed.Inbound = ATM_USER_DATA_RATE_SONET_155;

        //
        //  MAC Address:
        //
        Status = epvcPrepareAndSendNdisRequest (pAdapter,
                                             &Request,
                                             NULL,              // OPTIONAL
                                             OID_ATM_HW_CURRENT_ADDRESS,
                                             (PVOID)(&pAdapter->info.MacAddress),
                                             sizeof (pAdapter->info.MacAddress),
                                             NdisRequestQueryInformation,
                                             NULL,  // No miniport
                                             FALSE, // No request was pended
                                             FALSE, // Pended Request info
                                             pSR);

        ASSERT (PEND(Status) == FALSE);

        if (FAIL(Status)== TRUE)
        {   
            //
            // Don't break .continue on
            //
            TRACE (TL_I, TM_Pt, ("Oid - Atm Hw Address failed %x", Status));

        }
        
        Status = epvcPrepareAndSendNdisRequest(
                                            pAdapter,
                                            &Request,
                                            NULL,               // OPTIONAL
                                            OID_ATM_MAX_AAL5_PACKET_SIZE,
                                            (PVOID)(&pAdapter->info.MaxAAL5PacketSize),
                                            sizeof(pAdapter->info.MaxAAL5PacketSize),
                                            NdisRequestQueryInformation,
                                             NULL,  // No miniport
                                             FALSE, // No request was pended
                                             FALSE, // Pended Request info
                                            pSR);
    
        if (FAIL(Status)== TRUE)
        {
            TRACE (TL_I, TM_Pt, ("Oid - Atm Max AAL5 Packet Size  failed %x", Status));
            
    
        }

        if (pAdapter->info.MaxAAL5PacketSize  > ATMEPVC_DEF_MAX_AAL5_PDU_SIZE)
        {
            pAdapter->info.MaxAAL5PacketSize   =  ATMEPVC_DEF_MAX_AAL5_PDU_SIZE;
        }

        //
        //  Link speed:
        //
        Status = epvcPrepareAndSendNdisRequest(
                                            pAdapter,
                                            &Request,
                                            NULL,               // OPTIONAL
                                            OID_GEN_CO_LINK_SPEED,
                                            &pAdapter->info.LinkSpeed,
                                            sizeof(pAdapter->info.LinkSpeed),
                                            NdisRequestQueryInformation,
                                            NULL,  // No miniport
                                            FALSE, // No request was pended
                                            FALSE, // Pended Request info
                                            pSR);

        TRACE (TL_V, TM_Mp, ("Outbound %x Inbound %x",
                             pAdapter->info.LinkSpeed.Outbound, 
                             pAdapter->info.LinkSpeed.Inbound));                                            
        
        
        if ((NDIS_STATUS_SUCCESS != Status) ||
            (0 == pAdapter->info.LinkSpeed.Inbound) ||
            (0 == pAdapter->info.LinkSpeed.Outbound))
        {
            TRACE (TL_I, TM_Pt, ( "GetAdapterInfo: OID_GEN_CO_LINK_SPEED failed\n"));

            //
            //  Default and assume data rate for 155.52Mbps SONET
            //
            pAdapter->info.LinkSpeed.Outbound = pAdapter->info.LinkSpeed.Inbound = ATM_USER_DATA_RATE_SONET_155;
        }

        //
        //  Link speed:
        //
        Status = epvcPrepareAndSendNdisRequest(
                                            pAdapter,
                                            &Request,
                                            NULL,               // OPTIONAL
                                            OID_GEN_MEDIA_CONNECT_STATUS,
                                            &MediaState,
                                            sizeof(MediaState),
                                            NdisRequestQueryInformation,
                                            NULL,  // No miniport
                                            FALSE, // No request was pended
                                            FALSE, // Pended Request info
                                            pSR);

        TRACE (TL_V, TM_Mp, ("MediaConnectivity %x ",MediaState));                                          
        
        
        if (NDIS_STATUS_SUCCESS != Status )
        {
            TRACE (TL_I, TM_Pt, ( "GetAdapterInfo: OID_GEN_CO_LINK_SPEED failed\n"));

            //
            //  Default and assume data rate for 155.52Mbps SONET
            //
            MediaState = NdisMediaStateDisconnected;
        }

        pAdapter->info.MediaState  = MediaState ;
        
        TRACE( TL_V, TM_Pt,("GetAdapterInfo: Outbound Linkspeed %d", pAdapter->info.LinkSpeed.Outbound));
        TRACE( TL_V, TM_Pt,("GetAdapterInfo: Inbound  Linkspeed %d\n", pAdapter->info.LinkSpeed.Inbound));

    }while (FALSE);

                        
    return;
}



NDIS_STATUS
EpvcPtPNPHandler(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    )

/*++
Routine Description:

    This is the Protocol PNP handlers. 
    All PNP Related OIDS(requests) are routed to this function
    
Arguments:

    ProtocolBindingContext  Pointer to our adapter structure.
    pNetPnPEvent Pointer to a Net_PnP_Event

Return Value:

    NDIS_STATUS_SUCCESS: as we do not do much here

--*/
{
    ENTER("EpvcPtPnPHandler", 0xacded1ce)
    PEPVC_ADAPTER           pAdapter  =(PEPVC_ADAPTER)ProtocolBindingContext;
    NDIS_STATUS Status  = NDIS_STATUS_SUCCESS;
    RM_DECLARE_STACK_RECORD (SR);

    TRACE (TL_T, TM_Pt, ("==> EpvcPtPNPHandler Adapter %p, pNetPnpEvent %x", pAdapter, pNetPnPEvent));


    //
    // This will happen when all entities in the system need to be notified
    //

    switch(pNetPnPEvent->NetEvent)
    {

     case NetEventReconfigure :
        Status  = epvcPtNetEventReconfigure(pAdapter, pNetPnPEvent->Buffer, &SR);
        break;

     default :
        Status  = NDIS_STATUS_SUCCESS;
        break;
    }


    TRACE (TL_T, TM_Pt, ("<== EpvcPtPNPHandler Status %x", Status));
    RM_ASSERT_NOLOCKS(&SR)
    EXIT();
    return Status;
}

NDIS_STATUS
epvcPtNetEventReconfigure(
    IN  PEPVC_ADAPTER           pAdapter,
    IN  PVOID                   pBuffer,
    IN PRM_STACK_RECORD         pSR
    
    )
/*++
Routine Description:
    This is the function that will be called by the PNP handler 
    whenever a PNPNetEventReconfigure happens

    THis will happen if a new physical adapter has come in or the user
    has re-enabled a virtual miniport.

    To process:
    Iterate through all the adapter. If adapters are bound, then make sure that
    all of its miniport's are initialized.

    If not, then leave it and call NdisReenumerate to connect all our protocol
    instances with valid adapters

Arguments:

    ProtocolBindingContext  Pointer to our adapter structure.

Return Value:

    NDIS_STATUS_SUCCESS: as we do not do much here


--*/
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    
    TRACE (TL_T, TM_Pt, ("==> epvcPtNetEventReconfigure Adapter %p, pBuffer %x", pAdapter, pBuffer));
    

    do
    {

        

        //
        // The notify object sets the REconfig buffer. 
        //
        if (pBuffer != NULL)
        {

            ASSERT (!"PnPBuffer != NULL - not implemented yet");
            break;
        }

        if (pAdapter == NULL)
        {
            //
            // Iterate through all the adapters and initialize
            // uninitialized miniports
            //
            
            epvcEnumerateObjectsInGroup ( &EpvcGlobals.adapters.Group,
                                          epvcReconfigureAdapter,
                                          pBuffer,
                                          pSR);


            
            //
            // Re-enumerate the protocol bindings, this will cause us to get
            // a BindAdapter on all our unbound adapters, and then we 
            // will InitDeviceInstance.
            // This is called when the protcol is not bound to the physical adapter
            //
            NdisReEnumerateProtocolBindings(EpvcGlobals.driver.ProtocolHandle);
            break;

        }

    
    } while (FALSE);

    Status = NDIS_STATUS_SUCCESS;


    TRACE (TL_T, TM_Pt, ("<== epvcPtNetEventReconfigure " ));

    return Status;
}


INT
epvcReconfigureAdapter(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        )
/*++
Routine Description:

    When the Protocol's Reconfigure handler is called, this adapter will be in one 
    of two condtions - Its binding to the adapter below is open or the binding is 
    closed.

    if the blinding is closed, then the protocol will call NdisReEnumerate Bindings
    and this will restart the Binding  and re-instantiate the miniports.


Arguments:

    ProtocolBindingContext  Pointer to our adapter structure.

Return Value:

    TRUE: so that iteration continues

--*/
{
    ENTER("epvcReconfigureAdapter", 0x2906a037)
    PEPVC_ADAPTER pAdapter = (PEPVC_ADAPTER )pHdr; 

    do
    {
        if (CHECK_AD_PRIMARY_STATE(pAdapter, EPVC_AD_PS_INITED)== FALSE)
        {
            //
            // no more work to be done on this adapter, 
            //
            break;        
        }

        //
        //  TODO: Go through the registry and initialize 
        //  all the IM miniports present
        //
        epvcReadAdapterConfiguration(pAdapter, pSR);
        //
        // Now go through all the miniports on this group and 
        // initialize them
        //
        epvcEnumerateObjectsInGroup ( &pAdapter->MiniportsGroup,
                                      epvcReconfigureMiniport,
                                      NULL,
                                      pSR);

 
    } while (FALSE);

    

    EXIT()

    return TRUE;
}




INT
epvcReconfigureMiniport (
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        )
/*++
Routine Description:

    This should check to see if the InitDev instance has been
    called on this miniport. IF not, then queue the task to 
    do it.

Arguments:

    ProtocolBindingContext  Pointer to our adapter structure.

Return Value:

    TRUE: so that iteration continues

--*/
{
    ENTER( "epvcReconfigureMiniport" ,0xdd9ecb01)
    
    PEPVC_I_MINIPORT pMiniport = (PEPVC_I_MINIPORT)pHdr;
    PTASK_AF            pTask = NULL;
    PEPVC_ADAPTER       pAdapter = (PEPVC_ADAPTER)pMiniport->Hdr.pParentObject;
    NDIS_STATUS         Status = NDIS_STATUS_FAILURE;

    LOCKOBJ(pMiniport, pSR);

    //
    // If the device instance is not initialized (i.e it has been halted)
    // then this thread reinitializes the device instance
    //
    do
    {


        //
        // If the device is already Initialized then exit.
        //
        if (MiniportTestFlag (pMiniport, fMP_DevInstanceInitialized ) == TRUE)
        {
            break;
        }
        //
        // Allocate task to Initialize the Device Instance.
        //
        Status = epvcAllocateTask(
                    &pMiniport->Hdr,            // pParentObject,
                    epvcTaskStartIMiniport, // pfnHandler,
                    0,                          // Timeout,
                    "Task: Open address Family",    // szDescription
                    &((PRM_TASK)pTask),
                    pSR
                    );
    
        if (FAIL(Status))
        {
            // Ugly situation. We'll just leave things as they are...
            //
            pTask = NULL;
            TR_WARN(("FATAL: couldn't allocate unbind task!\n"));
            break;
        }
    
        // Start the task to complete the Open Address Family.
        // No locks must be held. RmStartTask uses up the tmpref on the task
        // which was added by epvcAllocateTask.
        //
        UNLOCKOBJ(pMiniport, pSR);
        
        pTask->pAf= &pAdapter->af.AddressFamily ;
        pTask->Cause = TaskCause_ProtocolBind;
        RmStartTask((PRM_TASK)pTask, 0, pSR);

        LOCKOBJ(pMiniport, pSR);
    
    } while(FALSE);

    UNLOCKOBJ(pMiniport, pSR);
    EXIT()

    return TRUE;
}





VOID
epvcExtractSendCompleteInfo (
    OUT PEPVC_SEND_COMPLETE     pStruct,
    PEPVC_I_MINIPORT        pMiniport,
    PNDIS_PACKET            pPacket 
    )
/*++

Routine Description:


Arguments:


Return Value:
    
--*/
{
    NDIS_HANDLE         PoolHandle = NULL;

    pStruct->pPacket = pPacket;


    PoolHandle = NdisGetPoolFromPacket(pPacket);

    if (PoolHandle != pMiniport->PktPool.Send.Handle)
    {
        //
        // We had passed down a packet belonging to the protocol above us.
        //

        pStruct->fUsedPktStack = TRUE;


    }
    else
    {
            pStruct->fUsedPktStack = FALSE;

    }

    epvcSendCompleteStats();

}

    

VOID
EpvcPtSendComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:

The Vc Context is the miniport block, Use it to complete the send

Arguments:


Return Value:


--*/
{
    ENTER("EpvcPtSendComplete", 0x76beac72)
    PEPVC_I_MINIPORT        pMiniport =(PEPVC_I_MINIPORT)ProtocolVcContext;
    EPVC_SEND_COMPLETE      Struct;
    RM_DECLARE_STACK_RECORD (SR);
    

    TRACE (TL_T, TM_Send, ("EpvcPtSendComplete"));
    
    EPVC_ZEROSTRUCT (&Struct);
    
    #define OUR_EXTERNAL_ENTITY ((UINT_PTR) Packet)
    #define szEPVCASSOC_EXTLINK_DEST_TO_PKT_FORMAT "    send pkt 0x%p\n"

    do 
    {
        epvcExtractSendCompleteInfo (&Struct, pMiniport, Packet);

        //
        // If we are using the Packetstacking, then this packet is the
        // original packet
        //
        if (Struct.fUsedPktStack == TRUE)
        {
            BOOLEAN Remaining = FALSE;

            Struct.pOrigPkt = Packet;

            Struct.pStack = NdisIMGetCurrentPacketStack(Packet, &Remaining);

            Struct.pContext =  (PEPVC_STACK_CONTEXT)(&Struct.pStack->IMReserved[0]) ;

        }
        else
        {
        
            Struct.pPktContext =(PEPVC_PKT_CONTEXT)(Packet->ProtocolReserved);

            Struct.pContext =  &Struct.pPktContext->Stack;

            Struct.pOrigPkt = Struct.pPktContext->pOriginalPacket;

            NdisIMCopySendCompletePerPacketInfo (Struct.pOrigPkt , Packet);
        }

        
        LOCKOBJ (pMiniport, &SR);

        epvcDerefSendPkt(Packet, &pMiniport->Hdr);

        UNLOCKOBJ (pMiniport, &SR);


        //
        // Make sure the original packet is in the same state 
        // when it was sent to the miniport
        //
        Struct.pPacket = Packet;

        //
        // Remove the ethernet padding - if necessary
        //
        epvcRemoveEthernetPad (pMiniport, Packet);

        //
        // Remove the ethernet padding buffer - if necessary
        //
        epvcRemoveEthernetTail (pMiniport, Packet, Struct.pPktContext);

        //
        // Remove the LLC Snap headers - if necessary
        //
        epvcRemoveExtraNdisBuffers (pMiniport, &Struct);
        


        if (Struct.fUsedPktStack == FALSE)
        {
            epvcDprFreePacket(Packet,
                              &pMiniport->PktPool.Send);
        }

        if (Status == NDIS_STATUS_SUCCESS)
        {
            pMiniport->count.FramesXmitOk ++;
        }
        
    } while (FALSE);

    //
    // Complete the send
    //
    epvcMSendComplete(pMiniport,
                      Struct.pOrigPkt,
                      Status);

    EXIT();
    RM_ASSERT_CLEAR(&SR);

    return;                          
}


VOID
epvcRemoveExtraNdisBuffers (
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PEPVC_SEND_COMPLETE pStruct
    )
/*++

Routine Description:

    In the case of IP encapsulation, there will be an extra ndis buffer
    that has been made the head of the Ndispacket. Remove it and 
    reattach the old one.

Arguments:


Return Value:


--*/

{

    PNDIS_BUFFER    pOldHead = NULL;
    UINT            OldHeadLength = 0;
    
    do
    {
        //
        // if an LLC header was used, remove it and free the MDL
        // use the packet that was completed
        // 

        if (pMiniport->fAddLLCHeader== TRUE)
        {
            PNDIS_PACKET_PRIVATE    pPrivate = &pStruct->pPacket->Private;      
            PNDIS_BUFFER            pHead = pPrivate->Head;     

            //
            // Move the head of the packet past the LLC Header
            //
            pPrivate->Head = pHead->Next;

            //
            // Free the Head MDL
            //
            epvcFreeBuffer(pHead);
                    
        }

        //
        // if we are not doing IP encapsulation, then we are done.
        //
        if (pMiniport->fDoIpEncapsulation== FALSE)
        {
            break;
        }


        
        //
        // if the Ethernet header was stripped off, then put it back
        //
        pOldHead =  pStruct->pContext->ipv4Send.pOldHeadNdisBuffer;

        ASSERT (pOldHead != NULL);

        OldHeadLength = NdisBufferLength(pOldHead);
            
        //
        // two ways this can happen 
        // 1) if the ethernet header was in a seperate MDL
        //        then simply take the old Head and make it the Head again
        //
        if (OldHeadLength == sizeof (EPVC_ETH_HEADER))
        {
            PNDIS_PACKET_PRIVATE    pPrivate = &pStruct->pPacket->Private;      
            PNDIS_BUFFER            pHead = pPrivate->Head;     

            ASSERT (pOldHead->Next == pPrivate->Head);


            pOldHead->Next = pPrivate->Head;
            
            pPrivate->Head = pOldHead ;


                
            break;  // we are done

        }


        //
        // 2nd Way 2) A new MDL had been allocated which just points to the 
        // IP part of the header.
        //  For this - free the Head in Packet, Take the old Head and put it back 
        //  in the packet as the New Head
        //

        if (OldHeadLength > sizeof (EPVC_ETH_HEADER))
        {
            
            PNDIS_PACKET_PRIVATE pPrivate = &pStruct->pPacket->Private;     

            ASSERT (pOldHead->Next == pPrivate->Head->Next);

            if (pPrivate->Head == pPrivate->Tail)
            {
                pPrivate->Tail = pOldHead;  
                pOldHead->Next = NULL;
            }
            else
            {
                pOldHead->Next = pPrivate->Head->Next;
            }
            
            epvcFreeBuffer(pPrivate->Head );
            
            pPrivate->Head = pOldHead;

            
            break;  // we are done

        }       
    } while (FALSE);        
}



VOID
EpvcPtReceiveComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext
    )
/*++

Routine Description:

    Called by the adapter below us when it is done indicating a batch of
    received packets.

Arguments:

    ProtocolBindingContext  Pointer to our adapter structure.

Return Value:

    None

--*/
{
    PEPVC_ADAPTER pAdapter = (PEPVC_ADAPTER)ProtocolBindingContext;

    return;

}


INT
epvcMiniportDoUnbind(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        )
{

/*++

Routine Description:

    This is called from the Protocl Unbind code path

    This should halt the current miniport and close the address 
    family. This is all done in the CloseMiniportTask, so we 
    will simply start the task and wait for it to complete

Arguments:


Return Value:

    TRUE - as we want to iterate to the very end

--*/

    ENTER ("epvcMiniportDoUnbind", 0x26dc5d35)

    PRM_TASK            pRmTask = NULL;
    PTASK_AF            pAfTask = NULL;
    NDIS_STATUS         Status = NDIS_STATUS_FAILURE;
    PEPVC_I_MINIPORT    pMiniport = (PEPVC_I_MINIPORT)pHdr;
    PEPVC_ADAPTER       pAdapter = (PEPVC_ADAPTER) pMiniport->Hdr.pParentObject;
    BOOLEAN             fHaltNotCompleted = FALSE;
    
    TRACE (TL_T, TM_Mp, ("==>epvcMiniportDoUnbind pMiniport %x", pMiniport) );

    do
    {
        
        if (MiniportTestFlag (pMiniport, fMP_AddressFamilyOpened) == TRUE)
        {

            //
            // allocate a close Miniport Task 
            //

            Status = epvcAllocateTask(
                        &pMiniport->Hdr,            // pParentObject,
                        epvcTaskCloseIMiniport, // pfnHandler,
                        0,                          // Timeout,
                        "Task: CloseIMiniport- Unbind", // szDescription
                        &pRmTask,
                        pSR
                        );
                        
            if (Status != NDIS_STATUS_SUCCESS)
            {
                ASSERT (Status == NDIS_STATUS_SUCCESS);
                pAfTask = NULL;
                break;
            }

            pAfTask= (PTASK_AF)pRmTask ;
            
            pAfTask->Cause = TaskCause_ProtocolUnbind;

            //
            // Reference the task so it is around until our Wait for completion
            // is complete
            //
            RmTmpReferenceObject (&pAfTask->TskHdr.Hdr, pSR);



            epvcInitializeEvent (&pAfTask->CompleteEvent);

            RmStartTask (pRmTask, 0, pSR);


            epvcWaitEvent(&pAfTask->CompleteEvent, WAIT_INFINITE);

            RmTmpDereferenceObject (&pAfTask->TskHdr.Hdr, pSR);

        
        }       

        LOCKOBJ (pMiniport, pSR);
            
        //
        // If the Halt has not already completed then, we should wait for it
        //
        if (MiniportTestFlag(pMiniport ,fMP_MiniportInitialized) == TRUE )
        {
            //
            // prepare to wait for halt
            //
            epvcResetEvent (&pMiniport->pnp.HaltCompleteEvent);

            //
            // Set the flag to mark it as waiting for halt 
            //
            MiniportSetFlag (pMiniport, fMP_WaitingForHalt);

            fHaltNotCompleted = TRUE;
        }

        UNLOCKOBJ (pMiniport, pSR);

        if (fHaltNotCompleted == TRUE)
        {
            BOOLEAN bWaitSuccessful;

            
            bWaitSuccessful = epvcWaitEvent (&pMiniport->pnp.HaltCompleteEvent,WAIT_INFINITE);                                    


            if (bWaitSuccessful == FALSE)
            {
                ASSERT (bWaitSuccessful == TRUE);
            }
            

        }
            
        //
        // Free the miniport object because there should be no more tasks on it.
        // this Thread will have either caused the Miniport to Halt and waited 
        // for its completion (above) or the miniport will already have been halted
        //

        TRACE ( TL_I, TM_Mp, ("epvcMiniportDoUnbind  Freeing miniport %p", pMiniport) );

        RmFreeObjectInGroup (&pAdapter->MiniportsGroup,&pMiniport->Hdr, NULL, pSR);
        
    } while (FALSE);
        
    TRACE (TL_T, TM_Mp, ("<==epvcMiniportDoUnbind pMiniport %x", pMiniport) );
    EXIT();
    return TRUE;
}



NDIS_STATUS
epvcProcessOidCloseAf(
    PEPVC_I_MINIPORT pMiniport,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    This is called from the Af Close Request Code path

    This simply starts a worktitem to close the Af, if the 
    Af is open

Arguments:


Return Value:


--*/
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    PTASK_AF pTaskAf = NULL;
    PEPVC_WORK_ITEM  pCloseAfWorkItem = NULL;

    TRACE (TL_T, TM_Mp, ("==> epvcProcessOidCloseAf pMiniport %x", pMiniport) );

    
    
    //
    // reference the adapter as it is going to passed to a workiter.
    // decremented in the workitem
    //

    do
    {
        if (MiniportTestFlag( pMiniport, fMP_AddressFamilyOpened) == FALSE)
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        Status = epvcAllocateMemoryWithTag (&pCloseAfWorkItem, 
                                            sizeof(*pCloseAfWorkItem) , 
                                            TAG_WORKITEM);            
        if (Status != NDIS_STATUS_SUCCESS)
        {
            pCloseAfWorkItem= NULL;
            break;                
        }

        epvcMiniportQueueWorkItem (pCloseAfWorkItem,
                                   pMiniport,
                                   epvcOidCloseAfWorkItem,
                                   Status, // Ignored
                                   pSR
                                   );
                                   
        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        //
        // free locally allocated memory
        //
        if (pCloseAfWorkItem != NULL)            
        {
            epvcFreeMemory(pCloseAfWorkItem, sizeof (*pCloseAfWorkItem), 0);
        }
    }
    

    return Status;
}





VOID
epvcOidCloseAfWorkItem(
    IN PRM_OBJECT_HEADER pObj,
    IN NDIS_STATUS Status,
    IN PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    This is called from the Af Close Request Code path

    This simply starts a worktitem to close the Af, if the 
    Af is open

Arguments:


Return Value:


--*/
{
    
    PTASK_AF pTaskAf = NULL;
    PEPVC_I_MINIPORT pMiniport = (PEPVC_I_MINIPORT)pObj;
    
    TRACE (TL_T, TM_Mp, ("==> epvcProcessOidCloseAf pMiniport %x", pMiniport) );

    Status = NDIS_STATUS_FAILURE;
    
    //
    // reference the adapter as it is going to passed to a workiter.
    // decremented in the workitem
    //

    do
    {
        if (MiniportTestFlag( pMiniport, fMP_AddressFamilyOpened) == FALSE)
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }


    
        Status = epvcAllocateTask(
                    &pMiniport->Hdr,            // pParentObject,
                    epvcTaskCloseIMiniport, // pfnHandler,
                    0,                          // Timeout,
                    "Task: CloseIMiniport - OID CloseAf",   // szDescription
                    &(PRM_TASK)pTaskAf,
                    pSR
                    );

        if (FAIL(Status))
        {
            pTaskAf = NULL;
            ASSERT (Status == NDIS_STATUS_SUCCESS);
            break;
        }


        pTaskAf->Cause = TaskCause_AfCloseRequest;

        pTaskAf->pRequest = NULL;

        
        RmStartTask ((PRM_TASK)pTaskAf , 0, pSR);

    

    } while (FALSE);


    

    return ;
}


UINT
EpvcCoReceive(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:

Arguments:


Return Value:

--*/
{
    ENTER ("EpvcPtCoReceive", 0x1bfc168e)
    PEPVC_ADAPTER           pAdapter =(PEPVC_ADAPTER)ProtocolBindingContext;
    PEPVC_I_MINIPORT        pMiniport = (PEPVC_I_MINIPORT)ProtocolVcContext;

    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
    EPVC_RCV_STRUCT         RcvStruct;

    
    RM_DECLARE_STACK_RECORD (SR);

    TRACE (TL_T, TM_Pt, ("==> EpvcCoReceive Pkt %x", Packet));

    EPVC_ZEROSTRUCT (&RcvStruct);
    
    TRACE (TL_T, TM_Recv, ("EpvcPtCoReceive pAd %p, pMp %p, pPkt %p", pAdapter, pMiniport, Packet));

    do
    {
        if (MiniportTestFlag (pMiniport, fMP_MiniportInitialized) == FALSE)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        Status = epvcGetRecvPkt (&RcvStruct,pMiniport, Packet);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        ASSERT (RcvStruct.pNewPacket != NULL);      

        Status = epvcStripHeaderFromNewPacket (&RcvStruct, pMiniport);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        Status = epvcAddEthHeaderToNewPacket (&RcvStruct, pMiniport);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        //
        // Now indicate the packet up
        //
        NDIS_SET_PACKET_HEADER_SIZE(RcvStruct.pNewPacket,
                                    sizeof (EPVC_ETH_HEADER)) ; 

        ASSERT (NDIS_GET_PACKET_HEADER_SIZE(RcvStruct.pNewPacket) == 14); 

        //
        // Force protocols above to make a copy if they want to hang
        // on to data in this packet. This is because we are in our
        // Receive handler (not ReceivePacket) and we can't return a
        // ref count from here.
        //

        RcvStruct.OldPacketStatus = NDIS_GET_PACKET_STATUS(Packet);

        
        NDIS_SET_PACKET_STATUS(RcvStruct.pNewPacket, 
                               RcvStruct.OldPacketStatus );

        epvcDumpPkt (RcvStruct.pNewPacket);

        epvcValidatePacket (RcvStruct.pNewPacket);

        NdisMIndicateReceivePacket(pMiniport->ndis.MiniportAdapterHandle, 
                                   &RcvStruct.pNewPacket, 
                                   1);


                
        
    } while (FALSE);

    //
    // Check if we had indicated up the packet with NDIS_STATUS_RESOURCES
    // NOTE -- do not use NDIS_GET_PACKET_STATUS(MyPacket) for this since
    // it might have changed! Use the value saved in the local variable.
    //
    if (RcvStruct.OldPacketStatus == NDIS_STATUS_RESOURCES)
    {
        epvcProcessReturnPacket (pMiniport, RcvStruct.pNewPacket,NULL, &SR); 
        Status = NDIS_STATUS_RESOURCES;

    }
    else if (Status != NDIS_STATUS_SUCCESS)
    {
        epvcProcessReturnPacket (pMiniport, RcvStruct.pNewPacket,NULL, &SR); 
        Status = NDIS_STATUS_RESOURCES;
        pMiniport->count.RecvDropped ++;
    }
        


    RM_ASSERT_CLEAR(&SR);

    TRACE (TL_T, TM_Pt, ("<== EpvcCoReceive Pkt %x", Packet))

    return((Status != NDIS_STATUS_RESOURCES) ? 1 : 0);
    
}



NDIS_STATUS
epvcGetRecvPkt (
    IN PEPVC_RCV_STRUCT pRcvStruct,
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET Packet
    )
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;

    TRACE (TL_T, TM_Pt, ("==>epvcGetRecvPkt "))

    do
    {
        if (MiniportTestFlag (pMiniport, fMP_MiniportInitialized) == FALSE)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }


        epvcValidatePacket (Packet);            

        //
        // See if the packet is large enough
        //
        if (epvcIsPacketLengthAcceptable (Packet, pMiniport)== FALSE)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }
    
        pRcvStruct->pPacket = Packet;
        //
        // Check if we can reuse the same packet for indicating up.
        //
        pRcvStruct->pStack = NdisIMGetCurrentPacketStack(Packet, &pRcvStruct->fRemaining);

        if (pRcvStruct->fRemaining)
        {
            //
            // We can reuse "Packet".
            //
            // NOTE: if we needed to keep per-packet information in packets
            // indicated up, we can use pStack->IMReserved[].
            //

            pRcvStruct->pNewPacket = Packet;

            pRcvStruct->fUsedPktStacks = TRUE;

            pRcvStruct->pPktContext = (PEPVC_PKT_CONTEXT)pRcvStruct->pStack;

            // Zero out our context
            NdisZeroMemory (&pRcvStruct->pPktContext->Stack, sizeof(EPVC_STACK_CONTEXT));

            NDIS_SET_PACKET_HEADER_SIZE(Packet, 14);

            Status = NDIS_STATUS_SUCCESS; // We are done
            break;
        }
        
    
        //
        // Get a packet off the pool and indicate that up
        //
        epvcDprAllocatePacket(&Status,
                                  &pRcvStruct->pNewPacket,
                                  &pMiniport->PktPool.Recv);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            pRcvStruct->pNewPacket = NULL;
            break;
        }

        {
            //
            // set up the new packet to look exactly like the old one
            //

            PNDIS_PACKET MyPacket = pRcvStruct->pNewPacket; 

            MyPacket->Private.Head = Packet->Private.Head;
            MyPacket->Private.Tail = Packet->Private.Tail;

            //
            // Set the standard Ethernet header size
            //
            NDIS_SET_PACKET_HEADER_SIZE(MyPacket, 14);

            //
            // Copy packet flags.
            //
            NdisGetPacketFlags(MyPacket) = NdisGetPacketFlags(Packet);

            //
            // Set up the context pointers
            //
            pRcvStruct->pPktContext = (PEPVC_PKT_CONTEXT)&MyPacket->MiniportReservedEx[0];
            NdisZeroMemory (pRcvStruct->pPktContext, sizeof (*pRcvStruct->pPktContext));
            pRcvStruct->pPktContext->pOriginalPacket = Packet;

        }

        Status = NDIS_STATUS_SUCCESS; // We are done
    

    } while (FALSE);

    TRACE (TL_T, TM_Pt, ("<==epvcGetRecvPkt Old %p, New %p ", 
                              pRcvStruct->pPacket, pRcvStruct->pNewPacket))

    return Status;
}



NDIS_STATUS
epvcStripLLCHeaderFromNewPacket (
    IN PEPVC_RCV_STRUCT pRcvStruct, 
    IN PEPVC_I_MINIPORT pMiniport
    )
{
    NDIS_STATUS     Status = NDIS_STATUS_FAILURE;
    PNDIS_PACKET    pPacket = NULL;
    PNDIS_BUFFER    pHead, pNewHead =NULL;
    ULONG           CurLength = 0;
    PUCHAR          pCurVa = NULL;
    ULONG           LlcHeaderLength = 0;
    BOOLEAN         fIsCorrectHeader ;
    do
    {

        if (pMiniport->fAddLLCHeader == FALSE)
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }


        pPacket = pRcvStruct->pNewPacket;
        pHead = pPacket->Private.Head;      
        LlcHeaderLength = pMiniport->LlcHeaderLength;
        //
        // Move the Head past the LLC Header
        //
        ASSERT (NdisBufferLength (pHead) > LlcHeaderLength);

        //
        // Adjust the length and start VA of the MDL
        //
        CurLength = NdisBufferLength(pHead); 

        pCurVa = NdisBufferVirtualAddress(pHead);


        //
        // Check arguments
        //
        if (pCurVa == NULL)
        {
            break;
        }

        if (CurLength <= LlcHeaderLength)
        {
            break;
        }

        //
        // Compare and make sure that it is the right header
        //
        
        fIsCorrectHeader = NdisEqualMemory (pCurVa , 
                                           pMiniport->pLllcHeader, 
                                           pMiniport->LlcHeaderLength) ;

        
        // If the IsCorrectheader is still false, then there is more to do
        if (fIsCorrectHeader == FALSE)
        {
            break;
        }


        if (pMiniport->fDoIpEncapsulation == TRUE)
        {
            //
            // In the case of IPEncap + LLC Header, the function
            // which adds the Mac Header will strip the LLC Header
            //
            Status= NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // Strip the LLC Header Length
        //
        CurLength -= pMiniport->LlcHeaderLength;
        pCurVa += pMiniport->LlcHeaderLength;

        epvcAllocateBuffer(&Status ,
                            &pNewHead, 
                            NULL,
                            pCurVa, 
                            CurLength
                            );
                            
        if (Status != NDIS_STATUS_SUCCESS)
        {   
            pNewHead = NULL;
            break;
        }

        //
        // Set up the Packet context
        //

        pPacket->Private.ValidCounts= FALSE;

        pRcvStruct->pPktContext->Stack.EthLLC.pOldHead = pHead;
        pRcvStruct->pPktContext->Stack.EthLLC.pOldTail = pPacket->Private.Tail;
        
        //
        // Set the New Ndis buffer in the Packet
        //
        pNewHead->Next = pHead->Next;

        pPacket->Private.Head = pNewHead;

        if (pPacket->Private.Tail == pHead)
        {
               //
               // Update the Tail of the packet as well
               //
               pPacket->Private.Tail = pNewHead; 
        }



        Status = NDIS_STATUS_SUCCESS;
    

    } while (FALSE);


    return Status;
}




NDIS_STATUS
epvcAddEthHeaderToNewPacket (
    IN PEPVC_RCV_STRUCT pRcvStruct, 
    IN PEPVC_I_MINIPORT pMiniport
    )
{
    NDIS_STATUS         Status = NDIS_STATUS_FAILURE    ;
    PNDIS_BUFFER        pOldHead = NULL;
    PNDIS_BUFFER        pNewBuffer = NULL;
    PNDIS_PACKET        pNewPacket = NULL;
    PUCHAR              pStartOfValidData = NULL;
    PUCHAR              pCurrOffset = NULL;

    PEPVC_IP_RCV_BUFFER pIpBuffer = NULL; 
    
    extern UCHAR LLCSnapIpv4[8] ;


    
    
    TRACE (TL_T, TM_Pt, ("==>epvcAddEthHeaderToNewPacket pRcvStruct %p ", pRcvStruct))
    do
    {
        if (pMiniport->fDoIpEncapsulation == FALSE)
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // Copy the data into a new buffer. The start of the data is adjusted 
        // to account for the LLC header and ethernet header
        //
        pNewPacket = pRcvStruct->pNewPacket;
        
        pOldHead = pNewPacket->Private.Head;
        
        pStartOfValidData  = NdisBufferVirtualAddress (pOldHead );

        if (pStartOfValidData  == NULL)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        if (pMiniport->fAddLLCHeader == TRUE)
        {
            pStartOfValidData += sizeof (LLCSnapIpv4);
            pRcvStruct->fLLCHeader = TRUE;
        }

        pRcvStruct->pStartOfValidData = pStartOfValidData ;
        

        //
        // Get a locally allocated buffer to copy the packet into
        //
        

        pIpBuffer = epvcGetLookasideBuffer (&pMiniport->rcv.LookasideList);

        if (pIpBuffer  == NULL)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }


        //
        // Start of the data
        //
        pCurrOffset  = pRcvStruct->pLocalMemory = (PUCHAR)(&pIpBuffer->u.Pkt.Eth);
        


        //
        // First copy the Ethernet Header into the LocalMemory
        //
        NdisMoveMemory (pCurrOffset , 
                        &pMiniport->RcvEnetHeader, 
                        sizeof(pMiniport->RcvEnetHeader));          

        pCurrOffset += sizeof(pMiniport->RcvEnetHeader);

        pRcvStruct->BytesCopied += sizeof(pMiniport->RcvEnetHeader);


        //
        // Now copy the NdisBufferChain into the Locally allocated memory
        //
        Status = epvcCopyNdisBufferChain (pRcvStruct,
                                          pOldHead ,
                                          pCurrOffset
                                          );

        //
        // We have to add an Ethernet Header for this packet.
        //

        
        
        epvcAllocateBuffer (&Status,
                            &pNewBuffer,
                            NULL,
                            pRcvStruct->pLocalMemory,
                            pRcvStruct->BytesCopied);

                            
        if (Status != NDIS_STATUS_SUCCESS)
        {   
            pNewBuffer = NULL;
            ASSERTAndBreak(Status == NDIS_STATUS_SUCCESS);
            break;
        }

        //
        // Make the new Ndis Buffer the head
        //
        {
            PNDIS_PACKET_PRIVATE pPrivate = &pRcvStruct->pNewPacket->Private;

            //
            // Save the head and tail of the old packet
            //
            pIpBuffer->pOldHead = pPrivate->Head ;  
            pIpBuffer->pOldTail = pPrivate->Tail ;  


            //
            // Now set up the new packet
            //
            pNewBuffer->Next = NULL;
            pPrivate->Head = pNewBuffer;
            pPrivate->Tail = pNewBuffer; 


            pPrivate->ValidCounts= FALSE;

            pRcvStruct->pPktContext->Stack.ipv4Recv.pIpBuffer = pIpBuffer;

        }
        
        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);    


    if (Status == NDIS_STATUS_SUCCESS)
    {
        pRcvStruct->pNewBuffer = pNewBuffer;
        pRcvStruct->pIpBuffer = pIpBuffer;
    }
    else
    {
        pRcvStruct->pNewBuffer  = NULL;
        pRcvStruct->pIpBuffer = NULL;
        if (pIpBuffer != NULL)
        {
            epvcFreeToNPagedLookasideList (&pMiniport->rcv.LookasideList,
                                       (PVOID)pIpBuffer);           

        }
    }

    TRACE (TL_T, TM_Pt, ("<==epvcAddEthHeaderToNewPacket Status %x ", Status))
    
    return Status;
}



NDIS_STATUS
epvcCopyNdisBufferChain (
    IN PEPVC_RCV_STRUCT pRcvStruct, 
    IN PNDIS_BUFFER pInBuffer,
    IN PUCHAR pCurrOffset 
    )
{

    //
    //  This function copies the data the belongs to the 
    //  pInMdl chain to the local Buffer. 
    //  BufferLength is used for validation purposes only
    //  Fragmentation and insertion of headers will take place here
    //


    UINT BufferLength = MAX_ETHERNET_FRAME- sizeof (EPVC_ETH_HEADER);
    
    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;

    UINT        LocalBufferIndex = 0;       // Used as an index to the LocalBuffer, used for validation

    UINT        MdlLength = 0;              

    PUCHAR      MdlAddress = NULL;
    
    PNDIS_BUFFER pCurrBuffer = pInBuffer;

    PUCHAR      pLocalBuffer = pCurrOffset;

    extern UCHAR LLCSnapIpv4[8];

    //
    // Use the pStartOfValidData for the first MDL
    //

    MdlLength = NdisBufferLength(pCurrBuffer);
    MdlAddress= NdisBufferVirtualAddress(pCurrBuffer);

    //
    // Adjust for the LLC Header if any
    //

    
    if (pRcvStruct->fLLCHeader == TRUE)
    {
        //
        // We have an LLC encapsulation
        // 
        MdlLength -= sizeof (LLCSnapIpv4);
        ASSERT (pRcvStruct->pStartOfValidData - MdlAddress == sizeof (LLCSnapIpv4));
        
        MdlAddress = pRcvStruct->pStartOfValidData;
    }


    //
    //  Copy the first buffer Data to local memory.
    //


    NdisMoveMemory((PVOID)((ULONG_PTR)pLocalBuffer),
                MdlAddress,
                MdlLength);

    LocalBufferIndex += MdlLength;

    pCurrBuffer = pCurrBuffer->Next;

    //
    // now walk through the ndis buffer chain
    //
    
    while (pCurrBuffer!= NULL)
    {
    
    
        MdlLength = NdisBufferLength(pCurrBuffer);
        MdlAddress= NdisBufferVirtualAddress(pCurrBuffer);


        if (MdlLength != 0)
        {
            if (MdlAddress == NULL)
            {
                NdisStatus = NDIS_STATUS_FAILURE;
                break;
            }

            if ( LocalBufferIndex + MdlLength > BufferLength)
            {

                ASSERT(LocalBufferIndex + MdlLength <= BufferLength);

                NdisStatus = NDIS_STATUS_BUFFER_TOO_SHORT;

                break;
            }

            //
            //  Copy the Data to local memory.
            //


            NdisMoveMemory((PVOID)((ULONG_PTR)pLocalBuffer+LocalBufferIndex),
                        MdlAddress,
                        MdlLength);

            LocalBufferIndex += MdlLength;
        }

        pCurrBuffer = pCurrBuffer->Next;

    } 
    pRcvStruct->BytesCopied += LocalBufferIndex;

    return NdisStatus;

}



VOID
epvcValidatePacket (
    IN PNDIS_PACKET pPacket
    )
/*++

Routine Description:

    Takes a packet and makes sure that the MDL chain is valid
Arguments:


Return Value:

--*/
{
    ULONG TotalLength = 0;
    //ASSERT (pPacket->Private.Tail->Next == NULL);


    if (pPacket->Private.Head != pPacket->Private.Tail)
    {
        PNDIS_BUFFER pTemp = pPacket->Private.Head;
        
        while (pTemp != NULL)
        {
            TotalLength += NdisBufferLength(pTemp);
            pTemp = pTemp->Next;
        }

    }
    else
    {
        TotalLength += NdisBufferLength(pPacket->Private.Head);
        
    }

    if (TotalLength != pPacket->Private.TotalLength)
    {
        ASSERT (pPacket->Private.ValidCounts == FALSE);
    }
}   


BOOLEAN
epvcIsPacketLengthAcceptable (
    IN PNDIS_PACKET Packet, 
    IN PEPVC_I_MINIPORT pMiniport
    )
/*++

Routine Description:

    Validates the packet length of an incoming packet
Arguments:


Return Value:

--*/

{   
    UINT PktLength;
    BOOLEAN fValid = FALSE;

    epvcQueryPacket (Packet, NULL, NULL, NULL, &PktLength);

    fValid =  (PktLength >= pMiniport->MinAcceptablePkt);

    if (fValid == TRUE)
    {
        fValid = (PktLength <= pMiniport->MaxAcceptablePkt);
    }
    
    return fValid;
    

}



NDIS_STATUS
epvcStripHeaderFromNewPacket (
    IN PEPVC_RCV_STRUCT pRcvStruct, 
    IN PEPVC_I_MINIPORT pMiniport
    )
/*++

Routine Description:

    In the pure bridged (ethernet) encapsulation, all ethernet packets 
    are preceeded by a 0x00, 0x00 header. Check if it is present 

    in the ethernet/llc case, verify the LLC header is correct.

    In both cases, allocate a new Ndis Buffer which does not include the
    2684 headers.

    Store the old head and tail into the NdisPacket and send it up to the
    

    
Arguments:


Return Value:

--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_FAILURE;
    PNDIS_PACKET    pPacket = NULL;
    PNDIS_BUFFER    pHead, pNewHead =NULL;
    ULONG           CurLength = 0;
    PUCHAR          pCurVa = NULL;
    ULONG           EpvcHeaderLength = 0;
    PUCHAR          pEpvcHeader = NULL;
    BOOLEAN         fIsCorrectHeader ;
    do
    {
        //
        // we are not interested in the pure ipv4 case
        //
        if (pMiniport->Encap == IPV4_ENCAP_TYPE)
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }


        pPacket = pRcvStruct->pNewPacket;
        pHead = pPacket->Private.Head;      

        switch (pMiniport->Encap)
        {
            case IPV4_LLC_SNAP_ENCAP_TYPE:
            case ETHERNET_LLC_SNAP_ENCAP_TYPE:
            {
                EpvcHeaderLength = pMiniport->LlcHeaderLength; 
                pEpvcHeader = pMiniport->pLllcHeader;
                break;
            }
            case ETHERNET_ENCAP_TYPE:
            {
                EpvcHeaderLength = ETHERNET_PADDING_LENGTH; 
                pEpvcHeader = &gPaddingBytes[0];
                break;
            }                        
                
            case IPV4_ENCAP_TYPE:
            default:
            {
                //
                // pMiniport->Encap is only allowed four values,
                // therefore we should never hit the defualt case.
                //
                Status = NDIS_STATUS_FAILURE; 
                ASSERT (Status != NDIS_STATUS_FAILURE);
                return Status;

            }
            
        }

        //
        // Adjust the length and start VA of the MDL
        //
        CurLength = NdisBufferLength(pHead); 

        pCurVa = NdisBufferVirtualAddress(pHead);


        //
        // Check arguments
        //
        if (pCurVa == NULL)
        {
            break;
        }

        if (CurLength <= EpvcHeaderLength )
        {
            //
            // we do not handle the case where the header is longer than
            // the first mdl
            //
            ASSERT (CurLength > EpvcHeaderLength );
            break;
        }

        //
        // Compare and make sure that it is the right header
        //
        
        fIsCorrectHeader = NdisEqualMemory (pCurVa , 
                                           pEpvcHeader, 
                                           EpvcHeaderLength) ;

        
        // If the IsCorrectheader is still false, then there is more to do
        if (fIsCorrectHeader == FALSE)
        {
            break;
        }


        if (pMiniport->fDoIpEncapsulation == TRUE)
        {
            //
            // In the case of IPEncap + LLC Header, the function
            // which adds the Mac Header will strip the LLC Header
            //
            Status= NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // Strip the LLC Header Length
        //
        CurLength -= EpvcHeaderLength;
        pCurVa += EpvcHeaderLength;

        epvcAllocateBuffer(&Status ,
                            &pNewHead, 
                            NULL,
                            pCurVa, 
                            CurLength
                            );
                            
        if (Status != NDIS_STATUS_SUCCESS)
        {   
            pNewHead = NULL;
            break;
        }

        //
        // Set up the Packet context
        //

        pPacket->Private.ValidCounts= FALSE;

        pRcvStruct->pPktContext->Stack.EthLLC.pOldHead = pHead;
        pRcvStruct->pPktContext->Stack.EthLLC.pOldTail = pPacket->Private.Tail;
        
        //
        // Set the New Ndis buffer in the Packet
        //
        pNewHead->Next = pHead->Next;

        pPacket->Private.Head = pNewHead;

        if (pPacket->Private.Tail == pHead)
        {
               //
               // Update the Tail of the packet as well
               //
               pPacket->Private.Tail = pNewHead; 
        }

        Status = NDIS_STATUS_SUCCESS;
    

    } while (FALSE);


    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\sys\util.h ===
#ifndef _UTIL_H
#define _UTIL_H

NDIS_STATUS
epvcAllocateTask(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription, OPTIONAL
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    );


VOID
epvcSetPrimaryAdapterTask(
    PEPVC_ADAPTER pAdapter,         // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    );


VOID
epvcClearPrimaryAdapterTask(
    PEPVC_ADAPTER pAdapter,         // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    );
    
VOID
epvcSetSecondaryAdapterTask(
    PEPVC_ADAPTER pAdapter,         // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    );

VOID
epvcClearSecondaryAdapterTask(
    PEPVC_ADAPTER pAdapter,         // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    );

VOID
epvcTaskDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    );

NDIS_STATUS
epvcCopyUnicodeString(
        OUT         PNDIS_STRING pDest,
        IN          PNDIS_STRING pSrc,
        BOOLEAN     fUpCase
        );

VOID
epvcSetFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask );

VOID
epvcClearFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask );
    
ULONG
epvcReadFlags(
    IN ULONG* pulFlags );

BOOLEAN
epvcIsThisTaskPrimary (
    PRM_TASK pTask,
    PRM_TASK* ppLocation 
    );


VOID
epvcClearPrimaryTask (
    PRM_TASK* ppLocation 
    );


#if DBG

    VOID
    Dump(
        IN CHAR* p,
        IN ULONG cb,
        IN BOOLEAN fAddress,
        IN ULONG ulGroup );



#else


    #define Dump(p,cb,fAddress,ulGroup )

#endif


#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define net_short(_x) _byteswap_ushort((USHORT)(_x))
#define net_long(_x)  _byteswap_ulong(_x)
#else
__inline
USHORT
FASTCALL
net_short(
    UINT NaturalData)
{
    USHORT ShortData = (USHORT)NaturalData;

    return (ShortData << 8) | (ShortData >> 8);
}

// if x is aabbccdd (where aa, bb, cc, dd are hex bytes)
// we want net_long(x) to be ddccbbaa.  A small and fast way to do this is
// to first byteswap it to get bbaaddcc and then swap high and low words.
//
__inline
ULONG
FASTCALL
net_long(
    ULONG NaturalData)
{
    ULONG ByteSwapped;

    ByteSwapped = ((NaturalData & 0x00ff00ff) << 8) |
                  ((NaturalData & 0xff00ff00) >> 8);

    return (ByteSwapped << 16) | (ByteSwapped >> 16);
}
#endif

NDIS_STATUS
epvcAllocateTaskUsingLookasideList(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PEPVC_NPAGED_LOOKASIDE_LIST pList,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription, OPTIONAL
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    );



VOID
epvcInitializeLookasideList(
    IN OUT PEPVC_NPAGED_LOOKASIDE_LIST pLookasideList,
    ULONG Size,
    ULONG Tag,
    USHORT Depth
    );


VOID
epvcDeleteLookasideList (
    IN OUT PEPVC_NPAGED_LOOKASIDE_LIST pLookasideList
    );


PVOID
epvcGetLookasideBuffer(
    IN  PEPVC_NPAGED_LOOKASIDE_LIST pLookasideList
    );

VOID
epvcFreeToNPagedLookasideList (
    IN PEPVC_NPAGED_LOOKASIDE_LIST pLookasideList,
    IN PVOID    pBuffer
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\sys\rmdbg.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    dbg.h

Abstract:

    Debug-related definitions for RM Apis in ATMEPVC

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    ADube     03-23-00    created, .

--*/



//-----------------------------------------------------------------------------
// Debug constants
//-----------------------------------------------------------------------------

// Memory tags used with NdisAllocateMemoryWithTag to identify allocations
// made by the EPVC driver.  Also, several context blocks define a first field
// of 'ulTag' set to these values for ASSERT sanity checking and eased memory
// dump browsing.  Such tags are set to MTAG_FREED just before NdisFreeMemory
// is called.
//

// Rm/generic tags
// 
#define MTAG_DBGINFO    'd31A'
#define MTAG_TASK       't31A'
#define MTAG_STRING     's31A'
#define MTAG_FREED      'z31A'
#define MTAG_RMINTERNAL 'r31A'


// Trace levels.
//
#define TL_FATAL    TL_A // Fatal errors -- always printed in checked build.
#define TL_WARN     TL_I // Warnings
#define TL_INFO     TL_N // Informational (highest level workable for general use)
#define TL_VERB     TL_V     // VERBOSE


#if DBG

#define TR_FATAL(Args)                                         \
    TRACE(TL_FATAL, TM_RM, Args)

#define TR_INFO(Args)                                          \
    TRACE(TL_INFO, TM_RM, Args)

#define TR_WARN(Args)                                          \
    TRACE(TL_WARN,TM_RM, Args)

#define TR_VERB(Args)                                          \
    TRACE(TL_VERB, TM_RM, Args)

#define ENTER(_Name, _locid)                                    \
    char *dbg_func_name =  (_Name);                             \
    UINT dbg_func_locid = (_locid);
    
#define EXIT()


// ASSERT checks caller's assertion expression and if false, prints a kernel
// debugger message and breaks.
//
#undef ASSERT
#define ASSERT(x)                                               \
{                                                               \
    if (!(x))                                                   \
    {                                                           \
        DbgPrint( "EPVC: !ASSERT( %s ) L:%d,F:%s\n",            \
            #x, __LINE__, __FILE__ );                           \
        DbgBreakPoint();                                        \
    }                                                           \
}

#define ASSERTEX(x, ctxt)                                       \
{                                                               \
    if (!(x))                                                   \
    {                                                           \
        DbgPrint( "Epvc: !ASSERT( %s ) C:0x%p L:%d,F:%s\n",     \
            #x, (ctxt), __LINE__, __FILE__ );                   \
        DbgBreakPoint();                                        \
    }                                                           \
}

//
// DbgMark does nothing useful. But it is convenient to insert DBGMARK in
// places in your code while debugging, and set a breakpoint on DbgMark, so that
// the debugger will stop at the places you inserted DBGMARK. It's a bit more
// flexible than inserting a hardcoded DbgBreakPoint.
//
void DbgMark(UINT Luid);
#define DBGMARK(_Luid) DbgMark(_Luid)


#define DBGSTMT(_stmt)      _stmt

#define RETAILASSERTEX ASSERTEX
#define RETAILASSERT   ASSERT


// TRACE0 is like TRACE, except that it doesn't print the prefix.
//
#define TRACE0(ulLevel,  Args)                                  \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & TM_CURRENT)) \
    {                                                          \
        DbgPrint Args;                                         \
    }                                                          \
}



#else // !DBG

#define TR_FATAL(Args)
#define TR_INFO(Args)
#define TR_WARN(Args)
#define TR_VERB(Args)
// Debug macros compile out of non-DBG builds.
//
#undef ASSERT
#define ASSERT(x)
#define ASSERTEX(x, ctxt)
#define ENTER(_Name, _locid)
#define EXIT()
#define DBGMARK(_Luid) (0)
#define DBGSTMT(_stmt)


#define RETAILASSERT(x)                                         \
{                                                               \
    if (!(x))                                                   \
    {                                                           \
        DbgPrint( "EPVC: !RETAILASSERT( %s ) L:%d,F:%s\n",      \
            #x, __LINE__, __FILE__ );                           \
        DbgBreakPoint();                                        \
    }                                                           \
}

#define RETAILASSERTEX(x, ctxt)                                 \
{                                                               \
    if (!(x))                                                   \
    {                                                           \
        DbgPrint( "EPVC: !RETAILASSERT( %s ) C:0x%p L:%d,F:%s\n",\
            #x, (ctxt), __LINE__, __FILE__ );                   \
        DbgBreakPoint();                                        \
    }                                                           \
}

#endif



#if BINARY_COMPATIBLE
#define         ASSERT_PASSIVE() (0)
#else // !BINARY_COMPATIBLE
#define     ASSERT_PASSIVE() \
                ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL)
            
#endif // !BINARY_COMPATIBLE
//-----------------------------------------------------------------------------
// Prototypes
//-----------------------------------------------------------------------------

VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks );

VOID
Dump(
    CHAR* p,
    ULONG cb,
    BOOLEAN fAddress,
    ULONG ulGroup );

VOID
DumpLine(
    CHAR* p,
    ULONG cb,
    BOOLEAN  fAddress,
    ULONG ulGroup );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\sys\rm.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    rm.h

Abstract:

    "Resource Manager" structures and APIs

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    josephj     11-10-98    created

--*/

//=================================================================================
//                  O S - S P E C I F I C   T Y P E S
//=================================================================================

#define RM_OS_LOCK                          NDIS_SPIN_LOCK
#define OS_WORK_ITEM                        NDIS_WORK_ITEM
#define OS_TIMER                            NDIS_TIMER

#define RM_STATUS                            NDIS_STATUS

#define RM_OS_FILL_MEMORY(_dest, _len, _fill) NdisFillMemory(_dest, _len, _fill)
#define RM_OS_ZERO_MEMORY(_dest, _len)        NdisZeroMemory(_dest, _len)
#define RM_OS_GET_CURRENT_THREAD_HANDLE()     NULL

// If set, the object tree is explicitly maintained.
//
#define RM_TRACK_OBJECT_TREE 1

//=================================================================================
//                  F O R W A R D       R E F E R E N C E S
//=================================================================================

typedef struct _RM_STACK_RECORD     RM_STACK_RECORD,        *PRM_STACK_RECORD;
typedef struct _RM_OBJECT_HEADER    RM_OBJECT_HEADER,       *PRM_OBJECT_HEADER;
typedef struct _RM_TASK             RM_TASK,                *PRM_TASK;
typedef struct _RM_RESOURCE_TABLE_ENTRY
                                RM_RESOURCE_TABLE_ENTRY, *PRM_RESOURCE_TABLE_ENTRY;


//=================================================================================
//                  T Y P E D E F S
//=================================================================================

//
// RM_DBG_LOCK_INFO Keeps debugging information specific to an instance of a RM_LOCK.
//
typedef struct _RM_DBG_LOCK_INFO
{
    //
    // If nonzero, LocID is a magic number which uniquely identifies the source
    // location where the lock was aquired.
    //
    ULONG uLocID;

    //
    // pSR points to the stack record of the currently owning thread, if there
    // is one. If a function F expects an object pObj to be locked on entry,
    // it can  ASSERT(pObj->pLock->pDbgInfo->pSR == pSR);
    //
    struct _RM_STACK_RECORD *pSR;


} RM_DBG_LOCK_INFO, *PRM_DBG_LOCK_INFO;

//
// RM_LOCK keeps information about a lock.
//
typedef struct _RM_LOCK
{
    //
    // Native, os-provided lock structure.
    //
    RM_OS_LOCK OsLock;

    //
    // Level of this lock. Multiple locks can only be acquired in increasing order
    // of this value.
    //
    ULONG Level;

    //
    // Pointer to debugging info for this lock. Could be NULL.
    //
    PRM_DBG_LOCK_INFO pDbgInfo;

#if RM_EXTRA_CHECKING
    RM_DBG_LOCK_INFO DbgInfo;
#endif // RM_EXTRA_CHECKING

} RM_LOCK, *PRM_LOCK;


typedef
ULONG
(*PFNLOCKVERIFIER) (
        PRM_LOCK            pLock,
        BOOLEAN             fLock,
        PVOID               pContext,
        PRM_STACK_RECORD    pSR
    );

// RM_LOCKING_INFO keeps information about a particular lock being held.
// In non-checking mode, this is just the pointer to the lock.
// In checking mode, this additionally contains information that can be used
// to verify that the entity being protected by the lock is not changed when
// the lock is not being held.
//
typedef struct
{
    PRM_LOCK pLock;

#if RM_EXTRA_CHECKING
    PFNLOCKVERIFIER pfnVerifier;
    PVOID           pVerifierContext;
#endif // RM_EXTRA_CHECKING

}  RM_LOCKING_INFO, PRM_LOCKING_INFO;

//
// RM_STACK_RECORD keeps information relevant to the current call tree.
//
typedef struct _RM_STACK_RECORD
{
    //
    // LockInfo contains information about currently-held locks.
    //
    struct
    {
        //
        // Level of the currently held lock. Locks must be claimed in
        // order of increasing Level values. The lowest level value is 1. Level
        // 0 indicates no locks held.
        //
        UINT    CurrentLevel;

        //
        // Pointer to the first location to store a pointers to a locks.
        //
        PRM_LOCKING_INFO *pFirst;

        //
        // Pointer to the next free location to store a pointer to a lock
        // that has been claimed in this call tree.
        //
        PRM_LOCKING_INFO *pNextFree;

        //
        // Pointer to the last valid location to store a lock pointer.
        //
        PRM_LOCKING_INFO *pLast;

    } LockInfo;


    //
    // Count of tmp refs taken with this stack record.
    //
    ULONG TmpRefs;

#if DBG

    //
    // DbgInfo contains diagnostic information relevant to this call tree.
    //
    struct
    {
        //
        // Verbosity level
        //
        ULONG Level;

        //
        //  Points to the os-provided thread handle of the current thread.
        //  if there is one.
        //
        PVOID pvThread;


    } DbgInfo;

#endif // DBG

} RM_STACK_RECORD, *PRM_STACK_RECORD;

#if DBG
    #define RM_INIT_DBG_STACK_RECORD(_sr, _dbglevel)                \
        _sr.DbgInfo.Level           = _dbglevel;                    \
        _sr.DbgInfo.pvThread        = RM_OS_GET_CURRENT_THREAD_HANDLE();
#else
    #define RM_INIT_DBG_STACK_RECORD(_sr, _dbglevel)
#endif 

//
// RM_DECLARE_STACK_RECORD_EX is a macro to reserve some stack space for
// a stack record.
//
#define RM_DECLARE_STACK_RECORD_EX(_sr, _max_locks, _dbglevel)      \
    RM_LOCKING_INFO rm_lock_array[_max_locks];                      \
    RM_STACK_RECORD _sr;                                            \
    RM_OS_ZERO_MEMORY(rm_lock_array, sizeof(rm_lock_array));        \
    _sr.TmpRefs                 = 0;                                \
    _sr.LockInfo.CurrentLevel   = 0;                                \
    _sr.LockInfo.pFirst     = rm_lock_array;                    \
    _sr.LockInfo.pNextFree  = rm_lock_array;                    \
    _sr.LockInfo.pLast      = rm_lock_array+(_max_locks)-1;     \
    RM_INIT_DBG_STACK_RECORD(_sr, _dbglevel);


//
// RM_DECLARE_STACK_RECORD is a macro to reserve default stack space for
// a stack record.
//
#define RM_DECLARE_STACK_RECORD(_sr)                                \
    RM_DECLARE_STACK_RECORD_EX(_sr, 4, 0)



//
// Generic memory allocator prototype
//
typedef
PVOID
(*PFN_RM_MEMORY_ALLOCATOR)(
    PVOID pAllocationContext,
    UINT  Size                  // in bytes
    );

//
// Generic memory deallocator prototype
//
typedef
PVOID
(*PFN_RM_MEMORY_DEALLOCATOR)(
    PVOID pMem,
    PVOID pAllocationContext
    );


//  RM_HASH_LINK is the field in the structures being hashed that is
//  used to link all items in the same bucket. It also contains the
//  "HashKey", which is a potentially-nonunique UINT-sized hash of the
//  real key.
//
typedef struct _RM_HASH_LINK
{
    struct _RM_HASH_LINK *pNext;
    UINT                  uHash;
} RM_HASH_LINK, *PRM_HASH_LINK;


//
// Hash table comparison function.
//
typedef
BOOLEAN
(*PFN_RM_COMPARISON_FUNCTION)(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    );


//
// Hash computation function.
//
typedef
ULONG
(*PFN_RM_HASH_FUNCTION)(
    PVOID           pKey
    );


//
// RM_HASH_INFO specifies customizing information about a hash table.
//
typedef struct
{
    // Allocator used to allocate the hash table if it needs to grow.
    //
    PFN_RM_MEMORY_ALLOCATOR pfnTableAllocator;

    // Free function for the above allocator.
    PFN_RM_MEMORY_DEALLOCATOR pfnTableDeallocator;

    // Comparison function for strict equality.
    //
    PFN_RM_COMPARISON_FUNCTION pfnCompare;

    // Function to generate a ULONG-sized hash.
    //
    PFN_RM_HASH_FUNCTION pfnHash;

#if OBSOLETE
    // Offset in sizeof(UINT) to location of the place to keep
    // the next pointer for the bucket list.
    //
    UINT    OffsetNext;

    // Offset in sizeof(UINT) to location of UINT-sized Temp ref
    //
    UINT    OffsetTmpRef;

    // Offset in sizeof(UINT) to location of UINT-sized Tot ref
    //
    UINT    OffsetTotRef;

    // Offset in sizeof(UINT) to location of ULONG-sized hash key.
    //
    UINT    OffsetHashKey;
#endif // OBSOLETE

} RM_HASH_INFO, *PRM_HASH_INFO;

#define RM_MIN_HASH_TABLE_SIZE 4

//
// RM_HASH_TABLE is a hash table.
//
typedef struct
{
    //  Number of items currently in hash table.
    //
    UINT NumItems;

    //  Stats is a 32-bit quantity keeps a running total of number of accesses
    //  (add+search+remove) in the HIWORD and the total number of list nodes
    //  traversed in the LOWORD. This field gets updated even on searches, but
    //  it is not protected by the hash table lock -- instead it is
    //  updated using  an interlocked operation. This allows us to use
    //  a read lock for searches while still updating this statistic value.
    //  The Stats field is re-scaled when the counts get too high, to avoid
    //  overflow and also to favor more recent stats in preference to older
    //  stats.
    //
    //  NumItems, Stats and TableLength are used to decide whether to
    //  dynamically resize the hash table.
    //
    ULONG Stats;

    //  Length of hash table in units of PVOID
    //
    ULONG TableLength;

    // Pointer to TableLength-sized array of PVOIDs -- this is the actual hash table
    //
    PRM_HASH_LINK *pTable;


    // The hash table
    //
    PRM_HASH_LINK InitialTable[RM_MIN_HASH_TABLE_SIZE];

    // Static information about this hash table.
    //
    PRM_HASH_INFO pHashInfo;

    // Passed into the allocate/deallocate functions.
    //
    PVOID pAllocationContext;

} RM_HASH_TABLE, *PRM_HASH_TABLE;

// Returns approximate value of (num-nodes-traversed)/(num-accesses)
//
#define RM_HASH_TABLE_TRAVERSE_RATIO(_pHash_Table) \
            (((_pHash_Table)->Stats & 0xffff) / (1+((_pHash_Table)->Stats >> 16)))
            //
            // NOTE: the "1+" above is simply to guard against devide-by-zero.


//
// RM_OBJECT_DIAGNOSTIC_INFO keeps diagnostic info specific to an instance of
// an object.
//
// This structure is for private use of the RM APIs.
// The only field of general interest is PrevState.
//
typedef struct
{
    // Back pointer to owning object.
    //
    RM_OBJECT_HEADER *pOwningObject;

    // Each time the object-specific State field is updated, it's previous
    // value is saved here.
    //
    ULONG               PrevState;

    // Used for correctly updating PrevState.
    //
    ULONG               TmpState;

    // Diagnostic-related state.
    //
    ULONG               DiagState;
    #define fRM_PRIVATE_DISABLE_LOCK_CHECKING (0x1<<0)

    // This is an object-specific checksum that is computed and 
    // saved just before the object is unlocked. It is  checked
    // just after the object is locked.
    //
    ULONG               Checksum;

    // Native OS lock to be *only* to serialize access to the information
    // in this structure.
    //
    RM_OS_LOCK          OsLock;

    // Keeps an associative list of all entities which have been registered
    // (using RmDbgAddAssociation) with this object. Ths includes objects which
    // have been linked to this object using the RmLinkObjects call, as well
    // as childen and parents of this object.
    //
    RM_HASH_TABLE       AssociationTable;

    // Following is set to TRUE IFF  there was an allocation failure when trying to
    // add an association. If there'e been an allocation failure, we don't complain
    // (i.e. ASSERT) if an attempt is made to remove an assertion that doesn't
    // exist. In this way we gracefully deal with allocation failures of the
    // association table entries.
    //
    INT                 AssociationTableAllocationFailure;

    // The per-object list of log entries.
    // This is serialized by the global rm lock, not the local rm-private lock!
    //
    LIST_ENTRY          listObjectLog;

    // Count of entries in this object's log.
    // This is serialized by the global rm lock, not the local rm-private lock!
    //
    UINT                NumObjectLogEntries;

#if TODO    // We haven't implemented the following yet...

    // Future:
    // RM_STATE_HISTORY -- generalization of PrevState.

#endif //  TODO


} RM_OBJECT_DIAGNOSTIC_INFO, *PRM_OBJECT_DIAGNOSTIC_INFO;

typedef
PRM_OBJECT_HEADER
(*PFN_CREATE_OBJECT)(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    psr
        );

typedef
VOID
(*PFN_DELETE_OBJECT)(PRM_OBJECT_HEADER, PRM_STACK_RECORD psr);


//
// RM_STATIC_OBJECT_INFO keeps information that is common to all instances of
// a particular type of object.
//
typedef struct
{
    ULONG   TypeUID;
    ULONG   TypeFlags;
    char*   szTypeName;
    UINT    Timeout;

    //
    // Various Handlers
    //
    PFN_CREATE_OBJECT           pfnCreate;
    PFN_DELETE_OBJECT           pfnDelete;
    PFNLOCKVERIFIER             pfnLockVerifier;

    //
    // Resource Information
    //
    UINT    NumResourceTableEntries;
    struct  _RM_RESOURCE_TABLE_ENTRY *  pResourceTable;

    //
    // Hash-table info, if this object is part of a group.
    //
    PRM_HASH_INFO pHashInfo;

} RM_STATIC_OBJECT_INFO, *PRM_STATIC_OBJECT_INFO;

//
// RM_OBJECT_HEADER is the common header for all objects.
//
typedef struct _RM_OBJECT_HEADER
{
    //
    // Object-type-specific signature.
    //
    ULONG Sig;

    //
    // Description of this object (could be the same as pStaticInfo->szTypeName,
    // but may be something more specific).
    // Used only for debugging purposes.
    // TODO: consider moving this into the pDiagInfo struct. For now, leave it
    // here because it's useful when debugging.
    //
    const char *szDescription;

    //
    // Object-specific state.
    //
    ULONG State;

    ULONG RmState; // One or more RMOBJSTATE_* or RMTSKSTATE_* flags below...

    //
    // RM state flags....
    //
    
    // Object allocation state...
    //
    #define RMOBJSTATE_ALLOCMASK        0x00f
    #define RMOBJSTATE_ALLOCATED        0x001
    #define RMOBJSTATE_DEALLOCATED      0x000

    // Task state ...
    //
    #define RMTSKSTATE_MASK             0x0f0
    #define RMTSKSTATE_IDLE             0x000
    #define RMTSKSTATE_STARTING         0x010
    #define RMTSKSTATE_ACTIVE           0x020
    #define RMTSKSTATE_PENDING          0x030
    #define RMTSKSTATE_ENDING           0x040

    //  Task delay state
    //
    #define RMTSKDELSTATE_MASK          0x100
    #define RMTSKDELSTATE_DELAYED       0x100

    //  Task abort state
    //
    #define RMTSKABORTSTATE_MASK        0x200
    #define RMTSKABORTSTATE_ABORT_DELAY 0x200

    //
    // Bitmap identifying resources used by this object.
    //
    ULONG ResourceMap;

    // Total reference count.
    //
    //
    ULONG TotRefs;


    //
    // Pointer to a RM_LOCK object used to serialize access to this object.
    //
    PRM_LOCK pLock;

    //
    // Pointer to information common to all instances of this object type.
    //
    PRM_STATIC_OBJECT_INFO    pStaticInfo;

    //
    // Points to diagnostic information about this object.  Could be NULL.
    //
    PRM_OBJECT_DIAGNOSTIC_INFO pDiagInfo;


    //
    //  Points to the parent object.
    //
    struct _RM_OBJECT_HEADER *pParentObject;

    //
    //  Points to the root (ancestor of all object) -- could be the same
    //  as pParentObject;
    //
    struct _RM_OBJECT_HEADER *pRootObject;

    //
    // This is a private lock used exclusively by the RM apis. It is
    // never left unlocked by the RM apis.
    // TODO: maybe make this a native-os lock.
    //
    RM_LOCK RmPrivateLock;

    // Used to create groups of objects.
    // TODO: make this a private field, present only if the object is
    // meant to be in a group.
    //
    RM_HASH_LINK HashLink;

#if RM_TRACK_OBJECT_TREE
    LIST_ENTRY          listChildren; // Protected by this object's RmPrivateLock.
    LIST_ENTRY          linkSiblings; // Protected by parent object's RmPrivateLock.
    
#endif // RM_TRACK_OBJECT_TREE

    ULONG TempRefs;

} RM_OBJECT_HEADER, *PRM_OBJECT_HEADER;


//
// Diagnostic resource tracking.
//
typedef struct
{
    ULONG_PTR               Instance;
    ULONG                   TypeUID;
    PRM_OBJECT_HEADER       pParentObject;
    ULONG                   CallersUID;
    ULONG                   CallersSrUID;

} RM_DBG_RESOURCE_ENTRY;


typedef enum
{
    RM_RESOURCE_OP_LOAD,
    RM_RESOURCE_OP_UNLOAD

} RM_RESOURCE_OPERATION;

typedef
RM_STATUS
(*PFN_RM_RESOURCE_HANDLER)(
    PRM_OBJECT_HEADER       pObj,
    RM_RESOURCE_OPERATION   Op,
    PVOID                   pvUserParams,
    PRM_STACK_RECORD        psr
);

typedef struct _RM_RESOURCE_TABLE_ENTRY
{
    UINT                    ID;
    PFN_RM_RESOURCE_HANDLER pfnHandler;
    
} RM_RESOURCE_TABLE_ENTRY, *PRM_RESOURCE_TABLE_ENTRY;


typedef struct
{
    UINT u;

} RM_OBJECT_INDEX,  *PRM_OBJECT_INDEX;


typedef struct
{
    PRM_OBJECT_HEADER           pOwningObject;
    const char *                szDescription;
    PRM_STATIC_OBJECT_INFO      pStaticInfo;
    RM_HASH_TABLE               HashTable;


    // Private lock used ONLY by group access functions.
    //
    RM_OS_LOCK                      OsLock;

    // When non-NULL, points to the task responsible for unloading all objects
    // in this group.
    //
    PRM_TASK                    pUnloadTask;

    BOOLEAN fEnabled;

} RM_GROUP,  *PRM_GROUP;


typedef enum
{
    RM_TASKOP_START,
    RM_TASKOP_PENDCOMPLETE,
    RM_TASKOP_END,
    RM_TASKOP_PRIVATE,
    RM_TASKOP_ABORT,
    RM_TASKOP_TIMEOUT

} RM_TASK_OPERATION;


typedef
RM_STATUS
(*PFN_RM_TASK_HANDLER)(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Op,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );
//
// For START and PENDCOMPLETE, a return value other than PENDING causes
// the task to end. Of course, it is illegal to return non-pending when
// the task is in a pending state.
//


// Task allocator prototype
//
typedef
RM_STATUS
(*PFN_RM_TASK_ALLOCATOR)(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription,
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    );

typedef struct _RM_TASK
{
    RM_OBJECT_HEADER                Hdr;

    PFN_RM_TASK_HANDLER             pfnHandler;
    LIST_ENTRY                      linkFellowPendingTasks;
    LIST_ENTRY                      listTasksPendingOnMe;
    struct _RM_TASK *               pTaskIAmPendingOn;


    // In the case that we need to asynchronously notify the completion of a
    // pending operation, we can save the completion param here.
    //
    UINT_PTR                        AsyncCompletionParam;

    UINT                            SuspendContext;

} RM_TASK, *PRM_TASK;

typedef
VOID
(*PFN_DBG_DUMP_LOG_ENTRY) (
    char *szFormatString,
    UINT_PTR Param1,
    UINT_PTR Param2,
    UINT_PTR Param3,
    UINT_PTR Param4
);


#if RM_EXTRA_CHECKING

// (For debugging only)
// Keeps track of a single association (See RmDbgAddAssociation)
// This is a PRIVATE data structure, and is only here because
// the kd extension refers to it.
//
typedef struct
{
    ULONG           LocID;
    ULONG_PTR       Entity1;
    ULONG_PTR       Entity2;
    ULONG           AssociationID;
    const char *    szFormatString;
    RM_HASH_LINK    HashLink;

} RM_PRIVATE_DBG_ASSOCIATION;

// (For debugging only)
// Keeps track of a single per-object log entry.
// This is a PRIVATE data structure, and is only here because
// the kd extension refers to it.
//
typedef struct
{
    // Link to other entries for this object
    //
    LIST_ENTRY linkObjectLog;

    // Link to other entries in the global list.
    //
    LIST_ENTRY linkGlobalLog;

    // Object this entry belongs to
    //
    PRM_OBJECT_HEADER   pObject;

    // Function to be used for dumping the log.
    //
    PFN_DBG_DUMP_LOG_ENTRY pfnDumpEntry;

    // Prefix string to be dumped *before* the log display.
    // This was added so we could log associations properly, otherwise it's
    // extra baggage. Can be null.
    //
    char *szPrefix;

    // Format string for log display -- 1st arg to pfnDumpEntry
    //
    char *szFormatString;

    // Remaining args to pfnDumpEntry;
    //
    //
    UINT_PTR Param1;
    UINT_PTR Param2;
    UINT_PTR Param3;
    UINT_PTR Param4;

    // If non-NULL, piece of memory to be freed when the log entry is freed.
    // TODO: See notes.txt  entry "03/07/1999 ... Registering root objects with RM"
    // on how we will find the deallocator function. For now we simply
    // use NdisFreeMemory.
    //
    PVOID pvBuf;

} RM_DBG_LOG_ENTRY;

#endif RM_EXTRA_CHECKING

//=================================================================================
//                      U T I L I T Y       M A C R O S
//=================================================================================

#define RM_PARENT_OBJECT(_pObj)             \
            ((_pObj)->Hdr.pParentObject)

#define RM_PEND_CODE(_pTask)                \
            ((_pTask)->SuspendContext)

#define RM_ASSERT_SAME_LOCK_AS_PARENT(_pObj)                                        \
                ASSERTEX(                                                       \
                    ((_pObj)->Hdr.pLock == (_pObj)->Hdr.pParentObject->pLock),  \
                    (_pObj))

#define RM_SET_STATE(_pObj, _Mask, _Val)    \
            (((_pObj)->Hdr.State) = (((_pObj)->Hdr.State) & ~(_Mask)) | (_Val))

#define RM_CHECK_STATE(_pObj, _Mask, _Val)  \
            ((((_pObj)->Hdr.State) & (_Mask)) == (_Val))

#define RM_GET_STATE(_pObj, _Mask)  \
            (((_pObj)->Hdr.State) & (_Mask))

// Asserts that the object is in the "zombie" state, i.e., it
// lives on just because of references.
// WARNING: It is upto the caller to synchronize access to this -- for example
// if they're going to do thing's like if (!RM_IS_ZOMBIE(pObj)) {do-stuff}, they
// had better make sure that only one of them goes on to "does-stuff".
//
#define RM_IS_ZOMBIE(_pobj) \
            (((_pobj)->Hdr.RmState&RMOBJSTATE_ALLOCMASK)==RMOBJSTATE_DEALLOCATED)

// Asserts that no locks are held.
//
#define RM_ASSERT_NOLOCKS(_psr) \
        ASSERTEX((_psr)->LockInfo.CurrentLevel == 0, (_psr))

// Assert that no locks or tmprefs are held.
//
#define RM_ASSERT_CLEAR(_psr) \
        ASSERTEX(((_psr)->LockInfo.CurrentLevel==0), (_psr)); \
        ASSERTEX((_psr)->TmpRefs==0, (_psr));

#if RM_EXTRA_CHECKING

//
// TODO: rename the following to something better...
//

#define RM_DBG_ASSERT_LOCKED0(_pLk, _pSR)   \
    ASSERTEX((_pLk)->DbgInfo.pSR == (_pSR), (_pHdr))

// TODO -- replace calls to this by calls to RM_ASSERT_OBJLOCKED
#define RM_DBG_ASSERT_LOCKED(_pHdr, _pSR)   \
    ASSERTEX((_pHdr)->pLock->DbgInfo.pSR == (_pSR), (_pHdr))

#define RM_ASSERT_OBJLOCKED(_pHdr, _pSR)    \
    ASSERTEX((_pHdr)->pLock->DbgInfo.pSR == (_pSR), (_pHdr))

// Note that we can't assume DbgInfo.pSR is NULL below (it could be locked
// by some other thread), but we CAN assert that DbgInfo.pSR is not equal to the
// current pSR!
//
#define RM_ASSERT_OBJUNLOCKED(_pHdr, _pSR)  \
    ASSERTEX((_pHdr)->pLock->DbgInfo.pSR != (_pSR), (_pHdr))

#else // !RM_EXTRA_CHECKING

#define RM_DBG_ASSERT_LOCKED0(_pLk, _pSR)   (0)
#define RM_DBG_ASSERT_LOCKED(_pHdr, _pSR)   (0)
#define RM_ASSERT_OBJLOCKED(_pHdr, _pSR)    (0)
#define RM_ASSERT_OBJUNLOCKED(_pHdr, _pSR)  (0)


#endif // !RM_EXTRA_CHECKING

#define RM_NUM_ITEMS_IN_GROUP(_pGroup) \
            ((_pGroup)->HashTable.NumItems)

//=================================================================================
//                  F U N C T I O N     P R O T O T Y P E S
//=================================================================================

VOID
RmInitializeRm(VOID);

VOID
RmDeinitializeRm(VOID);

VOID
RmInitializeHeader(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  UINT                        Sig,
    IN  PRM_LOCK                    pLock,
    IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,
    IN  const char *                szDescription,
    IN  PRM_STACK_RECORD            pSR
    );
//
// Object allocation and deallocation APIs
//

VOID
RmDeallocateObject(
    IN  PRM_OBJECT_HEADER           pObject,
    IN  PRM_STACK_RECORD            pSR
    );


//
// locking
//

VOID
RmInitializeLock(
    IN PRM_LOCK pLock,
    IN UINT     Level
    );

VOID
RmDoWriteLock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    );

#if TODO
VOID
RmDoReadLock(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    );
#else //!TODO
#define RmDoReadLock    RmDoWriteLock
#endif //!TODO

VOID
RmDoUnlock(
    PRM_LOCK                pLock,
    PRM_STACK_RECORD        pSR
    );


#if TODO
VOID
RmReadLockObject(
    IN  PRM_OBJECT_HEADER           pObj,
#if RM_EXTRA_CHECKING
    UINT                            uLocID,
#endif //RM_EXTRA_CHECKING
    IN  PRM_STACK_RECORD            pSR
    );
#else //!TODO
#define RmReadLockObject RmWriteLockObject
#endif //!TODO

VOID
RmWriteLockObject(
    IN  PRM_OBJECT_HEADER           pObj,
#if RM_EXTRA_CHECKING
    UINT                            uLocID,
#endif //RM_EXTRA_CHECKING
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnlockObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnlockAll(
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmDbgChangeLockScope(
    IN  PRM_OBJECT_HEADER           pPreviouslyLockedObject,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG                       LocID,
    IN  PRM_STACK_RECORD            
    );

//
// reference counting
//

VOID
RmLinkObjects(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  PRM_STACK_RECORD            pSr
    );

VOID
RmUnlinkObjects(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  PRM_STACK_RECORD            pSr
    );

VOID
RmLinkObjectsEx(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  ULONG                       LocID,
    IN  ULONG                       AssocID,
    IN  const char *                szAssociationFormat,
    IN  ULONG                       InvAssocID,
    IN  const char *                szInvAssociationFormat,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnlinkObjectsEx(
    IN  PRM_OBJECT_HEADER           pObj1,
    IN  PRM_OBJECT_HEADER           pObj2,
    IN  ULONG                       LocID,
    IN  ULONG                       AssocID,
    IN  ULONG                       InvAssocID,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmLinkToExternalEx(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  ULONG                       LocID,
    IN  UINT_PTR                    ExternalEntity,
    IN  ULONG                       AssocID,
    IN  const char *                szAssociationFormat,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnlinkFromExternalEx(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  ULONG                       LocID,
    IN  UINT_PTR                    ExternalEntity,
    IN  ULONG                       AssocID,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmLinkToExternalFast( // TODO make inline
    IN  PRM_OBJECT_HEADER           pObj
    );

VOID
RmUnlinkFromExternalFast(   // TODO make inline
    IN  PRM_OBJECT_HEADER           pObj
    );

VOID
RmTmpReferenceObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmTmpDereferenceObject(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    );

//
// Generic resource management
//

RM_STATUS
RmLoadGenericResource(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  UINT                        GenericResourceID,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnloadGenericResource(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  UINT                        GenericResourceID,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnloadAllGenericResources(
    IN  PRM_OBJECT_HEADER           pObj,
    IN  PRM_STACK_RECORD            pSR
    );

//
// Diagnostic per-object tracking of arbitrary "associations"
//

//
// NOTE: AssociationID must not have the high-bit set. Associations with the
// high bit set are reserved for internal use of the Rm API implementation.
//

VOID
RmDbgAddAssociation(
    IN  ULONG                       LocID,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG_PTR                   Instance1,
    IN  ULONG_PTR                   Instance2,
    IN  ULONG                       AssociationID,
    IN  const char *                szFormatString, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmDbgDeleteAssociation(
    IN  ULONG                       LocID,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  ULONG_PTR                   Entity1,
    IN  ULONG_PTR                   Entity2,
    IN  ULONG                       AssociationID,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmDbgPrintAssociations(
    IN  PRM_OBJECT_HEADER pObject,
    IN  PRM_STACK_RECORD pSR
    );

//
// Diagnostic per-object logging.
//

VOID
RmDbgLogToObject(
    IN  PRM_OBJECT_HEADER       pObject,
    IN  char *                  szPrefix,       OPTIONAL
    IN  char *                  szFormatString,
    IN  UINT_PTR                Param1,
    IN  UINT_PTR                Param2,
    IN  UINT_PTR                Param3,
    IN  UINT_PTR                Param4,
    IN  PFN_DBG_DUMP_LOG_ENTRY  pfnDumpEntry,   OPTIONAL
    IN  PVOID                   pvBuf           OPTIONAL
    );


VOID
RmDbgPrintObjectLog(
    IN PRM_OBJECT_HEADER pObject
    );

VOID
RmDbgPrintGlobalLog(VOID);

//
// Groups of Objects
//


VOID
RmInitializeGroup(
    IN  PRM_OBJECT_HEADER           pOwningObject,
    IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,
    IN  PRM_GROUP                   pGroup,
    IN  const char*                 szDescription,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmDeinitializeGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_STACK_RECORD            pSR
    );

RM_STATUS
RmLookupObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  ULONG                       Flags, // Lookup flags defined below
    IN  PVOID                       pvKey,
    IN  PVOID                       pvCreateParams,
    OUT PRM_OBJECT_HEADER *         ppObject,
    OUT INT *                       pfCreated,
    IN  PRM_STACK_RECORD            pSR
    );

//
//  Lookup flags
//
#define RM_CREATE       0x1
#define RM_NEW          (0x1<<1)
#define RM_LOCKED       (0x1<<2)


#define RM_CREATE_AND_LOCK_OBJECT_IN_GROUP(_pGrp, _pKey, _pParams, _ppHdr, _fC,_psr)\
        RmLookupObjectInGroup(                                                      \
                            (_pGrp),                                                \
                            RM_CREATE|RM_NEW|RM_LOCKED,                             \
                            (_pKey),                                                \
                            (_pParams),                                             \
                            (_ppHdr),                                               \
                            (_fC),                                                  \
                            (_psr)                                                  \
                            );

// RM_STATUS
// RM_LOOKUP_AND_LOCK_OBJECT_IN_GROUP(
//                  PRM_GROUP           _pGrp,
//                  PVOID               _pKey,
//                  PRM_OBJECT_HEADER * _ppHdr,
//                  PRM_STACK_RECORD    _psr
//                  )
// Lookup (don't create) and lock an object in the specified group.
//
#define RM_LOOKUP_AND_LOCK_OBJECT_IN_GROUP(_pGrp, _pKey, _ppHdr, _psr)              \
        RmLookupObjectInGroup(                                                      \
                            (_pGrp),                                                \
                            RM_LOCKED,                                              \
                            (_pKey),                                                \
                            NULL,                                                   \
                            (_ppHdr),                                               \
                            NULL,                                                   \
                            (_psr)                                                  \
                            );

RM_STATUS
RmGetNextObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_OBJECT_HEADER           pCurrentObject,     OPTIONAL
    OUT PRM_OBJECT_HEADER *         ppNextObject,
    IN  PRM_STACK_RECORD            pSR
    );


VOID
RmFreeObjectInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_OBJECT_HEADER           pObject,
    IN  struct _RM_TASK             *pTask, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmFreeAllObjectsInGroup(
    IN  PRM_GROUP                   pGroup,
    IN  struct _RM_TASK             *pTask, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmUnloadAllObjectsInGroup(
    IN  PRM_GROUP                   pGroup,
    PFN_RM_TASK_ALLOCATOR           pfnUnloadTaskAllocator,
    PFN_RM_TASK_HANDLER             pfnUnloadTaskHandler,
    PVOID                           pvUserParam,
    IN  struct _RM_TASK             *pTask, OPTIONAL
    IN  UINT                        uTaskPendCode, OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    );

VOID
RmEnableGroup(
    IN  PRM_GROUP                   pGroup,
    IN  PRM_STACK_RECORD            pSR
    );



// Enumeration function prototype. This function is passed into
// RmEnumerateObjectsInGroup and gets called for each object in the group
// until the function returns FALSE.
//
typedef
INT
(*PFN_RM_GROUP_ENUMERATOR) (
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        );

VOID
RmEnumerateObjectsInGroup(
    PRM_GROUP               pGroup,
    PFN_RM_GROUP_ENUMERATOR pfnFunction,
    PVOID                   pvContext,
    INT                     fStrong,
    PRM_STACK_RECORD        pSR
    );

VOID
RmWeakEnumerateObjectsInGroup(
    PRM_GROUP               pGroup,
    PFN_RM_GROUP_ENUMERATOR pfnFunction,
    PVOID                   pvContext,
    PRM_STACK_RECORD        pSR
    );

//
// Task APIs
//

VOID
RmInitializeTask(
IN  PRM_TASK                    pTask,
IN  PRM_OBJECT_HEADER           pParentObject,
IN  PFN_RM_TASK_HANDLER         pfnHandler,
IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,    OPTIONAL
IN  const char *                szDescription,  OPTIONAL
IN  UINT                        Timeout,
IN  PRM_STACK_RECORD            pSR
);


RM_STATUS
RmStartTask(
IN  PRM_TASK                    pTask,
IN  UINT_PTR                    UserParam,
IN  PRM_STACK_RECORD            pSR
);


VOID
RmAbortTask(
IN  PRM_TASK                    pTask,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmDbgDumpTask(
IN  PRM_TASK                    pTask,
IN  PRM_STACK_RECORD            pSR
);

RM_STATUS
RmSuspendTask(
IN  PRM_TASK                    pTask,
IN  UINT                        SuspendContext,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmUnsuspendTask(
IN  PRM_TASK                    pTask,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmResumeTask(
IN  PRM_TASK                    pTask,
IN  UINT_PTR                    SuspendCompletionParam,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmResumeTaskAsync(
IN  PRM_TASK                    pTask,
IN  UINT_PTR                    SuspendCompletionParam,
IN  OS_WORK_ITEM            *   pOsWorkItem,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmResumeTaskDelayed(
IN  PRM_TASK                    pTask,
IN  UINT_PTR                    SuspendCompletionParam,
IN  ULONG                       MsDelay,
IN  OS_TIMER                *   pOsTimerObject,
IN  PRM_STACK_RECORD            pSR
);


VOID
RmResumeDelayedTaskNow(
IN  PRM_TASK                    pTask,
IN  OS_TIMER                *   pOsTimer,
OUT PUINT                       pTaskResumed,
IN  PRM_STACK_RECORD            pSR
);

RM_STATUS
RmPendTaskOnOtherTask(
IN  PRM_TASK                    pTask,
IN  UINT                        SuspendContext,
IN  PRM_TASK                    pOtherTask,
IN  PRM_STACK_RECORD            pSR
);

// See  03/26/1999 notes.txt entry "Some proposed ..."
//
RM_STATUS
RmPendOnOtherTaskV2(
IN  PRM_TASK                    pTask,
IN  UINT                        SuspendContext,
IN  PRM_TASK                    pOtherTask,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmCancelPendOnOtherTask(
IN  PRM_TASK                    pTask,
IN  PRM_TASK                    pOtherTask,
IN  UINT_PTR                    UserParam,
IN  PRM_STACK_RECORD            pSR
);

//
// Timer management
//
VOID
RmResetAgeingTimer(
IN  PRM_OBJECT_HEADER           pObj,
IN  UINT                        Timeout,
IN  PRM_STACK_RECORD            pSR
);

//
// Hash table manipulation.
//

VOID
RmInitializeHashTable(
PRM_HASH_INFO pHashInfo,
PVOID         pAllocationContext,
PRM_HASH_TABLE pHashTable
);

VOID
RmDeinitializeHashTable(
PRM_HASH_TABLE pHashTable
);

BOOLEAN
RmLookupHashTable(
PRM_HASH_TABLE      pHashTable,
PRM_HASH_LINK **    pppLink,
PVOID               pvRealKey
);

BOOLEAN
RmNextHashTableItem(
PRM_HASH_TABLE      pHashTable,
PRM_HASH_LINK       pCurrentLink,   // OPTIONAL
PRM_HASH_LINK *    ppNextLink
);

VOID
RmAddHashItem(
PRM_HASH_TABLE  pHashTable,
PRM_HASH_LINK * ppLink,
PRM_HASH_LINK   pLink,
PVOID           pvKey
);

VOID
RmRemoveHashItem(
PRM_HASH_TABLE  pHashTable,
PRM_HASH_LINK   pLinkToRemove
);

typedef
VOID
(*PFN_ENUM_HASH_TABLE)
(
PRM_HASH_LINK pLink,
PVOID pvContext,
PRM_STACK_RECORD pSR
);

VOID
RmEnumHashTable(
PRM_HASH_TABLE          pHashTable,
PFN_ENUM_HASH_TABLE     pfnEnumerator,
PVOID                   pvContext,
PRM_STACK_RECORD        pSR
);

#if OBSOLETE
//
// Indexes of objects.
//

RM_STATUS
RmAllocateObjectIndex(
IN  PRM_OBJECT_HEADER           pParentObject,
// OBSOLETE IN  PRM_OBJECT_ALLOCATOR        pObjectAllocator,
IN  PRM_STATIC_OBJECT_INFO      pStaticInfo,
IN  PULONG                      Flags,
OUT PRM_OBJECT_INDEX *          ppObjectIndex,
IN  PRM_STACK_RECORD            pSR
);

VOID
RmFreeObjectIndex(
IN  PRM_OBJECT_INDEX            pObjectIndex,
IN  PRM_STACK_RECORD            pSR
);

RM_STATUS
RmLookupObjectInIndex(
IN  PRM_OBJECT_INDEX            pObjectIndex,
IN  PULONG                      Flags, // create, remove, lock
IN  PVOID                       pvKey,
OUT PRM_OBJECT_HEADER *         ppObject,
IN  PRM_STACK_RECORD            pSR
);


RM_STATUS
RmRemoveObjectFromIndex(
IN  PRM_OBJECT_INDEX            pObjectIndex,
IN  PRM_OBJECT_HEADER           pObject,
IN  PRM_STACK_RECORD            pSR
);

typedef
RM_STATUS
(*PFN_RM_OBJECT_INDEX_ENUMERATOR)(
IN  PRM_OBJECT_HEADER           pObject,
IN  PVOID                       pvContext,
IN  PRM_STACK_RECORD            pSR
);

RmEnumerateObjectsInIndex(
IN  PRM_OBJECT_INDEX            pObjectIndex,
IN  PFN_RM_OBJECT_INDEX_ENUMERATOR
                                pfnEnumerator,
IN  PRM_STACK_RECORD            pSR
);

#endif // OBSOLETE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\sys\util.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    util.c

Abstract:

    ATMEPVC - utilities

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    ADube     03-23-00    created, .

--*/


#include "precomp.h"
#pragma hdrstop


#if DO_TIMESTAMPS

void
epvcTimeStamp(
    char *szFormatString,
    UINT Val
    )
{
    UINT Minutes;
    UINT Seconds;
    UINT Milliseconds;
    LARGE_INTEGER Time;
    NdisGetCurrentSystemTime(&Time);
    Time.QuadPart /= 10000;         //10-nanoseconds to milliseconds.
    Milliseconds = Time.LowPart; // don't care about highpart.
    Seconds = Milliseconds/1000;
    Milliseconds %= 1000;
    Minutes = Seconds/60;
    Seconds %= 60;


    DbgPrint( szFormatString, Minutes, Seconds, Milliseconds, Val);
}

#endif // DO_TIMESTAMPS

//------------------------------------------------------------------------
//                                                                      //
//  Task Data structures and functions begin here                       //
//                                                                      //
//----------------------------------------------------------------------//


//
// EpvcTasks_StaticInfo contains static information about
// objects of type  EPVC_TASK;
//
RM_STATIC_OBJECT_INFO
EpvcTasks_StaticInfo = 
{
    0, // TypeUID
    0, // TypeFlags
    "ATM Epvc Task",    // TypeName
    0, // Timeout

    NULL, // pfnCreate
    epvcTaskDelete, // pfnDelete
    NULL,   // LockVerifier

    0,   // length of resource table
    NULL // Resource Table
};


VOID
epvcTaskDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    )
/*++

Routine Description:

    Free an object of type EPVC_TASK.

Arguments:

    pHdr    - Actually a pointer to the EPVC_TASK to be deleted.

--*/
{
    EPVC_FREE(pObj);
}



NDIS_STATUS
epvcAllocateTask(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription, OPTIONAL
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Allocates and initializes a task of subtype ARP1394_TASK.

Arguments:

    pParentObject       - Object that is to be the parent of the allocated task.
    pfnHandler          - The task handler for the task.
    Timeout             - Unused.
    szDescription       - Text describing this task.
    ppTask              - Place to store pointer to the new task.

Return Value:

    NDIS_STATUS_SUCCESS if we could allocate and initialize the task.
    NDIS_STATUS_RESOURCES otherwise
--*/
{
    EPVC_TASK *pATask;
    NDIS_STATUS Status;

    Status = EPVC_ALLOCSTRUCT(pATask, TAG_TASK); // TODO use lookaside lists.
        
    *ppTask = NULL;

    if (pATask != NULL && (FAIL(Status)== FALSE))
    {
        EPVC_ZEROSTRUCT(pATask);

        RmInitializeTask(
                &(pATask->TskHdr),
                pParentObject,
                pfnHandler,
                &EpvcTasks_StaticInfo,
                szDescription,
                Timeout,
                pSR
                );
        *ppTask = &(pATask->TskHdr);
        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;
    }

    return Status;
}




NDIS_STATUS
epvcAllocateTaskUsingLookasideList(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PEPVC_NPAGED_LOOKASIDE_LIST pList,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription, OPTIONAL
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Allocates and initializes a task of subtype ARP1394_TASK.

Arguments:

    pParentObject       - Object that is to be the parent of the allocated task.
    pfnHandler          - The task handler for the task.
    Timeout             - Unused.
    szDescription       - Text describing this task.
    ppTask              - Place to store pointer to the new task.

Return Value:

    NDIS_STATUS_SUCCESS if we could allocate and initialize the task.
    NDIS_STATUS_RESOURCES otherwise
--*/
{
    EPVC_TASK *pATask;
    NDIS_STATUS Status;

    pATask = epvcGetLookasideBuffer (pList);

    
    Status = EPVC_ALLOCSTRUCT(pATask, TAG_TASK); // TODO use lookaside lists.
        
    *ppTask = NULL;

    if (pATask != NULL && (FAIL(Status)== FALSE))
    {
        EPVC_ZEROSTRUCT(pATask);

        RmInitializeTask(
                &(pATask->TskHdr),
                pParentObject,
                pfnHandler,
                &EpvcTasks_StaticInfo,
                szDescription,
                Timeout,
                pSR
                );
        *ppTask = &(pATask->TskHdr);
        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;
    }

    return Status;
}




VOID
epvcSetPrimaryAdapterTask(
    PEPVC_ADAPTER pAdapter,         // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("epvcSetPrimaryAdapterTask", 0x49c9e2d5)
    RM_ASSERT_OBJLOCKED(&pAdapter->Hdr, pSR);

    ASSERT(pAdapter->bind.pPrimaryTask==NULL);

#if DBG
    // Veriy that this is a valid primary task. Also verify that PrimaryState
    // is a valid primary state.
    //
    {
        PFN_RM_TASK_HANDLER pfn = pTask->pfnHandler;
        ASSERT(
            ((pfn == epvcTaskInitializeAdapter) && (PrimaryState == EPVC_AD_PS_INITING))
         || ((pfn == epvcTaskShutdownAdapter) && (PrimaryState == EPVC_AD_PS_DEINITING))
            );
    }
#endif // DBG

    //
    // Although it's tempting to put pTask as entity1 and pRask->Hdr.szDescption as
    // entity2 below, we specify NULL for both so that we can be sure that ONLY one
    // primary task can be active at any one time.
    //
    DBG_ADDASSOC(
        &pAdapter->Hdr,
        NULL,                           // Entity1
        NULL,                           // Entity2
        EPVC_ASSOC_AD_PRIMARY_TASK,
        "   Primary task\n",
        pSR
        );

    pAdapter->bind.pPrimaryTask = pTask;
    SET_AD_PRIMARY_STATE(pAdapter, PrimaryState);

    EXIT()
}


VOID
epvcClearPrimaryAdapterTask(
    PEPVC_ADAPTER pAdapter,         // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("epvcClearPrimaryAdapterTask", 0x593087b1)

    RM_ASSERT_OBJLOCKED(&pAdapter->Hdr, pSR);
    ASSERT(pAdapter->bind.pPrimaryTask==pTask);

    // Veriy that PrimaryState is a valid primary state.
    //
    ASSERT(
            (PrimaryState == EPVC_AD_PS_INITED)
        ||  (PrimaryState == EPVC_AD_PS_FAILEDINIT)
        ||  (PrimaryState == EPVC_AD_PS_DEINITED)
        );

    // Delete the association added when setting the primary IF task
    //
    DBG_DELASSOC(
        &pAdapter->Hdr,
        NULL,
        NULL,
        EPVC_ASSOC_AD_PRIMARY_TASK,
        pSR
        );

    pAdapter->bind.pPrimaryTask = NULL;
    SET_AD_PRIMARY_STATE(pAdapter, PrimaryState);

    EXIT()
}


VOID
epvcSetSecondaryAdapterTask(
    PEPVC_ADAPTER pAdapter,         // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("epvcSetSecondaryAdapterTask", 0x56bbb567)
    RM_ASSERT_OBJLOCKED(&pAdapter->Hdr, pSR);

    if (pAdapter->bind.pSecondaryTask != NULL)
    {
        ASSERT(FALSE);
        return;                                     // EARLY RETURN
    }

#if DBG
    // Veriy that this is a valid act/deact task. Also verify that SecondaryState
    // is a valid state.
    //
    {
        PFN_RM_TASK_HANDLER pfn = pTask->pfnHandler;
        ASSERT(
               ((pfn == epvcTaskActivateAdapter) && (SecondaryState == EPVC_AD_AS_ACTIVATING))
            || ((pfn == epvcTaskDeactivateAdapter) && (SecondaryState == EPVC_AD_AS_DEACTIVATING))
            );
    }
#endif // DBG

    //
    // Although it's tempting to put pTask as entity1 and pRask->Hdr.szDescption as
    // entity2 below, we specify NULL for both so that we can be sure that ONLY one
    // primary task can be active at any one time.
    //
    DBG_ADDASSOC(
        &pAdapter->Hdr,
        NULL,                           // Entity1
        NULL,                           // Entity2
        EPVC_ASSOC_ACTDEACT_AD_TASK,
        "   Secondary task\n",
        pSR
        );

    pAdapter->bind.pSecondaryTask = pTask;
    SET_AD_ACTIVE_STATE(pAdapter, SecondaryState);

    EXIT()
}


VOID
epvcClearSecondaryAdapterTask(
    PEPVC_ADAPTER pAdapter,         // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    )
{
    ENTER("epvcClearSecondaryAdapterTask", 0x698552bd)
    RM_ASSERT_OBJLOCKED(&pAdapter->Hdr, pSR);

    if (pAdapter->bind.pSecondaryTask != pTask)
    {
        ASSERT(FALSE);
        return;                                     // EARLY RETURN
    }

    // Veriy that SecondaryState is a valid primary state.
    //
    ASSERT(
            (SecondaryState == EPVC_AD_AS_ACTIVATED)
        ||  (SecondaryState == EPVC_AD_AS_FAILEDACTIVATE)
        ||  (SecondaryState == EPVC_AD_AS_DEACTIVATED)
        );

    // Delete the association added when setting the primary IF task
    //
    DBG_DELASSOC(
        &pAdapter->Hdr,
        NULL,
        NULL,
        EPVC_ASSOC_ACTDEACT_AD_TASK,
        pSR
        );

    pAdapter->bind.pSecondaryTask = NULL;
    SET_AD_ACTIVE_STATE(pAdapter, SecondaryState);

    EXIT()
}



NDIS_STATUS
epvcCopyUnicodeString(
        OUT         PNDIS_STRING pDest,
        IN          PNDIS_STRING pSrc,
        BOOLEAN     fUpCase
        )
/*++

Routine Description:

    Copy the contents of unicode string pSrc into pDest.
    pDest->Buffer is allocated using NdisAllocateMemoryWithTag; Caller is
    responsible for freeing it.

    EXTRA EXTRA EXTRA:
        This make sure the destination is NULL terminated.
        IPAddInterface expects the Unicode string passed in to be
        NULL terminated.

Return Value:

    NDIS_STATUS_SUCCESS on success;
    NDIS failure status on failure.
--*/
{
    USHORT Length = pSrc->Length;
    PWCHAR pwStr;
    epvcAllocateMemoryWithTag(&pwStr, Length+sizeof(WCHAR), MTAG_STRING);
    EPVC_ZEROSTRUCT(pDest);

    if  (pwStr == NULL)
    {
        return NDIS_STATUS_RESOURCES;
    }
    else
    {
        pDest->Length = Length;
        pDest->MaximumLength = Length+sizeof(WCHAR);

        pDest->Buffer = pwStr;

        {
            NdisMoveMemory(pwStr, pSrc->Buffer, Length);
            if (Length & 0x1)
            {
                ((PUCHAR)pwStr)[Length] = 0;
            }
            else
            {
                pwStr[Length/sizeof(*pwStr)] = 0;
            }
        }

        return NDIS_STATUS_SUCCESS;
    }
}





VOID
epvcSetFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask )

    // Set 'ulMask' bits in '*pulFlags' flags as an interlocked operation.
    //
{
    ULONG ulFlags;
    ULONG ulNewFlags;

    do
    {
        ulFlags = *pulFlags;
        ulNewFlags = ulFlags | ulMask;
    }
    while (InterlockedCompareExchange(
               pulFlags, ulNewFlags, ulFlags ) != (LONG )ulFlags);
}

VOID
epvcClearFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask )

    // Set 'ulMask' bits in '*pulFlags' flags as an interlocked operation.
    //
{
    ULONG ulFlags;
    ULONG ulNewFlags;

    do
    {
        ulFlags = *pulFlags;
        ulNewFlags = ulFlags & ~(ulMask);
    }
    while (InterlockedCompareExchange(
               pulFlags, ulNewFlags, ulFlags ) != (LONG )ulFlags);
}

ULONG
epvcReadFlags(
    IN ULONG* pulFlags )

    // Read the value of '*pulFlags' as an interlocked operation.
    //
{
    return *pulFlags;
}



BOOLEAN
epvcIsThisTaskPrimary (
    PRM_TASK pTask,
    PRM_TASK* ppLocation 
    )
{
    BOOLEAN fIsThisTaskPrimary = FALSE;

    ASSERT (*ppLocation != pTask);

    if (*ppLocation  == NULL)
    {
        *ppLocation = pTask;
        return TRUE;
    }
    else
    {
        return FALSE;
        
    }
}

VOID
epvcClearPrimaryTask (
    PRM_TASK* ppLocation 
    )
{

        *ppLocation = NULL;

}



#if DBG
VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks )

    // Tries to detect corruption in list 'pList', printing verbose linkage
    // output if 'fShowLinks' is set.
    //
{
    LIST_ENTRY* pLink;
    ULONG ul;

    ul = 0;
    for (pLink = pList->Flink;
         pLink != pList;
         pLink = pLink->Flink)
    {
        if (fShowLinks)
        {
            DbgPrint( "EPVC: CheckList($%p) Flink(%d)=$%p\n",
                pList, ul, pLink );
        }
        ++ul;
    }

    for (pLink = pList->Blink;
         pLink != pList;
         pLink = pLink->Blink)
    {
        if (fShowLinks)
        {
            DbgPrint( "EPVC: CheckList($%p) Blink(%d)=$%p\n",
                pList, ul, pLink );
        }
        --ul;
    }

    if (ul)
    {
        DbgBreakPoint();
    }
}
#endif


#if DBG
VOID
Dump(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )

    // Hex dump 'cb' bytes starting at 'p' grouping 'ulGroup' bytes together.
    // For example, with 'ulGroup' of 1, 2, and 4:
    //
    // 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
    // 0000 0000 0000 0000 0000 0000 0000 0000 |................|
    // 00000000 00000000 00000000 00000000 |................|
    //
    // If 'fAddress' is true, the memory address dumped is prepended to each
    // line.
    //
{
    while (cb)
    {
        INT cbLine;

        cbLine = (cb < DUMP_BytesPerLine) ? cb : DUMP_BytesPerLine;
        DumpLine( p, cbLine, fAddress, ulGroup );
        cb -= cbLine;
        p += cbLine;
    }
}
#endif

#if DBG
VOID
DumpLine(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )
{
    CHAR* pszDigits = "0123456789ABCDEF";
    CHAR szHex[ ((2 + 1) * DUMP_BytesPerLine) + 1 ];
    CHAR* pszHex = szHex;
    CHAR szAscii[ DUMP_BytesPerLine + 1 ];
    CHAR* pszAscii = szAscii;
    ULONG ulGrouped = 0;

    if (fAddress)
        DbgPrint( "EPVC: %p: ", p );
    else
        DbgPrint( "EPVC: " );

    while (cb)
    {
        *pszHex++ = pszDigits[ ((UCHAR )*p) / 16 ];
        *pszHex++ = pszDigits[ ((UCHAR )*p) % 16 ];

        if (++ulGrouped >= ulGroup)
        {
            *pszHex++ = ' ';
            ulGrouped = 0;
        }

        *pszAscii++ = (*p >= 32 && *p < 128) ? *p : '.';

        ++p;
        --cb;
    }

    *pszHex = '\0';
    *pszAscii = '\0';

    DbgPrint(
        "%-*s|%-*s|\n",
        (2 * DUMP_BytesPerLine) + (DUMP_BytesPerLine / ulGroup), szHex,
        DUMP_BytesPerLine, szAscii );
}
#endif





VOID
epvcInitializeLookasideList(
    IN OUT PEPVC_NPAGED_LOOKASIDE_LIST pLookasideList,
    ULONG Size,
    ULONG Tag,
    USHORT Depth
    )
/*++

Routine Description:
  Allocates and initializes a epvc Lookaside list

Arguments:


Return Value:


--*/
{
    TRACE( TL_T, TM_Mp, ( "==> epvcInitializeLookasideList pLookaside List %x, size %x, Tag %x, Depth %x, ", 
                                pLookasideList, Size, Tag, Depth) );
                             
    NdisInitializeNPagedLookasideList( &pLookasideList->List,
                                       NULL,                        //Allocate 
                                       NULL,                            // Free
                                       0,                           // Flags
                                       Size,
                                       Tag,
                                       Depth );                             // Depth

    pLookasideList->Size =  Size;
    pLookasideList->bIsAllocated = TRUE;

    TRACE( TL_T, TM_Mp, ( "<== epvcInitializeLookasideList " ) );
}   
                                  

VOID
epvcDeleteLookasideList (
    IN OUT PEPVC_NPAGED_LOOKASIDE_LIST pLookasideList
    )

/*++

Routine Description:
    Deletes a lookaside list, only if it has been allocated

Arguments:


Return Value:


--*/
{
    TRACE( TL_T, TM_Mp, ( "==> epvcDeleteLookasideList  pLookaside List %x",pLookasideList ) );

    if (pLookasideList && pLookasideList->bIsAllocated == TRUE)
    {
        while (pLookasideList->OutstandingPackets != 0)
        {
            NdisMSleep( 10000);
        
        }
        
        NdisDeleteNPagedLookasideList (&pLookasideList->List);
    }

    TRACE( TL_T, TM_Mp, ( "<== epvcDeleteLookasideList pLookaside List %x", pLookasideList) );
    
}


PVOID
epvcGetLookasideBuffer(
    IN  PEPVC_NPAGED_LOOKASIDE_LIST pLookasideList
    )
    // Function Description:
    //    Allocate an buffer from the lookaside list.
    //    will be changed to a macro
    //
    //
    //
    // Arguments
    //  Lookaside list - from which the buffer is allocated
    //
    //
    // Return Value:
    //  Return buffer can be NULL
    //
{

    PVOID pLocalBuffer = NULL;
    
    TRACE( TL_T, TM_Send, ( "==>epvcGetLookasideBuffer pList %x",pLookasideList) );
    
    ASSERT (pLookasideList != NULL);

    //
    // Optimize the lookaside list code path
    //
    pLocalBuffer = NdisAllocateFromNPagedLookasideList (&pLookasideList->List);

    if (pLocalBuffer != NULL)
    {   
        NdisZeroMemory (pLocalBuffer, pLookasideList->Size); 
        NdisInterlockedIncrement (&pLookasideList->OutstandingPackets);
    }
    else
    {
        epvcIncrementMallocFailure();
    }

        
    
    TRACE( TL_T, TM_Send, ( "<==epvcGetLookasideBuffer, %x", pLocalBuffer ) );
    
    return pLocalBuffer ;

}


VOID
epvcFreeToNPagedLookasideList (
    IN PEPVC_NPAGED_LOOKASIDE_LIST pLookasideList,
    IN PVOID    pBuffer
    )

    // Function Description:
    //   Return the local buffer to the lookaside list
    //
    // Atguments
    // Lookaside list and its buffer
    // Return Value:
    // None 
{

    
    TRACE( TL_T, TM_Send, ( "==> epvcFreeToNPagedLookasideList , Lookaside list %x, plocalbuffer %x",pLookasideList, pBuffer ) );

    NdisFreeToNPagedLookasideList (&pLookasideList->List, pBuffer);     
    NdisInterlockedDecrement (&pLookasideList->OutstandingPackets);

    TRACE( TL_T, TM_Send, ( "<== epvcFreeToNPagedLookasideList ") );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\inc\atm40.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation

Module Name:

	atm.h

Abstract:

	This module defines the structures, macros, and manifests available
	to ATM aware components.

Author:

	Jameel Hyder - jameelh@microsoft.com

Revision History:

	Initial Version - March 1996
#ifdef MS_UNI4
	John Dalgas (v-jdalga)	09/18/97		added support for UNI4.0 ATM CM
#endif // MS_UNI4

--*/

#ifndef	_ATM_H_
#define	_ATM_H_

//
// Address type
//
typedef ULONG	ATM_ADDRESSTYPE;

#define	ATM_NSAP				0
#define	ATM_E164				1

//
// ATM Address
//
#define	ATM_MAC_ADDRESS_LENGTH	6		// Same as 802.x
#define	ATM_ADDRESS_LENGTH		20

//
//  Special characters in ATM address string used in textual representations
//
#define ATM_ADDR_BLANK_CHAR				L' '
#define ATM_ADDR_PUNCTUATION_CHAR		L'.'
#define ATM_ADDR_E164_START_CHAR		L'+'

typedef struct _ATM_ADDRESS
{
	ATM_ADDRESSTYPE				AddressType;
	ULONG						NumberOfDigits;
	UCHAR						Address[ATM_ADDRESS_LENGTH];
} ATM_ADDRESS, *PATM_ADDRESS;



//
// AAL types that the miniport supports
//
#define	AAL_TYPE_AAL0			1
#define	AAL_TYPE_AAL1			2
#define	AAL_TYPE_AAL34			4
#define	AAL_TYPE_AAL5			8

typedef ULONG	ATM_AAL_TYPE, *PATM_AAL_TYPE;


//
// Flags for Information Element types
//
#define ATM_IE_RESPONSE_FLAG		0x80000000
#define ATM_IE_EMPTY_FLAG			0x40000000


//
// Types of Information Elements
//
typedef enum
{
	// These identify request IEs
	IE_AALParameters,
	IE_TrafficDescriptor,
	IE_BroadbandBearerCapability,
	IE_BHLI,
	IE_BLLI,
	IE_CalledPartyNumber,
	IE_CalledPartySubaddress,
	IE_CallingPartyNumber,
	IE_CallingPartySubaddress,
	IE_Cause,
	IE_QOSClass,
	IE_TransitNetworkSelection,
	IE_BroadbandSendingComplete,
	IE_LIJCallId,
	IE_Raw,
#ifdef MS_UNI4
	IE_TrafficDescriptor_AddOn,
	IE_BroadbandBearerCapability_Uni40,
	IE_BLLI_AddOn,
	IE_ConnectionId,
	IE_NotificationIndicator,
	IE_MinimumTrafficDescriptor,
	IE_AlternativeTrafficDescriptor,
	IE_ExtendedQOS,
	IE_EndToEndTransitDelay,
	IE_ABRSetupParameters,
	IE_ABRAdditionalParameters,
	IE_LIJParameters,
	IE_LeafSequenceNumber,
	IE_ConnectionScopeSelection,
	IE_UserUser,
	IE_GenericIDTransport,
	IE_ConnectedNumber,					// invalid to use in request
	IE_ConnectedSubaddress,         	// invalid to use in request
#endif // MS_UNI4
	// End of request IEs
	IE_NextRequest,						// invalid to use in request

	// These identify empty IE buffers, to hold a possible response
	IE_Cause_Empty						= IE_Cause			   		| ATM_IE_EMPTY_FLAG,
#ifdef MS_UNI4
	IE_ConnectionId_Empty				= IE_ConnectionId			| ATM_IE_EMPTY_FLAG,
	IE_ConnectedNumber_Empty			= IE_ConnectedNumber		| ATM_IE_EMPTY_FLAG,
	IE_ConnectedSubaddress_Empty		= IE_ConnectedSubaddress	| ATM_IE_EMPTY_FLAG,
	IE_NotificationIndicator_Empty		= IE_NotificationIndicator	| ATM_IE_EMPTY_FLAG,
	IE_UserUser_Empty					= IE_UserUser				| ATM_IE_EMPTY_FLAG,
	IE_GenericIDTransport_Empty			= IE_GenericIDTransport		| ATM_IE_EMPTY_FLAG,
#endif // MS_UNI4

	// These identify response IEs
	IE_Cause_Response					= IE_Cause					| ATM_IE_RESPONSE_FLAG,
	IE_AALParameters_Response			= IE_AALParameters			| ATM_IE_RESPONSE_FLAG,
	IE_BLLI_Response					= IE_BLLI					| ATM_IE_RESPONSE_FLAG,
#ifdef MS_UNI4
	IE_BLLI_AddOn_Response				= IE_BLLI_AddOn			   	| ATM_IE_RESPONSE_FLAG,
	IE_TrafficDescriptor_Response		= IE_TrafficDescriptor		| ATM_IE_RESPONSE_FLAG,
	IE_TrafficDescriptor_AddOn_Response	= IE_TrafficDescriptor_AddOn| ATM_IE_RESPONSE_FLAG,
	IE_ConnectionId_Response			= IE_ConnectionId			| ATM_IE_RESPONSE_FLAG,
	IE_NotificationIndicator_Response	= IE_NotificationIndicator	| ATM_IE_RESPONSE_FLAG,
	IE_ExtendedQOS_Response				= IE_ExtendedQOS			| ATM_IE_RESPONSE_FLAG,
	IE_EndToEndTransitDelay_Response	= IE_EndToEndTransitDelay	| ATM_IE_RESPONSE_FLAG,
	IE_ABRSetupParameters_Response		= IE_ABRSetupParameters		| ATM_IE_RESPONSE_FLAG,
	IE_ABRAdditionalParameters_Response	= IE_ABRAdditionalParameters| ATM_IE_RESPONSE_FLAG,
	IE_ConnectedNumber_Response			= IE_ConnectedNumber		| ATM_IE_RESPONSE_FLAG,
	IE_ConnectedSubaddress_Response		= IE_ConnectedSubaddress	| ATM_IE_RESPONSE_FLAG,
	IE_UserUser_Response				= IE_UserUser				| ATM_IE_RESPONSE_FLAG,
	IE_GenericIDTransport_Response		= IE_GenericIDTransport		| ATM_IE_RESPONSE_FLAG,
#endif // MS_UNI4
} Q2931_IE_TYPE;



//
// Common header for each Information Element
//
typedef struct _Q2931_IE
{
	Q2931_IE_TYPE				IEType;
	ULONG						IELength;	// Bytes, including IEType and IELength fields
	UCHAR						IE[1];
} Q2931_IE, *PQ2931_IE;


//
// Definitions for SapType in CO_SAP
//
#define SAP_TYPE_NSAP			0x00000001
#define SAP_TYPE_E164			0x00000002

//
// Values used for the Mode field in AAL5_PARAMETERS
//
#define AAL5_MODE_MESSAGE			0x01
#define AAL5_MODE_STREAMING			0x02

//
// Values used for the SSCSType field in AAL5_PARAMETERS
//
#define AAL5_SSCS_NULL				0x00
#define AAL5_SSCS_SSCOP_ASSURED		0x01
#define AAL5_SSCS_SSCOP_NON_ASSURED	0x02
#define AAL5_SSCS_FRAME_RELAY		0x04


//
// AAL Parameters
//
typedef struct _AAL1_PARAMETERS
{
	UCHAR						Subtype;
	UCHAR						CBRRate;
	USHORT						Multiplier;							// optional (exception: zero if absent)
	UCHAR						SourceClockRecoveryMethod;			// optional
	UCHAR						ErrorCorrectionMethod;				// optional
	USHORT						StructuredDataTransferBlocksize;	// optional (exception: zero if absent)
	UCHAR						PartiallyFilledCellsMethod;			// optional
} AAL1_PARAMETERS, *PAAL1_PARAMETERS;

typedef struct _AAL34_PARAMETERS
{
	USHORT						ForwardMaxCPCSSDUSize;
	USHORT						BackwardMaxCPCSSDUSize;
	USHORT						LowestMID;					// optional
	USHORT						HighestMID;					// optional
	UCHAR						SSCSType;					// optional
} AAL34_PARAMETERS, *PAAL34_PARAMETERS;

typedef struct _AAL5_PARAMETERS
{
	ULONG						ForwardMaxCPCSSDUSize;
	ULONG						BackwardMaxCPCSSDUSize;
	UCHAR						Mode;
	UCHAR						SSCSType;					// optional
} AAL5_PARAMETERS, *PAAL5_PARAMETERS;

typedef struct _AALUSER_PARAMETERS
{
	ULONG						UserDefined;
} AALUSER_PARAMETERS, *PAALUSER_PARAMETERS;

typedef struct _AAL_PARAMETERS_IE
{
	ATM_AAL_TYPE				AALType;
	union
	{
		AAL1_PARAMETERS			AAL1Parameters;
		AAL34_PARAMETERS		AAL34Parameters;
		AAL5_PARAMETERS			AAL5Parameters;
		AALUSER_PARAMETERS		AALUserParameters;
	} AALSpecificParameters;

} AAL_PARAMETERS_IE, *PAAL_PARAMETERS_IE;

//
// ATM Traffic Descriptor
//
typedef struct _ATM_TRAFFIC_DESCRIPTOR	// For one direction
{
	ULONG						PeakCellRateCLP0;			// optional
	ULONG						PeakCellRateCLP01;			// optional
	ULONG						SustainableCellRateCLP0;	// optional
	ULONG						SustainableCellRateCLP01;	// optional
	ULONG						MaximumBurstSizeCLP0;		// optional
	ULONG						MaximumBurstSizeCLP01;		// optional
	BOOLEAN						Tagging;
} ATM_TRAFFIC_DESCRIPTOR, *PATM_TRAFFIC_DESCRIPTOR;


typedef struct _ATM_TRAFFIC_DESCRIPTOR_IE
{
	ATM_TRAFFIC_DESCRIPTOR		ForwardTD;
	ATM_TRAFFIC_DESCRIPTOR		BackwardTD;
	BOOLEAN						BestEffort;
} ATM_TRAFFIC_DESCRIPTOR_IE, *PATM_TRAFFIC_DESCRIPTOR_IE;


#ifdef MS_UNI4
//
// ATM Traffic Descriptor Add-On for UNI 4.0+
//
// REQUIREMENT: An add-on IE must follow immediately after its ancestor IE.
//
typedef struct _ATM_TRAFFIC_DESCRIPTOR_ADDON	// For one direction
{
	ULONG						ABRMinimumCellRateCLP01;	// optional
	BOOLEAN						FrameDiscard;
} ATM_TRAFFIC_DESCRIPTOR_ADDON, *PATM_TRAFFIC_DESCRIPTOR_ADDON;


typedef struct _ATM_TRAFFIC_DESCRIPTOR_IE_ADDON
{
	ATM_TRAFFIC_DESCRIPTOR_ADDON		ForwardTD;
	ATM_TRAFFIC_DESCRIPTOR_ADDON		BackwardTD;
} ATM_TRAFFIC_DESCRIPTOR_IE_ADDON, *PATM_TRAFFIC_DESCRIPTOR_IE_ADDON;

#endif // MS_UNI4


#ifdef MS_UNI4
//
// Alternative Traffic Descriptor IE for UNI 4.0+
//
typedef struct ATM_ALTERNATIVE_TRAFFIC_DESCRIPTOR_IE
{
	ATM_TRAFFIC_DESCRIPTOR_IE			Part1;
	ATM_TRAFFIC_DESCRIPTOR_IE_ADDON		Part2;
} ATM_ALTERNATIVE_TRAFFIC_DESCRIPTOR_IE, *PATM_ALTERNATIVE_TRAFFIC_DESCRIPTOR_IE;

#endif // MS_UNI4


#ifdef MS_UNI4
//
// ATM Minimum Acceptable Traffic Descriptor
//
typedef struct _ATM_MINIMUM_TRAFFIC_DESCRIPTOR	// For one direction
{
	ULONG						PeakCellRateCLP0;			// optional
	ULONG						PeakCellRateCLP01;			// optional
	ULONG						MinimumCellRateCLP01;		// optional
} ATM_MINIMUM_TRAFFIC_DESCRIPTOR, *PATM_MINIMUM_TRAFFIC_DESCRIPTOR;


typedef struct _ATM_MINIMUM_TRAFFIC_DESCRIPTOR_IE
{
	ATM_MINIMUM_TRAFFIC_DESCRIPTOR		ForwardTD;
	ATM_MINIMUM_TRAFFIC_DESCRIPTOR		BackwardTD;
} ATM_MINIMUM_TRAFFIC_DESCRIPTOR_IE, *PATM_MINIMUM_TRAFFIC_DESCRIPTOR_IE;

#endif // MS_UNI4


//
// values used for the BearerClass field in the Broadband Bearer Capability
// and UNI 4.0 Broadband Bearer Capability IEs.
//


#define BCOB_A					0x00	// Bearer class A
#define BCOB_C					0x01	// Bearer class C
#define BCOB_X					0x02	// Bearer class X
#ifdef MS_UNI4_NOT_USED
#define BCOB_VP_SERVICE			0x03	// VP service
#endif

//
// values used for the TrafficType field in the Broadband Bearer Capability IE
//
#define TT_NOIND				0x00	// No indication of traffic type
#define TT_CBR					0x04	// Constant bit rate
#ifdef MS_UNI3_ERROR_KEPT
#define TT_VBR					0x06	// Variable bit rate
#else
#define TT_VBR					0x08	// Variable bit rate
#endif

//
// values used for the TimingRequirements field in the Broadband Bearer Capability IE
//
#define TR_NOIND				0x00	// No timing requirement indication
#define TR_END_TO_END			0x01	// End-to-end timing required
#define TR_NO_END_TO_END		0x02	// End-to-end timing not required

//
// values used for the ClippingSusceptability field in the Broadband Bearer Capability
// and UNI 4.0 Broadband Bearer Capability IEs.
//
#define CLIP_NOT				0x00	// Not susceptible to clipping
#define CLIP_SUS				0x20	// Susceptible to clipping

//
// values used for the UserPlaneConnectionConfig field in
// the Broadband Bearer Capability
// and UNI 4.0 Broadband Bearer Capability IEs.
//
#define UP_P2P					0x00	// Point-to-point connection
#define UP_P2MP					0x01	// Point-to-multipoint connection


//
// Broadband Bearer Capability for UNI 3.1
//
typedef struct _ATM_BROADBAND_BEARER_CAPABILITY_IE
{
	UCHAR			BearerClass;
	UCHAR			TrafficType;
	UCHAR			TimingRequirements;
	UCHAR			ClippingSusceptability;
	UCHAR			UserPlaneConnectionConfig;
} ATM_BROADBAND_BEARER_CAPABILITY_IE, *PATM_BROADBAND_BEARER_CAPABILITY_IE;


#ifdef MS_UNI4
//
// values used for the TransferCapability field in the UNI 4.0 Broadband Bearer Capability IE
//
									// Usage		Usage	Corresponding UNI3.x values
									// UNI 4.0		UNI 3.0	TrafficType	TimingRequirements
									// ------------	-------	-----------	------------------
#define XCAP_NRT_VBR_RCV_0	0x00	// Only rcv				NOIND		NOIND	   
#define XCAP_RT_VBR_RCV_1	0x01	// Only rcv				NOIND		END_TO_END
#define XCAP_NRT_VBR_RCV_2	0x02	// Only rcv				NOIND		NO_END_TO_END
#define XCAP_CBR_RCV_4		0x04	// Only rcv				CBR			NOIND	   
#define XCAP_CBR			0x05	// 						CBR			END_TO_END
#define XCAP_CBR_RCV_6		0x06	// Only rcv				CBR			NO_END_TO_END
#define XCAP_CBR_W_CLR		0x07	// 				None 	CBR			<reserved>
#define XCAP_NRT_VBR_RCV_8	0x08	// Only rcv				VBR			NOIND	   
#define XCAP_RT_VBR			0x09	// 						VBR			END_TO_END
#define XCAP_NRT_VBR		0x0A	// 						VBR			NO_END_TO_END
#define XCAP_NRT_VBR_W_CLR	0x0B	// 				None 	VBR			<reserved>
#define XCAP_ABR			0x0C	// 				None	<reserved>	NOIND	   
#define XCAP_RT_VBR_W_CLR	0x13	// 				None	(NOIND)	<reserved>

//
// Broadband Bearer Capability for UNI 4.0+
// Note: This can be used for UNI 3.1 as well.
//
typedef struct _ATM_BROADBAND_BEARER_CAPABILITY_IE_UNI40
{
	UCHAR			BearerClass;
	UCHAR			TransferCapability;				// optional
	UCHAR			ClippingSusceptability;
	UCHAR			UserPlaneConnectionConfig;
} ATM_BROADBAND_BEARER_CAPABILITY_IE_UNI40, *PATM_BROADBAND_BEARER_CAPABILITY_IE_UNI40;
#endif // MS_UNI4


//
// values used for the HighLayerInfoType field in ATM_BHLI
//
#define BHLI_ISO				0x00	// ISO
#define BHLI_UserSpecific		0x01	// User Specific
#define BHLI_HighLayerProfile	0x02	// High layer profile (only in UNI3.0)
#define BHLI_VendorSpecificAppId 0x03	// Vendor-Specific Application ID

//
// Broadband High layer Information
//
typedef struct _ATM_BHLI_IE
{
	ULONG			HighLayerInfoType;		// High Layer Information Type
	ULONG			HighLayerInfoLength;	// number of bytes in HighLayerInfo
	UCHAR			HighLayerInfo[8];		// The value dependent on the
											// HighLayerInfoType field
} ATM_BHLI_IE, *PATM_BHLI_IE;

//
// values used for Layer2Protocol in B-LLI
//
#define BLLI_L2_ISO_1745		0x01	// Basic mode ISO 1745
#define BLLI_L2_Q921			0x02	// CCITT Rec. Q.921
#define BLLI_L2_X25L			0x06	// CCITT Rec. X.25, link layer
#define BLLI_L2_X25M			0x07	// CCITT Rec. X.25, multilink
#define BLLI_L2_ELAPB			0x08	// Extended LAPB; for half duplex operation
#ifdef MS_UNI3_ERROR_KEPT
#define BLLI_L2_HDLC_NRM		0x09	// HDLC NRM (ISO 4335)
#define BLLI_L2_HDLC_ABM		0x0A	// HDLC ABM (ISO 4335)
#define BLLI_L2_HDLC_ARM		0x0B	// HDLC ARM (ISO 4335)
#else
#define BLLI_L2_HDLC_ARM		0x09	// HDLC ARM (ISO 4335)
#define BLLI_L2_HDLC_NRM		0x0A	// HDLC NRM (ISO 4335)
#define BLLI_L2_HDLC_ABM		0x0B	// HDLC ABM (ISO 4335)
#endif
#define BLLI_L2_LLC				0x0C	// LAN logical link control (ISO 8802/2)
#define BLLI_L2_X75				0x0D	// CCITT Rec. X.75, single link procedure
#define BLLI_L2_Q922			0x0E	// CCITT Rec. Q.922
#define BLLI_L2_USER_SPECIFIED	0x10	// User Specified
#define BLLI_L2_ISO_7776		0x11	// ISO 7776 DTE-DTE operation

//
// values used for Layer3Protocol in B-LLI
//
#define BLLI_L3_X25				0x06	// CCITT Rec. X.25, packet layer
#define BLLI_L3_ISO_8208		0x07	// ISO/IEC 8208 (X.25 packet layer for DTE
#define BLLI_L3_X223			0x08	// X.223/ISO 8878
#define BLLI_L3_SIO_8473		0x09	// ISO/IEC 8473 (OSI connectionless)
#define BLLI_L3_T70				0x0A	// CCITT Rec. T.70 min. network layer
#define BLLI_L3_ISO_TR9577		0x0B	// ISO/IEC TR 9577 Network Layer Protocol ID
#define BLLI_L3_USER_SPECIFIED	0x10	// User Specified
#ifdef MS_UNI4
#define BLLI_L3_H310			0x0C	// ITU H.310
#define BLLI_L3_H321			0x0D	// ITU H.321
#endif // MS_UNI4

//
// values used for Layer3IPI in struct B-LLI
//
#define BLLI_L3_IPI_SNAP		0x80	// IEEE 802.1 SNAP identifier
#define BLLI_L3_IPI_IP			0xCC	// Internet Protocol (IP) identifier

//
// Broadband Lower Layer Information
//
typedef struct _ATM_BLLI_IE
{
	ULONG						Layer2Protocol;
	UCHAR						Layer2Mode;
	UCHAR						Layer2WindowSize;
	ULONG						Layer2UserSpecifiedProtocol;
	ULONG						Layer3Protocol;
	UCHAR						Layer3Mode;
	UCHAR						Layer3DefaultPacketSize;
	UCHAR						Layer3PacketWindowSize;
	ULONG						Layer3UserSpecifiedProtocol;
	ULONG						Layer3IPI;
	UCHAR						SnapId[5];
} ATM_BLLI_IE, *PATM_BLLI_IE;


#ifdef MS_UNI4

//
// Values used for Layer3H310TerminalType in struct B-LLI ADDON
//
#define BLLI_L3_H310_TT_RECEIVE_ONLY		0x01
#define BLLI_L3_H310_TT_SEND_ONLY			0x02
#define BLLI_L3_H310_TT_RECEIVE_AND_SEND	0x03


//
// Values used for Layer3H310ForwardMultiplexingCapability
// and Layer3H310BackwardMultiplexingCapability in struct B-LLI ADDON
//
#define BLLI_L3_H310_MUX_NONE						0x00
#define BLLI_L3_H310_MUX_TRANSPORT_STREAM			0x01
#define BLLI_L3_H310_MUX_TRANSPORT_STREAM_WITH_FEC	0x02
#define BLLI_L3_H310_MUX_PROGRAM_STREAM				0x03
#define BLLI_L3_H310_MUX_PROGRAM_STREAM_WITH_FEC	0x04
#define BLLI_L3_H310_MUX_H221						0x05


//
// Broadband Lower Layer Information Add-On for UNI4.0+
//
// REQUIREMENT: An add-on IE must follow immediately after its ancestor IE.
//
typedef struct _ATM_BLLI_IE_ADDON
{
	UCHAR						Layer3H310TerminalType;						// optional
	UCHAR						Layer3H310ForwardMultiplexingCapability;	// optional
	UCHAR						Layer3H310BackwardMultiplexingCapability;	// optional
} ATM_BLLI_IE_ADDON, *PATM_BLLI_IE_ADDON;

#endif // MS_UNI4


//
// Values used for PresentationIndication in struct ATM_CALLING_PARTY_NUMBER_IE
//

#define CALLING_NUMBER_PRESENTATION_ALLOWED			0x00
#define CALLING_NUMBER_PRESENTATION_RESTRICTED		0x01
#define CALLING_NUMBER_PRESENTATION_NOT_AVAIL		0x02
#define CALLING_NUMBER_PRESENTATION_RESERVED		0x03

//
// Values used for ScreeningIndicator in struct ATM_CALLING_PARTY_NUMBER_IE
//

#define CALLING_NUMBER_SCREENING_USER_PROVIDED_NOT_SCREENED		0x00
#define CALLING_NUMBER_SCREENING_USER_PROVIDED_PASSED_SCREENING	0x01
#define CALLING_NUMBER_SCREENING_USER_PROVIDED_FAILED_SCREENING	0x02
#define CALLING_NUMBER_SCREENING_NW_PROVIDED		   			0x03


//
// Called Party Number
//
// If present, this IE overrides the Called Address specified in
// the main parameter block.
//
typedef ATM_ADDRESS	ATM_CALLED_PARTY_NUMBER_IE;


//
// Called Party Subaddress
//
typedef ATM_ADDRESS	ATM_CALLED_PARTY_SUBADDRESS_IE;



//
// Calling Party Number
//
typedef struct _ATM_CALLING_PARTY_NUMBER_IE
{
	ATM_ADDRESS					Number;
	UCHAR						PresentationIndication;		// optional
	UCHAR						ScreeningIndicator;			// optional
} ATM_CALLING_PARTY_NUMBER_IE, *PATM_CALLING_PARTY_NUMBER_IE;


//
// Calling Party Subaddress
//
typedef ATM_ADDRESS	ATM_CALLING_PARTY_SUBADDRESS_IE;


#ifdef MS_UNI4
//
// Connected Number IE for UNI 4.0 (for COLP Supplementary Services option)
//
typedef ATM_CALLING_PARTY_NUMBER_IE ATM_CONNECTED_NUMBER_IE, *PATM_CONNECTED_NUMBER_IE;


//
// Connected Subaddress IE for UNI 4.0 (for COLP Supplementary Services option)
//
typedef ATM_CALLING_PARTY_SUBADDRESS_IE ATM_CONNECTED_SUBADDRESS_IE, *PATM_CONNECTED_SUBADDRESS_IE;

#endif // MS_UNI4


//
// Values used for the QOSClassForward and QOSClassBackward
// fields in ATM_QOS_CLASS_IE
//
#define QOS_CLASS0				0x00
#define QOS_CLASS1				0x01
#define QOS_CLASS2				0x02
#define QOS_CLASS3				0x03
#define QOS_CLASS4				0x04

//
// QOS Class
//
typedef struct _ATM_QOS_CLASS_IE
{
	UCHAR						QOSClassForward;
	UCHAR						QOSClassBackward;
} ATM_QOS_CLASS_IE, *PATM_QOS_CLASS_IE;


#ifdef MS_UNI4
//
// Values used for the Origin field in ATM_EXTENDED_QOS_PARAMETERS_IE
//
#define ATM_XQOS_ORIGINATING_USER	0x00
#define ATM_XQOS_INTERMEDIATE_NW	0x01

//
// Extended QoS Parameters for UNI 4.0+
//
typedef struct _ATM_EXTENDED_QOS_PARAMETERS_IE
{
	UCHAR						Origin;
	UCHAR						Filler[3];
	ULONG						AcceptableForwardPeakCDV;	// optional
	ULONG						AcceptableBackwardPeakCDV;	// optional
	ULONG						CumulativeForwardPeakCDV;	// optional
	ULONG						CumulativeBackwardPeakCDV;	// optional
	UCHAR						AcceptableForwardCLR;		// optional
	UCHAR						AcceptableBackwardCLR;		// optional
} ATM_EXTENDED_QOS_PARAMETERS_IE, *PATM_EXTENDED_QOS_PARAMETERS_IE;

#endif // MS_UNI4


//
// Broadband Sending Complete
//
typedef struct _ATM_BROADBAND_SENDING_COMPLETE_IE
{
	UCHAR						SendingComplete;
} ATM_BROADBAND_SENDING_COMPLETE_IE, *PATM_BROADBAND_SENDING_COMPLETE_IE;


//
// Values used for the TypeOfNetworkId field in ATM_TRANSIT_NETWORK_SELECTION_IE
//
#define TNS_TYPE_NATIONAL			0x40

//
// Values used for the NetworkIdPlan field in ATM_TRANSIT_NETWORK_SELECTION_IE
//
#define TNS_PLAN_CARRIER_ID_CODE	0x01

//
// Transit Network Selection
//
typedef struct _ATM_TRANSIT_NETWORK_SELECTION_IE
{
	UCHAR						TypeOfNetworkId;
	UCHAR						NetworkIdPlan;
	UCHAR						NetworkIdLength;
	UCHAR						NetworkId[1];
} ATM_TRANSIT_NETWORK_SELECTION_IE, *PATM_TRANSIT_NETWORK_SELECTION_IE;


// 
// Values used for the Location field in struct ATM_CAUSE_IE
//
#define ATM_CAUSE_LOC_USER							0x00
#define ATM_CAUSE_LOC_PRIVATE_LOCAL					0x01
#define ATM_CAUSE_LOC_PUBLIC_LOCAL					0x02
#define ATM_CAUSE_LOC_TRANSIT_NETWORK				0x03
#define ATM_CAUSE_LOC_PUBLIC_REMOTE					0x04
#define ATM_CAUSE_LOC_PRIVATE_REMOTE				0x05
#ifdef MS_UNI3_ERROR_KEPT
#define ATM_CAUSE_LOC_INTERNATIONAL_NETWORK			0x06
#else
#define ATM_CAUSE_LOC_INTERNATIONAL_NETWORK			0x07
#endif
#define ATM_CAUSE_LOC_BEYOND_INTERWORKING			0x0A

// 
// Values used for the Cause field in struct ATM_CAUSE_IE
//
#ifdef MS_UNI4
#define ATM_CAUSE_UNALLOCATED_NUMBER				0x01
#define ATM_CAUSE_NO_ROUTE_TO_TRANSIT_NETWORK		0x02
#define ATM_CAUSE_NO_ROUTE_TO_DESTINATION			0x03
#define ATM_CAUSE_SEND_SPECIAL_TONE					0x04	// UNI 4.0+
#define ATM_CAUSE_MISDIALLED_TRUNK_PREFIX			0x05	// UNI 4.0+
#define ATM_CAUSE_CHANNEL_UNACCEPTABLE				0x06	// UNI 4.0+
#define ATM_CAUSE_CALL_AWARDED_IN_EST_CHAN			0x07	// UNI 4.0+
#define ATM_CAUSE_PREEMPTION						0x08	// UNI 4.0+
#define ATM_CAUSE_PREEMPTION_CIRC_RES_REUSE			0x09	// UNI 4.0+
#define ATM_CAUSE_VPI_VCI_UNACCEPTABLE				0x0A	// UNI 3.0 only!
#define ATM_CAUSE_NORMAL_CALL_CLEARING				0x10	// UNI 3.1+
#define ATM_CAUSE_USER_BUSY							0x11
#define ATM_CAUSE_NO_USER_RESPONDING				0x12
#define ATM_CAUSE_NO_ANSWER_FROM_USER_ALERTED		0x13	// UNI 4.0+
#define ATM_CAUSE_SUBSCRIBER_ABSENT					0x14	// UNI 4.0+
#define ATM_CAUSE_CALL_REJECTED						0x15
#define ATM_CAUSE_NUMBER_CHANGED					0x16
#define ATM_CAUSE_USER_REJECTS_CLIR					0x17
#define ATM_CAUSE_NONSELECTED_USER_CLEARING			0x1A	// UNI 4.0+
#define ATM_CAUSE_DESTINATION_OUT_OF_ORDER			0x1B
#define ATM_CAUSE_INVALID_NUMBER_FORMAT				0x1C
#define ATM_CAUSE_FACILITY_REJECTED					0x1D	// UNI 4.0+
#define ATM_CAUSE_STATUS_ENQUIRY_RESPONSE			0x1E
#define ATM_CAUSE_NORMAL_UNSPECIFIED				0x1F
#define ATM_CAUSE_TOO_MANY_ADD_PARTY				0x20	// UNI 4.0+
#define ATM_CAUSE_NO_CIRCUIT_CHANNEL_AVAIL			0x22	// UNI 4.0+
#define ATM_CAUSE_VPI_VCI_UNAVAILABLE				0x23
#define ATM_CAUSE_VPCI_VCI_ASSIGN_FAIL				0x24	// UNI 3.1+
#define ATM_CAUSE_USER_CELL_RATE_UNAVAILABLE		0x25	// UNI 3.1+
#define ATM_CAUSE_NETWORK_OUT_OF_ORDER				0x26
#define ATM_CAUSE_PFM_CONNECTION_OUT_OF_ORDER		0x27	// UNI 4.0+
#define ATM_CAUSE_PFM_CONNNECTION_OPERATIONAL		0x28	// UNI 4.0+
#define ATM_CAUSE_TEMPORARY_FAILURE					0x29
#define ATM_CAUSE_SWITCH_EQUIPM_CONGESTED			0x2A	// UNI 4.0+
#define ATM_CAUSE_ACCESS_INFORMAION_DISCARDED		0x2B
#define ATM_CAUSE_REQUESTED_CIRC_CHANNEL_NOT_AVAIL	0x2C	// UNI 4.0+
#define ATM_CAUSE_NO_VPI_VCI_AVAILABLE				0x2D
#define ATM_CAUSE_RESOURCE_UNAVAILABLE				0x2F
#define ATM_CAUSE_QOS_UNAVAILABLE					0x31
#define ATM_CAUSE_REQ_FACILITY_NOT_SUBSCRIBED		0x32	// UNI 4.0+
#define ATM_CAUSE_USER_CELL_RATE_UNAVAILABLE__UNI30	0x33	// UNI 3.0 only!
#define ATM_CAUSE_OUTG_CALLS_BARRED_W_CUG			0x35	// UNI 4.0+
#define ATM_CAUSE_INCOM_CALLS_BARRED_W_CUG			0x37	// UNI 4.0+
#define ATM_CAUSE_BEARER_CAPABILITY_UNAUTHORIZED	0x39
#define ATM_CAUSE_BEARER_CAPABILITY_UNAVAILABLE		0x3A
#define ATM_CAUSE_INCONSIST_OUTG_ACCESS_INFO		0x3E	// UNI 4.0+
#define ATM_CAUSE_OPTION_UNAVAILABLE				0x3F
#define ATM_CAUSE_BEARER_CAPABILITY_UNIMPLEMENTED	0x41
#define ATM_CAUSE_CHANNEL_TYPE_NOT_IMPLEMENTED		0x42	// UNI 4.0+
#define ATM_CAUSE_REQ_FACILITY_NOT_IMPLEMENTED		0x45	// UNI 4.0+
#define ATM_CAUSE_ONLY_RESTR_BEAR_CAP_AVAIL			0x46	// UNI 4.0+
#define ATM_CAUSE_UNSUPPORTED_TRAFFIC_PARAMETERS	0x49
#define ATM_CAUSE_AAL_PARAMETERS_UNSUPPORTED		0x4E	// UNI 3.1+
#define ATM_CAUSE_SERVICE_OPTION_NOT_AVAIL			0x4F	// UNI 4.0+
#define ATM_CAUSE_INVALID_CALL_REFERENCE			0x51
#define ATM_CAUSE_CHANNEL_NONEXISTENT				0x52
#define ATM_CAUSE_SUSP_CALL_EXISTS_NOT_CALL_ID		0x53	// UNI 4.0+
#define ATM_CAUSE_CALL_ID_IN_USE					0x54	// UNI 4.0+
#define ATM_CAUSE_NO_CALL_SUSPENDED					0x55	// UNI 4.0+
#define ATM_CAUSE_CALL_W_REQ_ID_CLEARED				0x56	// UNI 4.0+
#define ATM_CAUSE_USER_NOT_MEMBER_CUG				0x57	// UNI 4.0+
#define ATM_CAUSE_INCOMPATIBLE_DESTINATION			0x58
#define ATM_CAUSE_INVALID_ENDPOINT_REFERENCE		0x59
#define ATM_CAUSE_NON_EXISTENT_CUG 					0x5A	// UNI 4.0+
#define ATM_CAUSE_INVALID_TRANSIT_NETWORK_SELECTION	0x5B
#define ATM_CAUSE_TOO_MANY_PENDING_ADD_PARTY		0x5C
#define ATM_CAUSE_AAL_PARAMETERS_UNSUPPORTED__UNI30	0x5D	// UNI 3.0 only!
#define ATM_CAUSE_INVALID_MSG_UNSPECIFIED			0x5F	// UNI 4.0+
#define ATM_CAUSE_MANDATORY_IE_MISSING				0x60
#define ATM_CAUSE_UNIMPLEMENTED_MESSAGE_TYPE		0x61
#define ATM_CAUSE_MSG_CONFL_STATE_OR_UNIMPL			0x62	// UNI 4.0+
#define ATM_CAUSE_UNIMPLEMENTED_IE					0x63
#define ATM_CAUSE_INVALID_IE_CONTENTS				0x64
#define ATM_CAUSE_INVALID_STATE_FOR_MESSAGE			0x65
#define ATM_CAUSE_RECOVERY_ON_TIMEOUT				0x66
#define ATM_CAUSE_IE_INVAL_UNIMPL_PASSED_ON			0x67	// UNI 4.0+
#define ATM_CAUSE_INCORRECT_MESSAGE_LENGTH			0x68
#define ATM_CAUSE_UNRECOGNIZED_PARM_MSG_DISCARDED	0x6E	// UNI 4.0+
#define ATM_CAUSE_PROTOCOL_ERROR					0x6F
#define ATM_CAUSE_INTERWORKING_UNSPECIFIED			0x7F	// UNI 4.0+

#else // !MS_UNI4

#define ATM_CAUSE_UNALLOCATED_NUMBER				0x01
#define ATM_CAUSE_NO_ROUTE_TO_TRANSIT_NETWORK		0x02
#define ATM_CAUSE_NO_ROUTE_TO_DESTINATION			0x03
#define ATM_CAUSE_VPI_VCI_UNACCEPTABLE				0x0A
#define ATM_CAUSE_NORMAL_CALL_CLEARING				0x10
#define ATM_CAUSE_USER_BUSY							0x11
#define ATM_CAUSE_NO_USER_RESPONDING				0x12
#define ATM_CAUSE_CALL_REJECTED						0x15
#define ATM_CAUSE_NUMBER_CHANGED					0x16
#define ATM_CAUSE_USER_REJECTS_CLIR					0x17
#define ATM_CAUSE_DESTINATION_OUT_OF_ORDER			0x1B
#define ATM_CAUSE_INVALID_NUMBER_FORMAT				0x1C
#define ATM_CAUSE_STATUS_ENQUIRY_RESPONSE			0x1E
#define ATM_CAUSE_NORMAL_UNSPECIFIED				0x1F
#define ATM_CAUSE_VPI_VCI_UNAVAILABLE				0x23
#define ATM_CAUSE_NETWORK_OUT_OF_ORDER				0x26
#define ATM_CAUSE_TEMPORARY_FAILURE					0x29
#define ATM_CAUSE_ACCESS_INFORMAION_DISCARDED		0x2B
#define ATM_CAUSE_NO_VPI_VCI_AVAILABLE				0x2D
#define ATM_CAUSE_RESOURCE_UNAVAILABLE				0x2F
#define ATM_CAUSE_QOS_UNAVAILABLE					0x31
#define ATM_CAUSE_USER_CELL_RATE_UNAVAILABLE		0x33
#define ATM_CAUSE_BEARER_CAPABILITY_UNAUTHORIZED	0x39
#define ATM_CAUSE_BEARER_CAPABILITY_UNAVAILABLE		0x3A
#define ATM_CAUSE_OPTION_UNAVAILABLE				0x3F
#define ATM_CAUSE_BEARER_CAPABILITY_UNIMPLEMENTED	0x41
#define ATM_CAUSE_UNSUPPORTED_TRAFFIC_PARAMETERS	0x49
#define ATM_CAUSE_INVALID_CALL_REFERENCE			0x51
#define ATM_CAUSE_CHANNEL_NONEXISTENT				0x52
#define ATM_CAUSE_INCOMPATIBLE_DESTINATION			0x58
#define ATM_CAUSE_INVALID_ENDPOINT_REFERENCE		0x59
#define ATM_CAUSE_INVALID_TRANSIT_NETWORK_SELECTION	0x5B
#define ATM_CAUSE_TOO_MANY_PENDING_ADD_PARTY		0x5C
#define ATM_CAUSE_AAL_PARAMETERS_UNSUPPORTED		0x5D
#define ATM_CAUSE_MANDATORY_IE_MISSING				0x60
#define ATM_CAUSE_UNIMPLEMENTED_MESSAGE_TYPE		0x61
#define ATM_CAUSE_UNIMPLEMENTED_IE					0x63
#define ATM_CAUSE_INVALID_IE_CONTENTS				0x64
#define ATM_CAUSE_INVALID_STATE_FOR_MESSAGE			0x65
#define ATM_CAUSE_RECOVERY_ON_TIMEOUT				0x66
#define ATM_CAUSE_INCORRECT_MESSAGE_LENGTH			0x68
#define ATM_CAUSE_PROTOCOL_ERROR					0x6F
#endif // !MS_UNI4

//
// Values used for the Condition portion of the Diagnostics field
// in struct ATM_CAUSE_IE, for certain Cause values
//
#define ATM_CAUSE_COND_UNKNOWN						0x00
#define ATM_CAUSE_COND_PERMANENT					0x01
#define ATM_CAUSE_COND_TRANSIENT					0x02

//
// Values used for the Rejection Reason portion of the Diagnostics field
// in struct ATM_CAUSE_IE, for certain Cause values
//
#define ATM_CAUSE_REASON_USER						0x00
#define ATM_CAUSE_REASON_IE_MISSING					0x04
#define ATM_CAUSE_REASON_IE_INSUFFICIENT			0x08

//
// Values used for the P-U flag of the Diagnostics field
// in struct ATM_CAUSE_IE, for certain Cause values
//
#define ATM_CAUSE_PU_PROVIDER						0x00
#define ATM_CAUSE_PU_USER							0x08

//
// Values used for the N-A flag of the Diagnostics field
// in struct ATM_CAUSE_IE, for certain Cause values
//
#define ATM_CAUSE_NA_NORMAL							0x00
#define ATM_CAUSE_NA_ABNORMAL						0x04

#ifdef MS_UNI4
//
// values used for placing IE identifiers in the Diagnostics field
//
#define	ATM_CAUSE_DIAG_IE_NARROW_BEARER_CAPABILITY	0x04
#define	ATM_CAUSE_DIAG_IE_CAUSE						0x08
#define	ATM_CAUSE_DIAG_IE_CALL_STATE				0x14
#define	ATM_CAUSE_DIAG_IE_PROGRESS_IND				0x1E
#define	ATM_CAUSE_DIAG_IE_NOTIF_IND					0x27
#define	ATM_CAUSE_DIAG_IE_END_TO_END_TDELAY			0x42
#define	ATM_CAUSE_DIAG_IE_CONNECTED_NUMBER			0x4C
#define	ATM_CAUSE_DIAG_IE_CONNECTED_SUBADDR			0x4D
#define	ATM_CAUSE_DIAG_IE_ENDPOINT_REF				0x54
#define	ATM_CAUSE_DIAG_IE_ENDPOINT_STATE			0x55
#define	ATM_CAUSE_DIAG_IE_AAL_PARMS					0x58
#define	ATM_CAUSE_DIAG_IE_TRAFFIC_DESCRIPTOR		0x59
#define	ATM_CAUSE_DIAG_IE_CONNECTION_ID				0x5A
#define ATM_CAUSE_DIAG_IE_OAM_TRAFFIC_DESCRIPTOR	0x5B
#define	ATM_CAUSE_DIAG_IE_QOS						0x5C
#define	ATM_CAUSE_DIAG_IE_HIGH_LAYER_INFO			0x5D
#define	ATM_CAUSE_DIAG_IE_BEARER_CAPABILITY			0x5E
#define	ATM_CAUSE_DIAG_IE_LOW_LAYER_INFO			0x5F
#define	ATM_CAUSE_DIAG_IE_LOCKING_SHIFT				0x60
#define	ATM_CAUSE_DIAG_IE_NON_LOCKING_SHIFT			0x61
#define	ATM_CAUSE_DIAG_IE_SENDING_COMPLETE			0x62
#define	ATM_CAUSE_DIAG_IE_REPEAT_INDICATOR			0x63
#define	ATM_CAUSE_DIAG_IE_CALLING_PARTY_NUMBER		0x6C
#define	ATM_CAUSE_DIAG_IE_CALLING_PARTY_SUBADDR		0x6D
#define	ATM_CAUSE_DIAG_IE_CALLED_PARTY_NUMBER		0x70
#define	ATM_CAUSE_DIAG_IE_CALLED_PARTY_SUBADDR		0x71
#define	ATM_CAUSE_DIAG_IE_TRANSIT_NETWORK_SELECT	0x78
#define	ATM_CAUSE_DIAG_IE_RESTART_INDICATOR			0x79
#define	ATM_CAUSE_DIAG_IE_NARROW_LOW_LAYER_COMPAT	0x7C
#define	ATM_CAUSE_DIAG_IE_NARROW_HIGH_LAYER_COMPAT	0x7D
#define	ATM_CAUSE_DIAG_IE_USER_USER					0x7E
#define	ATM_CAUSE_DIAG_IE_GENERIC_ID				0x7F
#define	ATM_CAUSE_DIAG_IE_MIN_TRAFFIC_DESCRIPTOR	0x81
#define	ATM_CAUSE_DIAG_IE_ALT_TRAFFIC_DESCRIPTOR	0x82
#define	ATM_CAUSE_DIAG_IE_ABR_SETUP_PARMS			0x84
#define	ATM_CAUSE_DIAG_IE_CALLED_SOFT_PVPC_PVCC		0xE0
#define	ATM_CAUSE_DIAG_IE_CRANKBACK					0xE1
#define	ATM_CAUSE_DIAG_IE_DESIGNATED_TRANSIT_LIST	0xE2
#define	ATM_CAUSE_DIAG_IE_CALLING_SOFT_PVPC_PVCC	0xE3
#define	ATM_CAUSE_DIAG_IE_ABR_ADD_PARMS				0xE4
#define	ATM_CAUSE_DIAG_IE_LIJ_CALL_ID				0xE8
#define	ATM_CAUSE_DIAG_IE_LIJ_PARMS					0xE9
#define	ATM_CAUSE_DIAG_IE_LEAF_SEQ_NO				0xEA
#define	ATM_CAUSE_DIAG_IE_CONNECTION_SCOPE_SELECT	0xEB
#define	ATM_CAUSE_DIAG_IE_EXTENDED_QOS				0xEC

//
// values used for placing IE subfield identifiers in the Diagnostics field
//
#define ATM_CAUSE_DIAG_RATE_ID_FW_PEAK_CLP0			0x82
#define ATM_CAUSE_DIAG_RATE_ID_BW_PEAK_CLP0			0x83
#define ATM_CAUSE_DIAG_RATE_ID_FW_PEAK_CLP01		0x84
#define ATM_CAUSE_DIAG_RATE_ID_BW_PEAK_CLP01		0x85
#define ATM_CAUSE_DIAG_RATE_ID_FW_SUST_CLP0			0x88
#define ATM_CAUSE_DIAG_RATE_ID_BW_SUST_CLP0			0x89
#define ATM_CAUSE_DIAG_RATE_ID_FW_SUST_CLP01		0x90
#define ATM_CAUSE_DIAG_RATE_ID_BW_SUST_CLP01		0x91
#define ATM_CAUSE_DIAG_RATE_ID_FW_ABR_MIN_CLP01		0x92
#define ATM_CAUSE_DIAG_RATE_ID_BW_ABR_MIN_CLP01		0x93
#define ATM_CAUSE_DIAG_RATE_ID_FW_BURST_CLP0		0xA0
#define ATM_CAUSE_DIAG_RATE_ID_BW_BURST_CLP0		0xA1
#define ATM_CAUSE_DIAG_RATE_ID_FW_BURST_CLP01		0xB0
#define ATM_CAUSE_DIAG_RATE_ID_BW_BURST_CLP01		0xB1
#define ATM_CAUSE_DIAG_RATE_ID_BEST_EFFORT			0xBE
#define ATM_CAUSE_DIAG_RATE_ID_TM_OPTIONS			0xBF

//
// Values used for placing a CCBS indicator in the Diagnostics field 
//
#define ATM_CAUSE_DIAG_CCBS_SPARE					0x00
#define ATM_CAUSE_DIAG_CCBS_CCBS_POSSIBLE			0x01
#define ATM_CAUSE_DIAG_CCBS_CCBS_NOT_POSSIBLE		0x02

//
// Values used for placing Attribute Numbers in the Diagnostics field
//
#define ATM_CAUSE_DIAG_ATTR_NO_INFO_XFER_CAP		0x31
#define ATM_CAUSE_DIAG_ATTR_NO_INFO_XFER_MODE		0x32
#define ATM_CAUSE_DIAG_ATTR_NO_INFO_XFER_RATE		0x33
#define ATM_CAUSE_DIAG_ATTR_NO_STRUCTURE			0x34
#define ATM_CAUSE_DIAG_ATTR_NO_CONFIG				0x35
#define ATM_CAUSE_DIAG_ATTR_NO_ESTABL				0x36
#define ATM_CAUSE_DIAG_ATTR_NO_SYMMETRY				0x37
#define ATM_CAUSE_DIAG_ATTR_NO_INFO_XFER_RATE2		0x38
#define ATM_CAUSE_DIAG_ATTR_NO_LAYER_ID				0x39
#define ATM_CAUSE_DIAG_ATTR_NO_RATE_MULT			0x3A

#endif // MS_UNI4


//
// Cause
//
// Note: If used as empty buffer for response IE, then the DiagnosticsLength
//		 MUST be filled in correctly, to show available buffer length.
//
typedef struct _ATM_CAUSE_IE
{
	UCHAR						Location;
	UCHAR						Cause;
	UCHAR						DiagnosticsLength;
	UCHAR						Diagnostics[4];		// Variable length information (minimum 4 bytes)
} ATM_CAUSE_IE, *PATM_CAUSE_IE;


#ifdef MS_UNI4
//
// Connection Identifier IE for UNI 4.0+
//
// Setting VPCI to SAP_FIELD_ABSENT, means it is "VP-associated" signalling,
// (which is not supported by this CallManager);
//
// Otherwise we assume "explicit VPCI" (this is the normal setting),
// and the Vpci value is used.
//
// Setting the VCI to SAP_FIELD_ABSENT, means it is "switched VP",
// which is not supported by this CallManager;
//
// Setting the VCI to SAP_FIELD_ANY, means it is "explicit VPCI, any VCI";
//
// Setting both the Vpci and the Vci fields to SAP_FIELD_ANY,
// or setting both the Vpci and the Vci fields to SAP_FIELD_ABSENT,
// means that the ConnectionId is not defined,
// so it will not be sent to the peer.
// (This allows an empty ConnectionIdentifier IE to hold the response).
//
// Otherwise we assume "explicit VPCI, explicit VCI" (this is the normal
// setting), and the Vci value is used.
//
typedef struct _ATM_CONNECTION_ID_IE
{
	ULONG						Vpci;	// Optional: Can use SAP_FIELD_ANY or SAP_FIELD_ABSENT here.
	ULONG						Vci;	// Optional: Can use SAP_FIELD_ANY or SAP_FIELD_ABSENT here.
} ATM_CONNECTION_ID_IE, *PATM_CONNECTION_ID_IE;

#endif // MS_UNI4


#ifdef MS_UNI4
//
// End-to-End Transit Delay IE for UNI 4.0+
//
typedef struct _ATM_END_TO_END_TRANSIT_DELAY_IE
{
	ULONG						CumulativeTransitDelay;			// optional (Milliseconds)
	ULONG						MaximumEndToEndTransitDelay;	// optional (Milliseconds)
	BOOLEAN						NetworkGenerated;
} ATM_END_TO_END_TRANSIT_DELAY_IE, *PATM_END_TO_END_TRANSIT_DELAY_IE;

#endif // MS_UNI4


#ifdef MS_UNI4
//
// Notification Indicator IE for UNI 4.0+
//
// Note: If used as empty buffer for response IE, then the InformationLength
//		 MUST be filled in correctly, to show available buffer length.
//
typedef struct _ATM_NOTIFICATION_INDICATOR_IE
{
	USHORT						NotificationId;
	USHORT						InformationLength;
	UCHAR						NotificationInformation[1];		// Variable length information
} ATM_NOTIFICATION_INDICATOR_IE, *PATM_NOTIFICATION_INDICATOR_IE;

#endif // MS_UNI4


#ifdef MS_UNI4
//
// User-User IE for UNI 4.0+ (for UUS Supplementary Services option)
//
// Note: If used as empty buffer for response IE, then the InformationLength
//		 MUST be filled in correctly, to show available buffer length.
//
typedef struct _ATM_USER_USER_IE
{
	UCHAR						ProtocolDescriminator;
	UCHAR						Filler[1];
	USHORT						InformationLength;
	UCHAR						UserUserInformation[1];			// Variable length information
} ATM_USER_USER_IE, *PATM_USER_USER_IE;

#endif // MS_UNI4


#ifdef MS_UNI4
//
// Generic ID Transport IE for UNI 4.0+
//
// Note: If used as empty buffer for response IE, then the InformationLength
//		 MUST be filled in correctly, to show available buffer length.
//
typedef struct _ATM_GENERIC_ID_TRANSPORT_IE
{
	USHORT						InformationLength;
	UCHAR						GenericIDInformation[1];		// Variable length information
} ATM_GENERIC_ID_TRANSPORT_IE, *PATM_GENERIC_ID_TRANSPORT_IE;

#endif // MS_UNI4


//
// Leaf Initiated Join (LIJ) Identifier
//
typedef struct _ATM_LIJ_CALLID_IE
{
	ULONG						Identifier;
} ATM_LIJ_CALLID_IE, *PATM_LIJ_CALLID_IE;


#ifdef MS_UNI4
//
// Values used for the ScreeningIndication field in struct ATM_LIJ_PARAMETERS_IE
//
#define ATM_LIJ_PARMS_SCREEN_NO_ROOT_NOTIF	0x00

//
// Leaf Initiated Join (LIJ) Parameters IE for UNI 4.0+
//
typedef struct _ATM_LIJ_PARAMETERS_IE
{
	UCHAR						ScreeningIndication;
} ATM_LIJ_PARAMETERS_IE, *PATM_LIJ_PARAMETERS_IE;

#endif // MS_UNI4


#ifdef MS_UNI4
//
// Leaf Sequence Number IE for UNI 4.0+
//
typedef struct _ATM_LEAF_SEQUENCE_NUMBER_IE
{
	ULONG						SequenceNumber;
} ATM_LEAF_SEQUENCE_NUMBER_IE, *PATM_LEAF_SEQUENCE_NUMBER_IE;

#endif // MS_UNI4


#ifdef MS_UNI4
//
// Values used for the ConnectionScopeType field in _ATM_CONNECTION_SCOPE_SELECTION_IE
//
#define ATM_SCOPE_TYPE_ORGANIZATIONAL				0x01

//
// Values used for the ConnectionScopeSelection field in _ATM_CONNECTION_SCOPE_SELECTION_IE
//
#define ATM_SCOPE_ORGANIZATIONAL_LOCAL_NW			0x01
#define ATM_SCOPE_ORGANIZATIONAL_LOCAL_NW_PLUS1		0x02
#define ATM_SCOPE_ORGANIZATIONAL_LOCAL_NW_PLUS2		0x03
#define ATM_SCOPE_ORGANIZATIONAL_SITE_MINUS1		0x04
#define ATM_SCOPE_ORGANIZATIONAL_INTRA_SITE			0x05
#define ATM_SCOPE_ORGANIZATIONAL_SITE_PLUS1			0x06
#define ATM_SCOPE_ORGANIZATIONAL_ORG_MINUS1			0x07
#define ATM_SCOPE_ORGANIZATIONAL_INTRA_ORG			0x08
#define ATM_SCOPE_ORGANIZATIONAL_ORG_PLUS1			0x09
#define ATM_SCOPE_ORGANIZATIONAL_COMM_MINUS1		0x0A
#define ATM_SCOPE_ORGANIZATIONAL_INTRA_COMM			0x0B
#define ATM_SCOPE_ORGANIZATIONAL_COMM_PLUS1			0x0C
#define ATM_SCOPE_ORGANIZATIONAL_REGIONAL			0x0D
#define ATM_SCOPE_ORGANIZATIONAL_INTER_REGIONAL		0x0E
#define ATM_SCOPE_ORGANIZATIONAL_GLOBAL				0x0F

//
// Connection Scope Selection IE for UNI 4.0+
//
typedef struct _ATM_CONNECTION_SCOPE_SELECTION_IE
{
	UCHAR						ConnectionScopeType;
	UCHAR						ConnectionScopeSelection;
} ATM_CONNECTION_SCOPE_SELECTION_IE, *PATM_CONNECTION_SCOPE_SELECTION_IE;

#endif // MS_UNI4


#ifdef MS_UNI4
//
// Values used for the XxxxAdditionalParameters fields in _ATM_ABR_ADDITIONAL_PARAMETERS_IE
//
#define			ATM_ABR_PARMS_NRM_PRESENT		0x80000000
#define			ATM_ABR_PARMS_TRM_PRESENT		0x40000000
#define			ATM_ABR_PARMS_CDF_PRESENT		0x20000000
#define			ATM_ABR_PARMS_ADTF_PRESENT		0x10000000
#define			ATM_ABR_PARMS_NRM_MASK			0x0E000000
#define			ATM_ABR_PARMS_NRM_SHIFT			25
#define			ATM_ABR_PARMS_TRM_MASK			0x01C00000
#define			ATM_ABR_PARMS_TRM_SHIFT			22
#define			ATM_ABR_PARMS_CDF_MASK			0x00380000
#define			ATM_ABR_PARMS_CDF_SHIFT			19
#define			ATM_ABR_PARMS_ADTF_MASK			0x0007FE00
#define			ATM_ABR_PARMS_ADTF_SHIFT		9
#define 		ATM_ABR_PARMS_NRM_DEFAULT		4
#define 		ATM_ABR_PARMS_TRM_DEFAULT		7
#define 		ATM_ABR_PARMS_CDF_DEFAULT		3
#define 		ATM_ABR_PARMS_ADTF_DEFAULT		50

typedef struct _ATM_ABR_ADDITIONAL_PARAMETERS_IE
{
	ULONG	ForwardAdditionalParameters;
	ULONG	BackwardAdditionalParameters;
} ATM_ABR_ADDITIONAL_PARAMETERS_IE, *PATM_ABR_ADDITIONAL_PARAMETERS_IE;

#endif // MS_UNI4


#ifdef MS_UNI4
//
// ABR Setup Parameters IE for UNI 4.0+
//
typedef struct _ATM_ABR_SETUP_PARAMETERS_IE
{
	ULONG	ForwardABRInitialCellRateCLP01;			// optional
	ULONG	BackwardABRInitialCellRateCLP01;		// optional
	ULONG	ForwardABRTransientBufferExposure;		// optional
	ULONG	BackwardABRTransientBufferExposure;		// optional
	ULONG	CumulativeRmFixedRTT;
	UCHAR	ForwardABRRateIncreaseFactorLog2;		// optional (0..15 [log2(RIF*32768)])
	UCHAR	BackwardABRRateIncreaseFactorLog2;		// optional (0..15 [log2(RIF*32768)])
	UCHAR	ForwardABRRateDecreaseFactorLog2;		// optional (0..15 [log2(RDF*32768)])
	UCHAR	BackwardABRRateDecreaseFactorLog2;		// optional (0..15 [log2(RDF*32768)])
} ATM_ABR_SETUP_PARAMETERS_IE, *PATM_ABR_SETUP_PARAMETERS_IE;

#endif // MS_UNI4


//
// Raw Information Element - the user can fill in whatever he wants
//
typedef struct _ATM_RAW_IE
{
	ULONG						RawIELength;
	ULONG						RawIEType;
	UCHAR						RawIEValue[1];		// Vaiable length information
} ATM_RAW_IE, *PATM_RAW_IE;


//
// This is the value of the ParamType field in the CO_SPECIFIC_PARAMETERS structure
// when the Parameters[] field contains ATM media specific values in the structure
// ATM_MEDIA_PARAMETERS.
//
#define ATM_MEDIA_SPECIFIC		0x00000001

//
// The Q2931 Call Manager Specific parameters that goes into the
// CallMgrParameters->CallMgrSpecific.Parameters
//
typedef struct _Q2931_CALLMGR_PARAMETERS
{
	ATM_ADDRESS					CalledParty;
	ATM_ADDRESS					CallingParty;
	ULONG						InfoElementCount;
	UCHAR						InfoElements[1];	// one or more info elements
} Q2931_CALLMGR_PARAMETERS, *PQ2931_CALLMGR_PARAMETERS;


//
// This is the specific portion of either the Media parameters or the CallMgr
// Parameters. The following define is used in the ParamType field
// depending on the signaling type.
//
#define CALLMGR_SPECIFIC_Q2931	0x00000001

typedef struct _ATM_VPIVCI
{
	ULONG						Vpi;
	ULONG						Vci;
} ATM_VPIVCI, *PATM_VPIVCI;

//
// ATM Service Category
//
#define	ATM_SERVICE_CATEGORY_CBR	1	// Constant Bit Rate
#define	ATM_SERVICE_CATEGORY_VBR	2	// Variable Bit Rate
#define	ATM_SERVICE_CATEGORY_UBR	4	// Unspecified Bit Rate
#define	ATM_SERVICE_CATEGORY_ABR	8	// Available Bit Rate

typedef ULONG	ATM_SERVICE_CATEGORY, *PATM_SERVICE_CATEGORY;


//
// ATM flow parameters for use in specifying Media parameters
//
typedef struct _ATM_FLOW_PARAMETERS
{
	ATM_SERVICE_CATEGORY		ServiceCategory;
	ULONG						AverageCellRate;			// in cells/sec
	ULONG						PeakCellRate;				// in cells/sec
	ULONG						MinimumCellRate;			// in cells/sec (ABR MCR)
	ULONG						InitialCellRate;			// in cells/sec (ABR ICR)
	ULONG						BurstLengthCells;			// in cells
	ULONG						MaxSduSize;					// MTU in bytes
	ULONG						TransientBufferExposure;	// in cells (ABR TBE)
	ULONG						CumulativeRMFixedRTT;		// in microseconds (ABR FRTT)
	UCHAR						RateIncreaseFactor;			// UNI 4.0 coding (ABR RIF)
	UCHAR						RateDecreaseFactor;			// UNI 4.0 coding (ABR RDF)
	USHORT						ACRDecreaseTimeFactor;		// UNI 4.0 coding (ABR ADTF)
	UCHAR						MaximumCellsPerForwardRMCell; // UNI 4.0 coding (ABR Nrm)
	UCHAR						MaximumForwardRMCellInterval; // UNI 4.0 coding (ABR Trm)
	UCHAR						CutoffDecreaseFactor;		// UNI 4.0 coding (ABR CDF)
	UCHAR						Reserved1;					// padding
	ULONG						MissingRMCellCount;			// (ABR CRM)
	ULONG						Reserved2;
	ULONG						Reserved3;
} ATM_FLOW_PARAMETERS, *PATM_FLOW_PARAMETERS;

//
// ATM Specific Media parameters - this is the Media specific structure for ATM
// that goes into MediaParameters->MediaSpecific.Parameters.
//
typedef struct _ATM_MEDIA_PARAMETERS
{
	ATM_VPIVCI					ConnectionId;
	ATM_AAL_TYPE				AALType;
	ULONG						CellDelayVariationCLP0;
	ULONG						CellDelayVariationCLP1;
	ULONG						CellLossRatioCLP0;
	ULONG						CellLossRatioCLP1;
	ULONG						CellTransferDelayCLP0;
	ULONG						CellTransferDelayCLP1;
	ULONG						DefaultCLP;
	ATM_FLOW_PARAMETERS			Transmit;
	ATM_FLOW_PARAMETERS			Receive;
} ATM_MEDIA_PARAMETERS, *PATM_MEDIA_PARAMETERS;

#ifdef MS_UNI4
//
// Generic ATM Call Manager Specific parameters.
// These may be used for call/leaf teardown and for certain NdisCoRequest calls.
//
// When used for closing a call and for dropping a leaf, by either client or
// Call Manager, this struct is referenced by the `Buffer` parameter of
// the relevant NDIS functions.
//
// When used for NdisCoRequest calls to make ATM UNI protocol specific
// requests and indications
//		OID_ATM_CALL_PROCEEDING
//		OID_ATM_CALL_ALERTING
//		OID_ATM_LEAF_ALERTING
//		OID_ATM_CALL_NOTIFY
// this struct is referenced by the `InformationBuffer` parameter.
//
typedef struct _Q2931_CALLMGR_SUBSEQUENT_PARAMETERS
{
	ULONG						InfoElementCount;
	UCHAR						InfoElements[1];	// one or more info elements
} Q2931_CALLMGR_SUBSEQUENT_PARAMETERS, *PQ2931_CALLMGR_SUBSEQUENT_PARAMETERS;
#endif // MS_UNI4

#ifdef MS_UNI4
//
// Field values that may be used whereever applicable to signify absence
// of data or wildcard data.
//
#endif // MS_UNI4

#ifndef SAP_FIELD_ABSENT
#define SAP_FIELD_ABSENT		((ULONG)0xfffffffe)
#endif

#ifndef SAP_FIELD_ABSENT_USHORT
#define SAP_FIELD_ABSENT_USHORT	((USHORT)0xfffe)
#endif

#ifndef SAP_FIELD_ABSENT_UCHAR
#define SAP_FIELD_ABSENT_UCHAR	((UCHAR)0xfe)
#endif

#ifndef SAP_FIELD_ANY
#define SAP_FIELD_ANY			((ULONG)0xffffffff)
#endif

#define SAP_FIELD_ANY_AESA_SEL	((ULONG)0xfffffffa)	// SEL is wild-carded
#define SAP_FIELD_ANY_AESA_REST	((ULONG)0xfffffffb)	// All of the address
													// except SEL, is wild-carded

//
// The ATM Specific SAP definition
//
typedef struct _ATM_SAP
{
	ATM_BLLI_IE					Blli;
	ATM_BHLI_IE					Bhli;
	ULONG						NumberOfAddresses;
	UCHAR						Addresses[1];	// each of type ATM_ADDRESS
} ATM_SAP, *PATM_SAP;

//
// The ATM Specific SAP definition when adding PVCs
//
typedef struct _ATM_PVC_SAP
{
	ATM_BLLI_IE					Blli;
	ATM_BHLI_IE					Bhli;
} ATM_PVC_SAP, *PATM_PVC_SAP;

//
// The structure passed in the Parameters field of the CO_SPECIFIC_PARAMETERS
// structure passed in an ADD PVC request for Q.2931
//
typedef struct _Q2931_ADD_PVC
{
	ATM_ADDRESS					CalledParty;
	ATM_ADDRESS					CallingParty;
	ATM_VPIVCI					ConnectionId;
	ATM_AAL_TYPE				AALType;
	ATM_FLOW_PARAMETERS			ForwardFP;
	ATM_FLOW_PARAMETERS			BackwardFP;
	ULONG						Flags;
	ATM_PVC_SAP					LocalSap;
	ATM_PVC_SAP					DestinationSap;
	BOOLEAN						LIJIdPresent;
	ATM_LIJ_CALLID_IE			LIJId;
} Q2931_ADD_PVC, *PQ2931_ADD_PVC;

//
// These flags are defined to be used with Q2931_ADD_PVC above
//
// this VC should be used by the CallMgr as the signaling VC now
#define CO_FLAG_SIGNALING_VC	0x00000001

//
// use this flag when the VC cannot be used for a MakeCall - incoming call only
// the call mgr can then be optimized not to search these PVCs during make call
// processing.
#define CO_FLAG_NO_DEST_SAP		0x00000002

//
//  Use this flag for a PVC that cannot be used to indicate an incoming call.
//
#define CO_FLAG_NO_LOCAL_SAP	0x00000004

//
// the structure passed in the Parameters field of the CO_SPECIFIC_PARAMETERS
// structure passed in an NDIS_CO_PVC request for Q2931
//
typedef struct _Q2931_DELETE_PVC
{
	ATM_VPIVCI					ConnectionId;
} Q2931_DELETE_PVC, *PQ2931_DELETE_PVC;

typedef struct _CO_GET_CALL_INFORMATION
{
	ULONG						CallInfoType;
	ULONG						CallInfoLength;
	PVOID						CallInfoBuffer;
} CO_GET_CALL_INFORMATION, *PCO_GET_CALL_INFORMATION;

//
// the structure for returning the supported VC rates from the miniport,
// returned in response to OID_ATM_SUPPORTED_VC_RATES
//
typedef struct _ATM_VC_RATES_SUPPORTED
{
	ULONG						MinCellRate;
	ULONG						MaxCellRate;
} ATM_VC_RATES_SUPPORTED, *PATM_VC_RATES_SUPPORTED;

//
//	NDIS_PACKET out of band information for ATM.
//
typedef struct _ATM_AAL_OOB_INFO
{
	ATM_AAL_TYPE		AalType;
	union
	{
		struct _ATM_AAL5_INFO
		{
			BOOLEAN		CellLossPriority;
			UCHAR		UserToUserIndication;
			UCHAR		CommonPartIndicator;
		} ATM_AAL5_INFO;

		struct _ATM_AAL0_INFO
		{
			BOOLEAN		CellLossPriority;
			UCHAR		PayLoadTypeIdentifier;
		} ATM_AAL0_INFO;
	};
} ATM_AAL_OOB_INFO, *PATM_AAL_OOB_INFO;


//
//  Physical Line Speeds in bits/sec.
//
#define ATM_PHYS_RATE_SONET_STS3C						155520000
#define ATM_PHYS_RATE_IBM_25						 	 25600000

//
//  ATM cell layer transfer capacities in bits/sec. This is the throughput
//  available for ATM cells, after allowing for physical framing overhead.
//
#define ATM_CELL_TRANSFER_CAPACITY_SONET_STS3C			149760000
#define ATM_CELL_TRANSFER_CAPACITY_IBM_25			 	 25125926



//
//  User data rate in units of 100 bits/sec. This is returned in response to
//  the OID_GEN_CO_LINK_SPEED query. This is the effective rate of
//  transfer of data available to the ATM layer user, after allowing for
//  the ATM cell header.
//
#define ATM_USER_DATA_RATE_SONET_155					  1356317
#define ATM_USER_DATA_RATE_IBM_25			               227556



//
//  The ATM Service Registry MIB Table is used to locate ATM network
//  services. OID_ATM_GET_SERVICE_ADDRESS is used by clients to access
//  this table.
//

typedef ULONG		ATM_SERVICE_REGISTRY_TYPE;

#define ATM_SERVICE_REGISTRY_LECS		1	// LAN Emulation Configuration Server
#define ATM_SERVICE_REGISTRY_ANS		2	// ATM Name Server

//
//  Structure passed to OID_ATM_GET_SERVICE_ADDRESS.
//
typedef struct _ATM_SERVICE_ADDRESS_LIST
{
	ATM_SERVICE_REGISTRY_TYPE	ServiceRegistryType;
	ULONG						NumberOfAddressesAvailable;
	ULONG						NumberOfAddressesReturned;
	ATM_ADDRESS					Address[1];
} ATM_SERVICE_ADDRESS_LIST, *PATM_SERVICE_ADDRESS_LIST;

#endif	//	_ATM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\sys\wrapper.c ===
/*++

Copyright(c) 1992  Microsoft Corporation

Module Name:

    wrapper.c

Abstract:

    This file contains wrapper for all function calls that call outside atmepvc.sys.

Author:

    ADube , 03/31/00

Environment:


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

VOID
epvcOpenProtocolConfiguration(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            ConfigurationHandle,
    IN  PNDIS_STRING            ProtocolSection,
    PRM_STACK_RECORD            pSR
    )
{
    TRACE (TL_T, TM_Pt, (" == NdisOpenProtocolConfiguration") );    

    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    NdisOpenProtocolConfiguration(Status,
                             ConfigurationHandle,
                             ProtocolSection);

}



VOID
epvcOpenConfigurationKeyByName(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             ConfigurationHandle,
    IN  PNDIS_STRING            SubKeyName,
    OUT PNDIS_HANDLE            SubKeyHandle,
    PRM_STACK_RECORD            pSR
    )
{
    TRACE (TL_T, TM_Pt, (" == NdisOpenConfigurationKeyByName") );   

    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    NdisOpenConfigurationKeyByName(
                                Status,
                                ConfigurationHandle,
                                SubKeyName,
                                SubKeyHandle
                                );


}



VOID
epvcOpenConfigurationKeyByIndex(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             ConfigurationHandle,
    IN  ULONG                   Index,
    OUT PNDIS_STRING            KeyName,
    OUT PNDIS_HANDLE            KeyHandle,
    PRM_STACK_RECORD            pSR
    
    )
{

    TRACE (TL_T, TM_Pt, (" == NdisOpenConfigurationKeyByIndex") );  

    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    NdisOpenConfigurationKeyByIndex(
                                Status,
                                ConfigurationHandle,
                                Index,
                                KeyName,
                                KeyHandle);

}



VOID
epvcOpenAdapter(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_STATUS            OpenErrorStatus,
    OUT PNDIS_HANDLE            NdisBindingHandle,
    OUT PUINT                   SelectedMediumIndex,
    IN  PNDIS_MEDIUM            MediumArray,
    IN  UINT                    MediumArraySize,
    IN  NDIS_HANDLE             NdisProtocolHandle,
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_STRING            AdapterName,
    IN  UINT                    OpenOptions,
    IN  PSTRING                 AddressingInformation OPTIONAL,
    PRM_STACK_RECORD            pSR
    )
{

    TRACE (TL_T, TM_Pt, (" == epvcOpenAdapter") );  

    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    NdisOpenAdapter(
        Status,
        OpenErrorStatus,
        NdisBindingHandle,
        SelectedMediumIndex,
        MediumArray,
        MediumArraySize,
        NdisProtocolHandle,
        ProtocolBindingContext,
        AdapterName,
        OpenOptions,
        AddressingInformation OPTIONAL
        );


}




VOID
epvcCloseAdapter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    PRM_STACK_RECORD            pSR
    )
{
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    TRACE (TL_T, TM_Pt, (" == epvcCloseAdapter") ); 
    NdisCloseAdapter(
        Status,
        NdisBindingHandle
        );

}


NDIS_STATUS
epvcClOpenAddressFamily(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PCO_ADDRESS_FAMILY      AddressFamily,
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  PNDIS_CLIENT_CHARACTERISTICS ClCharacteristics,
    IN  UINT                    SizeOfClCharacteristics,
    OUT PNDIS_HANDLE            NdisAfHandle
    )

{

    TRACE (TL_T, TM_Pt, (" == epvcClOpenAddressFamily") );  
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    return NdisClOpenAddressFamily(
                                NdisBindingHandle,
                                AddressFamily,
                                ProtocolAfContext,
                                ClCharacteristics,
                                SizeOfClCharacteristics,
                                NdisAfHandle
                                );
}



NDIS_STATUS
epvcCoCreateVc(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             NdisAfHandle        OPTIONAL,   // For CM signalling VCs
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN OUT PNDIS_HANDLE         NdisVcHandle
    )
{


    TRACE (TL_T, TM_Pt, (" == epvcCoCreateVc") );
    //ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    return NdisCoCreateVc(NdisBindingHandle,
                       NdisAfHandle     OPTIONAL,   // For CM signalling VCs
                       ProtocolVcContext,
                       NdisVcHandle
                       );

}

NDIS_STATUS
epvcClCloseCall(
    IN  NDIS_HANDLE             NdisVcHandle
    )
{

    TRACE (TL_T, TM_Pt, (" == EpvcClCloseCall") );  

    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    return NdisClCloseCall( NdisVcHandle,
                            NULL,
                            NULL,
                            0);


}




NDIS_STATUS
epvcClMakeCall(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    OUT PNDIS_HANDLE            NdisPartyHandle         OPTIONAL
    )
{
    TRACE (TL_T, TM_Pt, (" == EpvcClMakeCall") );   
    ASSERT (NdisVcHandle != NULL);
    //ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    return NdisClMakeCall( NdisVcHandle,
                        CallParameters,
                        ProtocolPartyContext    OPTIONAL,
                        NdisPartyHandle         OPTIONAL
                        );


}



NDIS_STATUS
epvcCoDeleteVc(
    IN  NDIS_HANDLE             NdisVcHandle
    )
{

    TRACE (TL_T, TM_Pt, (" == epvcCoDeleteVc") );   

    ASSERT (NdisVcHandle!= NULL);
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    return NdisCoDeleteVc(NdisVcHandle);

}



NDIS_STATUS
epvcAllocateMemoryWithTag(
    OUT PVOID *                 VirtualAddress,
    IN  UINT                    Length,
    IN  ULONG                   Tag
    )
{

    return NdisAllocateMemoryWithTag(
                           VirtualAddress,
                           Length,
                           Tag
                           );


}


VOID
epvcFreeMemory(
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length,
    IN  UINT                    MemoryFlags
    )
{
    NdisFreeMemory( VirtualAddress,
                    Length,
                    MemoryFlags
                    );


}


VOID
epvcInitializeEvent(
    IN  PNDIS_EVENT             Event
)
{
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    NdisInitializeEvent(Event);
}


BOOLEAN
epvcWaitEvent(
    IN  PNDIS_EVENT             Event,
    IN  UINT                    msToWait
)
{
    return (NdisWaitEvent(Event,msToWait));
}



VOID
epvcSetEvent(
    IN  PNDIS_EVENT             Event   
    )
{
    NdisSetEvent(Event);
}

VOID
epvcResetEvent(
    IN  PNDIS_EVENT             Event
    )
{
    
    NdisResetEvent(Event);
}



VOID
epvcCoRequestComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             NdisVcHandle    OPTIONAL,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL,
    IN  PNDIS_REQUEST           NdisRequest
    )
{
    TRACE (TL_T, TM_Cl, ("-- epvcCoRequestComplete"));
    NdisCoRequestComplete(Status,
                        NdisAfHandle,
                        NdisVcHandle    OPTIONAL,
                        NdisPartyHandle OPTIONAL,
                        NdisRequest
                         );



}



VOID
epvcEnumerateObjectsInGroup (
    PRM_GROUP               pGroup,
    PFN_RM_GROUP_ENUMERATOR pfnEnumerator,
    PVOID                   pvContext,
    PRM_STACK_RECORD        pSR
    )
{


    RmWeakEnumerateObjectsInGroup(pGroup,
                                  pfnEnumerator,
                                  pvContext,
                                  pSR
                                  );

    return;

}



VOID
epvcAllocatePacketPool(
    OUT PNDIS_STATUS            Status,
    OUT PEPVC_PACKET_POOL       pPktPool,
    IN  UINT                    NumberOfDescriptors,
    IN  UINT                    NumberOfOverflowDescriptors,
    IN  UINT                    ProtocolReservedLength
    )
{

    EPVC_ZEROSTRUCT(pPktPool);

    NdisAllocatePacketPoolEx(
        Status,
        &pPktPool->Handle,
        NumberOfDescriptors,
        NumberOfOverflowDescriptors,
        ProtocolReservedLength
        );


}


VOID
epvcFreePacketPool(
    IN  PEPVC_PACKET_POOL       pPktPool
    )
{
    //
    // Callable at PASSIVE ONLY
    //
    UINT i = 0;
    
    ASSERT (pPktPool->Handle != NULL);



    while (NdisPacketPoolUsage(pPktPool->Handle) != 0)
    {
        if (i >0)
        {
            TRACE (TL_I, TM_Mp, ("Looping in epvcFreePacketPool"));
        }
        NdisMSleep (10000); // 10 ms
        i++;
    }

    
    NdisFreePacketPool(pPktPool->Handle );

    // 
    // Zero out the Handle, 
    //
    EPVC_ZEROSTRUCT (pPktPool);
}



VOID
epvcAllocatePacket(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_PACKET *          Packet,
    IN  PEPVC_PACKET_POOL       pPktPool
    )
{


    NdisAllocatePacket(Status,Packet,pPktPool->Handle);
    if (*Status == NDIS_STATUS_SUCCESS)
    {
        NdisInterlockedIncrement (&pPktPool->AllocatedPackets);

    } 
    else
    {
        Packet = NULL;
    }

}


VOID 
epvcFreePacket (
    IN PNDIS_PACKET pPkt,
    IN PEPVC_PACKET_POOL pPool
    )
{

    NdisInterlockedDecrement (&pPool->AllocatedPackets);
    NdisFreePacket(pPkt);

}


VOID
epvcDprFreePacket(
    IN  PNDIS_PACKET            Packet,
    IN  PEPVC_PACKET_POOL       pPool
    )
{

    NdisInterlockedDecrement (&pPool->AllocatedPackets);
    NdisDprFreePacket(Packet);

}


VOID
epvcDprAllocatePacket(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_PACKET *          Packet,
    IN  PEPVC_PACKET_POOL       pPktPool
    )
{
    NdisDprAllocatePacket(  Status,
                            Packet,
                            pPktPool->Handle    );


    if (*Status == NDIS_STATUS_SUCCESS)
    {
        NdisInterlockedIncrement (&pPktPool->AllocatedPackets);

    } 
    else
    {
        Packet = NULL;
    }
    

}


NDIS_STATUS
epvcClCloseAddressFamily(
    IN  NDIS_HANDLE             NdisAfHandle
    )
{

    TRACE (TL_V, TM_Pt, ("epvcClCloseAddressFamily "));
    return NdisClCloseAddressFamily(NdisAfHandle);


}


VOID
epvcMIndicateStatus(
    IN  PEPVC_I_MINIPORT        pMiniport ,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    )
{



    if (CanMiniportIndicate(pMiniport) == FALSE)
    {
        return;
    }
    


    NdisMIndicateStatus(pMiniport->ndis.MiniportAdapterHandle,
                        GeneralStatus,
                        StatusBuffer,
                        StatusBufferSize
                        );


}



VOID
epvcMIndicateReceivePacket(
    IN  PEPVC_I_MINIPORT        pMiniport,
    IN  PPNDIS_PACKET           ReceivedPackets,
    IN  UINT                    NumberOfPackets
    )
{

    NdisMIndicateReceivePacket(pMiniport->ndis.MiniportAdapterHandle,
                               ReceivedPackets,
                               NumberOfPackets  );




}



VOID
epvcFreeBuffer(
    IN  PNDIS_BUFFER            Buffer
    )
{
    NdisFreeBuffer(Buffer);

}



VOID
epvcAllocateBuffer(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_BUFFER *          Buffer,
    IN  NDIS_HANDLE             PoolHandle,
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length
    )
{

    NdisAllocateBuffer(Status,
                       Buffer,
                       PoolHandle,
                       VirtualAddress,
                       Length
                       );




}




VOID
epvcMSendComplete(
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET pPkt,
    IN NDIS_STATUS Status
    )
{
    epvcValidatePacket (pPkt);

    NdisMSendComplete(pMiniport->ndis.MiniportAdapterHandle,
                             pPkt,
                             Status);


}



VOID
epvcReturnPacketToNdis(
    IN  PEPVC_I_MINIPORT        pMiniport,
    IN  PNDIS_PACKET            pPacket,
    IN  PRM_STACK_RECORD        pSR
    )
{

    epvcValidatePacket (pPacket);
    NdisReturnPackets(&pPacket, 1 );

}



VOID
epvcInitializeWorkItem(
    IN  PRM_OBJECT_HEADER       pObj,   
    IN  PNDIS_WORK_ITEM         WorkItem,
    IN  NDIS_PROC               Routine,
    IN  PVOID                   Context,
    IN PRM_STACK_RECORD         pSR
    )
{




    NdisInitializeWorkItem(WorkItem,
                           Routine,
                           Context);


    NdisScheduleWorkItem(WorkItem);                            



}


VOID
epvcCoSendPackets(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
{

    ASSERT (NumberOfPackets == 1);
    epvcValidatePacket (*PacketArray);
    
    NdisCoSendPackets(NdisVcHandle,PacketArray,NumberOfPackets);


}

VOID
epvcQueryPacket(
    IN  PNDIS_PACKET            _Packet,
    OUT PUINT                   _PhysicalBufferCount OPTIONAL,
    OUT PUINT                   _BufferCount OPTIONAL,
    OUT PNDIS_BUFFER *          _FirstBuffer OPTIONAL,
    OUT PUINT                   _TotalPacketLength OPTIONAL
    )
{


NdisQueryPacket(
    _Packet,
    _PhysicalBufferCount OPTIONAL,
    _BufferCount OPTIONAL,
    _FirstBuffer OPTIONAL,
    _TotalPacketLength OPTIONAL
    );



}


VOID
epvcIMDeInitializeDeviceInstance (
    IN PEPVC_I_MINIPORT pMiniport    
    )
{
    TRACE (TL_I, TM_Pt, ("    NdisIMDeInitializeDeviceInstance pMiniport %p", pMiniport) );

    NdisIMDeInitializeDeviceInstance(pMiniport->ndis.MiniportAdapterHandle);
}

NDIS_STATUS
epvcIMCancelInitializeDeviceInstance (
    IN PEPVC_I_MINIPORT pMiniport
    )

{
    NDIS_STATUS Status;
    TRACE (TL_I, TM_Pt, ("    NdisIMCancelInitializeDeviceInstance pMiniport %p", pMiniport) );

    Status = NdisIMCancelInitializeDeviceInstance (EpvcGlobals.driver.DriverHandle,&pMiniport->ndis.DeviceName);

    TRACE (TL_I, TM_Pt, ("    Status %x\n", Status) );
    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\inc\rwanuser.h ===
/*++ BUILD Version: 0001

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    rwanuser.h

Abstract:

    This header file defines constants and types for accessing the NT
    RAW WAN driver. Based on ntddtcp.h

Author:

    ArvindM					October 13, 1997

Revision History:

--*/

#ifndef _RWANUSER__H
#define _RWANUSER__H


#define FSCTL_RAWWAN_BASE     FILE_DEVICE_NETWORK

#define _RAWWAN_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_RAWWAN_BASE, function, method, access)

#define IOCTL_RWAN_MEDIA_SPECIFIC_GLOBAL_QUERY	\
			_RAWWAN_CTL_CODE(0, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_RWAN_MEDIA_SPECIFIC_GLOBAL_SET  \
            _RAWWAN_CTL_CODE(1, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_RWAN_MEDIA_SPECIFIC_CONN_HANDLE_QUERY	\
			_RAWWAN_CTL_CODE(2, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_RWAN_MEDIA_SPECIFIC_CONN_HANDLE_SET	\
            _RAWWAN_CTL_CODE(3, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_RWAN_MEDIA_SPECIFIC_ADDR_HANDLE_QUERY	\
			_RAWWAN_CTL_CODE(4, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_RWAN_MEDIA_SPECIFIC_ADDR_HANDLE_SET	\
            _RAWWAN_CTL_CODE(5, METHOD_NEITHER, FILE_ANY_ACCESS)



#define IOCTL_RWAN_GENERIC_GLOBAL_QUERY	\
			_RAWWAN_CTL_CODE(10, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_RWAN_GENERIC_GLOBAL_SET  \
            _RAWWAN_CTL_CODE(11, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_RWAN_GENERIC_CONN_HANDLE_QUERY	\
			_RAWWAN_CTL_CODE(12, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_RWAN_GENERIC_CONN_HANDLE_SET	\
            _RAWWAN_CTL_CODE(13, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_RWAN_GENERIC_ADDR_HANDLE_QUERY	\
			_RAWWAN_CTL_CODE(14, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_RWAN_GENERIC_ADDR_HANDLE_SET	\
            _RAWWAN_CTL_CODE(15, METHOD_NEITHER, FILE_ANY_ACCESS)


typedef UINT	RWAN_OBJECT_ID;

//
//  Query Information structure. This is passed in as the InputBuffer in
//  the DeviceIoControl. The return information is to be filled into the
//  OutputBuffer.
//
typedef struct _RWAN_QUERY_INFORMATION_EX
{
	RWAN_OBJECT_ID			ObjectId;
	INT						ContextLength;
	UCHAR					Context[1];
} RWAN_QUERY_INFORMATION_EX, *PRWAN_QUERY_INFORMATION_EX;


//
//  Set Information structure. This is passed in as the InputBuffer to
//  the DeviceIoControl. There is no OutputBuffer.
//
typedef struct _RWAN_SET_INFORMATION_EX
{
	RWAN_OBJECT_ID			ObjectId;
	INT						BufferSize;
	UCHAR					Buffer[1];
} RWAN_SET_INFORMATION_EX, *PRWAN_SET_INFORMATION_EX;


//
//  Raw WAN Object IDs
//
#define RWAN_OID_ADDRESS_OBJECT_FLAGS		((RWAN_OBJECT_ID)1)
#define RWAN_OID_CONN_OBJECT_MAX_MSG_SIZE	((RWAN_OBJECT_ID)2)



//
//  Bit definitions for Address Object Flags
//
#define RWAN_AOFLAG_C_ROOT					((ULONG)0x00000001)
#define RWAN_AOFLAG_C_LEAF					((ULONG)0x00000002)
#define RWAN_AOFLAG_D_ROOT					((ULONG)0x00000004)
#define RWAN_AOFLAG_D_LEAF					((ULONG)0x00000008)


#endif // _RWANUSER__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\sys\wrapper.h ===
/*++

Copyright(c) 1992  Microsoft Corporation

Module Name:

    wrapper.c

Abstract:

    This file contains declarations for all wrapper function calls .

Author:

    ADube , 03/31/00

Environment:


Revision History:


--*/


#ifndef _ATMEPVC_WRAPPER
#define _ATMEPVC_WRAPPER 1


VOID
epvcOpenProtocolConfiguration(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            ConfigurationHandle,
    IN  PNDIS_STRING            ProtocolSection,
    PRM_STACK_RECORD            pSR
    );


VOID
epvcOpenConfigurationKeyByName(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             ConfigurationHandle,
    IN  PNDIS_STRING            SubKeyName,
    OUT PNDIS_HANDLE            SubKeyHandle,
    PRM_STACK_RECORD            pSR
    );



VOID
epvcOpenConfigurationKeyByIndex(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             ConfigurationHandle,
    IN  ULONG                   Index,
    OUT PNDIS_STRING            KeyName,
    OUT PNDIS_HANDLE            KeyHandle,
    PRM_STACK_RECORD            pSR
    
    );


VOID
epvcOpenAdapter(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_STATUS            OpenErrorStatus,
    OUT PNDIS_HANDLE            NdisBindingHandle,
    OUT PUINT                   SelectedMediumIndex,
    IN  PNDIS_MEDIUM            MediumArray,
    IN  UINT                    MediumArraySize,
    IN  NDIS_HANDLE             NdisProtocolHandle,
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_STRING            AdapterName,
    IN  UINT                    OpenOptions,
    IN  PSTRING                 AddressingInformation OPTIONAL,
    PRM_STACK_RECORD            pSR
    );


VOID
epvcCloseAdapter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
epvcClOpenAddressFamily(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PCO_ADDRESS_FAMILY      AddressFamily,
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  PNDIS_CLIENT_CHARACTERISTICS ClCharacteristics,
    IN  UINT                    SizeOfClCharacteristics,
    OUT PNDIS_HANDLE            NdisAfHandle
    );

NDIS_STATUS
epvcCoCreateVc(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             NdisAfHandle        OPTIONAL,   // For CM signalling VCs
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN OUT PNDIS_HANDLE         NdisVcHandle
    );

NDIS_STATUS
epvcClMakeCall(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    OUT PNDIS_HANDLE            NdisPartyHandle         OPTIONAL
    );


NDIS_STATUS
epvcClCloseCall(
    IN  NDIS_HANDLE             NdisVcHandle
    );

NDIS_STATUS
epvcAllocateMemoryWithTag(
    OUT PVOID *                 VirtualAddress,
    IN  UINT                    Length,
    IN  ULONG                   Tag
    );

NDIS_STATUS
epvcCoDeleteVc(
    IN  NDIS_HANDLE             NdisVcHandle
    );

VOID
epvcFreeMemory(
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length,
    IN  UINT                    MemoryFlags
    );

VOID
epvcInitializeEvent(
    IN  PNDIS_EVENT             Event
);

BOOLEAN
epvcWaitEvent(
    IN  PNDIS_EVENT             Event,
    IN  UINT                    msToWait
);

VOID
epvcSetEvent(
    IN  PNDIS_EVENT             Event
    );

VOID
epvcResetEvent(
    IN  PNDIS_EVENT             Event
    );

VOID
epvcCoRequestComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             NdisVcHandle    OPTIONAL,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL,
    IN  PNDIS_REQUEST           NdisRequest
    );

VOID
epvcEnumerateObjectsInGroup (
    PRM_GROUP               pGroup,
    PFN_RM_GROUP_ENUMERATOR pfnEnumerator,
    PVOID                   pvContext,
    PRM_STACK_RECORD        pSR
    );


VOID
epvcAllocatePacketPool(
    OUT PNDIS_STATUS            Status,
    OUT PEPVC_PACKET_POOL       pPktPool,
    IN  UINT                    NumberOfDescriptors,
    IN  UINT                    NumberOfOverflowDescriptors,
    IN  UINT                    ProtocolReservedLength
    );

VOID
epvcFreePacketPool(
    IN  PEPVC_PACKET_POOL       pPktPool
    );

VOID 
epvcFreePacket (
    IN PNDIS_PACKET pPkt,
    IN PEPVC_PACKET_POOL pPool
    );
    
VOID
epvcAllocatePacket(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_PACKET *          Packet,
    IN  PEPVC_PACKET_POOL       pPktPool
    );


VOID
epvcDprFreePacket(
    IN  PNDIS_PACKET            Packet,
    IN  PEPVC_PACKET_POOL       pPool
    );

VOID
epvcDprAllocatePacket(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_PACKET *          Packet,
    IN  PEPVC_PACKET_POOL       pPktPool
    );

NDIS_STATUS
epvcClCloseAddressFamily(
    IN  NDIS_HANDLE             NdisAfHandle
    );

VOID
epvcMIndicateStatus(
    IN  PEPVC_I_MINIPORT        pMiniport ,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    );


VOID
epvcMIndicateReceivePacket(
    IN  PEPVC_I_MINIPORT        pMiniport,
    IN  PPNDIS_PACKET           ReceivedPackets,
    IN  UINT                    NumberOfPackets
    );

VOID
epvcFreeBuffer(
    IN  PNDIS_BUFFER            Buffer
    );



VOID
epvcAllocateBuffer(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_BUFFER *          Buffer,
    IN  NDIS_HANDLE             PoolHandle,
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length
    );

VOID
epvcMSendComplete(
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET pPkt,
    IN NDIS_STATUS Status
    );


VOID
epvcReturnPacketToNdis(
    IN  PEPVC_I_MINIPORT        pMiniport,
    IN  PNDIS_PACKET            pPacket,
    IN  PRM_STACK_RECORD        pSR
    );

VOID
epvcInitializeWorkItem(
    IN  PRM_OBJECT_HEADER       pObj,   
    IN  PNDIS_WORK_ITEM         WorkItem,
    IN  NDIS_PROC               Routine,
    IN  PVOID                   Context,
    IN  PRM_STACK_RECORD        pSR
    );

VOID
epvcCoSendPackets(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    );

VOID
epvcQueryPacket(
    IN  PNDIS_PACKET            _Packet,
    OUT PUINT                   _PhysicalBufferCount OPTIONAL,
    OUT PUINT                   _BufferCount OPTIONAL,
    OUT PNDIS_BUFFER *          _FirstBuffer OPTIONAL,
    OUT PUINT                   _TotalPacketLength OPTIONAL
    );


VOID
epvcIMDeInitializeDeviceInstance (
    IN PEPVC_I_MINIPORT pMiniport    
    );

NDIS_STATUS
epvcIMCancelInitializeDeviceInstance (
    IN PEPVC_I_MINIPORT pMiniport
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\kdext\kdlane.c ===
#include <windows.h>
#include <wtypes.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ntverp.h>

#include "tracelog.h"
#include "event.h"

void PrintTraceLogEntry(FILE *outfile, PTRACEENTRY TraceEntry);

void PrintTraceLogEntry(FILE *outfile, PTRACEENTRY TraceEntry);

EXT_API_VERSION        ApiVersion = { 4, 0, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;

// ======================================================================

#define MAXREAD 3500

BOOL ReadMemoryEx(ULONG_PTR From, ULONG_PTR To, ULONG Size, PULONG OutBytesRead)
	{
	ULONG BytesRead;
	ULONG TotalBytesRead = 0;
	BOOL success;

//	dprintf("ReadMemoryEx: reading %08x bytes from %08x to %08x\n", Size, From, To);

	while (Size)
		{
		if (CheckControlC())
			return 0;
		if (Size > MAXREAD)
			{
//			dprintf("(reading %08x bytes from %08x to %08x)\n",	MAXREAD, From, To);
			success = ReadMemory((ULONG_PTR)From, (PVOID)To, MAXREAD, &BytesRead);
			if (!success)
				{
       			dprintf("Problem reading memory at %x for %x bytes\n", From, MAXREAD);
				break;
				}
			TotalBytesRead += BytesRead;
			}
		else
			{
//			dprintf("(reading %08x bytes from %08x to %08x)\n",	Size, From, To);
			success = ReadMemory((ULONG_PTR)From, (PVOID)To, Size, &BytesRead);
			if (!success)
				{
       			dprintf("Problem reading memory at %x for %x bytes\n", From, Size);
				break;
				}
			TotalBytesRead += BytesRead;
			}

		if (Size > MAXREAD)
			{
			Size -= MAXREAD;
			From += MAXREAD;
			To += MAXREAD;
			}
		else
			Size = 0;
		}

	*OutBytesRead = TotalBytesRead;
	return success;
	}

// ======================================================================

ULONG_PTR GetTraceLogAddress(VOID)
	{
	ULONG_PTR TargetTraceLog;
	PUCHAR symbol = "ATMLANE!TraceLog";	
	
	TargetTraceLog = (ULONG_PTR)GetExpression(symbol);	

    if ( !TargetTraceLog ) 
		{
        dprintf("Unable to resolve symbol \"%s\". Try .reload cmd.\n", symbol);
        return 0;
	    }
	return TargetTraceLog;
	}

// ======================================================================

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}

// ======================================================================

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

// ======================================================================

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf("%s Extension dll for Build %d debugging %s kernel for Build %d\n",
            DebuggerType,
            VER_PRODUCTBUILD,
            SavedMajorVersion == 0x0c ? "Checked" : "Free",
            SavedMinorVersion
            );
}

// ======================================================================

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

// ======================================================================

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

// ======================================================================

DECLARE_API(dumplog)
	{
	ULONG_PTR		 	TargetTraceLogAddress;
	TRACELOG			TargetTraceLog;
	TRACELOG 			LocalTraceLog;
	PUCHAR 				LocalLogStorage;
	PTRACEENTRY 		TraceEntry;
	PUCHAR 				CurString, NullPos;
	UCHAR 				SaveChar;
	ULONG 				LogLength;
    ULONG 				bytesread, firstsize;
	char *				indexstr, *filenamestr;
	ULONG 				index;
	FILE *				outfile;

	filenamestr = strtok((char *)args, " ");	

	if (filenamestr == NULL)
		{
        dprintf("usage: dumplog <filename>\n");
		return;
		}

	TargetTraceLogAddress = GetTraceLogAddress();
	if (!TargetTraceLogAddress)
		return;

    // read trace log struct out of target's memory

    if (!ReadMemoryEx( (ULONG_PTR)TargetTraceLogAddress, (ULONG_PTR)&TargetTraceLog, 
			sizeof(TRACELOG), &bytesread))
        return;

#if 1
	// display trace log vars
	dprintf("TraceLog\n");
	dprintf("\tStorage = 0x%08x\n", TargetTraceLog.Storage);
	dprintf("\tSize    = 0x%08x\n", TargetTraceLog.StorageSizeBytes);
	dprintf("\tFirst   = 0x%08x\n", TargetTraceLog.First);
	dprintf("\tLast    = 0x%08x\n", TargetTraceLog.Last);	
	dprintf("\tCurrent = 0x%08x\n", TargetTraceLog.Current);
#endif

    // see if logging enabled (i.e. log has storage allocated
	
	if (TargetTraceLog.Storage == NULL)
		{
		dprintf("Trace Log is disabled\n");
		return;
		}

	// alloc local memory for log
	
	LocalLogStorage = (PUCHAR) malloc(TargetTraceLog.StorageSizeBytes);
	if (LocalLogStorage == NULL)
		{
		dprintf("can't alloc %d bytes for local storage\n",
			TargetTraceLog.StorageSizeBytes); 
		return;
		}

	// open the output file

	outfile = fopen(filenamestr, "wt");
	if (outfile == NULL)
		{
		dprintf("open of file '%s' failed, errno = %d\n", filenamestr, errno);
		free(LocalLogStorage);
		return;
		}

	// read the log out of target's memory
	
	dprintf("reading log from target system, please wait...\n");

	if (!ReadMemoryEx((ULONG_PTR)TargetTraceLog.Storage, (ULONG_PTR)LocalLogStorage,
			TargetTraceLog.StorageSizeBytes, &bytesread))
			{
			fclose(outfile);
			free(LocalLogStorage);
			return;
			}

	// convert addresses to local trace log
	
	LocalTraceLog.Storage = LocalLogStorage;
	LocalTraceLog.First = (PTRACEENTRY) LocalTraceLog.Storage;
	LocalTraceLog.Last = LocalTraceLog.First + 
		(TargetTraceLog.Last - TargetTraceLog.First);
	LocalTraceLog.Current = LocalTraceLog.First + 
		(TargetTraceLog.Current - TargetTraceLog.First);


	// loop thru the trace log printing out the values

	TraceEntry = LocalTraceLog.Current - 1;

	dprintf("writing formatted log to file...\n");

	for (;;)			
		{
		if (TraceEntry < LocalTraceLog.First)
			TraceEntry = LocalTraceLog.Last;
		if (TraceEntry->EventId == 0 || TraceEntry == LocalTraceLog.Current)
			{		
			dprintf("done.\n");
			break;
			}
		PrintTraceLogEntry(outfile, TraceEntry);	
		TraceEntry--;
		if (CheckControlC()) 
			{		
			dprintf("Aborted before end of log.\n");
			break;
			}
		}


	// cleanup
	
	fclose(outfile);
	free(LocalLogStorage);
	}

// ======================================================================

DECLARE_API( help )
	{
    dprintf("ATMLANE driver kd extensions\n\n");
    dprintf("\tdumplog <filename>  - dumps & formats tracelog buffer to file\n");
	}

// ======================================================================

void PrintTraceLogEntry(FILE *outfile, PTRACEENTRY TraceEntry)
	{
	ULONG params, i;

	switch (TraceEntry->EventId)
		{

		case TL_MSENDPKTIN:
			fprintf(outfile, "[% 10u] MSENDPKTIN: PktCnt %d\n", 
				TraceEntry->Time,
				TraceEntry->Params[0]
				);
			break;

		case TL_MSENDPKTBEGIN:
			fprintf(outfile, "[% 10u] MSENDPKTBEGIN: Index %d Pkt %x\n", 
				TraceEntry->Time,
				TraceEntry->Params[0],
				TraceEntry->Params[1]
				);
			break;

		case TL_MSENDPKTEND:
			fprintf(outfile, "[% 10u] MSENDPKTEND: Index %d Pkt %x Status %x\n", 
				TraceEntry->Time,
				TraceEntry->Params[0],
				TraceEntry->Params[1],
				TraceEntry->Params[2]
				);
			break;

		case TL_MSENDPKTOUT:
			fprintf(outfile, "[% 10u] MSENDPKTOUT\n", 
				TraceEntry->Time,
				TraceEntry->Params[0]
				);
			break;

		case TL_MSENDCOMPL:
			fprintf(outfile, "[% 10u] MSENDCOMPL: Pkt %x Status %x\n", 
				TraceEntry->Time,
				TraceEntry->Params[0],
				TraceEntry->Params[1]
				);
			break;
		
		case TL_WRAPSEND:
			fprintf(outfile, "[% 10u] WRAPSEND: From %x To %x Bcnt %d Len %d\n", 
				TraceEntry->Time,
				TraceEntry->Params[0],
				TraceEntry->Params[1],
				TraceEntry->Params[2],
				TraceEntry->Params[3]
				);
			break;
			
		case TL_UNWRAPSEND:
			fprintf(outfile, "[% 10u] UNWRAPSEND: From %x To %x Bcnt %d Len %d\n", 
				TraceEntry->Time,
				TraceEntry->Params[0],
				TraceEntry->Params[1],
				TraceEntry->Params[2],
				TraceEntry->Params[3]
				);
			break;
			
		case TL_WRAPRECV:
			fprintf(outfile, "[% 10u] WRAPRECV: From %x To %x Bcnt %d Len %d\n", 
				TraceEntry->Time,
				TraceEntry->Params[0],
				TraceEntry->Params[1],
				TraceEntry->Params[2],
				TraceEntry->Params[3]
				);
			break;

		case TL_UNWRAPRECV:
			fprintf(outfile, "[% 10u] UNWRAPRECV: From %x To %x Bcnt %d Len %d\n", 
				TraceEntry->Time,
				TraceEntry->Params[0],
				TraceEntry->Params[1],
				TraceEntry->Params[2],
				TraceEntry->Params[3]
				);
			break;
			
		case TL_COSENDPACKET:
			fprintf(outfile, "[% 10u] COSENDPKT: Pkt %x\n", 
				TraceEntry->Time,
				TraceEntry->Params[0]
				);
			break;

		case TL_COSENDCMPLTIN:
			fprintf(outfile, "[% 10u] COSENDCMPLTIN: Pkt %x Status %x\n", 
				TraceEntry->Time,
				TraceEntry->Params[0],
				TraceEntry->Params[1]
				);
			break;
			
		case TL_COSENDCMPLTOUT:
			fprintf(outfile, "[% 10u] COSENDCMPLTOUT: Pkt %x\n", 
				TraceEntry->Time,
				TraceEntry->Params[0]
				);
			break;

		case TL_CORECVPACKET:
			fprintf(outfile, "[% 10u] CORECVPKT: Pkt %x Vc %x\n", 
				TraceEntry->Time,
				TraceEntry->Params[0],
				TraceEntry->Params[1]
				);
			break;
			
		case TL_CORETNPACKET:
			fprintf(outfile, "[% 10u] CORETNPKT: Pkt %x\n", 
				TraceEntry->Time,
				TraceEntry->Params[0]
				);
			break;
			
		case TL_MINDPACKET:
			fprintf(outfile, "[% 10u] MINDPKT: Pkt %x\n", 
				TraceEntry->Time,
				TraceEntry->Params[0]
				);
			break;
			
		case TL_MRETNPACKET:
			fprintf(outfile, "[% 10u] MRETNPKT: Pkt %x\n", 
				TraceEntry->Time,
				TraceEntry->Params[0]
				);
			break;

		case TL_NDISPACKET:
			fprintf(outfile, "[% 10u] NDISPKT: %x Cnt %d Len %d Bufs %x %x %x %x %x\n",
				TraceEntry->Time,
				TraceEntry->Params[0],
				TraceEntry->Params[1],
				TraceEntry->Params[2],
				TraceEntry->Params[3],
				TraceEntry->Params[4],
				TraceEntry->Params[5],
				TraceEntry->Params[6],
				TraceEntry->Params[7]
				);
			break;
				
		default:
			params = TL_GET_PARAM_COUNT(TraceEntry->EventId);
			fprintf(outfile, "****: Unknown Event ID %d with %d Params: ",
				TL_GET_EVENT(TraceEntry->EventId), params);
			for (i = 0; i <	params; i++)
				fprintf(outfile, "%x ", TraceEntry->Params[i]);
			fprintf(outfile, "\n");
			break;
		}
	}


// ======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\inc\ws2atmsp.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    ws2atmsp.h

Abstract:

    This header file defines constants and types for accessing the ATM-specific
	component of the NT RAW WAN driver.

Author:

    ArvindM					October 13, 1997

Revision History:

--*/

#ifndef _WS2ATMSP__H
#define _WS2ATMSP__H


#define DD_ATM_DEVICE_NAME		L"\\Device\\Atm"


typedef UINT	ATM_OBJECT_ID;

//
//  ATM Object IDs
//
#define ATMSP_OID_NUMBER_OF_DEVICES			((ATM_OBJECT_ID)10)
#define ATMSP_OID_ATM_ADDRESS				((ATM_OBJECT_ID)11)
#define ATMSP_OID_PVC_ID					((ATM_OBJECT_ID)12)
#define ATMSP_OID_CONNECTION_ID				((ATM_OBJECT_ID)13)

//
//  Query Information structure. This is passed in as the InputBuffer in
//  the DeviceIoControl. The return information is to be filled into the
//  OutputBuffer.
//
typedef struct _ATM_QUERY_INFORMATION_EX
{
	ATM_OBJECT_ID			ObjectId;
	INT						ContextLength;
	UCHAR					Context[1];
} ATM_QUERY_INFORMATION_EX, *PATM_QUERY_INFORMATION_EX;


//
//  Set Information structure. This is passed in as the InputBuffer to
//  the DeviceIoControl. There is no OutputBuffer.
//
typedef struct _ATM_SET_INFORMATION_EX
{
	ATM_OBJECT_ID			ObjectId;
	INT						BufferSize;
	UCHAR					Buffer[1];
} ATM_SET_INFORMATION_EX, *PATM_SET_INFORMATION_EX;


#endif // _WS2ATMSP__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\adapter.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	adapter.c

Abstract:

	Handlers for adapter events.
	
Author:

	Larry Cleeton, FORE Systems (v-lcleet)		

Environment:

	Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

NDIS_STATUS
AtmLanePnPEventHandler(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNET_PNP_EVENT			pNetPnPEvent
)
/*++

Routine Description:

	Handler for PnP Events.

Arguments:

	ProtocolBindingContext		-	Handle to protocol's adapter binding context.
									Actually a pointer to our adapter struct.

	pNetPnPEvent				- 	Pointer to PnP Event structure describing the event.

Return Value:

	Status of handling the event.
	
--*/
{
	NDIS_STATUS						Status;
	PATMLANE_ADAPTER				pAdapter;
	PNET_DEVICE_POWER_STATE			pPowerState = (PNET_DEVICE_POWER_STATE)pNetPnPEvent->Buffer;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(PnPEventHandler);

	//	Extract the adapter struct pointer - this will be NULL for
	//  global reconfig messages.

	pAdapter = (PATMLANE_ADAPTER)ProtocolBindingContext;
	
	switch (pNetPnPEvent->NetEvent)
	{
		case NetEventSetPower:
			DBGP((1, "PnPEventHandler: NetEventSetPower\n"));
			switch (*pPowerState)
			{
				case NetDeviceStateD0:

					Status = NDIS_STATUS_SUCCESS;
					break;
				
				default:

					//
					//  We can't suspend, so we ask NDIS to unbind us by
					//  returning this status:
					//
					Status = NDIS_STATUS_NOT_SUPPORTED;
					break;
			}
			break;
		case NetEventQueryPower:
			DBGP((1, "PnPEventHandler: NetEventQueryPower succeeding\n"));
			Status = NDIS_STATUS_SUCCESS;
			break;
		case NetEventQueryRemoveDevice:
			DBGP((1, "PnPEventHandler: NetEventQueryRemoveDevice succeeding\n"));
			Status = NDIS_STATUS_SUCCESS;
			break;
		case NetEventCancelRemoveDevice:
			DBGP((1, "PnPEventHandler: NetEventCancelRemoveDevice succeeding\n"));
			Status = NDIS_STATUS_SUCCESS;
			break;
		case NetEventBindList:
			DBGP((1, "PnPEventHandler: NetEventBindList not supported\n"));
			Status = NDIS_STATUS_NOT_SUPPORTED;
			break;
		case NetEventMaximum:
			DBGP((1, "PnPEventHandler: NetEventMaximum not supported\n"));
			Status = NDIS_STATUS_NOT_SUPPORTED;
			break;
		case NetEventReconfigure:
			DBGP((1, "PnPEventHandler: NetEventReconfigure\n"));
			Status = AtmLaneReconfigureHandler(pAdapter, pNetPnPEvent);
			break;
		default:
			DBGP((1, "PnPEventHandler: Unknown event 0x%x not supported\n", 
					pNetPnPEvent->NetEvent));
			Status = NDIS_STATUS_NOT_SUPPORTED;
			break;
	}
		
	TRACEOUT(PnPEventHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return Status;
}


VOID
AtmLaneBindAdapterHandler(
	OUT	PNDIS_STATUS			pStatus,
	IN	NDIS_HANDLE				BindContext,
	IN	PNDIS_STRING			pDeviceName,
	IN	PVOID					SystemSpecific1,
	IN	PVOID					SystemSpecific2
	)
/*++

Routine Description:

	Handler for BindAdapter event from NDIS.

Arguments:

	Status			-	Points to a variable to return the status
						of the bind operation.
	BindContext		- 	NDIS supplied handle to be used in call to 
						NdisCompleteBindAdapter.
	pDeviceName		- 	Points to a counted, zero-terminated Unicode
						string naming the adapter to open. 
	SystemSpecific1	-	Registry path pointer to be used in call to
						NdisOpenProtocolConfiguration. 
	SystemSpecific2 - 	Reserved.

Return Value:

	None.
	
--*/
{
	PATMLANE_ADAPTER				pAdapter;
	PATMLANE_ELAN					pElan;
	NDIS_STATUS						Status;
	NDIS_STATUS						OutputStatus;
	NDIS_STATUS						OpenStatus;
	NDIS_MEDIUM						Media;
	UINT							MediumIndex;
	ULONG							rc;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(BindAdapterHandler);

	do
	{
		//
		//	Initialize for error clean-up.
		//
		Status = NDIS_STATUS_SUCCESS;
		pAdapter = NULL_PATMLANE_ADAPTER;

		if (AtmLaneIsDeviceAlreadyBound(pDeviceName))
		{
			DBGP((0, "BindAdapterHandler: duplicate bind to %ws\n", pDeviceName->Buffer));
			Status = NDIS_STATUS_NOT_ACCEPTED;
			break;
		}

		//
		//	Allocate Adapter structure.
		//
		pAdapter = AtmLaneAllocAdapter(pDeviceName, SystemSpecific1);
		if (NULL_PATMLANE_ADAPTER == pAdapter)
		{
			DBGP((0, "BindAdapterHandler: Allocate of adapter struct failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Put open adapter reference on the Adapter struct.
		//
		(VOID)AtmLaneReferenceAdapter(pAdapter, "openadapter");		

		//
		//	Save bind context
		//
		pAdapter->BindContext = BindContext;

		//
		//	Open the Adapter.
		//
		INIT_BLOCK_STRUCT(&(pAdapter->Block));
		INIT_BLOCK_STRUCT(&(pAdapter->OpenBlock));
		pAdapter->Flags |= ADAPTER_FLAGS_OPEN_IN_PROGRESS;
		
		Media = NdisMediumAtm;

		NdisOpenAdapter(
			&Status,
			&OpenStatus,
			&(pAdapter->NdisAdapterHandle),
			&(MediumIndex),						
			&Media,
			1,
			pAtmLaneGlobalInfo->NdisProtocolHandle,
			(NDIS_HANDLE)pAdapter,
			pDeviceName,
			0,
			(PSTRING)NULL);
			
		if (Status == NDIS_STATUS_PENDING)
		{
			//
			//  Wait for completion.
			//
			Status = WAIT_ON_BLOCK_STRUCT(&(pAdapter->Block));
		}

		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, "BindAdapterHandler: NdisOpenAdapter failed, status %x\n",
						Status));
			break;
		}

		//
		//  Get info from Adapter
		//
		AtmLaneGetAdapterInfo(pAdapter);

		//
		//  Allow an AF notification thread to proceed now.
		//
		ACQUIRE_ADAPTER_LOCK(pAdapter);
		pAdapter->Flags &= ~ADAPTER_FLAGS_OPEN_IN_PROGRESS;
		SIGNAL_BLOCK_STRUCT(&pAdapter->OpenBlock, NDIS_STATUS_SUCCESS);
		RELEASE_ADAPTER_LOCK(pAdapter);

		break;		

	} while (FALSE);


	//
	//	If bad status then cleanup.
	//
	if (NDIS_STATUS_SUCCESS != Status)
	{
		//
		//	Dereference the Adapter struct if it exists
		//
		if (NULL_PATMLANE_ADAPTER != pAdapter)
		{
			rc = AtmLaneDereferenceAdapter(pAdapter, "openadapter");
			ASSERT(rc == 0);
		}
		
		DBGP((0, "BindAdapterHandler: Bad status %x\n", Status));
	}

	//
	//	Output Status
	//
	*pStatus = Status;


	TRACEOUT(BindAdapterHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneUnbindAdapterHandler(
	OUT	PNDIS_STATUS			pStatus,
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				UnbindContext
	)
/*++

Routine Description:

	Handler for UnBindAdapter event from NDIS.

Arguments:

	Status					-	Points to a variable to return the status
								of the unbind operation.
	ProtocolBindingContext	- 	Specifies the handle to a protocol-allocated context area
								in which the protocol driver maintains per-binding runtime
								state. The driver supplied this handle when it called
								NdisOpenAdapter. 
	UnbindContext			-	Specifies a handle, supplied by NDIS, that the protocol
								passes subsequently to NdisCompleteUnbindAdapter. 

Return Value:

	None.
	
--*/
{
	PATMLANE_ADAPTER		pAdapter;
	PATMLANE_ELAN			pElan;
	PLIST_ENTRY				p;
	PATMLANE_ATM_ENTRY		pAtmEntry;
	PATMLANE_ATM_ENTRY		pNextAtmEntry;
	PATMLANE_MAC_ENTRY		pMacEntry;
	ULONG					rc;
	ULONG					i;
	BOOLEAN					WasCancelled;
	BOOLEAN					CompleteUnbind;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(UnbindAdapterHandler);

	pAdapter = (PATMLANE_ADAPTER)ProtocolBindingContext;
	STRUCT_ASSERT(pAdapter, atmlane_adapter);

	DBGP((0, "UnbindAdapterHandler: pAdapter %p, UnbindContext %x\n",
				pAdapter, UnbindContext));

	*pStatus = NDIS_STATUS_PENDING;


	//
	//  Save the unbind context for a possible later call to
	//  NdisCompleteUnbindAdapter.
	//  
	ACQUIRE_ADAPTER_LOCK(pAdapter);
	
	pAdapter->UnbindContext = UnbindContext;

	pAdapter->Flags |= ADAPTER_FLAGS_UNBINDING;

	while (pAdapter->Flags & ADAPTER_FLAGS_BOOTSTRAP_IN_PROGRESS)
	{
		RELEASE_ADAPTER_LOCK(pAdapter);
		(VOID)WAIT_ON_BLOCK_STRUCT(&pAdapter->UnbindBlock);
		ACQUIRE_ADAPTER_LOCK(pAdapter);
	}

	if (IsListEmpty(&pAdapter->ElanList))
	{	
		CompleteUnbind = TRUE;
	}
	else
	{
		//
		//  We will complete the unbind later.
		//
		pAdapter->Flags |= ADAPTER_FLAGS_UNBIND_COMPLETE_PENDING;
		CompleteUnbind = FALSE;
	}

	RELEASE_ADAPTER_LOCK(pAdapter);

	//
	//  If there are no elans on this adapter, we are done.
	//

	if (CompleteUnbind)
	{
		AtmLaneCompleteUnbindAdapter(pAdapter);
		CHECK_EXIT_IRQL(EntryIrql); 
		return;
	}

	//
	//	Shutdown each ELAN
	//
	ACQUIRE_ADAPTER_LOCK(pAdapter);

	p = pAdapter->ElanList.Flink;
	while (p != &pAdapter->ElanList)
	{
		pElan = CONTAINING_RECORD(p, ATMLANE_ELAN, Link);
		STRUCT_ASSERT(pElan, atmlane_elan);

		ACQUIRE_ELAN_LOCK(pElan);
		AtmLaneReferenceElan(pElan, "tempUnbind");
		RELEASE_ELAN_LOCK(pElan);

		p = p->Flink;
	}

	RELEASE_ADAPTER_LOCK(pAdapter);

	p = pAdapter->ElanList.Flink;
	while (p != &pAdapter->ElanList)
	{
		pElan = CONTAINING_RECORD(p, ATMLANE_ELAN, Link);
		STRUCT_ASSERT(pElan, atmlane_elan);

		//
		// get next pointer before elan goes away
		//
		p = p->Flink;

		//
		//  Kill the ELAN
		//
		ACQUIRE_ELAN_LOCK(pElan);
		rc = AtmLaneDereferenceElan(pElan, "tempUnbind");
		if (rc != 0)
		{
			AtmLaneShutdownElan(pElan, FALSE);
		}
	}

	TRACEOUT(UnbindAdapterHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneCompleteUnbindAdapter(
	IN	PATMLANE_ADAPTER				pAdapter
)
/*++

Routine Description:

	Complete the process of adapter unbinding. All Elans on this
	adapter are assumed to have been removed.

	We start it off by calling NdisCloseAdapter. Action continues
	in our CloseAdapterComplete routine.

Arguments:

	pAdapter		- Pointer to the adapter being unbound.

Return Value:

	None

--*/
{
	NDIS_STATUS			Status;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(CompleteUnbindAdapter);
	
	DBGP((3, "CompleteUnbindAdapter: pAdapter %x, AdapterHandle %x\n",
			pAdapter, pAdapter->NdisAdapterHandle));

	ASSERT(pAdapter->NdisAdapterHandle != NULL);

	pAdapter->Flags |= ADAPTER_FLAGS_CLOSE_IN_PROGRESS;

	NdisCloseAdapter(
		&Status,
		pAdapter->NdisAdapterHandle
		);

	if (Status != NDIS_STATUS_PENDING)
	{
		AtmLaneCloseAdapterCompleteHandler(
			(NDIS_HANDLE)pAdapter,
			Status
			);
	}
	
	TRACEOUT(CompleteUnbindAdapter);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneOpenAdapterCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status,
	IN	NDIS_STATUS					OpenErrorStatus
)
/*++

Routine Description:

	This is called by NDIS when a previous call to NdisOpenAdapter
	that had pended has completed. The thread that called NdisOpenAdapter
	would have blocked itself, so we simply wake it up now.

Arguments:

	ProtocolBindingContext	- Our context for this adapter binding, which
							  is a pointer to an ATMLANE Adapter structure.
	Status					- Status of OpenAdapter
	OpenErrorStatus			- Error code in case of failure.

Return Value:

	None

--*/
{
	PATMLANE_ADAPTER			pAdapter;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);
	
	TRACEIN(OpenAdapterCompleteHandler);

	pAdapter = (PATMLANE_ADAPTER)ProtocolBindingContext;

	STRUCT_ASSERT(pAdapter, atmlane_adapter);

	SIGNAL_BLOCK_STRUCT(&(pAdapter->Block), Status);
	
	TRACEOUT(OpenAdapterCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneCloseAdapterCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status
)
/*++

Routine Description:

	This is called by NDIS when a previous call to NdisCloseAdapter
	that had pended has completed. The thread that called NdisCloseAdapter
	would have blocked itself, so we simply wake it up now.

Arguments:

	ProtocolBindingContext	- Our context for this adapter binding, which
							  is a pointer to an ATMLANE Adapter structure.
	Status					- Status of CloseAdapter

Return Value:

	None

--*/
{
	PATMLANE_ADAPTER			pAdapter;
	NDIS_HANDLE					UnbindContext;
	ULONG						rc;
#if DEBUG_IRQL
	KIRQL						EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(CloseAdapterCompleteHandler);
	
	pAdapter = (PATMLANE_ADAPTER)ProtocolBindingContext;

	STRUCT_ASSERT(pAdapter, atmlane_adapter);

	pAdapter->Flags &= ~ADAPTER_FLAGS_CLOSE_IN_PROGRESS;

	pAdapter->NdisAdapterHandle = NULL;
	UnbindContext = pAdapter->UnbindContext;

	DBGP((0, "CloseAdapterComplete: pAdapter %x, UnbindContext %x\n",
			pAdapter, UnbindContext));

	//
	//	Dereference the Adapter (should free structure)
	//
	ACQUIRE_ADAPTER_LOCK(pAdapter);
	rc = AtmLaneDereferenceAdapter(pAdapter, "openadapter");
	ASSERT(rc == 0);

	//
	//  If NDIS had requested us to Unbind, complete the
	//  request now.
	//
	if (UnbindContext != (NDIS_HANDLE)NULL)
	{
		NdisCompleteUnbindAdapter(
			UnbindContext,
			NDIS_STATUS_SUCCESS
			);
	}
	else
	{
		//
		//  We initiated the unbind from our Unload handler,
		//  which would have been waiting for us to complete.
		//  Wake up that thread now.
		//
		SIGNAL_BLOCK_STRUCT(&(pAtmLaneGlobalInfo->Block), NDIS_STATUS_SUCCESS);
	}

	TRACEOUT(CloseAdapterCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneResetCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status
)
/*++

Routine Description:

	This routine is called when the miniport indicates that a Reset
	operation has just completed. We ignore this event.

Arguments:

	ProtocolBindingContext	- Our context for this adapter binding, which
							  is a pointer to an ATMLANE Adapter structure.
	Status					- Status of the reset operation.

Return Value:

	None

--*/
{
	PATMLANE_ADAPTER			pAdapter;

	TRACEIN(ResetCompleteHandler);
	
	pAdapter = (PATMLANE_ADAPTER)ProtocolBindingContext;
	STRUCT_ASSERT(pAdapter, atmlane_adapter);

	DBGP((3, "Reset Complete on Adapter %x\n", pAdapter));

	TRACEOUT(ResetCompleteHandler);

	return;
}

VOID
AtmLaneRequestCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_STATUS					Status
)
/*++

Routine Description:

	This is called by NDIS when a previous call we made to NdisRequest() has
	completed. We would be blocked on our adapter structure, waiting for this
	to happen -- wake up the blocked thread.

Arguments:

	ProtocolBindingContext	- Pointer to our Adapter structure
	pNdisRequest			- The request that completed
	Status					- Status of the request.

Return Value:

	None

--*/
{
	PATMLANE_ADAPTER				pAdapter;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(RequestCompleteHandler);
	
	pAdapter = (PATMLANE_ADAPTER)ProtocolBindingContext;
	
	STRUCT_ASSERT(pAdapter, atmlane_adapter);

	SIGNAL_BLOCK_STRUCT(&(pAdapter->Block), Status);
	
	TRACEOUT(RequestCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneReceiveCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext
)
/*++

Routine Description:

	This is currently ignored.
	
Arguments:

	ProtocolBindingContext	- Our context for this adapter binding, which
							  is a pointer to an ATMLANE Adapter structure.

Return Value:

	None

--*/
{
	PATMLANE_ADAPTER				pAdapter;
	PATMLANE_ELAN					pElan;
	PLIST_ENTRY						Entry;

	TRACEIN(ReceiveCompleteHandler);
	
	TRACEOUT(ReceiveCompleteHandler);
	
	return;
}

VOID
AtmLaneStatusHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						pStatusBuffer,
	IN	UINT						StatusBufferSize
)
/*++

Routine Description:

	This routine is called when the miniport indicates an adapter-wide
	status change. We ignore this.

Arguments:

	<Ignored>

Return Value:

	None

--*/
{

	TRACEIN(StatusHandler);

	DBGP((3, "StatusHandler: ProtocolBindContext %x, Status %x\n",
			ProtocolBindingContext,
			GeneralStatus));

	TRACEOUT(StatusHandler);
			
	return;
}


VOID
AtmLaneStatusCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext
)
/*++

Routine Description:

	This routine is called when the miniport wants to tell us about
	completion of a status change (?). Ignore this.

Arguments:

	<Ignored>

Return Value:

	None

--*/
{
	TRACEIN(StatusCompleteHandler);


	DBGP((3, "StatusCompleteHandler: ProtocolBindingContext %x\n",
					ProtocolBindingContext));
					
	TRACEOUT(StatusCompleteHandler);

	return;
}

VOID
AtmLaneCoSendCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	This routine is called by NDIS when the ATM miniport is finished
	with a packet we had previously sent via NdisCoSendPackets.

	If packet originated within ATMLANE it is freed here.

	If packet originated in protocol above the virtual miniport
	the packet must be put back in it's original condition and
	returned to the protocol.
	
Arguments:

	Status					- Status of the NdisCoSendPackets.
	ProtocolVcContext		- Our context for the VC on which the packet was sent
							  (i.e. pointer to ATMLANE VC).
	pNdisPacket				- The packet whose "send" is being completed.

Return Value:

	None

--*/
{
	PATMLANE_VC				pVc;
	PATMLANE_ELAN			pElan;
	UINT					TotalLength;
	BOOLEAN					OwnerIsLane;
	PNDIS_BUFFER			pNdisBuffer;
	PNDIS_PACKET			pProtNdisPacket;
	ULONG					rc;
#if DEBUG_IRQL
	KIRQL					EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);
	
	TRACEIN(CoSendCompleteHandler);
	
	TRACELOGWRITE((&TraceLog, TL_COSENDCMPLTIN, pNdisPacket, Status));
	TRACELOGWRITEPKT((&TraceLog, pNdisPacket));

	pVc = (PATMLANE_VC)ProtocolVcContext;
	STRUCT_ASSERT(pVc, atmlane_vc)

	ACQUIRE_VC_LOCK(pVc);

	pElan = pVc->pElan;
	STRUCT_ASSERT(pElan, atmlane_elan);

	rc = AtmLaneDereferenceVc(pVc, "sendpkt");
	if (rc > 0)
	{
		pVc->OutstandingSends--;

		if ((pVc->OutstandingSends == 0) &&
			(IS_FLAG_SET(pVc->Flags,
						VC_CLOSE_STATE_MASK,
						VC_CLOSE_STATE_CLOSING)))
		{
			DBGP((1, "CoSendComplete: Vc %p, closing call\n", pVc));
			AtmLaneCloseCall(pVc);
			//
			//  VC lock is released above.
			//
		}
		else
		{
			RELEASE_VC_LOCK(pVc);
		}
	}

#if SENDLIST
	//
	//	Remove packet from send list if there
	//
	NdisAcquireSpinLock(&pElan->SendListLock);
	{
		PNDIS_PACKET 	*ppNextPkt;
		BOOLEAN			Found = FALSE;

		ppNextPkt = &(pElan->pSendList);
		
		while (*ppNextPkt != (PNDIS_PACKET)NULL)
		{
			if (*ppNextPkt == pNdisPacket)
			{
				*ppNextPkt = PSEND_RSVD(pNdisPacket)->pNextInSendList;
				Found = TRUE;
				break;
			}
			else
			{
				ppNextPkt = &(PSEND_RSVD((*ppNextPkt))->pNextInSendList);
			}
		}

		if (!Found)
		{
			DBGP((0, "CoSendCompleteHandler: Pkt %x Duplicate Completion\n", pNdisPacket));
			NdisReleaseSpinLock(&pElan->SendListLock);
			goto skipit;
		}
	}

	NdisReleaseSpinLock(&pElan->SendListLock);
#endif // SENDLIST

#if PROTECT_PACKETS
	//
	//	Lock the packet
	//
	ACQUIRE_SENDPACKET_LOCK(pNdisPacket);

	//
	//	Mark it as having been completed by miniport.
	//	Remember completion status.
	//
	ASSERT((PSEND_RSVD(pNdisPacket)->Flags & PACKET_RESERVED_COMPLETED) == 0);
	PSEND_RSVD(pNdisPacket)->Flags |= PACKET_RESERVED_COMPLETED;
	PSEND_RSVD(pNdisPacket)->CompletionStatus = Status;
	
	//
	//	Complete the packet only if the call to NdisCoSendPackets
	//	for this packet has returned.  Otherwise it will be completed
	//	when NdisCoSendPackets returns.
	//
	if ((PSEND_RSVD(pNdisPacket)->Flags & PACKET_RESERVED_COSENDRETURNED) != 0)
	{
		AtmLaneCompleteSendPacket(pElan, pNdisPacket, Status);
		//
		//	packet lock released in above
		//
	}
	else
	{
		RELEASE_SENDPACKET_LOCK(pNdisPacket);
	}
#else	// PROTECT_PACKETS
	AtmLaneCompleteSendPacket(pElan, pNdisPacket, Status);
#endif	// PROTECT_PACKETS

#if SENDLIST
skipit:
#endif

	TRACELOGWRITE((&TraceLog, TL_COSENDCMPLTOUT, pNdisPacket));
	
	TRACEOUT(CoSendCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneCoStatusHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						pStatusBuffer,
	IN	UINT						StatusBufferSize
)
/*++

Routine Description:

	This routine is called when the miniport indicates a status
	change, possibly on a VC. Ignore this.

Arguments:

	<Ignored>

Return Value:

	None

--*/
{
	TRACEIN(CoStatusHandler);

	DBGP((3, "CoStatusHandler: ProtocolBindingContext %x "
			"ProtocolVcContext %x, Status %x\n",
			ProtocolBindingContext,
			ProtocolVcContext,
			GeneralStatus));

	TRACEOUT(CoStatusHandler);

	return;
}

NDIS_STATUS
AtmLaneSendAdapterNdisRequest(
	IN	PATMLANE_ADAPTER			pAdapter,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
)
/*++

Routine Description:

	Send an NDIS (non-Connection Oriented) request to the Miniport. 
	Initialize the NDIS_REQUEST structure, link the supplied buffer to it,
	and send the request. If the request does not pend, we call our
	completion routine from here.

Arguments:

	pAdapter				- Pointer to our Adapter structure representing
							  the adapter to which the request is to be sent
	pNdisRequest			- Pointer to NDIS request structure
	RequestType				- Set/Query information
	Oid						- OID to be passed in the request
	pBuffer					- place for value(s)
	BufferLength			- length of above

Return Value:

	Status of the NdisRequest.

--*/
{
	NDIS_STATUS			Status;

	TRACEIN(SendAdapterNdisRequest);

	//
	//  Fill in the NDIS Request structure
	//
	pNdisRequest->RequestType = RequestType;
	if (RequestType == NdisRequestQueryInformation)
	{
		pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;
	}
	else
	{
		pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.SET_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
		pNdisRequest->DATA.SET_INFORMATION.BytesNeeded = 0;
	}

	INIT_BLOCK_STRUCT(&(pAdapter->Block));
	
	NdisRequest(
			&Status,
			pAdapter->NdisAdapterHandle,
			pNdisRequest);

	if (Status == NDIS_STATUS_PENDING)
	{
		Status = WAIT_ON_BLOCK_STRUCT(&(pAdapter->Block));
	}
		
	TRACEOUT(SendAdapterNdisRequest);

	return (Status);
}

VOID
AtmLaneGetAdapterInfo(
	IN	PATMLANE_ADAPTER			pAdapter
)
/*++

Routine Description:

	Query an adapter for hardware-specific information that we need:
		- burnt in hardware address (ESI part)
		- Max packet size
		- line rate

Arguments:

	pAdapter		- Pointer to ATMLANE adapter structure

Return Value:

	None

--*/
{
	NDIS_STATUS				Status;
	NDIS_REQUEST			NdisRequest;
	ULONG					Value;

	TRACEIN(GetAdapterInfo);

	//
	//  Initialize.
	//
	NdisZeroMemory(&pAdapter->MacAddress, sizeof(MAC_ADDRESS));

	//
	//  MAC Address:
	//
	Status = AtmLaneSendAdapterNdisRequest(
						pAdapter,
						&NdisRequest,
						NdisRequestQueryInformation,
						OID_ATM_HW_CURRENT_ADDRESS,
						(PVOID)&(pAdapter->MacAddress),
						sizeof(MAC_ADDRESS)
						);

	if (NDIS_STATUS_SUCCESS != Status)
	{
		DBGP((0, "GetAdapterInfo: OID_ATM_HW_CURRENT_ADDRESS failed\n"));
	}
	else
	{
		DBGP((1, "GetAdapterInfo: ATM card MacAddr %s\n", 
			MacAddrToString(&pAdapter->MacAddress)));
	}

						
	//
	//  Max Frame Size:
	//
	Status = AtmLaneSendAdapterNdisRequest(
						pAdapter,
						&NdisRequest,
						NdisRequestQueryInformation,
						OID_ATM_MAX_AAL5_PACKET_SIZE,
						(PVOID)&(pAdapter->MaxAAL5PacketSize),
						sizeof(ULONG)
						);

	if (NDIS_STATUS_SUCCESS != Status)
	{
		DBGP((0, "GetAdapterInfo: OID_ATM_MAX_AAL5_PACKET_SIZE failed\n"));

		//
		//  Use the default.
		//
		pAdapter->MaxAAL5PacketSize = ATMLANE_DEF_MAX_AAL5_PDU_SIZE;
	}

	if (pAdapter->MaxAAL5PacketSize > ATMLANE_DEF_MAX_AAL5_PDU_SIZE)
	{
		pAdapter->MaxAAL5PacketSize = ATMLANE_DEF_MAX_AAL5_PDU_SIZE;
	}
	DBGP((1, "GetAdapterInfo: MaxAAL5PacketSize %d\n", pAdapter->MaxAAL5PacketSize));


	//
	//  Link speed:
	//
	Status = AtmLaneSendAdapterNdisRequest(
						pAdapter,
						&NdisRequest,
						NdisRequestQueryInformation,
						OID_GEN_CO_LINK_SPEED,
						(PVOID)(&(pAdapter->LinkSpeed)),
						sizeof(NDIS_CO_LINK_SPEED)
						);

	if ((NDIS_STATUS_SUCCESS != Status) ||
		(0 == pAdapter->LinkSpeed.Inbound) ||
		(0 == pAdapter->LinkSpeed.Outbound))
	{
		DBGP((0, "GetAdapterInfo: OID_GEN_CO_LINK_SPEED failed\n"));

		//
		//  Default and assume data rate for 155.52Mbps SONET
		//
		pAdapter->LinkSpeed.Outbound = pAdapter->LinkSpeed.Inbound = ATM_USER_DATA_RATE_SONET_155;
	}
	DBGP((1, "GetAdapterInfo: Outbound Linkspeed %d\n", pAdapter->LinkSpeed.Outbound));
	DBGP((1, "GetAdapterInfo: Inbound  Linkspeed %d\n", pAdapter->LinkSpeed.Inbound));

	TRACEOUT(GetAdapterInfo);
	return;
}

UINT
AtmLaneCoReceivePacketHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	This is routine is called when a packet is received on a VC owned
	by the ATMLANE module.  It is dispatched based on the VC type.

Arguments:

	ProtocolBindingContext		- Actually a pointer to our Adapter structure
	ProtocolVcContext			- Actually a pointer to our VC structure
	pNdisPacket					- NDIS packet being received.

Return Value:

	0	- if packet is a LANE Control Packet or undesired data packet.
	1 	- if data packet indicated up to protocol.
	
--*/
{
	PATMLANE_ELAN			pElan;
	PATMLANE_VC				pVc;
	UINT					TotalLength;	// Total bytes in packet
	PNDIS_BUFFER			pNdisBuffer;	// Pointer to first buffer
	UINT					BufferLength;
	UINT					IsNonUnicast;	// Is this to a non-unicast destn MAC addr?
	BOOLEAN					RetainIt;		// Should we hang on to this packet?
	static ULONG			Count = 0;
#if DEBUG_IRQL
	KIRQL					EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);
	
	TRACEIN(CoReceivePacketHandler);
	
	pVc = (PATMLANE_VC)ProtocolVcContext;
	STRUCT_ASSERT(pVc, atmlane_vc);
	pElan = pVc->pElan;
	STRUCT_ASSERT(pElan, atmlane_elan);

	// if ((++Count % 10) == 0)
	//  	DBGP((0, "%d Packets Received\n", Count));

	DBGP((2, "CoReceivePacketHandler: pVc %x Pkt %x\n", pVc, pNdisPacket));

	TRACELOGWRITE((&TraceLog, 
				TL_CORECVPACKET,	
				pNdisPacket,
				pVc));

	//
	//	Initialize
	//
	RetainIt = FALSE;	// default to discarding received packet
	
	if (ELAN_STATE_OPERATIONAL == pElan->AdminState)
	{

		switch(pVc->LaneType)
		{
			case VC_LANE_TYPE_CONFIG_DIRECT:

				AtmLaneConfigureResponseHandler(pElan, pVc, pNdisPacket); 
	
				break;

			case VC_LANE_TYPE_CONTROL_DIRECT:
			case VC_LANE_TYPE_CONTROL_DISTRIBUTE:

				AtmLaneControlPacketHandler(pElan, pVc, pNdisPacket);
				
				break;

			case VC_LANE_TYPE_DATA_DIRECT:
			case VC_LANE_TYPE_MULTI_SEND:
			case VC_LANE_TYPE_MULTI_FORWARD:
				
				if (ELAN_STATE_OPERATIONAL == pElan->State)
				{
					RetainIt = AtmLaneDataPacketHandler(pElan, pVc, pNdisPacket);
				}
				else
				{
					DBGP((0, "%d Dropping Pkt %x cuz Elan %x state is %d\n",
							pElan->ElanNumber,
							pNdisPacket,
							pElan,
							pElan->State));
				}

				break;

			default:

				DBGP((0, "CoReceivePacketHandler: pVc %x Type UNKNOWN!\n", pVc));

				break;
		}
	}

	TRACEOUT(CoReceivePacketHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return (RetainIt);
}

VOID
AtmLaneUnloadProtocol(
	VOID
)
/*++

Routine Description:

	Unloads the ATMLANE protocol module. We unbind from all adapters,
	and deregister from NDIS as a protocol.

Arguments:

	None.

Return Value:

	None

--*/
{
	NDIS_STATUS			Status;
	PATMLANE_ADAPTER	pAdapter;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(UnloadProtocol);
	Status = NDIS_STATUS_SUCCESS;
	
	ACQUIRE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

	//
	//	Until adapter list is empty...
	//
	while (!IsListEmpty(&pAtmLaneGlobalInfo->AdapterList))
	{
		//
		// Keep grabbing the first one on the list.
		//	
		pAdapter = CONTAINING_RECORD(
			pAtmLaneGlobalInfo->AdapterList.Flink,
			ATMLANE_ADAPTER, 
			Link
			);
		
		STRUCT_ASSERT(pAdapter, atmlane_adapter);

		RELEASE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

		DBGP((3, "UnloadProtocol: will unbind adapter %x\n", pAdapter));

		INIT_BLOCK_STRUCT(&(pAtmLaneGlobalInfo->Block));

		//
		// unbind which should delete the adapter struct
		// and remove it from global list
		//
		AtmLaneUnbindAdapterHandler(
				&Status,
				(NDIS_HANDLE)pAdapter,
				(NDIS_HANDLE)NULL		// No UnbindContext ==> Don't complete NdisUnbind
				);

		if (NDIS_STATUS_PENDING == Status)
		{
			//
			//  Wait for the unbind to complete
			//
			(VOID)WAIT_ON_BLOCK_STRUCT(&(pAtmLaneGlobalInfo->Block));
		}

		ACQUIRE_GLOBAL_LOCK(pAtmLaneGlobalInfo);
	}

	RELEASE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

	FREE_GLOBAL_LOCK(pAtmLaneGlobalInfo);
	
	FREE_BLOCK_STRUCT(&(pAtmArpGlobalInfo->Block));

#if 0
	AuditShutdown();
#endif 

	if (pAtmLaneGlobalInfo->SpecialNdisDeviceHandle)
	{
		DBGP((0, "Deregistering device from UnloadProtocol\n"));
		Status = NdisMDeregisterDevice(pAtmLaneGlobalInfo->SpecialNdisDeviceHandle);
		pAtmLaneGlobalInfo->SpecialNdisDeviceHandle = NULL;
		ASSERT(NDIS_STATUS_SUCCESS == Status);
	}

	if (pAtmLaneGlobalInfo->NdisProtocolHandle)
	{
		DBGP((0, "UnloadProtocol: NdisDeregisterProtocol now, "
				"NdisProtocolHandle %x\n",
				pAtmLaneGlobalInfo->NdisProtocolHandle));

		NdisDeregisterProtocol(
			&Status,
			pAtmLaneGlobalInfo->NdisProtocolHandle
			);

		pAtmLaneGlobalInfo->NdisProtocolHandle = NULL;
	}

	ASSERT(NDIS_STATUS_SUCCESS == Status);

	TRACEIN(UnloadProtocol);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

//
// Dummy handlers so that a debug build won't complain
//
VOID
AtmLaneSendCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				Packet,
	IN	NDIS_STATUS					Status
	)
{
}

VOID
AtmLaneTransferDataCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				Packet,
	IN	NDIS_STATUS					Status,
	IN	UINT						BytesTransferred
	)
{
}

NDIS_STATUS
AtmLaneReceiveHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					MacReceiveContext,
	IN	PVOID						HeaderBuffer,
	IN	UINT						HeaderBufferSize,
	IN	PVOID						LookAheadBuffer,
	IN	UINT						LookaheadBufferSize,
	IN	UINT						PacketSize
	)
{
	return(NDIS_STATUS_FAILURE);
}



BOOLEAN
AtmLaneIsDeviceAlreadyBound(
	IN	PNDIS_STRING				pDeviceName
)
/*++

Routine Description:

	Check if we have already bound to a device (adapter).

Arguments:

	pDeviceName		- Points to device name to be checked.

Return Value:

	TRUE iff we already have an Adapter structure representing
	this device.

--*/
{
	PATMLANE_ADAPTER	pAdapter;
	BOOLEAN				bFound = FALSE;
	PLIST_ENTRY			pListEntry;

	ACQUIRE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

	for (pListEntry = pAtmLaneGlobalInfo->AdapterList.Flink;
		 pListEntry != &(pAtmLaneGlobalInfo->AdapterList);
		 pListEntry = pListEntry->Flink)
	{
		//
		// Keep grabbing the first one on the list.
		//	
		pAdapter = CONTAINING_RECORD(
			pListEntry,
			ATMLANE_ADAPTER, 
			Link
			);

		if ((pDeviceName->Length == pAdapter->DeviceName.Length) &&
			(memcmp(pDeviceName->Buffer,
						pAdapter->DeviceName.Buffer,
						pDeviceName->Length) == 0))
		{
			bFound = TRUE;
			break;
		}
	}

	RELEASE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

	return (bFound);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\debug.h ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	debug.h

Abstract:

	This file contains debugging support declarations.

Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:

--*/

#ifndef __ATMLANE_DEBUG_H
#define __ATMLANE_DEBUG_H

#if DBG

#define DBG_OUTBUF_SIZE 128

extern ULONG 		DbgVerbosity;
extern ULONG 		DbgLogSize;

#if	DBG_TRACE
extern TRACELOG		TraceLog;
extern PUCHAR		pTraceLogSpace;
#endif

struct _string_table {
	PUCHAR string;
	ULONG value;
	};

extern struct _string_table oid_string_table[];

extern struct _string_table irp_string_table[];

#define DBGP(x) DbgOut x

extern
VOID
DbgOut(ULONG Level, PUCHAR Message, ...);

extern
PUCHAR
UnicodeToString(PUNICODE_STRING unicodeString);

extern
PUCHAR
MacAddrToString(PVOID In);

extern
PUCHAR
AtmAddrToString(PVOID In);

extern
PUCHAR
OidToString(ULONG Oid);

extern
PUCHAR
IrpToString(ULONG Irp);

VOID
DbgPrintHexDump(
	IN	ULONG			Level,
	IN	PUCHAR			pBuffer,
	IN	ULONG			Length
);

#define STRUCT_ASSERT(s, t)												\
		if ((s)->t##_sig != t##_signature) 								\
		{																\
			DbgPrint("Structure assertion failure at %p for type " #t 	\
					   " in file %s, line %d\n", s, __FILE__, __LINE__);\
			DbgBreakPoint();											\
		}
		
#if	DBG_TRACE

#define TRACELOGWRITE(x) TraceLogWrite x
#define TRACELOGWRITEPKT(x) TraceLogWritePkt x

extern
VOID
TraceLogWritePkt(
	IN	PTRACELOG		pTraceLog,
	IN	PNDIS_PACKET	pNdisPacket
);

#else

#define TRACELOGWRITE(x)

#define TRACELOGWRITEPKT(x)
#endif

#if MYASSERT

#undef ASSERT

#define ASSERT( exp ) \
    if (!(exp)) \
    { \
    	DbgPrint("Assertion Failed ("#exp") in file %s line %d\n", __FILE__, __LINE__); \
    	DbgBreakPoint(); \
	}
	
#endif


#else

#define DBGP(x)

#define MacAddrToString(x)

#define AtmAddrToString(x)

#define OidToString(x)

#define DbgPrintHexDump(x)

#define STRUCT_ASSERT(s, t)

#define TRACELOGWRITE(x)

#define TRACELOGWRITEPKT(x)

#endif


#ifdef TRACE

#define TRACEIN(x)  DBGP((5, "--> "#x"\n"))
#define TRACEOUT(x) DBGP((5, "<-- "#x"\n"))

#else

#define TRACEIN(x)  {}
#define TRACEOUT(x)	{}

#endif


#if DEBUG_IRQL

#define GET_ENTRY_IRQL(_Irql)			\
			_Irql = KeGetCurrentIrql()
			
#define CHECK_EXIT_IRQL(_EntryIrql)											\
		{																	\
			KIRQL _ExitIrql;												\
			_ExitIrql = KeGetCurrentIrql();									\
			if (_ExitIrql != _EntryIrql)									\
			{																\
				DbgPrint("File %s, Line %d, Exit IRQ %d != Entry IRQ %d\n",	\
						__FILE__, __LINE__, _ExitIrql, _EntryIrql);			\
				DbgBreakPoint();											\
			}																\
		}
#else

#define GET_ENTRY_IRQL(x)
#define CHECK_EXIT_IRQL(x)

#endif // DEBUG_IRQL


#if DEBUG_SPIN_LOCK

#define LOCK_FILE_NAME_LEN		48

typedef struct _ATMLANE_LOCK
{
	ULONG					Signature;
	ULONG					IsAcquired;
	PKTHREAD				OwnerThread;
	UCHAR					TouchedByFileName[LOCK_FILE_NAME_LEN];
	ULONG					TouchedInLineNumber;
	NDIS_SPIN_LOCK			NdisLock;
} ATMLANE_LOCK, *PATMLANE_LOCK;

#define ATMLANE_LOCK_SIG	'KCOL'

extern ULONG				SpinLockInitDone;
extern NDIS_SPIN_LOCK		LockLock;

extern
VOID
AtmLaneAllocateSpinLock(
    IN  PATMLANE_LOCK       pLock,
    IN	PUCHAR				String,
    IN  PUCHAR              FileName,
    IN  ULONG               LineNumber
);

extern
VOID
AtmLaneAcquireSpinLock(
    IN  PATMLANE_LOCK		pLock,
    IN	PUCHAR				String,
    IN  PUCHAR              FileName,
    IN  ULONG               LineNumber
);

extern
VOID
AtmLaneReleaseSpinLock(
    IN  PATMLANE_LOCK       pLock,
    IN	PUCHAR				String,
    IN  PUCHAR              FileName,
    IN  ULONG               LineNumber
);

extern
VOID
AtmLaneFreeSpinLock(
	IN	PATMLANE_LOCK		pLock,
	IN	PUCHAR				String,
	IN	PUCHAR				FileName,
	IN	ULONG				LineNumber
);

#else

#define ATMLANE_LOCK	NDIS_SPIN_LOCK
#define PATMLANE_LOCK	PNDIS_SPIN_LOCK

#endif	// DEBUG_SPIN_LOCK

#endif  //  __ATMLANE_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\callmgr.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	callmgr.c

Abstract:

	Call Manager interface routines.
	
Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:

--*/


#include <precomp.h>
#pragma	hdrstop

//
//  Rounded-off size of generic Q.2931 IE header
//

#define SIZEOF_Q2931_IE	 			ROUND_OFF(sizeof(Q2931_IE))
#define SIZEOF_AAL_PARAMETERS_IE	ROUND_OFF(sizeof(AAL_PARAMETERS_IE))
#define SIZEOF_ATM_TRAFFIC_DESCR_IE	ROUND_OFF(sizeof(ATM_TRAFFIC_DESCRIPTOR_IE))
#define SIZEOF_ATM_BBC_IE			ROUND_OFF(sizeof(ATM_BROADBAND_BEARER_CAPABILITY_IE))
#define SIZEOF_ATM_BLLI_IE			ROUND_OFF(sizeof(ATM_BLLI_IE))
#define SIZEOF_ATM_QOS_IE			ROUND_OFF(sizeof(ATM_QOS_CLASS_IE))


//
//  Total space required for Information Elements in an outgoing call.
//
#define ATMLANE_CALL_IE_SPACE (	\
						SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE +	\
						SIZEOF_Q2931_IE + SIZEOF_ATM_TRAFFIC_DESCR_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_BBC_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_QOS_IE )

//
// Size of Call Manager Parameters Block
//
#define ATMLANE_Q2931_CALLMGR_PARAMETERS_SIZE	 	\
	sizeof(Q2931_CALLMGR_PARAMETERS) - 1 +			\
	sizeof(Q2931_IE) - 1 +							\
	sizeof(AAL_PARAMETERS_IE) +						\
	sizeof(Q2931_IE) - 1 +							\
	sizeof(ATM_TRAFFIC_DESCRIPTOR_IE) +				\
	sizeof(Q2931_IE) - 1 +							\
	sizeof(ATM_BROADBAND_BEARER_CAPABILITY_IE) +	\
	sizeof(Q2931_IE) - 1 +							\
	sizeof(ATM_BLLI_IE) +							\
	sizeof(Q2931_IE) - 1 +							\
	sizeof(ATM_QOS_CLASS_IE)					

//
//	ATMLANE Call Manager Parameters Block
//
typedef struct _ATMLANE_Q2931_CALLMGR_PARAMETERS
{
	UCHAR Q2931CallMgrParameters[ATMLANE_Q2931_CALLMGR_PARAMETERS_SIZE];
}
	ATMLANE_Q2931_CALLMGR_PARAMETERS,
	*PATMLANE_Q2931_CALLMGR_PARAMETERS;




VOID
AtmLaneAfRegisterNotifyHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PCO_ADDRESS_FAMILY			pAddressFamily
)
/*++

Routine Description:

	This routine is called by NDIS when a Call manager registers its support
	for an Address Family over an adapter. If this is the Address Family we
	are interested in (UNI 3.1), then we bootstrap the Elans for this adapter.

Arguments:

	ProtocolBindingContext	- our context passed in NdisOpenAdapter, which is
							  a pointer to our Adapter structure.
	pAddressFamily			- points to a structure describing the Address Family
							  being registered by a Call Manager.

Return Value:

	None

--*/
{
	PATMLANE_ADAPTER				pAdapter;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(AfRegisterNotifyHandler);
	
	do
	{
		DBGP((1, "AfRegisterNotifyHandler: AF %x MajVer %x MinVer %x\n",
				pAddressFamily->AddressFamily,
				pAddressFamily->MajorVersion,
				pAddressFamily->MinorVersion));
	
		//
		//  Only interested in UNI Version 3.1
		//
		if ((pAddressFamily->AddressFamily != CO_ADDRESS_FAMILY_Q2931) ||
			(pAddressFamily->MajorVersion != 3) ||
			(pAddressFamily->MinorVersion != 1))
		{
			DBGP((2, "AfRegisterNotifyHandler: ignoring AF %x MajVer %x MinVer %x\n",
				pAddressFamily->AddressFamily,
				pAddressFamily->MajorVersion,
				pAddressFamily->MinorVersion));
			break;
		}

		pAdapter = (PATMLANE_ADAPTER)ProtocolBindingContext;
		STRUCT_ASSERT(pAdapter, atmlane_adapter);

		ACQUIRE_ADAPTER_LOCK(pAdapter);
		pAdapter->Flags |= ADAPTER_FLAGS_AF_NOTIFIED;

		while (pAdapter->Flags & ADAPTER_FLAGS_OPEN_IN_PROGRESS)
		{
			RELEASE_ADAPTER_LOCK(pAdapter);
			DBGP((0, "AfRegisterNotifyHandler: Adapter %p/%x still opening\n",
					pAdapter, pAdapter->Flags));
			(VOID)WAIT_ON_BLOCK_STRUCT(&pAdapter->OpenBlock);
			ACQUIRE_ADAPTER_LOCK(pAdapter);
		}

		RELEASE_ADAPTER_LOCK(pAdapter);

        //
        //  Bootstrap the ELANs configured on this adapter
        //
        AtmLaneBootStrapElans(pAdapter);


	} while (FALSE);

	TRACEOUT(AfFRegisterNotifyHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}


NDIS_STATUS
AtmLaneOpenCallMgr(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Start access to the Call Manager on an Elan,
	by doing the following:
		- Open Address Family

	For all of these, we wait for completion in case they pend.

	It is assumed that the Elan structure is locked.

Arguments:

	pElan	- pointer to the ATMLANE Elan

Return Value:

	NDIS status.

--*/
{
	PCO_ADDRESS_FAMILY			pAddressFamily;
	NDIS_STATUS					Status;
	ULONG						RequestSize;
	NDIS_CLIENT_CHARACTERISTICS	AtmLaneClientChars;

	TRACEIN(OpenCallMgr);


	pAddressFamily = (PCO_ADDRESS_FAMILY)NULL;
	Status = NDIS_STATUS_SUCCESS;

	do {

		//
		//  Allocate address family struct.
		//
		ALLOC_MEM(&pAddressFamily, sizeof(CO_ADDRESS_FAMILY));

		if ((PCO_ADDRESS_FAMILY)NULL == pAddressFamily)
		{
			DBGP((0, "OpenCallMgr: Alloc address family struct failed\n"));
			break;
		}

		//
		//  Init the address family struct.
		//
		NdisZeroMemory(pAddressFamily, sizeof(CO_ADDRESS_FAMILY));
		pAddressFamily->AddressFamily = CO_ADDRESS_FAMILY_Q2931;
		pAddressFamily->MajorVersion = 3;
		pAddressFamily->MinorVersion = 1;

		//
		//	Init the call manager client characteristics.
		//
		NdisZeroMemory(&AtmLaneClientChars, sizeof(AtmLaneClientChars));
		AtmLaneClientChars.MajorVersion = 5;
		AtmLaneClientChars.MinorVersion = 0;
		AtmLaneClientChars.ClCreateVcHandler = AtmLaneCreateVcHandler;
		AtmLaneClientChars.ClDeleteVcHandler = AtmLaneDeleteVcHandler;
		AtmLaneClientChars.ClRequestHandler = AtmLaneCoRequestHandler;
		AtmLaneClientChars.ClRequestCompleteHandler = AtmLaneCoRequestCompleteHandler;
		AtmLaneClientChars.ClOpenAfCompleteHandler = AtmLaneOpenAfCompleteHandler;
		AtmLaneClientChars.ClCloseAfCompleteHandler = AtmLaneCloseAfCompleteHandler;
		AtmLaneClientChars.ClRegisterSapCompleteHandler = AtmLaneRegisterSapCompleteHandler;
		AtmLaneClientChars.ClDeregisterSapCompleteHandler = AtmLaneDeregisterSapCompleteHandler;
		AtmLaneClientChars.ClMakeCallCompleteHandler = AtmLaneMakeCallCompleteHandler;
		AtmLaneClientChars.ClModifyCallQoSCompleteHandler = AtmLaneModifyQosCompleteHandler;
		AtmLaneClientChars.ClCloseCallCompleteHandler = AtmLaneCloseCallCompleteHandler;
		AtmLaneClientChars.ClAddPartyCompleteHandler = AtmLaneAddPartyCompleteHandler;
		AtmLaneClientChars.ClDropPartyCompleteHandler = AtmLaneDropPartyCompleteHandler;
		AtmLaneClientChars.ClIncomingCallHandler = AtmLaneIncomingCallHandler;
		AtmLaneClientChars.ClIncomingCallQoSChangeHandler = (CL_INCOMING_CALL_QOS_CHANGE_HANDLER)NULL;
		AtmLaneClientChars.ClIncomingCloseCallHandler = AtmLaneIncomingCloseHandler;
		AtmLaneClientChars.ClIncomingDropPartyHandler = AtmLaneIncomingDropPartyHandler;
		AtmLaneClientChars.ClCallConnectedHandler = AtmLaneCallConnectedHandler;

		//
		//	Open the call manager
		//
		INIT_BLOCK_STRUCT(&pElan->Block);
		Status = NdisClOpenAddressFamily(
					pElan->NdisAdapterHandle,
					pAddressFamily,
					pElan,
					&AtmLaneClientChars,
					sizeof(AtmLaneClientChars),
					&pElan->NdisAfHandle);
		if (NDIS_STATUS_PENDING == Status)
		{
			//
			//  Wait for completion
			//
			Status = WAIT_ON_BLOCK_STRUCT(&pElan->Block);
		}
		if (NDIS_STATUS_SUCCESS != Status)
		{
			DBGP((0, "%d OpenCallMgr: OpenAddressFamily failed, status %x, Elan %x\n",
				pElan->ElanNumber, Status, pElan));
			break;
		}
		break;
	}
	while (FALSE);

	//
	//	clean up.

	if (pAddressFamily != (PCO_ADDRESS_FAMILY)NULL)
	{
		NdisFreeMemory(pAddressFamily,0,0);
	}

	TRACEOUT(OpenCallMgr);
	
	return (Status);
}

VOID
AtmLaneOpenAfCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisAfHandle
)
/*++

Routine Description:

	This handler is called to indicate completion of a previous call
	to NdisClOpenAddressFamily. We would have blocked the thread that
	called this. Wake it up now.

	If open is successful, store NdisAfHandle in Adapter.

	We don't need to acquire locks here because the thread that called
	OpenAddressFamily would have blocked with a lock acquired.

Arguments:

	Status					- Status of the Open AF
	ProtocolAfContext		- Pointer to our Adapter structure
	NdisAfHandle			- NDIS handle to the AF association

Return Value:

	None

--*/
{
	PATMLANE_ELAN			pElan;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(OpenAfCompleteHandler);

	pElan = (PATMLANE_ELAN)ProtocolAfContext;

	STRUCT_ASSERT(pElan, atmlane_elan);

	if (NDIS_STATUS_SUCCESS == Status)
	{
		pElan->NdisAfHandle = NdisAfHandle;
	}

	//
	//  Store status, Wake up the blocked thread.
	//
	SIGNAL_BLOCK_STRUCT(&pElan->Block, Status);

	TRACEOUT(OpenAfCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneCloseAfCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext
)
/*++

Routine Description:

	This handler is called to indicate completion of a previous call
	to NdisClCloseAddressFamily. We would have blocked the thread that
	called this. Wake it up now.

	We don't need to acquire locks here because the thread that called
	CloseAddressFamily would have blocked with a lock acquired.

Arguments:

	Status					- Status of the Open AF
	ProtocolAfContext		- Pointer to our Adapter structure

Return Value:

	None

--*/
{
	PATMLANE_ELAN		pElan;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);


	TRACEIN(CloseAfCompleteHandler);

	pElan = (PATMLANE_ELAN)ProtocolAfContext;

	STRUCT_ASSERT(pElan, atmlane_elan);
	DBGP((0, "%d CloseAF complete on Elan %x sts %x\n", pElan->ElanNumber, pElan, Status));

	AtmLaneContinueShutdownElan(pElan);
	
	TRACEOUT(CloseAfCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneRegisterSaps(
	IN	PATMLANE_ELAN			pElan	LOCKIN	NOLOCKOUT
)
/*++

Routine Description:

	Register the LANE SAPs for the given Elan.

	We just issue the NdisClRegisterSap requests for all SAPs.
	We don't wait for completion.

Arguments:

	pElan			- Pointer to ATMLANE Elan.

Return Value:

	None

--*/
{
	PATMLANE_SAP				pAtmLaneLesSap;
	PATMLANE_SAP				pAtmLaneBusSap;
	PATMLANE_SAP				pAtmLaneDataSap;
	PATM_ADDRESS				pAtmAddress;
	PATM_SAP					pAtmSap;
	NDIS_STATUS					Status;
	ULONG						rc;				// Ref count on Elan
	ATM_BLLI_IE UNALIGNED *		pBlli;
	ATM_BHLI_IE UNALIGNED *		pBhli;
	

	TRACEIN(RegisterSaps);

	if (pElan->AdminState != ELAN_STATE_OPERATIONAL)
	{
		RELEASE_ELAN_LOCK(pElan);
		return;
	}

	//
	//	Initialize SAPs
	// 
	pElan->SapsRegistered = 0;
	pAtmLaneLesSap = &pElan->LesSap;
	pAtmLaneBusSap = &pElan->BusSap;
	pAtmLaneDataSap = &pElan->DataSap;
	
	//
	//	First init the LES control distribute connection SAP
	//
	SET_FLAG(pAtmLaneLesSap->Flags,
			SAP_REG_STATE_MASK,
			SAP_REG_STATE_REGISTERING);
	pAtmLaneLesSap->LaneType = VC_LANE_TYPE_CONTROL_DISTRIBUTE;
	pAtmLaneLesSap->pElan = pElan;
	pAtmLaneLesSap->Flags = SAP_REG_STATE_IDLE;
	pAtmLaneLesSap->pInfo->SapType = SAP_TYPE_NSAP;
	pAtmLaneLesSap->pInfo->SapLength = sizeof(ATM_SAP)+sizeof(ATM_ADDRESS);
	pAtmSap = (PATM_SAP)&pAtmLaneLesSap->pInfo->Sap;
	pBhli = (ATM_BHLI_IE UNALIGNED *)&pAtmSap->Bhli;
	pBlli = (ATM_BLLI_IE UNALIGNED *)&pAtmSap->Blli;

	pBhli->HighLayerInfoType = SAP_FIELD_ABSENT;

	pBlli->Layer2Protocol = SAP_FIELD_ABSENT;
	pBlli->Layer3Protocol = BLLI_L3_ISO_TR9577;
	pBlli->Layer3IPI = 		BLLI_L3_IPI_SNAP;
	pBlli->SnapId[0] = 0x00;
	pBlli->SnapId[1] = 0xa0;
	pBlli->SnapId[2] = 0x3e;
	pBlli->SnapId[3] = 0x00;
	pBlli->SnapId[4] = 0x01;		// control distribute
	
	pAtmSap->NumberOfAddresses = 1;

	pAtmAddress = (PATM_ADDRESS)pAtmSap->Addresses;
	pAtmAddress->AddressType = ATM_NSAP;
	pAtmAddress->NumberOfDigits = ATM_ADDRESS_LENGTH;
	NdisMoveMemory(
		pAtmAddress->Address,
		pElan->AtmAddress.Address,
		ATM_ADDRESS_LENGTH);

	//
	//	Now init the BUS mulicast forward connection SAP
	//
	SET_FLAG(pAtmLaneBusSap->Flags,
			SAP_REG_STATE_MASK,
			SAP_REG_STATE_REGISTERING);
	pAtmLaneBusSap->LaneType = VC_LANE_TYPE_MULTI_FORWARD;
	pAtmLaneBusSap->pElan = pElan;
	pAtmLaneBusSap->Flags = SAP_REG_STATE_IDLE;
	pAtmLaneBusSap->pInfo->SapType = SAP_TYPE_NSAP;
	pAtmLaneBusSap->pInfo->SapLength = sizeof(ATM_SAP)+sizeof(ATM_ADDRESS);
	pAtmSap = (PATM_SAP)&pAtmLaneBusSap->pInfo->Sap;
	pBhli = (ATM_BHLI_IE UNALIGNED *)&pAtmSap->Bhli;
	pBlli = (ATM_BLLI_IE UNALIGNED *)&pAtmSap->Blli;

	pBhli->HighLayerInfoType = SAP_FIELD_ABSENT;

	pBlli->Layer2Protocol = SAP_FIELD_ABSENT;
	pBlli->Layer3Protocol = BLLI_L3_ISO_TR9577;
	pBlli->Layer3IPI = 		BLLI_L3_IPI_SNAP;
	pBlli->SnapId[0] = 0x00;
	pBlli->SnapId[1] = 0xa0;
	pBlli->SnapId[2] = 0x3e;
	pBlli->SnapId[3] = 0x00;
	if (pElan->LanType == LANE_LANTYPE_ETH)
	{
		pBlli->SnapId[4] = 0x04;		// Ethernet/802.3 Multicast Forward
	}
	else
	{
		pBlli->SnapId[4] = 0x05;		// 802.5 Multicast Forward
	}
	
	pAtmSap->NumberOfAddresses = 1;

	pAtmAddress = (PATM_ADDRESS)pAtmSap->Addresses;
	pAtmAddress->AddressType = ATM_NSAP;
	pAtmAddress->NumberOfDigits = ATM_ADDRESS_LENGTH;
	NdisMoveMemory(
		pAtmAddress->Address,
		pElan->AtmAddress.Address,
		ATM_ADDRESS_LENGTH);
	
	//
	//	Now init the DATA direct connection SAP
	//
	SET_FLAG(pAtmLaneDataSap->Flags,
			SAP_REG_STATE_MASK,
			SAP_REG_STATE_REGISTERING);
	pAtmLaneDataSap->LaneType = VC_LANE_TYPE_DATA_DIRECT;
	pAtmLaneDataSap->pElan = pElan;
	pAtmLaneDataSap->Flags = SAP_REG_STATE_IDLE;
	pAtmLaneDataSap->pInfo->SapType = SAP_TYPE_NSAP;
	pAtmLaneDataSap->pInfo->SapLength = sizeof(ATM_SAP)+sizeof(ATM_ADDRESS);
	pAtmSap = (PATM_SAP)&pAtmLaneDataSap->pInfo->Sap;
	pBhli = (ATM_BHLI_IE UNALIGNED *)&pAtmSap->Bhli;
	pBlli = (ATM_BLLI_IE UNALIGNED *)&pAtmSap->Blli;

	pBhli->HighLayerInfoType = SAP_FIELD_ABSENT;

	pBlli->Layer2Protocol = SAP_FIELD_ABSENT;
	pBlli->Layer3Protocol = BLLI_L3_ISO_TR9577;
	pBlli->Layer3IPI = 		BLLI_L3_IPI_SNAP;
	pBlli->SnapId[0] = 0x00;
	pBlli->SnapId[1] = 0xa0;
	pBlli->SnapId[2] = 0x3e;
	pBlli->SnapId[3] = 0x00;
	if (pElan->LanType == LANE_LANTYPE_ETH)
	{
		pBlli->SnapId[4] = 0x02;		// Ethernet/802.3 Data Direct
	}
	else
	{
		pBlli->SnapId[4] = 0x03;		// 802.5 Data Direct
	}
	
	pAtmSap->NumberOfAddresses = 1;

	pAtmAddress = (PATM_ADDRESS)pAtmSap->Addresses;
	pAtmAddress->AddressType = ATM_NSAP;
	pAtmAddress->NumberOfDigits = ATM_ADDRESS_LENGTH;
	NdisMoveMemory(
		pAtmAddress->Address,
		pElan->AtmAddress.Address,
		ATM_ADDRESS_LENGTH);

	//
	//  Make sure that the Elan doesn't go away.
	//
	AtmLaneReferenceElan(pElan, "tempregsaps");

	RELEASE_ELAN_LOCK(pElan);

	ASSERT(pElan->NdisAfHandle != NULL);

	//
	//	Register the LES Sap
	//
	Status = NdisClRegisterSap(
					pElan->NdisAfHandle,
					(NDIS_HANDLE)pAtmLaneLesSap,	// ProtocolSapContext
					pAtmLaneLesSap->pInfo,
					&(pAtmLaneLesSap->NdisSapHandle)
					);

	if (Status != NDIS_STATUS_PENDING)
	{
		AtmLaneRegisterSapCompleteHandler(
					Status,
					(NDIS_HANDLE)pAtmLaneLesSap,
					pAtmLaneLesSap->pInfo,
					pAtmLaneLesSap->NdisSapHandle
					);
	}

	ASSERT(pElan->NdisAfHandle != NULL);

	//
	//	Register the BUS Sap
	//
	Status = NdisClRegisterSap(
					pElan->NdisAfHandle,
					(NDIS_HANDLE)pAtmLaneBusSap,	// ProtocolSapContext
					pAtmLaneBusSap->pInfo,
					&(pAtmLaneBusSap->NdisSapHandle)
					);

	if (Status != NDIS_STATUS_PENDING)
	{
		AtmLaneRegisterSapCompleteHandler(
					Status,
					(NDIS_HANDLE)pAtmLaneBusSap,
					pAtmLaneBusSap->pInfo,
					pAtmLaneBusSap->NdisSapHandle
					);
	}

	ASSERT(pElan->NdisAfHandle != NULL);

	//
	//	Register the DATA Sap
	//
	Status = NdisClRegisterSap(
					pElan->NdisAfHandle,
					(NDIS_HANDLE)pAtmLaneDataSap,	// ProtocolSapContext
					pAtmLaneDataSap->pInfo,
					&(pAtmLaneDataSap->NdisSapHandle)
					);

	if (Status != NDIS_STATUS_PENDING)
	{
		AtmLaneRegisterSapCompleteHandler(
					Status,
					(NDIS_HANDLE)pAtmLaneDataSap,
					pAtmLaneDataSap->pInfo,
					pAtmLaneDataSap->NdisSapHandle
					);
	}

	//
	//  Remove the reference we added earlier to the Elan.
	//
	ACQUIRE_ELAN_LOCK(pElan);
	rc = AtmLaneDereferenceElan(pElan, "tempregsaps");
	if (rc > 0)
	{
		RELEASE_ELAN_LOCK(pElan);
	}
	//
	//  else the Elan is gone!

	TRACEOUT(RegisterSaps);

	return;
}

VOID
AtmLaneDeregisterSaps(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Deregister all SAPs on an ATMLANE Elan. We issue NdisClDeregisterSap
	calls on all SAPs we have currently registered.

Arguments:

	pElan			- Pointer to ATMLANE Elan

Return Value:

	None

--*/
{
	NDIS_HANDLE					NdisSapHandle;
	ULONG						rc;				// Reference count on Interface
	PATMLANE_SAP				pAtmLaneSap;
	NDIS_STATUS					Status;

	TRACEIN(DeregisterSaps);

	ACQUIRE_ELAN_LOCK(pElan);

	//
	//  Make sure the Elan structure doesn't go away.
	//
	AtmLaneReferenceElan(pElan, "tempDeregSap");
	RELEASE_ELAN_LOCK(pElan);

	//
	//  First the LES SAP
	//
	pAtmLaneSap = &(pElan->LesSap);

	NdisSapHandle = pAtmLaneSap->NdisSapHandle;
	if (NdisSapHandle != NULL)
	{
		Status = NdisClDeregisterSap(NdisSapHandle);
		if (Status != NDIS_STATUS_PENDING)
		{
			AtmLaneDeregisterSapCompleteHandler(
					Status,
					(NDIS_HANDLE)pAtmLaneSap
					);
		}
	}
	
	//
	//  Then the BUS SAP
	//
	pAtmLaneSap = &(pElan->BusSap);

	NdisSapHandle = pAtmLaneSap->NdisSapHandle;
	if (NdisSapHandle != NULL)
	{
		Status = NdisClDeregisterSap(NdisSapHandle);
		if (Status != NDIS_STATUS_PENDING)
		{
			AtmLaneDeregisterSapCompleteHandler(
					Status,
					(NDIS_HANDLE)pAtmLaneSap
					);
		}
	}

	//
	//  And finally the Data SAP
	//
	pAtmLaneSap = &(pElan->DataSap);

	NdisSapHandle = pAtmLaneSap->NdisSapHandle;
	if (NdisSapHandle != NULL)
	{
		Status = NdisClDeregisterSap(NdisSapHandle);
		if (Status != NDIS_STATUS_PENDING)
		{
			AtmLaneDeregisterSapCompleteHandler(
					Status,
					(NDIS_HANDLE)pAtmLaneSap
					);
		}
	}

	//
	//  Remove the reference we added earlier to the Interface.
	//
	ACQUIRE_ELAN_LOCK(pElan);
	rc = AtmLaneDereferenceElan(pElan, "tempDeregSap");
	if (rc > 0)
	{
		RELEASE_ELAN_LOCK(pElan);
	}
	//
	//  else the interface is gone
	//

	TRACEOUT(DeregisterSaps);
	return;
}

NDIS_STATUS
AtmLaneMakeCall(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_ATM_ENTRY			pAtmEntry	LOCKIN NOLOCKOUT,
	IN	BOOLEAN						UsePvc
)
/*++

Routine Description:

	Place a call to the given destination. 

	NOTE: The caller is assumed to hold a lock for the ATM Entry,
	which will be released here. The reason we do it this way is so that
	nobody else can come in and try to make another call (of the same kind)
	to this ATM Entry -- once we get a new VC into the ATM Entry's list,
	we can release its lock.

	SIDE EFFECT: If the NDIS call doesn't pend, then we call our
	MakeCall completion handler from here, and return NDIS_STATUS_PENDING
	to the caller.


Arguments:

	pElan				- the Elan originating this call
	pAtmEntry			- Pointer to ATM Address Entry corresponding to the
						  called address.

Return Value:

	If there is an immediate failure (e.g. allocation failure), we return
	appropriate NDIS_STATUS value denoting that failure.

	If we made it to the call to NdisClMakeCall(), we return NDIS_STATUS_PENDING.
	However, if NDIS returns other than NDIS_STATUS_PENDING, we'd also
	call our MakeCall completion handler.

--*/
{
	PATMLANE_VC										pVc;
	NDIS_STATUS										Status;
	NDIS_HANDLE										NdisVcHandle;
	NDIS_HANDLE										NdisAfHandle;
	NDIS_HANDLE										ProtocolVcContext;	
	PCO_CALL_PARAMETERS								pCallParameters;
	PCO_CALL_MANAGER_PARAMETERS						pCallMgrParameters;
	PQ2931_CALLMGR_PARAMETERS						pAtmCallMgrParameters;
	PCO_MEDIA_PARAMETERS							pMediaParameters;
	PATM_MEDIA_PARAMETERS							pAtmMediaParameters;
	Q2931_IE UNALIGNED *							pIe;
	AAL_PARAMETERS_IE UNALIGNED *					pAalIe;
	ATM_TRAFFIC_DESCRIPTOR_IE UNALIGNED *			pTrafficDescriptor;
	ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *	pBbc;
	ATM_BLLI_IE UNALIGNED *							pBlli;
	ATM_QOS_CLASS_IE UNALIGNED *					pQos;
	
	ULONG											RequestSize;
	BOOLEAN											bIsLockHeld;
	
	TRACEIN(MakeCall);

	STRUCT_ASSERT(pElan, atmlane_elan);
	STRUCT_ASSERT(pAtmEntry, atmlane_atm);

	bIsLockHeld = TRUE;	// do we hold the ATM Entry lock?

	do
	{
		if (ELAN_STATE_OPERATIONAL != pElan->AdminState)
		{
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		if (!UsePvc)
		{
			// 
			// 	Default case is to make an server/peer SVC call.
			//	Compute size of the SVC call parameters.
			//
			RequestSize = 	sizeof(CO_CALL_PARAMETERS) +
						  	sizeof(CO_CALL_MANAGER_PARAMETERS) +
							sizeof(Q2931_CALLMGR_PARAMETERS) +
							ATMLANE_CALL_IE_SPACE;
		}
		else
		{
			//
			//	This is the LECS PVC (vpi 0, vci 17).
			//	Compute size of the PVC call parameters.
			//		
			RequestSize =	sizeof(CO_CALL_PARAMETERS) +
						  	sizeof(CO_CALL_MANAGER_PARAMETERS) +
							sizeof(CO_MEDIA_PARAMETERS) +
							sizeof(ATM_MEDIA_PARAMETERS);
		}

		ALLOC_MEM(&pCallParameters, RequestSize);
		if ((PCO_CALL_PARAMETERS)NULL == pCallParameters)
		{
			DBGP((0, "MakeCall: callparams alloc (%d) failed\n", RequestSize));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Allocate a VC structure for the call
		//
		pVc = AtmLaneAllocateVc(pElan);

		if (NULL_PATMLANE_VC == pVc)
		{
			DBGP((0, "MakeCall: VC alloc failed\n"));
			FREE_MEM(pCallParameters);
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	For later call to MakeCallComplete
		//
		ProtocolVcContext = pVc;

		//
		//	Get NDIS handle for this VC
		//
		NdisVcHandle = NULL_NDIS_HANDLE;
		NdisAfHandle = pElan->NdisAfHandle;

		if (NULL == NdisAfHandle)
		{
			DBGP((0, "%d MakeCall: ELAN %p: AfHandle is NULL!\n",
					pElan->ElanNumber, pElan));
			FREE_MEM(pCallParameters);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		Status = NdisCoCreateVc(
						pElan->NdisAdapterHandle,
						NdisAfHandle,
						ProtocolVcContext,
						&NdisVcHandle
						);

		if (NDIS_STATUS_SUCCESS != Status)
		{
			ASSERT(NDIS_STATUS_PENDING != Status);

			DBGP((0, "MakeCall: NdisCoCreateVc failed: %x, pAtmEnt %x, RefCount %d\n",
						Status, pAtmEntry, pAtmEntry->RefCount));
			FREE_MEM(pCallParameters);
			AtmLaneDeallocateVc(pVc);
			break;
		}

		DBGP((3, "MakeCall: pAtmEntry %x pVc %x NdisVcHandle %x\n",
				pAtmEntry,
				pVc,
				NdisVcHandle));

		AtmLaneReferenceVc(pVc, "vc");	// CreateVc reference

		//
		//	Now fill in the rest of the VC structure.  We don't need a lock
		//	for the VC until it gets linked to the ATM Entry structure.
		//
		pVc->NdisVcHandle = NdisVcHandle;
		NdisMoveMemory((PUCHAR)&(pVc->CallingAtmAddress),
					  (PUCHAR)&(pElan->AtmAddress),
					  sizeof(ATM_ADDRESS));
		pVc->Flags = 	VC_TYPE_SVC |
						VC_OWNER_IS_ATMLANE |
						VC_CALL_STATE_OUTGOING_IN_PROGRESS;

		//
		//	Start with with normal timeout, 
		//	AtmLaneLinkVcToAtmEntry will accelerate	if necessary.
		//
		pVc->AgingTime = pElan->VccTimeout;		

		switch (pAtmEntry->Type)
		{
			case ATM_ENTRY_TYPE_PEER:
				DBGP((1, "%d Outgoing call %x to PEER\n", pVc->pElan->ElanNumber, pVc));
				pVc->LaneType = VC_LANE_TYPE_DATA_DIRECT;
				break;
			case ATM_ENTRY_TYPE_LECS:
				DBGP((1, "%d Outgoing call %x to LECS\n", pVc->pElan->ElanNumber, pVc));
				pVc->LaneType = VC_LANE_TYPE_CONFIG_DIRECT;
				break;
			case ATM_ENTRY_TYPE_LES:
				DBGP((1, "%d Outgoing call %x to LES\n", pVc->pElan->ElanNumber, pVc));
				pVc->LaneType = VC_LANE_TYPE_CONTROL_DIRECT;
				break;
			case ATM_ENTRY_TYPE_BUS:
				DBGP((1, "%d Outgoing call %x to BUS\n", pVc->pElan->ElanNumber, pVc));
				pVc->LaneType = VC_LANE_TYPE_MULTI_SEND;
				break;
			default:
				ASSERT(FALSE);
				break;
		}
						
		//
		//	Zero out call parameters.
		//
		NdisZeroMemory(pCallParameters, RequestSize);

		if (!UsePvc)
		{
			//
			//	Distribute space and link up pointers amongst the various
			//	structures for an SVC.
			//
			//	pCallParameters------->+------------------------------------+
			//	                       | CO_CALL_PARAMETERS                 |
			//	pCallMgrParameters---->+------------------------------------+
			//	                       | CO_CALL_MANAGER_PARAMETERS         |
			//	pAtmCallMgrParameters->+------------------------------------+
			//	                       | Q2931_CALLMGR_PARAMETERS           |
			//	                       +------------------------------------+
			//	                       | AAL_PARAMETERS_IE                  |
			//	                       +------------------------------------+
			//	                       | ATM_TRAFFIC_DESCRIPTOR_IE          |
			//	                       +------------------------------------+
			//	                       | ATM_BROADBAND_BEARER_CAPABILITY_IE |
			//	                       +------------------------------------+
			//	                       | ATM_BLLI_IE                        |
			//	                       +------------------------------------+
			//	                       | ATM_QOS_CLASS_IE                   |
			//	                       +------------------------------------+
			
			//
			pCallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)
									((PUCHAR)pCallParameters +
									sizeof(CO_CALL_PARAMETERS));
		    pCallParameters->CallMgrParameters = pCallMgrParameters;
			pCallParameters->MediaParameters = (PCO_MEDIA_PARAMETERS)NULL;
			pCallMgrParameters->CallMgrSpecific.ParamType = CALLMGR_SPECIFIC_Q2931;	
			pCallMgrParameters->CallMgrSpecific.Length = 
								sizeof(Q2931_CALLMGR_PARAMETERS) +
								ATMLANE_CALL_IE_SPACE;
			pAtmCallMgrParameters = (PQ2931_CALLMGR_PARAMETERS)
								pCallMgrParameters->CallMgrSpecific.Parameters;

		}
		else
		{
			//
			//	Distribute space and link up pointers amongst the various
			//	structures for the LECS PVC.
			//
			//	pCallParameters------->+----------------------------+
			//	                       | CO_CALL_PARAMETERS         |
			//	pCallMgrParameters---->+----------------------------+
			//	                       | CO_CALL_MANAGER_PARAMETERS |
			//	pMediaParameters------>+----------------------------+
			//	                       | CO_MEDIA_PARAMETERS        |
			//	pAtmMediaParameters--->+----------------------------+
			//	                       | ATM_MEDIA_PARAMETERS       |
			//	                       +----------------------------+
			//
			pCallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)
									((PUCHAR)pCallParameters +
									sizeof(CO_CALL_PARAMETERS));
		    pCallParameters->CallMgrParameters = pCallMgrParameters;
			pCallMgrParameters->CallMgrSpecific.ParamType = 0;	
			pCallMgrParameters->CallMgrSpecific.Length = 0;
			pMediaParameters = (PCO_MEDIA_PARAMETERS)
				pCallMgrParameters->CallMgrSpecific.Parameters;
			pCallParameters->MediaParameters = pMediaParameters;
			pAtmMediaParameters = (PATM_MEDIA_PARAMETERS)
									pMediaParameters->MediaSpecific.Parameters;
		}

		//
		//	Call Manager generic flow paramters:
		//
		pCallMgrParameters->Transmit.TokenRate = 
				pElan->pAdapter->LinkSpeed.Outbound/8*100;	// cnvt decibits to bytes
		pCallMgrParameters->Transmit.PeakBandwidth = 
				pElan->pAdapter->LinkSpeed.Outbound/8*100;	// cnvt decibits to bytes
		pCallMgrParameters->Transmit.ServiceType = SERVICETYPE_BESTEFFORT;

		pCallMgrParameters->Receive.TokenRate = 
				pElan->pAdapter->LinkSpeed.Inbound/8*100;	// cnvt decibits to bytes
		pCallMgrParameters->Receive.PeakBandwidth = 
				pElan->pAdapter->LinkSpeed.Inbound/8*100;	// cnvt decibits to bytes
		pCallMgrParameters->Receive.ServiceType = SERVICETYPE_BESTEFFORT;

		if (ATM_ENTRY_TYPE_PEER == pAtmEntry->Type ||
			ATM_ENTRY_TYPE_BUS == pAtmEntry->Type)
		{
			//
			//	Is data direct or multicast send VC so use configured size
			//
			pCallMgrParameters->Transmit.TokenBucketSize = 
				pCallMgrParameters->Transmit.MaxSduSize = 
				pCallMgrParameters->Receive.TokenBucketSize = 
				pCallMgrParameters->Receive.MaxSduSize = 
					 pElan->MaxFrameSize;
		}
		else
		{
			//
			//	Is control VC so use 1516 per spec
			//
			pCallMgrParameters->Transmit.TokenBucketSize = 
				pCallMgrParameters->Transmit.MaxSduSize = 
				pCallMgrParameters->Receive.TokenBucketSize = 
				pCallMgrParameters->Receive.MaxSduSize = 
					 1516;
		}


		if (!UsePvc)
		{
			//
			//  SVC Q2931 Call Manager Parameters:
			//

			//
			//  Called address:
			//
			NdisMoveMemory((PUCHAR)&(pAtmCallMgrParameters->CalledParty),
						  (PUCHAR)&(pAtmEntry->AtmAddress),
						  sizeof(ATM_ADDRESS));

			//
			//  Calling address:
			//
			NdisMoveMemory((PUCHAR)&(pAtmCallMgrParameters->CallingParty),
						  (PUCHAR)&(pElan->AtmAddress),
						  sizeof(ATM_ADDRESS));

			//
			//  LANE spec says that the following IEs MUST be present in the
			//  SETUP message, so fill them all.
			//
			//      AAL Parameters
			//      Traffic Descriptor
			//      Broadband Bearer Capability
			//      Broadband Low Layer Info
			//      QoS
			//

			//
			//  Initialize the Info Element list
			//
			pAtmCallMgrParameters->InfoElementCount = 0;
			pIe = (PQ2931_IE)(pAtmCallMgrParameters->InfoElements);


			//
			//  AAL Parameters:
			//		AAL5
			//		SDU size 
			//			1516 for control
			//			ELAN MaxFrameSize for data
			{
				UNALIGNED AAL5_PARAMETERS	*pAal5;
	
				pIe->IEType = IE_AALParameters;
				pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE;
				pAalIe = (PAAL_PARAMETERS_IE)pIe->IE;
				pAalIe->AALType = AAL_TYPE_AAL5;
				pAal5 = &(pAalIe->AALSpecificParameters.AAL5Parameters);


			if (ATM_ENTRY_TYPE_PEER == pAtmEntry->Type ||
				ATM_ENTRY_TYPE_BUS == pAtmEntry->Type)
				{
					//
					//	Is data direct or multicast send VC so use configured size
					//
					pAal5->ForwardMaxCPCSSDUSize = 
						pAal5->BackwardMaxCPCSSDUSize = (USHORT)pElan->MaxFrameSize;
				}
				else
				{
					//
					//	Is control VC so use 1516 per spec
					//
					pAal5->ForwardMaxCPCSSDUSize = 
						pAal5->BackwardMaxCPCSSDUSize = 1516;
				}
			}

			pAtmCallMgrParameters->InfoElementCount++;
			pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


			//
			//  Traffic Descriptor:
			//		Line Rate Best Effort
			//
			pIe->IEType = IE_TrafficDescriptor;
			pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_TRAFFIC_DESCR_IE;
			pTrafficDescriptor = (PATM_TRAFFIC_DESCRIPTOR_IE)pIe->IE;

			pTrafficDescriptor->ForwardTD.PeakCellRateCLP01 = 
					LINKSPEED_TO_CPS(pElan->pAdapter->LinkSpeed.Outbound);
			DBGP((2, "MakeCall: fwd PeakCellRateCLP01 %d\n",
				pTrafficDescriptor->ForwardTD.PeakCellRateCLP01));
			pTrafficDescriptor->BackwardTD.PeakCellRateCLP01 = 
					LINKSPEED_TO_CPS(pElan->pAdapter->LinkSpeed.Inbound);
			DBGP((2, "MakeCall: bwd PeakCellRateCLP01 %d\n",
				pTrafficDescriptor->BackwardTD.PeakCellRateCLP01));
			pTrafficDescriptor->BestEffort = TRUE;

			pAtmCallMgrParameters->InfoElementCount++;
			pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);

			//
			//  Broadband Bearer Capability
			//
			pIe->IEType = IE_BroadbandBearerCapability;
			pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_BBC_IE;
			pBbc = (PATM_BROADBAND_BEARER_CAPABILITY_IE)pIe->IE;
	
			pBbc->BearerClass = BCOB_X;
			pBbc->TrafficType = TT_NOIND;
			pBbc->TimingRequirements = TR_NOIND;
			pBbc->ClippingSusceptability = CLIP_NOT;
			pBbc->UserPlaneConnectionConfig = UP_P2P;
	
			pAtmCallMgrParameters->InfoElementCount++;
			pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
	
			//
			//  Broadband Lower Layer Information
			//
			pIe->IEType = IE_BLLI;
			pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE;
			pBlli = (PATM_BLLI_IE)pIe->IE;
	
			pBlli->Layer2Protocol = SAP_FIELD_ABSENT;
			pBlli->Layer3Protocol = BLLI_L3_ISO_TR9577;
			pBlli->Layer3IPI = 		BLLI_L3_IPI_SNAP;
	
			pBlli->SnapId[0] = 0x00;
			pBlli->SnapId[1] = 0xa0;
			pBlli->SnapId[2] = 0x3e;
			pBlli->SnapId[3] = 0x00;
	
			pBlli->SnapId[4] = 0x01;			// default to Config Direct or 
												// Control Direct
											
			if (ATM_ENTRY_TYPE_PEER == pAtmEntry->Type)
			{
				if (pElan->LanType == LANE_LANTYPE_ETH)
				{
					pBlli->SnapId[4] = 0x02;	// Eth/802.3 Data Direct
				}
				else
				{
					pBlli->SnapId[4] = 0x03;	// 802.5 Data Direct
				}
			}
			if (ATM_ENTRY_TYPE_BUS == pAtmEntry->Type)
			{
				if (pElan->LanType == LANE_LANTYPE_ETH)
				{
					pBlli->SnapId[4] = 0x04;	// Eth/802.3 Multicast Send
				}
				else
				{
					pBlli->SnapId[4] = 0x05;	// 802.5 Multicast Send
				}
			}
	
			pAtmCallMgrParameters->InfoElementCount++;
			pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);

			//
			//  QoS
			//
			pIe->IEType = IE_QOSClass;
			pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_QOS_IE;
			pQos = (PATM_QOS_CLASS_IE)pIe->IE;
			pQos->QOSClassForward = pQos->QOSClassBackward = 0;

			pAtmCallMgrParameters->InfoElementCount++;
			pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
		}
		else
		{
			//
			//  PVC Generic and ATM-specific Media Parameters
			//
			pMediaParameters->Flags = TRANSMIT_VC | RECEIVE_VC;
			pMediaParameters->MediaSpecific.ParamType = ATM_MEDIA_SPECIFIC;
			pMediaParameters->MediaSpecific.Length = sizeof(ATM_MEDIA_PARAMETERS);

			pAtmMediaParameters->ConnectionId.Vpi = 0;
			pAtmMediaParameters->ConnectionId.Vci = 17;
			pAtmMediaParameters->AALType = AAL_TYPE_AAL5;
			pAtmMediaParameters->Transmit.PeakCellRate = 
				LINKSPEED_TO_CPS(pElan->pAdapter->LinkSpeed.Outbound);
			pAtmMediaParameters->Transmit.MaxSduSize = 1516;
			pAtmMediaParameters->Transmit.ServiceCategory = 
				ATM_SERVICE_CATEGORY_UBR;
			pAtmMediaParameters->Receive.PeakCellRate = 
				LINKSPEED_TO_CPS(pElan->pAdapter->LinkSpeed.Outbound);
			pAtmMediaParameters->Receive.MaxSduSize = 1516;
			pAtmMediaParameters->Receive.ServiceCategory = 
				ATM_SERVICE_CATEGORY_UBR;

			//
			//	Set PVC flag here
			//
			pCallParameters->Flags |= PERMANENT_VC;

		}

		//
		//  We add the Call reference
		//  right here
		//
		AtmLaneReferenceVc(pVc, "call");	// Call reference (MakeCall coming up)

		//
		//  We are ready to make the call. Before we do so, we need to
		//  link the VC structure to the ATM Entry, and release the
		//  ATM Entry lock
		//
		AtmLaneLinkVcToAtmEntry(pVc, pAtmEntry, FALSE);
		RELEASE_ATM_ENTRY_LOCK(pAtmEntry);	// acquired by caller
		bIsLockHeld = FALSE;

		//
		//  Make the Call now
		//
		Status = NdisClMakeCall(
						NdisVcHandle,
						pCallParameters,
						(NDIS_HANDLE)NULL,	// No Party context
						(PNDIS_HANDLE)NULL	// No Party handle expected
						);

		if (Status != NDIS_STATUS_PENDING)
		{
			AtmLaneMakeCallCompleteHandler(
						Status,
						ProtocolVcContext,
						(NDIS_HANDLE)NULL,	// No Party handle
						pCallParameters
						);
			Status = NDIS_STATUS_PENDING;
		}
		//
		//  else the MakeCall complete handler will be called
		//  later
		//

	} while (FALSE);

	if (bIsLockHeld)
	{
		RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
	}

	DBGP((3, "MakeCall: pVc %x, returning status %x\n",
						pVc, Status));

	TRACEOUT(MakeCall);
	return Status;
}


VOID
AtmLaneCloseCall(
	IN	PATMLANE_VC					pVc		LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Closes an existing call on a VC. It is assumed that a call exists
	on the VC, and the VC is not linked with any ATM Entry.

	NOTE: The caller is assumed to hold a lock to the VC structure,
	and it will be released here.

	SIDE EFFECT: If the NDIS call returns other than NDIS_STATUS_PENDING,
	we call our CloseCall Complete handler from here.

Arguments:

	pVc			- Pointer to ATMLANE VC structure.

Return Value:

	None

--*/
{
	NDIS_HANDLE				NdisVcHandle;
	NDIS_HANDLE				ProtocolVcContext;
	NDIS_STATUS				Status;
	PATMLANE_ELAN			pElan;
	BOOLEAN					WasRunning;	
	ULONG					rc;	

	TRACEIN(CloseCall);
	
	STRUCT_ASSERT(pVc, atmlane_vc);
	
	NdisVcHandle = pVc->NdisVcHandle;
	ProtocolVcContext = (NDIS_HANDLE)pVc;
	pElan = pVc->pElan;

	DBGP((1, "%d Closing call %x\n", pVc->pElan->ElanNumber, pVc));

	rc = pVc->RefCount;

	//
	//  Stop any timers running on this VC.
	//
	WasRunning = AtmLaneStopTimer(&(pVc->ReadyTimer), pElan);
	if (WasRunning)
	{
		rc = AtmLaneDereferenceVc(pVc, "ready timer");
	}
	if (rc > 0)
	{
		WasRunning = AtmLaneStopTimer(&(pVc->AgingTimer), pElan);
		if (WasRunning)
		{
			rc = AtmLaneDereferenceVc(pVc, "aging timer");
		}
	}

	//
	//  Continue only if the VC remains.
	//
	if (rc > 0)
	{
		//
		//  Check the call state on this VC. If the call is active,
		//  close it. Otherwise, simply mark the VC as closing, we'll
		//  continue this process when the current operation on the VC
		//  completes.

		if (IS_FLAG_SET(pVc->Flags,
						VC_CALL_STATE_MASK,
						VC_CALL_STATE_ACTIVE) &&
			(pVc->OutstandingSends == 0))
		{
			//
			//  Set VC call state to "Close Call in progress"
			//
			SET_FLAG(
					pVc->Flags,
					VC_CALL_STATE_MASK,
					VC_CALL_STATE_CLOSE_IN_PROGRESS);


			RELEASE_VC_LOCK(pVc);

			DBGP((3,
				"Closecall: NdisClCloseCall on NdisVcHandle %x\n",
			 		NdisVcHandle));

			Status = NdisClCloseCall(
						NdisVcHandle,
						(NDIS_HANDLE)NULL,	// No Party Handle
						(PVOID)NULL,		// No Buffer
						(UINT)0				// Size of above
						);

			if (Status != NDIS_STATUS_PENDING)
			{
				AtmLaneCloseCallCompleteHandler(
						Status,
						ProtocolVcContext,
						(NDIS_HANDLE)NULL
						);
			}
		}
		else
		{
			//
			//  Some operation is going on here (call setup). Mark this
			//  VC so that we know what to do when this operation completes.
			//
			SET_FLAG(
					pVc->Flags,
					VC_CLOSE_STATE_MASK,
					VC_CLOSE_STATE_CLOSING);

			RELEASE_VC_LOCK(pVc);
		}
	}
	//
	//  else the VC is gone.
	//

	
	TRACEOUT(CloseCall);

	return;
}



NDIS_STATUS
AtmLaneCreateVcHandler(
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisVcHandle,
	OUT	PNDIS_HANDLE				pProtocolVcContext
)
/*++

Routine Description:

	Entry point called by NDIS when the Call Manager wants to create
	a new endpoint (VC). We allocate a new ATMLANE VC structure, and
	return a pointer to it as our VC context.

Arguments:

	ProtocolAfContext	- Actually a pointer to the ATMLANE Interface structure
	NdisVcHandle		- Handle for this VC for all future references
	pProtocolVcContext	- Place where we (protocol) return our context for the VC

Return Value:

	NDIS_STATUS_SUCCESS if we could create a VC
	NDIS_STATUS_RESOURCES otherwise

--*/
{
	PATMLANE_ELAN		pElan;
	PATMLANE_VC			pVc;
	NDIS_STATUS			Status;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);
	
	TRACEIN(CreateVcHandler);

	pElan = (PATMLANE_ELAN)ProtocolAfContext;

	

	pVc = AtmLaneAllocateVc(pElan);
	if (pVc != NULL_PATMLANE_VC)
	{
		*pProtocolVcContext = (NDIS_HANDLE)pVc;
		pVc->NdisVcHandle = NdisVcHandle;
		pVc->Flags = VC_OWNER_IS_CALLMGR;
		AtmLaneReferenceVc(pVc, "vc");	// Create VC ref

		Status = NDIS_STATUS_SUCCESS;
	}
	else
	{
		Status = NDIS_STATUS_RESOURCES;
	}

	DBGP((3, "CreateVcHandler: pVc %x, Status %x\n", pVc, Status));

	TRACEOUT(CreateVcHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return (Status);
}

NDIS_STATUS
AtmLaneDeleteVcHandler(
	IN	NDIS_HANDLE					ProtocolVcContext
)
/*++

Routine Description:

	Our Delete VC handler. This VC would have been allocated as a result
	of a previous entry into our CreateVcHandler, and possibly used for
	an incoming call.

	At this time, this VC structure should be free of any calls, and we
	simply free this.

Arguments:

	ProtocolVcContext	- pointer to our VC structure

Return Value:

	NDIS_STATUS_SUCCESS always

--*/
{
	PATMLANE_VC			pVc;
	ULONG				rc;		// Ref count on the VC
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(DeleteVcHandler);

	pVc = (PATMLANE_VC)ProtocolVcContext;

	STRUCT_ASSERT(pVc, atmlane_vc);
	
	ASSERT((pVc->Flags & VC_OWNER_MASK) == VC_OWNER_IS_CALLMGR);

	ACQUIRE_VC_LOCK(pVc);
	rc = AtmLaneDereferenceVc(pVc, "vc");
	if (rc > 0)
	{
		//
		//  This can happen if there is a timer still running
		//  on this VC. When the timer elapses, the VC will be
		//  freed.
		//
		DBGP((2, "Delete VC handler: pVc %x, Flags %x, refcount %d\n",
					pVc, pVc->Flags, rc));
		RELEASE_VC_LOCK(pVc);
	}
	//
	//  else the VC is gone.
	//
	DBGP((3, "Delete Vc Handler: %x: done\n", pVc));

	TRACEOUT(DeleteVcHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
AtmLaneIncomingCallHandler(
	IN		NDIS_HANDLE				ProtocolSapContext,
	IN		NDIS_HANDLE				ProtocolVcContext,
	IN OUT	PCO_CALL_PARAMETERS 	pCallParameters
)
/*++

Routine Description:

	This handler is called when there is an incoming call matching our
	SAPs. 

Arguments:

	ProtocolSapContext		- Pointer to ATMLANE Interface structure
	ProtocolVcContext		- Pointer to ATMLANE VC structure
	pCallParameters			- Call parameters

Return Value:

	NDIS_STATUS_SUCCESS if we accept this call
	NDIS_STATUS_FAILURE if we reject it.

--*/
{
	PATMLANE_VC										pVc;
	PATMLANE_ATM_ENTRY								pAtmEntry;
	PATMLANE_ELAN									pElan;
	PATMLANE_SAP									pSap;

	Q2931_CALLMGR_PARAMETERS UNALIGNED *			pAtmCallMgrParameters;

	//
	//  To traverse the list of Info Elements
	//
	Q2931_IE UNALIGNED *							pIe;
	ULONG											InfoElementCount;

	//
	//  Info Elements in the incoming call, that are of interest to us.
	//  Initialize these to <not present>.
	//
	ATM_ADDRESS UNALIGNED *							pCallingAddress = NULL;
	AAL_PARAMETERS_IE UNALIGNED *					pAal = NULL;
	ATM_TRAFFIC_DESCRIPTOR_IE UNALIGNED *			pTrafficDescriptor = NULL;
	ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *	pBbc = NULL;
	ATM_BLLI_IE UNALIGNED *							pBlli = NULL;
	ATM_QOS_CLASS_IE UNALIGNED *					pQos = NULL;
	AAL5_PARAMETERS UNALIGNED *						pAal5;
	UCHAR											AddrTypeLen;
	UCHAR											SubaddrTypeLen;
	PUCHAR											pAtmSubaddress;
	NDIS_STATUS										Status;
	ULONG											Type;
	ULONG											rc;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);
	
	TRACEIN(IncomingCallHandler);

	pVc = (PATMLANE_VC)ProtocolVcContext;
	pSap = (PATMLANE_SAP)ProtocolSapContext;

	STRUCT_ASSERT(pVc, atmlane_vc);
	STRUCT_ASSERT(pSap, atmlane_sap);

	ASSERT((pVc->Flags & VC_TYPE_MASK) == VC_TYPE_UNUSED);
	ASSERT((pVc->Flags & VC_OWNER_MASK) == VC_OWNER_IS_CALLMGR);
	ASSERT((pVc->Flags & VC_CALL_STATE_MASK) == VC_CALL_STATE_IDLE);

	pElan = pVc->pElan;
	DBGP((3, "Incoming Call: pElan %x, pVc %x, pCallParams %x Type %s\n",
				pElan, pVc, pCallParameters,
				(pSap->LaneType == VC_LANE_TYPE_CONTROL_DISTRIBUTE?"LES":
				(pSap->LaneType == VC_LANE_TYPE_MULTI_FORWARD?"BUS":"DATA"))
				));

	do
	{
		//
		//	Start off with accepting the call
		//
		Status = NDIS_STATUS_SUCCESS;

	
		//
		//	If Elan is going down or staying down then reject the call
		//
		if (ELAN_STATE_OPERATIONAL != pElan->AdminState)
		{
			DBGP((2, "IncomingCallHandler: Elan is down, rejecting call\n"));
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//	Reject PVCs for now...
		//
		if ((pCallParameters->Flags & PERMANENT_VC) != 0)
		{
			DBGP((0, "IncomingCallHandler: PVCs not supported\n"));
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Get the following info from the Incoming call:
		//		Calling Address
		//		AAL Parameters
		//		Traffic Descriptor
		//		Broadband Bearer Capability
		//		QoS
		//
		pAtmCallMgrParameters = (PQ2931_CALLMGR_PARAMETERS)
					pCallParameters->CallMgrParameters->CallMgrSpecific.Parameters;

		pCallingAddress = &(pAtmCallMgrParameters->CallingParty);
		InfoElementCount = pAtmCallMgrParameters->InfoElementCount;
		pIe = (PQ2931_IE)(pAtmCallMgrParameters->InfoElements);

		while (InfoElementCount--)
		{
			switch (pIe->IEType)
			{
				case IE_AALParameters:
					pAal = (PAAL_PARAMETERS_IE)(pIe->IE);
					break;
				case IE_TrafficDescriptor:
					pTrafficDescriptor = (PATM_TRAFFIC_DESCRIPTOR_IE)(pIe->IE);
					break;
				case IE_BroadbandBearerCapability:
					pBbc = (PATM_BROADBAND_BEARER_CAPABILITY_IE)(pIe->IE);
					break;
				case IE_QOSClass:
					pQos = (PATM_QOS_CLASS_IE)(pIe->IE);
					break;
				case IE_BLLI:
					pBlli = (PATM_BLLI_IE)(pIe->IE);
					break;
				default:
					break;
			}
			pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
		}

		//
		//  Make sure all mandatory IEs are present. If not, reject the call
		//
		if ((pAal == 				(PAAL_PARAMETERS_IE)NULL) ||
			(pTrafficDescriptor == 	(PATM_TRAFFIC_DESCRIPTOR_IE)NULL) ||
			(pBbc == 				(PATM_BROADBAND_BEARER_CAPABILITY_IE)NULL) ||
			(pQos == 				(PATM_QOS_CLASS_IE)NULL) ||
			(pBlli ==				(PATM_BLLI_IE)NULL))
		{
			DBGP((0, "IncomingCallHandler: IE missing: "
			         " AAL %x TRAF %x BBC %x QOS %x BLLI %x",
					pAal,
					pTrafficDescriptor,
					pBbc,
					pQos,
					pBlli));
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Calling Address must be present
		//
		if (((pCallParameters->Flags & PERMANENT_VC) == 0) &&
			(pCallingAddress->NumberOfDigits == 0))
		{
			DBGP((0, "IncomingCallHandler: calling address missing\n"));
			Status = NDIS_STATUS_INVALID_ADDRESS;
			break;
		}

		//
		//  Make sure that the requested SDU sizes are sane.
		//	Originally this failed the call but now just a warning in DBG mode.
		//
#if DBG	
		pAal5 = &(pAal->AALSpecificParameters.AAL5Parameters);
		switch (pSap->LaneType)
		{
			case VC_LANE_TYPE_CONTROL_DISTRIBUTE:		// LES incoming
				if (pAal5->ForwardMaxCPCSSDUSize != 1516)
				{
					DBGP((0, "IncomingCallHandler: (Warning) ForwardMaxCPCSSDUSize %d"
							 "Incorrect for Control Distribute VCC\n",
							 pAal5->ForwardMaxCPCSSDUSize));
				}
				break;
			case VC_LANE_TYPE_MULTI_FORWARD:			// BUS incoming
				if (pAal5->ForwardMaxCPCSSDUSize != pElan->MaxFrameSize)
				{
					DBGP((0, "IncomingCallHandler: (Warning) ForwardMaxCPCSSDUSize %d "
							 "Invalid for Multicast Forward VCC\n",
							 pAal5->ForwardMaxCPCSSDUSize));
				}
				break;
			case VC_LANE_TYPE_DATA_DIRECT:				// PEER
				if (pAal5->ForwardMaxCPCSSDUSize != pElan->MaxFrameSize)
				{
					DBGP((0, "IncomingCallHandler: (Warning) ForwardMaxCPCSSDUSize %d "
							 "Invalid for Data Direct VCC\n",
							 pAal5->ForwardMaxCPCSSDUSize));
				}

				if (pAal5->BackwardMaxCPCSSDUSize != pElan->MaxFrameSize)
				{
					DBGP((0, "IncomingCallHandler: (Warning) BackwardMaxCPCSSDUSize %d "
							 "Invalid for Data Direct VCC\n",
							 pAal5->BackwardMaxCPCSSDUSize));
				}
				break;
		}
#endif

		//
		//	Earlier SAP matching problem required looking at the
		//	BLLI.  It was corrected. Now it is just redundant.
		//
		
		switch (pBlli->SnapId[4])
		{
			case 0x01:
				Type = VC_LANE_TYPE_CONTROL_DISTRIBUTE;
				break;
			case 0x02:
				Type = VC_LANE_TYPE_DATA_DIRECT;
				if (pElan->LanType == LANE_LANTYPE_TR)
				{
					DBGP((0, "IncomingCallHandler: Got ETH call on TR LAN\n"));
					Status = NDIS_STATUS_FAILURE;
				}
				break;
			case 0x03:
				Type = VC_LANE_TYPE_DATA_DIRECT;
				if (pElan->LanType == LANE_LANTYPE_ETH)
				{
					DBGP((0, "IncomingCallHandler: Got TR call on ETH LAN\n"));
					Status = NDIS_STATUS_FAILURE;
				}
				break;
			case 0x04:
				Type = VC_LANE_TYPE_MULTI_FORWARD;
				if (pElan->LanType == LANE_LANTYPE_TR)
				{
					DBGP((0, "IncomingCallHandler: Got ETH call on TR LAN\n"));
					Status = NDIS_STATUS_FAILURE;
				}
				break;
			case 0x05:
				Type = VC_LANE_TYPE_MULTI_FORWARD;
				if (pElan->LanType == LANE_LANTYPE_ETH)
				{
					DBGP((0, "IncomingCallHandler: Got TR call on ETH LAN\n"));
					Status = NDIS_STATUS_FAILURE;
				}
				break;
		}
		if (NDIS_STATUS_SUCCESS != Status)
		{
			break;
		}

		if (Type != pSap->LaneType)
		{
			DBGP((0, 
				"IncomingCallHandler: Type %d from BLLI"
				" differs from Type %d in SAP\n",
				Type, pSap->LaneType));
		}
		
		//
		//	Now link up the VC to ATM Entry based on type
		//
		pVc->LaneType = Type;

		switch (Type)
		{
			case VC_LANE_TYPE_CONTROL_DISTRIBUTE:		// LES incoming
				DBGP((1, "%d Incoming call %x from LES\n", pVc->pElan->ElanNumber, pVc));
				pAtmEntry = pElan->pLesAtmEntry;

				if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
				{
					Status = NDIS_STATUS_FAILURE;
					break;
				}

				ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
				ACQUIRE_VC_LOCK_DPC(pVc);
				NdisMoveMemory(							// copy in caller's addr
							&pVc->CallingAtmAddress,
							pCallingAddress,
							sizeof(ATM_ADDRESS)
							);
				if (pAtmEntry->pVcIncoming != NULL_PATMLANE_VC)
				{
					DBGP((0, "IncomingCallHandler: Redundant LES incoming call\n"));
					Status = NDIS_STATUS_FAILURE;
				}
				else
				{
					AtmLaneLinkVcToAtmEntry(pVc, pAtmEntry, TRUE);
					SET_FLAG(
							pAtmEntry->Flags,
							ATM_ENTRY_STATE_MASK,
							ATM_ENTRY_CONNECTED
							);
					pVc->Flags |= (VC_TYPE_SVC|VC_CALL_STATE_INCOMING_IN_PROGRESS);
				}
				RELEASE_VC_LOCK_DPC(pVc);
				RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
				break;
				
			case VC_LANE_TYPE_MULTI_FORWARD:			// BUS incoming
				DBGP((1, "%d Incoming call %x from BUS\n", pVc->pElan->ElanNumber, pVc));
				pAtmEntry = pElan->pBusAtmEntry;

				if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
				{
					Status = NDIS_STATUS_FAILURE;
					break;
				}

				ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
				ACQUIRE_VC_LOCK_DPC(pVc);
				NdisMoveMemory(							// copy in caller's addr
							&pVc->CallingAtmAddress,
							pCallingAddress,
							sizeof(ATM_ADDRESS)
							);
				if (pAtmEntry->pVcIncoming != NULL_PATMLANE_VC)
				{
					DBGP((0, "IncomingCallHandler: Redundant BUS incoming call\n"));
					Status = NDIS_STATUS_FAILURE;
				}
				else
				{
					AtmLaneLinkVcToAtmEntry(pVc, pAtmEntry, TRUE);
					SET_FLAG(
							pAtmEntry->Flags,
							ATM_ENTRY_STATE_MASK,
							ATM_ENTRY_CONNECTED
							);
					pVc->Flags |= (VC_TYPE_SVC|VC_CALL_STATE_INCOMING_IN_PROGRESS);
				}
				RELEASE_VC_LOCK_DPC(pVc);
				RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
				break;

			case VC_LANE_TYPE_DATA_DIRECT:				// PEER
				DBGP((1, "%d Incoming call %x from PEER\n", pVc->pElan->ElanNumber, pVc));


				//
				//	Find/create an ATM Entry
				//
				pAtmEntry = AtmLaneSearchForAtmAddress(
										pElan, 
										pCallingAddress->Address,
										ATM_ENTRY_TYPE_PEER,
										TRUE
										);
				if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
				{
					Status = NDIS_STATUS_RESOURCES;
					break;
				}

				ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);

				//
				//	Remember caller's address
				//
				ACQUIRE_VC_LOCK_DPC(pVc);
				NdisMoveMemory(							
							&pVc->CallingAtmAddress,
							pCallingAddress,
							sizeof(ATM_ADDRESS)
							);
							
				//
				//	Start with with normal timeout, 
				//	AtmLaneLinkVcToAtmEntry will accelerate	if necessary.
				//
				pVc->AgingTime = pElan->VccTimeout;		
							
				//
				//	Link up the VC with ATM Entry
				//
				if (pAtmEntry->pVcList != NULL_PATMLANE_VC)
				{
					DBGP((2, 
						"IncomingCallHandler: Multiple VCs for Dest ATM Addr\n"));
				}
				AtmLaneLinkVcToAtmEntry(pVc, pAtmEntry, FALSE);
				SET_FLAG(
						pAtmEntry->Flags,
						ATM_ENTRY_STATE_MASK,
						ATM_ENTRY_CONNECTED
						);
				pVc->Flags |= (VC_TYPE_SVC|VC_CALL_STATE_INCOMING_IN_PROGRESS);
				RELEASE_VC_LOCK_DPC(pVc);

				//
				//  Remove ref added by SearchFor...
				//
				rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "search");
				if (rc != 0)
				{
					RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
				}
				break;
		}

		break;

	}
	while (FALSE);

	DBGP((3, "Incoming call: pVc %x, Status %x\n", pVc, Status));
		
	TRACEOUT(IncomingCallHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return Status;
}


VOID
AtmLaneCallConnectedHandler(
	IN	NDIS_HANDLE					ProtocolVcContext
)
/*++

Routine Description:

	This handler is called as the final step in an incoming call, to inform
	us that the call is fully setup.

	For a PVC, we link the ATMLANE VC structure in the list of unresolved PVCs,
	and use InATMLANE to resolve both the IP and ATM addresses of the other
	end.

	For an SVC, 
	
Arguments:

	ProtocolVcContext		- Pointer to ATMLANE VC structure

Return Value:

	None

--*/
{
	PATMLANE_VC			pVc;
	PATMLANE_ELAN		pElan;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(CallConnectedHandler);

	pVc = (PATMLANE_VC)ProtocolVcContext;
	
	STRUCT_ASSERT(pVc, atmlane_vc);
	
	ASSERT((pVc->Flags & VC_CALL_STATE_MASK)
						 == VC_CALL_STATE_INCOMING_IN_PROGRESS);

	ACQUIRE_VC_LOCK(pVc);

	DBGP((1, "%d Incoming call %x connected\n", pVc->pElan->ElanNumber, pVc));

	//
	//  Note down that a call is active on this VC.
	//
	SET_FLAG(
			pVc->Flags,
			VC_CALL_STATE_MASK,
			VC_CALL_STATE_ACTIVE
			);

	AtmLaneReferenceVc(pVc, "call");		// Incoming call reference

	DBGP((2, "CallConnectedHandler: pVc %x Flags %x pAtmEntry %x\n",
					pVc, pVc->Flags, pVc->pAtmEntry));

	pElan = pVc->pElan;
	STRUCT_ASSERT(pElan, atmlane_elan);


	if (ELAN_STATE_OPERATIONAL == pElan->AdminState)
	{
		if (pVc->LaneType == VC_LANE_TYPE_DATA_DIRECT)
		{
			//
			//	Start ready protocol on non-server connections
			//  only if ready indication not already received.
			//
			if (!IS_FLAG_SET(
					pVc->Flags,
					VC_READY_STATE_MASK,
					VC_READY_INDICATED))
			{
				DBGP((2, "CallConnectedHandler: pVc %x Starting Ready Timer\n", pVc));
				SET_FLAG(
						pVc->Flags,
						VC_READY_STATE_MASK,
						VC_READY_WAIT
						);
				pVc->RetriesLeft = 1;
				AtmLaneReferenceVc(pVc, "ready timer");
				AtmLaneStartTimer(
						pElan, 
						&pVc->ReadyTimer, 
						AtmLaneReadyTimeout, 
						pElan->ConnComplTimer, 
						pVc);

						
			}
			
			//
			//  Start VC aging timer
			//
			AtmLaneReferenceVc(pVc, "aging timer");
			AtmLaneStartTimer(
						pElan,
						&pVc->AgingTimer,
						AtmLaneVcAgingTimeout,
						pVc->AgingTime,
						(PVOID)pVc
						);
		}
		else
		{
			SET_FLAG(
					pVc->Flags,
					VC_READY_STATE_MASK,
					VC_READY_INDICATED
					);
		}
		RELEASE_VC_LOCK(pVc);

	}
	else
	{
		//
		//  The elan is going down. Close this call.
		//
		AtmLaneCloseCall(pVc);
		//
		// VC lock released in above
		//
	}

	TRACEOUT(CallConnectedHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}


VOID
AtmLaneIncomingCloseHandler(
	IN	NDIS_STATUS					CloseStatus,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PVOID						pCloseData	OPTIONAL,
	IN	UINT						Size		OPTIONAL
)
/*++

Routine Description:

	This handler is called when a call is closed, either by the network
	or by the remote peer.

Arguments:

	CloseStatus			- Reason for the call clearing
	ProtocolVcContext	- Actually a pointer to the ATMLANE VC structure
	pCloseData			- Additional info about the close
	Size				- Length of above

Return Value:

	None

--*/
{
	PATMLANE_VC			pVc;
	PATMLANE_ATM_ENTRY	pAtmEntry;
	PATMLANE_ELAN		pElan;
	ULONG				rc;				// Ref Count
	BOOLEAN				IsServer = FALSE;
	ULONG				ServerType = 0;
#if DEBUG_IRQL
	KIRQL				EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(IncomingCloseHandler);

	pVc = (PATMLANE_VC)ProtocolVcContext;
	STRUCT_ASSERT(pVc, atmlane_vc);
	
	ACQUIRE_VC_LOCK(pVc);
	
	pVc->Flags |= VC_SEEN_INCOMING_CLOSE;

	pAtmEntry = pVc->pAtmEntry;
	pElan = pVc->pElan;
	
	if (NULL_PATMLANE_ATM_ENTRY != pAtmEntry)
	{
		//
		//	Determine if this is server connection
		//
		IsServer = (ATM_ENTRY_TYPE_PEER == pAtmEntry->Type) ? FALSE : TRUE;
		if (IsServer)
		{
			ServerType = pAtmEntry->Type;
		}

		//
		//	Unlink the VC from the AtmEntry
		//
		if (AtmLaneUnlinkVcFromAtmEntry(pVc))
		{
			rc = AtmLaneDereferenceVc(pVc, "atm");
			ASSERT(rc > 0);
		}
	}

	//
	//  If we're seeing this just after accepting an incomingcall,
	//  fake the call state to Active, so that AtmLaneCloseCall will
	//  tear down the call.
	//
	if (IS_FLAG_SET(pVc->Flags,
					VC_CALL_STATE_MASK,
					VC_CALL_STATE_INCOMING_IN_PROGRESS))
	{
		SET_FLAG(
				pVc->Flags,
				VC_CALL_STATE_MASK,
				VC_CALL_STATE_ACTIVE);

		AtmLaneReferenceVc(pVc, "call");	// Incoming call reference - CloseCall
	}

	//
	//	Complete tearing down the call
	//
	AtmLaneCloseCall(pVc);

	//
	//	If server connection - notify the event handler
	//
	if (IsServer)
	{
		ACQUIRE_ELAN_LOCK(pElan);
		switch(ServerType)
		{
			case ATM_ENTRY_TYPE_LECS:
				AtmLaneQueueElanEvent(pElan, ELAN_EVENT_LECS_CALL_CLOSED, 0);
				break;
			case ATM_ENTRY_TYPE_LES:
				AtmLaneQueueElanEvent(pElan, ELAN_EVENT_LES_CALL_CLOSED, 0);
				break;
			case ATM_ENTRY_TYPE_BUS:
				AtmLaneQueueElanEvent(pElan, ELAN_EVENT_BUS_CALL_CLOSED, 0);
				break;
		}
		RELEASE_ELAN_LOCK(pElan);
	}

	TRACEOUT(IncomingCloseHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneIncomingDropPartyHandler(
	IN	NDIS_STATUS					DropStatus,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	PVOID						pCloseData	OPTIONAL,
	IN	UINT						Size		OPTIONAL
)
/*++

Routine Description:

	This handler is called if the network (or remote peer) drops
	a leaf node from a point-to-multipoint call rooted at us.

	Since we don't use point-to-multipoint calls, we should never
	see one of these.

Arguments:

	Not relevant to us since we never expect to see this.

Return Value:

	None

--*/
{
	TRACEIN(IncomingDropPartyHandler);

	DBGP((0, "IncomingDropPartyHandler: UNEXPECTED CALL!\n"));
	ASSERT(FALSE);
	
	TRACEOUT(IncomingDropPartyHandler);

	return;
}

VOID
AtmLaneQosChangeHandler(
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
)
/*++

Routine Description:

	This handler is called if the remote peer modifies call parameters
	"on the fly", i.e. after the call is established and running.

	This isn't supported by existing ATM signalling, and shouldn't happen,
	but we'll allow this.

	FUTURE: The FlowSpecs associated with the call are affected by this.

Arguments:

	ProtocolVcContext		- Pointer to our ATMLANE VC structure
	pCallParameters			- updated call parameters.

Return Value:

	None

--*/
{
	PATMLANE_VC		pVc;

	TRACEIN(QosChangeHandler);

	pVc = (PATMLANE_VC)ProtocolVcContext;

	DBGP((0, "Ignoring Qos Change, VC: %x\n", pVc));

	TRACEOUT(QosChangeHandler);

	return;
}



VOID
AtmLaneRegisterSapCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolSapContext,
	IN	PCO_SAP						pSap,
	IN	NDIS_HANDLE					NdisSapHandle
)
/*++

Routine Description:

	This routine is called to indicate completion of a call to
	NdisClRegisterSap. If the call was successful, save the
	allocated NdisSapHandle in our SAP structure.

Arguments:

	Status						- Status of Register SAP
	ProtocolSapContext			- Pointer to our ATMLANE Interface structure
	pSap						- SAP information we'd passed in the call
	NdisSapHandle				- SAP Handle

Return Value:

	None

--*/
{
	PATMLANE_SAP					pAtmLaneSap;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(RegisterSapCompleteHandler);

	pAtmLaneSap = (PATMLANE_SAP)ProtocolSapContext;

	if (Status == NDIS_STATUS_SUCCESS)
	{
		pAtmLaneSap->NdisSapHandle = NdisSapHandle;
		SET_FLAG(pAtmLaneSap->Flags,
				SAP_REG_STATE_MASK,
				SAP_REG_STATE_REGISTERED);
				
		NdisInterlockedIncrement(&pAtmLaneSap->pElan->SapsRegistered);
		if (pAtmLaneSap->pElan->SapsRegistered == 3)
			AtmLaneQueueElanEvent(
					pAtmLaneSap->pElan, 
					ELAN_EVENT_SAPS_REGISTERED, 
					Status);
	}
	else
	{
		SET_FLAG(pAtmLaneSap->Flags,
				SAP_REG_STATE_MASK,
				SAP_REG_STATE_IDLE);
		AtmLaneQueueElanEvent(
				pAtmLaneSap->pElan, 
				ELAN_EVENT_SAPS_REGISTERED, 
				Status);
	}
	
	TRACEOUT(RegisterSapCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneDeregisterSapCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolSapContext
)
/*++

Routine Description:

	This routine is called when a previous call to NdisClDeregisterSap
	has completed. If it was successful, we update the state of the ATMLANE
	SAP structure representing the Sap.

Arguments:

	Status						- Status of the Deregister SAP request
	ProtocolSapContext			- Pointer to our ATMLANE SAP structure

Return Value:

	None

--*/
{

	PATMLANE_ELAN					pElan;
	PATMLANE_SAP					pAtmLaneSap;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(DeregisterSapCompleteHandler);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		pAtmLaneSap = (PATMLANE_SAP)ProtocolSapContext;

		STRUCT_ASSERT(pAtmLaneSap, atmlane_sap);
		pElan = pAtmLaneSap->pElan;

		ACQUIRE_ELAN_LOCK(pElan);

		pAtmLaneSap->NdisSapHandle = NULL;

		SET_FLAG(pAtmLaneSap->Flags,
					SAP_REG_STATE_MASK,
					SAP_REG_STATE_IDLE);
		
		RELEASE_ELAN_LOCK(pElan);
	}

	TRACEOUT(DeregisterSapCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneMakeCallCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					NdisPartyHandle		OPTIONAL,
	IN	PCO_CALL_PARAMETERS			pCallParameters
)
/*++

Routine Description:

	This routine is called when an outgoing call request (NdisClMakeCall)
	has completed. The "Status" parameter indicates whether the call was
	successful or not.

	If the call was successful and this is a server connection then
	the an event handler is called.  If it is a peer connection then
	???

	If the call failed ??

Arguments:

	Status						- Result of the NdisClMakeCall
	ProtocolVcContext			- Pointer to ATMLANE VC structure
	NdisPartyHandle				- Not used (no point-to-multipoint calls)
	pCallParameters				- Pointer to call parameters

Return Value:

	None

--*/
{
	PATMLANE_VC					pVc;
	PATMLANE_ATM_ENTRY			pAtmEntry;
	PATMLANE_MAC_ENTRY			pMacEntry;
	PATMLANE_MAC_ENTRY			PMacEntryNext;
	PATMLANE_ELAN				pElan;
	ULONG						rc;			
	NDIS_HANDLE					NdisVcHandle;
	BOOLEAN						IsServer;	
	ULONG						EventStatus;
#if DEBUG_IRQL
	KIRQL						EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);
	
	TRACEIN(MakeCallCompleteHandler);

	//
	//  Initialize
	//
	pVc = (PATMLANE_VC)ProtocolVcContext;
	STRUCT_ASSERT(pVc, atmlane_vc);

	ACQUIRE_VC_LOCK(pVc);

	DBGP((3, "MakeCallCompleteHandler: Status %x, pVc %x, pAtmEntry %x\n",
				Status, pVc, pVc->pAtmEntry));
	
	pElan = pVc->pElan;

	DBGP((1, "%d Outgoing call %x %s\n", pVc->pElan->ElanNumber, pVc,
		(Status == NDIS_STATUS_SUCCESS)?"complete":"failed"));

	if ((ELAN_STATE_OPERATIONAL == pElan->AdminState) &&

		(!IS_FLAG_SET(pVc->Flags,
					  VC_CLOSE_STATE_MASK,
					  VC_CLOSE_STATE_CLOSING)))
	{
		pAtmEntry = pVc->pAtmEntry;
		STRUCT_ASSERT(pAtmEntry, atmlane_atm);

		//
		//	Determine if this is server connection
		//
		IsServer = (ATM_ENTRY_TYPE_PEER == pAtmEntry->Type) ? FALSE : TRUE;

		if (Status == NDIS_STATUS_SUCCESS)
		{
			//
			//  Update the call state on this VC.
			//
			SET_FLAG(pVc->Flags,
					VC_CALL_STATE_MASK,
					VC_CALL_STATE_ACTIVE);

			//
			//  Update the call type on this VC. 
			//
			if (pCallParameters->Flags & PERMANENT_VC)
			{
				SET_FLAG(pVc->Flags,
						VC_TYPE_MASK,
						VC_TYPE_PVC);
			}
			else
			{
				SET_FLAG(pVc->Flags,
						VC_TYPE_MASK,
						VC_TYPE_SVC);
			}

			//
			//  Start VC aging timer if not server
			//
			if (!IsServer)
			{
				AtmLaneReferenceVc(pVc, "aging timer");
				AtmLaneStartTimer(
						pElan,
						&pVc->AgingTimer,
						AtmLaneVcAgingTimeout,
						pVc->AgingTime,
						(PVOID)pVc
						);
			}
			//
			//	Update the ready state on this VC
			//
			SET_FLAG(pVc->Flags,
					VC_READY_STATE_MASK,
					VC_READY_INDICATED);
			if (!IsServer)
			{
				AtmLaneSendReadyIndication(pElan, pVc);
				//
				//	VC lock released in above
				//
			}
			else
			{
				RELEASE_VC_LOCK(pVc);
			}

			//
			//	Update the Atm Entry
			//
			//	Clear call-in-progress and mark connected
			//
			ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);

			pAtmEntry->Flags &= ~ ATM_ENTRY_CALLINPROGRESS;

			SET_FLAG(
					pAtmEntry->Flags,
					ATM_ENTRY_STATE_MASK,
					ATM_ENTRY_CONNECTED);

			//
			//	Go through the Mac Entry List and see if any
			//	need the flush protocol initiated.
			//
			pMacEntry = pAtmEntry->pMacEntryList;
			RELEASE_ATM_ENTRY_LOCK(pAtmEntry);

			while (pMacEntry != NULL_PATMLANE_MAC_ENTRY)
			{
				PATMLANE_MAC_ENTRY		pNextMacEntry;

				ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);

				pNextMacEntry = pMacEntry->pNextToAtm;

				if (IS_FLAG_SET(
						pMacEntry->Flags,
						MAC_ENTRY_STATE_MASK,
						MAC_ENTRY_RESOLVED))
				{
					//
					//	Start the Flush protocol
					//
					pMacEntry->RetriesLeft = 0;
					AtmLaneReferenceMacEntry(pMacEntry, "timer");
					AtmLaneStartTimer(
						pElan,
						&pMacEntry->FlushTimer,
						AtmLaneFlushTimeout,
						pElan->FlushTimeout,
						(PVOID)pMacEntry
						);

					SET_FLAG(
						pMacEntry->Flags,
						MAC_ENTRY_STATE_MASK,
						MAC_ENTRY_FLUSHING);

					//
					//	Send the flush
					//
					AtmLaneSendFlushRequest(pElan, pMacEntry, pAtmEntry);
					//
					//	MacEntry lock released in above
					//
				}
				else
				{
					RELEASE_MAC_ENTRY_LOCK(pMacEntry);
				}
				pMacEntry = pNextMacEntry;
			}
		}
		else
		{
			//
			//  The call failed.
			//
			SET_FLAG(pVc->Flags,
					VC_CALL_STATE_MASK,
					VC_CALL_STATE_IDLE);

			//
			//	Clear call in progress on Atm Entry
			//	Add temp reference to keep the AtmEntry around
			//
			RELEASE_VC_LOCK(pVc);
			ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
			pAtmEntry->Flags &= ~ATM_ENTRY_CALLINPROGRESS;
			AtmLaneReferenceAtmEntry(pAtmEntry, "temp1");
			RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
			ACQUIRE_VC_LOCK(pVc);

			//
			//  Delete the Call reference
			//
			rc = AtmLaneDereferenceVc(pVc, "call");
			ASSERT(rc > 0);

			//
			//  Unlink this VC from the ATM Entry it belonged to.
			//
			ASSERT(pVc->pAtmEntry != NULL_PATMLANE_ATM_ENTRY);
			if (AtmLaneUnlinkVcFromAtmEntry(pVc))
			{
				rc = AtmLaneDereferenceVc(pVc, "atm");
				ASSERT(rc > 0);
			}

			//
			//  Delete the CreateVc reference
			//
			NdisVcHandle = pVc->NdisVcHandle;
			rc =  AtmLaneDereferenceVc(pVc, "vc");	// Create Vc ref
			if (rc > 0)
			{
				RELEASE_VC_LOCK(pVc);
			}
			
			//
			//  Delete the NDIS association
			//
			(VOID)NdisCoDeleteVc(NdisVcHandle);
			DBGP((3, 
				"MakeCallCompleteHandler: DeleteVc  Vc %x NdisVcHandle %x\n",
				pVc, NdisVcHandle));

			//
			//	Abort all the MAC entries attached to this Atm Entry.
			//
			pMacEntry = pAtmEntry->pMacEntryList;
			while ( pMacEntry != NULL_PATMLANE_MAC_ENTRY)
			{
				ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
				AtmLaneAbortMacEntry(pMacEntry);
				ASSERT(pAtmEntry->pMacEntryList != pMacEntry);
				pMacEntry = pAtmEntry->pMacEntryList;
			}

			ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
			rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "temp1");
			if (rc > 0)
			{
				RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
			}
		}

		//
		//	Free the Call Parameters allocated in MakeCall().
		//
		FREE_MEM(pCallParameters);

		//
		//	If this is server connection then 
		//	send an event to the elan state machine.
		//
	
		if (IsServer)
		{
			ACQUIRE_ELAN_LOCK(pElan);
			AtmLaneQueueElanEvent(pElan, ELAN_EVENT_SVR_CALL_COMPLETE, Status);
			RELEASE_ELAN_LOCK(pElan);
		}
	}
	else
	{
		//
		//  The Elan is going down and/or we are aborting the
		//  ATM entry: clean up everything first.
		//

		//
		//	Free the Call Parameters allocated in MakeCall().
		//
		FREE_MEM(pCallParameters);

		//
		//  Unlink this VC from the ATM Entry
		//
		if (pVc->pAtmEntry != NULL_PATMLANE_ATM_ENTRY)
		{
			if (AtmLaneUnlinkVcFromAtmEntry(pVc))
			{
				rc = AtmLaneDereferenceVc(pVc, "atm");
				ASSERT(rc > 0);
			}
		}

		if (NDIS_STATUS_SUCCESS == Status)
		{
			//
			//  The call had been set up successfully, so close it.
			//
			//
			//  Update the call state on this VC.
			//
			SET_FLAG(pVc->Flags,
					VC_CALL_STATE_MASK,
					VC_CALL_STATE_ACTIVE);

			AtmLaneCloseCall(pVc);
			//
			//  The VC lock is released by CloseCall
			//
		}
		else
		{
			//  MakeCall had failed. (And the ELAN is going down)

			SET_FLAG(pVc->Flags,
						VC_CALL_STATE_MASK,
						VC_CALL_STATE_IDLE);

			//
			//  Delete the CreateVc reference
			//
			NdisVcHandle = pVc->NdisVcHandle;
			rc =  AtmLaneDereferenceVc(pVc, "vc");	// Create Vc ref
			if (rc > 0)
			{
				RELEASE_VC_LOCK(pVc);
			}

			//
			//  Delete the NDIS association
			//
			(VOID)NdisCoDeleteVc(NdisVcHandle);
			DBGP((3,
			"MakeCallCompleteHandler: Deleted NDIS VC on pVc %x: NdisVcHandle %x\n",
				pVc, NdisVcHandle));
		}
	}
			
	TRACEOUT(MakeCallCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneCloseCallCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					ProtocolPartyContext OPTIONAL
)
/*++

Routine Description:

	This routine handles completion of a previous NdisClCloseCall.
	It is assumed that Status is always NDIS_STATUS_SUCCESS.

Arguments:

	Status					- Status of the Close Call.
	ProtocolVcContext		- Pointer to ATMLANE VC structure.
	ProtocolPartyContext	- Not used.

Return Value:

	None

--*/
{
	PATMLANE_VC				pVc;
	ULONG					rc;			// Ref Count
	NDIS_HANDLE				NdisVcHandle;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(CloseCallCompleteHandler);

	pVc = (PATMLANE_VC)ProtocolVcContext;
	STRUCT_ASSERT(pVc, atmlane_vc);

	DBGP((1, "%d Close call %x complete\n", pVc->pElan->ElanNumber, pVc));

	ACQUIRE_VC_LOCK(pVc);

	rc = AtmLaneDereferenceVc(pVc, "call");	// Call reference
	SET_FLAG(pVc->Flags,
				VC_CALL_STATE_MASK,
				VC_CALL_STATE_IDLE);

	//
	//  If this VC belongs to us, delete it.
	//
	if (IS_FLAG_SET(pVc->Flags,
						VC_OWNER_MASK,
						VC_OWNER_IS_ATMLANE))
	{
		NdisVcHandle = pVc->NdisVcHandle;
		rc =  AtmLaneDereferenceVc(pVc, "vc");	// Create Vc ref
		if (rc > 0)
		{
			RELEASE_VC_LOCK(pVc);
		}
		//
		//  Delete the NDIS association
		//
		(VOID)NdisCoDeleteVc(NdisVcHandle);
		DBGP((3, "CloseCallComplete: deleted NDIS VC on pVc %x: NdisVcHandle %x\n",
				pVc, NdisVcHandle));
	}
	else
	{
		//
		//  VC belongs to the Call Manager -- take it back to the
		//  state it was when it was just created (via our CreateVcHandler).
		//  The Call Manager can either re-use it or delete it.
		//
		pVc->Flags = VC_OWNER_IS_CALLMGR;
		RELEASE_VC_LOCK(pVc);
	}

	TRACEOUT(CloseCallCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}


VOID
AtmLaneAddPartyCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	NDIS_HANDLE					NdisPartyHandle,
	IN	PCO_CALL_PARAMETERS			pCallParameters
)
/*++

Routine Description:

	This routine is called on completion of a previous call to
	NdisClAddParty. Since we don't use point-to-multipoint connections,
	this should never get called.

Arguments:

	<Don't care>

Return Value:

	None

--*/
{
	TRACEIN(AddPartyCompleteHandler);

	DBGP((0, "Add Party Complete unexpectedly called\n"));

	TRACEOUT(AddPartyCompleteHandler);

	return;
}

VOID
AtmLaneDropPartyCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext
)
/*++

Routine Description:

	This routine is called on completion of a previous call to
	NdisClDropParty. Since we don't use point-to-multipoint connections,
	this should never get called.

Arguments:

	<Don't care>

Return Value:

	None

--*/
{
	TRACEIN(DropPartyCompleteHandler);

	DBGP((0, "Drop Party Complete unexpectedly called\n"));

	TRACEOUT(DropPartyCompleteHandler);

	return;
}



VOID
AtmLaneModifyQosCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
)
/*++

Routine Description:

	This routine is called on completion of a previous call to
	NdisClModifyCallQoS. Since we don't call this, this should never
	get called.

Arguments:

	<Don't care>

Return Value:

	None

--*/
{
	TRACEIN(ModifyQosCompleteHandler);

	DBGP((0, "Modify QOS Complete unexpectedly called\n"));

	TRACEOUT(ModifyQosCompleteHandler);

	return;
}

NDIS_STATUS
AtmLaneSendNdisCoRequest(
	IN	NDIS_HANDLE					NdisAdapterHandle,
	IN	NDIS_HANDLE					NdisAfHandle,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
)
/*++

Routine Description:

	Send an NDIS Connection Oriented request to the Call Manager. We
	allocate an NDIS_REQUEST structure, link the supplied buffer to it,
	and send the request. If the request does not pend, we call our
	completion routine from here.

Arguments:

	NdisAdapterHandle		- Binding Handle to be used in the request
	NdisAfHandle			- AF Handle value to be used in the request
	pNdisRequest			- Pointer to NDIS request structure
	RequestType				- Set/Query information
	Oid						- OID to be passed in the request
	pBuffer					- place for value(s)
	BufferLength			- length of above

Return Value:

	Status of the NdisCoRequest.

--*/
{
	NDIS_STATUS			Status;

	TRACEIN(SendNdisCoRequest);

	//
	//  Fill in the NDIS Request structure
	//
	pNdisRequest->RequestType = RequestType;
	if (RequestType == NdisRequestQueryInformation)
	{
		pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;
	}
	else
	{
		pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.SET_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
		pNdisRequest->DATA.SET_INFORMATION.BytesNeeded = 0;
	}

	if (NULL == NdisAfHandle ||
		NULL == NdisAdapterHandle)
	{
		Status = NDIS_STATUS_INTERFACE_DOWN;
	}
	else
	{

		Status = NdisCoRequest(
					NdisAdapterHandle,
					NdisAfHandle,
					NULL,			// No VC handle
					NULL,			// No Party Handle
					pNdisRequest);
	}
		
	TRACEOUT(SendNdisCoRequest);

	return (Status);
}




NDIS_STATUS
AtmLaneCoRequestHandler(
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_HANDLE					ProtocolPartyContext	OPTIONAL,
	IN OUT PNDIS_REQUEST			pNdisRequest
)
/*++

Routine Description:

	This routine is called by NDIS when our Call Manager sends us an
	NDIS Request. NDIS Requests that are of significance to us are:
	- OID_CO_ADDRESS_CHANGE
		The set of addresses registered with the switch has changed,
		i.e. address registration is complete. We issue an NDIS Request
		ourselves to get the list of addresses registered.
	- OID_CO_SIGNALING_ENABLED
		We ignore this as of now.
	- OID_CO_SIGNALING_DISABLED
		We ignore this for now.
	- OID_CO_AF_CLOSE
		The Call manager wants us to shut down this AF open (== ELAN).

	We ignore all other OIDs.

Arguments:

	ProtocolAfContext			- Our context for the Address Family binding,
								  which is a pointer to the ATMLANE Interface.
	ProtocolVcContext			- Our context for a VC, which is a pointer to
								  an ATMLANE VC structure.
	ProtocolPartyContext		- Our context for a Party. Since we don't do
								  PMP, this is ignored (must be NULL).
	pNdisRequest				- Pointer to the NDIS Request.

Return Value:

	NDIS_STATUS_SUCCESS if we recognized the OID
	NDIS_STATUS_NOT_RECOGNIZED if we didn't.

--*/
{
	PATMLANE_ELAN				pElan;
	PATMLANE_ADAPTER			pAdapter;
	NDIS_STATUS					Status;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(CoRequestHandler);

	pElan = (PATMLANE_ELAN)ProtocolAfContext;
	STRUCT_ASSERT(pElan, atmlane_elan);

	//
	//  Initialize
	//
	Status = NDIS_STATUS_NOT_RECOGNIZED;

	if (pNdisRequest->RequestType == NdisRequestSetInformation)
	{
		switch (pNdisRequest->DATA.SET_INFORMATION.Oid)
		{
			case OID_CO_ADDRESS_CHANGE:
				DBGP((1, "CoRequestHandler: CO_ADDRESS_CHANGE\n"));
				//
				//  The Call Manager says that the list of addresses
				//  registered on this interface has changed. Get the
				//  (potentially) new ATM address for this interface.
				//
				ACQUIRE_ELAN_LOCK(pElan);
				pElan->AtmInterfaceUp = FALSE;
				//
				//	zero out the Elan's ATM address
				//
				NdisZeroMemory((PUCHAR)&(pElan->AtmAddress), sizeof(ATM_ADDRESS));
				
				RELEASE_ELAN_LOCK(pElan);

				AtmLaneGetAtmAddress(pElan);
				Status = NDIS_STATUS_SUCCESS;
				break;
			
			case OID_CO_SIGNALING_ENABLED:
				DBGP((1, "CoRequestHandler: CO_SIGNALING_ENABLED\n"));
				// ignored for now
				Status = NDIS_STATUS_SUCCESS;
				break;

			case OID_CO_SIGNALING_DISABLED:
				DBGP((1, "CoRequestHandler: CO_SIGNALING_DISABLED\n"));
				// Ignored for now
				Status = NDIS_STATUS_SUCCESS;
				break;

			case OID_CO_AF_CLOSE:
				DBGP((0, "CoRequestHandler: CO_AF_CLOSE on ELAN %x/%x\n", pElan, pElan->Flags));
				pAdapter = pElan->pAdapter;
				ACQUIRE_ADAPTER_LOCK(pAdapter);
				while (pAdapter->Flags & ADAPTER_FLAGS_BOOTSTRAP_IN_PROGRESS)
				{
					RELEASE_ADAPTER_LOCK(pAdapter);
					(VOID)WAIT_ON_BLOCK_STRUCT(&pAdapter->UnbindBlock);
					ACQUIRE_ADAPTER_LOCK(pAdapter);
				}
				RELEASE_ADAPTER_LOCK(pAdapter);

				ACQUIRE_ELAN_LOCK(pElan);
				pElan->Flags |= ELAN_SAW_AF_CLOSE;
				AtmLaneQueueElanEventAfterDelay(pElan, ELAN_EVENT_STOP, 0, 1*1000);
				RELEASE_ELAN_LOCK(pElan);
				Status = NDIS_STATUS_SUCCESS;
				break;

			default:
				break;
		}
	}

	TRACEOUT(CoRequestHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return (Status);
}

VOID
AtmLaneCoRequestCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_HANDLE					ProtocolPartyContext	OPTIONAL,
	IN	PNDIS_REQUEST				pNdisRequest
)
/*++

Routine Description:

	This routine is called by NDIS when a previous call to NdisCoRequest
	that had pended, is complete. We handle this based on the request
	we had sent, which has to be one of:
	- OID_CO_GET_ADDRESSES
		Get all addresses registered on the specified AF binding.

Arguments:

	Status						- Status of the Request.
	ProtocolAfContext			- Our context for the Address Family binding,
								  which is a pointer to the ATMLANE Interface.
	ProtocolVcContext			- Our context for a VC, which is a pointer to
								  an ATMLANE VC structure.
	ProtocolPartyContext		- Our context for a Party. Since we don't do
								  PMP, this is ignored (must be NULL).
	pNdisRequest				- Pointer to the NDIS Request.


Return Value:

	None

--*/
{
	PATMLANE_ELAN				pElan;
	ULONG						Oid;
#if DEBUG_IRQL
	KIRQL							EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(CoRequestCompleteHandler);

	pElan = (PATMLANE_ELAN)ProtocolAfContext;
	STRUCT_ASSERT(pElan, atmlane_elan);

	if (pNdisRequest->RequestType == NdisRequestQueryInformation)
	{
		switch (pNdisRequest->DATA.QUERY_INFORMATION.Oid)
		{
			case OID_CO_GET_ADDRESSES:
				AtmLaneGetAtmAddressComplete(
							Status,
							pElan,
							pNdisRequest
							);
				break;

			case OID_ATM_LECS_ADDRESS:
				AtmLaneGetLecsIlmiComplete(
							Status,
							pElan,
							pNdisRequest
							);
				break;

			default:
				DBGP((0, "CoRequestComplete: pNdisReq %x, unknown Query Oid %x\n",
					 		pNdisRequest,
					 		pNdisRequest->DATA.QUERY_INFORMATION.Oid));
				ASSERT(FALSE);
				break;
		}
	}
	else
	{
		Oid = pNdisRequest->DATA.QUERY_INFORMATION.Oid;

		switch (Oid)
		{
			case OID_ATM_MY_IP_NM_ADDRESS:
				DBGP((3, "CoRequestComplete: IP addr: Status %x\n", Status));
				break;
			default:
				DBGP((0, "CoRequestComplete: pNdisReq %x, unknown Set Oid %x\n",
					 		pNdisRequest, Oid));
				ASSERT(FALSE);
				break;
		}
	}

	FREE_MEM(pNdisRequest);

	TRACEOUT(CoRequestCompleteHandler);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}



NDIS_STATUS
AtmLaneGetAtmAddress(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Send a request to the Call Manager to retrieve the ATM address
	registered with the switch on the given interface.

	This is called when the Call Manager tells us that there has been
	a change in its list of addresses registered with the switch.
	Normally, this happens when we start up our signalling stack (i.e.
	initial address registration), but it might happen during runtime,
	for example, if the link goes down and up, or we get physically
	connected to a different switch...

	In any case, we issue an NDIS Request to the Call Manager to retrieve
	the first address it has registered. Action then continues in
	AtmLaneGetAtmAddressComplete.

Arguments:

	pElan				- Elan structure for which this event occurred.

Return Value:

	None

--*/
{
	PNDIS_REQUEST				pNdisRequest;
	NDIS_HANDLE					NdisAfHandle;
	NDIS_HANDLE					NdisAdapterHandle;
	NDIS_STATUS					Status;

	PCO_ADDRESS_LIST			pAddressList;
	ULONG						RequestSize;

	TRACEIN(GetAtmAddress);

	DBGP((3, "GetAtmAddress: pElan %x\n", pElan));

	ACQUIRE_ELAN_LOCK(pElan);

	NdisAfHandle = pElan->NdisAfHandle;
	NdisAdapterHandle = pElan->NdisAdapterHandle;

	RELEASE_ELAN_LOCK(pElan);

	do
	{
		if (NULL == NdisAfHandle ||
			NULL == NdisAdapterHandle)
		{
			DBGP((0, "%d Aborting GetAtmAddress, Elan %x, AfH %x AdH %x\n",
					pElan->ElanNumber, pElan, NdisAfHandle, NdisAdapterHandle));

			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Allocate all that we need.
		//
		RequestSize = 	sizeof(NDIS_REQUEST) +
						sizeof(CO_ADDRESS_LIST) + 
						sizeof(CO_ADDRESS) + 
						sizeof(ATM_ADDRESS);
						
		ALLOC_MEM(&pNdisRequest, RequestSize);
	
		if ((PNDIS_REQUEST)NULL == pNdisRequest)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
		
		//
		//	Init request data
		//
		pAddressList = (PCO_ADDRESS_LIST)((PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST));

		NdisZeroMemory(pAddressList, sizeof(CO_ADDRESS_LIST));

		//
		//	Send off request
		//
		Status = AtmLaneSendNdisCoRequest(
						NdisAdapterHandle,
						NdisAfHandle,
						pNdisRequest,
						NdisRequestQueryInformation,
						OID_CO_GET_ADDRESSES,
						(PVOID)pAddressList,
						RequestSize - sizeof(NDIS_REQUEST)
						);

		if (NDIS_STATUS_PENDING != Status)
		{
			AtmLaneCoRequestCompleteHandler(
						Status,
						(NDIS_HANDLE)pElan,	// ProtocolAfContext
						NULL,				// Vc Context
						NULL,				// Party Context
						pNdisRequest
						);
		}

		
	} while (FALSE);

	TRACEOUT(GetAtmAddress);

	return Status;
}


VOID
AtmLaneGetAtmAddressComplete(
	IN	NDIS_STATUS					Status,
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_REQUEST				pNdisRequest
)
/*++

Routine Description:

	This is called when we have a reply to our previous call to
	NdisCoRequest(OID_CO_GET_ADDRESSES). If any addresses returned,
	copy the first for our address.

	If the address is different from the previous signal an event.
	
Arguments:

	Status					- result of the request
	pElan					- ATMLANE Elan on which the request was issued
	pNdisRequest			- the request itself. This will also contain the
							  returned address.

Return Value:

	None

--*/
{
	PCO_ADDRESS_LIST		pAddressList;
	ATM_ADDRESS UNALIGNED *	pAtmAddress;

	TRACEIN(GetAtmAddressComplete);

	DBGP((3, "GetAtmAddressComplete: pElan %x, Status %x\n",
			pElan, Status));

	if (NDIS_STATUS_SUCCESS == Status)
	{
		pAddressList = (PCO_ADDRESS_LIST)
						pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer;

		DBGP((3, "GetAtmAddressComplete: pElan %x, Count %d\n",
					pElan, pAddressList->NumberOfAddresses));

		if (pAddressList->NumberOfAddresses > 0)
		{
			//
			//  We have at least one address
			//
			ACQUIRE_ELAN_LOCK(pElan);

			//
			//	Mark AtmInterface "up"
			//
			pElan->AtmInterfaceUp = TRUE;

			pAtmAddress = (ATM_ADDRESS UNALIGNED *)(pAddressList->AddressList.Address);

			//
			//	See if address(without selector byte) differs from
			//	one we already have.  First time will differ as ATM
			//	address starts as all zeros.
			//
			
			if (!NdisEqualMemory(
					pElan->AtmAddress.Address,
					pAtmAddress->Address,
					ATM_ADDRESS_LENGTH-1))
			{

				//
				//	Copy in the new address
				//
				NdisMoveMemory(
						(PUCHAR)&(pElan->AtmAddress),
						(PUCHAR)pAtmAddress,
						sizeof(ATM_ADDRESS)
						);

				//
				//  Patch the selector byte with the Elan number.
				//
				pElan->AtmAddress.Address[ATM_ADDRESS_LENGTH-1] = 
								(UCHAR)(pElan->ElanNumber);

				DBGP((1, 
					"%d GetAtmAddressComplete: New ATMAddr %s\n",
					pElan->ElanNumber,
					AtmAddrToString(pElan->AtmAddress.Address)
					));
					
				AtmLaneQueueElanEventAfterDelay(pElan, ELAN_EVENT_NEW_ATM_ADDRESS, Status, 1*1000);
			}

			RELEASE_ELAN_LOCK(pElan);
		}
	}
	//
	//  else our request failed! Wait for another ADDRESS_CHANGE notification
	//

	TRACEOUT(GetAtmAddressComplete);

	return;
}

NDIS_STATUS
AtmLaneGetLecsIlmi(
	IN	PATMLANE_ELAN			pElan	LOCKIN	NOLOCKOUT
)
/*++

Routine Description:

	Send a request to the Call Manager to retrieve (using ILMI) 
	the ATM address	of the LECS.

	In any case, we issue an NDIS Request to the Call Manager to retrieve
	the address. Action	then continues in AtmLaneGetLecsIlmiComplete.

Arguments:

	pElan				- Elan structure for which this event occurred.

Return Value:

	None

--*/
{
	PNDIS_REQUEST				pNdisRequest;
	NDIS_HANDLE					NdisAfHandle;
	NDIS_HANDLE					NdisAdapterHandle;
	NDIS_STATUS					Status;

	PATM_ADDRESS				pAtmAddress;
	ULONG						RequestSize;

	TRACEIN(GetIlmiLecs);

	DBGP((3, "GetIlmiLecs: pElan %x\n", pElan));

	ACQUIRE_ELAN_LOCK(pElan);

	NdisAfHandle = pElan->NdisAfHandle;
	NdisAdapterHandle = pElan->NdisAdapterHandle;

	RELEASE_ELAN_LOCK(pElan);

	pNdisRequest = NULL;

	//
	//	Zero LecsAddress in Elan
	//
	NdisZeroMemory(&pElan->LecsAddress, sizeof(ATM_ADDRESS));

	do
	{
		//
		//  Allocate NDIS_REQUEST plus one ATM_ADDRESS
		//
		RequestSize =  sizeof(NDIS_REQUEST) + sizeof(ATM_ADDRESS);
		ALLOC_MEM(&pNdisRequest, RequestSize);
	
		if ((PNDIS_REQUEST)NULL == pNdisRequest)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
		
		//
		//	Init request data
		//
		pAtmAddress = (PATM_ADDRESS)((PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST));

		NdisZeroMemory(pAtmAddress, sizeof(ATM_ADDRESS));

		//
		//	Send off request
		//
		Status = AtmLaneSendNdisCoRequest(
						NdisAdapterHandle,
						NdisAfHandle,
						pNdisRequest,
						NdisRequestQueryInformation,
						OID_ATM_LECS_ADDRESS,
						(PVOID)pAtmAddress,
						RequestSize - sizeof(NDIS_REQUEST)
						);
	}
	while (FALSE);

	if ((NDIS_STATUS_PENDING != Status) &&
		(pNdisRequest != NULL))
	{
		AtmLaneCoRequestCompleteHandler(
					Status,
					(NDIS_HANDLE)pElan,	// ProtocolAfContext
					NULL,				// Vc Context
					NULL,				// Party Context
					pNdisRequest
					);
	}
		
	TRACEOUT(GetIlmiLecs);

	return Status;
}


VOID
AtmLaneGetLecsIlmiComplete(
	IN	NDIS_STATUS					Status,
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_REQUEST				pNdisRequest
)
/*++

Routine Description:

	This is called when we have a reply to our previous call to
	NdisCoRequest(OID_CO_GET_ADDRESSES). Check if we got any addresses
	back: if we did, store the address as our Local ATM Address, and
	if conditions are ripe, start registering ourselves with the ARP
	server.

	Since we allocated the NDIS request, free it here.

Arguments:

	Status					- result of the request
	pElan					- ATMLANE Elan on which the request was issued
	pNdisRequest			- the request itself. This will also contain the
							  returned address.

Return Value:

	None

--*/
{
	PATM_ADDRESS UNALIGNED *	pAtmAddress;

	TRACEIN(GetLecsIlmiComplete);


	ACQUIRE_ELAN_LOCK(pElan);

	if (NDIS_STATUS_SUCCESS == Status)
	{
		pAtmAddress = (PATM_ADDRESS UNALIGNED *)
						pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer;
		

		//
		//  We have the address. Copy it to elan run-time variable.
		//
		NdisMoveMemory(
				(PUCHAR)&(pElan->LecsAddress),
				(PUCHAR)pAtmAddress,
				sizeof(ATM_ADDRESS)
				);
				
		DBGP((1, "%d ILMI LECS Addr %s\n",
			pElan->ElanNumber,
			AtmAddrToString(pElan->LecsAddress.Address)
			));

		
	}
	else
	{
		DBGP((3, "%d OID_ATM_LECS_ADDRESS Failed %x\n",
				pElan->ElanNumber,
				Status));

	}
	
	AtmLaneQueueElanEvent(pElan, ELAN_EVENT_GOT_ILMI_LECS_ADDR, Status);
	
	RELEASE_ELAN_LOCK(pElan);
	
	TRACEOUT(HandleGetIlmiLecsComplete);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\debug.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	debug.c

Abstract:

	This file contains debugging support.
	
Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:


--*/

#include "precomp.h"

#include <stdarg.h>
#include <stdio.h>

#pragma hdrstop


#if DBG

ULONG			DbgVerbosity = 0;
#if DBG_TRACE
ULONG			DbgLogSize = 128*1024;
TRACELOG		TraceLog;
PUCHAR			pTraceLogSpace;
#endif
#include "oidstrng.h"
#include "irpstrng.h"

#define MAX_HD_LENGTH		128

VOID
DbgOut(ULONG Level, PUCHAR Message, ...)
	{
    char buf[DBG_OUTBUF_SIZE];
	va_list ap;
	LONG numchars;
	
	if (Level > DbgVerbosity)
    	return;

    va_start(ap, Message);
	
	numchars = _vsnprintf(buf, DBG_OUTBUF_SIZE, Message, ap);

	buf[DBG_OUTBUF_SIZE-1] = '\0';

	DbgPrint("ATMLANE: %s", buf);
}

//
//	Careful! Uses static storage for string
//
PUCHAR
UnicodeToString(PUNICODE_STRING unicodeString)
{
	static CHAR 	ansiStringBuffer[129];
	ANSI_STRING		ansiString;

	ansiString.Length = 0;
	ansiString.MaximumLength = 128;
	ansiString.Buffer = ansiStringBuffer;

	if (unicodeString->Length > 0)
	{
		NdisUnicodeStringToAnsiString(
   			&ansiString,
    		unicodeString);
    }

	ansiStringBuffer[ansiString.Length] = '\0';

	return ansiStringBuffer;
}


//
// Careful! Uses static storage for string.
//
PUCHAR
MacAddrToString(PVOID In)
    {
    static UCHAR String[20];
    static PUCHAR HexChars = "0123456789abcdef";
    PUCHAR EthAddr = (PUCHAR) In;
    UINT i;
    PUCHAR s;
    
    for (i = 0, s = String; i < 6; i++, EthAddr++)
        {
        *s++ = HexChars[(*EthAddr)>>4];
        *s++ = HexChars[(*EthAddr)&0xf];
        }
    *s = '\0';
    return String; 
    }

//
// Careful! Uses static storage for string.
//
PUCHAR
AtmAddrToString(PVOID In)
    {
    static UCHAR String[80];
    static PUCHAR HexChars = "0123456789abcdef";
    PUCHAR AtmAddr = (PUCHAR) In;
    UINT i;
    PUCHAR s = String;

    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 1
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 2
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 3
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 4
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 5
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 6
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 7
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 8
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 9
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 10
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 11
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 12
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 13
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 14
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 15
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 16
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 17
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 18
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 19
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 20
    *s = '\0';
    return String; 
    }

PUCHAR
OidToString(ULONG Oid)
	{
    struct _string_table *oidtab;
	
    
	for (oidtab = &oid_string_table[0]; oidtab->value != 0; oidtab++)
	    if (oidtab->value == Oid)
        	return oidtab->string;

	return oid_string_table[(sizeof(oid_string_table) / 
    	sizeof(struct _string_table)) - 1].string;
    }
    
PUCHAR
IrpToString(ULONG Irp)
	{
    struct _string_table *irptab;
	
    
	for (irptab = &irp_string_table[0]; irptab->value != 0xffffffff; irptab++)
	    if (irptab->value == Irp)
        	return irptab->string;

	return irp_string_table[(sizeof(irp_string_table) / 
    	sizeof(struct _string_table)) - 1].string;
    }

VOID
DbgPrintHexDump(
	IN	ULONG			Level,
	IN	PUCHAR			pBuffer,
	IN	ULONG			Length
)
/*++

Routine Description:

	Print a hex dump of the given contiguous buffer. If the length
	is too long, we truncate it.

Arguments:

	pBuffer			- Points to start of data to be dumped
	Length			- Length of above.

Return Value:

	None

--*/
{
	ULONG		i;

	if (Level > DbgVerbosity)
    	return;

	if (Length > MAX_HD_LENGTH)
	{
		Length = MAX_HD_LENGTH;
	}

	for (i = 0; i < Length; i++)
	{
		//
		//  Check if we are at the end of a line
		//
		if ((i > 0) && ((i & 0xf) == 0))
		{
			DbgPrint("\n");
		}

		//
		//  Print addr if we are at start of a new line
		//
		if ((i & 0xf) == 0)
		{
			DbgPrint("%08x ", pBuffer);
		}

		DbgPrint(" %02x", *pBuffer++);
	}

	//
	//  Terminate the last line.
	//
	if (Length > 0)
	{
		DbgPrint("\n");
	}
}

VOID
TraceLogWritePkt(
	IN	PTRACELOG		pTraceLog,
	IN	PNDIS_PACKET	pNdisPacket
)
{
	PNDIS_BUFFER	pBuffer[5] = {(PNDIS_BUFFER)NULL};

	do
	{
		pBuffer[0] = pNdisPacket->Private.Head;
		if (pBuffer[0] == (PNDIS_BUFFER)NULL)
			break;
		pBuffer[1] = pBuffer[0]->Next;
		if (pBuffer[1] == (PNDIS_BUFFER)NULL)
			break;
		pBuffer[2] = pBuffer[1]->Next;
		if (pBuffer[2] == (PNDIS_BUFFER)NULL)
			break;
		pBuffer[3] = pBuffer[2]->Next;
		if (pBuffer[3] == (PNDIS_BUFFER)NULL)
			break;
		pBuffer[4] = pBuffer[3]->Next;
	}
	while (FALSE);


	TraceLogWrite(
		pTraceLog, 
		TL_NDISPACKET,
		pNdisPacket,
		pNdisPacket->Private.PhysicalCount,
		pNdisPacket->Private.TotalLength,
		pBuffer[0],
		pBuffer[1],
		pBuffer[2],
		pBuffer[3],
		pBuffer[4]
		);
}		

#endif

#if DEBUG_SPIN_LOCK

ULONG				SpinLockInitDone = 0;
NDIS_SPIN_LOCK		LockLock;

VOID
AtmLaneAllocateSpinLock(
	IN	PATMLANE_LOCK		pLock,
	IN	PUCHAR				String,
	IN	PUCHAR				FileName,
	IN	ULONG				LineNumber
)
{
	DBGP((2, "ALLOCATE LOCK %x %s\n", pLock, String));
	
	if (SpinLockInitDone == 0)
	{

		SpinLockInitDone = 1;
		NdisAllocateSpinLock(&(LockLock));
	}

	NdisAcquireSpinLock(&(LockLock));
	pLock->Signature = ATMLANE_LOCK_SIG;
	NdisMoveMemory(pLock->TouchedByFileName, FileName, 32);
	pLock->TouchedByFileName[31] = 0x0;
	pLock->TouchedInLineNumber = LineNumber;
	pLock->IsAcquired = 0;
	pLock->OwnerThread = 0;
	NdisAllocateSpinLock(&(pLock->NdisLock));
	NdisReleaseSpinLock(&(LockLock));
}

VOID
AtmLaneFreeSpinLock(
	IN	PATMLANE_LOCK		pLock,
	IN	PUCHAR				String,
	IN	PUCHAR				FileName,
	IN	ULONG				LineNumber
)
{
	DBGP((2, "FREE LOCK %x %s\n", pLock, String));

	NdisFreeSpinLock(pLock);
}

VOID
AtmLaneAcquireSpinLock(
	IN	PATMLANE_LOCK		pLock,
	IN	PUCHAR				String,
	IN	PUCHAR				FileName,
	IN	ULONG				LineNumber
)
{
	PKTHREAD		pThread;

	DBGP((4, "ACQUIRE LOCK %x %s\n", pLock, String));

	pThread = KeGetCurrentThread();
	NdisAcquireSpinLock(&(LockLock));
	if (pLock->Signature != ATMLANE_LOCK_SIG)
	{
		DbgPrint("Trying to acquire uninited lock %x, File %s, Line %d\n",
				pLock, FileName, LineNumber);
		DbgBreakPoint();
	}

	if (pLock->IsAcquired != 0)
	{
		if (pLock->OwnerThread == pThread)
		{
			DbgPrint("Detected multiple locking!: pLock %x, File %s, Line %d\n",
				pLock, FileName, LineNumber);
			DbgPrint("pLock %x already acquired in File %s, Line %d\n",
				pLock, 
				pLock->TouchedByFileName, 
				pLock->TouchedInLineNumber);
			DbgBreakPoint();
		}
	}

	//
	//  Mark this lock.
	//
	pLock->IsAcquired++;

	NdisReleaseSpinLock(&(LockLock));
	NdisAcquireSpinLock(&(pLock->NdisLock));

	pLock->OwnerThread = pThread;
	NdisMoveMemory(pLock->TouchedByFileName, FileName, LOCK_FILE_NAME_LEN);
	pLock->TouchedByFileName[LOCK_FILE_NAME_LEN - 1] = 0x0;
	pLock->TouchedInLineNumber = LineNumber;

}


VOID
AtmLaneReleaseSpinLock(
	IN	PATMLANE_LOCK		pLock,
	IN	PUCHAR				String,
	IN	PUCHAR				FileName,
	IN	ULONG				LineNumber
)
{
	DBGP((4, "RELEASE LOCK %x %s\n", pLock, String));

	NdisAcquireSpinLock(&(LockLock));
	if (pLock->Signature != ATMLANE_LOCK_SIG)
	{
		DbgPrint("Trying to release uninited lock %x, File %s, Line %d\n",
				pLock,
				FileName,
				LineNumber);
		DbgBreakPoint();
	}

	if (pLock->IsAcquired == 0)
	{
		DbgPrint("Detected release of unacquired lock %x, File %s, Line %d\n",
				pLock,
				FileName,
				LineNumber);
		DbgBreakPoint();
	}

	NdisMoveMemory(pLock->TouchedByFileName, FileName, LOCK_FILE_NAME_LEN);
	pLock->TouchedByFileName[LOCK_FILE_NAME_LEN - 1] = 0x0;
	pLock->TouchedInLineNumber = LineNumber;
	pLock->IsAcquired--;
	pLock->OwnerThread = 0;
	NdisReleaseSpinLock(&(LockLock));

	NdisReleaseSpinLock(&(pLock->NdisLock));
}
#endif // DEBUG_SPIN_LOCK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\exe\atmlane.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	atmlane.c

Abstract:

	ATM LAN Emulation Client Admin Utility.

	Usage:

		atmlane 

Revision History:

	Who			When		What
	--------	--------	---------------------------------------------
	v-lcleet	02-03-98	Created

Notes:

	Modelled after atmadm utility from the UNI 3.1 Call Manager

--*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <ctype.h>
#include <malloc.h>
#include <time.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <winerror.h>
#include <winsock.h>

#ifndef NDIS_STATUS
#define NDIS_STATUS		ULONG
#endif

#include "laneinfo.h"
#include "atmmsg.h"


//
//	Private types
//
typedef struct {
	DWORD				Message;
	LPSTR				String;
} MESSAGE_STRING, *PMESSAGE_STRING;

#define MSG_NO_MESSAGE			0

#define MAX_ATMLANE_ADAPTERS	64
#define MAX_ATMLANE_ELANS		64
#define MAX_ATMLANE_NAME_LEN	256
#define MAX_ATMLANE_ARP_ENTRIES	4096
#define MAX_ATMLANE_CONNECTIONS	4096

//
//	Globals
//
CHAR							DefaultDeviceName[] = "\\\\.\\AtmLane";
CHAR							*pDeviceName = DefaultDeviceName;

//
//  Data structures to store list of adapters:
//
#define ADAPTER_LIST_BUFFER_SIZE	(sizeof(ATMLANE_ADAPTER_LIST) + \
									(MAX_ATMLANE_ADAPTERS * \
			 (sizeof(UNICODE_STRING) + (MAX_ATMLANE_NAME_LEN * sizeof(WCHAR)))))

UCHAR							AdapterListBuffer[ADAPTER_LIST_BUFFER_SIZE];
PATMLANE_ADAPTER_LIST			pAdapterList = (PATMLANE_ADAPTER_LIST)AdapterListBuffer;


//
//	Data structures to store list of ELANS on an adapter:
//
#define ELAN_LIST_BUFFER_SIZE		(sizeof(ATMLANE_ELAN_LIST) + \
									(MAX_ATMLANE_ELANS * \
			(sizeof(UNICODE_STRING) + (MAX_ATMLANE_NAME_LEN * sizeof(WCHAR)))))

UCHAR							ElanListBuffer[ELAN_LIST_BUFFER_SIZE];
PATMLANE_ELAN_LIST				pElanList = (PATMLANE_ELAN_LIST)ElanListBuffer;


//
//	Data structure to hold ELAN information
//
#define ELAN_INFO_BUFFER_SIZE		(sizeof(ATMLANE_ELANINFO) + \
			((sizeof(UNICODE_STRING) + (MAX_ATMLANE_NAME_LEN * sizeof(WCHAR))) * 2))

UCHAR							ElanInfoBuffer[ELAN_INFO_BUFFER_SIZE];
PATMLANE_ELANINFO				pElanInfo = (PATMLANE_ELANINFO)ElanInfoBuffer;


//
//	Data structure to hold an ELAN's ARP table
//
#define ARP_TABLE_BUFFER_SIZE		(sizeof(ATMLANE_ARPTABLE) + \
			((sizeof(ATMLANE_ARPENTRY) * MAX_ATMLANE_ARP_ENTRIES)))

UCHAR							ArpTableBuffer[ARP_TABLE_BUFFER_SIZE];
PATMLANE_ARPTABLE				pArpTable = (PATMLANE_ARPTABLE)ArpTableBuffer;


//
//	Data structure to hold an ELAN's connection table
//
#define CONN_TABLE_BUFFER_SIZE		(sizeof(ATMLANE_CONNECTTABLE) + \
			((sizeof(ATMLANE_CONNECTENTRY) * MAX_ATMLANE_CONNECTIONS)))

UCHAR							ConnTableBuffer[CONN_TABLE_BUFFER_SIZE];
PATMLANE_CONNECTTABLE			pConnTable = (PATMLANE_CONNECTTABLE)ConnTableBuffer;


//
//	Internationalizable message strings loaded by this module.  If we fail
//	to load, default to English language strings.
//
MESSAGE_STRING ElanState[] = {
	MSG_ELAN_STATE_UNKNOWN,					TEXT(" ? "),
	MSG_ELAN_STATE_INIT,					TEXT("INITIAL"),
	MSG_ELAN_STATE_LECS_CONNECT_ILMI,		TEXT("LECS CONNECT ILMI"),
	MSG_ELAN_STATE_LECS_CONNECT_WKA,		TEXT("LECS CONNECT WKA"),
	MSG_ELAN_STATE_LECS_CONNECT_PVC,		TEXT("LECS CONNECT PVC"),
	MSG_ELAN_STATE_LECS_CONNECT_CFG,		TEXT("LECS CONNECT CFG"),
	MSG_ELAN_STATE_CONFIGURE,				TEXT("CONFIGURE"),
	MSG_ELAN_STATE_LES_CONNECT,				TEXT("LES CONNECT"),
	MSG_ELAN_STATE_JOIN,					TEXT("JOIN"),
	MSG_ELAN_STATE_BUS_CONNECT,				TEXT("BUS CONNECT"),
	MSG_ELAN_STATE_OPERATIONAL,				TEXT("OPERATIONAL"),
	MSG_ELAN_STATE_SHUTDOWN,				TEXT("SHUTDOWN")
};

#define NUMBER_OF_ELAN_STATES	(sizeof(ElanState)/sizeof(ElanState[0]))

MESSAGE_STRING LanType[] = {
	MSG_LANTYPE_UNKNOWN,					TEXT(" ? "),
	MSG_LANTYPE_UNSPECIFIED,				TEXT("Unspecified"),
	MSG_LANTYPE_ETHERNET,					TEXT("Ethernet/802.3"),
	MSG_LANTYPE_TOKENRING,					TEXT("Token Ring/802.5")
};

#define NUMBER_OF_LAN_TYPES	(sizeof(LanType)/sizeof(LanType[0]))

MESSAGE_STRING VcType[] = {
	MSG_VCTYPE_UNKNOWN,						TEXT(" ? "),
	MSG_VCTYPE_DATA_DIRECT,					TEXT("DataDirect"),
	MSG_VCTYPE_CONFIG_DIRECT,				TEXT("ConfigDirect"),
	MSG_VCTYPE_CONTROL_DIRECT,				TEXT("CtrlDirect"),
	MSG_VCTYPE_CONTROL_DISTRIBUTE,			TEXT("+ CtrlDistr"),
	MSG_VCTYPE_MULTI_SEND,					TEXT("McastSend"),
	MSG_VCTYPE_MULTI_FORWARD,				TEXT("+ McastFwd")
};

#define NUMBER_OF_VC_TYPES	(sizeof(VcType)/sizeof(VcType[0]))

MESSAGE_STRING McastSendVcType[] = {
	MSG_MCAST_VCTYPE_UNKNOWN,				TEXT(" ? "),
	MSG_MCAST_VCTYPE_BESTEFFORT,			TEXT("Best Effort"),
	MSG_MCAST_VCTYPE_VARIABLE,				TEXT("Variable"),
	MSG_MCAST_VCTYPE_VARIABLE,				TEXT("Constant"),
};

#define NUMBER_OF_MCAST_VC_TYPES	(sizeof(McastSendVcType)/sizeof(McastSendVcType[0]))

MESSAGE_STRING Misc[] = {
	MSG_NONE,								TEXT("None"),
	MSG_OFF,								TEXT("Off"),
	MSG_ON,									TEXT("On"),
	MSG_UNSPECIFIED,						TEXT("Unspecified"),
	MSG_NOCONNECT,							TEXT("<no connection>")
};

#define NUMBER_OF_MISC 	(sizeof(Misc)/sizeof(Misc[0]))

MESSAGE_STRING ConnType[] = {
	MSG_CONNTYPE_PEER,						TEXT("PEER"),
	MSG_CONNTYPE_LECS,						TEXT("LECS"),
	MSG_CONNTYPE_LES,						TEXT("LES "),
	MSG_CONNTYPE_BUS,						TEXT("BUS ")
};

#define NUMBER_OF_CONN_TYPES 	(sizeof(ConnType)/sizeof(ConnType[0]))

//
//  LoadMessageTable
//
//  Loads internationalizable strings into a table, replacing the default for
//  each. If an error occurs, the English language default is left in place.
//
//
VOID
LoadMessageTable(
	PMESSAGE_STRING	Table,
	UINT MessageCount
)
{
    LPTSTR string;
    DWORD count;

    //
    // for all messages in a MESSAGE_STRING table, load the string from this
    // module, replacing the default string in the table (only there in case
    // we get an error while loading the string, so we at least have English
    // to fall back on)
    //

    while (MessageCount--) {
        if (Table->Message != MSG_NO_MESSAGE) {

            //
            // we really want LoadString here, but LoadString doesn't indicate
            // how big the string is, so it doesn't give us an opportunity to
            // allocate exactly the right buffer size. FormatMessage does the
            // right thing
            //

            count = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                                  | FORMAT_MESSAGE_FROM_HMODULE,
                                  NULL, // use default hModule
                                  Table->Message,
                                  0,    // use default language
                                  (LPTSTR)&string,
                                  0,    // minimum size to allocate
                                  NULL  // no arguments for inclusion in strings
                                  );
            if (count) {

                //
                // Format message returned the string: replace the English
                // language default
                //

                Table->String = string;
            } else {

                //
                // this is ok if there is no string (e.g. just %0) in the .mc
                // file
                //

                Table->String = TEXT("");
            }
        }
        ++Table;
    }
}


//
//  LoadMessages - courtesy IPCONFIG
//
//  Loads all internationalizable messages into the various tables
//
VOID
LoadMessages(
)
{
	LoadMessageTable(ElanState, 		NUMBER_OF_ELAN_STATES);
	LoadMessageTable(LanType, 			NUMBER_OF_LAN_TYPES);
	LoadMessageTable(VcType, 			NUMBER_OF_VC_TYPES);
	LoadMessageTable(McastSendVcType, 	NUMBER_OF_MCAST_VC_TYPES);
	LoadMessageTable(Misc,				NUMBER_OF_MISC);
	LoadMessageTable(ConnType,			NUMBER_OF_CONN_TYPES);
}

VOID
DisplayMessage(
	IN	BOOLEAN			Tabbed,
	IN	DWORD			MessageId,
	...
)
{
	va_list		pArg;
	CHAR		MessageBuffer[2048];
	INT			Count;

	va_start(pArg, MessageId);

	Count = FormatMessage(
				FORMAT_MESSAGE_FROM_HMODULE,
				NULL,				// default hModule
				MessageId,
				0,					// default language
				MessageBuffer,
				sizeof(MessageBuffer),
				&pArg
				);

	va_end(pArg);

	if (Tabbed)
	{
		putchar('\t');
	}

	printf(MessageBuffer);
}

HANDLE
OpenDevice(
	CHAR	*pDeviceName
)
{
	DWORD	DesiredAccess;
	DWORD	ShareMode;
	LPSECURITY_ATTRIBUTES	lpSecurityAttributes = NULL;

	DWORD	CreationDistribution;
	DWORD	FlagsAndAttributes;
	HANDLE	TemplateFile;
	HANDLE	Handle;

	DesiredAccess = GENERIC_READ|GENERIC_WRITE;
	ShareMode = 0;
	CreationDistribution = OPEN_EXISTING;
	FlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
	TemplateFile = (HANDLE)INVALID_HANDLE_VALUE;

	Handle = CreateFile(
				pDeviceName,
				DesiredAccess,
				ShareMode,
				lpSecurityAttributes,
				CreationDistribution,
				FlagsAndAttributes,
				TemplateFile
			);

	return (Handle);
}


VOID
CloseDevice(
	HANDLE		DeviceHandle
)
{
	CloseHandle(DeviceHandle);
}

BOOLEAN
CheckVersion(
	HANDLE		DeviceHandle
)
{
	ULONG						Version;
	ULONG						BytesReturned;

	if (!DeviceIoControl(
				DeviceHandle,
				ATMLANE_IOCTL_GET_INFO_VERSION,
				(PVOID)&Version,
				sizeof(Version),
				(PVOID)&Version,
				sizeof(Version),
				&BytesReturned,
				0))
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_VERSION_INFO);
		return FALSE;
	}	

	if (Version != ATMLANE_INFO_VERSION)
	{
		DisplayMessage(FALSE, MSG_ERROR_INVALID_INFO_VERSION);
		return FALSE;
	}

	return TRUE;
}

BOOLEAN
GetAdapterList(
	HANDLE		DeviceHandle
)
{
	ULONG		BytesReturned;
	BOOLEAN		Result = FALSE;

	if (DeviceIoControl(
				DeviceHandle,
				ATMLANE_IOCTL_ENUM_ADAPTERS,
				(PVOID)pAdapterList,
				ADAPTER_LIST_BUFFER_SIZE,
				(PVOID)pAdapterList,
				ADAPTER_LIST_BUFFER_SIZE,
				&BytesReturned,
				0))
	{
		Result = TRUE;
	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_ADAPTER_LIST);
	}

	return Result;
}


BOOLEAN
GetElanList(
	HANDLE				DeviceHandle,
	PUNICODE_STRING		pAdapterName
)
{
	ULONG				BytesReturned;
	BOOLEAN				Result = FALSE;

	//
	// Copy adapter name in to buffer as input
	//
	memcpy(pElanList, pAdapterName, sizeof(UNICODE_STRING)+pAdapterName->Length);

	if (DeviceIoControl(
				DeviceHandle,
				ATMLANE_IOCTL_ENUM_ELANS,
				(PVOID)pElanList,
				sizeof(UNICODE_STRING)+pAdapterName->Length,
				(PVOID)pElanList,
				ELAN_LIST_BUFFER_SIZE,
				&BytesReturned,
				0))
	{
		Result = TRUE;
	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_ELAN_LIST);
	}

	return Result;
}



BOOLEAN
GetElanInfo(
	HANDLE				DeviceHandle,
	PUNICODE_STRING		pAdapterName,
	PUNICODE_STRING		pElanName
)
{
	ULONG				BytesReturned;
	BOOLEAN				Result = FALSE;

	//
	//	copy adapter name into buffer as input
	//
	memcpy(ElanInfoBuffer, pAdapterName, sizeof(UNICODE_STRING)+pAdapterName->Length);

	//
	//	copy elan name in to buffer as input
	//
	memcpy(ElanInfoBuffer + sizeof(UNICODE_STRING)+pAdapterName->Length, pElanName,
		sizeof(UNICODE_STRING)+pElanName->Length);
	
	if (DeviceIoControl(
				DeviceHandle,
				ATMLANE_IOCTL_GET_ELAN_INFO,
				(PVOID)pElanInfo,
				sizeof(UNICODE_STRING)+pAdapterName->Length + 
					sizeof(UNICODE_STRING)+pElanName->Length,
				(PVOID)pElanInfo,
				ELAN_INFO_BUFFER_SIZE,
				&BytesReturned,
				0))
	{
		Result = TRUE;
	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_ELAN_INFO);
	}

	return Result;
}

BOOLEAN
GetElanArpTable(
	HANDLE				DeviceHandle,
	PUNICODE_STRING		pAdapterName,
	PUNICODE_STRING		pElanName
)
{
	ULONG				BytesReturned;
	BOOLEAN				Result = FALSE;
	
	//
	//	copy adapter name into buffer as input
	//
	memcpy(ArpTableBuffer, pAdapterName, sizeof(UNICODE_STRING)+pAdapterName->Length);

	//
	//	copy elan name in to buffer as input
	//
	memcpy(ArpTableBuffer + sizeof(UNICODE_STRING)+pAdapterName->Length, pElanName,
		sizeof(UNICODE_STRING)+pElanName->Length);
	
	if (DeviceIoControl(
				DeviceHandle,
				ATMLANE_IOCTL_GET_ELAN_ARP_TABLE,
				(PVOID)pArpTable,
				sizeof(UNICODE_STRING)+pAdapterName->Length + 
					sizeof(UNICODE_STRING)+pElanName->Length,
				(PVOID)pArpTable,
				ARP_TABLE_BUFFER_SIZE,
				&BytesReturned,
				0))
	{
		Result = TRUE;
	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_ELAN_ARP_TABLE);
	}

	return Result;
}

BOOLEAN
GetElanConnTable(
	HANDLE				DeviceHandle,
	PUNICODE_STRING		pAdapterName,
	PUNICODE_STRING		pElanName
)
{
	ULONG				BytesReturned;
	BOOLEAN				Result = FALSE;
	
	//
	//	copy adapter name into buffer as input
	//
	memcpy(ConnTableBuffer, pAdapterName, sizeof(UNICODE_STRING)+pAdapterName->Length);

	//
	//	copy elan name in to buffer as input
	//
	memcpy(ConnTableBuffer + sizeof(UNICODE_STRING)+pAdapterName->Length, pElanName,
		sizeof(UNICODE_STRING)+pElanName->Length);
	
	if (DeviceIoControl(
				DeviceHandle,
				ATMLANE_IOCTL_GET_ELAN_CONNECT_TABLE,
				(PVOID)pConnTable,
				sizeof(UNICODE_STRING)+pAdapterName->Length + 
					sizeof(UNICODE_STRING)+pElanName->Length,
				(PVOID)pConnTable,
				CONN_TABLE_BUFFER_SIZE,
				&BytesReturned,
				0))
	{
		Result = TRUE;
	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_ELAN_CONN_TABLE);
	}

	return Result;
}


LPSTR
ElanStateToString(ULONG In)
{
	switch(In)
	{
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
			return (ElanState[In].String);
		default:
			return (ElanState[0].String);
	}
}


LPSTR
ElanLanTypeToString(ULONG In)
{
	switch(In)
	{
		case 0:
			return LanType[1].String;
		case 1:
			return LanType[2].String;
		case 2:
			return LanType[3].String;
		default:
			return LanType[0].String;
	}
}

LPSTR
ElanMaxFrameSizeToString(ULONG In)
{
	switch(In)
	{	
		case 0:
			return Misc[3].String;
		case 1:
			return "1516";
		case 2:
			return "4544";
		case 3:
			return "9234";
		case 4:
			return "18190";
		default:
			return " ? ";
	}
}

LPSTR
McastVcTypeToString(ULONG In)
{
	switch(In)
	{	
		case 0:
			return McastSendVcType[1].String;
		case 1:
			return McastSendVcType[2].String;
		case 2:
			return McastSendVcType[3].String;
		default:
			return McastSendVcType[0].String;
	}
}

PUCHAR
MacAddrToString(PVOID In)
    {
    static UCHAR String[20];
    static PUCHAR HexChars = "0123456789abcdef";
    PUCHAR EthAddr = (PUCHAR) In;
    UINT i;
    PUCHAR s;
    
    for (i = 0, s = String; i < 6; i++, EthAddr++)
        {
        *s++ = HexChars[(*EthAddr)>>4];
        *s++ = HexChars[(*EthAddr)&0xf];
        *s++ = '.';
        }
    *(--s) = '\0';
    return String; 
    }


PUCHAR
AtmAddrToString(PVOID In)
    {
    static UCHAR String[80];
    static PUCHAR HexChars = "0123456789abcdef";
    PUCHAR AtmAddr = (PUCHAR) In;
    UINT i;
    PUCHAR s = String;

    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 1
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 2
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 3
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 4
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 5
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 6
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 7
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 8
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 9
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 10
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 11
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 12
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 13
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 14
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 15
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 16
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 17
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 18
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 19
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 20
    *s = '\0';
    return String; 
    }


VOID
DisplayElanInfo(
	VOID
)
{
	DisplayMessage(FALSE, MSG_ELAN_NUMBER, 	pElanInfo->ElanNumber);
	DisplayMessage(FALSE, MSG_ELAN_STATE,  	ElanStateToString(pElanInfo->ElanState));
	DisplayMessage(FALSE, MSG_C1,  			AtmAddrToString(&pElanInfo->AtmAddress));
	DisplayMessage(FALSE, MSG_C2,  			ElanLanTypeToString(pElanInfo->LanType));
	DisplayMessage(FALSE, MSG_C3,  			ElanMaxFrameSizeToString(pElanInfo->MaxFrameSizeCode));
	DisplayMessage(FALSE, MSG_C4,  			Misc[1].String); // always off
	if (pElanInfo->ElanName[0] == '\0')
	{
		DisplayMessage(FALSE, MSG_C5,  		Misc[3].String); // unspecified
	}
	else
	{
		DisplayMessage(FALSE, MSG_C5,  		pElanInfo->ElanName);
	}
	DisplayMessage(FALSE, MSG_C6,  			MacAddrToString(&pElanInfo->MacAddress));
	DisplayMessage(FALSE, MSG_C7,  			pElanInfo->ControlTimeout);
	DisplayMessage(FALSE, MSG_C8,  			Misc[0].String);
	DisplayMessage(FALSE, MSG_LECS_ADDR,  	AtmAddrToString(&pElanInfo->LecsAddress));
	DisplayMessage(FALSE, MSG_C9,  			AtmAddrToString(&pElanInfo->LesAddress));
	DisplayMessage(FALSE, MSG_BUS_ADDR,  	AtmAddrToString(&pElanInfo->BusAddress));
	DisplayMessage(FALSE, MSG_C10,  		pElanInfo->MaxUnkFrameCount);
	DisplayMessage(FALSE, MSG_C11,  		pElanInfo->MaxUnkFrameTime);
	DisplayMessage(FALSE, MSG_C12,  		pElanInfo->VccTimeout);
	DisplayMessage(FALSE, MSG_C13,  		pElanInfo->MaxRetryCount);
	DisplayMessage(FALSE, MSG_C14,  		pElanInfo->LecId);
	DisplayMessage(FALSE, MSG_C15);
	DisplayMessage(FALSE, MSG_C16);
	DisplayMessage(FALSE, MSG_C17,  		pElanInfo->AgingTime);
	DisplayMessage(FALSE, MSG_C18,  		pElanInfo->ForwardDelayTime);
	DisplayMessage(FALSE, MSG_C19,  		pElanInfo->TopologyChange==0?Misc[1].String:Misc[2].String);
	DisplayMessage(FALSE, MSG_C20,  		pElanInfo->ArpResponseTime);
	DisplayMessage(FALSE, MSG_C21,  		pElanInfo->FlushTimeout);
	DisplayMessage(FALSE, MSG_C22,  		pElanInfo->PathSwitchingDelay);
	DisplayMessage(FALSE, MSG_C23,  		pElanInfo->LocalSegmentId);
	DisplayMessage(FALSE, MSG_C24,  		McastVcTypeToString(pElanInfo->McastSendVcType));
	DisplayMessage(FALSE, MSG_C25,  		pElanInfo->McastSendVcAvgRate);
	DisplayMessage(FALSE, MSG_C26,  		pElanInfo->McastSendVcPeakRate);
	DisplayMessage(FALSE, MSG_C27,  		Misc[0].String);
	DisplayMessage(FALSE, MSG_C28,  		pElanInfo->ConnComplTimer);
}


VOID
DisplayElanArpTable(
	VOID
)
{
	PATMLANE_ARPENTRY	pArpEntry;
	ULONG 				i;
	
	DisplayMessage(FALSE, MSG_C16_LE_ARP_CACHE);

	pArpEntry = (PATMLANE_ARPENTRY) (ArpTableBuffer + sizeof(ATMLANE_ARPTABLE));
	for (i = 0; i < pArpTable->ArpEntriesReturned; i++)
	{
		DisplayMessage(FALSE, MSG_ARP_ENTRY,
			MacAddrToString(pArpEntry->MacAddress),
			AtmAddrToString(pArpEntry->AtmAddress));
		pArpEntry++;
	}

}



VOID
DisplayElanConnTable(
	VOID
)
{
	PATMLANE_CONNECTENTRY	pConnEntry;
	ULONG 					i;

	DisplayMessage(FALSE, MSG_CONN_CACHE);
	
	pConnEntry = (PATMLANE_CONNECTENTRY) (ConnTableBuffer + sizeof(ATMLANE_CONNECTTABLE));
	for (i = 0; i < pConnTable->ConnectEntriesReturned; i++)
	{
		switch (pConnEntry->Type)
		{

			default:
			case 0: // peer
				DisplayMessage(FALSE, MSG_CONN_ENTRY,
					ConnType[0].String, 
					AtmAddrToString(pConnEntry->AtmAddress),
					pConnEntry->Vc?VcType[1].String:Misc[4].String,
					TEXT(""));
				break;
					
			case 1: // lecs
				DisplayMessage(FALSE, MSG_CONN_ENTRY,
					ConnType[1].String, 
					AtmAddrToString(pConnEntry->AtmAddress),
					pConnEntry->Vc?VcType[2].String:Misc[4].String,
					TEXT(""));
				break;

			case 2: // les
				DisplayMessage(FALSE, MSG_CONN_ENTRY,
					ConnType[2].String, 
					AtmAddrToString(pConnEntry->AtmAddress),
					pConnEntry->Vc?VcType[3].String:Misc[4].String,
					pConnEntry->VcIncoming?VcType[4].String:TEXT(""));
				break;

			case 3: // bus
				DisplayMessage(FALSE, MSG_CONN_ENTRY,
					ConnType[3].String, 
					AtmAddrToString(pConnEntry->AtmAddress),
					pConnEntry->Vc?VcType[5].String:Misc[4].String,
					pConnEntry->VcIncoming?VcType[6].String:TEXT(""));
				break;
		}
		
		pConnEntry++;
	}
}

	
VOID __cdecl
main(
	INT			argc,
	CHAR		*argv[]
)
{
	HANDLE	DeviceHandle;
	PUNICODE_STRING				pAdapterName;
	PUNICODE_STRING				pElanName;
	ULONG						i, j;
	BOOLEAN						Result;
	
	DisplayMessage(FALSE, MSG_ATMLANE_BANNER);

	DeviceHandle = OpenDevice(pDeviceName);
	if (DeviceHandle == INVALID_HANDLE_VALUE)
	{
		DisplayMessage(FALSE, MSG_ERROR_OPENING_DEVICE);
		return;
	}

	//
	//	First check the version
	//
	if (!CheckVersion(DeviceHandle))
	{
		CloseDevice(DeviceHandle);
		return;
	}

	//
	//	First get the list of available adapters
	//
	if (!GetAdapterList(DeviceHandle))
	{
		CloseDevice(DeviceHandle);
		return;
	}

	//
	//	Loop thru the adapters getting each adapter's elan list
	//
	pAdapterName = &pAdapterList->AdapterList;
	for (i = 0; i < pAdapterList->AdapterCountReturned; i++)
	{
		DisplayMessage(FALSE, MSG_ADAPTER, 
			(PWSTR)((PUCHAR)pAdapterName + sizeof(UNICODE_STRING)));

		if (GetElanList(DeviceHandle, pAdapterName))
		{

			//
			//	Loop thru the elan list getting ELAN info
			//
			pElanName = &pElanList->ElanList;
			for (j = 0; j < pElanList->ElanCountReturned; j++)
			{
				DisplayMessage(FALSE, MSG_ELAN, 
					(PWSTR)((PUCHAR)pElanName + sizeof(UNICODE_STRING)));

				if (GetElanInfo(DeviceHandle, pAdapterName, pElanName))
				{
					DisplayElanInfo();
				}

				if (GetElanArpTable(DeviceHandle, pAdapterName, pElanName))
				{
					DisplayElanArpTable();
				}

				if (GetElanConnTable(DeviceHandle, pAdapterName, pElanName))
				{
					DisplayElanConnTable();
				}

				//
				//	next elan
				//
				pElanName = (PUNICODE_STRING)((PUCHAR)pElanName +
						sizeof(UNICODE_STRING) + pElanName->Length);
			}

		}

		//
		//	next adapter
		//
		pAdapterName = (PUNICODE_STRING)((PUCHAR)pAdapterName +
				sizeof(UNICODE_STRING) + pAdapterName->Length);
	}

	CloseDevice(DeviceHandle);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\atmlane.h ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	atmlane.h

Abstract:

Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:

--*/

#ifndef	__ATMLANE_ATMLANE_H
#define __ATMLANE_ATMLANE_H

//
//	Configuration defaults and stuff
//
#define DEF_HEADER_BUF_SIZE				LANE_HEADERSIZE

#define DEF_HDRBUF_GROW_SIZE			50	// these used for packet pad buffers also
#define DEF_MAX_HEADER_BUFS				300

#define DEF_PROTOCOL_BUF_SIZE			sizeof(LANE_CONTROL_FRAME)
#define DEF_MAX_PROTOCOL_BUFS			100

#define MCAST_LIST_SIZE					32

#define FAST_VC_TIMEOUT					30  // seconds

// 
//	The registry parameter strings
//
#define ATMLANE_LINKNAME_STRING			L"\\DosDevices\\AtmLane"
#define ATMLANE_NTDEVICE_STRING			L"\\Device\\AtmLane"
#define ATMLANE_PROTOCOL_STRING			L"AtmLane"
#define ATMLANE_USELECS_STRING 			L"UseLecs"
#define	ATMLANE_DISCOVERLECS_STRING		L"DiscoverLecs"
#define	ATMLANE_LECSADDR_STRING			L"LecsAddr"
#define ATMLANE_ELANLIST_STRING			L"ElanList"
#define ATMLANE_DEVICE_STRING			L"Device"
#define ATMLANE_ELANNAME_STRING			L"ElanName"
#define	ATMLANE_LANTYPE_STRING			L"LanType"
#define	ATMLANE_MAXFRAMESIZE_STRING		L"MaxFrameSizeCode"
#define	ATMLANE_MACADDR_STRING			L"MacAddr"
#define	ATMLANE_LESADDR_STRING			L"LesAddr"
#define ATMLANE_HEADERBUFSIZE_STRING	L"HeaderBufSize"
#define ATMLANE_MAXHEADERBUFS_STRING	L"MaxHeaderBufs"
#define ATMLANE_MAXPROTOCOLBUFS_STRING	L"MaxProtocolBufs"
#define ATMLANE_UPPERBINDINGS_STRING    L"UpperBindings"
#define ATMLANE_DATADIRECTPCR_STRING	L"DataDirectPCR"

//
//	MAC table size 
//	Current sized at 256.
//	Hash function currently uses byte 5 of MAC Address as index.
//	Some research at Digital has shown it to be the best byte to use.
//
#define ATMLANE_MAC_TABLE_SIZE			256


//
//	Some misc defaults
//
#define ATMLANE_DEF_MAX_AAL5_PDU_SIZE	((64*1024)-1)

//
//  Timer configuration.
//
#define ALT_MAX_TIMER_SHORT_DURATION            60      // Seconds
#define ALT_MAX_TIMER_LONG_DURATION         (30*60)     // Seconds

#define ALT_SHORT_DURATION_TIMER_PERIOD			 1		// Second
#define ALT_LONG_DURATION_TIMER_PERIOD			10		// Seconds


//
//	Foward References
//
struct _ATMLANE_VC;
struct _ATMLANE_ATM_ENTRY;
struct _ATMLANE_ELAN;
struct _ATMLANE_ADAPTER;


//
//	Blocking data structure.
//
typedef struct _ATMLANE_BLOCK
{
	NDIS_EVENT			Event;
	NDIS_STATUS			Status;

} ATMLANE_BLOCK, *PATMLANE_BLOCK;


//
//	The following object is a convenient way to 
//	store and access an IEEE 48-bit MAC address.
//
typedef struct _MAC_ADDRESS
{
	UCHAR	Byte[6];
}
	MAC_ADDRESS,
	*PMAC_ADDRESS;
	

//
//	Packet context data in ProtocolReserved area of 
//	NDIS Packet header owned by ATMLANE.
//
typedef struct _SEND_PACKET_RESERVED
{
#if DBG
	ULONG						Signature;
	PNDIS_PACKET				pNextInSendList;
#endif
	ULONG						Flags;
	PNDIS_PACKET				pOrigNdisPacket;
	ULONG						OrigBufferCount;
	ULONG						OrigPacketLength;
	ULONG						WrappedBufferCount;
	PNDIS_PACKET				pNextNdisPacket;
#if PROTECT_PACKETS
	ATMLANE_LOCK				Lock;
	NDIS_STATUS					CompletionStatus;
#endif	// PROTECT_PACKETS
}	
	SEND_PACKET_RESERVED,
	*PSEND_PACKET_RESERVED;

//
//	Packet context data in MiniportReserved area of
//	NDIS packet header owned by ATMLANE.
//
typedef struct _RECV_PACKET_RESERVED
{
	ULONG						Flags;
	PNDIS_PACKET				pNdisPacket;
}
	RECV_PACKET_RESERVED,
	*PRECV_PACKET_RESERVED;
//
//	Definitions of Flags in both  (SEND/RECV)_PACKET_RESERVED.
//
#define PACKET_RESERVED_OWNER_MASK			0x00000007
#define PACKET_RESERVED_OWNER_PROTOCOL		0x00000001
#define PACKET_RESERVED_OWNER_ATMLANE		0x00000002
#define PACKET_RESERVED_OWNER_MINIPORT		0x00000004

#if PROTECT_PACKETS
#define PACKET_RESERVED_COSENDRETURNED		0x10000000
#define PACKET_RESERVED_COMPLETED			0x01000000
#endif	// PROTECT_PACKETS

#define PSEND_RSVD(_pPkt) \
	((PSEND_PACKET_RESERVED)(&((_pPkt)->ProtocolReserved)))
#define ZERO_SEND_RSVD(_pPkt) \
	NdisZeroMemory(&((_pPkt)->ProtocolReserved), sizeof(SEND_PACKET_RESERVED))

//
//  ------------------------ Global Data Object ------------------------
//

typedef struct _ATMLANE_GLOBALS
{
#if DBG
	ULONG						atmlane_globals_sig;	// debug signature
#endif
	ATMLANE_LOCK				GlobalLock;				// global data lock
	ATMLANE_BLOCK				Block;					 
	NDIS_HANDLE					NdisWrapperHandle;		// returned by NdisMInitializeWrapper
	NDIS_HANDLE					MiniportDriverHandle;	// returned by NdisIMRegisterLayeredMiniport
	NDIS_HANDLE					NdisProtocolHandle;		// returned by NdisRegisterProtocol
	LIST_ENTRY					AdapterList;			// list of bound adapters 
	PDRIVER_OBJECT				pDriverObject;			// our driver object
	PDEVICE_OBJECT				pSpecialDeviceObject;	// special protocol ioctl device object ptr
	NDIS_HANDLE					SpecialNdisDeviceHandle;// special protocol ioctl device handle
} 	
	ATMLANE_GLOBALS, 	
	*PATMLANE_GLOBALS;

#if DBG
#define atmlane_globals_signature	'LGLA'
#endif

//
//  ------------------------ Timer Management ------------------------
//

struct _ATMLANE_TIMER ;
struct _ATMLANE_TIMER_LIST ;

//
//  Timeout Handler prototype
//
typedef
VOID
(*ATMLANE_TIMEOUT_HANDLER)(
	IN	struct _ATMLANE_TIMER *		pTimer,
	IN	PVOID						ContextPtr
);

//
//  An ATMLANE_TIMER structure is used to keep track of each timer
//  in the ATMLANE module.
//
typedef struct _ATMLANE_TIMER
{
	struct _ATMLANE_TIMER *			pNextTimer;
	struct _ATMLANE_TIMER *			pPrevTimer;
	struct _ATMLANE_TIMER *			pNextExpiredTimer;	// Used to chain expired timers
	struct _ATMLANE_TIMER_LIST *	pTimerList;			// NULL iff this timer is inactive
	ULONG							Duration;			// In seconds
	ULONG							LastRefreshTime;
	ATMLANE_TIMEOUT_HANDLER			TimeoutHandler;
	PVOID							ContextPtr;			// To be passed to timeout handler
	
} ATMLANE_TIMER, *PATMLANE_TIMER;

//
//  NULL pointer to ATMLANE Timer
//
#define NULL_PATMLANE_TIMER	((PATMLANE_TIMER)NULL)


//
//  Control structure for a timer wheel. This contains all information
//  about the class of timers that it implements.
//
typedef struct _ATMLANE_TIMER_LIST
{
#if DBG
	ULONG							atmlane_timerlist_sig;
#endif // DBG
	PATMLANE_TIMER					pTimers;		// List of timers
	ULONG							TimerListSize;	// Length of above
	ULONG							CurrentTick;	// Index into above
	ULONG							TimerCount;		// Number of running timers
	ULONG							MaxTimer;		// Max timeout value for this
	NDIS_TIMER						NdisTimer;		// System support
	UINT							TimerPeriod;	// Interval between ticks
	PVOID							ListContext;	// Used as a back pointer to the
													// Interface structure

} ATMLANE_TIMER_LIST, *PATMLANE_TIMER_LIST;

#if DBG
#define atmlane_timerlist_signature		'LTLA'
#endif // DBG

//
//  Timer Classes
//
typedef enum
{
	ALT_CLASS_SHORT_DURATION,
	ALT_CLASS_LONG_DURATION,
	ALT_CLASS_MAX

} ATMLANE_TIMER_CLASS;

//
//  ------------------------ ATMLANE SAP --------------------------------
//
//  Each of these structures maintains information about an individual SAP
//	associated with an ELAN.  Each ELAN registers 3 SAPs.
//	- Incoming Control Distribute VC
//	- Incoming Data Direct VCs
//  - Incoming Multicast Forward VC
//
typedef struct _ATMLANE_SAP
{
#if DBG
	ULONG							atmlane_sap_sig;
#endif
	struct _ATMLANE_ELAN *			pElan	;	// back pointer
	NDIS_HANDLE						NdisSapHandle;
	ULONG							Flags;		// state information
	ULONG							LaneType;	// LES\BUS\DATA
	PCO_SAP							pInfo;		// SAP characteristics.
} 	
	ATMLANE_SAP,
	*PATMLANE_SAP;

#if DBG
#define atmlane_sap_signature			'PSLA'
#endif

//
//  NULL pointer to ATMLANE SAP
//
#define NULL_PATMLANE_SAP			((PATMLANE_SAP)NULL)

//
//  Definitions for Flags in ATMLANE SAP
//
//
//  Bits 0 to 3 contain the SAP-registration state.
//
#define SAP_REG_STATE_MASK						0x0000000f
#define SAP_REG_STATE_IDLE						0x00000000
#define SAP_REG_STATE_REGISTERING				0x00000001	// Sent RegisterSap
#define SAP_REG_STATE_REGISTERED				0x00000002	// RegisterSap completed
#define SAP_REG_STATE_DEREGISTERING				0x00000004	// Sent DeregisterSap


//
//  ---- ATMLANE Buffer Tracker ----
//
//  Keeps track of allocation information for a pool of buffers. A list
//  of these structures is used to maintain info about a dynamically
//  growable pool of buffers (e.g. for LANE data packet header buffers)
//

typedef struct _ATMLANE_BUFFER_TRACKER
{
	struct _ATMLANE_BUFFER_TRACKER *	pNext;		// in a list of trackers
	NDIS_HANDLE							NdisHandle;	// for Buffer Pool
	PUCHAR								pPoolStart;	// start of memory chunk allocated
													// from the system
} ATMLANE_BUFFER_TRACKER, *PATMLANE_BUFFER_TRACKER;

//
//  NULL pointer to ATMARP Buffer tracker structure
//
#define NULL_PATMLANE_BUFFER_TRACKER	((PATMLANE_BUFFER_TRACKER)NULL)


//
//  ------------------------ ATM Address Entry ------------------------
//
//  All information about an ATM destination and the VCs associated 
//	with it.  One of these entries is used for a given ATM Address
//	with the exception of LANE services ATM Addresses

//  
//  It is deleted when all references (see below) to this entry are gone.
//  
//  One Data Direct VC can associated with this entry. One or more ARP Table 
//  Entries could point to this entry, because more than one MAC address 
//  could map to this ATM address.
//  
//  Reference Count: we add one to the RefCount for each of the following:
//  - Each VC associated with the entry.
//  - Each MAC Entry that points to it.
//	- BusTimer active.
//	- FlushTimer active.
//  - For the duration that another structure points to it.
//  
typedef struct _ATMLANE_ATM_ENTRY
{
#if DBG
	ULONG						atmlane_atm_sig;	// Signature for debugging
#endif
	struct _ATMLANE_ATM_ENTRY *	pNext;				// Next entry on this elan 
	ULONG						RefCount;			// References to this struct
	ULONG						Flags;				// State information
	ULONG						Type;				// Type of entry
	ATMLANE_LOCK				AeLock;				
	struct _ATMLANE_ELAN  *		pElan;				// Back pointer to parent
	struct _ATMLANE_VC  *		pVcList;				// List of VCs to this address
	struct _ATMLANE_VC	*		pVcIncoming;		// Optional incoming VC if server
	struct _ATMLANE_MAC_ENTRY *	pMacEntryList;		// List of MAC entries that
													// point to this entry
	ATM_ADDRESS					AtmAddress;			// ATM Address of this entry
	PATMLANE_TIMER				FlushTimer;			// Flush protocol timer
	ULONG						FlushTid;			// Transaction ID of Flush Request
}
	ATMLANE_ATM_ENTRY,
	*PATMLANE_ATM_ENTRY;

#if DBG
#define atmlane_atm_signature	'EALA'
#endif

//
//  NULL pointer to ATMLANE ATM ENTRY
//
#define NULL_PATMLANE_ATM_ENTRY		((PATMLANE_ATM_ENTRY)NULL)

//
//  Definitions for Flags in ATMLANE ATM ENTRY
//
//
//	Bits 0-4 contain the state of an ATM Entry.
//
#define ATM_ENTRY_STATE_MASK					0x00000007
#define ATM_ENTRY_IDLE							0x00000000	// Just created
#define ATM_ENTRY_VALID							0x00000001	// Installed into the database
#define ATM_ENTRY_CONNECTED						0x00000002	// VC connected
#define ATM_ENTRY_CLOSING						0x00000004  // entry is about to go away

#define ATM_ENTRY_CALLINPROGRESS				0x00000010	// Call underway
#define ATM_ENTRY_WILL_ABORT					0x80000000	// Preparing to abort this

//
//	Definitions for Type in ATMLANE ATM ENTRY
//
#define ATM_ENTRY_TYPE_PEER						0
#define ATM_ENTRY_TYPE_LECS						1
#define ATM_ENTRY_TYPE_LES						2
#define ATM_ENTRY_TYPE_BUS						3



//
//  ------------------------ MAC (ARP Table) Entry ------------------------
//
//	Contains information about one remote MAC address.
//
//	It is assumed that each MAC address resolves to exactly on ATM address.
//	So there is at most one ARP Table entry for a given MAC address.
//
//	The MAC entry participates in two lists:
//	(1) A list of all entries that hash to the same bucket in the ARP Table.
//	(2) A list of all entries that resolve to the same ATM address.
//
//	Reference Count: We add one to its ref count for each of the following:
//	- For the duration an active timer exists on this entry.
//  - For the duration the entry belongs to the list of MAC entries linked
//	  to an ATM entry.
//
typedef struct _ATMLANE_MAC_ENTRY
{
#if DBG
	ULONG						atmlane_mac_sig;	// Signature for debugging
#endif
	struct _ATMLANE_MAC_ENTRY *	pNextEntry;			// Next in hash list
	struct _ATMLANE_MAC_ENTRY * pNextToAtm;			// List of entries pointing to 
													// the save ATM Entry
	ULONG						RefCount;			// References to this struct
	ULONG						Flags;				// State and Type information
	ATMLANE_LOCK				MeLock;				// Lock for this structure
	MAC_ADDRESS					MacAddress;			// MAC Address
	ULONG						MacAddrType;		// Type of Addr (MAC vs RD)
	struct _ATMLANE_ELAN *		pElan;				// Back pointer to Elan
	PATMLANE_ATM_ENTRY			pAtmEntry;			// Pointer to ATM entry
	ATMLANE_TIMER				Timer;				// For ARP and Aging
	ATMLANE_TIMER				FlushTimer;			// For Flushing
	ULONG						RetriesLeft;		// Number of ARP retries left
	PNDIS_PACKET				PacketList;			// Packet list
	ULONG						PacketListCount;	// Number packets queued
	NDIS_TIMER					BusTimer;			// For metering Bus Sends
    ULONG						BusyTime;			// For metering Bus Sends
    ULONG						LimitTime;			// For metering Bus Sends
    ULONG						IncrTime;			// For metering Bus Sends
    ULONG						FlushTid;			// TID of outstanding flush
    ULONG						ArpTid;				// TID of outstanding arp
}
	ATMLANE_MAC_ENTRY,
	*PATMLANE_MAC_ENTRY;

#if DBG
#define atmlane_mac_signature	'EMLA'
#endif

//
//  NULL pointer to ATMLANE MAC ENTRY
//
#define NULL_PATMLANE_MAC_ENTRY		((PATMLANE_MAC_ENTRY)NULL)

//
//  Definitions for Flags in ATMLANE MAC ENTRY
//
#define MAC_ENTRY_STATE_MASK		0x0000007F
#define MAC_ENTRY_NEW				0x00000001		// Brand new
#define MAC_ENTRY_ARPING			0x00000002		// Running ARP protocol
#define MAC_ENTRY_RESOLVED			0x00000004		// Calling
#define MAC_ENTRY_FLUSHING			0x00000008		// Flushing
#define MAC_ENTRY_ACTIVE			0x00000010		// Connected
#define MAC_ENTRY_AGED				0x00000020		// Aged Out
#define MAC_ENTRY_ABORTING			0x00000040		// Aborting

#define MAC_ENTRY_BROADCAST			0x00010000		// Is broadcast address (BUS)
#define MAC_ENTRY_BUS_TIMER			0x00040000		// BUS timer running
#define MAC_ENTRY_USED_FOR_SEND		0x00080000      // Was used for send 

//
//  ------------------------ ATMLANE Virtual Circuit (VC) ---------------------
//
//	One of these is used for each call terminated at the ELAN.
//	Creation and deletion of this structure is linked to NdisCoCreateVc and
//	NdisCoDeleteVc.
//
typedef struct _ATMLANE_VC
{
#if DBG
	ULONG						atmlane_vc_sig;		// Signature for debuging
#endif
	struct _ATMLANE_VC *		pNextVc;			// Next VC in list
	ULONG						RefCount;			// References to this struct
	ULONG						OutstandingSends;	// Packets pending CoSendComplete
	ATMLANE_LOCK				VcLock;
	ULONG						Flags;				// State and Type information
	ULONG						LaneType;			// LANE type of VC 
	NDIS_HANDLE					NdisVcHandle;		// NDIS handle for this VC
	struct _ATMLANE_ELAN *		pElan;				// Back pointer to parent Elan
	PATMLANE_ATM_ENTRY			pAtmEntry;			// Back pointer to ATM Entry
	ATMLANE_TIMER				AgingTimer;			// Aging Timer
	ULONG						AgingTime;			// Aging Time
	ATMLANE_TIMER				ReadyTimer;			// Ready Timer
	ULONG						RetriesLeft;		// retries left
	ATM_ADDRESS					CallingAtmAddress;	// Calling party ATM Address
													//   in call for this VC
	ULONG						ReceiveActivity;	// non-zero if receive activity seen													
}
	ATMLANE_VC,
	*PATMLANE_VC;

#if DBG
#define atmlane_vc_signature	'CVLA'
#endif
	
//
//  NULL pointer to ATMLANE VC
//
#define NULL_PATMLANE_VC	((PATMLANE_VC)NULL)

//
//  Definitions for ATMLANE VC flags. The following information is kept
//  here:
//		- Is this VC an SVC or PVC
//  	- Is this created (owned) by an Elan or the Call Manager
//  	- Call State: Incoming in progress, Outgoing in progress, Active,
//		- LANE Ready state
//		- Close in progress
//

//  Bits 0-1 for svc vs pvc type
#define VC_TYPE_MASK							0x00000003
#define VC_TYPE_UNUSED							0x00000000
#define VC_TYPE_SVC								0x00000001
#define VC_TYPE_PVC								0x00000002

//  Bits 2-3 for "Owner"
#define VC_OWNER_MASK							0x0000000C
#define VC_OWNER_IS_UNKNOWN						0x00000000
#define VC_OWNER_IS_ATMLANE						0x00000004	// NdisClCreateVc done
#define VC_OWNER_IS_CALLMGR						0x00000008	// CreateVcHandler done

// Bits 4-7 for Call State
#define VC_CALL_STATE_MASK						0x000000F0
#define VC_CALL_STATE_IDLE						0x00000000
#define VC_CALL_STATE_INCOMING_IN_PROGRESS		0x00000010	// Wait for CallConnected
#define VC_CALL_STATE_OUTGOING_IN_PROGRESS		0x00000020	// Wait for MakeCallCmpl
#define VC_CALL_STATE_ACTIVE					0x00000040
#define VC_CALL_STATE_CLOSE_IN_PROGRESS			0x00000080	// Wait for CloseCallCmpl

// Bits 8-9 to indicate waiting for LANE Ready state
#define VC_READY_STATE_MASK						0x00000300
#define VC_READY_WAIT							0x00000100
#define VC_READY_INDICATED						0x00000200

// Bit 10 to indicate whether we are closing this VC
#define VC_CLOSE_STATE_MASK						0x00000400
#define VC_CLOSE_STATE_CLOSING					0x00000400

// Bit 12 to indicate whether we have seen an incoming close
#define VC_SEEN_INCOMING_CLOSE					0x00001000

//
// Definitions for LaneType
//
#define VC_LANE_TYPE_UNKNOWN					0
#define VC_LANE_TYPE_CONFIG_DIRECT				1	// LECS Connection (bidirectional)
#define VC_LANE_TYPE_CONTROL_DIRECT				2	// LES Connection  (bidirectional)
#define VC_LANE_TYPE_CONTROL_DISTRIBUTE			3	// LES Connection  (uni,incoming)
#define VC_LANE_TYPE_DATA_DIRECT				4	// LEC Connection  (bidirectional)
#define VC_LANE_TYPE_MULTI_SEND					5	// BUS Connection  (bidirectional)
#define VC_LANE_TYPE_MULTI_FORWARD				6	// BUS Connection  (uni,incoming)

//
//	------------------------ ELAN Event Object ------------------
//

typedef struct _ATMLANE_EVENT
{
	ULONG						Event;				// Latest state-related event 
	NDIS_STATUS					EventStatus;		// Status related to current event
	LIST_ENTRY					Link;				// event queue link
} 
	ATMLANE_EVENT,
	*PATMLANE_EVENT;

//
//	------------------------ ELAN Delayed Event Object ----------
//

typedef struct _ATMLANE_DELAYED_EVENT
{
	struct _ATMLANE_EVENT		DelayedEvent;		// event info
	struct _ATMLANE_ELAN *		pElan;				// target ELAN for this event
	NDIS_TIMER					DelayTimer;			// To implement the delay
} 
	ATMLANE_DELAYED_EVENT,
	*PATMLANE_DELAYED_EVENT;
	
	
//
//  ------------------------ ELAN Object ------------------------
//

//
//  ELAN object represents an ELAN instance and it's 
//  corresponding virtual miniport adapter.
//

typedef struct _ATMLANE_ELAN
{
#if DBG
	ULONG						atmlane_elan_sig;
#endif // DBG
	LIST_ENTRY					Link;				// for adapter's elan list
	ATMLANE_LOCK				ElanLock;			// Mutex for elan struct
	ATMLANE_BLOCK				Block;
	ULONG						RefCount;			// references to this elan
	ULONG						AdminState;			// Desired state of this elan
	ULONG						State;				// (Actual) State of this elan
	LIST_ENTRY					EventQueue;			// Event queue
	NDIS_WORK_ITEM				EventWorkItem;		// For event handling
	ULONG						RetriesLeft;		// For retry handling
	ATMLANE_TIMER				Timer;				// Timer for svr call & request timeouts
	NDIS_WORK_ITEM				NdisWorkItem;		// For scheduling a passive-level thread
	ULONG						Flags;				// Misc state information
	PATMLANE_DELAYED_EVENT		pDelayedEvent;		// Event to be queued in a while

	//
	//	------ Adapter related ----
	//
	struct _ATMLANE_ADAPTER *	pAdapter;			// back pointer to adapter parent
	NDIS_HANDLE					NdisAdapterHandle;	// cached adapter handle

	//
	//	------ Call Manager related ----
	//
	NDIS_HANDLE					NdisAfHandle;		// handle to call manager
	ULONG						AtmInterfaceUp;		// The ATM interface is considered
													// "up" after ILMI addr reg is over
	ATMLANE_SAP					LesSap;				// Control Distribute SAP
	ATMLANE_SAP					BusSap;				// Multicast Forward SAP
	ATMLANE_SAP					DataSap;			// Data Direct SAP
	ULONG						SapsRegistered;		// Number of Saps registered
	ATMLANE_BLOCK				AfBlock;			// Used to block shutdown while
													// AF open is in progress

	//
	//	------ Virtual Miniport related ----
	//
	NDIS_HANDLE					MiniportAdapterHandle;// Virtual Miniport NDIS handle
	NDIS_STRING					CfgDeviceName;		// Miniport netcard driver name
	ULONG						CurLookAhead;		// Current established lookahead size
	ULONG						CurPacketFilter;	// Current packet filter bits
	ULONG						FramesXmitGood;
	ULONG						FramesRecvGood;
	ATMLANE_BLOCK				InitBlock;			// Used to block while IMInit
													// is in progress

	//
	//	------ Timer data ----
	//
	ATMLANE_TIMER_LIST			TimerList[ALT_CLASS_MAX];
	ATMLANE_LOCK				TimerLock;			// Mutex for timer structures

	//
	//	----- LECS Configuration Parameters ----
	//
	BOOLEAN					    CfgUseLecs;
	BOOLEAN					    CfgDiscoverLecs;
	ATM_ADDRESS				    CfgLecsAddress;
	
	//
	//	----- ELAN Configuration Parameters ----
	//
	NDIS_STRING					CfgBindName;
	NDIS_STRING					CfgElanName;
	ULONG						CfgLanType;
	ULONG						CfgMaxFrameSizeCode;
	ATM_ADDRESS					CfgLesAddress;
	
	//
	//	----- ELAN Run-Time Parameters ----
	//
	ULONG						ElanNumber;			// logical Elan number
	ATM_ADDRESS					AtmAddress;			// (C1)  - LE Client's ATM Address
	UCHAR						LanType;			// (C2)  - LAN Type
	UCHAR						MaxFrameSizeCode;	// (C3)  - Maximum Data Frame Size Code
	ULONG						MaxFrameSize;		//		 - Maximum Data Frame Size Value
	USHORT						LecId;				// (C14) - LE Client Identifier
	UCHAR		ElanName[LANE_ELANNAME_SIZE_MAX];	// (C5)  - ELAN Name
	UCHAR						ElanNameSize;		//         Size of above
	MAC_ADDRESS					MacAddressEth;		// (C6)  - Elan's MAC Address (Eth/802.3 format)
	MAC_ADDRESS					MacAddressTr;		//		   Elan's MAC Address (802.5 format)
	ULONG						ControlTimeout;		// (C7)  - Control Time-out
	ATM_ADDRESS					LesAddress;			// (C9)  - LE Server ATM Address
	ULONG						MaxUnkFrameCount;	// (C10) - Maximum Unknown Frame Count
	ULONG						MaxUnkFrameTime;	// (C11) - Maximum Unknown Frame Time
	ULONG						LimitTime;			//         Precalculated values for
	ULONG						IncrTime;			//           limiting bus traffic
	ULONG						VccTimeout;			// (C12) - VCC Time-out Period
	ULONG						MaxRetryCount;		// (C13) - Maximum Retry Count
	MAC_ADDRESS	   McastAddrs[MCAST_LIST_SIZE]; 	// (C15) - Multicast MAC Addresses
	ULONG						McastAddrCount;		//		   Number of above
	ULONG						AgingTime;			// (C17) - Aging Time
	ULONG						ForwardDelayTime;	// (C18) - Forward Delay Time
	ULONG						TopologyChange;		// (C19) - Topology Change
	ULONG						ArpResponseTime;	// (C20) - Expected LE_ARP Response Time
	ULONG						FlushTimeout;		// (C21) - Flush Time-out
	ULONG						PathSwitchingDelay;	// (C22) - Path Switching Delay
	ULONG						LocalSegmentId;		// (C23) - Local Segment ID
	ULONG						McastSendVcType;	// (C24) - Mcast Send VCC Type (ignored)
	ULONG						McastSendVcAvgRate; // (C25) - Mcast Send Avg Rate (ignored)
	ULONG						McastSendVcPeakRate;// (C26) - Mcast Send Peak Rate (ignored)
	ULONG						ConnComplTimer;		// (C28) - Connection Completion Timer
	ULONG						TransactionId;		// LANE Control Frame Tid
	ATM_ADDRESS					LecsAddress;		// LECS ATM Address
	ATM_ADDRESS					BusAddress;			// BUS ATM Address
	ULONG						MinFrameSize;		// Minimum LANE frame size
	NDIS_STATUS					LastEventCode;		// Used to avoid repeated event logging
	
	//
	//  ----- Buffer Management: Header buffers and Protocol buffers ----
	//
	ATMLANE_LOCK				HeaderBufferLock;	// Mutex for header buffers
	PNDIS_BUFFER				HeaderBufList;		// Free list of header buffers
	ULONG						HeaderBufSize;		// Size of each header buffer
	ULONG						RealHeaderBufSize;	// Above size rounded up to mult of 4
	ULONG						MaxHeaderBufs;		// Max header buffers we can allocate
	ULONG						CurHeaderBufs;		// Current header buffers allocated
	PATMLANE_BUFFER_TRACKER		pHeaderTrkList;		// Info about allocated header buffers
	PNDIS_BUFFER				PadBufList;
	ULONG						PadBufSize;			// Size of pad buffers
	ULONG						MaxPadBufs;			// Max pad buffers we can allocate
	ULONG						CurPadBufs;			// Current pad buffers allocated
	PATMLANE_BUFFER_TRACKER		pPadTrkList;		// Info about allocated pad buffers
	NDIS_HANDLE					ProtocolPacketPool;	// Handle for Packet pool
	NDIS_HANDLE					ProtocolBufferPool;	// Handle for Buffer pool
	PUCHAR						ProtocolBufList;	// Free list of protocol buffers (for
													// LANE control packets)
	PUCHAR						ProtocolBufTracker;	// Start of chunk of memory used for
													// the above.
	ULONG						ProtocolBufSize;	// Size of each protocol buffer
	ULONG						MaxProtocolBufs;	// Number of protocol buffers
	NDIS_HANDLE					TransmitPacketPool;	// Handle for transmit packet pool
	NDIS_HANDLE					ReceivePacketPool;	// Handle for receive packet pool
	NDIS_HANDLE					ReceiveBufferPool;	// Handle for receive buffer pool 
#if PKT_HDR_COUNTS
	ULONG						XmitPktCount;
	ULONG						RecvPktCount;
	ULONG						ProtPktCount;
#endif // PKT_HDR_COUNTS
#if SENDLIST
	PNDIS_PACKET				pSendList;
	NDIS_SPIN_LOCK				SendListLock;
#endif // SENDLIST

	//
	//	----- MAC Entry Cache ----- (C16)
	//
	PATMLANE_MAC_ENTRY	*		pMacTable;			// (C16) LE_ARP Cache
	ULONG						NumMacEntries;		// Count of entries in cache
	ATMLANE_LOCK				MacTableLock;		// Mutex for above table

	//
	//	----- Connection Cache -----
	//
	PATMLANE_ATM_ENTRY			pLecsAtmEntry;		// LE Configuration Server
	PATMLANE_ATM_ENTRY			pLesAtmEntry;		// LAN Emulation Server
	PATMLANE_ATM_ENTRY			pBusAtmEntry;		// Broadcast & Unknown Server
	PATMLANE_ATM_ENTRY			pAtmEntryList;		// List of all ATM Entries
	ULONG						NumAtmEntries;		// Count of entries
	ATMLANE_LOCK				AtmEntryListLock;	// Mutex for above list
	
}
	ATMLANE_ELAN,
	*PATMLANE_ELAN;

#if DBG
#define atmlane_elan_signature 'LELA'
#endif

//
//  NULL pointer to ATMLANE ELAN
//
#define NULL_PATMLANE_ELAN	((PATMLANE_ELAN)NULL)

//
//	Definitions of ATMLANE ELAN States.
//
#define ELAN_STATE_ALLOCATED				0
#define ELAN_STATE_INIT						1
#define ELAN_STATE_LECS_CONNECT_ILMI		2
#define ELAN_STATE_LECS_CONNECT_WKA			3
#define ELAN_STATE_LECS_CONNECT_PVC			4
#define ELAN_STATE_LECS_CONNECT_CFG			5
#define ELAN_STATE_CONFIGURE				6
#define ELAN_STATE_LES_CONNECT				7
#define ELAN_STATE_JOIN						8
#define ELAN_STATE_BUS_CONNECT				9
#define ELAN_STATE_OPERATIONAL				10
#define ELAN_STATE_SHUTDOWN					11

//
//	Definitions of ATMLANE Elan Flags
//
//
//	Bits 0 thru 3 define the current LECS Connect attempt
//
#define ELAN_LECS_MASK						0x0000000f
#define ELAN_LECS_ILMI						0x00000001
#define ELAN_LECS_WKA						0x00000002
#define ELAN_LECS_PVC						0x00000004
#define ELAN_LECS_CFG						0x00000008

//
//	Bit 4 & 5 define the virtual miniport state
//
#define ELAN_MINIPORT_INITIALIZED			0x00000010
#define ELAN_MINIPORT_OPERATIONAL			0x00000020

//
//	Bit 6 defines event work item scheduling state
//
#define ELAN_EVENT_WORK_ITEM_SET			0x00000040

//
//  Bit 7 specifies if we want to restart this ELAN
//
#define ELAN_NEEDS_RESTART					0x00000080

#define ELAN_SAW_AF_CLOSE					0x00000100

//
//  Bit 9 defines whether there is a pending IMInitializeDeviceInstance
//  on the ELAN, i.e. we expect to see a MiniportInitialize.
//
#define ELAN_MINIPORT_INIT_PENDING			0x00000200

//
//  Bit 10 defines whether we are in the process of opening
//  an AF handle.
//
#define ELAN_OPENING_AF						0x00000400

//
//  This bit indicates whether this ELAN is being deallocated.
//
#define ELAN_DEALLOCATING					0x80000000

//
//	Elan events
//
#define ELAN_EVENT_START					1
#define ELAN_EVENT_NEW_ATM_ADDRESS			2
#define ELAN_EVENT_GOT_ILMI_LECS_ADDR		3
#define ELAN_EVENT_SVR_CALL_COMPLETE		4
#define ELAN_EVENT_CONFIGURE_RESPONSE		5
#define ELAN_EVENT_SAPS_REGISTERED			6
#define ELAN_EVENT_JOIN_RESPONSE			7
#define ELAN_EVENT_ARP_RESPONSE				8
#define ELAN_EVENT_BUS_CALL_CLOSED			9
#define ELAN_EVENT_LES_CALL_CLOSED			10
#define ELAN_EVENT_LECS_CALL_CLOSED			11
#define ELAN_EVENT_RESTART					12
#define ELAN_EVENT_STOP						13

//
//	Event status codes - use NDIS status codes
//	but make up one for timeout
//
#define NDIS_STATUS_TIMEOUT					((NDIS_STATUS)STATUS_TIMEOUT)


//
//	------------------------ ElanName Object ------------------------
//

typedef struct _ATMLANE_NAME
{
	struct _ATMLANE_NAME *	pNext;
	NDIS_STRING				Name;
} ATMLANE_NAME,
  *PATMLANE_NAME;


//
//  ------------------------ Adapter Object ------------------------
//


//
//  Adapter object represents an actual ATM adapter.
//

typedef struct _ATMLANE_ADAPTER
{
#if DBG
	ULONG					atmlane_adapter_sig;
#endif
	//
	//  Reference count and lock to protect this object.
	//
	ULONG					RefCount;
	ATMLANE_LOCK			AdapterLock;
	//
	//	State
	//
	ULONG					Flags;

	//
	//	Block data structure for blocking threads during adapter requests.
	//
	ATMLANE_BLOCK			Block;

	//
	//	Link for global adapter list.
	//
	LIST_ENTRY				Link;

	//
	//	Adapter handle and such.
	//
	NDIS_HANDLE				NdisAdapterHandle;
	NDIS_HANDLE				BindContext;
	NDIS_HANDLE				UnbindContext;

	//
	//	Protocol configuration handle and string for opening it.
	//
	NDIS_STRING				ConfigString;

	//
	//	Adapter parameters acquired from miniport
	//
	MAC_ADDRESS				MacAddress;
	ULONG					MaxAAL5PacketSize;
	NDIS_CO_LINK_SPEED		LinkSpeed;

	//
	//  Adapter configuration parameters.
	//  These only exist on Memphis/Win98.
	//	
	BOOLEAN					RunningOnMemphis;
    NDIS_STRING				CfgUpperBindings;
    PATMLANE_NAME			UpperBindingsList;
	NDIS_STRING				CfgElanName;
	PATMLANE_NAME			ElanNameList;

	//
	//	List of created ELANs.
	//
	LIST_ENTRY				ElanList;
	UINT					ElanCount;

	//
	//  Used to block Unbind while bootstrapping ELANs.
	//
	ATMLANE_BLOCK			UnbindBlock;

	//
	//  Used to block AF notification while querying the ATM adapter.
	//
	ATMLANE_BLOCK			OpenBlock;

	//
	//  Name of device. Used to protect against multiple calls to our
	//  BindAdapter handler for the same device.
	//
	NDIS_STRING				DeviceName;
}
	ATMLANE_ADAPTER,
	*PATMLANE_ADAPTER;

#if DBG
#define atmlane_adapter_signature 'DALA'
#endif

//
//  NULL pointer to ATMLANE Adapter
//
#define NULL_PATMLANE_ADAPTER	((PATMLANE_ADAPTER)NULL)

//
//  Definitions for Adapter State Flags
//
#define ADAPTER_FLAGS_AF_NOTIFIED               0x00000001
#define ADAPTER_FLAGS_UNBINDING					0x00000002
#define ADAPTER_FLAGS_UNBIND_COMPLETE_PENDING	0x00000004
#define ADAPTER_FLAGS_CLOSE_IN_PROGRESS			0x00000008
#define ADAPTER_FLAGS_BOOTSTRAP_IN_PROGRESS		0x00000010
#define ADAPTER_FLAGS_OPEN_IN_PROGRESS			0x00000100
#define ADAPTER_FLAGS_DEALLOCATING				0x80000000

#endif // __ATMLANE_ATMLANE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\elanproc.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	elanproc.c

Abstract:

Revision History:

Notes:

--*/


#include <precomp.h>
#pragma	hdrstop

VOID
AtmLaneEventHandler(
	IN	PNDIS_WORK_ITEM				pWorkItem,
	IN	PVOID						pContext
)
/*++

Routine Description:

	Elan state machine event handler.

Arguments:

	pContext	- should be pointer to ATMLANE Elan 
	
Return Value:

	None

--*/
{
	PATMLANE_ELAN		pElan;
	PATMLANE_MAC_ENTRY	pMacEntry;
	PATMLANE_EVENT		pEvent;
	ULONG				Event;
	NDIS_STATUS			EventStatus;
	NDIS_STATUS			Status;
	NDIS_HANDLE			AdapterHandle;
	ULONG				rc;
	BOOLEAN				WasCancelled;
	PLIST_ENTRY			p;
#if DEBUG_IRQL
	KIRQL				EntryIrql;
#endif
	
#if DEBUG_IRQL
	GET_ENTRY_IRQL(EntryIrql);
	ASSERT(EntryIrql == PASSIVE_LEVEL);
#endif

	TRACEIN(EventHandler);

	//	Get the pointer to the Elan

	pElan = (PATMLANE_ELAN)pContext;
	STRUCT_ASSERT(pElan, atmlane_elan);

	//	Lock the Elan

	ACQUIRE_ELAN_LOCK(pElan);

	//	Release the timer reference

	rc = AtmLaneDereferenceElan(pElan, "eventtimer");
	ASSERT(rc > 0);
	pElan->Flags &= ~ ELAN_EVENT_WORK_ITEM_SET;

	//	Remove the event at the head of the queue

	pEvent = AtmLaneDequeueElanEvent(pElan);

	if (pEvent == NULL)
	{
		RELEASE_ELAN_LOCK(pElan);
		CHECK_EXIT_IRQL(EntryIrql);
		return;
	}

	//	Save locally the important stuff
	
	Event = pEvent->Event;
	EventStatus = pEvent->EventStatus;

	// 	Free the event struct

	FREE_MEM(pEvent);

	//  Check if the ELAN is gone.
	if (rc == 1)
	{
		DBGP((0, "EventHandler: ELAN %x is gone!\n", pElan));
		CHECK_EXIT_IRQL(EntryIrql);
		return;
	}

	// 	If queue isn't empty schedule next event handler
	
	if (!IsListEmpty(&pElan->EventQueue))
	{
		NDIS_STATUS		NdisStatus;
		

		AtmLaneReferenceElan(pElan, "workitemevent");
		pElan->Flags |= ELAN_EVENT_WORK_ITEM_SET;

		p = pElan->EventQueue.Flink;
		pEvent = CONTAINING_RECORD(p, ATMLANE_EVENT, Link);
		NdisInitializeWorkItem(&pElan->EventWorkItem, AtmLaneEventHandler, pElan);

		DBGP((0, " %d EventHandler: Multiple events queued, pElan %x, State %d, Flags %x, Ref %d, processing %d, queued event %d!\n",
				pElan->ElanNumber, pElan, pElan->State, pElan->Flags, pElan->RefCount, Event, pEvent->Event));
		NdisStatus = NdisScheduleWorkItem(&pElan->EventWorkItem);
		ASSERT(NdisStatus == NDIS_STATUS_SUCCESS);
	}
	
	switch (pElan->State)
	{
		//
		//	INIT STATE ---------------------------------------------------
		//
		case ELAN_STATE_INIT:

			switch (Event)
			{
				case ELAN_EVENT_START:

				
					DBGP((1, "%d INIT - START\n", pElan->ElanNumber));

					//
					//  Open Call Manager and get ATM address
					//

					//
					//  Make sure that ShutdownElan does not
					//  pre-empt us here.
					//
					pElan->Flags |= ELAN_OPENING_AF;
					AtmLaneReferenceElan(pElan, "openaf");
					INIT_BLOCK_STRUCT(&pElan->AfBlock);
					RELEASE_ELAN_LOCK(pElan);

					Status = AtmLaneOpenCallMgr(pElan);
					if (NDIS_STATUS_SUCCESS == Status)
					{
						AtmLaneGetAtmAddress(pElan);
					}

					ACQUIRE_ELAN_LOCK(pElan);
					rc = AtmLaneDereferenceElan(pElan, "openaf");
					if (rc != 0)
					{
						pElan->Flags &= ~ELAN_OPENING_AF;
						SIGNAL_BLOCK_STRUCT(&pElan->AfBlock, NDIS_STATUS_SUCCESS);
						RELEASE_ELAN_LOCK(pElan);
					}

					break;
				    
				case ELAN_EVENT_NEW_ATM_ADDRESS:

					DBGP((1, "%d INIT - NEW ATM ADDRESS\n", pElan->ElanNumber));

					if (!pElan->CfgUseLecs)
					{
						//
						//	If configured to NOT use an LECS then
						//  set ELAN vars from registry config vars 
						//  (normally established in ConfigResponseHandler)
						//  and advance to the LES CONNECT Phase.

						pElan->LanType = (UCHAR)pElan->CfgLanType;
						if (pElan->LanType == LANE_LANTYPE_UNSPEC)
						{
							pElan->LanType = LANE_LANTYPE_ETH;
						}
						pElan->MaxFrameSizeCode = (UCHAR)pElan->CfgMaxFrameSizeCode;
						if (pElan->MaxFrameSizeCode == LANE_MAXFRAMESIZE_CODE_UNSPEC)
						{
							pElan->MaxFrameSizeCode = LANE_MAXFRAMESIZE_CODE_1516;
						}
						switch (pElan->MaxFrameSizeCode)
						{
							case LANE_MAXFRAMESIZE_CODE_18190:
								pElan->MaxFrameSize = 18190;
								break;
							case LANE_MAXFRAMESIZE_CODE_9234:
								pElan->MaxFrameSize = 9234;
								break;
							case LANE_MAXFRAMESIZE_CODE_4544:
								pElan->MaxFrameSize = 4544;
								break;
							case LANE_MAXFRAMESIZE_CODE_1516:
							case LANE_MAXFRAMESIZE_CODE_UNSPEC:
							default:
								pElan->MaxFrameSize = 1516;
								break;
						}				

						if (pElan->LanType == LANE_LANTYPE_ETH)
						{
							pElan->MinFrameSize = LANE_MIN_ETHPACKET;
						}
						else
						{
							pElan->MinFrameSize = LANE_MIN_TRPACKET;
						}

						NdisMoveMemory(
								&pElan->LesAddress, 
								&pElan->CfgLesAddress,
								sizeof(ATM_ADDRESS));

						pElan->State = ELAN_STATE_LES_CONNECT;

						pElan->RetriesLeft = 4;

						AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);
						
						RELEASE_ELAN_LOCK(pElan);
					}
					else
					{
						//
						// If configured to NOT discover the LECS then
						// advance to the LECS CONNECT CFG state.
						//
						if (!pElan->CfgDiscoverLecs)
						{
							pElan->State = ELAN_STATE_LECS_CONNECT_CFG;

							pElan->RetriesLeft = 4;

							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);
						
							RELEASE_ELAN_LOCK(pElan);
						}
						else
						{
							//
							//	Otherwise, advance to LECS CONNECT ILMI state
							//
							pElan->State = ELAN_STATE_LECS_CONNECT_ILMI;
							
							pElan->RetriesLeft = 4;

							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);
						
							RELEASE_ELAN_LOCK(pElan);
						}
					}

					break;

				case ELAN_EVENT_RESTART:
				
					DBGP((1, "%d INIT - RESTART\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, TRUE);

					break;
					
				case ELAN_EVENT_STOP:
				
					DBGP((1, "%d INIT - STOP\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, FALSE);

					break;
					
				default:
					DBGP((0, "%d INIT - UNEXPECTED EVENT %d\n", 
							pElan->ElanNumber, Event));

					RELEASE_ELAN_LOCK(pElan);

					break;

			}

			break;

		//
		//	LECS CONNECT ILMI STATE -------------------------------------------
		//
		case ELAN_STATE_LECS_CONNECT_ILMI:

			switch (Event)
			{
				case ELAN_EVENT_START:

					DBGP((1, "%d LECS CONNECT ILMI - START\n", pElan->ElanNumber));

					SET_FLAG(
							pElan->Flags,
							ELAN_LECS_MASK,
							ELAN_LECS_ILMI
							);

					RELEASE_ELAN_LOCK(pElan);
					
					AtmLaneGetLecsIlmi(pElan);

					break;

				case ELAN_EVENT_GOT_ILMI_LECS_ADDR:

					DBGP((1, "%d LECS CONNECT ILMI - GOT ILMI LECS ADDR (%x)\n", 
						pElan->ElanNumber, EventStatus));

					if (EventStatus == NDIS_STATUS_SUCCESS)
					{
						RELEASE_ELAN_LOCK(pElan);
						//
						//	Attempt to connect to the LECS
						//
						AtmLaneConnectToServer(pElan, ATM_ENTRY_TYPE_LECS, FALSE);
					}
					else
					{
						if (EventStatus == NDIS_STATUS_INTERFACE_DOWN)
						{
							//
							//  Wait for a while for the interface to come up.
							//
							DBGP((0, "%d LECS CONNECT ILMI - Interface down\n",
									pElan->ElanNumber));

							AtmLaneQueueElanEventAfterDelay(pElan, ELAN_EVENT_START, NDIS_STATUS_SUCCESS, 2*1000);
						}
						else
						{
							//
							//	Otherwise advance to LECS CONNECT WKA state
							//

							pElan->State = ELAN_STATE_LECS_CONNECT_WKA;

							pElan->RetriesLeft = 4;

							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);
						}

						RELEASE_ELAN_LOCK(pElan);

					}
					break;

				case ELAN_EVENT_SVR_CALL_COMPLETE:
				
					DBGP((1, "%d LECS CONNECT ILMI - LECS CALL COMPLETE (%x)\n", 
						pElan->ElanNumber, EventStatus));

					switch (EventStatus)
					{
						case NDIS_STATUS_SUCCESS:

							//
							//	advance to the CONFIGURE Phase
							//
							pElan->State = ELAN_STATE_CONFIGURE;

							pElan->RetriesLeft = 4;

							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);

							RELEASE_ELAN_LOCK(pElan);

							break;

						case NDIS_STATUS_INTERFACE_DOWN:

							if (pElan->RetriesLeft--)
							{
								//
								//	retry in a little while
								//
								AtmLaneQueueElanEventAfterDelay(
										pElan, 
										ELAN_EVENT_GOT_ILMI_LECS_ADDR, 
										NDIS_STATUS_SUCCESS, 
										2*1000);
								RELEASE_ELAN_LOCK(pElan);
							}
							else
							{
								//
								//	Restart the Elan
								//
								AtmLaneShutdownElan(pElan, TRUE);
								//
								//	lock released in above
								//
							}
							
							break;

						default: 

							//
							//	Call failed, advance to LECS CONNECT WKA state
							//
							pElan->State = ELAN_STATE_LECS_CONNECT_WKA;

							pElan->RetriesLeft = 4;

							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);
						
							RELEASE_ELAN_LOCK(pElan);

							break;
					}
					
					break;

				case ELAN_EVENT_RESTART:
				
					DBGP((1, "%d LECS CONNECT ILMI - RESTART\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, TRUE);

					break;
					
				case ELAN_EVENT_STOP:
				
					DBGP((1, "%d LECS CONNECT ILMI - STOP\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, FALSE);

					break;
					
				default:
					DBGP((0, "%d LECS CONNECT ILMI - UNEXPECTED EVENT %d\n", 
							pElan->ElanNumber, Event));
							
					RELEASE_ELAN_LOCK(pElan);

					break;
			}
			break;
			
		//
		//	LECS CONNECT WKA STATE -------------------------------------------
		//
		case ELAN_STATE_LECS_CONNECT_WKA:

			switch (Event)
			{			
				case ELAN_EVENT_START:

					DBGP((1, "%d LECS CONNECT WKA - START\n", pElan->ElanNumber));

					//
					//	Attempt to connect to the LECS with Well-Known Address
					//
					SET_FLAG(
							pElan->Flags,
							ELAN_LECS_MASK,
							ELAN_LECS_WKA);
	
					NdisMoveMemory(
							&pElan->LecsAddress, 
							&gWellKnownLecsAddress,
							sizeof(ATM_ADDRESS));

					RELEASE_ELAN_LOCK(pElan);
					
					AtmLaneConnectToServer(pElan, ATM_ENTRY_TYPE_LECS, FALSE);

					break;

				case ELAN_EVENT_SVR_CALL_COMPLETE:

					DBGP((1, "%d LECS CONNECT WKA - LECS CALL COMPLETE (%x)\n", 
						pElan->ElanNumber, EventStatus));

					switch (EventStatus)
					{
						case NDIS_STATUS_SUCCESS:

							//
							//	advance to the CONFIGURE Phase
							//
							pElan->State = ELAN_STATE_CONFIGURE;

							pElan->RetriesLeft = 4;

							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);

							RELEASE_ELAN_LOCK(pElan);

							break;

						case NDIS_STATUS_INTERFACE_DOWN:

							if (pElan->RetriesLeft--)
							{
								//
								//	retry in a little while
								//
								AtmLaneQueueElanEventAfterDelay(
										pElan, 
										ELAN_EVENT_START, 
										NDIS_STATUS_SUCCESS, 
										2*1000);
								RELEASE_ELAN_LOCK(pElan);
							}
							else
							{
								//
								//	Return to the Init State in a little while
								//
								AtmLaneShutdownElan(pElan, TRUE);
								//
								//	lock released in above
								//
							}
							

							break;

						default: 

							//
							//	Call failed, advance to LECS CONNECT PVC state
							//
							pElan->State = ELAN_STATE_LECS_CONNECT_PVC;

							pElan->RetriesLeft = 2;

							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);
						
							RELEASE_ELAN_LOCK(pElan);

							break;
					}
					
					break;

				case ELAN_EVENT_RESTART:
				
					DBGP((1, "%d LECS CONNECT WKA - RESTART\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, TRUE);

					break;

				case ELAN_EVENT_STOP:
				
					DBGP((1, "%d LECS CONNECT WKA - STOP\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, FALSE);

					break;

				default:
					DBGP((0, "%d LECS CONNECT WKA - UNEXPECTED EVENT %d\n", 
							pElan->ElanNumber, Event));
							
					RELEASE_ELAN_LOCK(pElan);

					break;
			}
			break;
			
		//
		//	LECS CONNECT PVC STATE -------------------------------------------
		//
		case ELAN_STATE_LECS_CONNECT_PVC:

			switch (Event)
			{			
				case ELAN_EVENT_START:

					DBGP((1, "%d LECS CONNECT PVC - START\n", pElan->ElanNumber));

					//
					//	Attempt to connect to the LECS using PVC (0,17)
					//
					SET_FLAG(
							pElan->Flags,
							ELAN_LECS_MASK,
							ELAN_LECS_PVC);
	
					NdisZeroMemory(
							&pElan->LecsAddress, 
							sizeof(ATM_ADDRESS));

					RELEASE_ELAN_LOCK(pElan);
					
					AtmLaneConnectToServer(pElan, ATM_ENTRY_TYPE_LECS, TRUE);

					break;

				case ELAN_EVENT_SVR_CALL_COMPLETE:

					DBGP((1, "%d LECS CONNECT PVC - LECS CALL COMPLETE (%x)\n", 
						pElan->ElanNumber, EventStatus));

					switch (EventStatus)
					{
						case NDIS_STATUS_SUCCESS:

							//
							//	advance to the CONFIGURE Phase
							//
							pElan->State = ELAN_STATE_CONFIGURE;

							pElan->RetriesLeft = 2;

							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);

							RELEASE_ELAN_LOCK(pElan);

							break;

						case NDIS_STATUS_INTERFACE_DOWN:

							if (pElan->RetriesLeft--)
							{
								//
								//	retry in a little while
								//
								AtmLaneQueueElanEventAfterDelay(
										pElan, 
										ELAN_EVENT_START, 
										NDIS_STATUS_SUCCESS, 
										2*1000);
								RELEASE_ELAN_LOCK(pElan);
							}
							else
							{
								//
								//	Return to the Init State in a little while
								//
								AtmLaneShutdownElan(pElan, TRUE);
								//
								//	lock released in above
								//
							}
							

							break;

						default: 

							//
							//	Call failed, Return to the Init State in a little while
							//
							AtmLaneShutdownElan(pElan, TRUE);
							//
							//	lock released in above
							//

							break;
					}
					
					break;

				case ELAN_EVENT_RESTART:
				
					DBGP((1, "%d LECS CONNECT PVC - RESTART\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, TRUE);

					break;

				case ELAN_EVENT_STOP:
				
					DBGP((1, "%d LECS CONNECT PVC - STOP\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, FALSE);

					break;

				default:
					DBGP((0, "%d LECS CONNECT PVC - UNEXPECTED %d\n", 
							pElan->ElanNumber, Event));
							
					RELEASE_ELAN_LOCK(pElan);

					break;
			}
			break;
			
		//
		//	LECS CONNECT CFG STATE -------------------------------------------
		//
		case ELAN_STATE_LECS_CONNECT_CFG:

			switch (Event)
			{			
				case ELAN_EVENT_START:

					DBGP((1, "%d LECS CONNECT CFG - START\n", pElan->ElanNumber));

					//
					//	Attempt to connect to the LECS with configured Address
					//
					SET_FLAG(
							pElan->Flags,
							ELAN_LECS_MASK,
							ELAN_LECS_CFG);
	
					NdisMoveMemory(
							&pElan->LecsAddress, 
							&pElan->CfgLecsAddress,
							sizeof(ATM_ADDRESS));

					RELEASE_ELAN_LOCK(pElan);
					
					AtmLaneConnectToServer(pElan, ATM_ENTRY_TYPE_LECS, FALSE);

					break;

				case ELAN_EVENT_SVR_CALL_COMPLETE:
				
					DBGP((1, "%d LECS CONNECT CFG - LECS CALL COMPLETE (%x)\n", 
						pElan->ElanNumber, EventStatus));

					switch (EventStatus)
					{
						case NDIS_STATUS_SUCCESS:

							//
							//	advance to the CONFIGURE Phase
							//
							pElan->State = ELAN_STATE_CONFIGURE;

							pElan->RetriesLeft = 4;

							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);

							RELEASE_ELAN_LOCK(pElan);

							break;

						case NDIS_STATUS_INTERFACE_DOWN:

							if (pElan->RetriesLeft--)
							{
								//
								//	retry in a little while
								//
								AtmLaneQueueElanEventAfterDelay(
										pElan, 
										ELAN_EVENT_START, 
										NDIS_STATUS_SUCCESS, 
										2*1000);
								RELEASE_ELAN_LOCK(pElan);
							}
							else
							{
								//
								//	Return to the Init State in a little while
								//
								AtmLaneShutdownElan(pElan, TRUE);
								//
								//	lock released in above
								//
							}
							
							break;

						default: 

							//
							//	Call failed, XXX What to do ??  Shutdown ?? Log ??
							//

							RELEASE_ELAN_LOCK(pElan);

							break;
					}

					break;

				case ELAN_EVENT_RESTART:
				
					DBGP((1, "%d LECS CONNECT CFG - RESTART\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, TRUE);

					break;
					
				case ELAN_EVENT_STOP:
				
					DBGP((1, "%d LECS CONNECT CFG - STOP\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, FALSE);

					break;
					
				default:
					DBGP((0, "%d LECS CONNECT CFG - UNEXPECTED EVENT %d\n", 
							pElan->ElanNumber, Event));
							
					RELEASE_ELAN_LOCK(pElan);

					break;
			}
			break;
		
		//
		//	CONFIGURE STATE -------------------------------------------
		//
		case ELAN_STATE_CONFIGURE:

			switch (Event)
			{
				case ELAN_EVENT_START:

					DBGP((1, "%d CONFIGURE - START\n", pElan->ElanNumber));

					//
					//	Start configure request timer
					//
					AtmLaneReferenceElan(pElan, "timer"); // timer reference
					AtmLaneStartTimer(
							pElan, 
							&pElan->Timer, 
							AtmLaneConfigureResponseTimeout,
							pElan->ControlTimeout,
							pElan);
							
					RELEASE_ELAN_LOCK(pElan);
							
					//
					//	Send a configure request
					//
					AtmLaneSendConfigureRequest(pElan);
					
					break;

				case ELAN_EVENT_CONFIGURE_RESPONSE:

					DBGP((1, "%d CONFIGURE - CONFIGURE RESPONSE (%x)\n", 
						pElan->ElanNumber, EventStatus));

					switch (EventStatus)
					{
						case NDIS_STATUS_SUCCESS:
							//
							//	Stop configure request timer
							//
							if (AtmLaneStopTimer(&pElan->Timer, pElan))
							{
								rc = AtmLaneDereferenceElan(pElan, "timer");
								ASSERT(rc > 0);
							}								
					
							//
							//	Close the LECS Connection
							//
							RELEASE_ELAN_LOCK(pElan);
							ACQUIRE_ATM_ENTRY_LOCK(pElan->pLecsAtmEntry);
							AtmLaneInvalidateAtmEntry(pElan->pLecsAtmEntry);

							//
							//	Advance to LES CONNECT phase.
							//
							ACQUIRE_ELAN_LOCK(pElan);
						
							pElan->State = ELAN_STATE_LES_CONNECT;
	
							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);
	
							RELEASE_ELAN_LOCK(pElan);

							break;

						case NDIS_STATUS_TIMEOUT:

							//
							//	Return to the Init State in a little while
							//
							AtmLaneShutdownElan(pElan, TRUE);
							//
							//	lock released in above
							//
							
							break;
						
						case NDIS_STATUS_FAILURE:

							//
							//	Return to the Init State in a little while
							//
							AtmLaneShutdownElan(pElan, TRUE);
							//
							//	lock released in above
							//
							
							break;
					} // switch (EventStatus)

					break;

				case ELAN_EVENT_RESTART:
				
					DBGP((1, "%d CONFIGURE - RESTART\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, TRUE);

					break;
					
				case ELAN_EVENT_STOP:
				
					DBGP((1, "%d CONFIGURE - STOP\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, FALSE);

					break;
					
				default:
					DBGP((1, "%d CONFIGURE - UNEXPECTED EVENT %d\n", 
							pElan->ElanNumber, Event));

					RELEASE_ELAN_LOCK(pElan);

					break;
			}

			break;

		//
		//	LES CONNECT STATE --------------------------------------------
		//
		case ELAN_STATE_LES_CONNECT:

			switch (Event)
			{
				case ELAN_EVENT_START:
				
					DBGP((1, "%d LES CONNECT - START\n", pElan->ElanNumber));
			
					//
					//	Register our SAPs
					//
					AtmLaneRegisterSaps(pElan);
					//
					//	Elan lock is released in above.
					//
					break;

				case ELAN_EVENT_SAPS_REGISTERED:
				
					DBGP((1, "%d LES CONNECT - SAPS REGISTERED (%x)\n",
						pElan->ElanNumber, EventStatus));

					if (NDIS_STATUS_SUCCESS == EventStatus)
					{
						pElan->RetriesLeft = 4;
						RELEASE_ELAN_LOCK(pElan);
						//
						//	Connect to the LES
						//
						AtmLaneConnectToServer(pElan, ATM_ENTRY_TYPE_LES, FALSE);
						//
						//	Elan lock is released in above.
						//
					}
					else
					{
						// XXX - What to do?

						RELEASE_ELAN_LOCK(pElan);
					}
					break;

				case ELAN_EVENT_SVR_CALL_COMPLETE:

					DBGP((1, "%d LES CONNECT - LES CALL COMPLETE (%x)\n", 
						pElan->ElanNumber, EventStatus));

					switch (EventStatus)
					{
						case NDIS_STATUS_SUCCESS:

							//
							//	Advance to Join state
							//
							pElan->State = ELAN_STATE_JOIN;

							pElan->RetriesLeft = 4;
	
							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);
					
							RELEASE_ELAN_LOCK(pElan);

							break;

						case NDIS_STATUS_INTERFACE_DOWN:

							if (pElan->RetriesLeft--)
							{
								//
								//	retry in a little while
								//
								AtmLaneQueueElanEventAfterDelay(
										pElan, 
										ELAN_EVENT_SAPS_REGISTERED, 
										NDIS_STATUS_SUCCESS, 
										2*1000);
								RELEASE_ELAN_LOCK(pElan);
							}
							else
							{
								//
								//	Return to the Init State in a little while
								//
								AtmLaneShutdownElan(pElan, TRUE);
								//
								//	lock released in above
								//
							}
							
							break;

						default: 

							//
							//	Call failed, return to the Init State in a little while
							//
							AtmLaneShutdownElan(pElan, TRUE);
							//
							//	lock released in above
							//

							break;
					}

					break;

				case ELAN_EVENT_RESTART:
				
					DBGP((1, "%d LES CONNECT - RESTART\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, TRUE);

					break;
					
				case ELAN_EVENT_STOP:
				
					DBGP((1, "%d LES CONNECT - STOP\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, FALSE);

					break;
					
				default:
					DBGP((0, "%d LES CONNECT - UNEXPECTED EVENT %d\n", 
							pElan->ElanNumber, Event));
							
					RELEASE_ELAN_LOCK(pElan);

					break;
			}
			break;
			
		//
		//	JOIN STATE ---------------------------------------------------
		//
		case ELAN_STATE_JOIN:

			switch (Event)
			{
				case ELAN_EVENT_START:

					DBGP((1, "%d JOIN - START\n", pElan->ElanNumber));

					//
					//	Start join request timer
					//
					AtmLaneReferenceElan(pElan, "timer"); // timer reference
					AtmLaneStartTimer(
							pElan, 
							&pElan->Timer, 
							AtmLaneJoinResponseTimeout,
							pElan->ControlTimeout,
							pElan);

					RELEASE_ELAN_LOCK(pElan);
			
					//
					//	Send a Join request
					//
					AtmLaneSendJoinRequest(pElan);
					break;

				case ELAN_EVENT_JOIN_RESPONSE:

					DBGP((1, "%d JOIN - JOIN RESPONSE (%x)\n", 
						pElan->ElanNumber, EventStatus));

					switch (EventStatus)
					{
						case NDIS_STATUS_SUCCESS:
							//
							//	Stop join request timer
							//
							if (AtmLaneStopTimer(&pElan->Timer, pElan))
							{
								rc = AtmLaneDereferenceElan(pElan, "timer");
								ASSERT(rc > 0);
							}								
					
							//
							//	Advance to BUS CONNECT phase.
							//
							pElan->State = ELAN_STATE_BUS_CONNECT;
	
							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);
	
							RELEASE_ELAN_LOCK(pElan);

							break;

						case NDIS_STATUS_TIMEOUT:
							//
							//	restart the Elan
							//
							AtmLaneShutdownElan(pElan, TRUE);
							//
							//	lock released in above
							//
							
							break;
						
						case NDIS_STATUS_FAILURE:
							//
							//	restart the Elan
							//
							AtmLaneShutdownElan(pElan, TRUE);
							//
							//	lock released in above
							//
							
							break;
					}
					
					break;
					
				case ELAN_EVENT_LES_CALL_CLOSED:
				
					DBGP((1, "%d JOIN - LES CALL CLOSED\n", pElan->ElanNumber));
					
					//
					//	restart the Elan
					//
					AtmLaneShutdownElan(pElan, TRUE);
					//
					//	lock released in above
					//
					break;

				case ELAN_EVENT_RESTART:
				
					DBGP((1, "%d JOIN - RESTART\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, TRUE);

					break;

				case ELAN_EVENT_STOP:
				
					DBGP((1, "%d JOIN - STOP\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, FALSE);

					break;

				default:
					DBGP((0, "%d JOIN - UNEXPECTED %d\n", 
							pElan->ElanNumber, Event));
							
					RELEASE_ELAN_LOCK(pElan);

					break;
		
			}
			break;
			
		//
		//	BUS CONNECT STATE ---------------------------------------------------
		//
		case ELAN_STATE_BUS_CONNECT:

			switch (Event)
			{
				case ELAN_EVENT_START:

					DBGP((1, "%d BUS CONNECT - START\n", pElan->ElanNumber));

					RELEASE_ELAN_LOCK(pElan);
			
					//
					//	Find or create a MAC entry for the Broadcast MAC Addr
					//
					ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan);
					pMacEntry = AtmLaneSearchForMacAddress(
											pElan, 
											LANE_MACADDRTYPE_MACADDR,
											&gMacBroadcastAddress, 
											TRUE);
					RELEASE_ELAN_MAC_TABLE_LOCK(pElan);

					if (pMacEntry == NULL_PATMLANE_MAC_ENTRY)
					{
						break;
					}

					ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);

					SET_FLAG(
							pMacEntry->Flags,
							MAC_ENTRY_STATE_MASK,
							MAC_ENTRY_ARPING);
							
					pMacEntry->Flags |= MAC_ENTRY_BROADCAST;
					

					//
					// Send ARP Request
					//
					AtmLaneStartTimer(
							pElan,
							&pMacEntry->Timer,
							AtmLaneArpTimeout,
							pElan->ArpResponseTime,
							(PVOID)pMacEntry
							);

					pMacEntry->RetriesLeft = pElan->MaxRetryCount;
					AtmLaneReferenceMacEntry(pMacEntry, "timer");
					pMacEntry->Flags |= MAC_ENTRY_ARPING;

					AtmLaneSendArpRequest(pElan, pMacEntry);
					//
					//	MAC Entry lock released in above
					//
							
					break;

				case ELAN_EVENT_ARP_RESPONSE:

					DBGP((1, "%d BUS CONNECT - ARP RESPONSE (%x)\n", 
						pElan->ElanNumber, EventStatus));
				
					if (NDIS_STATUS_SUCCESS == EventStatus)
					{
						pElan->RetriesLeft = 4;
						RELEASE_ELAN_LOCK(pElan);
						
						//
						//	Connect to the BUS
						//
						AtmLaneConnectToServer(pElan, ATM_ENTRY_TYPE_BUS, FALSE);
					}
					else
					{
						DBGP((2, "ELAN %d: NO ARP RESPONSE for BUS, restarting\n"));
						
						//
						//	restart the Elan
						//
						AtmLaneShutdownElan(pElan, TRUE);
						//
						//	lock released in above
						//
					}
					break;

				case ELAN_EVENT_SVR_CALL_COMPLETE:

					DBGP((1, "%d BUS CONNECT - BUS CALL COMPLETE (%x)\n", 
						pElan->ElanNumber, EventStatus));

					switch (EventStatus)
					{
						case NDIS_STATUS_SUCCESS:

							//
							//	Now connected to BUS, start the Operational phase
							//
							pElan->State = ELAN_STATE_OPERATIONAL;

							pElan->RetriesLeft = 4;

							AdapterHandle = pElan->MiniportAdapterHandle;
							
							AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, 0);
						
							RELEASE_ELAN_LOCK(pElan);

							//
							//  Indicate media connect status if our miniport is up:
							//
							if (AdapterHandle != NULL)
							{
								NdisMIndicateStatus(
									AdapterHandle,
									NDIS_STATUS_MEDIA_CONNECT,
									(PVOID)NULL,
									0);
								
								NdisMIndicateStatusComplete(AdapterHandle);
							}

							break;

						case NDIS_STATUS_INTERFACE_DOWN:

							if (pElan->RetriesLeft--)
							{
								//
								//	retry in a little while
								//
								AtmLaneQueueElanEventAfterDelay(
										pElan, 
										ELAN_EVENT_ARP_RESPONSE, 
										NDIS_STATUS_SUCCESS, 
										2*1000);
								RELEASE_ELAN_LOCK(pElan);
							}
							else
							{
								//
								//	return to the Init State in a little while
								//
								AtmLaneShutdownElan(pElan, TRUE);
								//
								//	lock released in above
								//
							}
							
							break;

						default: 

							//
							//	Call failed, 
							//	Close the LES connection and
							//	return to the Init State in a little while.
							//
							AtmLaneShutdownElan(pElan, TRUE);
							//
							//	lock released in above
							//

							break;
					}


					break;
					
				case ELAN_EVENT_LES_CALL_CLOSED:
				
					DBGP((1, "%d BUS CONNECT - LES CALL CLOSED\n", pElan->ElanNumber));
					
					//
					//	restart the Elan
					//
					AtmLaneShutdownElan(pElan, TRUE);
					//
					//	lock released in above
					//
					break;

				case ELAN_EVENT_RESTART:
				
					DBGP((1, "%d BUS CONNECT - RESTART\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, TRUE);

					break;

				case ELAN_EVENT_STOP:
				
					DBGP((1, "%d BUS CONNECT - STOP\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, FALSE);

					break;

				default:
					DBGP((0, "%d BUS CONNECT - UNEXPECTED EVENT %d\n", 
							pElan->ElanNumber, Event));
							
					RELEASE_ELAN_LOCK(pElan);

					break;

			}

			break;
			
		//
		//	OPERATIONAL STATE ---------------------------------------------------
		//
		case ELAN_STATE_OPERATIONAL:

			switch (Event)
			{
				case ELAN_EVENT_START:

					DBGP((1, "%d OPERATIONAL - START\n", pElan->ElanNumber));

					// Initialize the miniport if not already

					if ((pElan->Flags & ELAN_MINIPORT_INITIALIZED) == 0)
					{
						// Only if we have a device name

						if (pElan->CfgDeviceName.Length > 0)
						{
				
							pElan->Flags |= ELAN_MINIPORT_INITIALIZED;

							//
							//	Schedule a PASSIVE_LEVEL thread to call
							//	NdisIMInitializeDeviceInstance
							//
							NdisInitializeWorkItem(
									&pElan->NdisWorkItem,
									AtmLaneInitializeMiniportDevice,
									pElan);

							AtmLaneReferenceElan(pElan, "workitem");

							NdisScheduleWorkItem(&pElan->NdisWorkItem);

						}
						else
						{
							DBGP((0, "EventHandler: No miniport device name configured\n"));
						}
					}

					//
					//	Clear last event log code
					//
					pElan->LastEventCode = 0;
					
					RELEASE_ELAN_LOCK(pElan);
					
					break;

				case ELAN_EVENT_LES_CALL_CLOSED:
				
					DBGP((1, "%d OPERATIONAL - LES CALL CLOSED\n", pElan->ElanNumber));
					
					//
					//	Tear everything down and restart
					//
					AtmLaneShutdownElan(pElan, TRUE);
					//
					//	lock released in above
					//
					break;

				case ELAN_EVENT_BUS_CALL_CLOSED:
				
					DBGP((1, "%d OPERATIONAL - BUS CALL CLOSED\n", pElan->ElanNumber));

					//
					//	Tear everything down and restart
					//
					AtmLaneShutdownElan(pElan, TRUE);
					//
					//	lock released in above
					//
					break;

					break;

				case ELAN_EVENT_RESTART:
				
					DBGP((1, "%d OPERATIONAL - RESTART\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, TRUE);

					break;
					
				case ELAN_EVENT_STOP:
				
					DBGP((1, "%d OPERATIONAL - STOP\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, FALSE);

					break;
					
				default:
					DBGP((0, "%d OPERATIONAL - UNEXPECTED EVENT%d\n", 
							pElan->ElanNumber, Event));
							
					RELEASE_ELAN_LOCK(pElan);

					break;
			}
			
			break;


		default:

			DBGP((0, "%d UNKOWN STATE  %d EVENT %d\n", 
				pElan->ElanNumber, pElan->State, Event));
		
			RELEASE_ELAN_LOCK(pElan);

			break;


	} // switch (pElan->State)

	TRACEOUT(EventHandler);
	CHECK_EXIT_IRQL(EntryIrql);
	return;
}

VOID
AtmLaneBootStrapElans(
    IN  PATMLANE_ADAPTER            pAdapter
)
/*++

Routine Description:

	Start up the ELANs configured for an adapter.
    Done upon receipt of AF notify from call manager.

Arguments:

	pAdapter	- Pointer to ATMLANE Adapter structure

Return Value:

	None

--*/
{
	NDIS_STATUS						Status;
	NDIS_HANDLE                     AdapterConfigHandle;
	NDIS_STRING				        ElanListKeyName;
	NDIS_HANDLE                     ElanListConfigHandle;
	NDIS_HANDLE                     ElanConfigHandle;
	NDIS_STRING                     ElanKeyName;
	UINT                            Index;
	PLIST_ENTRY                     p;
    PATMLANE_ELAN                   pElan;
    PATMLANE_NAME					pName;
    BOOLEAN							bBootStrapping;
	
	TRACEIN(BootStrapElans);
	
	//
	//  Initialize.
	//
	Status = NDIS_STATUS_SUCCESS;
	AdapterConfigHandle = NULL_NDIS_HANDLE;
    ElanListConfigHandle = NULL_NDIS_HANDLE;
    ElanConfigHandle = NULL_NDIS_HANDLE;
    bBootStrapping = TRUE;
	
    do
	{
		DBGP((1, "BootStrapElans: Starting ELANs on adapter %p\n", pAdapter));
		ACQUIRE_ADAPTER_LOCK(pAdapter);

		if (pAdapter->Flags & (ADAPTER_FLAGS_BOOTSTRAP_IN_PROGRESS|
                                ADAPTER_FLAGS_UNBINDING))
		{
			DBGP((0, "Skipping bootstrap on adapter %x/%x\n", pAdapter, pAdapter->Flags));
			RELEASE_ADAPTER_LOCK(pAdapter);
			bBootStrapping = FALSE;
			break;
		}

		pAdapter->Flags |= ADAPTER_FLAGS_BOOTSTRAP_IN_PROGRESS;
		INIT_BLOCK_STRUCT(&pAdapter->UnbindBlock);
		RELEASE_ADAPTER_LOCK(pAdapter);
	
		//
		//  Open the AtmLane protocol configuration section for this adapter.
		//

    	NdisOpenProtocolConfiguration(
	    					&Status,
		    				&AdapterConfigHandle,
			    			&pAdapter->ConfigString
	    					);
    
	    if (NDIS_STATUS_SUCCESS != Status)
	    {
		    AdapterConfigHandle = NULL_NDIS_HANDLE;
			DBGP((0, "BootStrapElans: OpenProtocolConfiguration failed\n"));
			Status = NDIS_STATUS_OPEN_FAILED;
			break;
	    }

		//
		//	Get the protocol specific configuration
		//
		AtmLaneGetProtocolConfiguration(AdapterConfigHandle, pAdapter);

        //
        //  We bootstrap the ELANs differently on NT5 and Memphis(Win98)
        //
        if (!pAdapter->RunningOnMemphis)
        {
            //
            //  This is the NT5 ELAN bootstrap case
            //        
            do
            {
        		//
	        	//	Open the Elan List configuration key.
        		//
            	NdisInitUnicodeString(&ElanListKeyName, ATMLANE_ELANLIST_STRING);

            	NdisOpenConfigurationKeyByName(
				        &Status,
				        AdapterConfigHandle,
    				    &ElanListKeyName,
				        &ElanListConfigHandle);

	            if (NDIS_STATUS_SUCCESS != Status)
	            {
		            ElanListConfigHandle = NULL_NDIS_HANDLE;
			        DBGP((0, "BootStrapElans: Failed open of ElanList key\n"));
			        Status = NDIS_STATUS_FAILURE;
			        break;
	            }

    		    //
    	    	//	Iterate thru the configured Elans
    		    //
                for (Index = 0;
			    	;			// Stop only on error or no more Elans
        			 Index++)
		        {
        			//
		        	//	Open the "next" Elan key
        			//
	                NdisOpenConfigurationKeyByIndex(
				                &Status,
				                ElanListConfigHandle,
				                Index,
				                &ElanKeyName,
				                &ElanConfigHandle
				                );

	                if (NDIS_STATUS_SUCCESS != Status)
	                {
		                ElanConfigHandle = NULL_NDIS_HANDLE;
	                }
	                
			        //
			        //	If NULL handle, assume no more ELANs.
			        //
			        if (NULL_NDIS_HANDLE == ElanConfigHandle)
			        {
				        break;
			        }

                    //
                    //  Create this Elan
                    //
                    DBGP((2, "Bootstrap ELANs: Adapter %x, KeyName: len %d, max %d, name: [%ws]\n",
                    			pAdapter,
                    			ElanKeyName.Length,
                    			ElanKeyName.MaximumLength,
                    			ElanKeyName.Buffer));
                    (VOID)AtmLaneCreateElan(pAdapter, &ElanKeyName, &pElan);
                }   
                
            } while (FALSE);

            Status = NDIS_STATUS_SUCCESS;
        }
        else
        {
            //
            //  This is the Memphis/Win98 ELAN bootstrap case
            // 
			//	Create Elans for each entry in the UpperBindings List
			//				
			pName = pAdapter->UpperBindingsList;

			while (pName != NULL)
			{
				(VOID)AtmLaneCreateElan(pAdapter, NULL, &pElan);
           
				pName = pName->pNext;
            }
		}


	} while (FALSE);
        

	//
	//	Close config handles
	//		
	if (NULL_NDIS_HANDLE != ElanConfigHandle)
	{
		NdisCloseConfiguration(ElanConfigHandle);
		ElanConfigHandle = NULL_NDIS_HANDLE;
	}
	if (NULL_NDIS_HANDLE != ElanListConfigHandle)
	{
		NdisCloseConfiguration(ElanListConfigHandle);
		ElanListConfigHandle = NULL_NDIS_HANDLE;
	}
	if (NULL_NDIS_HANDLE != AdapterConfigHandle)
	{
	    NdisCloseConfiguration(AdapterConfigHandle);
		AdapterConfigHandle = NULL_NDIS_HANDLE;
	}


	//
    //  Loop thru the ELANs and kickstart them - only the newly
    //  allocated ones.
    //
	if (!IsListEmpty(&pAdapter->ElanList))
	{
		p = pAdapter->ElanList.Flink;
		while (p != &pAdapter->ElanList)
		{
			pElan = CONTAINING_RECORD(p, ATMLANE_ELAN, Link);
			STRUCT_ASSERT(pElan, atmlane_elan);
			
		    ACQUIRE_ELAN_LOCK(pElan);
		    if (ELAN_STATE_ALLOCATED == pElan->State)
		    {
				pElan->AdminState = ELAN_STATE_OPERATIONAL;
				pElan->State = ELAN_STATE_INIT;
				AtmLaneQueueElanEventAfterDelay(pElan, ELAN_EVENT_START, Status, 1*1000);
			}
			RELEASE_ELAN_LOCK(pElan);
		
			p = p->Flink;
		}
	}
	
	if (bBootStrapping)
	{
		ACQUIRE_ADAPTER_LOCK(pAdapter);
		pAdapter->Flags &= ~ADAPTER_FLAGS_BOOTSTRAP_IN_PROGRESS;
		RELEASE_ADAPTER_LOCK(pAdapter);

		SIGNAL_BLOCK_STRUCT(&pAdapter->UnbindBlock, NDIS_STATUS_SUCCESS);
	}

	TRACEOUT(BootStrapElans);
	return;
}


NDIS_STATUS
AtmLaneCreateElan(
    IN  PATMLANE_ADAPTER            pAdapter,
    IN  PNDIS_STRING                pElanKey,
    OUT	PATMLANE_ELAN *				ppElan
)
/*++

Routine Description:

	Create and start an ELAN.
	
Arguments:

	pAdapter	    -   Pointer to ATMLANE Adapter structure
	pElanKey	    -   Points to a Unicode string naming the elan to create. 
	ppElan			- 	Pointer to pointer to ATMLANE_ELAN (output)
	
Return Value:

	None

--*/
{
	NDIS_STATUS			Status;
	PATMLANE_ELAN       pElan;


    TRACEIN(CreateElan);


    Status = NDIS_STATUS_SUCCESS;
    pElan = NULL_PATMLANE_ELAN;

    DBGP((1, "CreateElan: Adapter %p, ElanKey %ws\n", pAdapter, pElanKey->Buffer));

	do
	{
		//
		//  Weed out duplicates.
		//
		if (pElanKey != NULL)
		{

			pElan = AtmLaneFindElan(pAdapter, pElanKey);

			if (NULL_PATMLANE_ELAN != pElan)
			{
				// Duplicate
				DBGP((0, "CreateElan: found duplicate pElan %p\n", pElan));

				Status = NDIS_STATUS_FAILURE;
				pElan = NULL_PATMLANE_ELAN;
				break;
			}
		}

		//
		//	Allocate an ELAN data structure.
		//
		Status = AtmLaneAllocElan(pAdapter, &pElan);
		if (NDIS_STATUS_SUCCESS != Status)
		{
			DBGP((0, "CreateElan: Failed allocate of elan data\n"));
			break;
		}

		//
		//	Put initial reference on the Elan struct.
		//
		AtmLaneReferenceElan(pElan, "adapter");		

		//
		//	Store in bind name (NT only, not supplied on Win98)
		//
		if (pElanKey != NULL)
		{
			if (!AtmLaneCopyUnicodeString(&pElan->CfgBindName, pElanKey, TRUE, TRUE))
			{
				DBGP((0, "CreateElan: Failed allocate of bind name string\n"));
				Status = NDIS_STATUS_RESOURCES;
				break;
			}
		}

		//
		//	Get the ELAN's configuration.
		//
		AtmLaneGetElanConfiguration(pElanKey, pElan);
		

		//
		//  Allocate protocol buffers for this Elan.
		//
		Status = AtmLaneInitProtoBuffers(pElan);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, 
				"CreateElan: bad status (%x) from InitBufs\n",
				Status));
			break;
		}

		//
		//	Allocate transmit packet descriptors for this Elan.
		//
		NdisAllocatePacketPool(
				&Status, 
				&pElan->TransmitPacketPool, 
				pElan->MaxHeaderBufs,
				sizeof(SEND_PACKET_RESERVED)
				);
#if PKT_HDR_COUNTS
		pElan->XmitPktCount = pElan->MaxHeaderBufs;
		DBGP((1, "XmitPktCount %d\n", pElan->XmitPktCount));
#endif

		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, 
				"CreateElan: bad status (%x)"
				" from NdisAllocatePacketPool (xmit)\n",
				Status));
			break;
		}

		//
		//	Allocate receive packet descriptors for this Elan.
		//
		NdisAllocatePacketPool(
				&Status, 
				&pElan->ReceivePacketPool, 
				pElan->MaxHeaderBufs,
				sizeof(RECV_PACKET_RESERVED)
				);
#if PKT_HDR_COUNTS
		pElan->RecvPktCount = pElan->MaxHeaderBufs;
		DBGP((1, "RecvPktCount %d\n", pElan->RecvPktCount));
#endif
		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, 
				"CreateElan: bad status (%x)"
				" from NdisAllocatePacketPool (xmit)\n",
				Status));
			break;
		}

		//
		//	Allocate receive buffer descriptors for this Elan.
		//
		NdisAllocateBufferPool(&Status, 
					&pElan->ReceiveBufferPool, 
					pElan->MaxHeaderBufs
					);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, 
				"AfRegisterNotifyHandler: bad status (%x)"
				" from NdisAllocateBufferPool\n",
				Status));
			break;
		}
	
	}
	while (FALSE);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		//
		//	There was a failure in processing this Elan.
		//
		if (NULL_PATMLANE_ELAN != pElan)
		{
			ACQUIRE_ELAN_LOCK(pElan);
			AtmLaneDereferenceElan(pElan, "adapter");
		}

		*ppElan = NULL_PATMLANE_ELAN;
	}
	else
	{
		//	Output created Elan
	
		*ppElan = pElan;
	}


    TRACEOUT(CreateElan);

    return Status;
}

NDIS_STATUS
AtmLaneReconfigureHandler(
	IN	PATMLANE_ADAPTER		pAdapter,
	IN	PNET_PNP_EVENT			pNetPnPEvent
)
/*++

Routine Description:

	Handler for PnP Reconfigure events.

Arguments:

	pAdapter		-	Pointer to our adapter struct.

	pNetPnPEvent	- 	Pointer to PnP Event structure describing the event.

Return Value:

	Status of handling the reconfigure event.
	
--*/
{
	NDIS_STATUS						Status;
	PATMLANE_PNP_RECONFIG_REQUEST	pReconfig;
	NDIS_STRING						ElanKey;
	PATMLANE_ELAN					pElan;

	TRACEIN(ReconfigureHandler);

	do
	{
		DBGP((1, "Reconfigurehandler: Buffer 0x%x BufferLength %d\n",
					pNetPnPEvent->Buffer, pNetPnPEvent->BufferLength));

		Status = NDIS_STATUS_SUCCESS;

		if (pAdapter == NULL_PATMLANE_ADAPTER)
		{
			//
			//  Either a global reconfig notification or this is
			//  NDIS itself asking us to re-evaluate our ELANs.
			//  We go through the list of configured ELANs on all
			//  adapters and start any that haven't been started.
			//
			{
				PLIST_ENTRY		pEnt, pNextEnt;

				ACQUIRE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

				for (pEnt = pAtmLaneGlobalInfo->AdapterList.Flink;
					 pEnt != &pAtmLaneGlobalInfo->AdapterList;
					 pEnt = pNextEnt)
				{
					pNextEnt = pEnt->Flink;
					RELEASE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

					pAdapter = CONTAINING_RECORD(pEnt, ATMLANE_ADAPTER, Link);

			        if (pAdapter->Flags & ADAPTER_FLAGS_AF_NOTIFIED)
			        {
						DBGP((1, "Reconfig: Will bootstrap ELANs on Adapter %x\n",
								pAdapter));

						AtmLaneBootStrapElans(pAdapter);
					}

					ACQUIRE_GLOBAL_LOCK(pAtmLaneGlobalInfo);
				}

				RELEASE_GLOBAL_LOCK(pAtmLaneGlobalInfo);
			}


			break;
		}
	
		//	Get pointer to LANE reconfig struct inside the generic PnP struct
	
		pReconfig = (PATMLANE_PNP_RECONFIG_REQUEST)(pNetPnPEvent->Buffer);

		// 	Check for null pointer

		if (pReconfig == NULL)
		{
			DBGP((0, "ReconfigureHandler: NULL pointer to event buffer!\n"));
			Status = NDIS_STATUS_INVALID_DATA;
			break;
		}

		//	Validate the version

		if (pReconfig->Version != 1)
		{
			DBGP((0, "ReconfigureHandler: Version not 1\n"));
			Status = NDIS_STATUS_BAD_VERSION;
			break;
		}

		//	Build a UNICODE string containing the ELAN's key

		NdisInitUnicodeString(&ElanKey, pReconfig->ElanKey);

		//	First find the Elan

		pElan = AtmLaneFindElan(pAdapter, &ElanKey);

		DBGP((0, "ReconfigHandler: Adapter %x, ELAN %x, OpType %d\n",
					pAdapter, pElan, pReconfig->OpType));

		//  Sanity check: don't add an existing ELAN

		if (ATMLANE_RECONFIG_OP_ADD_ELAN == pReconfig->OpType &&
			NULL_PATMLANE_ELAN != pElan)
		{
			DBGP((0, "ReconfigureHandler: Ignoring ADD existing Elan %x\n", pElan));
			Status = NDIS_STATUS_SUCCESS;
			break;
		}

		//	If MOD or DEL first shutdown the existing ELAN

		if (ATMLANE_RECONFIG_OP_MOD_ELAN == pReconfig->OpType ||
			ATMLANE_RECONFIG_OP_DEL_ELAN == pReconfig->OpType)
		{
			
			if (NULL_PATMLANE_ELAN == pElan)
			{
				DBGP((0, "ReconfigureHandler: No existing Elan found for Modify/Delete\n"));
				Status = NDIS_STATUS_FAILURE;
				break;
			}
			
			//	Shut down the existing Elan

			ACQUIRE_ELAN_LOCK(pElan);
			AtmLaneShutdownElan(pElan, FALSE);
		}

		// 	If ADD or MOD startup the new ELAN

		if (ATMLANE_RECONFIG_OP_ADD_ELAN == pReconfig->OpType ||
			ATMLANE_RECONFIG_OP_MOD_ELAN == pReconfig->OpType)
		{
			Status = AtmLaneCreateElan(pAdapter, &ElanKey, &pElan);
			if (NDIS_STATUS_SUCCESS == Status)
			{
		    	pElan->AdminState = ELAN_STATE_OPERATIONAL;
		    	pElan->State = ELAN_STATE_INIT;
				AtmLaneQueueElanEventAfterDelay(pElan, ELAN_EVENT_START, Status, 1*1000);
			}
		}

	} while (FALSE);

	TRACEOUT(ReconfigureHandler);
	DBGP((0, "Reconfigure: pAdapter %x, returning %x\n", pAdapter, Status));
	return Status;
}

PATMLANE_ELAN
AtmLaneFindElan(
	IN	PATMLANE_ADAPTER		pAdapter,
	IN	PNDIS_STRING			pElanKey
)
/*++

Routine Description:

	Find an ELAN by bind name/key

Arguments:

	pAdapter		-	Pointer to an adapter struct.

	pElanKey		- 	Pointer to NDIS_STRING containing Elan's bind name.

Return Value:

	Pointer to matching Elan or NULL if not found.
	
--*/
{
	PLIST_ENTRY 		p;
	PATMLANE_ELAN		pElan;
	BOOLEAN				Found;
	NDIS_STRING			ElanKeyName;

	TRACEIN(FindElan);
	DBGP((1, "FindElan: Adapter %p, ElanKey %ws\n", pAdapter, pElanKey->Buffer));

	Found = FALSE;
	ElanKeyName.Buffer = NULL;
	pElan = NULL_PATMLANE_ELAN;

	do
	{
		//
		//  Make an up-cased copy of the given string.
		//
		ALLOC_MEM(&ElanKeyName.Buffer, pElanKey->MaximumLength);
		if (ElanKeyName.Buffer == NULL)
		{
			break;
		}

		ElanKeyName.Length = pElanKey->Length;
		ElanKeyName.MaximumLength = pElanKey->MaximumLength;

#ifndef LANE_WIN98
		(VOID)NdisUpcaseUnicodeString(&ElanKeyName, pElanKey);
#else
		memcpy(ElanKeyName.Buffer, pElanKey->Buffer, ElanKeyName.Length);
#endif // LANE_WIN98

		ACQUIRE_ADAPTER_LOCK(pAdapter);

		p = pAdapter->ElanList.Flink;
		while (p != &pAdapter->ElanList)
		{
			pElan = CONTAINING_RECORD(p, ATMLANE_ELAN, Link);
			STRUCT_ASSERT(pElan, atmlane_elan);

			// compare the key

			if ((ElanKeyName.Length == pElan->CfgBindName.Length) &&
				(memcmp(ElanKeyName.Buffer, pElan->CfgBindName.Buffer, ElanKeyName.Length) == 0))
			{
				//
				//  Skip ELANs that are shutting down and not restarting
				//
				if ((pElan->AdminState != ELAN_STATE_SHUTDOWN) ||
					((pElan->Flags & ELAN_NEEDS_RESTART) != 0))
				{
					Found = TRUE;
					break;
				}
			}
		
			// get next link

			p = p->Flink;
		}

		RELEASE_ADAPTER_LOCK(pAdapter);
	}
	while (FALSE);

	if (!Found)
	{
		DBGP((2, "FindElan: No match found!\n"));
	
		pElan = NULL_PATMLANE_ELAN;
	}

	if (ElanKeyName.Buffer)
	{
		FREE_MEM(ElanKeyName.Buffer);
	}

	TRACEOUT(FindElan);
	return pElan;
}

VOID
AtmLaneConnectToServer(
	IN	PATMLANE_ELAN				pElan,
	IN	ULONG						ServerType,
	IN	BOOLEAN						UsePvc
)
/*++

Routine Description:

	Setup and make call to a LANE Server.


Arguments:

	pElan		- Pointer to ATMLANE Elan structure

	ServerType	- LECS, LES, or BUS

Return Value:

	None

--*/
{
	NDIS_STATUS				Status;
	ULONG					rc;
	PATMLANE_ATM_ENTRY		pAtmEntry;

	TRACEIN(ConnectToServer);

	do
	{
		switch (ServerType)
		{
			case ATM_ENTRY_TYPE_LECS:

				//
				//	Create the ATM Entry
				//
				pAtmEntry = AtmLaneAllocateAtmEntry(pElan);
				if (NULL_PATMLANE_ATM_ENTRY != pAtmEntry)
				{
					//
					//	Init ATM Entry
					//
					pAtmEntry->Type = ServerType;
					NdisMoveMemory(
						&pAtmEntry->AtmAddress, 
						&pElan->LecsAddress, 
						sizeof(ATM_ADDRESS));

					//
					//  Add it to the Elan's list
					//
					ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);
					pElan->pLecsAtmEntry = pAtmEntry;
					pAtmEntry->pNext = pElan->pAtmEntryList;
					pElan->pAtmEntryList = pAtmEntry;
					pElan->NumAtmEntries++;
					RELEASE_ELAN_ATM_LIST_LOCK(pElan);

					ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);

				}
				break;

			case ATM_ENTRY_TYPE_LES:
				//
				//	Create the ATM Entry
				//
				pAtmEntry = AtmLaneAllocateAtmEntry(pElan);
				if (NULL_PATMLANE_ATM_ENTRY != pAtmEntry)
				{
					//
					//	Init ATM Entry
					//
					pAtmEntry->Type = ServerType;

					NdisMoveMemory(
						&pAtmEntry->AtmAddress, 
						&pElan->LesAddress, 
						sizeof(ATM_ADDRESS));
					//
					//  Add it to the Elan's list
					//
					ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);
					pElan->pLesAtmEntry = pAtmEntry;
					pAtmEntry->pNext = pElan->pAtmEntryList;
					pElan->pAtmEntryList = pAtmEntry;
					pElan->NumAtmEntries++;
					RELEASE_ELAN_ATM_LIST_LOCK(pElan);

					ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
				}
				break;
				
			case ATM_ENTRY_TYPE_BUS:
			
				ASSERT(NULL_PATMLANE_ATM_ENTRY != pElan->pBusAtmEntry);
				
				NdisMoveMemory(
					&pElan->BusAddress, 
					&pElan->pBusAtmEntry->AtmAddress, 
					sizeof(ATM_ADDRESS));

				pAtmEntry = pElan->pBusAtmEntry;

				ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
				
				break;
		}

		if (NULL_PATMLANE_ATM_ENTRY == pAtmEntry)
		{
			break;
		}
		
		//
		//	Call the Server
		//
		DBGP((1, "%d: ConnectToServer: pElan %x/ref %d, Type %d, pAtmEnt %x, Ref %d\n",
					pElan->ElanNumber,
					pElan,
					pElan->RefCount,
					ServerType,
					pAtmEntry,
					pAtmEntry->RefCount));

		
		Status = AtmLaneMakeCall(pElan, pAtmEntry, UsePvc);
	
		if (NDIS_STATUS_SUCCESS == Status)
		{
			//
			//	Call completed synchronously.
			//	
			AtmLaneQueueElanEvent(pElan, ELAN_EVENT_SVR_CALL_COMPLETE, Status);
			break;
		}
				
		if (NDIS_STATUS_PENDING != Status)
		{
			// 
			//	Call failed.
			//	Dereference Atm Entry (should delete it).
			//	Signal the elan state machine.
			//
			ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
			rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "elan");		// Elan list reference
			ASSERT(0 == rc);

			AtmLaneQueueElanEvent(pElan, ELAN_EVENT_SVR_CALL_COMPLETE, Status);
			
			break;
		}
	}
	while (FALSE);

	TRACEOUT(ConnectToServer);

	return;
}


VOID
AtmLaneInvalidateAtmEntry(
	IN	PATMLANE_ATM_ENTRY			pAtmEntry	LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Invalidate an ATM Entry by unlinking it from MAC entries and
	closing VC's on it.

Arguments:

	pAtmEntry		- The ATM Entry needing invalidating.

Return Value:

	None

--*/
{
	PATMLANE_MAC_ENTRY		pMacEntry;
	PATMLANE_MAC_ENTRY		pNextMacEntry;
	ULONG					rc;			// Ref Count of ATM Entry
	INT						MacEntriesUnlinked;

	TRACEIN(InvalidateAtmEntry);

	DBGP((1, "%d Del ATM %x: %s\n", 
		pAtmEntry->pElan->ElanNumber,
		pAtmEntry,
		AtmAddrToString(pAtmEntry->AtmAddress.Address)));

	DBGP((3, 
		"InvalidateAtmEntry: pAtmEntry %x, pMacEntryList %x\n",
				pAtmEntry,
				pAtmEntry->pMacEntryList));
	//
	//  Initialize.
	//
	MacEntriesUnlinked = 0;

	//
	//  Take the MAC Entry list out of the ATM Entry.
	//
	pMacEntry = pAtmEntry->pMacEntryList;
	pAtmEntry->pMacEntryList = NULL_PATMLANE_MAC_ENTRY;

	//
	//  We let go of the ATM Entry lock here because we'll need
	//  to lock each MAC Entry in the above list, and we need to make
	//  sure that we don't deadlock.
	//
	//  However, we make sure that the ATM Entry doesn't go away
	//  by adding a reference to it.
	//
	AtmLaneReferenceAtmEntry(pAtmEntry, "temp");	// Temp ref
	RELEASE_ATM_ENTRY_LOCK(pAtmEntry);

	//
	//  Now unlink all MAC entries.
	//
	while (pMacEntry != NULL_PATMLANE_MAC_ENTRY)
	{
		ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
		pNextMacEntry = pMacEntry->pNextToAtm;

		//
		//  Remove the mapping.
		//
		pMacEntry->Flags = MAC_ENTRY_NEW;
		pMacEntry->pAtmEntry = NULL_PATMLANE_ATM_ENTRY;
		pMacEntry->pNextToAtm = NULL_PATMLANE_MAC_ENTRY;

		//
		//  Remove the ATM Entry linkage reference.
		//
		if (AtmLaneDereferenceMacEntry(pMacEntry, "atm") != 0)
		{
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
		}
		//
		//  else the MAC Entry is gone
		//

		MacEntriesUnlinked++;

		pMacEntry = pNextMacEntry;
	}

	ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);

	//
	//  Now dereference the ATM Entry as many times as we unliked
	//  MAC Entries from it.
	//
	while (MacEntriesUnlinked-- > 0)
	{
		rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "mac");	// MAC Entry reference
		ASSERT(rc != 0);
	}

	//
	//  Take out the reference we added at the beginning of
	//  this routine.
	//
	rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "temp");	// Temp ref

	//
	//  Close the SVCs attached to the ATM Entry. 
	//  But do all this only if the ATM Entry
	//  hasn't been dereferenced away already.
	//
	if (rc != 0)
	{
		//
		//  The ATM Entry still exists.
		//	Close the VCs.
		//
		AtmLaneCloseVCsOnAtmEntry(pAtmEntry);
		//
		//  The ATM Entry lock is released within the above.
		//
	}
	//
	//  else the ATM Entry is gone
	//
	TRACEOUT(InvalidateAtmEntry);
	return;
}


VOID
AtmLaneCloseVCsOnAtmEntry(
	IN	PATMLANE_ATM_ENTRY			pAtmEntry		LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Close the (potentially two) VCs attached to an ATM Entry.
	
Arguments:

	pAtmEntry			- Pointer to ATM Entry on which we want to close SVCs.

Return Value:

	None

--*/
{
	PATMLANE_VC		pVcList;			// List of "Main" VCs on the ATM Entry
	PATMLANE_VC		pVc;				// Main VC on the ATM Entry
	PATMLANE_VC		pVcIncomingList;	// List of Optional incoming VCs on ATM Entry
	PATMLANE_VC		pVcIncoming;		// Optional incoming VC on ATM Entry
	PATMLANE_VC		pNextVc;			// Temp, for traversing VC lists.
	ULONG			rc;					// Ref count on ATM Entry

	TRACEIN(CloseVCsOnAtmEntry);

	//
	//  Initialize.
	//
	rc = pAtmEntry->RefCount;

	//
	//	Take out the Main VC list from the ATM Entry.
	//	
	pVcList = pAtmEntry->pVcList;
	pAtmEntry->pVcList = NULL_PATMLANE_VC;

	//
	//  Deref the ATM Entry for each of the Main VCs.
	//
	for (pVc = pVcList;
		 NULL_PATMLANE_VC != pVc;
		 pVc = pNextVc)
	{
		ASSERT(rc != 0);

		ACQUIRE_VC_LOCK(pVc);
		pNextVc = pVc->pNextVc;
	
		//
		//	Unlink this VC from the ATM Entry.
		//
		pVc->pAtmEntry = NULL_PATMLANE_ATM_ENTRY;

		//
		//	Leave AtmEntry Reference on VC so it doesn't go away
		//	
		RELEASE_VC_LOCK(pVc);

		DBGP((1, "%d unlink VC %x/%x, Ref %d from ATM Entry %x\n",
				pAtmEntry->pElan->ElanNumber,
				pVc, pVc->Flags, pVc->RefCount,
				pAtmEntry));

		//
		//	Dereference the ATM Entry.
		//
		rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "vc");	// VC reference
	}

	if (rc != 0)
	{
		//
		//  Take out the Incoming VC list from the ATM Entry.
		//
		pVcIncomingList = pAtmEntry->pVcIncoming;
		pAtmEntry->pVcIncoming = NULL_PATMLANE_VC;

		//
		//  Deref the ATM Entry for each of the Incoming VCs.
		//
		for (pVcIncoming = pVcIncomingList;
 			NULL_PATMLANE_VC != pVcIncoming;
 			pVcIncoming = pNextVc)
		{
			ASSERT(rc != 0);

			ACQUIRE_VC_LOCK(pVcIncoming);
			pNextVc = pVcIncoming->pNextVc;

			//
			//	Unlink this VC from the ATM Entry.
			//
			pVcIncoming->pAtmEntry = NULL_PATMLANE_ATM_ENTRY;
		
			//
			//	Leave AtmEntry Reference on VC so it doesn't go away
			//	
			RELEASE_VC_LOCK(pVcIncoming);

			DBGP((1, "%d unlink Incoming VC %x from ATM Entry %x\n",
					pAtmEntry->pElan->ElanNumber,
					pVcIncoming,
					pAtmEntry));

			//
			//	Dereference the ATM Entry.
			//
			rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "vc");	// VC reference
		}
	}
	else
	{
		pVcIncomingList = NULL_PATMLANE_VC;
	}
	
	if (rc != 0)
	{
		//
		//  The ATM Entry lives on. We don't need a lock to it anymore.
		//
		RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
	}

	//
	//  Now close the VC(s).
	//

	for (pVc = pVcList;
		 NULL_PATMLANE_VC != pVc;
		 pVc = pNextVc)
	{
		ACQUIRE_VC_LOCK(pVc);
		pNextVc = pVc->pNextVc;
		
		rc = AtmLaneDereferenceVc(pVc, "atm");	// ATM Entry reference
		if (rc != 0)
		{
			AtmLaneCloseCall(pVc);
			//
			//  The VC lock is released within the above.
			//
		}
		//
		//  else the VC is gone.
		//
	}
	
	for (pVcIncoming = pVcIncomingList;
		 NULL_PATMLANE_VC != pVcIncoming;
		 pVcIncoming = pNextVc)
	{
		ACQUIRE_VC_LOCK(pVcIncoming);
		pNextVc = pVcIncoming->pNextVc;
		
		rc = AtmLaneDereferenceVc(pVcIncoming, "atm");	// ATM Entry reference
		if (rc != 0)
		{
			AtmLaneCloseCall(pVcIncoming);
			//
			//  The VC lock is released within the above.
			//
		}
		//
		//  else the VC is gone.
		//
	}

	TRACEOUT(CloseVCsOnAtmEntry);

	return;
}


VOID
AtmLaneGenerateMacAddr(
	PATMLANE_ELAN					pElan
)
/*++

Routine Description:

	Generates a "virtual" MAC address for Elans after the first
	Elan on an ATM interface.
	
Arguments:

	pElan					- Pointer to ATMLANE elan structure

Return Value:

	None

--*/
{

	TRACEIN(GenerateMacAddress);

	//
	//	Start by using the real ATM card's MAC address
	//
	
	NdisMoveMemory(
		&pElan->MacAddressEth,
		&pElan->pAdapter->MacAddress, 
		sizeof(MAC_ADDRESS)
		);
		
	if (pElan->ElanNumber != 0)
	{
		//
		//	Not Elan number zero so generate a locally 
		//	administered address by manipulating the first two bytes.
		//
		pElan->MacAddressEth.Byte[0] = 
			0x02 | (((UCHAR)pElan->ElanNumber & 0x3f) << 2);
		pElan->MacAddressEth.Byte[1] = 
			(pElan->pAdapter->MacAddress.Byte[1] & 0x3f) | 
			((UCHAR)pElan->ElanNumber & 0x3f);
	}	

	//
	//	Create the Token Ring version of the MAC Address
	//
	NdisMoveMemory(
		&pElan->MacAddressTr, 
		&pElan->MacAddressEth,
		sizeof(MAC_ADDRESS)
		);

	AtmLaneBitSwapMacAddr((PUCHAR)&pElan->MacAddressTr);

	DBGP((1, "%d MacAddrEth %s\n",
		pElan->ElanNumber, MacAddrToString(&pElan->MacAddressEth)));
	DBGP((1, "%d MacAddrTr  %s\n",
		pElan->ElanNumber, MacAddrToString(&pElan->MacAddressTr)));

	TRACEOUT(GenerateMacAddress);
	return;
}

PATMLANE_MAC_ENTRY
AtmLaneSearchForMacAddress(
	PATMLANE_ELAN					pElan,
	ULONG							MacAddrType,
	PMAC_ADDRESS					pMacAddress,
	BOOLEAN							CreateNew
)
/*++

Routine Description:

	Search for an MAC Address in the MAC Table. Optionally, create one
	if a match is not found.

	The caller is assumed to hold a lock to the MAC Table.

Arguments:

	pElan					- Pointer to ATMLANE Elan
	MacAddrType				- Type of MAC Addr (MAC vs RD)
	pMacAddress				- what we are looking for
	CreateNew				- Should a new entry be created if no match?

Return Value:

	Pointer to a matching Mac Entry if found (or created anew).

--*/
{
	ULONG					HashIndex;
	PATMLANE_MAC_ENTRY		pMacEntry;
	BOOLEAN					Found;

	TRACEIN(SearchForMacAddress);

	HashIndex = ATMLANE_HASH(pMacAddress);
	Found = FALSE;

	pMacEntry = pElan->pMacTable[HashIndex];

	//
	//  Go through the addresses in this hash list.
	//
	while (pMacEntry != NULL_PATMLANE_MAC_ENTRY)
	{
		if (!IS_FLAG_SET(
				pMacEntry->Flags,
				MAC_ENTRY_STATE_MASK,
				MAC_ENTRY_ABORTING) &&
			(MAC_ADDR_EQUAL(&pMacEntry->MacAddress, pMacAddress)) &&
			(pMacEntry->MacAddrType == MacAddrType))
		{
			Found = TRUE;
			break;
		}
		pMacEntry = pMacEntry->pNextEntry;
	}

	if (!Found && CreateNew && (pElan->AdminState != ELAN_STATE_SHUTDOWN))
	{
		pMacEntry = AtmLaneAllocateMacEntry(pElan);

		if (pMacEntry != NULL_PATMLANE_MAC_ENTRY)
		{
			//
			//  Fill in this new entry.
			//
			NdisMoveMemory(&pMacEntry->MacAddress, pMacAddress, sizeof(MAC_ADDRESS));
			pMacEntry->MacAddrType = MacAddrType;
			AtmLaneReferenceMacEntry(pMacEntry, "table");	// Mac Table linkage

			//
			//  Link it to the hash table.
			//
			pMacEntry->pNextEntry = pElan->pMacTable[HashIndex];
			pElan->pMacTable[HashIndex] = pMacEntry;
			pElan->NumMacEntries++;

			DBGP((1, "%d New MAC %x: %s\n", 
				pElan->ElanNumber,
				pMacEntry,
				MacAddrToString(pMacAddress)));
		}
		else
		{
			DBGP((0, "SearchForMacAddress: alloc of new mac entry failed\n"));
		}
	}

	TRACEOUT(SearchForMacAddress);
	return (pMacEntry);
}

PATMLANE_ATM_ENTRY
AtmLaneSearchForAtmAddress(
	IN	PATMLANE_ELAN				pElan,
	IN	PUCHAR						pAtmAddress,
	IN	ULONG						Type,
	IN	BOOLEAN						CreateNew
)
/*++

Routine Description:

	Search for an ATM Entry that matches the given ATM address and type.
	Optionally, create one if there is no match.

	NOTE: this routine references the ATM entry it returns. The caller
	should deref it.

Arguments:

	pElan					- Pointer to ATMLANE Elan
	pAtmAddress				- ATM Address
	Type					- ATM Entry Type (Peer, LECS, LES, BUS)
	CreateNew				- Do we create a new entry if we don't find one?

Return Value:

	Pointer to a matching ATM Entry if found (or created anew).

--*/
{
	PATMLANE_ATM_ENTRY			pAtmEntry;
	BOOLEAN						Found;

	TRACEIN(SearchForAtmAddress);

	ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

	//
	//  Go through the list of ATM Entries on this interface.
	//
	Found = FALSE;
	for (pAtmEntry = pElan->pAtmEntryList;
			 pAtmEntry != NULL_PATMLANE_ATM_ENTRY;
			 pAtmEntry = pAtmEntry->pNext)
	{
		//
		//  Compare the ATM Address and Type
		//
		if ((ATM_ADDR_EQUAL(pAtmAddress, pAtmEntry->AtmAddress.Address)) &&
		     (pAtmEntry->Type == Type) &&
			 ((pAtmEntry->Flags & ATM_ENTRY_WILL_ABORT) == 0))
		{
			Found = TRUE;
			break;
		}
	}

	if (!Found && CreateNew && (pElan->State != ELAN_STATE_SHUTDOWN))
	{
		pAtmEntry = AtmLaneAllocateAtmEntry(pElan);

		if (pAtmEntry != NULL_PATMLANE_ATM_ENTRY)
		{
			//
			//  Fill in this new entry.
			//
			pAtmEntry->Flags = ATM_ENTRY_VALID;

			//
			//  The ATM Address.
			//
			pAtmEntry->AtmAddress.AddressType = ATM_NSAP;
			pAtmEntry->AtmAddress.NumberOfDigits = ATM_ADDRESS_LENGTH;
			NdisMoveMemory(
					pAtmEntry->AtmAddress.Address,
					pAtmAddress,
					ATM_ADDRESS_LENGTH);

			//
			//	The Type.
			//
			pAtmEntry->Type = Type;

			//
			//  Link in this entry to the Elan
			//
			pAtmEntry->pNext = pElan->pAtmEntryList;
			pElan->pAtmEntryList = pAtmEntry;
			pElan->NumAtmEntries++;


			DBGP((1, "%d New ATM %x: %s\n", 
				pElan->ElanNumber, 
				pAtmEntry,
				AtmAddrToString(pAtmAddress)));
		}
	}

	//
	//  Reference this ATM entry so that it won't be derefed away
	//  before the caller gets to use this.
	//
	if (NULL_PATMLANE_ATM_ENTRY != pAtmEntry)
	{
		ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		AtmLaneReferenceAtmEntry(pAtmEntry, "search");
		RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
	}

	RELEASE_ELAN_ATM_LIST_LOCK(pElan);

	TRACEOUT(SearchForAtmAddress);
	return (pAtmEntry);
}

ULONG
AtmLaneMacAddrEqual(
	PMAC_ADDRESS			pMacAddr1,
	PMAC_ADDRESS			pMacAddr2
)
/*++

Routine Description:

	Compares two 48bit(6 Byte) MAC Addresses.
	
Arguments:

	pMacAddr1			- First MAC Address.
	pMacAddr2			- Second MAC Address.
	
Return Value:

	1 if equal, 0 if not equal.

--*/
{
	ULONG		Result;

	TRACEIN(MacAddrEqual);

	//
	//	Assume not equal
	//
	Result = 0;
		
	do
	{
		//
		//	Studies have shown the fifth byte to be
		//	the most unique on a network.
		//	
		if (pMacAddr1->Byte[4] != pMacAddr2->Byte[4])
			break;
		if (pMacAddr1->Byte[5] != pMacAddr2->Byte[5])
			break;
		if (pMacAddr1->Byte[3] != pMacAddr2->Byte[3])
			break;
		if (pMacAddr1->Byte[2] != pMacAddr2->Byte[2])
			break;
		if (pMacAddr1->Byte[1] != pMacAddr2->Byte[1])
			break;
		if (pMacAddr1->Byte[0] != pMacAddr2->Byte[0])
			break;
	
		Result = 1;
		break;
	}
	while (FALSE);

	TRACEOUT(MacAddrEqual);
	return Result;
}

VOID
AtmLaneAbortMacEntry(
	IN	PATMLANE_MAC_ENTRY			pMacEntry
)
/*++

Routine Description:

	Clean up and delete an Mac entry.

	The caller is assumed to hold a lock to the Mac Entry,
	which will be released here.

Arguments:

	pMacEntry		- Pointer to Mac Entry to be deleted.

Return Value:

	None

--*/
{
	PATMLANE_ELAN			pElan;
	PATMLANE_MAC_ENTRY *	ppNextMacEntry;
	ULONG					rc;	
	BOOLEAN					Found;
	BOOLEAN					TimerWasRunning;
	ULONG					HashIndex;
	PNDIS_PACKET			pNdisPacket;

	TRACEIN(AbortMacEntry);

	DBGP((1, "%d Del MAC %x: %s\n", 
		pMacEntry->pElan->ElanNumber,
		pMacEntry,
		MacAddrToString(&pMacEntry->MacAddress)));

	//
	//  Initialize.
	//
	rc = pMacEntry->RefCount;
	pElan = pMacEntry->pElan;

	do
	{
		if (IS_FLAG_SET(
			pMacEntry->Flags,
			MAC_ENTRY_STATE_MASK,
			MAC_ENTRY_ABORTING))
		{
			DBGP((1, "%d MAC %x already aborting\n",
				pMacEntry->pElan->ElanNumber,
				pMacEntry));
			
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
			break;
		}

		//
		//	Set State to ABORTING
		//
		SET_FLAG(
				pMacEntry->Flags,
				MAC_ENTRY_STATE_MASK,
				MAC_ENTRY_ABORTING);

		//
		//	Put temp reference on mac entry
		//
		AtmLaneReferenceMacEntry(pMacEntry, "temp");

		//
		//  Reacquire the desired locks in the right order.
		//
		RELEASE_MAC_ENTRY_LOCK(pMacEntry);
		ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan);
		ACQUIRE_MAC_ENTRY_LOCK_DPC(pMacEntry);

		//
		//  Unlink this MAC Entry from the MAC Table
		//
		Found = FALSE;

		HashIndex = ATMLANE_HASH(&pMacEntry->MacAddress);
		ppNextMacEntry = &(pElan->pMacTable[HashIndex]);
		while (*ppNextMacEntry != NULL_PATMLANE_MAC_ENTRY)
		{
			if (*ppNextMacEntry == pMacEntry)
			{
				//
				//  Make the predecessor point to the next
				//  in the list.
				//
				*ppNextMacEntry = pMacEntry->pNextEntry;
				Found = TRUE;
				pElan->NumMacEntries--;
				break;
			}
			else
			{
				ppNextMacEntry = &((*ppNextMacEntry)->pNextEntry);
			}
		}

		if (Found)
		{
			AtmLaneDereferenceMacEntry(pMacEntry, "table");	
		}

		RELEASE_MAC_ENTRY_LOCK_DPC(pMacEntry);
		RELEASE_ELAN_MAC_TABLE_LOCK(pElan);
		ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
	
		//
		//  Unlink MAC Entry from the Atm Entry
		//
		if (pMacEntry->pAtmEntry != NULL_PATMLANE_ATM_ENTRY)
		{
			SET_FLAG(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_NEW);

			Found = AtmLaneUnlinkMacEntryFromAtmEntry(pMacEntry);
			pMacEntry->pAtmEntry = NULL_PATMLANE_ATM_ENTRY;

			if (Found)
			{
				AtmLaneDereferenceMacEntry(pMacEntry, "atm");
			}
		}

		//
		//  Stop Arp or Aging timer running on the MAC Entry.
		//
		TimerWasRunning = AtmLaneStopTimer(&(pMacEntry->Timer), pElan);
		if (TimerWasRunning)
		{
			AtmLaneDereferenceMacEntry(pMacEntry, "timer");
		}

		//
		//	Stop Bus Timer
		//
		NdisCancelTimer(&pMacEntry->BusTimer, &TimerWasRunning);
		if (TimerWasRunning)
		{	
			AtmLaneDereferenceMacEntry(pMacEntry, "bus timer");
		}

		//
		//	Stop Flush Timer
		//
		TimerWasRunning = AtmLaneStopTimer(&pMacEntry->FlushTimer, pElan);
		if (TimerWasRunning)
		{
			AtmLaneDereferenceMacEntry(pMacEntry, "flush timer");
		}

		//
		//	Now complete all packets hanging on the MacEntry
		//
		DBGP((1, "%d: Aborting MAC %x, Before: PktList %x, PktListCount %d\n",
				pElan->ElanNumber, pMacEntry, pMacEntry->PacketList, pMacEntry->PacketListCount));
		AtmLaneFreePacketQueue(pMacEntry, NDIS_STATUS_SUCCESS);

		DBGP((1, "%d: Aborting MAC %x, After:  PktList %x, PktListCount %d\n",
				pElan->ElanNumber, pMacEntry, pMacEntry->PacketList, pMacEntry->PacketListCount));
		
		//
		//	Remove temp reference and unlock if still around
		//
		rc = AtmLaneDereferenceMacEntry(pMacEntry, "temp");
		if (rc > 0)
		{
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
		}
	}
	while (FALSE);

	TRACEOUT(AbortMacEntry);

	return;
}

VOID
AtmLaneMacEntryAgingTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This routine is called if some time has passed since an
	MAC entry was last validated.

	If there is no VC associated with this MAC entry, delete it.
	If there has been no sends on the entry since last validated, delete it.
	Otherwise  revalidate the entry by starting the ARP protocol.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMLANE Mac Entry structure

Return Value:

	None

--*/
{
	PATMLANE_MAC_ENTRY		pMacEntry;		// Mac Entry that has aged out
	ULONG					rc;				// Ref count on Mac Entry
	PATMLANE_VC				pVc;			// VC going to this Mac Entry
	ULONG					Flags;			// Flags on above VC
	PATMLANE_ELAN			pElan;
	PATMLANE_ATM_ENTRY		pAtmEntry;

	TRACEOUT(MacEntryAgingTimeout);

	pMacEntry = (PATMLANE_MAC_ENTRY)Context;
	STRUCT_ASSERT(pMacEntry, atmlane_mac);

	do
	{
		ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
	
		DBGP((2, "MacEntryAgingTimeout: pMacEntry %x MacAddr %s\n",
				pMacEntry, MacAddrToString(&pMacEntry->MacAddress)));

		rc = AtmLaneDereferenceMacEntry(pMacEntry, "aging timer");
		if (rc == 0)
		{
			break; 	// It's gone!
		}

		//
		//  Continue only if the Elan is not going down
		//
		pElan = pMacEntry->pElan;
		if (ELAN_STATE_OPERATIONAL != pElan->AdminState)
		{
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
			break;
		}

		pVc = NULL_PATMLANE_VC;
		pAtmEntry = pMacEntry->pAtmEntry;
		if (pAtmEntry != NULL_PATMLANE_ATM_ENTRY)
		{
			pVc = pAtmEntry->pVcList;
		}


		if (pVc != NULL_PATMLANE_VC &&
			(pMacEntry->Flags & MAC_ENTRY_USED_FOR_SEND) != 0)
		{
			//
			//  There is a VC for this Mac Address and it's been
			//	used for a send in the last aging period.
			//  So we try to revalidate this Mac entry.
			//
			//
			//	Set state to AGED
			//
			SET_FLAG(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_AGED);

			pMacEntry->Flags &= ~ MAC_ENTRY_USED_FOR_SEND;

			//
			// Send ARP Request
			//
			pMacEntry->RetriesLeft = pElan->MaxRetryCount;
			AtmLaneReferenceMacEntry(pMacEntry, "timer");
			AtmLaneStartTimer(
					pElan,
					&pMacEntry->Timer,
					AtmLaneArpTimeout,
					pElan->ArpResponseTime,
					(PVOID)pMacEntry
					);
			
			AtmLaneSendArpRequest(pElan, pMacEntry);
			//
			//	MAC Entry lock released in above
			//
		}
		else
		{
			//
			//  No VC associated with this Mac Entry or
			//  it hasn't been used in last aging period.
			//	Delete it.
			//
			AtmLaneAbortMacEntry(pMacEntry);
			//
			//  The Mac Entry lock is released in the above routine.
			//
		}

	}
	while (FALSE);

	TRACEOUT(MacEntryAgingTimeout);
	return;		

}


VOID
AtmLaneArpTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This is called when we time out waiting for a response to an ARP Request
	we had sent ages ago in order to resolve/refresh an MAC entry.

	Check if we	have tried enough times. If we have retries left, send another 
	ARP	Request.

	If we have run out of retries, delete the MAC entry, and any VCs going to it.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMLANE MAC Entry structure
	ContextValue		- ignored

Return Value:

	None

--*/
{
	PATMLANE_MAC_ENTRY		pMacEntry;		// MAC Entry being ARP'ed for.
	PATMLANE_VC				pVc;			// VC to this MAC destination
	PATMLANE_ELAN			pElan;
	ULONG					rc;				// Ref Count on MAC Entry
	ULONG					IsBroadcast;

	TRACEIN(ArpTimeout);

	do
	{
		pMacEntry = (PATMLANE_MAC_ENTRY)Context;
		STRUCT_ASSERT(pMacEntry, atmlane_mac);

		ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);

		pElan = pMacEntry->pElan;

		DBGP((2, "ArpTimeout: Mac Entry %x\n", pMacEntry));
				
		rc = AtmLaneDereferenceMacEntry(pMacEntry, "timer");	// Timer reference
		if (rc == 0)
		{
			break;	// It's gone!
		}
		
		//
		//	Retry if any retries left
		//
		if (pMacEntry->RetriesLeft != 0)
		{
			pMacEntry->RetriesLeft--;

			AtmLaneReferenceMacEntry(pMacEntry, "timer");
			
			AtmLaneStartTimer(
						pElan,
						&pMacEntry->Timer,
						AtmLaneArpTimeout,
						pElan->ArpResponseTime,
						(PVOID)pMacEntry
						);

			AtmLaneSendArpRequest(pElan, pMacEntry);
			//
			//	MAC Entry lock released in above
			//
			
			break;
		}


		//
		//	Is this the broadcast/BUS entry?
		//	
		IsBroadcast = (pMacEntry->Flags & MAC_ENTRY_BROADCAST);

		//
		//  We are out of retries. Abort the Mac Entry
		//
		AtmLaneAbortMacEntry(pMacEntry);
		//
		//  lock is released in the above routine
		//

		if (IsBroadcast)
		{
			//
			//	Signal the event to the state machine
			//
			ACQUIRE_ELAN_LOCK(pElan);
			AtmLaneQueueElanEvent(pElan, ELAN_EVENT_ARP_RESPONSE, NDIS_STATUS_TIMEOUT);
			RELEASE_ELAN_LOCK(pElan);
		}
	}
	while (FALSE);
	
	TRACEOUT(ArpTimeout);
	return;
}

VOID
AtmLaneConfigureResponseTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This is called when we time out waiting for a response 
	to an LE_CONFIGURE_REQUEST we sent to the LECS.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMLANE Elan structure

Return Value:

	None

--*/
{
	PATMLANE_ELAN			pElan;
	ULONG					rc;

	TRACEIN(ConfigureResponseTimeout);
	
	pElan = (PATMLANE_ELAN)Context;
	STRUCT_ASSERT(pElan, atmlane_elan);

	do
	{
		ACQUIRE_ELAN_LOCK_DPC(pElan);
		rc = AtmLaneDereferenceElan(pElan, "timer"); // Timer deref

		if (rc == 0)
		{
			//
			//  The ELAN is gone.
			//
			break;
		}

		AtmLaneQueueElanEvent(pElan, ELAN_EVENT_CONFIGURE_RESPONSE, NDIS_STATUS_TIMEOUT);

		RELEASE_ELAN_LOCK_DPC(pElan);

	}
	while (FALSE);

	TRACEOUT(ConfigureResponseTimeout);
	return;
}


VOID
AtmLaneJoinResponseTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This is called when we time out waiting for a response 
	to an LE_JOIN_REQUEST we sent to the LES.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMLANE Elan structure

Return Value:

	None

--*/
{
	PATMLANE_ELAN			pElan;
	ULONG					rc;

	TRACEIN(JoinResponseTimeout);
	
	pElan = (PATMLANE_ELAN)Context;
	STRUCT_ASSERT(pElan, atmlane_elan);

	do
	{
		ACQUIRE_ELAN_LOCK_DPC(pElan);

		rc = AtmLaneDereferenceElan(pElan, "timer"); // Timer deref

		if (rc == 0)
		{
			//
			//  The ELAN is gone.
			//
			break;
		}

		AtmLaneQueueElanEvent(pElan, ELAN_EVENT_JOIN_RESPONSE, NDIS_STATUS_TIMEOUT);

		RELEASE_ELAN_LOCK_DPC(pElan);
	}
	while (FALSE);

	TRACEOUT(JoinResponseTimeout);
	return;
}

VOID
AtmLaneInitializeMiniportDevice(
	IN	PNDIS_WORK_ITEM				NdisWorkItem,
	IN	PVOID						Context
)
{
	PATMLANE_ELAN			pElan;
	ULONG					rc;
	BOOLEAN					bDontBotherToInit;
	NDIS_STATUS				Status;

	TRACEIN(InitializeMiniportDevice);

	pElan = (PATMLANE_ELAN)Context;
	STRUCT_ASSERT(pElan, atmlane_elan);

	//
	//  If we are shutting down this ELAN (e.g. because we are
	//  unbinding from the ATM adapter), then don't bother to
	//  initiate MiniportInit.
	//
	ACQUIRE_ELAN_LOCK(pElan);
	if (pElan->AdminState == ELAN_STATE_SHUTDOWN)
	{
		bDontBotherToInit = TRUE;
	}
	else
	{
		bDontBotherToInit = FALSE;
		pElan->Flags |= ELAN_MINIPORT_INIT_PENDING;
		INIT_BLOCK_STRUCT(&pElan->InitBlock);
	}
	RELEASE_ELAN_LOCK(pElan);

	if (!bDontBotherToInit)
	{
		DBGP((1, "%d Miniport INITIALIZING Device %s\n", 
			pElan->ElanNumber,
			UnicodeToString(&pElan->CfgDeviceName)));
	
		Status = NdisIMInitializeDeviceInstanceEx(
					pAtmLaneGlobalInfo->MiniportDriverHandle,
					&pElan->CfgDeviceName,
					(NDIS_HANDLE)pElan);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, "%d IMInitializeDeviceInstanceEx failed on ELAN %p (%x)\n",
					pElan->ElanNumber, pElan, Status));

			ACQUIRE_ELAN_LOCK(pElan);
			pElan->Flags &= ~ELAN_MINIPORT_INIT_PENDING;
			SIGNAL_BLOCK_STRUCT(&pElan->InitBlock, NDIS_STATUS_SUCCESS);
			RELEASE_ELAN_LOCK(pElan);
		}
	}

	ACQUIRE_ELAN_LOCK(pElan);
	rc = AtmLaneDereferenceElan(pElan, "workitem");
	if (rc > 0)
	{
		RELEASE_ELAN_LOCK(pElan);
	}
	
	TRACEOUT(InitializeMiniportDevice);
	return;
}

VOID
AtmLaneDeinitializeMiniportDevice(
	IN	PNDIS_WORK_ITEM				NdisWorkItem,
	IN	PVOID						Context
)

{
	PATMLANE_ELAN			pElan;
	NDIS_STATUS				Status;
	ULONG					rc;
	NDIS_HANDLE				AdapterHandle;

	TRACEIN(DeinitializeMiniportDevice);

	pElan = (PATMLANE_ELAN)Context;
	STRUCT_ASSERT(pElan, atmlane_elan);

	DBGP((1, "%d Miniport DEINITIALIZING, AdapterHandle %x, RefCount %d\n",
			pElan->ElanNumber, pElan->MiniportAdapterHandle, pElan->RefCount));

	ACQUIRE_ELAN_LOCK(pElan);

	AdapterHandle = pElan->MiniportAdapterHandle;

	RELEASE_ELAN_LOCK(pElan);

	if (NULL != AdapterHandle)
	{
		DBGP((1, "Will call NdisIMDeInit %x\n", AdapterHandle));
		Status = NdisIMDeInitializeDeviceInstance(AdapterHandle);
		ASSERT(Status == NDIS_STATUS_SUCCESS);
		//
		//  Our MHalt routine will be called at some point.
		//
	}
	//
	//  else our MHalt routine was called already.
	//

	DBGP((0, "DeInit completing, pElan %x, RefCount %d, State %d\n",
			pElan, pElan->RefCount, pElan->State));
	
	ACQUIRE_ELAN_LOCK(pElan);
	rc = AtmLaneDereferenceElan(pElan, "workitem");
	if (rc > 0)
	{
		RELEASE_ELAN_LOCK(pElan);
	}
	
	TRACEOUT(DeinitializeMiniportDevice);
	return;
}

VOID
AtmLaneReadyTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This is called when we time out waiting for a ready indication
	on a incoming data direct VC.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to an ATMLANE Vc structure

Return Value:

	None

--*/
{
	PATMLANE_VC			pVc;
	PATMLANE_ELAN		pElan;
	ULONG				rc;

	TRACEIN(AtmLaneReadyTimeout);
	
	pVc = (PATMLANE_VC)Context;
	STRUCT_ASSERT(pVc, atmlane_vc);
	pElan = pVc->pElan;
	STRUCT_ASSERT(pElan, atmlane_elan);

	do
	{
	
		ACQUIRE_VC_LOCK(pVc);

		//
		//	Remove ready timer reference
		//
		rc = AtmLaneDereferenceVc(pVc, "ready timer");
		if (rc == 0)
		{
			break;
		}

		//
		//	Vc is still around, check state
		//
		if (!IS_FLAG_SET(
				pVc->Flags,
				VC_CALL_STATE_MASK,
				VC_CALL_STATE_ACTIVE
				))
		{
			RELEASE_VC_LOCK(pVc);
			break;
		}

		//
		//	Check if any retries left
		//
		if (pVc->RetriesLeft--)
		{
			//
			//	Start timer again
			//
			SET_FLAG(
					pVc->Flags,
					VC_READY_STATE_MASK,
					VC_READY_WAIT
					);
			AtmLaneReferenceVc(pVc, "ready timer");
			AtmLaneStartTimer(	
					pElan, 
					&pVc->ReadyTimer, 
					AtmLaneReadyTimeout, 
					pElan->ConnComplTimer, 
					pVc);
			//
			//	Send Ready Query
			//
			AtmLaneSendReadyQuery(pElan, pVc);
			//
			//	VC lock is released in above.
			//
		}
		else
		{
			//
			//	Give up and mark as having received indication anyway
			//
			SET_FLAG(
					pVc->Flags,
					VC_READY_STATE_MASK,
					VC_READY_INDICATED
					);
			RELEASE_VC_LOCK(pVc);
		}
	}
	while (FALSE);

	TRACEOUT(AtmLaneReadyTimeout);

	return;
}

VOID
AtmLaneFlushTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This is called when we time out waiting for a response to a FLUSH Request.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to a ATMLANE MAC Entry structure

Return Value:

	None

--*/
{
	PATMLANE_MAC_ENTRY			pMacEntry;
	PATMLANE_ATM_ENTRY			pAtmEntry;
	PATMLANE_VC					pVc;
	PNDIS_PACKET				pNdisPacket;
	ULONG						rc;
	
	TRACEIN(FlushTimeout);
	
	pMacEntry = (PATMLANE_MAC_ENTRY)Context;
	STRUCT_ASSERT(pMacEntry, atmlane_mac);

	ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
	
	do
	{
		if (!IS_FLAG_SET(
				pMacEntry->Flags,
				MAC_ENTRY_STATE_MASK,
				MAC_ENTRY_FLUSHING))
		{
			DBGP((0, "%d FlushTimeout: MacEntry %p, bad state, Flags %x\n",
					pMacEntry->pElan->ElanNumber,
					pMacEntry,
					pMacEntry->Flags));
			break;
		}

		if (pMacEntry->pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
		{
			DBGP((0, "%d FlushTimeout: Mac Entry %p, Flags %x, NULL AtmEntry\n",
					pMacEntry->pElan->ElanNumber,
					pMacEntry,
					pMacEntry->Flags));

			SET_FLAG(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_NEW);

			break;
		}
			
		//
		//	Mark MAC Entry active
		//
		SET_FLAG(
				pMacEntry->Flags,
				MAC_ENTRY_STATE_MASK,
				MAC_ENTRY_ACTIVE);

		//
		//	Send any queued packets
		//
		if (pMacEntry->PacketList == (PNDIS_PACKET)NULL)
		{
			break;
		}

		pVc = pMacEntry->pAtmEntry->pVcList;

		if (pVc == NULL_PATMLANE_VC)
		{
			break;
		}

		ACQUIRE_VC_LOCK(pVc);

		//
		//  Make sure this VC doesn't go away.
		//
		AtmLaneReferenceVc(pVc, "flushtemp");

		RELEASE_VC_LOCK(pVc);
	
		while ((pNdisPacket = AtmLaneDequeuePacketFromHead(pMacEntry)) !=
				(PNDIS_PACKET)NULL)
		{
			//
			//	Send it
			//
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);

			ACQUIRE_VC_LOCK(pVc);
			AtmLaneSendPacketOnVc(pVc, pNdisPacket, TRUE);

			ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
		}

		ACQUIRE_VC_LOCK(pVc);

		rc = AtmLaneDereferenceVc(pVc, "flushtemp");

		if (rc != 0)
		{
			RELEASE_VC_LOCK(pVc);
		}
		break;
	}
	while (FALSE);

	rc = AtmLaneDereferenceMacEntry(pMacEntry, "flush timer");
	if (rc != 0)
	{
		RELEASE_MAC_ENTRY_LOCK(pMacEntry);
	}

	TRACEOUT(FlushTimeout);
	return;
}

VOID
AtmLaneVcAgingTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This is called when the VC aging timeout fires.
	It will fire if this VC hasn't been used to transmit
	a packet for the timeout period.  The VC will be 
	closed unless it has had receive activity since the last
	timeout.  The data receive path sets a flag if a packet
	has been received.  
	

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to a ATMLANE VC structure

Return Value:

	None

--*/
{
	PATMLANE_VC				pVc;			
	ULONG					rc;
	PATMLANE_ELAN			pElan;

	TRACEIN(VcAgingTimeout);

	do
	{
		pVc = (PATMLANE_VC)Context;
		STRUCT_ASSERT(pVc, atmlane_vc);
		ASSERT(IS_FLAG_SET(pVc->Flags, VC_TYPE_MASK, VC_TYPE_SVC));

		ACQUIRE_VC_LOCK(pVc);
		pElan = pVc->pElan;

		//
		//	Continue only if VC still active
		//	Otherwise dereference, unlock it, and return
		//
		if (!(IS_FLAG_SET(pVc->Flags,
						VC_CALL_STATE_MASK,
						VC_CALL_STATE_ACTIVE)))
		{
			rc = AtmLaneDereferenceVc(pVc, "aging timer");
			if (rc > 0)
			{
				RELEASE_VC_LOCK(pVc);
			}
			break;
		}

		//
		//	Continue only if the ELAN isn't going down
		//	Otherwise dereference, unlock it, and return
		//
		if (ELAN_STATE_OPERATIONAL != pElan->AdminState)
		{
			rc = AtmLaneDereferenceVc(pVc, "aging timer");
			if (rc > 0)
			{
				RELEASE_VC_LOCK(pVc);
			}
			break;
		}

		//
		//	If received activity is non-zero, 
		//	clear flag, restart aging timer, release lock
		//	and return
		//
		if (pVc->ReceiveActivity != 0)
		{
			pVc->ReceiveActivity = 0;

			// timer reference still on VC no need to re-reference
			
			AtmLaneStartTimer(
						pElan,
						&pVc->AgingTimer,
						AtmLaneVcAgingTimeout,
						pVc->AgingTime,
						(PVOID)pVc
						);

			DBGP((1, "%d Vc %x aging timer refreshed due to receive activity\n", 
				pVc->pElan->ElanNumber,
				pVc));

						
			RELEASE_VC_LOCK(pVc);
			break;
		}

		//
		//	VC is to be closed
		//
		DBGP((1, "%d Vc %x aged out\n", 
			pVc->pElan->ElanNumber,
			pVc));

		
		DBGP((3, "VcAgingTimeout: Vc %x RefCount %d Flags %x pAtmEntry %x\n",
			pVc, pVc->RefCount, pVc->Flags, pVc->pAtmEntry));

		//
		//	Remove timer reference and return if refcount goes to zero
		//
		rc = AtmLaneDereferenceVc(pVc, "aging timer");
		if (rc == 0)
		{
			break;
		}

		//
		//  Take this VC out of the VC list for this ATM destination
		//	and return if refcount goes to zero
		//
		if (pVc->pAtmEntry != NULL_PATMLANE_ATM_ENTRY)
		{
			if (AtmLaneUnlinkVcFromAtmEntry(pVc))
			{
				rc = AtmLaneDereferenceVc(pVc, "atm");
				if (rc == 0)
				{
					break;
				}
			}
		}

		//
		//  Close this VC
		//
		AtmLaneCloseCall(pVc);
		//
		//  The VC lock is released in CloseCall
		//
	} while (FALSE);
	
	
	TRACEOUT(VcAgingTimeout);
	return;
}


VOID
AtmLaneShutdownElan(
	IN	PATMLANE_ELAN				pElan		LOCKIN	NOLOCKOUT,
	IN	BOOLEAN						Restart
)
/*++

Routine Description:

	This routine will "shutdown" an ELAN prior to it going back
	to the Initial state or driver shutdown.  The caller is 
	expected to hold the ELAN lock and it will be released here.
	
Arguments:

	pElan				- Pointer to an ATMLANE Elan structure.
	Restart				- If TRUE ELAN should restart at Initial state.
						  If FALSE ELAN should not restart.
						  
Return Value:

	None

--*/

{
	PATMLANE_ATM_ENTRY		pAtmEntry;
	PATMLANE_ATM_ENTRY		pNextAtmEntry;
	PATMLANE_MAC_ENTRY		pMacEntry;
	ULONG					rc;
	ULONG					i;
	BOOLEAN					WasCancelled;
	NDIS_STATUS				Status;
	NDIS_HANDLE				NdisAfHandle;
	BOOLEAN					bTempRef;

	TRACEIN(ShutdownElan);
	STRUCT_ASSERT(pElan, atmlane_elan);

	//
	//  Add a temp ref
	//
	bTempRef = TRUE;
	AtmLaneReferenceElan(pElan, "tempshutdown");

    do
    {
        DBGP((0, "%d ShutDownElan pElan %p/%x, Ref %d State %d, Restart %d\n",
			pElan->ElanNumber, pElan, pElan->Flags, pElan->RefCount, pElan->State,
			Restart));

        //
        //  If state already == SHUTDOWN nothing to do
        //
        if (ELAN_STATE_SHUTDOWN == pElan->State)
        {
            RELEASE_ELAN_LOCK(pElan);
            break;
        }

        //
        //  If we are transitioning from operational to shutdown,
        //  and our miniport is active, then indicate a media disconnect
        //  event.
        //
        if (pElan->State == ELAN_STATE_OPERATIONAL &&
        	pElan->MiniportAdapterHandle != NULL)
        {
        	NdisMIndicateStatus(
        		pElan->MiniportAdapterHandle,
        		NDIS_STATUS_MEDIA_DISCONNECT,
        		NULL,
        		0);
        	
        	NdisMIndicateStatusComplete(pElan->MiniportAdapterHandle);
        }
            
		//
		//	Change state to shutdown.  If restarting state will
		//	be changed back to init after cleanup below.
		//
		pElan->AdminState = ELAN_STATE_SHUTDOWN;
	    pElan->State = ELAN_STATE_SHUTDOWN;

	    //
	    //  Wait for any pending OpenAF operation to finish.
	    //
	    while (pElan->Flags & ELAN_OPENING_AF)
	    {
			RELEASE_ELAN_LOCK(pElan);

			DBGP((0, "%d: Shutdown Elan %p/%x is opening AF\n",
					pElan->ElanNumber, pElan, pElan->Flags));

			(VOID)WAIT_ON_BLOCK_STRUCT(&pElan->AfBlock);

			ACQUIRE_ELAN_LOCK(pElan);
		}

	    NdisAfHandle = pElan->NdisAfHandle;
	    pElan->NdisAfHandle = NULL;

	    if (Restart)
	    {
	    	pElan->Flags |= ELAN_NEEDS_RESTART;
	    }

	    //
	    //  Are we waiting for MiniportInitialize to run and finish?
	    //  If so, try to cancel IMInit.
	    //
	    if (pElan->Flags & ELAN_MINIPORT_INIT_PENDING)
	    {
			RELEASE_ELAN_LOCK(pElan);

			Status = NdisIMCancelInitializeDeviceInstance(
						pAtmLaneGlobalInfo->MiniportDriverHandle,
						&pElan->CfgDeviceName);

			DBGP((0, "%d ShutdownElan Elan %p/%x, Ref %d, CancelInit returned %x\n",
						pElan->ElanNumber, pElan, pElan->Flags, pElan->RefCount, Status));

			if (Status == NDIS_STATUS_SUCCESS)
			{
				//
				//  Canceled the IMInit process.
				//
				ACQUIRE_ELAN_LOCK(pElan);
				pElan->Flags &= ~ELAN_MINIPORT_INIT_PENDING;
			}
			else
			{
				//
				//  Our MiniportInit function -will- be called.
				//  Wait for it to finish.
				//
				(VOID)WAIT_ON_BLOCK_STRUCT(&pElan->InitBlock);
				DBGP((2, "%d: Shutdown ELAN %p, Flags %x, woke up from InitBlock\n",
							pElan->ElanNumber, pElan, pElan->Flags));
				ACQUIRE_ELAN_LOCK(pElan);
				ASSERT((pElan->Flags & ELAN_MINIPORT_INIT_PENDING) == 0);
			}
		}
	    
	    //
	    //	Stop any timers running on the elan.
	    //

	    if (AtmLaneStopTimer(&pElan->Timer, pElan))
	    {
		    rc = AtmLaneDereferenceElan(pElan, "timer"); // Timer ref
		    ASSERT(rc > 0);
	    }

	    if (NULL != pElan->pDelayedEvent)
	    {
	    	BOOLEAN		TimerCancelled;

	    	NdisCancelTimer(
	    		&pElan->pDelayedEvent->DelayTimer,
	    		&TimerCancelled);

			DBGP((0, "ATMLANE: %d ShutdownElan %p, DelayedEvent %p, Cancelled %d\n",
						pElan->ElanNumber,
						pElan,
						pElan->pDelayedEvent,
						TimerCancelled));

	    	if (TimerCancelled)
	    	{
				FREE_MEM(pElan->pDelayedEvent);
				pElan->pDelayedEvent = NULL;

	    		rc = AtmLaneDereferenceElan(pElan, "delayeventcancel");
	    		ASSERT(rc > 0);
	    	}
	    }

	    RELEASE_ELAN_LOCK(pElan);

	    //
	    //	Deregister all SAPs. 
	    //
	    AtmLaneDeregisterSaps(pElan);
		
	    //
	    //	Abort all MAC table entries.
	    //
	    for (i = 0; i < ATMLANE_MAC_TABLE_SIZE; i++)
	    {
		    ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan);
		    while (pElan->pMacTable[i] != NULL_PATMLANE_MAC_ENTRY)
		    {
			    pMacEntry = pElan->pMacTable[i];

			    //
			    //  Place a temp ref so that this won't go away
			    //  when we release the MAC table lock.
			    //
			    ACQUIRE_MAC_ENTRY_LOCK_DPC(pMacEntry);
			    AtmLaneReferenceMacEntry(pMacEntry, "ShutDownTemp");
			    RELEASE_MAC_ENTRY_LOCK_DPC(pMacEntry);

			    RELEASE_ELAN_MAC_TABLE_LOCK(pElan);

			    ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);

			    //
			    //  Remove the temp ref
			    //
			    rc = AtmLaneDereferenceMacEntry(pMacEntry, "ShutDownTemp");
			    if (rc != 0)
			    {
					AtmLaneAbortMacEntry(pMacEntry);
					//
					//  MAC Entry Lock is released within the above.
					//
			    }
			    //
			    //  else the MAC entry is gone.
			    //

			    ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan);
		    }
			RELEASE_ELAN_MAC_TABLE_LOCK(pElan);
	    }

	    //
	    //  Abort all ATM Entries.
	    //

		//  First, run through the list and reference
	    //  all of them first, so that we don't
	    //  skip to an invalid pointer when aborting the entries.
	    //
	    ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

	    for (pAtmEntry = pElan->pAtmEntryList;
	    	 pAtmEntry != NULL_PATMLANE_ATM_ENTRY;
	    	 pAtmEntry = pNextAtmEntry)
	    {
			ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);

			pAtmEntry->Flags |= ATM_ENTRY_WILL_ABORT;
	    	AtmLaneReferenceAtmEntry(pAtmEntry, "tempS");
	    	pNextAtmEntry = pAtmEntry->pNext;

			RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		}

		//
		//  Now, do the actual abort.
		//
	    pAtmEntry = pElan->pAtmEntryList;
	    while (pAtmEntry != NULL_PATMLANE_ATM_ENTRY)
	    {
		    RELEASE_ELAN_ATM_LIST_LOCK(pElan);

		    ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
		    pNextAtmEntry = pAtmEntry->pNext;
		    AtmLaneInvalidateAtmEntry(pAtmEntry);
		    //
		    //  The ATM Entry lock is released within the above.
		    //

		    ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);
		    pAtmEntry = pNextAtmEntry;
	    }

	    //
	    //  Remove all temp references.
	    //
	    for (pAtmEntry = pElan->pAtmEntryList;
	    	 pAtmEntry != NULL_PATMLANE_ATM_ENTRY;
	    	 pAtmEntry = pNextAtmEntry)
	    {
		    RELEASE_ELAN_ATM_LIST_LOCK(pElan);

			ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);

			ASSERT(pAtmEntry->Flags & ATM_ENTRY_WILL_ABORT);
			pAtmEntry->Flags &= ~ATM_ENTRY_WILL_ABORT;

	    	pNextAtmEntry = pAtmEntry->pNext;

	    	rc = AtmLaneDereferenceAtmEntry(pAtmEntry,"tempS");
	    	if (rc != 0)
	    	{
	    		RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
	    	}

		    ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);
		}

	    RELEASE_ELAN_ATM_LIST_LOCK(pElan);

		//
		//  Remove the temp ref
		//
		STRUCT_ASSERT(pElan, atmlane_elan);
		bTempRef = FALSE;
	    ACQUIRE_ELAN_LOCK(pElan);
	    rc = AtmLaneDereferenceElan(pElan, "tempshutdown");
	    if (rc == 0)
	    {
	    	break;
	    }
	    RELEASE_ELAN_LOCK(pElan);

	    if (NULL != NdisAfHandle)
	    {
	    	Status = NdisClCloseAddressFamily(NdisAfHandle);
	    	if (NDIS_STATUS_PENDING != Status)
	    	{
	    		AtmLaneCloseAfCompleteHandler(Status, (NDIS_HANDLE)pElan);
	    	}
	    }
	    else
	    {
	    	AtmLaneContinueShutdownElan(pElan);
	    }

	} while (FALSE);
	

	if (bTempRef)
	{
	    ACQUIRE_ELAN_LOCK(pElan);
	    rc = AtmLaneDereferenceElan(pElan, "tempshutdown");
	    if (rc != 0)
	    {
	    	RELEASE_ELAN_LOCK(pElan);
	    }
	}

	TRACEOUT(ShutdownElan);

	return;
}

VOID
AtmLaneContinueShutdownElan(
	IN	PATMLANE_ELAN			pElan
	)
/*++

Routine Description:

	This routine continues the shutting down process for an ELAN,
	after the Af handle with the Call Manager has been closed.

Arguments:

	pElan	- the ELAN being shutdown.

Return Value:

	None.
--*/
{
	ULONG		rc;

	TRACEIN(ContinueShutdownElan);

	DBGP((0, "%d ContinueShutdown ELAN %x Flags 0x%x State %d\n",
				pElan->ElanNumber,
				pElan,
				pElan->Flags,
				pElan->State));

	do
	{
	    if (pElan->Flags & ELAN_NEEDS_RESTART)
	    {
		    ACQUIRE_ELAN_LOCK(pElan);
			//
			//	Change state to INIT
			//
			pElan->AdminState = ELAN_STATE_OPERATIONAL;
 		    pElan->State = ELAN_STATE_INIT;
		    pElan->RetriesLeft = 4;

		    pElan->Flags &= ~ELAN_NEEDS_RESTART;

		    //
		    //  Clear out the local ATM address so that we start off the
		    //  ELAN properly when we obtain it from the Call manager.
		    //
		    NdisZeroMemory(&pElan->AtmAddress, sizeof(ATM_ADDRESS));

			//
            //  Empty the event queue and schedule a restart in a little while
            //	
			AtmLaneDrainElanEventQueue(pElan);
		    AtmLaneQueueElanEventAfterDelay(pElan, ELAN_EVENT_START, 0, 2*1000);

		    RELEASE_ELAN_LOCK(pElan);
	    }
	    else
	    {
            //
            //  Completely remove the ELAN
            //
		    AtmLaneUnlinkElanFromAdapter(pElan);
		    
    	    ACQUIRE_ELAN_LOCK(pElan);

    	    //
    	    //	Add workitem reference and remove adapter reference
    	    //
    	    AtmLaneReferenceElan(pElan, "workitem");
    	    rc = AtmLaneDereferenceElan(pElan, "adapter");

	        //
	        //  We are here for one of the following reasons:
	        //
	        //  1. Unbinding from an ATM adapter
	        //  2. The CM asked us to shut down the AF open on an ATM adapter
	        //  3. The virtual miniport was halted.
	        //
	        //  If it isn't case (3), then we should make sure that the miniport
	        //  gets halted, by calling NdisIMDeInitializeDeviceInstance.
	        //

		    if (pElan->MiniportAdapterHandle != NULL)
		    {

				DBGP((1, "%d ContinueShutdown: pElan x%x, scheduling NdisIMDeInit, Handle %x\n",
				        pElan->ElanNumber, pElan, pElan->MiniportAdapterHandle));
				        
		    	//
				//	Schedule a PASSIVE_LEVEL thread to call
				//	NdisIMInitializeDeviceInstance
				//
				NdisInitializeWorkItem(
						&pElan->NdisWorkItem,
						AtmLaneDeinitializeMiniportDevice,
						pElan);

				//	workitem reference already on Elan from above
				
				NdisScheduleWorkItem(&pElan->NdisWorkItem);

				RELEASE_ELAN_LOCK(pElan);
			}
			else
			{
				// 
				// 	Just remove workitem reference and unlock if Elan still around
				//
				rc = AtmLaneDereferenceElan(pElan, "workitem");
				if (rc > 0)
					RELEASE_ELAN_LOCK(pElan);
			}
		}

		break;

	}
	while (FALSE);

	TRACEOUT(ContinueShutdownElan);
	return;
}


VOID
AtmLaneGetProtocolConfiguration(
	IN	NDIS_HANDLE				AdapterConfigHandle,
	IN	PATMLANE_ADAPTER		pAdapter
	)
/*++

Routine Description:

	This routine will attempt to get any ATMLANE protocol specific
	configuration information optionally stored under an adapter's
	registry parameters.  

Arguments:

	AdapterConfigHandle	- the handle that was returned by
						  AtmLaneOpenAdapterConfiguration.
	pAdapter			- Pointer to ATMLANE adapter structure.

Return Value:

	None.
	
--*/
{
	NDIS_STATUS						Status;
	PNDIS_CONFIGURATION_PARAMETER 	ParameterValue;
	ATM_ADDRESS						LecsAddress;
	NDIS_STRING						ValueName;
	PATMLANE_NAME *					ppNext;
	PATMLANE_NAME					pName;
	PWSTR							pTempStr;
	USHORT							StrLength;
	
	TRACEIN(GetProtocolConfiguration);

	//
	//	Get the UpperBindings parameter (it will only exist on Memphis)
	//
	NdisInitUnicodeString(&ValueName, ATMLANE_UPPERBINDINGS_STRING);
	NdisReadConfiguration(
		&Status,
		&ParameterValue,
		AdapterConfigHandle,
		&ValueName,
		NdisParameterString);
	if (NDIS_STATUS_SUCCESS == Status)
	{
		//	Copy the string into adapter struct

		(VOID)AtmLaneCopyUnicodeString(
				&(pAdapter->CfgUpperBindings),
				&(ParameterValue->ParameterData.StringData),
				TRUE,
				FALSE);
		DBGP((1, "GetProtocolConfiguration: UpperBindings %s\n",
			UnicodeToString(&pAdapter->CfgUpperBindings)));
		
		//
		//  Existence of this parameter is a definite clue we're running
		//  on Memphis/Win98
		//
		pAdapter->RunningOnMemphis = TRUE;
	}

    //
    //  Get the ElanName parameter (it will only exist on Memphis)
    //
	NdisInitUnicodeString(&ValueName, ATMLANE_ELANNAME_STRING);
	NdisReadConfiguration(
		&Status,
		&ParameterValue,
		AdapterConfigHandle,
		&ValueName,
		NdisParameterString);
	if (NDIS_STATUS_SUCCESS == Status)
	{

		//	Copy the string into adapter struct

		(VOID)AtmLaneCopyUnicodeString(
				&(pAdapter->CfgElanName),
				&(ParameterValue->ParameterData.StringData),
				TRUE,
				FALSE);
		DBGP((1, "GetProtocolConfiguration: ElanName %s\n",
			UnicodeToString(&pAdapter->CfgElanName)));

		//
		//  Existence of this parameter is definite clue we're running
		//  on Memphis/Win98
		//
		pAdapter->RunningOnMemphis = TRUE;
	}

	//
	//	If on Win98 we have to parse the upper bindings and elan name strings
	//

	if (pAdapter->RunningOnMemphis)
	{
		// cut up the upper bindings string

		ppNext = &(pAdapter->UpperBindingsList);
		pTempStr = AtmLaneStrTok(pAdapter->CfgUpperBindings.Buffer, L',', &StrLength);

		do
		{
			*ppNext = NULL;

			if (pTempStr == NULL)
			{
				break;
			}

			ALLOC_MEM(&pName, sizeof(ATMLANE_NAME));

			if (pName == NULL)
			{
				break;
			}

			pName->Name.Buffer = pTempStr;
			pName->Name.MaximumLength = StrLength+1;
			pName->Name.Length = StrLength;

			*ppNext = pName;
			ppNext = &(pName->pNext);
		
			pTempStr = AtmLaneStrTok(NULL, L',', &StrLength);

		} while (TRUE);


		// cut up the elan name string

		ppNext = &(pAdapter->ElanNameList);
		pTempStr = AtmLaneStrTok(pAdapter->CfgElanName.Buffer, L',', &StrLength);

		do
		{
			*ppNext = NULL;

			if (pTempStr == NULL)
			{
				break;
			}

			ALLOC_MEM(&pName, sizeof(ATMLANE_NAME));
			
			if (pName == NULL)
			{
				break;
			}

			pName->Name.Buffer = pTempStr;
			pName->Name.MaximumLength = StrLength+1;
			pName->Name.Length = StrLength;

			*ppNext = pName;
			ppNext = &(pName->pNext);
		
			pTempStr = AtmLaneStrTok(NULL, L',', &StrLength);

		} while (TRUE);
		
	}

	TRACEOUT(GetProtocolConfiguration);

	return;
}

VOID
AtmLaneGetElanConfiguration(
	IN	PNDIS_STRING			pElanKey,
	IN	PATMLANE_ELAN			pElan
	)
/*++

Routine Description:

	This routine will first initialize the configuration parameters
	for the specified ELAN.   Then it will attempt to get any ELAN
	configuration information optionally stored	under the ELAN's
	registry key.

Arguments:

    pElanKey            - UNICODE string containing ELAN's 
                          registry key

Return Value:

	None.
	
--*/
{
	NDIS_STATUS						Status;
	PNDIS_CONFIGURATION_PARAMETER 	ParameterValue;
	NDIS_STRING						ValueName;
	ANSI_STRING						TempAnsiString;
	ATM_ADDRESS						LecsAddress;
	NDIS_HANDLE                     AdapterConfigHandle;
	NDIS_HANDLE                     ElanListConfigHandle;
	NDIS_HANDLE                     ElanConfigHandle;
	NDIS_HANDLE						CommonConfigHandle;
	NDIS_STRING				        ElanListKeyName;
	PATMLANE_NAME					pName;
	ULONG							Index;
	
	TRACEIN(GetElanConfiguration);

	//
	//	Init handles to null for proper cleanup later
	//
	AdapterConfigHandle = NULL_NDIS_HANDLE;
	ElanListConfigHandle = NULL_NDIS_HANDLE;
	ElanConfigHandle = NULL_NDIS_HANDLE;

    //
    //  Init some defaults
    //
	pElan->CfgUseLecs = TRUE;
	pElan->CfgDiscoverLecs = TRUE;
	pElan->CfgLecsAddress = gWellKnownLecsAddress;

    do
    {
    	//
    	//  Open the AtmLane protocol configuration section for this adapter.
    	//	This must succeed on NT and Win98.
    	//
       	NdisOpenProtocolConfiguration(
	    			&Status,
		    		&AdapterConfigHandle,
			    	&pElan->pAdapter->ConfigString
	    			);
    
	    if (NDIS_STATUS_SUCCESS != Status)
	    {
		    AdapterConfigHandle = NULL_NDIS_HANDLE;
			DBGP((0, "GetElanConfiguration: OpenProtocolConfiguration failed\n"));
			Status = NDIS_STATUS_OPEN_FAILED;
			break;
	    }


		//
		//	If running on Win98 we will get ELAN config info from the
		//	adapter's parameters.  For NT we will get ELAN config info
		//	from the ELAN's own parameters.
		//
    	if (pElan->pAdapter->RunningOnMemphis)
    	{
			//
			//	Use the adapter's config handle
			//    	
			CommonConfigHandle = AdapterConfigHandle;
    	}
    	else
		{
	    	//
		    //	Open the Elan List configuration key.
	        //
	        NdisInitUnicodeString(&ElanListKeyName, ATMLANE_ELANLIST_STRING);

	       	NdisOpenConfigurationKeyByName(
			        &Status,
					AdapterConfigHandle,
	    			&ElanListKeyName,
					&ElanListConfigHandle);

		    if (NDIS_STATUS_SUCCESS != Status)
		    {
	            ElanListConfigHandle = NULL_NDIS_HANDLE;
	            DBGP((0, "GetElanConfiguration: Failed open of ElanList key\n"));
	            Status = NDIS_STATUS_FAILURE;
	            break;
	        }

    		//
		    //  Open ELAN key
		    //
			NdisOpenConfigurationKeyByName(
			        &Status,
					ElanListConfigHandle,
					pElanKey,
					&ElanConfigHandle);

		    if (NDIS_STATUS_SUCCESS != Status)
		    {
	            ElanConfigHandle = NULL_NDIS_HANDLE;
	            DBGP((0, "GetElanConfiguration: Failed open of ELAN key\n"));
	            Status = NDIS_STATUS_FAILURE;
	            break;
	        }

			//
			//	Use the ELAN's config handle
			//
			CommonConfigHandle = ElanConfigHandle;
	        
		}

		//
		//	Get the UseLECS parameter
		//
		NdisInitUnicodeString(&ValueName, ATMLANE_USELECS_STRING);
		NdisReadConfiguration(
			&Status,
			&ParameterValue,
			CommonConfigHandle,
			&ValueName,
			NdisParameterInteger);
		if (NDIS_STATUS_SUCCESS == Status)
		{
			pElan->CfgUseLecs = 
				(ParameterValue->ParameterData.IntegerData == 0) ? FALSE : TRUE;
			DBGP((1, "%d UseLECS = %s\n", 
				pElan->ElanNumber,
				pElan->CfgUseLecs?"TRUE":"FALSE"));
		}

		//
		//	Get the DiscoverLECS parameter
		//
		NdisInitUnicodeString(&ValueName, ATMLANE_DISCOVERLECS_STRING);
		NdisReadConfiguration(
			&Status,
			&ParameterValue,
			CommonConfigHandle,
			&ValueName,
			NdisParameterInteger);
		if (NDIS_STATUS_SUCCESS == Status)
		{
			pElan->CfgDiscoverLecs = 
				(ParameterValue->ParameterData.IntegerData == 0) ? FALSE : TRUE;
			DBGP((1, "%d DiscoverLECS = %s\n",
					pElan->ElanNumber,
					pElan->CfgDiscoverLecs?"TRUE":"FALSE"));
		}

		//
		//	Get the LECS Address (only if Discover LECS is FALSE)
		//
		if (FALSE == pElan->CfgDiscoverLecs)
		{
			NdisInitUnicodeString(&ValueName, ATMLANE_LECSADDR_STRING);
			NdisReadConfiguration(
				&Status,
				&ParameterValue,
				CommonConfigHandle,
				&ValueName,
				NdisParameterString);
			if (NDIS_STATUS_SUCCESS == Status)
			{
				NdisConvertStringToAtmAddress(
					&Status,
					&ParameterValue->ParameterData.StringData,
					&LecsAddress);
				if (NDIS_STATUS_SUCCESS == Status)
				{
					pElan->CfgLecsAddress = LecsAddress;
					DBGP((1, "%d LECSAddr = %s\n",
						pElan->ElanNumber,
						AtmAddrToString(pElan->CfgLecsAddress.Address)));
				}
			}
		}

    	//
		//	Get the DeviceName parameter (different on NT5 and Memphis/Win98)
		//
    	if (!pElan->pAdapter->RunningOnMemphis)
    	{
        	//
        	//  NT5
        	//    
    		NdisInitUnicodeString(&ValueName, ATMLANE_DEVICE_STRING);
    		NdisReadConfiguration(
    				&Status,
    				&ParameterValue,
    				ElanConfigHandle,
    				&ValueName,
    				NdisParameterString);
    		if (NDIS_STATUS_SUCCESS == Status)
    		{
    			//
    			//	Copy into Elan struct.
    			//
				(VOID)AtmLaneCopyUnicodeString(
					&(pElan->CfgDeviceName),
					&(ParameterValue->ParameterData.StringData),
					TRUE,
					FALSE);
    		}
    	}
    	else
    	{
    	    //
        	//  Memphis/Win98
        	//
        	//
        	//	Index to this elan's device name string
        	//
			pName = pElan->pAdapter->UpperBindingsList;
			Index = pElan->ElanNumber;
			while (Index > 0)
			{
				ASSERT(pName != NULL);
				pName = pName->pNext;
				Index--;
			}
   
			//
			//	Copy it to the Elan CfgDeviceName string
			//
			(VOID)AtmLaneCopyUnicodeString(
				&(pElan->CfgDeviceName),
				&(pName->Name),
				TRUE,
				FALSE);
    	}	
 		DBGP((1, "%d Device Name = %s\n",
			pElan->ElanNumber,
			UnicodeToString(&pElan->CfgDeviceName)));
   

		//
		//	Get the ELANName Parameter (different on NT5 and Memphis/Win98
		//
    	if (!pElan->pAdapter->RunningOnMemphis)
    	{
        	//
        	//  NT5
        	//    
	    	NdisInitUnicodeString(&ValueName, ATMLANE_ELANNAME_STRING);
	    	NdisReadConfiguration(
			    	&Status,
			    	&ParameterValue,
			    	ElanConfigHandle,
			    	&ValueName,
			    	NdisParameterString);

	    	if (NDIS_STATUS_SUCCESS != Status)
	    	{
	    		NDIS_STRING	DefaultNameString = NDIS_STRING_CONST("");

    			//
    			//	Copy into the Elan data structure.
    			//
    			if (!AtmLaneCopyUnicodeString(
					&(pElan->CfgElanName),
					&DefaultNameString,
					TRUE,
					FALSE))
				{
					Status = NDIS_STATUS_RESOURCES;
					break;
				}

				Status = NDIS_STATUS_SUCCESS;
			}
			else
    		{
    			//
    			//	Copy into the Elan data structure.
    			//
    			if (!AtmLaneCopyUnicodeString(
					&(pElan->CfgElanName),
					&(ParameterValue->ParameterData.StringData),
					TRUE,
					FALSE))
				{
					Status = NDIS_STATUS_RESOURCES;
					break;
				}
			}
  			
    		//
			//	Convert it to ANSI and copy into run-time Elan variable
			//
			TempAnsiString.Length = 0;
			TempAnsiString.MaximumLength = 32;
			TempAnsiString.Buffer = pElan->ElanName;

			NdisUnicodeStringToAnsiString(
		    		&TempAnsiString,
			    	&pElan->CfgElanName);

			pElan->ElanNameSize = (UCHAR) TempAnsiString.Length;
    	}
    	else
   		{
        	//
        	//  Memphis/Win98
			//
  			DBGP((2, "GetElanConfiguration: Getting Elan Name for Win98\n"));

	      	//
        	//	Index to this elan's name string
        	//
			pName = pElan->pAdapter->ElanNameList;
			Index = pElan->ElanNumber;
			while (Index > 0 && pName != NULL)
			{
				pName = pName->pNext;
				Index--;
			}
   
			//
			//	Copy it to the Elan CfgElanName string
			//
			if (pName != NULL)
			{
				DBGP((2, "GetElanConfiguration: Using Elan Name at 0x%x\n", pName->Name.Buffer));

				(VOID)AtmLaneCopyUnicodeString(
					&(pElan->CfgElanName),
					&(pName->Name),
					TRUE,
					FALSE);

 				//
   				//	Convert it to ANSI and copy into run-time Elan variable
   				//
   				TempAnsiString.Length = 0;
   				TempAnsiString.MaximumLength = 32;
   				TempAnsiString.Buffer = pElan->ElanName;
    
    			NdisUnicodeStringToAnsiString(
	    			&TempAnsiString,
		    		&pName->Name);

   				pElan->ElanNameSize = (UCHAR) TempAnsiString.Length;
  			}
  		}
	   	DBGP((1, "%d ELAN Name = %s\n",
			pElan->ElanNumber,
			UnicodeToString(&pElan->CfgElanName)));


		//
		//	Get the LAN type.
		//
		pElan->CfgLanType = LANE_LANTYPE_UNSPEC;
		NdisInitUnicodeString(&ValueName, ATMLANE_LANTYPE_STRING);
		NdisReadConfiguration(
			&Status,
			&ParameterValue,
			CommonConfigHandle,
			&ValueName,
			NdisParameterInteger);
		if (NDIS_STATUS_SUCCESS == Status)
		{
			pElan->CfgLanType = (UCHAR) ParameterValue->ParameterData.IntegerData;
			DBGP((1, "%d LAN Type = %u\n", 
					ParameterValue->ParameterData.IntegerData));
		}

		if (pElan->CfgLanType > LANE_LANTYPE_TR)
		{
			pElan->CfgLanType = LANE_LANTYPE_UNSPEC;
		}
		DBGP((1, "%d LAN Type = %u\n", pElan->ElanNumber, pElan->CfgLanType));

		//
		//	Get the Max Frame Size.
		//
		pElan->CfgMaxFrameSizeCode = LANE_MAXFRAMESIZE_CODE_UNSPEC;
		NdisInitUnicodeString(&ValueName, ATMLANE_MAXFRAMESIZE_STRING);
		NdisReadConfiguration(
			&Status,
			&ParameterValue,
			CommonConfigHandle,
			&ValueName,
			NdisParameterInteger);
		if (NDIS_STATUS_SUCCESS == Status)
		{
			pElan->CfgMaxFrameSizeCode = (UCHAR) ParameterValue->ParameterData.IntegerData;
		}

		if (pElan->CfgMaxFrameSizeCode > LANE_MAXFRAMESIZE_CODE_18190)
		{
			pElan->CfgMaxFrameSizeCode = LANE_MAXFRAMESIZE_CODE_UNSPEC;
		}
		DBGP((1, "%d MaxFrameSize Code = %u\n", 
			pElan->ElanNumber, 
			pElan->CfgMaxFrameSizeCode));

		//
		//	Get the LES Address
		//
		NdisZeroMemory(&pElan->CfgLesAddress, sizeof(ATM_ADDRESS));
		NdisInitUnicodeString(&ValueName, ATMLANE_LESADDR_STRING);
		NdisReadConfiguration(
			&Status,
			&ParameterValue,
			CommonConfigHandle,
			&ValueName,
			NdisParameterString);
		if (NDIS_STATUS_SUCCESS == Status)
		{
			NdisConvertStringToAtmAddress(
				&Status,
				&ParameterValue->ParameterData.StringData,
				&pElan->CfgLesAddress);
				DBGP((1, "%d LESAddr = %s\n",
					pElan->ElanNumber,
					AtmAddrToString(pElan->CfgLesAddress.Address)));
		}
	
		//
		//	Get the HeaderBufSize
		//
		pElan->HeaderBufSize = DEF_HEADER_BUF_SIZE;
		NdisInitUnicodeString(&ValueName, ATMLANE_HEADERBUFSIZE_STRING);
		NdisReadConfiguration(
			&Status,
			&ParameterValue,
			CommonConfigHandle,
			&ValueName,
			NdisParameterInteger);
		if (NDIS_STATUS_SUCCESS == Status)
		{
			pElan->HeaderBufSize = ParameterValue->ParameterData.IntegerData;
		}
		if (pElan->HeaderBufSize == 0)
		{
			DBGP((0, "HeaderBufSize overridden to default value %d!\n", 
				DEF_HEADER_BUF_SIZE));
			pElan->HeaderBufSize = DEF_HEADER_BUF_SIZE;
		}
	
		//
		//	Round the "real" HeaderBufSize up to mult of 4.
		//
		pElan->RealHeaderBufSize = (((pElan->HeaderBufSize + 3) / 4) * 4);

	
		//
		//	Get the MaxHeaderBufs
		//
		pElan->MaxHeaderBufs = DEF_MAX_HEADER_BUFS;
		NdisInitUnicodeString(&ValueName, ATMLANE_MAXHEADERBUFS_STRING);
		NdisReadConfiguration(
			&Status,
			&ParameterValue,
			CommonConfigHandle,
			&ValueName,
			NdisParameterInteger);
		if (NDIS_STATUS_SUCCESS == Status)
		{
			pElan->MaxHeaderBufs = ParameterValue->ParameterData.IntegerData;
		}
		if (pElan->MaxHeaderBufs == 0)
		{
			DBGP((0, "MaxHeaderBufs overridden to default value %d!\n", 
				DEF_MAX_HEADER_BUFS));
			pElan->MaxHeaderBufs = DEF_MAX_HEADER_BUFS;
		}


		//
		//	Make max pad buffers same as header buffers
		//
		pElan->MaxPadBufs = pElan->MaxHeaderBufs;
		//
		//	PadBufSize not configurable - but make it multiple of 4
		//
		pElan->PadBufSize = MAX(LANE_MIN_ETHPACKET, LANE_MIN_TRPACKET);
		pElan->PadBufSize = (((pElan->PadBufSize + 3) / 4) * 4);
		
		
		//
		//	ProtocolBufSize not configurable.
		//
		pElan->ProtocolBufSize = ROUND_OFF(DEF_PROTOCOL_BUF_SIZE);

		//
		//	Get the MaxProtocolBufs
		//
		pElan->MaxProtocolBufs = DEF_MAX_PROTOCOL_BUFS;
		NdisInitUnicodeString(&ValueName, ATMLANE_MAXPROTOCOLBUFS_STRING);
		NdisReadConfiguration(
			&Status,
			&ParameterValue,
			CommonConfigHandle,
			&ValueName,
			NdisParameterInteger);
		if (NDIS_STATUS_SUCCESS == Status)
		{
			pElan->MaxProtocolBufs = ParameterValue->ParameterData.IntegerData;
		}
		if (pElan->MaxProtocolBufs == 0)
		{
			DBGP((0, "MaxProtocolBufs overridden to default value %d!\n", 
				DEF_MAX_PROTOCOL_BUFS));
			pElan->MaxProtocolBufs = DEF_MAX_PROTOCOL_BUFS;
		}

	} while (FALSE);

	//
	//	Close config handles
	//		
	if (NULL_NDIS_HANDLE != ElanConfigHandle)
	{
		NdisCloseConfiguration(ElanConfigHandle);
		ElanConfigHandle = NULL_NDIS_HANDLE;
	}
	if (NULL_NDIS_HANDLE != ElanListConfigHandle)
	{
		NdisCloseConfiguration(ElanListConfigHandle);
		ElanListConfigHandle = NULL_NDIS_HANDLE;
	}
	if (NULL_NDIS_HANDLE != AdapterConfigHandle)
	{
	    NdisCloseConfiguration(AdapterConfigHandle);
		AdapterConfigHandle = NULL_NDIS_HANDLE;
	}

	TRACEOUT(GetElanConfiguration);

	return;
}

VOID
AtmLaneQueueElanEventAfterDelay(
	IN	PATMLANE_ELAN			pElan,
	IN	ULONG					Event,
	IN	NDIS_STATUS				EventStatus,
	IN	ULONG					DelayMs
	)
/*++

Routine Description:

	Queue an ELAN event on the ELAN's event queue after
	a specified delay. Caller is assumed to hold the ELAN
	lock.

Arguments:

    pElan				- Pointer to ELAN structure.
    Event				- Event code.
    EventStatus			- Status related to event.
    DelayMs				- Time to wait before queueing this event.

Return Value:

	None.
	
--*/
{	
	PATMLANE_DELAYED_EVENT	pDelayedEvent;
	PATMLANE_EVENT			pEvent;

	TRACEIN(QueueElanEventAfterDelay);

	do
	{
		//
		//	If the ELAN is being shut down, don't queue any events.
		//
		if (ELAN_STATE_SHUTDOWN == pElan->AdminState)
		{
			DBGP((0, "QueueElanEventAfterDelay: Not queuing event (ELAN shutdown)\n"));
			break;
		}

		if (NULL != pElan->pDelayedEvent)
		{
			DBGP((0, "QueueElanEventAfterDelay: Not queueing event %d (ELAN %x/%x already has one)\n",
					Event, pElan, pElan->Flags));
			DBGP((0, "QueueElanEventAfterDelay: ELAN %x: existing event %d\n",
						pElan, pElan->pDelayedEvent->DelayedEvent.Event));

			//
			//  Make sure we don't drop an ELAN_EVENT_STOP on the floor!
			//
			if (Event == ELAN_EVENT_STOP)
			{
				pElan->pDelayedEvent->DelayedEvent.Event = ELAN_EVENT_STOP;
			}

			break;
		}

		//
		//	Alloc an event struct and a timer struct.
		//
		ALLOC_MEM(&pDelayedEvent, sizeof(ATMLANE_DELAYED_EVENT));
		if ((PATMLANE_DELAYED_EVENT)NULL == pDelayedEvent)
		{
			DBGP((0, "QueueElanEventAfterDelay: Event object alloc failed\n"));
			break;
		}

		//
		//	Stash event data in event struct
		//
		pEvent = &pDelayedEvent->DelayedEvent;
		pEvent->Event = Event;
		pEvent->EventStatus = EventStatus;

		//
		//  Remember the ELAN.
		//
		pDelayedEvent->pElan = pElan;

		//
		//  Stash a pointer to this delayed event in the ELAN
		//
		pElan->pDelayedEvent = pDelayedEvent;

		//
		//  Reference the ELAN so that it doesn't go away for the
		//  duration this delayed event is alive.
		//
		AtmLaneReferenceElan(pElan, "delayevent");

		//
		//  Set up the timer to fire after the specified delay.
		//
		NdisInitializeTimer(&pDelayedEvent->DelayTimer,
							AtmLaneQueueDelayedElanEvent,
							(PVOID)pDelayedEvent);
		
		NdisSetTimer(&pDelayedEvent->DelayTimer, DelayMs);

	} while (FALSE);

	TRACEOUT(QueueElanEventAfterDelay);
	return;
}


VOID
AtmLaneQueueDelayedElanEvent(
	IN	PVOID					SystemSpecific1,
	IN	PVOID					TimerContext,
	IN	PVOID					SystemSpecific2,
	IN	PVOID					SystemSpecific3
	)
/*++

Routine Description:

	This is the routine fired off after a delay in order to
	queue an event on an ELAN. The event is queued now.

Arguments:

    SystemSpecific[1-3]	- Ignored
    TimerContext		- Actually a pointer to the delayed event structure

Return Value:

	None.
	
--*/
{	
	PATMLANE_DELAYED_EVENT	pDelayedEvent;
	PATMLANE_EVENT			pEvent;
	PATMLANE_ELAN			pElan;
	ULONG					rc;

	TRACEIN(QueueDelayedElanEvent);

	pDelayedEvent = (PATMLANE_DELAYED_EVENT)TimerContext;

	do
	{
		pElan = pDelayedEvent->pElan;

		ACQUIRE_ELAN_LOCK(pElan);

		pElan->pDelayedEvent = NULL;

		//
		//  Take out the delay event reference.
		//
		rc = AtmLaneDereferenceElan(pElan, "delayevent");

		if (rc == 0)
		{
			break;
		}

		pEvent = &pDelayedEvent->DelayedEvent;
		AtmLaneQueueElanEvent(pElan, pEvent->Event, pEvent->EventStatus);

		RELEASE_ELAN_LOCK(pElan);
	}
	while (FALSE);

	FREE_MEM(pDelayedEvent);

	TRACEOUT(QueueDelayedElanEvent);
	return;
}

VOID
AtmLaneQueueElanEvent(
	IN	PATMLANE_ELAN			pElan,
	IN	ULONG					Event,
	IN	NDIS_STATUS				EventStatus
	)
/*++

Routine Description:

	Queue an ELAN event on the ELAN's event queue and if
	not already scheduled, schedule the handler.  Caller
	is assumed to hold ELAN's lock.

Arguments:

    pElan				- Pointer to ELAN structure.
    Event				- Event code.
    EventStatus			- Status related to event.

Return Value:

	None.
	
--*/
{	
	PATMLANE_EVENT	pEvent;

	TRACEIN(AtmLaneQueueElanEvent);

	do
	{
		//
		//	If the ELAN is being shut down, don't queue any events.
		//
		if (ELAN_STATE_SHUTDOWN == pElan->AdminState)
		{
			if ((Event != ELAN_EVENT_START) &&
				(Event != ELAN_EVENT_RESTART))
			{
				DBGP((0, "%d: QueueElanEvent: Not queuing event %d (ELAN shutdown)\n", pElan->ElanNumber, Event));
				break;
			}
		}

		//
		//	Alloc an event struct 
		//
		ALLOC_MEM(&pEvent, sizeof(ATMLANE_EVENT));
		if ((PATMLANE_EVENT)NULL == pEvent)
		{
			DBGP((0, "QueueElanEvent: Event object alloc failed\n"));
			break;
		}

		//
		//	Stash event data in event struct
		//
		pEvent->Event = Event;
		pEvent->EventStatus = EventStatus;
	
		//
		//	Queue it at tail, reference Elan, and if required, schedule
		//  work item to handle it.
		//
		InsertTailList(&pElan->EventQueue, &pEvent->Link);
		AtmLaneReferenceElan(pElan, "event");

		if ((pElan->Flags & ELAN_EVENT_WORK_ITEM_SET) == 0)
		{
			NDIS_STATUS	Status;

			AtmLaneReferenceElan(pElan, "workitemevent");
			pElan->Flags |= ELAN_EVENT_WORK_ITEM_SET;

			NdisInitializeWorkItem(&pElan->EventWorkItem, AtmLaneEventHandler, pElan);
			Status = NdisScheduleWorkItem(&pElan->EventWorkItem);
			ASSERT(Status == NDIS_STATUS_SUCCESS);
		}

	} while (FALSE);

	TRACEOUT(QueueElanEvent);
	return;
}

PATMLANE_EVENT
AtmLaneDequeueElanEvent(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Remove an ELAN event from the head of the ELAN's
	event queue.  Caller is assumed to hold ELAN's lock.
  	Caller is responsible for freeing event object.
Arguments:

    pElan				- Pointer to ELAN structure.

Return Value:

	Pointer to removed ELAN event or NULL if queue empty.
	
--*/
{
	PLIST_ENTRY		p;
	PATMLANE_EVENT 	pEvent;

	TRACEIN(DequeueElanEvent);

	if (!IsListEmpty(&pElan->EventQueue))
	{
		p = RemoveHeadList(&pElan->EventQueue);
		pEvent = CONTAINING_RECORD(p, ATMLANE_EVENT, Link);
		(VOID)AtmLaneDereferenceElan(pElan, "event");
	}
	else
	{
		pEvent = NULL;
	}
	
	TRACEIN(DequeueElanEvent);

	return pEvent;
}

VOID
AtmLaneDrainElanEventQueue(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Remove all ELAN events from the ELAN's event queue.
	Caller is assumed to hold ELAN's lock.

Arguments:

    pElan				- Pointer to ELAN structure.

Return Value:

	None.
	
--*/
{
	BOOLEAN			WasCancelled;
	PATMLANE_EVENT 	pEvent;

	TRACEIN(DrainElanEventQueue);

	while ((pEvent = AtmLaneDequeueElanEvent(pElan)) != NULL)
	{
		DBGP((0, "%d Drained event %x, Status %x from Elan %x\n",
				pElan->ElanNumber,
				pEvent->Event,
				pEvent->EventStatus,
				pElan));

		FREE_MEM(pEvent);
	}
	
	TRACEIN(DrainElanEventQueue);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\irpstrng.h ===
struct _string_table irp_string_table[] = {
	{"IRP_MJ_CREATE",					IRP_MJ_CREATE},
	{"IRP_MJ_CREATE_NAMED_PIPE",		IRP_MJ_CREATE_NAMED_PIPE},
	{"IRP_MJ_CLOSE",					IRP_MJ_CLOSE},
	{"IRP_MJ_READ",					  	IRP_MJ_READ},
	{"IRP_MJ_WRITE",					IRP_MJ_WRITE},
	{"IRP_MJ_QUERY_INFORMATION",		IRP_MJ_QUERY_INFORMATION},
	{"IRP_MJ_SET_INFORMATION",			IRP_MJ_SET_INFORMATION},
	{"IRP_MJ_QUERY_EA",					IRP_MJ_QUERY_EA},
	{"IRP_MJ_SET_EA",					IRP_MJ_SET_EA},
	{"IRP_MJ_FLUSH_BUFFERS",			IRP_MJ_FLUSH_BUFFERS},
	{"IRP_MJ_QUERY_VOLUME_INFORMATION",	IRP_MJ_QUERY_VOLUME_INFORMATION},
	{"IRP_MJ_SET_VOLUME_INFORMATION",	IRP_MJ_SET_VOLUME_INFORMATION},
	{"IRP_MJ_DIRECTORY_CONTROL",		IRP_MJ_DIRECTORY_CONTROL},
	{"IRP_MJ_FILE_SYSTEM_CONTROL",		IRP_MJ_FILE_SYSTEM_CONTROL},
	{"IRP_MJ_DEVICE_CONTROL",			IRP_MJ_DEVICE_CONTROL},
	{"IRP_MJ_INTERNAL_DEVICE_CONTROL",	IRP_MJ_INTERNAL_DEVICE_CONTROL},
	{"IRP_MJ_SHUTDOWN",					IRP_MJ_SHUTDOWN},
	{"IRP_MJ_LOCK_CONTROL",				IRP_MJ_LOCK_CONTROL},
	{"IRP_MJ_CLEANUP",					IRP_MJ_CLEANUP},
	{"IRP_MJ_CREATE_MAILSLOT",			IRP_MJ_CREATE_MAILSLOT},
	{"IRP_MJ_QUERY_SECURITY",			IRP_MJ_QUERY_SECURITY},
	{"IRP_MJ_SET_SECURITY",				IRP_MJ_SET_SECURITY},
	{"IRP_MJ_POWER",					IRP_MJ_POWER},
	{"IRP_MJ_SYSTEM_CONTROL",			IRP_MJ_SYSTEM_CONTROL},
	{"IRP_MJ_DEVICE_CHANGE",			IRP_MJ_DEVICE_CHANGE},
	{"IRP_MJ_QUERY_QUOTA",				IRP_MJ_QUERY_QUOTA},
	{"IRP_MJ_SET_QUOTA",				IRP_MJ_SET_QUOTA},
	{"IRP_MJ_PNP",					 	IRP_MJ_PNP},
    {"*** UNKNOWN IRP MJ CODE ***",    	0xffffffff}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\externs.h ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	externs.h

Abstract:

	All external declarations for ATMLANE modules (functions,
	variables) are here.

Revision History:

Notes:

--*/

#ifndef __ATMLANE_EXTERNS_H
#define __ATMLANE_EXTERNS_H

#ifndef EXTERN
#define EXTERN extern
#endif // EXTERN

//
//  --------------- From adapter.c ----------------------------
//
#if 0
EXTERN VOID Adapter();
#endif

EXTERN
NDIS_STATUS
AtmLanePnPEventHandler(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNET_PNP_EVENT			NetPnPEvent
);

EXTERN
VOID
AtmLaneBindAdapterHandler(
	OUT	PNDIS_STATUS			pStatus,
	IN	NDIS_HANDLE				BindContext,
	IN	PNDIS_STRING			pDeviceName,
	IN	PVOID					SystemSpecific1,
	IN	PVOID					SystemSpecific2
);

EXTERN
VOID
AtmLaneUnbindAdapterHandler(
	OUT	PNDIS_STATUS			Status,
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				UnbindContext
);

EXTERN
VOID
AtmLaneCompleteUnbindAdapter(
	IN	PATMLANE_ADAPTER				pAdapter
);

EXTERN
VOID
AtmLaneOpenAdapterCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status,
	IN	NDIS_STATUS					OpenErrorStatus
);

EXTERN
VOID
AtmLaneCloseAdapterCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status
);

EXTERN
VOID
AtmLaneSendCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				Packet,
	IN	NDIS_STATUS					Status
	);

EXTERN
VOID
AtmLaneTransferDataCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				Packet,
	IN	NDIS_STATUS					Status,
	IN	UINT						BytesTransferred
	);

EXTERN
NDIS_STATUS
AtmLaneReceiveHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					MacReceiveContext,
	IN	PVOID						HeaderBuffer,
	IN	UINT						HeaderBufferSize,
	IN	PVOID						LookAheadBuffer,
	IN	UINT						LookaheadBufferSize,
	IN	UINT						PacketSize
	);

EXTERN
VOID
AtmLaneResetCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status
);

EXTERN
VOID
AtmLaneRequestCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_STATUS					Status
);

EXTERN
VOID
AtmLaneReceiveCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext
);

EXTERN
VOID
AtmLaneStatusHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						pStatusBuffer,
	IN	UINT						StatusBufferSize
);

EXTERN
VOID
AtmLaneStatusCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext
);

EXTERN
VOID
AtmLaneCoSendCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmLaneCoStatusHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						pStatusBuffer,
	IN	UINT						StatusBufferSize
);

EXTERN
NDIS_STATUS
AtmLaneSendAdapterNdisRequest(
	IN	PATMLANE_ADAPTER			pAdapter,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
);

EXTERN
VOID
AtmLaneGetAdapterInfo(
	IN	PATMLANE_ADAPTER			pAdapter
);

EXTERN
UINT
AtmLaneCoReceivePacketHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmLaneUnloadProtocol(
	VOID
);

EXTERN
BOOLEAN
AtmLaneIsDeviceAlreadyBound(
	IN	PNDIS_STRING				pDeviceName
);

//
//  --------------- From callmgr.c ----------------------------
//
#if 0
EXTERN VOID CallMgr();
#endif

EXTERN
VOID
AtmLaneAfRegisterNotifyHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PCO_ADDRESS_FAMILY			pAddressFamily
);

EXTERN
NDIS_STATUS
AtmLaneOpenCallMgr(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneOpenAfCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisAfHandle
);

EXTERN
VOID
AtmLaneCloseAfCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext
);

EXTERN

VOID
AtmLaneRegisterSaps(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneDeregisterSaps(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneRegisterSaps(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
NDIS_STATUS
AtmLaneMakeCall(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_ATM_ENTRY			pAtmEntry,
	IN	BOOLEAN						UsePvc
);

EXTERN
VOID
AtmLaneCloseCall(
	IN	PATMLANE_VC					pVc
);

EXTERN
NDIS_STATUS
AtmLaneCreateVcHandler(
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisVcHandle,
	OUT	PNDIS_HANDLE				pProtocolVcContext
);

EXTERN
NDIS_STATUS
AtmLaneDeleteVcHandler(
	IN	NDIS_HANDLE					ProtocolVcContext
);

EXTERN
NDIS_STATUS
AtmLaneIncomingCallHandler(
	IN		NDIS_HANDLE				ProtocolSapContext,
	IN		NDIS_HANDLE				ProtocolVcContext,
	IN OUT	PCO_CALL_PARAMETERS 	pCallParameters
);


EXTERN
VOID
AtmLaneCallConnectedHandler(
	IN	NDIS_HANDLE					ProtocolVcContext
);

EXTERN
VOID
AtmLaneIncomingCloseHandler(
	IN	NDIS_STATUS					CloseStatus,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PVOID						pCloseData	OPTIONAL,
	IN	UINT						Size		OPTIONAL
);

EXTERN
VOID
AtmLaneIncomingDropPartyHandler(
	IN	NDIS_STATUS					DropStatus,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	PVOID						pCloseData	OPTIONAL,
	IN	UINT						Size		OPTIONAL
);

EXTERN
VOID
AtmLaneQosChangeHandler(
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
);

EXTERN
VOID
AtmLaneRegisterSapCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolSapContext,
	IN	PCO_SAP						pSap,
	IN	NDIS_HANDLE					NdisSapHandle
);

EXTERN
VOID
AtmLaneDeregisterSapCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolSapContext
);

EXTERN
VOID
AtmLaneMakeCallCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					NdisPartyHandle		OPTIONAL,
	IN	PCO_CALL_PARAMETERS			pCallParameters
);

EXTERN
VOID
AtmLaneCloseCallCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					ProtocolPartyContext OPTIONAL
);

EXTERN
VOID
AtmLaneAddPartyCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	NDIS_HANDLE					NdisPartyHandle,
	IN	PCO_CALL_PARAMETERS			pCallParameters
);

EXTERN
VOID
AtmLaneDropPartyCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext
);

EXTERN
VOID
AtmLaneModifyQosCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
);

EXTERN
NDIS_STATUS
AtmLaneSendNdisCoRequest(
	IN	NDIS_HANDLE					NdisAdapterHandle,
	IN	NDIS_HANDLE					NdisAfHandle,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
);

EXTERN
NDIS_STATUS
AtmLaneCoRequestHandler(
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_HANDLE					ProtocolPartyContext	OPTIONAL,
	IN OUT PNDIS_REQUEST			pNdisRequest
);

EXTERN
VOID
AtmLaneCoRequestCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_HANDLE					ProtocolPartyContext	OPTIONAL,
	IN	PNDIS_REQUEST				pNdisRequest
);

EXTERN
NDIS_STATUS
AtmLaneGetAtmAddress(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneGetAtmAddressComplete(
	IN	NDIS_STATUS					Status,
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_REQUEST				pNdisRequest
);

EXTERN
NDIS_STATUS
AtmLaneGetLecsIlmi(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneGetLecsIlmiComplete(
	IN	NDIS_STATUS					Status,
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_REQUEST				pNdisRequest
);

//
//  --------------- From elanpkt.c ----------------------------
//
#if 0
EXTERN VOID ElanPkt();
#endif

EXTERN
VOID
AtmLaneSendConfigureRequest(
	IN PATMLANE_ELAN				pElan	LOCKIN NOLOCKOUT
);

EXTERN
VOID
AtmLaneSendJoinRequest(
	IN PATMLANE_ELAN				pElan
);

EXTERN
VOID
AtmLaneSendArpRequest(
	IN PATMLANE_ELAN				pElan,
	IN PATMLANE_MAC_ENTRY			pMacEntry	LOCKIN NOLOCKOUT
);

EXTERN
VOID
AtmLaneSendReadyQuery(
	IN PATMLANE_ELAN				pElan,
	IN PATMLANE_VC					pVc		LOCKIN NOLOCKOUT
);

EXTERN
VOID
AtmLaneSendReadyIndication(
	IN PATMLANE_ELAN				pElan,
	IN PATMLANE_VC					pVc		LOCKIN NOLOCKOUT
);

EXTERN
VOID
AtmLaneSendFlushRequest(
	IN PATMLANE_ELAN				pElan,
	IN PATMLANE_MAC_ENTRY			pMacEntry	LOCKIN NOLOCKOUT,
	IN PATMLANE_ATM_ENTRY			pAtmEntry
);

EXTERN
VOID
AtmLaneConfigureResponseHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmLaneControlPacketHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmLaneJoinResponseHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PLANE_CONTROL_FRAME 		pCf
);

EXTERN
VOID
AtmLaneReadyQueryHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_VC					pVc,
	IN	PNDIS_PACKET				pQueryNdisPacket
);

EXTERN
VOID
AtmLaneFlushRequestHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_PACKET				pRequestNdisPacket
);

EXTERN
VOID
AtmLaneArpRequestHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PLANE_CONTROL_FRAME 		pCf
);

EXTERN
VOID
AtmLaneArpResponseHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PLANE_CONTROL_FRAME 		pCf
);

EXTERN
VOID
AtmLaneFlushResponseHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PLANE_CONTROL_FRAME 		pCf
);

EXTERN
VOID
AtmLaneReadyIndicationHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_VC					pVc,
	IN	PNDIS_PACKET				pIndNdisPacket
);

EXTERN
VOID
AtmLaneTopologyRequestHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PLANE_CONTROL_FRAME			pCf
);

EXTERN
BOOLEAN
AtmLaneDataPacketHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmLaneSendPacketOnVc(
	IN	PATMLANE_VC					pVc		LOCKIN	NOLOCKOUT,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	BOOLEAN						Refresh
);
	
EXTERN
VOID
AtmLaneQueuePacketOnHead(
	IN	PATMLANE_MAC_ENTRY			pMacEntry,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmLaneQueuePacketOnTail(
	IN	PATMLANE_MAC_ENTRY			pMacEntry,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
PNDIS_PACKET
AtmLaneDequeuePacketFromHead(
	IN	PATMLANE_MAC_ENTRY			pMacEntry
);

EXTERN
NDIS_STATUS
AtmLaneSendUnicastPacket(
	IN	PATMLANE_ELAN				pElan,
	IN	ULONG						DestAddrType,
	IN	PMAC_ADDRESS				pDestAddress,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmLaneStartBusSends(
	IN	PATMLANE_MAC_ENTRY			pMacEntry	LOCKIN	NOLOCKOUT
);

EXTERN
VOID
AtmLaneDoBusSends(
	IN	PATMLANE_MAC_ENTRY			pMacEntry	LOCKIN	NOLOCKOUT
);

EXTERN
VOID
AtmLaneBusSendTimer(
	IN	PVOID						SystemSpecific1,
	IN	PVOID						pContext,
	IN	PVOID						SystemSpecific2,
	IN	PVOID						SystemSpecific3
);

EXTERN
BOOLEAN
AtmLaneOKToBusSend(
	IN	PATMLANE_MAC_ENTRY		pMacEntry
);

EXTERN
VOID
AtmLaneFreePacketQueue(
	IN	PATMLANE_MAC_ENTRY			pMacEntry,
	IN	NDIS_STATUS					Status
);

EXTERN
VOID
AtmLaneCompleteSendPacket(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	NDIS_STATUS					Status
);

EXTERN
PWSTR
AtmLaneMacAddrToString(
	IN	VOID * pIn
);

EXTERN
PWSTR
AtmLaneAtmAddrToString(
	IN	PATM_ADDRESS pIn
);


//
//  --------------- From elanproc.c ----------------------------
//
#if 0
EXTERN VOID elanproc();
#endif

EXTERN
VOID
AtmLaneEventHandler(
	IN	PNDIS_WORK_ITEM				pWorkItem,
	IN	PVOID						pContext
);

EXTERN
VOID
AtmLaneBootStrapElans(
    IN  PATMLANE_ADAPTER            pAdapter
);

EXTERN
NDIS_STATUS
AtmLaneCreateElan(
    IN  PATMLANE_ADAPTER            pAdapter,
    IN  PNDIS_STRING                pElanKey,
    OUT	PATMLANE_ELAN *				ppElan
);

EXTERN
NDIS_STATUS
AtmLaneReconfigureHandler(
	IN	PATMLANE_ADAPTER		pAdapter,
	IN	PNET_PNP_EVENT			pNetPnPEvent
);

EXTERN
PATMLANE_ELAN
AtmLaneFindElan(
	IN	PATMLANE_ADAPTER		pAdapter,
	IN	PNDIS_STRING			pElanKey
);

EXTERN
VOID
AtmLaneConnectToServer(
	IN	PATMLANE_ELAN				pElan		LOCKIN NOLOCKOUT,
	IN	ULONG						ServerType,
	IN	BOOLEAN						UsePvc
);

EXTERN
VOID
AtmLaneInvalidateAtmEntry(
	IN	PATMLANE_ATM_ENTRY			pAtmEntry	LOCKIN NOLOCKOUT
);

EXTERN
VOID
AtmLaneCloseVCsOnAtmEntry(
	IN	PATMLANE_ATM_ENTRY			pAtmEntry	LOCKIN NOLOCKOUT
);

EXTERN
VOID
AtmLaneGenerateMacAddr(
	PATMLANE_ELAN					pElan
);

EXTERN
PATMLANE_MAC_ENTRY
AtmLaneSearchForMacAddress(
	PATMLANE_ELAN					pElan,
	ULONG							pMacAddrType,
	PMAC_ADDRESS					pMacAddress,
	BOOLEAN							CreateNew
);

EXTERN
PATMLANE_ATM_ENTRY
AtmLaneSearchForAtmAddress(
	IN	PATMLANE_ELAN				pElan,
	IN	PUCHAR						pAtmAddress,
	IN	ULONG						Type,
	IN	BOOLEAN						CreateNew
);

EXTERN
ULONG
AtmLaneMacAddrEqual(
	PMAC_ADDRESS			pMacAddr1,
	PMAC_ADDRESS			pMacAddr2
);

EXTERN
VOID
AtmLaneAbortMacEntry(
	IN	PATMLANE_MAC_ENTRY			pMacEntry
);

EXTERN
VOID
AtmLaneMacEntryAgingTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmLaneArpTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmLaneConfigureResponseTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmLaneJoinResponseTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmLaneInitializeMiniportDevice(
	IN	PNDIS_WORK_ITEM				NdisWorkItem,
	IN	PVOID						Context
);

EXTERN
VOID
AtmLaneReadyTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmLaneFlushTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmLaneVcAgingTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmLaneShutdownElan(
	IN	PATMLANE_ELAN				pElan		LOCKIN	NOLOCKOUT,
	IN	BOOLEAN						Restart
);

EXTERN
VOID
AtmLaneContinueShutdownElan(
	IN	PATMLANE_ELAN				pElan
);

EXTERN
VOID
AtmLaneGetProtocolConfiguration(
	IN	NDIS_HANDLE				AdapterConfigHandle,
	IN	PATMLANE_ADAPTER		pAdapter
);


EXTERN
VOID
AtmLaneGetElanConfiguration(
	IN	NDIS_HANDLE				ElanConfigHandle,
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneQueueElanEventAfterDelay(
	IN	PATMLANE_ELAN			pElan,
	IN	ULONG					Event,
	IN	NDIS_STATUS				EventStatus,
	IN	ULONG					DelayMs
	);

EXTERN
VOID
AtmLaneQueueDelayedElanEvent(
	IN	PVOID					SystemSpecific1,
	IN	PVOID					TimerContext,
	IN	PVOID					SystemSpecific2,
	IN	PVOID					SystemSpecific3
	);


EXTERN
VOID
AtmLaneQueueElanEvent(
	IN	PATMLANE_ELAN			pElan,
	IN	ULONG					Event,
	IN	NDIS_STATUS				EventStatus
);

EXTERN
PATMLANE_EVENT
AtmLaneDequeueElanEvent(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneDrainElanEventQueue(
	IN	PATMLANE_ELAN			pElan
);


//
//  --------------- From miniport.c ----------------------------
//
#if 0
EXTERN VOID Miniport();
#endif

EXTERN
NDIS_STATUS 
AtmLaneMInitialize(
	OUT	PNDIS_STATUS			OpenErrorStatus,
	OUT	PUINT					SelectedMediumIndex,
	IN	PNDIS_MEDIUM				MediumArray,
	IN	UINT						MediumArraySize,
	IN	NDIS_HANDLE				MiniportAdapterHandle,
	IN	NDIS_HANDLE				WrapperConfigurationContext
);

EXTERN
VOID
AtmLaneMSendPackets(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PPNDIS_PACKET			PacketArray,
	IN	UINT						NumberOfPackets
);

EXTERN
VOID
AtmLaneMReturnPacket(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PNDIS_PACKET				Packet
);

EXTERN
NDIS_STATUS 
AtmLaneMQueryInformation(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_OID					Oid,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT	PULONG					BytesWritten,
	OUT	PULONG					BytesNeeded
);

EXTERN
NDIS_STATUS 
AtmLaneMSetInformation(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_OID					Oid,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT	PULONG					BytesRead,
	OUT	PULONG					BytesNeeded
);

EXTERN
NDIS_STATUS 
AtmLaneMReset(
	OUT	PBOOLEAN 				AddressingReset,
	IN	NDIS_HANDLE 			MiniportAdapterContext
);

EXTERN
VOID 
AtmLaneMHalt(
	IN	NDIS_HANDLE MiniportAdapterContext
);

EXTERN
PNDIS_PACKET
AtmLaneWrapSendPacket(
	IN	PATMLANE_ELAN			pElan,
	IN	PNDIS_PACKET			pSendNdisPacket,
	OUT	ULONG *					pMacAddrType,
	OUT	PMAC_ADDRESS			pMacAddress,
	OUT	BOOLEAN	*				pSendViaBUS
);

EXTERN
PNDIS_PACKET
AtmLaneUnwrapSendPacket(
	IN	PATMLANE_ELAN			pElan,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
PNDIS_PACKET
AtmLaneWrapRecvPacket(
	IN	PATMLANE_ELAN			pElan,
	IN	PNDIS_PACKET			pRecvNdisPacket,
	OUT	ULONG *					pMacHdrSize,
	OUT	ULONG *					pDestAddrType,					
	OUT	PMAC_ADDRESS			pDestAddr,
	OUT	BOOLEAN	*				pDestIsMulticast
)
;		

EXTERN
PNDIS_PACKET
AtmLaneUnwrapRecvPacket(
	IN	PATMLANE_ELAN			pElan,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
NDIS_STATUS
AtmLaneMSetNetworkAddresses(
	IN	PATMLANE_ELAN			pElan,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT	PULONG					BytesRead,
	OUT	PULONG					BytesNeeded
);

//
//  --------------- From space.c ----------------------------
//
#if 0
EXTERN VOID Space();
#endif

EXTERN	PATMLANE_GLOBALS	pAtmLaneGlobalInfo;
EXTERN 	ATM_ADDRESS 		gWellKnownLecsAddress;

EXTERN	ATM_ADDRESS 		gWellKnownLecsAddress;
EXTERN	MAC_ADDRESS			gMacBroadcastAddress;
EXTERN	ULONG				AtmLaneMaxTimerValue[];
EXTERN	ULONG				AtmLaneTimerListSize[];
EXTERN	ULONG				AtmLaneTimerPeriod[];

//
//  --------------- From utils.c ----------------------------
//
#if 0
EXTERN VOID Utils();
#endif

EXTERN
VOID
AtmLaneInitGlobals(
	VOID
);

EXTERN
PATMLANE_ADAPTER
AtmLaneAllocAdapter(
	IN	PNDIS_STRING		pDeviceName,
	IN	PVOID				SystemSpecific1
);

EXTERN
VOID
AtmLaneDeallocateAdapter(
	IN	PATMLANE_ADAPTER	pAdapter
);

EXTERN
BOOLEAN
AtmLaneReferenceAdapter(
	IN	PATMLANE_ADAPTER	pAdapter,
	IN	PUCHAR				String
);

EXTERN
ULONG
AtmLaneDereferenceAdapter(
	IN	PATMLANE_ADAPTER	pAdapter,
	IN	PUCHAR				String
);
	
EXTERN
NDIS_STATUS
AtmLaneAllocElan(
	IN		PATMLANE_ADAPTER	pAdapter,
	IN OUT	PATMLANE_ELAN		*ppElan
);

EXTERN
VOID
AtmLaneDeallocateElan(
	IN	PATMLANE_ELAN		pElan
);

EXTERN
VOID
AtmLaneReferenceElan(
	IN	PATMLANE_ELAN		pElan,
	IN	PUCHAR				String
);

EXTERN
ULONG
AtmLaneDereferenceElan(
	IN	PATMLANE_ELAN		pElan,
	IN	PUCHAR				String
);

EXTERN
VOID
AtmLaneUnlinkElanFromAdapter(
	IN	PATMLANE_ELAN		pElan
);

EXTERN
PATMLANE_ATM_ENTRY
AtmLaneAllocateAtmEntry(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneDeallocateAtmEntry(
	IN	PATMLANE_ATM_ENTRY			pAtmEntry
);

EXTERN
VOID
AtmLaneReferenceAtmEntry(
	IN	PATMLANE_ATM_ENTRY			pAtmEntry,
	IN	PUCHAR						String
);

EXTERN
ULONG
AtmLaneDereferenceAtmEntry(
	IN	PATMLANE_ATM_ENTRY			pAtmEntry,
	IN	PUCHAR						String
);

EXTERN
PATMLANE_VC
AtmLaneAllocateVc(
	IN	PATMLANE_ELAN				pElan
);

EXTERN
VOID
AtmLaneDeallocateVc(
	IN	PATMLANE_VC					pVc
);

EXTERN
VOID
AtmLaneReferenceVc(
	IN	PATMLANE_VC					pVc,
	IN	PUCHAR						String
);

EXTERN
ULONG
AtmLaneDereferenceVc(
	IN	PATMLANE_VC					pVc,
	IN	PUCHAR						String
);

EXTERN
PATMLANE_MAC_ENTRY
AtmLaneAllocateMacEntry(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneDeallocateMacEntry(
	IN	PATMLANE_MAC_ENTRY			pMacEntry
);

EXTERN
VOID
AtmLaneReferenceMacEntry(
	IN	PATMLANE_MAC_ENTRY			pMacEntry,
	IN	PUCHAR						String
);

EXTERN
ULONG
AtmLaneDereferenceMacEntry(
	IN	PATMLANE_MAC_ENTRY			pMacEntry,
	IN	PUCHAR						String
);

EXTERN
PNDIS_PACKET
AtmLaneAllocProtoPacket(
	IN	PATMLANE_ELAN			pElan
);

VOID
AtmLaneFreeProtoPacket(
	IN	PATMLANE_ELAN			pElan,
	IN	PNDIS_PACKET			pNdisPacket
);

EXTERN
PNDIS_BUFFER
AtmLaneGrowHeaders(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
PNDIS_BUFFER
AtmLaneAllocateHeader(
	IN	PATMLANE_ELAN			pElan,
	OUT	PUCHAR *				pBufferAddress
);

EXTERN
VOID
AtmLaneFreeHeader(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	BOOLEAN						LockHeld
);

EXTERN
VOID
AtmLaneDeallocateHeaderBuffers(
	IN	PATMLANE_ELAN				pElan
);

EXTERN
PNDIS_BUFFER
AtmLaneGrowPadBufs(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
PNDIS_BUFFER
AtmLaneAllocatePadBuf(
	IN	PATMLANE_ELAN			pElan,
	OUT	PUCHAR *				pBufferAddress
);

EXTERN
VOID
AtmLaneFreePadBuf(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	BOOLEAN						LockHeld
);

EXTERN
VOID
AtmLaneDeallocatePadBufs(
	IN	PATMLANE_ELAN				pElan
);

EXTERN
PNDIS_BUFFER
AtmLaneAllocateProtoBuffer(
	IN	PATMLANE_ELAN				pElan,
	IN	ULONG						Length,
	OUT	PUCHAR *					pBufferAddress
);

EXTERN
VOID
AtmLaneFreeProtoBuffer(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_BUFFER				pNdisBuffer
);

EXTERN
NDIS_STATUS
AtmLaneInitProtoBuffers(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneDeallocateProtoBuffers(
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneLinkVcToAtmEntry(
	IN	PATMLANE_VC					pVc,
	IN	PATMLANE_ATM_ENTRY			pAtmEntry,
	IN	BOOLEAN						ServerIncoming
);

EXTERN
BOOLEAN
AtmLaneUnlinkVcFromAtmEntry(
	IN	PATMLANE_VC					pVc
);

EXTERN
BOOLEAN
AtmLaneUnlinkMacEntryFromAtmEntry(
	IN	PATMLANE_MAC_ENTRY			pMacEntry
);

EXTERN
VOID
AtmLaneStartTimer(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_TIMER				pTimer,
	IN	ATMLANE_TIMEOUT_HANDLER		TimeoutHandler,
	IN	ULONG						SecondsToGo,
	IN	PVOID						ContextPtr
);

EXTERN
BOOLEAN
AtmLaneStopTimer(
	IN	PATMLANE_TIMER			pTimer,
	IN	PATMLANE_ELAN			pElan
);

EXTERN
VOID
AtmLaneRefreshTimer(
	IN	PATMLANE_TIMER				pTimer
);

EXTERN
VOID
AtmLaneTickHandler(
	IN	PVOID						SystemSpecific1,
	IN	PVOID						Context,
	IN	PVOID						SystemSpecific2,
	IN	PVOID						SystemSpecific3
);

EXTERN
ULONG
AtmLaneSystemTimeMs(
	void
);

EXTERN
VOID
AtmLaneBitSwapMacAddr(
	IN OUT	PUCHAR		ap
);

EXTERN
BOOLEAN
AtmLaneCopyUnicodeString(
	IN OUT	PUNICODE_STRING pDestString,
	IN OUT	PUNICODE_STRING pSrcString,
	IN		BOOLEAN			AllocDest,
	IN		BOOLEAN			ConvertToUpper
);

EXTERN
PWSTR
AtmLaneStrTok(
	IN	PWSTR	StrToken,
	IN	WCHAR	ChrDelim,
	OUT	PUSHORT	pStrLength
);

#endif	//	__ATMLANE_EXTERNS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\ioctl.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997  Microsoft Corporation

Module Name:

	ioctl.c

Abstract:

	IOCTL Handler functions

Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Notes:

--*/
#include <precomp.h>


PATMLANE_ADAPTER
AtmLaneIoctlNameToAdapter(
	IN	PUNICODE_STRING		pDeviceName
)
/*++

Routine Description:

	Given the name of an adapter, return a pointer to the corresponding
	adapter structure if one exists, else NULL.

	This routine also references the adapter.

Arguments:

	pDeviceName	- Pointer to Device name we are searching for.

Return Value:

	See above.

--*/
{
	PLIST_ENTRY				pListEntry;
	PATMLANE_ADAPTER		pAdapter;
	PATMLANE_ADAPTER		pAdapterToReturn = NULL_PATMLANE_ADAPTER;
	BOOLEAN                 bReferenced = FALSE;

	TRACEIN(IoctlNameToAdapter);

	// fixup the Buffer pointer
	
	pDeviceName->Buffer = (PWSTR)((PUCHAR)pDeviceName + sizeof(UNICODE_STRING));
	

	// loop thru the adapters looking for the ELAN

	ACQUIRE_GLOBAL_LOCK(pAtmLaneGlobalInfo);
	
	for (pListEntry = pAtmLaneGlobalInfo->AdapterList.Flink;
		 pListEntry != &(pAtmLaneGlobalInfo->AdapterList);
		 pListEntry = pListEntry->Flink)
	{
		// get pointer to Adapter
	
		pAdapter = CONTAINING_RECORD(pListEntry, ATMLANE_ADAPTER, Link);
		STRUCT_ASSERT(pAdapter, atmlane_adapter);
		
		// compare length first and then actual names

		if ((pDeviceName->Length == pAdapter->DeviceName.Length) &&
			(memcmp(pDeviceName->Buffer,
						pAdapter->DeviceName.Buffer,
						pDeviceName->Length) == 0))
		{
			// match - return this adapter
		
			pAdapterToReturn = pAdapter;

			ACQUIRE_ADAPTER_LOCK_DPC(pAdapter);
			bReferenced = AtmLaneReferenceAdapter(pAdapter, "ioctl");
			RELEASE_ADAPTER_LOCK_DPC(pAdapter);

			break;
		}
	}

	RELEASE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

	TRACEOUT(IoctlNameToAdapter);
	return (bReferenced? pAdapterToReturn: NULL);
}


PATMLANE_ELAN
AtmLaneIoctlNameToElan(
	IN	PATMLANE_ADAPTER	pAdapter,
	IN	PUNICODE_STRING		pDeviceName
)
/*++

Routine Description:

	Given a pointer to an adapter data structure and an 
	ELAN device name, return a pointer to the corresponding
	ELAN structure if one exists, else NULL.

	This also references the ELAN structure.

Arguments:
	pAdapter	- Pointer to Adapter data structure.
	pDeviceName	- Pointer to Device name we are searching for.

Return Value:

	See above.

--*/
{
	PLIST_ENTRY				pListEntry;
	PATMLANE_ELAN			pElan;
	PATMLANE_ELAN			pElanToReturn = NULL_PATMLANE_ELAN;

	TRACEIN(IoctlNameToElan);

	STRUCT_ASSERT(pAdapter, atmlane_adapter);

	// fixup the Buffer pointer

	pDeviceName->Buffer = (PWSTR)((PUCHAR)pDeviceName + sizeof(UNICODE_STRING));
	
	ACQUIRE_ADAPTER_LOCK(pAdapter);

	// loop thru the ELANs looking for the given name

	for (pListEntry = pAdapter->ElanList.Flink;
		 pListEntry != &(pAdapter->ElanList);
		 pListEntry = pListEntry->Flink)
	{
		// get pointer to ELAN
	
		pElan = CONTAINING_RECORD(pListEntry, ATMLANE_ELAN, Link);
		STRUCT_ASSERT(pElan, atmlane_elan);

		// compare length first and then actual names

		if ((pDeviceName->Length == pElan->CfgDeviceName.Length) &&
			(memcmp(pDeviceName->Buffer,
						pElan->CfgDeviceName.Buffer,
						pDeviceName->Length) == 0))
		{
			// match - return this ELAN
		
			pElanToReturn = pElan;

			ACQUIRE_ELAN_LOCK(pElan);
			AtmLaneReferenceElan(pElan, "iocnametoelan");
			RELEASE_ELAN_LOCK(pElan);

			break;
		}
	}
	
	RELEASE_ADAPTER_LOCK(pAdapter);

	TRACEOUT(IoctlNameToElan);

	return (pElanToReturn);
}

NTSTATUS
AtmLaneIoctlGetInfoVersion (
	IN	PUCHAR				pBuffer,
	IN 	UINT				InputBufferLength,
	IN	UINT				OutputBufferLength,
	IN OUT	UINT_PTR *		pBytesWritten
)
/*++

Routine Description:

	Return the version number of the information exported by
	these ioctl codes. 
	
Arguments:

	pBuffer				- Space for input/output
	InputBufferLength	- Length of input parameters
	OutputBufferLength	- Space available for output
	pBytesWritten		- Where we return the amount we actually used up

Return Value:

	Status code

--*/
{
	NTSTATUS			Status;
	
	TRACEIN(IoctlGetInfoVersion);

	// init

	*pBytesWritten = 0;
	Status = STATUS_SUCCESS;

	do
	{
		//	check for enough output space

		if (OutputBufferLength < sizeof(ULONG))
		{
			Status =  STATUS_BUFFER_OVERFLOW;
			break;
		}

		//	output the version

		*((PULONG)pBuffer) = ATMLANE_INFO_VERSION;
		
		*pBytesWritten = sizeof(ULONG);
	}
	while (FALSE);

	TRACEOUT(IoctlGetInfoVersion);

	return STATUS_SUCCESS;
}

NTSTATUS
AtmLaneIoctlEnumerateAdapters (
	IN	PUCHAR				pBuffer,
	IN 	UINT				InputBufferLength,
	IN	UINT				OutputBufferLength,
	IN OUT	UINT_PTR *		pBytesWritten
)
/*++

Routine Description:

	Return a list of adapters bound to the AtmLane protocol.
	We go through the list of Adapter structures and concatenate the
	device names stored in each into the output buffer.

Arguments:

	pBuffer				- Space for input/output
	InputBufferLength	- Length of input parameters
	OutputBufferLength	- Space available for output
	pBytesWritten		- Where we return the amount we actually used up

Return Value:

	Status code

--*/
{
	PATMLANE_ADAPTER		pAdapter;
	UINT					Remaining;
	PATMLANE_ADAPTER_LIST	pAdapterList;
	PUNICODE_STRING			pAdapterName;
	NTSTATUS				Status;
	PLIST_ENTRY				pListEntry;

	TRACEIN(IoctlEnumAdapters);

	// init

	*pBytesWritten = 0;
	Status = STATUS_SUCCESS;

	do
	{
		//	check for minimal output space

		Remaining = OutputBufferLength;
		if (Remaining < sizeof(ATMLANE_ADAPTER_LIST))
		{
			Status =  STATUS_BUFFER_OVERFLOW;
			break;
		}

		pAdapterList = (PATMLANE_ADAPTER_LIST)pBuffer;

		//	setup to return empty list

		pAdapterList->AdapterCountReturned = 0;
		*pBytesWritten = FIELD_OFFSET(ATMLANE_ADAPTER_LIST, AdapterList);
		pAdapterName = &pAdapterList->AdapterList;

		//  adjust space for output
		Remaining -= FIELD_OFFSET (ATMLANE_ADAPTER_LIST, AdapterList);

		//	loop thru the adapters

		ACQUIRE_GLOBAL_LOCK(pAtmLaneGlobalInfo);
	
		for (pListEntry = pAtmLaneGlobalInfo->AdapterList.Flink;
			 pListEntry != &(pAtmLaneGlobalInfo->AdapterList);
			 pListEntry = pListEntry->Flink)
		{
			//	get pointer to adapter struct
	
			pAdapter = CONTAINING_RECORD(pListEntry, ATMLANE_ADAPTER, Link);
			STRUCT_ASSERT(pAdapter, atmlane_adapter);

			//	quit loop if no more space

			if (Remaining < sizeof(NDIS_STRING) + pAdapter->DeviceName.Length)
			{
				Status = STATUS_BUFFER_OVERFLOW;
				break;
			}

			//	count and copy the adapter name

			pAdapterList->AdapterCountReturned++;
			pAdapterName->Buffer = (PWSTR)((PUCHAR)pAdapterName + sizeof(UNICODE_STRING));
			memcpy(pAdapterName->Buffer, pAdapter->DeviceName.Buffer, pAdapter->DeviceName.Length);
			pAdapterName->MaximumLength = pAdapterName->Length = pAdapter->DeviceName.Length;

			//  convert the Buffer pointer to an offset - caller expects it

			pAdapterName->Buffer = (PWSTR)((PUCHAR)pAdapterName->Buffer - (PUCHAR)pAdapterList);

			//	move ptr past the name we just copied

			pAdapterName = (PUNICODE_STRING)((PUCHAR)pAdapterName + sizeof(UNICODE_STRING)
							+ pAdapter->DeviceName.Length);

			//	update bytes written and remaining space

			*pBytesWritten += sizeof(UNICODE_STRING) + pAdapter->DeviceName.Length;
			Remaining -= sizeof(UNICODE_STRING) + pAdapter->DeviceName.Length;
		}
	

		//	check count available same as count returned

		pAdapterList->AdapterCountAvailable = pAdapterList->AdapterCountReturned;

		//	count any remaining adapters that there wasn't space for

		while (pListEntry != &(pAtmLaneGlobalInfo->AdapterList))
		{
			pAdapterList->AdapterCountAvailable++;
			pListEntry = pListEntry->Flink;
		}

		RELEASE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

	} while (FALSE);
	
	TRACEOUT(IoctlEnumerateAdapters);
				
	return (Status);

}


NTSTATUS
AtmLaneIoctlEnumerateElans(
	IN	PUCHAR				pBuffer,
	IN 	UINT				InputBufferLength,
	IN	UINT				OutputBufferLength,
	IN OUT	UINT_PTR *		pBytesWritten
)
/*++

Routine Description:

	Return a list of adapters bound to the AtmLane protocol.
	We go through the list of Adapter structures and concatenate the
	device names stored in each into the output buffer.

Arguments:

	pBuffer				- Space for input/output
	InputBufferLength	- Length of input parameters
	OutputBufferLength	- Space available for output
	pBytesWritten		- Where we return the amount we actually used up

Return Value:

	Status code

--*/
{
	PATMLANE_ADAPTER		pAdapter;
	UINT					Remaining;
	PATMLANE_ELAN_LIST		pElanList;
	PUNICODE_STRING			pElanName;
	NTSTATUS				Status;
	PATMLANE_ELAN			pElan;
	PLIST_ENTRY				pListEntry;
	ULONG					rc;

	TRACEIN(IoctlEnumerateElans);

	// init
	
	*pBytesWritten = 0;
	Status = STATUS_SUCCESS;
	pAdapter = NULL;

	do
	{
		//	check if adapter string passed in

		if (InputBufferLength < sizeof(UNICODE_STRING))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		if (InputBufferLength < sizeof(UNICODE_STRING) + ((PUNICODE_STRING)pBuffer)->MaximumLength)
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		//  sanity check

		if (((PUNICODE_STRING)pBuffer)->MaximumLength < ((PUNICODE_STRING)pBuffer)->Length)
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		//	get the adapter struct from the name
	
		pAdapter = AtmLaneIoctlNameToAdapter((PUNICODE_STRING)pBuffer);

		if (pAdapter == NULL_PATMLANE_ADAPTER)
		{
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		//	check for minimal output space

		Remaining = OutputBufferLength;
		if (Remaining < sizeof(ATMLANE_ELAN_LIST))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}	

		pElanList = (PATMLANE_ELAN_LIST)pBuffer;

		//	setup to return empty list
	
		pElanList->ElanCountReturned = 0;
		*pBytesWritten = FIELD_OFFSET(ATMLANE_ELAN_LIST, ElanList);
		Remaining -= FIELD_OFFSET(ATMLANE_ELAN_LIST, ElanList);

		pElanName = &pElanList->ElanList;

		//	loop thru the Elans

		ACQUIRE_ADAPTER_LOCK(pAdapter);
	
		for (pListEntry = pAdapter->ElanList.Flink;
		 	pListEntry != &(pAdapter->ElanList);
		 	pListEntry = pListEntry->Flink)
		{
			//	get pointer to adapter struct
	
			pElan = CONTAINING_RECORD(pListEntry, ATMLANE_ELAN, Link);
			STRUCT_ASSERT(pElan, atmlane_elan);

			//	quit loop if no more space

			if (Remaining < sizeof(NDIS_STRING) + pElan->CfgDeviceName.Length)
			{
				Status = STATUS_BUFFER_OVERFLOW;
				break;
			}

			//	count and copy the adapter name

			pElanList->ElanCountReturned++;
			pElanName->Buffer = (PWSTR)((PUCHAR)pElanName + sizeof(UNICODE_STRING));
			memcpy(pElanName->Buffer, pElan->CfgDeviceName.Buffer, pElan->CfgDeviceName.Length);
			pElanName->MaximumLength = pElanName->Length = pElan->CfgDeviceName.Length;

			//  convert the Buffer pointer to an offset - caller expects it

			pElanName->Buffer = (PWSTR)((PUCHAR)pElanName->Buffer - (PUCHAR)pElanList);

			//	move ptr past the name we just copied

			pElanName = (PUNICODE_STRING)((PUCHAR)pElanName + sizeof(UNICODE_STRING)
							+ pElan->CfgDeviceName.Length);

			//	update bytes written and remaining space

			*pBytesWritten += (sizeof(UNICODE_STRING) + pElan->CfgDeviceName.Length);
			Remaining -= sizeof(UNICODE_STRING) + pElan->CfgDeviceName.Length;
		}

		//	set count available same as count returned

		pElanList->ElanCountAvailable = pElanList->ElanCountReturned;

		//	count any remaining adapters that there wasn't space for

		while (pListEntry != &(pAdapter->ElanList))
		{
			pElanList->ElanCountAvailable++;
			pListEntry = pListEntry->Flink;
		}

		RELEASE_ADAPTER_LOCK(pAdapter);

	} while (FALSE);
	
	if (pAdapter != NULL)
	{
		ACQUIRE_ADAPTER_LOCK(pAdapter);
		rc = AtmLaneDereferenceAdapter(pAdapter, "ioctl: enumelans");
		
		if (rc != 0)
		{
			RELEASE_ADAPTER_LOCK(pAdapter);
		}
	}

	TRACEOUT(IoctlEnumerateElans);

	return (Status);
}


NTSTATUS
AtmLaneIoctlGetElanInfo(
	IN	PUCHAR				pBuffer,
	IN 	UINT				InputBufferLength,
	IN	UINT				OutputBufferLength,
	OUT	UINT_PTR *			pBytesWritten
)
/*++

Routine Description:

	Return the state information about a specific Elan.

Arguments:

	pBuffer				- Space for input/output
	InputBufferLength	- Length of input parameters
	OutputBufferLength	- Space available for output
	pBytesWritten		- Where we return the amount we actually used up

Return Value:

	Status Code

--*/
{
	PATMLANE_ADAPTER					pAdapter;
	PATMLANE_ELAN						pElan;
	PUNICODE_STRING						pAdapterNameIn;
	PUNICODE_STRING						pElanNameIn;
	PATMLANE_ELANINFO					pElanInfo;
	NTSTATUS							Status;
	ULONG								rc;

	TRACEIN(IoctlGetElanInfo);

	// init

	*pBytesWritten = 0;
	Status = STATUS_SUCCESS;
	pAdapter = NULL;
	pElan = NULL;

	do
	{
	
		// check if adapter string passed in

		if (InputBufferLength < sizeof(UNICODE_STRING))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		// check if elan string passed in

		if (InputBufferLength < ((sizeof(UNICODE_STRING) * 2) + 
								((PUNICODE_STRING)pBuffer)->MaximumLength))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		//  sanity check

		if (((PUNICODE_STRING)pBuffer)->MaximumLength < ((PUNICODE_STRING)pBuffer)->Length)
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		// check if minimal output space

		if (OutputBufferLength < sizeof(ATMLANE_ELANINFO))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		// setup ptrs to input names

		pAdapterNameIn = (PUNICODE_STRING)pBuffer;
		pElanNameIn = (PUNICODE_STRING)(pBuffer + sizeof(UNICODE_STRING) + 
						pAdapterNameIn->MaximumLength);

		// find adapter struct

		pAdapter = AtmLaneIoctlNameToAdapter(pAdapterNameIn);

		if (pAdapter == NULL_PATMLANE_ADAPTER)
		{
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		// find elan struct - check the lengths passed in first.

		InputBufferLength -= (sizeof(UNICODE_STRING) + pAdapterNameIn->MaximumLength);

		if (InputBufferLength < sizeof(UNICODE_STRING))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		if (InputBufferLength < sizeof(UNICODE_STRING) + pElanNameIn->MaximumLength)
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		if (pElanNameIn->MaximumLength < pElanNameIn->Length)
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		pElan = AtmLaneIoctlNameToElan(pAdapter, pElanNameIn);

		if (pElan == NULL_PATMLANE_ELAN)
		{
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		// setup to fill in ELAN info

		pElanInfo = (PATMLANE_ELANINFO)pBuffer;
	
		NdisZeroMemory(pElanInfo, sizeof(ATMLANE_ELANINFO));
			
		ACQUIRE_ELAN_LOCK(pElan);

		pElanInfo->ElanNumber 			= pElan->ElanNumber;
		pElanInfo->ElanState			= pElan->State;
		NdisMoveMemory(
			&pElanInfo->AtmAddress,	
			&pElan->AtmAddress.Address,
			ATM_ADDRESS_LENGTH);
		NdisMoveMemory(
			&pElanInfo->LecsAddress, 
			&pElan->LecsAddress.Address, 
			ATM_ADDRESS_LENGTH);
		NdisMoveMemory(
			&pElanInfo->LesAddress,	
			&pElan->LesAddress.Address,	 
			ATM_ADDRESS_LENGTH);
		NdisMoveMemory(
			&pElanInfo->BusAddress,	
			&pElan->BusAddress.Address,	 
			ATM_ADDRESS_LENGTH);
		pElanInfo->LanType				= pElan->LanType;
		pElanInfo->MaxFrameSizeCode 	= pElan->MaxFrameSizeCode;
		pElanInfo->LecId				= SWAPUSHORT(pElan->LecId);
		NdisMoveMemory(
			pElanInfo->ElanName,	
			pElan->ElanName, 
			pElan->ElanNameSize);
		if (pElan->LanType == LANE_LANTYPE_TR)
		{
			NdisMoveMemory(
				&pElanInfo->MacAddress, 
				&pElan->MacAddressTr, 
				sizeof(MAC_ADDRESS));
		}
		else
		{
			NdisMoveMemory(
				&pElanInfo->MacAddress, 
				&pElan->MacAddressEth, 
				sizeof(MAC_ADDRESS));
		}
		pElanInfo->ControlTimeout		= pElan->ControlTimeout;
		pElanInfo->MaxUnkFrameCount 	= pElan->MaxUnkFrameCount;
		pElanInfo->MaxUnkFrameTime		= pElan->MaxUnkFrameTime;
		pElanInfo->VccTimeout			= pElan->VccTimeout;
		pElanInfo->MaxRetryCount		= pElan->MaxRetryCount;
		pElanInfo->AgingTime			= pElan->AgingTime;
		pElanInfo->ForwardDelayTime 	= pElan->ForwardDelayTime;
		pElanInfo->TopologyChange 		= pElan->TopologyChange;
		pElanInfo->ArpResponseTime		= pElan->ArpResponseTime;
		pElanInfo->FlushTimeout			= pElan->FlushTimeout;
		pElanInfo->PathSwitchingDelay 	= pElan->PathSwitchingDelay;
		pElanInfo->LocalSegmentId		= pElan->LocalSegmentId;		
		pElanInfo->McastSendVcType		= pElan->McastSendVcType;	
		pElanInfo->McastSendVcAvgRate	= pElan->McastSendVcAvgRate; 
		pElanInfo->McastSendVcPeakRate	= pElan->McastSendVcPeakRate;
		pElanInfo->ConnComplTimer		= pElan->ConnComplTimer;
	
		RELEASE_ELAN_LOCK(pElan);

		*pBytesWritten = sizeof(ATMLANE_ELANINFO);

	} while (FALSE);

	if (pElan != NULL)
	{
		ACQUIRE_ELAN_LOCK(pElan);
		rc = AtmLaneDereferenceElan(pElan, "ioctl: getelaninfo");

		if (rc != 0)
		{
			RELEASE_ELAN_LOCK(pElan);
		}
	}

	if (pAdapter != NULL)
	{
		ACQUIRE_ADAPTER_LOCK(pAdapter);
		rc = AtmLaneDereferenceAdapter(pAdapter, "ioctl: getelaninfo");
		
		if (rc != 0)
		{
			RELEASE_ADAPTER_LOCK(pAdapter);
		}
	}

	TRACEOUT(IoctlGetElanInfo);
	
	return (Status);
}


NTSTATUS
AtmLaneIoctlGetElanArpTable(
	IN	PUCHAR				pBuffer,
	IN 	UINT				InputBufferLength,
	IN	UINT				OutputBufferLength,
	OUT	UINT_PTR *			pBytesWritten
)
/*++

Routine Description:

	Return the ARP table for the specified ELAN.

Arguments:

	pBuffer				- Space for input/output
	InputBufferLength	- Length of input parameters
	OutputBufferLength	- Space available for output
	pBytesWritten		- Where we return the amount we actually used up

Return Value:
	Status code

--*/
{
	PATMLANE_ADAPTER		pAdapter;
	PATMLANE_ELAN			pElan;
	PUNICODE_STRING			pAdapterNameIn;
	PUNICODE_STRING			pElanNameIn;
	PATMLANE_ARPTABLE		pArpTable;
	PATMLANE_ARPENTRY		pArpEntry;
	UINT					Remaining;
	PATMLANE_MAC_ENTRY		pMacEntry;
	NTSTATUS				Status;
	UINT					i;
	ULONG					rc;

	TRACEIN(IoctlGetElanArpTable);

	// init

	*pBytesWritten = 0;
	Status = STATUS_SUCCESS;
	pAdapter = NULL;
	pElan = NULL;

	do
	{
		// check if adapter string passed in

		if (InputBufferLength < sizeof(UNICODE_STRING))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		// sanity check the unicode string fields.
		if (((PUNICODE_STRING)pBuffer)->MaximumLength < ((PUNICODE_STRING)pBuffer)->Length)
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		// check if elan string passed in

		if (InputBufferLength < (((sizeof(UNICODE_STRING) * 2) + 
								((PUNICODE_STRING)pBuffer)->MaximumLength)))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}	

		// check if minimum output space

		if (OutputBufferLength < sizeof(ATMLANE_ARPTABLE))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		// setup ptrs to input names

		pAdapterNameIn = (PUNICODE_STRING)pBuffer;
		pElanNameIn = (PUNICODE_STRING)(pBuffer + sizeof(UNICODE_STRING) + 
						pAdapterNameIn->MaximumLength);

		// find adapter struct

		pAdapter = AtmLaneIoctlNameToAdapter(pAdapterNameIn);

		if (pAdapter == NULL_PATMLANE_ADAPTER)
		{
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		// find elan struct

		pElan = AtmLaneIoctlNameToElan(pAdapter, pElanNameIn);

		if (pElan == NULL_PATMLANE_ELAN)
		{
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		//	setup to return empty list

		pArpTable = (PATMLANE_ARPTABLE)pBuffer;
		pArpTable->ArpEntriesAvailable = pElan->NumMacEntries;
		pArpTable->ArpEntriesReturned = 0;
		*pBytesWritten = sizeof(ATMLANE_ARPTABLE);
		Remaining = OutputBufferLength - sizeof(ATMLANE_ARPTABLE);
	
		pArpEntry = (PATMLANE_ARPENTRY)(pBuffer + sizeof(ATMLANE_ARPTABLE));
	
		ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan);

		//	loop thru array of lists
	
		for (i = 0; i < ATMLANE_MAC_TABLE_SIZE; i++)
		{
			pMacEntry = pElan->pMacTable[i];

			while (pMacEntry != NULL_PATMLANE_MAC_ENTRY)
			{

				//	check if enough space remaining

				if (Remaining < sizeof(ATMLANE_ARPENTRY))
				{
					Status = STATUS_BUFFER_OVERFLOW;
					break;
				}

				// 	output the entry

				NdisZeroMemory(pArpEntry, sizeof(ATMLANE_ARPENTRY));

				NdisMoveMemory(
					pArpEntry->MacAddress, 
					&pMacEntry->MacAddress, 
					sizeof(MAC_ADDRESS));

				if (pMacEntry->pAtmEntry != NULL_PATMLANE_ATM_ENTRY)
				{
					NdisMoveMemory(
						pArpEntry->AtmAddress,
						pMacEntry->pAtmEntry->AtmAddress.Address,
						ATM_ADDRESS_LENGTH);
				}

				//	update space used and space remaining

				*pBytesWritten += sizeof(ATMLANE_ARPENTRY);
				Remaining -= sizeof(ATMLANE_ARPENTRY);

				// 	increment in and out pointers
				
				pArpEntry++;
				pMacEntry = pMacEntry->pNextEntry;

				// 	add one to EntriesReturned
				
				pArpTable->ArpEntriesReturned++;
				
			}
		}
			
		RELEASE_ELAN_MAC_TABLE_LOCK(pElan);

	} while (FALSE);

	if (pElan != NULL)
	{
		ACQUIRE_ELAN_LOCK(pElan);
		rc = AtmLaneDereferenceElan(pElan, "ioctl: getelanarp");

		if (rc != 0)
		{
			RELEASE_ELAN_LOCK(pElan);
		}
	}

	if (pAdapter != NULL)
	{
		ACQUIRE_ADAPTER_LOCK(pAdapter);
		rc = AtmLaneDereferenceAdapter(pAdapter, "ioctl: getelanarp");
		
		if (rc != 0)
		{
			RELEASE_ADAPTER_LOCK(pAdapter);
		}
	}

	TRACEOUT(IoctlGetElanArpTable);

	return (Status);
}


NTSTATUS
AtmLaneIoctlGetElanConnectTable(
	IN	PUCHAR				pBuffer,
	IN 	UINT				InputBufferLength,
	IN	UINT				OutputBufferLength,
	OUT	UINT_PTR *			pBytesWritten
)
/*++

Routine Description:

	Return the Connection table for the specified ELAN.

Arguments:

	pBuffer				- Space for input/output
	InputBufferLength	- Length of input parameters
	OutputBufferLength	- Space available for output
	pBytesWritten		- Where we return the amount we actually used up

Return Value:
	Status code

--*/
{
	PATMLANE_ADAPTER		pAdapter;
	PATMLANE_ELAN			pElan;
	PUNICODE_STRING			pAdapterNameIn;
	PUNICODE_STRING			pElanNameIn;
	PATMLANE_CONNECTTABLE	pConnTable;
	PATMLANE_CONNECTENTRY	pConnEntry;
	UINT					Remaining;
	PATMLANE_ATM_ENTRY		pAtmEntry;
	NTSTATUS				Status;
	ULONG					rc;

	TRACEIN(IoctlGetElanConnectTable);

	// init

	*pBytesWritten = 0;
	Status = STATUS_SUCCESS;
	pAdapter = NULL;
	pElan = NULL;

	do
	{
		// check if adapter string passed in

		if (InputBufferLength < sizeof(UNICODE_STRING))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		// check if elan string passed in

		if (InputBufferLength < (((sizeof(UNICODE_STRING) * 2) + 
								((PUNICODE_STRING)pBuffer)->MaximumLength)))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}	

		//  sanity check

		if (((PUNICODE_STRING)pBuffer)->MaximumLength < ((PUNICODE_STRING)pBuffer)->Length)
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		// check if minimum output space

		if (OutputBufferLength < sizeof(ATMLANE_CONNECTTABLE))
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		// setup ptrs to input names

		pAdapterNameIn = (PUNICODE_STRING)pBuffer;
		pElanNameIn = (PUNICODE_STRING)(pBuffer + sizeof(UNICODE_STRING) + 
						pAdapterNameIn->MaximumLength);

		// How much of the input buffer do we have left?
		InputBufferLength -= (sizeof(UNICODE_STRING) + pAdapterNameIn->MaximumLength);

		// validate the ELAN name buffer
		if (pElanNameIn->MaximumLength < pElanNameIn->Length)
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		if (InputBufferLength < sizeof(UNICODE_STRING) + pElanNameIn->MaximumLength)
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}

		// find adapter struct

		pAdapter = AtmLaneIoctlNameToAdapter(pAdapterNameIn);

		if (pAdapter == NULL_PATMLANE_ADAPTER)
		{
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		// find elan struct

		pElan = AtmLaneIoctlNameToElan(pAdapter, pElanNameIn);

		if (pElan == NULL_PATMLANE_ELAN)
		{
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		//	setup to return empty list

		pConnTable = (PATMLANE_CONNECTTABLE)pBuffer;
		pConnTable->ConnectEntriesAvailable = pElan->NumAtmEntries;
		pConnTable->ConnectEntriesReturned = 0;
		*pBytesWritten = sizeof(ATMLANE_CONNECTTABLE);
		Remaining = OutputBufferLength - sizeof(ATMLANE_CONNECTTABLE);
	
		pConnEntry = 
			(PATMLANE_CONNECTENTRY)(pBuffer + sizeof(ATMLANE_CONNECTTABLE));
	
		ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

		//	loop thru the list
		
		pAtmEntry = pElan->pAtmEntryList;

		while (pAtmEntry != NULL_PATMLANE_ATM_ENTRY)
		{

			//	check if enough space for another entry
	
			if (Remaining < sizeof(ATMLANE_CONNECTENTRY))
			{
				Status = STATUS_BUFFER_OVERFLOW;
				break;
			}

			//	fill in entry
		
			NdisMoveMemory(
				pConnEntry->AtmAddress, 
				&pAtmEntry->AtmAddress.Address,
				ATM_ADDRESS_LENGTH
				);
			pConnEntry->Type = pAtmEntry->Type;
			pConnEntry->Vc = (pAtmEntry->pVcList!=NULL_PATMLANE_VC);
			pConnEntry->VcIncoming = (pAtmEntry->pVcIncoming!=NULL_PATMLANE_VC);

			// 	update space used and space remaining

			*pBytesWritten += sizeof(ATMLANE_CONNECTENTRY);
			Remaining -= sizeof(ATMLANE_CONNECTENTRY);
			
			//	increment in and out pointers

			pConnEntry++;
			pAtmEntry = pAtmEntry->pNext;

			// 	add one to EntriesReturned

			pConnTable->ConnectEntriesReturned++;
		}

		RELEASE_ELAN_ATM_LIST_LOCK(pElan);

	} while (FALSE);

	if (pElan != NULL)
	{
		ACQUIRE_ELAN_LOCK(pElan);
		rc = AtmLaneDereferenceElan(pElan, "ioctl: getelanconntab");

		if (rc != 0)
		{
			RELEASE_ELAN_LOCK(pElan);
		}
	}

	if (pAdapter != NULL)
	{
		ACQUIRE_ADAPTER_LOCK(pAdapter);
		rc = AtmLaneDereferenceAdapter(pAdapter, "ioctl: getelanconntab");
		
		if (rc != 0)
		{
			RELEASE_ADAPTER_LOCK(pAdapter);
		}
	}

	TRACEOUT(IoctlGetElanConnectTable);

	return (Status);
}


NTSTATUS
AtmLaneIoctlRequest(
	IN	PIRP					pIrp
)
/*++

Routine Description:

	Starting point for all IOCTL Requests.

Arguments:

	pIrp			: Pointer to the IRP
	pHandled		: If request handled TRUE otherwise FALSE

Return Value:

	Status of the request

--*/
{
	NTSTATUS            Status = STATUS_SUCCESS;
	PUCHAR				pBuf;
	UINT				BufLen;
	UINT				OutBufLen;
	UNICODE_STRING		IfName;
    PIO_STACK_LOCATION 	pIrpSp;

	TRACEIN(IoctlRequest);
	
	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

	pBuf = pIrp->AssociatedIrp.SystemBuffer;
	BufLen = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
	OutBufLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

	switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode)
	{
		case ATMLANE_IOCTL_GET_INFO_VERSION:
			DBGP((3, "IoctlRequest: Get Info Version\n"));

			Status = AtmLaneIoctlGetInfoVersion(
						pBuf,
						BufLen,
						OutBufLen,
						&pIrp->IoStatus.Information
						);
			break;
	
		case ATMLANE_IOCTL_ENUM_ADAPTERS:

			DBGP((3, "IoctlRequest: Enum Adapters\n"));
		
			Status = AtmLaneIoctlEnumerateAdapters(
						pBuf,
						BufLen,
						OutBufLen,
						&pIrp->IoStatus.Information
						);
			break;
			
		case ATMLANE_IOCTL_ENUM_ELANS:

			DBGP((3, "IoctlRequest: Enum ELANs\n"));
		
			Status = AtmLaneIoctlEnumerateElans(
						pBuf,
						BufLen,
						OutBufLen,
						&pIrp->IoStatus.Information
						);
			break;
		
		case ATMLANE_IOCTL_GET_ELAN_INFO:

			DBGP((3, "IoctlRequest: Get ELAN Info\n"));
		
			Status = AtmLaneIoctlGetElanInfo(
						pBuf,
						BufLen,
						OutBufLen,
						&pIrp->IoStatus.Information
						);
			break;
		
		case ATMLANE_IOCTL_GET_ELAN_ARP_TABLE:

			DBGP((3, "IoctlRequest: Getl ELAN ARP table\n"));
		
			Status = AtmLaneIoctlGetElanArpTable(
						pBuf,
						BufLen,
						OutBufLen,
						&pIrp->IoStatus.Information
						);
			break;
		
		case ATMLANE_IOCTL_GET_ELAN_CONNECT_TABLE:

			DBGP((3, "IoctlRequest: Get ELAN Connection table\n"));
		
			Status = AtmLaneIoctlGetElanConnectTable(
						pBuf,
						BufLen,
						OutBufLen,
						&pIrp->IoStatus.Information
						);
			break;
		
		default:
		
			DBGP((0, "IoctlRequest: Unknown control code %x\n", 
				pIrpSp->Parameters.DeviceIoControl.IoControlCode));
			break;
	}
	
	TRACEOUT(IoctlRequest);

	return (Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\lane10.h ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	lane10.h

Abstract:

	Definitions from ATM Forum LANE 1.0 Specification.

Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:

--*/

#ifndef	__ATMLANE_LANE10_H
#define __ATMLANE_LANE10_H


//
//	Minimum packet sizes including 2 byte LANE header
//
#define LANE_MIN_ETHPACKET			62
#define LANE_MIN_TRPACKET			16

//
//	Maximum bytes for ethernet/802.3 header and token ring header
//	including the 2 byte LANE header.  See section 4.1 of the LE spec
//  for the derivation.
//
#define LANE_ETH_HEADERSIZE			16
#define LANE_TR_HEADERSIZE			46
#define LANE_MAX_HEADERSIZE			46
#define LANE_HEADERSIZE				2

//
//	Type of LAN
//
#define LANE_LANTYPE_UNSPEC			0x00
#define LANE_LANTYPE_ETH			0x01
#define LANE_LANTYPE_TR				0x02

//
//	Maximum Frame Size Codes
//
#define LANE_MAXFRAMESIZE_CODE_UNSPEC	0x00
#define LANE_MAXFRAMESIZE_CODE_1516		0x01
#define LANE_MAXFRAMESIZE_CODE_4544		0x02
#define LANE_MAXFRAMESIZE_CODE_9234		0x03
#define LANE_MAXFRAMESIZE_CODE_18190	0x04

//
//	Maximum Size of an ELAN Name
//
#define LANE_ELANNAME_SIZE_MAX		32


#include <pshpack1.h>

//
//	Mac Address as LANE defines them in 
//	control packets.
//
typedef struct _LANE_MAC_ADDRESS
{
	USHORT			Type;
	UCHAR			Byte[6];
}
	LANE_MAC_ADDRESS;

typedef LANE_MAC_ADDRESS UNALIGNED 	*PLANE_MAC_ADDRESS;

//
//	LANE Mac Address types.
//	With USHORTS nicely preswapped for little-endian.
//
#define LANE_MACADDRTYPE_NOTPRESENT		0x0000	// no address here
#define LANE_MACADDRTYPE_MACADDR		0x0100	// this is a mac addr
#define LANE_MACADDRTYPE_ROUTEDESCR		0x0200	// this is a route descriptor

//
//	LAN Emulation Control Frame
//
typedef struct _LANE_CONTROL_FRAME
{
	USHORT				Marker;
	UCHAR				Protocol;
	UCHAR				Version;
	USHORT				OpCode;
	USHORT				Status;
	ULONG				Tid;
	USHORT				LecId;
	USHORT				Flags;
	LANE_MAC_ADDRESS	SourceMacAddress;
	LANE_MAC_ADDRESS	TargetMacAddress;
	UCHAR				SourceAtmAddr[20];
	UCHAR				LanType;
	UCHAR				MaxFrameSize;
	UCHAR				NumTlvs;
	UCHAR				ElanNameSize;
	UCHAR				TargetAtmAddr[20];
	UCHAR				ElanName[LANE_ELANNAME_SIZE_MAX];
}
	LANE_CONTROL_FRAME;

typedef LANE_CONTROL_FRAME UNALIGNED	*PLANE_CONTROL_FRAME;


//
//	LAN Emulation Ready Frame (really just a short control frame)
//
typedef struct _LANE_READY_FRAME
{
	USHORT				Marker;
	UCHAR				Protocol;
	UCHAR				Version;
	USHORT				OpCode;
}
	LANE_READY_FRAME;
	
typedef LANE_READY_FRAME UNALIGNED	*PLANE_READY_FRAME;


//
//	TLV (type/length/value)
//
typedef struct _LANE_TLV
{
	ULONG				Type;
	UCHAR				Length;
	UCHAR				Value[1];
}
	LANE_TLV;

typedef LANE_TLV UNALIGNED	*PLANE_TLV;

#include <poppack.h>

//
//	LANE Status codes
//	With USHORTS nicely preswapped for little-endian.
//
#define	LANE_STATUS_SUCCESS			0x0000	// Success
#define	LANE_STATUS_VERSNOSUPP		0x0100	// Version not supported
#define	LANE_STATUS_REQPARMINVAL	0x0200	// Invalid request parameters
#define	LANE_STATUS_DUPLANDEST		0x0400	// Duplicate LAN destination
#define	LANE_STATUS_DUPATMADDR		0x0500	// Duplicate ATM address
#define	LANE_STATUS_INSUFFRES		0x0600	// Insufficient resources
#define	LANE_STATUS_NOACCESS		0x0700	// Access denied
#define	LANE_STATUS_REQIDINVAL		0x0800	// Invalid requester ID
#define	LANE_STATUS_LANDESTINVAL	0x0900	// Invalid LAN destination
#define	LANE_STATUS_ATMADDRINVAL	0x0A00	// Invalid ATM address
#define	LANE_STATUS_NOCONF			0x1400	// No configuration
#define	LANE_STATUS_CONFERROR		0x1500	// Configuration error
#define	LANE_STATUS_INSUFFINFO		0x1600	// Insufficient information

//
//	LANE Operation Codes.
//	With USHORTS nicely preswapped for little-endian.
//
#define LANE_CONFIGURE_REQUEST		0x0100
#define LANE_CONFIGURE_RESPONSE		0x0101
#define LANE_JOIN_REQUEST			0x0200
#define LANE_JOIN_RESPONSE			0x0201
#define LANE_READY_QUERY			0x0300
#define LANE_READY_IND				0x0301
#define LANE_REGISTER_REQUEST		0x0400
#define LANE_REGISTER_RESPONSE		0x0401
#define LANE_UNREGISTER_REQUEST		0x0500
#define LANE_UNREGISTER_RESPONSE	0x0501
#define LANE_ARP_REQUEST			0x0600
#define LANE_ARP_RESPONSE			0x0601
#define LANE_FLUSH_REQUEST			0x0700
#define LANE_FLUSH_RESPONSE			0x0701
#define LANE_NARP_REQUEST			0x0800
#define LANE_TOPOLOGY_REQUEST		0x0900

//
//	Control Frame Marker, Protocol, and Version.
//	With USHORTS nicely preswapped for little-endian.
//
#define	LANE_CONTROL_MARKER			0x00FF
#define LANE_PROTOCOL				0x01
#define LANE_VERSION				0x01

//
//	Type codes for TLVs in Configure Response
//	With USHORTS nicely preswapped for little-endian.
//
#define LANE_CFG_CONTROL_TIMEOUT	0x013EA000
#define LANE_CFG_UNK_FRAME_COUNT	0x023EA000
#define LANE_CFG_UNK_FRAME_TIME		0x033EA000
#define LANE_CFG_VCC_TIMEOUT		0x043EA000
#define LANE_CFG_MAX_RETRY_COUNT	0x053EA000
#define LANE_CFG_AGING_TIME			0x063EA000
#define LANE_CFG_FWD_DELAY_TIME		0x073EA000
#define LANE_CFG_ARP_RESP_TIME		0x083EA000
#define LANE_CFG_FLUSH_TIMEOUT		0x093EA000
#define LANE_CFG_PATH_SWITCH_DELAY	0x0A3EA000
#define LANE_CFG_LOCAL_SEGMENT_ID	0x0B3EA000
#define LANE_CFG_MCAST_VCC_TYPE		0x0C3EA000
#define LANE_CFG_MCAST_VCC_AVG		0x0D3EA000
#define LANE_CFG_MCAST_VCC_PEAK		0x0E3EA000
#define LANE_CFG_CONN_COMPL_TIMER	0x0F3EA000

//
//	Definitions for Control Frame Flags field
//
#define LANE_CONTROL_FLAGS_REMOTE_ADDRESS		0x0001
#define LANE_CONTROL_FLAGS_TOPOLOGY_CHANGE		0x0100
#define LANE_CONTROL_FLAGS_PROXY				0x0800


//
//	Default/min/max for ELAN run-time configuration parameters
//	Units are seconds if time related parameter.
//
#define LANE_C7_MIN					10		// Control Time-out
#define LANE_C7_DEF					10
#define LANE_C7_MAX					300

#define LANE_C10_MIN				1		// Maximum Unknown Framount Count
#define LANE_C10_DEF				1
#define LANE_C10_MAX				100		// non-standard but reasonable!

#define LANE_C11_MIN				1		// Maximum Unknown Frame Time
#define LANE_C11_DEF				1
#define LANE_C11_MAX				60

#define LANE_C12_MIN				1
#define LANE_C12_DEF				(20*60)	// VCC Time-out Period
// no max defined

#define LANE_C13_MIN				0		// Maximum Retry Count
#define LANE_C13_DEF				1
#define LANE_C13_MAX				2

#define LANE_C17_MIN				10		// ARP Aging Time
#define LANE_C17_DEF				300		
#define LANE_C17_MAX				300

#define LANE_C18_MIN				4		// Forward Delay Time
#define LANE_C18_DEF				15
#define LANE_C18_MAX				30

#define LANE_C20_MIN				1		// Expected LE_ARP Response Time
#define LANE_C20_DEF				1
#define LANE_C20_MAX				30

#define LANE_C21_MIN				1		// Flush Time-out
#define LANE_C21_DEF				4
#define LANE_C21_MAX				4

#define LANE_C22_MIN				1		// Path Switching Delay
#define LANE_C22_DEF				6
#define LANE_C22_MAX				8

#define LANE_C28_MIN				1		// Expected LE_ARP Response Time
#define LANE_C28_DEF				4
#define LANE_C28_MAX				10


#endif // __ATMLANE_LANE10_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\event.h ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	atmlane.h

Abstract:

Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:

--*/

#ifndef _ATMLANE_EVENT_H_
#define _ATMLANE_EVENT_H_

#define TL_MSENDPKTIN			TL_BUILD_EVENT_ID(1,2)
#define TL_MSENDPKTBEGIN		TL_BUILD_EVENT_ID(2,2)
#define TL_MSENDPKTEND			TL_BUILD_EVENT_ID(3,3)
#define TL_MSENDPKTOUT			TL_BUILD_EVENT_ID(4,1)

#define TL_COSENDCMPLTIN		TL_BUILD_EVENT_ID(5,2)
#define TL_COSENDCMPLTOUT		TL_BUILD_EVENT_ID(6,1)

#define TL_MSENDCOMPL			TL_BUILD_EVENT_ID(7,1)

#define TL_WRAPSEND				TL_BUILD_EVENT_ID(8,4)

#define TL_UNWRAPSEND			TL_BUILD_EVENT_ID(9,4)

#define TL_WRAPRECV				TL_BUILD_EVENT_ID(10,4)

#define TL_UNWRAPRECV			TL_BUILD_EVENT_ID(11,4)

#define TL_COSENDPACKET			TL_BUILD_EVENT_ID(12,1)

#define TL_CORECVPACKET			TL_BUILD_EVENT_ID(13,2)
#define TL_CORETNPACKET			TL_BUILD_EVENT_ID(14,1)

#define TL_MINDPACKET			TL_BUILD_EVENT_ID(15,1)
#define TL_MRETNPACKET			TL_BUILD_EVENT_ID(16,1)

#define TL_NDISPACKET			TL_BUILD_EVENT_ID(17,8)


#endif // _ATMLANE_EVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\elanpkt.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	elanpkt.c

Abstract:

Revision History:

Notes:

--*/

#include <precomp.h>
#pragma	hdrstop


VOID
AtmLaneSendConfigureRequest(
	IN PATMLANE_ELAN					pElan
)
/*++

Routine Description:

	Send an LE_CONFIGURE_REQUEST for the given ELAN to the LECS.
	It is assumed that caller holds a lock on the ELAN structure
	and it will be released here.

Arguments:

	pElan					- Pointer to ATMLANE elan structure

Return Value:

	None

--*/
{
	PATMLANE_ATM_ENTRY				pAtmEntry;
	PATMLANE_VC						pVc;	
	PNDIS_PACKET					pNdisPacket;
	PNDIS_BUFFER					pNdisBuffer;
	PUCHAR							pPkt;		
	LANE_CONTROL_FRAME UNALIGNED *	pCf;	
	ULONG							ulTemp;
	NDIS_STATUS						Status;
	ULONG							rc;

	DBGP((3, "SendConfigureRequest: Elan %x\n", pElan));

	//
	//	Initialize
	//
	pNdisPacket = (PNDIS_PACKET)NULL;
	pNdisBuffer = (PNDIS_BUFFER)NULL;
	Status = NDIS_STATUS_SUCCESS;
	pVc = NULL_PATMLANE_VC;

	do
	{
		ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

		pAtmEntry = pElan->pLecsAtmEntry;

		if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
		{
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		pVc = pAtmEntry->pVcList;
		if (pVc == NULL_PATMLANE_VC)
		{
			RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			break;
		}

		//
		//	Reference the VC to keep it around
		//
		ACQUIRE_VC_LOCK_DPC(pVc);
		AtmLaneReferenceVc(pVc, "temp");
		RELEASE_VC_LOCK_DPC(pVc);
		
		RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		RELEASE_ELAN_ATM_LIST_LOCK(pElan);
		
		//
		//	Allocate the Ndis packet header.
		//
		pNdisPacket = AtmLaneAllocProtoPacket(pElan);
		if ((PNDIS_PACKET)NULL == pNdisPacket)
		{
			DBGP((0, "SendConfigureRequest: allocate packet failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Allocate the protocol buffer
		//
		pNdisBuffer = AtmLaneAllocateProtoBuffer(
									pElan,
									pElan->ProtocolBufSize,
									&(pPkt)
									);
		if ((PNDIS_BUFFER)NULL == pNdisBuffer)
		{
			DBGP((0, "SendConfigureRequest: allocate proto buffer failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
			
		//
		//	Fill in the packet with LE_CONFIGURE_REQUEST
		//
		NdisZeroMemory(pPkt, pElan->ProtocolBufSize);

		pCf = (PLANE_CONTROL_FRAME)pPkt;

		pCf->Marker 	= LANE_CONTROL_MARKER;
		pCf->Protocol 	= LANE_PROTOCOL;
		pCf->Version	= LANE_VERSION;
		pCf->OpCode 	= LANE_CONFIGURE_REQUEST;
		ulTemp			= NdisInterlockedIncrement(&pElan->TransactionId);
		pCf->Tid 		= SWAPULONG(ulTemp);

		pCf->SourceMacAddress.Type = LANE_MACADDRTYPE_MACADDR;

		if (pElan->LanType == LANE_LANTYPE_TR) 
		{
			NdisMoveMemory(
				&pCf->SourceMacAddress.Byte, 
				&pElan->MacAddressTr, 
				sizeof(MAC_ADDRESS)
				);
		}
		else
		{
			NdisMoveMemory(
				&pCf->SourceMacAddress.Byte, 
				&pElan->MacAddressEth, 
				sizeof(MAC_ADDRESS)
				);
		}
		
		NdisMoveMemory(
			&pCf->SourceAtmAddr, 
			&pElan->AtmAddress.Address, 
			ATM_ADDRESS_LENGTH
			);

		DBGP((4, "%d: sending Config Req, Elan %x has LanType %d, CfgLanType %d\n",
				pElan->ElanNumber,
				pElan,
				pElan->LanType,
				pElan->CfgLanType));

		pCf->LanType = LANE_LANTYPE_UNSPEC;
		pCf->MaxFrameSize = (UCHAR) pElan->CfgMaxFrameSizeCode;

		pCf->ElanNameSize = pElan->ElanNameSize;
		NdisMoveMemory(
			&pCf->ElanName,
			pElan->ElanName,
			LANE_ELANNAME_SIZE_MAX
			);

		//
		//	Link the ndis buffer to the ndis packet
		//
		NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);
					
		//
		//	Reacquire VC lock and if VC still connected send packet
		//
		ACQUIRE_VC_LOCK(pVc);
		if (IS_FLAG_SET(
					pVc->Flags,
					VC_CALL_STATE_MASK,
					VC_CALL_STATE_ACTIVE))
		{
			AtmLaneSendPacketOnVc(pVc, pNdisPacket, FALSE);
			//
			//	VC lock released in above
			//
		}
		else
		{
			Status = NDIS_STATUS_FAILURE;
			RELEASE_VC_LOCK(pVc);
		}
	}
	while (FALSE);

	//
	//	Remove temp VC reference
	//
	if (pVc != NULL_PATMLANE_VC)
	{
		ACQUIRE_VC_LOCK(pVc);
		rc = AtmLaneDereferenceVc(pVc, "temp");
		if (rc > 0)
		{
			RELEASE_VC_LOCK(pVc);
		}
		//
		//	else VC is gone
		//
	}

	//
	//	Cleanup if failure
	//
	if (Status != NDIS_STATUS_SUCCESS)
	{
		if (pNdisPacket != (PNDIS_PACKET)NULL)
		{
			AtmLaneFreeProtoPacket(pElan, pNdisPacket);
		}
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreeProtoBuffer(pElan, pNdisBuffer);
		}
	}

	TRACEOUT(SendConfigureRequest);
	return;
}


VOID
AtmLaneSendJoinRequest(
	IN PATMLANE_ELAN					pElan
)
/*++

Routine Description:

	Send an LE_JOIN_REQUEST for the given ELAN to the LES.
	It is assumed that caller holds a lock on the ELAN structure
	and it will be released here.
	
Arguments:

	pElan					- Pointer to ATMLANE elan structure

Return Value:

	None

--*/
{
	PATMLANE_ATM_ENTRY				pAtmEntry;
	PATMLANE_VC						pVc;
	PNDIS_PACKET					pNdisPacket;
	PNDIS_BUFFER					pNdisBuffer;
	PUCHAR							pPkt;
	LANE_CONTROL_FRAME UNALIGNED *	pCf;	
	ULONG							ulTemp;
	NDIS_STATUS						Status;
	ULONG							rc;
	
	TRACEIN(SendJoinRequest);

	DBGP((3, "SendJoinRequest: Elan %x\n", pElan));

	//
	//	Initialize
	//
	pNdisPacket = (PNDIS_PACKET)NULL;
	pNdisBuffer = (PNDIS_BUFFER)NULL;
	Status = NDIS_STATUS_SUCCESS;
	pVc = NULL_PATMLANE_VC;

	do
	{
		ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

		pAtmEntry = pElan->pLesAtmEntry;

		if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
		{
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		pVc = pAtmEntry->pVcList;
		if (pVc == NULL_PATMLANE_VC)
		{
			RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			break;
		}

		//
		//	Reference the VC to keep it around
		//
		ACQUIRE_VC_LOCK_DPC(pVc);
		AtmLaneReferenceVc(pVc, "temp");
		RELEASE_VC_LOCK_DPC(pVc);
		
		RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		RELEASE_ELAN_ATM_LIST_LOCK(pElan);
		
		//
		//	Allocate the Ndis packet header.
		//
		pNdisPacket = AtmLaneAllocProtoPacket(pElan);
		if ((PNDIS_PACKET)NULL == pNdisPacket)
		{
			DBGP((0, "SendJoinRequest: allocate packet failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Allocate the protocol buffer
		//
		pNdisBuffer = AtmLaneAllocateProtoBuffer(
									pElan,
									pElan->ProtocolBufSize,
									&(pPkt)
									);
		if ((PNDIS_BUFFER)NULL == pNdisBuffer)
		{
			DBGP((0, "SendJoinRequest: allocate proto buffer failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
			
		//
		//	Fill in the packet with LE_JOIN_REQUEST
		//
		NdisZeroMemory(pPkt, pElan->ProtocolBufSize);

		pCf = (PLANE_CONTROL_FRAME)pPkt;

		pCf->Marker 	= LANE_CONTROL_MARKER;
		pCf->Protocol 	= LANE_PROTOCOL;
		pCf->Version	= LANE_VERSION;
		pCf->OpCode 	= LANE_JOIN_REQUEST;
		ulTemp			= NdisInterlockedIncrement(&pElan->TransactionId);
		pCf->Tid 		= SWAPULONG(ulTemp);

		pCf->SourceMacAddress.Type = LANE_MACADDRTYPE_MACADDR;
		
		if (pElan->LanType == LANE_LANTYPE_TR) 
		{
			NdisMoveMemory(
				&pCf->SourceMacAddress.Byte, 
				&pElan->MacAddressTr, 
				sizeof(MAC_ADDRESS)
				);
		}
		else
		{
			DBGP((0, "%d Send Join with MAC addr: %s\n",
					pElan->ElanNumber,
					MacAddrToString(&pElan->MacAddressEth)));

			NdisMoveMemory(
				&pCf->SourceMacAddress.Byte, 
				&pElan->MacAddressEth, 
				sizeof(MAC_ADDRESS)
				);
		}

		NdisMoveMemory(
			&pCf->SourceAtmAddr, 
			&pElan->AtmAddress.Address, 
			ATM_ADDRESS_LENGTH
			);

		pCf->LanType = pElan->LanType;
		pCf->MaxFrameSize = pElan->MaxFrameSizeCode;

		pCf->ElanNameSize = pElan->ElanNameSize;
		NdisMoveMemory(
			&pCf->ElanName,
			pElan->ElanName,
			LANE_ELANNAME_SIZE_MAX
			);

		//
		//	Link the ndis buffer to the ndis packet
		//
		NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);
					
		//
		//	Reacquire VC lock and if VC still connected send packet
		//
		ACQUIRE_VC_LOCK(pVc);
		if (IS_FLAG_SET(
					pVc->Flags,
					VC_CALL_STATE_MASK,
					VC_CALL_STATE_ACTIVE))
		{
			AtmLaneSendPacketOnVc(pVc, pNdisPacket, FALSE);
			//
			//	VC lock released in above
			//
		}
		else
		{
			Status = NDIS_STATUS_FAILURE;
			RELEASE_VC_LOCK(pVc);
		}
	}
	while (FALSE);
	
	//
	//	Remove temp VC reference
	//
	if (pVc != NULL_PATMLANE_VC)
	{
		ACQUIRE_VC_LOCK(pVc);
		rc = AtmLaneDereferenceVc(pVc, "temp");
		if (rc > 0)
		{
			RELEASE_VC_LOCK(pVc);
		}
		//
		//	else VC is gone
		//
	}

	//
	//	Cleanup if failure
	//
	if (Status != NDIS_STATUS_SUCCESS)
	{
		if (pNdisPacket != (PNDIS_PACKET)NULL)
		{
			AtmLaneFreeProtoPacket(pElan, pNdisPacket);
		}
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreeProtoBuffer(pElan, pNdisBuffer);
		}
	}

	TRACEOUT(SendJoinRequest);
	return;
}


VOID
AtmLaneSendArpRequest(
	IN PATMLANE_ELAN					pElan,
	IN PATMLANE_MAC_ENTRY				pMacEntry	LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Send an LE_ARP_REQUEST for a particular Mac Entry to the LES.
	
Arguments:

	pElan					- Pointer to ATMLANE elan structure

	pMacEntry				- Pointer to ATMLANE Mac Entry for which
							  to send the LE_ARP_REQUEST.

Return Value:

	None

--*/
{
	PATMLANE_ATM_ENTRY				pAtmEntry;
	PATMLANE_VC						pVc;
	PNDIS_PACKET					pNdisPacket;
	PNDIS_BUFFER					pNdisBuffer;
	PUCHAR							pPkt;
	LANE_CONTROL_FRAME UNALIGNED *	pCf;
	ULONG							ulTemp;
	NDIS_STATUS						Status;
	ULONG							rc;
	BOOLEAN							MacEntryLockReleased;
	
	TRACEIN(SendArpRequest);

	DBGP((3, "SendArpRequest: Elan %x MacEntry %x\n", 
		pElan, pMacEntry));

	//
	//	Initialize
	//
	pNdisPacket = (PNDIS_PACKET)NULL;
	pNdisBuffer = (PNDIS_BUFFER)NULL;
	Status = NDIS_STATUS_SUCCESS;
	pVc = NULL_PATMLANE_VC;
	MacEntryLockReleased = FALSE;

	do
	{
		ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

		pAtmEntry = pElan->pLesAtmEntry;

		if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
		{
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		pVc = pAtmEntry->pVcList;
		if (pVc == NULL_PATMLANE_VC)
		{
			RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			break;
		}

		//
		//	Reference the VC to keep it around
		//
		ACQUIRE_VC_LOCK_DPC(pVc);
		AtmLaneReferenceVc(pVc, "temp");
		RELEASE_VC_LOCK_DPC(pVc);
		
		RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		RELEASE_ELAN_ATM_LIST_LOCK(pElan);

		//
		//	Allocate the Ndis packet header.
		//
		pNdisPacket = AtmLaneAllocProtoPacket(pElan);
		if ((PNDIS_PACKET)NULL == pNdisPacket)
		{
			DBGP((0, "SendArpRequest: allocate packet failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Allocate the protocol buffer
		//
		pNdisBuffer = AtmLaneAllocateProtoBuffer(
									pElan,
									pElan->ProtocolBufSize,
									&(pPkt)
									);
		if ((PNDIS_BUFFER)NULL == pNdisBuffer)
		{
			DBGP((0, "SendArpRequest: allocate proto buffer failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
			
		//
		//	Fill in the packet with LE_ARP_REQUEST
		//
		NdisZeroMemory(pPkt, pElan->ProtocolBufSize);

		pCf = (PLANE_CONTROL_FRAME)pPkt;

		pCf->Marker 	= LANE_CONTROL_MARKER;
		pCf->Protocol 	= LANE_PROTOCOL;
		pCf->Version	= LANE_VERSION;
		pCf->OpCode 	= LANE_ARP_REQUEST;
		ulTemp			= NdisInterlockedIncrement(&pElan->TransactionId);
		pCf->Tid 		= SWAPULONG(ulTemp);
		pCf->LecId		= pElan->LecId;		// already swapped
		
		//
		//	Leave SourceMacAddress zero (not present).
		// 	TargetMacAddress is what we are looking for!
		//
		pCf->TargetMacAddress.Type = (USHORT) pMacEntry->MacAddrType;
		NdisMoveMemory(
			&pCf->TargetMacAddress.Byte, 
			&pMacEntry->MacAddress, 
			sizeof(MAC_ADDRESS)
			);

		//
		//	SourceAtmAddr is the Elan's
		//
		NdisMoveMemory(
			&pCf->SourceAtmAddr, 
			&pElan->AtmAddress.Address, 
			ATM_ADDRESS_LENGTH
			);

		//
		//	Store swapped Tid in MacEntry for later matching!
		//
		pMacEntry->ArpTid = SWAPULONG(ulTemp);
		RELEASE_MAC_ENTRY_LOCK(pMacEntry);
		MacEntryLockReleased = TRUE;
		
		//
		//	Link the ndis buffer to the ndis packet
		//
		NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);
					
		//
		//	Reacquire VC lock and if VC still connected send packet
		//
		ACQUIRE_VC_LOCK(pVc);
		if (IS_FLAG_SET(
					pVc->Flags,
					VC_CALL_STATE_MASK,
					VC_CALL_STATE_ACTIVE))
		{
			DBGP((2, "SendArpRequest: %s Sending ARP Request: Atm Entry %x pVc %x\n", 
					MacAddrToString(&pMacEntry->MacAddress), pAtmEntry, pVc));
			AtmLaneSendPacketOnVc(pVc, pNdisPacket, FALSE);
			//
			//	VC lock released in above
			//
		}
		else
		{
			Status = NDIS_STATUS_FAILURE;
			RELEASE_VC_LOCK(pVc);
		}
	}
	while (FALSE);
	
	if (!MacEntryLockReleased)
	{
		RELEASE_MAC_ENTRY_LOCK(pMacEntry);
	}

	//
	//	Remove temp VC reference
	//
	if (pVc != NULL_PATMLANE_VC)
	{
		ACQUIRE_VC_LOCK(pVc);
		rc = AtmLaneDereferenceVc(pVc, "temp");
		if (rc > 0)
		{
			RELEASE_VC_LOCK(pVc);
		}
		//
		//	else VC is gone
		//
	}

	//
	//	Cleanup if failure
	//
	if (Status != NDIS_STATUS_SUCCESS)
	{
		if (pNdisPacket != (PNDIS_PACKET)NULL)
		{
			AtmLaneFreeProtoPacket(pElan, pNdisPacket);
		}
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreeProtoBuffer(pElan, pNdisBuffer);
		}
	}
	
	TRACEOUT(SendArpRequest);
	return;
}

VOID
AtmLaneSendReadyQuery(
	IN PATMLANE_ELAN				pElan,
	IN PATMLANE_VC					pVc		LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Sends a READY_QUERY frame on the VC.
	It is assumed that caller holds a lock on the VC structure
	and it will be released here.
	
Arguments:

	pElan					- Pointer to ATMLANE elan structure
	pVc						- Pointer to the ATMLANE VC structure
							  on which to send the frame.
Return Value:

	None

--*/
{
	PNDIS_PACKET			pNdisPacket;
	PNDIS_BUFFER			pNdisBuffer;
	ULONG					TotalLength;
	ULONG					BufferLength;
	PLANE_READY_FRAME		pQueryRf;
	NDIS_STATUS				Status;

	TRACEIN(SendReadyQuery);

	//
	//	Initialize
	//
	pNdisPacket = (PNDIS_PACKET)NULL;
	pNdisBuffer = (PNDIS_BUFFER)NULL;
	Status = NDIS_STATUS_SUCCESS;

	do
	{
		//
		//	Allocate the Ndis packet header.
		//
		pNdisPacket = AtmLaneAllocProtoPacket(pElan);
		if ((PNDIS_PACKET)NULL == pNdisPacket)
		{
			DBGP((0, "SendReadyQuery: allocate packet failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Allocate the protocol buffer
		//
		pNdisBuffer = AtmLaneAllocateProtoBuffer(
								pElan,
								sizeof(LANE_READY_FRAME),
								&((PUCHAR)(pQueryRf))
								);
		if ((PNDIS_BUFFER)NULL == pNdisBuffer)
		{
			DBGP((0, "SendReadyQuery: allocate proto buffer failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Fill in Indication
		//
		pQueryRf->Marker 		= LANE_CONTROL_MARKER;
		pQueryRf->Protocol		= LANE_PROTOCOL;
		pQueryRf->Version		= LANE_VERSION;
		pQueryRf->OpCode		= LANE_READY_QUERY;

		//
		//	Link the ndis buffer to the ndis packet
		//
		NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);
					
		//
		//	Send it 
		//
		DBGP((2, "SendReadyQuery: pVc %x sending READY QUERY\n", pVc));
		AtmLaneSendPacketOnVc(pVc, pNdisPacket, FALSE);
		//
		//	VC lock released in above
		//
		break;
	}
	while (FALSE);

	//
	//	Cleanup if failure
	//
	if (Status != NDIS_STATUS_SUCCESS)
	{
		RELEASE_VC_LOCK(pVc);
		if (pNdisPacket != (PNDIS_PACKET)NULL)
		{
			AtmLaneFreeProtoPacket(pElan, pNdisPacket);
		}
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreeProtoBuffer(pElan, pNdisBuffer);
		}
	}

	TRACEOUT(SendReadyQuery);

	return;
}


VOID
AtmLaneSendReadyIndication(
	IN PATMLANE_ELAN				pElan,
	IN PATMLANE_VC					pVc		LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Sends a ready indication frame on the VC.
	It is assumed that caller holds a lock on the VC structure
	and it will be released here.
	
Arguments:

	pElan					- Pointer to ATMLANE elan structure
	pVc						- Pointer to the ATMLANE VC structure
							  on which to send the frame.
							  
Return Value:

	None

--*/
{
	ULONG					TotalLength;
	ULONG					BufferLength;
	PLANE_READY_FRAME		pIndRf;
	PNDIS_PACKET			pNdisPacket;
	PNDIS_BUFFER			pNdisBuffer;
	NDIS_STATUS				Status;

	TRACEIN(SendReadyIndication);

	//
	//	Initialize
	//
	pNdisPacket = (PNDIS_PACKET)NULL;
	pNdisBuffer = (PNDIS_BUFFER)NULL;
	Status = NDIS_STATUS_SUCCESS;

	do
	{
		//
		//	Allocate the Ndis packet header.
		//
		pNdisPacket = AtmLaneAllocProtoPacket(pElan);
		if ((PNDIS_PACKET)NULL == pNdisPacket)
		{
			DBGP((0, "SendReadyIndication: allocate packet failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Allocate the protocol buffer
		//
		pNdisBuffer = AtmLaneAllocateProtoBuffer(
								pElan,
								sizeof(LANE_READY_FRAME),
								&((PUCHAR)(pIndRf))
								);
		if ((PNDIS_BUFFER)NULL == pNdisBuffer)
		{
			DBGP((0, "SendReadyIndication: allocate proto buffer failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Fill in Indication
		//
		pIndRf->Marker 		= LANE_CONTROL_MARKER;
		pIndRf->Protocol	= LANE_PROTOCOL;
		pIndRf->Version		= LANE_VERSION;
		pIndRf->OpCode		= LANE_READY_IND;

		//
		//	Link the ndis buffer to the ndis packet
		//
		NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);
					
		//
		//	Send it 
		//
		DBGP((2, "SendReadyIndication: pVc %x sending READY INDICATION\n", pVc));
		AtmLaneSendPacketOnVc(pVc, pNdisPacket, FALSE);
		//
		//	VC lock released in above
		//
		break;
	}
	while (FALSE);

	//
	//	Cleanup if failure
	//
	if (Status != NDIS_STATUS_SUCCESS)
	{
		RELEASE_VC_LOCK(pVc);
		if (pNdisPacket != (PNDIS_PACKET)NULL)
		{
			AtmLaneFreeProtoPacket(pElan, pNdisPacket);
		}
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreeProtoBuffer(pElan, pNdisBuffer);
		}
	}

	TRACEOUT(SendReadyIndication);

	return;
}


VOID
AtmLaneSendFlushRequest(
	IN PATMLANE_ELAN				pElan,
	IN PATMLANE_MAC_ENTRY			pMacEntry	LOCKIN NOLOCKOUT,
	IN PATMLANE_ATM_ENTRY			pAtmEntry
)
/*++

Routine Description:

	Sends a flush request to the BUS for a particular MAC Entry
	using the destination ATM address in the specified ATM Entry.
	
Arguments:

	pElan					- Pointer to ATMLANE Elan structure
	pMacEntry				- Pointer to ATMLANE Mac entry structure
	pAtmEntry				- Pointer to ATMLANE Atm entry structure
							  
Return Value:

	None

--*/
{
	PATMLANE_ATM_ENTRY		pBusAtmEntry;
	PATMLANE_VC				pVc;
	ULONG					TotalLength;
	ULONG					BufferLength;
	ULONG					ulTemp;
	PLANE_CONTROL_FRAME		pCf;
	PNDIS_PACKET			pNdisPacket;
	PNDIS_BUFFER			pNdisBuffer;
	NDIS_STATUS				Status;
	ULONG					rc;
	BOOLEAN					MacEntryLockReleased;

	TRACEIN(SendFlushRequest);

	//
	//	Initialize
	//
	pNdisPacket = (PNDIS_PACKET)NULL;
	pNdisBuffer = (PNDIS_BUFFER)NULL;
	Status = NDIS_STATUS_SUCCESS;
	pVc = NULL_PATMLANE_VC;
	MacEntryLockReleased = FALSE;

	do
	{
		ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

		pBusAtmEntry = pElan->pBusAtmEntry;

		if (pBusAtmEntry == NULL_PATMLANE_ATM_ENTRY)
		{
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		ACQUIRE_ATM_ENTRY_LOCK_DPC(pBusAtmEntry);
		pVc = pBusAtmEntry->pVcList;
		if (pVc == NULL_PATMLANE_VC)
		{
			RELEASE_ATM_ENTRY_LOCK_DPC(pBusAtmEntry);
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			break;
		}

		//
		//	Reference the VC to keep it around
		//
		ACQUIRE_VC_LOCK_DPC(pVc);
		AtmLaneReferenceVc(pVc, "temp");
		RELEASE_VC_LOCK_DPC(pVc);
		
		RELEASE_ATM_ENTRY_LOCK_DPC(pBusAtmEntry);
		RELEASE_ELAN_ATM_LIST_LOCK(pElan);
		
		//
		//	Allocate the Ndis packet header.
		//
		pNdisPacket = AtmLaneAllocProtoPacket(pElan);
		if ((PNDIS_PACKET)NULL == pNdisPacket)
		{
			DBGP((0, "SendFlushRequest: allocate packet failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Allocate the protocol buffer
		//
		pNdisBuffer = AtmLaneAllocateProtoBuffer(
								pElan,
								sizeof(LANE_CONTROL_FRAME),
								&((PUCHAR)(pCf))
								);
		if ((PNDIS_BUFFER)NULL == pNdisBuffer)
		{
			DBGP((0, "SendFlushRequest: allocate proto buffer failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Fill in Flush Request
		//

		NdisZeroMemory((PUCHAR)pCf, sizeof(LANE_CONTROL_FRAME));
		
		pCf->Marker 	= LANE_CONTROL_MARKER;
		pCf->Protocol	= LANE_PROTOCOL;
		pCf->Version	= LANE_VERSION;
		pCf->OpCode		= LANE_FLUSH_REQUEST;

		ulTemp			= NdisInterlockedIncrement(&pElan->TransactionId);
		pCf->Tid 		= SWAPULONG(ulTemp);

		pCf->LecId		= pElan->LecId;		// already swapped

		NdisMoveMemory(
			&pCf->SourceAtmAddr, 
			&pElan->AtmAddress.Address, 
			ATM_ADDRESS_LENGTH
			);

		NdisMoveMemory(
			&pCf->TargetAtmAddr, 
			&pAtmEntry->AtmAddress.Address, 
			ATM_ADDRESS_LENGTH
			);

		//
		//	Store swapped Tid in MacEntry for later matching!
		//
		pMacEntry->FlushTid = SWAPULONG(ulTemp);
		RELEASE_MAC_ENTRY_LOCK(pMacEntry);
		MacEntryLockReleased = TRUE;

		//
		//	Link the ndis buffer to the ndis packet
		//
		NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);
					
		//
		//	Reacquire VC lock and if VC still connected send packet
		//
		ACQUIRE_VC_LOCK(pVc);
		if (IS_FLAG_SET(
					pVc->Flags,
					VC_CALL_STATE_MASK,
					VC_CALL_STATE_ACTIVE))
		{
			DBGP((2, "SendFlushRequest: sending FLUSH REQUEST for MacEntry %x\n", pMacEntry));
			AtmLaneSendPacketOnVc(pVc, pNdisPacket, FALSE);
			//
			//	VC lock released in above
			//
		}
		else
		{
			Status = NDIS_STATUS_FAILURE;
			RELEASE_VC_LOCK(pVc);
		}

 		break;
	}
	while (FALSE);

	if (!MacEntryLockReleased)
	{
		RELEASE_MAC_ENTRY_LOCK(pMacEntry);
	}

	//
	//	Remove temp VC reference
	//
	if (pVc != NULL_PATMLANE_VC)
	{
		ACQUIRE_VC_LOCK(pVc);
		rc = AtmLaneDereferenceVc(pVc, "temp");
		if (rc > 0)
		{
			RELEASE_VC_LOCK(pVc);
		}
		//
		//	else VC is gone
		//
	}

	//
	//	Cleanup if failure
	//
	if (Status != NDIS_STATUS_SUCCESS)
	{
		if (pNdisPacket != (PNDIS_PACKET)NULL)
		{
			AtmLaneFreeProtoPacket(pElan, pNdisPacket);
		}
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreeProtoBuffer(pElan, pNdisBuffer);
		}
	}

	TRACEOUT(SendFlushRequest);

	return;
}


VOID
AtmLaneConfigureResponseHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	Handles incoming packets from the Configuration Direct VC.
	
	
Arguments:

	pElan					- Pointer to ATMLANE Elan structure

	pVc						- Pointer to ATMLANE Vc structure

	pNdisPacket				- Pointer to the Ndis Packet

Return Value:

	None

--*/
{
	PNDIS_BUFFER			pNdisBuffer;
	ULONG					TotalLength;
	ULONG					BufferLength;
	PLANE_CONTROL_FRAME		pCf;
	ULONG					NumTlvs;
	ULONG UNALIGNED *		pType;
	PUCHAR					pLength;
	USHORT UNALIGNED *		pUShort;
	ULONG UNALIGNED *		pULong;
	NDIS_STATUS				EventCode;
	USHORT					NumStrings;
	PWCHAR					StringList[2];
	BOOLEAN					FreeString[2];
	
	
	TRACEIN(ConfigureResponseHandler);

	do
	{
		//
		//	Get initial buffer and total length of packet
		//		
		NdisGetFirstBufferFromPacket(
				pNdisPacket, 
				&pNdisBuffer, 
				(PVOID *)&pCf,
				&BufferLength,
				&TotalLength);

		//
		//	Packet must be at least the size of a control frame.
		//	Could be larger with optional TLVs.
		//
		if (TotalLength < sizeof(LANE_CONTROL_FRAME))
		{
			DBGP((0,
				"ConfigureResponseHandler: Received runt control frame (%d)\n",
				TotalLength));
			break;
		}

		//
		//	If buffer is not at least the size of a control frame
		//	we currently will not deal with it.
		//
		if (BufferLength < sizeof(LANE_CONTROL_FRAME))
		{
			DBGP((0, "ConfigureResponseHandler: Control frame is fragmented\n"));
			break;
		}

		//
		//	Verify that this is really a configure reponse
		//
		if (pCf->Marker != LANE_CONTROL_MARKER 		||
			pCf->Protocol != LANE_PROTOCOL 			||
			pCf->Version != LANE_VERSION			||
			pCf->OpCode != LANE_CONFIGURE_RESPONSE)
		{
			DBGP((0, "ConfigureResponseHandler: Not a configure response\n"));
			//DbgPrintHexDump(0, (PUCHAR)pCf, BufferLength);
			break;
		}
		
		//
		//	Check for successful configure status
		//
		if (pCf->Status != LANE_STATUS_SUCCESS)
		{
			//
			//	Failure
			//		
			DBGP((0,
				"ConfigureResponseHandler: Unsuccessful Status 0x%x (%d)\n", 
				SWAPUSHORT(pCf->Status), SWAPUSHORT(pCf->Status)));


			//
			//	Setup to log event
			//
			StringList[0] = NULL;
			FreeString[0] = FALSE;
			StringList[1] = NULL;
			FreeString[1] = FALSE;
			
			switch (pCf->Status)
			{
				case LANE_STATUS_VERSNOSUPP:
					EventCode = EVENT_ATMLANE_CFGREQ_FAIL_VERSNOSUPP;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
		
				case LANE_STATUS_REQPARMINVAL:
					EventCode = EVENT_ATMLANE_CFGREQ_FAIL_REQPARMINVAL;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
				
				case LANE_STATUS_INSUFFRES:
					EventCode = EVENT_ATMLANE_CFGREQ_FAIL_INSUFFRES;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
				
				case LANE_STATUS_NOACCESS:
					EventCode = EVENT_ATMLANE_CFGREQ_FAIL_NOACCESS;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
				
				case LANE_STATUS_REQIDINVAL:
					EventCode = EVENT_ATMLANE_CFGREQ_FAIL_REQIDINVAL;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
				
				case LANE_STATUS_LANDESTINVAL:
					EventCode = EVENT_ATMLANE_CFGREQ_FAIL_LANDESTINVAL;
					StringList[0] = pElan->CfgElanName.Buffer;
					if (pElan->LanType == LANE_LANTYPE_ETH)
					{
						StringList[1] = AtmLaneMacAddrToString(&pElan->MacAddressEth);
						FreeString[1] = TRUE;
					}
					else
					{
						StringList[1] = AtmLaneMacAddrToString(&pElan->MacAddressTr);
						FreeString[1] = TRUE;
					}
					NumStrings = 2;
					break;
				
				case LANE_STATUS_ATMADDRINVAL:
					EventCode = EVENT_ATMLANE_CFGREQ_FAIL_ATMADDRINVAL;
					StringList[0] = pElan->CfgElanName.Buffer;
					StringList[1] = AtmLaneAtmAddrToString(&pElan->AtmAddress);
					FreeString[1] = TRUE;
					NumStrings = 2;
					break;
				
				case LANE_STATUS_NOCONF:
					EventCode = EVENT_ATMLANE_CFGREQ_FAIL_NOCONF;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
				
				case LANE_STATUS_CONFERROR:
					EventCode = EVENT_ATMLANE_CFGREQ_FAIL_CONFERROR;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
				
				case LANE_STATUS_INSUFFINFO:
				default:
					EventCode = EVENT_ATMLANE_CFGREQ_FAIL_INSUFFINFO;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
			}						

			//
			//	If not repeated event on this ELAN write the event to log
			//
			if (pElan->LastEventCode != EventCode)
			{
				pElan->LastEventCode = EventCode;
				(VOID) NdisWriteEventLogEntry(
						pAtmLaneGlobalInfo->pDriverObject,
						EventCode, 0, NumStrings, StringList, 0, NULL);
			}

			//
			//	Free any strings allocated
			//
			if (FreeString[0] && StringList[0] != NULL)
			{
				FREE_MEM(StringList[0]);
			}
			if (FreeString[1] && StringList[1] != NULL)
			{
				FREE_MEM(StringList[1]);
			}
			
			//
			//	Notify event handler of failure
			//
			ACQUIRE_ELAN_LOCK(pElan);
			
			AtmLaneQueueElanEvent(pElan, ELAN_EVENT_CONFIGURE_RESPONSE, NDIS_STATUS_FAILURE);

			RELEASE_ELAN_LOCK(pElan);
			
			break;
		}

		//
		//	Successful Configure Response
		//
		//
		//	Extract the required Elan parameters
		//
		ACQUIRE_ELAN_LOCK(pElan);
		
		pElan->LanType = pCf->LanType;
		DBGP((1, "%d LanType = %x\n", pElan->ElanNumber, pElan->LanType));
		if (pElan->LanType == LANE_LANTYPE_UNSPEC)
		{
			DBGP((1, "Defaulting to LanType 1 (Ethernet/802.3)\n"));
			pElan->LanType = LANE_LANTYPE_ETH;
		}
		pElan->MaxFrameSizeCode = pCf->MaxFrameSize;
		DBGP((1, "%d MaxFrameSizeCode = %x\n", pElan->ElanNumber, pElan->MaxFrameSizeCode));
		if (pElan->MaxFrameSizeCode == LANE_MAXFRAMESIZE_CODE_UNSPEC)
		{
			DBGP((1, "Defaulting to MaxFrameSizeCode 1 (1516)\n"));
			pElan->MaxFrameSizeCode = LANE_MAXFRAMESIZE_CODE_1516;
		}
		switch (pElan->MaxFrameSizeCode)
		{
			case LANE_MAXFRAMESIZE_CODE_18190:
				pElan->MaxFrameSize = 18190;
				break;
			case LANE_MAXFRAMESIZE_CODE_9234:
				pElan->MaxFrameSize = 9234;
				break;
			case LANE_MAXFRAMESIZE_CODE_4544:
				pElan->MaxFrameSize = 4544;
				break;
			case LANE_MAXFRAMESIZE_CODE_1516:
			case LANE_MAXFRAMESIZE_CODE_UNSPEC:
			default:
				pElan->MaxFrameSize = 1516;
				break;
		}				

		if (pElan->LanType == LANE_LANTYPE_ETH)
		{
			pElan->MinFrameSize = LANE_MIN_ETHPACKET;
		}
		else
		{
			pElan->MinFrameSize = LANE_MIN_TRPACKET;
		}

		NdisZeroMemory(
				pElan->ElanName,
				LANE_ELANNAME_SIZE_MAX);
		NdisMoveMemory(
				pElan->ElanName,
				pCf->ElanName,
				pCf->ElanNameSize);
		pElan->ElanNameSize = pCf->ElanNameSize;
		
		pElan->LesAddress.AddressType = ATM_NSAP;
		pElan->LesAddress.NumberOfDigits = ATM_ADDRESS_LENGTH;
		NdisMoveMemory(
				pElan->LesAddress.Address,
				&pCf->TargetAtmAddr,
				ATM_ADDRESS_LENGTH);
		DBGP((1, "%d LES ATMAddr: %s\n",
			pElan->ElanNumber,
			AtmAddrToString(pElan->LesAddress.Address)));
	
		//
		//	Check for TLVs
		//
		if (pCf->NumTlvs > 0)
		{
			DBGP((2, "ConfigureReponseHandler: NumTlvs is %d\n", pCf->NumTlvs));

			NumTlvs = pCf->NumTlvs;
			
			pType = (ULONG UNALIGNED *)
				(((PUCHAR)pCf) + sizeof(LANE_CONTROL_FRAME));
			
			while (NumTlvs--)
			{
				pLength = (PUCHAR)pType + sizeof(*pType);
				pUShort = (USHORT UNALIGNED *)
					(((PUCHAR)pLength) + sizeof(*pLength));
				pULong = (ULONG UNALIGNED *)
					(((PUCHAR)pLength) + sizeof(*pLength));

				switch (*pType)
				{
					case LANE_CFG_CONTROL_TIMEOUT:			// C7
						pElan->ControlTimeout = SWAPUSHORT(*pUShort);
						if (pElan->ControlTimeout < LANE_C7_MIN || 
							pElan->ControlTimeout > LANE_C7_MAX)
							pElan->ControlTimeout = LANE_C7_DEF;
						DBGP((1, "%d Control Time-out %d\n",
							pElan->ElanNumber,
							pElan->ControlTimeout));
						break;
					case LANE_CFG_UNK_FRAME_COUNT:			// C10
						pElan->MaxUnkFrameCount = SWAPUSHORT(*pUShort);
						if (pElan->MaxUnkFrameCount < LANE_C10_MIN || 
							pElan->MaxUnkFrameCount > LANE_C10_MAX)
							pElan->MaxUnkFrameCount = LANE_C10_DEF;
						DBGP((1, "%d Maximum Unknown Frame Count %d\n",
							pElan->ElanNumber,
							pElan->MaxUnkFrameCount));
						break;
					case LANE_CFG_UNK_FRAME_TIME:			// C11
						pElan->MaxUnkFrameTime = SWAPUSHORT(*pUShort);
						if (pElan->MaxUnkFrameTime < LANE_C11_MIN || 
							pElan->MaxUnkFrameTime > LANE_C11_MAX)
							pElan->MaxUnkFrameTime = LANE_C11_DEF;
						DBGP((1, "%d Maximum Unknown Frame Time %d\n", 
							pElan->ElanNumber,
							pElan->MaxUnkFrameTime));
						break;
					case LANE_CFG_VCC_TIMEOUT:				// C12
						pElan->VccTimeout = SWAPULONG(*pULong);
						if (pElan->VccTimeout < LANE_C12_MIN)
							pElan->VccTimeout = LANE_C12_DEF;
						DBGP((1, "%d VCC Timeout Period %d\n", 
							pElan->ElanNumber,
							pElan->VccTimeout));
						break;
					case LANE_CFG_MAX_RETRY_COUNT:			// C13
						pElan->MaxRetryCount = SWAPUSHORT(*pUShort);
						if (/* pElan->MaxRetryCount < LANE_C13_MIN || */
							pElan->MaxRetryCount > LANE_C13_MAX)
							pElan->MaxRetryCount = LANE_C13_DEF;
						DBGP((1, "%d Maximum Retry Count %d\n", 
							pElan->ElanNumber,
							pElan->MaxRetryCount));
						break;
					case LANE_CFG_AGING_TIME:				// C17
						pElan->AgingTime = SWAPULONG(*pULong);
						if (pElan->AgingTime < LANE_C17_MIN || 
							pElan->AgingTime > LANE_C17_MAX)
							pElan->AgingTime = LANE_C17_DEF;
						DBGP((1, "%d Aging Time %d\n",
							pElan->ElanNumber,
							pElan->AgingTime));
						break;
					case LANE_CFG_FWD_DELAY_TIME:			// C18
						pElan->ForwardDelayTime = SWAPUSHORT(*pUShort);
						if (pElan->ForwardDelayTime < LANE_C18_MIN || 
							pElan->ForwardDelayTime > LANE_C18_MAX)
							pElan->ForwardDelayTime = LANE_C18_DEF;
						DBGP((1, "%d Forward Delay Time %d\n", 
							pElan->ElanNumber,
							pElan->ForwardDelayTime));
						break;
					case LANE_CFG_ARP_RESP_TIME:			// C20
						pElan->ArpResponseTime = SWAPUSHORT(*pUShort);
						if (pElan->ArpResponseTime < LANE_C20_MIN || 
							pElan->ArpResponseTime > LANE_C20_MAX)
							pElan->ArpResponseTime = LANE_C20_DEF;
						DBGP((1, "%d Arp Response Time %d\n", 
							pElan->ElanNumber,
							pElan->ArpResponseTime));
						break;
					case LANE_CFG_FLUSH_TIMEOUT:			// C21
						pElan->FlushTimeout = SWAPUSHORT(*pUShort);
						if (pElan->FlushTimeout < LANE_C21_MIN || 
							pElan->FlushTimeout > LANE_C21_MAX)
							pElan->FlushTimeout = LANE_C21_DEF;
						DBGP((1, "%d Flush Time-out %d\n", 
							pElan->ElanNumber,
							pElan->FlushTimeout));
						break;
					case LANE_CFG_PATH_SWITCH_DELAY:		// C22
						pElan->PathSwitchingDelay = SWAPUSHORT(*pUShort);
						if (pElan->PathSwitchingDelay < LANE_C22_MIN || 
							pElan->PathSwitchingDelay > LANE_C22_MAX)
							pElan->PathSwitchingDelay = LANE_C22_DEF;
						DBGP((1, "%d Path Switching Delay %d\n", 
							pElan->ElanNumber,
							pElan->PathSwitchingDelay));
						break;
					case LANE_CFG_LOCAL_SEGMENT_ID:			// C23
						pElan->LocalSegmentId = SWAPUSHORT(*pUShort);
						DBGP((1, "%d Local Segment ID %d\n",
							pElan->ElanNumber,
							pElan->LocalSegmentId));
						break;
					case LANE_CFG_MCAST_VCC_TYPE:			// C24
						pElan->McastSendVcType = SWAPUSHORT(*pUShort);
						DBGP((1, "%d Mcast Send VCC Type %d\n", 
							pElan->ElanNumber,
							pElan->McastSendVcType));
						break;
					case LANE_CFG_MCAST_VCC_AVG:			// C25
						pElan->McastSendVcAvgRate = SWAPULONG(*pULong);
						DBGP((1, "%d Mcast Send VCC AvgRate %d\n", 
							pElan->ElanNumber,
							pElan->McastSendVcAvgRate));
						break;
					case LANE_CFG_MCAST_VCC_PEAK:			// C26
						pElan->McastSendVcPeakRate = SWAPULONG(*pULong);
						DBGP((1, "%d Mcast Send VCC PeakRate %d\n", 
							pElan->ElanNumber,
							pElan->McastSendVcPeakRate));
						break;
					case LANE_CFG_CONN_COMPL_TIMER:			// C28
						pElan->ConnComplTimer = SWAPUSHORT(*pUShort);
						if (pElan->ConnComplTimer < LANE_C28_MIN || 
							pElan->ConnComplTimer > LANE_C28_MAX)
							pElan->ConnComplTimer = LANE_C28_DEF;
						DBGP((1, "%d Connection Completion Timer %d\n", 
							pElan->ElanNumber,
							pElan->ConnComplTimer));
						break;
				}

				pType = (ULONG UNALIGNED *)
					(((PUCHAR)pType) + sizeof(pType) + 
					sizeof(*pLength) + *pLength);

			} // while (NumTlvs--)

			//
			//	Recalc the bus rate limiter parameters 
			//			
			pElan->LimitTime = pElan->MaxUnkFrameTime * 1000;
			pElan->IncrTime  = pElan->LimitTime / pElan->MaxUnkFrameCount;
		}

		//
		//	Notify event handler of success
		//
		AtmLaneQueueElanEvent(pElan, ELAN_EVENT_CONFIGURE_RESPONSE, NDIS_STATUS_SUCCESS);

		RELEASE_ELAN_LOCK(pElan);

	}
	while (FALSE);

	TRACEOUT(ConfigureResponsehandler);
	return;
}


VOID
AtmLaneControlPacketHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	Handles incoming packets from the control VC(s) to/from the LES.
	
	
Arguments:

	pElan					- Pointer to ATMLANE Elan structure

	pVc						- Pointer to ATMLANE Vc structure

	pNdisPacket				- Pointer to the Ndis Packet

Return Value:

	None

--*/
{
	PNDIS_BUFFER			pNdisBuffer;
	ULONG					TotalLength;
	ULONG					BufferLength;
	PLANE_CONTROL_FRAME		pCf;
	NDIS_STATUS				Status;

	
	TRACEIN(ControlPacketHandler);

	do
	{
		//
		//	Get initial buffer and total length of packet
		//		
		NdisGetFirstBufferFromPacket(
				pNdisPacket, 
				&pNdisBuffer, 
				(PVOID *)&pCf,
				&BufferLength,
				&TotalLength);

		//
		//	Packet must be at least the size of a control frame.
		//
		if (TotalLength < sizeof(LANE_CONTROL_FRAME))
		{
			DBGP((0,
				"ConPacketHandler: Received runt control frame (%d)\n",
				TotalLength));
			break;
		}

		//
		//	If buffer is not at least the size of a control frame
		//	we currently will not deal with it.
		//
		if (BufferLength < sizeof(LANE_CONTROL_FRAME))
		{
			DBGP((0, "ConfigureResponseHandler: Control frame is fragmented\n"));
			break;
		}

		//
		//	Verify that this is really a control packet
		//
		if (pCf->Marker != LANE_CONTROL_MARKER 		||
			pCf->Protocol != LANE_PROTOCOL 			||
			pCf->Version != LANE_VERSION)
		{
			DBGP((0, "ControlPacketHandler: Not a control packet!\n"));
			//DbgPrintHexDump(0, (PUCHAR)pCf, BufferLength);
			break;
		}

		//
		//	Now handle by type of control packet
		//
		switch (pCf->OpCode)
		{
			case LANE_JOIN_RESPONSE:

				DBGP((2, "ControlPacketHandler: Join Response\n"));

				AtmLaneJoinResponseHandler(pElan, pCf);

				break;
			
			case LANE_ARP_RESPONSE:

				DBGP((2, "ControlPacketHandler: ARP Response\n"));

				AtmLaneArpResponseHandler(pElan, pCf);

				break;
				
			case LANE_ARP_REQUEST:

				DBGP((1, "ControlPacketHandler: ARP Request\n"));

				AtmLaneArpRequestHandler(pElan, pCf);

				break;
				
			case LANE_TOPOLOGY_REQUEST:

				DBGP((1, "ControlPacketHandler: TOPOLOGY Request\n"));

				AtmLaneTopologyRequestHandler(pElan, pCf);
				
				break;

			case LANE_NARP_REQUEST:

				DBGP((2, "ControlPacketHandler: NARP Request\n"));

				// ignore these

				break;

			case LANE_FLUSH_RESPONSE:
				DBGP((2, "ControlPacketHandler: FLUSH Response\n"));

				AtmLaneFlushResponseHandler(pElan, pCf);

				break;

			default:

				DBGP((0, "ControlPacketHandler: Unexpected OpCode %x!\n",
					pCf->OpCode));
				//DbgPrintHexDump(0, (PUCHAR)pCf, BufferLength);

				break;

		} // switch (pCf->OpCode)

		break;
	
	}
	while (FALSE);

	TRACEOUT(ControlPackethandler);
	return;
}

VOID
AtmLaneJoinResponseHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PLANE_CONTROL_FRAME 		pCf
)
/*++

Routine Description:

	Handles incoming Join Response packets from the LES.
		
Arguments:

	pElan					- Pointer to ATMLANE Elan structure

	pCf						- Pointer to LANE Control Frame

Return Value:

	None

--*/
{
	PWCHAR					StringList[2];
	BOOLEAN					FreeString[2];
	NDIS_STATUS				EventCode;
	USHORT					NumStrings;

	TRACEIN(JoinResponseHandler);
	
	ACQUIRE_ELAN_LOCK(pElan);

	if (ELAN_STATE_JOIN == pElan->State)
	{
		//
		//	Only handle join response in JOIN state!
		//	
		if (LANE_STATUS_SUCCESS == pCf->Status)
		{
			//
			//	Success.
			//
			//	Extract the info we need
			//
			pElan->LecId = pCf->LecId;		// leave in network byte order
			DBGP((2,
				"ControlPacketHandler: LECID %x\n",
				SWAPUSHORT(pElan->LecId)));
			AtmLaneQueueElanEvent(pElan, ELAN_EVENT_JOIN_RESPONSE, NDIS_STATUS_SUCCESS);
		}
		else
		{
			//
			//	Failure
			//		
			DBGP((0,
				"ControlPacketHandler: Unsuccessful Status (%d)\n",
				pCf->Status));

			//
			//	Setup to write error to event log
			//
			StringList[0] = NULL;
			FreeString[0] = FALSE;
			StringList[1] = NULL;
			FreeString[1] = FALSE;
			
			switch (pCf->Status)
			{
				case LANE_STATUS_VERSNOSUPP:
					EventCode = EVENT_ATMLANE_JOINREQ_FAIL_VERSNOSUPP;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
				
				case LANE_STATUS_DUPLANDEST:
					EventCode = EVENT_ATMLANE_JOINREQ_FAIL_DUPLANDEST;
					StringList[0] = pElan->CfgElanName.Buffer;
					if (pElan->LanType == LANE_LANTYPE_ETH)
					{
						StringList[1] = AtmLaneMacAddrToString(&pElan->MacAddressEth);
						FreeString[1] = TRUE;
					}
					else
					{
						StringList[1] = AtmLaneMacAddrToString(&pElan->MacAddressTr);
						FreeString[1] = TRUE;
					}
					NumStrings = 2;
					break;
					

				case LANE_STATUS_DUPATMADDR:
					EventCode = EVENT_ATMLANE_JOINREQ_FAIL_DUPATMADDR;
					StringList[0] = pElan->CfgElanName.Buffer;
					StringList[1] = AtmLaneAtmAddrToString(&pElan->AtmAddress);
					FreeString[1] = TRUE;
					NumStrings = 2;
					break;
				
				case LANE_STATUS_INSUFFRES:
					EventCode = EVENT_ATMLANE_JOINREQ_FAIL_INSUFFRES;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
				
				case LANE_STATUS_NOACCESS:
					EventCode = EVENT_ATMLANE_JOINREQ_FAIL_NOACCESS;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
				
				case LANE_STATUS_REQIDINVAL:
					EventCode = EVENT_ATMLANE_JOINREQ_FAIL_REQIDINVAL;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
				
				case LANE_STATUS_LANDESTINVAL:
					EventCode = EVENT_ATMLANE_JOINREQ_FAIL_LANDESTINVAL;
					StringList[0] = pElan->CfgElanName.Buffer;
					if (pElan->LanType == LANE_LANTYPE_ETH)
					{
						StringList[1] = AtmLaneMacAddrToString(&pElan->MacAddressEth);
						FreeString[1] = TRUE;
					}
					else
					{
						StringList[1] = AtmLaneMacAddrToString(&pElan->MacAddressTr);
						FreeString[1] = TRUE;
					}
					NumStrings = 2;
					break;
				
				case LANE_STATUS_ATMADDRINVAL:
					EventCode = EVENT_ATMLANE_JOINREQ_FAIL_ATMADDRINVAL;
					StringList[0] = pElan->CfgElanName.Buffer;
					StringList[1] = AtmLaneAtmAddrToString(&pElan->AtmAddress);
					FreeString[1] = TRUE;
					NumStrings = 2;
					break;
					
				case LANE_STATUS_REQPARMINVAL:
				default:
					EventCode = EVENT_ATMLANE_JOINREQ_FAIL_REQPARMINVAL;
					StringList[0] = pElan->CfgElanName.Buffer;
					NumStrings = 1;
					break;
			}

			//
			//	If not repeated event on this ELAN write the event to log
			//
			if (pElan->LastEventCode != EventCode)
			{
				pElan->LastEventCode = EventCode;
				(VOID) NdisWriteEventLogEntry(
						pAtmLaneGlobalInfo->pDriverObject,
						EventCode, 0, NumStrings, StringList, 0, NULL);
			}

			//
			//	Free any strings allocated
			//
			if (FreeString[0] && StringList[0] != NULL)
			{
				FREE_MEM(StringList[0]);
			}
			if (FreeString[1] && StringList[1] != NULL)
			{
				FREE_MEM(StringList[1]);
			}

				
			AtmLaneQueueElanEvent(pElan, ELAN_EVENT_JOIN_RESPONSE, NDIS_STATUS_FAILURE);
		}
	}
	else
	{
		//
		// else bad elan state - ignore packet
		//
		DBGP((0, 
			"ControlPacketHandler: Elan state wrong - Ignoring packet\n",
			pCf->Status));
			
	}
	RELEASE_ELAN_LOCK(pElan);

	TRACEOUT(JoinResponseHandler);
	return;
}

VOID
AtmLaneReadyQueryHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_VC					pVc,
	IN	PNDIS_PACKET				pQueryNdisPacket
)
/*++

Routine Description:

	Handles incoming READY_QUERY packets from peers.
		
Arguments:

	pElan					- Pointer to ATMLANE Elan structure

	pVc						- Pointer to ATMLANE VC for this packet

	pQueryNdisPacket		- Pointer to the Ndis Packet

Return Value:

	None

--*/
{
	PNDIS_BUFFER			pNdisBuffer;
	ULONG					TotalLength;
	ULONG					BufferLength;
	PLANE_READY_FRAME		pQueryRf;
	PLANE_READY_FRAME		pIndRf;
	PNDIS_PACKET			pIndNdisPacket;
	
	TRACEIN(ReadyQueryHandler);

	do
	{
		//
		//	Get initial buffer and total length of packet
		//		
		NdisGetFirstBufferFromPacket(
				pQueryNdisPacket, 
				&pNdisBuffer, 
				&pQueryRf,
				&BufferLength,
				&TotalLength);
				
		//
		//	Packet must be at least the size of a READY frame.
		//
		if (TotalLength < sizeof(LANE_READY_FRAME))
		{
			DBGP((0,
				"ReadyQueryHandler: Received runt ready frame (%d)\n",
				TotalLength));
			break;
		}

		//
		//	If buffer is not at least the size of a ready frame
		//	we currently will not deal with it.
		//
		if (BufferLength < sizeof(LANE_READY_FRAME))
		{
			DBGP((0, "ReadyQueryHandler: Control frame is fragmented\n"));
			break;
		}

		//
		//	Verify that this is really a ready query
		//
		if (pQueryRf->Marker != LANE_CONTROL_MARKER 		||
			pQueryRf->Protocol != LANE_PROTOCOL 			||
			pQueryRf->Version != LANE_VERSION			||
			pQueryRf->OpCode != LANE_READY_QUERY)
		{
			DBGP((0, "ReadyQueryHandler: Not a ready query\n"));
			//DbgPrintHexDump(0, (PUCHAR)pQueryRf, BufferLength);
			break;
		}

		//
		//	Send Ready Indication back on VC
		//
		ACQUIRE_VC_LOCK(pVc);
		AtmLaneSendReadyIndication(pElan, pVc);
		//
		//	VC lock released in above
		//

		break;
	}
	while (FALSE);

	TRACEOUT(ReadyQueryHandler);
	return;
}


VOID
AtmLaneFlushRequestHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_PACKET				pRequestNdisPacket
)
/*++

Routine Description:

	Handles incoming FLUSH_REQUEST packets from peers.
	
	
Arguments:

	pElan					- Pointer to ATMLANE Elan structure

	pRequestNdisPacket		- Pointer to the Ndis Packet

Return Value:

	None

--*/
{
	PATMLANE_ATM_ENTRY		pAtmEntry;
	PATMLANE_VC				pVc;
	PNDIS_BUFFER			pRequestNdisBuffer;
	PNDIS_PACKET			pResponseNdisPacket;
	PNDIS_BUFFER			pResponseNdisBuffer;
	ULONG					TotalLength;
	ULONG					BufferLength;
	PLANE_CONTROL_FRAME		pRequestCf;
	PLANE_CONTROL_FRAME		pResponseCf;
	NDIS_STATUS				Status;
	ULONG					rc;
	
	TRACEIN(FlushRequestHandler);

	//
	//	Initialize
	//
	pResponseNdisPacket = (PNDIS_PACKET)NULL;
	pResponseNdisBuffer = (PNDIS_BUFFER)NULL;
	Status = NDIS_STATUS_SUCCESS;
	pVc = NULL_PATMLANE_VC;

	do
	{
		ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

		pAtmEntry = pElan->pLesAtmEntry;

		if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
		{
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		pVc = pAtmEntry->pVcList;
		if (pVc == NULL_PATMLANE_VC)
		{
			RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			break;
		}

		//
		//	Reference the VC to keep it around
		//
		ACQUIRE_VC_LOCK_DPC(pVc);
		AtmLaneReferenceVc(pVc, "temp");
		RELEASE_VC_LOCK_DPC(pVc);
		
		RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		RELEASE_ELAN_ATM_LIST_LOCK(pElan);
	
		//
		//	Get initial buffer and total length of packet
		//		
		NdisGetFirstBufferFromPacket(
				pRequestNdisPacket, 
				&pRequestNdisBuffer, 
				(PVOID *)&pRequestCf,
				&BufferLength,
				&TotalLength);
				
		//
		//	Packet must be at least the size of a control frame.
		//
		if (TotalLength < sizeof(LANE_CONTROL_FRAME))
		{
			DBGP((0,
				"FlushRequestHandler: Received runt control frame (%d)\n",
				TotalLength));
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//	If buffer is not at least the size of a control frame
		//	we currently will not deal with it.
		//
		if (BufferLength < sizeof(LANE_CONTROL_FRAME))
		{
			DBGP((0, "FlushRequestHandler: Control frame is fragmented\n"));
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//	Verify that this is really a flush request
		//
		if (pRequestCf->Marker != LANE_CONTROL_MARKER 		||
			pRequestCf->Protocol != LANE_PROTOCOL 			||
			pRequestCf->Version != LANE_VERSION			||
			pRequestCf->OpCode != LANE_FLUSH_REQUEST)
		{
			DBGP((0, "FlushRequestHandler: Not a flush request\n"));
			//DbgPrintHexDump(0, (PUCHAR)pRequestCf, BufferLength);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//	See if it is really destined for us
		//
		if (!ATM_ADDR_EQUAL(pRequestCf->TargetAtmAddr, pElan->AtmAddress.Address))
		{
			DBGP((1, "FlushRequestHandler: bad target addr, discarding, Vc %x\n", pVc));
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//	Turn packet around and send it to the LES
		//
		do
		{
			//
			//	Allocate the Ndis packet header.
			//
			pResponseNdisPacket = AtmLaneAllocProtoPacket(pElan);
			if ((PNDIS_PACKET)NULL == pResponseNdisPacket)
			{
				DBGP((0, "FlushRequestHandler: allocate packet failed\n"));
				Status = NDIS_STATUS_RESOURCES;
				break;
			}

			//
			//	Allocate the protocol buffer
			//
			pResponseNdisBuffer = AtmLaneAllocateProtoBuffer(
									pElan,
									pElan->ProtocolBufSize,
									&((PUCHAR)(pResponseCf))
									);
			if ((PNDIS_BUFFER)NULL == pResponseNdisBuffer)
			{
				DBGP((0, "FlushRequestHandler: allocate proto buffer failed\n"));
				Status = NDIS_STATUS_RESOURCES;
				break;
			}

			//
			//	Copy in the request packet
			//
			NdisMoveMemory(
					pResponseCf, 
					pRequestCf, 
					sizeof(LANE_CONTROL_FRAME)
					);
			

			//
			//	Change to a response opcode
			//
			pResponseCf->OpCode = LANE_FLUSH_RESPONSE;

			//
			//	Link the ndis buffer to the ndis packet
			//
			NdisChainBufferAtFront(pResponseNdisPacket, pResponseNdisBuffer);
					
			//
			//	Reacquire VC lock and if VC still connected send packet
			//
			ACQUIRE_VC_LOCK(pVc);
			if (IS_FLAG_SET(
						pVc->Flags,
						VC_CALL_STATE_MASK,
						VC_CALL_STATE_ACTIVE))
			{
				DBGP((2, "FlushRequestHandler: Sent FLUSH RESPONSE\n"));
				AtmLaneSendPacketOnVc(pVc, pResponseNdisPacket, FALSE);
				//
				//	VC lock released in above
				//
			}
			else
			{
				Status = NDIS_STATUS_FAILURE;
				RELEASE_VC_LOCK(pVc);
			}

			break;
		}
		while (FALSE);

		break;
	}
	while (FALSE);
	
	//
	//	Remove temp VC reference
	//
	if (pVc != NULL_PATMLANE_VC)
	{
		ACQUIRE_VC_LOCK(pVc);
		rc = AtmLaneDereferenceVc(pVc, "temp");
		if (rc > 0)
		{
			RELEASE_VC_LOCK(pVc);
		}
		//
		//	else VC is gone
		//
	}

	//
	//	Cleanup if failure
	//
	if (Status != NDIS_STATUS_SUCCESS)
	{
		if (pResponseNdisPacket != (PNDIS_PACKET)NULL)
		{
			AtmLaneFreeProtoPacket(pElan, pResponseNdisPacket);
		}
		if (pResponseNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreeProtoBuffer(pElan, pResponseNdisBuffer);
		}
	}

	TRACEOUT(FlushRequestHandler);
	return;
}

VOID
AtmLaneArpRequestHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PLANE_CONTROL_FRAME 		pRequestCf
)
/*++

Routine Description:

	Handles incoming Arp Request packets from the LES.
		
Arguments:

	pRequestCf		- Pointer to ARP Request Frame

Return Value:

	None

--*/
{
	PATMLANE_ATM_ENTRY		pAtmEntry;
	PATMLANE_VC				pVc;
	PNDIS_PACKET			pResponseNdisPacket;
	PNDIS_BUFFER			pResponseNdisBuffer;
	ULONG					TotalLength;
	ULONG					BufferLength;
	PLANE_CONTROL_FRAME		pResponseCf;
	NDIS_STATUS				Status;
	ULONG					rc;
	PMAC_ADDRESS			pMacAddress;

	TRACEIN(ArpRequestHandler);

	//
	//	Initialize
	//
	pResponseNdisPacket = (PNDIS_PACKET)NULL;
	pResponseNdisBuffer = (PNDIS_BUFFER)NULL;
	Status = NDIS_STATUS_SUCCESS;
	pVc = NULL_PATMLANE_VC;
	pMacAddress = (PMAC_ADDRESS)pRequestCf->TargetMacAddress.Byte;

	do
	{
		DBGP((2, "%d Arp Request for MAC %s\n",
				pElan->ElanNumber, MacAddrToString(pMacAddress)));
	
		//
		// 	If not looking for our MAC address then done.
		//
		if (pElan->LanType == LANE_LANTYPE_TR) 
		{
			if (!MAC_ADDR_EQUAL(pMacAddress, &pElan->MacAddressTr))
			{
				break;
			}
		
		}
		else
		{
			if (!MAC_ADDR_EQUAL(pMacAddress, &pElan->MacAddressEth))
			{
				break;
			}
		}

		DBGP((1, "%d ARP REQUEST\n", pElan->ElanNumber));
			
		//
		//	Get the LES Vc
		//
		ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

		pAtmEntry = pElan->pLesAtmEntry;

		if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
		{
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			DBGP((0, "%d ARP REQUEST before we have an LES entry\n", pElan->ElanNumber));
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		pVc = pAtmEntry->pVcList;
		if (pVc == NULL_PATMLANE_VC)
		{
			RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			DBGP((0, "%d ARP REQUEST with no VC to LES\n", pElan->ElanNumber));
			break;
		}

		//
		//	Reference the VC to keep it around
		//
		ACQUIRE_VC_LOCK_DPC(pVc);
		AtmLaneReferenceVc(pVc, "temp");
		RELEASE_VC_LOCK_DPC(pVc);
		
		RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		RELEASE_ELAN_ATM_LIST_LOCK(pElan);
	
		//
		//	Send Arp Response to the LES
		//
		do
		{
			//
			//	Allocate the Ndis packet header.
			//
			pResponseNdisPacket = AtmLaneAllocProtoPacket(pElan);
			if ((PNDIS_PACKET)NULL == pResponseNdisPacket)
			{
				DBGP((0, "ArpRequestHandler: allocate packet failed\n"));
				Status = NDIS_STATUS_RESOURCES;
				break;
			}

			//
			//	Allocate the protocol buffer
			//
			pResponseNdisBuffer = AtmLaneAllocateProtoBuffer(
									pElan,
									pElan->ProtocolBufSize,
									&((PUCHAR)(pResponseCf))
									);
			if ((PNDIS_BUFFER)NULL == pResponseNdisBuffer)
			{
				DBGP((0, "ArpRequestHandler: allocate proto buffer failed\n"));
				Status = NDIS_STATUS_RESOURCES;
				break;
			}

			//
			//	Copy in the request packet
			//
			NdisMoveMemory(
					pResponseCf, 
					pRequestCf, 
					sizeof(LANE_CONTROL_FRAME)
					);

			//
			//	Change to a response opcode
			//
			pResponseCf->OpCode = LANE_ARP_RESPONSE;

			//
			//	Fill in our ATM Address
			//
			NdisMoveMemory(
				&pResponseCf->TargetAtmAddr,
				&pElan->AtmAddress.Address,
				ATM_ADDRESS_LENGTH
				);
				
			//
			//	Link the ndis buffer to the ndis packet
			//
			NdisChainBufferAtFront(pResponseNdisPacket, pResponseNdisBuffer);
					
			//
			//	Reacquire VC lock and if VC still connected send packet
			//
			ACQUIRE_VC_LOCK(pVc);
			if (IS_FLAG_SET(
						pVc->Flags,
						VC_CALL_STATE_MASK,
						VC_CALL_STATE_ACTIVE))
			{
				DBGP((2, "ArpRequestHandler: Sent ARP RESPONSE\n"));
				AtmLaneSendPacketOnVc(pVc, pResponseNdisPacket, FALSE);
				//
				//	VC lock released in above
				//
			}
			else
			{
				Status = NDIS_STATUS_FAILURE;
				RELEASE_VC_LOCK(pVc);
			}

			break;
		}
		while (FALSE);

		break;
	}
	while (FALSE);
	
	//
	//	Remove temp VC reference
	//
	if (pVc != NULL_PATMLANE_VC)
	{
		ACQUIRE_VC_LOCK(pVc);
		rc = AtmLaneDereferenceVc(pVc, "temp");
		if (rc > 0)
		{
			RELEASE_VC_LOCK(pVc);
		}
		//
		//	else VC is gone
		//
	}

	//
	//	Cleanup if failure
	//
	if (Status != NDIS_STATUS_SUCCESS)
	{
		if (pResponseNdisPacket != (PNDIS_PACKET)NULL)
		{
			AtmLaneFreeProtoPacket(pElan, pResponseNdisPacket);
		}
		if (pResponseNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreeProtoBuffer(pElan, pResponseNdisBuffer);
		}
	}
	
	TRACEOUT(ArpRequestHandler);
	return;
}

VOID
AtmLaneArpResponseHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PLANE_CONTROL_FRAME 		pCf
)
/*++

Routine Description:

	Handle an LE_ARP Response frame.
	
	The MAC Entry should already exist and the Tid in the
	ARP frame should match the one in the MAC Entry.
	If either is not true then the information is ignored.

	An ATM Entry is created or and existing one is found.
	The MAC Entry is linked to it and appropriate actions
	are taken based on the MAC Entry state.

Arguments:

	pElan					- Pointer to ATMLANE Elan
	pMacAddress				- MAC Address
	pAtmAddress				- ATM Address

Return Value:

	None.

--*/
{
	PATMLANE_MAC_ENTRY			pMacEntry;
	PATMLANE_ATM_ENTRY			pAtmEntry;
	PMAC_ADDRESS				pMacAddress;
	PUCHAR						pAtmAddress;				
	BOOLEAN						WasRunning;
	BOOLEAN						bFound;
	ULONG						MacAddrType;
	ULONG						rc;

	TRACEIN(ArpResponseHandler);

	//
	//  Initialize
	//
	pMacEntry = NULL_PATMLANE_MAC_ENTRY;
	pAtmEntry = NULL_PATMLANE_ATM_ENTRY;

	MacAddrType = pCf->TargetMacAddress.Type;
	pMacAddress = (PMAC_ADDRESS)pCf->TargetMacAddress.Byte;
	pAtmAddress = pCf->TargetAtmAddr;

	do
	{
		//
		//	Check Status
		//				
		if (pCf->Status != LANE_STATUS_SUCCESS)
		{
			DBGP((0,
				"ArpResponseHandler: Unsuccessful Status (%d) for %s\n",
				pCf->Status,
				MacAddrToString(pMacAddress)));
			break;
		}

		//
		//  Get an existing MAC Entry
		//
		ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan);
		pMacEntry = AtmLaneSearchForMacAddress(
								pElan,
								MacAddrType,
								pMacAddress,
								FALSE
								);
		RELEASE_ELAN_MAC_TABLE_LOCK(pElan);
		if (pMacEntry == NULL_PATMLANE_MAC_ENTRY)
		{
			DBGP((0, "ArpResponseHandler: non-existing MAC %s\n",
				MacAddrToString(pMacAddress)));
			break;
		}
		
		ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);

		//
		//	Verify that Tid matches
		//
		if (pMacEntry->ArpTid != pCf->Tid)
		{
			DBGP((0, "ArpResponseHandler: invalid Tid for MAC %s\n",
				MacAddrToString(pMacAddress)));
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
			break;
		}
		
		DBGP((1, "%d Resolved %s to %s\n", 
			pElan->ElanNumber,
			MacAddrToString(pMacAddress),
			AtmAddrToString(pAtmAddress)));
	
		//
		//  Get an existing or create new ATM Entry
		//
		pAtmEntry = AtmLaneSearchForAtmAddress(
								pElan,
								pAtmAddress,
								(((pMacEntry->Flags & MAC_ENTRY_BROADCAST) != 0)
									? ATM_ENTRY_TYPE_BUS
									: ATM_ENTRY_TYPE_PEER),
								TRUE
								);
		if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
		{
			//
			//	resource problem - ARP timeout will clean up MAC Entry
			//		
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
			break;
		}
		
		//
		//  Got both entries.
		//
		//  If the MAC Entry is linked to a different
		//	ATM Entry, unlink it from the old entry.
		//
		if ((pMacEntry->pAtmEntry != NULL_PATMLANE_ATM_ENTRY) && 
			(pMacEntry->pAtmEntry != pAtmEntry))
		{
			DBGP((0, 
				"LearnMacToAtm: MacEntry %x moving from ATM Entry %x to ATM Entry %x\n",
				pMacEntry, pMacEntry->pAtmEntry, pAtmEntry));

			SET_FLAG(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_NEW);
					
			bFound = AtmLaneUnlinkMacEntryFromAtmEntry(pMacEntry);
			pMacEntry->pAtmEntry = NULL_PATMLANE_ATM_ENTRY;

			if (bFound)
			{
				rc = AtmLaneDereferenceMacEntry(pMacEntry, "atm");
				if (rc == 0)
				{
					//
					//  The MAC entry is gone. Let the next outgoing packet
					//  cause a new entry to be created.
					//
					break;
				}
			}
		}

		if (IS_FLAG_SET(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_ARPING))
		{
			//
			//	MAC Entry is in ARPING state
			//
			ASSERT(pMacEntry->pAtmEntry == NULL_PATMLANE_ATM_ENTRY);

			//
			//	Link MAC Entry and ATM Entry together
			//
			ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
#if DBG1
			{
				PATMLANE_MAC_ENTRY		pTmpMacEntry;
				ULONG					Count = 0;

				for (pTmpMacEntry = pAtmEntry->pMacEntryList;
					 pTmpMacEntry != NULL;
					 pTmpMacEntry = pTmpMacEntry->pNextToAtm)
				{
					if (pTmpMacEntry == pMacEntry)
					{
						DBGP((0, "LearnMacToAtm: pMacEntry %x already in list for pAtmEntry %x\n",
							pTmpMacEntry, pAtmEntry));
						DbgBreakPoint();
					}

					Count++;
					if (Count > 5000)
					{
						DBGP((0, "Loop in list on pAtmEntry %x\n", pAtmEntry));
						DbgBreakPoint();
						break;
					}
				}
			}
#endif // DBG
			pMacEntry->pAtmEntry = pAtmEntry;
			AtmLaneReferenceAtmEntry(pAtmEntry, "mac");
			pMacEntry->pNextToAtm = pAtmEntry->pMacEntryList;
			pAtmEntry->pMacEntryList = pMacEntry;
			RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
			AtmLaneReferenceMacEntry(pMacEntry, "atm");

			DBGP((1, "%d Linked1 MAC %x to ATM %x\n",
					pAtmEntry->pElan->ElanNumber,
					pMacEntry,
					pAtmEntry));

			//
			//	Cancel ARP timer
			//
			WasRunning = AtmLaneStopTimer(&(pMacEntry->Timer), pElan);
			if (WasRunning)
			{
				rc = AtmLaneDereferenceMacEntry(pMacEntry, "timer");
				ASSERT(rc > 0);
			}

			//
			//	Transition to RESOLVED state
			//
			SET_FLAG(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_RESOLVED);

			//
			//	Handle special case for broadcast address.
			//	
			if ((pMacEntry->Flags & MAC_ENTRY_BROADCAST) != 0)
			{
				RELEASE_MAC_ENTRY_LOCK(pMacEntry);
				
				//
				//	Cache the AtmEntry in the Elan
				//
				ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);
				pElan->pBusAtmEntry = pAtmEntry;
				RELEASE_ELAN_ATM_LIST_LOCK(pElan);
				
				//
				//	Copy the Atm Address into the AtmEntry
				//
				pAtmEntry->AtmAddress.AddressType = ATM_NSAP;
				pAtmEntry->AtmAddress.NumberOfDigits = ATM_ADDRESS_LENGTH;
				NdisMoveMemory(
						pAtmEntry->AtmAddress.Address, 
						pAtmAddress,
						ATM_ADDRESS_LENGTH
						);

				//
				//	Signal the event to the state machine
				//
				AtmLaneQueueElanEvent(pElan, ELAN_EVENT_ARP_RESPONSE, NDIS_STATUS_SUCCESS);

				//
				//	Event handler will initiate the call to the bus
				//

				break; // done
			}

			//
			//	Not broadcast address.
			//
			//  Start the Aging timer.
			//	Use Elan AgingTime if TopologyChange is inactive.
			//	Use Elan ForwardDelayTime if TopologyChange is active.
			//  
			AtmLaneReferenceMacEntry(pMacEntry, "timer");
			AtmLaneStartTimer(
						pElan,
						&pMacEntry->Timer,
						AtmLaneMacEntryAgingTimeout,
						pElan->TopologyChange?pElan->ForwardDelayTime:pElan->AgingTime,
						(PVOID)pMacEntry
						);
		
			//
			//	If ATM Entry not connected and a call not in progress
			//  then start a call
			//
			ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
		
			if (!IS_FLAG_SET(
						pAtmEntry->Flags,
						ATM_ENTRY_STATE_MASK,
						ATM_ENTRY_CONNECTED))
			{
				if ((pAtmEntry->Flags & ATM_ENTRY_CALLINPROGRESS) == 0)
				{
					// 
					//	Mark ATM entry with call in progress
					//
					pAtmEntry->Flags |= ATM_ENTRY_CALLINPROGRESS;

					//
					//	Release the MAC lock and reacquire ATM lock
					//
					RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
					RELEASE_MAC_ENTRY_LOCK(pMacEntry);
					ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
					AtmLaneMakeCall(pElan, pAtmEntry, FALSE);
					//
					//	ATM Entry released in above
					//
				}
				else
				{
					//
					//	Call already in progress
					//
					RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
					RELEASE_MAC_ENTRY_LOCK(pMacEntry);
				}
				break; // done
			}

			//
			//	ATM Entry is connected
			//

			RELEASE_ATM_ENTRY_LOCK(pAtmEntry);

			//
			//	Transition to FLUSHING state
			//
			SET_FLAG(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_FLUSHING);

			//
			//	 Start flushing
			//
			pMacEntry->RetriesLeft = 0;
			AtmLaneReferenceMacEntry(pMacEntry, "timer");
			AtmLaneStartTimer(
					pElan,
					&pMacEntry->FlushTimer,
					AtmLaneFlushTimeout,
					pElan->FlushTimeout,
					(PVOID)pMacEntry
					);
	
			AtmLaneSendFlushRequest(pElan, pMacEntry, pAtmEntry);
			//
			// MAC Entry released in above
			//

			break; // done
		}

		if (IS_FLAG_SET(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_AGED))
		{
			//
			//	MAC Entry is being revalidated 
			//
			//
			//	Cancel ARP timer
			//
			WasRunning = AtmLaneStopTimer(&(pMacEntry->Timer), pElan);
			if (WasRunning)
			{
				rc = AtmLaneDereferenceMacEntry(pMacEntry, "timer");
				ASSERT(rc > 0);
			}

			//
			//	Start the Aging timer up again
			//
			AtmLaneReferenceMacEntry(pMacEntry, "timer");
			AtmLaneStartTimer(
					pElan,
					&pMacEntry->Timer,
					AtmLaneMacEntryAgingTimeout,
					pElan->TopologyChange?pElan->ForwardDelayTime:pElan->AgingTime,
					(PVOID)pMacEntry
					);

			//
			//	Check if MAC Entry is switching to new ATM Entry

			if (pMacEntry->pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
			{
				//
				//	Link MAC Entry and new ATM Entry together
				//
				ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
#if DBG1
			{
				PATMLANE_MAC_ENTRY		pTmpMacEntry;
				ULONG					Count = 0;

				for (pTmpMacEntry = pAtmEntry->pMacEntryList;
					 pTmpMacEntry != NULL;
					 pTmpMacEntry = pTmpMacEntry->pNextToAtm)
				{
					if (pTmpMacEntry == pMacEntry)
					{
						DBGP((0, "RespHandler: pMacEntry %x already in list for pAtmEntry %x\n",
							pTmpMacEntry, pAtmEntry));
						DbgBreakPoint();
					}

					Count++;
					if (Count > 5000)
					{
						DBGP((0, "RespHandler: Loop in list on pAtmEntry %x\n", pAtmEntry));
						DbgBreakPoint();
						break;
					}
				}
			}
#endif // DBG
				pMacEntry->pAtmEntry = pAtmEntry;
				AtmLaneReferenceAtmEntry(pAtmEntry, "mac");
				pMacEntry->pNextToAtm = pAtmEntry->pMacEntryList;
				pAtmEntry->pMacEntryList = pMacEntry;
				RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
				AtmLaneReferenceMacEntry(pMacEntry, "atm");

				DBGP((1, "%d Linked2 MAC %x to ATM %x\n",
						pAtmEntry->pElan->ElanNumber,
						pMacEntry,
						pAtmEntry));

				//
				//	Transition back to resolved state
				//
				SET_FLAG(
						pMacEntry->Flags,
						MAC_ENTRY_STATE_MASK,
						MAC_ENTRY_RESOLVED);
			}

			//
			//	If ATM Entry not connected and a call not in progress
			//  then start a call
			//
			ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
		
			if (!IS_FLAG_SET(
						pAtmEntry->Flags,
						ATM_ENTRY_STATE_MASK,
						ATM_ENTRY_CONNECTED))
			{
				if ((pAtmEntry->Flags & ATM_ENTRY_CALLINPROGRESS) == 0)
				{
					// 
					//	Mark ATM entry with call in progress
					//
					pAtmEntry->Flags |= ATM_ENTRY_CALLINPROGRESS;

					//
					//	Release the MAC lock and reacquire ATM lock
					//
					RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
					RELEASE_MAC_ENTRY_LOCK(pMacEntry);
					ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
					AtmLaneMakeCall(pElan, pAtmEntry, FALSE);
					//
					//	ATM Entry released in above
					//
				}
				else
				{
					//
					//	Call already in progress
					//
					RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
					RELEASE_MAC_ENTRY_LOCK(pMacEntry);
				}
				break; // done
			}

			RELEASE_ATM_ENTRY_LOCK(pAtmEntry);

			//
			//	MAC Entry is now either still AGED or 
			//	transitioned to RESOLVED state.  
			//

			ASSERT((pMacEntry->Flags & (MAC_ENTRY_AGED | MAC_ENTRY_RESOLVED)) != 0);

			if (IS_FLAG_SET(
						pMacEntry->Flags,
						MAC_ENTRY_STATE_MASK,
						MAC_ENTRY_RESOLVED))
			{
				// 
				//	MAC entry must have moved to new, connected ATM Entry
				//	Do the flush
				//
				SET_FLAG(
						pMacEntry->Flags,
						MAC_ENTRY_STATE_MASK,
						MAC_ENTRY_FLUSHING);

				pMacEntry->RetriesLeft = 0;
				AtmLaneReferenceMacEntry(pMacEntry, "timer");
				AtmLaneStartTimer(
						pElan,
						&pMacEntry->FlushTimer,
						AtmLaneFlushTimeout,
						pElan->FlushTimeout,
						(PVOID)pMacEntry
						);

				AtmLaneSendFlushRequest(pElan, pMacEntry, pAtmEntry);
				//
				// MAC Entry released in above
				//

				break; // done
			}

			//
			//	MAC Entry can just transition back to ACTIVE
			//
			SET_FLAG(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_ACTIVE);

			RELEASE_MAC_ENTRY_LOCK(pMacEntry);

			break;
		}

		//
		//	Shouldn't get here
		//
		RELEASE_MAC_ENTRY_LOCK(pMacEntry);
		DBGP((0, "LearnMacToAtm: MacEntry in wrong state!\n"));
		break;

	}
	while (FALSE);

	if (NULL_PATMLANE_ATM_ENTRY != pAtmEntry)
	{
		//
		//  Remove the temp ref added by SearchFor...
		//
		ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
		rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "search");
		if (rc != 0)
		{
			RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
		}
	}

	TRACEOUT(ArpResponseHandler);

	return;
}

VOID
AtmLaneFlushResponseHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PLANE_CONTROL_FRAME 		pCf
)
/*++

Routine Description:

	Handles incoming Flush Response packets from peers.
		
Arguments:

	pCf						- Pointer to LANE Control Frame

Return Value:

	None

--*/
{
	PATMLANE_ATM_ENTRY		pAtmEntry;
	PATMLANE_MAC_ENTRY		pMacEntry;
	PNDIS_PACKET			pNdisPacket;
	PNDIS_PACKET			pNextPacket;
	PATMLANE_VC				pVc;
	BOOLEAN					WasRunning;
	ULONG					rc;

	TRACEIN(FlushResponseHandler);

	pAtmEntry = NULL_PATMLANE_ATM_ENTRY;

	do
	{
		//
		// 	Check that we originated the request
		//
		if (!ATM_ADDR_EQUAL(pCf->SourceAtmAddr, &pElan->AtmAddress.Address))
		{
			DBGP((0, "FlushResponseHandler: Response not addressed to us!\n"));
			break;
		}
	
		//
		//	Find the Atm Entry for the target address
		//
		pAtmEntry = AtmLaneSearchForAtmAddress(
							pElan,
							pCf->TargetAtmAddr,
							ATM_ENTRY_TYPE_PEER,
							FALSE);				// don't create a new one
		if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
		{
			DBGP((0, "FlushResponseHandler: No matching ATM entry\n"));
			break;
		}

		//
		//	Grab and Reference the VC for this ATM Entry 
		//
		ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
		pVc = pAtmEntry->pVcList;
		if (pVc == NULL_PATMLANE_VC)
		{
			DBGP((0, "FlushResponseHandler: No VC on ATM Entry\n"));
			RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
			break;
		}
		ACQUIRE_VC_LOCK_DPC(pVc);
		AtmLaneReferenceVc(pVc, "temp");
		RELEASE_VC_LOCK_DPC(pVc);

		//
		//	Find the Mac Entry on this Atm Entry that matches the Tid
		//
		pMacEntry = pAtmEntry->pMacEntryList;
		while(pMacEntry != NULL_PATMLANE_MAC_ENTRY)
		{
			if (pMacEntry->FlushTid == pCf->Tid)
				break;
			pMacEntry = pMacEntry->pNextToAtm;
		}
		if (pMacEntry == NULL_PATMLANE_MAC_ENTRY)
		{	
			//
			//	No MAC Entry still exists that originated this flush
			//
			DBGP((0, "FlushResponseHandler: No MAC entry with matching TID\n"));

			ACQUIRE_VC_LOCK(pVc);
			rc = AtmLaneDereferenceVc(pVc, "temp");
			if (rc > 0)
			{
				RELEASE_VC_LOCK(pVc);
			}
			RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
			break;
		}
		else
		{
			//
			//	Found it
			//		
			RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
		}

		//
		//	Mark MAC Entry ACTIVE
		//
		ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
		AtmLaneReferenceMacEntry(pMacEntry, "temp");
		SET_FLAG(
				pMacEntry->Flags,
				MAC_ENTRY_STATE_MASK,
				MAC_ENTRY_ACTIVE);

		//
		//	Cancel the flush timer
		//
		WasRunning = AtmLaneStopTimer(&pMacEntry->FlushTimer, pElan);
		if (WasRunning)
		{
			rc = AtmLaneDereferenceMacEntry(pMacEntry, "flush timer");
			ASSERT(rc > 0);
		}

		//
		//	Send any queued packets
		//
		while ((pNdisPacket = AtmLaneDequeuePacketFromHead(pMacEntry)) != 
				(PNDIS_PACKET)NULL)
		{
			//
			//	Send it
			//
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
			ACQUIRE_VC_LOCK(pVc);
			AtmLaneSendPacketOnVc(pVc, pNdisPacket, TRUE);

			ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
		}


		//
		//	Dereference the MAC Entry
		//
		rc = AtmLaneDereferenceMacEntry(pMacEntry, "temp");
		if (rc > 0)
		{
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
		}
		
		//
		//	Dereference the VC
		//
		ACQUIRE_VC_LOCK(pVc);
		rc = AtmLaneDereferenceVc(pVc, "temp");
		if (rc > 0)
		{
			RELEASE_VC_LOCK(pVc);
		}
		
		break;
	}
	while (FALSE);
	
	if (NULL_PATMLANE_ATM_ENTRY != pAtmEntry)
	{
		//
		//  Remove the temp ref added by SearchFor...
		//
		ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
		rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "search");
		if (rc != 0)
		{
			RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
		}
	}

	TRACEOUT(FlushResponseHandler);
	return;
}



VOID
AtmLaneReadyIndicationHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_VC					pVc,
	IN	PNDIS_PACKET				pIndNdisPacket
)
/*++

Routine Description:

	Handles incoming READY_INDICATION packets from peers.
		
Arguments:

	pElan					- Pointer to ATMLANE Elan structure

	pVc						- Pointer to ATMLANE VC for this packet

	pIndNdisPacket			- Pointer to the Ndis Packet

Return Value:

	None

--*/
{
	BOOLEAN				WasRunning;
	ULONG				rc;
	
	TRACEIN(ReadyIndicationHandler);

	ACQUIRE_VC_LOCK(pVc);
	
	//
	//	Cancel the ready timer on VC
	//
	WasRunning = AtmLaneStopTimer(&pVc->ReadyTimer, pElan);
	if (WasRunning)
	{
		rc = AtmLaneDereferenceVc(pVc, "ready timer");
	}
	else
	{
		rc = pVc->RefCount;
	}

	//
	//	If VC still around update state
	//
	if (rc > 0)
	{
		DBGP((2, "ReadyIndicationHandler: pVc %x State to INDICATED\n", pVc));
		SET_FLAG(
			pVc->Flags,
			VC_READY_STATE_MASK,
			VC_READY_INDICATED
			);
		RELEASE_VC_LOCK(pVc);
	}
	//
	//	else VC is gone
	//

	TRACEOUT(ReadyIndicationHandler);
	return;
}

VOID
AtmLaneTopologyRequestHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PLANE_CONTROL_FRAME			pCf
)
/*++

Routine Description:

	Handles incoming Topology Request packets from the LES.
		
Arguments:

	pRequestCf		- Pointer to ARP Request Frame

Return Value:

	None

--*/
{
	ULONG					i;
	PATMLANE_MAC_ENTRY		pMacEntry;

	TRACEIN(TopologyRequestHandler);

	if ((pCf->Flags & LANE_CONTROL_FLAGS_TOPOLOGY_CHANGE) == 0)
	{
		//
		//	Topology change state OFF
		//
		DBGP((1, "%d TOPOLOGY CHANGE OFF\n", pElan->ElanNumber));
		pElan->TopologyChange = 0;
	}
	else
	{
		//
		//	Topology change state ON
		//
		DBGP((1, "%d TOPOLOGY CHANGE ON\n", pElan->ElanNumber));
		pElan->TopologyChange = 1;

		//
		//	Abort all MAC table entries.
		//
		for (i = 0; i < ATMLANE_MAC_TABLE_SIZE; i++)
		{
			ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan);
			while (pElan->pMacTable[i] != NULL_PATMLANE_MAC_ENTRY)
			{
				pMacEntry = pElan->pMacTable[i];
				RELEASE_ELAN_MAC_TABLE_LOCK(pElan);		

				ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
				AtmLaneAbortMacEntry(pMacEntry);
				//
				//  MAC Entry Lock is released within the above.
				//
				ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan);
			}
			RELEASE_ELAN_MAC_TABLE_LOCK(pElan);
		}
		
	}

	TRACEOUT(TopologyRequestHandler);
	return;
}

BOOLEAN
AtmLaneDataPacketHandler(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	Handles incoming packets from the data VCs from peers and
	unknown and multicast packets from the BUS.
	
	
Arguments:

	pElan					- Pointer to ATMLANE Elan structure

	pVc						- Pointer to ATMLANE Vc structure

	pNdisPacket				- Pointer to the Ndis Packet

Return Value:

	TRUE 					- if packet will be retained (i.e. sent
							  up to protocols)

	FALSE					- if packet was a flush request packet and
							  can be reliquished back to adapter
							  immediately.

--*/
{
	ULONG					TotalLength;
	ULONG					TempLength;
	PUCHAR					pBuffer;
	BOOLEAN					RetainIt;
	PLANE_CONTROL_FRAME		pCf;
	PNDIS_PACKET			pNewNdisPacket;
	PNDIS_BUFFER			pFirstNdisBuffer;
	PNDIS_BUFFER			pTempNdisBuffer;
	PNDIS_BUFFER			pNewNdisBuffer;
	PUCHAR					pTempBuffer;
	NDIS_STATUS				Status;
	ULONG					MacHdrSize;
	ULONG					DestAddrType;
	MAC_ADDRESS				DestAddr;
	BOOLEAN					DestIsMulticast;
	NDIS_HANDLE				MiniportAdapterHandle;
	
	TRACEIN(DataPacketHandler);

	//	Initialize

	RetainIt = FALSE;			// default is not to keep packet
	pNewNdisPacket = NULL;

	do
	{
		//
		//	Get initial buffer and total length of packet
		//		
		NdisGetFirstBufferFromPacket(
				pNdisPacket, 
				&pFirstNdisBuffer, 
				&pBuffer,
				&TempLength,
				&TotalLength);

		DBGP((3, "DataPacketHandler: Pkt %x Length %d\n",
			pNdisPacket, TotalLength));
		//DbgPrintNdisPacket(pNdisPacket);

		//
		//	Filter out flush request and ready query frames
		//
		if (TempLength < 6)
		{
			DBGP((0, "DataPacketHandler: pVc %x First fragment"
			         " < 6, discarding\n", pVc));

			break;
		}
		
		pCf = (PLANE_CONTROL_FRAME)pBuffer;
		
		if (pCf->Marker == LANE_CONTROL_MARKER 	&&
			pCf->Protocol == LANE_PROTOCOL 		&&
			pCf->Version == LANE_VERSION)
		{
			switch (pCf->OpCode)
			{
				case LANE_FLUSH_REQUEST:
					DBGP((2, "DataPacketHandler: pVc %x FLUSH REQUEST\n", pVc));
					AtmLaneFlushRequestHandler(pElan, pNdisPacket);
					break;
				case LANE_READY_QUERY:
					DBGP((2, "DataPacketHandler: pVc %x READY QUERY\n", pVc));
					AtmLaneReadyQueryHandler(pElan, pVc, pNdisPacket);
					break;
				case LANE_READY_IND:
					DBGP((2, "DataPacketHandler: pVc %x READY INDICATION\n", pVc));
					AtmLaneReadyIndicationHandler(pElan, pVc, pNdisPacket);
					break;
				default:
					DBGP((2, 
						"DataPacketHandler: pVc %x Unexpected control"
						" packet, opcode %x\n",
						pVc, pCf->OpCode));
					break;
			}
			break;
		}

		//
		//	If miniport is not operational - discard
		//
		if ((pElan->Flags & ELAN_MINIPORT_OPERATIONAL) == 0)
		{
			DBGP((2, "%d Dropping pkt %x, cuz Elan %x Flags are %x\n",
						pElan->ElanNumber, pNdisPacket, pElan, pElan->Flags));
			break;
		}

		//
		//  If no filters are set, discard.
		//
		if (pElan->CurPacketFilter == 0)
		{
			DBGP((2, "%d Dropping pkt %x, cuz Elan %x Filter is zero\n",
						pElan->ElanNumber, pNdisPacket, pElan));
			break;
		}

		MiniportAdapterHandle = pElan->MiniportAdapterHandle;
		if (NULL == MiniportAdapterHandle)
		{
			DBGP((0, "%d Dropping pkt %x cuz ELAN %x has Null handle!\n",
					pElan->ElanNumber, pNdisPacket, pElan));
			break;
		}

		//
		//	Mark VC with fact that it has had data packet receive activity
		//
		//	To avoid slowing down the receive path, MP issues with
		//	setting this flag are ignored.  This flag is a VC aging
		//  optimization and not critical.  
		//
		pVc->ReceiveActivity = 1;

		//
		//	Repackage it and learn some stuff about it.
		//
		pNewNdisPacket = AtmLaneWrapRecvPacket(
								pElan, 
								pNdisPacket, 
								&MacHdrSize,
								&DestAddrType,
								&DestAddr,
								&DestIsMulticast);

		//
		//	If wrap failed just discard packet
		//	
		if (pNewNdisPacket == (PNDIS_PACKET)NULL)
		{
			DBGP((2, "%d Dropping pkt %x, len %d, VC %x, wrap failed\n",
					pElan->ElanNumber, pNdisPacket, TotalLength, pVc));
			break;
		}

		//
		//	Branch on Ethernet v.s. Token Ring
		//
		if (pElan->LanType == LANE_LANTYPE_ETH)
		{
			//
			//	Filter out BUS reflections that we originated.
			//
			if (pCf->Marker == pElan->LecId)  
			{
				DBGP((2, "%d Dropping pkt %x, len %d, VC %x, BUS reflection\n",
						pElan->ElanNumber, pNdisPacket, TotalLength, pVc));
				break;
			}

			//
			//	Filter out Unicasts not addressed to us
			//
			if ((!DestIsMulticast) &&
				(!MAC_ADDR_EQUAL(&DestAddr, &pElan->MacAddressEth)))
			{
				DBGP((2, "%d Dropping pkt %x, len %d, VC %x, unicast not for us\n",
						pElan->ElanNumber, pNdisPacket, TotalLength, pVc));
				break;
			}
		}
		else
		{
			ASSERT(pElan->LanType == LANE_LANTYPE_TR);
			
			//
			//	Filter out Non-Multicast BUS reflections that we originated
			//
			if ((pCf->Marker == pElan->LecId) && (!DestIsMulticast))  
			{
				DBGP((2, "%d Dropping pkt %x, len %d, VC %x, TR Bus refln\n",
						pElan->ElanNumber, pNdisPacket, TotalLength, pVc));
				break;
			}

			//
			//	Filter out Unicasts not addressed to us
			//
			if ((!DestIsMulticast) &&
				(!MAC_ADDR_EQUAL(&DestAddr, &pElan->MacAddressTr)))
			{
				DBGP((2, "%d Dropping pkt %x, len %d, VC %x, TR unicast not for us\n",
						pElan->ElanNumber, pNdisPacket, TotalLength, pVc));
				break;
			}
		}

		//
		//  Filter out multicast/broadcast if we don't have these enabled.
		//
		if (DestIsMulticast)
		{
			if ((pElan->CurPacketFilter &
					(NDIS_PACKET_TYPE_MULTICAST|
					 NDIS_PACKET_TYPE_BROADCAST|
					 NDIS_PACKET_TYPE_ALL_MULTICAST)) == 0)
			{
				DBGP((2, "%d Dropping multicast pkt %x, cuz CurPacketFilter is %x\n",
						pElan->ElanNumber, pNdisPacket, pElan->CurPacketFilter));
				break;
			}

			if (((pElan->CurPacketFilter & NDIS_PACKET_TYPE_BROADCAST) == 0) &&
				 MAC_ADDR_EQUAL(&DestAddr, &gMacBroadcastAddress))
			{
				DBGP((2, "%d Dropping broadcast pkt %x, cuz CurPacketFilter is %x\n",
						pElan->ElanNumber, pNdisPacket, pElan->CurPacketFilter));
				break;
			}

		}

		//
		//	Count it
		//
		NdisInterlockedIncrement(&pElan->FramesRecvGood);

		//
		//	Indicate it up to protocols and other interested parties
		//	
		NDIS_SET_PACKET_HEADER_SIZE(pNewNdisPacket, MacHdrSize);

		TRACELOGWRITE((&TraceLog, 
					TL_MINDPACKET,	
					pNewNdisPacket));
		
		//
		//  Set the packet status according to what we received from the miniport.
		//
		Status = NDIS_GET_PACKET_STATUS(pNdisPacket);
		NDIS_SET_PACKET_STATUS(pNewNdisPacket, Status);
		
		NdisMIndicateReceivePacket(
				MiniportAdapterHandle,
				&pNewNdisPacket,
				1
				);

		if (Status != NDIS_STATUS_RESOURCES)
		{
			RetainIt = TRUE;
			DBGP((2, "DataPacketHandler: Packet Retained!\n"));
		}
		//
		//  else our ReturnPackets handler is guaranteed to be called.
		//
		
	}	
	while (FALSE);

	//
	//	Unwrap the packet if it was wrapped and we don't have to keep it.
	//
	if (pNewNdisPacket && !RetainIt)
	{
		(VOID)AtmLaneUnwrapRecvPacket(pElan, pNewNdisPacket);
	}

	TRACEOUT(DataPacketHandler);
	
	return (RetainIt);
}


VOID
AtmLaneSendPacketOnVc(
	IN	PATMLANE_VC					pVc		LOCKIN	NOLOCKOUT,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	BOOLEAN						Refresh
)
/*++

Routine Description:

	Send a packet on the specified VC. 
	Assumes caller has lock on VC structure.
	Assumes caller has checked VC state for validity.
	If requested, refresh the aging timer.
	Sends the packet.
	Returns the send status

Arguments:

	pVc					- Pointer to ATMLANE VC
	pNdisPacket			- Pointer to packet to be sent.
	Refresh				- If TRUE refresh the Aging Timer.

Return Value:

	NDIS_STATUS value set on the packet by the miniport.

--*/
{
	NDIS_HANDLE				NdisVcHandle;
	PATMLANE_ELAN			pElan;
	
	TRACEIN(SendPacketOnVc);

	pElan = pVc->pElan;
	STRUCT_ASSERT(pElan, atmlane_elan);

	//
	//	If requested, refresh the aging timer
	//
	if (Refresh)
	{
		AtmLaneRefreshTimer(&pVc->AgingTimer);
	}	

#if SENDLIST

	//
	//	Check list for duplicate send
	//
	NdisAcquireSpinLock(&pElan->SendListLock);
	{
		PNDIS_PACKET pDbgPkt;

		pDbgPkt = pElan->pSendList;

		while (pDbgPkt != (PNDIS_PACKET)NULL)
		{
			if (pNdisPacket == pDbgPkt)
			{
				DBGP((0, "SendPacketOnVc: Duplicate Send!\n"));
				// DbgBreakPoint();
			}
			pDbgPkt = PSEND_RSVD(pDbgPkt)->pNextInSendList;
		}
	}

	//
	//	Queue packet on list of outstanding sends
	//
	PSEND_RSVD(pNdisPacket)->pNextInSendList = pElan->pSendList;
	pElan->pSendList = pNdisPacket;

	NdisReleaseSpinLock(&pElan->SendListLock);
#endif // SENDLIST

	//
	//	Reference the VC with the outstanding send
	//
	AtmLaneReferenceVc(pVc, "sendpkt");

	//
	//  Note this outstanding send.
	//
	pVc->OutstandingSends++;

	//
	//	Get the Ndis handle
	//
	NdisVcHandle = pVc->NdisVcHandle;

	//
	//	Send it
	//
	DBGP((3, "SendPacketOnVc: pVc %x, Pkt %x, VcHandle %x\n",
			pVc, pNdisPacket, NdisVcHandle));


	TRACELOGWRITE((&TraceLog, TL_COSENDPACKET, pNdisPacket));
	TRACELOGWRITEPKT((&TraceLog, pNdisPacket));
			
	RELEASE_VC_LOCK(pVc);

	NdisCoSendPackets(NdisVcHandle,	&pNdisPacket, 1);

#if PROTECT_PACKETS
	//
	//	Lock the packet
	//
	ACQUIRE_SENDPACKET_LOCK(pNdisPacket);

	//
	//	Mark it with NdisCoSendPackets having returned
	//
	ASSERT((PSEND_RSVD(pNdisPacket)->Flags & PACKET_RESERVED_COSENDRETURNED) == 0);
	PSEND_RSVD(pNdisPacket)->Flags |= PACKET_RESERVED_COSENDRETURNED;

	//
	//	Complete the packet only if it is marked as having been completed
	//	by miniport.
	//
	if ((PSEND_RSVD(pNdisPacket)->Flags & PACKET_RESERVED_COMPLETED) != 0)
	{
		AtmLaneCompleteSendPacket(pElan, pNdisPacket, 
			PSEND_RSVD(pNdisPacket)->CompletionStatus);
		//
		//	packet lock released in above
		//
	}
	else
	{
		RELEASE_SENDPACKET_LOCK(pNdisPacket);
	}
#endif	// PROTECT_PACKETS

	TRACEOUT(SendPacketOnVc);
	
	return;
}


VOID
AtmLaneQueuePacketOnHead(
	IN	PATMLANE_MAC_ENTRY			pMacEntry,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	Queue a packet at the head of the MAC Entry 
	packet queue for later transmit.
	Assumes caller has lock on MAC Entry.

Arguments:

	pMacEntry			- Pointer to ATMLANE MAC Entry.
	pNdisPacket			- The packet to be queued.

Return Value:

	None

--*/
{
	PNDIS_PACKET		pPrevPacket;

	TRACEIN(QueuePacketOnHead);

	SET_NEXT_PACKET(pNdisPacket, pMacEntry->PacketList);
	pMacEntry->PacketList =  pNdisPacket;

	pMacEntry->PacketListCount++;

	DBGP((2, "%d QueueHead Count %d on %s\n", 
		pMacEntry->pElan->ElanNumber, 
		pMacEntry->PacketListCount,
		MacAddrToString(&pMacEntry->MacAddress)));

	TRACEOUT(QueuePacketOnHead);
	
	return;
}


VOID
AtmLaneQueuePacketOnTail(
	IN	PATMLANE_MAC_ENTRY			pMacEntry,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	Queue a packet at the tail of the MAC Entry 
	packet queue for later transmit.
	Assumes caller has lock on MAC Entry.

Arguments:

	pMacEntry			- Pointer to ATMLANE MAC Entry.
	pNdisPacket			- The packet to be queued.

Return Value:

	None

--*/
{
	PNDIS_PACKET		pPrevPacket;

	TRACEIN(QueuePacketOnTail);


	if (pMacEntry->PacketList == (PNDIS_PACKET)NULL)
	{
		//
		//  Currently empty.
		//
		pMacEntry->PacketList = pNdisPacket;
	}
	else
	{
		//
		//  Go to the end of the packet list.
		//
		pPrevPacket = pMacEntry->PacketList;
		while (GET_NEXT_PACKET(pPrevPacket) != (PNDIS_PACKET)NULL)
		{
			pPrevPacket = GET_NEXT_PACKET(pPrevPacket);
		}

		//
		//  Found the last packet in the list. Chain this packet
		//  to it.
		//
		SET_NEXT_PACKET(pPrevPacket, pNdisPacket);
	}

	//
	//	Set tail's next pointer to NULL.
	//
	SET_NEXT_PACKET(pNdisPacket, NULL);

	pMacEntry->PacketListCount++;

	DBGP((2, "%d QueueTail Count %d on %s\n", 
		pMacEntry->pElan->ElanNumber, 
		pMacEntry->PacketListCount,
		MacAddrToString(&pMacEntry->MacAddress)));

	TRACEOUT(QueuePacketOnTail);
	return;
}


PNDIS_PACKET
AtmLaneDequeuePacketFromHead(
	IN	PATMLANE_MAC_ENTRY			pMacEntry
)
/*++

Routine Description:

	Dequeue a packet from the head of the MAC Entry packet queue.
	Assumes caller has lock on MAC Entry.

Arguments:

	pMacEntry			- Pointer to ATMLANE MAC Entry.

Return Value:

	First packet on the MAC Entry queue or NULL if queue is empty.

--*/
{
	PNDIS_PACKET		pNdisPacket;

	TRACEIN(DequeuePacketFromHead);

	do
	{
	
		//
		//  If queue is empty, setup to return NULL
		//
		if (pMacEntry->PacketList == (PNDIS_PACKET)NULL)
		{
			ASSERT(pMacEntry->PacketListCount == 0);
		
			pNdisPacket = (PNDIS_PACKET)NULL;
			break;
		}

		//
		//	Queue is not empty - remove head 
		//
		ASSERT(pMacEntry->PacketListCount > 0);

		pNdisPacket = pMacEntry->PacketList;
		
		pMacEntry->PacketList = GET_NEXT_PACKET(pNdisPacket);
		
		SET_NEXT_PACKET(pNdisPacket, NULL);
		
		pMacEntry->PacketListCount--;

		DBGP((2, "%d DequeueHead Count %d on %s\n", 
			pMacEntry->pElan->ElanNumber, 
			pMacEntry->PacketListCount,
			MacAddrToString(&pMacEntry->MacAddress)));

		break;
	}
	while (FALSE);

	TRACEOUT(DequeuePacketFromHead);
	
	return pNdisPacket;
}

NDIS_STATUS
AtmLaneSendUnicastPacket(
	IN	PATMLANE_ELAN				pElan,
	IN	ULONG						DestAddrType,
	IN	PMAC_ADDRESS				pDestAddress,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	Send a unicast packet.
	
Arguments:

	pElan					- Pointer to ATMLANE elan structure
	DestAddrType			- Either LANE_MACADDRTYPE_MACADDR or 
									 LANE_MACADDRTYPE_ROUTEDESCR.
	pDestAddress			- Pointer to Destination MAC Address
	pNdisPacket				- Pointer to packet to be sent.

Return Value:

	NDIS_STATUS_PENDING		- if packet queued or sent
	NDIS_STATUS_FAILURE		- if some error

--*/
{
	PATMLANE_MAC_ENTRY		pMacEntry;
	PATMLANE_ATM_ENTRY		pAtmEntry;
	PATMLANE_VC				pVc;
	NDIS_STATUS				Status;
	ULONG					rc;

	TRACEIN(SendUnicastPacket);
	
	//
	//	Initialize
	//
	pMacEntry = NULL_PATMLANE_MAC_ENTRY;
	Status = NDIS_STATUS_PENDING;
	
	do
	{
		//
		//	Find a MAC entry for this destination address
		//
		ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan);
		pMacEntry = AtmLaneSearchForMacAddress(
							pElan,
							DestAddrType,
							pDestAddress,
							TRUE		// Create new entry if not found
							);

		if (pMacEntry == NULL_PATMLANE_MAC_ENTRY)
		{
			Status = NDIS_STATUS_RESOURCES;
			RELEASE_ELAN_MAC_TABLE_LOCK(pElan);
			break;
		}

		//
		//  Add a temp ref so that this won't go away when we release
		//  the MAC table lock (#303602).
		//
		ACQUIRE_MAC_ENTRY_LOCK_DPC(pMacEntry);
		AtmLaneReferenceMacEntry(pMacEntry, "tempunicast");
		RELEASE_MAC_ENTRY_LOCK_DPC(pMacEntry);

		RELEASE_ELAN_MAC_TABLE_LOCK(pElan);

		//
		//	Lock the MAC Entry
		//
		ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);

		//
		//  Check if it has been deref'ed away.
		//
		rc = AtmLaneDereferenceMacEntry(pMacEntry, "tempunicast");
		if (rc == 0)
		{
			//
			//  The MAC entry is gone! Fail this send.
			//
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//	MAC Entry State - NEW
		//
		if (IS_FLAG_SET(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_NEW))
		{
			DBGP((2, "SendUnicastPacket: NEW Mac Entry %x for %s\n",
				pMacEntry, MacAddrToString(pDestAddress)));
			
			//
			//	Queue packet on MAC Entry
			//
			AtmLaneQueuePacketOnHead(pMacEntry, pNdisPacket);

			//
			//	Transition to ARPING State
			//
			SET_FLAG(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_ARPING);

			ASSERT(pMacEntry->pAtmEntry == NULL_PATMLANE_ATM_ENTRY);
			
			//
			//	Start the BUS sends.
			//
			AtmLaneStartBusSends(pMacEntry);
			//
			//	Lock released in above
			//

			//
			//	Reacquire the lock
			//
			ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
			
			//
			//	Start the ARP protocol
			//
			pMacEntry->RetriesLeft = pElan->MaxRetryCount;
			AtmLaneReferenceMacEntry(pMacEntry, "timer");
			AtmLaneStartTimer(
					pElan,
					&pMacEntry->Timer,
					AtmLaneArpTimeout,
					pElan->ArpResponseTime,
					(PVOID)pMacEntry
					);

			AtmLaneSendArpRequest(pElan, pMacEntry);
			//
			//	MAC Entry lock released in above
			//

			break;
		}

		//
		//	MAC Entry State - ARPING
		//
		if (IS_FLAG_SET(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_ARPING))
		{
			DBGP((2, "SendUnicastPacket: ARPING Mac Entry %x for %s\n",
				pMacEntry, MacAddrToString(pDestAddress)));
				
			//
			//	Queue packet on MAC Entry
			//
			AtmLaneQueuePacketOnHead(pMacEntry, pNdisPacket);

			//
			//	Start the BUS sends
			//
			AtmLaneStartBusSends(pMacEntry);
			//
			//	Lock released in above
			//
			break;
		}

		//
		//	MAC Entry State - RESOLVED
		//
		if (IS_FLAG_SET(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_RESOLVED))
		{
			DBGP((2, "SendUnicastPacket: RESOLVED Mac Entry %x for %s\n",
				pMacEntry, MacAddrToString(pDestAddress)));
			//
			//	Queue packet on MAC Entry
			//
			AtmLaneQueuePacketOnHead(pMacEntry, pNdisPacket);

			//
			//	Start the BUS sends
			//
			AtmLaneStartBusSends(pMacEntry);
			//
			//	Lock released in above
			//
			break;
		}

		//
		//	MAC Entry State - FLUSHING
		//
		if (IS_FLAG_SET(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_FLUSHING))
		{
			DBGP((2, "SendUnicastPacket: FLUSHING Mac Entry %x for %s\n",
				pMacEntry, MacAddrToString(pDestAddress)));
			//
			//	Queue packet on MAC Entry
			//
			AtmLaneQueuePacketOnHead(pMacEntry, pNdisPacket);

			RELEASE_MAC_ENTRY_LOCK(pMacEntry);

			break;
		}

		//
		//	MAC Entry State - ACTIVE
		//
		//
		if (IS_FLAG_SET(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_ACTIVE))
		{
			DBGP((2, "SendUnicastPacket: ACTIVE Mac Entry %x for %s\n",
				pMacEntry, MacAddrToString(pDestAddress)));

			//
			//	Mark MAC Entry as having been used to send a packet.
			//  Will cause revalidation at aging time instead of deletion.
			//
			pMacEntry->Flags |= MAC_ENTRY_USED_FOR_SEND;

			ASSERT(pMacEntry->pAtmEntry != NULL_PATMLANE_ATM_ENTRY);

			pVc = pMacEntry->pAtmEntry->pVcList;

			if (pVc == NULL_PATMLANE_VC)
			{
				RELEASE_MAC_ENTRY_LOCK(pMacEntry);
				Status = NDIS_STATUS_FAILURE;
				break;
			}

			ACQUIRE_VC_LOCK(pVc);
			AtmLaneReferenceVc(pVc, "unicast");
			RELEASE_VC_LOCK(pVc);

			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
			ACQUIRE_VC_LOCK(pVc);

			rc = AtmLaneDereferenceVc(pVc, "unicast");

			if (rc == 0)
			{
				Status = NDIS_STATUS_FAILURE;
				break;
			}

			AtmLaneSendPacketOnVc(pVc, pNdisPacket, TRUE);
			//
			//	Vc lock released in above
			//
			NdisInterlockedIncrement(&pElan->FramesXmitGood);	// count packet
			break;
		}

		//
		//	MAC Entry State - AGED
		//
		//
		if (IS_FLAG_SET(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_AGED))
		{
			DBGP((2, "SendUnicastPacket: AGED Mac Entry %x for %s\n",
				pMacEntry, MacAddrToString(pDestAddress)));

			ASSERT(pMacEntry->pAtmEntry != NULL_PATMLANE_ATM_ENTRY);
			ASSERT(pMacEntry->pAtmEntry->pVcList != NULL_PATMLANE_VC);

			pVc = pMacEntry->pAtmEntry->pVcList;

			ACQUIRE_VC_LOCK(pVc);
			AtmLaneReferenceVc(pVc, "unicast");
			RELEASE_VC_LOCK(pVc);

			RELEASE_MAC_ENTRY_LOCK(pMacEntry);

			ACQUIRE_VC_LOCK(pVc);

			rc = AtmLaneDereferenceVc(pVc, "unicast");

			if (rc == 0)
			{
				Status = NDIS_STATUS_FAILURE;
				break;
			}

			AtmLaneSendPacketOnVc(pVc, pNdisPacket, TRUE);
			//
			//	Vc lock released in above
			//
			NdisInterlockedIncrement(&pElan->FramesXmitGood);	// count packet
			break;
		}

		//
		//	MAC Entry State - ABORTING
		//
		//
		if (IS_FLAG_SET(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_ABORTING))
		{
			DBGP((2, "SendUnicastPacket: ABORTING Mac Entry %x for %s\n",
				pMacEntry, MacAddrToString(pDestAddress)));

			Status = NDIS_STATUS_FAILURE;
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
			break;
		}

	}
	while (FALSE);

	TRACEOUT(SendUnicastPacket);

	return Status;
}

VOID
AtmLaneStartBusSends(
	IN	PATMLANE_MAC_ENTRY			pMacEntry	LOCKIN	NOLOCKOUT
)
/*++

Routine Description:

	Starts up the bus send process.
		
Arguments:

	pMacEntry			- A pointer to an ATMLANE MAC Entry structure

Return Value:

	None

--*/
{
	TRACEIN(StartBusSends);

	do
	{
		//
		//	If timer set, just wait for it to go off
		//
		if (pMacEntry->Flags & MAC_ENTRY_BUS_TIMER)
		{
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
			break;
		}

		//
		//	Otherwise do the sends
		//
		AtmLaneDoBusSends(pMacEntry);
		//
		//	lock released in above
		//
	}
	while (FALSE);

	TRACEOUT(StartBusSends);
	return;
}

VOID
AtmLaneDoBusSends(
	IN	PATMLANE_MAC_ENTRY			pMacEntry	LOCKIN	NOLOCKOUT
)
/*++

Routine Description:

	Attempt to send the packets on the MAC Entry's queue.
	Schedule a timer to send later if we exceed the BUS send limits.

	The caller is assumed to have acquired the MAC entry lock,
	which will be released here.
		
Arguments:

	pMacEntry			- A pointer to an ATMLANE MAC Entry structure

Return Value:

	None

--*/
{
	PATMLANE_ATM_ENTRY		pAtmEntry;
	PATMLANE_VC				pVc;
	PATMLANE_ELAN			pElan;
	PNDIS_PACKET			pNdisPacket;
	ULONG					rc;

	TRACEIN(DoBusSends);

	pElan = pMacEntry->pElan;
	
	//
	//	Initialize
	//
	pVc = NULL_PATMLANE_VC;

	//
	//  Place a temp ref on this MAC entry so that it won't go away.
	//
	AtmLaneReferenceMacEntry(pMacEntry, "DoBusSends");

	do
	{
		//
		//	If Elan state not operational then done
		//
		if (ELAN_STATE_OPERATIONAL != pElan->AdminState ||
			ELAN_STATE_OPERATIONAL != pElan->State)
		{
			break;
		}
		
		ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

		pAtmEntry = pElan->pBusAtmEntry;

		if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
		{
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			break;
		}

		ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		pVc = pAtmEntry->pVcList;
		if (pVc == NULL_PATMLANE_VC)
		{
			RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
			RELEASE_ELAN_ATM_LIST_LOCK(pElan);
			break;
		}

		//
		//	Reference the VC to keep it around
		//
		ACQUIRE_VC_LOCK_DPC(pVc);
		AtmLaneReferenceVc(pVc, "temp");
		RELEASE_VC_LOCK_DPC(pVc);
		
		RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		RELEASE_ELAN_ATM_LIST_LOCK(pElan);

		//
		//	loop until no more packets or send limit reached
		//
		do
		{
			//
			//	If no more packets to send then done
			//
			if (pMacEntry->PacketList == (PNDIS_PACKET)NULL)
			{
				break;
			}

			//
			//	Check if ok to send a packet now
			//
			if (!AtmLaneOKToBusSend(pMacEntry))
			{
				// 
				//  Not OK to send now, try later
				//
				//	Reference the MAC Entry
				//
				AtmLaneReferenceMacEntry(pMacEntry, "bus timer");
				
				//
				//	Reschedule the timer routine
				//
				pMacEntry->Flags |= MAC_ENTRY_BUS_TIMER;
				NdisSetTimer(&pMacEntry->BusTimer, pMacEntry->IncrTime);	

				break;
			}

			//
			// 	Dequeue a packet
			//
			pNdisPacket = AtmLaneDequeuePacketFromHead(pMacEntry);

			RELEASE_MAC_ENTRY_LOCK(pMacEntry);

			ASSERT(pNdisPacket != (PNDIS_PACKET)NULL);

			//
			//	Reacquire VC lock and if VC still connected send packet
			//
			ACQUIRE_VC_LOCK(pVc);
			if (IS_FLAG_SET(
						pVc->Flags,
						VC_CALL_STATE_MASK,
						VC_CALL_STATE_ACTIVE))
			{
				DBGP((2, "DoBusSends: pVc %x Pkt %x Sending to BUS\n",
					pVc, pNdisPacket));
				AtmLaneSendPacketOnVc(pVc, pNdisPacket, FALSE);
				//
				//	VC lock released in above
				//
				NdisInterlockedIncrement(&pElan->FramesXmitGood);	// count it

				ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
			}
			else
			{
				//
				//	Not sent, release lock, requeue packet, abort
				//
				DBGP((2, "DoBusSend: pVc %x, Flags %x not good, pkt %x\n",
						pVc, pVc->Flags, pNdisPacket));
				RELEASE_VC_LOCK(pVc);

				ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
				AtmLaneQueuePacketOnHead(pMacEntry, pNdisPacket);
				break;
			}

		}
		while (FALSE);

		//
		//	Remove temp VC reference
		//
		if (pVc == NULL_PATMLANE_VC)
		{
			ACQUIRE_VC_LOCK(pVc);
			rc = AtmLaneDereferenceVc(pVc, "temp");
			if (rc > 0)
			{
				RELEASE_VC_LOCK(pVc);
			}
			//
			//	else VC is gone
			//
		}

	}
	while (FALSE);

	//
	//  Remove the temp ref we had added to the MAC entry on entering
	//  this function.
	//
	rc = AtmLaneDereferenceMacEntry(pMacEntry, "DoBusSends");
	if (rc != 0)
	{
		RELEASE_MAC_ENTRY_LOCK(pMacEntry);
	}
	//
	//  else the MAC entry is gone.
	//
	
	TRACEOUT(DoBusSends);
	return;
}

VOID
AtmLaneBusSendTimer(
	IN	PVOID						SystemSpecific1,
	IN	PVOID						pContext,
	IN	PVOID						SystemSpecific2,
	IN	PVOID						SystemSpecific3
)
{
	PATMLANE_MAC_ENTRY			pMacEntry;
	ULONG						rc;
	
	TRACEIN(BusSendTimer);

	pMacEntry = (PATMLANE_MAC_ENTRY)pContext;
	STRUCT_ASSERT(pMacEntry, atmlane_mac);

	do
	{
		//
		// 	Grab the Mac Entry's lock
		//
		ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);

		//
		//	Clear the bus timer flag
		//
		pMacEntry->Flags &= ~ MAC_ENTRY_BUS_TIMER;
		
		//
		//	Dereference the Mac Entry
		//
		rc = AtmLaneDereferenceMacEntry(pMacEntry, "bus timer");
		if (rc == 0)
		{
			break;
		}
		
		//
		//	Mac Entry still here, try to send more
		//
		AtmLaneDoBusSends(pMacEntry);
		//
		//	lock released in above
		//

		break;
		
	}
	while (FALSE);

	TRACEOUT(BusSendTimer);
	return;
}


BOOLEAN
AtmLaneOKToBusSend(
	IN	PATMLANE_MAC_ENTRY		pMacEntry
)
/*++

Routine Description:

	Determines if, at the current time, it is OK to send
	a packet to the BUS.  Additionally, if it is OK to send
	a packet, it updates the state variables in the MAC Entry
	in preparation for another attempt to send a packet to
	the Bus.

	The LANE spec requires a LANE client to restrict the
	sending of packets over the BUS to a specific LAN
	destination address	by using two parameters:
		Maximum Unknown Packet Count
		Maximum Unknown Packet Time
	A LANE client can only send "Maximum Unknown Packet Count"
	packets within the period of time "Maximum Unknown Packet 
	Time".  

	This function expects the MAC Entry to contain three
	variables:
    	BusyTime
    	LimitTime
    	IncrTime
			
Arguments:

	pMacEntry			- Pointer to an ATMLANE MAC Entry.

Return Value:

	TRUE				- if ok to send packet on BUS
	FALSE				- if exceeded traffic to the BUS

--*/
{
    ULONG	Now;
    ULONG	BusyTime;
    LONG	TimeUntilIdle;

    Now = AtmLaneSystemTimeMs();
    BusyTime = pMacEntry->BusyTime;
    TimeUntilIdle = BusyTime - Now;

	//
    // bring busy until time up to current; also handles
    // wrapping.  Under normal circumstances, TimeUntilIdle
    // is either < 0 or no more than limitTime + incrtime.
    // The value of limitTime * 8 is a little more conservative and
    // cheaper to compute.
    //
    if (TimeUntilIdle < 0 || 
    	TimeUntilIdle > (LONG)(pMacEntry->LimitTime << 3))
    {
		BusyTime = Now;
    }
    else 
    {
    	if (TimeUntilIdle > (LONG)pMacEntry->LimitTime) 
    	{
    		//
			// channel is already estimated to be busy until past
			// the burst time, so we can't overload it by sending
	 		// more now.
	 		//
		return FALSE;
    	}
    }
    
	//
    // mark channel as busy for another inter-packet arrival
    // time, and return OK to send the new packet.
    //
    pMacEntry->BusyTime = BusyTime + pMacEntry->IncrTime;
    return TRUE;
}



VOID
AtmLaneFreePacketQueue(
	IN	PATMLANE_MAC_ENTRY			pMacEntry,
	IN	NDIS_STATUS					Status
)
/*++

Routine Description:

	Frees the list of packets queued on a MAC Entry.
	Assumes caller holds lock on MAC Entry.

Arguments:

	pMacEntry			- Pointer to MAC Entry.
	Status				- The status to use if the packet is
						  protocol packet.

Return Value:

	None

--*/
{
	PNDIS_PACKET			pNdisPacket;

	TRACEIN(FreePacketQueue);
	
	while ((pNdisPacket = AtmLaneDequeuePacketFromHead(pMacEntry)) != (PNDIS_PACKET)NULL)
	{
		RELEASE_MAC_ENTRY_LOCK(pMacEntry);

#if PROTECT_PACKETS		
		ACQUIRE_SENDPACKET_LOCK(pNdisPacket);
		PSEND_RSVD(pNdisPacket)->Flags |= PACKET_RESERVED_COSENDRETURNED;
		PSEND_RSVD(pNdisPacket)->Flags |= PACKET_RESERVED_COMPLETED;
#endif	// PROTECT_PACKETS
		AtmLaneCompleteSendPacket(pMacEntry->pElan, pNdisPacket, Status);
		//
		//	packet lock released in above
		//
	
		ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
	}

	TRACEOUT(FreePacketQueue);
	return;
}

VOID
AtmLaneCompleteSendPacket(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_PACKET				pNdisPacket 	LOCKIN NOLOCKOUT,
	IN	NDIS_STATUS					Status
)
/*++

Routine Description:

	Complete a send packet. The packet is one of the following types:
	(a) Belonging to a protocol (b) Belonging to the ATMLANE module. 
	In the case	of a protocol packet we unwrap it and complete it.
	In the case of an ATMLANE packet we just free it.

Arguments:

	pElan				- Pointer to ATMLANE Elan.
	pNdisPacket			- Pointer to the packet
	Status				- The status to use if the packet is
						  protocol packet.

Return Value:

	None

--*/
{
	PNDIS_BUFFER			pNdisBuffer;
	PNDIS_PACKET			pProtNdisPacket;

	TRACEIN(CompleteSendPacket);

#if PROTECT_PACKETS
	//
	//	Assert that we can release and/or complete all resources for this packet
	//
	ASSERT((PSEND_RSVD(pNdisPacket)->Flags & 
			(PACKET_RESERVED_COMPLETED | PACKET_RESERVED_COSENDRETURNED)) 
			== (PACKET_RESERVED_COMPLETED | PACKET_RESERVED_COSENDRETURNED));
#endif	// PROTECT_PACKETS

	//
	//	Determine originator of packet
	//
	if (IS_FLAG_SET(
				PSEND_RSVD(pNdisPacket)->Flags,
				PACKET_RESERVED_OWNER_MASK,
				PACKET_RESERVED_OWNER_ATMLANE
				))
	{
		//
		//  Packet originated by ATMLANE.  Free the buffer.
		//
		NdisUnchainBufferAtFront(pNdisPacket, &pNdisBuffer);
		ASSERT(NULL != pNdisBuffer);
		AtmLaneFreeProtoBuffer(pElan, pNdisBuffer);
		
		//
		//	Free the packet header.
		//
		DBGP((3, "CompleteSendPkt: Freeing AtmLane owned pkt %x\n", pNdisPacket));
#if PROTECT_PACKETS
		RELEASE_SENDPACKET_LOCK(pNdisPacket);
		FREE_SENDPACKET_LOCK(pNdisPacket);
#endif	// PROTECT_PACKETS
		NdisFreePacket(pNdisPacket);

#if PKT_HDR_COUNTS
		InterlockedIncrement(&pElan->ProtPktCount);
		if ((pElan->ProtPktCount % 20) == 0 && 
			pElan->ProtPktCount != pElan->MaxProtocolBufs)
		{
			DBGP((1, "ProtPktCount %d\n", pElan->ProtPktCount));
		}
#endif
	}
	else
	{
		//
		//	Packet orignated by a protocol. 
		//	Unwrap it.
		//	Complete it to the protocol.
		//	

		pProtNdisPacket = AtmLaneUnwrapSendPacket(pElan, pNdisPacket);
		//
		//	packet lock released in above
		//

		TRACELOGWRITE((&TraceLog, TL_MSENDCOMPL, pProtNdisPacket, Status));
		TRACELOGWRITEPKT((&TraceLog, pProtNdisPacket));

		// DBGP((0, "NdisMSendComplete: Pkt %x Stat %x\n", pProtNdisPacket, Status));

		NdisMSendComplete(
					pElan->MiniportAdapterHandle, 
					pProtNdisPacket, 
					Status);
	}

	TRACEOUT(CompleteSendPacket);
	return;
}


PWSTR
AtmLaneMacAddrToString(
	IN	VOID * pIn
)
{
    static PWSTR 	WHexChars = L"0123456789abcdef";
	PWSTR 			StrBuf;
	ULONG			Index;
	PWSTR			pWStr;
	PUCHAR			pMacAddr;
	PWSTR			punicodeMacAddrBuffer = ((PWSTR)0);

	UNICODE_STRING	unicodeString;
	ANSI_STRING 	ansiString;
	
	TRACEIN(MacAddrToString);

	//	alloc space for output unicode string

	ALLOC_MEM(&punicodeMacAddrBuffer, (((sizeof(MAC_ADDRESS) * 2) + 1) * sizeof(WCHAR)));

	if (((PWSTR)0) != punicodeMacAddrBuffer)
	{
    	for (Index = 0, pWStr = punicodeMacAddrBuffer, pMacAddr = pIn; 
    		Index < sizeof(MAC_ADDRESS); 
    		Index++, pMacAddr++)
        {
        	*pWStr++ = WHexChars[(*pMacAddr)>>4];
	        *pWStr++ = WHexChars[(*pMacAddr)&0xf];
	    }

	    *pWStr = L'\0';
	}

	TRACEOUT(MacAddrToString);
	
	return punicodeMacAddrBuffer;
}


PWSTR
AtmLaneAtmAddrToString(
	IN	PATM_ADDRESS pIn
)
{
    static PWSTR 	WHexChars = L"0123456789abcdef";
	PWSTR 			StrBuf;
	ULONG			Index;
	PWSTR			pWStr;
	PUCHAR			pAtmAddr;
	PWSTR			punicodeAtmAddrBuffer = ((PWSTR)0);

	UNICODE_STRING	unicodeString;
	ANSI_STRING 	ansiString;
	
	TRACEIN(AtmAddrToString);

	//	alloc space for output unicode string
	
	ALLOC_MEM(&punicodeAtmAddrBuffer, (((ATM_ADDRESS_LENGTH * 2) + 1) * sizeof(WCHAR)));

	if (((PWSTR)0) != punicodeAtmAddrBuffer)
	{
		//	format ATM addr into Unicode string buffer

    	for (Index = 0, pWStr = punicodeAtmAddrBuffer, pAtmAddr = pIn->Address; 
    		Index < pIn->NumberOfDigits;
    		Index++, pAtmAddr++)
        {
        	*pWStr++ = WHexChars[(*pAtmAddr)>>4];
	        *pWStr++ = WHexChars[(*pAtmAddr)&0xf];
	    }

	    *pWStr = L'\0';
	}

	TRACEOUT(AtmAddrToString);
	
	return punicodeAtmAddrBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\macros.h ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

    macros.h

Abstract:

	Macros for the ATMLANE module

Author:


Revision History:

--*/
#ifndef __ATMLANE_MACROS_H
#define __ATMLANE_MACROS_H

#include "atmlane.h"

#ifndef LOCKIN
#define LOCKIN
#endif

#ifndef NOLOCKOUT
#define NOLOCKOUT
#endif

#define NULL_NDIS_HANDLE	((NDIS_HANDLE)NULL)

#ifndef MAX

/*++
OPAQUE
MAX(
	IN	OPAQUE		Fred,
	IN	OPAQUE		Shred
)
--*/
#define MAX(Fred, Shred)		(((Fred) > (Shred)) ? (Fred) : (Shred))

#endif // MAX


#ifndef MIN

/*++
OPAQUE
MIN(
	IN	OPAQUE		Fred,
	IN	OPAQUE		Shred
)
--*/
#define MIN(Fred, Shred)		(((Fred) < (Shred)) ? (Fred) : (Shred))

#endif // MIN

#define ROUND_OFF(_size)		(((_size) + 7) & ~0x7)

/*++
ULONG
ATMLANE_HASH(
	IN	PMAC_ADDRESS	pMacAddress
)
--*/
#define ATMLANE_HASH(pMacAddress)	\
			((ULONG)(pMacAddress)->Byte[4])

/*++
BOOLEAN
MAC_ADDR_EQUAL(
	IN	PMAC_ADDRESS	pMacAddr1,
	IN 	PMAC_ADDRESS	pMacAddr2
)
--*/
#define MAC_ADDR_EQUAL(_pMac1, _pMac2)                            \
			((*(ULONG UNALIGNED *)&((PUCHAR)(_pMac1))[2] ==       \
			  *(ULONG UNALIGNED *)&((PUCHAR)(_pMac2))[2])    &&   \
			 (*(USHORT UNALIGNED *)(_pMac1) ==                    \
			  *(USHORT UNALIGNED *)(_pMac2)))

/*++
VOID
SET_FLAG(
	IN	ULONG		Flags,
	IN	ULONG		Mask,
	IN	ULONG		Val
)
--*/
#define SET_FLAG(Flags, Mask, Val)	\
			(Flags) = ((Flags) & ~(Mask)) | (Val)


/*++
BOOLEAN
IS_FLAG_SET(
	IN	ULONG		Flags,
	IN	ULONG		Mask,
	IN	ULONG		Val
)
--*/
#define IS_FLAG_SET(Flags, Mask, Val)	\
			(((Flags) & (Mask)) == (Val))

// ----------------------------------------------------------------------------

/*++
VOID
INIT_BLOCK_STRUCT(
	IN	ATMLANE_BLOCK	*pBlock
)
--*/
#define INIT_BLOCK_STRUCT(pBlock)		NdisInitializeEvent(&((pBlock)->Event))


/*++
NDIS_STATUS
WAIT_ON_BLOCK_STRUCT(
	IN	ATMLANE_BLOCK	*pBlock
)
--*/
#define WAIT_ON_BLOCK_STRUCT(pBlock)		\
			(NdisWaitEvent(&((pBlock)->Event), 0), (pBlock)->Status)


/*++
VOID
SIGNAL_BLOCK_STRUCT(
	IN	ATMLANE_BLOCK	*pBlock,
	IN	UINT			Status
)
--*/
#define SIGNAL_BLOCK_STRUCT(pBlock, _Status)	\
			{ (pBlock)->Status = _Status; NdisSetEvent(&((pBlock)->Event)); }


/*++
VOID
FREE_BLOCK_STRUCT(
	IN	ATMLANE_BLOCK	*pBlock
)
--*/
#define FREE_BLOCK_STRUCT(pBlock)		// Nothing to be done here

// ----------------------------------------------------------------------------

/*++
VOID
INIT_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_LOCK(pLock, Str)	\
				AtmLaneAllocateSpinLock(pLock, Str, __FILE__, __LINE__)
#else
#define INIT_LOCK(pLock)	\
				NdisAllocateSpinLock(pLock)
#endif // DEBUG_SPIN_LOCK


/*++
VOID
ACQUIRE_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock,
	IN	PUCHAR				Str
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_LOCK(pLock, Str)	\
				AtmLaneAcquireSpinLock(pLock, Str, __FILE__, __LINE__)
#else
#define ACQUIRE_LOCK(pLock)	\
				NdisAcquireSpinLock(pLock)
#endif // DEBUG_SPIN_LOCK


/*++
VOID
ACQUIRE_LOCK_DPC(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_LOCK_DPC(pLock, Str)	\
				AtmLaneAcquireSpinLock(pLock, Str"-dpc", __FILE__, __LINE__)
#else
#define ACQUIRE_LOCK_DPC(pLock)	\
				NdisDprAcquireSpinLock(pLock)
#endif // DEBUG_SPIN_LOCK


/*++
VOID
RELEASE_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock,
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_LOCK(pLock, Str)		\
				AtmLaneReleaseSpinLock(pLock, Str, __FILE__, __LINE__)
#else
#define RELEASE_LOCK(pLock)		\
				NdisReleaseSpinLock(pLock)
#endif // DEBUG_SPIN_LOCK


/*++
VOID
RELEASE_LOCK_DPC(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_LOCK_DPC(pLock, Str)		\
				AtmLaneReleaseSpinLock(pLock, Str"-dpc", __FILE__, __LINE__)
#else
#define RELEASE_LOCK_DPC(pLock)		\
				NdisDprReleaseSpinLock(pLock)
#endif // DEBUG_SPIN_LOCK


/*++
VOID
FREE_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_LOCK(pLock, Str)		\
				AtmLaneFreeSpinLock(pLock, Str, __FILE__, __LINE__)
#else
#define FREE_LOCK(pLock)			\
				NdisFreeSpinLock(pLock)
#endif

// ----------------------------------------------------------------------------

/*++
VOID
INIT_ADAPTER_LOCK(
	IN PATMLANE_ADAPTER	pAdapter
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_ADAPTER_LOCK(pAdapter)		\
				INIT_LOCK(&((pAdapter)->AdapterLock), "adapter")
#else
#define INIT_ADAPTER_LOCK(pAdapter)		\
				INIT_LOCK(&((pAdapter)->AdapterLock))
#endif

/*++
VOID
ACQUIRE_ADAPTER_LOCK(
	IN PATMLANE_ELAN	pAdapter
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ADAPTER_LOCK(pAdapter)		\
				ACQUIRE_LOCK(&((pAdapter)->AdapterLock), "adapter")
#else
#define ACQUIRE_ADAPTER_LOCK(pAdapter)		\
				ACQUIRE_LOCK(&((pAdapter)->AdapterLock))
#endif

/*++
VOID
ACQUIRE_ADAPTER_LOCK_DPC(
	IN PATMLANE_ELAN	pAdapter
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ADAPTER_LOCK_DPC(pAdapter)		\
				ACQUIRE_LOCK_DPC(&((pAdapter)->AdapterLock), "adapter")
#else
#define ACQUIRE_ADAPTER_LOCK_DPC(pAdapter)		\
				ACQUIRE_LOCK_DPC(&((pAdapter)->AdapterLock))
#endif


/*++
VOID
RELEASE_ADAPTER_LOCK(
	IN PATMLANE_ELAN	pAdapter
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ADAPTER_LOCK(pAdapter)		\
				RELEASE_LOCK(&((pAdapter)->AdapterLock), "adapter")
#else
#define RELEASE_ADAPTER_LOCK(pAdapter)		\
				RELEASE_LOCK(&((pAdapter)->AdapterLock))
#endif


/*++
VOID
RELEASE_ADAPTER_LOCK_DPC(
	IN PATMLANE_ELAN	pAdapter
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ADAPTER_LOCK_DPC(pAdapter)		\
				RELEASE_LOCK_DPC(&((pAdapter)->AdapterLock), "adapter")
#else
#define RELEASE_ADAPTER_LOCK_DPC(pAdapter)		\
				RELEASE_LOCK_DPC(&((pAdapter)->AdapterLock))
#endif


/*++
VOID
FREE_ADAPTER_LOCK(
	IN	PATMLANE_ELAN	pAdapter
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_ADAPTER_LOCK(pAdapter)	\
				FREE_LOCK(&((pAdapter)->AdapterLock), "adapter")
#else
#define FREE_ADAPTER_LOCK(pAdapter)	\
				FREE_LOCK(&((pAdapter)->AdapterLock))
#endif

// ----------------------------------------------------------------------------

/*++
VOID
INIT_ELAN_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_ELAN_LOCK(pElan)		\
				INIT_LOCK(&((pElan)->ElanLock), "elan")
#else
#define INIT_ELAN_LOCK(pElan)		\
				INIT_LOCK(&((pElan)->ElanLock))
#endif

/*++
VOID
ACQUIRE_ELAN_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ELAN_LOCK(pElan)		\
				ACQUIRE_LOCK(&((pElan)->ElanLock), "elan")
#else
#define ACQUIRE_ELAN_LOCK(pElan)		\
				ACQUIRE_LOCK(&((pElan)->ElanLock))
#endif


/*++
VOID
ACQUIRE_ELAN_LOCK_DPC(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ELAN_LOCK_DPC(pElan)		\
				ACQUIRE_LOCK_DPC(&((pElan)->ElanLock), "elan")
#else
#define ACQUIRE_ELAN_LOCK_DPC(pElan)		\
				ACQUIRE_LOCK_DPC(&((pElan)->ElanLock))
#endif


/*++
VOID
RELEASE_ELAN_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ELAN_LOCK(pElan)		\
				RELEASE_LOCK(&((pElan)->ElanLock), "elan")
#else
#define RELEASE_ELAN_LOCK(pElan)		\
				RELEASE_LOCK(&((pElan)->ElanLock))
#endif


/*++
VOID
RELEASE_ELAN_LOCK_DPC(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ELAN_LOCK_DPC(pElan)		\
				RELEASE_LOCK_DPC(&((pElan)->ElanLock), "elan")
#else
#define RELEASE_ELAN_LOCK_DPC(pElan)		\
				RELEASE_LOCK_DPC(&((pElan)->ElanLock))
#endif


/*++
VOID
FREE_ELAN_LOCK(
	IN	PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_ELAN_LOCK(pElan)	\
				FREE_LOCK(&((pElan)->ElanLock), "elan")
#else
#define FREE_ELAN_LOCK(pElan)	\
				FREE_LOCK(&((pElan)->ElanLock))
#endif

// ----------------------------------------------------------------------------

/*++
VOID
INIT_HEADER_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_HEADER_LOCK(pElan)		\
				INIT_LOCK(&((pElan)->HeaderBufferLock), "header")
#else
#define INIT_HEADER_LOCK(pElan)		\
				INIT_LOCK(&((pElan)->HeaderBufferLock))
#endif

/*++
VOID
ACQUIRE_HEADER_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_HEADER_LOCK(pElan)		\
				ACQUIRE_LOCK(&((pElan)->HeaderBufferLock), "header")
#else
#define ACQUIRE_HEADER_LOCK(pElan)		\
				ACQUIRE_LOCK(&((pElan)->HeaderBufferLock))
#endif


/*++
VOID
ACQUIRE_HEADER_LOCK_DPC(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_HEADER_LOCK_DPC(pElan)		\
				ACQUIRE_LOCK_DPC(&((pElan)->HeaderBufferLock), "header")
#else
#define ACQUIRE_HEADER_LOCK_DPC(pElan)		\
				ACQUIRE_LOCK_DPC(&((pElan)->HeaderBufferLock))
#endif


/*++
VOID
RELEASE_HEADER_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_HEADER_LOCK(pElan)		\
				RELEASE_LOCK(&((pElan)->HeaderBufferLock), "header")
#else
#define RELEASE_HEADER_LOCK(pElan)		\
				RELEASE_LOCK(&((pElan)->HeaderBufferLock))
#endif


/*++
VOID
RELEASE_HEADER_LOCK_DPC(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_HEADER_LOCK_DPC(pElan)		\
				RELEASE_LOCK_DPC(&((pElan)->HeaderBufferLock), "header")
#else
#define RELEASE_HEADER_LOCK_DPC(pElan)		\
				RELEASE_LOCK_DPC(&((pElan)->HeaderBufferLock))
#endif


/*++
VOID
FREE_HEADER_LOCK(
	IN	PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_HEADER_LOCK(pElan)	\
				FREE_LOCK(&((pElan)->HeaderBufferLock), "header")
#else
#define FREE_HEADER_LOCK(pElan)	\
				FREE_LOCK(&((pElan)->HeaderBufferLock))
#endif

// ----------------------------------------------------------------------------

/*++
VOID
INIT_ELAN_TIMER_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_ELAN_TIMER_LOCK(pElan)		\
				INIT_LOCK(&((pElan)->TimerLock), "timer")
#else
#define INIT_ELAN_TIMER_LOCK(pElan)		\
				INIT_LOCK(&((pElan)->TimerLock))
#endif

/*++
VOID
ACQUIRE_ELAN_TIMER_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ELAN_TIMER_LOCK(pElan)		\
				ACQUIRE_LOCK(&((pElan)->TimerLock), "timer")
#else
#define ACQUIRE_ELAN_TIMER_LOCK(pElan)		\
				ACQUIRE_LOCK(&((pElan)->TimerLock))
#endif

/*++
VOID
ACQUIRE_ELAN_TIMER_LOCK_DPC(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ELAN_TIMER_LOCK_DPC(pElan)		\
				ACQUIRE_LOCK_DPC(&((pElan)->TimerLock), "timer")
#else
#define ACQUIRE_ELAN_TIMER_LOCK_DPC(pElan)		\
				ACQUIRE_LOCK_DPC(&((pElan)->TimerLock))
#endif

/*++
VOID
RELEASE_ELAN_TIMER_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ELAN_TIMER_LOCK(pElan)		\
				RELEASE_LOCK(&((pElan)->TimerLock), "timer")
#else
#define RELEASE_ELAN_TIMER_LOCK(pElan)		\
				RELEASE_LOCK(&((pElan)->TimerLock))
#endif

/*++
VOID
RELEASE_ELAN_TIMER_LOCK_DPC(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ELAN_TIMER_LOCK_DPC(pElan)		\
				RELEASE_LOCK_DPC(&((pElan)->TimerLock), "timer")
#else
#define RELEASE_ELAN_TIMER_LOCK_DPC(pElan)		\
				RELEASE_LOCK_DPC(&((pElan)->TimerLock))
#endif


/*++
VOID
FREE_ELAN_TIMER_LOCK(
	IN	PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_ELAN_TIMER_LOCK(pElan)	\
				FREE_LOCK(&((pElan)->TimerLock), "timer")
#else
#define FREE_ELAN_TIMER_LOCK(pElan)	\
				FREE_LOCK(&((pElan)->TimerLock))
#endif
// ----------------------------------------------------------------------------

/*++
VOID
INIT_ATM_ENTRY_LOCK(
	IN PATMLANE_ATM_ENTRY	pAe
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_ATM_ENTRY_LOCK(pAe)		\
				INIT_LOCK(&((pAe)->AeLock), "atmentry")
#else
#define INIT_ATM_ENTRY_LOCK(pAe)		\
				INIT_LOCK(&((pAe)->AeLock))
#endif

/*++
VOID
ACQUIRE_ATM_ENTRY_LOCK(
	IN PATMLANE_ATM_ENTRY	pAe
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ATM_ENTRY_LOCK(pAe)		\
				ACQUIRE_LOCK(&((pAe)->AeLock), "atmentry")
#else
#define ACQUIRE_ATM_ENTRY_LOCK(pAe)		\
				ACQUIRE_LOCK(&((pAe)->AeLock))
#endif

/*++
VOID
ACQUIRE_ATM_ENTRY_LOCK_DPC(
	IN PATMLANE_ATM_ENTRY	pAe
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ATM_ENTRY_LOCK_DPC(pAe)		\
				ACQUIRE_LOCK_DPC(&((pAe)->AeLock), "atmentry")
#else
#define ACQUIRE_ATM_ENTRY_LOCK_DPC(pAe)		\
				ACQUIRE_LOCK_DPC(&((pAe)->AeLock))
#endif

/*++
VOID
RELEASE_ATM_ENTRY_LOCK(
	IN PATMLANE_ATM_ENTRY	pAe
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ATM_ENTRY_LOCK(pAe)		\
				RELEASE_LOCK(&((pAe)->AeLock), "atmentry")
#else
#define RELEASE_ATM_ENTRY_LOCK(pAe)		\
				RELEASE_LOCK(&((pAe)->AeLock))
#endif

/*++
VOID
RELEASE_ATM_ENTRY_LOCK_DPC(
	IN PATMLANE_ATM_ENTRY	pAe
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ATM_ENTRY_LOCK_DPC(pAe)		\
				RELEASE_LOCK_DPC(&((pAe)->AeLock), "atmentry")
#else
#define RELEASE_ATM_ENTRY_LOCK_DPC(pAe)		\
				RELEASE_LOCK_DPC(&((pAe)->AeLock))
#endif

/*++
VOID
FREE_ATM_ENTRY_LOCK(
	IN PATMLANE_ATM_ENTRY	pAe
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_ATM_ENTRY_LOCK(pAe)		\
				FREE_LOCK(&((pAe)->AeLock), "atmentry")
#else
#define FREE_ATM_ENTRY_LOCK(pAe)		\
				FREE_LOCK(&((pAe)->AeLock))
#endif

// ----------------------------------------------------------------------------

/*++
VOID
INIT_MAC_ENTRY_LOCK(
	IN PATMLANE_ATM_ENTRY	pMe
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_MAC_ENTRY_LOCK(pMe)		\
				INIT_LOCK(&((pMe)->MeLock), "macentry")
#else
#define INIT_MAC_ENTRY_LOCK(pMe)		\
				INIT_LOCK(&((pMe)->MeLock))
#endif

/*++
VOID
ACQUIRE_MAC_ENTRY_LOCK(
	IN PATMLANE_ATM_ENTRY	pMe
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_MAC_ENTRY_LOCK(pMe)		\
				ACQUIRE_LOCK(&((pMe)->MeLock), "macentry")
#else
#define ACQUIRE_MAC_ENTRY_LOCK(pMe)		\
				ACQUIRE_LOCK(&((pMe)->MeLock))
#endif

/*++
VOID
ACQUIRE_MAC_ENTRY_LOCK_DPC(
	IN PATMLANE_ATM_ENTRY	pMe
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_MAC_ENTRY_LOCK_DPC(pMe)		\
				ACQUIRE_LOCK_DPC(&((pMe)->MeLock), "macentry")
#else
#define ACQUIRE_MAC_ENTRY_LOCK_DPC(pMe)		\
				ACQUIRE_LOCK_DPC(&((pMe)->MeLock))
#endif

/*++
VOID
RELEASE_MAC_ENTRY_LOCK(
	IN PATMLANE_ATM_ENTRY	pMe
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_MAC_ENTRY_LOCK(pMe)		\
				RELEASE_LOCK(&((pMe)->MeLock), "macentry")
#else
#define RELEASE_MAC_ENTRY_LOCK(pMe)		\
				RELEASE_LOCK(&((pMe)->MeLock))
#endif

/*++
VOID
RELEASE_MAC_ENTRY_LOCK_DPC(
	IN PATMLANE_ATM_ENTRY	pMe
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_MAC_ENTRY_LOCK_DPC(pMe)		\
				RELEASE_LOCK_DPC(&((pMe)->MeLock), "macentry")
#else
#define RELEASE_MAC_ENTRY_LOCK_DPC(pMe)		\
				RELEASE_LOCK_DPC(&((pMe)->MeLock))
#endif

/*++
VOID
FREE_MAC_ENTRY_LOCK(
	IN PATMLANE_ATM_ENTRY	pMe
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_MAC_ENTRY_LOCK(pMe)		\
				FREE_LOCK(&((pMe)->MeLock), "macentry")
#else
#define FREE_MAC_ENTRY_LOCK(pMe)		\
				FREE_LOCK(&((pMe)->MeLock))
#endif
				
// ----------------------------------------------------------------------------

/*++
VOID
INIT_ELAN_ATM_LIST_LOCK(
	IN PATMARP_INTERFACE	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_ELAN_ATM_LIST_LOCK(pElan)		\
				INIT_LOCK(&((pElan)->AtmEntryListLock), "atmlist")
#else
#define INIT_ELAN_ATM_LIST_LOCK(pElan)		\
				INIT_LOCK(&((pElan)->AtmEntryListLock))
#endif

/*++
VOID
ACQUIRE_ELAN_ATM_LIST_LOCK(
	IN PATMARP_INTERFACE	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ELAN_ATM_LIST_LOCK(pElan)		\
				ACQUIRE_LOCK(&((pElan)->AtmEntryListLock), "atmlist")
#else
#define ACQUIRE_ELAN_ATM_LIST_LOCK(pElan)		\
				ACQUIRE_LOCK(&((pElan)->AtmEntryListLock))
#endif

/*++
VOID
ACQUIRE_ELAN_ATM_LIST_LOCK_DPC(
	IN PATMARP_INTERFACE	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ELAN_ATM_LIST_LOCK_DPC(pElan)		\
				ACQUIRE_LOCK_DPC(&((pElan)->AtmEntryListLock), "atmlist")
#else
#define ACQUIRE_ELAN_ATM_LIST_LOCK_DPC(pElan)		\
				ACQUIRE_LOCK_DPC(&((pElan)->AtmEntryListLock))
#endif


/*++
VOID
RELEASE_ELAN_ATM_LIST_LOCK(
	IN PATMARP_INTERFACE	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ELAN_ATM_LIST_LOCK(pElan)		\
				RELEASE_LOCK(&((pElan)->AtmEntryListLock), "atmlist")
#else
#define RELEASE_ELAN_ATM_LIST_LOCK(pElan)		\
				RELEASE_LOCK(&((pElan)->AtmEntryListLock))
#endif

/*++
VOID
RELEASE_ELAN_ATM_LIST_LOCK_DPC(
	IN PATMARP_INTERFACE	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ELAN_ATM_LIST_LOCK_DPC(pElan)		\
				RELEASE_LOCK_DPC(&((pElan)->AtmEntryListLock), "atmlist")
#else
#define RELEASE_ELAN_ATM_LIST_LOCK_DPC(pElan)		\
				RELEASE_LOCK_DPC(&((pElan)->AtmEntryListLock))
#endif


/*++
VOID
FREE_ELAN_ATM_LIST_LOCK(
	IN	PATMARP_INTERFACE	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_ELAN_ATM_LIST_LOCK(pElan)	\
				FREE_LOCK(&((pElan)->AtmEntryListLock), "atmlist")
#else
#define FREE_ELAN_ATM_LIST_LOCK(pElan)	\
				FREE_LOCK(&((pElan)->AtmEntryListLock))
#endif

// ----------------------------------------------------------------------------
				
/*++
VOID
INIT_ELAN_MAC_TABLE_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_ELAN_MAC_TABLE_LOCK(pElan)		\
				INIT_LOCK(&((pElan)->MacTableLock), "mactable")
#else
#define INIT_ELAN_MAC_TABLE_LOCK(pElan)		\
				INIT_LOCK(&((pElan)->MacTableLock))
#endif

/*++
VOID
ACQUIRE_ELAN_MAC_TABLE_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan)		\
				ACQUIRE_LOCK(&((pElan)->MacTableLock), "mactable")
#else
#define ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan)		\
				ACQUIRE_LOCK(&((pElan)->MacTableLock))
#endif

/*++
VOID
ACQUIRE_ELAN_MAC_TABLE_LOCK_DPC(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ELAN_MAC_TABLE_LOCK_DPC(pElan)		\
				ACQUIRE_LOCK_DPC(&((pElan)->MacTableLock), "mactable")
#else
#define ACQUIRE_ELAN_MAC_TABLE_LOCK_DPC(pElan)		\
				ACQUIRE_LOCK_DPC(&((pElan)->MacTableLock))
#endif


/*++
VOID
RELEASE_ELAN_MAC_TABLE_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ELAN_MAC_TABLE_LOCK(pElan)		\
				RELEASE_LOCK(&((pElan)->MacTableLock), "mactable")
#else
#define RELEASE_ELAN_MAC_TABLE_LOCK(pElan)		\
				RELEASE_LOCK(&((pElan)->MacTableLock))
#endif

/*++
VOID
RELEASE_ELAN_MAC_TABLE_LOCK_DPC(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ELAN_MAC_TABLE_LOCK_DPC(pElan)		\
				RELEASE_LOCK_DPC(&((pElan)->MacTableLock), "mactable")
#else
#define RELEASE_ELAN_MAC_TABLE_LOCK_DPC(pElan)		\
				RELEASE_LOCK_DPC(&((pElan)->MacTableLock))
#endif


/*++
VOID
FREE_ELAN_MAC_TABLE_LOCK(
	IN	PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_ELAN_MAC_TABLE_LOCK(pElan)	\
				FREE_LOCK(&((pElan)->MacTableLock), "mactable")
#else
#define FREE_ELAN_MAC_TABLE_LOCK(pElan)	\
				FREE_LOCK(&((pElan)->MacTableLock))
#endif

// ----------------------------------------------------------------------------

/*++
VOID
INIT_VC_LOCK(
	IN PATMLANE_VC	pVc
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_VC_LOCK(pVc)		\
				INIT_LOCK(&((pVc)->VcLock), "vc")
#else
#define INIT_VC_LOCK(pVc)		\
				INIT_LOCK(&((pVc)->VcLock))
#endif

/*++
VOID
ACQUIRE_VC_LOCK(
	IN PATMLANE_VC	pVc
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_VC_LOCK(pVc)		\
				ACQUIRE_LOCK(&((pVc)->VcLock), "vc")
#else
#define ACQUIRE_VC_LOCK(pVc)		\
				ACQUIRE_LOCK(&((pVc)->VcLock))
#endif

/*++
VOID
ACQUIRE_VC_LOCK_DPC(
	IN PATMLANE_VC	pVc
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_VC_LOCK_DPC(pVc)		\
				ACQUIRE_LOCK_DPC(&((pVc)->VcLock), "vc")
#else
#define ACQUIRE_VC_LOCK_DPC(pVc)		\
				ACQUIRE_LOCK_DPC(&((pVc)->VcLock))
#endif

/*++
VOID
RELEASE_VC_LOCK(
	IN PATMLANE_VC	pVc
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_VC_LOCK(pVc)		\
				RELEASE_LOCK(&((pVc)->VcLock), "vc")
#else
#define RELEASE_VC_LOCK(pVc)		\
				RELEASE_LOCK(&((pVc)->VcLock))
#endif

/*++
VOID
RELEASE_VC_LOCK_DPC(
	IN PATMLANE_VC	pVc
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_VC_LOCK_DPC(pVc)		\
				RELEASE_LOCK_DPC(&((pVc)->VcLock), "vc")
#else
#define RELEASE_VC_LOCK_DPC(pVc)		\
				RELEASE_LOCK_DPC(&((pVc)->VcLock))
#endif

/*++
VOID
FREE_VC_LOCK(
	IN PATMLANE_VC	pVc
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_VC_LOCK(pVc)		\
				FREE_LOCK(&((pVc)->VcLock), "vc")
#else
#define FREE_VC_LOCK(pVc)		\
				FREE_LOCK(&((pVc)->VcLock))
#endif

// ----------------------------------------------------------------------------

/*++
VOID
INIT_SENDPACKET_LOCK(
	IN PNDIS_PACKET	pPkt
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_SENDPACKET_LOCK(pPkt)		\
				INIT_LOCK(&(PSEND_RSVD(pPkt)->Lock), "packet")
#else
#define INIT_SENDPACKET_LOCK(pPkt)		\
				INIT_LOCK(&(PSEND_RSVD(pPkt)->Lock))
#endif

/*++
VOID
ACQUIRE_SENDPACKET_LOCK(
	IN PNDIS_PACKET	pPkt
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_SENDPACKET_LOCK(pPkt)		\
				ACQUIRE_LOCK(&(PSEND_RSVD(pPkt)->Lock), "packet")
#else
#define ACQUIRE_SENDPACKET_LOCK(pPkt)		\
				ACQUIRE_LOCK(&(PSEND_RSVD(pPkt)->Lock))
#endif

/*++
VOID
RELEASE_SENDPACKET_LOCK(
	IN PNDIS_PACKET	pPkt
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_SENDPACKET_LOCK(pPkt)		\
				RELEASE_LOCK(&(PSEND_RSVD(pPkt)->Lock), "packet")
#else
#define RELEASE_SENDPACKET_LOCK(pPkt)		\
				RELEASE_LOCK(&(PSEND_RSVD(pPkt)->Lock))
#endif

/*++
VOID
FREE_SENDPACKET_LOCK(
	IN PNDIS_PACKET	pPkt
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_SENDPACKET_LOCK(pPkt)		\
				FREE_LOCK(&(PSEND_RSVD(pPkt)->Lock), "packet")
#else
#define FREE_SENDPACKET_LOCK(pPkt)		\
				FREE_LOCK(&(PSEND_RSVD(pPkt)->Lock))
#endif

// ----------------------------------------------------------------------------

/*++
VOID
INIT_GLOBAL_LOCK(
	IN PATMLANE_GLOBALS	pGlob
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_GLOBAL_LOCK(pGlob)		\
				INIT_LOCK(&((pGlob)->GlobalLock), "global")
#else
#define INIT_GLOBAL_LOCK(pGlob)		\
				INIT_LOCK(&((pGlob)->GlobalLock))
#endif

/*++
VOID
ACQUIRE_GLOBAL_LOCK(
	IN PATMLANE_GLOBALS	pGlob
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_GLOBAL_LOCK(pGlob)		\
				ACQUIRE_LOCK(&((pGlob)->GlobalLock), "global")
#else
#define ACQUIRE_GLOBAL_LOCK(pGlob)		\
				ACQUIRE_LOCK(&((pGlob)->GlobalLock))
#endif

/*++
VOID
RELEASE_GLOBAL_LOCK(
	IN PATMLANE_GLOBALS	pGlob
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_GLOBAL_LOCK(pGlob)		\
				RELEASE_LOCK(&((pGlob)->GlobalLock), "global")
#else
#define RELEASE_GLOBAL_LOCK(pGlob)		\
				RELEASE_LOCK(&((pGlob)->GlobalLock))
#endif

/*++
VOID
FREE_GLOBAL_LOCK(
	IN PATMLANE_GLOBALS	pGlob
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_GLOBAL_LOCK(pGlob)		\
				FREE_LOCK(&((pGlob)->GlobalLock), "global")
#else
#define FREE_GLOBAL_LOCK(pGlob)		\
				FREE_LOCK(&((pGlob)->GlobalLock))
#endif

// ----------------------------------------------------------------------------

/*++
VOID *
ALLOC_MEM(
	OUT	PVOID *		pPtr,
	IN	ULONG		SizeInBytes
)
--*/
#if DEBUG_MEMORY_ALLOC
#define ALLOC_MEM(pPtr, SizeInBytes)	\
			AaAuditAllocMem(pPtr,(ULONG)(SizeInBytes),__FILE__,__LINE__)
#else
#define ALLOC_MEM(pPtr, SizeInBytes)	\
			NdisAllocateMemoryWithTag((pPtr), (SizeInBytes), (ULONG)'ENAL')
#endif // DBG


/*++
VOID
FREE_MEM(
	IN	POPAQUE		pMem
)
--*/
#if DEBUG_MEMORY_ALLOC
#define FREE_MEM(pMem)	AaAuditFreeMem((PVOID)(pMem));
#else
#define FREE_MEM(pMem)	NdisFreeMemory((PVOID)(pMem), 0, 0);
#endif // DBG

// ----------------------------------------------------------------------------

/*++
VOID
INIT_SYSTEM_TIMER(
	IN	PNDIS_TIMER			pTimer,
	IN	PNDIS_TIMER_FUNCTON	pFunc,
	IN	PVOID				Context
)
--*/
#define INIT_SYSTEM_TIMER(pTimer, pFunc, Context)	\
			NdisInitializeTimer(pTimer, (PNDIS_TIMER_FUNCTION)(pFunc), (PVOID)Context)



/*++
VOID
START_SYSTEM_TIMER(
	IN	PNDIS_TIMER			pTimer,
	IN	UINT				PeriodInSeconds
)
--*/
#define START_SYSTEM_TIMER(pTimer, PeriodInSeconds)	\
			NdisSetTimer(pTimer, (UINT)(PeriodInSeconds * 1000))


/*++
VOID
STOP_SYSTEM_TIMER(
	IN	PNDIS_TIMER			pTimer
)
--*/
#define STOP_SYSTEM_TIMER(pTimer)						\
			{												\
				BOOLEAN		WasCancelled;					\
				NdisCancelTimer(pTimer, &WasCancelled);		\
			}

/*++
BOOLEAN
IS_TIMER_ACTIVE(
	IN	PATMLANE_TIMER		pArpTimer
)
--*/
#define IS_TIMER_ACTIVE(pTmr)	((pTmr)->pTimerList != (PATMLANE_TIMER_LIST)NULL)

	
// ----------------------------------------------------------------------------


/*++
ULONG
SECONDS_TO_LONG_TICKS(
	IN	ULONG				Seconds
)
Convert from seconds to "long duration timer ticks"
--*/
#define SECONDS_TO_LONG_TICKS(Seconds)		((Seconds)/10)


/*++
ULONG
SECONDS_TO_SHORT_TICKS(
	IN	ULONG				Seconds
)
Convert from seconds to "short duration timer ticks"
--*/
#define SECONDS_TO_SHORT_TICKS(Seconds)		(Seconds)

// ----------------------------------------------------------------------------

/*++
VOID
SET_NEXT_PACKET(
	IN	PNDIS_PACKET		pNdisPacket,
	IN	PNDIS_PACKET		pNextPacket
)
--*/
#define SET_NEXT_PACKET(pPkt, pNext) \
		((PSEND_PACKET_RESERVED)((pPkt)->ProtocolReserved))->pNextNdisPacket = pNext;

/*++
PNDIS_PACKET
GET_NEXT_PACKET(
	IN	PNDIS_PACKET		pNdisPacket
)
--*/
#define GET_NEXT_PACKET(pPkt)			\
		((PSEND_PACKET_RESERVED)((pPkt)->ProtocolReserved))->pNextNdisPacket

// ----------------------------------------------------------------------------

/*++
ULONG
CELLS_TO_BYTES(
	IN	ULONG				NumberOfCells
)
Convert from cell count to byte count
--*/
#define CELLS_TO_BYTES(NumberOfCells)	((NumberOfCells) * 48)


/*++
ULONG
BYTES_TO_CELLS(
	IN	ULONG				ByteCount
)
Convert from byte count to cell count
--*/
#define BYTES_TO_CELLS(ByteCount)		((ByteCount) / 48)


/*++
ULONG
LINKSPEED_TO_CPS(
	IN	ULONG				LinkSpeed
)
Convert from NDIS "Link Speed" to cells per second
--*/
#define LINKSPEED_TO_CPS(_LinkSpeed)		(((_LinkSpeed)*100)/(48*8))

// ----------------------------------------------------------------------------

/*++
ULONG
SWAPULONG(
	IN	ULONG	Val
)
--*/
#define SWAPULONG(Val)	\
	((((Val)&0xff)<<24)|(((Val)&0xff00)<<8)| \
	(((Val)&0xff0000)>>8)|(((Val)&0xff000000)>>24))

/*++
USHORT
SWAPUSHORT(
	IN	USHORT	Val
)
--*/
#define SWAPUSHORT(Val)	\
	((((Val) & 0xff) << 8) | (((Val) & 0xff00) >> 8))
	
// ----------------------------------------------------------------------------

/*++
BOOLEAN
ATM_ADDR_EQUAL(
	IN	PUCHAR Addr1,
	IN	PUCHAR Addr2
)
--*/
#define ATM_ADDR_EQUAL(_Addr1, _Addr2) \
	NdisEqualMemory((_Addr1), (_Addr2), ATM_ADDRESS_LENGTH)

/*++
BOOLEAN
ETH_ADDR_MULTICAST(
	IN	PUCHAR	Addr,
)
--*/
#define ETH_ADDR_MULTICAST(_Addr) ((_Addr)[0]&1)

/*++
BOOLEAN
TR_ADDR_MULTICAST(
	IN	PUCHAR	Addr,
)
--*/
#define TR_ADDR_MULTICAST(_Addr) ((_Addr)[0]&0x80)

// ----------------------------------------------------------------------------

#endif // __ATMLANE_MACROS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\precomp.h ===
#include <ndis.h>
#include <atm.h>

#include "tracelog.h"
#include "lane10.h"
#include "debug.h"
#include "event.h"
#include "atmlane.h"
#include "laneinfo.h"
#include "macros.h"
#include "externs.h"
#include "netevent.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\space.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	space.c

Abstract:

	This file contains global definitions.

Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  Global Info structure. Initialized in DriverEntry (ntentry.c).
// 
ATMLANE_GLOBALS		gAtmLaneGlobalInfo;
PATMLANE_GLOBALS	pAtmLaneGlobalInfo = &gAtmLaneGlobalInfo;


//
//	The well-know ATM address for the LECS.
//
ATM_ADDRESS 		gWellKnownLecsAddress = 
{
	ATM_NSAP,						// type
	20,								// num digits
	{								// address bytes
	0x47, 0x00, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xa0, 0x3e, 0x00, 0x00, 0x01, 0x00
    }
};

MAC_ADDRESS			gMacBroadcastAddress =
{
	0xff,0xff,0xff,0xff,0xff,0xff
};

//
//  Max timeout value (in seconds) for each class.
//
ULONG	AtmLaneMaxTimerValue[ALT_CLASS_MAX] =
						{
							ALT_MAX_TIMER_SHORT_DURATION,
							ALT_MAX_TIMER_LONG_DURATION
						};

//
//  Size of each timer wheel.
//
ULONG	AtmLaneTimerListSize[ALT_CLASS_MAX] =
						{
							SECONDS_TO_SHORT_TICKS(ALT_MAX_TIMER_SHORT_DURATION)+1,
							SECONDS_TO_LONG_TICKS(ALT_MAX_TIMER_LONG_DURATION)+1
						};
//
//  Interval between ticks, in seconds, for each class.
//
ULONG	AtmLaneTimerPeriod[ALT_CLASS_MAX] =
						{
							ALT_SHORT_DURATION_TIMER_PERIOD,
							ALT_LONG_DURATION_TIMER_PERIOD
						};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\tracelog.h ===
//
// tracelog.h
//
// Copyright (c) 1996 FORE Systems, Inc.
// All rights reserved.
//
// THIS SOURCE CODE CONTAINS CONFIDENTIAL INFORMATION THAT IS OWNED BY FORE
// SYSTEMS, INC. AND MAY NOT BE COPIED, DISCLOSED OR OTHERWISE USED WITHOUT
// THE EXPRESS WRITTEN CONSENT OF FORE SYSTEMS, INC.
//

#ifndef _FORE_TRACELOG_H_
#define _FORE_TRACELOG_H_

#define MAX_TRACELOG_PARAMS 8

#define TL_GET_PARAM_COUNT(eid)  ((eid)&0xF)
#define TL_GET_EVENT(eid)        ((eid)>>4)
#define TL_BUILD_EVENT_ID(ev,p)  (((ev)<<4)|((p)&0xF))

typedef struct _TraceEntry
	{
	unsigned long EventId;
	unsigned long Time;
	unsigned long  Params[MAX_TRACELOG_PARAMS];
	} TRACEENTRY, *PTRACEENTRY;

typedef struct _TraceLog
	{
	unsigned char *Storage;
	unsigned long StorageSizeBytes;
	PTRACEENTRY First;
	PTRACEENTRY Last;
	PTRACEENTRY Current;
	} TRACELOG, *PTRACELOG;

extern void 
InitTraceLog(PTRACELOG TraceLog, unsigned char *Storage, 
	unsigned long StorageSizeBytes);

extern void 
TraceLogWrite(PTRACELOG TraceLog, unsigned long EventId, ...);

#endif // _FORE_TRACELOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\tracelog.c ===
//
// tracelog.c
//
// Copyright (c) 1996 FORE Systems, Inc.
// All rights reserved.
//
// THIS SOURCE CODE CONTAINS CONFIDENTIAL INFORMATION THAT IS OWNED BY FORE
// SYSTEMS, INC. AND MAY NOT BE COPIED, DISCLOSED OR OTHERWISE USED WITHOUT
// THE EXPRESS WRITTEN CONSENT OF FORE SYSTEMS, INC.
//

#include <precomp.h>
#include <stdlib.h>
#include <stdarg.h>
#pragma hdrstop

void
InitTraceLog(PTRACELOG TraceLog, unsigned char *Storage, 
	unsigned long StorageSizeBytes)
    {
	memset(TraceLog, 0, sizeof(TraceLog));
	if (Storage == NULL)
		return;
	TraceLog->Storage = Storage;
	TraceLog->StorageSizeBytes = StorageSizeBytes;
	TraceLog->First = (PTRACEENTRY)TraceLog->Storage;
	TraceLog->Last  = 
		(PTRACEENTRY) (TraceLog->Storage + 
		((TraceLog->StorageSizeBytes / sizeof(TRACEENTRY)) * sizeof(TRACEENTRY)) -
		sizeof(TRACEENTRY));
	TraceLog->Current = TraceLog->First;
	memset(TraceLog->Storage, 0, TraceLog->StorageSizeBytes);
    }


void
TraceLogWrite(PTRACELOG TraceLog, unsigned long EventId, ...)
	{
	PTRACEENTRY TraceEntry;
	unsigned long ParamCount;
	unsigned long i;
	va_list ap;

	if (TraceLog->Storage == NULL)
		return;
		
	ACQUIRE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

	TraceEntry = TraceLog->Current;

	ParamCount = TL_GET_PARAM_COUNT(EventId);

	memset(TraceEntry, 0, sizeof(TRACEENTRY));

	TraceEntry->EventId = EventId;

	TraceEntry->Time = AtmLaneSystemTimeMs();

	if (ParamCount > 0)
		{
		va_start(ap, EventId);
		for(i = 0; i < ParamCount; i++)
			TraceEntry->Params[i] = va_arg(ap, unsigned long);
		}

	if (TraceLog->Current >= TraceLog->Last)
		TraceLog->Current = TraceLog->First;
	else
		TraceLog->Current++;

	RELEASE_GLOBAL_LOCK(pAtmLaneGlobalInfo);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\oidstrng.h ===
struct _string_table oid_string_table[] = {
    {"OID_GEN_SUPPORTED_LIST",				OID_GEN_SUPPORTED_LIST},
    {"OID_GEN_HARDWARE_STATUS",				OID_GEN_HARDWARE_STATUS},
    {"OID_GEN_MEDIA_SUPPORTED",				OID_GEN_MEDIA_SUPPORTED},
    {"OID_GEN_MEDIA_IN_USE",				OID_GEN_MEDIA_IN_USE},
    {"OID_GEN_MAXIMUM_LOOKAHEAD",			OID_GEN_MAXIMUM_LOOKAHEAD},
    {"OID_GEN_MAXIMUM_FRAME_SIZE",			OID_GEN_MAXIMUM_FRAME_SIZE},
    {"OID_GEN_MAXIMUM_TOTAL_SIZE",			OID_GEN_MAXIMUM_TOTAL_SIZE},
    {"OID_GEN_MAC_OPTIONS",					OID_GEN_MAC_OPTIONS},
    {"OID_GEN_PROTOCOL_OPTIONS",			OID_GEN_PROTOCOL_OPTIONS},
    {"OID_GEN_LINK_SPEED",					OID_GEN_LINK_SPEED},
    {"OID_GEN_TRANSMIT_BUFFER_SPACE",		OID_GEN_TRANSMIT_BUFFER_SPACE},
    {"OID_GEN_RECEIVE_BUFFER_SPACE",		OID_GEN_RECEIVE_BUFFER_SPACE},
    {"OID_GEN_TRANSMIT_BLOCK_SIZE",			OID_GEN_TRANSMIT_BLOCK_SIZE},
    {"OID_GEN_TRANSMIT_QUEUE_LENGTH",		OID_GEN_TRANSMIT_QUEUE_LENGTH},
    {"OID_GEN_RECEIVE_BLOCK_SIZE",			OID_GEN_RECEIVE_BLOCK_SIZE},
    {"OID_GEN_VENDOR_DESCRIPTION",			OID_GEN_VENDOR_DESCRIPTION},
    {"OID_GEN_VENDOR_ID",					OID_GEN_VENDOR_ID},
    {"OID_GEN_DRIVER_VERSION",				OID_GEN_DRIVER_VERSION},
    {"OID_GEN_CURRENT_PACKET_FILTER",		OID_GEN_CURRENT_PACKET_FILTER},
    {"OID_GEN_CURRENT_LOOKAHEAD",			OID_GEN_CURRENT_LOOKAHEAD},
    {"OID_GEN_XMIT_OK",						OID_GEN_XMIT_OK},
    {"OID_GEN_RCV_OK",						OID_GEN_RCV_OK},
    {"OID_GEN_XMIT_ERROR",					OID_GEN_XMIT_ERROR},
    {"OID_GEN_RCV_ERROR",					OID_GEN_RCV_ERROR},
    {"OID_GEN_RCV_NO_BUFFER",				OID_GEN_RCV_NO_BUFFER},
    {"OID_GEN_RCV_CRC_ERROR",				OID_GEN_RCV_CRC_ERROR},
    {"OID_GEN_MAXIMUM_SEND_PACKETS",		OID_GEN_MAXIMUM_SEND_PACKETS},
    {"OID_802_3_PERMANENT_ADDRESS",			OID_802_3_PERMANENT_ADDRESS},
    {"OID_802_3_CURRENT_ADDRESS",			OID_802_3_CURRENT_ADDRESS},
    {"OID_802_3_MULTICAST_LIST",			OID_802_3_MULTICAST_LIST},
    {"OID_802_3_MAXIMUM_LIST_SIZE",			OID_802_3_MAXIMUM_LIST_SIZE},
    {"OID_802_3_RCV_ERROR_ALIGNMENT",		OID_802_3_RCV_ERROR_ALIGNMENT},
    {"OID_802_3_XMIT_ONE_COLLISION",		OID_802_3_XMIT_ONE_COLLISION},
    {"OID_802_3_XMIT_MORE_COLLISIONS",		OID_802_3_XMIT_MORE_COLLISIONS},
    {"OID_802_5_PERMANENT_ADDRESS",			OID_802_5_PERMANENT_ADDRESS},
    {"OID_802_5_CURRENT_ADDRESS",			OID_802_5_CURRENT_ADDRESS},
    {"OID_802_5_CURRENT_FUNCTIONAL",		OID_802_5_CURRENT_FUNCTIONAL},
    {"OID_802_5_CURRENT_GROUP",				OID_802_5_CURRENT_GROUP},
    {"OID_802_5_LAST_OPEN_STATUS",			OID_802_5_LAST_OPEN_STATUS},
    {"OID_802_5_CURRENT_RING_STATUS",		OID_802_5_CURRENT_RING_STATUS},
    {"OID_802_5_CURRENT_RING_STATE",		OID_802_5_CURRENT_RING_STATE},
    {"OID_802_5_LINE_ERRORS",				OID_802_5_LINE_ERRORS},
    {"OID_802_5_LOST_FRAMES",				OID_802_5_LOST_FRAMES},
    {"OID_802_5_BURST_ERRORS",				OID_802_5_BURST_ERRORS},
    {"OID_802_5_FRAME_COPIED_ERRORS",		OID_802_5_FRAME_COPIED_ERRORS},
    {"OID_802_5_TOKEN_ERRORS",				OID_802_5_TOKEN_ERRORS},
    {"*** UNKNOWN OID ***",             	0}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\miniport.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	miniport.c

Abstract:

	Miniport upper-edge functions.
	
Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:

--*/

#include <precomp.h>
#pragma	hdrstop

//
// List of supported OIDs for this driver when an Ethernet Elan.
//
static
NDIS_OID EthernetSupportedOids[] = {
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_CONNECT_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_PROTOCOL_OPTIONS,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_VENDOR_ID,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_VENDOR_DRIVER_VERSION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,
    OID_802_3_MULTICAST_LIST,
    OID_802_3_MAXIMUM_LIST_SIZE,
    OID_802_3_RCV_ERROR_ALIGNMENT,
    OID_802_3_XMIT_ONE_COLLISION,
    OID_802_3_XMIT_MORE_COLLISIONS,
    OID_GEN_NETWORK_LAYER_ADDRESSES,
    };

static
NDIS_OID TokenRingSupportedOids[] = {
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_CONNECT_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_PROTOCOL_OPTIONS,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
 	OID_GEN_MAXIMUM_SEND_PACKETS,
	OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_VENDOR_DRIVER_VERSION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_802_5_PERMANENT_ADDRESS,
    OID_802_5_CURRENT_ADDRESS,
    OID_802_5_CURRENT_FUNCTIONAL,
    OID_802_5_CURRENT_GROUP,
    OID_802_5_LAST_OPEN_STATUS,
    OID_802_5_CURRENT_RING_STATUS,
    OID_802_5_CURRENT_RING_STATE,
    OID_802_5_LINE_ERRORS,
    OID_802_5_LOST_FRAMES,
    OID_802_5_BURST_ERRORS,
    OID_802_5_FRAME_COPIED_ERRORS,
    OID_802_5_TOKEN_ERRORS,
    OID_GEN_NETWORK_LAYER_ADDRESSES,
	};



NDIS_STATUS 
AtmLaneMInitialize(
	OUT	PNDIS_STATUS			OpenErrorStatus,
	OUT	PUINT					SelectedMediumIndex,
	IN	PNDIS_MEDIUM			MediumArray,
	IN	UINT					MediumArraySize,
	IN	NDIS_HANDLE				MiniportAdapterHandle,
	IN	NDIS_HANDLE				WrapperConfigurationContext
)
{
    UINT 					i;
    NDIS_MEDIUM				MediumToFind;
    NDIS_STATUS				Status;
    PATMLANE_ELAN			pElan;
    PUCHAR					pMacAddr;
    UINT					MacAddrLength;
    

	TRACEIN(MInitialize);

	//
	//	Get context (Elan) supplied with NdisIMInitializeDeviceEx
	//
	pElan = NdisIMGetDeviceContext(MiniportAdapterHandle);
	STRUCT_ASSERT(pElan, atmlane_elan);

	ASSERT(pElan->Flags & ELAN_MINIPORT_INIT_PENDING);

	DBGP((1, "%d MInitialize\n", pElan->ElanNumber));

	do
	{
		Status = NDIS_STATUS_SUCCESS;
		
		//
		//	Are we Ethernet or Token Ring?
		//
		if (pElan->LanType == LANE_LANTYPE_ETH)
		{
			MediumToFind = NdisMedium802_3;
		}
		else
		{
			MediumToFind = NdisMedium802_5;
		}
	
		//
		//	Look for MediumToFind in MediumArray.
		//
    	for (i = 0; i < MediumArraySize; i++) 
       	{
        	if (MediumArray[i] == MediumToFind)
            	break;   
        }

		//
		//	Not found, return error.
        
    	if (i == MediumArraySize)
    	{
    		Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
			break;
    	}

		Status = NDIS_STATUS_SUCCESS;

    	//
    	//	Output select medium
    	//
	    *SelectedMediumIndex = i;   

		//
		//	Set my attributes
		//
		NdisMSetAttributesEx(
				MiniportAdapterHandle,					// MiniportAdapterHandle
				(NDIS_HANDLE)pElan,						// MiniportAdapterContext
				0,										// CheckForHangTimeInSeconds
				NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT |	// AttributeFlags
				NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT |
				NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER |
				NDIS_ATTRIBUTE_DESERIALIZE,
				0										// AdapterType
				);

		ACQUIRE_ELAN_LOCK(pElan);
		AtmLaneReferenceElan(pElan, "miniport");

		//
		//  Save away the MiniportAdapterHandle now. This is so that we
		//  don't call NdisMIndicateStatus before calling NdisMSetAttributesEx.
		//
		pElan->MiniportAdapterHandle = MiniportAdapterHandle;
	
		RELEASE_ELAN_LOCK(pElan);

		break;
	}
	while (FALSE);

	//
	//  Wake up any thread (i.e. AtmLaneShutdownElan) waiting for
	//  a pending Init to be over.
	//
	ACQUIRE_ELAN_LOCK(pElan);
	pElan->Flags &= ~ELAN_MINIPORT_INIT_PENDING;
	RELEASE_ELAN_LOCK(pElan);

	DBGP((2, "%d MInitialize ELAN %p/%x, Ref %d, Status %x\n",
			pElan->ElanNumber, pElan, pElan->Flags, pElan->RefCount, Status));

	SIGNAL_BLOCK_STRUCT(&pElan->InitBlock, NDIS_STATUS_SUCCESS);

	TRACEOUT(MInitialize);
	return Status;
}

VOID
AtmLaneMSendPackets(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PPNDIS_PACKET			PacketArray,
	IN	UINT					NumberOfPackets
)
{
	PATMLANE_ELAN		pElan;
	UINT				PacketIndex;
	PNDIS_PACKET		pSendNdisPacket;
	PNDIS_PACKET		pNewNdisPacket;
	PNDIS_BUFFER		pHeaderNdisBuffer;
	PUCHAR				pHeaderBuffer;
	PUCHAR				pPktHeader;
	PNDIS_BUFFER		pTempNdisBuffer;
	PATMLANE_VC			pVc;
	ULONG				TotalLength;
	ULONG				BufferLength;
	NDIS_STATUS			Status;
	ULONG				DestAddrType;
	MAC_ADDRESS			DestAddress;
	BOOLEAN				SendViaBUS;
	PATMLANE_MAC_ENTRY	pMacEntry;
	PATMLANE_ATM_ENTRY	pAtmEntry;
	ULONG				rc;
#if DEBUG_IRQL
	KIRQL				EntryIrql;
#endif

	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(MSendPackets);

	pElan = (PATMLANE_ELAN)MiniportAdapterContext;
	STRUCT_ASSERT(pElan, atmlane_elan);

	TRACELOGWRITE((&TraceLog, TL_MSENDPKTIN, NumberOfPackets));

	DBGP((2, "MSendPackets: Count %d\n", NumberOfPackets));
		
	//
	// loop thru the array of packets to send
	//
	for (PacketIndex = 0; PacketIndex < NumberOfPackets; PacketIndex++)
	{
		pSendNdisPacket = PacketArray[PacketIndex];

		pNewNdisPacket = (PNDIS_PACKET)NULL;
		SendViaBUS = FALSE;
		pMacEntry = NULL_PATMLANE_MAC_ENTRY;
		pVc = NULL_PATMLANE_VC;

		Status = NDIS_STATUS_PENDING;
		
		// DBGP((0, "MSendPackets: Pkt %x\n", pSendNdisPacket));
		
		TRACELOGWRITE((&TraceLog, TL_MSENDPKTBEGIN, PacketIndex, pSendNdisPacket));
		TRACELOGWRITEPKT((&TraceLog, pSendNdisPacket));
		
		//
		//	ALWAYS set packet status to NDIS_STATUS_PENDING
		//
		NDIS_SET_PACKET_STATUS(pSendNdisPacket, NDIS_STATUS_PENDING);

		do
		{
			//
			//	Wrap it up for sending
			//
			pNewNdisPacket = AtmLaneWrapSendPacket(
									pElan, 
									pSendNdisPacket, 
									&DestAddrType,
									&DestAddress, 
									&SendViaBUS
									);
			if (pNewNdisPacket == (PNDIS_PACKET)NULL)
			{
				//
				//	Out of resources
				//			
				Status = NDIS_STATUS_RESOURCES;
				break;
			}

			//
			//	If Elan is down then just set local status to failure
			//
			if (ELAN_STATE_OPERATIONAL != pElan->State ||
				ELAN_STATE_OPERATIONAL != pElan->AdminState)
			{
				DBGP((0, "%d Send failure on ELAN %x flags %x state %d AdminSt %d\n",
						pElan->ElanNumber,
						pElan,
						pElan->Flags,
						pElan->State,
						pElan->AdminState));

				Status = NDIS_STATUS_FAILURE;
				break;
			}

			if (SendViaBUS)
			{
				//
				//	Packet is multicast so send it to the bus
				//
				ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

				pAtmEntry = pElan->pBusAtmEntry;

				if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
				{
					RELEASE_ELAN_ATM_LIST_LOCK(pElan);
					Status = NDIS_STATUS_FAILURE;
					break;
				}

				ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
				pVc = pAtmEntry->pVcList;
				if (pVc == NULL_PATMLANE_VC)
				{
					RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
					RELEASE_ELAN_ATM_LIST_LOCK(pElan);
					Status = NDIS_STATUS_FAILURE;
					break;
				}

				//
				//	Reference the VC to keep it around
				//
				ACQUIRE_VC_LOCK_DPC(pVc);
				AtmLaneReferenceVc(pVc, "temp");
				RELEASE_VC_LOCK_DPC(pVc);
		
				RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
				RELEASE_ELAN_ATM_LIST_LOCK(pElan);


				//
				//	Reacquire VC lock and dereference it
				//
				ACQUIRE_VC_LOCK(pVc);
				rc = AtmLaneDereferenceVc(pVc, "temp");
				if (rc == 0)
				{
					//
					//	Vc pulled out from under us.
					//
					Status = NDIS_STATUS_FAILURE;
					break;
				}

				//
				// Send it!
				//
				DBGP((2, "MSendPackets: Sending to BUS, VC %x\n", pVc));
				AtmLaneSendPacketOnVc(pVc, pNewNdisPacket, FALSE);
				//
				//	VC lock released in above
				//

				break;
			}

			// 
			//	Packet is unicast 
			//
			DBGP((2, "MSendPackets: Sending unicast, dest %x:%x:%x:%x:%x:%x\n", 
						((PUCHAR)&DestAddress)[0],
						((PUCHAR)&DestAddress)[1],
						((PUCHAR)&DestAddress)[2],
						((PUCHAR)&DestAddress)[3],
						((PUCHAR)&DestAddress)[4],
						((PUCHAR)&DestAddress)[5]
						));

			Status = AtmLaneSendUnicastPacket(
							pElan, 
							DestAddrType,
							&DestAddress,
							pNewNdisPacket							
							);

			break;
		}
		while (FALSE);
		
		//
		//	If no new packet header than it must be a resource failure
		//  or Elan is down. 
		//	Complete the packet with NDIS_STATUS_SUCCESS.
		//
		if (pNewNdisPacket == (PNDIS_PACKET)NULL)
		{
			ASSERT(Status != NDIS_STATUS_PENDING);

			// DBGP((0, "NdisMSendComplete: Pkt %x Stat %x\n", pSendNdisPacket, NDIS_STATUS_SUCCESS));

			NdisMSendComplete(
					pElan->MiniportAdapterHandle, 
					pSendNdisPacket, 
					NDIS_STATUS_SUCCESS);

			TRACELOGWRITE((&TraceLog, TL_MSENDPKTEND, PacketIndex, pSendNdisPacket, Status));

			continue;
		}

		//
		//	If status isn't pending then some other failure to send occurred.
		//	Complete the packet with NDIS_STATUS_SUCCESS.
		//
		if (Status != NDIS_STATUS_PENDING)
		{
#if PROTECT_PACKETS
			ACQUIRE_SENDPACKET_LOCK(pNewNdisPacket);
			ASSERT((PSEND_RSVD(pNewNdisPacket)->Flags & PACKET_RESERVED_COSENDRETURNED) == 0);
			ASSERT((PSEND_RSVD(pNewNdisPacket)->Flags & PACKET_RESERVED_COMPLETED) == 0);
			PSEND_RSVD(pNewNdisPacket)->Flags |= PACKET_RESERVED_COSENDRETURNED;			
			PSEND_RSVD(pNewNdisPacket)->Flags |= PACKET_RESERVED_COMPLETED;
#endif	// PROTECT_PACKETS
			AtmLaneCompleteSendPacket(pElan, pNewNdisPacket, NDIS_STATUS_SUCCESS);
			//
			//	packet lock released in above
			//
			TRACELOGWRITE((&TraceLog, TL_MSENDPKTEND, PacketIndex, pSendNdisPacket, Status));
			
			continue;
		}

		//
		//	Otherwise do nothing
		//
		ASSERT(Status == NDIS_STATUS_PENDING);
		TRACELOGWRITE((&TraceLog, TL_MSENDPKTEND, PacketIndex, pSendNdisPacket, Status));
		
	}	// for(...next packet

	TRACELOGWRITE((&TraceLog, TL_MSENDPKTOUT));
	
	TRACEOUT(MSendPackets);

	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneMReturnPacket(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PNDIS_PACKET			pNdisPacket
)
/*++

Routine Description:

	This function is called by a protocol or by NDIS on
	behalf of a protocol to return a packet that was
	retained beyond the context of the receive indication.
	
Arguments:

	MiniportAdapterContext	- Pointer to ATMLANE elan structure

	pNdisPacket				- Pointer to NDIS packet

Return Value:

	none.
	
--*/
{
	PATMLANE_ELAN		pElan;
	PNDIS_PACKET		pOrigNdisPacket;
	PNDIS_BUFFER		pTempNdisBuffer;
	ULONG				Length;
#if DEBUG_IRQL
	KIRQL				EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(MReturnPacket);

	pElan = (PATMLANE_ELAN)MiniportAdapterContext;
	STRUCT_ASSERT(pElan, atmlane_elan);

	TRACELOGWRITE((&TraceLog, 
			TL_MRETNPACKET,	
			pNdisPacket));

	ASSERT(NDIS_GET_PACKET_STATUS(pNdisPacket) != NDIS_STATUS_RESOURCES);

	pOrigNdisPacket = AtmLaneUnwrapRecvPacket(pElan, pNdisPacket);

	TRACELOGWRITE((&TraceLog, 
			TL_CORETNPACKET,	
			pOrigNdisPacket));
			
	//
	//  Return original packet to ATM miniport.
	//
	NdisReturnPackets(
				&pOrigNdisPacket, 
				1);

	TRACEOUT(MReturnPacket);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

NDIS_STATUS 
AtmLaneMQueryInformation(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_OID				Oid,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT	PULONG					BytesWritten,
	OUT	PULONG					BytesNeeded
)
/*++

Routine Description:

    The QueryInformation Handler for the virtual miniport.

Arguments:

    MiniportAdapterContext 	- a pointer to the Elan.

    Oid 					- the NDIS_OID to process.

    InformationBuffer 		- a pointer into the NdisRequest->InformationBuffer
    						  into which store the result of the query.

    InformationBufferLength	- a pointer to the number of bytes left in the
    InformationBuffer.

    BytesWritten 			- a pointer to the number of bytes written into the
    InformationBuffer.

    BytesNeeded 			- If there is not enough room in the information
    						  buffer then this will contain the number of bytes
    						  needed to complete the request.

Return Value:

    The function value is the status of the operation.

--*/
{
    UINT 					BytesLeft 		= InformationBufferLength;
    PUCHAR					InfoBuffer 		= (PUCHAR)(InformationBuffer);
    NDIS_STATUS 			StatusToReturn	= NDIS_STATUS_SUCCESS;
    NDIS_HARDWARE_STATUS	HardwareStatus	= NdisHardwareStatusReady;
    NDIS_MEDIA_STATE		MediaState;
    NDIS_MEDIUM 			Medium;
  	PATMLANE_ELAN			pElan;	
  	PATMLANE_ADAPTER		pAdapter;
    ULONG 					GenericULong;
    USHORT 					GenericUShort;
    UCHAR 					GenericArray[6];
    UINT 					MoveBytes 		= sizeof(ULONG);
    PVOID 					MoveSource 		= (PVOID)(&GenericULong);
	ULONG 					i;
	PATMLANE_MAC_ENTRY		pMacEntry;
	PATMLANE_ATM_ENTRY		pAtmEntry;
	BOOLEAN					IsShuttingDown;
#if DEBUG_IRQL
	KIRQL					EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(MQueryInformation);

	pElan = (PATMLANE_ELAN)MiniportAdapterContext;
	STRUCT_ASSERT(pElan, atmlane_elan);

	DBGP((1, "%d Query OID %x %s\n", pElan->ElanNumber, Oid, OidToString(Oid)));

	ACQUIRE_ELAN_LOCK(pElan);
	IsShuttingDown = (ELAN_STATE_OPERATIONAL != pElan->AdminState);
	pAdapter = pElan->pAdapter;
	RELEASE_ELAN_LOCK(pElan);

    //
    // Switch on request type
    //
    switch (Oid) 
    {
	    case OID_GEN_MAC_OPTIONS:

    	    GenericULong = 						
    	    	NDIS_MAC_OPTION_NO_LOOPBACK;

    	    DBGP((2, "Value %d\n", GenericULong));

        	break;

    	case OID_GEN_SUPPORTED_LIST:

    		if (pElan->LanType == LANE_LANTYPE_ETH)
    		{
	        	MoveSource = (PVOID)(EthernetSupportedOids);
    	    	MoveBytes = sizeof(EthernetSupportedOids);
    	    }
    	    else
    	    {
	        	MoveSource = (PVOID)(TokenRingSupportedOids);
    	    	MoveBytes = sizeof(TokenRingSupportedOids);
    	    }
        	break;

	    case OID_GEN_HARDWARE_STATUS:

    	    HardwareStatus = NdisHardwareStatusReady;
        	MoveSource = (PVOID)(&HardwareStatus);
	        MoveBytes = sizeof(NDIS_HARDWARE_STATUS);

    	    break;

		case OID_GEN_MEDIA_CONNECT_STATUS:
			if (ELAN_STATE_OPERATIONAL == pElan->State)
			{
				MediaState = NdisMediaStateConnected;
			}
			else
			{
				MediaState = NdisMediaStateDisconnected;
			}
			DBGP((2, "%d Elan %p returning conn status %d: %s\n",
						pElan->ElanNumber,
						pElan,
						MediaState,
						((MediaState == NdisMediaStateConnected)?
							"Connected": "Disconnected")));
			MoveSource = (PVOID)(&MediaState);
			MoveBytes = sizeof(NDIS_MEDIA_STATE);

			break;

	    case OID_GEN_MEDIA_SUPPORTED:
	    case OID_GEN_MEDIA_IN_USE:

    		if (pElan->LanType == LANE_LANTYPE_ETH)
    		{
    			Medium = NdisMedium802_3;
    			DBGP((2, "Media is NdisMedium802_3\n"));
    		}
    		else
    		{
    			Medium = NdisMedium802_5;
    			DBGP((2, "Media is NdisMedium802_5\n"));
	   		}
    	    MoveSource = (PVOID) (&Medium);
        	MoveBytes = sizeof(NDIS_MEDIUM);

	        break;

	    case OID_GEN_MAXIMUM_LOOKAHEAD:
	    
    	    if (pAdapter != NULL_PATMLANE_ADAPTER)
    	    {
    	    	GenericULong = pElan->pAdapter->MaxAAL5PacketSize;
    	    }
    	    else
    	    {
    	    	GenericULong = pElan->CurLookAhead;
    	    }
    	    
   			DBGP((2, "Value %d\n", GenericULong));
    	    
        	break;
        	
    	case OID_GEN_CURRENT_LOOKAHEAD:

    		if (pElan->CurLookAhead == 0)
    		{
    			if (pAdapter != NULL_PATMLANE_ADAPTER)
    			{
					pElan->CurLookAhead = pAdapter->MaxAAL5PacketSize;
				}
    		}

    	    GenericULong = pElan->CurLookAhead;
    	    
   			DBGP((2, "Value %d\n", GenericULong));
    	    
        	break;

   		case OID_GEN_MAXIMUM_FRAME_SIZE:

			GenericULong = (pElan->MaxFrameSize - LANE_ETH_HEADERSIZE);
			
   			DBGP((2, "Value %d\n", GenericULong));

        	break;

		case OID_GEN_MAXIMUM_TOTAL_SIZE:

			GenericULong = (pElan->MaxFrameSize - LANE_HEADERSIZE);
			
   			DBGP((2, "Value %d\n", GenericULong));

			break;

    	case OID_GEN_TRANSMIT_BLOCK_SIZE:

			GenericULong = (pElan->MaxFrameSize - LANE_HEADERSIZE);
			
   			DBGP((2, "Value %d\n", GenericULong));

			break;
			
    	case OID_GEN_RECEIVE_BLOCK_SIZE:

			GenericULong = (pElan->MaxFrameSize - LANE_HEADERSIZE);
			
   			DBGP((2, "Value %d\n", GenericULong));

			break;
    	
		case OID_GEN_MAXIMUM_SEND_PACKETS:

			GenericULong = 32;		// XXX What is our limit? From adapter?
			
   			DBGP((2, "Value %d\n", GenericULong));

			break;
		
		case OID_GEN_LINK_SPEED:

        	if (pAdapter != NULL_PATMLANE_ADAPTER)
        	{
        		GenericULong = pElan->pAdapter->LinkSpeed.Outbound;
        	}
        	else
        	{
        		GenericULong = ATM_USER_DATA_RATE_SONET_155;
        	}
			
   			DBGP((2, "Value %d\n", GenericULong));

        	break;

    	case OID_GEN_TRANSMIT_BUFFER_SPACE:
    	case OID_GEN_RECEIVE_BUFFER_SPACE:

        	GenericULong = 32 * 1024;	// XXX What should this really be?
			
   			DBGP((2, "Value %d\n", GenericULong));

        	break;

	    case OID_GEN_VENDOR_ID:

       		NdisMoveMemory(
            	(PVOID)&GenericULong,
            	&pElan->MacAddressEth,
            	3
            	);
        	GenericULong &= 0xFFFFFF00;
        	MoveSource = (PVOID)(&GenericULong);
        	MoveBytes = sizeof(GenericULong);
        	break;

    	case OID_GEN_VENDOR_DESCRIPTION:

        	MoveSource = (PVOID)"Microsoft ATM LAN Emulation";
        	MoveBytes = 28;

        	break;

    	case OID_GEN_DRIVER_VERSION:
    	case OID_GEN_VENDOR_DRIVER_VERSION:

        	GenericUShort = ((USHORT)5 << 8) | 0;
        	MoveSource = (PVOID)(&GenericUShort);
        	MoveBytes = sizeof(GenericUShort);

        	DBGP((2, "Value %x\n", GenericUShort));

        	break;

    	case OID_802_3_PERMANENT_ADDRESS:
    	case OID_802_3_CURRENT_ADDRESS:
    	
        	NdisMoveMemory((PCHAR)GenericArray,
        				&pElan->MacAddressEth,
        				sizeof(MAC_ADDRESS));
        	MoveSource = (PVOID)(GenericArray);
        	MoveBytes = sizeof(MAC_ADDRESS);

        	DBGP((1, "%d Address is %s\n", pElan->ElanNumber, 
        		MacAddrToString(MoveSource)));

        	break;

    	case OID_802_5_PERMANENT_ADDRESS:
    	case OID_802_5_CURRENT_ADDRESS:

        	NdisMoveMemory((PCHAR)GenericArray,
        				&pElan->MacAddressTr,
        				sizeof(MAC_ADDRESS));
        	MoveSource = (PVOID)(GenericArray);
        	MoveBytes = sizeof(MAC_ADDRESS);

        	DBGP((1, "%d Address is %s\n", pElan->ElanNumber,
        		MacAddrToString(MoveSource)));

        	break;

		case OID_802_3_MULTICAST_LIST:

			MoveSource = (PVOID) &pElan->McastAddrs[0];
			MoveBytes = pElan->McastAddrCount * sizeof(MAC_ADDRESS);

			break;

    	case OID_802_3_MAXIMUM_LIST_SIZE:

        	GenericULong = MCAST_LIST_SIZE;
		
   			DBGP((2, "Value %d\n", GenericULong));
        	
        	break;
        	
    	case OID_802_5_CURRENT_FUNCTIONAL:
		case OID_802_5_CURRENT_GROUP:

        	NdisZeroMemory((PCHAR)GenericArray,
        				sizeof(MAC_ADDRESS));
        	MoveSource = (PVOID)(GenericArray);
        	MoveBytes = sizeof(MAC_ADDRESS);

        	DBGP((2, "Address is %s\n", MacAddrToString(MoveSource)));

			break;
			
		case OID_802_5_LAST_OPEN_STATUS:
		case OID_802_5_CURRENT_RING_STATUS:
		case OID_802_5_CURRENT_RING_STATE:

		   	GenericULong = 0;

		   	DBGP((2, "Value %d\n", GenericULong));

        	break;


    	case OID_GEN_XMIT_OK:

        	GenericULong = (UINT)(pElan->FramesXmitGood);

		   	DBGP((2, "Value %d\n", GenericULong));
		   	
        	break;

    	case OID_GEN_RCV_OK:

        	GenericULong = (UINT)(pElan->FramesRecvGood);

		   	DBGP((2, "Value %d\n", GenericULong));
		   	
        	break;

    	case OID_GEN_XMIT_ERROR:
    	case OID_GEN_RCV_ERROR:
    	case OID_GEN_RCV_NO_BUFFER:
    	case OID_802_3_RCV_ERROR_ALIGNMENT:
    	case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
		case OID_802_5_LINE_ERRORS:
    	case OID_802_5_LOST_FRAMES:
    	case OID_802_5_BURST_ERRORS:
    	case OID_802_5_FRAME_COPIED_ERRORS:
    	case OID_802_5_TOKEN_ERRORS:

        	GenericULong = 0;

		   	DBGP((2, "Value %d\n", GenericULong));
        	
        	break;

    	default:

        	StatusToReturn = NDIS_STATUS_INVALID_OID;
        	break;

    }


    if (StatusToReturn == NDIS_STATUS_SUCCESS) 
    {
        if (MoveBytes > BytesLeft) 
        {
            //
            // Not enough room in InformationBuffer. Punt
            //
            *BytesNeeded = MoveBytes;

            *BytesWritten = 0;

            StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
        }
        else
        {
            //
            // Store result.
            //
            NdisMoveMemory(InfoBuffer, MoveSource, MoveBytes);

            *BytesWritten = MoveBytes;
        }
    }

	DBGP((2, "Query Status %x\n", StatusToReturn));

	TRACEOUT(MQueryInformation);
	CHECK_EXIT_IRQL(EntryIrql); 
    return StatusToReturn;
}

NDIS_STATUS 
AtmLaneMSetInformation(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_OID				Oid,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT	PULONG					BytesRead,
	OUT	PULONG					BytesNeeded
)
/*++

Routine Description:

    Handles a set operation for a single OID.

Arguments:

    MiniportAdapterContext 	- a pointer to the Elan.

    Oid 					- the NDIS_OID to process.

    InformationBuffer 		- Holds the data to be set.

    InformationBufferLength - The length of InformationBuffer.

    BytesRead 				- If the call is successful, returns the number
        					  of bytes read from InformationBuffer.

    BytesNeeded 			- If there is not enough data in InformationBuffer
        					  to satisfy the OID, returns the amount of storage
        					  needed.

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING
    NDIS_STATUS_INVALID_LENGTH
    NDIS_STATUS_INVALID_OID

--*/
{
    NDIS_STATUS 		StatusToReturn	= NDIS_STATUS_SUCCESS;
    UINT 				BytesLeft 		= InformationBufferLength;
    PUCHAR 				InfoBuffer		= (PUCHAR)(InformationBuffer);
    UINT 				OidLength;
    ULONG 				LookAhead;
    ULONG 				Filter;
    PATMLANE_ELAN		pElan;
    BOOLEAN				IsShuttingDown;
#if DEBUG_IRQL
	KIRQL				EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);
    
	TRACEIN(MSetInformation);

	pElan = (PATMLANE_ELAN)MiniportAdapterContext;
	STRUCT_ASSERT(pElan, atmlane_elan);
	
	DBGP((1, "%d Set OID %x %s\n", pElan->ElanNumber, Oid, OidToString(Oid)));

	ACQUIRE_ELAN_LOCK(pElan);
	IsShuttingDown = (ELAN_STATE_OPERATIONAL != pElan->AdminState);
	RELEASE_ELAN_LOCK(pElan);

	if (IsShuttingDown)
	{
		DBGP((1, "%d ELAN shutting down. Trivially succeeding Set OID %x %s\n", 
			pElan->ElanNumber, Oid, OidToString(Oid)));
        *BytesRead = 0;
        *BytesNeeded = 0;

		StatusToReturn = NDIS_STATUS_SUCCESS;
		return (StatusToReturn);
	}

    //
    // Get Oid and Length of request
    //
    OidLength = BytesLeft;

    switch (Oid) 
    {

    	case OID_802_3_MULTICAST_LIST:

			if (OidLength % sizeof(MAC_ADDRESS))
			{
				StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
        	    *BytesRead = 0;
    	        *BytesNeeded = 0;
	            break;
			}
			
			if (OidLength > (MCAST_LIST_SIZE * sizeof(MAC_ADDRESS)))
			{
	            StatusToReturn = NDIS_STATUS_MULTICAST_FULL;
        	    *BytesRead = 0;
    	        *BytesNeeded = 0;
	            break;
			}
			
			NdisZeroMemory(
					&pElan->McastAddrs[0], 
					MCAST_LIST_SIZE * sizeof(MAC_ADDRESS)
					);
			NdisMoveMemory(
					&pElan->McastAddrs[0], 
					InfoBuffer,
					OidLength
					);
			pElan->McastAddrCount = OidLength / sizeof(MAC_ADDRESS);

#if DBG
			{
				ULONG i;

				for (i = 0; i < pElan->McastAddrCount; i++)
				{
					DBGP((2, "%s\n", MacAddrToString(&pElan->McastAddrs[i])));
				}
			}
#endif // DBG

			break;

    	case OID_GEN_CURRENT_PACKET_FILTER:
	        //
   	     	// Verify length
   	     	//
        	if (OidLength != sizeof(ULONG)) 
        	{
	            StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
        	    *BytesRead = 0;
    	        *BytesNeeded = sizeof(ULONG);
	            break;
    	    }

	        //
	        // Store the new value.
	        //
			NdisMoveMemory(&Filter, InfoBuffer, sizeof(ULONG));

			//
			// Don't allow promisc mode, because we can't support that.
			//
			if (Filter & NDIS_PACKET_TYPE_PROMISCUOUS)
			{
				StatusToReturn = NDIS_STATUS_NOT_SUPPORTED;
				break;
			}

			ACQUIRE_ELAN_LOCK(pElan);
		
           	pElan->CurPacketFilter = Filter;

			//
			//	Mark Miniport Running if not already
			//
			if ((pElan->Flags & ELAN_MINIPORT_OPERATIONAL) == 0)
			{
				pElan->Flags |= ELAN_MINIPORT_OPERATIONAL;

				DBGP((1, "%d Miniport OPERATIONAL\n", pElan->ElanNumber));
			}
			
			RELEASE_ELAN_LOCK(pElan);
           	
           	DBGP((2, "CurPacketFilter now %x\n", Filter));

            break;

	    case OID_802_5_CURRENT_FUNCTIONAL:
		case OID_802_5_CURRENT_GROUP:

			// XXX just accept whatever for now ???
			
            break;

    	case OID_GEN_CURRENT_LOOKAHEAD:

	        //
   	     	// Verify length
   	     	//
        	if (OidLength != 4) 
        	{
	            StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
        	    *BytesRead = 0;
    	        *BytesNeeded = 0;
	            break;
    	    }

	        //
	        // Store the new value.
	        //
			NdisMoveMemory(&LookAhead, InfoBuffer, 4);
		
	        if ((pElan->pAdapter == NULL_PATMLANE_ADAPTER) ||
				(LookAhead <= pElan->pAdapter->MaxAAL5PacketSize))
	        {
            	pElan->CurLookAhead = LookAhead;
            	DBGP((2, "CurLookAhead now %d\n", LookAhead));
        	}
        	else 
        	{
           		StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
        	}

        	break;

    	case OID_GEN_NETWORK_LAYER_ADDRESSES:
    		StatusToReturn = AtmLaneMSetNetworkAddresses(
    							pElan,
    							InformationBuffer,
    							InformationBufferLength,
    							BytesRead,
    							BytesNeeded);
    		break;
    							
    	default:

        	StatusToReturn = NDIS_STATUS_INVALID_OID;

        	*BytesRead = 0;
       		*BytesNeeded = 0;

        	break;

	}

    if (StatusToReturn == NDIS_STATUS_SUCCESS) 
    {
        *BytesRead = BytesLeft;
        *BytesNeeded = 0;
    }

	DBGP((2, "Set Status %x\n", StatusToReturn));

	TRACEOUT(MSetInformation);
	CHECK_EXIT_IRQL(EntryIrql); 
	return StatusToReturn;
}


NDIS_STATUS 
AtmLaneMReset(
	OUT	PBOOLEAN 				AddressingReset,
	IN	NDIS_HANDLE 			MiniportAdapterContext
)
{
	TRACEIN(MReset);

	TRACEOUT(MReset);
	return NDIS_STATUS_NOT_RESETTABLE;
}

VOID 
AtmLaneMHalt(
	IN	NDIS_HANDLE 			MiniportAdapterContext
)
{
    PATMLANE_ELAN		pElan;
    ULONG				rc;
#if DEBUG_IRQL
	KIRQL				EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);
	TRACEIN(MHalt);

	pElan = (PATMLANE_ELAN)MiniportAdapterContext;
	STRUCT_ASSERT(pElan, atmlane_elan);

	ACQUIRE_ELAN_LOCK(pElan);

	DBGP((1, "%d MHalt pElan %x, ref count %d, Admin state %d, State %d\n",
			 pElan->ElanNumber, pElan, pElan->RefCount, pElan->AdminState, pElan->State));

	pElan->MiniportAdapterHandle = NULL;

	rc = AtmLaneDereferenceElan(pElan, "miniport");	// Miniport handle is gone.

	if (rc != 0)
	{
		AtmLaneShutdownElan(pElan, FALSE);
		// lock released in above
	}
	//
	//  else the Elan is gone.
	//

	TRACEOUT(MHalt);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}



PNDIS_PACKET
AtmLaneWrapSendPacket(
	IN	PATMLANE_ELAN			pElan,
	IN	PNDIS_PACKET			pSendNdisPacket,
	OUT	ULONG *					pAddressType,					
	OUT	PMAC_ADDRESS			pDestAddress,
	OUT	BOOLEAN	*				pSendViaBUS
)
/*++

Routine Description:

	This function repackages a protocol sent NDIS packet.
	It puts on a new NDIS packet header and a buffer for
	the LANE header. It saves away the original packet
	header in the ProtocolReserved area of the new packet header.
	Additionally, it determines if packet is to be sent via
	the BUS and the destination address of the packet.
	
Arguments:

	pElan					- Pointer to ATMLANE elan structure

	pSendNdisPacket			- Pointer to NDIS packet

	pAddressType			- Pointer to ULONG that gets one of
							  (LANE_MACADDRTYPE_MACADDR, 
							   LANE_MACADDRTYPE_ROUTEDESCR).
							   
	pDestAddress			- Pointer to 6-byte buffer that gets
							  destination address.

	pSendViaBus				- Pointer to boolean

Return Value:

	New NDIS packet header or NULL if out of resources.
	
--*/
{
	PNDIS_PACKET			pNewNdisPacket;
	PNDIS_BUFFER			pTempNdisBuffer;
	PUCHAR					pHeaderBuffer;
	PUCHAR					pNewHeaderBuffer;
	PUCHAR					pNewPadBuffer;
	ULONG					BufferLength;
	ULONG					TotalLength;
	PNDIS_BUFFER			pHeaderNdisBuffer;
	PNDIS_BUFFER			pPadNdisBuffer;
	NDIS_STATUS				Status;
	PSEND_PACKET_RESERVED	pNewPacketContext;
	ULONG					OrigBufferCount;
	ULONG					WrappedBufferCount;
	ULONG					RILength;
	BOOLEAN					DirectionBit;
	PUCHAR					pCurRouteDescr;
	PUCHAR					pNextRouteDescr;

	TRACEIN(WrapSendPacket);

	//
	//	Initialize
	//
	pNewNdisPacket = (PNDIS_PACKET)NULL;
	pHeaderNdisBuffer = (PNDIS_BUFFER)NULL;
	pPadNdisBuffer = (PNDIS_BUFFER)NULL;
	Status = NDIS_STATUS_SUCCESS;
	OrigBufferCount = 0;
	WrappedBufferCount = 0;

	do
	{
		//
		//	Get first buffer and total length of packet
		//		
		NdisGetFirstBufferFromPacket(
				pSendNdisPacket, 
				&pTempNdisBuffer, 
				&pHeaderBuffer,
				&BufferLength,
				&TotalLength);

		DBGP((3, "WrapSendPacket: SendPkt %x Length %d\n", 
				pSendNdisPacket, TotalLength));

		ASSERT(pTempNdisBuffer != NULL);

		//
		//	Allocate a new transmit packet descriptor
		//	
		NdisAllocatePacket(&Status, &pNewNdisPacket, pElan->TransmitPacketPool);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, "WrapSendPacket: Alloc xmit NDIS Packet failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
		
#if PKT_HDR_COUNTS
		InterlockedDecrement(&pElan->XmitPktCount);
		if ((pElan->XmitPktCount % 20) == 0)
		{
			DBGP((1, "XmitPktCount %d\n", pElan->XmitPktCount));
		}
#endif

		//
		//	Allocate a Header Buffer
		//
		pHeaderNdisBuffer = AtmLaneAllocateHeader(pElan, &pNewHeaderBuffer);
		if (pHeaderNdisBuffer == (PNDIS_BUFFER)NULL)
		{
			DBGP((0, "WrapSendPacket: Alloc Header Buffer failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Spec says we can put zero or our LECID in the header.
		//	We'll put our LECID in the header for echo-filtering purposes.
		//
		ASSERT(pElan->HeaderBufSize == LANE_HEADERSIZE);
		*((PUSHORT)pNewHeaderBuffer) = pElan->LecId;
			

		//
		//	Allocate a pad buffer now, if necessary, before we get all tied
		//	up in knots.
		//
		if ((TotalLength + LANE_HEADERSIZE) < pElan->MinFrameSize)
		{
			pPadNdisBuffer = AtmLaneAllocatePadBuf(pElan, &pNewPadBuffer);
			if (pPadNdisBuffer == (PNDIS_BUFFER)NULL)
			{
				DBGP((0, "WrapSendPacket: Alloc Pad Buffer failed\n"));
				Status = NDIS_STATUS_RESOURCES;
				break;
			}
		}

		//
		//	Put new header buffer at head of new NDIS Packet
		//
		NdisChainBufferAtFront(pNewNdisPacket, pHeaderNdisBuffer);
		WrappedBufferCount++;

		//
		//	Chain buffers from send packet onto tail of new NDIS Packet
		//
		do
		{
			NdisUnchainBufferAtFront(pSendNdisPacket, &pTempNdisBuffer);

			if (pTempNdisBuffer == (PNDIS_BUFFER)NULL)
				break;
			ASSERT(pTempNdisBuffer->Next == NULL);
			OrigBufferCount++;
			NdisChainBufferAtBack(pNewNdisPacket, pTempNdisBuffer);
			WrappedBufferCount++;
		}
		while (TRUE);

		//
		//	Chain pad buffer on tail if needed (it would be allocated already)
		//
		if (pPadNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			NdisChainBufferAtBack(pNewNdisPacket, pPadNdisBuffer);
			WrappedBufferCount++;

			//
			//	Set size of pad buffer to minimum necessary
			//
			NdisAdjustBufferLength(pPadNdisBuffer, 
					pElan->MinFrameSize - TotalLength - LANE_HEADERSIZE);
		}

		//
		//	Save away pointer to original NDIS Packet header in reserved
		//	area of our new NDIS Packet header.
		//
		//	NOTE use of ProtocolReserved in this case!
		//
		//	Also set Owner and Multicast flags appropriately.
		//
		pNewPacketContext = 
			(PSEND_PACKET_RESERVED)&pNewNdisPacket->ProtocolReserved;
		NdisZeroMemory(pNewPacketContext, sizeof(SEND_PACKET_RESERVED));
#if PROTECT_PACKETS
		INIT_SENDPACKET_LOCK(pNewNdisPacket);
#endif	// PROTECT_PACKETS
#if DBG
		pNewPacketContext->Signature = 'ENAL';
#endif
		pNewPacketContext->pOrigNdisPacket = pSendNdisPacket;
		pNewPacketContext->OrigBufferCount = OrigBufferCount;
		pNewPacketContext->OrigPacketLength = TotalLength;
		pNewPacketContext->WrappedBufferCount = WrappedBufferCount;
		SET_FLAG(
				pNewPacketContext->Flags,
				PACKET_RESERVED_OWNER_MASK,
				PACKET_RESERVED_OWNER_PROTOCOL
				);
		ASSERT(pNewPacketContext->Flags == PACKET_RESERVED_OWNER_PROTOCOL);

		//
		//	Branch on Ethernet v.s. Token Ring to sniff pkt contents
		//
		if (pElan->LanType == LANE_LANTYPE_ETH)
		{

			//	Send packet via BUS if it has a multicast
			// 	Destination Address. If low-order bit in
			//	first byte of the Destination Address is set then
			//  it's a multicast or broadcast address.
			//	Destination Address is first in packet header and it's
			//	always a MAC address.
			//
			*pSendViaBUS = ((*pHeaderBuffer) & 1) != 0;
			*pAddressType = LANE_MACADDRTYPE_MACADDR;
			NdisMoveMemory(pDestAddress, pHeaderBuffer, 6);
		}
		else
		{
			ASSERT(pElan->LanType == LANE_LANTYPE_TR);
		
			//
			//	now the very complicated sorting of TR packets
			//
			do
			{
				//
				//	Section 8.5.3 of LANE Specification.
				//	Multicast frames go to the BUS.
				//
				if ((*(pHeaderBuffer+2) & 0x80) != 0)		// DA multicast bit present?
				{
					*pSendViaBUS = TRUE;
					*pAddressType = LANE_MACADDRTYPE_MACADDR;
					NdisMoveMemory(pDestAddress, pHeaderBuffer+2, 6);
					break;
				}

				//
				//	Section 8.5.2 of LANE Specification.
				//	NSR frames go to destination address.
				//
				if ( (*(pHeaderBuffer+8) & 0x80) == 0)		// SA RI bit not present?
				{
					*pSendViaBUS = FALSE;
					*pAddressType = LANE_MACADDRTYPE_MACADDR;
					NdisMoveMemory(pDestAddress, pHeaderBuffer+2, 6);
					break;
				}

				//
				//	Section 8.5.4 of LANE Specification.
				//	ARE or STE frames go to the BUS.
				//
				if ( ((*(pHeaderBuffer+8) & 0x80) != 0) &&	// SA RI bit present and
					 ((*(pHeaderBuffer+14) & 0xe0) !=0) )	// RI type field upper bits on?
				{
					*pSendViaBUS = TRUE;
					*pAddressType = LANE_MACADDRTYPE_MACADDR;
					NdisMoveMemory(pDestAddress, pHeaderBuffer+2, 6);
					break;
				}

				//
				// 	Frame is source routed so extract Routing Information (RI) length.
				//
				RILength = *(pHeaderBuffer+14) & 0x1f;
				
				//
				//	Section 8.5.7 of LANE Specification.
				//	SR frame with a RI length less than 6 contains no hops.
				//	Send to destination address.
				//
				if (RILength < 6)
				{
					*pSendViaBUS = FALSE;
					*pAddressType = LANE_MACADDRTYPE_MACADDR;
					NdisMoveMemory(pDestAddress, pHeaderBuffer+2, 6);
					break;
				}

				//
				//	Section 8.5.6 of LANE Specification.
				//	Odd RILength is invalid, we choose to send via BUS.
				//
				if ((RILength & 1) != 0)
				{
					*pSendViaBUS = FALSE;
					*pAddressType = LANE_MACADDRTYPE_MACADDR;
					NdisMoveMemory(pDestAddress, pHeaderBuffer+2, 6);
					break;
				}

				
				//
				//	Section 8.5.5 of LANE Specification.
				//	At this point we have a SR frame with RI Length >= 6;
				//	We are never a bridge so frame should go to "next RD".
				//
				*pSendViaBUS = FALSE;
				*pAddressType = LANE_MACADDRTYPE_ROUTEDESCR;
				NdisZeroMemory(pDestAddress, 4);

				DirectionBit = (*(pHeaderBuffer+15) & 0x80) != 0;

				if (DirectionBit)
				{
					//
					//	Frame is traversing LAN in reverse order of RDs.
					//	"next RD" is the next-to-last RD in the packet.
					//	Use Segment ID and Bridge Num from this RD.
					//
					pNextRouteDescr = pHeaderBuffer+14+RILength-4;
					pDestAddress->Byte[4] = pNextRouteDescr[0];
					pDestAddress->Byte[5] = pNextRouteDescr[1];
				}
				else
				{
					//
					//	Frame is traversing LAN in the order of the RDs.
					//	"next RD" straddles the first and second RD in the packet.
					//	Use Segment ID from second RD and Bridge Num from first RD.
					//
					pCurRouteDescr	= pHeaderBuffer+14+2;	// first RD
					pNextRouteDescr	= pHeaderBuffer+14+4;	// second RD
					pDestAddress->Byte[4] = pNextRouteDescr[0];
					pDestAddress->Byte[5] = (pNextRouteDescr[1] & 0xf0) | (pCurRouteDescr[1] & 0x0f);
				}
				break;
			}
			while (FALSE);
		}

		NdisQueryPacket(pNewNdisPacket, NULL, NULL, NULL, &TotalLength);
		DBGP((3, "WrapSendPacket: SendPkt %x NewPkt %x Bufs %d Length %d\n", 
			pSendNdisPacket, pNewNdisPacket, WrappedBufferCount, TotalLength));

		TRACELOGWRITE((&TraceLog, 
				TL_WRAPSEND,
				pSendNdisPacket, 
				pNewNdisPacket, 
				WrappedBufferCount, 
				TotalLength));
		TRACELOGWRITEPKT((&TraceLog, pNewNdisPacket));

		break;
	}
	while (FALSE);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		if (pNewNdisPacket != (PNDIS_PACKET)NULL)
		{
#if PROTECT_PACKETS
			FREE_SENDPACKET_LOCK(pNewNdisPacket);
#endif	// PROTECT_PACKETS
			NdisFreePacket(pNewNdisPacket);
			pNewNdisPacket = (PNDIS_PACKET)NULL;
#if PKT_HDR_COUNTS
			InterlockedIncrement(&pElan->XmitPktCount);
			if ((pElan->XmitPktCount % 20) == 0 &&
				pElan->XmitPktCount != pElan->MaxHeaderBufs)
			{
				DBGP((1, "XmitPktCount %d\n", pElan->XmitPktCount));
			}
#endif
		}
		
		if (pHeaderNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreeHeader(pElan, pHeaderNdisBuffer, FALSE);
			pHeaderNdisBuffer = (PNDIS_BUFFER)NULL;
		}

		if (pPadNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreePadBuf(pElan, pPadNdisBuffer, FALSE);
			pPadNdisBuffer = (PNDIS_BUFFER)NULL;
		}

	}

	TRACEOUT(WrapSendPacket);

	return pNewNdisPacket;
}


PNDIS_PACKET
AtmLaneUnwrapSendPacket(
	IN	PATMLANE_ELAN			pElan,
	IN	PNDIS_PACKET			pNdisPacket		LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	This function basically undoes what AtmLaneWrapSendPacket
	does.  It removes the new NDIS packet header and the LANE 
	header and frees them.  It restores the original packet header.
	
Arguments:

	pElan					- Pointer to ATMLANE elan structure

	pNdisPacket				- Pointer to NDIS packet

Return Value:

	Original NDIS packet header.
	
--*/
{
	PSEND_PACKET_RESERVED	pPacketContext;
	UINT					TotalLength;
	PNDIS_PACKET			pOrigNdisPacket;
	PNDIS_BUFFER			pTempNdisBuffer;
	ULONG					OrigPacketLength;
	ULONG					OrigBufferCount;
	ULONG					WrappedBufferCount;
	ULONG					BufferCount;
	BOOLEAN 				First;

	TRACEIN(UnwrapSendPacket);

	//
	//	Get original packet header from reserved area.
	//
	pPacketContext = PSEND_RSVD(pNdisPacket);
	pOrigNdisPacket = pPacketContext->pOrigNdisPacket;
	OrigBufferCount = pPacketContext->OrigBufferCount;
	OrigPacketLength = pPacketContext->OrigPacketLength;
	WrappedBufferCount = pPacketContext->WrappedBufferCount;
	
	ASSERT(pPacketContext->Signature == 'ENAL');
	ASSERT((pPacketContext->Flags & PACKET_RESERVED_OWNER_PROTOCOL) != 0);
	ASSERT(pPacketContext->pOrigNdisPacket != NULL);

	//
	//	Unchain first buffer (ours) and free it.
	//

	pTempNdisBuffer = (PNDIS_BUFFER)NULL;
	NdisUnchainBufferAtFront(pNdisPacket, &pTempNdisBuffer);
	ASSERT(pTempNdisBuffer != (PNDIS_BUFFER)NULL);
	AtmLaneFreeHeader(pElan, pTempNdisBuffer, FALSE);

	//
	//	If padded, unchain last buffer (ours) and free it.
	//
	if ((WrappedBufferCount - OrigBufferCount) > 1)
	{
		pTempNdisBuffer = (PNDIS_BUFFER)NULL;
		NdisUnchainBufferAtBack(pNdisPacket, &pTempNdisBuffer);
		ASSERT(pTempNdisBuffer != (PNDIS_BUFFER)NULL);
		AtmLaneFreePadBuf(pElan, pTempNdisBuffer, FALSE);
	}
		
	//
	//	Put rest of buffers back on original packet header.
	//
	First = TRUE;
	BufferCount = 0;
	do 
	{
		NdisUnchainBufferAtFront(pNdisPacket, &pTempNdisBuffer);
		ASSERT(!((pTempNdisBuffer == NULL) && First));
		First = FALSE;
		if (pTempNdisBuffer == (PNDIS_BUFFER)NULL)
			break;
		NdisChainBufferAtBack(pOrigNdisPacket, pTempNdisBuffer);
		BufferCount++;
	}
	while (TRUE);

	NdisQueryPacket(pOrigNdisPacket, NULL, NULL, NULL, &TotalLength);
	DBGP((3, "UnwrapSendPacket: SendPkt %x Bufcnt %d Length %d\n",
		pOrigNdisPacket, BufferCount, TotalLength));

	TRACELOGWRITE((&TraceLog, 
				TL_UNWRAPSEND,	
				pNdisPacket,
				pOrigNdisPacket,
				BufferCount, 
				TotalLength));
	TRACELOGWRITEPKT((&TraceLog, pOrigNdisPacket));
				
	ASSERT(OrigBufferCount == BufferCount);
//	ASSERT(OrigPacketLength == TotalLength);

	//
	//	Free the packet header
	//
#if PROTECT_PACKETS
	RELEASE_SENDPACKET_LOCK(pNdisPacket);
	FREE_SENDPACKET_LOCK(pNdisPacket);
#endif	// PROTECT_PACKETS
	NdisFreePacket(pNdisPacket);
#if PKT_HDR_COUNTS
	InterlockedIncrement(&pElan->XmitPktCount);
	if ((pElan->XmitPktCount % 20) == 0 &&
		pElan->XmitPktCount != pElan->MaxHeaderBufs)
	{
		DBGP((1, "XmitPktCount %d\n", pElan->XmitPktCount));
	}
#endif
	
	TRACEOUT(UnwrapSendPacket);

	return pOrigNdisPacket;
}

PNDIS_PACKET
AtmLaneWrapRecvPacket(
	IN	PATMLANE_ELAN			pElan,
	IN	PNDIS_PACKET			pRecvNdisPacket,
	OUT	ULONG *					pMacHdrSize,
	OUT	ULONG *					pDestAddrType,					
	OUT	PMAC_ADDRESS			pDestAddr,
	OUT	BOOLEAN	*				pDestIsMulticast
)
/*++

Routine Description:

	This function repackages an adapter received NDIS packet.
	It puts on a new packet header and creates a new buffer
	descriptor for the first fragment that skips the 2-byte
	LANE header.  It then saves away the original packet 
	header with the original first buffer descriptor in the
	MiniportReserved area of the new packet header.
	Additionally, it outputs the destination address, the
	destination's address type if the packet is a destination
	address is a multicast address.
	
Arguments:

	pElan					- Pointer to ATMLANE elan structure

	pRecvNdisPacket			- Pointer to NDIS packet

	pMacHdrSize				- Pointer to ULONG that get the length
							  of the MAC header.

	pDestAddrType			- Pointer to ULONG that gets one of
							  (LANE_MACADDRTYPE_MACADDR, 
							   LANE_MACADDRTYPE_ROUTEDESCR).
							   
	pDestAddr				- Pointer to 6-byte buffer that gets
							  destination address.

	pDestIsMulticast		- Pointer to boolean that gets TRUE if
							  destination address is a multicast.

Return Value:

	New NDIS packet header or NULL if out of resources.
	
--*/
{
	ULONG					TotalLength;
	ULONG					TempLength;
	PUCHAR					pHeaderBuffer;
	PUCHAR					pBuffer;
	PNDIS_PACKET			pNewNdisPacket;
	PNDIS_BUFFER			pFirstNdisBuffer;
	PNDIS_BUFFER			pTempNdisBuffer;
	PNDIS_BUFFER			pNewNdisBuffer;
	PUCHAR					pTempBuffer;
	PRECV_PACKET_RESERVED	pNewPacketContext;
	NDIS_STATUS				Status;
	ULONG					BufferCount;
	
	TRACEIN(WrapRecvPacket);

	//
	//	Initialize
	//
	pNewNdisPacket = (PNDIS_PACKET)NULL;
	pNewNdisBuffer = (PNDIS_BUFFER)NULL;
	Status = NDIS_STATUS_SUCCESS;
	BufferCount = 0;

	do
	{
		//
		//	Get first buffer and total length of packet
		//		
		NdisGetFirstBufferFromPacket(
				pRecvNdisPacket, 
				&pTempNdisBuffer, 
				&pHeaderBuffer,
				&TempLength,
				&TotalLength);

		DBGP((3, "WrapRecvPacket: RecvPkt %x Length %d\n", 
				pRecvNdisPacket, TotalLength));
		//
		//	Allocate a new recv packet descriptor
		//	
		NdisAllocatePacket(&Status, &pNewNdisPacket, pElan->ReceivePacketPool);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, "WrapRecvPacket: Alloc recv NDIS Packet failed\n"));
			break;
		}
		
#if PKT_HDR_COUNTS
		InterlockedDecrement(&pElan->RecvPktCount);
		if ((pElan->RecvPktCount % 20) == 0)
		{
			DBGP((1, "RecvPktCount %d\n", pElan->RecvPktCount));
		}
#endif

		//
		//	Unchain first buffer 
		//
		NdisUnchainBufferAtFront(pRecvNdisPacket, &pFirstNdisBuffer);
		ASSERT(pFirstNdisBuffer != (PNDIS_BUFFER)NULL);
		NdisQueryBuffer(pFirstNdisBuffer, &pTempBuffer, &TempLength);
		ASSERT(TempLength > 2);

		//
		//	"Copy" it to another buffer header skipping the first 2 bytes
		//
		NdisCopyBuffer(
				&Status, 
				&pNewNdisBuffer, 
				pElan->ReceiveBufferPool, 
				pFirstNdisBuffer, 
				2, 
				(TempLength - 2)
				);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, "DataPacketHandler: NdisCopyBuffer failed (%x)\n",
				Status));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
			
		//
		//	Chain new buffer onto new packet header.
		//
		NdisChainBufferAtFront(pNewNdisPacket, pNewNdisBuffer);
		BufferCount++;
		
		//
		//	Chain rest of buffers onto tail of new NDIS Packet
		//
		do
		{
			NdisUnchainBufferAtFront(pRecvNdisPacket, &pTempNdisBuffer);

			if (pTempNdisBuffer == (PNDIS_BUFFER)NULL)
				break;
			ASSERT(pTempNdisBuffer->Next == NULL);
			NdisChainBufferAtBack(pNewNdisPacket, pTempNdisBuffer);
			BufferCount++;
		}
		while (TRUE);

		//
		//	Chain original first buffer back on original packet
		//
		NdisChainBufferAtFront(pRecvNdisPacket, pFirstNdisBuffer);

		//
		//	Save away pointer to original NDIS Packet header in reserved
		//	area of our new NDIS Packet header.
		//
		//	NOTE use of MiniportReserved in this case!
		//
		//	Also set Owner flag appropriately.
		pNewPacketContext = 
			(PRECV_PACKET_RESERVED)&pNewNdisPacket->MiniportReserved;
		NdisZeroMemory(pNewPacketContext, sizeof(*pNewPacketContext));
		pNewPacketContext->pNdisPacket = pRecvNdisPacket;
		SET_FLAG(
				pNewPacketContext->Flags,
				PACKET_RESERVED_OWNER_MASK,
				PACKET_RESERVED_OWNER_MINIPORT
				);

		//
		//	Increment the frame header pointer past the
		//	LANE header (+2 bytes)
		//
		pHeaderBuffer += 2;
		
		//
		//	Output the MAC header length.
		//	Output the address type.
		//	Output the destination address.
		//	Determine if packet is a multicast.
		//
		if (pElan->LanType == LANE_LANTYPE_ETH)
		{
			//	
			//	Ethernet/802.3 is simple.
			//
			//	Header size is always 14.
			//	Type is always a MAC address.
			//	Dest Addr is first 6 bytes of header.
			//	DestAddress is Multicast if low-order bit in
			//	first byte of the Destination Address is set.
			//
			*pMacHdrSize = 14;
			*pDestAddrType = LANE_MACADDRTYPE_MACADDR;
			NdisMoveMemory(pDestAddr, pHeaderBuffer, 6);
			*pDestIsMulticast = (((*pHeaderBuffer) & 1) != 0);
		}
		else
		{
			//
			//	Token Ring/802.5 is a slightly less simple (understatement!).
			//

			do
			{
				//
				//	Calculate MAC header size.
				//
				*pMacHdrSize = 14;								// start with minimum
				if (pHeaderBuffer[8] & 0x80)					// if SR info present
				{
					*pMacHdrSize += (pHeaderBuffer[14] & 0x1F);// add on SR info length
				}

				//
				//	Is it a true Multicast?
				//
				if ((*(pHeaderBuffer+2) & 0x80) != 0)		// DA multicast bit present?
				{
					*pDestIsMulticast = TRUE;
					*pDestAddrType = LANE_MACADDRTYPE_MACADDR;
					NdisMoveMemory(pDestAddr, pHeaderBuffer+2, 6);
					break;
				}

				//
				//	Is it an All Routes Explorer (ARE) or Spanning Tree Explorer (STE)?
				//	If so treat it as a multicast.
				//
				if ( ((*(pHeaderBuffer+8) & 0x80) != 0) &&	// SA RI bit present and
					 ((*(pHeaderBuffer+14) & 0xe0) !=0) )	// RI type field upper bits on?
				{
					*pDestIsMulticast = TRUE;
					*pDestAddrType = LANE_MACADDRTYPE_MACADDR;
					NdisMoveMemory(pDestAddr, pHeaderBuffer+2, 6);
					break;
				}
				
				//
				//	Otherwise it is unicast, Source Routed or not.
				//
				*pDestIsMulticast = FALSE;
				*pDestAddrType = LANE_MACADDRTYPE_MACADDR;
				NdisMoveMemory(pDestAddr, pHeaderBuffer+2, 6);
				break;
			}
			while (FALSE);

		} // if (pElan->LanType == LANE_LANTYPE_ETH)


		NdisQueryPacket(pNewNdisPacket, NULL, NULL, NULL, &TotalLength);
		DBGP((3, "WrapRecvPacket: RecvPkt %x NewPkt %x Length %d\n",
			pRecvNdisPacket, pNewNdisPacket, TempLength));

		TRACELOGWRITE((&TraceLog, 
				TL_WRAPRECV,
				pRecvNdisPacket, 
				pNewNdisPacket, 
				BufferCount, 
				TotalLength));
		break;
	}	
	while (FALSE);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		if (pNewNdisPacket != (PNDIS_PACKET)NULL)
		{
			NdisFreePacket(pNewNdisPacket);
#if PKT_HDR_COUNTS
			InterlockedIncrement(&pElan->RecvPktCount);
			if ((pElan->RecvPktCount % 20) == 0 &&
				pElan->RecvPktCount != pElan->MaxHeaderBufs)
			{
				DBGP((1, "RecvPktCount %d\n", pElan->RecvPktCount));
			}
#endif
			pNewNdisPacket = NULL;
		}

		if (pNewNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreeProtoBuffer(pElan, pNewNdisBuffer);
		}
	}

	TRACEOUT(WrapRecvPacket);
	
	return pNewNdisPacket;
}


PNDIS_PACKET
AtmLaneUnwrapRecvPacket(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	This function basically undoes what AtmLaneWrapRecvPacket
	does.  It removes the new NDIS packet header and the 
	2-byte offset buffer descriptor. It restores the original
	packet header and first buffer descriptor.
	
Arguments:

	pElan					- Pointer to ATMLANE elan structure

	pNdisPacket				- Pointer to NDIS packet

Return Value:

	Original NDIS packet header.
	
--*/
{
	PRECV_PACKET_RESERVED	pPacketContext;
	PNDIS_PACKET			pOrigNdisPacket;
	PNDIS_BUFFER			pTempNdisBuffer;
	ULONG					BufferCount;
	ULONG					TotalLength;	

	TRACEIN(UnwrapRecvPacket);

	//
	//	Get original packet from MiniportReserved.
	//	Should have original first buffer on it still.
	//
	pPacketContext = (PRECV_PACKET_RESERVED)&pNdisPacket->MiniportReserved;
	pOrigNdisPacket = pPacketContext->pNdisPacket;
	ASSERT(pOrigNdisPacket != (PNDIS_PACKET)NULL);
	ASSERT(pOrigNdisPacket->Private.Head != (PNDIS_BUFFER)NULL);
	BufferCount = 1;

	//
	//	Unchain first buffer (ours) and free it.
	//
	NdisUnchainBufferAtFront(pNdisPacket, &pTempNdisBuffer);
	NdisFreeBuffer(pTempNdisBuffer);
	
	//
	//	Put rest of buffers back on original packet header.
	//
	do 
	{
		NdisUnchainBufferAtFront(pNdisPacket, &pTempNdisBuffer);
		if (pTempNdisBuffer == (PNDIS_BUFFER)NULL)
			break;
		ASSERT(pTempNdisBuffer->Next == NULL);
		NdisChainBufferAtBack(pOrigNdisPacket, pTempNdisBuffer);
		BufferCount++;
	}
	while (TRUE);

	NdisQueryPacket(pOrigNdisPacket, NULL, NULL, NULL, &TotalLength);
	DBGP((3, "UnwrapRecvPacket: Pkt %x Length %d\n", pOrigNdisPacket, TotalLength));

	TRACELOGWRITE((&TraceLog, 
				TL_UNWRAPRECV,	
				pNdisPacket,
				pOrigNdisPacket,
				BufferCount, 
				TotalLength));

	//
	//	Free the recv packet descriptor.
	//
	NdisFreePacket(pNdisPacket);
	
#if PKT_HDR_COUNTS
	InterlockedIncrement(&pElan->RecvPktCount);
			if ((pElan->RecvPktCount % 20) == 0 &&
				pElan->RecvPktCount != pElan->MaxHeaderBufs)
	{
		DBGP((1, "RecvPktCount %d\n", pElan->RecvPktCount));
	}
#endif

	TRACEOUT(UnwrapRecvPacket);

	return pOrigNdisPacket;
}



NDIS_STATUS
AtmLaneMSetNetworkAddresses(
	IN	PATMLANE_ELAN			pElan,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT	PULONG					BytesRead,
	OUT	PULONG					BytesNeeded
)
/*++

Routine Description:

    Called when the protocol above us wants to let us know about
    the network address(es) assigned to this interface. If this is TCP/IP,
    then we reformat and send a request to the ATM Call Manager to set
    its atmfMyIpNmAddress object. We pick the first IP address given to us.

Arguments:

	pElan					- Pointer to the ELAN

    InformationBuffer 		- Holds the data to be set.

    InformationBufferLength - The length of InformationBuffer.

    BytesRead 				- If the call is successful, returns the number
        					  of bytes read from InformationBuffer.

    BytesNeeded 			- If there is not enough data in InformationBuffer
        					  to satisfy the OID, returns the amount of storage
        					  needed.

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING
    NDIS_STATUS_INVALID_LENGTH
--*/
{
	NETWORK_ADDRESS_LIST UNALIGNED *		pAddrList;
	NETWORK_ADDRESS UNALIGNED *				pAddr;
	NETWORK_ADDRESS_IP UNALIGNED *			pIpAddr;
	PNDIS_REQUEST							pNdisRequest;
	ULONG									RequestSize;
	PUCHAR									pNetworkAddr;
	NDIS_HANDLE								NdisAdapterHandle;
	NDIS_HANDLE								NdisAfHandle;
	NDIS_STATUS								Status;

	//
	//  Initialize.
	//
	*BytesRead = 0;
	Status = NDIS_STATUS_SUCCESS;

	pAddrList = (NETWORK_ADDRESS_LIST UNALIGNED *)InformationBuffer;

	do
	{
		ACQUIRE_ELAN_LOCK(pElan);

		if (NULL_PATMLANE_ADAPTER != pElan->pAdapter)
		{
			NdisAfHandle = pElan->NdisAfHandle;
			NdisAdapterHandle = pElan->pAdapter->NdisAdapterHandle;
		}
		else
		{
			Status = NDIS_STATUS_FAILURE;
		}

		RELEASE_ELAN_LOCK(pElan);

		if (NDIS_STATUS_SUCCESS != Status)
		{
			break;
		}

		*BytesNeeded = sizeof(*pAddrList) -
						FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address) +
						sizeof(NETWORK_ADDRESS) -
						FIELD_OFFSET(NETWORK_ADDRESS, Address);

		if (InformationBufferLength < *BytesNeeded)
		{
			Status = NDIS_STATUS_INVALID_LENGTH;
			break;
		}

		if (pAddrList->AddressType != NDIS_PROTOCOL_ID_TCP_IP)
		{
			// Not interesting.
			break;
		}

		if (pAddrList->AddressCount <= 0)
		{
			Status = NDIS_STATUS_INVALID_DATA;
			break;
		}

		pAddr = (NETWORK_ADDRESS UNALIGNED *)&pAddrList->Address[0];

		if ((pAddr->AddressLength > InformationBufferLength - *BytesNeeded) ||
			(pAddr->AddressLength == 0))
		{
			Status = NDIS_STATUS_INVALID_LENGTH;
			break;
		}

		if (pAddr->AddressType != NDIS_PROTOCOL_ID_TCP_IP)
		{
			// Not interesting.
			break;
		}

		if (pAddr->AddressLength < sizeof(NETWORK_ADDRESS_IP))
		{
			Status = NDIS_STATUS_INVALID_LENGTH;
			break;
		}

		pIpAddr = (NETWORK_ADDRESS_IP UNALIGNED *)&pAddr->Address[0];

		//
		//  Allocate an NDIS request to send down to the call manager.
		//
		RequestSize = sizeof(NDIS_REQUEST) + sizeof(pIpAddr->in_addr);
		ALLOC_MEM(&pNdisRequest, RequestSize);

		if (pNdisRequest == NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//  Copy the network address in.
		//
		pNetworkAddr = ((PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST));
		NdisMoveMemory(pNetworkAddr, &pIpAddr->in_addr, sizeof(pIpAddr->in_addr));

		DBGP((3, "%d Set network layer addr: length %d\n", pElan->ElanNumber, pAddr->AddressLength));
#if DBG
		if (pAddr->AddressLength >= 4)
		{
			DBGP((1, "Network layer addr: %d.%d.%d.%d\n",
					pNetworkAddr[0],
					pNetworkAddr[1],
					pNetworkAddr[2],
					pNetworkAddr[3]));
		}
#endif // DBG

		//
		//  Send off the request.
		//
		Status = AtmLaneSendNdisCoRequest(
					NdisAdapterHandle,
					NdisAfHandle,
					pNdisRequest,
					NdisRequestSetInformation,
					OID_ATM_MY_IP_NM_ADDRESS,
					pNetworkAddr,
					sizeof(pIpAddr->in_addr)
					);
		
		if (Status == NDIS_STATUS_PENDING)
		{
			Status = NDIS_STATUS_SUCCESS;
		}

		break;
	}
	while (FALSE);


	return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\ntentry.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	ntentry.c

Abstract:

	NT entry points for ATMLANE driver.
	
Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:

--*/

#include "precomp.h"


#pragma hdrstop


//
//  Due to problems with including zwapi.h:
//
NTSYSAPI
NTSTATUS
NTAPI
ZwLoadDriver(
    IN PUNICODE_STRING DriverServiceName
    );


EXTERN
NTSTATUS
AtmLaneIoctlRequest(
	IN	PIRP			pIrp
);

NTSTATUS
AtmLaneDeviceControl(
	IN	PDEVICE_OBJECT DeviceObject,
	IN	PIRP		   pIrp
);

VOID
AtmLaneUnload(
	IN	PDRIVER_OBJECT	pDriverObject
);

NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT	pDriverObject,
	IN	PUNICODE_STRING	RegistryPath
	)
/*++

Routine Description:

	Entry point for the driver.

Arguments:

	DriverObject	-	Pointer to the system allocated DRIVER_OBJECT.
	RegistryPath	-	Pointer to the UNICODE string defining the registry
						path for the driver's information.

Return Value:

	Appropriate NDIS_STATUS value.

--*/
{
	NTSTATUS						NtStatus	= STATUS_SUCCESS;
	UNICODE_STRING					DeviceName;
	UNICODE_STRING					DeviceLinkUnicodeString;
	NDIS_STATUS						NdisStatus;
	NDIS_HANDLE						NdisWrapperHandle = NULL;
	NDIS_HANDLE						MiniportDriverHandle;
	NDIS_HANDLE						NdisProtocolHandle;
	NDIS50_PROTOCOL_CHARACTERISTICS	AtmLaneProtChars;
	NDIS_MINIPORT_CHARACTERISTICS	AtmLaneMiniChars;
	PDRIVER_DISPATCH				DispatchTable[IRP_MJ_MAXIMUM_FUNCTION];
	ULONG							i;
	UNICODE_STRING AtmUniKeyName = 
	NDIS_STRING_CONST("\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Atmuni");

#if DBG
	volatile ULONG					DontRun = 0;
#endif

	TRACEIN(DriverEntry);

#if DBG
	DbgPrint("ATMLANE built %s %s\n", __DATE__, __TIME__);
	DbgPrint("ATMLANE: DbgVerbosity is at %p, currently set to %d\n",
				&DbgVerbosity, DbgVerbosity);

	if (DontRun > 0)
	{
		TRACEOUT(DriverEntry);
		return NDIS_STATUS_FAILURE;
	}
#endif // DBG
	
	//
	//  Initialize our globals.
	//
	AtmLaneInitGlobals();

	//
	//	Save the pointer to the Driver Object
	//
	
	pAtmLaneGlobalInfo->pDriverObject = pDriverObject;

	do
	{
		//
		//	Initialize the wrapper.
		//
		NdisInitializeWrapper(
			&NdisWrapperHandle,
			pDriverObject,
			RegistryPath,
			NULL);
		if (NULL == NdisWrapperHandle)
		{
			DBGP((0, "DriverEntry: NdisMInitializeWrapper failed!\n"));

			NdisStatus = NDIS_STATUS_FAILURE;
			break;
		}
		else
		{
			DBGP((3, "DriverEntry: NdisWrapperhandle %x\n", NdisWrapperHandle));
			//
			//	Save the handle to the wrapper.
			//	
			pAtmLaneGlobalInfo->NdisWrapperHandle = NdisWrapperHandle;
		}
		
		//
		//  Attempt to load the standard UNI 3.1 Call Manager
		//
		NtStatus = ZwLoadDriver(&AtmUniKeyName);
		DBGP((1, "ATMLANE: attempt to load ATMUNI returned %x\n", NtStatus));

		//
		//  We don't care whether we successfully loaded the call manager or not.
		//
		NtStatus = STATUS_SUCCESS;

		//
		//	Initialize the miniport characteristics.
		//
		NdisZeroMemory(&AtmLaneMiniChars, sizeof(AtmLaneMiniChars));
		AtmLaneMiniChars.MajorNdisVersion = 		4;
		AtmLaneMiniChars.MinorNdisVersion = 		0;
		// CheckForHangHandler
		// DisableInterruptHandler
		// EnableInterruptHandler
		AtmLaneMiniChars.HaltHandler = 				AtmLaneMHalt;
		// HandleInterruptHandler
		AtmLaneMiniChars.InitializeHandler = 		AtmLaneMInitialize;
		// ISRHandler
		AtmLaneMiniChars.QueryInformationHandler = 	AtmLaneMQueryInformation;
		// ReconfigureHandler
		AtmLaneMiniChars.ResetHandler = 			AtmLaneMReset;
		// SendHandler
		AtmLaneMiniChars.SetInformationHandler = 	AtmLaneMSetInformation;
		// TransferDataHandler
		AtmLaneMiniChars.ReturnPacketHandler = 		AtmLaneMReturnPacket;
		AtmLaneMiniChars.SendPacketsHandler = 		AtmLaneMSendPackets;
		// AllocateCompleteHandler

		//
		//	Register the Layered Miniport with NDIS.
		//
		NdisStatus = NdisIMRegisterLayeredMiniport(
					NdisWrapperHandle,
					&AtmLaneMiniChars,
					sizeof(AtmLaneMiniChars),
					&MiniportDriverHandle);
		if (NDIS_STATUS_SUCCESS == NdisStatus)
		{
			DBGP((3, "DriverEntry: NdisIMRegisterLayeredMiniport succeeded.\n"));
			//
			//	Save the handle to the driver.
			//
			pAtmLaneGlobalInfo->MiniportDriverHandle = MiniportDriverHandle;
		}
		else
		{
			DBGP((0, "DriverEntry: NdisIMRegisterLayeredMiniport failed! Status: %x\n",
				NdisStatus));
			break;
		}

		//
		//	Initialize the protocol characteristics.
		//
		NdisZeroMemory(&AtmLaneProtChars, sizeof(AtmLaneProtChars));
		AtmLaneProtChars.MajorNdisVersion = 			5;
		AtmLaneProtChars.MinorNdisVersion = 			0;
		AtmLaneProtChars.OpenAdapterCompleteHandler	= 	AtmLaneOpenAdapterCompleteHandler;
		AtmLaneProtChars.CloseAdapterCompleteHandler = 	AtmLaneCloseAdapterCompleteHandler;
		AtmLaneProtChars.SendCompleteHandler =			AtmLaneSendCompleteHandler;
		AtmLaneProtChars.TransferDataCompleteHandler =	AtmLaneTransferDataCompleteHandler;
		AtmLaneProtChars.ResetCompleteHandler = 		AtmLaneResetCompleteHandler;
		AtmLaneProtChars.RequestCompleteHandler = 		AtmLaneRequestCompleteHandler;
		AtmLaneProtChars.ReceiveHandler =				AtmLaneReceiveHandler;
		AtmLaneProtChars.ReceiveCompleteHandler =		AtmLaneReceiveCompleteHandler;
		AtmLaneProtChars.StatusHandler =				AtmLaneStatusHandler;
		AtmLaneProtChars.StatusCompleteHandler = 		AtmLaneStatusCompleteHandler;
		NdisInitUnicodeString(&AtmLaneProtChars.Name, ATMLANE_PROTOCOL_STRING);

		// ReceivePacketHandler;
		AtmLaneProtChars.BindAdapterHandler = 			AtmLaneBindAdapterHandler;
		AtmLaneProtChars.UnbindAdapterHandler = 		AtmLaneUnbindAdapterHandler;
		AtmLaneProtChars.PnPEventHandler = 				AtmLanePnPEventHandler;
		AtmLaneProtChars.UnloadHandler = 				AtmLaneUnloadProtocol;

		AtmLaneProtChars.CoSendCompleteHandler = 		AtmLaneCoSendCompleteHandler;
		AtmLaneProtChars.CoStatusHandler = 				AtmLaneCoStatusHandler;
		AtmLaneProtChars.CoReceivePacketHandler = 		AtmLaneCoReceivePacketHandler;
		AtmLaneProtChars.CoAfRegisterNotifyHandler =	AtmLaneAfRegisterNotifyHandler;

		//
		//	Register the Protocol with NDIS.
		//
		NdisRegisterProtocol(
			&NdisStatus,
			&NdisProtocolHandle,
			&AtmLaneProtChars,
			sizeof(AtmLaneProtChars));
		if (NDIS_STATUS_SUCCESS == NdisStatus)
		{
			DBGP((3, "DriverEntry: NdisProtocolhandle %x\n", 
				NdisProtocolHandle));
			//
			//	Save the NDIS Protocol handle.
			//	
			pAtmLaneGlobalInfo->NdisProtocolHandle = NdisProtocolHandle;
		}
		else
		{
			DBGP((0, "DriverEntry: NdisRegisterProtocol failed! Status: %x\n",
				NdisStatus));
			break;
		}

#ifndef LANE_WIN98
		//
		// Associate the miniport and protocol now
		//
		NdisIMAssociateMiniport(MiniportDriverHandle,
								NdisProtocolHandle);

#endif // LANE_WIN98

		//
		//	Register our protocol device name for special ioctls
		//
		for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
		{
			DispatchTable[i] = AtmLaneDeviceControl;
		}

		NdisInitUnicodeString(&DeviceName, ATMLANE_NTDEVICE_STRING);
		NdisInitUnicodeString(&DeviceLinkUnicodeString, ATMLANE_LINKNAME_STRING);

		NdisStatus = NdisMRegisterDevice(
						NdisWrapperHandle,
						&DeviceName,
						&DeviceLinkUnicodeString,
						&DispatchTable[0],
						&pAtmLaneGlobalInfo->pSpecialDeviceObject,   
						&pAtmLaneGlobalInfo->SpecialNdisDeviceHandle
						);

		if (NDIS_STATUS_SUCCESS != NdisStatus)
		{
			DBGP((0, "DriverEntry: NdisMRegisterDevice failed! Status: %x\n",
				NdisStatus));
			break;
		}
		
		DBGP((3, "DriverEntry: NdisMRegisterDevice: pDevObj %x DevHandle %x\n",
				pAtmLaneGlobalInfo->pSpecialDeviceObject, 
				pAtmLaneGlobalInfo->SpecialNdisDeviceHandle));

		NdisMRegisterUnloadHandler(NdisWrapperHandle,
								   AtmLaneUnload);

	} while(FALSE);


	if (NDIS_STATUS_SUCCESS != NdisStatus)
	{
		//
		//	Clean up.
		//
		if (NULL != NdisWrapperHandle)
		{
	    	NdisTerminateWrapper(
    	    		NdisWrapperHandle,
        			NULL);
        }
	}

	TRACEOUT(DriverEntry);

	return(NtStatus);
}


NTSTATUS
AtmLaneDeviceControl(
	IN	PDEVICE_OBJECT 	DeviceObject,
	IN	PIRP			pIrp
	)
/*++

Routine Description:

    This is the function that hooks NDIS's Device Control IRP
    handler to implement some protocol specific Ioctls.

Arguments:

    DeviceObject - Pointer to device object for target device
    pIrp         - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/
{
    PIO_STACK_LOCATION 	pIrpSp;
    NTSTATUS 			Status;
    
	TRACEIN(DeviceControl);

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

	DBGP((3, "DeviceControl %x %s\n", pIrpSp->MajorFunction, 
		IrpToString(pIrpSp->MajorFunction)));

	//
	//	We only hanle the IRP_MJ_DEVICE_CONTROL IRPs.
	//
	if (pIrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL)
	{
		DBGP((3, "DeviceControl: Handling request\n"));
		Status = AtmLaneIoctlRequest(pIrp);
	}
	else
	{
		switch (pIrpSp->MajorFunction)
		{
			case IRP_MJ_CREATE:
			case IRP_MJ_CLOSE:
			case IRP_MJ_CLEANUP:
				Status = STATUS_SUCCESS;
				break;
			case IRP_MJ_SHUTDOWN:
				Status = STATUS_NOT_IMPLEMENTED;
				break;
			default:
				DBGP((3, "DeviceControl: MajorFunction not supported\n"));
				Status = STATUS_NOT_SUPPORTED;
		}
	}

	ASSERT(STATUS_PENDING != Status);

	pIrp->IoStatus.Status = Status;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

	TRACEOUT(DeviceControl);

	return Status;
}


VOID
AtmLaneUnload(
	IN	PDRIVER_OBJECT				pDriverObject
)
/*++

Routine Description:

	This routine is called by the system prior to unloading us.
	Currently, we just undo everything we did in DriverEntry,
	that is, de-register ourselves as an NDIS protocol, and delete
	the device object we had created.

Arguments:

	pDriverObject	- Pointer to the driver object created by the system.

Return Value:

	None

--*/
{
	UNICODE_STRING			DeviceLinkUnicodeString;
	NDIS_STATUS				Status;

	TRACEIN(Unload);
	DBGP((0, "AtmLaneUnload\n"));

    //  Shut down the protocol first.  This is synchronous (i.e. blocks)

	AtmLaneUnloadProtocol();

	//  Delete the symbolic link created for the admin util

	if (pAtmLaneGlobalInfo->SpecialNdisDeviceHandle)
	{
		DBGP((0, "Deregistering device handle %x from AtmLaneUnload\n",
				pAtmLaneGlobalInfo->SpecialNdisDeviceHandle));
		Status = NdisMDeregisterDevice(pAtmLaneGlobalInfo->SpecialNdisDeviceHandle);
		pAtmLaneGlobalInfo->SpecialNdisDeviceHandle = NULL;
		ASSERT(NDIS_STATUS_SUCCESS == Status);
	}
	
	TRACEOUT(Unload);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\lane\sys\utils.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	utils.c

Abstract:

	Utility routines.
	
Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

VOID
AtmLaneInitGlobals(
	VOID
	)
/*++

Routine Description:

	Initialize the global data structures.

Arguments:

	None

Return Value:

	None

--*/
{
	TRACEIN(InitGlobals);
	
	NdisZeroMemory(pAtmLaneGlobalInfo, sizeof(ATMLANE_GLOBALS));

	INIT_GLOBAL_LOCK(pAtmLaneGlobalInfo);

	NdisInitializeListHead(&pAtmLaneGlobalInfo->AdapterList);

#if DBG_TRACE
	//
	// Init trace log
	//
	pTraceLogSpace = NULL;
	InitTraceLog(&TraceLog, NULL, 0);

	// allocate space and init trace log if configured

	if (DbgLogSize > 0)
	{
		ALLOC_MEM(&pTraceLogSpace, DbgLogSize);
		if (pTraceLogSpace  == NULL)
		{
			DBGP((0, "Failed to allocate %d bytes space for trace log\n",
				DbgLogSize));
		}
		else
		{
			InitTraceLog(
					&TraceLog, 
					pTraceLogSpace, 
					DbgLogSize);
		}
	}
#endif	// DBG_TRACE

	TRACEOUT(InitGlobals);

	return;
}


PATMLANE_ADAPTER
AtmLaneAllocAdapter(
	IN	PNDIS_STRING			pDeviceName,
	IN	PVOID					SystemSpecific1
)
/*++

Routine Description:

	Allocates an Adapter data structure.

Arguments:

	pDeviceName		- Points to name of adapter device
	SystemSpecific1	- What we got into our BindAdapter handler.

Return Value:

	Pointer to allocated Adapter structure or NULL.

--*/
{
	PATMLANE_ADAPTER	pAdapter;
	NDIS_STATUS			Status;
	ULONG				TotalLength;
	PNDIS_STRING		pConfigString;

	TRACEIN(AllocAdapter);

	//
	//	Initialize
	//
	pAdapter = NULL_PATMLANE_ADAPTER;
	pConfigString = (PNDIS_STRING)SystemSpecific1;
	
	do
	{
		//
		//	Allocate everything.  Adapter struct size plus two 
		//  UNICODE string buffers with extra WCHAR each for NULL termination.
		//
		TotalLength =   sizeof(ATMLANE_ADAPTER) + 
		                pDeviceName->MaximumLength + sizeof(WCHAR) + 
		                pConfigString->MaximumLength + sizeof(WCHAR);

		ALLOC_MEM(&pAdapter, TotalLength);

		if (NULL_PATMLANE_ADAPTER == pAdapter)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
		
		//
		// 	Zero it.
		//
		NdisZeroMemory(pAdapter, TotalLength);

		//
		// 	Debugging info.
		//
#if DBG
		pAdapter->atmlane_adapter_sig =  atmlane_adapter_signature;
#endif

		//
		//	Init lock.
		//
		INIT_ADAPTER_LOCK(pAdapter);

		//
		//	Init blocking objects.
		//
		INIT_BLOCK_STRUCT(&pAdapter->Block);
		INIT_BLOCK_STRUCT(&pAdapter->UnbindBlock);

		//
		//	Init ElanList
		//
		NdisInitializeListHead(&pAdapter->ElanList);

		//
		//  Copy in the device name
		//
		pAdapter->DeviceName.MaximumLength = pDeviceName->MaximumLength + sizeof(WCHAR);
		pAdapter->DeviceName.Length = pDeviceName->Length;
		pAdapter->DeviceName.Buffer = (PWCHAR)((PUCHAR)pAdapter + sizeof(ATMLANE_ADAPTER));
		NdisMoveMemory(pAdapter->DeviceName.Buffer,
					   pDeviceName->Buffer,
					   pDeviceName->Length);
		pAdapter->DeviceName.Buffer[pDeviceName->Length/sizeof(WCHAR)] = ((WCHAR)0);


		//
		//  Copy in the Config string - we will use this to open the
		//  registry section for this adapter at a later point.
		//
		pAdapter->ConfigString.MaximumLength = pConfigString->MaximumLength;
		pAdapter->ConfigString.Length = pConfigString->Length;
		pAdapter->ConfigString.Buffer = (PWCHAR)((PUCHAR)pAdapter + 
										sizeof(ATMLANE_ADAPTER) + 
										pAdapter->DeviceName.MaximumLength);

		NdisMoveMemory(pAdapter->ConfigString.Buffer,
					   pConfigString->Buffer,
					   pConfigString->Length);
		pAdapter->ConfigString.Buffer[pConfigString->Length/sizeof(WCHAR)] = ((WCHAR)0);

		//
		//	Link into global Adapter list.
		//
		ACQUIRE_GLOBAL_LOCK(pAtmLaneGlobalInfo);
		InsertTailList(&pAtmLaneGlobalInfo->AdapterList, &pAdapter->Link);
		RELEASE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

	} while (FALSE);
	
	TRACEOUT(AllocAdapter);

	return pAdapter;
}


VOID
AtmLaneDeallocateAdapter(
	IN	PATMLANE_ADAPTER	pAdapter
)
/*++

Routine Description:

	Deallocate an Adapter structure. It is assumed that all
	references to this structure have gone, so it is not necessary
	to acquire a lock to it.

	Also unlink this from the global Adapter list.

Arguments:

	pAdapter		- Pointer to Adapter structure to be deallocated.

Return Value:

	None

--*/
{
	PATMLANE_NAME	pName;


	STRUCT_ASSERT(pAdapter, atmlane_adapter);

	TRACEIN(DeallocateAdapter);

	ASSERT(pAdapter->RefCount == 0);

	//
	//  Unlink from global Adapter list.
	//
	ACQUIRE_GLOBAL_LOCK(pAtmLaneGlobalInfo);
	RemoveEntryList(&pAdapter->Link);
	RELEASE_GLOBAL_LOCK(pAtmLaneGlobalInfo);
	
	//
	//	Free the lock.
	//
	FREE_ADAPTER_LOCK(pAdapter);

#if DBG
	pAdapter->atmlane_adapter_sig++;
#endif

    //
    //  Free string buffers that may have been allocated
    //
	if (NULL != pAdapter->CfgUpperBindings.Buffer)
	{
		FREE_MEM(pAdapter->CfgUpperBindings.Buffer);
	}
	if (NULL != pAdapter->CfgElanName.Buffer)
	{
		FREE_MEM(pAdapter->CfgElanName.Buffer);
	}


	//
	//	Free the name lists that may have been allocated.
	//
	while (pAdapter->UpperBindingsList)
	{
		DBGP((1, "DeallocateAdapter: pname 0x%x\n"));
		pName = pAdapter->UpperBindingsList;
		pAdapter->UpperBindingsList = pName->pNext;
		FREE_MEM(pName);
	}
	while (pAdapter->ElanNameList)
	{
		DBGP((1, "DeallocateAdapter: pname 0x%x\n"));
		pName = pAdapter->ElanNameList;
		pAdapter->ElanNameList = pName->pNext;
		FREE_MEM(pName);
	}


	//
	//  Finally free the Adapter structure.
	//
	FREE_MEM(pAdapter);

	TRACEOUT(DeallocateAdapter);

	return;
}

BOOLEAN
AtmLaneReferenceAdapter(
	IN	PATMLANE_ADAPTER	pAdapter,
	IN	PUCHAR				String
	)
/*++

Routine Description:

	Add a references to an Adapter structure.
	NOTE: The caller is assumed to possess the Adapter's lock.

Arguments:

	pAdapter	-	Pointer to the Adapter structure.


Return Value:

	None.

--*/
{
	BOOLEAN			bReferenced;

	TRACEIN(ReferenceAdapter);

	STRUCT_ASSERT(pAdapter, atmlane_adapter);
	
	if ((pAdapter->Flags & ADAPTER_FLAGS_DEALLOCATING) == 0)
	{
		pAdapter->RefCount++;
		bReferenced = TRUE;
	}
	else
	{
		bReferenced = FALSE;
	}
	
	DBGP((5, "ReferenceAdapter: Adapter %x (%s) new count %d\n",
			 pAdapter, String, pAdapter->RefCount));

	TRACEOUT(ReferenceAdapter);

	return bReferenced;
}

ULONG
AtmLaneDereferenceAdapter(
	IN	PATMLANE_ADAPTER	pAdapter,
	IN	PUCHAR				String
	)
/*++

Routine Description:

	Subtract a reference from an Adapter structure. 
	If the reference count becomes zero, deallocate it.
	NOTE: The caller is assumed to posses the Adapter's lock.

Arguments:

	pAdapter	-	Pointer to an adapter structure.


Return Value:

	None.

--*/
{
	ULONG		rc;

	TRACEIN(DereferenceAdapter);

	STRUCT_ASSERT(pAdapter, atmlane_adapter);

	ASSERT(pAdapter->RefCount > 0);

	rc = --(pAdapter->RefCount);

	if (rc == 0)
	{
	    pAdapter->Flags |= ADAPTER_FLAGS_DEALLOCATING;
		RELEASE_ADAPTER_LOCK(pAdapter);
		AtmLaneDeallocateAdapter(pAdapter);
	}

	DBGP((5, "DereferenceAdapter: Adapter %x (%s) new count %d\n", 
		pAdapter, String, rc));

	TRACEOUT(DereferenceAdapter);

	return (rc);
}
	
NDIS_STATUS
AtmLaneAllocElan(
	IN		PATMLANE_ADAPTER	pAdapter,
	IN OUT	PATMLANE_ELAN		*ppElan
)
/*++

Routine Description:

	Allocates an ELAN data structure.

Arguments:

	None

Return Value:

	NDIS_STATUS_SUCCESS or NDIS_STATUS_RESOURCES.

--*/
{
	NDIS_STATUS				Status;
	PATMLANE_ELAN			pElan;
	PATMLANE_MAC_ENTRY *	pMacTable;
	PATMLANE_TIMER_LIST		pTimerList;
	USHORT					NameBufferSize;
	UINT					i;
	ULONG					SapSize;
	PCO_SAP					pLesSapInfo;
	PCO_SAP					pBusSapInfo;
	PCO_SAP					pDataSapInfo;
	ULONG					ElanNumber;

	TRACEIN(AllocElan);

	//
	//  Initialize
	//

	Status = NDIS_STATUS_SUCCESS;
	pElan = NULL_PATMLANE_ELAN;
	pMacTable = (PATMLANE_MAC_ENTRY *)NULL;

	pLesSapInfo = pBusSapInfo = pDataSapInfo = (PCO_SAP)NULL;
	
	SapSize = sizeof(CO_SAP)+sizeof(ATM_SAP)+sizeof(ATM_ADDRESS);

	do
	{
		//
		//	Allocate everything.
		//
		ALLOC_MEM(&pElan, sizeof(ATMLANE_ELAN));
		ALLOC_MEM((PVOID *)&pMacTable, ATMLANE_MAC_TABLE_SIZE*sizeof(PATMLANE_MAC_ENTRY));
		ALLOC_MEM(&pLesSapInfo, SapSize);
		ALLOC_MEM(&pBusSapInfo, SapSize);
		ALLOC_MEM(&pDataSapInfo, SapSize);

		if (NULL_PATMLANE_ELAN != pElan)
		{
			//
			// 	Zero the Elan structure now so that we clean up properly
			//  if any errors occur later on.
			//
			NdisZeroMemory(pElan, sizeof(ATMLANE_ELAN));
		}

		if ((NULL_PATMLANE_ELAN == pElan) ||
			(NULL == pMacTable) ||
			(NULL == pLesSapInfo) ||
			(NULL == pBusSapInfo) ||
			(NULL == pDataSapInfo))
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//  Allocate timer structures
		//
		for (i = 0; i < ALT_CLASS_MAX; i++)
		{
			pTimerList = &(pElan->TimerList[i]);
#if DBG
			pTimerList->atmlane_timerlist_sig = atmlane_timerlist_signature;
#endif
			ALLOC_MEM(&(pTimerList->pTimers), 
						sizeof(ATMLANE_TIMER) * AtmLaneTimerListSize[i]);
			if (NULL_PATMLANE_TIMER == pTimerList->pTimers)
			{
				Status = NDIS_STATUS_RESOURCES;
				break;
			}
		}

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		//
		//	Continue initializing the ELAN structure
		//
#if DBG
		//
		// 	Signatures, for debugging.
		//
		pElan->atmlane_elan_sig =  atmlane_elan_signature;
		pElan->LesSap.atmlane_sap_sig = atmlane_sap_signature;
		pElan->BusSap.atmlane_sap_sig = atmlane_sap_signature;
		pElan->DataSap.atmlane_sap_sig = atmlane_sap_signature;
#endif

		//
		//	Initialize state fields.
		//
		pElan->AdminState = ELAN_STATE_INIT;
		pElan->State = ELAN_STATE_ALLOCATED;
		NdisInitializeWorkItem(&pElan->EventWorkItem, AtmLaneEventHandler, pElan);
		
		//
		//	Initialize spinlocks.
		//
#if SENDLIST
		NdisAllocateSpinLock(&pElan->SendListLock);
#endif // SENDLIST
		INIT_ELAN_LOCK(pElan);
		INIT_ELAN_MAC_TABLE_LOCK(pElan);
		INIT_ELAN_ATM_LIST_LOCK(pElan);
		INIT_ELAN_TIMER_LOCK(pElan);
		INIT_BLOCK_STRUCT(&pElan->Block);
		INIT_BLOCK_STRUCT(&pElan->InitBlock);
		INIT_BLOCK_STRUCT(&pElan->AfBlock);
		INIT_HEADER_LOCK(pElan);

		//
		//	Init event queue.
		//
		InitializeListHead(&pElan->EventQueue);

		//
		//  Initialize timer wheels.
		//
		for (i = 0; i < ALT_CLASS_MAX; i++)
		{
			pTimerList = &(pElan->TimerList[i]);
			NdisZeroMemory(
				pTimerList->pTimers,
				sizeof(ATMLANE_TIMER) * AtmLaneTimerListSize[i]
				);
			pTimerList->MaxTimer = AtmLaneMaxTimerValue[i];
			pTimerList->TimerPeriod = AtmLaneTimerPeriod[i];
			pTimerList->ListContext = (PVOID)pElan;
			pTimerList->TimerListSize = AtmLaneTimerListSize[i];

			INIT_SYSTEM_TIMER(
					&(pTimerList->NdisTimer),
					AtmLaneTickHandler,
					(PVOID)pTimerList
					);
		}

		//
		//	Initialize all sub-components.
		//
		NdisZeroMemory(pMacTable, ATMLANE_MAC_TABLE_SIZE*sizeof(PATMLANE_MAC_ENTRY));
		NdisZeroMemory(pLesSapInfo, SapSize);
		NdisZeroMemory(pBusSapInfo, SapSize);
		NdisZeroMemory(pDataSapInfo, SapSize);

		//
		//	Link sub-components to the Elan structure.
		//
		pElan->pMacTable = pMacTable;

		pElan->LesSap.pInfo = pLesSapInfo;
		pElan->BusSap.pInfo = pBusSapInfo;
		pElan->DataSap.pInfo = pDataSapInfo;
				
		//
		//	Link the Elan to the adapter.
		//
		pElan->pAdapter = pAdapter;
		ACQUIRE_ADAPTER_LOCK(pAdapter);

		//
		//  Find a free ELAN number.
		//
		for (ElanNumber = 0; ElanNumber <= pAdapter->ElanCount; ElanNumber++)
		{
			PATMLANE_ELAN		pThisElan = NULL;
			PLIST_ENTRY			p;

			for (p = pAdapter->ElanList.Flink;
 				 p != &pAdapter->ElanList;
 				 p = p->Flink)
			{
				pThisElan = CONTAINING_RECORD(p, ATMLANE_ELAN, Link);

				if (pThisElan->ElanNumber == ElanNumber)
				{
					break;
				}
			}

			//
			//  See if we made it to the end of the list without hitting
			//  the current ElanNumber. If so, use this ElanNumber.
			//
			if (p == &pAdapter->ElanList)
			{
				break;
			}
		}

		DBGP((0, "%d Assign ElanNumber to ELAN %x\n", ElanNumber, pElan));
		(VOID)AtmLaneReferenceAdapter(pAdapter, "elan");
		InsertTailList(&pAdapter->ElanList,	&pElan->Link);
		pElan->ElanNumber = ElanNumber;
		pAdapter->ElanCount++;
		RELEASE_ADAPTER_LOCK(pAdapter);

		//
		//	Cache NdisAdapterHandle.
		//
		pElan->NdisAdapterHandle = pAdapter->NdisAdapterHandle;

		//
		//	Generate a MAC Address for the elan
		//
		AtmLaneGenerateMacAddr(pElan);		

		//
		//	Set the rest of the LANE Run-time parameters to defaults
		//
		pElan->ControlTimeout 		= LANE_C7_DEF;
		pElan->MaxUnkFrameCount 	= LANE_C10_DEF;
		pElan->MaxUnkFrameTime	 	= LANE_C11_DEF;
		pElan->VccTimeout 			= LANE_C12_DEF;
		pElan->MaxRetryCount 		= LANE_C13_DEF;
		pElan->AgingTime		 	= LANE_C17_DEF;
		pElan->ForwardDelayTime		= LANE_C18_DEF;
		pElan->ArpResponseTime	 	= LANE_C20_DEF;
		pElan->FlushTimeout 		= LANE_C21_DEF;
		pElan->PathSwitchingDelay 	= LANE_C22_DEF;
		pElan->ConnComplTimer 		= LANE_C28_DEF;

		//
		//	Calc the bus rate limiter parameters
		//			
		pElan->LimitTime 			= pElan->MaxUnkFrameTime * 1000;
		pElan->IncrTime 			= pElan->LimitTime / pElan->MaxUnkFrameCount;

		Status = NDIS_STATUS_SUCCESS;
		break;

	} while (FALSE);

	if (NDIS_STATUS_SUCCESS != Status)
	{
		//
		//	Failure cleanup.
		//
		if (NULL_PATMLANE_ELAN != pElan)
		{
			for (i = 0; i < ALT_CLASS_MAX; i++)
			{
				pTimerList = &(pElan->TimerList[i]);
				if (NULL != pTimerList->pTimers)
				{
					FREE_MEM(pTimerList->pTimers);
				}
			}
		}
		if (NULL != pLesSapInfo)
		{
			FREE_MEM(pLesSapInfo);
		}
		if (NULL != pBusSapInfo)
		{
			FREE_MEM(pBusSapInfo);
		}
		if (NULL != pDataSapInfo)
		{
			FREE_MEM(pDataSapInfo);
		}
		if (NULL != pMacTable)
		{
			FREE_MEM(pMacTable);
		}
		if (NULL_PATMLANE_ELAN != pElan)
		{
			FREE_MEM(pElan);
			pElan = NULL_PATMLANE_ELAN;
		}
	}
	//
	// 	Output pElan
	//
	*ppElan = pElan;

	TRACEOUT(AllocElan);

	return Status;
}


VOID
AtmLaneDeallocateElan(
	IN	PATMLANE_ELAN		pElan
)
/*++

Routine Description:

	Deallocate an Elan structure. It is assumed that all
	references to this structure have gone, so it is not necessary
	to acquire a lock to it.

	Also delink this from the Adapter's Elan list.

Arguments:

	pElan		- Pointer to Elan structure to be deallocated.

Return Value:

	None

--*/
{
	PATMLANE_ADAPTER		pAdapter;
	PATMLANE_ATM_ENTRY		pAtmEntry;
	PATMLANE_ATM_ENTRY		pNext;
	UINT					i;
	
	TRACEIN(DeallocateElan);

	STRUCT_ASSERT(pElan, atmlane_elan);

	ASSERT(pElan->RefCount == 0);

	DBGP((0, "%d Deleting ELAN %p\n", pElan->ElanNumber, pElan));


	//
	//	Free all subcomponents
	//

	//
	//	MAC Table
	//
	if ((PATMLANE_MAC_ENTRY *)NULL != pElan->pMacTable)
	{
		FREE_MEM(pElan->pMacTable);
		pElan->pMacTable = (PATMLANE_MAC_ENTRY *)NULL;
	}

	//
	//	ATM Entry List
	//
	for (pAtmEntry = pElan->pAtmEntryList;
		 pAtmEntry != NULL_PATMLANE_ATM_ENTRY;
		 pAtmEntry = (PATMLANE_ATM_ENTRY)pNext)
	{
		pNext = (PVOID)pAtmEntry->pNext;
		FREE_MEM(pAtmEntry);
	}
	pElan->pAtmEntryList = NULL_PATMLANE_ATM_ENTRY;

	//
	//  Timers
	//
	for (i = 0; i < ALT_CLASS_MAX; i++)
	{
		PATMLANE_TIMER_LIST pTimerList = &(pElan->TimerList[i]);
		if (NULL != pTimerList->pTimers)
		{
			FREE_MEM(pTimerList->pTimers);
		}
		pTimerList->pTimers = NULL_PATMLANE_TIMER;
	}

	//
	//	ProtocolPacketPool
	//	ProtocolBufferPool
	//	ProtocolBufList
	//
	AtmLaneDeallocateProtoBuffers(pElan);

	//
	//	TransmitPacketPool
	//
	if (pElan->TransmitPacketPool != NULL_NDIS_HANDLE)
	{
		NdisFreePacketPool(pElan->TransmitPacketPool);
		pElan->TransmitPacketPool = NULL_NDIS_HANDLE;
	}

	//
	//	ReceivePacketPool
	//
	if (pElan->ReceivePacketPool != NULL_NDIS_HANDLE)
	{
		NdisFreePacketPool(pElan->ReceivePacketPool);
		pElan->ReceivePacketPool = NULL_NDIS_HANDLE;
	}

	//
	//	ReceiveBufferPool
	//
	if (pElan->ReceiveBufferPool != NULL_NDIS_HANDLE)
	{
		NdisFreeBufferPool(pElan->ReceiveBufferPool);
		pElan->ReceiveBufferPool = NULL_NDIS_HANDLE;
	}

	//
	//	HeaderBufList
	//	pHeaderTrkList
	//
	AtmLaneDeallocateHeaderBuffers(pElan);

	//
	//	PadBufList
	//	pPadTrkList
	//
	AtmLaneDeallocatePadBufs(pElan);
		
	//
	//	Free the config strings
	//
	if (NULL != pElan->CfgBindName.Buffer)
	{
		FREE_MEM(pElan->CfgBindName.Buffer);
	}
	if (NULL != pElan->CfgDeviceName.Buffer)
	{
		FREE_MEM(pElan->CfgDeviceName.Buffer);
	}
	if (NULL != pElan->CfgElanName.Buffer)
	{
		FREE_MEM(pElan->CfgElanName.Buffer);
	}

	//
	//	Free the Sap info
	//

	if (NULL != pElan->LesSap.pInfo)
	{
		FREE_MEM(pElan->LesSap.pInfo);
	}
	if (NULL != pElan->BusSap.pInfo)
	{
		FREE_MEM(pElan->BusSap.pInfo);
	}
	if (NULL != pElan->DataSap.pInfo)
	{
		FREE_MEM(pElan->DataSap.pInfo);
	}
	
	//
	//	Free the locks.
	//
#if SENDLIST
	NdisFreeSpinLock(&pElan->SendListLock);
#endif // SENDLIST
	FREE_ELAN_LOCK(pElan);
	FREE_ELAN_MAC_TABLE_LOCK(pElan);
	FREE_ELAN_ATM_LIST_LOCK(pElan);
	FREE_ELAN_TIMER_LOCK(pElan);
	FREE_BLOCK_STRUCT(&pElan->Block);
	FREE_HEADER_LOCK(pElan);

	AtmLaneUnlinkElanFromAdapter(pElan);

#if DBG
	pElan->atmlane_elan_sig++;
#endif
	//
	//  Finally free the Elan structure.
	//
	FREE_MEM(pElan);

	TRACEOUT(DeallocateElan);

	return;
}

VOID
AtmLaneReferenceElan(
	IN	PATMLANE_ELAN	pElan,
	IN	PUCHAR			String
	)
/*++

Routine Description:

	Add a references to an Elan structure.
	NOTE: The caller is assumed to possess the Elan's lock.

Arguments:

	pElan	-	Pointer to the Elan structure.


Return Value:

	None.

--*/
{
	TRACEIN(ReferenceElan);

	STRUCT_ASSERT(pElan, atmlane_elan);
	
	pElan->RefCount++;
	
	DBGP((5, "ReferenceElan: Elan %p/%x (%s) new count %d\n",
			 pElan, pElan->Flags, String, pElan->RefCount));

	TRACEOUT(ReferenceElan);

	return;
}

ULONG
AtmLaneDereferenceElan(
	IN	PATMLANE_ELAN		pElan,
	IN	PUCHAR				String
	)
/*++

Routine Description:

	Subtract a reference from an Elan structure. 
	If the reference count becomes zero, deallocate it.
	NOTE: The caller is assumed to posses the Elan's lock.

Arguments:

	pElan	-	Pointer to an Elan structure.


Return Value:

	None.

--*/
{
	ULONG		rc;
#if DBG
	ULONG		Flags = pElan->Flags;
#endif

	TRACEIN(DereferenceElan);

	STRUCT_ASSERT(pElan, atmlane_elan);

	ASSERT(pElan->RefCount > 0);

	rc = --(pElan->RefCount);

	if (rc == 0)
	{
		pElan->Flags |= ELAN_DEALLOCATING;
		RELEASE_ELAN_LOCK(pElan);
		AtmLaneDeallocateElan(pElan);
	}
	
	DBGP((5, "DereferenceElan: Elan %p/%x (%s) new count %d\n",
			pElan, Flags, String, rc));

	TRACEOUT(DereferenceElan);

	return (rc);
}

VOID
AtmLaneUnlinkElanFromAdapter(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Unlinks an ELAN structure from the Adapter structure it is linked to.
	Also continues any pending operation on the Adapter.

Arguments:

	pElan		- Pointer to Elan

Return Value:

	None

--*/
{
	PATMLANE_ADAPTER		pAdapter;
	BOOLEAN					CompleteUnbind;

	DBGP((1, "%d UnlinkElanFromAdapter: pElan %p/%x, Ref %d, pAdapter %p\n",
			pElan->ElanNumber, pElan, pElan->Flags, pElan->RefCount, pElan->pAdapter));

	pAdapter = pElan->pAdapter;

	if (pAdapter != NULL_PATMLANE_ADAPTER)
	{
		DBGP((1, "UnlinkElanFromAdapter: pAdapter %x, Flags %x, RefCount %d\n",
					pAdapter,
					pAdapter->Flags, pAdapter->RefCount));
		//
		//  Unlink from adapter list.
		//
		ACQUIRE_ADAPTER_LOCK(pAdapter);
		pElan->pAdapter = NULL_PATMLANE_ADAPTER;
		RemoveEntryList(&pElan->Link);
		pAdapter->ElanCount--;
		AtmLaneDereferenceAdapter(pAdapter, "elan");

		if (IsListEmpty(&pAdapter->ElanList) &&
			(pAdapter->Flags & ADAPTER_FLAGS_UNBIND_COMPLETE_PENDING))
		{
			pAdapter->Flags &= ~ADAPTER_FLAGS_UNBIND_COMPLETE_PENDING;
			CompleteUnbind = TRUE;
		}
		else
		{
			CompleteUnbind = FALSE;
		}

		RELEASE_ADAPTER_LOCK(pAdapter);

		//
		//  If we just freed the last elan structure on this
		//  adapter, and an Unbind operation was in progress, complete
		//  it now.
		//
		if (CompleteUnbind)
		{
			AtmLaneCompleteUnbindAdapter(pAdapter);
		}
	}
}

PATMLANE_ATM_ENTRY
AtmLaneAllocateAtmEntry(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Allocate an ATM Entry structure, initialize it, and return it.

Arguments:

	pElan		- Pointer to Elan on which the entry is allocated

Return Value:

	Pointer to allocated ATM Entry structure if successful, NULL otherwise.

--*/
{
	PATMLANE_ATM_ENTRY		pAtmEntry;

	TRACEIN(AllocateAtmEntry);

	STRUCT_ASSERT(pElan, atmlane_elan);

	ALLOC_MEM(&pAtmEntry, sizeof(ATMLANE_ATM_ENTRY));
	if (pAtmEntry != NULL_PATMLANE_ATM_ENTRY)
	{
		NdisZeroMemory(pAtmEntry, sizeof(ATMLANE_ATM_ENTRY));
#if DBG
		pAtmEntry->atmlane_atm_sig = atmlane_atm_signature;
#endif
		pAtmEntry->Flags = ATM_ENTRY_IDLE;
		INIT_ATM_ENTRY_LOCK(pAtmEntry);
		pAtmEntry->pElan = pElan;
		
	}

	DBGP((5, "AllocateAtmEntry:ATM Entry: Elan %x, Entry %x\n",
				pElan, pAtmEntry));
				
	TRACEOUT(AllocateAtmEntry);

	return (pAtmEntry);
}


VOID
AtmLaneDeallocateAtmEntry(
	IN	PATMLANE_ATM_ENTRY			pAtmEntry
)
/*++

Routine Description:

	Free an ATM Entry structure. It is assumed that all references
	to the structure have gone. We don't need any locks here.

Arguments:

	pAtmEntry		- Pointer to ATM Entry to be freed.

Return Value:

	None

--*/
{
	TRACEIN(DeallocateAtmEntry);


	STRUCT_ASSERT(pAtmEntry, atmlane_atm);
	ASSERT(pAtmEntry->RefCount == 0);
	ASSERT(pAtmEntry->pVcList == NULL_PATMLANE_VC);

#if DBG
	pAtmEntry->atmlane_atm_sig++;
#endif

	FREE_ATM_ENTRY_LOCK(pAtmEntry);
	FREE_MEM(pAtmEntry);

	DBGP((5, "DeallocateAtmEntry: ATM Entry: %x\n", pAtmEntry));

	TRACEOUT(DeallocateAtmEntry);
}


VOID
AtmLaneReferenceAtmEntry(
	IN	PATMLANE_ATM_ENTRY			pAtmEntry,
	IN	PUCHAR						String
)
/*++

Routine Description:

	Add a reference to the specified ATM Entry.
	NOTE: The caller is assumed to possess a lock for the Entry.

Arguments:

	pAtmEntry			- Pointer to the Entry to be referenced

Return Value:

	None

--*/
{
	TRACEIN(ReferenceAtmEntry);
	
	STRUCT_ASSERT(pAtmEntry, atmlane_atm);

	pAtmEntry->RefCount++;

	DBGP((5, "ReferenceAtmEntry: Entry %x (%s) new count %d\n",
			 pAtmEntry, String, pAtmEntry->RefCount));
			 
	TRACEOUT(ReferenceAtmEntry);
}


ULONG
AtmLaneDereferenceAtmEntry(
	IN	PATMLANE_ATM_ENTRY			pAtmEntry,
	IN	PUCHAR						String
)
/*++

Routine Description:

	Subtract a reference from the specified ATM Entry. If the Entry's
	reference count becomes zero, deallocate it.

	NOTE: The caller is assumed to possess a lock for the Entry.
	SIDE EFFECT: See Return Value below

Arguments:

	pAtmEntry			- Pointer to the Entry to be dereferenced.

Return Value:

	Is the new reference count.
	[IMPORTANT] If the Entry's reference count became zero, the Entry will be
	deallocated -- the Entry lock is, obviously, released in this case.

--*/
{
	ULONG					rc;
	PATMLANE_ELAN			pElan;

	TRACEIN(DereferenceAtmEntry);
	
	STRUCT_ASSERT(pAtmEntry, atmlane_atm);

	if (pAtmEntry->RefCount == 0)
	{
		rc = 0;
	}
	else
	{
		rc = --(pAtmEntry->RefCount);
	}

	if (rc == 0)
	{
		PATMLANE_ATM_ENTRY *	ppAtmEntry;

		DBGP((5, "DerefAtmEntry %x, RefCount is 0\n", pAtmEntry));

		//
		//  Unlink this entry from the Elan's list of ATM Entries.
		//

		//
		//  Acquire locks in the right order. However note that in doing so,
		//  some other thread might stumble across this ATM entry and reference
		//  it (and also dereference it!). To handle this, add a temp ref first.
		//
		pAtmEntry->RefCount++;

		pElan = pAtmEntry->pElan;
		STRUCT_ASSERT(pElan, atmlane_elan);

		RELEASE_ATM_ENTRY_LOCK(pAtmEntry);

		ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);
		ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);

		//
		//  Remove the temp ref above. If the ref count is still at 0,
		//  nobody is using this ATM entry and it is safe to remove it
		//  from the list.
		//
		rc = --(pAtmEntry->RefCount);
		
		if (rc == 0)
		{
			//
			//  Safe to delete this ATM entry.
			//
#if DBG 
			if (pAtmEntry->pMacEntryList != NULL)
			{
				DBGP((0, "ATMLANE: derefed pAtmEntry %x, but MACEntryList isn't NULL!\n",
					pAtmEntry));
				ASSERT(FALSE);
			}
#endif // DBG
                
			ppAtmEntry = &(pElan->pAtmEntryList);
			while (*ppAtmEntry != pAtmEntry)
			{
				ASSERT(*ppAtmEntry != NULL_PATMLANE_ATM_ENTRY);
				ppAtmEntry = &((*ppAtmEntry)->pNext);
			}

			*ppAtmEntry = pAtmEntry->pNext;

			pElan->NumAtmEntries--;
		
			//
			//	If ATM Entry is for a LANE server 
			//	then also invalidate elan's cached pointer to it
			//
			switch (pAtmEntry->Type)
			{
				case ATM_ENTRY_TYPE_LECS:
					pElan->pLecsAtmEntry = NULL_PATMLANE_ATM_ENTRY;
					break;
				case ATM_ENTRY_TYPE_LES:
					pElan->pLesAtmEntry = NULL_PATMLANE_ATM_ENTRY;
					break;
				case ATM_ENTRY_TYPE_BUS:
					pElan->pBusAtmEntry = NULL_PATMLANE_ATM_ENTRY;
					break;
			}
		}

		RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		RELEASE_ELAN_ATM_LIST_LOCK(pElan);

		if (rc == 0)
		{
			AtmLaneDeallocateAtmEntry(pAtmEntry);
		}
		else
		{
			//
			//  As far as this caller is concerned, the ATM entry is gone.
			//  Return 0.
			//
			rc = 0;
		}
	}

	DBGP((5, "DereferenceAtmEntry: Entry %x (%s) new count %d\n", 
			pAtmEntry, String, rc));

	TRACEOUT(DereferenceAtmEntry);
	
	return (rc);
}

PATMLANE_VC
AtmLaneAllocateVc(
	IN	PATMLANE_ELAN				pElan
)
/*++

Routine Description:

	Allocate an ATMLANE VC structure, initialize it, and return it.

Arguments:

	pElan		- Elan for which this VC is created.

Return Value:

	Pointer to VC if allocated, NULL otherwise.

--*/
{
	PATMLANE_VC			pVc;

	TRACEIN(AllocateVc);

	STRUCT_ASSERT(pElan, atmlane_elan);

	ALLOC_MEM(&pVc, sizeof(ATMLANE_VC));

	if (pVc != NULL_PATMLANE_VC)
	{
		NdisZeroMemory(pVc, sizeof(ATMLANE_VC));
#if DBG
		pVc->atmlane_vc_sig = atmlane_vc_signature;
#endif // DBG
		pVc->pElan = pElan;
		INIT_VC_LOCK(pVc);
	}

	DBGP((3, "Allocated Vc %x\n", pVc));

	TRACEOUT(AllocateVc);

	return (pVc);
}

VOID
AtmLaneDeallocateVc(
	IN	PATMLANE_VC					pVc
)
/*++

Routine Description:

	Deallocate an ATMLANE VC structure. It is assumed that all references
	to this VC have gone, so there is no need to acquire a lock to the VC.

Arguments:

	pVc			- Pointer to the VC to be deallocated

Return Value:

	None

--*/
{
	TRACEIN(DeallocateVc);

	STRUCT_ASSERT(pVc, atmlane_vc);
	ASSERT(pVc->RefCount == 0);

#if DBG
	pVc->atmlane_vc_sig++;
#endif
	FREE_VC_LOCK(pVc);
	FREE_MEM(pVc);

	DBGP((5, "Deallocated Vc %x\n", pVc));

	TRACEOUT(DeallocateVc);

	return;
}

VOID
AtmLaneReferenceVc(
	IN	PATMLANE_VC					pVc,
	IN	PUCHAR						String
)
/*++

Routine Description:

	Add a reference to the specified ATMLANE VC.
	NOTE: The caller is assumed to possess a lock for the VC.

Arguments:

	pVc			- Pointer to the VC to be referenced

Return Value:

	None

--*/
{
	TRACEIN(ReferenceVc);

	STRUCT_ASSERT(pVc, atmlane_vc);

	pVc->RefCount++;

	DBGP((5, "ReferenceVc: Vc %x (%s) new count %d\n",
			 pVc, String, pVc->RefCount));

	TRACEOUT(ReferenceVc);

	return;
}


ULONG
AtmLaneDereferenceVc(
	IN	PATMLANE_VC					pVc,
	IN	PUCHAR						String
)
/*++

Routine Description:

	Subtract a reference from the specified ATMLANE VC. If the VC's
	reference count becomes zero, deallocate it.

	NOTE: The caller is assumed to possess a lock for the VC.
	SIDE EFFECT: See Return Value below

Arguments:

	pVc			- Pointer to the VC to be dereferenced.

Return Value:

	Is the new reference count.
	[IMPORTANT] If the VC's reference count became zero, the VC will be
	deallocated -- the VC lock is, obviously, released in this case.

--*/
{
	ULONG		rv;

	TRACEIN(DereferenceVc);

	STRUCT_ASSERT(pVc, atmlane_vc);
	ASSERT(pVc->RefCount > 0);

	rv = --(pVc->RefCount);
	if (rv == 0)
	{
		RELEASE_VC_LOCK(pVc);
		AtmLaneDeallocateVc(pVc);
	}

	DBGP((5, "DereferenceVc: Vc %x (%s) new count %d\n", 
			pVc, String, rv));

	TRACEOUT(DereferenceVc);

	return (rv);
}

PATMLANE_MAC_ENTRY
AtmLaneAllocateMacEntry(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Allocate an ATMLANE MAC Entry structure, initialize it, and
	return it.

Arguments:

	pElan		- Pointer to ATMLANE Interface on which this MAC
				  Entry is allocated.

Return Value:

	Pointer to allocated MAC Entry structure if successful,
	NULL otherwise.

--*/
{
	PATMLANE_MAC_ENTRY		pMacEntry;

	TRACEIN(AllocateMacEntry);

	ALLOC_MEM(&pMacEntry, sizeof(ATMLANE_MAC_ENTRY));

	if (pMacEntry != NULL_PATMLANE_MAC_ENTRY)
	{
		NdisZeroMemory(pMacEntry, sizeof(ATMLANE_MAC_ENTRY));
#if DBG
		pMacEntry->atmlane_mac_sig = atmlane_mac_signature;
#endif // DBG
		pMacEntry->pElan = pElan;
		pMacEntry->Flags = MAC_ENTRY_NEW;
		INIT_MAC_ENTRY_LOCK(pMacEntry);

		INIT_SYSTEM_TIMER(
					&pMacEntry->BusTimer, 
					AtmLaneBusSendTimer, 
					pMacEntry);

		pMacEntry->LimitTime = pElan->LimitTime;
		pMacEntry->IncrTime = pElan->IncrTime;
	}

	DBGP((5, "AllocateMacEntry: Allocated Entry %x\n", pMacEntry));

	TRACEOUT(AllocateMacEntry);
	return (pMacEntry);
}

VOID
AtmLaneDeallocateMacEntry(
	IN	PATMLANE_MAC_ENTRY			pMacEntry
)
/*++

Routine Description:

	Deallocate an ATMLANE Mac Entry. It is assumed that all references
	to this Mac Entry have gone, so there is no need to acquire its
	lock.

Arguments:

	pMacEntry			- Pointer to the Mac Entry to be deallocated.

Return Value:

	None

--*/
{
	TRACEIN(DeallocateMacEntry);

	STRUCT_ASSERT(pMacEntry, atmlane_mac);
	ASSERT(pMacEntry->RefCount == 0);

#if DBG
	pMacEntry->atmlane_mac_sig++;
#endif

	FREE_MAC_ENTRY_LOCK(pMacEntry);
	FREE_MEM(pMacEntry);

	DBGP((5,"DeallocateMacEntry: Deallocated Entry %x\n", pMacEntry));

	TRACEOUT(DeallocateMacEntry);
	return;
}

VOID
AtmLaneReferenceMacEntry(
	IN	PATMLANE_MAC_ENTRY			pMacEntry,
	IN	PUCHAR						String
)
/*++

Routine Description:

	Add a reference to an ATMLANE Mac Entry.
	NOTE: The caller is assumed to possess a lock for the Mac Entry.

Arguments:

	pMacEntry			- Pointer to an ATMLANE Mac Entry.

Return Value:

	None

--*/
{
	TRACEIN(ReferenceMacEntry);

	STRUCT_ASSERT(pMacEntry, atmlane_mac);

	pMacEntry->RefCount++;

	DBGP((5, "ReferenceMacEntry: Entry %x (%s) new count %d\n",
			pMacEntry, String, pMacEntry->RefCount));

	TRACEOUT(ReferenceMacEntry);
	return;
}

ULONG
AtmLaneDereferenceMacEntry(
	IN	PATMLANE_MAC_ENTRY			pMacEntry,
	IN	PUCHAR						String
)
/*++

Routine Description:

	Subtract a reference from an ATMLANE MAC Entry. If the reference
	count becomes zero, deallocate it.
	NOTE: It is assumed that the caller holds a lock to the MAC Entry.
	See SIDE EFFECT below.

Arguments:

	pMacEntry			- Pointer to ATMLANE MAC Entry

Return Value:

	The resulting reference count. If this is zero, then there are two
	SIDE EFFECTS: (1) the MAC Entry lock is released (2) the structure
	is freed.

--*/
{
	ULONG		rc;
	
	TRACEIN(DereferenceMacEntry);

	STRUCT_ASSERT(pMacEntry, atmlane_mac);

	rc = --(pMacEntry->RefCount);

	if (rc == 0)
	{
		PVOID	Caller, CallersCaller;

		RELEASE_MAC_ENTRY_LOCK(pMacEntry);

		//
		//  Save away the caller's address for debugging purposes...
		//
		RtlGetCallersAddress(&Caller, &CallersCaller);
		pMacEntry->Timer.ContextPtr = Caller;

		AtmLaneDeallocateMacEntry(pMacEntry);
	}

	DBGP((5, "DereferenceMacEntry: Entry %x (%s) new count %d\n",
			pMacEntry, String, rc));

	TRACEOUT(DereferenceMacEntry);
	return (rc);
}

PNDIS_PACKET
AtmLaneAllocProtoPacket(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Allocate an NDIS packet for use as a LANE control frame.

Arguments:

	pElan		- Pointer to ATMLANE ELAN structure

Return Value:

	Pointer to NDIS packet if allocated, NULL otherwise.

--*/
{
	NDIS_STATUS		Status;
	PNDIS_PACKET	pNdisPacket;

	TRACEIN(AllocProtoPacket);

	NdisAllocatePacket(
			&Status,
			&pNdisPacket,
			pElan->ProtocolPacketPool
		);
		
	if (pNdisPacket != (PNDIS_PACKET)NULL)
	{
		//
		//	Init ProtocolReserved and mark packet owned by ATMLANE
		//
		ZERO_SEND_RSVD(pNdisPacket);
	#if PROTECT_PACKETS
		INIT_SENDPACKET_LOCK(pNdisPacket);
	#endif	// PROTECT_PACKETS
		SET_FLAG(
				PSEND_RSVD(pNdisPacket)->Flags,
				PACKET_RESERVED_OWNER_MASK,
				PACKET_RESERVED_OWNER_ATMLANE
				);
		
#if PKT_HDR_COUNTS
		InterlockedDecrement(&pElan->ProtPktCount);
		if ((pElan->ProtPktCount % 20) == 0)
		{
			DBGP((1, "ProtPktCount %d\n", pElan->ProtPktCount));
		}
#endif
	}	

	TRACEOUT(AllocProtoPacket);

	return (pNdisPacket);
}

VOID
AtmLaneFreeProtoPacket(
	IN	PATMLANE_ELAN			pElan,
	IN	PNDIS_PACKET			pNdisPacket
)
/*++

Routine Description:

	Allocate an NDIS packet used as a LANE control frame.

Arguments:

	pElan			- Pointer to ATMLANE ELAN structure

	pNdisPacket		- pointer to NDIS_PACKET to free.

Return Value:

	None
	
--*/
{
	TRACEIN(FreeProtoPacket);

	if (pNdisPacket != (PNDIS_PACKET)NULL)
	{
#if PROTECT_PACKETS
		FREE_SENDPACKET_LOCK(pNdisPacket);
#endif	// PROTECT_PACKETS
		NdisFreePacket(pNdisPacket);
#if PKT_HDR_COUNTS
		InterlockedIncrement(&pElan->ProtPktCount);
		if ((pElan->ProtPktCount % 20) == 0 && 
			pElan->ProtPktCount != pElan->MaxProtocolBufs)
		{
			DBGP((1, "ProtPktCount %d\n", pElan->ProtPktCount));
		}
#endif
	}

	TRACEOUT(FreeProtoPacket);
	return;
}

PNDIS_BUFFER
AtmLaneGrowHeaders(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Allocate a bunch of header buffers on the specified ATMLANE Elan.
	Return one of them.

	We allocate a new Buffer tracker structure, a new NDIS Buffer pool, and
	finally a chunk of system memory that we break down into header buffers.
	These header buffers are then attached to NDIS Buffers before they are
	inserted into the list of free header buffers for this Interface.

	Caller is assumed to hold appropriate lock.

Arguments:

	pElan		- Pointer to ATMLANE Elan structure

Return Value:

	Pointer to allocated NDIS buffer if successful, NULL otherwise.

--*/
{
	PATMLANE_BUFFER_TRACKER		pTracker;		// for new set of buffers
	PUCHAR						pSpace;
	PNDIS_BUFFER				pNdisBuffer;
	PNDIS_BUFFER				pReturnBuffer;
	PNDIS_BUFFER				pBufferList;	// allocated list
	INT							i;				// iteration counter
	NDIS_STATUS					Status;

	TRACEIN(GrowHeaders);

	//
	//  Initialize
	//
	pTracker = NULL_PATMLANE_BUFFER_TRACKER;
	pReturnBuffer = (PNDIS_BUFFER)NULL;

	do
	{
		if (pElan->CurHeaderBufs >= pElan->MaxHeaderBufs)
		{
			DBGP((2, "GrowHeaders: Elan %x, CurHdrBufs %d > MaxHdrBufs %d\n",
					pElan, pElan->CurHeaderBufs, pElan->MaxHeaderBufs));
			break;
		}

		//
		//  Allocate and initialize Buffer tracker
		//
		ALLOC_MEM(&pTracker, sizeof(ATMLANE_BUFFER_TRACKER));
		if (pTracker == NULL_PATMLANE_BUFFER_TRACKER)
		{
			DBGP((0, "GrowHeaders: Elan %x, alloc failed for tracker\n",
					pElan));
			break;
		}

		NdisZeroMemory(pTracker, sizeof(ATMLANE_BUFFER_TRACKER));

		//
		//  Get the NDIS Buffer pool
		//
		NdisAllocateBufferPool(
				&Status,
				&(pTracker->NdisHandle),
				DEF_HDRBUF_GROW_SIZE
			);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, 
				"GrowHeaders: Elan %x, NdisAllocateBufferPool err status %x\n",
					pElan, Status));
			break;
		}

		//
		//  Allocate system space for a bunch of header buffers
		//	Note we use RealHeaderBufSize here so that the
		//	buffers end up on ULONG boundaries.
		//
		ALLOC_MEM(&(pTracker->pPoolStart),  
					pElan->RealHeaderBufSize * DEF_HDRBUF_GROW_SIZE);
		if (pTracker->pPoolStart == (PUCHAR)NULL)
		{
			DBGP((0, "GrowHeaders: Elan %x, could not alloc buf space %d bytes\n",
					pElan, pElan->HeaderBufSize * DEF_HDRBUF_GROW_SIZE));
			break;
		}

		//
		//  Make NDIS buffers out of the allocated space, and put them
		//  into the free header buffer list. Retain one for returning
		//  to caller.
		//
		pBufferList = (PNDIS_BUFFER)NULL;
		pSpace = pTracker->pPoolStart;
		for (i = 0; i < DEF_HDRBUF_GROW_SIZE; i++)
		{
			NdisAllocateBuffer(
					&Status,
					&pNdisBuffer,
					pTracker->NdisHandle,
					pSpace,
					pElan->HeaderBufSize
				);

			if (Status != NDIS_STATUS_SUCCESS)
			{
				DBGP((0, 
					"GrowHeaders: NdisAllocateBuffer failed: Elan %x, status %x\n",
							pElan, Status));
				break;
			}

			if (i == 0)
			{
				pReturnBuffer = pNdisBuffer;
			}
			else
			{
				NDIS_BUFFER_LINKAGE(pNdisBuffer) = pBufferList;
				pBufferList = pNdisBuffer;
			}
			pSpace += pElan->RealHeaderBufSize;
		}

		if (i > 0)
		{
			//
			//  Successfully allocated at least one more header buffer
			//
			pTracker->pNext = pElan->pHeaderTrkList;
			pElan->pHeaderTrkList = pTracker;
			pElan->CurHeaderBufs += i;

			pNdisBuffer = pBufferList;
			while (pNdisBuffer != (PNDIS_BUFFER)NULL)
			{
				pBufferList = NDIS_BUFFER_LINKAGE(pNdisBuffer);
				NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
				AtmLaneFreeHeader(pElan, pNdisBuffer, TRUE);
				pNdisBuffer = pBufferList;
			}
		}

	} while (FALSE);

	if (pReturnBuffer == (PNDIS_BUFFER)NULL)
	{
		//
		//  Failed to allocate. Undo all.
		//
		if (pTracker != NULL_PATMLANE_BUFFER_TRACKER)
		{
			if (pTracker->pPoolStart != (PUCHAR)NULL)
			{
				FREE_MEM(pTracker->pPoolStart);
			}
			if (pTracker->NdisHandle != (NDIS_HANDLE)NULL)
			{
				NdisFreeBufferPool(pTracker->NdisHandle);
			}
			FREE_MEM(pTracker);
		}
	}

	DBGP((2, "GrowHeaders: Elan %x, RetBuf %x, New Tracker %x\n",
				pElan, pReturnBuffer, pTracker));

	TRACEOUT(GrowHeaders);

	return (pReturnBuffer);
}

PNDIS_BUFFER
AtmLaneAllocateHeader(
	IN	PATMLANE_ELAN			pElan,
	OUT	PUCHAR *				pBufferAddress
)
/*++

Routine Description:

	Allocate an NDIS Buffer to be used for LECID a MAC packet. 
	We pick up the buffer at the top of the pre-allocated
	buffer list, if one exists. Otherwise, we try to grow this list and
	allocate.

Arguments:

	pElan			- Pointer to ATMLANE Elan
	pBufferAddress	- Place to return virtual address of allocated buffer

Return Value:

	Pointer to NDIS buffer if successful, NULL otherwise.

--*/
{
	PNDIS_BUFFER			pNdisBuffer;
	NDIS_STATUS				Status;
	ULONG					Length;

	TRACEIN(AllocateHeader);

	ACQUIRE_HEADER_LOCK(pElan);

	pNdisBuffer = pElan->HeaderBufList;
	if (pNdisBuffer != (PNDIS_BUFFER)NULL)
	{
		pElan->HeaderBufList = NDIS_BUFFER_LINKAGE(pNdisBuffer);
		NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
		NdisQueryBuffer(pNdisBuffer, (PVOID)pBufferAddress, &Length);
	}
	else
	{
		pNdisBuffer = AtmLaneGrowHeaders(pElan);
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
			NdisQueryBuffer(pNdisBuffer, (PVOID)pBufferAddress, &Length);
		}
	}

	DBGP((5, "AllocateHeader: Buffer %x, Elan %x\n",
					pNdisBuffer, pElan));

	RELEASE_HEADER_LOCK(pElan);

	TRACEOUT(AllocateHeader);
	return (pNdisBuffer);
}

VOID
AtmLaneFreeHeader(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	BOOLEAN						LockHeld
)
/*++

Routine Description:

	Deallocate a header buffer.

Arguments:

	pElan			- Pointer to ATMLANE Elan from which the buffer came
	pNdisBuffer		- Pointer to NDIS buffer being freed
	LockHeld		- TRUE if appropriate lock already held

Return Value:

	None

--*/
{
	TRACEIN(FreeHeader);

	if (!LockHeld)
	{
		ACQUIRE_HEADER_LOCK(pElan);
	}

	NDIS_BUFFER_LINKAGE(pNdisBuffer) = pElan->HeaderBufList;
	pElan->HeaderBufList = pNdisBuffer;

	DBGP((5, "FreeHeader: Buffer %x, Elan %x\n",
					pNdisBuffer, pElan));
					
	if (!LockHeld)
	{
		RELEASE_HEADER_LOCK(pElan);
	}
	
	TRACEOUT(FreeHeader);
}

VOID
AtmLaneDeallocateHeaderBuffers(
	IN	PATMLANE_ELAN				pElan
)
/*++

Routine Description:

	Deallocate everything pertaining to header buffers on an Elan.

Arguments:

	pElan				- Pointer to ATMLANE Elan.

Return Value:

	None

--*/
{
	PNDIS_BUFFER				pNdisBuffer;
	NDIS_STATUS					Status;
	PATMLANE_BUFFER_TRACKER		pTracker;
	PATMLANE_BUFFER_TRACKER		pNextTracker;

	TRACEIN(DeallocateHeaderBuffers);

	//
	//  Free all NDIS buffers in the header buffer list.
	//
	ACQUIRE_HEADER_LOCK(pElan);
	do
	{
		pNdisBuffer = pElan->HeaderBufList;
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			pElan->HeaderBufList = NDIS_BUFFER_LINKAGE(pNdisBuffer);
			NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
			NdisFreeBuffer(pNdisBuffer);
		}
		else
		{
			//
			//  No more NDIS buffers.
			//
			break;
		}
	}
	while (TRUE);

	//
	//  Now free all the buffer trackers.
	//
	pTracker = pElan->pHeaderTrkList;

	while (pTracker != NULL_PATMLANE_BUFFER_TRACKER)
	{
		pNextTracker = pTracker->pNext;
		if (pTracker->pPoolStart != (PUCHAR)NULL)
		{
			FREE_MEM(pTracker->pPoolStart);
			pTracker->pPoolStart = (PUCHAR)NULL;
		}
		if (pTracker->NdisHandle != (NDIS_HANDLE)NULL)
		{
			NdisFreeBufferPool(pTracker->NdisHandle);
			pTracker->NdisHandle = (NDIS_HANDLE)NULL;
		}
		FREE_MEM(pTracker);
		pTracker = pNextTracker;
	}

	RELEASE_HEADER_LOCK(pElan);

	TRACEOUT(DeallocateHeaderBuffers);
}

PNDIS_BUFFER
AtmLaneGrowPadBufs(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Allocate a bunch of packet pad buffers on the specified ATMLANE Elan.
	Return one of them.

	We allocate a new Buffer tracker structure, a new NDIS Buffer pool, and
	finally a chunk of system memory (if not allocated already, only need one).
	This buffer is then attached to the NDIS Buffers before they are
	inserted into the list of free pad buffers for this Interface.

	Caller is assumed to hold appropriate lock.

Arguments:

	pElan		- Pointer to ATMLANE Elan structure

Return Value:

	Pointer to allocated NDIS buffer if successful, NULL otherwise.

--*/
{
	PATMLANE_BUFFER_TRACKER		pTracker;		// for new set of buffers
	PUCHAR						pSpace;
	PNDIS_BUFFER				pNdisBuffer;
	PNDIS_BUFFER				pReturnBuffer;
	PNDIS_BUFFER				pBufferList;	// allocated list
	INT							i;				// iteration counter
	NDIS_STATUS					Status;

	TRACEIN(GrowPadBufs);

	//
	//  Initialize
	//
	pTracker = NULL_PATMLANE_BUFFER_TRACKER;
	pReturnBuffer = (PNDIS_BUFFER)NULL;

	do
	{
		if (pElan->CurPadBufs >= pElan->MaxPadBufs)
		{
			DBGP((0, "GrowPadBufs: Max Reached! Elan %x, CurPadBufs %d > MaxPadBufs %d\n",
					pElan, pElan->CurPadBufs, pElan->MaxPadBufs));
			break;
		}

		//
		//  Allocate and initialize Buffer tracker
		//
		ALLOC_MEM(&pTracker, sizeof(ATMLANE_BUFFER_TRACKER));
		if (pTracker == NULL_PATMLANE_BUFFER_TRACKER)
		{
			DBGP((0, "GrowPadBufs: Elan %x, alloc failed for tracker\n",
					pElan));
			break;
		}

		NdisZeroMemory(pTracker, sizeof(ATMLANE_BUFFER_TRACKER));

		//
		//  Get the NDIS Buffer pool
		//
		NdisAllocateBufferPool(
				&Status,
				&(pTracker->NdisHandle),
				DEF_HDRBUF_GROW_SIZE
			);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, 
				"GrowPadBufs: Elan %x, NdisAllocateBufferPool err status %x\n",
					pElan, Status));
			break;
		}

		//
		//  Allocate system space for a single pad buffer.
		//
		ALLOC_MEM(&(pTracker->pPoolStart), pElan->PadBufSize);
		if (pTracker->pPoolStart == (PUCHAR)NULL)
		{
			DBGP((0, "GrowPadBufs: Elan %x, could not alloc buf space %d bytes\n",
					pElan, pElan->PadBufSize * DEF_HDRBUF_GROW_SIZE));
			break;
		}

		//
		//  Make NDIS buffers out of the allocated space, and put them
		//  into the free pad buffer list. Retain one for returning
		//  to caller.  NOTE we put same pad buffer in each ndis buffer header
		//	since contents is irrelevent.
		//
		pBufferList = (PNDIS_BUFFER)NULL;
		pSpace = pTracker->pPoolStart;
		for (i = 0; i < DEF_HDRBUF_GROW_SIZE; i++)
		{
			NdisAllocateBuffer(
					&Status,
					&pNdisBuffer,
					pTracker->NdisHandle,
					pSpace,
					pElan->PadBufSize
				);

			if (Status != NDIS_STATUS_SUCCESS)
			{
				DBGP((0, 
					"GrowPadBufs: NdisAllocateBuffer failed: Elan %x, status %x\n",
							pElan, Status));
				break;
			}

			if (i == 0)
			{
				pReturnBuffer = pNdisBuffer;
			}
			else
			{
				NDIS_BUFFER_LINKAGE(pNdisBuffer) = pBufferList;
				pBufferList = pNdisBuffer;
			}
		}

		if (i > 0)
		{
			//
			//  Successfully allocated at least one more pad buffer
			//
			pTracker->pNext = pElan->pPadTrkList;
			pElan->pPadTrkList = pTracker;
			pElan->CurPadBufs += i;

			pNdisBuffer = pBufferList;
			while (pNdisBuffer != (PNDIS_BUFFER)NULL)
			{
				pBufferList = NDIS_BUFFER_LINKAGE(pNdisBuffer);
				NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
				AtmLaneFreePadBuf(pElan, pNdisBuffer, TRUE);
				pNdisBuffer = pBufferList;
			}
		}

	} while (FALSE);

	if (pReturnBuffer == (PNDIS_BUFFER)NULL)
	{
		//
		//  Failed to allocate. Undo all.
		//
		if (pTracker != NULL_PATMLANE_BUFFER_TRACKER)
		{
			if (pTracker->pPoolStart != (PUCHAR)NULL)
			{
				FREE_MEM(pTracker->pPoolStart);
			}
			if (pTracker->NdisHandle != (NDIS_HANDLE)NULL)
			{
				NdisFreeBufferPool(pTracker->NdisHandle);
			}
			FREE_MEM(pTracker);
		}
	}

	DBGP((2, "GrowPadBufs: Elan %x, RetBuf %x, New Tracker %x\n",
				pElan, pReturnBuffer, pTracker));

	TRACEOUT(GrowPadBufs);

	return (pReturnBuffer);
}

PNDIS_BUFFER
AtmLaneAllocatePadBuf(
	IN	PATMLANE_ELAN			pElan,
	OUT	PUCHAR *				pBufferAddress
)
/*++

Routine Description:

	Allocate an NDIS Buffer to be used to pad a MAC packet to min length.
	We pick up the buffer at the top of the pre-allocated
	buffer list, if one exists. Otherwise, we try to grow this list and
	allocate.

Arguments:

	pElan			- Pointer to ATMLANE Elan
	pBufferAddress	- Place to return virtual address of allocated buffer

Return Value:

	Pointer to NDIS buffer if successful, NULL otherwise.

--*/
{
	PNDIS_BUFFER			pNdisBuffer;
	NDIS_STATUS				Status;
	ULONG					Length;

	TRACEIN(AtmLaneAllocatePadBuf);

	ACQUIRE_HEADER_LOCK(pElan);

	pNdisBuffer = pElan->PadBufList;
	if (pNdisBuffer != (PNDIS_BUFFER)NULL)
	{
		pElan->PadBufList = NDIS_BUFFER_LINKAGE(pNdisBuffer);
		NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
		NdisQueryBuffer(pNdisBuffer, (PVOID)pBufferAddress, &Length);
	}
	else
	{
		pNdisBuffer = AtmLaneGrowPadBufs(pElan);
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
			NdisQueryBuffer(pNdisBuffer, (PVOID)pBufferAddress, &Length);
		}
	}

	DBGP((5, "AllocatePadBuf: Buffer %x, Elan %x\n",
					pNdisBuffer, pElan));

	RELEASE_HEADER_LOCK(pElan);

	TRACEOUT(AllocatePadBuf);
	return (pNdisBuffer);
}

VOID
AtmLaneFreePadBuf(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	BOOLEAN						LockHeld
)
/*++

Routine Description:

	Deallocate a Pad buffer.

Arguments:

	pElan			- Pointer to ATMLANE Elan from which the buffer came
	pNdisBuffer		- Pointer to NDIS buffer being freed
	LockHeld		- TRUE if appropriate lock already held

Return Value:

	None

--*/
{
	TRACEIN(FreePadBuf);

	if (!LockHeld)
	{
		ACQUIRE_HEADER_LOCK(pElan);
	}

	NDIS_BUFFER_LINKAGE(pNdisBuffer) = pElan->PadBufList;
	pElan->PadBufList = pNdisBuffer;

	DBGP((5, "FreePadBuf: Buffer %x, Elan %x\n",
					pNdisBuffer, pElan));
					
	if (!LockHeld)
	{
		RELEASE_HEADER_LOCK(pElan);
	}
	
	TRACEOUT(FreePadBuf);
}

VOID
AtmLaneDeallocatePadBufs(
	IN	PATMLANE_ELAN				pElan
)
/*++

Routine Description:

	Deallocate everything pertaining to Pad buffers on an Elan.

Arguments:

	pElan				- Pointer to ATMLANE Elan.

Return Value:

	None

--*/
{
	PNDIS_BUFFER				pNdisBuffer;
	NDIS_STATUS					Status;
	PATMLANE_BUFFER_TRACKER		pTracker;
	PATMLANE_BUFFER_TRACKER		pNextTracker;

	TRACEIN(DeallocatePadBufs);

	//
	//  Free all NDIS buffers in the Pad buffer list.
	//
	ACQUIRE_HEADER_LOCK(pElan);
	do
	{
		pNdisBuffer = pElan->PadBufList;
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			pElan->PadBufList = NDIS_BUFFER_LINKAGE(pNdisBuffer);
			NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
			NdisFreeBuffer(pNdisBuffer);
		}
		else
		{
			//
			//  No more NDIS buffers.
			//
			break;
		}
	}
	while (TRUE);

	//
	//  Now free all the buffer trackers.
	//
	pTracker = pElan->pPadTrkList;

	while (pTracker != NULL_PATMLANE_BUFFER_TRACKER)
	{
		pNextTracker = pTracker->pNext;
		if (pTracker->pPoolStart != (PUCHAR)NULL)
		{
			FREE_MEM(pTracker->pPoolStart);
			pTracker->pPoolStart = (PUCHAR)NULL;
		}
		if (pTracker->NdisHandle != (NDIS_HANDLE)NULL)
		{
			NdisFreeBufferPool(pTracker->NdisHandle);
			pTracker->NdisHandle = (NDIS_HANDLE)NULL;
		}
		FREE_MEM(pTracker);
		pTracker = pNextTracker;
	}

	RELEASE_HEADER_LOCK(pElan);

	TRACEOUT(DeallocatePadBufs);
}

PNDIS_BUFFER
AtmLaneAllocateProtoBuffer(
	IN	PATMLANE_ELAN				pElan,
	IN	ULONG						Length,
	OUT	PUCHAR *					pBufferAddress
)
/*++

Routine Description:

	Allocate a buffer to be used for a LANE protocol message. Attach
	it to an NDIS_BUFFER structure and return a pointer to this.

Arguments:

	pElan			- Pointer to ATMLANE Elan
	Length			- Length, in bytes, of the buffer.
	pBufferAddress	- Place to return virtual address of allocated buffer.

Return Value:

	Pointer to NDIS Buffer if successful, NULL otherwise.

--*/
{
	PNDIS_BUFFER		pNdisBuffer;
	NDIS_STATUS			Status;

	TRACEIN(AllocateProtobuffer);
	
	//
	//  Initialize
	//
	pNdisBuffer = NULL;

	ACQUIRE_ELAN_LOCK(pElan);

	ASSERT(Length <= pElan->ProtocolBufSize);

	*pBufferAddress = pElan->ProtocolBufList;
	if (*pBufferAddress != (PUCHAR)NULL)
	{
		NdisAllocateBuffer(
				&Status,
				&pNdisBuffer,
				pElan->ProtocolBufferPool,
				*pBufferAddress,
				Length
			);

		if (Status == NDIS_STATUS_SUCCESS)
		{
			pElan->ProtocolBufList = *((PUCHAR *)*pBufferAddress);
		}
	}

	RELEASE_ELAN_LOCK(pElan);

	DBGP((5, 
		"AllocateProtoBuffer:  ELan %x, pNdisBuffer %x, Length %d, Loc %x\n",
				pElan, pNdisBuffer, Length, *pBufferAddress));

	TRACEOUT(AllocateProtoBuffer);
	
	return (pNdisBuffer);
}


VOID
AtmLaneFreeProtoBuffer(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_BUFFER				pNdisBuffer
)
/*++

Routine Description:

	Free an NDIS buffer (and associated memory) used for a protocol
	packet. We return the associated memory to the ProtocolBufList
	in the Elan structure, and the NDIS buffer to NDIS.

Arguments:

	pElan			- Pointer to ATMLANE Elan structure
	pNdisBuffer		- Pointer to NDIS buffer to be freed

Return Value:

	None

--*/
{
	PUCHAR *		pBufferLinkage;
	ULONG			Length;

	TRACEIN(FreeProtoBuffer);

#if 0
	pBufferLinkage = (PUCHAR *)NdisBufferVirtualAddress(pNdisBuffer);
#else
	NdisQueryBuffer(pNdisBuffer, (PVOID)&pBufferLinkage, &Length);
#endif

	ACQUIRE_ELAN_LOCK(pElan);

	*pBufferLinkage = pElan->ProtocolBufList;
	pElan->ProtocolBufList = (PUCHAR)pBufferLinkage;

	RELEASE_ELAN_LOCK(pElan);

	NdisFreeBuffer(pNdisBuffer);

	DBGP((5, "FreeProtoBuffer: Elan %x, pNdisBuffer %x, Loc %x\n",
			pElan, pNdisBuffer, (ULONG_PTR)pBufferLinkage));

	TRACEOUT(FreeProtoBuffer);
	return;
}


NDIS_STATUS
AtmLaneInitProtoBuffers(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Initialize the protocol buffer pool for an elan.

	Allocate a chunk of memory to be used for ATMLANE protocol messages.
	We prepare a linked list of protocol buffers, and attach it to the
	Interface structure.

Arguments:

	pElan			- Pointer to Interface on which we need to allocate
					  protocol buffers.
Return Value:

	NDIS_STATUS_SUCCESS if successful, NDIS_STATUS_RESOURCES if we run
	into a resource failure.

--*/
{
	NDIS_STATUS			Status;
	PUCHAR				pSpace;
	ULONG				i;

	TRACEIN(InitProtoBuffers);

	do
	{
		NdisAllocatePacketPool(
				&Status,
				&(pElan->ProtocolPacketPool),
				pElan->MaxProtocolBufs,
				sizeof(SEND_PACKET_RESERVED)
				);
#if PKT_HDR_COUNTS
		pElan->ProtPktCount = pElan->MaxProtocolBufs;
		DBGP((1, "ProtPktCount %d\n", pElan->ProtPktCount));
#endif

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		NdisAllocateBufferPool(
				&Status,
				&(pElan->ProtocolBufferPool),
				pElan->MaxProtocolBufs
				);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		//
		//  Allocate a big chunk of system memory that we can divide up into
		//  protocol buffers.
		//
		ALLOC_MEM(
				&(pElan->ProtocolBufTracker),
				(pElan->ProtocolBufSize * pElan->MaxProtocolBufs)
				);

		if (pElan->ProtocolBufTracker == (PUCHAR)NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		Status = NDIS_STATUS_SUCCESS;

		//
		//  Make all protocol buffers free.
		//
		pSpace = pElan->ProtocolBufTracker;
		{
			PUCHAR	LinkPtr;

			LinkPtr = (PUCHAR)NULL;
			for (i = 0; i < pElan->MaxProtocolBufs; i++)
			{
				*((PUCHAR *)pSpace) = LinkPtr;
				LinkPtr = pSpace;
				pSpace += pElan->ProtocolBufSize;
			}
			pSpace -= pElan->ProtocolBufSize;
			pElan->ProtocolBufList = pSpace;
		}
	}
	while (FALSE);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		//
		//  Undo everything.
		//
		AtmLaneDeallocateProtoBuffers(pElan);
	}

	TRACEOUT(InitProtoBuffers);
	
	return (Status);
}


VOID
AtmLaneDeallocateProtoBuffers(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Free the protocol buffer pool for an interface.

Arguments:

	pElan		- Pointer to ATMLANE elan structure

Return Value:

	None

--*/
{
	if (pElan->ProtocolPacketPool != (NDIS_HANDLE)NULL)
	{
		NdisFreePacketPool(pElan->ProtocolPacketPool);
		pElan->ProtocolPacketPool = NULL;
	}

	if (pElan->ProtocolBufferPool != (NDIS_HANDLE)NULL)
	{
		NdisFreeBufferPool(pElan->ProtocolBufferPool);
		pElan->ProtocolBufferPool = NULL;
	}

	if (pElan->ProtocolBufTracker != (PUCHAR)NULL)
	{
		FREE_MEM(pElan->ProtocolBufTracker);
		pElan->ProtocolBufTracker = (PUCHAR)NULL;
	}
}

VOID
AtmLaneLinkVcToAtmEntry(
	IN	PATMLANE_VC					pVc,
	IN	PATMLANE_ATM_ENTRY			pAtmEntry,
	IN	BOOLEAN						ServerIncoming
)
/*++

Routine Description:

	Link an ATMLANE VC to an ATM Entry. The caller is assumed to
	hold locks to both structures.

Arguments:

	pVc					- Pointer to ATMLANE VC structure
	pAtmEntry			- Pointer to ATMLANE ATM Entry structure
	ServerIncoming		- Incoming call from server 

Return Value:

	None

--*/
{
	PATMLANE_VC *		ppNext;
	PATMLANE_VC			pVcEntry;
	BOOLEAN				WasRunning;

	TRACEIN(LinkVcToAtmEntry);

	DBGP((2, "LinkVcToAtmEntry: pVc %x to pAtmEntry %x ServerIncoming %s\n",
			pVc, pAtmEntry, ServerIncoming?"TRUE":"FALSE"));

	//
	//  Back pointer from VC to ATM Entry.
	//
	pVc->pAtmEntry = pAtmEntry;
	
	//
	//	If server incoming connection cache the VC
	//	special location in the AtmEntry.
	//
	if (ServerIncoming)
	{
		pAtmEntry->pVcIncoming = pVc;
		pVc->pNextVc = NULL_PATMLANE_VC;
	}
	else
	{
		//
		//	Otherwise...
		//
		//	Add VC to the list in ascending calling party ATM address order
		//
		ppNext = &pAtmEntry->pVcList;
		while (*ppNext != NULL_PATMLANE_VC)
		{
			if (memcmp(
					&pVc->CallingAtmAddress.Address, 
					(*ppNext)->CallingAtmAddress.Address, 
					ATM_ADDRESS_LENGTH) < 0)
			{
				// 
				//	Calling address is less than existing VC.
				//
				break;
			}
			else
			{
				//
				//	Calling address is equal or greater than existing VC.
				//	Move on to next.
				//			
				ppNext = &((*ppNext)->pNextVc);
			}
		}

		//
		//  Found the place we were looking for. Insert the VC here.
		//
		pVc->pNextVc = *ppNext;
		*ppNext = pVc;

	}

	//
	//	Add the VC reference to the ATM entry.
	//
	AtmLaneReferenceAtmEntry(pAtmEntry, "vc");	// VC reference

	//
	//	Add the ATM Entry reference to the VC.
	//
	AtmLaneReferenceVc(pVc, "atm");

	//
	//	If this VC is not the first in the list, i.e., not the lowest
	//	calling party number, then set the timeout to the fast VC 
	//	timeout value.  This will get rid of redundant DataDirect VCs quickly 
	//	ONLY if they don't get used within the fast timeout period. 
	//	Otherwise the timeout handler to keep the VC and set
	//	the timeout to the normal C12-VccTimeout value.
	//
	if (pVc != pAtmEntry->pVcList)
	{
		pVc->AgingTime = FAST_VC_TIMEOUT;
	}

	TRACEOUT(LinkVcToAtmEntry);
}

BOOLEAN
AtmLaneUnlinkVcFromAtmEntry(
	IN	PATMLANE_VC					pVc
)
/*++

Routine Description:

	Unlink an ATMLANE VC from the ATM Entry it is linked to.
	The caller is assumed to hold a lock for the VC structure.

Arguments:

	pVc				- Pointer to ATMLANE VC structure

Return Value:

	TRUE if we found the VC linked to the list on the ATM entry, and unlinked it.

--*/
{
	PATMLANE_ATM_ENTRY			pAtmEntry;
	PATMLANE_MAC_ENTRY			pMacEntry, pNextMacEntry;
	ULONG						rc;
	PATMLANE_VC *				ppVc;
	BOOLEAN						Found;

	DBGP((3, "UnlinkVcFromAtmEntry: pVc %x from pAtmEntry %x\n",
			pVc, pVc->pAtmEntry));

	pAtmEntry = pVc->pAtmEntry;
	ASSERT(NULL_PATMLANE_ATM_ENTRY != pAtmEntry);
	
	pVc->pAtmEntry = NULL_PATMLANE_ATM_ENTRY;

	//
	//	Reacquire locks in the right order.
	//
	AtmLaneReferenceVc(pVc, "temp");
	RELEASE_VC_LOCK(pVc);
	ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
	ACQUIRE_VC_LOCK(pVc);


	//
	//	VC is either a server incoming uni-directional connection,
	//	where it is linked to the AtmEntry via pVcIncoming, or a 
	// 	bi-directional connection that is in the pVcList.
	//
	if (pAtmEntry->pVcIncoming == pVc)
	{
		//
		//  If server incoming VC just remove single entry
		//
		pAtmEntry->pVcIncoming = NULL_PATMLANE_VC;
		Found = TRUE;
	}
	else
	{
		//
		//  Otherwise, find this VC in the ATM Entry's VC list
		//
		ppVc = &(pAtmEntry->pVcList);
		while (*ppVc != NULL_PATMLANE_VC && *ppVc != pVc)
		{
			ppVc = &((*ppVc)->pNextVc);
		}

		//
		//  Remove this VC by making it's predecessor in the list
		//	point to the next VC in the list.
		//
		if (*ppVc == pVc)
		{
			*ppVc = pVc->pNextVc;
			Found = TRUE;
		}
		else
		{
			Found = FALSE;
		}
	}

	rc = AtmLaneDereferenceVc(pVc, "temp");
	if (rc > 0)
	{
		RELEASE_VC_LOCK(pVc);
	}

	//
	//	If no more VC's in list mark AtmEntry as NOT connected
	//
	if (pAtmEntry->pVcList == NULL_PATMLANE_VC)
	{
		SET_FLAG(
				pAtmEntry->Flags,
				ATM_ENTRY_STATE_MASK,
				ATM_ENTRY_VALID);

		DBGP((2, "UnlinkVcFromAtmEntry: Aborting MAC Entries\n"));
		
		pMacEntry = pAtmEntry->pMacEntryList;

		//
		//  Take the MAC entry list out so that we can reference
		//  entries in this list in peace later on below.
		//
		pAtmEntry->pMacEntryList = NULL_PATMLANE_MAC_ENTRY;

		//
		//  Let go of the ATM entry lock while we abort all
		//  the MAC entries in the list above. The ATM entry
		//  won't go away because of the VC reference still on it.
		//  The MAC entries in the list won't go away since they
		//  have the ATM entry reference on them (see UnlinkMacEntry..).
		//
		RELEASE_ATM_ENTRY_LOCK(pAtmEntry);

		while (pMacEntry != NULL)
		{
			pNextMacEntry = pMacEntry->pNextToAtm;

			//
			//  Now abort the MAC Entry. Put this MAC entry back
			//  on the ATM entry's list so that it gets handled
			//  appropriately by AbortMacEntry.
			//
			ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);

			ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);

			pMacEntry->pNextToAtm = pAtmEntry->pMacEntryList;
			pAtmEntry->pMacEntryList = pMacEntry;

			ASSERT(pMacEntry->pAtmEntry == pAtmEntry);

			RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);

			AtmLaneAbortMacEntry(pMacEntry);
			//	MacEntry lock released in above

			pMacEntry = pNextMacEntry;
		}

		ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);

	}

	rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "vc"); // VC reference
	if (rc > 0)	
	{
		RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
	}
	//
	//  else the ATM Entry is gone!
	//

	//
	//  Acquire the VC lock again for the caller's sake
	//
	ACQUIRE_VC_LOCK(pVc);
	return (Found);
}

BOOLEAN
AtmLaneUnlinkMacEntryFromAtmEntry(
	IN	PATMLANE_MAC_ENTRY			pMacEntry
)
/*++

Routine Description:

	Unlink a Mac Entry from the ATM Entry it is linked to.
	Allow for the MAC entry to be absent in the ATM Entry's list.
	The caller is assumed to hold a lock for the Mac Entry.

Arguments:

	pMacEntry			- Pointer to Mac Entry to be unlinked.

Return Value:

	TRUE iff the MAC entry was found and unlinked.

--*/
{
	PATMLANE_ATM_ENTRY		pAtmEntry;
	PATMLANE_MAC_ENTRY *	ppNextMacEntry;
	ULONG					rc;				// Ref Count on ATM Entry
	BOOLEAN					bFound = FALSE;

	pAtmEntry = pMacEntry->pAtmEntry;
	ASSERT(pAtmEntry != NULL_PATMLANE_ATM_ENTRY);

	DBGP((2, "%d UnlinkMacEntryFromAtmEntry: MacEntry %x AtmEntry %x\n",
			pAtmEntry->pElan->ElanNumber,
			pMacEntry, pMacEntry->pAtmEntry));

	ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);

	//
	//  Locate the position of this MAC Entry in the ATM Entry's list.
	//
	ppNextMacEntry = &(pAtmEntry->pMacEntryList);

	while (*ppNextMacEntry != NULL_PATMLANE_MAC_ENTRY)
	{
		if (*ppNextMacEntry == pMacEntry)
		{
			//
			//  Found it.
			//
			bFound = TRUE;
			break;
		}
		else
		{
			ppNextMacEntry = &((*ppNextMacEntry)->pNextToAtm);
		}
	}

	if (bFound)
	{
		//
		//  Make the predecessor point to the next entry.
		//
		*ppNextMacEntry = pMacEntry->pNextToAtm;

		rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "mac");	// MAC entry reference
		if (rc != 0)
		{
			RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
		}
		//
		//  else the ATM Entry is gone.
		//
	}
	else
	{
		//
		//  The entry wasn't found.
		//
		RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
	}

	return bFound;
}


VOID
AtmLaneStartTimer(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_TIMER				pTimer,
	IN	ATMLANE_TIMEOUT_HANDLER		TimeoutHandler,
	IN	ULONG						SecondsToGo,
	IN	PVOID						ContextPtr
)
/*++

Routine Description:

	Start an ATMLANE timer. Based on the length (SecondsToGo) of the
	timer, we decide on whether to insert it in the short duration
	timer list or in the long duration timer list in the Elan
	structure.

	NOTE: the caller is assumed to either hold a lock to the structure
	that contains the timer, or ensure that it is safe to access the
	timer structure.

Arguments:

	pElan			- Pointer to the ATMLANE Elan
	pTimer			- Pointer to ATMLANE Timer structure
	TimeoutHandler	- Handler function to be called if this timer expires
	SecondsToGo		- When does this timer go off?
	ContextPtr		- To be passed to timeout handler if this timer expires
	ContextValue	- To be passed to timeout handler if this timer expires
	
Return Value:

	None

--*/
{
	PATMLANE_TIMER_LIST	pTimerList;		// List to which this timer goes
	PATMLANE_TIMER		pTimerListHead; // Head of above list
	ULONG				Index;			// Into timer wheel
	ULONG				TicksToGo;
	INT					i;

	TRACEIN(StartTimer);

	STRUCT_ASSERT(pElan, atmlane_elan);

	DBGP((5,
		"StartTimer: pElan %x, Secs %d, Handler %x, Ctxtp %x, pTimer %x\n",
 	 			pElan, SecondsToGo, TimeoutHandler, ContextPtr, pTimer));

	if (IS_TIMER_ACTIVE(pTimer))
	{
		DBGP((5, 
		"Start timer: pTimer %x: is active (list %x, hndlr %x), stopping it\n",
				pTimer, pTimer->pTimerList, pTimer->TimeoutHandler));
		AtmLaneStopTimer(pTimer, pElan);
	}

	ACQUIRE_ELAN_TIMER_LOCK(pElan);
	
	ASSERT(!IS_TIMER_ACTIVE(pTimer));

	//
	//  Find the list to which this timer should go, and the
	//  offset (TicksToGo)
	//
Try_Again:
	for (i = 0; i < ALT_CLASS_MAX; i++)
	{
		pTimerList = &(pElan->TimerList[i]);
		if (SecondsToGo <= pTimerList->MaxTimer)
		{
			//
			//  Found it.
			//
			TicksToGo = SecondsToGo / (pTimerList->TimerPeriod);
			if (TicksToGo >= 1)
				TicksToGo--;
			break;
		}
	}
	
	if (i == ALT_CLASS_MAX)
	{
		//
		//  Force this timer down!
		//
		SecondsToGo = pTimerList->MaxTimer;
		goto Try_Again;
	}


	//
	//  Find the position in the list for this timer
	//
	Index = pTimerList->CurrentTick + TicksToGo;
	if (Index >= pTimerList->TimerListSize)
	{
		Index -= pTimerList->TimerListSize;
	}
	ASSERT(Index < pTimerList->TimerListSize);

	pTimerListHead = &(pTimerList->pTimers[Index]);

	//
	//  Fill in the timer
	//
	pTimer->pTimerList = pTimerList;
	pTimer->LastRefreshTime = pTimerList->CurrentTick;
	pTimer->Duration = TicksToGo;
	pTimer->TimeoutHandler = TimeoutHandler;
	pTimer->ContextPtr = ContextPtr;
 
 	//
 	//  Insert this timer in the "ticking" list
 	//
 	pTimer->pPrevTimer = pTimerListHead;
 	pTimer->pNextTimer = pTimerListHead->pNextTimer;
 	if (pTimer->pNextTimer != NULL_PATMLANE_TIMER)
 	{
 		pTimer->pNextTimer->pPrevTimer = pTimer;
 	}
 	pTimerListHead->pNextTimer = pTimer;

	//
	//  Start off the system tick timer if necessary.
	//
	pTimerList->TimerCount++;
	if (pTimerList->TimerCount == 1)
	{
		DBGP((5,
			"StartTimer: Starting system timer %x, class %d on Elan %x\n",
					&(pTimerList->NdisTimer), i, pElan));

		START_SYSTEM_TIMER(&(pTimerList->NdisTimer), pTimerList->TimerPeriod);
	}

	RELEASE_ELAN_TIMER_LOCK(pElan);

	//
	//  We're done
	//
	DBGP((5,
		"Started timer %x, Elan %x, Secs %d, Index %d, Head %x\n",
				pTimer,
				pElan,
				SecondsToGo,
				Index,
				pTimerListHead));

	TRACEOUT(StartTimer);

	return;
}


BOOLEAN
AtmLaneStopTimer(
	IN	PATMLANE_TIMER			pTimer,
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Stop an ATMLANE timer, if it is running. We remove this timer from
	the active timer list and mark it so that we know it's not running.

	NOTE: the caller is assumed to either hold a lock to the structure
	that contains the timer, or ensure that it is safe to access the
	timer structure.

	SIDE EFFECT: If we happen to stop the last timer (of this "duration") on
	the Interface, we also stop the appropriate Tick function.

Arguments:

	pTimer			- Pointer to ATMLANE Timer structure
	pElan			- Pointer to interface to which the timer belongs

Return Value:

	TRUE if the timer was running, FALSE otherwise.

--*/
{
	PATMLANE_TIMER_LIST	pTimerList;			// Timer List to which this timer belongs
	BOOLEAN				WasRunning;

	TRACEIN(StopTimer);

	DBGP((5,
		"Stopping Timer %x, Elan %x, List %x, Prev %x, Next %x\n",
					pTimer,
					pElan,
					pTimer->pTimerList,
					pTimer->pPrevTimer,
					pTimer->pNextTimer));

	ACQUIRE_ELAN_TIMER_LOCK(pElan);

	if (IS_TIMER_ACTIVE(pTimer))
	{
		WasRunning = TRUE;

		//
		//  Unlink timer from the list
		//
		ASSERT(pTimer->pPrevTimer);	// the list head always exists

		pTimer->pPrevTimer->pNextTimer = pTimer->pNextTimer;
		if (pTimer->pNextTimer)
		{
			pTimer->pNextTimer->pPrevTimer = pTimer->pPrevTimer;
		}

		pTimer->pNextTimer = pTimer->pPrevTimer = NULL_PATMLANE_TIMER;

		//
		//  Update timer count on Interface, for this class of timers
		//
		pTimerList = pTimer->pTimerList;
		pTimerList->TimerCount--;

		//
		//  If all timers of this class are gone, stop the system tick timer
		//  for this class
		//
		if (pTimerList->TimerCount == 0)
		{
		DBGP((5,
			"Stopping system timer %x, List %x, Elan %x\n",
						&(pTimerList->NdisTimer),
						pTimerList,
						pElan));

			pTimerList->CurrentTick = 0;
			STOP_SYSTEM_TIMER(&(pTimerList->NdisTimer));
		}

		//
		//  Mark stopped timer as not active
		//
		pTimer->pTimerList = (PATMLANE_TIMER_LIST)NULL;

	}
	else
	{
		WasRunning = FALSE;
	}

	RELEASE_ELAN_TIMER_LOCK(pElan);

	TRACEOUT(StopTimer);

	return (WasRunning);
}




VOID
AtmLaneRefreshTimer(
	IN	PATMLANE_TIMER				pTimer
)
/*++

Routine Description:

	Refresh a timer that is already running.

	NOTE: The caller is assumed to possess a lock protecting the
	timer structure (i.e. to the structure containing the timer).

	NOTE: We don't acquire the IF Timer Lock here, to optimize
	the refresh operation. So, _within_ the confines of this routine,
	the tick handler may fire, and expire this timer. The only care
	that we take here is to make sure that we don't crash if the
	timer expires while we access the Timer list.

Arguments:

	pTimer		- Pointer to ATMLANE_TIMER structure

Return Value:

	None

--*/
{
	PATMLANE_TIMER_LIST	pTimerList;

	TRACEIN(RefreshTimer);

	if ((pTimerList = pTimer->pTimerList) != (PATMLANE_TIMER_LIST)NULL)
	{
		pTimer->LastRefreshTime = pTimerList->CurrentTick;
	}
	else
	{
		DBGP((5,
			"RefreshTimer: pTimer %x not active: Hnd %x, Ctxtp %x\n",
			 	pTimer,
			 	pTimer->TimeoutHandler,
			 	pTimer->ContextPtr
			 ));
	}

	DBGP((5,
		"Refreshed timer %x, List %x, hnd %x, Ctxtp %x, LastRefresh %d\n",
				pTimer,
				pTimer->pTimerList,
				pTimer->TimeoutHandler,
				pTimer->ContextPtr,
				pTimer->LastRefreshTime));

	TRACEOUT(RefreshTimer);

	return;
}


VOID
AtmLaneTickHandler(
	IN	PVOID						SystemSpecific1,
	IN	PVOID						Context,
	IN	PVOID						SystemSpecific2,
	IN	PVOID						SystemSpecific3
)
/*++

Routine Description:

	This is the handler we register with the system for processing each
	Timer List. This is called every "tick" seconds, where "tick" is
	determined by the granularity of the timer type.

Arguments:

	Context				- Actually a pointer to a Timer List structure
	SystemSpecific[1-3]	- Not used

Return Value:

	None

--*/
{

	PATMLANE_ELAN			pElan;
	PATMLANE_TIMER_LIST		pTimerList;

	PATMLANE_TIMER			pExpiredTimer;		// Start of list of expired timers
	PATMLANE_TIMER			pNextTimer;			// for walking above list
	PATMLANE_TIMER			pTimer;				// temp, for walking timer list
	PATMLANE_TIMER			pPrevExpiredTimer;	// for creating expired timer list

	ULONG					Index;				// into the timer wheel
	ULONG					NewIndex;			// for refreshed timers

	TRACEIN(TickHandler);

	pTimerList = (PATMLANE_TIMER_LIST)Context;
	STRUCT_ASSERT(pTimerList, atmlane_timerlist);

	pElan = (PATMLANE_ELAN)pTimerList->ListContext;
	STRUCT_ASSERT(pElan, atmlane_elan);

	DBGP((5,
		"Tick: pElan %x, List %x, Count %d\n",
		pElan, pTimerList, pTimerList->TimerCount));

	pExpiredTimer = NULL_PATMLANE_TIMER;

	ACQUIRE_ELAN_TIMER_LOCK(pElan);

	if (ELAN_STATE_OPERATIONAL == pElan->AdminState)
	{
		//
		//  Pick up the list of timers scheduled to have expired at the
		//  current tick. Some of these might have been refreshed.
		//
		Index = pTimerList->CurrentTick;
		pExpiredTimer = (pTimerList->pTimers[Index]).pNextTimer;
		(pTimerList->pTimers[Index]).pNextTimer = NULL_PATMLANE_TIMER;

		//
		//  Go through the list of timers scheduled to expire at this tick.
		//  Prepare a list of expired timers, using the pNextExpiredTimer
		//  link to chain them together.
		//
		//  Some timers may have been refreshed, in which case we reinsert
		//  them in the active timer list.
		//
		pPrevExpiredTimer = NULL_PATMLANE_TIMER;

		for (pTimer = pExpiredTimer;
		 	pTimer != NULL_PATMLANE_TIMER;
		 	pTimer = pNextTimer)
		{
			//
			// Save a pointer to the next timer, for the next iteration.
			//
			pNextTimer = pTimer->pNextTimer;

			DBGP((5,
				"Tick Handler: pElan %x, looking at timer %x, next %x\n",
					pElan, pTimer, pNextTimer));

			//
			//  Find out when this timer should actually expire.
			//
			NewIndex = pTimer->LastRefreshTime + pTimer->Duration;
			if (NewIndex >= pTimerList->TimerListSize)
			{
				NewIndex -= pTimerList->TimerListSize;
			}

			//
			//  Check if we are currently at the point of expiry.
			//
			if (NewIndex != Index)
			{
				//
				//  This timer still has some way to go, so put it back.
				//
				DBGP((5,
				"Tick: Reinserting Timer %x: Hnd %x, Durn %d, Ind %d, NewInd %d\n",
					pTimer, pTimer->TimeoutHandler, pTimer->Duration, Index, NewIndex));

				//
				//  Remove it from the expired timer list. Note that we only
				//  need to update the forward (pNextExpiredTimer) links.
				//
				if (pPrevExpiredTimer == NULL_PATMLANE_TIMER)
				{
					pExpiredTimer = pNextTimer;
				}
				else
				{
					pPrevExpiredTimer->pNextExpiredTimer = pNextTimer;
				}

				//
				//  And insert it back into the running timer list.
				//
				pTimer->pNextTimer = (pTimerList->pTimers[NewIndex]).pNextTimer;
				if (pTimer->pNextTimer != NULL_PATMLANE_TIMER)
				{
					pTimer->pNextTimer->pPrevTimer = pTimer;
				}
				pTimer->pPrevTimer = &(pTimerList->pTimers[NewIndex]);
				(pTimerList->pTimers[NewIndex]).pNextTimer = pTimer;
			}
			else
			{
				//
				//  This one has expired. Keep it in the expired timer list.
				//
				pTimer->pNextExpiredTimer = pNextTimer;
				if (pPrevExpiredTimer == NULL_PATMLANE_TIMER)
				{
					pExpiredTimer = pTimer;
				}
				pPrevExpiredTimer = pTimer;

				//
				//  Mark it as inactive.
				//
				ASSERT(pTimer->pTimerList == pTimerList);
				pTimer->pTimerList = (PATMLANE_TIMER_LIST)NULL;

				//
				//  Update the active timer count.
				//
				pTimerList->TimerCount--;
			}
		}

		//
		//  Update current tick index in readiness for the next tick.
		//
		if (++Index == pTimerList->TimerListSize)
		{
			pTimerList->CurrentTick = 0;
		}
		else
		{
			pTimerList->CurrentTick = Index;
		}

		if (pTimerList->TimerCount > 0)
		{
			//
			//  Re-arm the tick handler
			//
			DBGP((5,
				"Tick[%d]: Starting system timer %x, on Elan %x\n",
						pTimerList->CurrentTick, &(pTimerList->NdisTimer), pElan));
			
			START_SYSTEM_TIMER(&(pTimerList->NdisTimer), pTimerList->TimerPeriod);
		}
		else
		{
			pTimerList->CurrentTick = 0;
		}

	}

	RELEASE_ELAN_TIMER_LOCK(pElan);

	//
	//  Now pExpiredTimer is a list of expired timers.
	//  Walk through the list and call the timeout handlers
	//  for each timer.
	//
	while (pExpiredTimer != NULL_PATMLANE_TIMER)
	{
		pNextTimer = pExpiredTimer->pNextExpiredTimer;

		DBGP((5,
			"Expired timer %x: handler %x, next %x\n",
					pExpiredTimer, pExpiredTimer->TimeoutHandler, pNextTimer));

		(*(pExpiredTimer->TimeoutHandler))(
				pExpiredTimer,
				pExpiredTimer->ContextPtr
			);

		pExpiredTimer = pNextTimer;
	}


	TRACEOUT(TickHandler);

	return;
}

ULONG
AtmLaneSystemTimeMs(void)
/*++

Routine Description:

	This routine get the current system clock tick value and
	returns this value converted to milliseconds.
	
Arguments:

	None
	
Return Value:

	The system clock value in milliseconds.

--*/
{
#if BINARY_COMPATIBLE
    LARGE_INTEGER SystemTime;

    NdisGetCurrentSystemTime(&SystemTime);
    
    // comes back in 100 nanosecond units, we want milliseconds

	SystemTime.QuadPart /= 10000;
    
    return SystemTime.LowPart;
#else
	static LARGE_INTEGER Frequency = {0L,0L};
    LARGE_INTEGER SystemTime;

	SystemTime = KeQueryPerformanceCounter(Frequency.LowPart == 0?&Frequency:NULL);

	SystemTime.QuadPart = SystemTime.QuadPart * 1000000 / Frequency.QuadPart;

    return SystemTime.LowPart;
#endif
}


VOID
AtmLaneBitSwapMacAddr(
	IN OUT	PUCHAR		ap
)
/*++

Routine Description:

	This routine swaps (reverses) the bits in each individual
	byte of a MAC Address.  Use for Token Ring MAC addresses.
	
Arguments:

	ap		-	Pointer to array of bytes to bitswap in-place.
	
Return Value:

	None
	
--*/
{
	int 			i;
	unsigned int 	x;

    for (i = 0; i != 6; i++) 
    {
		x = ap[i];
		x = ((x & 0xaau) >> 1) | ((x & 0x55u) << 1);
		x = ((x & 0xccu) >> 2) | ((x & 0x33u) << 2);
		x = ((x & 0xf0u) >> 4) | ((x & 0x0fu) << 4);
		ap[i] = (UCHAR)x;
    }
}

BOOLEAN
AtmLaneCopyUnicodeString(
	IN OUT	PUNICODE_STRING pDestString,
	IN OUT	PUNICODE_STRING pSrcString,
	IN		BOOLEAN			AllocDest,
	IN		BOOLEAN			ConvertToUpper
)
{
/*++

Routine Description:

	This routine optionally allocates space in the destination string
	for the source string plus a terminating null.  It
	copies the source string to the destination string and 
	terminates the destination string with a null.
	
-*/
	BOOLEAN Result 		= TRUE;

	TRACEIN(CopyUnicodeString);

	do
	{
		//	Alloc space for the destination string if requested

		if (AllocDest)
		{
			ALLOC_MEM(&(pDestString->Buffer), pSrcString->Length + sizeof(WCHAR));
			if (NULL == pDestString->Buffer)
			{
				Result = FALSE;
				break;
			}

			//	Init lengths in dest string

			pDestString->Length = 0;
			pDestString->MaximumLength = pSrcString->Length + sizeof(WCHAR);
		}
		
		//	Copy the string

		if (ConvertToUpper)
		{
#ifndef LANE_WIN98
			(VOID)NdisUpcaseUnicodeString(pDestString, pSrcString);
#else
			memcpy(pDestString->Buffer, pSrcString->Buffer, pSrcString->Length);
#endif // LANE_WIN98
		}
		else
		{
			RtlCopyUnicodeString(pDestString, pSrcString);
		}

		//	Null terminate the dest string

		if (pDestString->Length < pDestString->MaximumLength)
		{
			pDestString->Buffer[pDestString->Length/sizeof(WCHAR)] = ((WCHAR)0);
		}
		else
		{
			pDestString->Buffer[(pDestString->MaximumLength - sizeof(WCHAR))/sizeof(WCHAR)] =
				((WCHAR)0);
		}
	
	} while (FALSE);

	TRACEOUT(CopyUnicodeString);
	return Result;
}

PWSTR
AtmLaneStrTok(
	IN	PWSTR	StrToken,
	IN	WCHAR	ChrDelim,
	OUT	PUSHORT	pStrLength
)
{
	static PWSTR 	StrSave = NULL;
	USHORT			StrLength = 0;	
	PWSTR 			StrOut = NULL;

	TRACEIN(StrTok);
	do
	{
		//	check for bad input
	
		if ((StrToken == NULL && StrSave == NULL) ||
			ChrDelim == ((WCHAR)0))
		{
			break;
		}

		//	if starting with new string, reset StrSave

		if (StrToken != NULL)
		{
			StrSave = StrToken;
		}

		//	token starts at start of current string

		StrOut = StrSave;

		//	walk string until delimiter or NULL
		
		while (*StrSave != ChrDelim && *StrSave != ((WCHAR)0))
		{
			StrSave++;
			StrLength++;
		}

		//	If we found a delimiter then NULL it out and
		//	move saved ptr to next token to setup for next 
		//	call on same string.  
		
		if (*StrSave == ChrDelim)
		{
			*StrSave = ((WCHAR)0);
			StrSave++;
		}

		//	If pointing at empty string then return null ptr
	
		if (*StrOut == ((WCHAR)0))
		{
			StrOut = NULL;
		}
		
	} while (FALSE);

	TRACEOUT(StrTok);
	*pStrLength = StrLength * sizeof(WCHAR);
	return StrOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\config.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\config.h

Abstract:

	Configurable constants for Null transport.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     06-13-97    Created

Notes:

--*/

#ifndef _TDI__RWAN_CONFIG__H
#define _TDI__RWAN_CONFIG__H


//
//  Initial size of send packet pool.
//
#define RWAN_INITIAL_SEND_PACKET_COUNT			100
//
//  How much do we allow the send packet pool to overflow?
//
#define RWAN_OVERFLOW_SEND_PACKET_COUNT			1000


//
//  Initial size of receive packet pool. Allocated if/when we need to
//  copy a received packet because the miniport doesn't allow us to
//  keep the original.
//
#define RWAN_INITIAL_COPY_PACKET_COUNT			100
//
//  How much do we allow the receive copy packet pool to overflow?
//
#define RWAN_OVERFLOW_COPY_PACKET_COUNT			500


#endif // _TDI__RWAN_CONFIG__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\debug.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    D:\nt\private\ntos\tdi\rawwan\core\debug.c

Abstract:

    This module contains all debug-related code.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    arvindm		05-29-97	Created, based on ATM ARP.

Notes:

--*/


#include <precomp.h>
#include "ntddk.h"
#include "ndis.h"
#include "atm.h"

#define STRUCT_OF(type, address, field) CONTAINING_RECORD(address, type, field)

#include "debug.h"

ULONG	gHackSendSize = 0;

#if DBG

INT		RWanDebugLevel=DL_WARN;
ULONG	RWanDebugComp=DC_WILDCARD;
INT	RWanDataDebugLevel=0;
INT	RWandBigDataLength=8000;
INT	RWanSkipAll = 0;

#if DBG_LOG_PACKETS
NDIS_SPIN_LOCK		RWanDPacketLogLock;
#endif

NDIS_SPIN_LOCK		RWanDbgLogLock;

PRWAND_ALLOCATION	RWandMemoryHead = (PRWAND_ALLOCATION)NULL;
PRWAND_ALLOCATION	RWandMemoryTail = (PRWAND_ALLOCATION)NULL;
ULONG				RWandAllocCount = 0;	// how many allocated so far (unfreed)

NDIS_SPIN_LOCK		RWandMemoryLock;
BOOLEAN				RWandInitDone = FALSE;


PVOID
RWanAuditAllocMem(
	PVOID	pPointer,
	ULONG	Size,
	ULONG	FileNumber,
	ULONG	LineNumber
)
{
	PVOID				pBuffer;
	PRWAND_ALLOCATION	pAllocInfo;

	if (!RWandInitDone)
	{
		NdisAllocateSpinLock(&(RWandMemoryLock));
		RWandInitDone = TRUE;
	}

	NdisAllocateMemoryWithTag(
		(PVOID *)&pAllocInfo,
		Size+sizeof(RWAND_ALLOCATION),
		(ULONG)'naWR'
	);

	if (pAllocInfo == (PRWAND_ALLOCATION)NULL)
	{
		RWANDEBUGP(DL_VERY_LOUD+50, DC_WILDCARD,
			("RWanAuditAllocMem: file %d, line %d, Size %d failed!\n",
				FileNumber, LineNumber, Size));
		pBuffer = NULL;
	}
	else
	{
		pBuffer = (PVOID)&(pAllocInfo->UserData);
		RWAN_SET_MEM(pBuffer, 0xaf, Size);
		pAllocInfo->Signature = RWAND_MEMORY_SIGNATURE;
		pAllocInfo->FileNumber = FileNumber;
		pAllocInfo->LineNumber = LineNumber;
		pAllocInfo->Size = Size;
		pAllocInfo->Location = (ULONG_PTR)pPointer;
		pAllocInfo->Next = (PRWAND_ALLOCATION)NULL;

		NdisAcquireSpinLock(&(RWandMemoryLock));

		pAllocInfo->Prev = RWandMemoryTail;
		if (RWandMemoryTail == (PRWAND_ALLOCATION)NULL)
		{
			// empty list
			RWandMemoryHead = RWandMemoryTail = pAllocInfo;
		}
		else
		{
			RWandMemoryTail->Next = pAllocInfo;
		}
		RWandMemoryTail = pAllocInfo;
		
		RWandAllocCount++;
		NdisReleaseSpinLock(&(RWandMemoryLock));
	}

	RWANDEBUGP(DL_VERY_LOUD+100, DC_WILDCARD,
	 ("RWanAuditAllocMem: file %c%c%c%c, line %d, %d bytes, [0x%x] <- 0x%x\n",
	 			(CHAR)(FileNumber & 0xff),
	 			(CHAR)((FileNumber >> 8) & 0xff),
	 			(CHAR)((FileNumber >> 16) & 0xff),
	 			(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber, Size, pPointer, pBuffer));

	return (pBuffer);

}


VOID
RWanAuditFreeMem(
	PVOID	Pointer
)
{
	PRWAND_ALLOCATION	pAllocInfo;

	NdisAcquireSpinLock(&(RWandMemoryLock));

	pAllocInfo = STRUCT_OF(RWAND_ALLOCATION, Pointer, UserData);

	if (pAllocInfo->Signature != RWAND_MEMORY_SIGNATURE)
	{
		RWANDEBUGP(DL_ERROR, DC_WILDCARD,
		 ("RWanAuditFreeMem: unknown buffer 0x%x!\n", Pointer));
		NdisReleaseSpinLock(&(RWandMemoryLock));
#ifdef DBG
		DbgBreakPoint();
#endif
		return;
	}

	pAllocInfo->Signature = (ULONG)'DEAD';
	if (pAllocInfo->Prev != (PRWAND_ALLOCATION)NULL)
	{
		pAllocInfo->Prev->Next = pAllocInfo->Next;
	}
	else
	{
		RWandMemoryHead = pAllocInfo->Next;
	}
	if (pAllocInfo->Next != (PRWAND_ALLOCATION)NULL)
	{
		pAllocInfo->Next->Prev = pAllocInfo->Prev;
	}
	else
	{
		RWandMemoryTail = pAllocInfo->Prev;
	}
	RWandAllocCount--;
	NdisReleaseSpinLock(&(RWandMemoryLock));

	NdisFreeMemory(pAllocInfo, 0, 0);
}


VOID
RWanAuditShutdown(
	VOID
)
{
	if (RWandInitDone)
	{
		if (RWandAllocCount != 0)
		{
			RWANDEBUGP(DL_ERROR, DC_WILDCARD, ("AuditShutdown: unfreed memory, %d blocks!\n",
					RWandAllocCount));
			RWANDEBUGP(DL_ERROR, DC_WILDCARD, ("MemoryHead: 0x%x, MemoryTail: 0x%x\n",
					RWandMemoryHead, RWandMemoryTail));
			DbgBreakPoint();
			{
				PRWAND_ALLOCATION		pAllocInfo;

				while (RWandMemoryHead != (PRWAND_ALLOCATION)NULL)
				{
					pAllocInfo = RWandMemoryHead;
					RWANDEBUGP(DL_INFO, DC_WILDCARD, ("AuditShutdown: will free 0x%x\n", pAllocInfo));
					RWanAuditFreeMem(&(pAllocInfo->UserData));
				}
			}
		}
		RWandInitDone = FALSE;
	}
}

#define MAX_HD_LENGTH		128

VOID
DbgPrintHexDump(
	IN	PUCHAR			pBuffer,
	IN	ULONG			Length
)
/*++

Routine Description:

	Print a hex dump of the given contiguous buffer. If the length
	is too long, we truncate it.

Arguments:

	pBuffer			- Points to start of data to be dumped
	Length			- Length of above.

Return Value:

	None

--*/
{
	ULONG		i;

	if (Length > MAX_HD_LENGTH)
	{
		Length = MAX_HD_LENGTH;
	}

	for (i = 0; i < Length; i++)
	{
		//
		//  Check if we are at the end of a line
		//
		if ((i > 0) && ((i & 0xf) == 0))
		{
			DbgPrint("\n");
		}

		//
		//  Print addr if we are at start of a new line
		//
		if ((i & 0xf) == 0)
		{
			DbgPrint("%08x ", pBuffer);
		}

		DbgPrint(" %02x", *pBuffer++);
	}

	//
	//  Terminate the last line.
	//
	if (Length > 0)
	{
		DbgPrint("\n");
	}
}


VOID
DbgPrintAtmAddr(
	IN	PCHAR					pString,
	IN	ATM_ADDRESS UNALIGNED *	pAddr
)
{
	ULONG			i;
	ULONG			NumOfDigits;
	PUCHAR			pSrc, pDst;
	UCHAR			AddrString[(ATM_ADDRESS_LENGTH*2) + 1];

	//
	// Prepare the Address string in ASCII
	//
	if ((NumOfDigits = pAddr->NumberOfDigits) > ATM_ADDRESS_LENGTH)
	{
		NumOfDigits = ATM_ADDRESS_LENGTH;
	}

	pSrc = pAddr->Address;
	pDst = AddrString;
	for (i = 0; i < NumOfDigits; i++, pSrc++)
	{
		*pDst = ((*pSrc) >> 4);
		*pDst += (((*pDst) > 9) ? ('A' - 10) : '0');
		pDst++;
		*pDst = ((*pSrc) & 0x0F);
		*pDst += (((*pDst) > 9) ? ('A' - 10) : '0');
		pDst++;
	}

	*pDst = '\0';

	DbgPrint("%s%s\n", pString, AddrString);
}



VOID
RWanCoSendPackets(
	IN	NDIS_HANDLE				NdisVcHandle,
	IN	PNDIS_PACKET *			PacketArray,
	IN	UINT					PacketCount
)
{
	PNDIS_PACKET		pNdisPacket;
	UINT				c;
	NDIS_STATUS			Status;
	PNDIS_BUFFER		pNdisBuffer;
	PULONG				pContext;

	for (c = 0; c < PacketCount; c++)
	{
		pNdisPacket = PacketArray[c];
		RWAN_ASSERT(pNdisPacket->Private.Head != NULL);
		Status = NDIS_GET_PACKET_STATUS(pNdisPacket);
		RWAN_ASSERT(Status != NDIS_STATUS_FAILURE);
		for (pNdisBuffer = pNdisPacket->Private.Head;
			 pNdisBuffer != NULL;
			 pNdisBuffer = pNdisBuffer->Next)
		{
			if (pNdisBuffer->Next == NULL)
			{
				RWAN_ASSERT(pNdisBuffer == pNdisPacket->Private.Tail);
			}
		}
		pContext = (PULONG)&(pNdisPacket->WrapperReserved[0]);
		*pContext = 'RWan';
	}

	NdisCoSendPackets(NdisVcHandle, PacketArray, PacketCount);
}

#endif // DBG


#if DBG_SPIN_LOCK
ULONG	RWandSpinLockInitDone = 0;
NDIS_SPIN_LOCK	RWandLockLock;

VOID
RWanAllocateSpinLock(
	IN	PRWAN_LOCK		pLock,
	IN	ULONG				FileNumber,
	IN	ULONG				LineNumber
)
{
	if (RWandSpinLockInitDone == 0)
	{
		RWandSpinLockInitDone = 1;
		NdisAllocateSpinLock(&(RWandLockLock));
	}

	NdisAcquireSpinLock(&(RWandLockLock));
	pLock->Signature = RWANL_SIG;
	pLock->TouchedByFileNumber = FileNumber;
	pLock->TouchedInLineNumber = LineNumber;
	pLock->IsAcquired = 0;
	pLock->OwnerThread = 0;
	NdisAllocateSpinLock(&(pLock->NdisLock));
	NdisReleaseSpinLock(&(RWandLockLock));
}


VOID
RWanAcquireSpinLock(
	IN	PRWAN_LOCK		pLock,
	IN	ULONG				FileNumber,
	IN	ULONG				LineNumber
)
{
	PKTHREAD		pThread;

	pThread = KeGetCurrentThread();
	NdisAcquireSpinLock(&(RWandLockLock));
	if (pLock->Signature != RWANL_SIG)
	{
		DbgPrint("Trying to acquire uninited lock 0x%x, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
		DbgBreakPoint();
	}

	if (pLock->IsAcquired != 0)
	{
		if (pLock->OwnerThread == pThread)
		{
			DbgPrint("Detected multiple locking!: pLock 0x%x, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
			DbgPrint("pLock 0x%x already acquired in File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(pLock->TouchedByFileNumber & 0xff),
				(CHAR)((pLock->TouchedByFileNumber >> 8) & 0xff),
				(CHAR)((pLock->TouchedByFileNumber >> 16) & 0xff),
				(CHAR)((pLock->TouchedByFileNumber >> 24) & 0xff),
				pLock->TouchedInLineNumber);
			DbgBreakPoint();
		}
	}

	pLock->IsAcquired++;

	NdisReleaseSpinLock(&(RWandLockLock));
	NdisAcquireSpinLock(&(pLock->NdisLock));

	//
	//  Mark this lock.
	//
	pLock->OwnerThread = pThread;
	pLock->TouchedByFileNumber = FileNumber;
	pLock->TouchedInLineNumber = LineNumber;
}


VOID
RWanReleaseSpinLock(
	IN	PRWAN_LOCK		pLock,
	IN	ULONG				FileNumber,
	IN	ULONG				LineNumber
)
{
	NdisDprAcquireSpinLock(&(RWandLockLock));
	if (pLock->Signature != RWANL_SIG)
	{
		DbgPrint("Trying to release uninited lock 0x%x, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
		DbgBreakPoint();
	}

	if (pLock->IsAcquired == 0)
	{
		DbgPrint("Detected release of unacquired lock 0x%x, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
		DbgBreakPoint();
	}
	pLock->TouchedByFileNumber = FileNumber;
	pLock->TouchedInLineNumber = LineNumber;
	pLock->IsAcquired--;
	pLock->OwnerThread = 0;
	NdisDprReleaseSpinLock(&(RWandLockLock));

	NdisReleaseSpinLock(&(pLock->NdisLock));
}
#endif // DBG_SPIN_LOCK


#ifdef PERF


#define MAX_SEND_LOG_ENTRIES		100

LARGE_INTEGER		TimeFrequency;
BOOLEAN				SendLogInitDone = FALSE;
BOOLEAN				SendLogUpdate = TRUE;
NDIS_SPIN_LOCK		SendLogLock;

DL_SEND_LOG_ENTRY	SendLog[MAX_SEND_LOG_ENTRIES];
ULONG				SendLogIndex = 0;
PDL_SEND_LOG_ENTRY	pSendLog = SendLog;

ULONG				MaxSendTime;

#define TIME_TO_ULONG(_pTime)	 *((PULONG)_pTime)

VOID
RWandLogSendStart(
	IN	PNDIS_PACKET	pNdisPacket,
	IN	ULONG			Destination,
	IN	PVOID			pRCE
)
{
	ULONG		Length;

	if (SendLogInitDone == FALSE)
	{
		SendLogInitDone = TRUE;
		(VOID)KeQueryPerformanceCounter(&TimeFrequency);
		MaxSendTime = (TIME_TO_ULONG(&TimeFrequency) * 2)/3;
		NdisAllocateSpinLock(&SendLogLock);
	}

	NdisQueryPacket(
			pNdisPacket,
			NULL,
			NULL,
			NULL,
			&Length
			);

	NdisAcquireSpinLock(&SendLogLock);
	pSendLog->Flags = DL_SEND_FLAG_WAITING_COMPLETION;
	if (pRCE != NULL)
	{
		pSendLog->Flags |= DL_SEND_FLAG_RCE_GIVEN;
	}
	pSendLog->pNdisPacket = pNdisPacket;
	pSendLog->Destination = Destination;
	pSendLog->Length = Length;
	pSendLog->SendTime = KeQueryPerformanceCounter(&TimeFrequency);

	pSendLog++;
	SendLogIndex++;
	if (SendLogIndex == MAX_SEND_LOG_ENTRIES)
	{
		SendLogIndex = 0;
		pSendLog = SendLog;
	}

	NdisReleaseSpinLock(&SendLogLock);
}



VOID
RWandLogSendUpdate(
	IN	PNDIS_PACKET	pNdisPacket
)
{
	PDL_SEND_LOG_ENTRY	pEntry;
	ULONG				Index;
	ULONG				SendTime;

	if (!SendLogUpdate)
	{
		return;
	}

	NdisAcquireSpinLock(&SendLogLock);

	pEntry = SendLog;
	for (Index = 0; Index < MAX_SEND_LOG_ENTRIES; Index++)
	{
		if (((pEntry->Flags & DL_SEND_FLAG_WAITING_COMPLETION) != 0) &&
			(pEntry->pNdisPacket == pNdisPacket))
		{
			pEntry->SendTime = KeQueryPerformanceCounter(&TimeFrequency);
			break;
		}
		pEntry++;
	}

	NdisReleaseSpinLock(&SendLogLock);
}



VOID
RWandLogSendComplete(
	IN	PNDIS_PACKET	pNdisPacket
)
{
	PDL_SEND_LOG_ENTRY	pEntry;
	ULONG				Index;
	ULONG				SendTime;

	NdisAcquireSpinLock(&SendLogLock);

	pEntry = SendLog;
	for (Index = 0; Index < MAX_SEND_LOG_ENTRIES; Index++)
	{
		if (((pEntry->Flags & DL_SEND_FLAG_WAITING_COMPLETION) != 0) &&
			(pEntry->pNdisPacket == pNdisPacket))
		{
			pEntry->Flags &= ~DL_SEND_FLAG_WAITING_COMPLETION;
			pEntry->Flags |= DL_SEND_FLAG_COMPLETED;
			pEntry->SendCompleteTime = KeQueryPerformanceCounter(&TimeFrequency);

			if (((pEntry->Flags & DL_SEND_FLAG_RCE_GIVEN) != 0) &&
				((SendTime = TIME_TO_ULONG(&pEntry->SendCompleteTime) -
							TIME_TO_ULONG(&pEntry->SendTime)) > MaxSendTime))
			{
				DbgPrint("Dest %d.%d.%d.%d, Pkt 0x%x, Len %d, Flags 0x%x, Took Long %d (0x%x)\n",
						((PUCHAR)&pEntry->Destination)[0],
						((PUCHAR)&pEntry->Destination)[1],
						((PUCHAR)&pEntry->Destination)[2],
						((PUCHAR)&pEntry->Destination)[3],
						pNdisPacket, pEntry->Length, pEntry->Flags, SendTime, SendTime);
			}
			break;
		}
		pEntry++;
	}

	NdisReleaseSpinLock(&SendLogLock);
}


VOID
RWandLogSendAbort(
	IN	PNDIS_PACKET		pNdisPacket
)
{
	PDL_SEND_LOG_ENTRY	pEntry;
	ULONG				Index;
	ULONG				SendTime;


	NdisAcquireSpinLock(&SendLogLock);

	pEntry = SendLog;
	for (Index = 0; Index < MAX_SEND_LOG_ENTRIES; Index++)
	{
		if (((pEntry->Flags & DL_SEND_FLAG_WAITING_COMPLETION) != 0) &&
			(pEntry->pNdisPacket == pNdisPacket))
		{
			pEntry->Flags = 0;
			break;
		}
		pEntry++;
	}

	NdisReleaseSpinLock(&SendLogLock);
}

#endif // PERF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\addr.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\addr.c

Abstract:

	TDI Entry points and support routines for Address Objects.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     04-29-97    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'RDDA'


//
//  Context we use to keep track of NDIS SAP registration
//
typedef struct _RWAN_REGISTER_SAP_CONTEXT
{
	PRWAN_NDIS_SAP				pRWanNdisSap;
	CO_SAP						CoSap;

} RWAN_REGISTER_SAP_CONTEXT, *PRWAN_REGISTER_SAP_CONTEXT;




TDI_STATUS
RWanTdiOpenAddress(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	TRANSPORT_ADDRESS UNALIGNED *pAddrList,
    IN	ULONG						AddrListLength,
    IN	UINT						Protocol,
    IN	PUCHAR						pOptions
    )
/*++

Routine Description:

	This is the TDI entry point for opening (creating) an Address Object.

Arguments:

	pTdiRequest		- Pointer to the TDI Request
	pAddrList		- List of alternative addresses, one of which we're to open.
	AddrListLength	- Length of the above
	Protocol		- Identifies the TDI Protocol being opened.
	pOptions		- Unused.

Return Value:

	TDI_STATUS -- TDI_SUCCESS if a new Address Object was successfully
	created, TDI_BAD_ADDR if the given address isn't valid,
	TDI_ADDR_IN_USE if it is a duplicate.

--*/
{
	PRWAN_TDI_PROTOCOL				pProtocol;
	PRWAN_TDI_ADDRESS				pAddrObject;
	TA_ADDRESS *			        pTransportAddress;
	TDI_STATUS						Status;
	INT								rc;

	UNREFERENCED_PARAMETER(pOptions);

	//
	//  Initialize.
	//
	pAddrObject = NULL_PRWAN_TDI_ADDRESS;
	Status = TDI_SUCCESS;

	do
	{
		//
		//  Get our protocol structure for the protocol being opened.
		//
		pProtocol = RWanGetProtocolFromNumber(Protocol);
		if (pProtocol == NULL_PRWAN_TDI_PROTOCOL)
		{
			RWANDEBUGP(DL_WARN, DC_ADDRESS,
					("RWanTdiOpenAddress: unknown protocol number %d\n", Protocol));
			Status = TDI_BAD_ADDR;
			break;
		}

		//
		//  Does this protocol allow creation of address objects?
		//
		if (!pProtocol->bAllowAddressObjects)
		{
			RWANDEBUGP(DL_WARN, DC_ADDRESS,
					("RWanTdiOpenAddress: Protocol %d/x%x doesn't allow addr objs\n",
						Protocol, pProtocol));
			Status = TDI_BAD_ADDR;
			break;
		}

		//
		//  Go through the given Address list and find the first one
		//  that matches the protocol.
		//
		pTransportAddress = (*pProtocol->pAfInfo->AfChars.pAfSpGetValidTdiAddress)(
								pProtocol->pAfInfo->AfSpContext,
								pAddrList,
								AddrListLength
								);

		if (pTransportAddress == NULL)
		{
			RWANDEBUGP(DL_WARN, DC_ADDRESS,
					("RWanTdiOpenAddress: No valid addr for Protocol x%x in list x%x\n",
						pProtocol, pAddrList));
			Status = TDI_BAD_ADDR;
			break;
		}


		RWANDEBUGP(DL_VERY_LOUD, DC_ADDRESS,
				("RWanTdiOpenAddress: pProto x%x, addr x%x, type %d, length %d\n",
					pProtocol,
					pTransportAddress,
					pTransportAddress->AddressType,
					pTransportAddress->AddressLength));


		//
		//  Allocate an Address Object.
		//
		pAddrObject = RWanAllocateAddressObject(pTransportAddress);

		if (pAddrObject == NULL_PRWAN_TDI_ADDRESS)
		{
			RWANDEBUGP(DL_WARN, DC_ADDRESS,
					("RWanTdiOpenAddress: couldnt allocate addr obj: %d bytes\n",
						sizeof(RWAN_TDI_ADDRESS)+pTransportAddress->AddressLength));

			Status = TDI_NO_RESOURCES;
			break;
		}

		pAddrObject->pProtocol = pProtocol;


		//
		//  Get a context for this address object from the media-specific
		//  module.
		//
		if (pAddrObject->pProtocol->pAfInfo->AfChars.pAfSpOpenAddress)
		{
			RWAN_STATUS		RWanStatus;

			RWanStatus = (*pAddrObject->pProtocol->pAfInfo->AfChars.pAfSpOpenAddress)(
							pAddrObject->pProtocol->pAfInfo->AfSpContext,
							(RWAN_HANDLE)pAddrObject,
							&(pAddrObject->AfSpAddrContext));

			if (RWanStatus != RWAN_STATUS_SUCCESS)
			{
				Status = RWanToTdiStatus(RWanStatus);
				break;
			}

			RWAN_SET_BIT(pAddrObject->Flags, RWANF_AO_AFSP_CONTEXT_VALID);
		}


		RWAN_ACQUIRE_ADDRESS_LIST_LOCK();


		//
		//  If this is a non-NULL address, register NDIS SAPs on all
		//  AF bindings for this protocol.
		//
		if (!((*pProtocol->pAfInfo->AfChars.pAfSpIsNullAddress)(
						pProtocol->pAfInfo->AfSpContext,
						pTransportAddress)))
		{
			//
			//  Add a temp ref so that the address object doesn't go away.
			//
			RWanReferenceAddressObject(pAddrObject);	// TdiOpenAddress temp ref

			Status = RWanCreateNdisSaps(pAddrObject, pProtocol);

			if (Status != TDI_SUCCESS)
			{
				if (RWAN_IS_BIT_SET(pAddrObject->Flags, RWANF_AO_AFSP_CONTEXT_VALID))
				{
					(*pAddrObject->pProtocol->pAfInfo->AfChars.pAfSpCloseAddress)(
						pAddrObject->AfSpAddrContext);
					
					RWAN_RESET_BIT(pAddrObject->Flags, RWANF_AO_AFSP_CONTEXT_VALID);
				}
			}

			//
			//  Get rid of the temp reference.
			//
			RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);
			rc = RWanDereferenceAddressObject(pAddrObject);	// TdiOpenAddr temp ref

			if (rc != 0)
			{
				RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);
			}
			else
			{
				//
				//  The address object is gone. Meaning no SAPs got registered.
				//
				pAddrObject = NULL;

				//
				//  Fix up the status only if we haven't got one already.
				//
				if (Status == TDI_SUCCESS)
				{
					Status = TDI_BAD_ADDR;
				}
			}

			if (Status != TDI_SUCCESS)
			{
				RWAN_RELEASE_ADDRESS_LIST_LOCK();
				break;
			}
		}

		RWAN_ASSERT(pAddrObject != NULL);

		RWanReferenceAddressObject(pAddrObject);	// TdiOpenAddress ref

		//
		//  Link this to the list of address objects on this protocol.
		//
		RWAN_INSERT_HEAD_LIST(&(pProtocol->AddrObjList),
							 &(pAddrObject->AddrLink));

		RWAN_RELEASE_ADDRESS_LIST_LOCK();

		//
		//  Fix up all return values.
		//
		pTdiRequest->Handle.AddressHandle = (PVOID)pAddrObject;
		break;

	}
	while (FALSE);


	if (Status != TDI_SUCCESS)
	{
		//
		//  Clean up.
		//
		if (pAddrObject != NULL_PRWAN_TDI_ADDRESS)
		{
			RWAN_FREE_MEM(pAddrObject);
		}
		RWANDEBUGP(DL_FATAL, DC_WILDCARD,
			("OpenAddr: failure status %x\n", Status));
	}

	return (Status);
}




TDI_STATUS
RWanTdiSetEvent(
	IN	PVOID						AddrObjContext,
	IN	INT							TdiEventType,
	IN	PVOID						Handler,
	IN	PVOID						HandlerContext
	)
/*++

Routine Description:

	Set an event handler (up-call) for an address object.

Arguments:

	AddrObjContext	- Our context for an Address Object (pointer to it).
	TdiEventType	- The TDI Event for which we are given an up-call handler.
	Handler			- The handler function
	HandlerContext	- Context to be passed to the handler function.

Return Value:

	TDI_STATUS - TDI_SUCCESS if the event type is a supported one, else
	TDI_BAD_EVENT_TYPE

--*/
{
	PRWAN_TDI_ADDRESS			pAddrObject;
	TDI_STATUS					Status;

	pAddrObject = (PRWAN_TDI_ADDRESS)AddrObjContext;
	RWAN_STRUCT_ASSERT(pAddrObject, nta);

	Status = TDI_SUCCESS;

	RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

	switch (TdiEventType)
	{
		case TDI_EVENT_CONNECT:

			RWANDEBUGP(DL_VERY_LOUD, DC_ADDRESS,
					("SetEvent[CONN IND]: pAddrObject x%x, Handler x%x, Ctxt x%x\n",
							pAddrObject, Handler, HandlerContext));

			pAddrObject->pConnInd = Handler;
			pAddrObject->ConnIndContext = HandlerContext;
			break;
	
		case TDI_EVENT_DISCONNECT:

			RWANDEBUGP(DL_VERY_LOUD, DC_ADDRESS,
					("SetEvent[DISC IND]: pAddrObject x%x, Handler x%x, Ctxt x%x\n",
							pAddrObject, Handler, HandlerContext));

			pAddrObject->pDisconInd = Handler;
			pAddrObject->DisconIndContext = HandlerContext;
			break;
		
		case TDI_EVENT_ERROR:

			RWANDEBUGP(DL_VERY_LOUD, DC_ADDRESS,
					("SetEvent[ERRORIND]: pAddrObject x%x, Handler x%x, Ctxt x%x\n",
							pAddrObject, Handler, HandlerContext));

			pAddrObject->pErrorInd = Handler;
			pAddrObject->ErrorIndContext = HandlerContext;
			break;
		
		case TDI_EVENT_RECEIVE:

			RWANDEBUGP(DL_VERY_LOUD, DC_ADDRESS,
					("SetEvent[RECV IND]: pAddrObject x%x, Handler x%x, Ctxt x%x\n",
							pAddrObject, Handler, HandlerContext));

			pAddrObject->pRcvInd = Handler;
			pAddrObject->RcvIndContext = HandlerContext;
			break;
		
		default:

			Status = TDI_BAD_EVENT_TYPE;
			break;
	}

	RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

	return (Status);
}




TDI_STATUS
RWanTdiCloseAddress(
    IN	PTDI_REQUEST				pTdiRequest
    )
/*++

Routine Description:

	This is the TDI entry point for closing (deleting) an Address Object.

Arguments:

	pTdiRequest		- Pointer to the TDI Request

Return Value:

	TDI_STATUS -- TDI_SUCCESS if we successfully deleted the address
	object immediately, TDI_PENDING if we have to complete some operations
	(e.g. deregister NDIS SAP) before we can complete this.

--*/
{
	TDI_STATUS					Status;
	PRWAN_TDI_ADDRESS			pAddrObject;
	PRWAN_TDI_PROTOCOL			pProtocol;
	INT							rc;
#if DBG
	RWAN_IRQL					EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	pAddrObject = (PRWAN_TDI_ADDRESS)pTdiRequest->Handle.AddressHandle;
	RWAN_STRUCT_ASSERT(pAddrObject, nta);

	pProtocol = pAddrObject->pProtocol;

	RWANDEBUGP(DL_EXTRA_LOUD, DC_BIND,
			("TdiCloseAddr: pAddrObj x%x, RefCnt %d\n",
				pAddrObject, pAddrObject->RefCount));

	//
	//  Delete this from the list of address objects on this protocol.
	//
	RWAN_ACQUIRE_ADDRESS_LIST_LOCK();

	RWAN_DELETE_FROM_LIST(&(pAddrObject->AddrLink));

	RWAN_RELEASE_ADDRESS_LIST_LOCK();

	//
	//  Tell the media-specific module that this address object is closing.
	//
	if (RWAN_IS_BIT_SET(pAddrObject->Flags, RWANF_AO_AFSP_CONTEXT_VALID))
	{
		(*pAddrObject->pProtocol->pAfInfo->AfChars.pAfSpCloseAddress)(
			pAddrObject->AfSpAddrContext);
		
		RWAN_RESET_BIT(pAddrObject->Flags, RWANF_AO_AFSP_CONTEXT_VALID);
	}

	RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

#if DBG
	if (!RWAN_IS_LIST_EMPTY(&pAddrObject->SapList) ||
		!RWAN_IS_LIST_EMPTY(&pAddrObject->IdleConnList) ||
		!RWAN_IS_LIST_EMPTY(&pAddrObject->ListenConnList) ||
		!RWAN_IS_LIST_EMPTY(&pAddrObject->ActiveConnList)
	   )
	{
		RWAN_ASSERT(pAddrObject->RefCount > 1);
	}
#endif // DBG

	rc = RWanDereferenceAddressObject(pAddrObject); // CloseAddress deref

	if (rc == 0)
	{
		Status = TDI_SUCCESS;
	}
	else
	{
		//
		//  Mark this address object as closing, so that we
		//  complete this operation when the reference count
		//  falls to 0.
		//
		RWAN_SET_BIT(pAddrObject->Flags, RWANF_AO_CLOSING);

		RWANDEBUGP(DL_LOUD, DC_BIND,
				("TdiCloseAddr: will pend, pAddrObj x%x, RefCnt %d, DelNotify x%x\n",
					pAddrObject, pAddrObject->RefCount, pTdiRequest->RequestNotifyObject));

		RWAN_SET_DELETE_NOTIFY(&pAddrObject->DeleteNotify,
							  pTdiRequest->RequestNotifyObject,
							  pTdiRequest->RequestContext);

		//
		//  Deregister all NDIS SAPs attached to this Address Object.
		//
		RWanDeleteNdisSaps(pAddrObject);

		Status = TDI_PENDING;
	}

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	return (Status);

}




TDI_STATUS
RWanCreateNdisSaps(
	IN	PRWAN_TDI_ADDRESS			pAddrObject,
	IN	PRWAN_TDI_PROTOCOL			pProtocol
	)
/*++

Routine Description:

	Create NDIS SAPs on behalf of the given TDI Address Object.
	We create NDIS SAPs on all AF opens that match the specified
	TDI protocol.

Arguments:

	pAddrObject		- Pointer to our TDI Address Object
	pProtocol		- Pointer to TDI protocol to which the addr object belongs

Return Value:

	TDI_STATUS -- this is TDI_SUCCESS if we started SAP registration
	on atleast one NDIS AF open, TDI_NOT_ASSOCIATED otherwise.

--*/
{
	TDI_STATUS					Status;
	PCO_SAP						pCoSap;
	PRWAN_NDIS_SAP				pSap;
	PLIST_ENTRY					pSapEntry;
	PLIST_ENTRY					pNextSapEntry;
	PRWAN_NDIS_ADAPTER			pAdapter;
	PLIST_ENTRY					pAdEntry;
	PRWAN_NDIS_AF				pAf;
	PLIST_ENTRY					pAfEntry;
	PRWAN_NDIS_AF_INFO			pAfInfo;

	pAfInfo = pProtocol->pAfInfo;

	RWANDEBUGP(DL_VERY_LOUD, DC_BIND,
			("CreateNdisSaps: pAddrObject x%x, pProtocol x%x, pAfInfo x%x\n",
				 pAddrObject, pProtocol, pAfInfo));

	RWAN_ASSERT(RWAN_IS_LIST_EMPTY(&pAddrObject->SapList));

	RWAN_ACQUIRE_GLOBAL_LOCK();

	//
	//  Prepare NDIS SAP structures for each NDIS AF open that matches
	//  this protocol.
	//
	for (pAdEntry = pRWanGlobal->AdapterList.Flink;
		 pAdEntry != &(pRWanGlobal->AdapterList);
		 pAdEntry = pAdEntry->Flink)
	{
		pAdapter = CONTAINING_RECORD(pAdEntry, RWAN_NDIS_ADAPTER, AdapterLink);

		RWANDEBUGP(DL_EXTRA_LOUD, DC_BIND,
				("CreateNdisSaps: looking at adapter x%x\n", pAdapter));

		for (pAfEntry = pAdapter->AfList.Flink;
			 pAfEntry != &(pAdapter->AfList);
			 pAfEntry = pAfEntry->Flink)
		{
			pAf = CONTAINING_RECORD(pAfEntry, RWAN_NDIS_AF, AfLink);

			RWANDEBUGP(DL_EXTRA_LOUD, DC_BIND,
					("CreateNdisSaps: looking at AF x%x, AfInfo x%x\n",
						 pAf, pAf->pAfInfo));

			if (pAf->pAfInfo == pAfInfo)
			{
				//
				//  This NDIS AF open matches the TDI protocol for which
				//  the address object is opened. We will create an NDIS
				//  SAP here.
				//

				ULONG		SapSize;

				//
				//  Allocate a new SAP structure.
				//
				SapSize = sizeof(RWAN_NDIS_SAP);

				RWAN_ALLOC_MEM(pSap, RWAN_NDIS_SAP, SapSize);

				if (pSap == NULL_PRWAN_NDIS_SAP)
				{
					RWANDEBUGP(DL_WARN, DC_ADDRESS,
							("RWanCreateNdisSaps: failed to alloc SAP %d bytes\n",
								SapSize));
					continue;
				}

				//
				//  Fill it in.
				//
				RWAN_SET_SIGNATURE(pSap, nsp);
				pSap->pAddrObject = pAddrObject;
				pSap->NdisSapHandle = NULL;
				pSap->pNdisAf = pAf;
				pSap->pCoSap = NULL;

				//
				//  Link to all SAPs associated with address object.
				//
				RWAN_INSERT_TAIL_LIST(&(pAddrObject->SapList),
									 &(pSap->AddrObjLink));

				RWanReferenceAddressObject(pAddrObject); // NDIS SAP ref

			}
		}
	}

	RWAN_RELEASE_GLOBAL_LOCK();

	//
	//  Now go through the SAP list and call NDIS to register them.
	//
	for (pSapEntry = pAddrObject->SapList.Flink;
		 pSapEntry != &(pAddrObject->SapList);
		 pSapEntry = pNextSapEntry)
	{
		RWAN_STATUS		RWanStatus;
		NDIS_STATUS		NdisStatus;

		pSap = CONTAINING_RECORD(pSapEntry, RWAN_NDIS_SAP, AddrObjLink);
		pNextSapEntry = pSap->AddrObjLink.Flink;

		//
		//  Convert the transport address to NDIS SAP format.
		//
		RWanStatus = (*pAfInfo->AfChars.pAfSpTdi2NdisSap)(
							pAfInfo->AfSpContext,
							pAddrObject->AddressType,
							pAddrObject->AddressLength,
							pAddrObject->pAddress,
							&(pSap->pCoSap));


		if (RWanStatus == RWAN_STATUS_SUCCESS)
		{
			RWAN_ASSERT(pSap->pCoSap != NULL);

			//
			//  Register this SAP with the Call Manager.
			//
			NdisStatus = NdisClRegisterSap(
							pSap->pNdisAf->NdisAfHandle,
							(NDIS_HANDLE)pSap,
							pSap->pCoSap,
							&(pSap->NdisSapHandle)
							);
		}
		else
		{
			NdisStatus = NDIS_STATUS_FAILURE;
		}

		if (NdisStatus != NDIS_STATUS_PENDING)
		{
			RWanNdisRegisterSapComplete(
							NdisStatus,
							(NDIS_HANDLE)pSap,
							pSap->pCoSap,
							pSap->NdisSapHandle
							);

		}
	}

	if (!RWAN_IS_LIST_EMPTY(&pAddrObject->SapList))
	{
		Status = TDI_SUCCESS;
	}
	else
	{
		Status = RWanNdisToTdiStatus(pAddrObject->SapStatus);
		RWANDEBUGP(DL_WARN, DC_WILDCARD,
			("CreateNdisSaps: NdisStatus %x, TdiStatus %x\n",
					pAddrObject->SapStatus, Status));
	}

	return (Status);
}




VOID
RWanNdisRegisterSapComplete(
	IN	NDIS_STATUS					NdisStatus,
	IN	NDIS_HANDLE					OurSapContext,
	IN	PCO_SAP						pCoSap,
	IN	NDIS_HANDLE					NdisSapHandle
	)
/*++

Routine Description:

	This is called by NDIS to signal completion of a previously
	pended call to NdisClRegisterSap.

Arguments:

	NdisStatus		- Final status of SAP registration.
	OurSapContext	- Points to our NDIS SAP structure.
	pCoSap			- The parameter we passed to NdisClRegisterSap. Not used.
	NdisSapHandle	- If NdisStatus indicates success, this contains the
					  assigned handle for this SAP.

Return Value:

	None

--*/
{
	PRWAN_NDIS_SAP				pSap;
	PRWAN_TDI_ADDRESS			pAddrObject;
	INT							rc;
	PRWAN_NDIS_AF_INFO			pAfInfo;
	PRWAN_NDIS_AF				pAf;

	UNREFERENCED_PARAMETER(pCoSap);

	pSap = (PRWAN_NDIS_SAP)OurSapContext;
	RWAN_STRUCT_ASSERT(pSap, nsp);

	pAddrObject = pSap->pAddrObject;

	pAfInfo = pSap->pNdisAf->pAfInfo;
	pCoSap = pSap->pCoSap;
	pSap->pCoSap = NULL;

	RWANDEBUGP(DL_LOUD, DC_BIND,
			("RegisterSapComplete: pAddrObj x%x, pSap x%x, Status x%x\n",
				pAddrObject, pSap, NdisStatus));

	if (NdisStatus == NDIS_STATUS_SUCCESS)
	{
		pSap->NdisSapHandle = NdisSapHandle;
		pAf = pSap->pNdisAf;

		//
		//  Link this SAP to the list of all SAPs on the AF.
		//
		RWAN_ACQUIRE_AF_LOCK(pAf);

		RWAN_INSERT_TAIL_LIST(&pAf->NdisSapList,
							 &pSap->AfLink);

		RWanReferenceAf(pAf);	// New SAP registered.
		
		RWAN_RELEASE_AF_LOCK(pAf);
	}
	else
	{
		//
		//  Failed to register this SAP. Clean up.
		//
		RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

		pAddrObject->SapStatus = NdisStatus;

		RWAN_DELETE_FROM_LIST(&(pSap->AddrObjLink));

		rc = RWanDereferenceAddressObject(pAddrObject); // Reg SAP failed

		if (rc != 0)
		{
			RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);
		}

		RWAN_FREE_MEM(pSap);
	}

	//
	//  If the AF-specific module had given us a SAP structure,
	//  return it now.
	//
	if (pCoSap != NULL)
	{
		(*pAfInfo->AfChars.pAfSpReturnNdisSap)(
				pAfInfo->AfSpContext,
				pCoSap
				);
	}

	return;
}




VOID
RWanDeleteNdisSaps(
	IN	PRWAN_TDI_ADDRESS			pAddrObject
	)
/*++

Routine Description:

	Delete all NDIS SAPs on the given address object. We call NDIS
	to deregister them.

Arguments:

	pAddrObject		- Pointer to TDI Address Object

Return Value:

	None

--*/
{
	PRWAN_NDIS_SAP			pSap;
	PLIST_ENTRY				pSapEntry;
	PLIST_ENTRY				pFirstSapEntry;
	PLIST_ENTRY				pNextSapEntry;
	NDIS_STATUS				NdisStatus;
	NDIS_HANDLE				NdisSapHandle;

	//
	//  Mark all SAPs as closing, while we hold a lock to the address object.
	//
	for (pSapEntry = pAddrObject->SapList.Flink;
		 pSapEntry != &(pAddrObject->SapList);
		 pSapEntry = pNextSapEntry)
	{
		pSap = CONTAINING_RECORD(pSapEntry, RWAN_NDIS_SAP, AddrObjLink);
		pNextSapEntry = pSap->AddrObjLink.Flink;
		RWAN_SET_BIT(pSap->Flags, RWANF_SAP_CLOSING);
	}

	//
	//  Unlink the SAP list from the Address Object.
	//  This will protect us if at all we re-enter this routine.
	//
	pFirstSapEntry = pAddrObject->SapList.Flink;
	RWAN_INIT_LIST(&pAddrObject->SapList);

	RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

	for (pSapEntry = pFirstSapEntry;
		 pSapEntry != &(pAddrObject->SapList);
		 pSapEntry = pNextSapEntry)
	{
		pSap = CONTAINING_RECORD(pSapEntry, RWAN_NDIS_SAP, AddrObjLink);
		pNextSapEntry = pSap->AddrObjLink.Flink;

		NdisSapHandle = pSap->NdisSapHandle;
		RWAN_ASSERT(NdisSapHandle != NULL);

		RWANDEBUGP(DL_LOUD, DC_BIND,
			("RWanDeleteNdisSaps: pAddrObj x%x, pSap x%x, pAf x%x\n",
				pAddrObject, pSap, pSap->pNdisAf));

		NdisStatus = NdisClDeregisterSap(NdisSapHandle);

		if (NdisStatus != NDIS_STATUS_PENDING)
		{
			RWanNdisDeregisterSapComplete(
				NdisStatus,
				(NDIS_HANDLE)pSap
				);
		}
	}
}




VOID
RWanNdisDeregisterSapComplete(
	IN	NDIS_STATUS					NdisStatus,
	IN	NDIS_HANDLE					ProtocolSapContext
	)
/*++

Routine Description:

	This is called by NDIS to signal completion of a previously
	pended call to NdisClDeregisterSap.

	We unlink the SAP from the two lists it is linked to: the
	Address Object's SAP list and the AF's SAP list.

Arguments:

	NdisStatus		- Final status of SAP deregistration.

Return Value:

	None

--*/
{
	PRWAN_NDIS_SAP				pSap;
	PRWAN_TDI_ADDRESS			pAddrObject;
	PRWAN_NDIS_AF				pAf;
	INT							rc;

	RWAN_ASSERT(NdisStatus == NDIS_STATUS_SUCCESS);

	pSap = (PRWAN_NDIS_SAP)ProtocolSapContext;
	RWAN_STRUCT_ASSERT(pSap, nsp);

	RWANDEBUGP(DL_VERY_LOUD, DC_BIND,
			("RWanDeregSapComplete: pSap x%x, pAddrObj x%x, pAf x%x\n",
			pSap, pSap->pAddrObject, pSap->pNdisAf));

	pAddrObject = pSap->pAddrObject;

	//
	//  Unlink the SAP from the Address Object.
	//
	RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

	RWAN_DELETE_FROM_LIST(&(pSap->AddrObjLink));

	rc = RWanDereferenceAddressObject(pAddrObject); // SAP dereg complete

	if (rc != 0)
	{
		RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);
	}

	//
	//  Unlink the SAP from the AF.
	//
	pAf = pSap->pNdisAf;

	RWAN_STRUCT_ASSERT(pAf, naf);

	RWAN_ACQUIRE_AF_LOCK(pAf);

	RWAN_DELETE_FROM_LIST(&(pSap->AfLink));

	rc = RWanDereferenceAf(pAf);	// SAP deregister complete

	if (rc != 0)
	{
		RWAN_RELEASE_AF_LOCK(pAf);
	}

	RWAN_FREE_MEM(pSap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\debug.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    D:\nt\private\ntos\tdi\rawwan\core\debug.h

Abstract:

    Debug macros for the Null Transport module.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    arvindm		05-29-97	created based on ATM ARP.

Notes:

--*/

#ifndef _RWANDEBUG__H
#define _RWANDEBUG__H

//
// Message verbosity: lower values indicate higher urgency
//
#define DL_EXTRA_LOUD		20
#define DL_VERY_LOUD		10
#define DL_LOUD			 	 8
#define DL_INFO			 	 6
#define DL_WARN		 	 	 4
#define DL_ERROR			 2
#define DL_FATAL			 0

//
// Component being debugged.
//
#define DC_DISPATCH			0x00000001
#define DC_BIND				0x00000002
#define DC_ADDRESS			0x00000004
#define DC_CONNECT			0x00000008
#define DC_DISCON			0x00000010
#define DC_DATA_TX			0x00000020
#define DC_DATA_RX			0x00000040
#define DC_UTIL				0x00000080
#define DC_WILDCARD			0xffffffff


//
//  Data traffic debug message flags
//
#define RWAND_DATA_IN			0x01
#define RWAND_DATA_OUT			0x02
#define RWAND_TRACK_BIG_SENDS	0x04

//
//  Logging for sends and receives
//
typedef struct _RWAND_DATA_LOG_ENTRY
{
	ULONG				Operation;
	#define RWAND_DLOG_TX_START				'  xt'
	#define RWAND_DLOG_TX_END				'  xT'
	#define RWAND_DLOG_RX_START				'  xr'
	#define RWAND_DLOG_RX_END				'  xR'
	PNDIS_PACKET		pNdisPacket;
	PVOID				Context;
	ULONG				PendingCount;

} RWAND_DATA_LOG_ENTRY, *PRWAND_DATA_LOG_ENTRY;

#define MAX_RWAND_PKT_LOG	32

#ifdef PERF

typedef struct _RWAND_SEND_LOG_ENTRY
{
	ULONG				Flags;
	PNDIS_PACKET		pNdisPacket;
	ULONG				Destination;
	ULONG				Length;
	LARGE_INTEGER		SendTime;
	LARGE_INTEGER		SendCompleteTime;
} RWAND_SEND_LOG_ENTRY, *PRWAND_SEND_LOG_ENTRY;

#define RWAND_SEND_FLAG_UNUSED					0x00000000
#define RWAND_SEND_FLAG_WAITING_COMPLETION		0x00000001
#define RWAND_SEND_FLAG_COMPLETED					0x00000002
#define RWAND_SEND_FLAG_RCE_GIVEN					0x00000100


extern VOID
RWandLogSendStart(
	IN	PNDIS_PACKET	pNdisPacket,
	IN	ULONG			Destination,
	IN	PVOID			pRCE
);

extern VOID
RWandLogSendUpdate(
	IN	PNDIS_PACKET	pNdisPacket
);

extern VOID
RWandLogSendComplete(
	IN	PNDIS_PACKET	pNdisPacket
);

extern VOID
RWandLogSendAbort(
	IN	PNDIS_PACKET	pNdisPacket
);

extern LARGE_INTEGER	TimeFrequency;


#endif // PERF

#if DBG_SPIN_LOCK

typedef struct _RWAN_LOCK
{
	ULONG					Signature;
	ULONG					IsAcquired;
	PKTHREAD				OwnerThread;
	ULONG					TouchedByFileNumber;
	ULONG					TouchedInLineNumber;
	NDIS_SPIN_LOCK			NdisLock;
} RWAN_LOCK, *PRWAN_LOCK;

#define RWANL_SIG	'KCOL'

extern
VOID
RWanAllocateSpinLock(
    IN  PRWAN_LOCK        pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);

extern
VOID
RWanAcquireSpinLock(
    IN  PRWAN_LOCK        pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);

extern
VOID
RWanReleaseSpinLock(
    IN  PRWAN_LOCK        pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);


#define CHECK_LOCK_COUNT(Count)		\
			{								\
				if ((INT)(Count) < 0)		\
				{							\
					DbgPrint("Lock Count %d is < 0! File %s, Line %d\n",	\
						Count, __FILE__, __LINE__);		\
					DbgBreakPoint();					\
				}							\
			}
#else
#define CHECK_LOCK_COUNT(Count)

#define RWAN_LOCK		NDIS_SPIN_LOCK
#define PRWAN_LOCK	PNDIS_SPIN_LOCK

#endif	// DBG_SPIN_LOCK

#if DBG

extern NDIS_SPIN_LOCK		RWanDbgLogLock;

extern INT	RWanDebugLevel;	// The value here defines what the user wants to see
								// all messages with this urgency and higher are enabled

extern ULONG	RWanDebugComp;	// The bits set here define what components are being
								// debugged
extern INT	RWanDataDebugLevel;
extern INT	RWandBigDataLength;


#define RWANDEBUGP(lev, comp, stmt)										\
		{																\
			if (((lev) <= RWanDebugLevel) && ((comp) & RWanDebugComp))	\
			{															\
				DbgPrint("RWan: "); DbgPrint stmt;						\
			}															\
		}

#define RWANDEBUGPDUMP(lev, comp, pBuf, Len)	\
		{																\
			if (((lev) <= RWanDebugLevel) && ((comp) & RWanDebugComp))	\
			{															\
				DbgPrintHexDump((PUCHAR)(pBuf), (ULONG)(Len));			\
			}															\
		}

#define RWANDEBUGPATMADDR(lev, comp, pString, pAddr)		\
		{																\
			if (((lev) <= RWanDebugLevel) && ((comp) & RWanDebugComp))	\
			{															\
				DbgPrintAtmAddr(pString, pAddr);						\
			}															\
		}

#define RWAN_ASSERT(exp)	\
		{																\
			if (!(exp))													\
			{															\
				DbgPrint("RWan: assert " #exp " failed in file %s, line %d\n", __FILE__, __LINE__);	\
				DbgBreakPoint();										\
			}															\
		}

#define RWAN_SET_SIGNATURE(s, t)\
				(s)->t##_sig = t##_signature;

#define RWAN_STRUCT_ASSERT(s, t)\
				if ((s)->t##_sig != t##_signature) {\
					DbgPrint("RWan: assertion failure for type " #t " at 0x%x in file %s, line %d\n", (PUCHAR)s, __FILE__, __LINE__);	\
					DbgBreakPoint();	\
				}

#if DBG_CO_SEND

#define NDIS_CO_SEND_PACKETS(_VcHandle, _PktArray, _Count)	\
			RWanCoSendPackets(_VcHandle, _PktArray, _Count)

#else

#define NDIS_CO_SEND_PACKETS(_VcHandle, _PktArray, _Count)	\
			NdisCoSendPackets(_VcHandle, _PktArray, _Count)

#endif // DBG_CO_SEND

extern INT	RWanSkipAll;		// Used as an emergency exit mechanism!

//
// Memory Allocation/Freeing Audit:
//

//
// The RWAND_ALLOCATION structure stores all info about one allocation
//
typedef struct _RWAND_ALLOCATION {

		ULONG					Signature;
		struct _RWAND_ALLOCATION	*Next;
		struct _RWAND_ALLOCATION *Prev;
		ULONG					FileNumber;
		ULONG					LineNumber;
		ULONG					Size;
		ULONG_PTR				Location;	// where the returned pointer was put
		union
		{
			ULONGLONG			Alignment;
			UCHAR					UserData;
		};

} RWAND_ALLOCATION, *PRWAND_ALLOCATION;

#define RWAND_MEMORY_SIGNATURE	(ULONG)'CSII'

extern
PVOID
RWanAuditAllocMem (
	PVOID		pPointer,
	ULONG		Size,
	ULONG		FileNumber,
	ULONG		LineNumber
);

extern
VOID
RWanAuditFreeMem(
	PVOID		Pointer
);

extern
VOID
RWanAuditShutdown(
	VOID
);

extern
VOID
DbgPrintHexDump(
	PUCHAR		pBuffer,
	ULONG		Length
);

extern
VOID
DbgPrintAtmAddr(
	PCHAR			pString,
	ATM_ADDRESS UNALIGNED *	pAddr
);

extern
VOID
DbgPrintMapping(
	PCHAR			pString,
	UCHAR UNALIGNED *	pIpAddr,
	ATM_ADDRESS UNALIGNED *	pAddr
);


extern
VOID
RWanCoSendPackets(
	IN	NDIS_HANDLE			NdisVcHandle,
	IN	PNDIS_PACKET *		PacketArray,
	IN	UINT				PacketCount
);

extern NDIS_SPIN_LOCK		RWanDPacketLogLock;


#if DBG_LOG_PACKETS
#define RWAND_LOG_PACKET(_pVc, _Op, _pPkt, _Ctxt)	\
{													\
	struct _RWAND_DATA_LOG_ENTRY *	pEnt;			\
	NdisAcquireSpinLock(&RWanDPacketLogLock);		\
	pEnt = &(_pVc)->DataLog[(_pVc)->Index];			\
	(_pVc)->Index++;								\
	if ((_pVc)->Index == MAX_RWAND_PKT_LOG)			\
		(_pVc)->Index = 0;							\
	pEnt->Operation = _Op;							\
	pEnt->pNdisPacket = _pPkt;						\
	pEnt->Context = _Ctxt;							\
	pEnt->PendingCount = (_pVc)->PendingPacketCount;\
	NdisReleaseSpinLock(&RWanDPacketLogLock);		\
}

#else
#define RWAND_LOG_PACKET(_pVc, _Op, _pPkt, _Ctxt)
#endif

#else
//
// No debug
//
#define RWANDEBUGP(lev, comp, stmt)
#define RWANDEBUGPDUMP(lev, comp, pBuf, Len)
#define RWANDEBUGPATMADDR(lev, comp, pString, pAddr)

#define RWAN_ASSERT(exp)
#define RWAN_SET_SIGNATURE(s, t)
#define RWAN_STRUCT_ASSERT(s, t)

#define NDIS_CO_SEND_PACKETS(_VcHandle, _PktArray, _Count)	\
			NdisCoSendPackets(_VcHandle, _PktArray, _Count)

#define RWAND_LOG_PACKET(_pVc, _Op, _pPkt, _Ctxt)

#endif	// DBG


extern ULONG	gHackSendSize;

#endif // _RWANDEBUG__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\info.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\info.c

Abstract:

	Routines for handling query/set information requests.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     06-09-97    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'OFNI'


//
//  Kludgy way to ensure we have enough space for a transport
//  address in the following INFO BUF structure.
//
#define MAX_RWAN_TDI_INFO_LENGTH		200


typedef union _RWAN_TDI_INFO_BUF
{
	TDI_CONNECTION_INFO			ConnInfo;
	TDI_ADDRESS_INFO			AddrInfo;
	TDI_PROVIDER_INFO			ProviderInfo;
	TDI_PROVIDER_STATISTICS		ProviderStats;
	UCHAR						Space[MAX_RWAN_TDI_INFO_LENGTH];

} RWAN_TDI_INFO_BUF, *PRWAN_TDI_INFO_BUF;



TDI_STATUS
RWanTdiQueryInformation(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	UINT						QueryType,
    IN	PNDIS_BUFFER				pNdisBuffer,
    IN	PUINT						pBufferSize,
    IN	UINT						IsConnection
    )
/*++

Routine Description:

	This is the TDI entry point to handle a QueryInformation TDI request.

Arguments:

	pTdiRequest		- Pointer to the TDI Request
	QueryType		- Information being queried for
	pNdisBuffer		- Start of list of buffers containing query data
	pBufferSize		- Total space in above list
	IsConnection	- Is this query on a connection endpoint?

Return Value:

	TDI_STATUS:  TDI_SUCCESS if the query was processed
	successfully, TDI_STATUS_XXX for any error.

--*/
{
	TDI_STATUS				TdiStatus;
	RWAN_TDI_INFO_BUF		InfoBuf;
	PVOID					InfoPtr;
	UINT					InfoSize;
	UINT					Offset;
	UINT					Size;
	UINT					BytesCopied;
	PRWAN_TDI_PROTOCOL		pProtocol;
	PRWAN_TDI_ADDRESS		pAddrObject;
	PRWAN_TDI_CONNECTION		pConnObject;
	RWAN_CONN_ID				ConnId;

	TdiStatus = TDI_SUCCESS;
	InfoPtr = NULL;

	switch (QueryType)
	{
		case TDI_QUERY_BROADCAST_ADDRESS:

			TdiStatus = TDI_INVALID_QUERY;
			break;

		case TDI_QUERY_PROVIDER_INFO:

			pProtocol = pTdiRequest->Handle.ControlChannel;
			RWAN_STRUCT_ASSERT(pProtocol, ntp);

			InfoBuf.ProviderInfo = pProtocol->ProviderInfo;
			InfoSize = sizeof(TDI_PROVIDER_INFO);
			InfoPtr = &InfoBuf.ProviderInfo;
			break;
	
		case TDI_QUERY_ADDRESS_INFO:

			if (IsConnection)
			{
				ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);

				RWAN_ACQUIRE_CONN_TABLE_LOCK();

				pConnObject = RWanGetConnFromId(ConnId);

				RWAN_RELEASE_CONN_TABLE_LOCK();

				if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
				{
					TdiStatus = TDI_INVALID_CONNECTION;
					break;
				}

				pAddrObject = pConnObject->pAddrObject;

			}
			else
			{
				pAddrObject = (PRWAN_TDI_ADDRESS)pTdiRequest->Handle.AddressHandle;
			}

			if (pAddrObject == NULL_PRWAN_TDI_ADDRESS)
			{
				TdiStatus = TDI_INVALID_CONNECTION;
				break;
			}

			RWAN_STRUCT_ASSERT(pAddrObject, nta);

			RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

			RWAN_ASSERT(pAddrObject->AddressLength <=
							(sizeof(RWAN_TDI_INFO_BUF) - sizeof(TDI_ADDRESS_INFO)));

			InfoSize = sizeof(TDI_ADDRESS_INFO) - sizeof(TRANSPORT_ADDRESS) +
						pAddrObject->AddressLength;

			InfoBuf.AddrInfo.ActivityCount = 1;	// same as TCP
			InfoBuf.AddrInfo.Address.TAAddressCount = 1;
			InfoBuf.AddrInfo.Address.Address[0].AddressLength = pAddrObject->AddressLength;
			InfoBuf.AddrInfo.Address.Address[0].AddressType = pAddrObject->AddressType;
			RWAN_COPY_MEM(InfoBuf.AddrInfo.Address.Address[0].Address,
						 pAddrObject->pAddress,
						 pAddrObject->AddressLength);

			RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

			RWANDEBUGP(DL_LOUD, DC_DISPATCH,
						("RWanTdiQueryInfo: IsConn %d, Addr dump:\n", IsConnection));
			RWANDEBUGPDUMP(DL_LOUD, DC_DISPATCH, pAddrObject->pAddress, pAddrObject->AddressLength);
			InfoPtr = &InfoBuf.AddrInfo;

			TdiStatus = TDI_SUCCESS;

			break;
		
		case TDI_QUERY_CONNECTION_INFO:

			TdiStatus = TDI_INVALID_QUERY;
			break;
		
		case TDI_QUERY_PROVIDER_STATISTICS:

			pProtocol = pTdiRequest->Handle.ControlChannel;
			RWAN_STRUCT_ASSERT(pProtocol, ntp);

			InfoBuf.ProviderStats = pProtocol->ProviderStats;
			InfoSize = sizeof(TDI_PROVIDER_STATISTICS);
			InfoPtr = &InfoBuf.ProviderStats;
			break;
		
		default:

			TdiStatus = TDI_INVALID_QUERY;
			break;
	}

	if (TdiStatus == TDI_SUCCESS)
	{
		RWAN_ASSERT(InfoPtr != NULL);
		Offset = 0;
		Size = *pBufferSize;

		(VOID)RWanCopyFlatToNdis(
					pNdisBuffer,
					InfoPtr,
					MIN(InfoSize, Size),
					&Offset,
					&BytesCopied
					);
		
		if (Size < InfoSize)
		{
			TdiStatus = TDI_BUFFER_OVERFLOW;
		}
		else
		{
			*pBufferSize = InfoSize;
		}
	}

	return (TdiStatus);
	
}


RWAN_STATUS
RWanHandleGenericConnQryInfo(
    IN	HANDLE						ConnectionContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength,
    OUT	PVOID						pOutputBuffer,
    IN OUT	PVOID					pOutputBufferLength
    )
/*++

Routine Description:

	Handle a generic QueryInformation command on a Connection Object.

Arguments:

	AddrHandle			- Pointer to our address object structure
	ConnectionContext	- TDI Connection ID
	pInputBuffer		- Query Info structure
	InputBufferLength	- Length of the above
	pOutputBuffer		- Output buffer
	pOutputBufferLength	- Space available/bytes filled in.

Return Value:

	RWAN_STATUS_SUCCESS if the command was processed successfully,
	RWAN_STATUS_XXX if not.

--*/
{
	PRWAN_TDI_CONNECTION		pConnObject;
	RWAN_STATUS					RWanStatus;
	PRWAN_QUERY_INFORMATION_EX	pQueryInfo;

	RWanStatus = RWAN_STATUS_SUCCESS;

	do
	{
		if (InputBufferLength < sizeof(RWAN_QUERY_INFORMATION_EX) ||
			pOutputBuffer == NULL)
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId((RWAN_CONN_ID)PtrToUlong(ConnectionContext));

		RWAN_RELEASE_CONN_TABLE_LOCK();

		if (pConnObject == NULL)
		{
			RWanStatus = RWAN_STATUS_BAD_PARAMETER;
			break;
		}

		RWAN_STRUCT_ASSERT(pConnObject, ntc);

		pQueryInfo = (PRWAN_QUERY_INFORMATION_EX)pInputBuffer;

		if (InputBufferLength < sizeof(RWAN_QUERY_INFORMATION_EX) + pQueryInfo->ContextLength - sizeof(UCHAR))
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		switch (pQueryInfo->ObjectId)
		{
			case RWAN_OID_CONN_OBJECT_MAX_MSG_SIZE:

				if (*(PULONG)(ULONG_PTR)pOutputBufferLength < sizeof(ULONG))
				{
					RWanStatus = RWAN_STATUS_RESOURCES;
					break;
				}

				RWAN_ACQUIRE_CONN_LOCK(pConnObject);

				if (pConnObject->NdisConnection.pNdisVc)
				{
					*(PULONG)(ULONG_PTR)pOutputBuffer = pConnObject->NdisConnection.pNdisVc->MaxSendSize;
					*(PULONG)(ULONG_PTR)pOutputBufferLength = sizeof(ULONG);
				}
				else
				{
					RWanStatus = RWAN_STATUS_BAD_PARAMETER;
				}

				RWAN_RELEASE_CONN_LOCK(pConnObject);
				break;
			
			default:

				RWanStatus = RWAN_STATUS_BAD_PARAMETER;
				break;
		}

		break;
	}
	while (FALSE);

	RWANDEBUGP(DL_LOUD, DC_BIND,
		("RWanHandleGenericConnQry: returning status %x\n", RWanStatus));

	return (RWanStatus);
}


RWAN_STATUS
RWanHandleGenericAddrSetInfo(
    IN	HANDLE						AddrHandle,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength
    )
/*++

Routine Description:

	Handle a non-media specific SetInformation command on an Address Object.

Arguments:

	AddrHandle			- Pointer to our address object structure
	pInputBuffer		- Set Info structure
	InputBufferLength	- Length of the above

Return Value:

	RWAN_STATUS_SUCCESS if the command was processed successfully,
	RWAN_STATUS_XXX if not.

--*/
{
	PRWAN_TDI_ADDRESS			pAddrObject;
	PRWAN_TDI_CONNECTION		pConnObject;
	PRWAN_SET_INFORMATION_EX	pSetInfo;
	RWAN_STATUS					RWanStatus;
	ULONG						Flags;

	RWanStatus = RWAN_STATUS_SUCCESS;
	pAddrObject = (PRWAN_TDI_ADDRESS)AddrHandle;

	do
	{
		if (pAddrObject == NULL)
		{
			RWanStatus = RWAN_STATUS_BAD_ADDRESS;
			break;
		}

		RWAN_STRUCT_ASSERT(pAddrObject, nta);

		if (InputBufferLength < sizeof(RWAN_SET_INFORMATION_EX))
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		pSetInfo = (PRWAN_SET_INFORMATION_EX)pInputBuffer;

		if (InputBufferLength < sizeof(RWAN_SET_INFORMATION_EX) + pSetInfo->BufferSize - sizeof(UCHAR))
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		switch (pSetInfo->ObjectId)
		{
			case RWAN_OID_ADDRESS_OBJECT_FLAGS:

				if (pSetInfo->BufferSize < sizeof(ULONG))
				{
					RWanStatus = RWAN_STATUS_RESOURCES;
					break;
				}

				Flags = *((PULONG)&pSetInfo->Buffer[0]);

				if (Flags & RWAN_AOFLAG_C_ROOT)
				{
					//
					//  This Address Object is designated as the Root of
					//  an outgoing Point to Multipoint connection.
					//

					RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

					RWAN_SET_BIT(pAddrObject->Flags, RWANF_AO_PMP_ROOT);

					if (pAddrObject->pRootConnObject != NULL)
					{
						RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);
						RWanStatus = RWAN_STATUS_BAD_ADDRESS;
						break;
					}

					//
					//  There should be a single Connection Object associated
					//  with this Address Object. That should now be designated
					//  the Root Connection Object.
					//
					RWAN_ASSERT(!RWAN_IS_LIST_EMPTY(&pAddrObject->IdleConnList));
					pConnObject = CONTAINING_RECORD(pAddrObject->IdleConnList.Flink, RWAN_TDI_CONNECTION, ConnLink);

					RWAN_STRUCT_ASSERT(pConnObject, ntc);

					pAddrObject->pRootConnObject = pConnObject;

					RWAN_ACQUIRE_CONN_LOCK_DPC(pConnObject);

					RWAN_SET_BIT(pConnObject->Flags, RWANF_CO_ROOT);

					RWAN_RELEASE_CONN_LOCK_DPC(pConnObject);

					RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

					RWANDEBUGP(DL_LOUD, DC_ADDRESS,
						("Marked PMP Root: AddrObj x%x, ConnObj x%x\n",
							pAddrObject, pConnObject));

				}

				break;

			default:

				RWanStatus = RWAN_STATUS_BAD_PARAMETER;
				break;
		}

		break;
	}
	while (FALSE);

	RWANDEBUGP(DL_VERY_LOUD, DC_DISPATCH,
			("Generic Set Addr: AddrObj x%x, returning x%x\n", pAddrObject, RWanStatus));

	return (RWanStatus);
}


RWAN_STATUS
RWanHandleMediaSpecificAddrSetInfo(
    IN	HANDLE						AddrHandle,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength
    )
/*++

Routine Description:

	Handle a media specific SetInformation command on an Address Object.

Arguments:

	AddrHandle			- Pointer to our address object structure
	pInputBuffer		- Set Info structure
	InputBufferLength	- Length of the above

Return Value:

	RWAN_STATUS_SUCCESS if the command was processed successfully,
	RWAN_STATUS_XXX if not.

--*/
{
	PRWAN_NDIS_AF_CHARS			pAfChars;
	PRWAN_TDI_ADDRESS			pAddrObject;
	RWAN_STATUS					RWanStatus;
	ULONG						Flags;

	RWanStatus = RWAN_STATUS_SUCCESS;
	pAddrObject = (PRWAN_TDI_ADDRESS)AddrHandle;

	do
	{
		if (pAddrObject == NULL)
		{
			RWanStatus = RWAN_STATUS_BAD_ADDRESS;
			break;
		}

		RWAN_STRUCT_ASSERT(pAddrObject, nta);

		pAfChars = &(pAddrObject->pProtocol->pAfInfo->AfChars);

		if (pAfChars->pAfSpSetAddrInformation != NULL)
		{
			RWanStatus = (*pAfChars->pAfSpSetAddrInformation)(
							pAddrObject->AfSpAddrContext,
							pInputBuffer,
							InputBufferLength
							);
		}
		else
		{
			RWanStatus = RWAN_STATUS_FAILURE;
		}

		break;
	}
	while (FALSE);

	return (RWanStatus);
}


RWAN_STATUS
RWanHandleMediaSpecificConnQryInfo(
    IN	HANDLE						ConnectionContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength,
    OUT	PVOID						pOutputBuffer,
    IN OUT	PVOID					pOutputBufferLength
    )
/*++

Routine Description:

	Handle a media specific QueryInformation command on a Connection Object.

Arguments:

	AddrHandle			- Pointer to our address object structure
	ConnectionContext	- TDI Connection ID
	pInputBuffer		- Query Info structure
	InputBufferLength	- Length of the above
	pOutputBuffer		- Output buffer
	pOutputBufferLength	- Space available/bytes filled in.

Return Value:

	RWAN_STATUS_SUCCESS if the command was processed successfully,
	RWAN_STATUS_XXX if not.

--*/
{
	PRWAN_NDIS_AF_CHARS			pAfChars;
	PRWAN_TDI_CONNECTION		pConnObject;
	RWAN_STATUS					RWanStatus;
	ULONG						Flags;

	RWanStatus = RWAN_STATUS_SUCCESS;

	do
	{
		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId((RWAN_CONN_ID)PtrToUlong(ConnectionContext));

		RWAN_RELEASE_CONN_TABLE_LOCK();

		if ((pConnObject == NULL) ||
			(pConnObject->pAddrObject == NULL))
		{
			RWanStatus = RWAN_STATUS_BAD_PARAMETER;
			break;
		}

		RWAN_STRUCT_ASSERT(pConnObject, ntc);

		pAfChars = &(pConnObject->pAddrObject->pProtocol->pAfInfo->AfChars);

		if (pAfChars->pAfSpQueryConnInformation != NULL)
		{
			RWanStatus = (*pAfChars->pAfSpQueryConnInformation)(
							pConnObject->AfSpConnContext,
							pInputBuffer,
							InputBufferLength,
							pOutputBuffer,
							pOutputBufferLength
							);
		}
		else
		{
			RWanStatus = RWAN_STATUS_FAILURE;
		}

		break;
	}
	while (FALSE);

	return (RWanStatus);
}



PNDIS_BUFFER
RWanCopyFlatToNdis(
    IN	PNDIS_BUFFER				pDestBuffer,
    IN	PUCHAR						pSrcBuffer,
    IN	UINT						LengthToCopy,
    IN OUT	PUINT					pStartOffset,
    OUT	PUINT						pBytesCopied
    )
/*++

Routine Description:

	Copy from a flat memory buffer to an NDIS buffer chain. It is assumed
	that the NDIS buffer chain has enough space.

	TBD: Use the TDI function for copying from flat mem to MDL.

Arguments:

	pDestBuffer		- First buffer in the destination NDIS buffer chain.
	pSrcBuffer		- Pointer to start of flat memory
	LengthToCopy	- Max bytes to copy
	pStartOffset	- Copy offset in first buffer
	pBytesCopied	- Place to return actual bytes copied

Return Value:

	Pointer to buffer in chain where data can be copied into next.
	Also, *pStartOffset and *pBytesCopied are set.

--*/
{
	UINT		CopyLength;
	PUCHAR		pDest;
	UINT		Offset;
	UINT		BytesCopied;
	UINT		DestSize;
	UINT		CopySize;

	BytesCopied = 0;
	Offset = *pStartOffset;

	pDest = (PUCHAR)NdisBufferVirtualAddress(pDestBuffer) + Offset;
	DestSize = NdisBufferLength(pDestBuffer) - Offset;

	for (;;)
	{
		CopySize = MIN(DestSize, LengthToCopy);

		RWAN_COPY_MEM(pDest, pSrcBuffer, CopySize);

		pDest += CopySize;
		pSrcBuffer += CopySize;
		BytesCopied += CopySize;

		LengthToCopy -= CopySize;

		if (LengthToCopy == 0)
		{
			break;
		}

		DestSize -= CopySize;

		if (DestSize == 0)
		{
			pDestBuffer = NDIS_BUFFER_LINKAGE(pDestBuffer);
			RWAN_ASSERT(pDestBuffer != NULL);

			pDest = NdisBufferVirtualAddress(pDestBuffer);
			DestSize = NdisBufferLength(pDestBuffer);
		}
	}

	//
	//  Prepare return values.
	//
	*pStartOffset = (UINT)(pDest - (PUCHAR)NdisBufferVirtualAddress(pDestBuffer));
	*pBytesCopied = BytesCopied;

	return (pDestBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\macros.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    D:\nt\private\ntos\tdi\rawwan\core\macros.h

Abstract:

	Macros for the NullTrans module. Adapted from ATMARP Client.

Revision History:

    Who         When        What
    --------    --------    ----
    arvindm     05-07-97    created

Notes:


--*/
#ifndef __RWAN_MACROS_H_INCLUDED
#define __RWAN_MACROS_H_INCLUDED



#ifndef MAX

/*++
OPAQUE
MAX(
	IN	OPAQUE		Fred,
	IN	OPAQUE		Shred
)
--*/
#define MAX(Fred, Shred)		(((Fred) > (Shred)) ? (Fred) : (Shred))

#endif // MAX


#ifndef MIN

/*++
OPAQUE
MIN(
	IN	OPAQUE		Fred,
	IN	OPAQUE		Shred
)
--*/
#define MIN(Fred, Shred)		(((Fred) < (Shred)) ? (Fred) : (Shred))

#endif // MIN



/*++
VOID
RWAN_SET_FLAG(
	IN	ULONG		Flags,
	IN	ULONG		Mask,
	IN	ULONG		Val
)
--*/
#define RWAN_SET_FLAG(Flags, Mask, Val)	\
			(Flags) = ((Flags) & ~(Mask)) | (Val)


/*++
BOOLEAN
RWAN_IS_FLAG_SET(
	IN	ULONG		Flags,
	IN	ULONG		Mask,
	IN	ULONG		Val
)
--*/
#define RWAN_IS_FLAG_SET(Flags, Mask, Val)	\
			(((Flags) & (Mask)) == (Val))


#define RWAN_SET_BIT(_Flags, _Bit)			\
			(_Flags) = (_Flags) | (_Bit);

#define RWAN_RESET_BIT(_Flags, _Bit)			\
			(_Flags) &= ~(_Bit);

#define RWAN_IS_BIT_SET(_Flags, _Bit)		\
			(((_Flags) & (_Bit)) != 0)


/*++
VOID
RWAN_INIT_EVENT_STRUCT(
	IN	RWAN_EVENT	*pEvent
)
--*/
#define RWAN_INIT_EVENT_STRUCT(pEvent)		NdisInitializeEvent(&((pEvent)->Event))


/*++
NDIS_STATUS
RWAN_WAIT_ON_EVENT_STRUCT(
	IN	RWAN_EVENT	*pEvent
)
--*/
#define RWAN_WAIT_ON_EVENT_STRUCT(pEvent)		\
			(NdisWaitEvent(&((pEvent)->Event), 0), (pEvent)->Status)


/*++
VOID
RWAN_SIGNAL_EVENT_STRUCT(
	IN	RWAN_EVENT	*pEvent,
	IN	UINT			Status
)
--*/
#define RWAN_SIGNAL_EVENT_STRUCT(pEvent, _Status)	\
			{ (pEvent)->Status = _Status; NdisSetEvent(&((pEvent)->Event)); }


/*++
VOID
RWAN_FREE_EVENT_STRUCT(
	IN	RWAN_EVENT	*pEvent
)
--*/
#define RWAN_FREE_EVENT_STRUCT(pEvent)		// Nothing to be done here


/*++
VOID
RWAN_INIT_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DBG_SPIN_LOCK
#define RWAN_INIT_LOCK(pLock)	\
				RWanAllocateSpinLock(pLock, _FILENUMBER, __LINE__)
#else
#define RWAN_INIT_LOCK(pLock)	\
				NdisAllocateSpinLock(pLock)
#endif // DBG_SPIN_LOCK


/*++
VOID
RWAN_ACQUIRE_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DBG_SPIN_LOCK
#define RWAN_ACQUIRE_LOCK(pLock)	\
				RWanAcquireSpinLock(pLock, _FILENUMBER, __LINE__)
#else
#define RWAN_ACQUIRE_LOCK(pLock)	\
				NdisAcquireSpinLock(pLock)
#endif // DBG_SPIN_LOCK


/*++
VOID
RWAN_ACQUIRE_LOCK_DPC(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DBG_SPIN_LOCK
#define RWAN_ACQUIRE_LOCK_DPC(pLock)	\
				RWanAcquireSpinLock(pLock, _FILENUMBER, __LINE__)
#else
#define RWAN_ACQUIRE_LOCK_DPC(pLock)	\
				NdisDprAcquireSpinLock(pLock)
#endif // DBG_SPIN_LOCK


/*++
VOID
RWAN_RELEASE_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DBG_SPIN_LOCK
#define RWAN_RELEASE_LOCK(pLock)		\
				RWanReleaseSpinLock(pLock, _FILENUMBER, __LINE__)
#else
#define RWAN_RELEASE_LOCK(pLock)		\
				NdisReleaseSpinLock(pLock)
#endif // DBG_SPIN_LOCK


/*++
VOID
RWAN_RELEASE_LOCK_DPC(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DBG_SPIN_LOCK
#define RWAN_RELEASE_LOCK_DPC(pLock)		\
				RWanReleaseSpinLock(pLock, _FILENUMBER, __LINE__)
#else
#define RWAN_RELEASE_LOCK_DPC(pLock)		\
				NdisDprReleaseSpinLock(pLock)
#endif // DBG_SPIN_LOCK


/*++
VOID
RWAN_FREE_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#define RWAN_FREE_LOCK(pLock)			\
				NdisFreeSpinLock(pLock)


//
//  Macros for operating the Global lock:
//
#define RWAN_INIT_GLOBAL_LOCK()		\
				RWAN_INIT_LOCK(&((pRWanGlobal)->GlobalLock))

#define RWAN_ACQUIRE_GLOBAL_LOCK()		\
				RWAN_ACQUIRE_LOCK(&((pRWanGlobal)->GlobalLock))

#define RWAN_RELEASE_GLOBAL_LOCK()		\
				RWAN_RELEASE_LOCK(&((pRWanGlobal)->GlobalLock))

#define RWAN_FREE_GLOBAL_LOCK()		\
				RWAN_FREE_LOCK(&((pRWanGlobal)->GlobalLock))


//
//  Macros for operating the Address List lock:
//
#define RWAN_INIT_ADDRESS_LIST_LOCK()		\
				RWAN_INIT_LOCK(&((pRWanGlobal)->AddressListLock))

#define RWAN_ACQUIRE_ADDRESS_LIST_LOCK()		\
				RWAN_ACQUIRE_LOCK(&((pRWanGlobal)->AddressListLock))

#define RWAN_RELEASE_ADDRESS_LIST_LOCK()		\
				RWAN_RELEASE_LOCK(&((pRWanGlobal)->AddressListLock))

#define RWAN_FREE_ADDRESS_LIST_LOCK()		\
				RWAN_FREE_LOCK(&((pRWanGlobal)->AddressListLock))



//
//  Macros for operating the Connection Table lock:
//
#define RWAN_INIT_CONN_TABLE_LOCK()		\
				RWAN_INIT_LOCK(&((pRWanGlobal)->ConnTableLock))

#define RWAN_ACQUIRE_CONN_TABLE_LOCK()		\
				RWAN_ACQUIRE_LOCK(&((pRWanGlobal)->ConnTableLock))

#define RWAN_RELEASE_CONN_TABLE_LOCK()		\
				RWAN_RELEASE_LOCK(&((pRWanGlobal)->ConnTableLock))

#define RWAN_FREE_CONN_TABLE_LOCK()		\
				RWAN_FREE_LOCK(&((pRWanGlobal)->ConnTableLock))



//
//  Macros for operating Connection object locks:
//
#define RWAN_INIT_CONN_LOCK(pConnObj)	\
				RWAN_INIT_LOCK(&(pConnObj)->Lock)

#define RWAN_ACQUIRE_CONN_LOCK(pConnObj)	\
				RWAN_ACQUIRE_LOCK(&(pConnObj)->Lock)

#define RWAN_ACQUIRE_CONN_LOCK_DPC(pConnObj)	\
				RWAN_ACQUIRE_LOCK_DPC(&(pConnObj)->Lock)

#define RWAN_RELEASE_CONN_LOCK(pConnObj)	\
				RWAN_RELEASE_LOCK(&(pConnObj)->Lock)

#define RWAN_RELEASE_CONN_LOCK_DPC(pConnObj)	\
				RWAN_RELEASE_LOCK_DPC(&(pConnObj)->Lock)

#define RWAN_FREE_CONN_LOCK(pConnObj)	\
				RWAN_FREE_CONN_LOCK(&(pConnObj)->Lock)


//
//  Macros for operating Address object locks:
//
#define RWAN_INIT_ADDRESS_LOCK(pAddrObj)	\
				RWAN_INIT_LOCK(&(pAddrObj)->Lock)

#define RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObj)	\
				RWAN_ACQUIRE_LOCK(&(pAddrObj)->Lock)

#define RWAN_ACQUIRE_ADDRESS_LOCK_DPC(pAddrObj)	\
				RWAN_ACQUIRE_LOCK_DPC(&(pAddrObj)->Lock)

#define RWAN_RELEASE_ADDRESS_LOCK(pAddrObj)	\
				RWAN_RELEASE_LOCK(&(pAddrObj)->Lock)

#define RWAN_RELEASE_ADDRESS_LOCK_DPC(pAddrObj)	\
				RWAN_RELEASE_LOCK_DPC(&(pAddrObj)->Lock)

#define RWAN_FREE_ADDRESS_LOCK(pAddrObj)	\
				RWAN_FREE_ADDRESS_LOCK(&(pAddrObj)->Lock)

//
//  Macros for operating AF locks:
//
#define RWAN_INIT_AF_LOCK(pAfBlk)	\
				RWAN_INIT_LOCK(&(pAfBlk)->Lock)

#define RWAN_ACQUIRE_AF_LOCK(pAfBlk)	\
				RWAN_ACQUIRE_LOCK(&(pAfBlk)->Lock)

#define RWAN_ACQUIRE_AF_LOCK_DPC(pAfBlk)	\
				RWAN_ACQUIRE_LOCK_DPC(&(pAfBlk)->Lock)

#define RWAN_RELEASE_AF_LOCK(pAfBlk)	\
				RWAN_RELEASE_LOCK(&(pAfBlk)->Lock)

#define RWAN_RELEASE_AF_LOCK_DPC(pAfBlk)	\
				RWAN_RELEASE_LOCK_DPC(&(pAfBlk)->Lock)

#define RWAN_FREE_AF_LOCK(pAfBlk)	\
				RWAN_FREE_AF_LOCK(&(pAfBlk)->Lock)


//
//  Macros for operating Adapter locks:
//
#define RWAN_INIT_ADAPTER_LOCK(pAdptr)	\
				RWAN_INIT_LOCK(&(pAdptr)->Lock)

#define RWAN_ACQUIRE_ADAPTER_LOCK(pAdptr)	\
				RWAN_ACQUIRE_LOCK(&(pAdptr)->Lock)

#define RWAN_ACQUIRE_ADAPTER_LOCK_DPC(pAdptr)	\
				RWAN_ACQUIRE_LOCK_DPC(&(pAdptr)->Lock)

#define RWAN_RELEASE_ADAPTER_LOCK(pAdptr)	\
				RWAN_RELEASE_LOCK(&(pAdptr)->Lock)

#define RWAN_RELEASE_ADAPTER_LOCK_DPC(pAdptr)	\
				RWAN_RELEASE_LOCK_DPC(&(pAdptr)->Lock)

#define RWAN_FREE_ADAPTER_LOCK(pAdptr)	\
				RWAN_FREE_ADAPTER_LOCK(&(pAdptr)->Lock)


/*++
VOID
RWAN_ALLOC_MEM(
	IN	POPAQUE		pVar,
	IN	OPAQUE		StructureType,
	IN	ULONG		SizeOfStructure
)
--*/
#if DBG
#define RWAN_ALLOC_MEM(pVar, StructureType, SizeOfStructure)	\
			pVar = (StructureType *)RWanAuditAllocMem(				\
										(PVOID)(&(pVar)),			\
										(ULONG)(SizeOfStructure),	\
										_FILENUMBER,				\
										__LINE__					\
									);
#else
#define RWAN_ALLOC_MEM(pVar, StructureType, SizeOfStructure)	\
			NdisAllocateMemoryWithTag((PVOID *)(&pVar), (ULONG)(SizeOfStructure), (ULONG)'naWR');
#endif // DBG


/*++
VOID
RWAN_FREE_MEM(
	IN	POPAQUE		pMem
)
--*/
#if DBG
#define RWAN_FREE_MEM(pMem)	RWanAuditFreeMem((PVOID)(pMem));
#else
#define RWAN_FREE_MEM(pMem)	NdisFreeMemory((PVOID)(pMem), 0, 0);
#endif // DBG


/*++
VOID
RWAN_SET_MEM(
	IN	POPAQUE		pMem,
	IN	UCHAR		bValue,
	IN	ULONG		NumberOfBytes
)
--*/
#define RWAN_SET_MEM(pMem, bValue, NumberOfBytes)	\
			RtlFillMemory((PVOID)(pMem), (ULONG)(NumberOfBytes), (UCHAR)(bValue));


/*++
VOID
RWAN_ZERO_MEM(
	IN	POPAQUE		pMem,
	IN	ULONG		NumberOfBytes
)
--*/
#define RWAN_ZERO_MEM(pMem, NumberOfBytes)	\
			RtlZeroMemory((PVOID)pMem, (ULONG)(NumberOfBytes));


/*++
VOID
RWAN_COPY_MEM(
	IN	POPAQUE		pDst,
	IN	POPAQUE		pSrc,
	IN	ULONG		NumberOfBytes
)
--*/
#define RWAN_COPY_MEM(pDst, pSrc, NumberOfBytes)	\
			NdisMoveMemory((PVOID)(pDst), (PVOID)(pSrc), NumberOfBytes);


/*++
BOOLEAN
RWAN_EQUAL_MEM(
	IN	POPAQUE		pMem1,
	IN	POPAQUE		pMem2,
	IN	ULONG		Length
)
--*/
#define RWAN_EQUAL_MEM(_pMem1, _pMem2, _Length)	\
			(RtlCompareMemory((PVOID)(_pMem1), (PVOID)(_pMem2), (ULONG)(_Length)) == (_Length))


/*++
VOID
RWAN_SET_NEXT_PACKET(
	IN	PNDIS_PACKET		pNdisPacket,
	IN	PNDIS_PACKET		pNextPacket
)
--*/
#define RWAN_SET_NEXT_PACKET(pPkt, pNext)			\
			*((PNDIS_PACKET *)((pPkt)->MiniportReserved)) = (pNext);



/*++
PNDIS_PACKET
RWAN_GET_NEXT_PACKET(
	IN	PNDIS_PACKET		pNdisPacket
)
--*/
#define RWAN_GET_NEXT_PACKET(pPkt)					\
			(*((PNDIS_PACKET *)((pPkt)->MiniportReserved)))



//
//  Doubly linked list manipulation definitions and macros.
//
#define RWAN_INIT_LIST(_pListHead)					\
			InitializeListHead(_pListHead)

#define RWAN_IS_LIST_EMPTY(_pListHead)				\
			IsListEmpty(_pListHead)

#define RWAN_INSERT_HEAD_LIST(_pListHead, _pEntry)	\
			InsertHeadList((_pListHead), (_pEntry))

#define RWAN_INSERT_TAIL_LIST(_pListHead, _pEntry)	\
			InsertTailList((_pListHead), (_pEntry))

#define RWAN_DELETE_FROM_LIST(_pEntry)				\
			RemoveEntryList(_pEntry)


/*++
ULONG
ROUND_UP(
	IN	ULONG	Val
)
Round up a value so that it becomes a multiple of 4.
--*/
#define ROUND_UP(Val)	(((Val) + 3) & ~0x3)



/*++
VOID
RWAN_ADVANCE_RCV_REQ_BUFFER(
	IN	PRWAN_RECEIVE_REQUEST		pRcvReq
)
--*/
#define RWAN_ADVANCE_RCV_REQ_BUFFER(_pRcvReq)											\
	{																					\
		PNDIS_BUFFER	_pNextBuffer;													\
		NdisGetNextBuffer((_pRcvReq)->pBuffer, &(_pNextBuffer));						\
		(_pRcvReq)->pBuffer = _pNextBuffer;												\
		if (_pNextBuffer != NULL)														\
		{																				\
			NdisQueryBuffer(															\
				(_pNextBuffer),															\
				&(_pRcvReq)->pWriteData, 												\
				&(_pRcvReq)->BytesLeftInBuffer											\
				);																		\
																						\
			if (((_pRcvReq)->BytesLeftInBuffer > (_pRcvReq)->AvailableBufferLength))	\
			{																			\
				(_pRcvReq)->BytesLeftInBuffer = (_pRcvReq)->AvailableBufferLength;		\
			}																			\
		}																				\
		else																			\
		{																				\
			(_pRcvReq)->BytesLeftInBuffer = 0;											\
			(_pRcvReq)->pWriteData = NULL;												\
		}																				\
	}


/*++
VOID
RWAN_ADVANCE_RCV_IND_BUFFER(
	IN	PRWAN_RECEIVE_INDICATION		pRcvInd
)
--*/
#define RWAN_ADVANCE_RCV_IND_BUFFER(_pRcvInd)							\
	{																	\
		PNDIS_BUFFER	_pNextBuffer;									\
		NdisGetNextBuffer((_pRcvInd)->pBuffer, &(_pNextBuffer));		\
		(_pRcvInd)->pBuffer = _pNextBuffer;								\
		if (_pNextBuffer != NULL)										\
		{																\
			NdisQueryBuffer(											\
				(_pNextBuffer),											\
				&(_pRcvInd)->pReadData, 								\
				&(_pRcvInd)->BytesLeftInBuffer							\
				);														\
		}																\
		else															\
		{																\
			(_pRcvInd)->BytesLeftInBuffer = 0;							\
			(_pRcvInd)->pReadData = NULL;								\
		}																\
	}



/*++
VOID
RWAN_SET_DELETE_NOTIFY(
	IN	PRWAN_DELETE_NOTIFY			pNotifyObject,
	IN	PCOMPLETE_RTN				pDeleteRtn,
	IN	PVOID						DeleteContext
)
--*/
#define RWAN_SET_DELETE_NOTIFY(_pNotifyObj, _pDeleteRtn, _DeleteContext)	\
	{																	\
		(_pNotifyObj)->pDeleteRtn = (_pDeleteRtn);						\
		(_pNotifyObj)->DeleteContext = (_DeleteContext);				\
	}



/*++
PRWAN_SEND_REQUEST
RWAN_SEND_REQUEST_FROM_PACKET(
	IN	PNDIS_PACKET				pNdisPacket
	)
--*/
#define RWAN_SEND_REQUEST_FROM_PACKET(_pNdisPacket)					\
			(PRWAN_SEND_REQUEST)((_pNdisPacket)->ProtocolReserved)


#if DBG
#define RWAN_LINK_CONNECTION_TO_VC(_pConn, _pVc)					\
			{														\
				(_pConn)->NdisConnection.pNdisVc = _pVc;			\
				(_pConn)->pNdisVcSave = _pVc;						\
				(_pVc)->pConnObject = (_pConn);						\
			}
#else
#define RWAN_LINK_CONNECTION_TO_VC(_pConn, _pVc)					\
			{														\
				(_pConn)->NdisConnection.pNdisVc = _pVc;			\
				(_pConn)->pNdisVcSave = _pVc;						\
				(_pVc)->pConnObject = (_pConn);						\
			}
#endif // DBG

#define RWAN_UNLINK_CONNECTION_AND_VC(_pConn, _pVc)					\
			{														\
				(_pConn)->NdisConnection.pNdisVc = NULL_PRWAN_NDIS_VC;\
				(_pVc)->pConnObject = NULL_PRWAN_TDI_CONNECTION;	\
			}


/*++
VOID
RWAN_SET_VC_CALL_PARAMS(
	IN	PRWAN_NDIS_VC				pVc,
	IN	PCO_CALL_PARAMETERS			pCallParameters
	)
--*/
#define RWAN_SET_VC_CALL_PARAMS(_pVc, _pCallParameters)				\
{																	\
	if ((_pCallParameters != NULL) &&								\
		(_pCallParameters->CallMgrParameters != NULL))				\
	{																\
		_pVc->MaxSendSize = _pCallParameters->CallMgrParameters->Transmit.MaxSduSize;	\
	}																\
	if (gHackSendSize)												\
	{																\
		_pVc->MaxSendSize = gHackSendSize;							\
	}																\
	/* DbgPrint("RWan: set vc %x: maxsendsize to %d\n", _pVc, _pVc->MaxSendSize); */	\
}


#define RWAN_SET_VC_EVENT(_pVc, _Flags)	((_pVc)->Flags) |= (_Flags);


#if STATS

#define INCR_STAT(_pSt)	InterlockedIncrement(_pSt);

#define ADD_STAT(_pSt, Incr)	*(_pSt) += Incr;

#endif // STATS

#endif // __RWAN_MACROS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\mediasp.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\mediasp.c

Abstract:

	Media and Address Family Specific routines. These are exported routines
	that a media/AF specific module can call.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     06-02-97    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER ' DEM'



RWAN_STATUS
RWanInitMediaSpecific(
	VOID
	)
/*++

Routine Description:

	Initialize all media/AF specific modules. For now, we just
	run through our list of media-specific Init routines and call
	each of them.

Arguments:

	None

Return Value:

	RWAN_STATUS_SUCCESS if initialization completed successfully for
	atleast one module, RWAN_STATUS_FAILURE otherwise.

--*/
{
	RWAN_STATUS				RWanStatus;
	PRWAN_AFSP_MODULE_CHARS	pModuleChars;
	INT						SuccessfulInits;

	SuccessfulInits = 0;

	for (pModuleChars = &RWanMediaSpecificInfo[0];
		 pModuleChars->pAfSpInitHandler != NULL;
		 pModuleChars++)
	{
		RWanStatus = (*pModuleChars->pAfSpInitHandler)();
		if (RWanStatus == RWAN_STATUS_SUCCESS)
		{
			SuccessfulInits++;
		}
	}

	if (SuccessfulInits > 0)
	{
		return (RWAN_STATUS_SUCCESS);
	}
	else
	{
		return (RWAN_STATUS_FAILURE);
	}
}




VOID
RWanShutdownMediaSpecific(
	VOID
	)
/*++

Routine Description:

	Tell all media/AF-specific modules to shut down.

Arguments:

	None

Return Value:

	None

--*/
{
	PRWAN_AFSP_MODULE_CHARS	pModuleChars;

	for (pModuleChars = &RWanMediaSpecificInfo[0];
		 pModuleChars->pAfSpInitHandler != NULL;
		 pModuleChars++)
	{
		(*pModuleChars->pAfSpShutdownHandler)();
	}
}




RWAN_STATUS
RWanAfSpRegisterNdisAF(
	IN	PRWAN_NDIS_AF_CHARS			pAfChars,
	IN	RWAN_HANDLE					AfSpContext,
	OUT	PRWAN_HANDLE					pRWanSpHandle
	)
/*++

Routine Description:

	This is called by a media-specific module to register support
	of an NDIS Address family for a particular medium. The characteristics
	structure contains the module's entry points for various media-specific
	operations.

	We create an AF_INFO structure to keep track of this AF+Medium,
	and return a pointer to it as the handle.

Arguments:

	pAfChars			- Entry points for the module
	AfSpContext			- The media-specific module's context for this AF+medium
	pRWanSpHandle		- Place to return our handle for this AF+medium

Return Value:

	RWAN_STATUS_SUCCESS if the new NDIS AF+medium was successfully registered,
	RWAN_STATUS_RESOURCES if we failed due to lack of resources.
	XXX: Check for duplicates?

--*/
{
	PRWAN_NDIS_AF_INFO			pAfInfo;
	RWAN_STATUS					RWanStatus;

	do
	{
		RWAN_ALLOC_MEM(pAfInfo, RWAN_NDIS_AF_INFO, sizeof(RWAN_NDIS_AF_INFO));

		if (pAfInfo == NULL)
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		RWAN_SET_SIGNATURE(pAfInfo, nai);

		pAfInfo->Flags = 0;
		RWAN_INIT_LIST(&pAfInfo->NdisAfList);
		RWAN_INIT_LIST(&pAfInfo->TdiProtocolList);

		RWAN_COPY_MEM(&pAfInfo->AfChars, pAfChars, sizeof(RWAN_NDIS_AF_CHARS));

		pAfInfo->AfSpContext = AfSpContext;

		RWAN_ACQUIRE_GLOBAL_LOCK();

		RWAN_INSERT_HEAD_LIST(&pRWanGlobal->AfInfoList,
							 &pAfInfo->AfInfoLink);

		pRWanGlobal->AfInfoCount++;

		RWAN_RELEASE_GLOBAL_LOCK();

		*pRWanSpHandle = (RWAN_HANDLE)pAfInfo;
		RWanStatus = RWAN_STATUS_SUCCESS;
		break;
	}
	while (FALSE);

	return (RWanStatus);
}



RWAN_STATUS
RWanAfSpDeregisterNdisAF(
	IN	RWAN_HANDLE					RWanSpAFHandle
	)
/*++

Routine Description:

	This is called by a media-specific module to deregister support
	of an NDIS Address family for a particular medium.

Arguments:

	RWanSpAFHandle		- Actually a pointer to an NDIS_AF_INFO block.

Return Value:

	RWAN_STATUS_SUCCESS if we successfully completed the deregistration
	here, RWAN_STATUS_PENDING if there are open AFs or TDI protocols
	on this block.

--*/
{
	PRWAN_NDIS_AF_INFO			pAfInfo;
	RWAN_STATUS					RWanStatus;

	pAfInfo = (PRWAN_NDIS_AF_INFO)RWanSpAFHandle;

	RWAN_STRUCT_ASSERT(pAfInfo, nai);

	RWAN_ACQUIRE_GLOBAL_LOCK();

	//
	//  See if all AF blocks and TDI protocols are gone.
	//
	if (RWAN_IS_LIST_EMPTY(&pAfInfo->TdiProtocolList) &&
		RWAN_IS_LIST_EMPTY(&pAfInfo->NdisAfList))
	{
		RWanStatus = RWAN_STATUS_SUCCESS;

		//
		//  Remove this AF INFO block from the global list.
		//
		RWAN_DELETE_FROM_LIST(&pAfInfo->AfInfoLink);

		//
		//  Free this AF INFO block.
		//
		RWAN_FREE_MEM(pAfInfo);
	}
	else
	{
		//
		//  There is still some activity on this AF INFO.
		//  Pend this request till all these go away.
		//
		RWanStatus = RWAN_STATUS_PENDING;

		RWAN_SET_BIT(pAfInfo->Flags, RWANF_AFI_CLOSING);

		RWAN_ASSERT(FALSE);
	}

	RWAN_RELEASE_GLOBAL_LOCK();

	return (RWanStatus);

}


RWAN_STATUS
RWanAfSpRegisterTdiProtocol(
	IN	RWAN_HANDLE						RWanSpHandle,
	IN	PRWAN_TDI_PROTOCOL_CHARS		pTdiChars,
	OUT	PRWAN_HANDLE					pRWanProtHandle
	)
/*++

Routine Description:

	This is the API called by a media-specific module to register
	support for a TDI protocol over an NDIS AF. We create a TDI
	Protocol block and a device object to represent this protocol.

Arguments:

	RWanSpHandle			- Actually a pointer to our NDIS_AF_INFO structure
	pTdiChars			- Characteristics of the protocol being registered
	pRWanProtHandle		- Place to return our context for this protocol

Return Value:

	RWAN_STATUS_SUCCESS if we successfully registered this TDI protocol,
	RWAN_STATUS_XXX error code otherwise.

--*/
{
	RWAN_STATUS					RWanStatus;
	PRWAN_NDIS_AF_INFO			pAfInfo;
	PRWAN_TDI_PROTOCOL			pProtocol;
#ifdef NT
	PRWAN_DEVICE_OBJECT			pRWanDeviceObject;
	NTSTATUS					Status;
#endif // NT

	pAfInfo = (PRWAN_NDIS_AF_INFO)RWanSpHandle;
	RWAN_STRUCT_ASSERT(pAfInfo, nai);

	pProtocol = NULL;
	pRWanDeviceObject = NULL;

	do
	{
		RWAN_ALLOC_MEM(pProtocol, RWAN_TDI_PROTOCOL, sizeof(RWAN_TDI_PROTOCOL));

		if (pProtocol == NULL)
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		RWAN_SET_SIGNATURE(pProtocol, ntp);
		pProtocol->pAfInfo = pAfInfo;
		pProtocol->TdiProtocol = pTdiChars->TdiProtocol;
		pProtocol->SockAddressFamily = pTdiChars->SockAddressFamily;
		pProtocol->SockProtocol = pTdiChars->SockProtocol;
		pProtocol->TdiProtocol = pTdiChars->TdiProtocol;
		pProtocol->SockType = pTdiChars->SockType;
		pProtocol->bAllowAddressObjects = pTdiChars->bAllowAddressObjects;
		pProtocol->bAllowConnObjects = pTdiChars->bAllowConnObjects;
		pProtocol->pAfSpDeregTdiProtocolComplete =
							pTdiChars->pAfSpDeregTdiProtocolComplete;
		pProtocol->ProviderInfo = pTdiChars->ProviderInfo;

		RWAN_INIT_LIST(&pProtocol->AddrObjList);

#ifdef NT
		//
		//  Create an I/O Device on which we can receive IRPs for this
		//  protocol.
		//
		RWAN_ALLOC_MEM(pRWanDeviceObject, RWAN_DEVICE_OBJECT, sizeof(RWAN_DEVICE_OBJECT));

		if (pRWanDeviceObject == NULL)
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		RWAN_SET_SIGNATURE(pRWanDeviceObject, ndo);
		pRWanDeviceObject->pProtocol = pProtocol;
		pProtocol->pRWanDeviceObject = (PVOID)pRWanDeviceObject;

		//
		//  Create the device now. A pointer's worth of space is requested
		//  in the device extension.
		//
		Status = IoCreateDevice(
						pRWanGlobal->pDriverObject,
						sizeof(PRWAN_DEVICE_OBJECT),
						pTdiChars->pDeviceName,
						FILE_DEVICE_NETWORK,
						0,
						FALSE,
						&(pRWanDeviceObject->pDeviceObject)
						);

		if (!NT_SUCCESS(Status))
		{
			RWanStatus = RWAN_STATUS_FAILURE;
			break;
		}

		//
		//  Store a pointer to our device context in the
		//  NT device object extension.
		//
		*(PRWAN_DEVICE_OBJECT *)(pRWanDeviceObject->pDeviceObject->DeviceExtension) =
						pRWanDeviceObject;

		RWAN_ACQUIRE_GLOBAL_LOCK();

		RWAN_INSERT_HEAD_LIST(&(pRWanGlobal->DeviceObjList),
							 &(pRWanDeviceObject->DeviceObjectLink));

		//
		//  Add this Protocol to the list of TDI protocols on the
		//  AF INFO block.
		//
		RWAN_INSERT_TAIL_LIST(&(pAfInfo->TdiProtocolList),
							 &(pProtocol->AfInfoLink));

		//
		//  Add this Protocol to the global list of TDI protocols.
		//
		RWAN_INSERT_TAIL_LIST(&(pRWanGlobal->ProtocolList),
							 &(pProtocol->TdiProtocolLink));
		
		pRWanGlobal->ProtocolCount++;

		RWAN_RELEASE_GLOBAL_LOCK();
#endif // NT

		RWanStatus = RWAN_STATUS_SUCCESS;
		*pRWanProtHandle = (RWAN_HANDLE)pProtocol;

		break;
	}
	while (FALSE);

	if (RWanStatus != RWAN_STATUS_SUCCESS)
	{
		if (pProtocol != NULL)
		{
			RWAN_FREE_MEM(pProtocol);
		}
#ifdef NT
		if (pRWanDeviceObject != NULL)
		{
			RWAN_FREE_MEM(pRWanDeviceObject);
		}
#endif // NT
	}

	return (RWanStatus);
}




VOID
RWanAfSpDeregisterTdiProtocol(
	IN	RWAN_HANDLE					RWanProtHandle
	)
/*++

Routine Description:

	This is the API called by a media-specific module to de-register
	support for a TDI protocol. We delete the TDI Protocol block
	that holds information about this protocol.

Arguments:

	RWanProtHandle		- Pointer to the TDI Protocol block

Return Value:

	None

--*/
{
	PRWAN_TDI_PROTOCOL		pProtocol;
	PRWAN_NDIS_AF_INFO		pAfInfo;
#ifdef NT
	PRWAN_DEVICE_OBJECT		pRWanDeviceObject;
#endif // NT

	pProtocol = (PRWAN_TDI_PROTOCOL)RWanProtHandle;
	RWAN_STRUCT_ASSERT(pProtocol, ntp);

	RWAN_ASSERT(RWAN_IS_LIST_EMPTY(&pProtocol->AddrObjList));

	//
	//  Unlink this TDI protocol.
	//
	RWAN_ACQUIRE_GLOBAL_LOCK();

	RWAN_DELETE_FROM_LIST(&(pProtocol->TdiProtocolLink));
	RWAN_DELETE_FROM_LIST(&(pProtocol->AfInfoLink));

	pRWanGlobal->ProtocolCount--;

	RWAN_RELEASE_GLOBAL_LOCK();

#ifdef NT
	//
	//  Delete the I/O device we'd created for this protocol.
	//
	pRWanDeviceObject = (PRWAN_DEVICE_OBJECT)pProtocol->pRWanDeviceObject;
	RWAN_ASSERT(pRWanDeviceObject != NULL);

	IoDeleteDevice(pRWanDeviceObject->pDeviceObject);

	RWAN_FREE_MEM(pRWanDeviceObject);
#endif // NT

	RWAN_FREE_MEM(pProtocol);

	return;
}




VOID
RWanAfSpOpenAfComplete(
    IN	RWAN_STATUS					RWanStatus,
    IN	RWAN_HANDLE					RWanAfHandle,
    IN	RWAN_HANDLE					AfSpAFContext,
    IN	ULONG						MaxMessageSize
   	)
/*++

Routine Description:

	This is called by an AF-specific module to signify completion
	of our call to its OpenAfHandler routine. If the AF-specific module
	has successfully set up its context for this AF open, we store
	its context for this in our NDIS AF structure.

	Otherwise, we tear down this AF.

Arguments:

	RWanStatus		- Final status of our call to AF-specific module's AfOpen handler
	RWanAfHandle	- Our context for an NDIS AF Open
	AfSpAFContext	- AF-Specific module's context for this Open
	MaxMessageSize	- Max message size for this AF

Return Value:

	None

--*/
{
	PRWAN_NDIS_AF			pAf;
	PRWAN_NDIS_ADAPTER		pAdapter;
	PRWAN_NDIS_AF_INFO		pAfInfo;
	PLIST_ENTRY				pEnt;
	PRWAN_TDI_PROTOCOL		pTdiProtocol;

	pAf = (PRWAN_NDIS_AF)RWanAfHandle;
	RWAN_STRUCT_ASSERT(pAf, naf);

	pAdapter = pAf->pAdapter;

	if (RWanStatus == RWAN_STATUS_SUCCESS)
	{
		RWAN_ACQUIRE_ADAPTER_LOCK(pAdapter);

		RWAN_ACQUIRE_AF_LOCK_DPC(pAf);
		pAf->AfSpAFContext = AfSpAFContext;

		RWAN_SET_BIT(pAf->Flags, RWANF_AF_IN_ADAPTER_LIST);

		//
		//  Add this AF to the adapter's list of open AFs.
		//
		RWAN_INSERT_HEAD_LIST(&(pAdapter->AfList),
							 &(pAf->AfLink));

		RWAN_RELEASE_AF_LOCK_DPC(pAf);

#if 0
		RWanReferenceAdapter(pAdapter);	// AF linkage
#endif

		RWAN_RELEASE_ADAPTER_LOCK(pAdapter);

		RWAN_ACQUIRE_GLOBAL_LOCK();

		pAfInfo = pAf->pAfInfo;
		for (pEnt = pAfInfo->TdiProtocolList.Flink;
			 pEnt != &pAfInfo->TdiProtocolList;
			 pEnt = pEnt->Flink)
		{
			pTdiProtocol = CONTAINING_RECORD(pEnt, RWAN_TDI_PROTOCOL, AfInfoLink);

			pTdiProtocol->ProviderInfo.MaxSendSize =
				MIN(pTdiProtocol->ProviderInfo.MaxSendSize, MaxMessageSize);
		}

		RWAN_RELEASE_GLOBAL_LOCK();
	}
	else
	{
		RWanShutdownAf(pAf);
	}
}




VOID
RWanAfSpCloseAfComplete(
    IN	RWAN_HANDLE					RWanAfHandle
    )
/*++

Routine Description:

	This is called by an AF-specific module to signify completion
	of our call to its CloseAfHandler routine.

	We now call NDIS to close this AF.

Arguments:

	RWanAfHandle		- Our context for an NDIS AF Open

Return Value:

	None

--*/
{
	PRWAN_NDIS_AF			pAf;
	NDIS_HANDLE				NdisAfHandle;
	NDIS_STATUS				Status;

	pAf = (PRWAN_NDIS_AF)RWanAfHandle;
	RWAN_STRUCT_ASSERT(pAf, naf);

	RWAN_ACQUIRE_AF_LOCK(pAf);

	pAf->AfSpAFContext = NULL;
	NdisAfHandle = pAf->NdisAfHandle;

	RWAN_RELEASE_AF_LOCK(pAf);

	RWANDEBUGP(DL_LOUD, DC_BIND,
			("AfSpCloseAfComplete: pAf x%x, will CloseAF, AfHandle x%x\n",
					pAf, NdisAfHandle));

	Status = NdisClCloseAddressFamily(NdisAfHandle);

	if (Status != NDIS_STATUS_PENDING)
	{
		RWanNdisCloseAddressFamilyComplete(
			Status,
			(NDIS_HANDLE)pAf
			);
	}
}





RWAN_STATUS
RWanAfSpSendAdapterRequest(
    IN	RWAN_HANDLE					RWanAfHandle,
    IN	RWAN_HANDLE					AfSpReqContext,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    )
/*++

Routine Description:

	Send an NDIS Request down to the miniport on behalf of the media
	specific module.

Arguments:

	RWanAfHandle		- Our context for an NDIS AF Open
	AfSpReqContext	- The caller's context for this request
	RequestType		- NDIS request type
	Oid				- The object being set or queried
	pBuffer			- Points to parameter value
	BufferLength	- Length of the above

Return Value:

	RWAN_STATUS_PENDING if the request was sent to the miniport,
	RWAN_STATUS_RESOURCES if we couldn't allocate resources for the
	request.

--*/
{
	PRWAN_NDIS_AF			pAf;
	NDIS_HANDLE				NdisAdapterHandle;
	PNDIS_REQUEST			pNdisRequest;
	NDIS_STATUS				Status;
	PRWAN_NDIS_REQ_CONTEXT	pContext;

	pAf = (PRWAN_NDIS_AF)RWanAfHandle;
	RWAN_STRUCT_ASSERT(pAf, naf);

	if ((RequestType != NdisRequestQueryInformation) &&
		(RequestType != NdisRequestSetInformation))
	{
		return RWAN_STATUS_BAD_PARAMETER;
	}

	RWAN_ALLOC_MEM(pNdisRequest, NDIS_REQUEST, sizeof(NDIS_REQUEST) + sizeof(RWAN_NDIS_REQ_CONTEXT));

	if (pNdisRequest == NULL)
	{
	    return RWAN_STATUS_RESOURCES;
	}

	RWAN_ZERO_MEM(pNdisRequest, sizeof(NDIS_REQUEST));

	pNdisRequest->RequestType = RequestType;

	if (RequestType == NdisRequestQueryInformation)
	{
		pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;
	}
	else
	{
		pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.SET_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
		pNdisRequest->DATA.SET_INFORMATION.BytesNeeded = BufferLength;
	}

	//
	//  Fill in context about this request, so that we can complete
	//  it to the media-specific module later.
	//
	pContext = (PRWAN_NDIS_REQ_CONTEXT)((PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST));
	pContext->pAf = pAf;
	pContext->AfSpReqContext = AfSpReqContext;

	NdisRequest(&Status,
				pAf->pAdapter->NdisAdapterHandle,
				pNdisRequest);

	if (Status != NDIS_STATUS_PENDING)
	{
		RWanNdisRequestComplete(
			pAf->pAdapter,
			pNdisRequest,
			Status
			);
	}

	return RWAN_STATUS_PENDING;
}




RWAN_STATUS
RWanAfSpSendAfRequest(
    IN	RWAN_HANDLE					RWanAfHandle,
    IN	RWAN_HANDLE					AfSpReqContext,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    )
/*++

Routine Description:

	Send an NDIS Request down to the call manager on behalf of the media
	specific module.

Arguments:

	RWanAfHandle	- Our context for an NDIS AF Open
	AfSpReqContext	- The caller's context for this request
	RequestType		- NDIS request type
	Oid				- The object being set or queried
	pBuffer			- Points to parameter value
	BufferLength	- Length of the above

Return Value:

	RWAN_STATUS_PENDING if the request was sent to the call manager,
	RWAN_STATUS_RESOURCES if we couldn't allocate resources for the
	request.

--*/
{
	PRWAN_NDIS_AF			pAf;
	NDIS_HANDLE				NdisAfHandle;
	PNDIS_REQUEST			pNdisRequest;
	NDIS_STATUS				Status;
	PRWAN_NDIS_REQ_CONTEXT	pContext;

	pAf = (PRWAN_NDIS_AF)RWanAfHandle;
	RWAN_STRUCT_ASSERT(pAf, naf);

	if ((RequestType != NdisRequestQueryInformation) &&
		(RequestType != NdisRequestSetInformation))
	{
		return RWAN_STATUS_BAD_PARAMETER;
	}

	RWAN_ALLOC_MEM(pNdisRequest, NDIS_REQUEST, sizeof(NDIS_REQUEST) + sizeof(RWAN_NDIS_REQ_CONTEXT));

	if (pNdisRequest == NULL)
	{
	    return RWAN_STATUS_RESOURCES;
	}

	RWAN_ZERO_MEM(pNdisRequest, sizeof(NDIS_REQUEST));

	pNdisRequest->RequestType = RequestType;

	if (RequestType == NdisRequestQueryInformation)
	{
		pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;
	}
	else
	{
		pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.SET_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
		pNdisRequest->DATA.SET_INFORMATION.BytesNeeded = BufferLength;
	}

	//
	//  Fill in context about this request, so that we can complete
	//  it to the media-specific module later.
	//
	pContext = (PRWAN_NDIS_REQ_CONTEXT)((PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST));
	pContext->pAf = pAf;
	pContext->AfSpReqContext = AfSpReqContext;

	Status = NdisCoRequest(
				pAf->pAdapter->NdisAdapterHandle,
				pAf->NdisAfHandle,
				NULL,	// NdisVcHandle,
				NULL,	// NdisPartyHandlem
				pNdisRequest
				);

	if (Status != NDIS_STATUS_PENDING)
	{
		RWanNdisCoRequestComplete(
			Status,
			(NDIS_HANDLE)pAf,
			NULL,
			NULL,
			pNdisRequest
			);
	}

	return RWAN_STATUS_PENDING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\externs.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\externs.h

Abstract:

	All external declarations for Null Transport (functions, globals)
	are here.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     06-13-97    Created

Notes:

--*/


#ifndef __TDI_RWAN_EXTERNS__H
#define __TDI_RWAN_EXTERNS__H


#ifndef EXTERN
#define EXTERN	extern
#endif // EXTERN

//
//  ---- From space.c
//
EXTERN ULONG							RWanMaxTdiConnections;

EXTERN RWAN_STATUS						RWanAtmSpInitialize(VOID);
EXTERN VOID								RWanAtmSpShutdown(VOID);

EXTERN NDIS_HANDLE						RWanCopyBufferPool;
EXTERN NDIS_HANDLE						RWanCopyPacketPool;
EXTERN NDIS_HANDLE						RWanSendPacketPool;

EXTERN RWAN_GLOBALS						RWanGlobals;
EXTERN PRWAN_GLOBALS						pRWanGlobal;

EXTERN NDIS_PROTOCOL_CHARACTERISTICS	RWanNdisProtocolCharacteristics;
EXTERN NDIS_CLIENT_CHARACTERISTICS		RWanNdisClientCharacteristics;

EXTERN RWAN_AFSP_MODULE_CHARS			RWanMediaSpecificInfo[];


//
//  ---- From addr.c
//

EXTERN
TDI_STATUS
RWanTdiOpenAddress(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	TRANSPORT_ADDRESS UNALIGNED *pAddrList,
    IN	ULONG						AddrListLength,
    IN	UINT						Protocol,
    IN	PUCHAR						pOptions
    );

EXTERN
TDI_STATUS
RWanTdiSetEvent(
	IN	PVOID						AddrObjContext,
	IN	INT							TdiEventType,
	IN	PVOID						Handler,
	IN	PVOID						HandlerContext
	);

EXTERN
TDI_STATUS
RWanTdiCloseAddress(
    IN	PTDI_REQUEST				pTdiRequest
    );

EXTERN
TDI_STATUS
RWanCreateNdisSaps(
	IN	PRWAN_TDI_ADDRESS			pAddrObject,
	IN	PRWAN_TDI_PROTOCOL			pProtocol
	);

EXTERN
VOID
RWanNdisRegisterSapComplete(
	IN	NDIS_STATUS					NdisStatus,
	IN	NDIS_HANDLE					OurSapContext,
	IN	PCO_SAP						pCoSap,
	IN	NDIS_HANDLE					NdisSapHandle
	);

EXTERN
VOID
RWanDeleteNdisSaps(
	IN	PRWAN_TDI_ADDRESS			pAddrObject
	);

EXTERN
VOID
RWanNdisDeregisterSapComplete(
	IN	NDIS_STATUS					NdisStatus,
	IN	NDIS_HANDLE					ProtocolSapContext
	);


//
//  ---- From info.c
//
EXTERN
TDI_STATUS
RWanTdiQueryInformation(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	UINT						QueryType,
    IN	PNDIS_BUFFER				pNdisBuffer,
    IN	PUINT						pBufferSize,
    IN	UINT						IsConnection
    );

EXTERN
RWAN_STATUS
RWanHandleGenericConnQryInfo(
    IN	HANDLE						AddrHandle,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength,
    OUT	PVOID						pOutputBuffer,
    IN OUT	PVOID					pOutputBufferLength
    );

EXTERN
RWAN_STATUS
RWanHandleGenericAddrSetInfo(
    IN	HANDLE						AddrHandle,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength
    );

EXTERN
RWAN_STATUS
RWanHandleMediaSpecificAddrSetInfo(
    IN	HANDLE						AddrHandle,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength
    );

EXTERN
RWAN_STATUS
RWanHandleMediaSpecificConnQryInfo(
    IN	HANDLE						ConnectionContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength,
    OUT	PVOID						pOutputBuffer,
    IN OUT	PVOID					pOutputBufferLength
    );

EXTERN
PNDIS_BUFFER
RWanCopyFlatToNdis(
    IN	PNDIS_BUFFER				pDestBuffer,
    IN	PUCHAR						pSrcBuffer,
    IN	UINT						LengthToCopy,
    IN OUT	PUINT					pStartOffset,
    OUT	PUINT						pBytesCopied
    );


//
//  ---- From mediasp.c
//
RWAN_STATUS
RWanInitMediaSpecific(
	VOID
	);

EXTERN
VOID
RWanShutdownMediaSpecific(
	VOID
	);


//
//  ---- From ndisbind.c
//
VOID
RWanNdisBindAdapter(
	OUT	PNDIS_STATUS				pStatus,
	IN	NDIS_HANDLE					BindContext,
	IN	PNDIS_STRING				pDeviceName,
	IN	PVOID						SystemSpecific1,
	IN	PVOID						SystemSpecific2
	);

EXTERN
VOID
RWanNdisUnbindAdapter(
	OUT	PNDIS_STATUS				pStatus,
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					UnbindContext
	);

EXTERN
VOID
RWanNdisOpenAdapterComplete(
	IN	NDIS_HANDLE					ProtocolContext,
	IN	NDIS_STATUS					Status,
	IN	NDIS_STATUS					OpenErrorStatus
	);

EXTERN
VOID
RWanNdisCloseAdapterComplete(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status
	);

EXTERN
VOID
RWanNdisAfRegisterNotify(
	IN	NDIS_HANDLE					ProtocolContext,
	IN	PCO_ADDRESS_FAMILY			pAddressFamily
	);

EXTERN
VOID
RWanNdisOpenAddressFamilyComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisAfHandle
	);

EXTERN
VOID
RWanShutdownAf(
	IN	PRWAN_NDIS_AF				pAf
	);

EXTERN
VOID
RWanNdisCloseAddressFamilyComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					OurAfContext
	);

EXTERN
PNDIS_MEDIUM
RWanGetSupportedMedia(
	IN	PULONG						pMediaCount
	);

EXTERN
VOID
RWanCloseAdapter(
	IN	PRWAN_NDIS_ADAPTER			pAdapter
	);

EXTERN
VOID
RWanNdisRequestComplete(
	IN	NDIS_HANDLE					OurBindingContext,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_STATUS					Status
	);

EXTERN
VOID
RWanNdisStatus(
	IN	NDIS_HANDLE					OurBindingContext,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						StatusBuffer,
	IN	UINT						StatusBufferSize
	);

EXTERN
VOID
RWanNdisCoStatus(
	IN	NDIS_HANDLE					OurBindingContext,
	IN	NDIS_HANDLE					OurVcContext OPTIONAL,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						StatusBuffer,
	IN	UINT						StatusBufferSize
	);

EXTERN
VOID
RWanNdisStatusComplete(
	IN	NDIS_HANDLE					OurBindingContext
	);

EXTERN
NDIS_STATUS
RWanNdisCoRequest(
	IN	NDIS_HANDLE					OurAfContext,
	IN	NDIS_HANDLE					OurVcContext OPTIONAL,
	IN	NDIS_HANDLE					OurPartyContext OPTIONAL,
	IN OUT PNDIS_REQUEST			pNdisRequest
	);

EXTERN
VOID
RWanNdisCoRequestComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					OurAfContext,
	IN	NDIS_HANDLE					OurVcContext OPTIONAL,
	IN	NDIS_HANDLE					OurPartyContext OPTIONAL,
	IN	PNDIS_REQUEST				pNdisRequest
	);

EXTERN
NDIS_STATUS
RWanNdisReset(
	IN	NDIS_HANDLE					OurBindingContext
	);

EXTERN
VOID
RWanNdisResetComplete(
	IN	NDIS_HANDLE					OurBindingContext,
	IN	NDIS_STATUS					Status
	);

EXTERN
NDIS_STATUS
RWanNdisPnPEvent(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNET_PNP_EVENT				pNetPnPEvent
	);

EXTERN
NDIS_STATUS
RWanNdisPnPSetPower(
	IN	PRWAN_NDIS_ADAPTER			pAdapter,
	IN	PNET_PNP_EVENT				pNetPnPEvent
	);

EXTERN
NDIS_STATUS
RWanNdisPnPQueryPower(
	IN	PRWAN_NDIS_ADAPTER			pAdapter,
	IN	PNET_PNP_EVENT				pNetPnPEvent
	);

EXTERN
NDIS_STATUS
RWanNdisPnPQueryRemove(
	IN	PRWAN_NDIS_ADAPTER			pAdapter,
	IN	PNET_PNP_EVENT				pNetPnPEvent
	);

EXTERN
NDIS_STATUS
RWanNdisPnPCancelRemove(
	IN	PRWAN_NDIS_ADAPTER			pAdapter,
	IN	PNET_PNP_EVENT				pNetPnPEvent
	);


//
//  ---- From ndisconn.c
//
NDIS_STATUS
RWanNdisCreateVc(
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisVcHandle,
	OUT	PNDIS_HANDLE				pProtocolVcContext
	);

EXTERN
NDIS_STATUS
RWanNdisDeleteVc(
	IN	NDIS_HANDLE					ProtocolVcContext
	);

EXTERN
VOID
RWanNdisMakeCallComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					NdisPartyHandle		OPTIONAL,
	IN	PCO_CALL_PARAMETERS			pCallParameters
	);

EXTERN
VOID
RWanNdisAddPartyComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	NDIS_HANDLE					NdisPartyHandle,
	IN	PCO_CALL_PARAMETERS			pCallParameters
	);

EXTERN
NDIS_STATUS
RWanNdisIncomingCall(
	IN		NDIS_HANDLE				ProtocolSapContext,
	IN		NDIS_HANDLE				ProtocolVcContext,
	IN OUT	PCO_CALL_PARAMETERS		pCallParameters
	);

EXTERN
VOID
RWanNdisCallConnected(
	IN	NDIS_HANDLE					ProtocolVcContext
	);

EXTERN
VOID
RWanNdisIncomingCloseCall(
	IN	NDIS_STATUS					CloseStatus,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PVOID						pCloseData,
	IN	UINT						CloseDataLength
	);

EXTERN
VOID
RWanNdisCloseCallComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					ProtocolPartyContext
	);

EXTERN
VOID
RWanNdisDropPartyComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext
	);

EXTERN
VOID
RWanNdisIncomingDropParty(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					OurPartyContext,
	IN	PVOID						pBuffer,
	IN	UINT						BufferLength
	);

EXTERN
VOID
RWanNdisModifyQoSComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					OurVcContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
	);

EXTERN
VOID
RWanNdisRejectIncomingCall(
	IN	PRWAN_TDI_CONNECTION			pConnObject,
	IN	NDIS_STATUS					RejectStatus
	);

EXTERN
VOID
RWanStartCloseCall(
	IN	PRWAN_TDI_CONNECTION			pConnObject,
	IN	PRWAN_NDIS_VC				pVc
	);

EXTERN
VOID
RWanUnlinkVcFromAf(
	IN	PRWAN_NDIS_VC				pVc
	);

EXTERN
VOID
RWanCompleteConnReq(
	IN	PRWAN_NDIS_AF				pAf,
	IN	PRWAN_CONN_REQUEST			pConnReq,
	IN	BOOLEAN						IsOutgoingCall,
	IN	PCO_CALL_PARAMETERS			pCallParameters	OPTIONAL,
	IN	RWAN_HANDLE					AfSpConnContext,
	IN	TDI_STATUS					TdiStatus
	);


//
//  ---- From ntentry.c
//
NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT				pDriverObject,
	IN	PUNICODE_STRING				pRegistryPath
	);

EXTERN
VOID
RWanUnload(
	IN	PDRIVER_OBJECT				pDriverObject
	);

EXTERN
VOID
RWanUnloadProtocol(
	VOID
	);

EXTERN
NTSTATUS
RWanDispatch(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp
	);

EXTERN
NTSTATUS
RWanCreate(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanCleanup(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanClose(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanDispatchInternalDeviceControl(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp
	);

EXTERN
NTSTATUS
RWanDispatchPrivateDeviceControl(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	);

EXTERN
FILE_FULL_EA_INFORMATION UNALIGNED *
RWanFindEa(
	IN	FILE_FULL_EA_INFORMATION *	pStartEa,
	IN	CHAR *						pTargetName,
	IN	USHORT						TargetNameLength
	);

EXTERN
NTSTATUS
RWanSendData(
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanReceiveData(
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanAssociateAddress(
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanDisassociateAddress(
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanConnect(
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanDisconnect(
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanListen(
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanAccept(
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanSetEventHandler(
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanQueryInformation(
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
VOID
RWanCloseObjectComplete(
	IN	PVOID				Context,
	IN	UINT				Status,
	IN	UINT				Unused
	);

EXTERN
VOID
RWanDataRequestComplete(
	IN	PVOID				Context,
	IN	UINT				Status,
	IN	UINT				ByteCount
	);

EXTERN
VOID
RWanRequestComplete(
	IN	PVOID				Context,
	IN	UINT				Status,
	IN	UINT				Unused
	);

EXTERN
VOID
RWanNonCancellableRequestComplete(
	IN	PVOID				Context,
	IN	UINT				Status,
	IN	UINT				Unused
	);

EXTERN
VOID
RWanCancelComplete(
	IN	PVOID				Context,
	IN	UINT				Unused1,
	IN	UINT				Unused2
	);

EXTERN
VOID
RWanCancelRequest(
	IN	PDEVICE_OBJECT		pDeviceObject,
	IN	PIRP				pIrp
	);

EXTERN
NTSTATUS
RWanPrepareIrpForCancel(
	IN	PRWAN_ENDPOINT		pEndpoint,
	IN	PIRP				pIrp,
	IN	PDRIVER_CANCEL		pCancelRoutine
	);

EXTERN
ULONG
RWanGetMdlChainLength(
	IN	PMDL				pMdl
	);

EXTERN
NTSTATUS
RWanToNTStatus(
	IN	RWAN_STATUS			RWanStatus
	);

//
//  ---- From receive.c
//
RWAN_STATUS
RWanInitReceive(
	VOID
	);

EXTERN
VOID
RWanShutdownReceive(
	VOID
	);

EXTERN
TDI_STATUS
RWanTdiReceive(
    IN	PTDI_REQUEST				pTdiRequest,
	OUT	PUSHORT						pFlags,
	IN	PUINT						pReceiveLength,
	IN	PNDIS_BUFFER				pNdisBuffer
	);

EXTERN
UINT
RWanNdisCoReceivePacket(
    IN	NDIS_HANDLE					ProtocolBindingContext,
    IN	NDIS_HANDLE					ProtocolVcContext,
    IN	PNDIS_PACKET				pNdisPacket
    );

EXTERN
VOID
RWanIndicateData(
    IN	PRWAN_TDI_CONNECTION			pConnObject
    );

EXTERN
VOID
RWanNdisReceiveComplete(
    IN	NDIS_HANDLE					ProtocolBindingContext
	);

EXTERN
VOID
RWanNdisTransferDataComplete(
    IN	NDIS_HANDLE					ProtocolBindingContext,
    IN	PNDIS_PACKET				pNdisPacket,
    IN	NDIS_STATUS					Status,
    IN	UINT						BytesTransferred
    );

EXTERN
NDIS_STATUS
RWanNdisReceive(
    IN	NDIS_HANDLE					ProtocolBindingContext,
    IN	NDIS_HANDLE					MacReceiveContext,
    IN	PVOID						HeaderBuffer,
    IN	UINT						HeaderBufferSize,
    IN	PVOID						pLookAheadBuffer,
    IN	UINT						LookAheadBufferSize,
    IN	UINT						PacketSize
    );

EXTERN
INT
RWanNdisReceivePacket(
    IN	NDIS_HANDLE					ProtocolBindingContext,
    IN	PNDIS_PACKET				pNdisPacket
    );

EXTERN
PRWAN_RECEIVE_REQUEST
RWanAllocateReceiveReq(
	VOID
	);

EXTERN
VOID
RWanFreeReceiveReq(
    IN	PRWAN_RECEIVE_REQUEST		pRcvReq
   	);

EXTERN
PRWAN_RECEIVE_INDICATION
RWanAllocateReceiveInd(
	VOID
	);

EXTERN
VOID
RWanFreeReceiveInd(
	IN	PRWAN_RECEIVE_INDICATION		pRcvInd
	);

EXTERN
PNDIS_PACKET
RWanMakeReceiveCopy(
    IN	PNDIS_PACKET				pNdisPacket
	);

EXTERN
VOID
RWanFreeReceiveCopy(
    IN	PNDIS_PACKET				pCopyPacket
	);

EXTERN
VOID
RWanFreeReceiveIndList(
	IN	PRWAN_RECEIVE_INDICATION		pRcvInd
	);

//
//  ---- From send.c
//
RWAN_STATUS
RWanInitSend(
	VOID
	);

EXTERN
VOID
RWanShutdownSend(
	VOID
	);

EXTERN
TDI_STATUS
RWanTdiSendData(
    IN	PTDI_REQUEST				pTdiRequest,
	IN	USHORT						SendFlags,
	IN	UINT						SendLength,
	IN	PNDIS_BUFFER				pSendBuffer
	);

EXTERN
VOID
RWanNdisCoSendComplete(
    IN	NDIS_STATUS					NdisStatus,
    IN	NDIS_HANDLE					ProtocolVcContext,
    IN	PNDIS_PACKET				pNdisPacket
    );

EXTERN
PNDIS_PACKET
RWanAllocateSendPacket(
	VOID
	);

EXTERN
VOID
RWanFreeSendPacket(
    IN	PNDIS_PACKET				pSendPacket
    );

EXTERN
VOID
RWanNdisSendComplete(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	NDIS_STATUS					Status
	);


//
//  ---- From tdiconn.c
//
TDI_STATUS
RWanTdiOpenConnection(
    IN OUT	PTDI_REQUEST			pTdiRequest,
    IN		PVOID					ConnectionHandle
    );

#if DBG

PVOID
RWanTdiDbgGetConnObject(
	IN	HANDLE						ConnectionContext
	);
#endif

EXTERN
TDI_STATUS
RWanTdiCloseConnection(
    IN	PTDI_REQUEST				pTdiRequest
    );

EXTERN
TDI_STATUS
RWanTdiAssociateAddress(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	PVOID						AddressContext
    );

EXTERN
TDI_STATUS
RWanTdiDisassociateAddress(
    IN	PTDI_REQUEST				pTdiRequest
    );

EXTERN
TDI_STATUS
RWanTdiConnect(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	PVOID						pTimeout 		OPTIONAL,
    IN	PTDI_CONNECTION_INFORMATION	pRequestInfo,
    IN	PTDI_CONNECTION_INFORMATION	pReturnInfo
    );

EXTERN
TDI_STATUS
RWanTdiPMPConnect(
	IN	PRWAN_NDIS_AF_INFO			pAfInfo,
	IN	PRWAN_TDI_ADDRESS			pAddrObject,
	IN	PRWAN_TDI_CONNECTION		pConnObject,
	IN	PCO_CALL_PARAMETERS			pCallParameters,
	IN	ULONG						CallFlags,
	IN	PRWAN_CONN_REQUEST			pConnReq
	);

EXTERN
TDI_STATUS
RWanTdiListen(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	USHORT						Flags,
    IN	PTDI_CONNECTION_INFORMATION	pAcceptableAddr,
    IN	PTDI_CONNECTION_INFORMATION	pConnectedAddr
    );

EXTERN
TDI_STATUS
RWanTdiUnListen(
    IN	PTDI_REQUEST				pTdiRequest
    );

EXTERN
TDI_STATUS
RWanTdiAccept(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	PTDI_CONNECTION_INFORMATION	pAcceptInfo,
    IN	PTDI_CONNECTION_INFORMATION	pConnectInfo
    );

EXTERN
TDI_STATUS
RWanTdiDisconnect(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	PVOID						pTimeout,
    IN	USHORT						Flags,
    IN	PTDI_CONNECTION_INFORMATION	pDisconnInfo,
    OUT	PTDI_CONNECTION_INFORMATION	pReturnInfo
    );

EXTERN
TDI_STATUS
RWanDoTdiDisconnect(
    IN	PRWAN_TDI_CONNECTION		pConnObject,
    IN	PTDI_REQUEST				pTdiRequest		OPTIONAL,
    IN	PVOID						pTimeout		OPTIONAL,
    IN	USHORT						Flags,
    IN	PTDI_CONNECTION_INFORMATION	pDisconnInfo	OPTIONAL,
    OUT	PTDI_CONNECTION_INFORMATION	pReturnInfo		OPTIONAL
	);

EXTERN
RWAN_CONN_ID
RWanGetConnId(
	IN	PRWAN_TDI_CONNECTION			pConnObject
	);

EXTERN
PRWAN_TDI_CONNECTION
RWanGetConnFromId(
	IN	RWAN_CONN_ID					ConnId
	);

EXTERN
VOID
RWanFreeConnId(
	IN	RWAN_CONN_ID					ConnId
	);

EXTERN
TDI_STATUS
RWanToTdiStatus(
	IN	RWAN_STATUS					RWanStatus
	);

EXTERN
PRWAN_CONN_REQUEST
RWanAllocateConnReq(
	VOID
	);

EXTERN
VOID
RWanFreeConnReq(
	IN	PRWAN_CONN_REQUEST			pConnReq
	);

EXTERN
VOID
RWanAbortConnection(
	IN	CONNECTION_CONTEXT			ConnectionContext
	);

EXTERN
VOID
RWanDoAbortConnection(
	IN	PRWAN_TDI_CONNECTION			pConnObject
	);

EXTERN
VOID
RWanScheduleDisconnect(
	IN	PRWAN_TDI_CONNECTION			pConnObject
	);

EXTERN
VOID
RWanDelayedDisconnectHandler(
	IN	PNDIS_WORK_ITEM					pCloseWorkItem,
	IN	PVOID							Context
	);

//
//  ---- From utils.c
//
RWAN_STATUS
RWanInitGlobals(
	IN	PDRIVER_OBJECT				pDriverObject
	);

EXTERN
VOID
RWanDeinitGlobals(
	VOID
	);

EXTERN
PRWAN_TDI_PROTOCOL
RWanGetProtocolFromNumber(
	IN	UINT						Protocol
	);

EXTERN
TA_ADDRESS *
RWanGetValidAddressFromList(
	IN	TRANSPORT_ADDRESS UNALIGNED *pAddrList,
	IN	PRWAN_TDI_PROTOCOL			pProtocol
	);

EXTERN
PRWAN_TDI_CONNECTION
RWanAllocateConnObject(
	VOID
	);

EXTERN
VOID
RWanReferenceConnObject(
	IN	PRWAN_TDI_CONNECTION			pConnObject
	);

EXTERN
INT
RWanDereferenceConnObject(
	IN	PRWAN_TDI_CONNECTION			pConnObject
	);

EXTERN
PRWAN_TDI_ADDRESS
RWanAllocateAddressObject(
	IN	TA_ADDRESS *		            pTransportAddress
	);

EXTERN
VOID
RWanReferenceAddressObject(
	IN	PRWAN_TDI_ADDRESS			pAddrObject
	);

EXTERN
INT
RWanDereferenceAddressObject(
	IN	PRWAN_TDI_ADDRESS			pAddrObject
	);

EXTERN
PRWAN_NDIS_AF
RWanAllocateAf(
	VOID
	);

EXTERN
VOID
RWanReferenceAf(
	IN	PRWAN_NDIS_AF			pAf
	);

EXTERN
INT
RWanDereferenceAf(
	IN	PRWAN_NDIS_AF			pAf
	);

#if 0

EXTERN
VOID
RWanReferenceAdapter(
	IN	PRWAN_NDIS_ADAPTER		pAdapter
	);

EXTERN
INT
RWanDereferenceAdapter(
	IN	PRWAN_NDIS_ADAPTER		pAdapter
	);

#endif // 0

EXTERN
TDI_STATUS
RWanNdisToTdiStatus(
	IN	NDIS_STATUS				Status
	);


//
//  ---- vc.c
//
PRWAN_NDIS_VC
RWanAllocateVc(
	IN	PRWAN_NDIS_AF				pAf,
	IN	BOOLEAN						IsOutgoing
	);

EXTERN
VOID
RWanFreeVc(
	IN	PRWAN_NDIS_VC				pVc
	);


#endif // __TDI_RWAN_EXTERNS__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\ndisbind.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\ndisbind.c

Abstract:

	NDIS entry points and helper routines for binding, unbinding, opening
	and closing adapters.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     05-02-97    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'DNIB'




VOID
RWanNdisBindAdapter(
	OUT	PNDIS_STATUS				pStatus,
	IN	NDIS_HANDLE					BindContext,
	IN	PNDIS_STRING				pDeviceName,
	IN	PVOID						SystemSpecific1,
	IN	PVOID						SystemSpecific2
	)
/*++

Routine Description:

	This is the NDIS protocol entry point for binding to an adapter.
	We open the adapter and see if it is one of the supported types.
	Action continues when we get notified of a Call Manager that
	has registered support for an Address Family.

Arguments:

	pStatus			- Place to return status of this call
	BindContext		- Used to complete this call, if we pend it.
	pDeviceName		- Name of adapter we are asked to bind to.
	SystemSpecific1	- Handle to use to access configuration information
	SystemSpecific2	- Not used

Return Value:

	None directly. But we set *pStatus to NDIS_STATUS_PENDING if we
	made the call to open the adapter, NDIS_STATUS_NOT_RECOGNIZED
	if this adapter isn't one of the supported media types, NDIS_STATUS_RESOURCES
	if we hit any allocation failures.

--*/
{
	PRWAN_NDIS_ADAPTER		pAdapter;
	PNDIS_MEDIUM			pMediaArray;
	UINT					MediaCount;	// Number of media-types we support
	NDIS_STATUS				Status;
	NDIS_STATUS				OpenStatus;
	ULONG					TotalLength;


	RWANDEBUGP(DL_LOUD, DC_BIND,
			("BindAdapter: Context x%x, Device %Z, SS1 x%x, SS2 x%x\n",
				BindContext, pDeviceName, SystemSpecific1, SystemSpecific2));

#if DBG
	if (RWanSkipAll)
	{
		RWANDEBUGP(DL_ERROR, DC_WILDCARD,
				("BindAdapter: bailing out!\n"));
		*pStatus = NDIS_STATUS_NOT_RECOGNIZED;
		return;
	}
#endif // DBG

	//
	//  Initialize.
	//
	pAdapter = NULL_PRWAN_NDIS_ADAPTER;
	pMediaArray = NULL;

	do
	{
		//
		//  Allocate an Adapter structure, along with space for the device
		//  name.
		//
		TotalLength = sizeof(RWAN_NDIS_ADAPTER) + (pDeviceName->MaximumLength)*sizeof(WCHAR);

		RWAN_ALLOC_MEM(pAdapter, RWAN_NDIS_ADAPTER, TotalLength);

		if (pAdapter == NULL_PRWAN_NDIS_ADAPTER)
		{
			RWANDEBUGP(DL_WARN, DC_BIND,
					("BindAdapter: Couldnt allocate adapter (%d bytes)\n", TotalLength));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//  Get the list of NDIS media that we support.
		//
		pMediaArray = RWanGetSupportedMedia(&MediaCount);

		if (pMediaArray == NULL)
		{
			RWANDEBUGP(DL_WARN, DC_BIND,
					("BindAdapter: Couldnt get supported media list!\n"));
			Status = NDIS_STATUS_NOT_RECOGNIZED;
			break;
		}

		//
		//  Initialize the Adapter.
		//
		RWAN_ZERO_MEM(pAdapter, TotalLength);
		RWAN_SET_SIGNATURE(pAdapter, nad);

		RWAN_INIT_LIST(&(pAdapter->AfList));
		RWAN_INIT_LOCK(&(pAdapter->Lock));

		pAdapter->pMediaArray = pMediaArray;
		pAdapter->BindContext = BindContext;

		//
		//  Copy in the device name.
		//
		pAdapter->DeviceName.Buffer = (PWCHAR)((PUCHAR)pAdapter + sizeof(RWAN_NDIS_ADAPTER));
		pAdapter->DeviceName.MaximumLength = pDeviceName->MaximumLength;
		pAdapter->DeviceName.Length = pDeviceName->Length;
		RWAN_COPY_MEM(pAdapter->DeviceName.Buffer, pDeviceName->Buffer, pDeviceName->Length);

		pAdapter->State = RWANS_AD_OPENING;


		//
		//  Link this adapter to the global list of adapters.
		//
		RWAN_ACQUIRE_GLOBAL_LOCK();

		RWAN_INSERT_HEAD_LIST(&(pRWanGlobal->AdapterList),
							 &(pAdapter->AdapterLink));

		pRWanGlobal->AdapterCount++;
		RWAN_RELEASE_GLOBAL_LOCK();


		//
		//  Open the Adapter.
		//
		NdisOpenAdapter(
			&Status,
			&OpenStatus,
			&(pAdapter->NdisAdapterHandle),
			&(pAdapter->MediumIndex),		// place to return selected medium index
			pMediaArray,					// List of media types we support
			MediaCount,						// Length of above list
			pRWanGlobal->ProtocolHandle,
			(NDIS_HANDLE)pAdapter,			// our context for the adapter binding
			pDeviceName,
			0,								// open options (none)
			(PSTRING)NULL					// Addressing info (none)
			);

		if (Status != NDIS_STATUS_PENDING)
		{
			RWanNdisOpenAdapterComplete(
				(NDIS_HANDLE)pAdapter,
				Status,
				OpenStatus
				);
		}

		Status = NDIS_STATUS_PENDING;

		break;
	}
	while (FALSE);


	if (Status != NDIS_STATUS_PENDING)
	{
		//
		//  Failed somewhere; clean up.
		//
		if (pAdapter != NULL_PRWAN_NDIS_ADAPTER)
		{
			RWAN_FREE_MEM(pAdapter);
		}

		if (pMediaArray != NULL)
		{
			RWAN_FREE_MEM(pMediaArray);
		}
	}

	*pStatus = Status;

	RWANDEBUGP(DL_LOUD, DC_BIND,
			("BindAdapter: pAdapter x%x, returning x%x\n", pAdapter, Status));

	return;

}



VOID
RWanNdisUnbindAdapter(
	OUT	PNDIS_STATUS				pStatus,
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					UnbindContext
	)
/*++

Routine Description:

	This is the NDIS protocol entry point for unbinding from an adapter
	that we have opened.

Arguments:

	pStatus			- Place to return status of this call
	ProtocolBindingContext - Our context for the bound adapter
	UnbindContext	- To be used when we complete the unbind.

Return Value:

	None. We set *pStatus to NDIS_STATUS_PENDING.

--*/
{
	PRWAN_NDIS_ADAPTER			pAdapter;
	PLIST_ENTRY					pAfEntry;
	PLIST_ENTRY					pNextAfEntry;
	PRWAN_NDIS_AF				pAf;


	pAdapter = (PRWAN_NDIS_ADAPTER)ProtocolBindingContext;
	RWAN_STRUCT_ASSERT(pAdapter, nad);

	RWANDEBUGP(DL_WARN, DC_BIND,
			("UnbindAdapter: pAdapter x%x, State x%x\n", pAdapter, pAdapter->State));

	RWAN_ACQUIRE_ADAPTER_LOCK(pAdapter);

	//
	//  Store away the unbind context for use in completing this
	//  unbind later.
	//
	pAdapter->BindContext = UnbindContext;
	RWAN_SET_BIT(pAdapter->Flags, RWANF_AD_UNBIND_PENDING);

	*pStatus = NDIS_STATUS_PENDING;

	if (RWAN_IS_LIST_EMPTY(&(pAdapter->AfList)))
	{
		RWanCloseAdapter(pAdapter);
		//
		//  Lock is released within the above.
		//
	}
	else
	{
		//
		//  Shut down all AFs on this adapter. We release the lock
		//  early since we are unbinding and don't expect any other
		//  events now.
		//

		RWAN_RELEASE_ADAPTER_LOCK(pAdapter);

		for (pAfEntry = pAdapter->AfList.Flink;
			 pAfEntry != &(pAdapter->AfList);
			 pAfEntry = pNextAfEntry)
		{
			pNextAfEntry = pAfEntry->Flink;

			pAf = CONTAINING_RECORD(pAfEntry, RWAN_NDIS_AF, AfLink);

			RWanShutdownAf(pAf);
		}

	}

	return;
}




VOID
RWanNdisOpenAdapterComplete(
	IN	NDIS_HANDLE					ProtocolContext,
	IN	NDIS_STATUS					Status,
	IN	NDIS_STATUS					OpenErrorStatus
	)
/*++

Routine Description:

	This is the NDIS Entry point called when a previous call we made
	to NdisOpenAdapter has completed.

Arguments:

	ProtocolContext	- our context for the adapter being opened,
					  which is a pointer to our Adapter structure.
	Status			- Final status of NdisOpenAdapter
	OpenErrorStatus	- Error code in case of failure

Return Value:

	None

--*/
{
	PRWAN_NDIS_ADAPTER			pAdapter;
	NDIS_HANDLE					BindContext;
	PNDIS_MEDIUM				pMediaArray;

	pAdapter = (PRWAN_NDIS_ADAPTER)ProtocolContext;

	RWAN_STRUCT_ASSERT(pAdapter, nad);

	BindContext = pAdapter->BindContext;
	pMediaArray = pAdapter->pMediaArray;

	if (Status == NDIS_STATUS_SUCCESS)
	{
		RWAN_ACQUIRE_ADAPTER_LOCK(pAdapter);

		pAdapter->Medium = pMediaArray[pAdapter->MediumIndex];

		pAdapter->State = RWANS_AD_OPENED;

		RWAN_RELEASE_ADAPTER_LOCK(pAdapter);
	}
	else
	{
		//
		//  Remove this adapter from the global list.
		//
		//
		RWAN_ACQUIRE_GLOBAL_LOCK();

		RWAN_DELETE_FROM_LIST(&(pAdapter->AdapterLink));

		pRWanGlobal->AdapterCount--;

		RWAN_RELEASE_GLOBAL_LOCK();

		RWAN_FREE_MEM(pAdapter);
	}

	RWAN_FREE_MEM(pMediaArray);
	
	RWANDEBUGP(DL_INFO, DC_BIND, ("OpenAdapterComplete: pAdapter x%x, Status x%x\n",
						pAdapter, Status));

	//
	//  Now complete the BindAdapter that we had pended.
	//
	NdisCompleteBindAdapter(
		BindContext,
		Status,
		OpenErrorStatus
		);

	return;
}




VOID
RWanNdisCloseAdapterComplete(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status
	)
/*++

Routine Description:

	This is the NDIS entry point signifying completion of a pended call
	to NdisCloseAdapter. If we were unbinding from the adapter, complete
	the unbind now.

Arguments:

	ProtocolBindingContext	- our context for an adapter binding,
					  which is a pointer to our Adapter structure.
	Status			- Final status of NdisCloseAdapter

Return Value:

	None

--*/
{
	PRWAN_NDIS_ADAPTER			pAdapter;
	NDIS_HANDLE					UnbindContext;

	RWAN_ASSERT(Status == NDIS_STATUS_SUCCESS);

	pAdapter = (PRWAN_NDIS_ADAPTER)ProtocolBindingContext;
	RWAN_STRUCT_ASSERT(pAdapter, nad);

	//
	//  Unlink this adapter from the global list of adapters.
	//
	RWAN_ACQUIRE_GLOBAL_LOCK();

	RWAN_DELETE_FROM_LIST(&(pAdapter->AdapterLink));

	pRWanGlobal->AdapterCount--;

	RWAN_RELEASE_GLOBAL_LOCK();

	UnbindContext = pAdapter->BindContext;

	RWAN_FREE_MEM(pAdapter);

	//
	//  We would have closed the adapter because of one of the following:
	//  1. NDIS told us to Unbind from the adapter -> complete the Unbind
	//  2. We are unloading -> continue this process
	//
	if (UnbindContext != NULL)
	{

		NdisCompleteUnbindAdapter(
				UnbindContext,
				NDIS_STATUS_SUCCESS
				);
	}
	else
	{
		//
		//  We are here because our Unload handler got called.
		//  Wake up the thread that's waiting for this adapter
		//  to be closed.
		//

		RWAN_SIGNAL_EVENT_STRUCT(&pRWanGlobal->Event, Status);
	}

	return;
}




VOID
RWanNdisAfRegisterNotify(
	IN	NDIS_HANDLE					ProtocolContext,
	IN	PCO_ADDRESS_FAMILY			pAddressFamily
	)
/*++

Routine Description:

	This is the NDIS entry point to announce the presence of a
	Call manager supporting a specified Address Family on an
	adapter that we are bound to.

	If this address family is one that we support, we create an
	AF block, and open the address family.

Arguments:

	ProtocolContext	- our context for an adapter binding,
					  which is a pointer to our Adapter structure.
	pAddressFamily	- pointer to structure describing the Address Family

Return Value:

	None

--*/
{
	PRWAN_NDIS_ADAPTER		pAdapter;
	NDIS_STATUS				Status;
	PLIST_ENTRY				pAfInfoEntry;
	PRWAN_NDIS_AF_INFO		pAfInfo;
	PRWAN_NDIS_AF			pAf;
	BOOLEAN					bFound;

	pAdapter = (PRWAN_NDIS_ADAPTER)ProtocolContext;

	RWAN_STRUCT_ASSERT(pAdapter, nad);

	do
	{
		//
		//  Create a new NDIS AF block.
		//
		pAf = RWanAllocateAf();

		if (pAf == NULL)
		{
			break;
		}

		pAf->pAdapter = pAdapter;

		RWanReferenceAf(pAf);	// Open AF ref

		//
		//  Search for an AF_INFO structure matching this <NDIS AF, Medium>
		//  pair.
		//
		bFound = FALSE;

		RWAN_ACQUIRE_GLOBAL_LOCK();

		for (pAfInfoEntry = pRWanGlobal->AfInfoList.Flink;
			 pAfInfoEntry != &(pRWanGlobal->AfInfoList);
			 pAfInfoEntry = pAfInfoEntry->Flink)
		{
			pAfInfo = CONTAINING_RECORD(pAfInfoEntry, RWAN_NDIS_AF_INFO, AfInfoLink);

			if ((pAfInfo->AfChars.Medium == pAdapter->Medium)
					&&
				(RWAN_EQUAL_MEM(pAddressFamily,
							   &(pAfInfo->AfChars.AddressFamily),
							   sizeof(*pAddressFamily))))
			{
				bFound = TRUE;
				pAf->pAfInfo = pAfInfo;

				RWAN_INSERT_TAIL_LIST(&(pAfInfo->NdisAfList),
									&(pAf->AfInfoLink));
				break;
			}
		}

		RWAN_RELEASE_GLOBAL_LOCK();

		if (!bFound)
		{
			RWAN_FREE_MEM(pAf);
			break;
		}

		//
		//  Open the Address Family.
		//
		Status = NdisClOpenAddressFamily(
						pAdapter->NdisAdapterHandle,
						pAddressFamily,
						(NDIS_HANDLE)pAf,
						&RWanNdisClientCharacteristics,
						sizeof(RWanNdisClientCharacteristics),
						&(pAf->NdisAfHandle)
						);

		if (Status != NDIS_STATUS_PENDING)
		{
			RWanNdisOpenAddressFamilyComplete(
				Status,
				(NDIS_HANDLE)pAf,
				pAf->NdisAfHandle
				);
		}

		break;
	}
	while (FALSE);

	return;
}




VOID
RWanNdisOpenAddressFamilyComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisAfHandle
	)
/*++

Routine Description:

	This is the NDIS entry point signifying completion of a call
	we made to NdisClOpenAddressFamily. If the Address Family open
	was successful, we store the returned handle in our AF block.
	Otherwise we delete the AF block.

Arguments:

	Status				- Final status of NdisClOpenAddressFamily
	ProtocolAfContext	- Our context for an AF open, which is a pointer
						  to an RWAN_NDIS_AF structure
	NdisAfHandle		- If successful, this is the handle we should use
						  to refer to this AF henceforth

Return Value:

	None

--*/
{
	PRWAN_NDIS_AF			pAf;
	NDIS_HANDLE				NdisAdapterHandle;
	PRWAN_NDIS_AF_INFO		pAfInfo;
	INT						rc;
	RWAN_STATUS				RWanStatus;
	ULONG					MaxMsgSize;

	pAf = (PRWAN_NDIS_AF)ProtocolAfContext;

	RWAN_STRUCT_ASSERT(pAf, naf);

	RWAN_ACQUIRE_AF_LOCK(pAf);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		pAf->NdisAfHandle = NdisAfHandle;
		NdisAdapterHandle = pAf->pAdapter->NdisAdapterHandle;

		pAfInfo = pAf->pAfInfo;

		RWAN_RELEASE_AF_LOCK(pAf);

		//
		//  Tell the AF-specific module about this successful AF open,
		//  so that it can initialize and return its context for this open.
		//
		RWanStatus = (*pAfInfo->AfChars.pAfSpOpenAf)(
						pAfInfo->AfSpContext,
						(RWAN_HANDLE)pAf,
						&pAf->AfSpAFContext,
						&MaxMsgSize
						);

		if (RWanStatus != RWAN_STATUS_PENDING)
		{
			RWanAfSpOpenAfComplete(
						RWanStatus,
						(RWAN_HANDLE)pAf,
						pAf->AfSpAFContext,
						MaxMsgSize
						);
		}
	}
	else
	{
		RWANDEBUGP(DL_WARN, DC_WILDCARD,
				("OpenAfComplete: Af x%x, bad status x%x\n", pAf, Status));

		rc = RWanDereferenceAf(pAf);	// Open AF failure

		RWAN_ASSERT(rc == 0);
	}

	return;
}



VOID
RWanShutdownAf(
	IN	PRWAN_NDIS_AF				pAf
	)
/*++

Routine Description:

	Shut down an AF open: deregister all SAPs and abort all calls.

Arguments:

	pAf					- Points to NDIS AF block

Return Value:

	None

--*/
{
	PRWAN_TDI_ADDRESS		pAddrObject;
	PRWAN_NDIS_SAP			pSap;
	PLIST_ENTRY				pSapEntry;
	PLIST_ENTRY				pNextSapEntry;
	NDIS_HANDLE				NdisSapHandle;
	NDIS_STATUS				Status;

	PRWAN_TDI_CONNECTION	pConnObject;
	PLIST_ENTRY				pVcEntry;
	PLIST_ENTRY				pNextVcEntry;
	PRWAN_NDIS_VC			pVc;

	INT						rc;
	RWAN_HANDLE				AfSpAFContext;
	RWAN_STATUS				RWanStatus;

	//
	//  Check if we are already closing this AF.
	//
	RWAN_ACQUIRE_AF_LOCK(pAf);

	RWANDEBUGP(DL_LOUD, DC_BIND,
			("ShutdownAf: AF x%x, Flags x%x, AfHandle x%x\n", pAf, pAf->Flags, pAf->NdisAfHandle));

	if (RWAN_IS_BIT_SET(pAf->Flags, RWANF_AF_CLOSING))
	{
		RWAN_RELEASE_AF_LOCK(pAf);
		return;
	}

	RWAN_SET_BIT(pAf->Flags, RWANF_AF_CLOSING);
	
	//
	//  Make sure the AF doesn't go away while we are here.
	//
	RWanReferenceAf(pAf);	// temp ref: RWanShutdownAf

	//
	//  Deregister all SAPs.
	//
	for (pSapEntry = pAf->NdisSapList.Flink;
		 pSapEntry != &(pAf->NdisSapList);
		 pSapEntry = pNextSapEntry)
	{
		pNextSapEntry = pSapEntry->Flink;

		pSap = CONTAINING_RECORD(pSapEntry, RWAN_NDIS_SAP, AfLink);

		pAddrObject = pSap->pAddrObject;

		RWAN_RELEASE_AF_LOCK(pAf);

		RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

		if (!RWAN_IS_BIT_SET(pSap->Flags, RWANF_SAP_CLOSING))
		{
			RWAN_SET_BIT(pSap->Flags, RWANF_SAP_CLOSING);

			RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

			NdisSapHandle = pSap->NdisSapHandle;
			RWAN_ASSERT(NdisSapHandle != NULL);

			Status = NdisClDeregisterSap(NdisSapHandle);

			if (Status != NDIS_STATUS_PENDING)
			{
				RWanNdisDeregisterSapComplete(
					Status,
					(NDIS_HANDLE)pSap
					);
			}
		}
		else
		{
			//
			//  This SAP is already closing.
			//
			RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);
		}
		
		RWAN_ACQUIRE_AF_LOCK(pAf);
	}

	//
	//  Close all connections on this AF.
	//
	for (pVcEntry = pAf->NdisVcList.Flink;
		 pVcEntry != &(pAf->NdisVcList);
		 pVcEntry = pNextVcEntry)
	{
		pNextVcEntry = pVcEntry->Flink;

		pVc = CONTAINING_RECORD(pVcEntry, RWAN_NDIS_VC, VcLink);

		RWAN_STRUCT_ASSERT(pVc, nvc);

		pConnObject = pVc->pConnObject;

		if (pConnObject != NULL)
		{
			RWAN_ACQUIRE_CONN_LOCK(pConnObject);
			RWanReferenceConnObject(pConnObject);   // temp - ShutdownAf
			RWAN_RELEASE_CONN_LOCK(pConnObject);

			RWAN_RELEASE_AF_LOCK(pAf);

			RWAN_ACQUIRE_CONN_LOCK(pConnObject);
			rc = RWanDereferenceConnObject(pConnObject);    // temp - ShutdownAf

			if (rc != 0)
			{
				RWanDoTdiDisconnect(
					pConnObject,
					NULL,			// pTdiRequest,
					NULL,			// pTimeout
					0,				// Flags
					NULL,			// pDisconnInfo
					NULL			// pReturnInfo
					);
				//
				//  Conn Object lock is released within the above.
				//
			}
			
			RWAN_ACQUIRE_AF_LOCK(pAf);
		}
	}

	//
	//  Tell the Media-specific module to clean up because this AF
	//  is being closed.
	//
	AfSpAFContext = pAf->AfSpAFContext;

	RWAN_RELEASE_AF_LOCK(pAf);

	if (AfSpAFContext != NULL)
	{
		RWAN_ASSERT(pAf->pAfInfo->AfChars.pAfSpCloseAf != NULL);

		RWanStatus = (*pAf->pAfInfo->AfChars.pAfSpCloseAf)(AfSpAFContext);

		if (RWanStatus != RWAN_STATUS_PENDING)
		{
			RWanAfSpCloseAfComplete((RWAN_HANDLE)pAf);
		}
	}
	else
	{
		//
		//  We don't have to inform the media-specific module.
		//
		RWanAfSpCloseAfComplete((RWAN_HANDLE)pAf);
	}


	RWAN_ACQUIRE_AF_LOCK(pAf);

	rc = RWanDereferenceAf(pAf);	// temp ref: RWanShutdownAf

	if (rc != 0)
	{
		RWAN_RELEASE_AF_LOCK(pAf);
	}
	//
	//  else the AF is gone.
	//

	return;
}




VOID
RWanNdisCloseAddressFamilyComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					OurAfContext
	)
/*++

Routine Description:

	This is the NDIS entry point signifying completion of
	a call to NdisClCloseAddressFamily.

Arguments:

	Status			- Final status of the Close AF
	OurAfContext	- Pointer to AF block

Return Value:

	None

--*/
{
	PRWAN_NDIS_AF			pAf;
	INT						rc;

	RWAN_ASSERT(Status == NDIS_STATUS_SUCCESS);

	pAf = (PRWAN_NDIS_AF)OurAfContext;
	RWAN_STRUCT_ASSERT(pAf, naf);

	RWAN_ACQUIRE_AF_LOCK(pAf);

	rc = RWanDereferenceAf(pAf);		// CloseAfComplete

	if (rc != 0)
	{
		RWAN_RELEASE_AF_LOCK(pAf);
	}
	
	return;
}




PNDIS_MEDIUM
RWanGetSupportedMedia(
	OUT	PULONG						pMediaCount
	)
/*++

Routine Description:

	Return a list of NDIS Media types that we support.

Arguments:

	pMediaCount - Place to return the number of media types.

Return Value:

	An allocated and filled list of media types. The caller is responsible
	for freeing this via RWAN_FREE_MEM.

--*/
{
	PNDIS_MEDIUM			pMediaArray;
	UINT					NumMedia;
	UINT					i;

	PLIST_ENTRY				pAfInfoEntry;
	PRWAN_NDIS_AF_INFO		pAfInfo;

	pMediaArray = NULL;

	do
	{
		RWAN_ACQUIRE_GLOBAL_LOCK();

		//
		//  An upper bound on the total number of media types supported
		//  is this:
		//
		NumMedia = pRWanGlobal->AfInfoCount;

		if (NumMedia == 0)
		{
			break;
		}

		RWAN_ALLOC_MEM(pMediaArray, NDIS_MEDIUM, NumMedia * sizeof(NDIS_MEDIUM));

		if (pMediaArray == NULL)
		{
			break;
		}

		NumMedia = 0;

		for (pAfInfoEntry = pRWanGlobal->AfInfoList.Flink;
			 pAfInfoEntry != &(pRWanGlobal->AfInfoList);
			 pAfInfoEntry = pAfInfoEntry->Flink)
		{
			NDIS_MEDIUM		Medium;

			pAfInfo = CONTAINING_RECORD(pAfInfoEntry, RWAN_NDIS_AF_INFO, AfInfoLink);

			Medium = pAfInfo->AfChars.Medium;

			//
			//  Check if this medium type is already in the output list.
			//
			for (i = 0; i < NumMedia; i++)
			{
				if (pMediaArray[i] == Medium)
				{
					break;
				}
			}

			if (i == NumMedia)
			{
				//
				//  This is the first time we've seen this Medium type.
				//  Create a new entry.
				//
				pMediaArray[i] = Medium;
				NumMedia++;
			}
		}

		RWAN_RELEASE_GLOBAL_LOCK();

		if (NumMedia == 0)
		{
			RWAN_FREE_MEM(pMediaArray);
			pMediaArray = NULL;
		}

		break;
	}
	while (FALSE);

	*pMediaCount = NumMedia;

	return (pMediaArray);

}



VOID
RWanCloseAdapter(
	IN	PRWAN_NDIS_ADAPTER			pAdapter
	)
/*++

Routine Description:

	Initiate closing an adapter. The caller is assumed to hold
	the adapter lock, which will be released here.

Arguments:

	pAdapter			- Points to adapter to be closed

Return Value:

	None

--*/
{
	NDIS_HANDLE				NdisAdapterHandle;
	NDIS_STATUS				Status;

	NdisAdapterHandle = pAdapter->NdisAdapterHandle;

	RWAN_ASSERT(NdisAdapterHandle != NULL);
	RWAN_ASSERT(RWAN_IS_LIST_EMPTY(&(pAdapter->AfList)));

	pAdapter->State = RWANS_AD_CLOSING;

	RWAN_RELEASE_ADAPTER_LOCK(pAdapter);

	NdisCloseAdapter(
			&Status,
			NdisAdapterHandle
			);

	if (Status != NDIS_STATUS_PENDING)
	{
		RWanNdisCloseAdapterComplete(
			(NDIS_HANDLE)pAdapter,
			Status
			);
	}
}



VOID
RWanNdisRequestComplete(
	IN	NDIS_HANDLE					OurBindingContext,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_STATUS					Status
	)
/*++

Routine Description:

	This is the NDIS entry point called when a previous pended call
	to NdisRequest() has completed. We would have called NdisRequest
	on behalf of the media-specific module. Complete it now.

Arguments:

	OurBindingContext	- Points to our adapter structure
	pNdisRequest		- Points to completed request
	Status				- Final status of the request

Return Value:

	None

--*/
{
	PRWAN_NDIS_ADAPTER			pAdapter;
	PRWAN_NDIS_REQ_CONTEXT		pReqContext;

	pAdapter = (PRWAN_NDIS_ADAPTER)OurBindingContext;
	RWAN_STRUCT_ASSERT(pAdapter, nad);

	pReqContext = (PRWAN_NDIS_REQ_CONTEXT)((PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST));

	if (pNdisRequest->RequestType == NdisRequestQueryInformation)
	{
		(*pReqContext->pAf->pAfInfo->AfChars.pAfSpAdapterRequestComplete)(
				Status,
				pReqContext->pAf->AfSpAFContext,
				pReqContext->AfSpReqContext,
				pNdisRequest->RequestType,
				pNdisRequest->DATA.QUERY_INFORMATION.Oid,
				pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
				pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength
				);
	}
	else
	{
		(*pReqContext->pAf->pAfInfo->AfChars.pAfSpAdapterRequestComplete)(
				Status,
				pReqContext->pAf->AfSpAFContext,
				pReqContext->AfSpReqContext,
				pNdisRequest->RequestType,
				pNdisRequest->DATA.SET_INFORMATION.Oid,
				pNdisRequest->DATA.SET_INFORMATION.InformationBuffer,
				pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength
				);
	}

	RWAN_FREE_MEM(pNdisRequest);

	return;
}



VOID
RWanNdisStatus(
	IN	NDIS_HANDLE					OurBindingContext,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						StatusBuffer,
	IN	UINT						StatusBufferSize
	)
/*++

Routine Description:

Arguments:


Return Value:

	None

--*/
{
	//
	//  Ignore this.
	//
	return;
}




VOID
RWanNdisCoStatus(
	IN	NDIS_HANDLE					OurBindingContext,
	IN	NDIS_HANDLE					OurVcContext OPTIONAL,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						StatusBuffer,
	IN	UINT						StatusBufferSize
	)
/*++

Routine Description:

Arguments:


Return Value:

	None

--*/
{
	//
	//  Ignore this.
	//
	return;
}




VOID
RWanNdisStatusComplete(
	IN	NDIS_HANDLE					OurBindingContext
	)
/*++

Routine Description:

Arguments:


Return Value:

	None

--*/
{
	//
	//  Ignore this.
	//
	return;
}




NDIS_STATUS
RWanNdisCoRequest(
	IN	NDIS_HANDLE					OurAfContext,
	IN	NDIS_HANDLE					OurVcContext OPTIONAL,
	IN	NDIS_HANDLE					OurPartyContext OPTIONAL,
	IN OUT PNDIS_REQUEST			pNdisRequest
	)
/*++

Routine Description:

	Handle events from the Call Manager.

Arguments:

	OurAfContext		- Points to our AF structure
	OurVcContext		- If not NULL, points to our VC structure
	OurPartyContext		- If not NULL, points to our Party structure
	pNdisRequest		- Points to request

Return Value:

	NDIS_STATUS_SUCCESS if the OID is one that we know about, else
	NDIS_STATUS_NOT_RECOGNIZED.

--*/
{
	NDIS_STATUS			Status;
	PRWAN_NDIS_AF		pAf;

	Status = NDIS_STATUS_SUCCESS;

	if (pNdisRequest->RequestType == NdisRequestSetInformation)
	{
		switch (pNdisRequest->DATA.SET_INFORMATION.Oid)
		{
			case OID_CO_ADDRESS_CHANGE:

				break;

			case OID_CO_AF_CLOSE:
				//
				//  The Call manager wants us to shutdown this AF open.
				//
				pAf = (PRWAN_NDIS_AF)OurAfContext;
				RWAN_STRUCT_ASSERT(pAf, naf);

				RWanShutdownAf(pAf);

				break;
				
			default:

				Status = NDIS_STATUS_NOT_RECOGNIZED;
				break;
		}
	}

	return (Status);
}




VOID
RWanNdisCoRequestComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					OurAfContext,
	IN	NDIS_HANDLE					OurVcContext OPTIONAL,
	IN	NDIS_HANDLE					OurPartyContext OPTIONAL,
	IN	PNDIS_REQUEST				pNdisRequest
	)
/*++

Routine Description:

	Handle completion of a CO-request we had sent to the Call Manager on
	behalf of a media-specific module. Inform the media-specific module
	of this completion.

Arguments:

	Status				- Status of request.
	OurAfContext		- Points to our AF structure
	OurVcContext		- If not NULL, points to our VC structure
	OurPartyContext		- If not NULL, points to our Party structure
	pNdisRequest		- Points to request

Return Value:

	None

--*/
{
	PRWAN_NDIS_AF				pAf;
	PRWAN_NDIS_REQ_CONTEXT		pReqContext;

	pAf = (PRWAN_NDIS_AF)OurAfContext;
	RWAN_STRUCT_ASSERT(pAf, naf);

	pReqContext = (PRWAN_NDIS_REQ_CONTEXT)((PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST));

	if (pNdisRequest->RequestType == NdisRequestQueryInformation)
	{
		(*pReqContext->pAf->pAfInfo->AfChars.pAfSpAfRequestComplete)(
				Status,
				pReqContext->pAf->AfSpAFContext,
				pReqContext->AfSpReqContext,
				pNdisRequest->RequestType,
				pNdisRequest->DATA.QUERY_INFORMATION.Oid,
				pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
				pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength
				);
	}
	else
	{
		(*pReqContext->pAf->pAfInfo->AfChars.pAfSpAfRequestComplete)(
				Status,
				pReqContext->pAf->AfSpAFContext,
				pReqContext->AfSpReqContext,
				pNdisRequest->RequestType,
				pNdisRequest->DATA.SET_INFORMATION.Oid,
				pNdisRequest->DATA.SET_INFORMATION.InformationBuffer,
				pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength
				);
	}

	RWAN_FREE_MEM(pNdisRequest);

	return;
}



NDIS_STATUS
RWanNdisReset(
	IN	NDIS_HANDLE					OurBindingContext
	)
/*++

Routine Description:

Arguments:


Return Value:

	None

--*/
{
	//
	//  Ignore this.
	//
	return (NDIS_STATUS_SUCCESS);
}




VOID
RWanNdisResetComplete(
	IN	NDIS_HANDLE					OurBindingContext,
	IN	NDIS_STATUS					Status
	)
/*++

Routine Description:

Arguments:


Return Value:

	None

--*/
{
	//
	//  Ignore this.
	//
	return;
}



NDIS_STATUS
RWanNdisPnPEvent(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNET_PNP_EVENT				pNetPnPEvent
	)
/*++

Routine Description:

	Handle a PnP Event from NDIS. The event structure contains the event
	code, includes power-management events and reconfigure events.

Arguments:

	ProtocolBindingContext	- Pointer to our Adapter structure. Could be
							  NULL for notification of global config changes
	pNetPnPEvent			- Points to event structure

Return Value:

	NDIS_STATUS_SUCCESS if we processed the event successfully.
	NDIS_STATUS_NOT_SUPPORTED for unsupported notifications.

--*/
{
	NDIS_STATUS				Status;
	PRWAN_NDIS_ADAPTER		pAdapter;

	pAdapter = (PRWAN_NDIS_ADAPTER)ProtocolBindingContext;

	switch (pNetPnPEvent->NetEvent)
	{
		case NetEventSetPower:

			Status = RWanNdisPnPSetPower(pAdapter, pNetPnPEvent);
			break;
		
		case NetEventQueryPower:

			Status = RWanNdisPnPQueryPower(pAdapter, pNetPnPEvent);
			break;
		
		case NetEventQueryRemoveDevice:

			Status = RWanNdisPnPQueryRemove(pAdapter, pNetPnPEvent);
			break;
		
		case NetEventCancelRemoveDevice:

			Status = RWanNdisPnPCancelRemove(pAdapter, pNetPnPEvent);
			break;
		
		case NetEventReconfigure:

			Status = NDIS_STATUS_NOT_SUPPORTED;
			break;
		
		case NetEventBindList:

			Status = NDIS_STATUS_NOT_SUPPORTED;
			break;
		
		default:

			Status = NDIS_STATUS_NOT_SUPPORTED;
			break;
	}

	return (Status);
}


NDIS_STATUS
RWanNdisPnPSetPower(
	IN	PRWAN_NDIS_ADAPTER			pAdapter,
	IN	PNET_PNP_EVENT				pNetPnPEvent
	)
/*++

Routine Description:

	Handle a Set Power event.

Arguments:

	pAdapter		- Points to our adapter structure
	pNetPnPEvent	- Points to event to be processed.

Return Value:

	NDIS_STATUS_SUCCESS if we successfully processed this event,
	NDIS_STATUS_XXX error code otherwise.

--*/
{
	PNET_DEVICE_POWER_STATE		pPowerState;
	NDIS_STATUS					Status;

	pPowerState = (PNET_DEVICE_POWER_STATE)pNetPnPEvent->Buffer;
	
	switch (*pPowerState)
	{
		case NetDeviceStateD0:

			Status = NDIS_STATUS_SUCCESS;
			break;

		default:
			
			//
			//  We can't suspend, so we ask NDIS to unbind us
			//  by returning this status:
			//
			Status = NDIS_STATUS_NOT_SUPPORTED;
			break;
	}

	return (Status);
}


NDIS_STATUS
RWanNdisPnPQueryPower(
	IN	PRWAN_NDIS_ADAPTER			pAdapter,
	IN	PNET_PNP_EVENT				pNetPnPEvent
	)
/*++

Routine Description:

	Called to see if we allow power to be shut off to the adapter.

Arguments:

	pAdapter		- Points to our adapter structure
	pNetPnPEvent	- Points to event to be processed.

Return Value:

	NDIS_STATUS_SUCCESS always.

--*/
{
	return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
RWanNdisPnPQueryRemove(
	IN	PRWAN_NDIS_ADAPTER			pAdapter,
	IN	PNET_PNP_EVENT				pNetPnPEvent
	)
/*++

Routine Description:

	Called to see if we allow the adapter to be removed.

Arguments:

	pAdapter		- Points to our adapter structure
	pNetPnPEvent	- Points to event to be processed.

Return Value:

	NDIS_STATUS_SUCCESS always.

--*/
{
	return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
RWanNdisPnPCancelRemove(
	IN	PRWAN_NDIS_ADAPTER			pAdapter,
	IN	PNET_PNP_EVENT				pNetPnPEvent
)
/*++

Routine Description:

	Called to cancel the above remove.

Arguments:

	pAdapter		- Points to our adapter structure
	pNetPnPEvent	- Points to event to be processed.

Return Value:

	NDIS_STATUS_SUCCESS always.

--*/
{
	return (NDIS_STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\precomp.h ===
#include <ndis.h>

#include <tdikrnl.h>
#include <tdistat.h>

#include "system.h"

#include "debug.h"

#include "rwanpub.h"
#include "rwandata.h"
#ifdef NT
#include "rwannt.h"
#include "rwanuser.h"
#endif // NT
#include "config.h"
#include "macros.h"
#include "externs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\ndisconn.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\ndisconn.c

Abstract:

	NDIS Entry points and support routines for Connection setup and
	release.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     05-06-97    Created

Notes:

	Code under ifndef NO_POST_DISCON: Nov 17, 98
		Added code to send a TDI DisconInd to AFD before completing
		a TDI Disconnect Request that AFD had sent to us. Without this,
		if an app calls shutdown(SD_SEND) -> TDI Disconnect Request,
		a subsequent call by the app to recv() blocks forever, because
		AFD expects the TDI transport to send up a TDI DisconInd!

--*/

#include <precomp.h>

#define _FILENUMBER 'NCDN'



NDIS_STATUS
RWanNdisCreateVc(
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisVcHandle,
	OUT	PNDIS_HANDLE				pProtocolVcContext
	)
/*++

Routine Description:

	This is the NDIS entry point for creating a new endpoint (VC).
	We allocate a new NDIS_VC structure and return a pointer to it
	as our context for the VC.

Arguments:

	ProtocolAfContext	- Pointer to our NDIS AF block
	NdisVcHandle		- Handle for the newly created VC
	pProtocolVcContext	- Place where we return our context for the VC

Return Value:

	NDIS_STATUS_SUCCESS if we could allocate a VC,
	NDIS_STATUS_RESOURCES otherwise.

--*/
{
	PRWAN_NDIS_AF			pAf;
	PRWAN_NDIS_VC			pVc;
	NDIS_STATUS				Status;

	pAf = (PRWAN_NDIS_AF)ProtocolAfContext;

	RWAN_STRUCT_ASSERT(pAf, naf);

	do
	{
		pVc = RWanAllocateVc(pAf, FALSE);

		if (pVc == NULL_PRWAN_NDIS_VC)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		pVc->NdisVcHandle = NdisVcHandle;

		RWANDEBUGP(DL_EXTRA_LOUD, DC_CONNECT,
				("CreateVc: pVc x%x, pAf x%x\n", pVc, pAf));

		Status = NDIS_STATUS_SUCCESS;
		break;
	}
	while (FALSE);

	*pProtocolVcContext = (NDIS_HANDLE)pVc;

	return (Status);
}




NDIS_STATUS
RWanNdisDeleteVc(
	IN	NDIS_HANDLE					ProtocolVcContext
	)
/*++

Routine Description:

	This entry point is called by NDIS to delete a VC context
	used for an incoming call. At this time, there should be
	no call on the VC. All we need to do is unlink the VC from
	the list it belongs to, and free it.

Arguments:

	ProtocolVcContext		- Points to our VC context.

Return Value:

	NDIS_STATUS_SUCCESS always.

--*/
{
	PRWAN_NDIS_VC			pVc;

	pVc = (PRWAN_NDIS_VC)ProtocolVcContext;
	RWAN_STRUCT_ASSERT(pVc, nvc);

	RWAN_ASSERT(pVc->pConnObject == NULL_PRWAN_TDI_CONNECTION);

	RWANDEBUGP(DL_EXTRA_LOUD, DC_DISCON,
			("DeleteVc: pVc x%x, pAf x%x\n", pVc, pVc->pNdisAf));

	//
	//  Unlink the VC from the list of VCs on the AF block
	//
	RWanUnlinkVcFromAf(pVc);

	RWanFreeVc(pVc);

	return (NDIS_STATUS_SUCCESS);
}




VOID
RWanNdisMakeCallComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					NdisPartyHandle		OPTIONAL,
	IN	PCO_CALL_PARAMETERS			pCallParameters
	)
/*++

Routine Description:

	This is the NDIS entry point that is called when a previous
	call we made to NdisClMakeCall has completed.

	We locate the TDI Connection Object for this call. If the
	user hasn't aborted the Connect/JoinLeaf, we complete the
	pended request. Otherwise, we initiate a CloseCall.

	This primitive can happen only when the endpoint is in
	the "Out call initiated" state.

Arguments:

	Status				- Final status of the MakeCall
	ProtocolVcContext	- Actually a pointer to our NDIS VC structure
	NdisPartyHandle		- If this is a PMP call, this is the handle to the
						  first party
	pCallParameters		- Final call parameters.

Return Value:

	None

--*/
{
	PRWAN_TDI_CONNECTION	pRootConnObject;
	PRWAN_TDI_CONNECTION	pConnObject;
	PRWAN_TDI_ADDRESS		pAddrObject;
	NDIS_HANDLE				NdisVcHandle;
	TDI_STATUS				TdiStatus;
	PRWAN_CONN_REQUEST		pConnReq;		// Saved context about the TdiConnect
	BOOLEAN					bIsConnClosing;	// Have we seen a TdiCloseConnection?
	PRWAN_NDIS_AF			pAf;
	PRWAN_NDIS_VC			pVc;
	PRWAN_NDIS_PARTY		pParty;
	PCO_CALL_PARAMETERS		pOriginalParams;// What we used in the MakeCall
	RWAN_HANDLE				AfSpConnContext;
#if DBG
	RWAN_IRQL				EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	pVc = (PRWAN_NDIS_VC)ProtocolVcContext;

	RWAN_STRUCT_ASSERT(pVc, nvc);

	//
	//  Check if this is a point-to-multipoint call.
	//
	if (!RWAN_IS_BIT_SET(pVc->Flags, RWANF_VC_PMP))
	{
		//
		//  Point-to-point call.
		//
		pConnObject = pVc->pConnObject;
		pRootConnObject = pConnObject; // for consistency.
		pParty = NULL;
		pOriginalParams = pVc->pCallParameters;
	}
	else
	{
		//
		//  PMP Call. Get at the Party structure.
		//
		pParty = pVc->pPartyMakeCall;
		RWAN_STRUCT_ASSERT(pParty, npy);

		pConnObject = pParty->pConnObject;
		pRootConnObject = pVc->pConnObject;
		pOriginalParams = pParty->pCallParameters;
	}

	RWAN_ASSERT(pOriginalParams != NULL);

	pAf = pVc->pNdisAf;

	RWANDEBUGP(DL_LOUD, DC_CONNECT,
			("MakeCallComplete: pConn x%x, State/Flags/Ref x%x/x%x/%d, pAddr %x, pVc x%x, Status x%x\n",
				pConnObject, pConnObject->State, pConnObject->Flags, pConnObject->RefCount, pConnObject->pAddrObject, pVc, Status));

	RWAN_ACQUIRE_CONN_LOCK(pConnObject);

	RWAN_ASSERT(pConnObject->State == RWANS_CO_OUT_CALL_INITIATED ||
				pConnObject->State == RWANS_CO_DISCON_REQUESTED);

	//
	//  Has the user initiated a TdiCloseConnection() or a TdiDisconnect()
	//  while this outgoing call was in progress?
	//
	bIsConnClosing = RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING) ||
						(pConnObject->State == RWANS_CO_DISCON_REQUESTED);

	//
	//  We would have saved context about the TdiConnect(). Get it.
	//
	pConnReq = pConnObject->pConnReq;
	pConnObject->pConnReq = NULL;


	if (pParty)
	{
		pVc->AddingPartyCount --;
		pParty->pCallParameters = NULL;
		pParty->NdisPartyHandle = NdisPartyHandle;
	}
	else
	{
		pVc->pCallParameters = NULL;
	}

	if (Status == NDIS_STATUS_SUCCESS)
	{
		RWAN_SET_VC_EVENT(pVc, RWANF_VC_EVT_MAKECALL_OK);

		if (!bIsConnClosing)
		{
			//
			//  Outgoing connection successfully set up.
			//

			pConnObject->State = RWANS_CO_CONNECTED;

			//
			//  Update PMP information.
			//
			if (pParty)
			{
				pVc->ActivePartyCount ++;	// MakeCall PMP complete
				pRootConnObject->State = RWANS_CO_CONNECTED;
			}

			AfSpConnContext = pConnObject->AfSpConnContext;

			RWAN_RELEASE_CONN_LOCK(pConnObject);

			RWanCompleteConnReq(		// MakeCall OK
						pAf,
						pConnReq,
						TRUE,
						pCallParameters,
						AfSpConnContext,
						TDI_SUCCESS
						);
		}
		else
		{
			//
			//  Abort this call.
			//
			pConnObject->State = RWANS_CO_ABORTING;

			RWanStartCloseCall(pConnObject, pVc);
		}
		RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
	}
	else
	{
		//
		//  MakeCall failed.
		//

		INT				rc;

		//
		//  XXX TBD : how about trying this call on another NDIS AF?
		//

		RWAN_SET_VC_EVENT(pVc, RWANF_VC_EVT_MAKECALL_FAIL);

		if (pParty == NULL)
		{
			//
			//  Point-to-Point call.
			//

			//
			//  Unlink the NDIS VC from this Conn Object.
			//
			RWAN_UNLINK_CONNECTION_AND_VC(pConnObject, pVc);	// MakeCall fail

		}
		else
		{
			//
			//  PMP Call. The VC would be attached to the Root
			//  Connection Object. Unlink the VC and the Root Connection.
			//
			RWAN_ACQUIRE_CONN_LOCK(pRootConnObject);

			RWAN_UNLINK_CONNECTION_AND_VC(pRootConnObject, pVc);	// MakeCallPMP fail

			rc = RWanDereferenceConnObject(pRootConnObject);	// VC deref: MakeCallPMP fail

			if (rc > 0)
			{
				RWAN_RELEASE_CONN_LOCK(pRootConnObject);
			}

			//
			//  Unlink the Party from the Connection and VC.
			//
			RWAN_DELETE_FROM_LIST(&(pParty->PartyLink));
			pParty->pVc = NULL;

			pParty->pConnObject = NULL;
			pConnObject->NdisConnection.pNdisParty = NULL;
		}

		rc = RWanDereferenceConnObject(pConnObject);	// VC/Pty deref: MakeCall fail

		//
		//  Continue with the Connection Object for this MakeCall,
		//  if it is still alive.
		//
		if (rc > 0)
		{
			if (pConnObject->pAddrObject != NULL)
			{
				//
				//  Move the Connection Object to the Idle list.
				//

				pAddrObject = pConnObject->pAddrObject;

				//
				//  Reacquire some locks in the right order.
				//
				RWAN_RELEASE_CONN_LOCK(pConnObject);

				RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);
				RWAN_ACQUIRE_CONN_LOCK_DPC(pConnObject);

				//
				//  Move this Connection to the Idle list.
				//
				RWAN_DELETE_FROM_LIST(&(pConnObject->ConnLink));
				RWAN_INSERT_TAIL_LIST(&(pAddrObject->IdleConnList),
 									&(pConnObject->ConnLink));

				//
				//  Send this back to the state it was in before the TdiConnect.
				//
				pConnObject->State = RWANS_CO_ASSOCIATED;

				AfSpConnContext = pConnObject->AfSpConnContext;

				RWAN_RELEASE_CONN_LOCK_DPC(pConnObject);

				RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

				//
				//  Complete the TdiConnect() with a failure status.
				//
				TdiStatus = RWanNdisToTdiStatus(Status);

				if (TdiStatus == TDI_NOT_ACCEPTED)
				{
					TdiStatus = TDI_CONN_REFUSED;
				}

				RWanCompleteConnReq(		// MakeCall Fail
						pAf,
						pConnReq,
						TRUE,
						NULL,
						AfSpConnContext,
						TdiStatus
						);
			}
			else
			{
				RWAN_RELEASE_CONN_LOCK(pConnObject);
			}
		}
		//
		//  else the Conn Object is gone. A TdiCloseConnection might be
		//  (must be?) in progress.
		//
#if 1
		// XXX: Remove this after debugging.
		pVc = (PRWAN_NDIS_VC)ProtocolVcContext;

		RWAN_STRUCT_ASSERT(pVc, nvc);
#endif // 1

		NdisVcHandle = pVc->NdisVcHandle;

		//
		//  Unlink the VC from the AF it is attached to.
		//
		RWanUnlinkVcFromAf(pVc);

		//
		//  Get rid of the VC.
		//
		Status = NdisCoDeleteVc(NdisVcHandle);
		RWAN_ASSERT(Status == NDIS_STATUS_SUCCESS);

		RWanFreeVc(pVc);	// MakeCall complete fail

		if (pParty != NULL)
		{
			RWAN_FREE_MEM(pParty);	// MakeCall complete fail
		}

		RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
	}

	//
	//  Return the Call Parameters structure to the AF-specific module.
	//
	(*pAf->pAfInfo->AfChars.pAfSpReturnNdisOptions)(
						pAf->AfSpAFContext,
						pOriginalParams
						);
	return;

}



VOID
RWanNdisAddPartyComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	NDIS_HANDLE					NdisPartyHandle,
	IN	PCO_CALL_PARAMETERS			pCallParameters
	)
/*++

Routine Description:

	This is the NDIS entry indicating completion of a call to NdisClAddParty
	that had pended.

Arguments:

	Status				- Final status of the AddParty
	ProtocolPartyContext- Actually a pointer to our NDIS PARTY structure
	NdisPartyHandle		- If the AddParty was successful, an NDIS handle for it
	pCallParameters		- Final parameters after the AddParty

Return Value:

	None

--*/
{
	PRWAN_NDIS_PARTY		pParty;
	PRWAN_TDI_CONNECTION	pConnObject;
	PRWAN_TDI_ADDRESS		pAddrObject;
	PRWAN_CONN_REQUEST		pConnReq;
	PRWAN_NDIS_AF			pAf;
	PRWAN_NDIS_VC			pVc;
	PCO_CALL_PARAMETERS		pOriginalParams;	// what was used in the AddParty
	TDI_STATUS				TdiStatus;
	BOOLEAN					bIsConnClosing;
	RWAN_HANDLE				AfSpConnContext;
#if DBG
	RWAN_IRQL				EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	pParty = (PRWAN_NDIS_PARTY)ProtocolPartyContext;
	RWAN_STRUCT_ASSERT(pParty, npy);

	pVc = pParty->pVc;
	RWAN_STRUCT_ASSERT(pVc, nvc);

	pAf = pVc->pNdisAf;
	pConnObject = pParty->pConnObject;

	RWAN_ACQUIRE_CONN_LOCK(pConnObject);

	pOriginalParams = pParty->pCallParameters;
	RWAN_ASSERT(pOriginalParams != NULL);

	pParty->pCallParameters = NULL;

	RWAN_ASSERT(pConnObject->State == RWANS_CO_OUT_CALL_INITIATED ||
				pConnObject->State == RWANS_CO_DISCON_REQUESTED);

	//
	//  Has the user initiated a TdiCloseConnection() or a TdiDisconnect()
	//  while this outgoing call was in progress?
	//
	bIsConnClosing = RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING) ||
						(pConnObject->State == RWANS_CO_DISCON_REQUESTED);

	RWANDEBUGP(DL_LOUD, DC_CONNECT,
			("AddPartyComplete: pConn x%x, State/Flags x%x/x%x, pVc x%x, Pty x%x, Status x%x\n",
				pConnObject, pConnObject->State, pConnObject->Flags, pVc, pParty, Status));

	//
	//  We would have saved context about the TdiConnect(). Get it.
	//
	pConnReq = pConnObject->pConnReq;
	pConnObject->pConnReq = NULL;

	pVc->AddingPartyCount --;

	if (Status == NDIS_STATUS_SUCCESS)
	{
		pParty->NdisPartyHandle = NdisPartyHandle;

		pConnObject->State = RWANS_CO_CONNECTED;

		//
		//  Outgoing party successfully set up.
		//
		pVc->ActivePartyCount ++;	// AddParty OK

		if (!bIsConnClosing)
		{
			AfSpConnContext = pConnObject->AfSpConnContext;

			RWAN_RELEASE_CONN_LOCK(pConnObject);

			RWanCompleteConnReq(		// AddParty OK
						pAf,
						pConnReq,
						TRUE,
						pCallParameters,
						AfSpConnContext,
						TDI_SUCCESS
						);
		}
		else
		{
			//
			//  Abort this Party.
			//
			RWanDoTdiDisconnect(
				pConnObject,
				NULL,		// pTdiRequest
				NULL,		// pTimeout
				0,			// Flags
				NULL,		// pDisconnInfo
				NULL		// pReturnInfo
				);

			//
			//  Conn Object lock is released above.
			//
		}

		RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
	}
	else
	{
		//
		//  AddParty failed.
		//

		INT				rc;

		//
		//  Unlink the Party from the VC.
		//
		RWAN_DELETE_FROM_LIST(&(pParty->PartyLink));

		pAddrObject = pConnObject->pAddrObject;

		rc = RWanDereferenceConnObject(pConnObject);	// Party deref: AddParty fail

		if (rc > 0)
		{
			//
			//  Reacquire some locks in the right order.
			//
			RWAN_RELEASE_CONN_LOCK(pConnObject);

			RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);
			RWAN_ACQUIRE_CONN_LOCK_DPC(pConnObject);

			//
			//  Move this Connection to the Idle list.
			//
			RWAN_DELETE_FROM_LIST(&(pConnObject->ConnLink));
			RWAN_INSERT_TAIL_LIST(&(pAddrObject->IdleConnList),
 								  &(pConnObject->ConnLink));

			//
			//  Send this back to the state it was in before the TdiConnect.
			//
			pConnObject->State = RWANS_CO_ASSOCIATED;

			AfSpConnContext = pConnObject->AfSpConnContext;

			RWAN_RELEASE_CONN_LOCK_DPC(pConnObject);

			RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

			//
			//  Complete the TdiConnect() with a failure status.
			//
			TdiStatus = RWanNdisToTdiStatus(Status);

			if (TdiStatus == TDI_NOT_ACCEPTED)
			{
				TdiStatus = TDI_CONN_REFUSED;
			}

			RWanCompleteConnReq(		// JoinLeaf Fail
				pAf,
				pConnReq,
				TRUE,
				NULL,
				AfSpConnContext,
				TdiStatus
				);
		}
		//
		//  else the ConnObject is gone.
		//

		RWAN_FREE_MEM(pParty);	// AddParty fail

		RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
	}

	//
	//  Return the Call Parameters structure to the AF-specific module.
	//
	(*pAf->pAfInfo->AfChars.pAfSpReturnNdisOptions)(
						pAf->AfSpAFContext,
						pOriginalParams
						);
	return;

}




NDIS_STATUS
RWanNdisIncomingCall(
	IN		NDIS_HANDLE				ProtocolSapContext,
	IN		NDIS_HANDLE				ProtocolVcContext,
	IN OUT	PCO_CALL_PARAMETERS		pCallParameters
	)
/*++

Routine Description:

	This is the NDIS entry point announcing a new Incoming call request,
	on the specified SAP.

	The SAP corresponds to an Address Object. If there are no Listens posted
	on the Address object, we reject this call. Otherwise, we pick up an
	arbitrary listening connection object and indicate this call on that.

	TBD: support selection of listening conn object based on specified
	remote criteria.

Arguments:

	ProtocolSapContext	- Our SAP context is a pointer to an NDIS SAP structure
	ProtocolVcContext	- Actually a pointer to our NDIS VC structure
	pCallParameters		- Points to Incoming call parameters.

Return Value:

	None

--*/
{
	PRWAN_NDIS_SAP				pSap;
	PRWAN_NDIS_VC				pVc;
	PRWAN_NDIS_AF				pAf;
	PRWAN_TDI_ADDRESS			pAddrObject;
	BOOLEAN						IsAddrLockAcquired;
	PRWAN_TDI_CONNECTION		pConnObject;
	PLIST_ENTRY					pConnEntry;
	NDIS_STATUS					Status;
	TDI_STATUS					TdiStatus;
	RWAN_STATUS					RWanStatus;
	PRWAN_CONN_REQUEST			pConnReq;

	PConnectEvent				pConnInd;
	PTDI_CONNECTION_INFORMATION	pTdiInfo;
	RWAN_HANDLE					AfSpTdiOptionsContext;
	PVOID						pTdiQoS;
	ULONG						TdiQoSLength;

	PVOID						ConnIndContext;
	PVOID						AcceptConnContext;
	RWAN_HANDLE					AfSpConnContext;
#ifdef NT
	PIO_STACK_LOCATION			pIrpSp;
	PTDI_REQUEST_KERNEL_ACCEPT	pAcceptReq;
	ConnectEventInfo			*EventInfo;
#else
	ConnectEventInfo			EventInfo;
#endif // NT


	pSap = (PRWAN_NDIS_SAP)ProtocolSapContext;
	RWAN_STRUCT_ASSERT(pSap, nsp);

	pAddrObject = pSap->pAddrObject;
	RWAN_ASSERT(pAddrObject != NULL);

	pVc = (PRWAN_NDIS_VC)ProtocolVcContext;
	RWAN_STRUCT_ASSERT(pVc, nvc);

	RWAN_SET_VC_EVENT(pVc, RWANF_VC_EVT_INCALL);

	pAf = pVc->pNdisAf;

	RWANDEBUGP(DL_INFO, DC_CONNECT,
			("IncomingCall: pVc x%x, pAddrObj x%x/x%x, pConnInd x%x\n",
				pVc, pAddrObject, pAddrObject->Flags, pAddrObject->pConnInd));

	//
	//  Initialize.
	//
	pTdiInfo = NULL;
	AfSpTdiOptionsContext = NULL;
	pConnReq = NULL;

	IsAddrLockAcquired = TRUE;
	RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

	do
	{
		if (RWAN_IS_BIT_SET(pAddrObject->Flags, RWANF_AO_CLOSING))
		{
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		if (pVc->pConnObject != NULL)
		{
			RWAN_ASSERT(FALSE);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Convert from NDIS Call Parameters to TDI Options.
		//
		RWanStatus = (*pAf->pAfInfo->AfChars.pAfSpNdis2TdiOptions)(
							pAf->AfSpAFContext,
							RWAN_CALLF_INCOMING_CALL|RWAN_CALLF_POINT_TO_POINT,
							pCallParameters,
							&pTdiInfo,
							&pTdiQoS,
							&TdiQoSLength,
							&AfSpTdiOptionsContext
							);
					
		if (RWanStatus != RWAN_STATUS_SUCCESS)
		{
			RWANDEBUGP(DL_LOUD, DC_CONNECT,
					("IncomingCall: conversion from NDIS to TDI failed, status x%x\n",
							RWanStatus));

			Status = NDIS_STATUS_FAILURE;
			break;
		}

		RWAN_ASSERT(pTdiInfo != NULL);
		RWAN_ASSERT(AfSpTdiOptionsContext != NULL);

		//
		//  It has been decided to pass QOS and any provider-specific info
		//  as part of TDI options.
		//
		pTdiInfo->Options = pTdiQoS;
		pTdiInfo->OptionsLength = TdiQoSLength;

		pVc->pCallParameters = pCallParameters;
		RWAN_SET_VC_CALL_PARAMS(pVc, pCallParameters);

		//
		//  Find a listening connection.
		//
		for (pConnEntry = pAddrObject->ListenConnList.Flink;
			 pConnEntry != &pAddrObject->ListenConnList;
			 pConnEntry = pConnEntry->Flink)
		{
			pConnObject = CONTAINING_RECORD(pConnEntry, RWAN_TDI_CONNECTION, ConnLink);
			RWAN_STRUCT_ASSERT(pConnObject, ntc);

			RWANDEBUGP(DL_EXTRA_LOUD, DC_CONNECT,
					("Incoming Call: looking at pConnObj x%x, state %d\n",
						pConnObject, pConnObject->State));

			if (pConnObject->State == RWANS_CO_LISTENING)
			{
				break;
			}
		}

		if (pConnEntry != &pAddrObject->ListenConnList)
		{
			//
			//  Found a listening connection.
			//
			RWAN_ACQUIRE_CONN_LOCK_DPC(pConnObject);

			//
			//  Move the Connection from the Idle list to the Active list.
			//
			RWAN_DELETE_FROM_LIST(&pConnObject->ConnLink);
			RWAN_INSERT_TAIL_LIST(&pAddrObject->ActiveConnList,
 								&pConnObject->ConnLink);

			RWAN_LINK_CONNECTION_TO_VC(pConnObject, pVc);

			RWanReferenceConnObject(pConnObject);	// VC ref - InCall, Listening conn

			RWANDEBUGP(DL_LOUD, DC_CONNECT,
					("IncomingCall: pVc x%x, pConnObj x%x is listening, ConnReqFlags x%x\n",
							pVc, pConnObject, pConnObject->pConnReq->Flags));

			if (pConnObject->pConnReq->pConnInfo)
			{
				*pConnObject->pConnReq->pConnInfo = *pTdiInfo;
			}

			//
			//  Check if it is pre-accepted. If so, tell NDIS that we have
			//  accepted the call.
			//
			if (!(pConnObject->pConnReq->Flags & TDI_QUERY_ACCEPT))
			{
				pConnObject->State = RWANS_CO_IN_CALL_ACCEPTING;

				RWAN_RELEASE_CONN_LOCK_DPC(pConnObject);

				//
				//  Request the media-specific module to update NDIS call parameters.
				//
				if (pAf->pAfInfo->AfChars.pAfSpUpdateNdisOptions)
				{
					(VOID)(*pAf->pAfInfo->AfChars.pAfSpUpdateNdisOptions)(
								pAf->AfSpAFContext,
								pConnObject->AfSpConnContext,
								RWAN_CALLF_INCOMING_CALL|RWAN_CALLF_POINT_TO_POINT,
								pTdiInfo,
								pTdiQoS,
								TdiQoSLength,
								&pCallParameters
								);
				}

				Status = NDIS_STATUS_SUCCESS;
				break;
			}

			//
			//  It isn't pre-accepted. Complete the pended listen.
			//

			pConnReq = pConnObject->pConnReq;
			pConnObject->pConnReq = NULL;

			pConnObject->State = RWANS_CO_IN_CALL_INDICATED;

			AfSpConnContext = pConnObject->AfSpConnContext;

			RWAN_RELEASE_CONN_LOCK_DPC(pConnObject);

			RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

			IsAddrLockAcquired = FALSE;

			RWanCompleteConnReq(		// InCall: Listen OK
						pSap->pNdisAf,
						pConnReq,
						FALSE,
						NULL,
						AfSpConnContext,
						TDI_SUCCESS
						);

			pConnReq = NULL;

			Status = NDIS_STATUS_PENDING;
			break;
		}


		//
		//  There wasn't a listening connection available.
		//  See if there is a Connect Indication event handler on this
		//  Address Object.
		//
		if (pAddrObject->pConnInd == NULL)
		{
			//
			//  No event handler. Reject this call.
			//
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Get some resources.
		//
		pConnReq = RWanAllocateConnReq();
		if (pConnReq == NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		pConnInd = pAddrObject->pConnInd;
		ConnIndContext = pAddrObject->ConnIndContext;

		RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);
		IsAddrLockAcquired = FALSE;

		RWANDEBUGP(DL_VERY_LOUD, DC_CONNECT,
				("IncomingCall: Will Indicate: pVc x%x, RemAddr x%x/%d, Options x%x/%d\n",
					pVc,
					pTdiInfo->RemoteAddress,
					pTdiInfo->RemoteAddressLength,
					pTdiInfo->Options,
					pTdiInfo->OptionsLength));

		//
		//  Indicate the call to the user.
		//
		TdiStatus = (*pConnInd)(
							ConnIndContext,
							pTdiInfo->RemoteAddressLength,
							pTdiInfo->RemoteAddress,
							pTdiInfo->UserDataLength,
							pTdiInfo->UserData,
							pTdiInfo->OptionsLength,
							pTdiInfo->Options,
							&AcceptConnContext,
							&EventInfo
							);

		RWANDEBUGP(DL_LOUD, DC_CONNECT,
				("IncomingCall: pVc x%x, pAddrObj x%x, Connect Ind returned x%x\n",
						pVc, pAddrObject, TdiStatus));

		if (TdiStatus != TDI_MORE_PROCESSING)
		{
			//
			//  Connection rejected.
			//
			Status = NDIS_STATUS_FAILURE;
			break;
		}


		//
		//  This connection has been accepted. Collect all information
		//  about this implicit TdiAccept Request.
		//
#ifdef NT
		pIrpSp = IoGetCurrentIrpStackLocation(EventInfo);

		Status = RWanPrepareIrpForCancel(
						(PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext,
						EventInfo,
						RWanCancelRequest
						);

		if (!NT_SUCCESS(Status))
		{
			//
			//  Reject this incoming call.
			//
			break;
		}

		pAcceptReq = (PTDI_REQUEST_KERNEL_ACCEPT) &(pIrpSp->Parameters);

		pConnReq->Request.pReqComplete = (PVOID)RWanRequestComplete;
		pConnReq->Request.ReqContext = EventInfo;
		pConnReq->pConnInfo = pAcceptReq->ReturnConnectionInformation;
#else
		pConnReq->Request.pReqComplete = EventInfo.cei_rtn;
		pConnReq->Request.ReqContext = EventInfo.cei_context;
		pConnReq->pConnInfo = EventInfo.cei_conninfo;
#endif // NT

		//
		//  Find the connection object on which it has been accepted.
		//
		IsAddrLockAcquired = TRUE;
		RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

		for (pConnEntry = pAddrObject->IdleConnList.Flink;
 			 pConnEntry != &pAddrObject->IdleConnList;
 			 pConnEntry = pConnEntry->Flink)
		{
			pConnObject = CONTAINING_RECORD(pConnEntry, RWAN_TDI_CONNECTION, ConnLink);
			RWAN_STRUCT_ASSERT(pConnObject, ntc);

			if ((pConnObject->ConnectionHandle == AcceptConnContext) &&
				!(RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING)))
			{
				break;
			}
		}

		if (pConnEntry == &pAddrObject->IdleConnList)
		{
			//
			//  Invalid connection context!
			//
			TdiStatus = TDI_INVALID_CONNECTION;
			RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

			IsAddrLockAcquired = FALSE;

			//
			//  Fail the Accept req
			//
			RWanCompleteConnReq(		// InCall: Accept is bad
						pAf,
						pConnReq,
						FALSE,
						NULL,
						NULL,
						TdiStatus
						);

			pConnReq = NULL;

			//
			//  Reject the incoming call
			//
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Request the media-specific module to update NDIS call parameters.
		//
		if (pAf->pAfInfo->AfChars.pAfSpUpdateNdisOptions)
		{
			(VOID)(*pAf->pAfInfo->AfChars.pAfSpUpdateNdisOptions)(
						pAf->AfSpAFContext,
						pConnObject->AfSpConnContext,
						RWAN_CALLF_INCOMING_CALL|RWAN_CALLF_POINT_TO_POINT,
						pTdiInfo,
						pTdiQoS,
						TdiQoSLength,
						&pCallParameters
						);
		}

		//
		//  Set up the Connection Object for accepting this call.
		//
		RWAN_ACQUIRE_CONN_LOCK_DPC(pConnObject);

		pConnObject->State = RWANS_CO_IN_CALL_ACCEPTING;

		//
		//  Save info to help us complete the Accept Req when
		//  we get a CallConnected from NDIS.
		//
		RWAN_ASSERT(pConnObject->pConnReq == NULL);
		pConnObject->pConnReq = pConnReq;

		//
		//  Move the Connection from the Idle list to the Active list.
		//
		RWAN_DELETE_FROM_LIST(&pConnObject->ConnLink);
		RWAN_INSERT_TAIL_LIST(&pAddrObject->ActiveConnList,
							 &pConnObject->ConnLink);

		RWAN_LINK_CONNECTION_TO_VC(pConnObject, pVc);

		RWanReferenceConnObject(pConnObject);	// VC ref

		RWAN_RELEASE_CONN_LOCK_DPC(pConnObject);

		//
		//  Accept the call.
		//
		Status = NDIS_STATUS_SUCCESS;
		break;

	}
	while (FALSE);

	if (IsAddrLockAcquired)
	{
		RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);
	}

	//
	//  If we are rejecting this call, clean up.
	//
	if ((Status != NDIS_STATUS_SUCCESS) &&
		(Status != NDIS_STATUS_PENDING))
	{
		if (pConnReq != NULL)
		{
			RWanFreeConnReq(pConnReq);
		}

	}

	//
	//  Return TDI options space to the media-specific module.
	//
	if (pTdiInfo != NULL)
	{
		RWAN_ASSERT(pAf);
		RWAN_ASSERT(AfSpTdiOptionsContext);

		(*pAf->pAfInfo->AfChars.pAfSpReturnTdiOptions)(
				pAf->AfSpAFContext,
				AfSpTdiOptionsContext
				);
	}

	RWANDEBUGP(DL_LOUD, DC_CONNECT,
			("IncomingCall: pVc x%x, returning status x%x\n", pVc, Status));

	return (Status);
}




VOID
RWanNdisCallConnected(
	IN	NDIS_HANDLE					ProtocolVcContext
	)
/*++

Routine Description:

	This is the NDIS entry point signifying successful setup of an
	incoming call. If required, we complete the TDI user's Accept Request
	here.

	This primitive can happen only when the call is in the "Accepting" state.

Arguments:

	ProtocolVcContext	- Actually a pointer to our NDIS VC structure

Return Value:

	None

--*/
{
	PRWAN_NDIS_VC				pVc;
	PRWAN_TDI_CONNECTION		pConnObject;
	PRWAN_TDI_ADDRESS			pAddrObject;
	NDIS_HANDLE					NdisVcHandle;
	NDIS_STATUS					Status;
	PRWAN_CONN_REQUEST			pConnReq;
	RWAN_HANDLE					AfSpConnContext;
	ULONG						rc;
	BOOLEAN						IsAborting = FALSE;


	pVc = (PRWAN_NDIS_VC) ProtocolVcContext;
	RWAN_STRUCT_ASSERT(pVc, nvc);
	RWAN_ASSERT(pVc->pConnObject != NULL_PRWAN_TDI_CONNECTION);

	pConnObject = pVc->pConnObject;
	RWAN_STRUCT_ASSERT(pConnObject, ntc);

	pAddrObject = pConnObject->pAddrObject;

	RWAN_ACQUIRE_CONN_LOCK(pConnObject);

	RWAN_SET_VC_EVENT(pVc, RWANF_VC_EVT_CALLCONN);

	IsAborting = ((pConnObject->State != RWANS_CO_IN_CALL_ACCEPTING) ||
					RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING));

	//
	//  Incoming Connection setup successfully.
	//
	if (!IsAborting)
	{
		pConnObject->State = RWANS_CO_CONNECTED;
	}

	//
	//  Add a temp ref to keep the conn object from going away.
	//
	RWanReferenceConnObject(pConnObject);	// Temp ref, CallConn

	//
	//  If we have an Accept Request to complete, complete it
	//  now. Note that we might not have one pending in case
	//  we had a pre-accepted listen.
	//
	pConnReq = pConnObject->pConnReq;
	pConnObject->pConnReq = NULL;

	AfSpConnContext = pConnObject->AfSpConnContext;

	RWAN_RELEASE_CONN_LOCK(pConnObject);

	if (pConnReq != NULL)
	{
		//
		//  Complete the Accept request.
		//
		RWanCompleteConnReq(		// CallConnected: Accept OK
					pVc->pNdisAf,
					pConnReq,
					FALSE,
					NULL,
					AfSpConnContext,
					TDI_SUCCESS
					);
	}

	//
	//  Trigger off data indications for any packets that were received and queued
	//  while we were in the process of accepting the call.
	//
	RWAN_ACQUIRE_CONN_LOCK(pConnObject);

	rc = RWanDereferenceConnObject(pConnObject);	// Temp ref - CallConn

	//
	//  But first make sure that the connection still exists and is in a good
	//  state.
	//
	if (rc != 0)
	{
		if (!IsAborting)
		{
			RWanIndicateData(pConnObject);
		}
		else
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);

			RWANDEBUGP(DL_FATAL, DC_WILDCARD,
				("CallConn: ConnObj %x/%x, State %d, aborting\n",
					pConnObject, pConnObject->Flags, pConnObject->State));
			RWanDoAbortConnection(pConnObject);
		}
	}
	//
	//  else the Connection is gone!
	//

	return;
}




VOID
RWanNdisIncomingCloseCall(
	IN	NDIS_STATUS					CloseStatus,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PVOID						pCloseData,
	IN	UINT						CloseDataLength
	)
/*++

Routine Description:

	This is the NDIS entry point called when a connection is torn
	down by the remote peer or network. We mark the affected endpoint,
	and if possible, indicate a Disconnect Event to the user. If we
	do indicate to the user, call teardown is continued when the
	user calls TdiDisconnect.

	This primitive can happen while the endpoint is in one of these
	states:
	(1) Connected
	(2) Accepting incoming call (TdiAccept pending)

Arguments:

	CloseStatus			- Status for the incoming close
	ProtocolVcContext	- Actually a pointer to our NDIS VC structure
	pCloseData			- Data/options associated with the close - NOT USED
	CloseDataLength		- Length of the above - NOT USED

Return Value:

	None

--*/
{
	PRWAN_NDIS_VC				pVc;
	PRWAN_NDIS_PARTY			pParty;
	PRWAN_NDIS_AF				pAf;
	PRWAN_TDI_CONNECTION		pConnObject;
	PRWAN_CONN_REQUEST			pConnReq;
	NDIS_HANDLE					NdisVcHandle;
	BOOLEAN						bIsConnClosing;	// TdiCloseConnection?
	BOOLEAN						bScheduleDisconnect;
	RWAN_HANDLE					AfSpConnContext;

	pVc = (PRWAN_NDIS_VC)ProtocolVcContext;
	RWAN_STRUCT_ASSERT(pVc, nvc);

	if (!RWAN_IS_BIT_SET(pVc->Flags, RWANF_VC_PMP))
	{
		pConnObject = pVc->pConnObject;
		pParty = NULL;
	}
	else
	{
		//
		//  Locate the connection object for the last leaf.
		//
		pParty = CONTAINING_RECORD(pVc->NdisPartyList.Flink, RWAN_NDIS_PARTY, PartyLink);
		RWAN_STRUCT_ASSERT(pParty, npy);

		pConnObject = pParty->pConnObject;
	}

	RWAN_ASSERT(pConnObject != NULL_PRWAN_TDI_CONNECTION);
	RWAN_STRUCT_ASSERT(pConnObject, ntc);

	RWANDEBUGP(DL_INFO, DC_DISCON,
			("IncomingClose: pVc x%x, pConnObj x%x/x%x, pParty x%x\n",
				pVc, pConnObject, pConnObject->Flags, pParty));

	RWAN_ACQUIRE_CONN_LOCK(pConnObject);

	RWAN_SET_VC_EVENT(pVc, RWANF_VC_EVT_INCLOSE);

	NdisVcHandle = pVc->NdisVcHandle;

	bIsConnClosing = RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING);

	if (bIsConnClosing)
	{
		//
		//  The user has initiated a TdiCloseConnection.
		//  Continue NDIS call teardown. When this completes,
		//  we'll complete the CloseConnection.
		//  
		RWanStartCloseCall(pConnObject, pVc);
		return;
	}

	pAf = pVc->pNdisAf;

	switch (pConnObject->State)
	{
		case RWANS_CO_IN_CALL_ACCEPTING:
			//
			//  If we have a pended Accept Request, fail it now.
			//  Otherwise, we must have had a pre-accepted listen,
			//  so we fall through and indicate a Disconnect.
			//
			pConnReq = pConnObject->pConnReq;
			pConnObject->pConnReq = NULL;

			if (pConnReq != NULL)
			{
				//
				//  Fix the state so that TdiDisconnect does the right thing
				//
				pConnObject->State = RWANS_CO_DISCON_INDICATED;

				AfSpConnContext = pConnObject->AfSpConnContext;

				RWanScheduleDisconnect(pConnObject);
				//
				//  Conn Lock is released within the above.
				//

				RWanCompleteConnReq(		// Incoming Close during IN_CALL_ACCEPT
							pAf,
							pConnReq,
							FALSE,
							NULL,
							AfSpConnContext,
							TDI_CONNECTION_ABORTED
							);
				break;
			}
			//
			//  else this must be a pre-accepted listen.
			//
			//  FALLTHRU on "else" to RWANS_CO_CONNECTED
			//

		case RWANS_CO_CONNECTED:
			//
			//  If there is a Disconnect Event handler, call it.
			//  Otherwise, simply mark this endpoint as having
			//  seen a Disconnect.
			//
			bScheduleDisconnect = TRUE;
			if (pConnObject->pAddrObject != NULL_PRWAN_TDI_ADDRESS)
			{
				PDisconnectEvent			pDisconInd;
				PVOID						IndContext;
				PVOID						ConnectionHandle;

				pDisconInd = pConnObject->pAddrObject->pDisconInd;
				IndContext = pConnObject->pAddrObject->DisconIndContext;

				//
				//  Don't send up a Disconnect Indication if we are in the
				//  middle of indicating data.
				//
				if ((pDisconInd != NULL) &&
					!(RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_INDICATING_DATA)))
				{
					RWANDEBUGP(DL_INFO, DC_WILDCARD,
						("IncomingClose: pConnObj %x/%x, st %x, will discon ind\n",
							pConnObject, pConnObject->Flags, pConnObject->State));

					pConnObject->State = RWANS_CO_DISCON_INDICATED;
					ConnectionHandle = pConnObject->ConnectionHandle;

					//
					//  Schedule a work item to continue Disconnect
					//  first. This is because the call to DiscInd can
					//  lead to a call to CloseConnection and block there.
					//
					bScheduleDisconnect = FALSE;
					RWanScheduleDisconnect(pConnObject);

					(*pDisconInd)(
							IndContext,
							ConnectionHandle,
							0,			// Disconnect Data Length
							NULL,		// Disconnect Data
							0,			// Disconnect Info Length
							NULL,		// Disconnect Info
							TDI_DISCONNECT_RELEASE
							);

				}
				else
				{
					RWANDEBUGP(DL_FATAL, DC_DISCON,
						("IncomingClose: pConnObj %x/%x, pending discon\n",
							pConnObject, pConnObject->Flags));

					pConnObject->State = RWANS_CO_DISCON_HELD;
					RWAN_SET_BIT(pConnObject->Flags, RWANF_CO_PENDED_DISCON);
				}
			}
			else
			{
				pConnObject->State = RWANS_CO_DISCON_HELD;
			}

			if (bScheduleDisconnect)
			{
				RWanScheduleDisconnect(pConnObject);
				//
				//  Conn Object lock is released within the above.
				//
			}

			break;

		case RWANS_CO_ABORTING:
		case RWANS_CO_DISCON_REQUESTED:
			//
			//  Ignore this.
			//
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			break;

		default:

			RWAN_ASSERT(FALSE);
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			break;
	}

	return;
}




VOID
RWanNdisCloseCallComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					ProtocolPartyContext
	)
/*++

Routine Description:

	The NDIS entry point that is called when a previous pended call
	we made to NdisClCloseCall has completed.

Arguments:

	Status				- Final status of CloseCall
	ProtocolVcContext	- Actually a pointer to our NDIS VC structure
	ProtocolPartyContext- Last party context, points to NDIS PARTY structure
						  if this is a point-to-multipoint call.

Return Value:

	None

--*/
{
	PRWAN_NDIS_VC			pVc;
	PRWAN_NDIS_PARTY		pParty;
	PRWAN_NDIS_AF			pAf;
	PRWAN_TDI_CONNECTION	pConnObject;
	PRWAN_TDI_CONNECTION	pRootConnObject;
	INT						rc;
	PRWAN_CONN_REQUEST		pConnReq;
	BOOLEAN					IsOutgoingCall;
	RWAN_HANDLE				AfSpConnContext;

#ifndef NO_POST_DISCON
	PDisconnectEvent		pDisconInd;
	PVOID					IndContext;
	PVOID					ConnectionHandle;
#endif // !NO_POST_DISCON

	RWAN_ASSERT(Status == NDIS_STATUS_SUCCESS);

	pVc = (PRWAN_NDIS_VC)ProtocolVcContext;
	RWAN_STRUCT_ASSERT(pVc, nvc);

	RWAN_SET_VC_EVENT(pVc, RWANF_VC_EVT_CLOSECOMP);

	//
	//  Check if this is a point-to-multipoint call.
	//
	pParty = (PRWAN_NDIS_PARTY)ProtocolPartyContext;

	if (ProtocolPartyContext == NULL)
	{
		//
		//  Point to point call.
		//
		pConnObject = pVc->pConnObject;
		pRootConnObject = NULL;
	}
	else
	{
		//
		//  PMP Call.
		//
		RWAN_STRUCT_ASSERT(pParty, npy);

		pConnObject = pParty->pConnObject;
		pRootConnObject = pConnObject->pRootConnObject;
	}

	RWANDEBUGP(DL_INFO, DC_DISCON,
			("CloseCallComplete: pVc x%x, pPty x%x, pConnObj x%x, pRoot x%x\n",
					pVc, pParty, pVc->pConnObject, pRootConnObject));

	if (pConnObject != NULL)
	{
		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		//
		//  A pended Disconnect Request may be around.
		//
		pConnReq = pConnObject->pConnReq;
		pConnObject->pConnReq = NULL;

		pAf = pVc->pNdisAf;

		IsOutgoingCall = RWAN_IS_BIT_SET(pVc->Flags, RWANF_VC_OUTGOING);

		//
		//  State change:
		//
		if (pConnObject->State != RWANS_CO_ABORTING)
		{
			pConnObject->State = ((pConnObject->pAddrObject != NULL) ?
										RWANS_CO_ASSOCIATED:
										RWANS_CO_CREATED);
		}

		if (pParty == NULL)
		{
			//
			//  Unlink the VC from the Connection Object.
			//
			RWAN_UNLINK_CONNECTION_AND_VC(pConnObject, pVc);	// CloseCallComplete

		}
		else
		{
			//
			//  PMP Call. The VC is linked to the root Conn Object.
			//
			RWAN_STRUCT_ASSERT(pRootConnObject, ntc);

			RWAN_ACQUIRE_CONN_LOCK(pRootConnObject);

			pRootConnObject->State = ((pRootConnObject->pAddrObject != NULL) ?
										RWANS_CO_ASSOCIATED:
										RWANS_CO_CREATED);

			pVc->DroppingPartyCount --;	// CloseCallComplete (PMP)

			RWAN_UNLINK_CONNECTION_AND_VC(pRootConnObject, pVc);	// CloseCallCompletePMP

			rc = RWanDereferenceConnObject(pRootConnObject);	// VC deref in CloseCallCompletePMP

			if (rc > 0)
			{
				RWAN_RELEASE_CONN_LOCK(pRootConnObject);
			}

			//
			//  Unlink the Party from the VC and Leaf Conn Object.
			//
			pParty->pVc = NULL;
			RWAN_DELETE_FROM_LIST(&(pParty->PartyLink));

			pParty->pConnObject = NULL;
			pConnObject->NdisConnection.pNdisParty = NULL;
		}

		AfSpConnContext = pConnObject->AfSpConnContext;

#ifndef NO_POST_DISCON
		if (pConnObject->pAddrObject != NULL_PRWAN_TDI_ADDRESS)
		{

			pDisconInd = pConnObject->pAddrObject->pDisconInd;
			IndContext = pConnObject->pAddrObject->DisconIndContext;

			ConnectionHandle = pConnObject->ConnectionHandle;
		}
		else
		{
			pDisconInd = NULL;
		}
#endif // NO_POST_DISCON

		rc = RWanDereferenceConnObject(pConnObject);	// VC/Pty deref in CloseCallComplete

		if (rc > 0)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
		}

		if (pConnReq != NULL)
		{
#ifndef NO_POST_DISCON
			if (pDisconInd != NULL)
			{
				(*pDisconInd)(
						IndContext,
						ConnectionHandle,
						0,			// Disconnect Data Length
						NULL,		// Disconnect Data
						0,			// Disconnect Info Length
						NULL,		// Disconnect Info
						TDI_DISCONNECT_ABORT
						);
			}
#endif // !NO_POST_DISCON

			RWanCompleteConnReq(		// CloseCallComplete - completing discon req
						pAf,
						pConnReq,
						IsOutgoingCall,
						NULL,
						AfSpConnContext,
						TDI_SUCCESS
						);

		}
	}

	//
	//  See if the VC was created by us. If so, call NDIS to delete it,
	//  and free it.
	//
	if (RWAN_IS_BIT_SET(pVc->Flags, RWANF_VC_OUTGOING))
	{
		NDIS_HANDLE			NdisVcHandle;

		NdisVcHandle = pVc->NdisVcHandle;

		//
		//  Unlink the VC from the list of VCs on the AF block
		//
		RWanUnlinkVcFromAf(pVc);

		Status = NdisCoDeleteVc(NdisVcHandle);
		RWAN_ASSERT(Status == NDIS_STATUS_SUCCESS);

		RWanFreeVc(pVc);
	}
	//
	//  Otherwise this VC was created by the Call Manager.
	//  Leave it as it is.
	//

	if (pParty != NULL)
	{
		RWAN_FREE_MEM(pParty);	// CloseCallComplete PMP
	}

	return;

}




VOID
RWanNdisDropPartyComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext
	)
/*++

Routine Description:

	This is the NDIS entry point signifying completion of a previous
	call to NdisClDropParty that had pended.

	We locate and complete the TDI Disconnect, if any, that lead to this.

Arguments:

	Status				- Final status of the Drop party request
	ProtocolPartyContext- Actually a pointer to our NDIS PARTY structure

Return Value:

	None

--*/
{
	PRWAN_NDIS_PARTY		pParty;
	PRWAN_NDIS_VC			pVc;
	PRWAN_NDIS_AF			pAf;
	PRWAN_TDI_CONNECTION	pConnObject;
	PRWAN_TDI_CONNECTION	pRootConnObject;
	PRWAN_CONN_REQUEST		pConnReq;
	ULONG					rc;
	BOOLEAN					IsOutgoingCall = TRUE;
	BOOLEAN					bVcNeedsClose;
	RWAN_HANDLE				AfSpConnContext;
#ifndef NO_POST_DISCON
	PDisconnectEvent		pDisconInd;
	PVOID					IndContext;
	PVOID					ConnectionHandle;
#endif // !NO_POST_DISCON

	RWAN_ASSERT(Status == NDIS_STATUS_SUCCESS);

	pParty = (PRWAN_NDIS_PARTY)ProtocolPartyContext;
	RWAN_STRUCT_ASSERT(pParty, npy);

	pVc = pParty->pVc;

	pConnObject = pParty->pConnObject;

	if (pConnObject != NULL)
	{
		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		//
		//  A pended Disconnect Request may be around.
		//
		pConnReq = pConnObject->pConnReq;
		pConnObject->pConnReq = NULL;

		pAf = pVc->pNdisAf;

		//
		//  State change:
		//
		if (pConnObject->State != RWANS_CO_ABORTING)
		{
			pConnObject->State = ((pConnObject->pAddrObject != NULL) ?
										RWANS_CO_ASSOCIATED:
										RWANS_CO_CREATED);
		}

		AfSpConnContext = pConnObject->AfSpConnContext;

		pRootConnObject = pVc->pConnObject;
		RWAN_STRUCT_ASSERT(pRootConnObject, ntc);

#if DBG
		if (pConnObject->pAddrObject != NULL)
		{
			RWAN_ASSERT(pRootConnObject == pConnObject->pAddrObject->pRootConnObject);
		}
#endif // DBG

#ifndef NO_POST_DISCON
		if (pConnObject->pAddrObject != NULL_PRWAN_TDI_ADDRESS)
		{

			pDisconInd = pConnObject->pAddrObject->pDisconInd;
			IndContext = pConnObject->pAddrObject->DisconIndContext;

			ConnectionHandle = pConnObject->ConnectionHandle;
		}
		else
		{
			pDisconInd = NULL;
		}
#endif // NO_POST_DISCON

		pConnObject->NdisConnection.pNdisParty = NULL;
		rc = RWanDereferenceConnObject(pConnObject);	// Pty deref in DropPartyComplete

		if (rc > 0)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
		}

		if (pConnReq != NULL)
		{
#ifndef NO_POST_DISCON
			if (pDisconInd != NULL)
			{
				(*pDisconInd)(
						IndContext,
						ConnectionHandle,
						0,			// Disconnect Data Length
						NULL,		// Disconnect Data
						0,			// Disconnect Info Length
						NULL,		// Disconnect Info
						TDI_DISCONNECT_ABORT
						);
			}
#endif // NO_POST_DISCON
			RWanCompleteConnReq(		// DropPartyComplete - completing discon req
						pAf,
						pConnReq,
						IsOutgoingCall,
						NULL,
						AfSpConnContext,
						TDI_SUCCESS
						);
		}

		//
		//  The Root Connection object lock controls access to
		//  the VC structure.
		//
		RWAN_ACQUIRE_CONN_LOCK(pRootConnObject);

		//
		//  Unlink the Party from the VC.
		//
		RWAN_DELETE_FROM_LIST(&(pParty->PartyLink));
		pVc->DroppingPartyCount --;	// DropPartyComplete

		//
		//  We may be in the process of shutting down this connection.
		//  This may be the penultimate Party going away. If so,
		//  continue the call close.
		//
		if (RWAN_IS_BIT_SET(pVc->Flags, RWANF_VC_NEEDS_CLOSE))
		{
			RWanStartCloseCall(pRootConnObject, pVc);
			//
			//  Root Conn lock is released within the above.
			//
		}
		else
		{
			RWAN_RELEASE_CONN_LOCK(pRootConnObject);
		}
	}
	else
	{
		//
		//  Not sure if we can be here.
		//
		RWAN_ASSERT(FALSE);
	}
	

	//
	//  End of the road for this Party structure.
	//
	RWAN_FREE_MEM(pParty);	// DropParty Complete

}




VOID
RWanNdisIncomingDropParty(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					OurPartyContext,
	IN	PVOID						pBuffer,
	IN	UINT						BufferLength
	)
/*++

Routine Description:

	This is the NDIS entry point notifying us that a leaf of a PMP call is
	being dropped, either because the remote station terminated its session
	or because of network conditions.

	We simply inform the TDI client of a Disconnect on the Connection Object
	representing this leaf, similar to an incoming Close on a VC.

Arguments:

	Status				- Status code for the Drop party
	OurPartyContext		- Pointer to our Party structure
	pBuffer				- Optional accompanying info (ignored)
	BufferLength		- Length of above (ignored)

Return Value:

	None

--*/
{
	PRWAN_NDIS_PARTY			pParty;
	PRWAN_NDIS_VC				pVc;
	PRWAN_TDI_CONNECTION		pConnObject;
	PRWAN_CONN_REQUEST			pConnReq;
	NDIS_HANDLE					NdisPartyHandle;
	BOOLEAN						bIsConnClosing;	// TdiCloseConnection?
	BOOLEAN						bIsLastLeaf;
	BOOLEAN						bScheduleDisconnect;

	pParty = (PRWAN_NDIS_PARTY)OurPartyContext;
	RWAN_STRUCT_ASSERT(pParty, npy);

	pVc = pParty->pVc;
	RWAN_STRUCT_ASSERT(pVc, nvc);

	RWANDEBUGP(DL_INFO, DC_DISCON,
			("IncomingDrop: pPty x%x, pVc x%x, pConnObj x%x, AddingCnt %d, ActiveCnt %d\n",
				pParty, pVc, pParty->pConnObject, pVc->AddingPartyCount, pVc->ActivePartyCount));

	pConnObject = pParty->pConnObject;

	RWAN_ASSERT(pConnObject != NULL_PRWAN_TDI_CONNECTION);
	RWAN_STRUCT_ASSERT(pConnObject, ntc);

	RWAN_ACQUIRE_CONN_LOCK(pConnObject);

	bIsLastLeaf = (pVc->AddingPartyCount + pVc->ActivePartyCount == 0);

	bIsConnClosing = RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING);

	if (bIsConnClosing)
	{
		//
		//  The user has initiated a TdiCloseConnection.
		//  Continue NDIS call teardown. When this completes,
		//  we'll complete the CloseConnection.
		//
		if (bIsLastLeaf)
		{
			RWanStartCloseCall(pConnObject, pVc);

			//
			//  Conn Lock is released within the above.
			//
		}
		else
		{
			NdisPartyHandle = pParty->NdisPartyHandle;

			RWAN_RELEASE_CONN_LOCK(pConnObject);

			Status = NdisClDropParty(
						NdisPartyHandle,
						NULL,		// No Drop Data
						0			// Length of above
						);
			
			if (Status != NDIS_STATUS_PENDING)
			{
				RWanNdisDropPartyComplete(
						Status,
						(NDIS_HANDLE)pParty
						);
			}
		}

		return;
	}


	switch (pConnObject->State)
	{
		case RWANS_CO_IN_CALL_ACCEPTING:

			RWAN_ASSERT(FALSE);
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			break;

		case RWANS_CO_CONNECTED:
			//
			//  If there is a Disconnect Event handler, call it.
			//  Otherwise, simply mark this endpoint as having
			//  seen a Disconnect.
			//
			bScheduleDisconnect = TRUE;
			if (pConnObject->pAddrObject != NULL_PRWAN_TDI_ADDRESS)
			{
				PDisconnectEvent			pDisconInd;
				PVOID						IndContext;
				PVOID						ConnectionHandle;

				pDisconInd = pConnObject->pAddrObject->pDisconInd;
				IndContext = pConnObject->pAddrObject->DisconIndContext;

				if (pDisconInd != NULL)
				{
					pConnObject->State = RWANS_CO_DISCON_INDICATED;
					ConnectionHandle = pConnObject->ConnectionHandle;

					bScheduleDisconnect = FALSE;

					RWanScheduleDisconnect(pConnObject);
					//
					//  Conn Object lock is released within the above.
					//

					RWANDEBUGP(DL_EXTRA_LOUD, DC_DISCON,
							("IncomingDrop: will indicate Discon, pConnObj x%x, pAddrObj x%x\n",
								pConnObject, pConnObject->pAddrObject));

					(*pDisconInd)(
							IndContext,
							ConnectionHandle,
							0,			// Disconnect Data Length
							NULL,		// Disconnect Data
							0,			// Disconnect Info Length
							NULL,		// Disconnect Info
							TDI_DISCONNECT_ABORT
							);
				}
				else
				{
					pConnObject->State = RWANS_CO_DISCON_HELD;
				}
			}
			else
			{
				pConnObject->State = RWANS_CO_DISCON_HELD;
			}

			if (bScheduleDisconnect)
			{
				RWanScheduleDisconnect(pConnObject);
				//
				//  Conn Object lock is released within the above.
				//
			}

			break;

		case RWANS_CO_ABORTING:
		case RWANS_CO_DISCON_REQUESTED:
			//
			//  Ignore this.
			//
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			break;

		default:

			RWAN_ASSERT(FALSE);
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			break;
	}

	return;
}




VOID
RWanNdisModifyQoSComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					OurVcContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
	)
/*++

Routine Description:

Arguments:


Return Value:

	None

--*/
{
	//
	//  Not expected, since we don't call NdisClModifyCallQoS
	//
	RWAN_ASSERT(FALSE);
}




VOID
RWanNdisRejectIncomingCall(
	IN	PRWAN_TDI_CONNECTION			pConnObject,
	IN	NDIS_STATUS					RejectStatus
	)
/*++

Routine Description:

	Reject the incoming call present on the specified Connection Object.

Arguments:

	pConnObject			- Points to the TDI Connection
	RejectStatus		- Reason for rejecting the call

Locks on Entry:

	pConnObject

Locks on Exit:

	None

Return Value:

	None

--*/
{
	PRWAN_NDIS_VC				pVc;
	NDIS_HANDLE					NdisVcHandle;
	PCO_CALL_PARAMETERS			pCallParameters;
	INT							rc;
	PRWAN_CONN_REQUEST			pConnReq;
	PRWAN_NDIS_AF				pAf;
	RWAN_HANDLE					AfSpConnContext;

	pVc = pConnObject->NdisConnection.pNdisVc;

	NdisVcHandle = pVc->NdisVcHandle;
	pCallParameters = pVc->pCallParameters;
	pVc->pCallParameters = NULL;
	pAf = pVc->pNdisAf;

	//
	//  Unlink the VC from the Conn Object.
	//
	RWAN_UNLINK_CONNECTION_AND_VC(pConnObject, pVc);	// Reject incoming call

	RWAN_SET_BIT(pVc->Flags, RWANF_VC_CLOSING_CALL);

	pConnReq = pConnObject->pConnReq;
	pConnObject->pConnReq = NULL;

	//
	//  State change.
	//
	if (pConnObject->State != RWANS_CO_ABORTING)
	{
		pConnObject->State = ((pConnObject->pAddrObject != NULL) ?
									RWANS_CO_ASSOCIATED:
									RWANS_CO_CREATED);
	}

	AfSpConnContext = pConnObject->AfSpConnContext;

	rc = RWanDereferenceConnObject(pConnObject);	// Unlinking VC in reject in-call

	if (rc > 0)
	{
		RWAN_RELEASE_CONN_LOCK(pConnObject);
	}

	NdisClIncomingCallComplete(
		RejectStatus,
		NdisVcHandle,
		pCallParameters
		);

	if (pConnReq != NULL)
	{
		RWanCompleteConnReq(		// Discon Req for rejecting in call
				pAf,
				pConnReq,
				FALSE,
				NULL,			// No Call Parameters
				AfSpConnContext,
				TDI_SUCCESS
				);
	}

	return;
}




VOID
RWanStartCloseCall(
	IN	PRWAN_TDI_CONNECTION		pConnObject,
	IN	PRWAN_NDIS_VC				pVc
	)
/*++

Routine Description:

	Start NDIS call teardown on the VC associated with the given
	connection object, if all pre-conditions are met:

	0. An NDIS CloseCall isn't already going on
	1. No outstanding sends

Arguments:

	pConnObject			- Points to TDI Connection object
	pVc					- Points to corresponding VC

Locks on Entry:

	pConnObject

Locks on Exit:

	None

Return Value:

	None

--*/
{
	PRWAN_NDIS_PARTY		pParty;
	NDIS_HANDLE				NdisVcHandle;
	NDIS_HANDLE				NdisPartyHandle;
	NDIS_STATUS				Status;
	PRWAN_RECEIVE_INDICATION	pRcvIndHead;
	PRWAN_RECEIVE_INDICATION	pRcvInd;

	RWANDEBUGP(DL_INFO, DC_DISCON,
			("StartCloseCall: pVc x%x/x%x, PendingCount %d, pConnObj x%x\n",
					pVc,
					pVc->Flags,
					pVc->PendingPacketCount,
					pConnObject));

	//
	//  Free up any pending receives.
	//
	pRcvIndHead = pVc->pRcvIndHead;
	if (pRcvIndHead != NULL)
	{
		pVc->pRcvIndHead = NULL;
		pVc->pRcvIndTail = NULL;

		//
		//  Update the count of pending packets on this VC.
		//
		for (pRcvInd = pRcvIndHead; pRcvInd != NULL; pRcvInd = pRcvInd->pNextRcvInd)
		{
			pVc->PendingPacketCount--;
		}

		//
		//  We will free this list below.
		//
	}


	if ((pVc != NULL) &&
		(pVc->PendingPacketCount == 0) &&
		(pVc->DroppingPartyCount == 0) &&
		(!RWAN_IS_BIT_SET(pVc->Flags, RWANF_VC_CLOSING_CALL)))
	{
		NdisVcHandle = pVc->NdisVcHandle;
		RWAN_SET_BIT(pVc->Flags, RWANF_VC_CLOSING_CALL);

		RWAN_RESET_BIT(pVc->Flags, RWANF_VC_NEEDS_CLOSE);

		if (RWAN_IS_LIST_EMPTY(&(pVc->NdisPartyList)))
		{
			pParty = NULL_PRWAN_NDIS_PARTY;
			NdisPartyHandle = NULL;
			RWAN_ASSERT(!RWAN_IS_BIT_SET(pVc->Flags, RWANF_VC_PMP));
		}
		else
		{
			pParty = CONTAINING_RECORD(pVc->NdisPartyList.Flink, RWAN_NDIS_PARTY, PartyLink);
			NdisPartyHandle = pParty->NdisPartyHandle;

			RWAN_SET_BIT(pParty->Flags, RWANF_PARTY_DROPPING);

			pVc->DroppingPartyCount ++;	// StartCloseCall PMP
			pVc->ActivePartyCount --;	// StartCloseCall PMP
		}

		RWAN_RELEASE_CONN_LOCK(pConnObject);

		Status = NdisClCloseCall(
						NdisVcHandle,
						NdisPartyHandle,
						NULL,				// No CloseData
						0
						);

		if (Status != NDIS_STATUS_PENDING)
		{
			RWanNdisCloseCallComplete(
						Status,
						(NDIS_HANDLE)pVc,	// ProtocolVcContext
						(NDIS_HANDLE)pParty	// ProtocolPartyContext
					);
		}
	}
	else
	{
		if (pVc != NULL)
		{
			RWAN_SET_BIT(pVc->Flags, RWANF_VC_NEEDS_CLOSE);
		}
		RWAN_RELEASE_CONN_LOCK(pConnObject);
	}


	if (pRcvIndHead != NULL)
	{
		RWANDEBUGP(DL_INFO, DC_DISCON,
				("RWanStartCloseCall: will free rcv ind list x%x on VC x%x\n",
						pRcvIndHead, pVc));

		RWanFreeReceiveIndList(pRcvIndHead);
	}
}




VOID
RWanUnlinkVcFromAf(
	IN	PRWAN_NDIS_VC				pVc
	)
/*++

Routine Description:

	Unlink a VC from the AF it belongs to.

Arguments:

	pVc					- Points to VC to be unlinked

Return Value:

	None

--*/
{
	PRWAN_NDIS_AF			pAf;
	INT						rc;

	pAf = pVc->pNdisAf;

	RWAN_STRUCT_ASSERT(pAf, naf);

	RWAN_ACQUIRE_AF_LOCK(pAf);

	RWAN_DELETE_FROM_LIST(&(pVc->VcLink));

	rc = RWanDereferenceAf(pAf);		// VC unlink deref

	if (rc != 0)
	{
		RWAN_RELEASE_AF_LOCK(pAf);
	}

	return;
}



VOID
RWanCompleteConnReq(
	IN	PRWAN_NDIS_AF				pAf,
	IN	PRWAN_CONN_REQUEST			pConnReq,
	IN	BOOLEAN						IsOutgoingCall,
	IN	PCO_CALL_PARAMETERS			pCallParameters	OPTIONAL,
	IN	RWAN_HANDLE					AfSpConnContext,
	IN	TDI_STATUS					TdiStatus
	)
/*++

Routine Description:

	Call the completion routine for a pended TDI request on a connection.
	Set up the options and completion status based on what's given to us.

Arguments:

	pAf					- The AF block on which the request was made
	pConnReq			- the pended request to be completed
	IsOutgoingCall		- Is this an outgoing call?
	pCallParameters		- if applicable, this should be mapped to connection info
	AfSpConnContext		- Connection context, if applicable, for the media-specific
						  module.
	TdiStatus			- completion status for the request

Return Value:

	None

--*/
{
	RWAN_STATUS			RWanStatus;
	ULONG				TdiQoSLength = 0;

	if (pConnReq == NULL)
	{
		return;
	}

	RWAN_STRUCT_ASSERT(pConnReq, nrc);

	//
	//  Update Connection Information if we need to.
	//
	if ((pConnReq->pConnInfo != NULL) &&
		(pCallParameters != NULL))
	{
		RWanStatus =  (*pAf->pAfInfo->AfChars.pAfSpUpdateTdiOptions)(
							pAf->AfSpAFContext,
							AfSpConnContext,
							IsOutgoingCall,
							pCallParameters,
							&pConnReq->pConnInfo,
							pConnReq->pConnInfo->Options,
							&pConnReq->pConnInfo->OptionsLength
							);
	}

	//
	//  Call the completion routine.
	//
	(*pConnReq->Request.pReqComplete)(
			pConnReq->Request.ReqContext,
			TdiStatus,
			0
			);

	RWanFreeConnReq(pConnReq);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\ntentry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\ntentry.c

Abstract:

	NT specific entry points for dispatching and handling TDI IRPs. Based on
	TCP source.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     04-21-97    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'IDTN'



#define RWAN_COMPLETE_IRP(_pIrp, _Status, _Info)						\
			{														\
				(_pIrp)->IoStatus.Status = (NTSTATUS)(_Status);		\
				(_pIrp)->IoStatus.Information = (_Info);			\
				IoCompleteRequest(_pIrp, IO_NETWORK_INCREMENT);		\
			}






NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT				pDriverObject,
	IN	PUNICODE_STRING				pRegistryPath
	)
/*++

Routine Description:

	This is the "init" routine called by the system when Raw WAN
	is loaded. We initialize all our global objects, fill in our
	Dispatch and Unload routine addresses in the driver object.

	We initialize the media/AF specific modules, and they register support
	for TDI protocols, at which time we create device objects.

Arguments:

	pDriverObject	- Pointer to the driver object created by the system.
	pRegistryPath	- Pointer to our global registry path. This is ignored.

Return Value:

	NT Status code: STATUS_SUCCESS if successful, error code otherwise.

--*/
{
	NTSTATUS				Status;
	RWAN_STATUS				RWanStatus;
	PDEVICE_OBJECT			pDeviceObject;
	UNICODE_STRING			DeviceName;
	INT						i;

	RWANDEBUGP(DL_FATAL, DC_WILDCARD,
			("RWanDebugLevel is %d, &RWanDebugLevel at x%x\n",
				RWanDebugLevel, &RWanDebugLevel));
	RWANDEBUGP(DL_FATAL, DC_WILDCARD,
			("RWanDebugComp is x%x, &RWanDebugComp at x%x\n",
				RWanDebugComp, &RWanDebugComp));
	RWANDEBUGP(DL_FATAL, DC_WILDCARD,
			("RWanGlobals at x%x\n", &RWanGlobals));
#if DBG
	RWANDEBUGP(DL_FATAL, DC_WILDCARD,
			("To skip everything set RWanSkipAll at x%x to 1\n", &RWanSkipAll));

	if (RWanSkipAll)
	{
		RWANDEBUGP(DL_FATAL, DC_WILDCARD,
				("Aborting DriverEntry\n"));
		return (STATUS_UNSUCCESSFUL);
	}

	NdisAllocateSpinLock(&RWanDbgLogLock);
#if DBG_LOG_PACKETS
	NdisAllocateSpinLock(&RWanDPacketLogLock);
#endif
#endif // DBG


	RWanStatus = RWanInitGlobals(pDriverObject);

	if (RWanStatus != RWAN_STATUS_SUCCESS)
	{
		return (STATUS_UNSUCCESSFUL);
	}

	//
	//  Register as an NDIS protocol.
	//
	RWAN_ZERO_MEM(&RWanNdisProtocolCharacteristics, sizeof(RWanNdisProtocolCharacteristics));

	RWanNdisProtocolCharacteristics.MajorNdisVersion = RWAN_NDIS_MAJOR_VERSION;
	RWanNdisProtocolCharacteristics.MinorNdisVersion = RWAN_NDIS_MINOR_VERSION;
	RWanNdisProtocolCharacteristics.OpenAdapterCompleteHandler = RWanNdisOpenAdapterComplete;
	RWanNdisProtocolCharacteristics.CloseAdapterCompleteHandler = RWanNdisCloseAdapterComplete;
	RWanNdisProtocolCharacteristics.SendCompleteHandler = RWanNdisSendComplete;
	RWanNdisProtocolCharacteristics.TransferDataCompleteHandler = RWanNdisTransferDataComplete;
	RWanNdisProtocolCharacteristics.ResetCompleteHandler = RWanNdisResetComplete;
	RWanNdisProtocolCharacteristics.RequestCompleteHandler = RWanNdisRequestComplete;
	RWanNdisProtocolCharacteristics.ReceiveHandler = RWanNdisReceive;
	RWanNdisProtocolCharacteristics.ReceiveCompleteHandler = RWanNdisReceiveComplete;
	RWanNdisProtocolCharacteristics.StatusHandler = RWanNdisStatus;
	RWanNdisProtocolCharacteristics.StatusCompleteHandler = RWanNdisStatusComplete;
	NdisInitUnicodeString(
		&RWanNdisProtocolCharacteristics.Name,
		RWAN_NAME
	);
	RWanNdisProtocolCharacteristics.ReceivePacketHandler = RWanNdisReceivePacket;
	RWanNdisProtocolCharacteristics.BindAdapterHandler = RWanNdisBindAdapter;
	RWanNdisProtocolCharacteristics.PnPEventHandler = RWanNdisPnPEvent;
	RWanNdisProtocolCharacteristics.UnbindAdapterHandler = RWanNdisUnbindAdapter;
	RWanNdisProtocolCharacteristics.UnloadHandler = (UNLOAD_PROTOCOL_HANDLER)RWanUnloadProtocol;
#ifdef _PNP_POWER_
	RWanNdisProtocolCharacteristics.PnpEventHandler = RWanNdisPnPEvent;
#endif // _PNP_POWER_
	RWanNdisProtocolCharacteristics.CoSendCompleteHandler = RWanNdisCoSendComplete;
	RWanNdisProtocolCharacteristics.CoStatusHandler = RWanNdisCoStatus;
	RWanNdisProtocolCharacteristics.CoReceivePacketHandler = RWanNdisCoReceivePacket;
#if 0
	RWanNdisProtocolCharacteristics.CoRequestHandler = RWanNdisCoRequest;
	RWanNdisProtocolCharacteristics.CoRequestCompleteHandler = RWanNdisCoRequestComplete;
#endif
	RWanNdisProtocolCharacteristics.CoAfRegisterNotifyHandler = RWanNdisAfRegisterNotify;

	RWAN_ZERO_MEM(&RWanNdisClientCharacteristics, sizeof(RWanNdisClientCharacteristics));

	RWanNdisClientCharacteristics.MajorVersion = RWAN_NDIS_MAJOR_VERSION;
	RWanNdisClientCharacteristics.MinorVersion = RWAN_NDIS_MINOR_VERSION;
	RWanNdisClientCharacteristics.ClCreateVcHandler = RWanNdisCreateVc;
	RWanNdisClientCharacteristics.ClDeleteVcHandler = RWanNdisDeleteVc;
	RWanNdisClientCharacteristics.ClOpenAfCompleteHandler = RWanNdisOpenAddressFamilyComplete;
	RWanNdisClientCharacteristics.ClCloseAfCompleteHandler = RWanNdisCloseAddressFamilyComplete;
	RWanNdisClientCharacteristics.ClRegisterSapCompleteHandler = RWanNdisRegisterSapComplete;
	RWanNdisClientCharacteristics.ClDeregisterSapCompleteHandler = RWanNdisDeregisterSapComplete;
	RWanNdisClientCharacteristics.ClMakeCallCompleteHandler = RWanNdisMakeCallComplete;
	RWanNdisClientCharacteristics.ClModifyCallQoSCompleteHandler = RWanNdisModifyQoSComplete;
	RWanNdisClientCharacteristics.ClCloseCallCompleteHandler = RWanNdisCloseCallComplete;
	RWanNdisClientCharacteristics.ClAddPartyCompleteHandler = RWanNdisAddPartyComplete;
	RWanNdisClientCharacteristics.ClDropPartyCompleteHandler = RWanNdisDropPartyComplete;
	RWanNdisClientCharacteristics.ClIncomingCallHandler = RWanNdisIncomingCall;
	RWanNdisClientCharacteristics.ClIncomingCallQoSChangeHandler = (CL_INCOMING_CALL_QOS_CHANGE_HANDLER)NULL;
	RWanNdisClientCharacteristics.ClIncomingCloseCallHandler = RWanNdisIncomingCloseCall;
	RWanNdisClientCharacteristics.ClIncomingDropPartyHandler = RWanNdisIncomingDropParty;
	RWanNdisClientCharacteristics.ClCallConnectedHandler = RWanNdisCallConnected;
#if 1
	RWanNdisClientCharacteristics.ClRequestHandler = RWanNdisCoRequest;
	RWanNdisClientCharacteristics.ClRequestCompleteHandler = RWanNdisCoRequestComplete;
#endif

	NdisRegisterProtocol(
		&Status,
		&(pRWanGlobal->ProtocolHandle),
		&RWanNdisProtocolCharacteristics,
		sizeof(RWanNdisProtocolCharacteristics)
		);
	
	if (Status != NDIS_STATUS_SUCCESS)
	{
		return (Status);
	}

#if DBG
	if (RWanSkipAll)
	{
		RWANDEBUGP(DL_FATAL, DC_WILDCARD,
				("Aborting DriverEntry\n"));

		NdisDeregisterProtocol(
			&Status,
			pRWanGlobal->ProtocolHandle
			);

		return (STATUS_UNSUCCESSFUL);
	}
#endif // DBG

	//
	//  Tell all media-specific modules to initialize.
	//
	RWanStatus = RWanInitMediaSpecific();

	if (RWanStatus != RWAN_STATUS_SUCCESS)
	{
		NdisDeregisterProtocol(
			&Status,
			pRWanGlobal->ProtocolHandle
			);

		return (STATUS_UNSUCCESSFUL);
	}


#if !BINARY_COMPATIBLE
	//
	//  Initialize the Driver Object.
	//
	pDriverObject->DriverUnload = RWanUnload;
	pDriverObject->FastIoDispatch = NULL;

	for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
	{
		pDriverObject->MajorFunction[i] = RWanDispatch;
	}

	pDriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
		RWanDispatchInternalDeviceControl;

#endif // !BINARY_COMPATIBLE


	return (STATUS_SUCCESS);

}



VOID
RWanUnload(
	IN	PDRIVER_OBJECT				pDriverObject
	)
/*++

Routine Description:

	This is called by the system prior to unloading us. Undo everything
	we did in DriverEntry.

Arguments:

	pDriverObject	- Pointer to the driver object representing us.

Return Value:

	None

--*/
{
#if DBG
	RWanDebugLevel = DL_EXTRA_LOUD;
	RWanDebugComp = DC_WILDCARD;
#endif

	RWANDEBUGP(DC_DISPATCH, DL_INFO,
			("RWanUnload entered: RWanGlobals at x%x\n", &RWanGlobals));

	RWanUnloadProtocol();

	RWANDEBUGP(DC_DISPATCH, DL_INFO,
			("RWanUnload exiting\n"));
}




VOID
RWanUnloadProtocol(
	VOID
	)
/*++

Routine Description:

	Unloads the Raw WAN protocol module. We unbind from all adapters,
	and shut down all media specific modules.

Arguments:

	None

Return Value:

	None

--*/
{
	NDIS_STATUS					Status;
	PRWAN_NDIS_ADAPTER			pAdapter;
#if DBG
	RWAN_IRQL					EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	RWAN_ACQUIRE_GLOBAL_LOCK();

	if (pRWanGlobal->UnloadDone)
	{
		RWANDEBUGP(DL_INFO, DC_WILDCARD,
			("UnloadProtocol: already done!\n"));
		RWAN_RELEASE_GLOBAL_LOCK();
		return;
	}

	pRWanGlobal->UnloadDone = TRUE;

#if 0
	//
	//  Commented out because of an NDIS change: if we have unclosed
	//  adapter bindings at this time, NDIS will call our Unbind
	//  handler for each of these, when we call NdisDeregisterProtocol
	//  below.
	//

	while (pRWanGlobal->AdapterCount != 0)
	{
		RWAN_ASSERT (!RWAN_IS_LIST_EMPTY(&pRWanGlobal->AdapterList));

		pAdapter = CONTAINING_RECORD(pRWanGlobal->AdapterList.Flink,
									 RWAN_NDIS_ADAPTER,
									 AdapterLink);

		RWAN_STRUCT_ASSERT(pAdapter, nad);

		RWAN_RELEASE_GLOBAL_LOCK();

		RWanNdisUnbindAdapter(
				&Status,
				(NDIS_HANDLE)pAdapter,
				NULL	// No UnbindContext implies don't complete NdisUnbindAdapter
				);

		if (Status == NDIS_STATUS_PENDING)
		{
			//
			//  Wait for the unbind to complete.
			//
			(VOID)RWAN_WAIT_ON_EVENT_STRUCT(&pRWanGlobal->Event);
		}

		RWAN_ACQUIRE_GLOBAL_LOCK();
	}
#endif // 0

	RWAN_RELEASE_GLOBAL_LOCK();

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	RWANDEBUGP(DL_FATAL, DC_DISPATCH,
			("RWanUnloadProtocol: will deregister protocol now\n"));

	NdisDeregisterProtocol(
			&Status,
			pRWanGlobal->ProtocolHandle
			);

	RWANDEBUGP(DL_FATAL, DC_DISPATCH,
		("UnloadProtocol: dereg protocol done\n"));

	RWanDeinitGlobals();

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	RWanShutdownMediaSpecific();

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
#if DBG
	RWanAuditShutdown();
#endif // DBG

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
}




NTSTATUS
RWanDispatch(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp
	)
/*++

Routine Description:

	System entry point for all IRPs dispatched to Raw WAN device objects.

Arguments:

	pDeviceObject	- Points to a device object created by RawWan. This
					  device object identifies a supported Winsock 2 triple
					  <Address Family, Type, Proto>.
	pIrp			- Pointer to the IRP

Return Value:

	NTSTATUS - STATUS_SUCCESS for immediate requests (such as create) that
	we successfully process, STATUS_PENDING for queued IRPs, and STATUS_XXX
	error codes for any failures.

--*/
{
	PIO_STACK_LOCATION				pIrpSp;
	NTSTATUS						Status;
#if DBG
	RWAN_IRQL						EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	pIrp->IoStatus.Information = 0;

	RWAN_ASSERT(pIrpSp->MajorFunction != IRP_MJ_INTERNAL_DEVICE_CONTROL);


	switch (pIrpSp->MajorFunction)
	{
		case IRP_MJ_CREATE:

			Status = RWanCreate(pDeviceObject, pIrp, pIrpSp);
			break;

		case IRP_MJ_CLEANUP:

			Status = RWanCleanup(pDeviceObject, pIrp, pIrpSp);
			break;
		
		case IRP_MJ_CLOSE:

			Status = RWanClose(pDeviceObject, pIrp, pIrpSp);
			break;
		
		case IRP_MJ_DEVICE_CONTROL:

			Status = TdiMapUserRequest(pDeviceObject, pIrp, pIrpSp);
			//
			//  TBD - get rid of the call to TdiMapUserRequest - AFD will be
			//  fixed so that we shouldn't see TDI commands come this way.
			//

			if (Status == STATUS_SUCCESS)
			{
				if (pIrpSp->MinorFunction == TDI_ASSOCIATE_ADDRESS ||
					pIrpSp->MinorFunction == TDI_DISASSOCIATE_ADDRESS)
				{
					return (RWanDispatchInternalDeviceControl(pDeviceObject, pIrp));
				}
				else
				{
					Status = STATUS_ACCESS_DENIED;
				}
			}
			else
			{
				return (RWanDispatchPrivateDeviceControl(pIrp, pIrpSp));
			}
			break;
		
		case IRP_MJ_READ:
		case IRP_MJ_WRITE:
		default:

			RWANDEBUGP(DL_WARN, DC_DISPATCH,
					("RWanDispatch: Unknown MajorFunction x%x\n", pIrpSp->MajorFunction));
			Status = STATUS_INVALID_DEVICE_REQUEST;
			break;
	}


	RWAN_ASSERT(Status != TDI_PENDING);

	RWAN_COMPLETE_IRP(pIrp, Status, 0);

	RWANDEBUGP(DL_VERY_LOUD, DC_DISPATCH,
			("RWanDispatch: pIrp x%x, MajorFunc %d, returning Status x%x, Info %d\n",
					pIrp, pIrpSp->MajorFunction, Status, pIrp->IoStatus.Information));

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	return (Status);
}




NTSTATUS
RWanCreate(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	)
/*++

Routine Description:

	This is called when a TDI client calls CreateFile. We allocate an
	ENDPOINT structure as our context for this endpoint. Based on
	parameters in the IRP, this is either an Address object, Connection
	object, or a Control channel.

Arguments:

	pDeviceObject	- Identifies the protocol being CreateFile'd
	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - STATUS_SUCCESS if we create the endpoint successfully,
	STATUS_INSUFFICIENT_RESOURCES if we fail to allocate, and
	STATUS_INVALID_PARAMETER if we find any parameter incorrect.

--*/
{
	NTSTATUS								Status;
	FILE_FULL_EA_INFORMATION *				pEa;
	FILE_FULL_EA_INFORMATION UNALIGNED *	pTargetEa;

	//
	//  Device being accessed.
	//
	PRWAN_DEVICE_OBJECT						pRWanDevice;

	//
	//  Endpoint to represent this object creation.
	//
	PRWAN_ENDPOINT							pEndpoint;

	//
	//  TDI Request to be passed down to our TDI layer.
	//
	TDI_REQUEST								TdiRequest;

	//
	//  Parameters to be passed down to our TDI layer.
	//
	UINT									Protocol;
	UCHAR									OptionsBuffer[3];
	PUCHAR									pOptions;



	PAGED_CODE();

	//
	//  Initialize.
	//
	pEndpoint = NULL_PRWAN_ENDPOINT;

	do
	{
		//
		//  Locate the TDI Protocol being opened.
		//
		pRWanDevice = *(PRWAN_DEVICE_OBJECT *)(pDeviceObject->DeviceExtension);

		if (pRWanDevice == NULL)
		{
			Status = STATUS_NO_SUCH_DEVICE;
			break;
		}

		//
		//  Allocate and initialize an Endpoint to represent
		//  this newly created object.
		//
		RWAN_ALLOC_MEM(pEndpoint, RWAN_ENDPOINT, sizeof(RWAN_ENDPOINT));

		if (pEndpoint == NULL_PRWAN_ENDPOINT)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		RWAN_ZERO_MEM(pEndpoint, sizeof(RWAN_ENDPOINT));

		RWAN_SET_SIGNATURE(pEndpoint, nep);

		pEndpoint->RefCount = 1;
		pEndpoint->bCancelIrps = FALSE;
		KeInitializeEvent(&pEndpoint->CleanupEvent, SynchronizationEvent, FALSE);
		pEndpoint->pProtocol = pRWanDevice->pProtocol;

		RWAN_EP_DBGLOG_SET_SIGNATURE(pEndpoint);

		pEa = (PFILE_FULL_EA_INFORMATION)pIrp->AssociatedIrp.SystemBuffer;

		//
		//  See if this is a Control Channel.
		//
		if (!pEa)
		{
			RWANDEBUGP(DL_LOUD, DC_DISPATCH,
					("RWanCreate: pIrp x%x, File obj x%x, Control Channel\n",
						pIrp, pIrpSp->FileObject));

			RWAN_ASSERT(pRWanDevice->pProtocol);

			pEndpoint->Handle.ControlChannel = pRWanDevice->pProtocol;
			pIrpSp->FileObject->FsContext = pEndpoint;
			pIrpSp->FileObject->FsContext2 = (PVOID)TDI_CONTROL_CHANNEL_FILE;

			RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'CCrC', 0, 0);

			Status = STATUS_SUCCESS;
			break;
		}

		//
		//  See if this is an Address Object.
		//

		pTargetEa = RWanFindEa(
						pEa,
						TdiTransportAddress,
						TDI_TRANSPORT_ADDRESS_LENGTH
						);
	
		if (pTargetEa != NULL)
		{
			RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'OArC', 0, 0);

			if (pTargetEa->EaValueLength < sizeof(TRANSPORT_ADDRESS))
			{
				Status = STATUS_INVALID_PARAMETER;
				break;
			}

			if (!pRWanDevice->pProtocol->bAllowAddressObjects)
			{
				Status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}

			Protocol = pRWanDevice->pProtocol->SockProtocol;
			pOptions = OptionsBuffer;

			if ((pIrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
				(pIrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE))
			{
				*pOptions = TDI_ADDRESS_OPTION_REUSE;
				pOptions++;
			}

			*pOptions = TDI_OPTION_EOL;

			//
			//  Call our TDI entry point.
			//
			Status = RWanTdiOpenAddress(
							&TdiRequest,
							(TRANSPORT_ADDRESS UNALIGNED *)
								&(pTargetEa->EaName[pTargetEa->EaNameLength + 1]),
							pTargetEa->EaValueLength,
							Protocol,
							OptionsBuffer
							);

			if (NT_SUCCESS(Status))
			{
				pEndpoint->Handle.AddressHandle = TdiRequest.Handle.AddressHandle;
				pIrpSp->FileObject->FsContext = pEndpoint;
				pIrpSp->FileObject->FsContext2 = (PVOID)TDI_TRANSPORT_ADDRESS_FILE;
			}

			break;
		}

		//
		//  See if this is a Connection Object.
		//
		pTargetEa = RWanFindEa(
						pEa,
						TdiConnectionContext,
						TDI_CONNECTION_CONTEXT_LENGTH
						);

		if (pTargetEa != NULL)
		{
			RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'OCrC', 0, 0);

			if (pTargetEa->EaValueLength < sizeof(CONNECTION_CONTEXT))
			{
				Status = STATUS_INVALID_PARAMETER;
				break;
			}

			if (!pRWanDevice->pProtocol->bAllowConnObjects)
			{
				Status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}

			//
			//  Call our TDI entry point for opening a Connection object.
			//
			Status = RWanTdiOpenConnection(
							&TdiRequest,
							*((CONNECTION_CONTEXT UNALIGNED *)
								&(pTargetEa->EaName[pTargetEa->EaNameLength + 1]))
							);

			if (NT_SUCCESS(Status))
			{
#if DBG
				pEndpoint->pConnObject = RWanTdiDbgGetConnObject(
											TdiRequest.Handle.ConnectionContext
											);
#endif
				pEndpoint->Handle.ConnectionContext = TdiRequest.Handle.ConnectionContext;
				pIrpSp->FileObject->FsContext = pEndpoint;
				pIrpSp->FileObject->FsContext2 = (PVOID)TDI_CONNECTION_FILE;
			}

			break;

		}

		Status = STATUS_INVALID_DEVICE_REQUEST;
		break;
	}
	while (FALSE);

	
	if (Status != STATUS_SUCCESS)
	{
		//
		//  Clean up.
		//
		if (pEndpoint != NULL)
		{
			RWAN_FREE_MEM(pEndpoint);
			pEndpoint = NULL;
		}
	}

	RWANDEBUGP(DL_VERY_LOUD, DC_DISPATCH,
			("RWanCreate: pIrp x%x, pEndpoint x%x, Status x%x\n",
				pIrp, pEndpoint, Status));

	return (Status);
}




NTSTATUS
RWanCleanup(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Called to process an MJ_CLEANUP IRP. All outstanding IRPs are cancelled
	by calling the appropriate close routine for the object.

	We block until all outstanding IRPs are completed.

Arguments:

	pDeviceObject	- Not used
	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - this is the final clean-up status.

--*/
{
	RWAN_IRQL				OldIrql;
	PIRP					pCancelIrp;
	PRWAN_ENDPOINT			pEndpoint;
	TDI_REQUEST				TdiRequest;
	NTSTATUS				Status;

	UNREFERENCED_PARAMETER(pDeviceObject);

	pEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;

	RWAN_STRUCT_ASSERT(pEndpoint, nep);


	IoAcquireCancelSpinLock(&OldIrql);

	pEndpoint->bCancelIrps = TRUE;
	KeResetEvent(&(pEndpoint->CleanupEvent));

	RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'ealC', pIrp, pEndpoint->RefCount);

	IoReleaseCancelSpinLock(OldIrql);


	//
	//  Prepare a Close request for the TDI layer.
	//
	TdiRequest.RequestNotifyObject = RWanCloseObjectComplete;
	TdiRequest.RequestContext = pIrp;

	switch ((INT)PtrToUint(pIrpSp->FileObject->FsContext2))
	{
		case TDI_TRANSPORT_ADDRESS_FILE:

			TdiRequest.Handle.AddressHandle = pEndpoint->Handle.AddressHandle;
			Status = RWanTdiCloseAddress(&TdiRequest);
			break;

		case TDI_CONNECTION_FILE:

			TdiRequest.Handle.ConnectionContext = pEndpoint->Handle.ConnectionContext;
			Status = RWanTdiCloseConnection(&TdiRequest);
			break;

		case TDI_CONTROL_CHANNEL_FILE:

			Status = STATUS_SUCCESS;
			break;

		default:

			RWAN_ASSERT(FALSE);

			IoAcquireCancelSpinLock(&OldIrql);
			pEndpoint->bCancelIrps = FALSE;
			IoReleaseCancelSpinLock(OldIrql);

			return (STATUS_INVALID_PARAMETER);
	}

	if (Status != TDI_PENDING)
	{
		RWanCloseObjectComplete(pIrp, Status, 0);
	}

	//
	//  Wait until all IRPs are completed.
	//
	Status = KeWaitForSingleObject(
					&(pEndpoint->CleanupEvent),
					UserRequest,
					KernelMode,
					FALSE,
					NULL
					);

	RWAN_ASSERT(NT_SUCCESS(Status));

	RWANDEBUGP(DL_VERY_LOUD, DC_DISPATCH,
			("RWanCleanup: pIrp x%x, Context2 %d, pEndpoint x%x, returning Status x%x\n",
				pIrp, 
				(INT)PtrToUint(pIrpSp->FileObject->FsContext2),
				pEndpoint,
				pIrp->IoStatus.Status));

	return (pIrp->IoStatus.Status);
}




NTSTATUS
RWanClose(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Called to destroy an endpoint that was created via MJ_CREATE.
	We'd have already processed and completed an MJ_CLEANUP,
	meaning that there would be no pending IRPs on this endpoint.
	All we need to do is deallocate the endpoint.

Arguments:

	pDeviceObject	- Identifies the protocol (not used)
	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NT_STATUS - always STATUS_SUCCESS

--*/
{
	PRWAN_ENDPOINT				pEndpoint;
	KIRQL						OldIrql;

	UNREFERENCED_PARAMETER(pDeviceObject);

	pEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pEndpoint, nep);

	RWANDEBUGP(DL_LOUD, DC_DISPATCH,
			("RWanClose: pIrp x%x, pEndpoint x%x\n", pIrp, pEndpoint));

	RWAN_FREE_MEM(pEndpoint);

	return (STATUS_SUCCESS);

}




NTSTATUS
RWanDispatchInternalDeviceControl(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp
	)
/*++

Routine Description:

	Called to handle MJ_DEVICE_CONTROL IRPs sent to us. These IRPs
	carry TDI primitives (e.g. CONNECT, DISCONNECT, SEND, RECEIVE).
	We call the appropriate TDI routine to handle the specified
	primitive.

Arguments:

	pDeviceObject	- Identifies the protocol (Not used here)
	pIrp			- Pointer to IRP

Return Value:

	NTSTATUS - this is STATUS_PENDING if the IRP was successfully
	queued for processing, STATUS_NOT_IMPLEMENTED for unsupported
	TDI commands, and STATUS_INVALID_DEVICE_REQUEST for unknown
	commands.

--*/
{
	PRWAN_ENDPOINT				pEndpoint;
	KIRQL						OldIrql;
	PIO_STACK_LOCATION			pIrpSp;
	NTSTATUS					Status;
	BOOLEAN						bDone;
#if DBG
	RWAN_IRQL					EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	UNREFERENCED_PARAMETER(pDeviceObject);

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

	pEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pEndpoint, nep);

	RWANDEBUGP(DL_VERY_LOUD, DC_DISPATCH,
			("RWanDispatchInternalDevCtl: pIrp x%x, pIrpSp x%x, pEndpoint x%x, Ctx2 %d\n",
				pIrp, pIrpSp, pEndpoint,
				(INT)PtrToUint(pIrpSp->FileObject->FsContext2)));

	do
	{
		if (((INT)PtrToUint(pIrpSp->FileObject->FsContext2)) == TDI_CONNECTION_FILE)
		{
			if (pIrpSp->MinorFunction == TDI_SEND)
			{
				RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'dneS', 0, 0);
	
				Status = RWanSendData(pIrp, pIrpSp);
				break;
			}

			if (pIrpSp->MinorFunction == TDI_RECEIVE)
			{
				RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'vceR', 0, 0);
	
				Status = RWanReceiveData(pIrp, pIrpSp);
				break;
			}

			bDone = TRUE;

			switch (pIrpSp->MinorFunction)
			{
				case TDI_ASSOCIATE_ADDRESS:

					RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'AssA', pIrp, pEndpoint->RefCount);
	
					Status = RWanAssociateAddress(pIrp, pIrpSp);
					RWAN_COMPLETE_IRP(pIrp, Status, 0);
					break;

				case TDI_DISASSOCIATE_ADDRESS:
			
					RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'AsiD', pIrp, pEndpoint->RefCount);

					Status = RWanDisassociateAddress(pIrp, pIrpSp);
					break;

				case TDI_CONNECT:
			
					RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'nnoC', pIrp, pEndpoint->RefCount);

					Status = RWanConnect(pIrp, pIrpSp);
					break;

				case TDI_DISCONNECT:

					RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'csiD', pIrp, pEndpoint->RefCount);

					Status = RWanDisconnect(pIrp, pIrpSp);
					break;

				case TDI_LISTEN:

					RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'tsiL', pIrp, pEndpoint->RefCount);

					Status = RWanListen(pIrp, pIrpSp);
					break;

				case TDI_ACCEPT:

					RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'eccA', pIrp, pEndpoint->RefCount);

					Status = RWanAccept(pIrp, pIrpSp);
					break;

				default:
					bDone = FALSE;

#if 0
	// Allow TDI_QUERY_INFORMATION on Conn endpoints to fall through
					RWANDEBUGP(DL_WARN, DC_DISPATCH,
						("RWanDispatchInternalDevCtl: pIrp x%x, pIrpSp x%x, unknown func x%x\n",
							pIrp, pIrpSp, pIrpSp->MinorFunction));

					Status = STATUS_INVALID_DEVICE_REQUEST;

					RWAN_COMPLETE_IRP(pIrp, Status, 0);
#else
					bDone = FALSE;
#endif
					break;
			}

			if (bDone)
			{
				break;
			}
			//
			//  else fall through - may be something common to all types
			//  of endpoints.
			//

		}
		else if (((INT)PtrToUint(pIrpSp->FileObject->FsContext2)) == TDI_TRANSPORT_ADDRESS_FILE)
		{
			if (pIrpSp->MinorFunction == TDI_SET_EVENT_HANDLER)
			{
				RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'EteS', 0, 0);

				Status = RWanSetEventHandler(pIrp, pIrpSp);

				RWAN_COMPLETE_IRP(pIrp, Status, 0);

				break;
			}
		}

		RWAN_ASSERT(
			(((INT)PtrToUint(pIrpSp->FileObject->FsContext2)) == TDI_TRANSPORT_ADDRESS_FILE)
			||
			(((INT)PtrToUint(pIrpSp->FileObject->FsContext2)) == TDI_CONNECTION_FILE)
			||
			(((INT)PtrToUint(pIrpSp->FileObject->FsContext2)) == TDI_CONTROL_CHANNEL_FILE)
			);

		//
		//  Check if this is a function common to all types of endpoints.
		//
		switch (pIrpSp->MinorFunction)
		{
			case TDI_QUERY_INFORMATION:

				RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'IyrQ', 0, 0);

				Status = RWanQueryInformation(pIrp, pIrpSp);
				break;
			
			case TDI_SET_INFORMATION:
			case TDI_ACTION:

				RWANDEBUGP(DL_INFO, DC_DISPATCH,
						("RWanDispatchInternalDevCtl: SET_INFO/ACTION not supported\n"));

				RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'IteS', 0, 0);

				Status = STATUS_NOT_IMPLEMENTED;
				RWAN_COMPLETE_IRP(pIrp, Status, 0);
				break;
			
			default:
			
				Status = STATUS_INVALID_DEVICE_REQUEST;
				RWAN_COMPLETE_IRP(pIrp, Status, 0);
				break;
		}

		break;
	}
	while (FALSE);

	RWANDEBUGP(DL_VERY_LOUD, DC_DISPATCH,
			("RWanDispatchInternalDevCtl: pIrp x%x, pIrpSp x%x, Maj/Min %d/%d, Status x%x\n",
					pIrp, pIrpSp, pIrpSp->MajorFunction, pIrpSp->MinorFunction, Status));

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
	return (Status);
}


NTSTATUS
RWanDispatchPrivateDeviceControl(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Called to handle MJ_DEVICE_CONTROL IRPs sent to us that contain
	non-TDI primitives.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - this is STATUS_PENDING if the IRP was successfully
	queued for processing, STATUS_NOT_IMPLEMENTED for unsupported
	commands, and STATUS_INVALID_DEVICE_REQUEST for unknown
	commands.

--*/
{
	PRWAN_ENDPOINT				pEndpoint;
	KIRQL						OldIrql;
	RWAN_STATUS					RWanStatus;
	NTSTATUS					Status;
	PRWAN_NDIS_AF_CHARS			pAfChars;
	PVOID						pInputBuffer;
	PVOID						pOutputBuffer;
	ULONG						InputBufferLength;
	ULONG						OutputBufferLength;

	PAGED_CODE();

	pEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pEndpoint, nep);

	//
	//  Initialize.
	//
	pIrp->IoStatus.Information = 0;
	Status = STATUS_INVALID_DEVICE_REQUEST;

	//
	//  Get some parameters from the IRP.
	//
	pInputBuffer = pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
	pOutputBuffer = pIrp->UserBuffer;

	InputBufferLength = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
	OutputBufferLength = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

	RWANDEBUGP(DL_INFO, DC_DISPATCH,
			("PrivateDevCtl: pEndpoint x%x, CtlCode x%x, InBuf x%x/%d, OutBuf x%x/%d\n",
				pEndpoint,
				pIrpSp->Parameters.DeviceIoControl.IoControlCode,
				pInputBuffer,
				InputBufferLength,
				pOutputBuffer,
				OutputBufferLength));

	//
	//  Validate the pointers we've got.
	//
	if (InputBufferLength)
	{
		try
		{
			if (pIrp->RequestorMode != KernelMode)
			{
				ProbeForRead(
					pInputBuffer,
					InputBufferLength,
					sizeof(ULONG)
					);
			}
		}
		except(EXCEPTION_EXECUTE_HANDLER)
		{
			RWAN_COMPLETE_IRP(pIrp, STATUS_INVALID_DEVICE_REQUEST, 0);
			return (STATUS_INVALID_DEVICE_REQUEST);
		}
	}

	if (OutputBufferLength)
	{
		try
		{
			if (pIrp->RequestorMode != KernelMode)
			{
				ProbeForWrite(
					pOutputBuffer,
					OutputBufferLength,
					sizeof(ULONG)
					);
			}
		}
		except(EXCEPTION_EXECUTE_HANDLER)
		{
			RWAN_COMPLETE_IRP(pIrp, STATUS_INVALID_DEVICE_REQUEST, 0);
			return (STATUS_INVALID_DEVICE_REQUEST);
		}
	}
			
	switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode)
	{
		case IOCTL_RWAN_GENERIC_GLOBAL_QUERY:
		case IOCTL_RWAN_GENERIC_GLOBAL_SET:
			Status = STATUS_NOT_IMPLEMENTED;
			break;
		
		case IOCTL_RWAN_GENERIC_CONN_HANDLE_QUERY:

			if (((INT)PtrToUint(pIrpSp->FileObject->FsContext2)) != TDI_CONNECTION_FILE)
			{
				Status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}

			RWanStatus = RWanHandleGenericConnQryInfo(
							pEndpoint->Handle.ConnectionContext,
							pInputBuffer,
							InputBufferLength,
							pOutputBuffer,
							&OutputBufferLength
							);

			Status = RWanToNTStatus(RWanStatus);
			if (Status != STATUS_SUCCESS)
			{
				OutputBufferLength = 0;
			}

			break;

		case IOCTL_RWAN_GENERIC_ADDR_HANDLE_QUERY:
		case IOCTL_RWAN_GENERIC_CONN_HANDLE_SET:
			Status = STATUS_NOT_IMPLEMENTED;
			break;

		case IOCTL_RWAN_GENERIC_ADDR_HANDLE_SET:

			if (((INT)PtrToUint(pIrpSp->FileObject->FsContext2)) != TDI_TRANSPORT_ADDRESS_FILE)
			{
				Status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}

			RWanStatus = RWanHandleGenericAddrSetInfo(
							pEndpoint->Handle.AddressHandle,
							pInputBuffer,
							InputBufferLength
							);

			Status = RWanToNTStatus(RWanStatus);
			OutputBufferLength = 0;

			break;

		case IOCTL_RWAN_MEDIA_SPECIFIC_GLOBAL_QUERY:
			//
			//  Get the media-specific module's QueryInfo handler.
			//
			pAfChars = &(pEndpoint->pProtocol->pAfInfo->AfChars);

			if (pAfChars->pAfSpQueryGlobalInfo != NULL)
			{
				RWanStatus = (*pAfChars->pAfSpQueryGlobalInfo)(
									pEndpoint->pProtocol->pAfInfo->AfSpContext,
									pInputBuffer,
									InputBufferLength,
									pOutputBuffer,
									&OutputBufferLength
									);
				
				Status = RWanToNTStatus(RWanStatus);
				if (Status != STATUS_SUCCESS)
				{
					OutputBufferLength = 0;
				}
			}
			else
			{
				Status = STATUS_NOT_IMPLEMENTED;
			}
			break;
		
		case IOCTL_RWAN_MEDIA_SPECIFIC_GLOBAL_SET:
			//
			//  Get the media-specific module's SetInfo handler.
			//
			pAfChars = &(pEndpoint->pProtocol->pAfInfo->AfChars);

			if (pAfChars->pAfSpSetGlobalInfo != NULL)
			{
				RWanStatus = (*pAfChars->pAfSpSetGlobalInfo)(
									pEndpoint->pProtocol->pAfInfo->AfSpContext,
									pInputBuffer,
									InputBufferLength
									);
				
				Status = RWanToNTStatus(RWanStatus);
			}
			else
			{
				Status = STATUS_NOT_IMPLEMENTED;
			}

			OutputBufferLength = 0;
			break;

		case IOCTL_RWAN_MEDIA_SPECIFIC_CONN_HANDLE_QUERY:

			if ((INT)PtrToUint(pIrpSp->FileObject->FsContext2) != TDI_CONNECTION_FILE)
			{
				Status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}

			RWanStatus = RWanHandleMediaSpecificConnQryInfo(
							pEndpoint->Handle.ConnectionContext,
							pInputBuffer,
							InputBufferLength,
							pOutputBuffer,
							&OutputBufferLength
							);

			Status = RWanToNTStatus(RWanStatus);

			break;

		case IOCTL_RWAN_MEDIA_SPECIFIC_ADDR_HANDLE_QUERY:
		case IOCTL_RWAN_MEDIA_SPECIFIC_CONN_HANDLE_SET:
			Status = STATUS_NOT_IMPLEMENTED;
			break;

		case IOCTL_RWAN_MEDIA_SPECIFIC_ADDR_HANDLE_SET:

			if ((INT)PtrToUint(pIrpSp->FileObject->FsContext2) != TDI_TRANSPORT_ADDRESS_FILE)
			{
				Status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}

			RWanStatus = RWanHandleMediaSpecificAddrSetInfo(
							pEndpoint->Handle.AddressHandle,
							pInputBuffer,
							InputBufferLength
							);

			Status = RWanToNTStatus(RWanStatus);
			OutputBufferLength = 0;

			break;

		default:

			OutputBufferLength = 0;
			Status = STATUS_INVALID_DEVICE_REQUEST;
			break;
	}

	RWAN_ASSERT(Status != STATUS_PENDING);

	RWAN_COMPLETE_IRP(pIrp, Status, OutputBufferLength);
	return (Status);
}



FILE_FULL_EA_INFORMATION UNALIGNED *
RWanFindEa(
	IN	FILE_FULL_EA_INFORMATION *	pStartEa,
	IN	CHAR *						pTargetName,
	IN	USHORT						TargetNameLength
	)
/*++

Routine Description:

	Searches for a target name in an Extended Attribute list
	and returns it.

Arguments:

	pStartEa		- Start of the attribute list
	pTargetName		- Pointer to name to look for
	TargetNameLength- Length of name

Return Value:

	Pointer to attribute matching the target name, if found;
	NULL otherwise.

--*/
{
	FILE_FULL_EA_INFORMATION UNALIGNED *	pEa;
	FILE_FULL_EA_INFORMATION UNALIGNED *	pNextEa;
	BOOLEAN									Found;
	USHORT									i;

	PAGED_CODE();

	pNextEa = pStartEa;
	Found = FALSE;

	do	
	{
		pEa = pNextEa;
		pNextEa = (FILE_FULL_EA_INFORMATION UNALIGNED *)
						((PUCHAR)pNextEa + pNextEa->NextEntryOffset);

		if (pEa->EaNameLength == TargetNameLength)
		{
			for (i = 0; i < TargetNameLength; i++)
			{
				if (pEa->EaName[i] != pTargetName[i])
				{
					break;
				}
			}

			if (i == TargetNameLength)
			{
				Found = TRUE;
				break;
			}
		}
	}
	while (pEa->NextEntryOffset != 0);

	return (Found? pEa: NULL);

}




NTSTATUS
RWanSendData(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Convert an IRP containing a TDI_SEND request to a call to our TDI
	dispatch routine for sends. We retain enough context to be able
	to complete the IRP when the send completes.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - STATUS_PENDING if we managed to queue the send successfully,
	STATUS_CANCELLED if the IRP was cancelled.
	STATUS_SUCCESS if the send completed successfully, immediately.

--*/
{
	PRWAN_ENDPOINT				pEndpoint;
	KIRQL						OldIrql;
	PTDI_REQUEST_KERNEL_SEND	pSendRequest;
	TDI_REQUEST					TdiRequest;
	NTSTATUS					Status;


	pEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pEndpoint, nep);

	pSendRequest = (PTDI_REQUEST_KERNEL_SEND) &(pIrpSp->Parameters);

	//
	//  Prepare a TDI Send request.
	//
	TdiRequest.Handle.ConnectionContext = pEndpoint->Handle.ConnectionContext;
	TdiRequest.RequestNotifyObject = (PVOID) RWanDataRequestComplete;
	TdiRequest.RequestContext = (PVOID) pIrp;

	IoAcquireCancelSpinLock(&OldIrql);

	if (!pIrp->Cancel)
	{
		//
		//  The IRP hasn't been cancelled. Set it up so that we are
		//  informed if it does get cancelled later.
		//
		IoMarkIrpPending(pIrp);
		IoSetCancelRoutine(pIrp, RWanCancelRequest);

		RWAN_INCR_EP_REF_CNT(pEndpoint, SendIncr);		// Send ref

		RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'DneS', pIrp, pEndpoint->RefCount);

		IoReleaseCancelSpinLock(OldIrql);

		Status = RWanTdiSendData(
					&TdiRequest,
					(USHORT)pSendRequest->SendFlags,
					pSendRequest->SendLength,
					(PNDIS_BUFFER) pIrp->MdlAddress
					);

		if (Status != TDI_PENDING)
		{
			//
			//  The Send either completed immediately, or failed.
			//
			pIrpSp->Control &= ~SL_PENDING_RETURNED;

			if (Status == TDI_SUCCESS)
			{
				//
				//  Examples of immediate successful completion:
				//  - A zero length send
				//
				RWanDataRequestComplete(pIrp, Status, pSendRequest->SendLength);
			}
			else
			{
				//
				//  The Send failed, could be a resource problem.
				//

				RWANDEBUGP(DL_INFO, DC_DATA_TX,
						("RWanSendData: pIrp x%x, pEndpoint x%x, TDI send fail: x%x\n",
							pIrp, pEndpoint, Status));

				RWanDataRequestComplete(pIrp, Status, 0);
			}
		}
	}
	else
	{
		//
		//  The IRP has been cancelled before it could reach us.
		//
		IoReleaseCancelSpinLock(OldIrql);

		Status = STATUS_CANCELLED;
		RWAN_COMPLETE_IRP(pIrp, Status, 0);
	}


	RWANDEBUGP(DL_LOUD, DC_DATA_TX,
			("RWanSendData: pIrp x%x, pEndpoint x%x, ret Status x%x\n",
				pIrp, pEndpoint, Status));

	return (Status);

}




NTSTATUS
RWanReceiveData(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Convert an IRP containing a TDI_RECEIVE request to a call to our TDI
	dispatch routine for receives. We retain enough context to be able
	to complete the IRP when the receive completes.

	The FileObject within the IRP refers to the connection endpoint.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - STATUS_PENDING if we managed to queue the receive successfully,
	STATUS_CANCELLED if the IRP was cancelled.

--*/
{
	PRWAN_ENDPOINT				pEndpoint;
	KIRQL						OldIrql;
	PTDI_REQUEST_KERNEL_RECEIVE	pReceiveRequest;
	TDI_REQUEST					TdiRequest;
	NTSTATUS					Status;


	pEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pEndpoint, nep);

	pReceiveRequest = (PTDI_REQUEST_KERNEL_RECEIVE) &(pIrpSp->Parameters);

	//
	//  Prepare a TDI Receive request.
	//
	TdiRequest.Handle.ConnectionContext = pEndpoint->Handle.ConnectionContext;
	TdiRequest.RequestNotifyObject = (PVOID) RWanDataRequestComplete;
	TdiRequest.RequestContext = (PVOID) pIrp;

	IoAcquireCancelSpinLock(&OldIrql);

	if (!pIrp->Cancel)
	{
		//
		//  The IRP hasn't been cancelled. Set it up so that we are
		//  informed if it does get cancelled later.
		//
		IoMarkIrpPending(pIrp);
		IoSetCancelRoutine(pIrp, RWanCancelRequest);

		RWAN_INCR_EP_REF_CNT(pEndpoint, RecvIncr);		// Receive ref

		RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'DvcR', pIrp, pEndpoint->RefCount);

		IoReleaseCancelSpinLock(OldIrql);

		Status = RWanTdiReceive(
					&TdiRequest,
					(USHORT *) &(pReceiveRequest->ReceiveFlags),
					&(pReceiveRequest->ReceiveLength),
					(PNDIS_BUFFER) pIrp->MdlAddress
					);

		if (Status != TDI_PENDING)
		{
			//
			//  The Receive either completed immediately, or failed.
			//
			pIrpSp->Control &= ~SL_PENDING_RETURNED;

			RWANDEBUGP(DL_WARN, DC_DATA_TX,
					("RWanReceiveData: pIrp x%x, pEndpoint x%x, TDI recv didnt pend: x%x\n",
						pIrp, pEndpoint, Status));

			RWanDataRequestComplete(pIrp, Status, 0);
		}
	}
	else
	{
		//
		//  The IRP has been cancelled before it could reach us.
		//
		IoReleaseCancelSpinLock(OldIrql);

		Status = STATUS_CANCELLED;

		RWAN_COMPLETE_IRP(pIrp, Status, 0);
	}


	RWANDEBUGP(DL_LOUD, DC_DATA_TX,
			("RWanReceiveData: pIrp x%x, pEndpoint x%x, ret Status x%x\n",
				pIrp, pEndpoint, Status));

	return (Status);

}



NTSTATUS
RWanAssociateAddress(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Converts a TDI_ASSOCIATE_ADDRESS IRP to a call to our AssociateAddress
	entry point.

	The FileObject in the IRP refers to the Connection Object, and the
	AddressHandle field within the kernel request refers to the Address
	Object.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - STATUS_SUCCESS if successful, STATUS_XXX error code otherwise.

--*/
{
	PRWAN_ENDPOINT					pConnEndpoint;
	PRWAN_ENDPOINT					pAddrEndpoint;
	PTDI_REQUEST_KERNEL_ASSOCIATE	pAssociateRequest;
	TDI_REQUEST						TdiRequest;
	PFILE_OBJECT					pFileObject;
	NTSTATUS						Status;

	PAGED_CODE();

	pConnEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pConnEndpoint, nep);

	//
	//  Prepare a TDI Associate Request
	//
	TdiRequest.Handle.ConnectionContext = pConnEndpoint->Handle.ConnectionContext;
	pAssociateRequest = (PTDI_REQUEST_KERNEL_ASSOCIATE) &(pIrpSp->Parameters);

	//
	//  Reference the file corresponding to the Address object.
	//  This is just so that it doesn't go away while we're processing
	//  the Associate.
	//
	//  The Address object is identified by its handle buried inside
	//  the Associate request.
	//
	Status = ObReferenceObjectByHandle(
					pAssociateRequest->AddressHandle,
					GENERIC_ALL,
					*IoFileObjectType,
					pIrp->RequestorMode,
					&pFileObject,
					NULL
					);

	if (NT_SUCCESS(Status) &&
		(pFileObject->DeviceObject->DriverObject == pRWanGlobal->pDriverObject))
	{

		//
		//  Found the file object. See if it is an Address object.
		//
		if ((INT)PtrToUint(pFileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE)
		{
			//
			//  Get our endpoint representing this address object.
			//
			pAddrEndpoint = (PRWAN_ENDPOINT) pFileObject->FsContext;
			RWAN_STRUCT_ASSERT(pAddrEndpoint, nep);

			//
			//  Dispatch this to the TDI layer.
			//
			Status = RWanTdiAssociateAddress(
						&TdiRequest,
						pAddrEndpoint->Handle.AddressHandle
						);

			RWAN_ASSERT(Status != TDI_PENDING);

			ObDereferenceObject(pFileObject);

		}
		else
		{
			ObDereferenceObject(pFileObject);

			RWANDEBUGP(DC_ADDRESS, DL_WARN,
					("RWanAssociateAddress: pIrp x%x, pConnEp x%x, bad Context2 %d\n",
						pIrp, pConnEndpoint,
						(INT)PtrToUint(pFileObject->FsContext2)));

			Status = STATUS_INVALID_HANDLE;
		}
	}
	else
	{
		RWANDEBUGP(DL_WARN, DC_ADDRESS,
				("RWanAssociateAddress: pIrp x%x, pConnEp x%x, bad addr handle x%x\n",
						pIrp, pConnEndpoint, pAssociateRequest->AddressHandle));
		//
		//  Clean up properly.
		//
		if (NT_SUCCESS(Status))
		{
			ObDereferenceObject(pFileObject);
			Status = STATUS_INVALID_HANDLE;
		}
	}

	RWANDEBUGP(DL_VERY_LOUD, DC_ADDRESS,
			("RWanAssociateAddress: pIrp x%x, pConnEp x%x, Addr Handle x%x, Status x%x\n",
						pIrp, pConnEndpoint, pAssociateRequest->AddressHandle, Status));

	return (Status);
}




NTSTATUS
RWanDisassociateAddress(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Converts a TDI_DISASSOCIATE_ADDRESS IRP to a call to our DisassociateAddress
	entry point.

	The FileObject in the IRP refers to the Connection Object that is
	to be disassociated.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	None

--*/
{
	PRWAN_ENDPOINT					pConnEndpoint;
	TDI_REQUEST						TdiRequest;
	NTSTATUS						Status;

	PAGED_CODE();

	pConnEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pConnEndpoint, nep);

	//
	//  Prepare a TDI Disassociate Request
	//
	TdiRequest.Handle.ConnectionContext = pConnEndpoint->Handle.ConnectionContext;
	TdiRequest.RequestNotifyObject = (PVOID)RWanRequestComplete;
	TdiRequest.RequestContext = (PVOID)pIrp;

	Status = RWanPrepareIrpForCancel(pConnEndpoint, pIrp, RWanCancelRequest);

	if (NT_SUCCESS(Status))
	{
		Status = RWanTdiDisassociateAddress(&TdiRequest);

		if (Status != TDI_PENDING)
		{
			RWanRequestComplete(pIrp, Status, 0);
			Status = TDI_PENDING;
		}
	}

	RWANDEBUGP(DL_VERY_LOUD, DC_ADDRESS,
			("RWanDisassociateAddr: pIrp x%x, pEndp x%x, Status x%x\n",
				pIrp, pConnEndpoint, Status));

	return (Status);
}




NTSTATUS
RWanConnect(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Convert a TDI Connect IRP to a call to our Connect entry point.

	The FileObject in the IRP refers to the Connection Object on which
	the outgoing call is to be placed.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - STATUS_PENDING if a call was initiated, STATUS_XXX error
	code otherwise.

--*/
{
	PRWAN_ENDPOINT					pConnEndpoint;
	TDI_REQUEST						TdiRequest;
	PTDI_CONNECTION_INFORMATION		pRequestInformation;
	PTDI_CONNECTION_INFORMATION		pReturnInformation;
	PTDI_REQUEST_KERNEL_CONNECT		pConnectRequest;
	NTSTATUS						Status;
	PLARGE_INTEGER					pRequestTimeout;
	LARGE_INTEGER					MillisecondTimeout;
	ULONG							Remainder;


	pConnEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pConnEndpoint, nep);

	//
	// Grab all parameters from the IRP.
	//
	pConnectRequest = (PTDI_REQUEST_KERNEL_CONNECT) &(pIrpSp->Parameters);
	pRequestInformation = pConnectRequest->RequestConnectionInformation;
	pReturnInformation = pConnectRequest->ReturnConnectionInformation;

	//
	//  Prepare a TDI CONNECT Request
	//
	TdiRequest.Handle.ConnectionContext = pConnEndpoint->Handle.ConnectionContext;
	TdiRequest.RequestNotifyObject = (PVOID)RWanRequestComplete;
	TdiRequest.RequestContext = (PVOID)pIrp;

	pRequestTimeout = (PLARGE_INTEGER)pConnectRequest->RequestSpecific;

	if (pRequestTimeout != NULL)
	{
		MillisecondTimeout = RWAN_CONVERT_100NS_TO_MS(*pRequestTimeout, &Remainder);
	}
	else
	{
		MillisecondTimeout.LowPart = 0;
		MillisecondTimeout.HighPart = 0;
	}

	Status = RWanPrepareIrpForCancel(pConnEndpoint, pIrp, RWanCancelRequest);


	if (NT_SUCCESS(Status))
	{
		Status = RWanTdiConnect(
					&TdiRequest,
					((MillisecondTimeout.LowPart != 0)?
						&(MillisecondTimeout.LowPart): NULL),
					pRequestInformation,
					pReturnInformation
					);

		if (Status != TDI_PENDING)
		{
			RWanRequestComplete(pIrp, Status, 0);
			Status = STATUS_PENDING;
		}
	}

	RWANDEBUGP(DL_LOUD, DC_CONNECT,
			("RWanConnect: pIrp x%x, pEndp x%x, Status x%x\n", 
				pIrp, pConnEndpoint, Status));

	return (Status);
}




NTSTATUS
RWanDisconnect(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Convert a TDI Connect IRP to a call to our Connect entry point.

	The FileObject in the IRP refers to the Connection Object hosting
	the connection to be disconnected.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - STATUS_PENDING if a disconnect was initiated, STATUS_XXX error
	code otherwise.

--*/
{
	PRWAN_ENDPOINT					pConnEndpoint;
	TDI_REQUEST						TdiRequest;
	PTDI_CONNECTION_INFORMATION		pRequestInformation;
	PTDI_CONNECTION_INFORMATION		pReturnInformation;
	PTDI_REQUEST_KERNEL_DISCONNECT	pDisconnectRequest;
	NTSTATUS						Status;
	PLARGE_INTEGER					pRequestTimeout;
	LARGE_INTEGER					MillisecondTimeout;
	BOOLEAN							bAbortiveDisconnect;


	pConnEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pConnEndpoint, nep);

	//
	// Grab all parameters from the IRP.
	//
	pDisconnectRequest = (PTDI_REQUEST_KERNEL_DISCONNECT) &(pIrpSp->Parameters);
	pRequestInformation = pDisconnectRequest->RequestConnectionInformation;
	pReturnInformation = pDisconnectRequest->ReturnConnectionInformation;

	//
	//  Prepare a TDI DISCONNECT Request
	//
	TdiRequest.Handle.ConnectionContext = pConnEndpoint->Handle.ConnectionContext;
	TdiRequest.RequestContext = (PVOID)pIrp;

	pRequestTimeout = (PLARGE_INTEGER)pDisconnectRequest->RequestSpecific;

	if (pRequestTimeout != NULL)
	{
		ULONG							Remainder;
		MillisecondTimeout = RWAN_CONVERT_100NS_TO_MS(*pRequestTimeout, &Remainder);
#if 0
		if ((pRequestTimeout->LowPart == -1) &&
			(pRequestTimeout->HighPart == -1))
		{
			MillisecondTimeout.LowPart = pRequestTimeout->LowPart;
			MillisecondTimeout.HighPart = 0;
		}
		else
		{
			MillisecondTimeout.QuadPart = -((*pRequestTimeout).QuadPart);
			MillisecondTimeout = RWAN_CONVERT_100NS_TO_MS(MillisecondTimeout);
		}

		RWAN_ASSERT(MillisecondTimeout.HighPart == 0);
#endif // 0
	}
	else
	{
		MillisecondTimeout.LowPart = 0;
		MillisecondTimeout.HighPart = 0;
	}

	if (pDisconnectRequest->RequestFlags & TDI_DISCONNECT_ABORT)
	{
		//
		//  Use non-generic completion routine for abortive disconnects,
		//  because they cannot be cancelled.
		//
		bAbortiveDisconnect = TRUE;
		IoMarkIrpPending(pIrp);
		TdiRequest.RequestNotifyObject = (PVOID)RWanNonCancellableRequestComplete;

		Status = STATUS_SUCCESS;
	}
	else
	{
		//
		//  Non-abortive disconnect.
		//
		bAbortiveDisconnect = FALSE;
		Status = RWanPrepareIrpForCancel(pConnEndpoint, pIrp, RWanCancelRequest);
		TdiRequest.RequestNotifyObject = (PVOID)RWanRequestComplete;
	}

	if (NT_SUCCESS(Status))
	{
		Status = RWanTdiDisconnect(
					&TdiRequest,
					((MillisecondTimeout.LowPart != 0)?
						&(MillisecondTimeout.LowPart): NULL),
					(USHORT)pDisconnectRequest->RequestFlags,
					pRequestInformation,
					pReturnInformation
					);

		if (Status != TDI_PENDING)
		{
			if (bAbortiveDisconnect)
			{
				RWanNonCancellableRequestComplete(pIrp, Status, 0);
			}
			else
			{
				RWanRequestComplete(pIrp, Status, 0);
			}
			Status = STATUS_PENDING;
		}
	}

	RWANDEBUGP(DL_LOUD, DC_DISCON,
			("RWanDisconnect: pIrp x%x, pEndp x%x, Abortive %d, Status x%x\n", 
				pIrp, pConnEndpoint, (INT)bAbortiveDisconnect, Status));

	return (Status);
}




NTSTATUS
RWanListen(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Convert a TDI Listen IRP to a call to our Listen entry point.

	The FileObject in the IRP refers to the Connection Object on which
	this Listen is posted.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - STATUS_PENDING if a Listen was initiated, STATUS_XXX error
	code otherwise.

--*/
{
	PRWAN_ENDPOINT					pConnEndpoint;
	TDI_REQUEST						TdiRequest;
	PTDI_CONNECTION_INFORMATION		pRequestInformation;
	PTDI_CONNECTION_INFORMATION		pReturnInformation;
	PTDI_REQUEST_KERNEL_LISTEN		pListenRequest;
	NTSTATUS						Status;

	pConnEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pConnEndpoint, nep);

	//
	// Grab all parameters from the IRP.
	//
	pListenRequest = (PTDI_REQUEST_KERNEL_LISTEN) &(pIrpSp->Parameters);
	pRequestInformation = pListenRequest->RequestConnectionInformation;
	pReturnInformation = pListenRequest->ReturnConnectionInformation;

	//
	//  Prepare a TDI LISTEN Request
	//
	TdiRequest.Handle.ConnectionContext = pConnEndpoint->Handle.ConnectionContext;
	TdiRequest.RequestNotifyObject = (PVOID)RWanRequestComplete;
	TdiRequest.RequestContext = (PVOID)pIrp;

	Status = RWanPrepareIrpForCancel(pConnEndpoint, pIrp, RWanCancelRequest);

	if (NT_SUCCESS(Status))
	{
		Status = RWanTdiListen(
					&TdiRequest,
					(USHORT)pListenRequest->RequestFlags,
					pRequestInformation,
					pReturnInformation
					);
		
		if (Status != TDI_PENDING)
		{
			RWanRequestComplete(pIrp, Status, 0);
			Status = STATUS_PENDING;
		}
	}

	RWANDEBUGP(DL_LOUD, DC_CONNECT,
			("RWanListen: pIrp x%x, pEndp x%x, Status x%x\n", 
				pIrp, pConnEndpoint, Status));

	return (Status);
}




NTSTATUS
RWanAccept(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Convert a TDI Accept IRP to a call to our Accept entry point.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - STATUS_PENDING if an Accept was initiated, STATUS_XXX error
	code otherwise.

--*/
{
	PRWAN_ENDPOINT					pConnEndpoint;
	TDI_REQUEST						TdiRequest;
	PTDI_CONNECTION_INFORMATION		pRequestInformation;
	PTDI_CONNECTION_INFORMATION		pReturnInformation;
	PTDI_REQUEST_KERNEL_ACCEPT		pAcceptRequest;
	NTSTATUS						Status;

	pConnEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pConnEndpoint, nep);

	//
	// Grab all parameters from the IRP.
	//
	pAcceptRequest = (PTDI_REQUEST_KERNEL_ACCEPT) &(pIrpSp->Parameters);
	pRequestInformation = pAcceptRequest->RequestConnectionInformation;
	pReturnInformation = pAcceptRequest->ReturnConnectionInformation;

	//
	//  Prepare a TDI ACCEPT Request
	//
	TdiRequest.Handle.ConnectionContext = pConnEndpoint->Handle.ConnectionContext;
	TdiRequest.RequestNotifyObject = (PVOID)RWanRequestComplete;
	TdiRequest.RequestContext = (PVOID)pIrp;

	Status = RWanPrepareIrpForCancel(pConnEndpoint, pIrp, RWanCancelRequest);

	if (NT_SUCCESS(Status))
	{
		Status = RWanTdiAccept(
					&TdiRequest,
					pRequestInformation,
					pReturnInformation
					);
		
		if (Status != TDI_PENDING)
		{
			RWanRequestComplete(pIrp, Status, 0);
			Status = STATUS_PENDING;
		}
	}

	RWANDEBUGP(DL_LOUD, DC_CONNECT,
			("RWanAccept: pIrp x%x, pEndp x%x, Status x%x\n", 
				pIrp, pConnEndpoint, Status));

	return (Status);
}




NTSTATUS
RWanSetEventHandler(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Convert a TDI Set Event Handler IRP to a call to our set event handler
	entry point.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - STATUS_SUCCESS if the request was successful, STATUS_XXX error
	code otherwise.

--*/
{
	PRWAN_ENDPOINT						pEndpoint;
	PTDI_REQUEST_KERNEL_SET_EVENT		pSetEvent;
	NTSTATUS							Status;

	PAGED_CODE();

	pEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pEndpoint, nep);

	pSetEvent = (PTDI_REQUEST_KERNEL_SET_EVENT) &(pIrpSp->Parameters);

	Status = RWanTdiSetEvent(
					pEndpoint->Handle.AddressHandle,
					pSetEvent->EventType,
					pSetEvent->EventHandler,
					pSetEvent->EventContext
					);
	
	RWAN_ASSERT(Status != STATUS_PENDING);

	RWANDEBUGP(DL_LOUD, DC_DISPATCH,
			("RWanSetEventHandler: pIrp x%x, pEndp x%x, Type x%x, Status x%x\n", 
				pIrp, pEndpoint, pSetEvent->EventType, Status));

	return (Status);
}




NTSTATUS
RWanQueryInformation(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Converts a TDI Query Information IRP to a call to the QueryInformation
	TDI entry point.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - this is STATUS_SUCCESS if the query was completed successfully,
	STATUS_PENDING if it will be completed later, STATUS_XXX error code otherwise.

--*/
{
	TDI_REQUEST						TdiRequest;
	NTSTATUS						Status;
	PRWAN_ENDPOINT					pEndpoint;
	PTDI_REQUEST_KERNEL_QUERY_INFORMATION		pQueryInfo;
	UINT							IsConnection;
	UINT							DataSize;

	IsConnection = FALSE;
	DataSize = 0;

	pEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pEndpoint, nep);

	pQueryInfo = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION) &(pIrpSp->Parameters);

	TdiRequest.RequestNotifyObject = RWanDataRequestComplete;
	TdiRequest.RequestContext = pIrp;

	Status = STATUS_SUCCESS;

	switch (pQueryInfo->QueryType)
	{
		case TDI_QUERY_BROADCAST_ADDRESS:

			Status = STATUS_NOT_IMPLEMENTED;
			break;
		
		case TDI_QUERY_PROVIDER_INFO:

			TdiRequest.Handle.ControlChannel = pEndpoint->Handle.ControlChannel;
			break;
		
		case TDI_QUERY_ADDRESS_INFO:

			if (((INT)PtrToUint(pIrpSp->FileObject->FsContext2)) == TDI_CONNECTION_FILE)
			{
				IsConnection = TRUE;
				TdiRequest.Handle.ConnectionContext = pEndpoint->Handle.ConnectionContext;
			}
			else
			{
				//
				//  Must be an address object.
				//
				RWAN_ASSERT(((INT) PtrToUint(pIrpSp->FileObject->FsContext2))
									 == TDI_TRANSPORT_ADDRESS_FILE);

				TdiRequest.Handle.AddressHandle = pEndpoint->Handle.AddressHandle;
			}
			break;

		case TDI_QUERY_CONNECTION_INFO:

			//
			//  Must be a connection object.
			//
			RWAN_ASSERT(((INT) PtrToUint(pIrpSp->FileObject->FsContext2)) == TDI_CONNECTION_FILE);

			IsConnection = TRUE;
			TdiRequest.Handle.ConnectionContext = pEndpoint->Handle.ConnectionContext;
			break;

		case TDI_QUERY_PROVIDER_STATISTICS:

			//
			//  Must be a control channel.
			//
			RWAN_ASSERT(((INT) PtrToUint(pIrpSp->FileObject->FsContext2))
									== TDI_CONTROL_CHANNEL_FILE);
			TdiRequest.Handle.ControlChannel = pEndpoint->Handle.ControlChannel;
			break;

		default:
		
			Status = STATUS_NOT_IMPLEMENTED;
			break;
	}

	if (NT_SUCCESS(Status))
	{
		Status = RWanPrepareIrpForCancel(pEndpoint, pIrp, NULL);

		if (NT_SUCCESS(Status))
		{
			DataSize = RWanGetMdlChainLength(pIrp->MdlAddress);

			Status = RWanTdiQueryInformation(
							&TdiRequest,
							pQueryInfo->QueryType,
							pIrp->MdlAddress,
							&DataSize,
							IsConnection
							);
			
			RWANDEBUGP(DL_LOUD, DC_DISPATCH,
				("RWanQueryInformation: pIrp x%x, pEndp x%x, Type x%x, Status x%x\n", 
					pIrp, pEndpoint, pQueryInfo->QueryType, Status));

			if (Status != TDI_PENDING)
			{
				RWanDataRequestComplete(pIrp, Status, DataSize);
			}

			return (STATUS_PENDING);
		}
		else
		{
			return (Status);
		}
	}

	RWAN_COMPLETE_IRP(pIrp, Status, 0);

	return (Status);
}




VOID
RWanCloseObjectComplete(
	IN	PVOID				Context,
	IN	UINT				Status,
	IN	UINT				Unused
	)
/*++

Routine Description:

	This is the call-back routine that processes a CloseConnection
	or CloseAddress completion. This is called by the core TDI
	provider. We dereference the endpoint; if it goes to 0, we
	wake up the thread that's running the CLEANUP.

Arguments:

	Context			- A pointer to the IRP for this request.
	Status			- Final TDI status for the CloseConnection/CloseAddress
	Unused			- Not used for this completion

Return Value:

	None

--*/
{
	KIRQL						OldIrql;
	PIRP						pIrp;
	PIO_STACK_LOCATION			pIrpSp;
	PRWAN_ENDPOINT				pEndpoint;

	UNREFERENCED_PARAMETER(Unused);

	pIrp = (PIRP)Context;
	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	pIrp->IoStatus.Status = Status;
	pEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pEndpoint, nep);

	IoAcquireCancelSpinLock(&OldIrql);

	IoSetCancelRoutine(pIrp, NULL);

	RWAN_DECR_EP_REF_CNT(pEndpoint, CloseComplDecr);		// CloseComplete deref

	RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'pmCC', pIrp, pEndpoint->RefCount);

	if (pEndpoint->RefCount == 0)
	{
		//
		//  The endpoint must be cleaning up.
		//

		RWANDEBUGP(DL_LOUD, DC_DISPATCH,
				("RWanCloseObjectComplete: pIrp x%x, pEndpoint x%x ref count 0\n",
						pIrp, pEndpoint));

		KeSetEvent(&(pEndpoint->CleanupEvent), 0, FALSE);
	}

	IoReleaseCancelSpinLock(OldIrql);

	return;
}




VOID
RWanDataRequestComplete(
	IN	PVOID				Context,
	IN	UINT				Status,
	IN	UINT				ByteCount
	)
/*++

Routine Description:

	This is the call-back routine that processes a Send/Receive completion.
	This is called by the core TDI provider. We complete the send/receive
	IRP appropriately, and dereference our endpoint.

Arguments:

	Context			- A pointer to the IRP for this request.
	Status			- Final TDI status for send/receive
	ByteCount		- Actual bytes sent/received.

Return Value:

	None

--*/
{
	KIRQL						OldIrql;
	PIRP						pIrp;
	PIO_STACK_LOCATION			pIrpSp;
	PRWAN_ENDPOINT				pEndpoint;

	pIrp = (PIRP)Context;
	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	pEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pEndpoint, nep);

	IoAcquireCancelSpinLock(&OldIrql);

	IoSetCancelRoutine(pIrp, NULL);

	RWAN_DECR_EP_REF_CNT(pEndpoint, DataReqComplDecr);		// Send/Receive deref

	RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'CerD', pIrp, pEndpoint->RefCount);

	RWANDEBUGP(DL_EXTRA_LOUD, DC_DATA_TX|DC_DATA_RX|DC_CONNECT|DC_DISCON,
			("RWanDataReq compl: pIrp x%x, pEndpoint x%x, RefCnt %d, Sts x%x, ByteCnt %d\n",
					pIrp, pEndpoint, pEndpoint->RefCount, Status, ByteCount));

	if (pEndpoint->RefCount == 0)
	{
		//
		//  The endpoint must be cleaning up.
		//

		RWANDEBUGP(DL_LOUD, DC_DISPATCH,
				("RWanDataRequestComplete: pIrp x%x, pEndpoint x%x ref count 0\n",
						pIrp, pEndpoint));

		KeSetEvent(&(pEndpoint->CleanupEvent), 0, FALSE);
	}

	//
	//  If the IRP was cancelled or we are cleaning up,
	//  update the completion status.
	//
	if (pIrp->Cancel || pEndpoint->bCancelIrps)
	{
		Status = (UINT)STATUS_CANCELLED;
		ByteCount = 0;
	}

	IoReleaseCancelSpinLock(OldIrql);

	RWAN_COMPLETE_IRP(pIrp, Status, ByteCount);

	return;
}




VOID
RWanRequestComplete(
	IN	PVOID				Context,
	IN	UINT				Status,
	IN	UINT				Unused
	)
/*++

Routine Description:

	This is our call-back routine for completing requests that don't
	include data. IRP processing is the same as that for data, except
	that the ByteCount is 0.

Arguments:

	Context			- A pointer to the IRP for this request.
	Status			- Final TDI status for the request.
	Unused			- Not used.

Return Value:

	None

--*/
{
	UNREFERENCED_PARAMETER(Unused);

	RWanDataRequestComplete(Context, Status, 0);
}




VOID
RWanNonCancellableRequestComplete(
	IN	PVOID				Context,
	IN	UINT				Status,
	IN	UINT				Unused
	)
/*++

Routine Description:

	This is our call-back routine for completing requests based
	on non-cancellable IRPs (e.g. Abortive Disconnect).

Arguments:

	Context			- A pointer to the IRP for this request.
	Status			- Final TDI status for the request.
	Unused			- Not used.

Return Value:

	None

--*/
{
	PIRP						pIrp;
	PIO_STACK_LOCATION			pIrpSp;

	UNREFERENCED_PARAMETER(Unused);

	pIrp = (PIRP)Context;
	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

	//
	//  Complete the IRP
	//
	RWAN_COMPLETE_IRP(pIrp, Status, 0);

	return;
}




VOID
RWanCancelComplete(
	IN	PVOID				Context,
	IN	UINT				Unused1,
	IN	UINT				Unused2
	)
/*++

Routine Description:

	This is called to process internal completion of an IRP cancellation.
	All we need to do here is to dereference the endpoint on which this
	happened.

Arguments:

	Context			- A pointer to the file object representing the
					  endpoint on which the IRP was cancelled.
	Unused[1-2]		- Not used

Return Value:

	None

--*/
{
	PFILE_OBJECT		pFileObject;
	PRWAN_ENDPOINT		pEndpoint;
	KIRQL				OldIrql;

	UNREFERENCED_PARAMETER(Unused1);
	UNREFERENCED_PARAMETER(Unused2);

	pFileObject = (PFILE_OBJECT)Context;
	pEndpoint = (PRWAN_ENDPOINT)(pFileObject->FsContext);

	RWAN_STRUCT_ASSERT(pEndpoint, nep);


	IoAcquireCancelSpinLock(&OldIrql);

	RWAN_DECR_EP_REF_CNT(pEndpoint, CancelComplDecr);		// CancelComplete deref

	RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'CnaC', 0, pEndpoint->RefCount);

	RWANDEBUGP(DL_EXTRA_LOUD, DC_DISPATCH,
			("RWanCancelComplete: pEndpoint x%x, RefCount %d\n",
				pEndpoint, pEndpoint->RefCount));

	if (pEndpoint->RefCount == 0)
	{
		//
		//  Wake up the thread waiting for IRPs to complete
		//
		KeSetEvent(&(pEndpoint->CleanupEvent), 0, FALSE);
	}

	IoReleaseCancelSpinLock(OldIrql);

	return;
}



VOID
RWanCancelRequest(
	IN	PDEVICE_OBJECT		pDeviceObject,
	IN	PIRP				pIrp
	)
/*++

Routine Description:

	This is the cancel routine we attach to IRPs that we queue. This
	is supposed to cancel the IRP.

Arguments:

	pDeviceObject	- Pointer to the device object for this IRP
	pIrp			- Pointer to request packet

Return Value:

	None

--*/
{
	PFILE_OBJECT			pFileObject;
	PIO_STACK_LOCATION		pIrpSp;
	PRWAN_ENDPOINT			pEndpoint;
	NTSTATUS				Status;
	TDI_REQUEST				TdiRequest;
	UCHAR					MinorFunction;

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	pFileObject = pIrpSp->FileObject;
	MinorFunction = pIrpSp->MinorFunction;

	pEndpoint = (PRWAN_ENDPOINT) pFileObject->FsContext;
	RWAN_STRUCT_ASSERT(pEndpoint, nep);

	//
	//  This routine is entered with Cancel SpinLock acquired.
	//
	RWAN_ASSERT(pIrp->Cancel);
	IoSetCancelRoutine(pIrp, NULL);

	//
	//  Make sure that the endpoint doesn't go away when
	//  we release the Cancel Spinlock.
	//
	RWAN_INCR_EP_REF_CNT(pEndpoint, CancelIncr);		// Cancel ref

	RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'RnaC', pIrp, pEndpoint->RefCount);

	IoReleaseCancelSpinLock(pIrp->CancelIrql);

	RWANDEBUGP(DL_LOUD, DC_DISPATCH,
			("RWanCancelRequest: pIrp x%x, MinorFunc %d, pEndpoint x%x\n",
				pIrp, MinorFunction, pEndpoint));

	Status = STATUS_SUCCESS;

	switch (MinorFunction)
	{
		case TDI_SEND:
		case TDI_RECEIVE:

			RWanAbortConnection(
				pEndpoint->Handle.ConnectionContext
				);
			break;

		case TDI_DISASSOCIATE_ADDRESS:

			break;

		case TDI_LISTEN:

			//
			//  Initiate an Unlisten.
			//
			TdiRequest.Handle.ConnectionContext = pEndpoint->Handle.ConnectionContext;
			TdiRequest.RequestNotifyObject = (PVOID)RWanCancelComplete;
			TdiRequest.RequestContext = (PVOID)pFileObject;

			Status = RWanTdiUnListen(
						&TdiRequest
						);
			break;

		default:

			//
			//  Initiate a Disconnect.
			//
			TdiRequest.Handle.ConnectionContext = pEndpoint->Handle.ConnectionContext;
			TdiRequest.RequestNotifyObject = (PVOID)RWanCancelComplete;
			TdiRequest.RequestContext = (PVOID)pFileObject;

			Status = RWanTdiDisconnect(
						&TdiRequest,
						NULL,
						TDI_DISCONNECT_ABORT,
						NULL,
						NULL
						);
			break;
	}

	if (Status != TDI_PENDING)
	{
		RWanCancelComplete(pFileObject, 0, 0);
	}

	return;
}




NTSTATUS
RWanPrepareIrpForCancel(
	IN	PRWAN_ENDPOINT		pEndpoint,
	IN	PIRP				pIrp,
	IN	PDRIVER_CANCEL		pCancelRoutine
	)
/*++

Routine Description:

	Check if an IRP has been cancelled. If so, complete it with the
	right status. Otherwise, set it up so that the supplied cancel
	routine is called if it is cancelled.

	This is called for non-data IRPs that are potentially going to
	pend.

Arguments:

	pEndpoint		- Pointer to endpoint on which this IRP arrived
	pIrp			- Pointer to request packet
	pCancelRoutine	- Cancellation routine to be tacked on to the IRP

Return Value:

	NTSTATUS - this is STATUS_CANCELLED if the IRP has been cancelled
	already, STATUS_SUCCESS otherwise.

--*/
{
	KIRQL			OldIrql;
	NTSTATUS		Status;

	IoAcquireCancelSpinLock(&OldIrql);

	RWAN_ASSERT(pIrp->CancelRoutine == NULL);

	if (!pIrp->Cancel)
	{
		//
		//  This IRP hasn't been cancelled. Mark it as pending, because
		//  it's going to be queued (by the caller).
		//
		IoMarkIrpPending(pIrp);

		IoSetCancelRoutine(pIrp, pCancelRoutine);

		//
		//  Add a reference for this IRP on the endpoint.
		//
		RWAN_INCR_EP_REF_CNT(pEndpoint, NonDataIncr);		// Non data IRP ref

		RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'DnoN', pIrp, pEndpoint->RefCount);

		IoReleaseCancelSpinLock(OldIrql);

		Status = STATUS_SUCCESS;
	}
	else
	{
		//
		//  The IRP has been cancelled already. Simply complete it.
		//

		IoReleaseCancelSpinLock(OldIrql);

		Status = STATUS_CANCELLED;
		RWAN_COMPLETE_IRP(pIrp, Status, 0);

	}

	RWANDEBUGP(DL_VERY_LOUD, DC_DISPATCH,
			("RWanPrepareIrpForCancel: pIrp x%x, pEndp x%x, ret Status x%x\n",
				pIrp, pEndpoint, Status));

	return (Status);
}



ULONG
RWanGetMdlChainLength(
	IN	PMDL				pMdl
	)
/*++

Routine Description:

	Return the total byte count of all MDLs in a chain.

Arguments:

	pMdl		- Points to start of MDL chain.

Return Value:

	Byte count of the MDL chain.

--*/
{
	ULONG		Count = 0;

	while (pMdl != NULL)
	{
		Count += MmGetMdlByteCount(pMdl);
		pMdl = pMdl->Next;
	}

	return (Count);
}




NTSTATUS
RWanToNTStatus(
	IN	RWAN_STATUS			RWanStatus
	)
/*++

Routine Description:

	Map from a Raw-WAN status code to an equivalent NT status code.

Arguments:

	RWanStatus		- The RAW WAN status code.

Return Value:

	The NT Status code.

--*/
{
	NTSTATUS		Status;

	switch (RWanStatus)
	{
		case RWAN_STATUS_SUCCESS:
				Status = STATUS_SUCCESS;
				break;
		case RWAN_STATUS_BAD_ADDRESS:
				Status = STATUS_INVALID_ADDRESS;
				break;
		case RWAN_STATUS_BAD_PARAMETER:
				Status = STATUS_INVALID_PARAMETER;
				break;
		case RWAN_STATUS_MISSING_PARAMETER:
				Status = STATUS_INVALID_PARAMETER;
				break;
		case RWAN_STATUS_RESOURCES:
				Status = STATUS_INSUFFICIENT_RESOURCES;
				break;
		case RWAN_STATUS_FAILURE:
		default:
				Status = STATUS_UNSUCCESSFUL;
				break;
	}

	return (Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\rwannt.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\rwannt.h

Abstract:

	NT-specific definitions for Raw WAN.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     04-17-97    Created

Notes:

--*/

#ifndef __TDI_RWANNT__H
#define __TDI_RWANNT__H

#ifdef NT


#if DBG_LOG_EP

#define MAX_EP_LOG_ENTRIES			32

typedef struct _RWAND_EP_LOG_ENTRY
{
	ULONG							LineNumber;
	ULONG							Event;
	PVOID							Context1;
	PVOID							Context2;

} RWAND_EP_LOG_ENTRY, *PRWAND_EP_LOG_ENTRY;

#define RWAN_EP_DBGLOG_SET_SIGNATURE(_pEp)						\
	(_pEp)->EpLogSig = 'GOLE'

#define RWAN_EP_DBGLOG_ENTRY(_pEp, _Event, _Ctx1, _Ctx2)		\
{																\
	PRWAND_EP_LOG_ENTRY		pLogEnt;							\
	ULONG					Index;								\
	NdisAcquireSpinLock(&RWanDbgLogLock);						\
	(_pEp)->EpLogCount++;										\
	Index = (_pEp)->EpLogIndex;									\
	pLogEnt = &((_pEp)->EpLog[Index]);							\
	pLogEnt->LineNumber = __LINE__;								\
	pLogEnt->Event = _Event;									\
	pLogEnt->Context1 = (PVOID)_Ctx1;							\
	pLogEnt->Context2 = (PVOID)_Ctx2;							\
	(_pEp)->EpLogIndex++;										\
	if ((_pEp)->EpLogIndex == MAX_EP_LOG_ENTRIES)				\
	{															\
		(_pEp)->EpLogIndex = 0;									\
	}															\
	NdisReleaseSpinLock(&RWanDbgLogLock);						\
}


#else

#define RWAN_EP_DBGLOG_SET_SIGNATURE(_pEp)	
#define RWAN_EP_DBGLOG_ENTRY(_pEp, _Event, _Ctx1, _Ctx2)

#endif

//
//  ***** Endpoint *****
//
//  One of these is allocated for each MJ_CREATE successfully processed.
//  A pointer to this structure is returned in FileObject->FsContext.
//
//  The object it represents is one of these:
//  Address object, Connection object, Control channel.
//
//  Reference Count: RefCount is incremented for each of the following:
//  - for the duration an IRP pertaining to this object is pending
//
typedef struct RWAN_ENDPOINT
{
#if DBG
	ULONG							nep_sig;
#endif
#ifdef REFDBG
	ULONG							SendIncrRefs;
	ULONG							RecvIncrRefs;
	ULONG							CloseComplDecrRefs;
	ULONG							DataReqComplDecrRefs;
	ULONG							CancelComplDecrRefs;
	ULONG							CancelIncrRefs;
	ULONG							NonDataIncrRefs;
#endif
#if DBG
	PVOID							pConnObject;			// Transport's context
#endif
	union
	{
		HANDLE					AddressHandle;				// Address Object
		CONNECTION_CONTEXT		ConnectionContext;			// Connection Object
		HANDLE					ControlChannel;				// Control channel

	}								Handle;
	struct _RWAN_TDI_PROTOCOL *		pProtocol;
	ULONG							RefCount;
	BOOLEAN							bCancelIrps;			// are we cleaning up?
	KEVENT							CleanupEvent;			// synchronization
#if DBG_LOG_EP
	ULONG							EpLogSig;
	ULONG							EpLogCount;
	ULONG							EpLogIndex;
	struct _RWAND_EP_LOG_ENTRY		EpLog[MAX_EP_LOG_ENTRIES];
#endif

} RWAN_ENDPOINT, *PRWAN_ENDPOINT;

#if DBG
#define nep_signature				'NlEp'
#endif // DBG

#define NULL_PRWAN_ENDPOINT			((PRWAN_ENDPOINT)NULL)




//
//  ***** Device Object *****
//
//  We create one NT device object for each TDI protocol that we
//  expose i.e. each Winsock triple <Family, Proto, Type>.
//
typedef struct _RWAN_DEVICE_OBJECT
{
#if DBG
	ULONG							ndo_sig;
#endif // DBG
	PDEVICE_OBJECT					pDeviceObject;			// NT device object
	struct _RWAN_TDI_PROTOCOL *		pProtocol;				// Info about the protocol
	LIST_ENTRY						DeviceObjectLink;		// in list of device objs

} RWAN_DEVICE_OBJECT, *PRWAN_DEVICE_OBJECT;

#if DBG
#define ndo_signature				'NlDo'
#endif // DBG



#ifdef REFDBG

#define RWAN_INCR_EP_REF_CNT(_pEp, _Type)	\
		{									\
			(_pEp)->RefCount++;				\
			(_pEp)->_Type##Refs++;			\
		}

#define RWAN_DECR_EP_REF_CNT(_pEp, _Type)	\
		{									\
			(_pEp)->RefCount--;				\
			(_pEp)->_Type##Refs--;			\
		}

#else

#define RWAN_INCR_EP_REF_CNT(_pEp, _Type)	\
			(_pEp)->RefCount++;

#define RWAN_DECR_EP_REF_CNT(_pEp, _Type)	\
			(_pEp)->RefCount--;

#endif // REFDBG

/*++
LARGE_INTEGER
RWAN_CONVERT_100NS_TO_MS(
	IN	LARGE_INTEGER				HnsTime,
	OUT	PULONG						pRemainder
	)
--*/
#define RWAN_CONVERT_100NS_TO_MS(_HnsTime, _pRemainder)	\
			RtlExtendedLargeIntegerDivide(_HnsTime, 10000, _pRemainder);

#endif // NT

#endif // __TDI_RWANNT__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\rwanpub.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\rwanpub.h

Abstract:

	Null Transport Public definitions. This is included by helper
	routines that perform media/Address family specific actions.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     04-24-97    Created

Notes:

--*/


#ifndef __TDI_RWANPUB__H
#define __TDI_RWANPUB__H

//
//  Null Transport status codes. Used between the core Null Transport
//  and helper routines.
//

typedef ULONG								RWAN_STATUS;

#define RWAN_STATUS_SUCCESS					0x00000000
#define RWAN_STATUS_FAILURE					0xc0000001
#define RWAN_STATUS_BAD_ADDRESS				0x00000001
#define RWAN_STATUS_NULL_ADDRESS			0x00000002
#define RWAN_STATUS_WILDCARD_ADDRESS		0x00000003
#define RWAN_STATUS_BAD_PARAMETER			0x00000010
#define RWAN_STATUS_MISSING_PARAMETER		0x00000020
#define RWAN_STATUS_RESOURCES				0x00000040
#define RWAN_STATUS_PENDING					0x00000103


typedef PVOID								RWAN_HANDLE, *PRWAN_HANDLE;

//
//  Bit definitions for CallFlags
//

//  Bit 0 is set iff Incoming Call:
#define RWAN_CALLF_OUTGOING_CALL			0x00000000
#define RWAN_CALLF_INCOMING_CALL			0x00000001
#define RWAN_CALLF_CALL_DIRECTION_MASK		0x00000001

//  Bit 1 is set iff Point to Multipoint Call:
#define RWAN_CALLF_POINT_TO_POINT			0x00000000
#define RWAN_CALLF_POINT_TO_MULTIPOINT		0x00000002
#define RWAN_CALLF_CALL_TYPE_MASK			0x00000002

//  Bit 2 is set iff Add Party:
#define RWAN_CALLF_PMP_FIRST_LEAF			0x00000000
#define RWAN_CALLF_PMP_ADDNL_LEAF			0x00000004
#define RWAN_CALLF_PMP_LEAF_TYPE_MASK		0x00000004


#ifndef EXTERN
#define EXTERN	extern
#endif


//
//  Entry points for NDIS AF-specific helper routines. All media/AF specific
//  actions are done by these routines.
//

//
//  Init routine. Called once when loading.
//
typedef
RWAN_STATUS
(*AFSP_INIT_HANDLER)();


//
//  Shutdown routine. Called once when unloading.
//
typedef
VOID
(*AFSP_SHUTDOWN_HANDLER)();


//
//  Set up context for an NDIS AF open. This is called after a
//  successful OpenAddressFamily for a supported AF+Medium.
//  The AF-specific module must allocate its context for this AF
//  open, perform any initializations (including OID queries to
//  the CM/Miniport) and return this context to us.
//  If the handler returns RWAN_STATUS_PENDING, it must call
//  RWanAfSpOpenAfComplete to complete this call.
//
typedef
RWAN_STATUS
(*AFSP_OPEN_AF_HANDLER)(
	IN	RWAN_HANDLE					AfSpContext,
	IN	RWAN_HANDLE					RWanAFHandle,
	OUT	PRWAN_HANDLE				pAfSpAFContext,
	OUT PULONG						pMaxMsgSize
	);


//
//  Shut down prior to closing an NDIS AF open. This gives a chance
//  for the AF-specific module to perform any clean up operations,
//  including freeing any context, for an NDIS AF open.
//  If the handler returns RWAN_STATUS_PENDING, it must call
//  RWanAfSpCloseAfComplete to complete this call.
//
typedef
RWAN_STATUS
(*AFSP_CLOSE_AF_HANDLER)(
	IN	RWAN_HANDLE					AfSpAFContext
	);

//
//  Notify media-specific module of a new Address Object being
//  opened for this medium. The media-specific module creates
//  its context for this address object and returns it.
//
typedef
RWAN_STATUS
(*AFSP_OPEN_ADDRESS_HANDLER)(
	IN	RWAN_HANDLE					AfSpContext,
	IN	RWAN_HANDLE					RWanAddrHandle,
	OUT	PRWAN_HANDLE				pAfSpAddrContext
	);


//
//  Notify media-specific module of an Address Object being
//  closed.
//
typedef
VOID
(*AFSP_CLOSE_ADDRESS_HANDLER)(
	IN	RWAN_HANDLE					AfSpAddrContext
	);


//
//  Notify media-specific module of a new Connection Object being
//  associated with an Address Object belonging to this media. The
//  media-specific module would typically create its context for
//  the Connection Object and return a pointer to it.
//
typedef
RWAN_STATUS
(*AFSP_ASSOCIATE_CONN_HANDLER)(
	IN	RWAN_HANDLE					AfSpAddrContext,
	IN	RWAN_HANDLE					RWanConnHandle,
	OUT	PRWAN_HANDLE				pAfSpConnContext
	);


//
//  Notify media-specific module of an existing Connection Object
//  being disassociated from an Address Object belonging to this module.
//
typedef
VOID
(*AFSP_DISASSOCIATE_CONN_HANDLER)(
	IN	RWAN_HANDLE					AfSpConnContext
	);


//
//  Convert options in TDI format to NDIS call parameters. The handler
//  is supposed to allocate space for NDIS call parameters, and return
//  this to the caller (via ppCallParameters).
//
//  Also this returns the RWAN handle for the AF on which the call should
//  be placed. If this is NULL, then the first AF is chosen.
//
typedef
RWAN_STATUS
(*AFSP_TDI2NDIS_OPTIONS_HANDLER)(
	IN	RWAN_HANDLE					AfSpConnContext,
	IN	ULONG						CallFlags,
	IN	PTDI_CONNECTION_INFORMATION	pTdiInfo,
	IN	PVOID						pTdiQoS,
	IN	ULONG						TdiQoSLength,
	OUT	PRWAN_HANDLE				pAfHandle,
	OUT PCO_CALL_PARAMETERS *		ppCallParameters
	);


//
//  Update NDIS call parameters with TDI options. This typically
//  happens when an incoming call is accepted with modified parameters.
//
typedef
RWAN_STATUS
(*AFSP_UPDATE_NDIS_OPTIONS_HANDLER)(
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	RWAN_HANDLE					AfSpConnContext,
	IN	ULONG						CallFlags,
	IN	PTDI_CONNECTION_INFORMATION	pTdiInfo,
	IN	PVOID						pTdiQoS,
	IN	ULONG						TdiQoSLength,
	IN OUT PCO_CALL_PARAMETERS *	ppCallParameters
	);


//
//  Return space allocated for NDIS Options to the AF Specific module.
//  See AFSP_TDI2NDIS_OPTIONS_HANDLER.
//
typedef
VOID
(*AFSP_RETURN_NDIS_OPTIONS_HANDLER)(
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
	);


//
//  Convert NDIS call parameters to TDI-style options. The handler
//  is supposed to allocate space for options+data+QoS parameters,
//  and return these to the caller. When the caller is done with
//  these, it will call the TDI Options return handler with
//  a context returned by the handler.
//
typedef
RWAN_STATUS
(*AFSP_NDIS2TDI_OPTIONS_HANDLER)(
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	ULONG						CallFlags,
	IN	PCO_CALL_PARAMETERS			pCallParameters,
	OUT	PTDI_CONNECTION_INFORMATION *ppTdiInfo,
	OUT	PVOID * 					ppTdiQoS,
	OUT	PULONG						pTdiQoSLength,
	OUT PRWAN_HANDLE				pAfSpTdiOptionsContext
	);


//
//  Update TDI-style options from NDIS call parameters. This is usually
//  done when completing an outgoing call.
//
typedef
RWAN_STATUS
(*AFSP_UPDATE_TDI_OPTIONS_HANDLER)(
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	RWAN_HANDLE					AfSpConnContext,
	IN	ULONG						CallFlags,
	IN	PCO_CALL_PARAMETERS			pCallParameters,
	IN OUT PTDI_CONNECTION_INFORMATION * pTdiInfo,
	IN OUT PUCHAR 					pTdiQoS,
	IN OUT PULONG					pTdiQoSLength
	);


//
//  Return space allocated for TDI options etc to the AF Specific module.
//  See AFSP_NDIS2TDI_OPTIONS_HANDLER.
//
typedef
VOID
(*AFSP_RETURN_TDI_OPTIONS_HANDLER)(
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	RWAN_HANDLE					AfSpTdiOptionsContext
	);



//
//  Get a valid Transport Address from a list of addresses.
//
typedef
TA_ADDRESS *
(*AFSP_GET_VALID_TDI_ADDRESS_HANDLER)(
	IN	RWAN_HANDLE					AfSpContext,
	IN	TRANSPORT_ADDRESS UNALIGNED *pAddressList,
	IN	ULONG						AddrListLength
	);


//
//  Check if a given Transport address is non-NULL. This means that it is
//  usable as a SAP address.
//
typedef
BOOLEAN
(*AFSP_IS_NULL_ADDRESS_HANDLER)(
	IN	RWAN_HANDLE					AfSpContext,
	IN	TA_ADDRESS *		        pTransportAddress
	);

//
//  Convert a TDI-style address specification to an NDIS SAP.
//  Allocate space for the NDIS SAP and return it if successful.
//
typedef
RWAN_STATUS
(*AFSP_TDI2NDIS_SAP_HANDLER)(
	IN	RWAN_HANDLE					AfSpContext,
	IN	USHORT						TdiAddressType,
	IN	USHORT						TdiAddressLength,
	IN	PVOID						pTdiAddress,
	OUT	PCO_SAP *					ppCoSap
	);


//
//  Return space allocated for an NDIS SAP. See AFSP_TDI2NDIS_SAP_HANDLER.
//
typedef
VOID
(*AFSP_RETURN_NDIS_SAP_HANDLER)(
	IN	RWAN_HANDLE					AfSpContext,
	IN	PCO_SAP						pCoSap
	);


//
//  Complete a media-specific module's call to RWanAfSpDeregisterNdisAF
//  that had pended.
//
typedef
VOID
(*AFSP_DEREG_NDIS_AF_COMP_HANDLER)(
	IN	RWAN_STATUS					RWanStatus,
	IN	RWAN_HANDLE					AfSpNdisAFContext
	);


//
//  Complete a media-specific module's call to RWanAfSpDeregisterTdiProtocol
//  that had pended.
//
typedef
VOID
(*AFSP_DEREG_TDI_PROTO_COMP_HANDLER)(
	IN	RWAN_STATUS					RWanStatus,
	IN	RWAN_HANDLE					AfSpTdiProtocolContext
	);


//
//  Complete a media-specific module's call to send an NDIS Request
//  to the miniport
//
typedef
VOID
(*AFSP_ADAPTER_REQUEST_COMP_HANDLER)(
	IN	NDIS_STATUS					Status,
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	RWAN_HANDLE					AfSpReqContext,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
	);


//
//  Complete a media-specific module's call to send an NDIS Request
//  to the Call Manager (AF-specific request)
//
typedef
VOID
(*AFSP_AF_REQUEST_COMP_HANDLER)(
	IN	NDIS_STATUS					Status,
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	RWAN_HANDLE					AfSpReqContext,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
	);

//
//  Process a media-specific global Query Information IOCTL from the Winsock2 helper DLL.
//
typedef
RWAN_STATUS
(*AFSP_QUERY_GLOBAL_INFO_HANDLER)(
	IN	RWAN_HANDLE					AfSpContext,
	IN	PVOID						pInputBuffer,
	IN	ULONG						InputBufferLength,
	IN	PVOID						pOutputBuffer,
	IN OUT	PULONG					pOutputBufferLength
	);

//
//  Process a media-specific global Set Information IOCTL from the Winsock2 helper DLL.
//
typedef
RWAN_STATUS
(*AFSP_SET_GLOBAL_INFO_HANDLER)(
	IN	RWAN_HANDLE					AfSpContext,
	IN	PVOID						pInputBuffer,
	IN	ULONG						InputBufferLength
	);


//
//  Process a media-specific per-connection Query Information IOCTL
//  from the Winsock2 helper DLL.
//
typedef
RWAN_STATUS
(*AFSP_QUERY_CONN_INFORMATION_HANDLER)(
	IN	RWAN_HANDLE					AfSpConnContext,
	IN	PVOID						pInputBuffer,
	IN	ULONG						InputBufferLength,
	OUT	PVOID						pOutputBuffer,
	IN OUT	PULONG					pOutputBufferLength
	);


//
//  Process a media-specific per-connection Set Information IOCTL
//  from the Winsock2 helper DLL.
//
typedef
RWAN_STATUS
(*AFSP_SET_CONN_INFORMATION_HANDLER)(
	IN	RWAN_HANDLE					AfSpConnContext,
	IN	PVOID						pInputBuffer,
	IN	ULONG						InputBufferLength
	);

//
//  Process a media-specific per-AddressObject Query Information IOCTL
//  from the Winsock2 helper DLL.
//
typedef
RWAN_STATUS
(*AFSP_QUERY_ADDR_INFORMATION_HANDLER)(
	IN	RWAN_HANDLE					AfSpAddrContext,
	IN	PVOID						pInputBuffer,
	IN	ULONG						InputBufferLength,
	IN	PVOID						pOutputBuffer,
	IN OUT	PULONG					pOutputBufferLength
	);


//
//  Process a media-specific per-AddressObject Set Information IOCTL
//  from the Winsock2 helper DLL.
//
typedef
RWAN_STATUS
(*AFSP_SET_ADDR_INFORMATION_HANDLER)(
	IN	RWAN_HANDLE					AfSpAddrContext,
	IN	PVOID						pInputBuffer,
	IN	ULONG						InputBufferLength
	);

//
//  ***** NDIS AF Characteristics *****
//
//  AF-specific information about a supported NDIS Address Family on
//  a supported NDIS medium. One of these exists for each
//  <CO_ADDRESS_FAMILY, NDIS_MEDIUM> pair.
//
typedef struct _RWAN_NDIS_AF_CHARS
{
	ULONG								MajorVersion;
	ULONG								MinorVersion;
	NDIS_MEDIUM							Medium;
	CO_ADDRESS_FAMILY					AddressFamily;
	ULONG								MaxAddressLength;
	AFSP_OPEN_AF_HANDLER				pAfSpOpenAf;
	AFSP_CLOSE_AF_HANDLER				pAfSpCloseAf;

	AFSP_OPEN_ADDRESS_HANDLER			pAfSpOpenAddress;
	AFSP_CLOSE_ADDRESS_HANDLER			pAfSpCloseAddress;

	AFSP_ASSOCIATE_CONN_HANDLER			pAfSpAssociateConnection;
	AFSP_DISASSOCIATE_CONN_HANDLER		pAfSpDisassociateConnection;

	AFSP_TDI2NDIS_OPTIONS_HANDLER		pAfSpTdi2NdisOptions;
	AFSP_RETURN_NDIS_OPTIONS_HANDLER	pAfSpReturnNdisOptions;
	AFSP_UPDATE_NDIS_OPTIONS_HANDLER	pAfSpUpdateNdisOptions;

	AFSP_NDIS2TDI_OPTIONS_HANDLER		pAfSpNdis2TdiOptions;
	AFSP_RETURN_TDI_OPTIONS_HANDLER		pAfSpReturnTdiOptions;
	AFSP_UPDATE_TDI_OPTIONS_HANDLER		pAfSpUpdateTdiOptions;

	AFSP_GET_VALID_TDI_ADDRESS_HANDLER	pAfSpGetValidTdiAddress;
	AFSP_IS_NULL_ADDRESS_HANDLER		pAfSpIsNullAddress;

	AFSP_TDI2NDIS_SAP_HANDLER			pAfSpTdi2NdisSap;
	AFSP_RETURN_NDIS_SAP_HANDLER		pAfSpReturnNdisSap;

	AFSP_DEREG_NDIS_AF_COMP_HANDLER		pAfSpDeregNdisAFComplete;
	AFSP_ADAPTER_REQUEST_COMP_HANDLER	pAfSpAdapterRequestComplete;
	AFSP_AF_REQUEST_COMP_HANDLER		pAfSpAfRequestComplete;

	AFSP_QUERY_GLOBAL_INFO_HANDLER		pAfSpQueryGlobalInfo;
	AFSP_SET_GLOBAL_INFO_HANDLER		pAfSpSetGlobalInfo;

	AFSP_QUERY_CONN_INFORMATION_HANDLER	pAfSpQueryConnInformation;
	AFSP_SET_CONN_INFORMATION_HANDLER	pAfSpSetConnInformation;

	AFSP_QUERY_ADDR_INFORMATION_HANDLER	pAfSpQueryAddrInformation;
	AFSP_SET_ADDR_INFORMATION_HANDLER	pAfSpSetAddrInformation;

} RWAN_NDIS_AF_CHARS, *PRWAN_NDIS_AF_CHARS;




//
//  ***** TDI Protocol Characteristics *****
//
//  This contains information about a TDI protocol that's supported over
//  an <NDIS AF, medium> pair. This is used by the AF+Medium specific module
//  in a call to RWanAfSpRegisterTdiProtocol.
//
typedef struct _RWAN_TDI_PROTOCOL_CHARS
{
	UINT								TdiProtocol;
	UINT								SockAddressFamily;
	UINT								SockProtocol;
	UINT								SockType;
	BOOLEAN								bAllowConnObjects;
	BOOLEAN								bAllowAddressObjects;
	USHORT								MaxAddressLength;
	TDI_PROVIDER_INFO					ProviderInfo;
	PNDIS_STRING						pDeviceName;

	AFSP_DEREG_TDI_PROTO_COMP_HANDLER	pAfSpDeregTdiProtocolComplete;

} RWAN_TDI_PROTOCOL_CHARS, *PRWAN_TDI_PROTOCOL_CHARS;




//
//  ***** AF-Specific Module Entry *****
//
//  This contains the basic entry points for an AF/medium-specific module.
//
typedef struct _RWAN_AFSP_MODULE_CHARS
{
	AFSP_INIT_HANDLER				pAfSpInitHandler;
	AFSP_SHUTDOWN_HANDLER			pAfSpShutdownHandler;

} RWAN_AFSP_MODULE_CHARS, *PRWAN_AFSP_MODULE_CHARS;


//
//  Exported Routines. Media/AF specific modules can call these.
//
EXTERN
RWAN_STATUS
RWanAfSpRegisterNdisAF(
	IN	PRWAN_NDIS_AF_CHARS			pAfChars,
	IN	RWAN_HANDLE					AfSpContext,
	OUT	PRWAN_HANDLE				pRWanSpHandle
	);

EXTERN
RWAN_STATUS
RWanAfSpDeregisterNdisAF(
	IN	RWAN_HANDLE					RWanSpAFHandle
	);

EXTERN
RWAN_STATUS
RWanAfSpRegisterTdiProtocol(
	IN	RWAN_HANDLE					RWanSpHandle,
	IN	PRWAN_TDI_PROTOCOL_CHARS	pTdiChars,
	OUT	PRWAN_HANDLE				pRWanProtHandle
	);

EXTERN
VOID
RWanAfSpDeregisterTdiProtocol(
	IN	RWAN_HANDLE					RWanProtHandle
	);

EXTERN
VOID
RWanAfSpOpenAfComplete(
    IN	RWAN_STATUS					RWanStatus,
    IN	RWAN_HANDLE					RWanAfHandle,
    IN	RWAN_HANDLE					AfSpAFContext,
    IN	ULONG						MaxMessageSize
   	);

EXTERN
VOID
RWanAfSpCloseAfComplete(
    IN	RWAN_HANDLE					RWanAfHandle
    );

EXTERN
RWAN_STATUS
RWanAfSpSendAdapterRequest(
    IN	RWAN_HANDLE					RWanAfHandle,
    IN	RWAN_HANDLE					AfSpReqContext,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    );

EXTERN
RWAN_STATUS
RWanAfSpSendAfRequest(
    IN	RWAN_HANDLE					RWanAfHandle,
    IN	RWAN_HANDLE					AfSpReqContext,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    );

#endif // __TDI_RWANPUB__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\receive.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\receive.c

Abstract:

	Routines for receiving data, including TDI and NDIS entry
	points and completions.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     05-16-97    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'VCER'


#if STATS

ULONG		RecvPktsOk = 0;
ULONG		RecvBytesOk = 0;
ULONG		RecvPktsFail = 0;
ULONG		RecvBytesFail = 0;

#endif // STATS

#if DBG

BOOLEAN		bVerifyData = FALSE;
UCHAR		CheckChar = 'X';

VOID
RWanCheckDataForChar(
	IN	PCHAR		pHelpString,
	IN	PVOID		Context,
	IN	PUCHAR		pBuffer,
	IN	ULONG		Length,
	IN	UCHAR		Char
	);


#define RWAN_CHECK_DATA(_pHelp, _Ctxt, _pBuf, _Len)	\
{														\
	if (bVerifyData)									\
	{													\
		RWanCheckDataForChar(_pHelp, _Ctxt, _pBuf, _Len, CheckChar);	\
	}													\
}

#else

#define RWAN_CHECK_DATA(_pHelp, _Ctxt, _pBuf, _Len)

#endif // DBG


#if DBG

VOID
RWanCheckDataForChar(
	IN	PCHAR		pHelpString,
	IN	PVOID		Context,
	IN	PUCHAR		pBuffer,
	IN	ULONG		Length,
	IN	UCHAR		Char
	)
{
	ULONG			i;
	PUCHAR			pBuf = pBuffer+1;

	for (i = 1; i < Length; i++)
	{
		if (*pBuf == Char)
		{
			DbgPrint("RAWWAN: %s: %p: Found char %c at offset %d, 0x%p, of buffer 0x%p\n",
						pHelpString,
						Context,
						Char,
						i,
						pBuf,
						pBuffer);
			DbgBreakPoint();
		}
		pBuf++;
	}
}

#endif // DBG

RWAN_STATUS
RWanInitReceive(
	VOID
	)
/*++

Routine Description:

	Initialize our receive structures. We allocate a buffer pool and
	a packet pool for keeping copies of received packets that we aren't
	allowed to keep by the miniport.

Arguments:

	None

Return Value:

	RWAN_STATUS_SUCCESS if initialized successfully, else RWAN_STATUS_RESOURCES.

--*/
{
	RWAN_STATUS				RWanStatus;
	NDIS_STATUS				Status;

	//
	//  Initialize.
	//
	RWanCopyPacketPool = NULL;
	RWanCopyBufferPool = NULL;
	RWanStatus = RWAN_STATUS_SUCCESS;

	NdisAllocatePacketPoolEx(
		&Status,
		&RWanCopyPacketPool,
		RWAN_INITIAL_COPY_PACKET_COUNT,
		RWAN_OVERFLOW_COPY_PACKET_COUNT,
		0
		);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		RWanStatus = RWAN_STATUS_RESOURCES;
	}
	else
	{
		NdisAllocateBufferPool(
			&Status,
			&RWanCopyBufferPool,
			RWAN_INITIAL_COPY_PACKET_COUNT+RWAN_OVERFLOW_COPY_PACKET_COUNT
			);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			NdisFreePacketPool(RWanCopyPacketPool);
			RWanCopyPacketPool = NULL;

			RWanStatus = RWAN_STATUS_RESOURCES;
		}
	}

	return (RWanStatus);
}




VOID
RWanShutdownReceive(
	VOID
	)
/*++

Routine Description:
	
	This is shutdown code, to clean up our receive structures.
	We free the packet pool and buffer pool allocated when we
	init'ed.

Arguments:

	None

Return Value:

	None

--*/
{
	if (RWanCopyPacketPool != NULL)
	{
		NdisFreePacketPool(RWanCopyPacketPool);
		RWanCopyPacketPool = NULL;
	}

	if (RWanCopyBufferPool != NULL)
	{
		NdisFreeBufferPool(RWanCopyBufferPool);
		RWanCopyBufferPool = NULL;
	}

	return;
}




TDI_STATUS
RWanTdiReceive(
    IN	PTDI_REQUEST				pTdiRequest,
	OUT	PUSHORT						pFlags,
	IN	PUINT						pReceiveLength,
	IN	PNDIS_BUFFER				pNdisBuffer
	)
/*++

Routine Description:

	This is the TDI Entry point for receiving data over a connection.

Arguments:

	pTdiRequest		- Pointer to the TDI Request
	pFlags			- Place to return additional information about this
					  receive
	pReceiveLength	- Points to the total length of the receive buffer chain
	pNdisBuffer		- Start of receive buffer chain

Return Value:

	TDI_PENDING if we queued this receive request successfully
	TDI_INVALID_CONNECTION if the Connection context isn't valid
	TDI_NO_RESOURCES if we had a resource problem with this receive

--*/
{
	RWAN_CONN_ID					ConnId;
	PRWAN_TDI_CONNECTION			pConnObject;
	BOOLEAN							bIsLockAcquired;	// Do we hold the Conn Object lock
	PRWAN_NDIS_VC					pVc;
	TDI_STATUS						TdiStatus;
	PRWAN_RECEIVE_REQUEST			pRcvReq;
	PRWAN_NDIS_ADAPTER				pAdapter;

	//
	//  Initialize.
	//
	TdiStatus = TDI_PENDING;
	bIsLockAcquired = FALSE;
	ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);
	pRcvReq = NULL;

	do
	{
		//
		//  Allocate space to hold context for this receive
		//
		pRcvReq = RWanAllocateReceiveReq();
		if (pRcvReq == NULL)
		{
			RWANDEBUGP(DL_INFO, DC_WILDCARD,
				("Rcv: Failed to allocate receive req!\n"));
			TdiStatus = TDI_NO_RESOURCES;
			break;
		}

		//
		//  Prepare the receive request.
		//
		pRcvReq->Request.pReqComplete = pTdiRequest->RequestNotifyObject;
		pRcvReq->Request.ReqContext = pTdiRequest->RequestContext;
		pRcvReq->TotalBufferLength = *pReceiveLength;
		pRcvReq->AvailableBufferLength = *pReceiveLength;
		pRcvReq->pUserFlags = pFlags;
		pRcvReq->pBuffer = pNdisBuffer;
		NdisQueryBufferSafe(
				pNdisBuffer,
				&(pRcvReq->pWriteData),
				&(pRcvReq->BytesLeftInBuffer),
				NormalPagePriority
				);

		if (pRcvReq->pWriteData == NULL)
		{
			RWANDEBUGP(DL_INFO, DC_WILDCARD,
				("Rcv: Failed to query req buffer!\n"));
			TdiStatus = TDI_NO_RESOURCES;
			break;
		}
		    
		pRcvReq->pNextRcvReq = NULL;
		if (pRcvReq->BytesLeftInBuffer > pRcvReq->AvailableBufferLength)
		{
			RWANDEBUGP(DL_INFO, DC_DATA_RX,
				("Rcv: pRcvReq %x, BytesLeft %d > Available %d, pTdiRequest %x\n",
						pRcvReq,
						pRcvReq->BytesLeftInBuffer,
						pRcvReq->AvailableBufferLength,
						pTdiRequest));
			pRcvReq->BytesLeftInBuffer = pRcvReq->AvailableBufferLength;
		}

		//
		//  See if the given Connection is valid.
		//
		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId(ConnId);

		RWAN_RELEASE_CONN_TABLE_LOCK();


		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			RWANDEBUGP(DL_FATAL, DC_WILDCARD,
				("Rcv: Invalid connection!\n"));
			TdiStatus = TDI_INVALID_CONNECTION;
			break;
		}

		bIsLockAcquired = TRUE;
		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		//
		//  Check the Connection state.
		//
		if ((pConnObject->State != RWANS_CO_CONNECTED) ||
			(RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING)))
		{
			RWANDEBUGP(DL_INFO, DC_DATA_RX,
				("TdiReceive: Conn %x bad state %d/flags %x\n",
					pConnObject, pConnObject->State, pConnObject->Flags));

			TdiStatus = TDI_INVALID_STATE;
			break;
		}

		pVc = pConnObject->NdisConnection.pNdisVc;
		RWAN_ASSERT(pVc != NULL);

		RWAN_STRUCT_ASSERT(pVc, nvc);
		pAdapter = pVc->pNdisAf->pAdapter;

		//
		//  Queue the receive request at the end of the queue on this VC.
		//
		if (pVc->pRcvReqHead == NULL)
		{
			pVc->pRcvReqHead = pVc->pRcvReqTail = pRcvReq;
		}
		else
		{
			RWAN_ASSERT(pVc->pRcvReqTail != NULL);
			pVc->pRcvReqTail->pNextRcvReq = pRcvReq;
			pVc->pRcvReqTail = pRcvReq;
		}

		RWANDEBUGP(DL_INFO, DC_DATA_RX,
				("Rcv: VC %x, queued RcvReq %x, space available %d bytes\n",
						pVc, pRcvReq, pRcvReq->AvailableBufferLength));

		//
		//  Start the common indicate code (for receive requests as well
		//  as for receive indications).
		//
		RWAN_RESET_BIT(pConnObject->Flags, RWANF_CO_PAUSE_RECEIVE);

		RWanIndicateData(pConnObject);

		bIsLockAcquired = FALSE;

		//
		//  Force return of any received packets that we have completed
		//  processing, to the miniport.
		//
		RWanNdisReceiveComplete((NDIS_HANDLE)pAdapter);

		break;

	}
	while (FALSE);

	if (bIsLockAcquired)
	{
		RWAN_RELEASE_CONN_LOCK(pConnObject);
	}

	if (TdiStatus != TDI_PENDING)
	{
		//
		//  Error - clean up.
		//
		if (pRcvReq != NULL)
		{
			RWanFreeReceiveReq(pRcvReq);
		}
	}

	return (TdiStatus);
}



UINT
RWanNdisCoReceivePacket(
    IN	NDIS_HANDLE					ProtocolBindingContext,
    IN	NDIS_HANDLE					ProtocolVcContext,
    IN	PNDIS_PACKET				pNdisPacket
    )
/*++

Routine Description:

	This is the NDIS entry point announcing arrival of a packet
	on a VC known to us.

Arguments:

	ProtocolBindingContext	- Pointer to our Adapter context
	ProtocolVcContext		- Pointer to our VC context
	pNdisPacket				- the received packet

Return Value:

	UINT - this is the reference count we place on the packet.
	This is 0 if we either dropped the packet, or if the miniport
	had marked the packet with NDIS_STATUS_RESOURCES. Otherwise,
	this is 1 (we queue the packet and will call NdisReturnPackets
	later).

--*/
{
	PRWAN_NDIS_VC			pVc;
	PRWAN_TDI_CONNECTION	pConnObject;
	UINT					PacketRefCount;
	NDIS_STATUS				ReceiveStatus;
	PRWAN_RECEIVE_INDICATION	pRcvInd;
	BOOLEAN					bIsMiniportPacket;	// Are we queueing the miniport's packet?
	BOOLEAN					bIsLockAcquired;

#if STATS
	PNDIS_BUFFER		StpNdisBuffer;
	PVOID				StFirstBufferVa;
	UINT				StFirstBufferLength;
	UINT				StTotalLength;
#endif // STATS

	UNREFERENCED_PARAMETER(ProtocolBindingContext);

	pVc = (PRWAN_NDIS_VC)ProtocolVcContext;
	RWAN_STRUCT_ASSERT(pVc, nvc);
	RWAN_ASSERT(pNdisPacket);

	pConnObject = pVc->pConnObject;

	RWANDEBUGP(DL_INFO, DC_DATA_RX,
			("Rcv: VC %x, NdisVCHandle %x, Pkt %x\n",
				ProtocolVcContext,
				((PRWAN_NDIS_VC)ProtocolVcContext)->NdisVcHandle,
				pNdisPacket));
	//
	//  Initialize.
	//
	PacketRefCount = 1;
	ReceiveStatus = NDIS_STATUS_SUCCESS;
	bIsMiniportPacket = TRUE;
	bIsLockAcquired = TRUE;

	do
	{
#if STATS
		NdisGetFirstBufferFromPacket(
			pNdisPacket,
			&StpNdisBuffer,
			&StFirstBufferVa,
			&StFirstBufferLength,
			&StTotalLength
			);
#endif // STATS
		
#if DBG
		//
		//  Debugging miniports indicating up garbage packets.
		//
		{
			ULONG			DbgTotalLength;
			PNDIS_BUFFER	pDbgFirstBuffer;
			PVOID			pFirstBufferVA;
			UINT			DbgFirstBufferLength;
			UINT			DbgTotalBufferLength;

			if ((pNdisPacket->Private.Head == NULL) || (pNdisPacket->Private.Tail == NULL))
			{
				RWANDEBUGP(DL_FATAL, DC_WILDCARD,
					("Rcv: VC %x, Pkt %x, Head/Tail is NULL!\n",
						ProtocolVcContext, pNdisPacket));
				RWAN_ASSERT(FALSE);
			}

			NdisGetFirstBufferFromPacket(
				pNdisPacket,
				&pDbgFirstBuffer,
				&pFirstBufferVA,
				&DbgFirstBufferLength,
				&DbgTotalBufferLength
				);

			if (pDbgFirstBuffer == NULL)
			{
				RWANDEBUGP(DL_FATAL, DC_WILDCARD,
					("Rcv: VC %x, Pkt %x, first buffer is NULL!\n",
						ProtocolVcContext, pNdisPacket));
				RWAN_ASSERT(FALSE);
			}

			if (DbgFirstBufferLength == 0)
			{
				RWANDEBUGP(DL_FATAL, DC_WILDCARD,
					("Rcv: VC %x, Pkt %x, first buffer length is 0!\n",
						ProtocolVcContext, pNdisPacket));
				// RWAN_ASSERT(FALSE);
			}

			if (DbgTotalBufferLength == 0)
			{
				RWANDEBUGP(DL_FATAL, DC_WILDCARD,
					("Rcv: VC %x, Pkt %x, Total buffer length is 0, FirstBufferLength %d!\n",
						ProtocolVcContext, pNdisPacket, DbgFirstBufferLength));
				// RWAN_ASSERT(FALSE);
			}

			if (pFirstBufferVA == NULL)
			{
				RWANDEBUGP(DL_FATAL, DC_WILDCARD,
					("Rcv: VC %x, Pkt %x, FirstBufferVA is NULL, FirstLength %d, Total %d\n",
						ProtocolVcContext, pNdisPacket, DbgFirstBufferLength, DbgTotalBufferLength));
				RWAN_ASSERT(FALSE);
			}

			RWANDEBUGP(DL_INFO, DC_DATA_RX,
				("Recv: VC %x, Pkt %x, TotalLength %d bytes\n",
					ProtocolVcContext, pNdisPacket, DbgTotalBufferLength));


			if (DbgTotalBufferLength == 0)
			{
				RWANDEBUGP(DL_FATAL, DC_WILDCARD,
					("Recv: VC %x, Pkt %x: discarding cuz zero length\n",
						ProtocolVcContext, pNdisPacket));
				bIsLockAcquired = FALSE;
				PacketRefCount = 0;
				ReceiveStatus = NDIS_STATUS_FAILURE;
				break;
			}
		}
#endif

		//
		//  See if we are aborting this connection. If so, drop this packet.
		//
		if (pConnObject == NULL)
		{
			bIsLockAcquired = FALSE;
			PacketRefCount = 0;
			ReceiveStatus = NDIS_STATUS_FAILURE;
			RWANDEBUGP(DL_FATAL, DC_WILDCARD,
				("Rcv: dropping cuz ConnObj is NULL\n"));
			break;
		}

		RWAN_STRUCT_ASSERT(pConnObject, ntc);

		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		//
		//  See if connection is closing. If so, drop this packet.
		//
		if (RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING) ||
			((pConnObject->State != RWANS_CO_CONNECTED) &&
			 (pConnObject->State != RWANS_CO_IN_CALL_ACCEPTING)))
		{
			PacketRefCount = 0;
			ReceiveStatus = NDIS_STATUS_FAILURE;
			RWANDEBUGP(DL_FATAL, DC_WILDCARD,
				("Rcv: dropping on Conn %p, Flags %x, State %d\n",
						pConnObject, pConnObject->Flags, pConnObject->State));
			break;
		}

		//
		//  If the packet cannot be queued, attempt to make a copy.
		//
		if (NDIS_GET_PACKET_STATUS(pNdisPacket) == NDIS_STATUS_RESOURCES)
		{
			PacketRefCount = 0;	// we cannot hang on to this packet

			pNdisPacket = RWanMakeReceiveCopy(pNdisPacket);
			if (pNdisPacket == NULL)
			{
				RWANDEBUGP(DL_WARN, DC_WILDCARD,
					("Rcv: failed to allocate receive copy!\n"));
				ReceiveStatus = NDIS_STATUS_RESOURCES;
				PacketRefCount = 0;
				break;
			}
			bIsMiniportPacket = FALSE;
		}

		//
		//  Prepare a receive indication element to keep track of this
		//  receive.
		//
		pRcvInd = RWanAllocateReceiveInd();
		if (pRcvInd == NULL)
		{
			PacketRefCount = 0;
			ReceiveStatus = NDIS_STATUS_RESOURCES;
			RWANDEBUGP(DL_FATAL, DC_WILDCARD,
				("Rcv: dropping cuz of failure allocating receive Ind!\n"));
			break;
		}

		pRcvInd->pPacket = pNdisPacket;
		pRcvInd->bIsMiniportPacket = bIsMiniportPacket;
		pRcvInd->pNextRcvInd = NULL;
		pRcvInd->pVc = pVc;

		NdisGetFirstBufferFromPacket(
				pNdisPacket,
				&(pRcvInd->pBuffer),
				(PVOID *)&(pRcvInd->pReadData),
				&(pRcvInd->BytesLeftInBuffer),
				&(pRcvInd->PacketLength)
				);

		pRcvInd->TotalBytesLeft = pRcvInd->PacketLength;

		//
		//  Queue the receive indication at the end of the receive queue on
		//  this VC.
		//
		if (pVc->pRcvIndHead == NULL)
		{
			pVc->pRcvIndHead = pVc->pRcvIndTail = pRcvInd;
		}
		else
		{
			RWAN_ASSERT(pVc->pRcvIndTail != NULL);
			pVc->pRcvIndTail->pNextRcvInd = pRcvInd;
			pVc->pRcvIndTail = pRcvInd;
		}

		RWANDEBUGP(DL_EXTRA_LOUD, DC_DATA_RX,
				("CoRcvPacket: Pkt x%x, pVc x%x, pRcvInd x%x, BytesLeft %d, PktLen %d, Head x%x, Tail x%x\n",
					pNdisPacket,
					pVc,
					pRcvInd,
					pRcvInd->BytesLeftInBuffer,
					pRcvInd->PacketLength,
					pVc->pRcvIndHead,
					pVc->pRcvIndTail));

		pVc->PendingPacketCount++;	// Receive Ind

		//
		//  Start the common indicate code (for receive requests as well
		//  as for receive indications).
		//
		if (pConnObject->State != RWANS_CO_IN_CALL_ACCEPTING)
		{
			RWanIndicateData(pConnObject);
		}
		else
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			RWANDEBUGP(DL_FATAL, DC_DATA_RX,
				("Rcv: queued packet %d bytes on accepting VC %x, pConn %x\n",
						pRcvInd->PacketLength, pVc, pConnObject));
		}

		bIsLockAcquired = FALSE;	// It's released within RWanIndicateData

		break;

	}
	while (FALSE);


	if (bIsLockAcquired)
	{
		RWAN_RELEASE_CONN_LOCK(pConnObject);
	}

	if (ReceiveStatus != NDIS_STATUS_SUCCESS)
	{
#if STATS
		INCR_STAT(&RecvPktsFail);
		ADD_STAT(&RecvBytesFail, StTotalLength);
#endif // STATS
		
		//
		//  Clean up.
		//
		if (!bIsMiniportPacket &&
			(pNdisPacket != NULL))
		{
			RWanFreeReceiveCopy(pNdisPacket);
		}
	}
#if STATS
	else
	{
		INCR_STAT(&RecvPktsOk);
		ADD_STAT(&RecvBytesOk, StTotalLength);
	}
#endif // STATS
		
	return (PacketRefCount);
}




VOID
RWanIndicateData(
    IN	PRWAN_TDI_CONNECTION			pConnObject
    )
/*++

Routine Description:

	Core internal receive processing routine. This tries to match up
    queued receive requests with queued receive indications and completes
    as many requests as it can. It calls the receive event handler, if any,
    for a receive indication that reaches the head of its queue without
    matching up with a receive request.

Arguments:

	pConnObject		- Points to our TDI Connection context.

Locks on Entry:

	pConnObject

Locks on Exit:

	None

Return Value:

	None

--*/
{
	PRWAN_TDI_ADDRESS			pAddrObject;
	PRWAN_NDIS_VC				pVc;
	PRWAN_NDIS_ADAPTER			pAdapter;
	PRcvEvent					pRcvIndEvent;
	INT							rc;
	PRWAN_RECEIVE_REQUEST		pRcvReq;
	PRWAN_RECEIVE_INDICATION	pRcvInd;
	PRWAN_RECEIVE_INDICATION	pNextRcvInd;
	UINT						BytesToCopy;
	//
	//  List of receive indications that have been completed here.
	//
	PRWAN_RECEIVE_INDICATION	pCompletedRcvIndHead;
	PRWAN_RECEIVE_INDICATION	pCompletedRcvIndTail;

	BOOLEAN						IsMessageMode = TRUE;
	//
	//  TBD: Set IsMessageMode based on the connection type/protocol type.
	//
	PVOID						TdiEventContext;
	BOOLEAN						bConnectionInBadState = FALSE;
	BOOLEAN						bContinue = TRUE;



	pVc = pConnObject->NdisConnection.pNdisVc;
	pAddrObject = pConnObject->pAddrObject;

	RWAN_ASSERT(pAddrObject != NULL);

	pRcvIndEvent = pAddrObject->pRcvInd;
	TdiEventContext = pAddrObject->RcvIndContext;

	pCompletedRcvIndHead = NULL;
	pCompletedRcvIndTail = NULL;
	pAdapter = pVc->pNdisAf->pAdapter;

	//
	//  Check if the client has paused receiving.
	//
	if (RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_PAUSE_RECEIVE))
	{
		RWAN_RELEASE_CONN_LOCK(pConnObject);
		return;
	}

	//
	//  Re-entrancy check.
	//
	if (RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_INDICATING_DATA))
	{
		RWAN_RELEASE_CONN_LOCK(pConnObject);
		return;
	}

	RWAN_SET_BIT(pConnObject->Flags, RWANF_CO_INDICATING_DATA);

	//
	//  Make sure the Connection Object doesn't go away as long
	//  as we are in this routine.
	//
	RWanReferenceConnObject(pConnObject);	// temp ref: RWanIndicateData

	RWANDEBUGP(DL_INFO, DC_DATA_RX,
		("=> Ind-Rcv: VC %x/%x, ReqHead %x, IndHead %x\n",
				pVc, pVc->Flags, pVc->pRcvReqHead, pVc->pRcvIndHead));

	//
	//  Loop till we run out of receive requests/indications.
	//
	for (/* Nothing */;
		 /* Nothing */;
		 /* Nothing */)
	{
		if (pVc->pRcvIndHead == NULL)
		{
			//
			//  No data to pass up. Quit.
			//
			break;
		}

		//
		//  See if we have data available in the current receive indication.
		//
		pRcvInd = pVc->pRcvIndHead;
		if (pRcvInd->TotalBytesLeft == 0)
		{
			//
			//  Move to the next receive indication.
			//
			pNextRcvInd = pRcvInd->pNextRcvInd;
			
			//
			//  Add the current receive indication to the list of receive
			//  indications to be freed up.
			//
			pRcvInd->pNextRcvInd = NULL;
			if (pCompletedRcvIndTail != NULL)
			{
				pCompletedRcvIndTail->pNextRcvInd = pRcvInd;
			}
			else
			{
				pCompletedRcvIndHead = pRcvInd;
			}
			pCompletedRcvIndTail = pRcvInd;

			pVc->PendingPacketCount--;	// Moved packet to completed list

			//
			//  Move to the next receive indication.
			//
			pVc->pRcvIndHead = pNextRcvInd;
			pRcvInd = pNextRcvInd;

			//
			//  See if there are no more receive indications.
			//
			if (pRcvInd == NULL)
			{
				pVc->pRcvIndTail = NULL;
				break;
			}

		}

#if DBG
		if (pRcvInd)
		{
			RWAN_CHECK_DATA("IndicateData:", pRcvInd, pRcvInd->pReadData, pRcvInd->BytesLeftInBuffer);
		}
#endif // DBG

		//
		//  We have data available to pass up.
		//
		//  If we don't have any pending receive requests, and there
		//  is a Receive Indication event handler available, call the
		//  handler. We may get back a receive request.
		//
		if ((pVc->pRcvReqHead == NULL) &&
			(pRcvIndEvent != NULL))
		{
			CONNECTION_CONTEXT		ConnectionHandle;
			ULONG					ReceiveFlags;
			ULONG					BytesIndicated;
			ULONG					BytesTaken;
			ULONG					BytesAvailable;
			PVOID					pTSDU;
			TDI_STATUS				TdiStatus;
#ifdef NT
			EventRcvBuffer *		ERB;
			EventRcvBuffer **		pERB = &ERB;
			PTDI_REQUEST_KERNEL_RECEIVE	pRequestInformation;
			PIO_STACK_LOCATION		pIrpSp;
#else
			EventRcvBuffer			ERB;
			EventRcvBuffer *		pERB = &ERB;
#endif // !NT

			//
			//  Pre-allocate a receive request.
			//
			pRcvReq = RWanAllocateReceiveReq();
			if (pRcvReq == NULL)
			{
				RWAN_ASSERT(FALSE);
				break;
			}

			pRcvInd = pVc->pRcvIndHead;
			ConnectionHandle = pConnObject->ConnectionHandle;
			BytesIndicated = pRcvInd->BytesLeftInBuffer;
			BytesAvailable = pRcvInd->TotalBytesLeft;
			pTSDU = (PVOID)pRcvInd->pReadData;

			RWAN_RELEASE_CONN_LOCK(pConnObject);

			ReceiveFlags = TDI_RECEIVE_NORMAL | TDI_RECEIVE_ENTIRE_MESSAGE;

			BytesTaken = 0;

			RWAN_ASSERT(BytesIndicated != 0);
			RWAN_ASSERT(BytesAvailable != 0);

			TdiStatus = (*pRcvIndEvent)(
							TdiEventContext,
							ConnectionHandle,
							ReceiveFlags,
							BytesIndicated,
							BytesAvailable,
							&BytesTaken,
							pTSDU,
							pERB
							);


			RWANDEBUGP(DL_INFO, DC_DATA_RX,
					("Ind-Rcv: VC %x, Head %x, Indicated %d, Available %d, Bytes taken %d, Status %x\n",
							pVc, pVc->pRcvReqHead, BytesIndicated, BytesAvailable, BytesTaken, TdiStatus));

			RWAN_ACQUIRE_CONN_LOCK(pConnObject);

			//
			//  Check if anything bad happened to this connection
			//  while we were indicating.
			//
			if ((pConnObject->State != RWANS_CO_CONNECTED) ||
				(RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING)))
			{
				RWanFreeReceiveReq(pRcvReq);
				bConnectionInBadState = TRUE;
				break;
			}

			//
			//  See if a receive request is given to us.
			//
			if (TdiStatus == TDI_MORE_PROCESSING)
			{
				//
				//  We have a receive request. Get at it.
				//
#ifdef NT
				NTSTATUS			Status;

				RWAN_ASSERT(ERB != NULL);

				pIrpSp = IoGetCurrentIrpStackLocation(*pERB);

				Status = RWanPrepareIrpForCancel(
								(PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext,
								ERB,
								RWanCancelRequest
								);

				if (NT_SUCCESS(Status))
				{
					pRequestInformation = (PTDI_REQUEST_KERNEL_RECEIVE)
											&(pIrpSp->Parameters);
					pRcvReq->Request.pReqComplete = RWanDataRequestComplete;
					pRcvReq->Request.ReqContext = ERB;
					pRcvReq->TotalBufferLength = pRequestInformation->ReceiveLength;
					pRcvReq->pBuffer = ERB->MdlAddress;
					pRcvReq->pUserFlags = (PUSHORT)
											&(pRequestInformation->ReceiveFlags);
#else
					pRcvReq->Request.pReqComplete = ERB.erb_rtn;
					pRcvReq->Request.ReqContext = ERB.erb_context;
					pRcvReq->TotalBufferLength = ERB.erb_size;
					pRcvReq->pBuffer = ERB.erb_buffer;
					pRcvReq->pUserFlags = ERB.erb_flags;
#endif // NT
					pRcvReq->AvailableBufferLength = pRcvReq->TotalBufferLength;
					NdisQueryBufferSafe(
							pRcvReq->pBuffer,
							&(pRcvReq->pWriteData),
							&(pRcvReq->BytesLeftInBuffer),
							NormalPagePriority
							);

					if (pRcvReq->pWriteData != NULL)
					{
						if (pRcvReq->BytesLeftInBuffer > pRcvReq->AvailableBufferLength)
						{
							RWANDEBUGP(DL_INFO, DC_DATA_RX,
								("Indicate: pRcvReq %x, BytesLeft %d > Available %d, pTdiRequest %x\n",
										pRcvReq,
										pRcvReq->BytesLeftInBuffer,
										pRcvReq->AvailableBufferLength,
										pRequestInformation));

							pRcvReq->BytesLeftInBuffer = pRcvReq->AvailableBufferLength;
						}

						pRcvReq->pNextRcvReq = NULL;


						//
						//  Insert this receive request at the head of the pending
						//  request queue.
						//
						if (pVc->pRcvReqHead == NULL)
						{
							pVc->pRcvReqHead = pVc->pRcvReqTail = pRcvReq;
						}
						else
						{
							RWAN_ASSERT(pVc->pRcvReqTail != NULL);
							pRcvReq->pNextRcvReq = pVc->pRcvReqHead;
							pVc->pRcvReqHead = pRcvReq;
						}
					}
					else
					{
						//
						//  Couldn't get virtual address of MDL passed in.
						//
						TdiStatus = TDI_SUCCESS;
						RWanFreeReceiveReq(pRcvReq);
						pRcvReq = NULL;
					}
#ifdef NT
				}
				else
				{
					//
					//  The IRP was cancelled before it got to us.
					//  Continue as if the user returned SUCCESS.
					//
					TdiStatus = TDI_SUCCESS;
					RWanFreeReceiveReq(pRcvReq);
					pRcvReq = NULL;
				}
#endif // NT

				//
				//  Update based on what was consumed during the Indicate.
				//
				pRcvInd->BytesLeftInBuffer -= BytesTaken;
				pRcvInd->TotalBytesLeft -= BytesTaken;

				//
				//  If we still don't have any pending receive requests, quit.
				//
				if (pVc->pRcvReqHead == NULL)
				{
					RWANDEBUGP(DL_FATAL, DC_WILDCARD,
						("Ind: VC %x/%x, ConnObj %x/%x, RcvInd %x, no pending Req\n",
							pVc, pVc->Flags,
							pConnObject, pConnObject->Flags,
							pRcvInd));
					break;
				}

				//
				//  We have receive requests, so continue from the top.
				//
				continue;

			}
			else
			{
				//
				//  We didn't get a receive request.
				//
				if (TdiStatus == TDI_NOT_ACCEPTED)
				{
					BytesTaken = 0;

					//
					//  By returning this status, the TDI client is telling
					//  us to stop indicating data on this connection until
					//  it sends us a TDI receive.
					//
					RWAN_SET_BIT(pConnObject->Flags, RWANF_CO_PAUSE_RECEIVE);
				}

				//
				//  Update based on what was consumed during the Indicate.
				//
				pRcvInd->BytesLeftInBuffer -= BytesTaken;
				pRcvInd->TotalBytesLeft -= BytesTaken;

				RWanFreeReceiveReq(pRcvReq);

				if (TdiStatus == TDI_SUCCESS)
				{
					continue;
				}
			}
	
		} // if Receive Event handler exists

		//
		//  If we still don't have any pending receive requests, quit.
		//
		if (pVc->pRcvReqHead == NULL)
		{
#if DBG1
			if (pVc->pRcvIndHead && (pVc->pRcvIndHead->TotalBytesLeft == 0))
			{
				RWANDEBUGP(DL_FATAL, DC_WILDCARD,
					("Ind: VC %x/%x, No pending recv reqs, RcvInd empty!\n", pVc, pVc->Flags));
				RWAN_ASSERT(FALSE);
			}
#endif
			break;
		}

		//
		//  Fill in the receive request at the head of the queue
		//  as much as we can.
		//
		pRcvReq = pVc->pRcvReqHead;
		pRcvInd = pVc->pRcvIndHead;

		RWAN_ASSERT(pRcvReq != NULL);
		RWAN_ASSERT(pRcvInd != NULL);

		while (pRcvReq->AvailableBufferLength != 0)
		{
			if (pRcvReq->BytesLeftInBuffer == 0)
			{
				//
				//  Move to the next buffer in the chain.
				//
				RWAN_ADVANCE_RCV_REQ_BUFFER(pRcvReq);
				RWAN_ASSERT(pRcvReq->BytesLeftInBuffer != 0);
			}

			RWAN_ASSERT(pRcvInd != NULL);

			if (pRcvInd->BytesLeftInBuffer == 0)
			{
				RWAN_ADVANCE_RCV_IND_BUFFER(pRcvInd);
				RWAN_ASSERT(pRcvInd->BytesLeftInBuffer != 0);
			}

			BytesToCopy = MIN(pRcvReq->BytesLeftInBuffer, pRcvInd->BytesLeftInBuffer);

			RWANDEBUGP(DL_EXTRA_LOUD, DC_DATA_RX,
					("IndicateData: pVc x%x, pRcvInd x%x, pRcvReq x%x, copying %d bytes, %x to %x\n",
						pVc,
						pRcvInd,
						pRcvReq,
						BytesToCopy,
						pRcvInd->pReadData,
						pRcvReq->pWriteData));

#if DBG
			if (pRcvInd)
			{
				RWAN_CHECK_DATA("IndicateData - copy:", pRcvInd, pRcvInd->pReadData, BytesToCopy);
			}
#endif // DBG
			RWAN_COPY_MEM(pRcvReq->pWriteData,
						 pRcvInd->pReadData,
						 BytesToCopy);
			
			pRcvReq->pWriteData += BytesToCopy;
			pRcvReq->BytesLeftInBuffer -= BytesToCopy;
			pRcvReq->AvailableBufferLength -= BytesToCopy;
#if DBG
			if (pRcvReq->AvailableBufferLength > pRcvReq->TotalBufferLength)
			{
				RWANDEBUGP(DL_INFO, DC_DATA_RX,
					("Indicate: VC %x, RcvRq %x, Avail %d > Total %d, BytesToCopy %d, RcvInd %x\n",
						pVc, pRcvReq,
						pRcvReq->AvailableBufferLength,
						pRcvReq->TotalBufferLength,
						BytesToCopy,
						pRcvInd));

				RWAN_ASSERT(FALSE);
			}
#endif
			pRcvInd->pReadData += BytesToCopy;
			pRcvInd->BytesLeftInBuffer -= BytesToCopy;
			pRcvInd->TotalBytesLeft -= BytesToCopy;

			//
			//  See if we have data available in the current receive indication.
			//
			if (pRcvInd->TotalBytesLeft == 0)
			{
				//
				//  Move to the next receive indication.
				//
				pNextRcvInd = pRcvInd->pNextRcvInd;
				
				//
				//  Add the current receive indication to the list of receive
				//  indications to be freed up.
				//
				pRcvInd->pNextRcvInd = NULL;
				if (pCompletedRcvIndTail != NULL)
				{
					pCompletedRcvIndTail->pNextRcvInd = pRcvInd;
				}
				else
				{
					pCompletedRcvIndHead = pRcvInd;
				}

				pCompletedRcvIndTail = pRcvInd;

				pVc->PendingPacketCount--;	// Moved packet to completed list

				//
				//  Move to the next receive indication.
				//
				pVc->pRcvIndHead = pNextRcvInd;
				pRcvInd = pNextRcvInd;

				//
				//  See if there are no more receive indications.
				//
				if (pRcvInd == NULL)
				{
					pVc->pRcvIndTail = NULL;
					break;
				}

				//
				//  If this connection uses message mode delivery,
				//  we don't allow a receive request to span multiple
				//  received packets.
				//
				if (IsMessageMode)
				{
					break;
				}
			}
		}

		//
		//  A receive request has been filled in either completely
		//  or partially. If we are in message mode, complete the
		//  receive now, otherwise we will wait for more data.
		//
		if ((pRcvReq->AvailableBufferLength == 0) ||
			IsMessageMode)
		{
			TDI_STATUS		ReceiveStatus;
			UINT			BytesCopied;

			//
			//  A receive request has been fully/partially satisfied. Take it
			//  out of the pending list and complete it.
			//
			pVc->pRcvReqHead = pRcvReq->pNextRcvReq;
			if (pVc->pRcvReqHead == NULL)
			{
				pVc->pRcvReqTail = NULL;
			}

			BytesCopied = pRcvReq->TotalBufferLength - pRcvReq->AvailableBufferLength;

			//
			//  Check if we copied in only part of a received packet into
			//  this receive request. If so, indicate an overflow.
			//
			if ((pRcvReq->AvailableBufferLength == 0) &&
				(pVc->pRcvIndHead != NULL) &&
				(pVc->pRcvIndHead->TotalBytesLeft != pVc->pRcvIndHead->PacketLength))
			{
				RWANDEBUGP(DL_LOUD, DC_WILDCARD,
					("Ind-Rcv: Overflow: VC %x/%x, Head %x, BytesCopied %d, Left %d\n",
						pVc, pVc->Flags, pVc->pRcvIndHead, BytesCopied, pVc->pRcvIndHead->TotalBytesLeft));
				ReceiveStatus = TDI_BUFFER_OVERFLOW;
				*(pRcvReq->pUserFlags) = 0;
			}
			else
			{
				ReceiveStatus = TDI_SUCCESS;
				*(pRcvReq->pUserFlags) = TDI_RECEIVE_ENTIRE_MESSAGE;
			}

			RWAN_RELEASE_CONN_LOCK(pConnObject);

			*(pRcvReq->pUserFlags) |= TDI_RECEIVE_NORMAL;

			RWANDEBUGP(DL_INFO, DC_DATA_RX,
				("Ind-Rcv: VC %x/%x, Head %x, completing TDI Rcv %x, %d bytes, Status %x\n",
						pVc, pVc->Flags, pVc->pRcvReqHead, pRcvReq, BytesCopied, ReceiveStatus));

			//
			//  Complete the Receive Req
			//
			(*pRcvReq->Request.pReqComplete)(
						pRcvReq->Request.ReqContext,
						ReceiveStatus,
						BytesCopied
						);
			
			RWanFreeReceiveReq(pRcvReq);

			RWAN_ACQUIRE_CONN_LOCK(pConnObject);

			//
			//  Check if anything bad happened to this connection
			//  while we were completing the receive request.
			//
			if ((pConnObject->State != RWANS_CO_CONNECTED) ||
				(RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING)))
			{
				bConnectionInBadState = TRUE;
				break;
			}
		}

	} // forever


	RWAN_RESET_BIT(pConnObject->Flags, RWANF_CO_INDICATING_DATA);

	rc = RWanDereferenceConnObject(pConnObject);	// end temp ref: RWanIndicateData

	if (rc > 0)
	{
		//
		//  Update receive indication queue on the VC. Only if the VC
		//  is still around...
		//
		if (pVc == pConnObject->NdisConnection.pNdisVc)
		{
			if (bConnectionInBadState)
			{
				ULONG		AbortCount = 0;

				RWANDEBUGP(DL_INFO, DC_DATA_RX,
					("Ind: start abort VC %x/%x state %d, pComplRcvHead %p, tail %p\n",
						pVc, pVc->Flags, pVc->State, pCompletedRcvIndHead, pCompletedRcvIndTail));
				//
				//  Take out all pending receives.
				//
				for (pRcvInd = pVc->pRcvIndHead;
 					pRcvInd != NULL;
 					pRcvInd = pNextRcvInd)
				{
					pNextRcvInd = pRcvInd->pNextRcvInd;

					pRcvInd->pNextRcvInd = NULL;
					if (pCompletedRcvIndTail != NULL)
					{
						pCompletedRcvIndTail->pNextRcvInd = pRcvInd;
					}
					else
					{
						pCompletedRcvIndHead = pRcvInd;
					}

					pCompletedRcvIndTail = pRcvInd;

					pVc->PendingPacketCount--;	// Abort: Moved packet to completed list
					AbortCount++;
				}

				pVc->pRcvIndHead = pVc->pRcvIndTail = NULL;

				RWANDEBUGP(DL_INFO, DC_DATA_RX,
					("Ind: end abort VC %x/%x state %d, pComplRcvHead %p, tail %p, Count %d\n",
						pVc, pVc->Flags, pVc->State, pCompletedRcvIndHead, pCompletedRcvIndTail, AbortCount));
			}
			else
			{
				//
				//  Update the first Receive Indication if necessary.
				//
				if (pVc->pRcvIndHead &&
					(pVc->pRcvIndHead->TotalBytesLeft == 0))
				{
					RWANDEBUGP(DL_LOUD, DC_WILDCARD,
						("Ind: VC %x/%x, empty pRcvInd at head %x\n", pVc, pVc->Flags,
							pVc->pRcvIndHead));

					pRcvInd = pVc->pRcvIndHead;
					pNextRcvInd = pRcvInd->pNextRcvInd;

					pRcvInd->pNextRcvInd = NULL;

					if (pCompletedRcvIndTail != NULL)
					{
						pCompletedRcvIndTail->pNextRcvInd = pRcvInd;
					}
					else
					{
						pCompletedRcvIndHead = pRcvInd;
					}

					pCompletedRcvIndTail = pRcvInd;

					pVc->PendingPacketCount--;	// IndComplete: Moved packet to completed list

					pVc->pRcvIndHead = pNextRcvInd;
					if (pVc->pRcvIndHead == NULL)
					{
						pVc->pRcvIndTail = NULL;
					}
				}
			}
		}
#if DBG
		else
		{
			RWANDEBUGP(DL_FATAL, DC_DATA_RX, ("Ind: ConnObj %p, VC %p blown away!\n",
							pConnObject, pVc));
		}
#endif // DBG

		//
		//  Check if we had queued up an IncomingClose while indicating data:
		//
		if (RWAN_IS_FLAG_SET(pConnObject->Flags, RWANF_CO_PENDED_DISCON, RWANF_CO_PENDED_DISCON))
		{
			RWAN_RESET_BIT(pConnObject->Flags, RWANF_CO_PENDED_DISCON);

			RWANDEBUGP(DL_FATAL, DC_DATA_RX, ("Ind: Conn %x, State %d, Addr %x, handling pended discon\n",
					pConnObject, pConnObject->State, pConnObject->pAddrObject));

			if (pConnObject->pAddrObject != NULL_PRWAN_TDI_ADDRESS)
			{
				PDisconnectEvent			pDisconInd;
				PVOID						IndContext;
				PVOID						ConnectionHandle;

				pDisconInd = pConnObject->pAddrObject->pDisconInd;
				IndContext = pConnObject->pAddrObject->DisconIndContext;

				if (pDisconInd != NULL)
				{
					RWANDEBUGP(DL_FATAL, DC_DATA_RX,
						("IndicateData: pConnObj %x/%x, st %x, will discon ind\n",
							pConnObject, pConnObject->Flags, pConnObject->State));

					pConnObject->State = RWANS_CO_DISCON_INDICATED;
					ConnectionHandle = pConnObject->ConnectionHandle;

					RWanScheduleDisconnect(pConnObject);
					bContinue = FALSE;

					(*pDisconInd)(
							IndContext,
							ConnectionHandle,
							0,			// Disconnect Data Length
							NULL,		// Disconnect Data
							0,			// Disconnect Info Length
							NULL,		// Disconnect Info
							TDI_DISCONNECT_RELEASE
							);
				}
				else
				{
					RWAN_ASSERT(FALSE);
				}
			}
			else
			{
				RWAN_ASSERT(FALSE);
			}
		}

		//
		//  Check if we need to close this connection.
		//
		if (bContinue)
		{
			if (RWAN_IS_BIT_SET(pVc->Flags, RWANF_VC_NEEDS_CLOSE))
			{
				RWanStartCloseCall(pConnObject, pVc);
			}
			else
			{
				RWAN_RELEASE_CONN_LOCK(pConnObject);
			}
		}
	}

	//
	//  Link all completed receive indications to the list on this adapter.
	//  They will be returned to the miniport in the ReceiveComplete
	//  handler.
	//
	RWAN_ACQUIRE_GLOBAL_LOCK();

	{
		PRWAN_RECEIVE_INDICATION *	ppRcvIndTail;

		ppRcvIndTail = &(pAdapter->pCompletedReceives);
		while (*ppRcvIndTail != NULL)
		{
			ppRcvIndTail = &((*ppRcvIndTail)->pNextRcvInd);
		}

#if DBG
		if (bConnectionInBadState)
		{
			RWANDEBUGP(DL_INFO, DC_WILDCARD,
				("Ind: Adapter %p &ComplRcvs %p ComplRcvs %p, will tack on %p\n",
						pAdapter,
						&pAdapter->pCompletedReceives,
						pAdapter->pCompletedReceives,
						pCompletedRcvIndHead));
		}
#endif // DBG

		*ppRcvIndTail = pCompletedRcvIndHead;

	}

	RWAN_RELEASE_GLOBAL_LOCK();

}




VOID
RWanNdisReceiveComplete(
    IN	NDIS_HANDLE					ProtocolBindingContext
	)
/*++

Routine Description:

	This is the entry point called by NDIS when the miniport
	informs it that it has completed indicating a bunch of
	received packets.

	We use this event to free up any completed receives
	on this adapter binding.

Arguments:

	ProtocolBindingContext	- Pointer to our Adapter structure

Return Value:

	None

--*/
{
	PRWAN_NDIS_ADAPTER			pAdapter;
	PRWAN_RECEIVE_INDICATION		pRcvInd;

	pAdapter = (PRWAN_NDIS_ADAPTER)ProtocolBindingContext;
	RWAN_STRUCT_ASSERT(pAdapter, nad);

	//
	//  Detach the list of completed receives from the adapter.
	//
	RWAN_ACQUIRE_GLOBAL_LOCK();

	pRcvInd = pAdapter->pCompletedReceives;
	pAdapter->pCompletedReceives = NULL;

	RWAN_RELEASE_GLOBAL_LOCK();

	RWanFreeReceiveIndList(pRcvInd);

	return;
}



VOID
RWanNdisTransferDataComplete(
    IN	NDIS_HANDLE					ProtocolBindingContext,
    IN	PNDIS_PACKET				pNdisPacket,
    IN	NDIS_STATUS					Status,
    IN	UINT						BytesTransferred
    )
/*++

Routine Description:


Arguments:


Return Value:

	None

--*/
{
	// Not expected.
	RWAN_ASSERT(FALSE);
}




NDIS_STATUS
RWanNdisReceive(
    IN	NDIS_HANDLE					ProtocolBindingContext,
    IN	NDIS_HANDLE					MacReceiveContext,
    IN	PVOID						HeaderBuffer,
    IN	UINT						HeaderBufferSize,
    IN	PVOID						pLookAheadBuffer,
    IN	UINT						LookAheadBufferSize,
    IN	UINT						PacketSize
    )
/*++

Routine Description:

Arguments:


Return Value:

	None

--*/
{
	// Not expected.
	RWAN_ASSERT(FALSE);
	return (NDIS_STATUS_FAILURE);
}




INT
RWanNdisReceivePacket(
    IN	NDIS_HANDLE					ProtocolBindingContext,
    IN	PNDIS_PACKET				pNdisPacket
    )
/*++

Routine Description:

Arguments:


Return Value:

	None

--*/
{
	// Not expected.
	RWAN_ASSERT(FALSE);
	return (0);
}




PRWAN_RECEIVE_REQUEST
RWanAllocateReceiveReq(
	VOID
	)
/*++

Routine Description:

	Allocate a structure to keep context of a TDI Receive request.

Arguments:

	None

Return Value:

	Pointer to the allocated receive request structure, or NULL.

--*/
{
	PRWAN_RECEIVE_REQUEST		pRcvReq;

	RWAN_ALLOC_MEM(pRcvReq, RWAN_RECEIVE_REQUEST, sizeof(RWAN_RECEIVE_REQUEST));

	if (pRcvReq != NULL)
	{
		RWAN_SET_SIGNATURE(pRcvReq, nrr);
	}

	return (pRcvReq);
}




VOID
RWanFreeReceiveReq(
    IN	PRWAN_RECEIVE_REQUEST		pRcvReq
   	)
/*++

Routine Description:

	Free a receive request structure.

Arguments:

	pRcvReq			- Points to structure to be freed

Return Value:

	None

--*/
{
	RWAN_STRUCT_ASSERT(pRcvReq, nrr);

	RWAN_FREE_MEM(pRcvReq);
}




PRWAN_RECEIVE_INDICATION
RWanAllocateReceiveInd(
	VOID
	)
/*++

Routine Description:

	Allocate a structure to keep context about an NDIS receive indication.

Arguments:

	None

Return Value:

	Pointer to the allocated structure, or NULL.

--*/
{
	PRWAN_RECEIVE_INDICATION		pRcvInd;

	RWAN_ALLOC_MEM(pRcvInd, RWAN_RECEIVE_INDICATION, sizeof(RWAN_RECEIVE_INDICATION));

	if (pRcvInd != NULL)
	{
		RWAN_SET_SIGNATURE(pRcvInd, nri);
	}

	return (pRcvInd);
}




VOID
RWanFreeReceiveInd(
	IN	PRWAN_RECEIVE_INDICATION		pRcvInd
	)
/*++

Routine Description:

	Free a receive indication structure.

Arguments:

	pRcvInd		- Points to structure to be freed.

Return Value:

	None

--*/
{
	RWAN_STRUCT_ASSERT(pRcvInd, nri);
	RWAN_FREE_MEM(pRcvInd);
}




PNDIS_PACKET
RWanMakeReceiveCopy(
    IN	PNDIS_PACKET				pNdisPacket
	)
/*++

Routine Description:

	Make a copy of a received packet to a private packet.

Arguments:

	pNdisPacket	- Points to original packet

Return Value:

	Pointer to private packet if successful, NULL otherwise.

--*/
{
	PNDIS_PACKET		pNewPacket;
	PNDIS_BUFFER		pNewBuffer;
	PUCHAR				pData;
	UINT				TotalLength;
	UINT				BytesCopied;
	NDIS_STATUS			Status;

	//
	//  Initialize.
	//
	pNewPacket = NULL;
	pNewBuffer = NULL;
	pData = NULL;

	do
	{
		NdisQueryPacket(
				pNdisPacket,
				NULL,
				NULL,
				NULL,
				&TotalLength
				);

		//
		//  Allocate space for the data.
		//
		RWAN_ALLOC_MEM(pData, UCHAR, TotalLength);
		if (pData == NULL)
		{
			break;
		}

		//
		//  Make this an NDIS Buffer (MDL).
		//
		NdisAllocateBuffer(
				&Status,
				&pNewBuffer,
				RWanCopyBufferPool,
				pData,
				TotalLength
				);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		//
		//  Allocate a new packet.
		//
		NdisAllocatePacket(
				&Status,
				&pNewPacket,
				RWanCopyPacketPool
				);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		NDIS_SET_PACKET_STATUS(pNewPacket, 0);

		//
		//  Link the buffer to the packet.
		//
		NdisChainBufferAtFront(pNewPacket, pNewBuffer);

		//
		//  Copy in the received packet.
		//
		NdisCopyFromPacketToPacket(
				pNewPacket,
				0,	// Destn offset
				TotalLength,
				pNdisPacket,
				0,	// Source offset
				&BytesCopied
				);

		RWAN_ASSERT(BytesCopied == TotalLength);

		break;
	}
	while (FALSE);

	if (pNewPacket == NULL)
	{
		//
		//  Clean up.
		//
		if (pData != NULL)
		{
			RWAN_FREE_MEM(pData);
		}

		if (pNewBuffer != NULL)
		{
			NdisFreeBuffer(pNewBuffer);
		}
	}

	return (pNewPacket);
}




VOID
RWanFreeReceiveCopy(
    IN	PNDIS_PACKET				pCopyPacket
	)
/*++

Routine Description:

	Free a packet that was used to keep a copy of a received packet,
	and its components (buffer etc).

Arguments:

	pCopyPacket	- Points to packet to be freed.

Return Value:

	None

--*/
{
	PNDIS_BUFFER	pCopyBuffer;
	PUCHAR			pCopyData;
	UINT			TotalLength;
	UINT			BufferLength;

	NdisGetFirstBufferFromPacket(
			pCopyPacket,
			&pCopyBuffer,
			(PVOID *)&pCopyData,
			&BufferLength,
			&TotalLength
			);
	
	RWAN_ASSERT(BufferLength == TotalLength);

	RWAN_ASSERT(pCopyBuffer != NULL);

	NdisFreePacket(pCopyPacket);

	NdisFreeBuffer(pCopyBuffer);

	RWAN_FREE_MEM(pCopyData);

	return;
}



VOID
RWanFreeReceiveIndList(
	IN	PRWAN_RECEIVE_INDICATION		pRcvInd
	)
/*++

Routine Description:

	Free a list of receive indications, and return any packets in there
	that belong to the miniport.

Arguments:

	pRcvInd				- Head of list of receives.

Return Value:

	None

--*/
{
	PRWAN_RECEIVE_INDICATION		pNextRcvInd;
	PNDIS_PACKET				pNdisPacket;
#if DBG
	RWAN_IRQL					EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	while (pRcvInd != NULL)
	{
		pNextRcvInd = pRcvInd->pNextRcvInd;

		pNdisPacket = pRcvInd->pPacket;

		RWANDEBUGP(DL_EXTRA_LOUD, DC_DATA_RX,
				("FreeRcvIndList: freeing Pkt x%x, RcvInd x%x\n",
						pNdisPacket, pRcvInd));

		if (pRcvInd->bIsMiniportPacket)
		{
			NdisReturnPackets(&pNdisPacket, 1);
		}
		else
		{
			RWanFreeReceiveCopy(pNdisPacket);
		}

		RWanFreeReceiveInd(pRcvInd);

		pRcvInd = pNextRcvInd;
	}

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\space.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\space.c

Abstract:

	Globals and tunables.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     05-29-97    Created

Notes:

--*/

#define _FILENUMBER 'CAPS'

#include <precomp.h>



ULONG	RWanMaxTdiConnections = 4096;


struct _RWAN_AFSP_MODULE_CHARS	RWanMediaSpecificInfo[] =
								{
									{
										RWanAtmSpInitialize,
										RWanAtmSpShutdown
									},
									{
										(AFSP_INIT_HANDLER)0,
										(AFSP_SHUTDOWN_HANDLER)0
									}
								};


//
//  Receive pools.
//
NDIS_HANDLE						RWanCopyBufferPool;
NDIS_HANDLE						RWanCopyPacketPool;

//
//  Send pools.
//
NDIS_HANDLE						RWanSendPacketPool;


RWAN_GLOBALS					RWanGlobals = { 0 };
PRWAN_GLOBALS					pRWanGlobal;

NDIS_PROTOCOL_CHARACTERISTICS	RWanNdisProtocolCharacteristics;
NDIS_CLIENT_CHARACTERISTICS		RWanNdisClientCharacteristics;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\rwandata.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\nltdata.h

Abstract:

	All private data structure definitions for Null Transport.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     04-17-97    Created

Notes:

--*/

#ifndef __TDI_RWANDATA__H
#define __TDI_RWANDATA__H



//
//  Forward definitions
//
struct _RWAN_TDI_CONNECTION ;
struct _RWAN_TDI_ADDRESS ;
struct _RWAN_NDIS_VC ;
struct _RWAN_NDIS_SAP ;
struct _RWAN_NDIS_AF ;
struct _RWAN_NDIS_AF_INFO ;
struct _RWAN_TDI_PROTOCOL ;

struct _RWAN_CONN_REQUEST ;
struct _RWAN_RECEIVE_INDICATION ;


typedef UCHAR				RWAN_CONN_INSTANCE;
typedef ULONG				RWAN_CONN_ID;



//
//  Completion routines.
//
typedef
VOID
(*PCOMPLETE_RTN)(PVOID CompletionContext, UINT, UINT);

typedef
VOID
(*PDATA_COMPLETE_RTN)(PVOID CompletionContext, UINT Status, UINT ByteCount);

typedef
VOID
(*PDELETE_COMPLETE_RTN)(PVOID CompletionContext);


//
//  A structure to hold a call-back routine and context to
//  be called when a structure is dereferenced away.
//
typedef struct _RWAN_DELETE_NOTIFY
{
	PCOMPLETE_RTN					pDeleteRtn;
	PVOID							DeleteContext;

} RWAN_DELETE_NOTIFY, *PRWAN_DELETE_NOTIFY;




//
//  ***** TDI Connection Object *****
//
//  Our context for a TDI Connection Object. This is created during
//  TdiOpenConnection(), and deleted during TdiCloseConnection().
//
//  Reference Count keeps track of:
//  - TdiOpenConnection
//  - Linkage to Address Object
//  - Linkage to NDIS VC or NDIS Party
//  - Each party in list on VC (for C-Root)
//  - Each work item queued for this Conn Object
//
typedef struct _RWAN_TDI_CONNECTION
{
#if DBG
	ULONG							ntc_sig;
#endif
	INT								RefCount;
	USHORT							State;
	USHORT							Flags;				// Pending events etc
	PVOID							ConnectionHandle;	// TDI handle
	struct _RWAN_TDI_ADDRESS *		pAddrObject;		// Associated Address Object
	LIST_ENTRY						ConnLink;			// In list of connections on
														// address object
	RWAN_HANDLE						AfSpConnContext;	// Media-Sp module's context
	RWAN_LOCK						Lock;				// Mutex
	union {
		struct _RWAN_NDIS_VC *	pNdisVc;
		struct _RWAN_NDIS_PARTY *pNdisParty;
	}								NdisConnection;
	struct _RWAN_TDI_CONNECTION *	pRootConnObject;	// For PMP Calls
	RWAN_CONN_INSTANCE				ConnInstance;		// Used to validate Conn Context
	RWAN_DELETE_NOTIFY				DeleteNotify;		// Things to do on freeing this
	struct _RWAN_CONN_REQUEST *		pConnReq;			// Info about a pended TDI request
	NDIS_WORK_ITEM					CloseWorkItem;		// Used to schedule a Close
	struct _RWAN_NDIS_VC *			pNdisVcSave;
#if DBG
	ULONG							ntcd_sig;
	USHORT							OldState;
	USHORT							OldFlags;
#endif

} RWAN_TDI_CONNECTION, *PRWAN_TDI_CONNECTION;

#if DBG
#define ntc_signature				'cTwR'
#endif // DBG

#define NULL_PRWAN_TDI_CONNECTION	((PRWAN_TDI_CONNECTION)NULL)

//
//  TDI Connection Object states
//
#define RWANS_CO_CREATED			0x0000	// After TdiOpenConnection
#define RWANS_CO_ASSOCIATED			0x0001	// After TdiAssociateAddress
#define RWANS_CO_LISTENING			0x0002	// After TdiListen
#define RWANS_CO_OUT_CALL_INITIATED	0x0003	// TdiConnect in progress
#define RWANS_CO_IN_CALL_INDICATED	0x0004	// Incoming call indicated to user
#define RWANS_CO_IN_CALL_ACCEPTING	0x0005	// TdiAccept in progress
#define RWANS_CO_CONNECTED			0x0006	// Connection established
#define RWANS_CO_DISCON_INDICATED	0x0007	// Incoming release indicated to user
#define RWANS_CO_DISCON_HELD		0x0008	// Incoming release not indicated to user
#define RWANS_CO_DISCON_REQUESTED	0x0009	// TdiDisconnect in progress
#define RWANS_CO_ABORTING			0x000A	// Aborting

//
//  TDI Connection Object flags
//
#define RWANF_CO_LEAF				0x0001	// This is a PMP leaf conn object
#define RWANF_CO_ROOT				0x0002	// This is a PMP root conn object
#define RWANF_CO_INDICATING_DATA	0x0010	// Receive processing going on
#define RWANF_CO_PAUSE_RECEIVE		0x0020	// The TDI Client has paused receiving
#define RWANF_CO_AFSP_CONTEXT_VALID	0x0040	// AfSpConnContext is valid
#define RWANF_CO_PENDED_DISCON		0x0100	// Pended a DisconInd until data ind is over
#define RWANF_CO_CLOSE_SCHEDULED	0x4000	// Scheduled work item for Closing
#define RWANF_CO_CLOSING			0x8000	// TdiCloseConnection in progress




//
//  ***** TDI Address Object *****
//
//  This is created on processing TdiOpenAddress, and deleted during
//  TdiCloseAddress. If this is a non-NULL (i.e. listening) address object,
//  we also register NDIS SAPs on all adapters supporting this address
//  family.
//
//  Reference Count keeps track of:
//  - TdiOpenAddress
//  - Each Connection Object associated with this
//  - Each NDIS SAP registered for this
//  
typedef struct _RWAN_TDI_ADDRESS
{
#if DBG
	ULONG							nta_sig;
#endif // DBG
	INT								RefCount;
	USHORT							State;
	USHORT							Flags;				// Pending events etc
	struct _RWAN_TDI_PROTOCOL *		pProtocol;			// Back ptr to protocol
	RWAN_HANDLE						AfSpAddrContext;	// Media-Sp module's context
	struct _RWAN_TDI_CONNECTION *	pRootConnObject;	// For PMP Calls
	LIST_ENTRY						AddrLink;			// In list of Address Objects
	LIST_ENTRY						IdleConnList;		// After TDI_ASSOCIATE_ADDRESS
	LIST_ENTRY						ListenConnList;		// After TDI_LISTEN
	LIST_ENTRY						ActiveConnList;		// After connection setup
	LIST_ENTRY						SapList;			// List of RWAN_NDIS_SAP structs
	RWAN_EVENT						Event;				// Used for synchronization
	RWAN_LOCK						Lock;				// Mutex
	RWAN_DELETE_NOTIFY				DeleteNotify;		// Things to do on freeing this
	PConnectEvent					pConnInd;			// Connect Indication up-call
	PVOID							ConnIndContext;		// Context for Connect
	PDisconnectEvent				pDisconInd;			// Disconnect Indication up-call
	PVOID							DisconIndContext;	// Context for Disconnect
	PErrorEvent						pErrorInd;			// Error Indication up-call
	PVOID							ErrorIndContext;	// Context for Error
	PRcvEvent						pRcvInd;			// Receive Indication up-call
	PVOID							RcvIndContext;		// Context for Receive
	USHORT							AddressType;		// From TdiOpenAddress
	USHORT							AddressLength;		// From TdiOpenAddress
	PVOID							pAddress;			// Protocol-dependent string
	NDIS_STATUS						SapStatus;			// Failure from RegisterSap

} RWAN_TDI_ADDRESS, *PRWAN_TDI_ADDRESS;

#if DBG
#define nta_signature				'aTwR'
#endif // DBG

#define NULL_PRWAN_TDI_ADDRESS		((PRWAN_TDI_ADDRESS)NULL)

//
//  Bit definitions for Flags in RWAN_TDI_ADDRESS
//
#define RWANF_AO_PMP_ROOT				0x0001			// Root of an outgoing PMP call
#define RWANF_AO_CLOSING				0x8000			// TdiCloseAddress() in progress
#define RWANF_AO_AFSP_CONTEXT_VALID		0x0040			// AfSpAddrContext is valid



//
//  ***** NDIS VC Block *****
//
//  Created during a CoCreateVc operation, and contains our context for
//  an NDIS VC. For an outgoing call, creation is initiated by us, by
//  calling NdisCoCreateVc. For an incoming call, the Call Manager initiates
//  VC creation.
//
typedef struct _RWAN_NDIS_VC
{
#if DBG
	ULONG							nvc_sig;
#endif
	USHORT							State;
	USHORT							Flags;				// Pending events etc
	NDIS_HANDLE						NdisVcHandle;		// For all NDIS calls
	struct _RWAN_TDI_CONNECTION *	pConnObject;		// To Connection Object
	PCO_CALL_PARAMETERS				pCallParameters;	// Call setup parameters
	struct _RWAN_NDIS_AF *			pNdisAf;			// Back pointer
	struct _RWAN_NDIS_PARTY *		pPartyMakeCall;		// First party in PMP call
	LIST_ENTRY						VcLink;				// In list of all VCs on AF
	LIST_ENTRY						NdisPartyList;		// List of NDIS Party (PMP only)
	ULONG							AddingPartyCount;	// Pending NdisClAddParty/MakeCall
	ULONG							ActivePartyCount;	// Connected parties
	ULONG							DroppingPartyCount;	// Pending NdisClDropParty
	ULONG							PendingPacketCount;	// Pending send+rcv packets
	ULONG							MaxSendSize;
	struct _RWAN_RECEIVE_INDICATION *pRcvIndHead;		// Head of the receive ind queue
	struct _RWAN_RECEIVE_INDICATION *pRcvIndTail;		// Tail of the receive ind queue
	struct _RWAN_RECEIVE_REQUEST *	pRcvReqHead;		// Head of the receive req queue
	struct _RWAN_RECEIVE_REQUEST *	pRcvReqTail;		// Tail of the receive req queue
#if DBG_LOG_PACKETS
	ULONG							DataLogSig;
	ULONG							Index;
	struct _RWAND_DATA_LOG_ENTRY	DataLog[MAX_RWAND_PKT_LOG];
#endif
} RWAN_NDIS_VC, *PRWAN_NDIS_VC;

#if DBG
#define nvc_signature				'cVwR'
#endif // DBG

#define NULL_PRWAN_NDIS_VC			((PRWAN_NDIS_VC)NULL)

//
//  NDIS VC flags
//
#define RWANF_VC_OUTGOING			0x0001	// Created by us.
#define RWANF_VC_PMP				0x0002	// Point to Multipoint call
#define RWANF_VC_CLOSING_CALL		0x8000	// NdisClCloseCall in progress
#define RWANF_VC_NEEDS_CLOSE		0x4000	// Waiting for conditions to be right
											// for NdisClCloseCall

//
// Various events seen on the VC
//
#define RWANF_VC_EVT_MAKECALL_OK	0x0010
#define RWANF_VC_EVT_MAKECALL_FAIL	0x0020
#define RWANF_VC_EVT_INCALL			0x0040
#define RWANF_VC_EVT_CALLCONN		0x0080
#define RWANF_VC_EVT_INCLOSE		0x0100
#define RWANF_VC_EVT_CLOSECOMP		0x0200


//
//  ***** NDIS Party Block *****
//
//  Represents our context for a party of an outgoing point to multipoint
//  NDIS call. This is created on processing a Winsock2 JoinLeaf, and deleted
//  when the leaf is no longer a member of the connection.
//
typedef struct _RWAN_NDIS_PARTY
{
#if DBG
	ULONG							npy_sig;
#endif // DBG
	USHORT							State;
	USHORT							Flags;				// Pending events etc
	NDIS_HANDLE						NdisPartyHandle;	// Supplied by NDIS
	struct _RWAN_NDIS_VC *			pVc;				// Back pointer
	struct _RWAN_TDI_CONNECTION *	pConnObject;		// To Connection Object
	LIST_ENTRY						PartyLink;			// To next party on VC
	PCO_CALL_PARAMETERS				pCallParameters;	// Party setup parameters

} RWAN_NDIS_PARTY, *PRWAN_NDIS_PARTY;

#if DBG
#define npy_signature				'yPwR'
#endif // DBG

#define NULL_PRWAN_NDIS_PARTY		((PRWAN_NDIS_PARTY)NULL)

#define RWANF_PARTY_DROPPING		0x8000


//
//  ***** NDIS SAP Block *****
//
//  This represents our context for an NDIS Service Access Point (SAP).
//  When a new Address Object is created, and it represents a listening
//  endpoint, we register SAPs on all adapters that support the bound
//  address family. A SAP block contains information for one such SAP.
//
typedef struct _RWAN_NDIS_SAP
{
#if DBG
	ULONG							nsp_sig;
#endif // DBG
	struct _RWAN_TDI_ADDRESS *		pAddrObject;		// Back pointer
	USHORT							Flags;
	LIST_ENTRY						AddrObjLink;		// To list of SAPs on addr object
	LIST_ENTRY						AfLink;				// To list of SAPs on AF
	NDIS_HANDLE						NdisSapHandle;		// Supplied by NDIS
	struct _RWAN_NDIS_AF *			pNdisAf;			// Back pointer
	PCO_SAP							pCoSap;

} RWAN_NDIS_SAP, *PRWAN_NDIS_SAP;

#if DBG
#define nsp_signature				'pSwR'
#endif // DBG

#define NULL_PRWAN_NDIS_SAP			((PRWAN_NDIS_SAP)NULL)

#define RWANF_SAP_CLOSING			0x8000



//
//  ***** NDIS AF Block *****
//
//  This represents our context for an NDIS Address Family open.
//  When we get notified of a Call Manager that supports a protocol
//  that is of interest to us, on an adapter that we are bound to,
//  we open the AF represented by the Call Manager. This goes away
//  when we unbind from the adapter.
//
//  Note that there could be multiple Call Managers running over
//  a single adapter, each supporting a different NDIS AF.
//
//  An NDIS AF supports one or more Winsock2 triples: <Family, Type, Proto>.
//
//  Reference Count keeps track of:
//  - OpenAf
//  - Each VC on this AF open
//  - Each SAP on this AF open
// 
typedef struct _RWAN_NDIS_AF
{
#if DBG
	ULONG							naf_sig;
#endif // DBG
	INT								RefCount;			// Reference Count
	USHORT							State;
	USHORT							Flags;				// Pending events etc
	LIST_ENTRY						AfLink;				// In list of AFs on adapter
	NDIS_HANDLE						NdisAfHandle;		// Supplied by NDIS
	LIST_ENTRY						NdisVcList;			// List of open VCs
	LIST_ENTRY						NdisSapList;		// List of registered SAPs
	RWAN_HANDLE						AfSpAFContext;		// AF-specific module's context
														// for this open
	struct _RWAN_NDIS_ADAPTER *		pAdapter;			// Back pointer
	struct _RWAN_NDIS_AF_INFO *		pAfInfo;			// Information about this NDIS AF
	LIST_ENTRY						AfInfoLink;			// In list of AFs with same Info
	RWAN_LOCK						Lock;				// Mutex
	ULONG							MaxAddrLength;		// For this Address Family
	RWAN_DELETE_NOTIFY				DeleteNotify;		// Things to do on freeing this

} RWAN_NDIS_AF, *PRWAN_NDIS_AF;

#if DBG
#define naf_signature				'fAwR'
#endif // DBG

#define NULL_PRWAN_NDIS_AF			((PRWAN_NDIS_AF)NULL)

#define RWANF_AF_CLOSING			0x8000
#define RWANF_AF_IN_ADAPTER_LIST	0x0001				// AfLink is valid



//
//  ***** NDIS Adapter Block *****
//
//  This is our context for an NDIS Adapter Binding. One of these is
//  created for each adapter that we bind to.
//
typedef struct _RWAN_NDIS_ADAPTER
{
#if DBG
	ULONG							nad_sig;
#endif
	USHORT							State;
	USHORT							Flags;				// Pending events etc
	NDIS_HANDLE						NdisAdapterHandle;	// Supplied by NDIS
	NDIS_MEDIUM						Medium;				// Supported by adapter
	PNDIS_MEDIUM					pMediaArray;		// Used in NdisOpenAdapter
	UINT							MediumIndex;		// Used in NdisOpenAdapter
	PVOID							BindContext;		// From BindAdapter/UnbindAdapter
	RWAN_LOCK						Lock;				// Mutex
	LIST_ENTRY						AdapterLink;		// In list of all adapters
	LIST_ENTRY						AfList;				// List of opened AFs on adapter
	struct _RWAN_RECEIVE_INDICATION *pCompletedReceives;	// List of completed rcv indns
	NDIS_STRING						DeviceName;			// Name of adapter

} RWAN_NDIS_ADAPTER, *PRWAN_NDIS_ADAPTER;

#if DBG
#define nad_signature				'dAwR'
#endif // DBG

#define NULL_PRWAN_NDIS_ADAPTER		((PRWAN_NDIS_ADAPTER)NULL)

//
//  Adapter states:
//
#define RWANS_AD_CREATED			0x0000
#define RWANS_AD_OPENING			0x0001
#define RWANS_AD_OPENED				0x0002
#define RWANS_AD_CLOSING			0x0003

//
//  Adapter flags:
//
#define RWANF_AD_UNBIND_PENDING		0x0001



//
//  ***** TDI Protocol Block *****
//
//  Maintains information about one Winsock protocol <Family, Protocol, Type>
//  supported by NullTrans. On NT, each TDI protocol block is represented
//  by a Device Object.
//
typedef struct _RWAN_TDI_PROTOCOL
{
#if DBG
	ULONG							ntp_sig;
#endif // DBG
	UINT							TdiProtocol;		// Matches TdiOpenAddress
	UINT							SockAddressFamily;
	UINT							SockProtocol;
	UINT							SockType;
	PVOID							pRWanDeviceObject;	// NT: to RWAN_DEVICE_OBJECT
	BOOLEAN							bAllowAddressObjects;
	BOOLEAN							bAllowConnObjects;
	USHORT							MaxAddrLength;		// For this TDI protocol
	LIST_ENTRY						AddrObjList;		// List of open AddressObjects
	LIST_ENTRY						TdiProtocolLink;	// In list of all TDI protocols
	struct _RWAN_NDIS_AF_INFO *		pAfInfo;			// NDIS Address Family
	LIST_ENTRY						AfInfoLink;			// List of TDI Protocols on AfInfo
	RWAN_EVENT						Event;				// Used for synchronization
	AFSP_DEREG_TDI_PROTO_COMP_HANDLER   pAfSpDeregTdiProtocolComplete;
	TDI_PROVIDER_INFO				ProviderInfo;
	TDI_PROVIDER_STATISTICS			ProviderStats;

} RWAN_TDI_PROTOCOL, *PRWAN_TDI_PROTOCOL;

#if DBG
#define ntp_signature				'pTwR'
#endif // DBG

#define NULL_PRWAN_TDI_PROTOCOL		((PRWAN_TDI_PROTOCOL)NULL)



//
//  ***** NDIS Address-Family Information Block *****
//
//  This contains information about a supported <NDIS AF, NDIS Medium> pair.
//  Each such pair could support one or more TDI Protocols, each identified by a
//  <Family, Protocol, Type> triple.
// 
typedef struct _RWAN_NDIS_AF_INFO
{
#if DBG
	ULONG							nai_sig;
#endif // DBG
	USHORT							Flags;
	LIST_ENTRY						AfInfoLink;			// In list of supported NDIS AFs
	LIST_ENTRY						TdiProtocolList;	// List of RWAN_TDI_PROTOCOL
	LIST_ENTRY						NdisAfList;			// List of RWAN_NDIS_AF
	RWAN_HANDLE						AfSpContext;		// AF-specific module's context
	RWAN_NDIS_AF_CHARS				AfChars;

} RWAN_NDIS_AF_INFO, *PRWAN_NDIS_AF_INFO;

#if DBG
#define nai_signature				'iAwR'
#endif // DBG

#define RWANF_AFI_CLOSING			0x8000



//
//  ***** Global Information Block *****
//
//  Root of all information for NullTrans. One of these structures exists
//  per system.
//
typedef struct _RWAN_GLOBALS
{
#if DBG
	ULONG							nlg_sig;
#endif // DBG
	NDIS_HANDLE						ProtocolHandle;		// from NdisRegisterProtocol
	LIST_ENTRY						AfInfoList;			// All supported NDIS AFs
	ULONG							AfInfoCount;		// Size of above list
	LIST_ENTRY						ProtocolList;		// All supported TDI protocols
	ULONG							ProtocolCount;		// Size of above list
	LIST_ENTRY						AdapterList;		// All bound adapters
	ULONG							AdapterCount;		// Size of above list
	RWAN_LOCK						GlobalLock;			// Mutex
	RWAN_LOCK						AddressListLock;	// Mutex for AddrObject table
	RWAN_LOCK						ConnTableLock;		// Mutex for ConnObject table

	RWAN_CONN_INSTANCE				ConnInstance;		// Counts ConnId's allocated sofar
	PRWAN_TDI_CONNECTION *			pConnTable;			// Pointers to open connections
	ULONG							ConnTableSize;		// Size of above table
	ULONG							MaxConnections;		// Max size of above table
	ULONG							NextConnIndex;		// Starting point for next search
	RWAN_EVENT						Event;				// Used for synchronization
	BOOLEAN							UnloadDone;			// Has our UnloadProtocol run?
#ifdef NT
	PDRIVER_OBJECT					pDriverObject;		// From DriverEntry()
	LIST_ENTRY						DeviceObjList;		// All device objs we've created
#endif // NT

} RWAN_GLOBALS, *PRWAN_GLOBALS;

#if DBG
#define nlg_signature				'lGwR'
#endif // DBG




//
//  ***** Request structure *****
//
//  This structure keeps context information about each TDI request
//  that we pend.
//
typedef struct _RWAN_REQUEST
{
#if DBG
	ULONG							nrq_sig;
#endif // DBG
	PCOMPLETE_RTN					pReqComplete;		// Call-back routine
	PVOID							ReqContext;			// Context for above
	TDI_STATUS						Status;				// Final status

} RWAN_REQUEST, *PRWAN_REQUEST;

#if DBG
#define nrq_signature				'qRwR'
#endif // DBG




//
//  ***** Connect Request structure *****
//
//  This structure is used to maintain information about a pended
//  TDI_CONNECT or TDI_LISTEN or TDI_ACCEPT or TDI_DISCONNECT.
//
typedef struct _RWAN_CONN_REQUEST
{
#if DBG
	ULONG									nrc_sig;
#endif // DBG
	struct _RWAN_REQUEST 					Request;	// Common stuff
	struct _TDI_CONNECTION_INFORMATION *	pConnInfo;	// Return info
	USHORT									Flags;

} RWAN_CONN_REQUEST, *PRWAN_CONN_REQUEST;

#if DBG
#define nrc_signature				'cRwR'
#endif // DBG



//
//  ***** Data Request structure *****
//
//  This is the common part of a send/receive data request.
//
typedef struct _RWAN_DATA_REQUEST
{
	PDATA_COMPLETE_RTN						pReqComplete;
	PVOID									ReqContext;

} RWAN_DATA_REQUEST, *PRWAN_DATA_REQUEST;




//
//  ***** Send Request structure *****
//
//  This structure is used to maintain information about a pended
//  TDI_SEND.
//
typedef struct _RWAN_SEND_REQUEST
{
#if DBG
	ULONG									nrs_sig;
#endif // DBG
	struct _RWAN_DATA_REQUEST				Request;	// Common stuff
	USHORT									SendFlags;
	UINT									SendLength;

} RWAN_SEND_REQUEST, *PRWAN_SEND_REQUEST;


#if DBG
#define nrs_signature				'sRwR'
#endif // DBG



//
//  ***** Receive Request structure *****
//
//  This structure is used to maintain information about a pended
//  TDI_RECEIVE.
//
typedef struct _RWAN_RECEIVE_REQUEST
{
#if DBG
	ULONG									nrr_sig;
#endif // DBG
	struct _RWAN_RECEIVE_REQUEST *			pNextRcvReq;		// For chaining
	struct _RWAN_DATA_REQUEST				Request;			// Common stuff
	PUSHORT									pUserFlags;			// Info about the rcv
	UINT									TotalBufferLength;	// From TdiReceive
	UINT									AvailableBufferLength; // out of the above
	PNDIS_BUFFER							pBuffer;			// Current buffer in chain
	PUCHAR									pWriteData;			// Write pointer
	UINT									BytesLeftInBuffer;	// Left in current buffer

} RWAN_RECEIVE_REQUEST, *PRWAN_RECEIVE_REQUEST;

#if DBG
#define nrr_signature				'rRwR'
#endif // DBG



//
//  ***** Receive Indication structure *****
//
//  This structure is used to maintain information about one
//  indicated NDIS packet.
//
typedef struct _RWAN_RECEIVE_INDICATION
{
#if DBG
	ULONG									nri_sig;
#endif // DBG
	struct _RWAN_RECEIVE_INDICATION *		pNextRcvInd;		// For chaining
	PNDIS_BUFFER							pBuffer;			// Next byte is read from
																// this buffer:
	PUCHAR									pReadData;			// Points to next byte
																// to be read
	UINT									BytesLeftInBuffer;
	UINT									TotalBytesLeft;		// Within this packet
	PNDIS_PACKET							pPacket;
	UINT									PacketLength;
	BOOLEAN									bIsMiniportPacket;	// Does this packet
																// belong to the miniport
	PRWAN_NDIS_VC							pVc;				// back-pointer

} RWAN_RECEIVE_INDICATION, *PRWAN_RECEIVE_INDICATION;

#if DBG
#define nri_signature				'iRwR'
#endif // DBG




//
//  Saved context for an NDIS Request sent to the miniport on behalf of
//  an AF/media specific module.
//
typedef struct _RWAN_NDIS_REQ_CONTEXT
{
	struct _RWAN_NDIS_AF *					pAf;
	RWAN_HANDLE								AfSpReqContext;

} RWAN_NDIS_REQ_CONTEXT, *PRWAN_NDIS_REQ_CONTEXT;



#endif // __TDI_RWANDATA__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\send.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\send.c

Abstract:

	Routines for sending data, including TDI entry points and
	NDIS completions.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     05-16-97    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'DNES'

#if STATS

ULONG		SendPktsOk = 0;
ULONG		SendBytesOk = 0;
ULONG		SendPktsFail = 0;
ULONG		SendBytesFail = 0;

#endif // STATS
RWAN_STATUS
RWanInitSend(
	VOID
	)
/*++

Routine Description:

	Initialize our send side structures. All we need to do is to allocate
	an NDIS packet pool.

Arguments:

	None

Return Value:

	RWAN_STATUS_SUCCESS if we initialized successfully, RWAN_STATUS_RESOURCES
	if we couldn't allocate what we need.

--*/
{
	NDIS_STATUS			Status;

	NdisAllocatePacketPoolEx(
		&Status,
		&RWanSendPacketPool,
		RWAN_INITIAL_SEND_PACKET_COUNT,
		RWAN_OVERFLOW_SEND_PACKET_COUNT,
		0
		);

	return ((Status == NDIS_STATUS_SUCCESS)? RWAN_STATUS_SUCCESS: RWAN_STATUS_RESOURCES);
}



VOID
RWanShutdownSend(
	VOID
	)
/*++

Routine Description:

	Free up our send resources.

Arguments:

	None

Return Value:

	None

--*/
{
	if (RWanSendPacketPool != NULL)
	{
		NdisFreePacketPool(RWanSendPacketPool);
		RWanSendPacketPool = NULL;
	}

	return;
}




TDI_STATUS
RWanTdiSendData(
    IN	PTDI_REQUEST				pTdiRequest,
	IN	USHORT						SendFlags,
	IN	UINT						SendLength,
	IN	PNDIS_BUFFER				pSendBuffer
	)
/*++

Routine Description:

	This is the TDI Entry point for sending connection-oriented data.
	The Connection Object is identified by its context buried in the
	TDI Request.

	If all is well with the specified Connection, we prepend an NDIS
	packet to the buffer chain, and submit it to the miniport.

Arguments:

	pTdiRequest		- Pointer to the TDI Request containing the Send
	SendFlags		- Options associated with this Send
	SendLength		- Total data bytes in this Send
	pSendBuffer		- Pointer to buffer chain

Return Value:

	TDI_STATUS - this is TDI_PENDING if we successfully submitted
	a send request via NDIS, TDI_NO_RESOURCES if we failed to allocate
	resources for the send, TDI_INVALID_CONNECTION if the specified

--*/
{
	RWAN_CONN_ID				ConnId;
	PRWAN_TDI_CONNECTION		pConnObject;
	TDI_STATUS				TdiStatus;

	PRWAN_NDIS_VC			pVc;
	NDIS_HANDLE				NdisVcHandle;
	PNDIS_PACKET			pNdisPacket;
	PRWAN_SEND_REQUEST		pSendReq;
	NDIS_STATUS				NdisStatus;


	pNdisPacket = NULL;

	do
	{
		//
		//  XXX: Should we check the length?
		//

		//
		//  Discard zero-length sends.
		//
		if (SendLength == 0)
		{
			TdiStatus = TDI_SUCCESS;
			break;
		}

		//
		//  Fail expedited data.
		//  TBD - base this on the media-specific module.
		//
		if (SendFlags & TDI_SEND_EXPEDITED)
		{
			TdiStatus = STATUS_NOT_SUPPORTED;	// No matching TDI status!
			break;
		}

		pNdisPacket = RWanAllocateSendPacket();
		if (pNdisPacket == NULL)
		{
			TdiStatus = TDI_NO_RESOURCES;
			break;
		}

		ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);
		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId(ConnId);

		RWAN_RELEASE_CONN_TABLE_LOCK();


		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			TdiStatus = TDI_INVALID_CONNECTION;
			break;
		}

		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		if ((pConnObject->State != RWANS_CO_CONNECTED) ||
			(RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING)) ||
			(RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSE_SCHEDULED)))
		{
			//
			//  Fix up the return status to get proper Winsock error
			//  codes back to the app.
			//
			RWANDEBUGP(DL_INFO, DC_DATA_TX,
				("Send: bad state %d, pConnObject %x\n", pConnObject->State, pConnObject));
			if ((pConnObject->State == RWANS_CO_DISCON_INDICATED) ||
				(pConnObject->State == RWANS_CO_ASSOCIATED) ||
				(pConnObject->State == RWANS_CO_DISCON_REQUESTED))
			{
				//
				//  AFD would like to see us send an Abort at this time.
				//

				PDisconnectEvent			pDisconInd;
				PVOID						IndContext;
				PVOID						ConnectionHandle;
	
				RWAN_ASSERT(pConnObject->pAddrObject != NULL);

				pDisconInd = pConnObject->pAddrObject->pDisconInd;
				IndContext = pConnObject->pAddrObject->DisconIndContext;
				ConnectionHandle = pConnObject->ConnectionHandle;
	
				RWAN_RELEASE_CONN_LOCK(pConnObject);

				(*pDisconInd)(
					IndContext,
					ConnectionHandle,
					0,			// Disconnect Data Length
					NULL,		// Disconnect Data
					0,			// Disconnect Info Length
					NULL,		// Disconnect Info
					TDI_DISCONNECT_ABORT
					);

				TdiStatus = TDI_CONNECTION_RESET;
			}
			else
			{
				RWAN_RELEASE_CONN_LOCK(pConnObject);
				TdiStatus = TDI_INVALID_STATE;
			}
			break;
		}

		if (RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_LEAF))
		{
			//
			//  Allow sends only on the Root Connection object.
			//
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			TdiStatus = TDI_INVALID_CONNECTION;
			break;
		}

		pVc = pConnObject->NdisConnection.pNdisVc;
		RWAN_ASSERT(pVc != NULL_PRWAN_NDIS_VC);
		RWAN_STRUCT_ASSERT(pVc, nvc);

		NdisVcHandle = pVc->NdisVcHandle;

		//
		//  Save context about this send.
		//
		pSendReq = RWAN_SEND_REQUEST_FROM_PACKET(pNdisPacket);
		pSendReq->Request.pReqComplete = pTdiRequest->RequestNotifyObject;
		pSendReq->Request.ReqContext = pTdiRequest->RequestContext;

		//
		//  XXX: we save the send flags also - may not be needed?
		//
		if ((pVc->MaxSendSize != 0) &&
			(SendLength > pVc->MaxSendSize))
		{
			RWANDEBUGP(DL_WARN, DC_DATA_TX,
					("TdiSendData: Sending %d, which is more than %d\n",
						SendLength, pVc->MaxSendSize));
#if HACK_SEND_SIZE
			pSendReq->SendLength = pVc->MaxSendSize;
		}
		else
		{
			pSendReq->SendLength = SendLength;
#else
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			TdiStatus = TDI_NO_RESOURCES;
			break;
		}

		pSendReq->SendLength = SendLength;
#endif // HACK_SEND_SIZE

		pVc->PendingPacketCount++;

		RWAN_RELEASE_CONN_LOCK(pConnObject);

		pSendReq->SendFlags = SendFlags;

		RWANDEBUGP(DL_INFO, DC_DATA_TX,
			("Send: VC %x [%d], %d bytes\n", pVc, pVc->MaxSendSize, SendLength));

		//
		//  Attach the buffer chain to the Packet.
		//
		NdisChainBufferAtFront(pNdisPacket, pSendBuffer);

#if HACK_SEND_SIZE
		if (pSendReq->SendLength != SendLength)
		{
			UINT		TotalPacketLength;

			//
			//  HACK: Recalculate total bytes and fix it.
			//
			NdisQueryPacket(
				pNdisPacket,
				NULL,
				NULL,
				NULL,
				&TotalPacketLength
				);
			
			pNdisPacket->Private.TotalLength = pSendReq->SendLength;
			DbgPrint("RWan: send: real length %d, sending length %d\n",
					TotalPacketLength, pSendReq->SendLength);
		}
#endif // HACK_SEND_SIZE

		RWAND_LOG_PACKET(pVc, RWAND_DLOG_TX_START, pNdisPacket, pTdiRequest->RequestContext);

		//
		//  And send it off.
		//
		NdisCoSendPackets(NdisVcHandle, &pNdisPacket, 1);

		//
		//  Our CoSendComplete handler will be called to signify completion.
		//  So we return PENDING now.
		//
		TdiStatus = TDI_PENDING;
		break;

	}
	while (FALSE);


	if (TdiStatus != TDI_PENDING)
	{
#if STATS
		if (TdiStatus == TDI_SUCCESS)
		{
			INCR_STAT(&SendPktsOk);
			ADD_STAT(&SendBytesOk, SendLength);
		}
		else
		{
			INCR_STAT(&SendPktsFail);
			ADD_STAT(&SendBytesFail, SendLength);
		}
#endif // STATS

		//
		//  Clean up.
		//

		if (pNdisPacket != NULL)
		{
			RWanFreeSendPacket(pNdisPacket);
		}

#if DBG
		if (TdiStatus != TDI_SUCCESS)
		{
			RWANDEBUGP(DL_INFO, DC_DATA_TX,
				("Send: Length %x, failing with status %x\n", SendLength, TdiStatus));
		}
#endif
	}

	return (TdiStatus);
}




VOID
RWanNdisCoSendComplete(
    IN	NDIS_STATUS					NdisStatus,
    IN	NDIS_HANDLE					ProtocolVcContext,
    IN	PNDIS_PACKET				pNdisPacket
    )
/*++

Routine Description:

	This is the NDIS Entry point indicating completion of a
	packet send. We complete the TDI Send Request.

Arguments:

	NdisStatus			- Status of the NDIS Send.
	ProtocolVcContext	- Actually a pointer to our NDIS VC structure
	pNdisPacket			- Packet that has been sent.

Return Value:

	None

--*/
{
	PRWAN_NDIS_VC			pVc;
	PRWAN_SEND_REQUEST		pSendReq;
	PRWAN_TDI_CONNECTION	pConnObject;
	TDI_STATUS				TdiStatus;

	pVc = (PRWAN_NDIS_VC)ProtocolVcContext;
	RWAN_STRUCT_ASSERT(pVc, nvc);

#if STATS
	{
		PNDIS_BUFFER		pNdisBuffer;
		PVOID				FirstBufferVa;
		UINT				FirstBufferLength;
		UINT				TotalLength;

		NdisGetFirstBufferFromPacket(
			pNdisPacket,
			&pNdisBuffer,
			&FirstBufferVa,
			&FirstBufferLength,
			&TotalLength
			);
		
		if (NdisStatus == NDIS_STATUS_SUCCESS)
		{
			INCR_STAT(&SendPktsOk);
			ADD_STAT(&SendBytesOk, TotalLength);
		}
		else
		{
			INCR_STAT(&SendPktsFail);
			ADD_STAT(&SendBytesFail, TotalLength);
		}
	}
#endif // STATS

	if (NdisStatus == NDIS_STATUS_SUCCESS)
	{
		TdiStatus = TDI_SUCCESS;
	}
	else
	{
		TdiStatus = RWanNdisToTdiStatus(NdisStatus);
		RWANDEBUGP(DL_INFO, DC_DATA_TX,
			("CoSendComp: Failing Pkt %x, NDIS Status %x, TDI Status %x\n",
					pNdisPacket, NdisStatus, TdiStatus));
	}

	pSendReq = RWAN_SEND_REQUEST_FROM_PACKET(pNdisPacket);

	RWAND_LOG_PACKET(pVc, RWAND_DLOG_TX_END, pNdisPacket, pSendReq->Request.ReqContext);

	//
	//  Complete the TDI Send.
	//
	(*pSendReq->Request.pReqComplete)(
				pSendReq->Request.ReqContext,
				TdiStatus,
				((TdiStatus == TDI_SUCCESS) ? pSendReq->SendLength: 0)
				);

	//
	//  Free the NDIS Packet structure.
	//
	RWanFreeSendPacket(pNdisPacket);

	//
	//  Update the Connection object.
	//
	pConnObject = pVc->pConnObject;

	if (pConnObject != NULL)
	{
		RWAN_ASSERT(pConnObject->NdisConnection.pNdisVc == pVc);
		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		pVc->PendingPacketCount--; // Send complete

		if ((pVc->PendingPacketCount == 0) &&
			(RWAN_IS_BIT_SET(pVc->Flags, RWANF_VC_NEEDS_CLOSE)))
		{
			RWanStartCloseCall(pConnObject, pVc);
		}
		else
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
		}
	}
	//
	//  else we are aborting this connection.
	//
#if DBG
	else
	{
		RWANDEBUGP(DL_WARN, DC_DATA_TX,
			("SendComp: VC %x, ConnObj is NULL\n", pVc));
	}
#endif // DBG

	return;
}




PNDIS_PACKET
RWanAllocateSendPacket(
	VOID
	)
/*++

Routine Description:

	Allocate and return an NDIS packet to prepare a send.

Arguments:

	None

Return Value:

	Pointer to allocate packet if successful, else NULL.

--*/
{
	PNDIS_PACKET		pSendPacket;
	NDIS_STATUS			Status;

	NdisAllocatePacket(
			&Status,
			&pSendPacket,
			RWanSendPacketPool
			);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		pSendPacket = NULL;
	}

	return (pSendPacket);
}




VOID
RWanFreeSendPacket(
    IN	PNDIS_PACKET				pSendPacket
    )
/*++

Routine Description:

	Free an NDIS_PACKET used for a send.

Arguments:

	pSendPacket			- Points to packet to be freed.

Return Value:

	None

--*/
{
	RWAN_ASSERT(pSendPacket != NULL);

	NdisFreePacket(pSendPacket);
}




VOID
RWanNdisSendComplete(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	NDIS_STATUS					Status
	)
/*++

Routine Description:

	Dummy handler for connection-less send completes.

Arguments:


Return Value:

	None

--*/
{
	//
	//  We don't do connection-less sends yet.
	//
	RWAN_ASSERT(FALSE);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\system.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\system.h

Abstract:

	Raw WAN versions of system objects/definitions.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     06-13-97    Created

Notes:

--*/

#ifndef __TDI_RWAN_SYSTEM__H
#define __TDI_RWAN_SYSTEM__H


#define RWAN_NDIS_MAJOR_VERSION		5
#define RWAN_NDIS_MINOR_VERSION		0


#define RWAN_NAME				L"RawWan"
#define RWAN_NAME_STRING		NDIS_STRING_CONST("RawWan")
#define RWAN_DEVICE_NAME		L"\\Device\\RawWan"


#define LOCKIN
#define LOCKOUT
#define NOLOCKOUT


typedef struct _RWAN_EVENT
{
	NDIS_EVENT			Event;
	NDIS_STATUS			Status;

} RWAN_EVENT, *PRWAN_EVENT;


//
//  List manipulation stuff
//

typedef SINGLE_LIST_ENTRY RWAN_SINGLE_LIST_ENTRY, *PRWAN_SINGLE_LIST_ENTRY;

#define NULL_PRWAN_SINGLE_LIST_ENTRY	((PRWAN_SINGLE_LIST_ENTRY)NULL)

#define RWAN_POP_FROM_SLIST	ExInterlockedPopEntrySList
#define RWAN_PUSH_TO_SLIST	ExInterlockedPushEntrySList

#if !BINARY_COMPATIBLE

#define RWAN_IRQL			KIRQL


#if DBG

#define RWAN_GET_ENTRY_IRQL(Irql)	\
			Irql = KeGetCurrentIrql()
#define RWAN_CHECK_EXIT_IRQL(EntryIrql, ExitIrql)	\
		{										\
			ExitIrql = KeGetCurrentIrql();		\
			if (ExitIrql != EntryIrql)			\
			{									\
				DbgPrint("File %s, Line %d, Exit IRQ %d != Entry IRQ %d\n",	\
						__FILE__, __LINE__, ExitIrql, EntryIrql);			\
				DbgBreakPoint();				\
			}									\
		}
#else

#define RWAN_GET_ENTRY_IRQL(Irql)
#define RWAN_CHECK_EXIT_IRQL(EntryIrql, ExitIrql)

#endif // DBG

#else

#define RWAN_GET_ENTRY_IRQL(Irql)
#define RWAN_CHECK_EXIT_IRQL(EntryIrql, ExitIrql)

#define RWAN_IRQL			ULONG

#endif // BINARY_COMPATIBLE


typedef PTDI_IND_CONNECT			PConnectEvent;
typedef PTDI_IND_DISCONNECT			PDisconnectEvent;
typedef PTDI_IND_ERROR				PErrorEvent;
typedef PTDI_IND_RECEIVE			PRcvEvent;

typedef IRP EventRcvBuffer;
typedef IRP ConnectEventInfo;


#endif // __TDI_RWAN_SYSTEM__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\tdi\precomp.h ===
#include <ndis.h>
#include <atm.h>
#include <ntddndis.h>

#include <tdikrnl.h>
#include <tdistat.h>

#include "debug.h"

#include "rwanpub.h"
#include "rwanatm.h"
#include "atmsp.h"

#include "ws2atmsp.h"

#include "macros.h"

#include "externs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\tdi\atmsp.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\nultrans\atm\atmsp.c

Abstract:

	ATM Specific support functions for Null Transport. These routines
	perform operations like converting between TDI and NDIS formats.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     06-02-97    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'SMTA'




//
//  Global data structures.
//
ATMSP_GLOBAL_INFO			AtmSpGlobal;
PATMSP_GLOBAL_INFO			pAtmSpGlobal;


RWAN_STATUS
RWanAtmSpInitialize(
	VOID
	)
/*++

Routine Description:

	Initialize our interface with the core Null Transport.

	Step 1: Register all supported NDIS AF+Media combinations.
	Step 2: Register all supported TDI protocols.

Arguments:

	None

Return Value:

	RWAN_STATUS_SUCCESS if we initialized OK, error code otherwise.

--*/
{
	PRWAN_NDIS_AF_CHARS			pAfChars;
	PRWAN_TDI_PROTOCOL_CHARS	pTdiChars;
	RWAN_STATUS					RWanStatus;
	NDIS_STRING					DeviceName = NDIS_STRING_CONST("\\Device\\Atm");

	pAtmSpGlobal = &AtmSpGlobal;

	NdisGetCurrentSystemTime(&pAtmSpGlobal->StartTime);

	//
	//  Allocate space for the device string.
	//
	ATMSP_ALLOC_MEM(pAtmSpGlobal->AtmSpDeviceName.Buffer, WCHAR, DeviceName.MaximumLength);
	if (pAtmSpGlobal->AtmSpDeviceName.Buffer == NULL)
	{
		return RWAN_STATUS_RESOURCES;
	}

	pAtmSpGlobal->AtmSpDeviceName.MaximumLength = DeviceName.MaximumLength;
	RtlCopyUnicodeString(&pAtmSpGlobal->AtmSpDeviceName, &DeviceName);

	ATMSP_INIT_LIST(&pAtmSpGlobal->AfList);

	pAfChars = &(pAtmSpGlobal->AfChars);

	ATMSP_ZERO_MEM(pAfChars, sizeof(RWAN_NDIS_AF_CHARS));

	pAfChars->Medium = NdisMediumAtm;
	pAfChars->AddressFamily.AddressFamily = CO_ADDRESS_FAMILY_Q2931;
	pAfChars->AddressFamily.MajorVersion = ATMSP_AF_MAJOR_VERSION;
	pAfChars->AddressFamily.MinorVersion = ATMSP_AF_MINOR_VERSION;
	pAfChars->MaxAddressLength = sizeof(ATMSP_SOCKADDR_ATM);
	pAfChars->pAfSpOpenAf = RWanAtmSpOpenAf;
	pAfChars->pAfSpCloseAf = RWanAtmSpCloseAf;
#ifndef NO_CONN_CONTEXT
	pAfChars->pAfSpOpenAddress = RWanAtmSpOpenAddressObject;
	pAfChars->pAfSpCloseAddress = RWanAtmSpCloseAddressObject;
	pAfChars->pAfSpAssociateConnection = RWanAtmSpAssociateConnection;
	pAfChars->pAfSpDisassociateConnection = RWanAtmSpDisassociateConnection;
#endif
	pAfChars->pAfSpTdi2NdisOptions = RWanAtmSpTdi2NdisOptions;
	pAfChars->pAfSpUpdateNdisOptions = RWanAtmSpUpdateNdisOptions;
	pAfChars->pAfSpReturnNdisOptions = RWanAtmSpReturnNdisOptions; 
	pAfChars->pAfSpNdis2TdiOptions = RWanAtmSpNdis2TdiOptions;
	pAfChars->pAfSpUpdateTdiOptions = RWanAtmSpUpdateTdiOptions;
	pAfChars->pAfSpReturnTdiOptions = RWanAtmSpReturnTdiOptions;
	pAfChars->pAfSpGetValidTdiAddress = RWanAtmSpGetValidTdiAddress;
	pAfChars->pAfSpIsNullAddress = RWanAtmSpIsNullAddress;
	pAfChars->pAfSpTdi2NdisSap = RWanAtmSpTdi2NdisSap;
	pAfChars->pAfSpReturnNdisSap = RWanAtmSpReturnNdisSap;
	pAfChars->pAfSpDeregNdisAFComplete = RWanAtmSpDeregNdisAFComplete;
	pAfChars->pAfSpAdapterRequestComplete = RWanAtmSpAdapterRequestComplete;
	pAfChars->pAfSpAfRequestComplete = RWanAtmSpAfRequestComplete;
	pAfChars->pAfSpQueryGlobalInfo = RWanAtmSpQueryGlobalInfo;
	pAfChars->pAfSpSetGlobalInfo = RWanAtmSpSetGlobalInfo;
	pAfChars->pAfSpQueryConnInformation = RWanAtmSpQueryConnInfo;
	pAfChars->pAfSpSetAddrInformation = RWanAtmSpSetAddrInfo;

	RWanStatus = RWanAfSpRegisterNdisAF(
					pAfChars,
					(RWAN_HANDLE)&AtmSpGlobal,
					&AtmSpGlobal.RWanSpHandle
					);

	if (RWanStatus == RWAN_STATUS_SUCCESS)
	{
		//
		//  Inform the core Null transport about the TDI protocols
		//  we support.
		//
		pTdiChars = &(AtmSpGlobal.TdiChars);
		ATMSP_ZERO_MEM(pTdiChars, sizeof(RWAN_TDI_PROTOCOL_CHARS));

		pTdiChars->SockAddressFamily = ATMSP_AF_ATM;
		pTdiChars->TdiProtocol = ATMSP_ATMPROTO_AAL5;
		pTdiChars->SockProtocol = ATMSP_ATMPROTO_AAL5;
		pTdiChars->SockType = ATMSP_SOCK_TYPE;
		pTdiChars->bAllowConnObjects = TRUE;
		pTdiChars->bAllowAddressObjects = TRUE;
		pTdiChars->MaxAddressLength = sizeof(ATM_ADDRESS);
		pTdiChars->pAfSpDeregTdiProtocolComplete = RWanAtmSpDeregTdiProtocolComplete;

		//
		//  TBD: Fill in ProviderInfo
		//
		pTdiChars->ProviderInfo.Version = 0;	// TBD
		pTdiChars->ProviderInfo.MaxSendSize = 65535;
		pTdiChars->ProviderInfo.MaxConnectionUserData = 0;
		pTdiChars->ProviderInfo.MaxDatagramSize = 0;
		pTdiChars->ProviderInfo.ServiceFlags =
									TDI_SERVICE_CONNECTION_MODE |
									TDI_SERVICE_MULTICAST_SUPPORTED |
									TDI_SERVICE_DELAYED_ACCEPTANCE |
									TDI_SERVICE_NO_ZERO_LENGTH |
									TDI_SERVICE_MESSAGE_MODE |
									TDI_SERVICE_FORCE_ACCESS_CHECK
									;
		pTdiChars->ProviderInfo.MinimumLookaheadData = 1;
		pTdiChars->ProviderInfo.MaximumLookaheadData = 65535;
		pTdiChars->ProviderInfo.NumberOfResources = 0;
		pTdiChars->ProviderInfo.StartTime = pAtmSpGlobal->StartTime;

		pTdiChars->pDeviceName = &pAtmSpGlobal->AtmSpDeviceName;

		RWanStatus = RWanAfSpRegisterTdiProtocol(
							AtmSpGlobal.RWanSpHandle,
							pTdiChars,
							&AtmSpGlobal.RWanProtHandle
							);

		ATMSP_ASSERT(RWanStatus != RWAN_STATUS_PENDING);

		if (RWanStatus != RWAN_STATUS_SUCCESS)
		{
			RWanStatus = RWanAfSpDeregisterNdisAF(pAtmSpGlobal->RWanSpHandle);

			if (RWanStatus != RWAN_STATUS_PENDING)
			{
				RWanAtmSpDeregNdisAFComplete(
						RWanStatus,
						(RWAN_HANDLE)pAtmSpGlobal
						);
			}

			//
			//  Cook the return value.
			//
			RWanStatus = RWAN_STATUS_FAILURE;
		}
	}

	if (RWanStatus != RWAN_STATUS_SUCCESS)
	{
		//
		//  Clean up.
		//
		ATMSP_FREE_MEM(pAtmSpGlobal->AtmSpDeviceName.Buffer);
		pAtmSpGlobal->AtmSpDeviceName.Buffer = NULL;
	}

	return (RWanStatus);
}




VOID
RWanAtmSpShutdown(
	VOID
	)
/*++

Routine Description:

	This entry point is called by the core Null Transport when it
	wants us to shutdown.

	We deregister the TDI Protocol and NDIS AF that we had registered.

Arguments:

	None

Return Value:

	None

--*/
{
	RWAN_STATUS			RWanStatus;

	if (pAtmSpGlobal->RWanProtHandle != NULL)
	{
		RWanAfSpDeregisterTdiProtocol(pAtmSpGlobal->RWanProtHandle);
	}

	if (pAtmSpGlobal->RWanSpHandle != NULL)
	{
		RWanStatus = RWanAfSpDeregisterNdisAF(pAtmSpGlobal->RWanSpHandle);

		if (RWanStatus != RWAN_STATUS_PENDING)
		{
			RWanAtmSpDeregNdisAFComplete(
					RWanStatus,
					(RWAN_HANDLE)pAtmSpGlobal
					);
		}
	}	

	if (pAtmSpGlobal->AtmSpDeviceName.Buffer)
	{
		ATMSP_FREE_MEM(pAtmSpGlobal->AtmSpDeviceName.Buffer);
		pAtmSpGlobal->AtmSpDeviceName.Buffer = NULL;
	}

	return;
}




RWAN_STATUS
RWanAtmSpOpenAf(
    IN	RWAN_HANDLE					AfSpContext,
    IN	RWAN_HANDLE					RWanAFHandle,
    OUT	PRWAN_HANDLE				pAfSpAFContext,
    OUT PULONG						pMaxMsgSize
    )
/*++

Routine Description:

	This entry point is called to set up our context for an NDIS AF
	open on a supported adapter. We allocate an AF context block,
	and query the miniport for some basic info about the adapter.

Arguments:

	AfSpContext			- Points to our global context
	RWanAFHandle		- Handle for this Open AF from the core Null Transport
	pAfSpAFContext		- Place to return our context for this AF
	pMaxMsgSize			- Place to return max message size for this AF

Return Value:

	RWAN_STATUS_SUCCESS normally, if we allocated an AF block
	RWAN_STATUS_RESOURCES if allocation failed.

--*/
{
	PATMSP_AF_BLOCK		pAfBlock;
	RWAN_STATUS			RWanStatus;

	UNREFERENCED_PARAMETER(AfSpContext);

	do
	{
		ATMSP_ALLOC_MEM(pAfBlock, ATMSP_AF_BLOCK, sizeof(ATMSP_AF_BLOCK));

		if (pAfBlock == NULL)
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		pAfBlock->RWanAFHandle = RWanAFHandle;

		ATMSP_INSERT_TAIL_LIST(&pAtmSpGlobal->AfList, &pAfBlock->AfBlockLink);
		pAtmSpGlobal->AfListSize++;

		//
		//  Query the Adapter for some information we use to build a default
		//  QOS structure.
		//
		(VOID)AtmSpDoAdapterRequest(
				pAfBlock,
				NdisRequestQueryInformation,
				OID_GEN_CO_LINK_SPEED,
				&(pAfBlock->LineRate),
				sizeof(pAfBlock->LineRate)
				);

		(VOID)AtmSpDoAdapterRequest(
				pAfBlock,
				NdisRequestQueryInformation,
				OID_ATM_MAX_AAL5_PACKET_SIZE,
				&(pAfBlock->MaxPacketSize),
				sizeof(pAfBlock->MaxPacketSize)
				);

		*pMaxMsgSize = pAfBlock->MaxPacketSize;

		//
		//  Prepare default QOS parameters for outgoing calls on this adapter.
		//
		AtmSpPrepareDefaultQoS(pAfBlock);

		*pAfSpAFContext = (RWAN_HANDLE)pAfBlock;
		RWanStatus = RWAN_STATUS_SUCCESS;

		break;
	}
	while (FALSE);

	if (RWanStatus != RWAN_STATUS_SUCCESS)
	{
		//
		//  Clean up.
		//
		if (pAfBlock != NULL)
		{
			ATMSP_FREE_MEM(pAfBlock);
		}
	}

	return (RWanStatus);

}




RWAN_STATUS
RWanAtmSpCloseAf(
    IN	RWAN_HANDLE					AfSpAFContext
    )
/*++

Routine Description:

	This entry point is called just before the core Null Transport
	closes an NDIS AF. We free the context we had allocated for this AF.

Arguments:

	AfSpAFContext		- Pointer to our AF block.

Return Value:

	RWAN_STATUS_SUCCESS always.

--*/
{
	PATMSP_AF_BLOCK		pAfBlock;

	pAfBlock = (PATMSP_AF_BLOCK)AfSpAFContext;

	ATMSP_DELETE_FROM_LIST(&pAfBlock->AfBlockLink);
	pAtmSpGlobal->AfListSize--;

	ATMSP_FREE_MEM(pAfBlock);

	return (RWAN_STATUS_SUCCESS);
}



RWAN_STATUS
RWanAtmSpOpenAddressObject(
    IN	RWAN_HANDLE					AfSpContext,
    IN	RWAN_HANDLE					RWanAddrHandle,
    OUT	PRWAN_HANDLE				pAfSpAddrContext
    )
/*++

Routine Description:

	We are notified that a new address object is created. We create
	our context for the addr object, store Rawwan's handle for the
	object and return our context.

Arguments:

	AfSpContext			- Points to our global context
	RWanAddrHandle		- Handle for this Address from the core RawWan
	pAfSpAddrContext	- Place to return our context for this addr object

Return Value:

	RWAN_STATUS_SUCCESS normally, if we allocated an Address block
	RWAN_STATUS_RESOURCES if allocation failed.

--*/
{
	PATMSP_ADDR_BLOCK			pAddrBlock;
	RWAN_STATUS					RWanStatus;

	*pAfSpAddrContext = NULL;

	do
	{
		ATMSP_ALLOC_MEM(pAddrBlock, ATMSP_ADDR_BLOCK, sizeof(ATMSP_ADDR_BLOCK));

		if (pAddrBlock == NULL)
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		ATMSP_ZERO_MEM(pAddrBlock, sizeof(ATMSP_ADDR_BLOCK));
		pAddrBlock->RWanAddrHandle = RWanAddrHandle;
		pAddrBlock->RefCount = 1;	// Creation

		ATMSP_INIT_LIST(&pAddrBlock->ConnList);
		ATMSP_INIT_LOCK(&pAddrBlock->Lock);

		//
		//  Return value.
		//
		*pAfSpAddrContext = (RWAN_HANDLE)pAddrBlock;
		RWanStatus = RWAN_STATUS_SUCCESS;
		break;
	}
	while (FALSE);

	return (RWanStatus);
}


VOID
RWanAtmSpCloseAddressObject(
    IN	RWAN_HANDLE					AfSpAddrContext
    )
/*++

Routine Description:

	Our notification routine called by RawWan when an Address Object
	is destroyed. At this time, no connection objects should be
	associated with it. We simply deallocate our context for the
	address object.

Arguments:

	AfSpAddrContext	- Actually a pointer to our address block

Return Value:

	None

--*/
{
	PATMSP_ADDR_BLOCK			pAddrBlock;
	ULONG						rc;

	pAddrBlock = (PATMSP_ADDR_BLOCK)AfSpAddrContext;

	ATMSP_ACQUIRE_LOCK(&pAddrBlock->Lock);

	rc = --pAddrBlock->RefCount;

	ATMSP_RELEASE_LOCK(&pAddrBlock->Lock);

	if (rc == 0)
	{
		ATMSP_ASSERT(ATMSP_IS_LIST_EMPTY(&pAddrBlock->ConnList));

		ATMSP_FREE_LOCK(&pAddrBlock->Lock);

		ATMSP_FREE_MEM(pAddrBlock);
	}

	return;
}



RWAN_STATUS
RWanAtmSpAssociateConnection(
    IN	RWAN_HANDLE					AfSpAddrContext,
    IN	RWAN_HANDLE					RWanConnHandle,
    OUT	PRWAN_HANDLE				pAfSpConnContext
    )
/*++

Routine Description:

	Our notification routine that's called by RawWan when a Connection
	Object is associated with an address object.

	We create a Connection Block and link it with the specified
	address block.

Arguments:

	AfSpAddrContext	- Actually a pointer to our address block
	RWanConnHandle	- RawWan's handle for this connection object
	pAfSpConnHandle	- where we're supposed to return our context for the conn object

Return Value:

	RWAN_STATUS_SUCCESS always.

--*/
{
	PATMSP_CONN_BLOCK		pConnBlock;
	PATMSP_ADDR_BLOCK		pAddrBlock;
	RWAN_STATUS				RWanStatus;

	pAddrBlock = (PATMSP_ADDR_BLOCK)AfSpAddrContext;

	do
	{
		ATMSP_ALLOC_MEM(pConnBlock, ATMSP_CONN_BLOCK, sizeof(ATMSP_CONN_BLOCK));
		if (pConnBlock == NULL)
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		pConnBlock->RWanConnHandle = RWanConnHandle;
		pConnBlock->pAddrBlock = pAddrBlock;

		//
		//  Link to address block.
		//
		ATMSP_ACQUIRE_LOCK(&pAddrBlock->Lock);

		ATMSP_INSERT_TAIL_LIST(&pAddrBlock->ConnList, &pConnBlock->ConnLink);

		pAddrBlock->RefCount++;

		ATMSP_RELEASE_LOCK(&pAddrBlock->Lock);

		//
		//  Return values.
		//
		*pAfSpConnContext = (RWAN_HANDLE)pConnBlock;
		RWanStatus = RWAN_STATUS_SUCCESS;
		break;
	}
	while (FALSE);

	return (RWanStatus);
}

VOID
RWanAtmSpDisassociateConnection(
	IN	RWAN_HANDLE					AfSpConnContext
	)
/*++

Routine Description:

	Our notification routine that's called by RawWan when a Connection
	Object is disassociated from its address object.

Arguments:

	AfSpConnContext	- Our Conn context that we returned from the Associate
					  Connection routine.

Return Value:

	None

--*/
{
	PATMSP_CONN_BLOCK			pConnBlock;
	PATMSP_ADDR_BLOCK			pAddrBlock;
	ULONG						rc;

	pConnBlock = (PATMSP_CONN_BLOCK)AfSpConnContext;
	pAddrBlock = pConnBlock->pAddrBlock;
	ATMSP_ASSERT(pAddrBlock != NULL);

	//
	//  De-link from address block first.
	//
	ATMSP_ACQUIRE_LOCK(&pAddrBlock->Lock);

	ATMSP_DELETE_FROM_LIST(&pConnBlock->ConnLink);

	rc = --pAddrBlock->RefCount;

	ATMSP_RELEASE_LOCK(&pAddrBlock->Lock);

	if (rc == 0)
	{
		ATMSP_ASSERT(ATMSP_IS_LIST_EMPTY(&pAddrBlock->ConnList));

		ATMSP_FREE_MEM(pAddrBlock);
	}

	ATMSP_FREE_MEM(pConnBlock);

	return;
}


RWAN_STATUS
RWanAtmSpTdi2NdisOptions(
    IN	RWAN_HANDLE					AfSpConnContext,
    IN	ULONG						CallFlags,
    IN	PTDI_CONNECTION_INFORMATION	pTdiInfo,
    IN	PVOID						pTdiQoS,
    IN	ULONG						TdiQoSLength,
    OUT	PRWAN_HANDLE				pRWanAfHandle	OPTIONAL,
    OUT	PCO_CALL_PARAMETERS *		ppCallParameters
    )
/*++

Routine Description:

	This is called to convert Call parameters from TDI form to
	NDIS format. We allocate space for NDIS parameters, fill it
	and return it.

	We also return the AFHandle for the AFBlock on which the call
	should be placed.

	For ATM, the call parameters are presented as follows:
	pTdiInfo->RemoteAddress - Calling/Called ATM Address, BLLI and BHLI
	pTdiQoS - Send and receive Flowspec, and optionally, other info elements.

Arguments:

	AfSpConnContext		- Points to our Conn block
	CallFlags			- Call direction and other info
	pTdiInfo			- Points to generic TDI Connection Information
	pTdiQoS				- Points to Winsock 2 style QoS structure
	TdiQoSLength		- Length of the above
	pRWanAfHandle		- Place to return AF Handle
	ppCallParameters 	- Place to return pointer to NDIS call parameters

Return Value:

	RWAN_STATUS_SUCCESS if we did the conversion successfully, RWAN_STATUS_XXX
	error code otherwise.

--*/
{
	RWAN_STATUS						RWanStatus;
	PATMSP_AF_BLOCK					pAfBlock;
	PATMSP_CONN_BLOCK				pConnBlock;
	PATMSP_ADDR_BLOCK				pAddrBlock;
	PCO_CALL_PARAMETERS				pCallParameters;
	Q2931_CALLMGR_PARAMETERS UNALIGNED *	pAtmCallParameters;
	CO_CALL_MANAGER_PARAMETERS UNALIGNED *	pCallMgrParameters;
	PATM_MEDIA_PARAMETERS			pAtmMediaParameters;
	ULONG							ParametersLength;
	Q2931_IE UNALIGNED *			pIe;
	Q2931_IE UNALIGNED *			pFirstIe;
	Q2931_IE UNALIGNED *			pDstIe;
	ULONG							IeLength;
	ATMSP_QOS *						pQoS;
	ATMSP_SOCKADDR_ATM UNALIGNED *	pRemoteAddr;
	BOOLEAN							IsBhliPresent; // part of Remote addr
	BOOLEAN							IsBlliPresent; // part of Remote addr
	INT								TotalIeLength; // explicitly passed to us by user
	ULONG							InfoElementCount; // explicit IE count
    BOOLEAN							IsOutgoingCall;
    BOOLEAN							IsPMPCall;
    BOOLEAN							IsPVC;


	//
	//  Initialize.
	//
	RWanStatus = RWAN_STATUS_SUCCESS;

	do
	{
#ifndef NO_CONN_CONTEXT
		pConnBlock = (PATMSP_CONN_BLOCK)AfSpConnContext;
		ATMSP_ASSERT(pConnBlock != NULL);

		pAddrBlock = pConnBlock->pAddrBlock;
		ATMSP_ASSERT(pAddrBlock != NULL);

		IsPVC =	(ATMSP_IS_BIT_SET(pAddrBlock->Flags, ATMSPF_ADDR_PVC_ID_SET));
#else
		IsPVC = FALSE;
#endif

		IsOutgoingCall = ((CallFlags & RWAN_CALLF_CALL_DIRECTION_MASK) == RWAN_CALLF_OUTGOING_CALL);
		IsPMPCall = ((CallFlags & RWAN_CALLF_CALL_TYPE_MASK) == RWAN_CALLF_POINT_TO_MULTIPOINT);

		if (IsPVC)
		{
			//
			//  Locate the AF block corresponding to the device
			//  number.
			//
			pAfBlock = AtmSpDeviceNumberToAfBlock(pAddrBlock->ConnectionId.DeviceNumber);

			if (pAfBlock == NULL)
			{
				RWanStatus = RWAN_STATUS_BAD_ADDRESS;
				break;
			}
		}
		else
		{
			if (ATMSP_IS_LIST_EMPTY(&pAtmSpGlobal->AfList))
			{
				RWanStatus = RWAN_STATUS_BAD_ADDRESS;
				break;
			}
			
			pAfBlock = CONTAINING_RECORD(pAtmSpGlobal->AfList.Flink, ATMSP_AF_BLOCK, AfBlockLink);
		}

		//
		//  Validate.
		//
		if (IsOutgoingCall)
		{
			pRemoteAddr = AtmSpGetSockAtmAddress(pTdiInfo->RemoteAddress, pTdiInfo->RemoteAddressLength);

			if (pRemoteAddr == NULL)
			{
				RWanStatus = RWAN_STATUS_BAD_ADDRESS;
				break;
			}

			RWANDEBUGPATMADDR(DL_LOUD, DC_CONNECT,
					"AtmSpTdi2NdisOptions: remote addr: ", &pRemoteAddr->satm_number);
		}
		else
		{
			pRemoteAddr = NULL;
		}

		if (pTdiQoS == NULL)
		{
		    RWANDEBUGP(DL_FATAL, DC_WILDCARD,
		        ("AtmSpTdi2NdisOptions: NULL TDIQOS\n"));

			pQoS = &(pAfBlock->DefaultQoS);
			TdiQoSLength = pAfBlock->DefaultQoSLength;
			TotalIeLength = 0;
			InfoElementCount = 0;
		}
		else
		{
			if (TdiQoSLength < sizeof(ATMSP_QOS))
			{
				RWanStatus = RWAN_STATUS_BAD_PARAMETER;
				break;
			}

			pQoS = (ATMSP_QOS *)pTdiQoS;

		    RWANDEBUGP(DL_FATAL, DC_WILDCARD,
		        ("AtmSpTdi2NdisOptions: Send: ServiceType %d, Peak %d, Recv %d, %d\n",
		            pQoS->SendingFlowSpec.ServiceType,
		            pQoS->SendingFlowSpec.PeakBandwidth,
		            pQoS->ReceivingFlowSpec.ServiceType,
		            pQoS->ReceivingFlowSpec.PeakBandwidth));


			//
			//  The provider-specific part is a list of Info Elements.
			//  Get the total length of this list.
			//
			TotalIeLength = (INT)pQoS->ProviderSpecific.len;

			//
			//  Get at the first Info element in the list.
			//
			pIe = (PQ2931_IE)((ULONG_PTR)pQoS + (ULONG_PTR)pQoS->ProviderSpecific.buf);
			pFirstIe = pIe;

#if 0
			if (((pIe == NULL) && (TotalIeLength != 0)) ||
				((pIe != NULL) && (TotalIeLength < sizeof(Q2931_IE))))
			{
				RWanStatus = RWAN_STATUS_BAD_PARAMETER;
				break;
			}
#endif // 0

			//
			//  Count the total number of Info Elements present.
			//  XXX: should we check IE types?
			//
			InfoElementCount = 0;

			while (TotalIeLength >= sizeof(Q2931_IE))
			{
				ATMSP_AAL_PARAMETERS_IE UNALIGNED *pAalParamsIe;
				ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *pBbcIe;

				if ((pIe->IELength == 0) ||
					(pIe->IELength > (ULONG)TotalIeLength))
				{
					RWanStatus = RWAN_STATUS_BAD_PARAMETER;
					break;
				}

				switch (pIe->IEType)
				{
					case IE_AALParameters:
						//
						//  Map AAL Type.
						//
						pAalParamsIe = (ATMSP_AAL_PARAMETERS_IE UNALIGNED *)&pIe->IE[0];
						if (pIe->IELength >= sizeof(*pAalParamsIe))
						{
							switch (pAalParamsIe->AALType)
							{
								case ATMSP_AALTYPE_5:
									pAalParamsIe->AALType = AAL_TYPE_AAL5;
									break;
								case ATMSP_AALTYPE_USER:
									pAalParamsIe->AALType = AAL_TYPE_AAL0;
									break;
								default:
									break;
							}
						}
						break;

					case IE_BroadbandBearerCapability:
						//
						//  Map BearerClass.
						//
						pBbcIe = (ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *)&pIe->IE[0];
						if (pIe->IELength >= sizeof(*pBbcIe))
						{
							switch (pBbcIe->BearerClass)
							{
								case ATMSP_BCOB_A:
									pBbcIe->BearerClass = BCOB_A;
									break;
								case ATMSP_BCOB_C:
									pBbcIe->BearerClass = BCOB_C;
									break;
								case ATMSP_BCOB_X:
									pBbcIe->BearerClass = BCOB_X;
									break;
								default:
									break;
							}
						}
						break;

					default:
						break;
				}

				TotalIeLength -= (INT)pIe->IELength;
				pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);

				InfoElementCount++;
			}

			if (RWanStatus != RWAN_STATUS_SUCCESS)
			{
				break;
			}

			TotalIeLength = (INT)pQoS->ProviderSpecific.len;
			pIe = pFirstIe;
		}

		//
		//  Calculate the total length requirements.
		//
		ParametersLength = sizeof(CO_CALL_PARAMETERS) +
						   sizeof(CO_CALL_MANAGER_PARAMETERS) +
						   sizeof(Q2931_CALLMGR_PARAMETERS) +
						   TotalIeLength;

		IsBlliPresent = (pRemoteAddr? ATMSP_BLLI_PRESENT(&pRemoteAddr->satm_blli): FALSE);

		if (IsBlliPresent)
		{
			ParametersLength += sizeof(ATM_BLLI_IE);
		}

		IsBhliPresent =  (pRemoteAddr? ATMSP_BHLI_PRESENT(&pRemoteAddr->satm_bhli): FALSE);
		if (IsBhliPresent)
		{
			ParametersLength += sizeof(ATM_BHLI_IE);
		}

#ifndef NO_CONN_CONTEXT
		//
		//  If this is a PVC, we'll fill in the Media parameters too.
		//
		if (IsPVC)
		{
			ParametersLength += sizeof(CO_MEDIA_PARAMETERS) +
								sizeof(ATM_MEDIA_PARAMETERS);
		}
#endif

		RWANDEBUGP(DL_EXTRA_LOUD, DC_CONNECT,
				("AtmSpTdi2NdisOptions: BlliPresent %d, BhliPresent %d, TotalIeLen %d, ParamsLength %d\n",
					IsBlliPresent,
					IsBhliPresent,
					TotalIeLength,
					ParametersLength
					));

		ATMSP_ALLOC_MEM(pCallParameters, CO_CALL_PARAMETERS, ParametersLength);

		if (pCallParameters == NULL)
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		ATMSP_ZERO_MEM(pCallParameters, ParametersLength);

		pCallParameters->Flags = 0;

		if (IsPMPCall)
		{
			pCallParameters->Flags |= MULTIPOINT_VC;
		}

		if (IsPVC)
		{
			pCallParameters->Flags |= PERMANENT_VC;

			//
			//  Start off with Media parameters, and then Call Mgr parameters.
			//
			pCallParameters->MediaParameters =
						(PCO_MEDIA_PARAMETERS)((PUCHAR)pCallParameters +
									sizeof(CO_CALL_PARAMETERS));
			pCallParameters->MediaParameters->MediaSpecific.ParamType = ATM_MEDIA_SPECIFIC;
			pCallParameters->MediaParameters->MediaSpecific.Length = sizeof(ATM_MEDIA_PARAMETERS);

			pAtmMediaParameters = (PATM_MEDIA_PARAMETERS)&pCallParameters->MediaParameters->MediaSpecific.Parameters[0];

			//
			//  Get the VPI/VCI values.
			//
			pAtmMediaParameters->ConnectionId.Vpi = pAddrBlock->ConnectionId.Vpi;
			pAtmMediaParameters->ConnectionId.Vci = pAddrBlock->ConnectionId.Vci;

			//
			//  Force the Call Manager to compute the rest of the ATM media
			//  parameters from the generic QoS parameters or IEs.
			//
			pAtmMediaParameters->AALType = QOS_NOT_SPECIFIED;

			//
			//  Allocate Call manager parameters space following the
			//  media parameters.
			//
			pCallMgrParameters =
			pCallParameters->CallMgrParameters =
						(PCO_CALL_MANAGER_PARAMETERS)((PUCHAR)pCallParameters +
									sizeof(CO_MEDIA_PARAMETERS) +
									sizeof(ATM_MEDIA_PARAMETERS) +
									sizeof(CO_CALL_PARAMETERS));
		}
		else
		{
			pCallParameters->MediaParameters = NULL;

			pCallMgrParameters =
			pCallParameters->CallMgrParameters =
						(PCO_CALL_MANAGER_PARAMETERS)((PUCHAR)pCallParameters +
									sizeof(CO_CALL_PARAMETERS));
		}

		if (IsOutgoingCall)
		{
			pCallMgrParameters->Transmit = pQoS->SendingFlowSpec;
			pCallMgrParameters->Receive = pQoS->ReceivingFlowSpec;

			if (IsPMPCall)
			{
				pCallMgrParameters->Receive.ServiceType = SERVICETYPE_NOTRAFFIC;
				pCallMgrParameters->Receive.PeakBandwidth = 0;
			}
		}
		else
		{
			pCallMgrParameters->Transmit = pQoS->ReceivingFlowSpec;
			pCallMgrParameters->Receive = pQoS->SendingFlowSpec;

			if (IsPMPCall)
			{
				pCallMgrParameters->Transmit.ServiceType = SERVICETYPE_NOTRAFFIC;
				pCallMgrParameters->Transmit.PeakBandwidth = 0;
			}
		}

		pCallMgrParameters->CallMgrSpecific.ParamType = 0;	// XXX?

		pAtmCallParameters = (PQ2931_CALLMGR_PARAMETERS)
									&(pCallMgrParameters->CallMgrSpecific.Parameters[0]);
		if (IsOutgoingCall)
		{
			ATMSP_ZERO_MEM(&pAtmCallParameters->CallingParty, sizeof(ATM_ADDRESS));
			pAtmCallParameters->CalledParty = pRemoteAddr->satm_number;
			if ((pRemoteAddr->satm_number.AddressType != SOCKATM_E164) &&
				(pRemoteAddr->satm_number.AddressType != SOCKATM_NSAP))
			{
				RWanStatus = RWAN_STATUS_BAD_ADDRESS;
				break;
			}

			pAtmCallParameters->CalledParty.AddressType =
					((pRemoteAddr->satm_number.AddressType == SOCKATM_E164)?
						ATM_E164: ATM_NSAP);
		}
		else
		{
			ATMSP_ZERO_MEM(&pAtmCallParameters->CalledParty, sizeof(ATM_ADDRESS));

			if (pRemoteAddr != NULL)
			{
				pAtmCallParameters->CallingParty = pRemoteAddr->satm_number;
				pAtmCallParameters->CallingParty.AddressType =
					((pRemoteAddr->satm_number.AddressType == SOCKATM_E164)?
						ATM_E164: ATM_NSAP);
			}
		}

		pAtmCallParameters->InfoElementCount = 0;
		pDstIe = (PQ2931_IE) &pAtmCallParameters->InfoElements[0];

		//
		//  Copy in the BHLI and BLLI IEs.
		//
		if (IsBhliPresent)
		{
			ATM_BHLI_IE UNALIGNED *	pBhliIe;

			pDstIe->IEType = IE_BHLI;
			pDstIe->IELength = ROUND_UP(sizeof(Q2931_IE) + sizeof(ATM_BHLI_IE));
			pBhliIe = (ATM_BHLI_IE UNALIGNED *)pDstIe->IE;

			pBhliIe->HighLayerInfoType = pRemoteAddr->satm_bhli.HighLayerInfoType;
			pBhliIe->HighLayerInfoLength = pRemoteAddr->satm_bhli.HighLayerInfoLength;
			ATMSP_COPY_MEM(pBhliIe->HighLayerInfo,
						   pRemoteAddr->satm_bhli.HighLayerInfo,
						   8);

			pDstIe = (PQ2931_IE)((PUCHAR)pDstIe + pDstIe->IELength);
			pAtmCallParameters->InfoElementCount++;
		}

		if (IsBlliPresent)
		{
			ATM_BLLI_IE UNALIGNED *	pBlliIe;

			pDstIe->IEType = IE_BLLI;
			pDstIe->IELength = ROUND_UP(sizeof(Q2931_IE) + sizeof(ATM_BLLI_IE));

			pBlliIe = (ATM_BLLI_IE UNALIGNED *)pDstIe->IE;

			pBlliIe->Layer2Protocol = pRemoteAddr->satm_blli.Layer2Protocol;
			pBlliIe->Layer2Mode = pBlliIe->Layer2WindowSize = 0;
			pBlliIe->Layer2UserSpecifiedProtocol = pRemoteAddr->satm_blli.Layer2UserSpecifiedProtocol;
			pBlliIe->Layer3Protocol = pRemoteAddr->satm_blli.Layer3Protocol;
			pBlliIe->Layer3Mode = 0;
			pBlliIe->Layer3DefaultPacketSize = 0;
			pBlliIe->Layer3PacketWindowSize = 0;
			pBlliIe->Layer3UserSpecifiedProtocol = pRemoteAddr->satm_blli.Layer3UserSpecifiedProtocol;
			pBlliIe->Layer3IPI = pRemoteAddr->satm_blli.Layer3IPI;
			ATMSP_COPY_MEM(pBlliIe->SnapId, pRemoteAddr->satm_blli.SnapId, 5);

			pDstIe = (PQ2931_IE)((PUCHAR)pDstIe + pDstIe->IELength);
			pAtmCallParameters->InfoElementCount++;

			RWANDEBUGP(DL_INFO, DC_CONNECT,
						("AtmSpTdi2NdisOptions: BLLI: Layer2Prot x%x, Layer3Prot x%x\n",
							pBlliIe->Layer2Protocol, pBlliIe->Layer3Protocol));
		}


		//
		//  Copy in the rest of the IEs.
		//
		if (InfoElementCount != 0)
		{
			pAtmCallParameters->InfoElementCount += InfoElementCount;
			ATMSP_COPY_MEM(pDstIe, pIe, TotalIeLength);

			pDstIe = (PQ2931_IE)((PUCHAR)pDstIe + TotalIeLength);
		}

		//
		//  Compute the length of the Call manager specific part.
		//
		pCallMgrParameters->CallMgrSpecific.Length =
						(ULONG)((ULONG_PTR)pDstIe - (ULONG_PTR)pAtmCallParameters);

		//
		//  We are done. Prepare return values.
		//
		*ppCallParameters = pCallParameters;
		if (pRWanAfHandle != NULL)
		{
			*pRWanAfHandle = pAfBlock->RWanAFHandle;
		}

		break;
	}
	while (FALSE);


	return (RWanStatus);
}




RWAN_STATUS
RWanAtmSpUpdateNdisOptions(
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	RWAN_HANDLE					AfSpConnContext,
	IN	ULONG						CallFlags,
	IN	PTDI_CONNECTION_INFORMATION	pTdiInfo,
	IN	PVOID						pTdiQoS,
	IN	ULONG						TdiQoSLength,
	IN OUT PCO_CALL_PARAMETERS *	ppCallParameters
	)
/*++

Routine Description:

	This entry point is called in order to update NDIS Call parameters
	with values from TDI-style QoS and options. The most common case
	where this is called is when a called user negotiates parameters
	for an incoming call.

	For now, we simply note down the VPI/VCI values for the connection,
	in order to support SIO_GET_ATM_CONNECTION_ID

Arguments:

	AfSpAFContext		- Points to our AF block
	AfSpConnContext		- Points to our Conn block
	CallFlags			- Call direction and other info
	pTdiInfo			- Generic TDI Connection information block
	pTdiQoS				- Points to TDI-style QOS structure
	TdiQoSLength		- Length of the above
	ppCallParameters	- Points to pointer to NDIS Call Parameters to be updated

Return Value:

	RWAN_STATUS_SUCCESS if we successfully updated NDIS parameters.

--*/
{
	RWAN_STATUS						RWanStatus;
	PATMSP_AF_BLOCK					pAfBlock;
	PATMSP_CONN_BLOCK				pConnBlock;
	PATM_MEDIA_PARAMETERS			pAtmMediaParameters;

	RWanStatus = RWAN_STATUS_SUCCESS;
	pAfBlock = (PATMSP_AF_BLOCK)AfSpAFContext;
	pConnBlock = (PATMSP_CONN_BLOCK)AfSpConnContext;

	ATMSP_ASSERT(pAfBlock != NULL);
	ATMSP_ASSERT(pConnBlock != NULL);
	ATMSP_ASSERT(ppCallParameters != NULL);
	ATMSP_ASSERT(*ppCallParameters != NULL);

	do
	{
		pAtmMediaParameters = (PATM_MEDIA_PARAMETERS)
			&((*ppCallParameters)->MediaParameters->MediaSpecific.Parameters[0]);

		pConnBlock->ConnectionId.DeviceNumber = AtmSpAfBlockToDeviceNumber(pAfBlock);
		pConnBlock->ConnectionId.Vpi = pAtmMediaParameters->ConnectionId.Vpi;
		pConnBlock->ConnectionId.Vci = pAtmMediaParameters->ConnectionId.Vci;

		RWANDEBUGP(DL_VERY_LOUD, DC_CONNECT,
			("AtmSP: UpdateNdis: VPI %d, VCI %d\n",
				pConnBlock->ConnectionId.Vpi,
				pConnBlock->ConnectionId.Vci));

		break;
	}
	while (FALSE);
		
	return (RWanStatus);
}




VOID
RWanAtmSpReturnNdisOptions(
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
	)
/*++

Routine Description:

	This entry point is called when core Null Transport is done with
	an NDIS options structure we'd given it via RWanAtmSpTdi2NdisOptions.
	We simply free the memory used for the structure.

Arguments:

	AfSpAFContext		- Points to our AF block
	pCallParameters		- Points to NDIS options

Return Value:

	None

--*/
{
	UNREFERENCED_PARAMETER(AfSpAFContext);

	ATMSP_FREE_MEM(pCallParameters);
}




RWAN_STATUS
RWanAtmSpNdis2TdiOptions(
    IN	RWAN_HANDLE					AfSpAFContext,
    IN	ULONG						CallFlags,
    IN	PCO_CALL_PARAMETERS			pCallParameters,
    OUT	PTDI_CONNECTION_INFORMATION *ppTdiInfo,
    OUT	PVOID *						ppTdiQoS,
    OUT	PULONG 						pTdiQoSLength,
    OUT	RWAN_HANDLE *				pAfSpTdiOptionsContext
    )
/*++

Routine Description:

	Convert NDIS Call parameters to TDI options and QoS. We allocate space
	for the latter, fill them and return them.

Arguments:

	AfSpAFContext		- Points to our AF block
	CallFlags			- Call direction and other flags
	pCallParameters		- Pointer to NDIS Call Parameters
	ppTdiInfo			- Place to return pointer to allocated TDI Connection info
	ppTdiQoS			- Place to return pointer to allocated TDI QoS structure
	pTdiQoSLength		- Place to return length of the above
	pAfSpTdiOptionsContext - Place to put our context for this allocated structure.

Return Value:

	RWAN_STATUS_SUCCESS if we successfully converted NDIS to TDI parameters,
	RWAN_STATUS_XXX error otherwise.

--*/
{
	Q2931_CALLMGR_PARAMETERS UNALIGNED *	pAtmCallParameters;
	CO_CALL_MANAGER_PARAMETERS UNALIGNED *	pCallMgrParameters;
	Q2931_IE UNALIGNED *			pIe;
	ATM_BLLI_IE UNALIGNED *			pBlli;
	ATM_BHLI_IE UNALIGNED *			pBhli;
	AAL_PARAMETERS_IE UNALIGNED *	pAalIe;
	AAL5_PARAMETERS UNALIGNED *		pAal5Params;
	ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *pBbcIe;
	ULONG							TotalLength;
	ULONG							TotalIeLength;
	ULONG							i;

	PATMSP_AF_BLOCK					pAfBlock;
	PTDI_CONNECTION_INFORMATION		pTdiInfo;
	PTRANSPORT_ADDRESS 				pTransportAddress;
	PTA_ADDRESS 					pAddress;
	ATMSP_SOCKADDR_ATM UNALIGNED *	pSockAddrAtm;
	ATM_ADDRESS UNALIGNED *			pAtmAddress;
	PVOID							pTdiQoS;
	ATMSP_QOS UNALIGNED *			pQoS;
	RWAN_STATUS						RWanStatus;
    BOOLEAN							IsOutgoingCall;


	pBlli = NULL;
	pBhli = NULL;
	pAfBlock = (PATMSP_AF_BLOCK)AfSpAFContext;

	IsOutgoingCall = ((CallFlags & RWAN_CALLF_CALL_DIRECTION_MASK) == RWAN_CALLF_OUTGOING_CALL);

	pCallMgrParameters = pCallParameters->CallMgrParameters;
	pAtmCallParameters = (PQ2931_CALLMGR_PARAMETERS)
								&(pCallMgrParameters->CallMgrSpecific.Parameters[0]);

	//
	//  Compute space required:
	//  1. TDI Connection Information
	//  2. Remote address
	//  3. Generic QoS
	//  4. Provider-specific buffer containing IEs
	//
	TotalLength = sizeof(TDI_CONNECTION_INFORMATION)
				  + TA_HEADER_LENGTH + TA_ATM_ADDRESS_LENGTH
				  + sizeof(ATMSP_QOS)
					;

	//
	//  Add space for IE list, and note down positions of BHLI and BLLI
	//  info elements - we need these for the SOCKADDR_ATM.
	//
	pIe = (PQ2931_IE)&(pAtmCallParameters->InfoElements[0]);

	TotalIeLength = 0;
	for (i = 0; i < pAtmCallParameters->InfoElementCount; i++)
	{
		TotalIeLength += pIe->IELength;

		switch (pIe->IEType)
		{
			case IE_BLLI:
				if (pBlli == NULL)
				{
					pBlli = (PATM_BLLI_IE) &(pIe->IE[0]);
				}
				break;

			case IE_BHLI:
				if (pBhli == NULL)
				{
					pBhli = (PATM_BHLI_IE) &(pIe->IE[0]);
				}
				break;

			case IE_AALParameters:
				pAalIe = (AAL_PARAMETERS_IE UNALIGNED *)&pIe->IE[0];

				switch (pAalIe->AALType)
				{
					case AAL_TYPE_AAL5:
						pAalIe->AALType = ATMSP_AALTYPE_5;
						pAal5Params = &pAalIe->AALSpecificParameters.AAL5Parameters;
						if (pAal5Params->ForwardMaxCPCSSDUSize > pAfBlock->MaxPacketSize)
						{
							pAal5Params->ForwardMaxCPCSSDUSize = pAfBlock->MaxPacketSize;
						}
						if (pAal5Params->BackwardMaxCPCSSDUSize > pAfBlock->MaxPacketSize)
						{
							pAal5Params->BackwardMaxCPCSSDUSize = pAfBlock->MaxPacketSize;
						}
						break;
					case AAL_TYPE_AAL0:
						pAalIe->AALType = ATMSP_AALTYPE_USER;
						break;
					default:
						ATMSP_ASSERT(FALSE);
						break;
				}
				break;

			case IE_BroadbandBearerCapability:

				pBbcIe = (ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *)&pIe->IE[0];

				switch (pBbcIe->BearerClass)
				{
					case BCOB_A:
						pBbcIe->BearerClass = ATMSP_BCOB_A;
						break;
					case BCOB_C:
						pBbcIe->BearerClass = ATMSP_BCOB_C;
						break;
					case BCOB_X:
						pBbcIe->BearerClass = ATMSP_BCOB_X;
						break;
					default:
						break;
				}

				break;

			default:
				break;

		}

		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
	}

	TotalLength += TotalIeLength;

	RWanStatus = RWAN_STATUS_SUCCESS;

	do
	{
		ATMSP_ALLOC_MEM(pTdiInfo, TDI_CONNECTION_INFORMATION, TotalLength);

		if (pTdiInfo == NULL)
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		pTdiInfo->UserDataLength = 0;
		pTdiInfo->UserData = NULL;
		pTdiInfo->OptionsLength = 0;
		pTdiInfo->Options = 0;
		pTdiInfo->RemoteAddressLength = TA_HEADER_LENGTH + TA_ATM_ADDRESS_LENGTH;

		pTdiInfo->RemoteAddress =
				(PVOID) ((PUCHAR)pTdiInfo + sizeof(TDI_CONNECTION_INFORMATION));

		pTdiQoS = (PVOID) ((PUCHAR)pTdiInfo->RemoteAddress + pTdiInfo->RemoteAddressLength);

		//
		//  Fill in the Remote address.
		//
		ATMSP_ZERO_MEM(pTdiInfo->RemoteAddress, pTdiInfo->RemoteAddressLength);

		pTransportAddress = (PTRANSPORT_ADDRESS)pTdiInfo->RemoteAddress;
		pTransportAddress->TAAddressCount = 1;

		pAddress = (PTA_ADDRESS)&(pTransportAddress->Address[0]);

		pAddress->AddressLength = TA_ATM_ADDRESS_LENGTH; // sizeof(ATMSP_SOCKADDR_ATM);
		pAddress->AddressType = TDI_ADDRESS_TYPE_ATM;

#if 0
		pSockAddrAtm = (ATMSP_SOCKADDR_ATM *)&(pAddress->Address[0]);
#else
		pSockAddrAtm = TA_POINTER_TO_ATM_ADDR_POINTER(pAddress->Address);
#endif
		pAtmAddress = &(pSockAddrAtm->satm_number);
		
		if (IsOutgoingCall)
		{
			*pAtmAddress = pAtmCallParameters->CalledParty;
			pAtmAddress->AddressType =
				((pAtmCallParameters->CalledParty.AddressType == ATM_E164)?
					SOCKATM_E164: SOCKATM_NSAP);
		}
		else
		{
			*pAtmAddress = pAtmCallParameters->CallingParty;
			pAtmAddress->AddressType =
				((pAtmCallParameters->CallingParty.AddressType == ATM_E164)?
					SOCKATM_E164: SOCKATM_NSAP);
		}

		RWANDEBUGP(DL_VERY_LOUD, DC_CONNECT,
				("AtmSpNdis2TdiOptions: pAddress %x, pSockAddrAtm %x, pAtmAddress %x, pAddress dump:\n",
							pAddress, pSockAddrAtm, pAtmAddress));

		RWANDEBUGPDUMP(DL_VERY_LOUD, DC_CONNECT, (PUCHAR)pAddress, sizeof(TA_ADDRESS) + sizeof(*pSockAddrAtm));

		RWANDEBUGPATMADDR(DL_LOUD, DC_CONNECT,
				"AtmSpNdis2TdiOptions: remote addr: ", pAtmAddress);

		//
		//  Fill in BHLI and BLLI elements.
		//
		if (pBhli == NULL)
		{
			pSockAddrAtm->satm_bhli.HighLayerInfoType = SAP_FIELD_ABSENT;
		}
		else
		{
			pSockAddrAtm->satm_bhli.HighLayerInfoType = pBhli->HighLayerInfoType;
			pSockAddrAtm->satm_bhli.HighLayerInfoLength = pBhli->HighLayerInfoLength;
			ATMSP_COPY_MEM(pSockAddrAtm->satm_bhli.HighLayerInfo,
						   pBhli->HighLayerInfo,
						   8);
		}

		if (pBlli == NULL)
		{
			pSockAddrAtm->satm_blli.Layer2Protocol = SAP_FIELD_ABSENT;
			pSockAddrAtm->satm_blli.Layer3Protocol = SAP_FIELD_ABSENT;
		}
		else
		{
			pSockAddrAtm->satm_blli.Layer2Protocol = pBlli->Layer2Protocol;
			pSockAddrAtm->satm_blli.Layer2UserSpecifiedProtocol = pBlli->Layer2UserSpecifiedProtocol;
			pSockAddrAtm->satm_blli.Layer3Protocol = pBlli->Layer3Protocol;
			pSockAddrAtm->satm_blli.Layer3UserSpecifiedProtocol = pBlli->Layer3UserSpecifiedProtocol;
			pSockAddrAtm->satm_blli.Layer3IPI = pBlli->Layer3IPI;
			ATMSP_COPY_MEM(pSockAddrAtm->satm_blli.SnapId,
						   pBlli->SnapId,
						   5);
		}

		//
		//  Fill in generic QoS.
		//
		pQoS = (ATMSP_QOS *)pTdiQoS;

		if (IsOutgoingCall)
		{
			pQoS->SendingFlowSpec = pCallMgrParameters->Transmit;
			pQoS->ReceivingFlowSpec = pCallMgrParameters->Receive;
		}
		else
		{
			pQoS->SendingFlowSpec = pCallMgrParameters->Transmit;
			pQoS->ReceivingFlowSpec = pCallMgrParameters->Receive;
		}

		//
		//  Fill in the provider-specific part with other Info Elements.
		//
		pQoS->ProviderSpecific.buf = (CHAR *)((PUCHAR)pQoS + sizeof(ATMSP_QOS));
		pQoS->ProviderSpecific.len = TotalIeLength;

		ATMSP_COPY_MEM(pQoS->ProviderSpecific.buf, &(pAtmCallParameters->InfoElements[0]), TotalIeLength);

		//
		//  All done. Fill in return values.
		//
		*ppTdiInfo = pTdiInfo;
		*ppTdiQoS = pTdiQoS;
		*pTdiQoSLength = sizeof(ATMSP_QOS) + TotalIeLength;
		*pAfSpTdiOptionsContext = pTdiInfo;

		RWANDEBUGP(DL_LOUD, DC_CONNECT,
			("pCallMgrParams %x, TotalIeLength %d\n", pCallMgrParameters, TotalIeLength));
		RWANDEBUGP(DL_LOUD, DC_CONNECT,
			("Transmit: SvcType %d, MaxSdu %d, Peak %d, TokenRt %d\n",
				pQoS->SendingFlowSpec.ServiceType,
				pQoS->SendingFlowSpec.MaxSduSize,
				pQoS->SendingFlowSpec.PeakBandwidth,
				pQoS->SendingFlowSpec.TokenRate));
		RWANDEBUGP(DL_LOUD, DC_CONNECT,
			("Receive: SvcType %d, MaxSdu %d, Peak %d, TokenRt %d\n",
				pQoS->ReceivingFlowSpec.ServiceType,
				pQoS->ReceivingFlowSpec.MaxSduSize,
				pQoS->ReceivingFlowSpec.PeakBandwidth,
				pQoS->ReceivingFlowSpec.TokenRate));

		break;
	}
	while (FALSE);

	return (RWanStatus);
}




RWAN_STATUS
RWanAtmSpUpdateTdiOptions(
    IN	RWAN_HANDLE						AfSpAFContext,
    IN	RWAN_HANDLE						AfSpConnContext,
    IN	ULONG							CallFlags,
    IN	PCO_CALL_PARAMETERS				pCallParameters,
    IN OUT	PTDI_CONNECTION_INFORMATION *	ppTdiInfo,
    IN OUT	PUCHAR						pTdiQoS,
    IN OUT	PULONG						pTdiQoSLength
    )
/*++

Routine Description:

	Entry point called to update TDI call parameters from NDIS parameters.
	This is typically on completion of an outgoing call.

	Right now, all we do is save the VPI/VCI for the connection to support
	SIO_GET_ATM_CONNECTION_ID.

Arguments:

	AfSpAFContext		- Points to our AF block
	AfSpConnContext		- Points to our CONN block
	CallFlags			- Call direction and other info
	pCallParameters		- Points to NDIS style Call parameters
	ppTdiInfo			- Points to pointer to generic TDI Connection Information
	pTdiQoS				- Points to generic TDI QOS structure
	pTdiQoSLength		- length of the above

Return Value:

	RWAN_STATUS_SUCCESS if the update was successful, RWAN_STATUS_XXX
	error code otherwise.

--*/
{
	RWAN_STATUS						RWanStatus;
	PATMSP_AF_BLOCK					pAfBlock;
	PATMSP_CONN_BLOCK				pConnBlock;
	PATM_MEDIA_PARAMETERS			pAtmMediaParameters;
	ATMSP_QOS *						pQoS;

	RWanStatus = RWAN_STATUS_SUCCESS;
	pAfBlock = (PATMSP_AF_BLOCK)AfSpAFContext;
	pConnBlock = (PATMSP_CONN_BLOCK)AfSpConnContext;

	ATMSP_ASSERT(pAfBlock != NULL);
	ATMSP_ASSERT(pConnBlock != NULL);
	ATMSP_ASSERT(pCallParameters != NULL);

	do
	{
		if (pCallParameters->MediaParameters)
		{
			pAtmMediaParameters = (PATM_MEDIA_PARAMETERS)
				&(pCallParameters->MediaParameters->MediaSpecific.Parameters[0]);

			pConnBlock->ConnectionId.DeviceNumber = AtmSpAfBlockToDeviceNumber(pAfBlock);
			pConnBlock->ConnectionId.Vpi = pAtmMediaParameters->ConnectionId.Vpi;
			pConnBlock->ConnectionId.Vci = pAtmMediaParameters->ConnectionId.Vci;

			RWANDEBUGP(DL_VERY_LOUD, DC_CONNECT,
				("AtmSP: UpdateTdi: VPI %d, VCI %d\n",
					pConnBlock->ConnectionId.Vpi,
					pConnBlock->ConnectionId.Vci));
		}

		if (pTdiQoS && (*pTdiQoSLength >= sizeof(ATMSP_QOS)))
		{
			pQoS = (PATMSP_QOS)pTdiQoS;
			pQoS->SendingFlowSpec = pCallParameters->CallMgrParameters->Transmit;
			pQoS->ReceivingFlowSpec = pCallParameters->CallMgrParameters->Receive;
			pQoS->ProviderSpecific.len = 0;	// for now
		}

		break;
	}
	while (FALSE);

	return (RWanStatus);
}




VOID
RWanAtmSpReturnTdiOptions(
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	RWAN_HANDLE					AfSpTdiOptionsContext
	)
/*++

Routine Description:

	This entry point is called when core Null Transport is done with
	a TDI QOS structure we'd given it via RWanAtmSpNdis2TdiOptions.
	We simply free the memory used for the structure.

Arguments:

	AfSpAFContext		- Points to our AF block
	AfSpTdiOptionsContext - Points to the structure we had allocated

Return Value:

	None

--*/
{
	UNREFERENCED_PARAMETER(AfSpAFContext);

	ATMSP_FREE_MEM(AfSpTdiOptionsContext);
}



TA_ADDRESS *
RWanAtmSpGetValidTdiAddress(
    IN	RWAN_HANDLE								AfSpContext,
    IN	TRANSPORT_ADDRESS UNALIGNED *			pAddressList,
    IN	ULONG									AddrListLength
    )
/*++

Routine Description:

	Go through the list of transport addresses given, and return the
	first valid address found.

Arguments:


Return Value:

	Pointer to the first valid address if found, else NULL.

--*/
{
	TA_ADDRESS *	        pTransportAddress;
	INT						i;
	BOOLEAN					Found;
	ULONG_PTR				EndOfAddrList;

	Found = FALSE;
	EndOfAddrList = (ULONG_PTR)pAddressList + AddrListLength;

	RWANDEBUGP(DL_LOUD, DC_WILDCARD,
		("AtmSpGetValidAddr: pAddrList x%x, Length %d\n",
					pAddressList, AddrListLength));
	
	do
	{
		if (AddrListLength < sizeof(*pAddressList))
		{
			break;
		}

		pTransportAddress = (TA_ADDRESS *) pAddressList->Address;

		for (i = 0; i < pAddressList->TAAddressCount; i++)
		{
			ULONG_PTR	EndOfAddress;

			//
			//  Check that we aren't falling off the end of the supplied
			//  buffer.
			//
			if ((ULONG_PTR)pTransportAddress < (ULONG_PTR)pAddressList ||
				(ULONG_PTR)pTransportAddress >= EndOfAddrList)
			{
				break;
			}

			EndOfAddress = (ULONG_PTR)pTransportAddress +
											sizeof(TA_ADDRESS) - 1 +
											sizeof(ATMSP_SOCKADDR_ATM);
			if (EndOfAddress < (ULONG_PTR)pAddressList ||
				EndOfAddress >= EndOfAddrList)
			{
				RWANDEBUGP(DL_ERROR, DC_WILDCARD,
							("AtmSpGetValidAddr: EndOfAddr x%x, EndOfAddrList x%x\n",
									EndOfAddress, EndOfAddrList));
				break;
			}

			if (pTransportAddress->AddressType == TDI_ADDRESS_TYPE_ATM)
			{
				if (pTransportAddress->AddressLength >= sizeof(ATMSP_SOCKADDR_ATM))
				{
					Found = TRUE;
					break;
				}
			}

			pTransportAddress = (TA_ADDRESS *)
									((PUCHAR)pTransportAddress + 
										sizeof(TA_ADDRESS) - 1 +
										pTransportAddress->AddressLength);
		}
	}
	while (FALSE);


	if (!Found)
	{
		pTransportAddress = NULL;
	}

	RWANDEBUGP(DL_LOUD, DC_WILDCARD,
		("AtmSpGetValidAddr returning x%x\n", pTransportAddress));

	return (pTransportAddress);
}




BOOLEAN
RWanAtmSpIsNullAddress(
    IN	RWAN_HANDLE					AfSpContext,
    IN	TA_ADDRESS *		        pTransportAddress
    )
/*++

Routine Description:

	Check if the given transport address contains a NULL ATM address.
	A NULL ATM address is one that cannot be used in an NDIS SAP.

Arguments:

	AfSpContext			- Points to our Global context
	pTransportAddress	- Points to a TDI transport address

Return Value:

	TRUE if the given address is a NULL ATM address, FALSE otherwise.

--*/
{
	ATMSP_SOCKADDR_ATM UNALIGNED *	pSockAddrAtm;
	ATM_ADDRESS UNALIGNED *			pAtmAddress;
	BOOLEAN							IsNullAddress;

	UNREFERENCED_PARAMETER(AfSpContext);

	ATMSP_ASSERT(pTransportAddress->AddressLength >= sizeof(ATMSP_SOCKADDR_ATM));

	pSockAddrAtm = TA_POINTER_TO_ATM_ADDR_POINTER(pTransportAddress->Address);

	pAtmAddress = &pSockAddrAtm->satm_number;

	return (pAtmAddress->AddressType == SAP_FIELD_ABSENT);
}




RWAN_STATUS
RWanAtmSpTdi2NdisSap(
    IN	RWAN_HANDLE					AfSpContext,
    IN	USHORT						TdiAddressType,
    IN	USHORT						TdiAddressLength,
    IN	PVOID						pTdiAddress,
    OUT	PCO_SAP *					ppCoSap
    )
/*++

Routine Description:

	Convert an ATM SAP in TDI format to NDIS format.

Arguments:

	AfSpContext			- Points to our Global context
	TdiAddressType		- Should be TDI_ADDRESS_TYPE_ATM
	TdiAddressLength	- Should be enough to hold SOCKADDR_ATM
	pTdiAddress			- Points to TDI address.
	ppCoSap				- Place to return pointer to allocated CO_SAP structure.

Return Value:

	RWAN_STATUS_SUCCESS if an NDIS ATM SAP was filled in successfully,
	RWAN_STATUS_XXX error code otherwise.

--*/
{
	RWAN_STATUS				RWanStatus;
	PCO_SAP					pCoSap;
	PATM_SAP				pAtmSap;
	ATMSP_SOCKADDR_ATM UNALIGNED *pSockAddrAtm;
	ATM_ADDRESS UNALIGNED *	pTdiAtmAddress;
	ULONG					SapSize;

	UNREFERENCED_PARAMETER(AfSpContext);

	ATMSP_ASSERT(TdiAddressType == TDI_ADDRESS_TYPE_ATM);
	ATMSP_ASSERT(TdiAddressLength >= sizeof(ATMSP_SOCKADDR_ATM));

	pSockAddrAtm = TA_POINTER_TO_ATM_ADDR_POINTER(pTdiAddress);
	pTdiAtmAddress = &(pSockAddrAtm->satm_number);

	RWANDEBUGPATMADDR(DL_LOUD, DC_CONNECT,
				"AtmSpTdi2NdisSap: remote addr: ", pTdiAtmAddress);

	SapSize = sizeof(CO_SAP) + sizeof(ATM_SAP) + sizeof(ATM_ADDRESS);

	ATMSP_ALLOC_MEM(pCoSap, CO_SAP, sizeof(CO_SAP) + sizeof(ATM_SAP) + sizeof(ATM_ADDRESS));

	if (pCoSap != NULL)
	{
		ATMSP_ZERO_MEM(pCoSap, SapSize);

		pCoSap->SapType = SAP_TYPE_NSAP;

		pCoSap->SapLength = sizeof(ATM_SAP) + sizeof(ATM_ADDRESS);
		pAtmSap = (PATM_SAP)&(pCoSap->Sap[0]);
		
		//
		//  Copy in the BLLI part. We can't use a simple mem copy because
		//  the Winsock 2 definition of BLLI in sockaddr_atm is different
		//  from the complete BLLI IE.
		//
		pAtmSap->Blli.Layer2Protocol = pSockAddrAtm->satm_blli.Layer2Protocol;
		pAtmSap->Blli.Layer2UserSpecifiedProtocol = pSockAddrAtm->satm_blli.Layer2UserSpecifiedProtocol;
		pAtmSap->Blli.Layer3Protocol = pSockAddrAtm->satm_blli.Layer3Protocol;
		pAtmSap->Blli.Layer3UserSpecifiedProtocol = pSockAddrAtm->satm_blli.Layer3UserSpecifiedProtocol;
		pAtmSap->Blli.Layer3IPI = pSockAddrAtm->satm_blli.Layer3IPI;
		ATMSP_COPY_MEM(pAtmSap->Blli.SnapId,
					   pSockAddrAtm->satm_blli.SnapId,
					   5);

		//
		//  Copy in the BHLI part.
		//
		pAtmSap->Bhli.HighLayerInfoType = pSockAddrAtm->satm_bhli.HighLayerInfoType;
		pAtmSap->Bhli.HighLayerInfoLength = pSockAddrAtm->satm_bhli.HighLayerInfoLength;
		ATMSP_COPY_MEM(pAtmSap->Bhli.HighLayerInfo,
					   pSockAddrAtm->satm_bhli.HighLayerInfo,
					   8);

		pAtmSap->NumberOfAddresses = 1;
		ATMSP_COPY_MEM(pAtmSap->Addresses, pTdiAtmAddress, sizeof(ATM_ADDRESS));

		//
		//  Convert the Address type from Winsock 2 definition to NDIS definitions
		//
		{
			ATM_ADDRESS UNALIGNED *	pNdisAtmAddress;

			pNdisAtmAddress = (ATM_ADDRESS UNALIGNED *)pAtmSap->Addresses;

			switch (pTdiAtmAddress->AddressType)
			{
				case SOCKATM_E164:
					pNdisAtmAddress->AddressType = ATM_E164;
					break;
				
				case SOCKATM_NSAP:
					pNdisAtmAddress->AddressType = ATM_NSAP;
					break;
				
				default:
					//
					// Possibly SAP_FIELD_XXX; leave it as it is.
					//
					break;
			}
		}

		RWanStatus = RWAN_STATUS_SUCCESS;
	}
	else
	{
		RWanStatus = RWAN_STATUS_RESOURCES;
	}

	*ppCoSap = pCoSap;

	return (RWanStatus);
}




VOID
RWanAtmSpReturnNdisSap(
    IN	RWAN_HANDLE					AfSpContext,
    IN	PCO_SAP						pCoSap
    )
/*++

Routine Description:

	This entry point is called to return an NDIS SAP structure we'd
	allocated in RWanAtmSpTdi2NdisSap

Arguments:

	AfSpContext			- Points to our Global context
	pCoSap				- Points to CO_SAP structure to be freed.

Return Value:

	None

--*/
{
	UNREFERENCED_PARAMETER(AfSpContext);
	ATMSP_FREE_MEM(pCoSap);

	return;
}




VOID
RWanAtmSpDeregNdisAFComplete(
    IN	RWAN_STATUS					RWanStatus,
    IN	RWAN_HANDLE					AfSpContext
    )
/*++

Routine Description:

	Entry point to complete a previous call we had made to
	RWanAfSpDeregisterNdisAF that had pended.

Arguments:

	RWanStatus			- Completion status
	AfSpContext			- Points to our Global context

Return Value:

	None

--*/
{
	UNREFERENCED_PARAMETER(RWanStatus);
	UNREFERENCED_PARAMETER(AfSpContext);

	// XXX: Do more
	return;
}




VOID
RWanAtmSpDeregTdiProtoComplete(
    IN	RWAN_STATUS					RWanStatus,
    IN	RWAN_HANDLE					AfSpContext
    )
/*++

Routine Description:

	Entry point to complete a previous call we had made to
	RWanAfSpDeregisterTdiProtocol that had pended.

Arguments:

	RWanStatus			- Completion status
	AfSpContext			- Points to our Global context

Return Value:

	None

--*/
{
	UNREFERENCED_PARAMETER(RWanStatus);
	UNREFERENCED_PARAMETER(AfSpContext);

	ATMSP_ASSERT(FALSE);	// XXX: Do more
	return;
}



PATMSP_AF_BLOCK
AtmSpDeviceNumberToAfBlock(
	IN	UINT						DeviceNumber
	)
/*++

Routine Description:

	Return the AF Block corresponding to the given Device Number.
	The AF blocks are assumed to be numbered 0, 1, 2 ...

Arguments:

	DeviceNumber	- what we are looking for

Return Value:

	Pointer to AF Block if found, else NULL.

--*/
{
	PATMSP_AF_BLOCK		pAfBlock;
	PLIST_ENTRY			pAfEntry;

	pAfBlock = NULL;

	for (pAfEntry = pAtmSpGlobal->AfList.Flink;
		 pAfEntry != &(pAtmSpGlobal->AfList);
		 pAfEntry = pAfEntry->Flink)
	{
		if (DeviceNumber == 0)
		{
			pAfBlock = CONTAINING_RECORD(pAfEntry, ATMSP_AF_BLOCK, AfBlockLink);
			break;
		}

		DeviceNumber--;
	}

	return (pAfBlock);
}


UINT
AtmSpAfBlockToDeviceNumber(
	IN	PATMSP_AF_BLOCK				pAfBlock
	)
/*++

Routine Description:

	Return the device number corresponding to the specified AF block.

Arguments:

	pAfBlock	- Pointer to AF block

Return Value:

	0-based device number.

--*/
{
	PLIST_ENTRY			pAfEntry;
	PATMSP_AF_BLOCK		pAfBlockEntry;
	UINT				DeviceNumber = (UINT)-1;

	for (pAfEntry = pAtmSpGlobal->AfList.Flink;
		 pAfEntry != &(pAtmSpGlobal->AfList);
		 pAfEntry = pAfEntry->Flink)
	{
		DeviceNumber++;

		pAfBlockEntry = CONTAINING_RECORD(pAfEntry, ATMSP_AF_BLOCK, AfBlockLink);
		if (pAfBlockEntry == pAfBlock)
		{
			break;
		}
	}

	return (DeviceNumber);
}


RWAN_STATUS
AtmSpDoAdapterRequest(
    IN	PATMSP_AF_BLOCK				pAfBlock,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    )
/*++

Routine Description:

	Send an NDIS Request to the adapter and wait till it completes.

Arguments:

	pAfBlock			- Points to our NDIS AF open context block
	RequestType			- Set/Query
	Oid					- Object under question
	pBuffer				- Pointer to buffer that contains/is to contain info.
	BufferLength		- Length of above

Return Value:

	RWAN_STATUS - RWAN_STATUS_SUCCESS if we succeeded, RWAN_STATUS_FAILURE if not.

--*/
{
	PATMSP_EVENT		pEvent;
	RWAN_STATUS			RWanStatus;

	ATMSP_ALLOC_MEM(pEvent, ATMSP_EVENT, sizeof(ATMSP_EVENT));

	if (pEvent == NULL)
	{
		return (RWAN_STATUS_RESOURCES);
	}

	ATMSP_INIT_EVENT_STRUCT(pEvent);

	RWanStatus = RWanAfSpSendAdapterRequest(
					pAfBlock->RWanAFHandle,
					(RWAN_HANDLE)pEvent,
					RequestType,
					Oid,
					pBuffer,
					BufferLength
					);

	if (RWanStatus == RWAN_STATUS_PENDING)
	{
		RWanStatus = ATMSP_WAIT_ON_EVENT_STRUCT(pEvent);
	}

	ATMSP_FREE_MEM(pEvent);

	return (RWanStatus);
}




RWAN_STATUS
AtmSpDoCallManagerRequest(
    IN	PATMSP_AF_BLOCK				pAfBlock,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    )
/*++

Routine Description:

	Send an NDIS Request to the Call Manager and wait till it completes.

Arguments:

	pAfBlock			- Points to our NDIS AF open context block
	RequestType			- Set/Query
	Oid					- Object under question
	pBuffer				- Pointer to buffer that contains/is to contain info.
	BufferLength		- Length of above

Return Value:

	RWAN_STATUS - RWAN_STATUS_SUCCESS if we succeeded, RWAN_STATUS_FAILURE if not.

--*/
{
	PATMSP_EVENT		pEvent;
	RWAN_STATUS			RWanStatus;

	ATMSP_ALLOC_MEM(pEvent, ATMSP_EVENT, sizeof(ATMSP_EVENT));

	if (pEvent == NULL)
	{
		return (RWAN_STATUS_RESOURCES);
	}

	ATMSP_INIT_EVENT_STRUCT(pEvent);

	RWanStatus = RWanAfSpSendAfRequest(
					pAfBlock->RWanAFHandle,
					(RWAN_HANDLE)pEvent,
					RequestType,
					Oid,
					pBuffer,
					BufferLength
					);

	if (RWanStatus == RWAN_STATUS_PENDING)
	{
		RWanStatus = ATMSP_WAIT_ON_EVENT_STRUCT(pEvent);
	}

	ATMSP_FREE_MEM(pEvent);

	return (RWanStatus);
}



ATMSP_SOCKADDR_ATM UNALIGNED *
AtmSpGetSockAtmAddress(
	IN	PVOID						pTdiAddressList,
	IN	ULONG						AddrListLength
	)
/*++

Routine Description:

	Look for a valid SOCKADDR_ATM address in the given TDI address list.

Arguments:

	pTdiAddressList		- Points to list of TDI addresses.
	AddrListLength		- Length of list

Return Value:

	Pointer to valid address if it exists, else NULL.

--*/
{
	TA_ADDRESS *		            pTransportAddress;
	ATMSP_SOCKADDR_ATM UNALIGNED *	pSockAddrAtm;

	pTransportAddress = RWanAtmSpGetValidTdiAddress(
								(RWAN_HANDLE)&AtmSpGlobal,
								pTdiAddressList,
								AddrListLength
								);

	if (pTransportAddress != NULL)
	{
		pSockAddrAtm = TA_POINTER_TO_ATM_ADDR_POINTER(pTransportAddress->Address);
	}
	else
	{
		pSockAddrAtm = NULL;
	}

	return (pSockAddrAtm);
}




VOID
RWanAtmSpAdapterRequestComplete(
    IN	NDIS_STATUS					Status,
    IN	RWAN_HANDLE					AfSpAFContext,
    IN	RWAN_HANDLE					AfSpReqContext,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    )
/*++

Routine Description:

	This entry point is called to signify completion of a previous
	NDIS request we'd sent to the miniport by calling RWanAfSpSendAdapterRequest.

Arguments:

	Status				- Status of the query
	AfSpAFContext		- Points to our NDIS AF open context block
	AfSpReqContext		- Points to Event structure
	RequestType			- Query/Set
	Oid					- Object that we were querying/setting
	pBuffer				- Pointer to object value
	BufferLength		- Length of the above


Return Value:

	None

--*/
{
	PATMSP_EVENT		pEvent;
	RWAN_STATUS			RWanStatus;

	pEvent = (PATMSP_EVENT) AfSpReqContext;

	RWanStatus = ((Status == NDIS_STATUS_SUCCESS)? RWAN_STATUS_SUCCESS: RWAN_STATUS_FAILURE);

	ATMSP_SIGNAL_EVENT_STRUCT(pEvent, RWanStatus);

	return;
}




VOID
RWanAtmSpAfRequestComplete(
    IN	NDIS_STATUS					Status,
    IN	RWAN_HANDLE					AfSpAFContext,
    IN	RWAN_HANDLE					AfSpReqContext,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    )
/*++

Routine Description:

	This entry point is called to signify completion of a previous
	NDIS request we'd sent to the Call Mgr by calling RWanAfSpSendAfRequest.

Arguments:

	Status				- Status of the query
	AfSpAFContext		- Points to our NDIS AF open context block
	AfSpReqContext		- Points to Event structure
	RequestType			- Query/Set
	Oid					- Object that we were querying/setting
	pBuffer				- Pointer to object value
	BufferLength		- Length of the above


Return Value:

	None

--*/
{
	PATMSP_EVENT		pEvent;
	RWAN_STATUS			RWanStatus;

	pEvent = (PATMSP_EVENT) AfSpReqContext;

	RWanStatus = ((Status == NDIS_STATUS_SUCCESS)? RWAN_STATUS_SUCCESS: RWAN_STATUS_FAILURE);

	ATMSP_SIGNAL_EVENT_STRUCT(pEvent, RWanStatus);

	return;
}



VOID
RWanAtmSpDeregTdiProtocolComplete(
	IN	RWAN_STATUS					RWanStatus,
	IN	RWAN_HANDLE					AfSpTdiProtocolContext
	)
/*++

Routine Description:

	Completion of our pended call to RWanAfSpDeregisterTdiProtocol.
	Not expected because we don't call this.

Arguments:

	RWanStatus		- Final status of deregistering the TDI protocol.
	AfSpTdiProtocolContext - Points to our global struct.

Return Value:

	None

--*/
{
	ATMSP_ASSERT(FALSE);

	return;
}




VOID
AtmSpPrepareDefaultQoS(
    IN	PATMSP_AF_BLOCK				pAfBlock
)
/*++

Routine Description:

	Prepare the default QOS structure to be used for outgoing calls
	on this AF.

Arguments:

	pAfBlock			- Points to our NDIS AF open context block

Return Value:

	None

--*/
{
	ATMSP_QOS *		pQoS;
	FLOWSPEC *		pSendFlowSpec;
	FLOWSPEC *		pRecvFlowSpec;

	pQoS = &pAfBlock->DefaultQoS;

	ATMSP_ZERO_MEM(pQoS, sizeof(ATMSP_QOS));

	pSendFlowSpec = &pQoS->SendingFlowSpec;
	pRecvFlowSpec = &pQoS->ReceivingFlowSpec;
	
	pRecvFlowSpec->ServiceType =
	pSendFlowSpec->ServiceType = SERVICETYPE_BESTEFFORT;

	//
	//  The line rates are in units of 100s of bits/second.
	//  Convert to bytes/second.
	//
	pRecvFlowSpec->TokenRate = (pAfBlock->LineRate.Inbound * 100) / 8;
	pSendFlowSpec->TokenRate = (pAfBlock->LineRate.Outbound * 100) / 8;

	pRecvFlowSpec->PeakBandwidth = pRecvFlowSpec->TokenRate;
	pSendFlowSpec->PeakBandwidth = pSendFlowSpec->TokenRate;

	pRecvFlowSpec->MaxSduSize =
	pSendFlowSpec->MaxSduSize = pAfBlock->MaxPacketSize;

	pAfBlock->DefaultQoSLength = sizeof(ATMSP_QOS);
	return;
}


RWAN_STATUS
RWanAtmSpQueryGlobalInfo(
    IN	RWAN_HANDLE					AfSpContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength,
    IN	PVOID						pOutputBuffer,
    IN OUT	PULONG					pOutputBufferLength
    )
/*++

Routine Description:

	Process a media-specific IOCTL to query information from the helper DLL.

Arguments:

	AfSpContext			- Points to our Global context
	pInputBuffer		- Input information
	InputBufferLength	- Length of the above
	pOutputBuffer		- Points to buffer for output
	pOutputBufferLength	- On entry, contains size of output buffer. On return,
						  we fill this with the actual bytes returned.

Return Value:

	RWAN_STATUS_SUCCESS if we processed the IOCTL successfully
	RWAN_STATUS_XXX to indicate any failure.

--*/
{
	PATM_QUERY_INFORMATION_EX		pQueryInfo;
	RWAN_STATUS						RWanStatus;
	ULONG							Info;
	PUCHAR							pSrcBuffer = (PUCHAR)&Info;
	ULONG							BufferLength;
	PATMSP_AF_BLOCK					pAfBlock;
	UINT							DeviceNumber;
	PCO_ADDRESS_LIST				pAddrList = NULL;

	RWANDEBUGP(DL_LOUD, DC_DISPATCH,
				("AtmSpQueryInfo: InBuf x%x/%d, OutBuf x%x/%d\n",
					pInputBuffer,
					InputBufferLength,
					pOutputBuffer,
					*pOutputBufferLength));

	RWanStatus = RWAN_STATUS_SUCCESS;

	do
	{
		//
		//  See if the input buffer is big enough.
		//
		if (InputBufferLength < sizeof(ATM_QUERY_INFORMATION_EX))
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		pQueryInfo = (PATM_QUERY_INFORMATION_EX)pInputBuffer;

		switch (pQueryInfo->ObjectId)
		{
			case ATMSP_OID_NUMBER_OF_DEVICES:

				BufferLength = sizeof(ULONG);
				Info = pAtmSpGlobal->AfListSize;
				break;
			
			case ATMSP_OID_ATM_ADDRESS:

				//
				//  Get the device number being queried.
				//
				if (pQueryInfo->ContextLength < sizeof(UINT))
				{
					RWanStatus = RWAN_STATUS_RESOURCES;
					break;
				}

				DeviceNumber = *((PUINT)&pQueryInfo->Context[0]);

				//
				//  Get the AF block for the device # being queried.
				//
				pAfBlock = AtmSpDeviceNumberToAfBlock(DeviceNumber);

				if (pAfBlock == NULL)
				{
					RWanStatus = RWAN_STATUS_BAD_ADDRESS;
					break;
				}

				ATMSP_ALLOC_MEM(pAddrList,
								CO_ADDRESS_LIST,
								sizeof(CO_ADDRESS_LIST)+sizeof(CO_ADDRESS)+sizeof(ATM_ADDRESS));
				if (pAddrList == NULL)
				{
					RWanStatus = RWAN_STATUS_RESOURCES;
					break;
				}

				RWanStatus = AtmSpDoCallManagerRequest(
								pAfBlock,
								NdisRequestQueryInformation,
								OID_CO_GET_ADDRESSES,
								pAddrList,
								sizeof(CO_ADDRESS_LIST)+sizeof(CO_ADDRESS)+sizeof(ATM_ADDRESS)
								);
				
				if ((RWanStatus == RWAN_STATUS_SUCCESS) &&
					(pAddrList->NumberOfAddresses > 0))
				{
					ATM_ADDRESS UNALIGNED *	pAtmAddress;

					pSrcBuffer = (PUCHAR)&pAddrList->AddressList.Address[0];

					//
					//  Fix the address type for Winsock2.
					//
					pAtmAddress = (ATM_ADDRESS UNALIGNED *)pSrcBuffer;
					pAtmAddress->AddressType = ((pAtmAddress->AddressType == ATM_E164)?
												SOCKATM_E164: SOCKATM_NSAP);

					BufferLength = sizeof(ATM_ADDRESS);
				}
				else
				{
					if (RWanStatus == RWAN_STATUS_SUCCESS)
					{
						RWanStatus = RWAN_STATUS_FAILURE;
					}
				}

				RWANDEBUGP(DL_LOUD, DC_DISPATCH,
							("AtmSpQueryInfo: GetAddr: Status %x, pSrc %x, BufLen %d\n",
								RWanStatus, pSrcBuffer, BufferLength));
				break;

			default:
				//
				//  Unknown OID
				//
				RWANDEBUGP(DL_ERROR, DC_DISPATCH,
							("AtmSpQueryInfo: Unknown OID x%x\n", pQueryInfo->ObjectId));
				RWanStatus = RWAN_STATUS_BAD_PARAMETER;
				break;
		}

		break;
	}
	while (FALSE);

	//
	//  Fill in the output buffer now.
	//
	if (RWanStatus == RWAN_STATUS_SUCCESS)
	{
		if (BufferLength <= *pOutputBufferLength)
		{
			RWANDEBUGP(DL_LOUD, DC_DISPATCH,
						("AtmSpQueryInfo: Copying %d bytes from %x to %x\n",
							BufferLength, pSrcBuffer, pOutputBuffer));
			ATMSP_COPY_MEM(pOutputBuffer, pSrcBuffer, BufferLength);
		}
		else
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
		}
		*pOutputBufferLength = BufferLength;
	}

	if (pAddrList != NULL)
	{
		ATMSP_FREE_MEM(pAddrList);
	}

	RWANDEBUGP(DL_LOUD, DC_DISPATCH,
				("AtmSpQueryInfo: returning x%x\n", RWanStatus));

	return (RWanStatus);
}


RWAN_STATUS
RWanAtmSpSetGlobalInfo(
    IN	RWAN_HANDLE					AfSpContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength
    )
/*++

Routine Description:

	Process a media-specific IOCTL to set information from the helper DLL.

Arguments:

	AfSpContext			- Points to our Global context
	pInputBuffer		- Input information
	InputBufferLength	- Length of the above

Return Value:

	RWAN_STATUS_SUCCESS if we processed the IOCTL successfully
	RWAN_STATUS_XXX to indicate any failure.

--*/
{
	RWANDEBUGP(DL_LOUD, DC_CONNECT,
				("AtmSpSetInfo: InBuf x%x/%d\n",
					pInputBuffer,
					InputBufferLength));

	return (RWAN_STATUS_FAILURE);
}


#ifndef NO_CONN_CONTEXT


RWAN_STATUS
RWanAtmSpSetAddrInfo(
    IN	RWAN_HANDLE					AfSpAddrContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength
    )
/*++

Routine Description:

	Process a media-specific IOCTL to set information on an address object
	from the helper DLL.

Arguments:

	AfSpAddrContext		- Points to our Address Block
	pInputBuffer		- Input information
	InputBufferLength	- Length of the above

Return Value:

	RWAN_STATUS_SUCCESS if we processed the IOCTL successfully
	RWAN_STATUS_XXX to indicate any failure.
--*/
{
	RWAN_STATUS						RWanStatus;
	PATM_SET_INFORMATION_EX			pSetInfo;
	PATMSP_ADDR_BLOCK				pAddrBlock;
	PATMSP_CONNECTION_ID			pConnectionId;

	RWanStatus = RWAN_STATUS_SUCCESS;
	pAddrBlock = (PATMSP_ADDR_BLOCK)AfSpAddrContext;
	ATMSP_ASSERT(pAddrBlock != NULL);

	do
	{
		//
		//  See if the input buffer is big enough.
		//
		if (InputBufferLength < sizeof(ATM_SET_INFORMATION_EX))
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}


		pSetInfo = (PATM_SET_INFORMATION_EX)pInputBuffer;

		switch (pSetInfo->ObjectId)
		{
			case ATMSP_OID_PVC_ID:

				if (pSetInfo->BufferSize < sizeof(ATMSP_CONNECTION_ID))
				{
					RWanStatus = RWAN_STATUS_RESOURCES;
					break;
				}

				//
				//  Copy in the connection Id.
				//
				try
				{
					pConnectionId = (PATMSP_CONNECTION_ID)&(pSetInfo->Buffer[0]);
					pAddrBlock->ConnectionId = *pConnectionId;
				}
				except (EXCEPTION_EXECUTE_HANDLER)
					{
						RWanStatus = RWAN_STATUS_FAILURE;
					}

				if (RWanStatus != RWAN_STATUS_SUCCESS)
				{
					break;
				}

				//
				//  Mark this address object.
				//
				ATMSP_SET_BIT(pAddrBlock->Flags, ATMSPF_ADDR_PVC_ID_SET);

				RWANDEBUGP(DL_LOUD, DC_BIND,
							("AtmSpSetAddrInfo: Set PVC Id: AddrBlock x%x, Vpi %d, Vci %d\n",
								pAddrBlock,
								pAddrBlock->ConnectionId.Vpi,
								pAddrBlock->ConnectionId.Vci));

				break;
			
			default:
				//
				//  Unknown OID
				//
				RWANDEBUGP(DL_ERROR, DC_DISPATCH,
							("AtmSpSetAddrInfo: Unknown OID x%x\n", pSetInfo->ObjectId));
				RWanStatus = RWAN_STATUS_BAD_PARAMETER;
				break;
		}

		break;
	}
	while (FALSE);
				
	return (RWanStatus);
}


RWAN_STATUS
RWanAtmSpQueryConnInfo(
    IN	RWAN_HANDLE					AfSpConnContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength,
    OUT	PVOID						pOutputBuffer,
    IN OUT PULONG					pOutputBufferLength
    )
/*++

Routine Description:

	Handle a request to query information for a connection.

Arguments:

	AfSpConnContext		- Points to our Connection Block
	pInputBuffer		- Input information
	InputBufferLength	- Length of the above
	pOutputBuffer		- Place to return information
	pOutputBufferLength	- where we return bytes-written

Return Value:

	RWAN_STATUS_SUCCESS if we processed the query successfully,
	RWAN_STATUS_XXX error code otherwise.

--*/
{
	RWAN_STATUS						RWanStatus;
	PATM_QUERY_INFORMATION_EX		pQueryInfo;
	PATMSP_CONN_BLOCK				pConnBlock;
	PATMSP_CONNECTION_ID			pConnectionId;

	RWanStatus = RWAN_STATUS_SUCCESS;
	pConnBlock = (PATMSP_CONN_BLOCK)AfSpConnContext;
	ATMSP_ASSERT(pConnBlock != NULL);

	do
	{
		//
		//  See if the input buffer is big enough.
		//
		if (InputBufferLength < sizeof(ATM_QUERY_INFORMATION_EX))
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}


		pQueryInfo = (PATM_QUERY_INFORMATION_EX)pInputBuffer;

		switch (pQueryInfo->ObjectId)
		{
			case ATMSP_OID_CONNECTION_ID:

				if (*pOutputBufferLength < sizeof(ATMSP_CONNECTION_ID))
				{
					RWanStatus = RWAN_STATUS_RESOURCES;
					break;
				}

				//
				//  Copy in the connection Id.
				//
				pConnectionId = pOutputBuffer;
				*pConnectionId = pConnBlock->ConnectionId;
				*pOutputBufferLength = sizeof(pConnBlock->ConnectionId);
				break;

			default:
				//
				//  Unknown OID
				//
				RWANDEBUGP(DL_ERROR, DC_DISPATCH,
							("AtmSpQueryConnInfo: Unknown OID x%x\n", pQueryInfo->ObjectId));
				RWanStatus = RWAN_STATUS_BAD_PARAMETER;
				break;
		}

		break;
	}
	while (FALSE);

	return (RWanStatus);
}
#endif // NO_CONN_CONTEXT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\vc.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\vc.c

Abstract:

	Routines that manage NDIS VC objects.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     05-05-97    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER '  CV'



PRWAN_NDIS_VC
RWanAllocateVc(
	IN	PRWAN_NDIS_AF				pAf,
	IN	BOOLEAN						IsOutgoing
	)
/*++

Routine Description:

	Allocate and initialize an NDIS VC endpoint on the specified
	Address Family. If it is an "outgoing" VC, we also request
	NDIS to allocate a handle for it.

Arguments:

	pAf					- Points to NDIS AF block
	IsOutgoing			- This VC is for an outgoing call

Return Value:

	Pointer to VC if successful, NULL otherwise.

--*/
{
	PRWAN_NDIS_VC			pVc;
	NDIS_STATUS				Status;


	RWAN_ALLOC_MEM(pVc, RWAN_NDIS_VC, sizeof(RWAN_NDIS_VC));

	if (pVc != NULL)
	{
		RWAN_ZERO_MEM(pVc, sizeof(RWAN_NDIS_VC));

		RWAN_SET_SIGNATURE(pVc, nvc);

		pVc->pNdisAf = pAf;
		pVc->MaxSendSize = 0;	// Initialize.

		RWAN_INIT_LIST(&(pVc->NdisPartyList));

		if (IsOutgoing)
		{
			//
			//  Request the Call manager and Miniport to create a VC.
			//
			Status = NdisCoCreateVc(
						pAf->pAdapter->NdisAdapterHandle,
						pAf->NdisAfHandle,
						(NDIS_HANDLE)pVc,
						&(pVc->NdisVcHandle)
						);

			if (Status == NDIS_STATUS_SUCCESS)
			{
				//
				//  Add this VC to the list on the AF Block.
				//
				RWAN_ACQUIRE_AF_LOCK(pAf);

				RWAN_INSERT_TAIL_LIST(&(pAf->NdisVcList),
 									 &(pVc->VcLink));
			
				RWanReferenceAf(pAf);	// New outgoing VC ref

				RWAN_RELEASE_AF_LOCK(pAf);
			}
			else
			{
				RWAN_FREE_MEM(pVc);
				pVc = NULL;
			}
		}
		else
		{
			//
			//  Add this VC to the list on the AF Block.
			//
			RWAN_ACQUIRE_AF_LOCK(pAf);

			RWAN_INSERT_TAIL_LIST(&(pAf->NdisVcList),
 								&(pVc->VcLink));

			RWanReferenceAf(pAf);	// New incoming VC ref

			RWAN_RELEASE_AF_LOCK(pAf);
		}	
	}

	return (pVc);
}



VOID
RWanFreeVc(
	IN	PRWAN_NDIS_VC				pVc
	)
/*++

Routine Description:

	Free a VC structure.

Arguments:

	pVc				- Pointer to VC to be freed.

Return Value:

	None

--*/
{
	RWAN_FREE_MEM(pVc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\tdi\externs.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\atm\externs.h

Abstract:

	All external declarations for ATM-specific Raw WAN (functions, globals)
	are here.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     06-13-97    Created

Notes:

--*/


#ifndef __TDI_ATMSP_EXTERNS__H
#define __TDI_ATMSP_EXTERNS__H


#ifndef EXTERN
#define EXTERN	extern
#endif // EXTERN

EXTERN
RWAN_STATUS
RWanAtmSpInitialize(
	VOID
	);

EXTERN
VOID
RWanAtmSpShutdown(
	VOID
	);

EXTERN
RWAN_STATUS
RWanAtmSpOpenAf(
    IN	RWAN_HANDLE					AfSpContext,
    IN	RWAN_HANDLE					RWanAFHandle,
    OUT	PRWAN_HANDLE				pAfSpAFContext,
    OUT PULONG						pMaxMsgSize
    );

EXTERN
RWAN_STATUS
RWanAtmSpCloseAf(
    IN	RWAN_HANDLE					AfSpAFContext
    );

EXTERN
RWAN_STATUS
RWanAtmSpOpenAddressObject(
    IN	RWAN_HANDLE					AfSpContext,
    IN	RWAN_HANDLE					RWanAddrHandle,
    OUT	PRWAN_HANDLE				pAfSpAddrContext
    );

EXTERN
VOID
RWanAtmSpCloseAddressObject(
    IN	RWAN_HANDLE					AfSpAddrContext
    );

EXTERN
RWAN_STATUS
RWanAtmSpAssociateConnection(
    IN	RWAN_HANDLE					AfSpAddrContext,
    IN	RWAN_HANDLE					RWanConnHandle,
    OUT	PRWAN_HANDLE				pAfSpConnContext
    );

EXTERN
VOID
RWanAtmSpDisassociateConnection(
	IN	RWAN_HANDLE					AfSpConnContext
	);

EXTERN
RWAN_STATUS
RWanAtmSpTdi2NdisOptions(
    IN	RWAN_HANDLE					AfSpConnContext,
    IN	ULONG						CallFlags,
    IN	PTDI_CONNECTION_INFORMATION	pTdiInfo,
    IN	PVOID						pTdiQoS,
    IN	ULONG						TdiQoSLength,
    OUT	PRWAN_HANDLE				pRWanAfHandle,
    OUT	PCO_CALL_PARAMETERS *		ppCallParameters
    );

EXTERN
RWAN_STATUS
RWanAtmSpUpdateNdisOptions(
	IN	RWAN_HANDLE					AfSpAFContext,
    IN	RWAN_HANDLE					AfSpConnContext,
    IN	ULONG						CallFlags,
	IN	PTDI_CONNECTION_INFORMATION	pTdiInfo,
	IN	PVOID						pTdiQoS,
	IN	ULONG						TdiQoSLength,
	IN OUT PCO_CALL_PARAMETERS *	ppCallParameters
	);

EXTERN
VOID
RWanAtmSpReturnNdisOptions(
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
	);

EXTERN
RWAN_STATUS
RWanAtmSpNdis2TdiOptions(
    IN	RWAN_HANDLE					AfSpAFContext,
    IN	ULONG						CallFlags,
    IN	PCO_CALL_PARAMETERS			pCallParameters,
    OUT	PTDI_CONNECTION_INFORMATION *ppTdiInfo,
    OUT	PVOID *						ppTdiQoS,
    OUT	PULONG 						pTdiQoSLength,
    OUT	RWAN_HANDLE *				pAfSpTdiOptionsContext
    );

EXTERN
RWAN_STATUS
RWanAtmSpUpdateTdiOptions(
    IN	RWAN_HANDLE					AfSpAFContext,
    IN	RWAN_HANDLE					AfSpConnContext,
    IN	ULONG						CallFlags,
    IN	PCO_CALL_PARAMETERS			pCallParameters,
    IN OUT	PTDI_CONNECTION_INFORMATION *	ppTdiInfo,
    IN OUT	PUCHAR						pTdiQoS,
    IN OUT	PULONG						pTdiQoSLength
    );

EXTERN
VOID
RWanAtmSpReturnTdiOptions(
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	RWAN_HANDLE					AfSpTdiOptionsContext
	);

EXTERN
TA_ADDRESS *
RWanAtmSpGetValidTdiAddress(
    IN	RWAN_HANDLE					AfSpContext,
    IN	TRANSPORT_ADDRESS UNALIGNED *pAddressList,
    IN	ULONG						AddrListLength
    );

EXTERN
BOOLEAN
RWanAtmSpIsNullAddress(
    IN	RWAN_HANDLE					AfSpContext,
    IN	TA_ADDRESS *		        pTransportAddress
    );

EXTERN
RWAN_STATUS
RWanAtmSpTdi2NdisSap(
    IN	RWAN_HANDLE					AfSpContext,
    IN	USHORT						TdiAddressType,
    IN	USHORT						TdiAddressLength,
    IN	PVOID						pTdiAddress,
    OUT	PCO_SAP *					ppCoSap
    );

EXTERN
VOID
RWanAtmSpReturnNdisSap(
    IN	RWAN_HANDLE					AfSpContext,
    IN	PCO_SAP						pCoSap
    );

EXTERN
VOID
RWanAtmSpDeregNdisAFComplete(
    IN	RWAN_STATUS					RWanStatus,
    IN	RWAN_HANDLE					AfSpContext
    );

EXTERN
VOID
RWanAtmSpDeregTdiProtoComplete(
    IN	RWAN_STATUS					RWanStatus,
    IN	RWAN_HANDLE					AfSpContext
    );

EXTERN
PATMSP_AF_BLOCK
AtmSpDeviceNumberToAfBlock(
	IN	UINT						DeviceNumber
	);

EXTERN
UINT
AtmSpAfBlockToDeviceNumber(
	IN	PATMSP_AF_BLOCK				pAfBlock
	);

EXTERN
RWAN_STATUS
AtmSpDoAdapterRequest(
    IN	PATMSP_AF_BLOCK				pAfBlock,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    );

EXTERN
RWAN_STATUS
AtmSpDoCallManagerRequest(
    IN	PATMSP_AF_BLOCK				pAfBlock,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    );

EXTERN
ATMSP_SOCKADDR_ATM UNALIGNED *
AtmSpGetSockAtmAddress(
	IN	PVOID						pTdiAddressList,
	IN	ULONG						AddrListLength
	);

EXTERN
VOID
RWanAtmSpAdapterRequestComplete(
    IN	NDIS_STATUS					Status,
    IN	RWAN_HANDLE					AfSpAFContext,
    IN	RWAN_HANDLE					AfSpReqContext,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    );

EXTERN
VOID
RWanAtmSpAfRequestComplete(
    IN	NDIS_STATUS					Status,
    IN	RWAN_HANDLE					AfSpAFContext,
    IN	RWAN_HANDLE					AfSpReqContext,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    );

EXTERN
VOID
RWanAtmSpDeregTdiProtocolComplete(
	IN	RWAN_STATUS					RWanStatus,
	IN	RWAN_HANDLE					AfSpTdiProtocolContext
	);

EXTERN
VOID
AtmSpPrepareDefaultQoS(
    IN	PATMSP_AF_BLOCK				pAfBlock
);

EXTERN
RWAN_STATUS
RWanAtmSpQueryGlobalInfo(
    IN	RWAN_HANDLE					AfSpContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength,
    IN	PVOID						pOutputBuffer,
    IN OUT	PULONG					pOutputBufferLength
    );

EXTERN
RWAN_STATUS
RWanAtmSpSetGlobalInfo(
    IN	RWAN_HANDLE					AfSpContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength
    );

EXTERN
RWAN_STATUS
RWanAtmSpSetAddrInfo(
    IN	RWAN_HANDLE					AfSpAddrContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength
    );

EXTERN
RWAN_STATUS
RWanAtmSpQueryConnInfo(
    IN	RWAN_HANDLE					AfSpConnContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength,
    OUT	PVOID						pOutputBuffer,
    IN OUT PULONG					pOutputBufferLength
    );

#endif // __TDI_ATMSP_EXTERNS__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\tdiconn.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\tdiconn.c

Abstract:

	TDI Entry points and support routines for Connection Objects.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     04-30-97    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'NCDT'


//
//  Private macros and definitions for the Connection Table. Copied from TCP.
//
#define RWAN_GET_SLOT_FROM_CONN_ID(_Id)		((_Id) & 0xffffff)

#define RWAN_GET_INSTANCE_FROM_CONN_ID(_Id)	((UCHAR)((_Id) >> 24))

#define RWAN_MAKE_CONN_ID(_Inst, _Slot)		((((RWAN_CONN_ID)(_Inst)) << 24) | ((RWAN_CONN_ID)(_Slot)))

#define RWAN_INVALID_CONN_ID				RWAN_MAKE_CONN_ID(0xff, 0xffffff)

#define CONN_TABLE_GROW_DELTA				16



TDI_STATUS
RWanTdiOpenConnection(
    IN OUT	PTDI_REQUEST			pTdiRequest,
    IN		PVOID					ConnectionHandle
    )
/*++

Routine Description:

	This is the TDI entry point for opening (creating) a Connection Object.
	We allocate a new Connection object and return an index to it in the
	request itself.

Arguments:

	pTdiRequest		- Pointer to the TDI Request
	ConnectionHandle- This is how we refer to this connection in up-calls

Return Value:

	TDI_SUCCESS if a connection object was successfully created, TDI_XXX
	failure code otherwise.

--*/
{
	TDI_STATUS						Status;
	PRWAN_TDI_CONNECTION				pConnObject;
	RWAN_CONN_ID						ConnId;

	//
	//  Initialize.
	//
	pConnObject = NULL_PRWAN_TDI_CONNECTION;

	do
	{
		pConnObject = RWanAllocateConnObject();

		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			Status = TDI_NO_RESOURCES;
			break;
		}

		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		//
		//  Prepare a context to be returned. We don't return a pointer
		//  to our Connection object as our context, because, seemingly,
		//  there is a chance that we might get invalid connection
		//  contexts in other TDI requests. So we need a way to validate
		//  a received connection context. This indirection (of using a
		//  Connection Index) helps us do so.
		//
		ConnId = RWanGetConnId(pConnObject);

		RWAN_RELEASE_CONN_TABLE_LOCK();

		if (ConnId == RWAN_INVALID_CONN_ID)
		{
			Status = TDI_NO_RESOURCES;
			break;
		}

		RWanReferenceConnObject(pConnObject);	// TdiOpenConnection ref

		pConnObject->ConnectionHandle = ConnectionHandle;

		//
		//  Return our context for this connection object.
		//
		pTdiRequest->Handle.ConnectionContext = (CONNECTION_CONTEXT)UlongToPtr(ConnId);
		Status = TDI_SUCCESS;

		break;
	}
	while (FALSE);

	RWANDEBUGP(DL_EXTRA_LOUD, DC_CONNECT,
			("RWanTdiOpenConnection: pConnObj x%x, Handle x%x, Status x%x\n",
					pConnObject,
					ConnectionHandle,
					Status));

	if (Status != TDI_SUCCESS)
	{
		//
		//  Clean up before returning.
		//
		if (pConnObject != NULL_PRWAN_TDI_CONNECTION)
		{
			RWAN_FREE_MEM(pConnObject);
		}
	}

	return (Status);
}


#if DBG

PVOID
RWanTdiDbgGetConnObject(
	IN	HANDLE						ConnectionContext
	)
/*++

Routine Description:

	DEBUGGING ONLY: Return our internal context for a connection

Arguments:

	ConnectionContext	- TDI context

Return Value:

	Pointer to our Connection structure if found, else NULL.

--*/
{
	PRWAN_TDI_CONNECTION	pConnObject;

	RWAN_ACQUIRE_CONN_TABLE_LOCK();

	pConnObject = RWanGetConnFromId((RWAN_CONN_ID)PtrToUlong(ConnectionContext));

	RWAN_RELEASE_CONN_TABLE_LOCK();

	return ((PVOID)pConnObject);
}

#endif


TDI_STATUS
RWanTdiCloseConnection(
    IN	PTDI_REQUEST				pTdiRequest
    )
/*++

Routine Description:

	This is the TDI entry point to close a Connection Object.
	If the connection object is participating in a connection, we
	initiate teardown. If it is associated with an address object, we
	handle disassociation.

Arguments:

	pTdiRequest		- Pointer to the TDI Request

Return Value:

	TDI_STATUS - this is TDI_PENDING if we started off CloseConnection
	successfully, TDI_SUCCESS if we are done with CloseConnection in here,
	TDI_INVALID_CONNECTION if the connection context is invalid.

--*/
{
	PRWAN_TDI_CONNECTION			pConnObject;
	PRWAN_TDI_ADDRESS				pAddrObject;
	PRWAN_NDIS_VC					pVc;
	TDI_STATUS						Status;
	RWAN_CONN_ID					ConnId;
	PRWAN_CONN_REQUEST				pConnReq;
	NDIS_HANDLE						NdisVcHandle;
	INT								rc;
	BOOLEAN							bIsLockAcquired;
#if DBG
	RWAN_IRQL						EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);

	Status = TDI_PENDING;
	bIsLockAcquired = FALSE;	// Do we hold the Conn Object locked?

	do
	{
		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId(ConnId);

		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			RWAN_RELEASE_CONN_TABLE_LOCK();
			Status = TDI_INVALID_CONNECTION;
			break;
		}

		//
		//  Remove this Connection Object from the Conn Table.
		//  This effectively invalidates this ConnId.
		//
		RWanFreeConnId(ConnId);

		RWAN_RELEASE_CONN_TABLE_LOCK();

		RWANDEBUGP(DL_LOUD, DC_DISCON,
				("TdiCloseConnection: pConnObj x%x, State/Flags/Ref x%x/x%x/%d, pAddrObj x%x\n",
					pConnObject,
					pConnObject->State,
					pConnObject->Flags,
					pConnObject->RefCount,
					pConnObject->pAddrObject));

		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

#if DBG
		pConnObject->OldState = pConnObject->State;
		pConnObject->OldFlags = pConnObject->Flags;
#endif

		//
		//  Mark this Connection Object as closing, and set Delete
		//  Notification info: this will be called when the Connection
		//  is dereferenced to death.
		//
		RWAN_SET_BIT(pConnObject->Flags, RWANF_CO_CLOSING);

		pConnObject->DeleteNotify.pDeleteRtn = pTdiRequest->RequestNotifyObject;
		pConnObject->DeleteNotify.DeleteContext = pTdiRequest->RequestContext;

		//
		//  Discard any pending operation.
		//
		pConnReq = pConnObject->pConnReq;
		if (pConnReq != NULL)
		{
			RWanFreeConnReq(pConnReq);
			pConnObject->pConnReq = NULL;
		}

		//
		//  Remove the TdiOpenConnection reference.
		//
		rc = RWanDereferenceConnObject(pConnObject);	// deref: TdiCloseConn

		if (rc == 0)
		{
			//
			//  The Connection object is gone. CloseConnection completion
			//  would have been called.
			//
			break;
		}

		pAddrObject = pConnObject->pAddrObject;

		//
		//  Force Disassociate Address if associated.
		//
		if (pAddrObject != NULL_PRWAN_TDI_ADDRESS)
		{
			//
			//  Add a temp reference to keep this Conn Object alive while we
			//  reacquire locks in the right order.
			//
			RWanReferenceConnObject(pConnObject);	// temp ref: CloseConn

			RWAN_RELEASE_CONN_LOCK(pConnObject);

			RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);
			RWAN_ACQUIRE_CONN_LOCK_DPC(pConnObject);

			//
			//  Remove from list on Address Object.
			//
			RWAN_DELETE_FROM_LIST(&(pConnObject->ConnLink));

			pConnObject->pAddrObject = NULL_PRWAN_TDI_ADDRESS;

			rc = RWanDereferenceConnObject(pConnObject);	// Force disassoc deref: CloseConn
			RWAN_ASSERT(rc != 0);

			RWAN_RELEASE_CONN_LOCK_DPC(pConnObject);

			rc = RWanDereferenceAddressObject(pAddrObject);	// Force Disassoc: CloseConn

			if (rc != 0)
			{
				RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);
			}

			//
			//  Reacquire ConnObject lock: we still have the temp reference on it.
			//
			RWAN_ACQUIRE_CONN_LOCK(pConnObject);

			rc = RWanDereferenceConnObject(pConnObject);	// remove temp ref: CloseConn

			if (rc == 0)
			{
				RWAN_ASSERT(Status == TDI_PENDING);
				break;
			}
		}

		bIsLockAcquired = TRUE;

		//
		//  If this is a root connection object, abort the connection.
		//
		if (RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_ROOT))
		{
			RWANDEBUGP(DL_FATAL, DC_DISCON,
				("TdiCloseConn: found root Conn Obj x%x\n", pConnObject));

			RWanReferenceConnObject(pConnObject);	// temp ref: CloseConn (root)

			RWAN_RELEASE_CONN_LOCK(pConnObject);

			RWanDoAbortConnection(pConnObject);

			RWAN_ACQUIRE_CONN_LOCK(pConnObject);
			rc = RWanDereferenceConnObject(pConnObject); 	// temp ref: CloseConn (root)

			if (rc == 0)
			{
				bIsLockAcquired = FALSE;
			}

			break;
		}

		//
		//  If the connection is active, tear it down.
		//

		switch (pConnObject->State)
		{
			case RWANS_CO_OUT_CALL_INITIATED:
			case RWANS_CO_DISCON_REQUESTED:
			case RWANS_CO_IN_CALL_ACCEPTING:

				//
				//  An NDIS operation is in progress. When it completes,
				//  the flag (CLOSING) we set earlier will cause the
				//  CloseConnection to continue.
				//
				break;

			case RWANS_CO_CONNECTED:

				RWanDoTdiDisconnect(
					pConnObject,
					NULL,		// pTdiRequest
					NULL,		// pTimeout
					0,			// Flags
					NULL,		// pDisconnInfo
					NULL		// pReturnInfo
					);
				//
				//  ConnObject Lock is released within the above.
				//
				bIsLockAcquired = FALSE;
				break;

			case RWANS_CO_DISCON_INDICATED:
			case RWANS_CO_DISCON_HELD:
			case RWANS_CO_ABORTING:

				//
				//  We would have started off an NDIS CloseCall/DropParty
				//  operation.
				//
				break;

			case RWANS_CO_IN_CALL_INDICATED:

				//
				//  Reject the incoming call.
				//
				RWanNdisRejectIncomingCall(pConnObject, NDIS_STATUS_FAILURE);

				//
				//  ConnObject Lock is released within the above.
				//
				bIsLockAcquired = FALSE;

				break;

			case RWANS_CO_CREATED:
			case RWANS_CO_ASSOCIATED:
			case RWANS_CO_LISTENING:
			default:

				//
				//  We should have broken out of the outer do..while
				//  earlier.
				//
				RWANDEBUGP(DL_FATAL, DC_WILDCARD,
					("TdiCloseConn: pConnObj x%x/x%x, bad state %d\n",
							pConnObject, pConnObject->Flags, pConnObject->State));

				RWAN_ASSERT(FALSE);
				break;

		}

		break;
	}
	while (FALSE);

	if (bIsLockAcquired)
	{
		RWAN_RELEASE_CONN_LOCK(pConnObject);
	}

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	RWANDEBUGP(DL_VERY_LOUD, DC_DISCON,
			("TdiCloseConn: pConnObject x%x, returning x%x\n", pConnObject, Status));

	return (Status);

}



TDI_STATUS
RWanTdiAssociateAddress(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	PVOID						AddressContext
    )
/*++

Routine Description:

	This is the TDI entry point to associate a connection object
	with an address object. The connection object is identified
	by its context buried in the TDI Request, and AddressContext
	is our context for an address object.

Arguments:

	pTdiRequest		- Pointer to the TDI Request
	AddressContext	- Actually a pointer to our TDI Address object.

Return Value:

	TDI_SUCCESS if the association was successful, TDI_ALREADY_ASSOCIATED
	if the connection object is already associated with an address object,
	TDI_INVALID_CONNECTION if the specified connection context is invalid.

--*/
{
	PRWAN_TDI_ADDRESS				pAddrObject;
	PRWAN_TDI_CONNECTION			pConnObject;
	RWAN_CONN_ID					ConnId;
	TDI_STATUS						Status;
	RWAN_STATUS						RWanStatus;

	pAddrObject = (PRWAN_TDI_ADDRESS)AddressContext;
	RWAN_STRUCT_ASSERT(pAddrObject, nta);

	ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);

	do
	{
		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId(ConnId);

		RWAN_RELEASE_CONN_TABLE_LOCK();


		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			Status = TDI_INVALID_CONNECTION;
			break;
		}

		if (pConnObject->pAddrObject != NULL_PRWAN_TDI_ADDRESS)
		{
			Status = TDI_ALREADY_ASSOCIATED;
			break;
		}

		//
		//  Get a context for this associated connection object
		//  from the media-specific module.
		//
		if (pAddrObject->pProtocol->pAfInfo->AfChars.pAfSpAssociateConnection)
		{
			RWanStatus = (*pAddrObject->pProtocol->pAfInfo->AfChars.pAfSpAssociateConnection)(
							pAddrObject->AfSpAddrContext,
							(RWAN_HANDLE)pConnObject,
							&(pConnObject->AfSpConnContext));

			if (RWanStatus != RWAN_STATUS_SUCCESS)
			{
				Status = RWanToTdiStatus(RWanStatus);
				break;
			}

			RWAN_SET_BIT(pConnObject->Flags, RWANF_CO_AFSP_CONTEXT_VALID);

			RWANDEBUGP(DL_LOUD, DC_WILDCARD,
				("Associate: AddrObj %x, ConnObj %x, AfSpAddrCont %x, AfSpConnCont %x\n",
						pAddrObject,
						pConnObject,
						pAddrObject->AfSpAddrContext,
						pConnObject->AfSpConnContext));
		}

		//
		//  Acquire locks in the right order.
		//
		RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

		RWAN_ACQUIRE_CONN_LOCK_DPC(pConnObject);

		RWAN_ASSERT(pConnObject->State == RWANS_CO_CREATED);

		pConnObject->State = RWANS_CO_ASSOCIATED;

		//
		//  Attach this Connection Object to this Address Object.
		//
		pConnObject->pAddrObject = pAddrObject;

		RWAN_INSERT_TAIL_LIST(&(pAddrObject->IdleConnList),
							 &(pConnObject->ConnLink));

		RWanReferenceConnObject(pConnObject);	// Associate ref

		//
		//  Check if this is a Leaf connection object.
		//
		if (RWAN_IS_BIT_SET(pAddrObject->Flags, RWANF_AO_PMP_ROOT))
		{
			RWAN_ASSERT(pAddrObject->pRootConnObject != NULL);

			RWAN_SET_BIT(pConnObject->Flags, RWANF_CO_LEAF);
			pConnObject->pRootConnObject = pAddrObject->pRootConnObject;
		}

		RWAN_RELEASE_CONN_LOCK_DPC(pConnObject);

		RWanReferenceAddressObject(pAddrObject);	// New Connection object associated

		RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

		Status = TDI_SUCCESS;
		break;
	}
	while (FALSE);


	RWANDEBUGP(DL_EXTRA_LOUD, DC_CONNECT,
			("RWanTdiAssociate: pAddrObject x%x, ConnId x%x, pConnObj x%x, Status x%x\n",
				pAddrObject, ConnId, pConnObject, Status));

	return (Status);
}




TDI_STATUS
RWanTdiDisassociateAddress(
    IN	PTDI_REQUEST				pTdiRequest
    )
/*++

Routine Description:

	This is the TDI entry point for disassociating a connection object
	from the address object it is currently associated with. The connection
	object is identified by its handle buried within the TDI request.

Arguments:

	pTdiRequest		- Pointer to the TDI Request

Return Value:

	TDI_SUCCESS if successful, TDI_NOT_ASSOCIATED if the connection object
	isn't associated with an address object, TDI_INVALID_CONNECTION if the
	given connection context is invalid, TDI_CONNECTION_ACTIVE if the
	connection is active.

--*/
{
	PRWAN_TDI_CONNECTION			pConnObject;
	RWAN_CONN_ID					ConnId;
	PRWAN_TDI_ADDRESS				pAddrObject;
	TDI_STATUS						Status;
	INT								rc;

	ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);

	do
	{
		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId(ConnId);

		RWAN_RELEASE_CONN_TABLE_LOCK();

		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			Status = TDI_INVALID_CONNECTION;
			break;
		}

		//
		//  See if the connection is associated.
		//
		pAddrObject = pConnObject->pAddrObject;

		if (pAddrObject == NULL_PRWAN_TDI_ADDRESS)
		{
			Status = TDI_NOT_ASSOCIATED;
			break;
		}

		//
		//  Tell the media-specific module about this disassociation.
		//  This invalidates the module's context for this connection
		//  object.
		//
		if (RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_AFSP_CONTEXT_VALID) &&
			pAddrObject->pProtocol->pAfInfo->AfChars.pAfSpDisassociateConnection)
		{
			(*pAddrObject->pProtocol->pAfInfo->AfChars.pAfSpDisassociateConnection)(
							pConnObject->AfSpConnContext);

			RWAN_RESET_BIT(pConnObject->Flags, RWANF_CO_AFSP_CONTEXT_VALID);
		}

		//
		//  Unlink this from the address object.
		//
		RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

		RWAN_DELETE_FROM_LIST(&(pConnObject->ConnLink));

		rc = RWanDereferenceAddressObject(pAddrObject); // Disassoc conn

		if (rc != 0)
		{
			RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);
		}

		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		pConnObject->pAddrObject = NULL_PRWAN_TDI_ADDRESS;

		rc = RWanDereferenceConnObject(pConnObject);	// Disassoc deref

		if (rc != 0)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
		}

		Status = TDI_SUCCESS;
		break;
	}
	while (FALSE);

	RWANDEBUGP(DL_LOUD, DC_DISCON,
			("RWanTdiDisassociate: pAddrObject x%x, pConnObj x%x, Status x%x\n",
				pAddrObject, pConnObject, Status));

	return (Status);
}




TDI_STATUS
RWanTdiConnect(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	PVOID						pTimeout 		OPTIONAL,
    IN	PTDI_CONNECTION_INFORMATION	pRequestInfo,
    IN	PTDI_CONNECTION_INFORMATION	pReturnInfo
    )
/*++

Routine Description:

	This is the TDI Entry point for setting up a connection.
	The connection object is identified by its handle buried within
	the TDI request.

Arguments:

	pTdiRequest		- Pointer to the TDI Request
	pTimeout		- Optional connect timeout
	pRequestInfo	- Points to information for making the connection
	pReturnInfo		- Place where we return final connection information

Return Value:

	TDI_STATUS - this is TDI_PENDING if we successfully fired off
	a Connect Request, TDI_NO_RESOURCES if we failed because of some
	allocation problem, TDI_BAD_ADDR if the destination address isn't
	valid, TDI_INVALID_CONNECTION if the specified Connection Object
	isn't valid, TDI_NOT_ASSOCIATED if the connection object isn't
	associated with an Address Object.

--*/
{
	PRWAN_TDI_CONNECTION			pConnObject;
	RWAN_CONN_ID					ConnId;
	PRWAN_TDI_ADDRESS				pAddrObject;
	PRWAN_NDIS_AF_CHARS				pAfChars;
	PRWAN_NDIS_AF_INFO				pAfInfo;
	PRWAN_NDIS_AF					pAf;
	PRWAN_NDIS_VC					pVc;
	PRWAN_CONN_REQUEST				pConnReq;
	TDI_STATUS						Status;
	RWAN_STATUS						RWanStatus;

	ULONG							CallFlags;

	PCO_CALL_PARAMETERS				pCallParameters;
	NDIS_HANDLE						NdisVcHandle;
	NDIS_STATUS						NdisStatus;

	BOOLEAN							bIsLockAcquired;
#if DBG
	RWAN_IRQL						EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	//
	//  Initialize
	//
	pConnReq = NULL;
	pCallParameters = NULL;
	bIsLockAcquired = FALSE;
	pVc = NULL;

#if DBG
	pConnObject = NULL;
	pAddrObject = NULL;
#endif

	do
	{
		//
		//  See if the destination address is present.
		//
		if ((pRequestInfo == NULL) ||
			(pRequestInfo->RemoteAddress == NULL))
		{
			Status = TDI_BAD_ADDR;
			break;
		}

		//
		//  Allocate a Connection Request structure to keep track
		//  of this request.
		//
		pConnReq = RWanAllocateConnReq();
		if (pConnReq == NULL)
		{
			Status = TDI_NO_RESOURCES;
			break;
		}

		pConnReq->Request.pReqComplete = pTdiRequest->RequestNotifyObject;
		pConnReq->Request.ReqContext = pTdiRequest->RequestContext;
		pConnReq->pConnInfo = pReturnInfo;

		//
		//  Get the Connection Object.
		//
		ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);

		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId(ConnId);

		RWAN_RELEASE_CONN_TABLE_LOCK();

		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			Status = TDI_INVALID_CONNECTION;
			break;
		}

		bIsLockAcquired = TRUE;
		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		//
		//  See if it is associated.
		//
		pAddrObject = pConnObject->pAddrObject;

		if (pAddrObject == NULL_PRWAN_TDI_ADDRESS)
		{
			Status = TDI_NOT_ASSOCIATED;
			break;
		}

		//
		//  Check its state.
		//
		if (pConnObject->State != RWANS_CO_ASSOCIATED)
		{
			Status = TDI_INVALID_STATE;
			break;
		}

		//
		//  Do we have atleast one NDIS AF for this protocol?
		//
		pAfInfo = pAddrObject->pProtocol->pAfInfo;
		if (RWAN_IS_LIST_EMPTY(&(pAfInfo->NdisAfList)))
		{
			Status = TDI_BAD_ADDR;
			break;
		}

		pAfChars = &(pAfInfo->AfChars);

		CallFlags = RWAN_CALLF_OUTGOING_CALL;

		if (RWAN_IS_BIT_SET(pAddrObject->Flags, RWANF_AO_PMP_ROOT))
		{
			CallFlags |= RWAN_CALLF_POINT_TO_MULTIPOINT;

			pConnObject->pRootConnObject = pAddrObject->pRootConnObject;
			if (pAddrObject->pRootConnObject->NdisConnection.pNdisVc == NULL)
			{
				CallFlags |= RWAN_CALLF_PMP_FIRST_LEAF;
				RWANDEBUGP(DL_INFO, DC_CONNECT,
						("TdiConnect PMP: First Leaf: ConnObj %x, RootConn %x, AddrObj %x\n",
								pConnObject,
								pConnObject->pRootConnObject,
								pAddrObject));
			}
			else
			{
				CallFlags |= RWAN_CALLF_PMP_ADDNL_LEAF;
				RWANDEBUGP(DL_INFO, DC_CONNECT,
						("TdiConnect PMP: Subseq Leaf: ConnObj %x, RootConn %x, AddrObj %x, Vc %x\n",
								pConnObject,
								pConnObject->pRootConnObject,
								pAddrObject,
								pConnObject->pRootConnObject->NdisConnection.pNdisVc
						));
			}
		}
		else
		{
			CallFlags |= RWAN_CALLF_POINT_TO_POINT;
		}

		//
		//  We get the AF from the media specific module.
		//
		pAf = NULL;

		//
		//  Validate and convert call parameters. Also get the AF (aka port) on
		//  which the call should be made.
		//
		RWanStatus = (*pAfChars->pAfSpTdi2NdisOptions)(
							pConnObject->AfSpConnContext,
							CallFlags,
							pRequestInfo,
							pRequestInfo->Options,
							pRequestInfo->OptionsLength,
							&pAf,
							&pCallParameters
							);

		if (RWanStatus != RWAN_STATUS_SUCCESS)
		{
			RWANDEBUGP(DL_WARN, DC_CONNECT,
				("TdiConnect: pConnObj x%x, Tdi2NdisOptions ret x%x\n", pConnObject, RWanStatus));

			Status = RWanToTdiStatus(RWanStatus);
			break;
		}

		if (pAf == NULL)
		{
			//
			//  Get at the first NDIS AF block for this TDI protocol.
			//
			pAf = CONTAINING_RECORD(pAfInfo->NdisAfList.Flink, RWAN_NDIS_AF, AfInfoLink);
		}

		RWAN_ASSERT(pAf != NULL);
		RWAN_STRUCT_ASSERT(pAf, naf);

		RWAN_ASSERT(pCallParameters != NULL);

		if (CallFlags & RWAN_CALLF_POINT_TO_MULTIPOINT)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			bIsLockAcquired = FALSE;

			Status = RWanTdiPMPConnect(
							pAfInfo,
							pAddrObject,
							pConnObject,
							pCallParameters,
							CallFlags,
							pConnReq
							);
			break;
		}

		//
		//  Allocate an NDIS VC. To avoid deadlocks, we must relinquish
		//  the Conn Object lock temporarily.
		//
		RWAN_RELEASE_CONN_LOCK(pConnObject);

		pVc = RWanAllocateVc(pAf, TRUE);

		if (pVc == NULL)
		{
			Status = TDI_NO_RESOURCES;
			bIsLockAcquired = FALSE;
			break;
		}

		RWAN_SET_VC_CALL_PARAMS(pVc, pCallParameters);

		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		RWAN_SET_BIT(pVc->Flags, RWANF_VC_OUTGOING);

		//
		//  We have completed all "immediate failure" checks.
		//

		//
		//  Link the VC to this Connection Object.
		//
		RWAN_LINK_CONNECTION_TO_VC(pConnObject, pVc);

		RWanReferenceConnObject(pConnObject);	// VC ref

		//
		//  Save the Connection Request
		//
		pConnObject->pConnReq = pConnReq;

		//
		//  Save the NDIS Call Parameters
		//
		pVc->pCallParameters = pCallParameters;

		pConnObject->State = RWANS_CO_OUT_CALL_INITIATED;

		RWAN_RELEASE_CONN_LOCK(pConnObject);
		bIsLockAcquired = FALSE;

		//
		//  Move this connection object from the Idle list to the
		//  Active list on the address object.
		//

		RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

		RWAN_DELETE_FROM_LIST(&(pConnObject->ConnLink));
		RWAN_INSERT_TAIL_LIST(&(pAddrObject->ActiveConnList),
							 &(pConnObject->ConnLink));

		pAddrObject->pRootConnObject = pConnObject;

		RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

		NdisVcHandle = pVc->NdisVcHandle;

		//
		//  Place the call.
		//
		NdisStatus = NdisClMakeCall(
						NdisVcHandle,
						pCallParameters,
						NULL,			// ProtocolPartyContext
						NULL			// pNdisPartyHandle
						);

		RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

		if (NdisStatus != NDIS_STATUS_PENDING)
		{
			RWanNdisMakeCallComplete(
						NdisStatus,
						(NDIS_HANDLE)pVc,
						NULL,			// NdisPartyHandle
						pCallParameters
						);
		}

		RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

		Status = TDI_PENDING;
		break;
	}
	while (FALSE);


	if (Status != TDI_PENDING)
	{
		//
		//  Clean up.
		//
		if (bIsLockAcquired)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
		}
			
		if (pConnReq != NULL)
		{
			RWanFreeConnReq(pConnReq);
		}

		if (pCallParameters != NULL)
		{
			(*pAfChars->pAfSpReturnNdisOptions)(
								pAf->AfSpAFContext,
								pCallParameters
								);
		}

		if (pVc != NULL)
		{
			RWanFreeVc(pVc);
		}
	}

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	RWANDEBUGP(DL_LOUD, DC_CONNECT,
		("TdiConnect: pTdiReq x%x, pConnObj x%x, pAddrObj x%x, Status x%x\n",
			pTdiRequest, pConnObject, pAddrObject, Status));

	return (Status);
}


TDI_STATUS
RWanTdiPMPConnect(
	IN	PRWAN_NDIS_AF_INFO			pAfInfo,
	IN	PRWAN_TDI_ADDRESS			pAddrObject,
	IN	PRWAN_TDI_CONNECTION		pConnObject,
	IN	PCO_CALL_PARAMETERS			pCallParameters,
	IN	ULONG						CallFlags,
	IN	PRWAN_CONN_REQUEST			pConnReq
	)
/*++

Routine Description:

	Handle a TDI Connect for a point-to-multipoint call.

Arguments:

	pAfInfo			- Pointer to AF Info structure
	pAddrObject		- Address Object on which this PMP call is made
	pConnObject		- Connection object representing a node of the PMP call
	pCallParameters	- NDIS call parameters
	CallFlags		- Flags indicating type of call
	pConnReq		- Information about the TDI request

Return Value:

	TDI_PENDING if a PMP call was launched successfully, TDI_XXX error code
	otherwise.

--*/
{
	PRWAN_TDI_CONNECTION	pRootConnObject;
	PRWAN_NDIS_AF			pAf;
	PRWAN_NDIS_VC			pVc;
	PRWAN_NDIS_PARTY		pParty;
	NDIS_HANDLE				NdisVcHandle;
	NDIS_STATUS				NdisStatus;
	TDI_STATUS				Status;
	BOOLEAN					bIsFirstLeaf;
#if DBG
	RWAN_IRQL				EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	bIsFirstLeaf = ((CallFlags & RWAN_CALLF_PMP_LEAF_TYPE_MASK) == RWAN_CALLF_PMP_FIRST_LEAF);
	Status = TDI_PENDING;
	pParty = NULL;
	pVc = NULL;
	pRootConnObject = NULL;

	RWANDEBUGP(DL_LOUD, DC_CONNECT,
		("TdiPMPConnect: pAddrObj x%x/x%x, pConnObj x%x/x%x, CallFlags x%x\n",
			pAddrObject, pAddrObject->Flags,
			pConnObject, pConnObject->Flags,
			CallFlags));

	do
	{
		//
		//  Allocate party object.
		//
		RWAN_ALLOC_MEM(pParty, RWAN_NDIS_PARTY, sizeof(RWAN_NDIS_PARTY));

		if (pParty == NULL)
		{
			Status = TDI_NO_RESOURCES;
			break;
		}

		RWAN_ZERO_MEM(pParty, sizeof(RWAN_NDIS_PARTY));
		RWAN_SET_SIGNATURE(pParty, npy);

		//
		//  Get at the root Connection object.
		//
		pRootConnObject = pAddrObject->pRootConnObject;
		RWAN_ASSERT(pRootConnObject != NULL);

		if (bIsFirstLeaf)
		{
			//
			//  Get at the first NDIS AF block for this TDI protocol.
			//
			pAf = CONTAINING_RECORD(pAfInfo->NdisAfList.Flink, RWAN_NDIS_AF, AfInfoLink);

			pVc = RWanAllocateVc(pAf, TRUE);

			if (pVc == NULL)
			{
				Status = TDI_NO_RESOURCES;
				break;
			}

			RWAN_SET_BIT(pVc->Flags, RWANF_VC_OUTGOING);
			RWAN_SET_BIT(pVc->Flags, RWANF_VC_PMP);

			RWAN_SET_VC_CALL_PARAMS(pVc, pCallParameters);

			//
			//  Link the VC to the Root Connection Object.
			//

			RWAN_ACQUIRE_CONN_LOCK(pRootConnObject);

			RWAN_LINK_CONNECTION_TO_VC(pRootConnObject, pVc);

			//
			//  Save pointer to this first party, for use in MakeCallComplete.
			//
			pVc->pPartyMakeCall = pParty;

			RWanReferenceConnObject(pRootConnObject);	// VC ref: TDI Conn PMP

			RWAN_RELEASE_CONN_LOCK(pRootConnObject);
		}
		else
		{
			pVc = pRootConnObject->NdisConnection.pNdisVc;

		}

		//
		//  We have finished all local checks. Fill in more of the Party structure.
		//
		pParty->pVc = pVc;
		pParty->pConnObject = pConnObject;
		pParty->pCallParameters = pCallParameters;

		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		RWanReferenceConnObject(pConnObject);	// Party ref

		pConnObject->State = RWANS_CO_OUT_CALL_INITIATED;

		//
		//  Save the Connection Request
		//
		pConnObject->pConnReq = pConnReq;

		//
		//  Link the Party to this Connection Object.
		//
		RWAN_ASSERT(pConnObject->NdisConnection.pNdisParty == NULL);
		pConnObject->NdisConnection.pNdisParty = pParty;

		RWAN_RELEASE_CONN_LOCK(pConnObject);

		//
		//  Link the Party and VC structures.
		//

		RWAN_ACQUIRE_CONN_LOCK(pRootConnObject);

		RWAN_INSERT_TAIL_LIST(&(pVc->NdisPartyList), &(pParty->PartyLink));

		pVc->AddingPartyCount ++;

		NdisVcHandle = pVc->NdisVcHandle;

		RWAN_RELEASE_CONN_LOCK(pRootConnObject);

		//
		//  Move this connection object from the Idle list to the
		//  Active list on the address object.
		//
		RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

		RWAN_DELETE_FROM_LIST(&(pConnObject->ConnLink));
		RWAN_INSERT_TAIL_LIST(&(pAddrObject->ActiveConnList),
							 &(pConnObject->ConnLink));

		RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);


		RWANDEBUGP(DL_LOUD, DC_CONNECT,
			("RWanTdiPMPConnect: AddrObj x%x, ConnObj x%x, RootConn x%x, VC %x, Pty %x, FirstLeaf %d\n",
					pAddrObject, pConnObject, pRootConnObject, pVc, pParty, bIsFirstLeaf));

		if (bIsFirstLeaf)
		{
			//
			//  Place the call.
			//
			NdisStatus = NdisClMakeCall(
							NdisVcHandle,
							pCallParameters,
							(NDIS_HANDLE)pParty,		// ProtocolPartyContext
							&pParty->NdisPartyHandle	// pNdisPartyHandle
							);

			RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

			if (NdisStatus != NDIS_STATUS_PENDING)
			{
				RWanNdisMakeCallComplete(
							NdisStatus,
							(NDIS_HANDLE)pVc,
							pParty->NdisPartyHandle,			// NdisPartyHandle
							pCallParameters
							);
			}
		}
		else
		{
			//
			//  Add the new party.
			//
			NdisStatus = NdisClAddParty(
							NdisVcHandle,
							(NDIS_HANDLE)pParty,
							pCallParameters,
							&pParty->NdisPartyHandle
							);
			
			if (NdisStatus != NDIS_STATUS_PENDING)
			{
				RWanNdisAddPartyComplete(
							NdisStatus,
							(NDIS_HANDLE)pParty,
							pParty->NdisPartyHandle,
							pCallParameters
							);
			}
		}
	
		RWAN_ASSERT(Status == TDI_PENDING);

		break;
	}
	while (FALSE);


	if (Status != TDI_PENDING)
	{
		//
		//  Failure - clean up.
		//
		RWAN_ASSERT(Status == TDI_NO_RESOURCES);

		if (pParty != NULL)
		{
			RWAN_FREE_MEM(pParty);
		}
			
		if (pVc != NULL)
		{
			RWanFreeVc(pVc);
		}
	}

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	return (Status);
}


TDI_STATUS
RWanTdiListen(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	USHORT						Flags,
    IN	PTDI_CONNECTION_INFORMATION	pAcceptableAddr,
    IN	PTDI_CONNECTION_INFORMATION	pConnectedAddr
    )
/*++

Routine Description:

	This is the TDI Entry point for posting a Listen. The Connection
	Object is identified by its context buried within the TDI request.
	We save off information about this request, and move the connection
	from the idle list to the listen list.

	For now, we ignore any given remote address information.
	TBD: Support remote address information in TdiListen().

Arguments:

	pTdiRequest		- Pointer to the TDI Request
	Flags			- Listen flags
	pAcceptableAddr	- List of acceptable remote addresses
	pConnectedAddr	- Place to return connected remote address

Return Value:

	TDI_STATUS - this is TDI_PENDING if we successfully queued a Listen,
	TDI_NO_RESOURCES if we ran into a resource failure, TDI_NOT_ASSOCIATED
	if the given Connection object isn't associated with an address,
	TDI_INVALID_CONNECTION if the specified connection object is invalid.

--*/
{
	PRWAN_TDI_CONNECTION			pConnObject;
	RWAN_CONN_ID					ConnId;
	PRWAN_TDI_ADDRESS				pAddrObject;
	PRWAN_CONN_REQUEST				pConnReq;
	TDI_STATUS						Status;
#if DBG
	RWAN_IRQL						EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	//
	//  Initialize
	//
	pConnReq = NULL;

	do
	{
		//
		//  XXX: Ignore Acceptable address(es) for now.
		//

		//
		//  Allocate a Connection Request structure to keep track
		//  of this request.
		//
		pConnReq = RWanAllocateConnReq();
		if (pConnReq == NULL)
		{
			Status = TDI_NO_RESOURCES;
			break;
		}

		pConnReq->Request.pReqComplete = pTdiRequest->RequestNotifyObject;
		pConnReq->Request.ReqContext = pTdiRequest->RequestContext;
		pConnReq->pConnInfo = pConnectedAddr;
		pConnReq->Flags = Flags;

		//
		//  Get the Connection Object.
		//

		ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);

		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId(ConnId);

		RWAN_RELEASE_CONN_TABLE_LOCK();

		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			Status = TDI_INVALID_CONNECTION;
			break;
		}


		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		//
		//  See if it is associated.
		//
		pAddrObject = pConnObject->pAddrObject;

		if (pAddrObject == NULL)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			Status = TDI_NOT_ASSOCIATED;
			break;
		}

		//
		//  We can move this Connection Object to the listen list
		//  only if there isn't any active connection on this.
		//
		if (pConnObject->State != RWANS_CO_ASSOCIATED)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			Status = TDI_INVALID_STATE;
			break;
		}

		pConnObject->State = RWANS_CO_LISTENING;

		//
		//  Save the Connection Request
		//
		pConnObject->pConnReq = pConnReq;

		RWAN_RELEASE_CONN_LOCK(pConnObject);


		RWANDEBUGP(DL_VERY_LOUD, DC_BIND,
				("Listen: pConnObject x%x, pAddrObject x%x\n", pConnObject, pAddrObject));

		//
		//  Move this connection object from the Idle list to the
		//  Listen list.
		//
		RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

		RWAN_DELETE_FROM_LIST(&(pConnObject->ConnLink));
		RWAN_INSERT_TAIL_LIST(&(pAddrObject->ListenConnList),
							 &(pConnObject->ConnLink));

		RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

		Status = TDI_PENDING;
		break;
	}
	while (FALSE);

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	if (Status != TDI_PENDING)
	{
		//
		//  Cleanup
		//
		if (pConnReq != NULL)
		{
			RWanFreeConnReq(pConnReq);
		}
	}

	return (Status);

}




TDI_STATUS
RWanTdiUnListen(
    IN	PTDI_REQUEST				pTdiRequest
    )
/*++

Routine Description:

	This is the TDI Entry point for terminating a Listen. The Connection
	Object is identified by its context buried within the TDI request.
	We move the connection from the listen list to the idle list.

Arguments:

	pTdiRequest		- Pointer to the TDI Request

Return Value:

	TDI_SUCCESS if successful.

--*/
{
	PRWAN_TDI_CONNECTION			pConnObject;
	PRWAN_CONN_REQUEST				pConnReq;
	RWAN_CONN_ID					ConnId;
	PRWAN_TDI_ADDRESS				pAddrObject;
	TDI_STATUS						Status;
#if DBG
	RWAN_IRQL						EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	do
	{
		//
		//  Get the Connection Object.
		//

		ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);

		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId(ConnId);

		RWAN_RELEASE_CONN_TABLE_LOCK();

		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			Status = TDI_INVALID_CONNECTION;
			break;
		}

		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		//
		//  See if it is associated.
		//
		pAddrObject = pConnObject->pAddrObject;

		if (pAddrObject == NULL)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			Status = TDI_NOT_ASSOCIATED;
			break;
		}

		//
		//  We can move this Connection Object to the idle list
		//  only if there isn't any active connection on this.
		//
		if (pConnObject->State != RWANS_CO_LISTENING)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			Status = TDI_INVALID_STATE;
			break;
		}

		pConnObject->State = RWANS_CO_ASSOCIATED;

		pConnReq = pConnObject->pConnReq;
		pConnObject->pConnReq = NULL;

		RWAN_RELEASE_CONN_LOCK(pConnObject);


		RWANDEBUGP(DL_VERY_LOUD, DC_BIND,
				("UnListen: pConnObject x%x, pAddrObject x%x\n", pConnObject, pAddrObject));

		//
		//  Move this connection object from the Listen list to the
		//  Idle list.
		//
		RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

		RWAN_DELETE_FROM_LIST(&(pConnObject->ConnLink));
		RWAN_INSERT_TAIL_LIST(&(pAddrObject->IdleConnList),
							 &(pConnObject->ConnLink));

		RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

		RWanCompleteConnReq(		// InCall: Listen OK
					NULL,
					pConnReq,
					FALSE,
					NULL,
					NULL,
					TDI_CANCELLED
					);

		Status = TDI_SUCCESS;
		break;
	}
	while (FALSE);

	return (Status);
}




TDI_STATUS
RWanTdiAccept(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	PTDI_CONNECTION_INFORMATION	pAcceptInfo,
    IN	PTDI_CONNECTION_INFORMATION	pConnectInfo
    )
/*++

Routine Description:

	This is the TDI entry point for accepting an incoming connection.
	The Connection Object is identified by its context buried within
	the TDI request.

	We translate this to a call to NdisClIncomingCallComplete, and
	pend this request. If all goes well, this request is completed
	when we receive a CallConnected primitive from NDIS.

Arguments:

	pTdiRequest		- Pointer to the TDI Request
	pAcceptInfo		- Contains options for the connection accept
	pConnectInfo	- Place to return final connection information

Return Value:

	TDI_STATUS - this is TDI_PENDING if we successfully processed
	the Accept, TDI_INVALID_CONNECTION if the given Connection Object
	isn't valid, TDI_NOT_ASSOCIATED if the connection object isn't
	associated with an address object.

--*/
{
	PRWAN_TDI_CONNECTION			pConnObject;
	PRWAN_NDIS_VC					pVc;
	RWAN_CONN_ID					ConnId;
	PRWAN_TDI_ADDRESS				pAddrObject;
	PRWAN_CONN_REQUEST				pConnReq;
	PRWAN_NDIS_AF_CHARS				pAfChars;
	TDI_STATUS						Status;
	NDIS_HANDLE						NdisVcHandle;
	PCO_CALL_PARAMETERS				pCallParameters;

	BOOLEAN							bIsLockAcquired;	// Have we locked the Conn Object?

	//
	//  Initialize
	//
	pConnReq = NULL;
	bIsLockAcquired = FALSE;

	do
	{
		//
		//  XXX: Ignore Acceptable address(es) for now.
		//

		//
		//  Allocate a Connection Request structure to keep track
		//  of this request.
		//
		pConnReq = RWanAllocateConnReq();
		if (pConnReq == NULL)
		{
			Status = TDI_NO_RESOURCES;
			break;
		}

		pConnReq->Request.pReqComplete = pTdiRequest->RequestNotifyObject;
		pConnReq->Request.ReqContext = pTdiRequest->RequestContext;
		pConnReq->pConnInfo = pConnectInfo;

		//
		//  Copy from Accept Info to Connect Info.
		//
		if ((pAcceptInfo != NULL) &&
			(pAcceptInfo->Options != NULL) &&
			(pConnectInfo != NULL) &&
			(pConnectInfo->Options != NULL) &&
			(pConnectInfo->OptionsLength >= pAcceptInfo->OptionsLength))
		{
			RWAN_COPY_MEM(pConnectInfo->Options,
						 pAcceptInfo->Options,
						 pAcceptInfo->OptionsLength);
		}

		//
		//  Get the Connection Object.
		//
		ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);

		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId(ConnId);

		RWAN_RELEASE_CONN_TABLE_LOCK();

		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			Status = TDI_INVALID_CONNECTION;
			break;
		}

		bIsLockAcquired = TRUE;
		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		//
		//  Make sure that the Connection is in the right state.
		//
		if (pConnObject->State != RWANS_CO_IN_CALL_INDICATED)
		{
			Status = TDI_INVALID_STATE;
			break;
		}

		pVc = pConnObject->NdisConnection.pNdisVc;

		if (pVc == NULL)
		{
			Status = TDI_INVALID_CONNECTION;
			break;
		}

		pCallParameters = pVc->pCallParameters;
		pVc->pCallParameters = NULL;

		//
		//  Update NDIS Call Parameters if Accept Options are present.
		//
		pAfChars = &(pVc->pNdisAf->pAfInfo->AfChars);

		if (pAfChars->pAfSpUpdateNdisOptions)
		{
			RWAN_STATUS			RWanStatus;
			ULONG				CallFlags = RWAN_CALLF_INCOMING_CALL|RWAN_CALLF_POINT_TO_POINT;
			PVOID				pTdiQoS;
			ULONG				TdiQoSLength;

			if (pAcceptInfo)
			{
				pTdiQoS = pAcceptInfo->Options;
				TdiQoSLength = pAcceptInfo->OptionsLength;
			}
			else
			{
				pTdiQoS = NULL;
				TdiQoSLength = 0;
			}

			RWanStatus = (*pAfChars->pAfSpUpdateNdisOptions)(
								pVc->pNdisAf->AfSpAFContext,
								pConnObject->AfSpConnContext,
								CallFlags,
								pAcceptInfo,
								pTdiQoS,
								TdiQoSLength,
								&pCallParameters
								);

			if (RWanStatus != RWAN_STATUS_SUCCESS)
			{
				Status = RWanToTdiStatus(RWanStatus);
				break;
			}
		}

		NdisVcHandle = pVc->NdisVcHandle;

		//
		//  Update Connection Object state.
		//
		pConnObject->State = RWANS_CO_IN_CALL_ACCEPTING;

		//
		//  Save the Connection Request
		//
		pConnObject->pConnReq = pConnReq;

		RWAN_RELEASE_CONN_LOCK(pConnObject);

		//
		//  Accept the call now.
		//
		NdisClIncomingCallComplete(
				NDIS_STATUS_SUCCESS,
				NdisVcHandle,
				pCallParameters
				);

		Status = TDI_PENDING;
		break;
	}
	while (FALSE);

	if (Status != TDI_PENDING)
	{
		//
		//  Cleanup
		//
		if (bIsLockAcquired)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
		}

		if (pConnReq != NULL)
		{
			RWanFreeConnReq(pConnReq);
		}
	}

	return (Status);

}




TDI_STATUS
RWanTdiDisconnect(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	PVOID						pTimeout,
    IN	USHORT						Flags,
    IN	PTDI_CONNECTION_INFORMATION	pDisconnInfo,
    OUT	PTDI_CONNECTION_INFORMATION	pReturnInfo
    )
/*++

Routine Description:

	This is the TDI Disconnect entry point. If this is an incoming
	call waiting to be accepted, we call NdisClIncomingCallComplete
	with a rejection status. Otherwise, we call NdisClCloseCall.

	The Connection Object is identified by its context buried within
	the TDI request.

	Note that this is never called for point-to-multipoint calls.
	Those are disconnected within TdiCloseConnection.

Arguments:

	pTdiRequest		- Pointer to the TDI Request
	pTimeout		- Points to timeout. Ignored.
	Flags			- Type of disconnect. Only Abortive is supported for now.
	pDisconnInfo	- Information for the disconnect. Ignored for now.
	pReturnInfo		- Return information about the disconnect. Ignored for now.

Return Value:

	TDI_STATUS - this is TDI_SUCCESS if we just rejected an incoming
	call, TDI_PENDING if we initiated NDIS CloseCall, TDI_INVALID_CONNECTION
	if the Connection Object context is invalid,

--*/
{
	PRWAN_TDI_CONNECTION			pConnObject;
	RWAN_CONN_ID					ConnId;
	TDI_STATUS						Status;

	do
	{
		//
		//  Get the Connection Object.
		//
		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);
		pConnObject = RWanGetConnFromId(ConnId);

		RWAN_RELEASE_CONN_TABLE_LOCK();

		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			Status = TDI_INVALID_CONNECTION;
			break;
		}

		RWANDEBUGP(DL_LOUD, DC_DISCON,
				("RWanTdiDiscon: pConnObj x%x, State/Flags x%x/x%x, pAddrObj x%x\n",
					pConnObject,
					pConnObject->State,
					pConnObject->Flags,
					pConnObject->pAddrObject));

		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		//
		//  Make sure that the Connection is in the right state for TdiDisconnect.
		//
		if ((pConnObject->State != RWANS_CO_CONNECTED) &&
			(pConnObject->State != RWANS_CO_DISCON_INDICATED) &&
			(pConnObject->State != RWANS_CO_IN_CALL_INDICATED) &&
			(pConnObject->State != RWANS_CO_IN_CALL_ACCEPTING) &&
			(pConnObject->State != RWANS_CO_OUT_CALL_INITIATED) &&
			(pConnObject->State != RWANS_CO_DISCON_HELD))
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);

			RWANDEBUGP(DL_INFO, DC_DISCON,
					("RWanTdiDiscon: pConnObj x%x/x%x, bad state x%x for TdiDiscon\n",
						pConnObject,
						pConnObject->Flags,
						pConnObject->State));

			Status = TDI_INVALID_STATE;
			break;
		}

		if ((pConnObject->State == RWANS_CO_DISCON_INDICATED) ||
			(pConnObject->State == RWANS_CO_DISCON_HELD))
		{
			//
			//  We would have initiated an NDIS CloseCall/DropParty already.
			//  Simply succeed this TDI Disconnect.
			//

			RWAN_RELEASE_CONN_LOCK(pConnObject);

			RWANDEBUGP(DL_INFO, DC_DISCON,
					("RWanTdiDiscon: pConnObj x%x/x%x, Discon recvd state %d\n",
						pConnObject,
						pConnObject->Flags,
						pConnObject->State));

			Status = TDI_SUCCESS;
			break;
		}

		Status = RWanDoTdiDisconnect(
					pConnObject,
					pTdiRequest,
					pTimeout,
					Flags,
					pDisconnInfo,
					pReturnInfo);

		//
		//  Conn Object lock is released within the above.
		//
		break;
	}
	while (FALSE);


	return (Status);
}



TDI_STATUS
RWanDoTdiDisconnect(
    IN	PRWAN_TDI_CONNECTION		pConnObject,
    IN	PTDI_REQUEST				pTdiRequest		OPTIONAL,
    IN	PVOID						pTimeout		OPTIONAL,
    IN	USHORT						Flags,
    IN	PTDI_CONNECTION_INFORMATION	pDisconnInfo	OPTIONAL,
    OUT	PTDI_CONNECTION_INFORMATION	pReturnInfo		OPTIONAL
	)
/*++

Routine Description:

	Perform a TDI Disconnect on the connection endpoint.
	Separated out from the main TdiDisconnect routine
	so that it can be reused by TdiCloseConnection.

	NOTE: This is called with the connection object lock held. This
	lock is released here.

Arguments:

	pConnObject		- Represents the TDI Connection being disconnected.
	pTdiRequest		- Pointer to the TDI Request.
	pTimeout		- Points to timeout. Ignored.
	Flags			- Type of disconnect. Only Abortive is supported for now.
	pDisconnInfo	- Information for the disconnect. Ignored for now.
	pReturnInfo		- Return information about the disconnect. Ignored for now.

Return Value:

	TDI_STATUS - this is TDI_SUCCESS if we just rejected an incoming
	call, TDI_PENDING if we initiated NDIS CloseCall or DropParty.

--*/
{
	TDI_STATUS						Status;
	INT								rc;
	PRWAN_NDIS_VC					pVc;
	PRWAN_NDIS_PARTY				pParty;
	PRWAN_CONN_REQUEST				pConnReq;
	PCO_CALL_PARAMETERS				pCallParameters;
	NDIS_STATUS						NdisStatus;
	NDIS_HANDLE						NdisPartyHandle;
	BOOLEAN							bIncomingCall;
	BOOLEAN							bIsPMPRoot;
	BOOLEAN							bIsLastLeaf;
	RWAN_HANDLE						AfSpConnContext;

	UNREFERENCED_PARAMETER(pTimeout);
	UNREFERENCED_PARAMETER(Flags);
	UNREFERENCED_PARAMETER(pDisconnInfo);
	UNREFERENCED_PARAMETER(pReturnInfo);

	//
	//  Initialize
	//
	pConnReq = NULL;
	Status = TDI_SUCCESS;

	do
	{
		bIsPMPRoot = (pConnObject->pRootConnObject != NULL);

		if (bIsPMPRoot)
		{
			pVc = pConnObject->pRootConnObject->NdisConnection.pNdisVc;

			if (pVc == NULL)
			{
				//
				//  Can happen if DoAbort has run on this connection.
				//  Bail out.
				//
				RWANDEBUGP(DL_INFO, DC_WILDCARD,
					("DoTdiDiscon(Root): pConnObj %p/%x: VC is null, bailing out\n",
							pConnObject, pConnObject->Flags));

				RWAN_RELEASE_CONN_LOCK(pConnObject);
				break;
			}

			RWAN_STRUCT_ASSERT(pVc, nvc);
			RWAN_ASSERT(pVc->AddingPartyCount + pVc->ActivePartyCount > 0);

			bIsLastLeaf = ((pVc->AddingPartyCount + pVc->ActivePartyCount) == 1);

			pParty = pConnObject->NdisConnection.pNdisParty;

			RWAN_ASSERT(pParty != NULL);
			RWAN_STRUCT_ASSERT(pParty, npy);

			if (RWAN_IS_BIT_SET(pParty->Flags, RWANF_PARTY_DROPPING))
			{
				RWANDEBUGP(DL_FATAL, DC_DISCON,
					("DoTdiDiscon (Root): pConnObj x%x, Party x%x already dropping\n",
						pConnObject, pParty));
				RWAN_RELEASE_CONN_LOCK(pConnObject);
				break;
			}

			NdisPartyHandle = pParty->NdisPartyHandle;

			RWANDEBUGP(DL_VERY_LOUD, DC_DISCON,
				("DoTdiDiscon (Root): pConnObj x%x, pVc x%x, pParty x%x, Adding %d, Active %d\n",
						pConnObject,
						pVc,
						pParty,
						pVc->AddingPartyCount,
						pVc->ActivePartyCount));
		}
		else
		{
			pVc = pConnObject->NdisConnection.pNdisVc;
			if (pVc == NULL)
			{
				//
				//  Can happen if DoAbort has run on this connection.
				//  Bail out.
				//
				RWANDEBUGP(DL_INFO, DC_WILDCARD,
					("DoTdiDiscon: pConnObj %p/%x: VC is null, bailing out\n",
							pConnObject, pConnObject->Flags));

				RWAN_RELEASE_CONN_LOCK(pConnObject);
				break;
			}

			RWAN_STRUCT_ASSERT(pVc, nvc);

			//
			//  Set last-leaf to TRUE to simplify processing later.
			//
			bIsLastLeaf = TRUE;
		}

		RWAN_ASSERT(pVc != NULL);

		//
		//  If an outgoing call is in progress, we complete the
		//  pended TDI_CONNECT with a cancel status, mark this
		//  Connection Object as Disconnecting and exit. When the
		//  outgoing call completes, we will clear it if it was
		//  successful.
		//

		if (pConnObject->State == RWANS_CO_OUT_CALL_INITIATED)
		{
			pConnObject->State = RWANS_CO_DISCON_REQUESTED;

			//
			//  Take out the pending TDI_CONNECT.
			//
			pConnReq = pConnObject->pConnReq;
			RWAN_ASSERT(pConnReq != NULL);

			pConnObject->pConnReq = NULL;

			AfSpConnContext = pConnObject->AfSpConnContext;

			RWAN_RELEASE_CONN_LOCK(pConnObject);

			//
			//  Complete the TDI_CONNECT with a cancelled status.
			//
			RWanCompleteConnReq(
					pVc->pNdisAf,
					pConnReq,
					TRUE,			// Is an outgoing call
					NULL,			// No call params
					AfSpConnContext,
					TDI_CANCELLED
					);
			
			//
			//  We will succeed this TDI_DISCONNECT.
			//
			pConnReq = NULL;
			Status = TDI_SUCCESS;
			break;
		}


		//
		//  If this connection is in the process of being accepted,
		//  then complete the pending TDI_ACCEPT with a cancel
		//  status and reject the incoming call.
		//
		if (pConnObject->State == RWANS_CO_IN_CALL_ACCEPTING)
		{
			RWANDEBUGP(DL_FATAL, DC_DISCON,
				("DoTdiDiscon: ConnObj %x/%x, in call accepting, VC %x\n",
						pConnObject,
						pConnObject->Flags,
						pVc));

			//
			//  Take out the pending TDI_CONNECT.
			//
			pConnReq = pConnObject->pConnReq;
			RWAN_ASSERT(pConnReq != NULL);

			pConnObject->pConnReq = NULL;

			AfSpConnContext = pConnObject->AfSpConnContext;

			RWAN_RELEASE_CONN_LOCK(pConnObject);

			//
			//  Complete the TDI_ACCEPT with a cancelled status.
			//
			RWanCompleteConnReq(
					pVc->pNdisAf,
					pConnReq,
					FALSE,			// Is an incoming call
					NULL,			// No call params
					AfSpConnContext,
					TDI_CANCELLED
					);

			//
			//  We will succeed this TDI_DISCONNECT.
			//
			pConnReq = NULL;
			Status = TDI_SUCCESS;
			break;
		}

#if DBG
		if (pConnObject->pConnReq != NULL)
		{
			RWANDEBUGP(DL_FATAL, DC_WILDCARD,
				("DoTdiDiscon: pConnObj %x/%x, State %x, non-NULL ConnReq %x\n",
						pConnObject, pConnObject->Flags, pConnObject->State,
						pConnObject->pConnReq));
		}
#endif // DBG

		RWAN_ASSERT(pConnObject->pConnReq == NULL);
		if (pTdiRequest != NULL)
		{
			//
			//  Allocate a Connection Request structure to keep track
			//  of this Disconnect request.
			//
			pConnReq = RWanAllocateConnReq();
			if (pConnReq == NULL)
			{
				RWAN_RELEASE_CONN_LOCK(pConnObject);
				Status = TDI_NO_RESOURCES;
				break;
			}

			pConnReq->Request.pReqComplete = pTdiRequest->RequestNotifyObject;
			pConnReq->Request.ReqContext = pTdiRequest->RequestContext;
			pConnReq->pConnInfo = NULL;
			pConnReq->Flags = 0;

			//
			//  Save info about the TDI Disconnect request.
			//
			pConnObject->pConnReq = pConnReq;
		}
		else
		{
			pConnReq = NULL;
		}

		bIncomingCall = (pConnObject->State == RWANS_CO_IN_CALL_INDICATED);

		if (bIncomingCall)
		{
			pCallParameters = pVc->pCallParameters;
			pVc->pCallParameters = NULL;
		}

		pConnObject->State = RWANS_CO_DISCON_REQUESTED;

		if (bIncomingCall)
		{
			//
			//  Reject the incoming call.
			//
			RWanNdisRejectIncomingCall(pConnObject, NDIS_STATUS_FAILURE);
		}
		else
		{
			//
			//  Closing an existing call.
			//  TBD: we don't support Close data yet.
			//
			if (bIsLastLeaf)
			{
				RWanStartCloseCall(pConnObject, pVc);

				//
				//  ConnObject lock is released within the above.
				//
			}
			else
			{
				pVc->DroppingPartyCount ++;	// DoTdiDiscon: not last leaf (DropParty)
				pVc->ActivePartyCount --;	// DoTdiDiscon: will DropParty

				RWAN_ASSERT(pParty != NULL);
				RWAN_STRUCT_ASSERT(pParty, npy);

				RWAN_SET_BIT(pParty->Flags, RWANF_PARTY_DROPPING);

				RWAN_RELEASE_CONN_LOCK(pConnObject);

				//
				//  Dropping a leaf of a PMP call.
				//
				NdisStatus = NdisClDropParty(
								NdisPartyHandle,
								NULL,		// No Drop data
								0			// Length of drop data
								);

				if (NdisStatus != NDIS_STATUS_PENDING)
				{
					RWanNdisDropPartyComplete(
								NdisStatus,
								(NDIS_HANDLE)pParty
								);
				}
			}
		}

		Status = TDI_PENDING;
		break;
	}
	while (FALSE);


	if (Status != TDI_PENDING)
	{
		//
		//  Cleanup.
		//
		if (pConnReq)
		{
			RWanFreeConnReq(pConnReq);
		}
	}

	return (Status);

}



RWAN_CONN_ID
RWanGetConnId(
	IN	PRWAN_TDI_CONNECTION			pConnObject
	)
/*++

Routine Description:

	Get a free Connection ID to assign to the Connection Object.
	This Connection ID is used as our context for the Connection
	object.

	It is assumed that the caller holds a lock to the Connection Table.

	Validation scheme courtesy TCP source.

Arguments:

	pConnObject		- Pointer to the TDI Connection Object

Return Value:

	RWAN_CONN_ID: this is RWAN_INVALID_CONN_ID iff we cannot allocate
	a Connection Id.

--*/
{
	ULONG			Slot;
	ULONG			i;
	BOOLEAN			bFound;
	RWAN_CONN_ID	ConnId;

	for (;;)
	{
		//
		//  Look for a free slot in the Connection Index table.
		//  Start from where we left off the last time we were called.
		//
		Slot = pRWanGlobal->NextConnIndex;

		for (i = 0; i < pRWanGlobal->ConnTableSize; i++)
		{
			if (Slot == pRWanGlobal->ConnTableSize)
			{
				Slot = 0;	// wrap around
			}

			if (pRWanGlobal->pConnTable[Slot] == NULL)
			{
				// Found free slot
				break;
			}

			++Slot;
		}

		if (i < pRWanGlobal->ConnTableSize)
		{
			bFound = TRUE;
			break;
		}

		//
		//  Grow the Connection Index table, if we can.
		//
		if (pRWanGlobal->ConnTableSize != pRWanGlobal->MaxConnections)
		{
			ULONG						NewTableSize;
			PRWAN_TDI_CONNECTION *		pNewConnTable;
			PRWAN_TDI_CONNECTION *		pOldConnTable;

			NewTableSize = MIN(pRWanGlobal->ConnTableSize + CONN_TABLE_GROW_DELTA,
								pRWanGlobal->MaxConnections);

			RWAN_ALLOC_MEM(pNewConnTable,
						  PRWAN_TDI_CONNECTION,
						  NewTableSize * sizeof(PRWAN_TDI_CONNECTION));

			if (pNewConnTable != NULL)
			{
				RWAN_ZERO_MEM(pNewConnTable, NewTableSize * sizeof(PRWAN_TDI_CONNECTION));

				pOldConnTable = pRWanGlobal->pConnTable;
				pRWanGlobal->pConnTable = pNewConnTable;

				if (pOldConnTable != NULL)
				{
					//
					//  Copy in the contents of the old table.
					//
					RWAN_COPY_MEM(pNewConnTable,
								 pOldConnTable,
								 pRWanGlobal->ConnTableSize * sizeof(PRWAN_TDI_CONNECTION));

					RWAN_FREE_MEM(pOldConnTable);
				}

				pRWanGlobal->ConnTableSize = NewTableSize;

				//
				//  Continue search.
				//
			}
			else
			{
				//
				//  Resource failure.
				//
				bFound = FALSE;
				break;
			}
		}
		else
		{
			//
			//  ConnTable is full, and we aren't permitted to grow it any further.
			//
			bFound = FALSE;
			break;
		}
	}

	if (bFound)
	{
		//
		//  Use the slot that we found.
		//
		pRWanGlobal->pConnTable[Slot] = pConnObject;
		pRWanGlobal->NextConnIndex = Slot + 1;

		//
		//  Assign an instance value for this. This is used to validate
		//  a given ConnId.
		//
		pRWanGlobal->ConnInstance++;
		pConnObject->ConnInstance = pRWanGlobal->ConnInstance;

		ConnId = RWAN_MAKE_CONN_ID(pConnObject->ConnInstance, Slot);
	}
	else
	{
		ConnId = RWAN_INVALID_CONN_ID;
	}

	return (ConnId);
}




PRWAN_TDI_CONNECTION
RWanGetConnFromId(
	IN	RWAN_CONN_ID					ConnId
	)
/*++

Routine Description:

	Given a Connection ID, validate it. If found OK, return a pointer
	to the TDI Connection that it represents.

	It is assumed that the caller holds a lock to the Connection Table.

	Validation scheme courtesy TCP source.

Arguments:

	ConnId			- Connection Id.

Return Value:

	PRWAN_TDI_CONNECTION - pointer to a TDI Connection structure that
	matches the given ConnId, if valid. Otherwise, NULL.

--*/
{
	ULONG					Slot;
	RWAN_CONN_INSTANCE		ConnInstance;
	PRWAN_TDI_CONNECTION	pConnObject;

	Slot = RWAN_GET_SLOT_FROM_CONN_ID(ConnId);

	if (Slot < pRWanGlobal->ConnTableSize)
	{
		pConnObject = pRWanGlobal->pConnTable[Slot];
		if (pConnObject != NULL_PRWAN_TDI_CONNECTION)
		{
			RWAN_STRUCT_ASSERT(pConnObject, ntc);
			ConnInstance = RWAN_GET_INSTANCE_FROM_CONN_ID(ConnId);
			if (pConnObject->ConnInstance != ConnInstance)
			{
				pConnObject = NULL_PRWAN_TDI_CONNECTION;
			}
		}
	}
	else
	{
		pConnObject = NULL_PRWAN_TDI_CONNECTION;
	}

	return (pConnObject);
}




VOID
RWanFreeConnId(
	IN	RWAN_CONN_ID					ConnId
	)
/*++

Routine Description:

	Free a Connection ID.

Arguments:

	ConnId		- ID to be freed.

Return Value:

	None

--*/
{
	ULONG					Slot;

	Slot = RWAN_GET_SLOT_FROM_CONN_ID(ConnId);

	RWAN_ASSERT(Slot < pRWanGlobal->ConnTableSize);

	pRWanGlobal->pConnTable[Slot] = NULL;

	return;
}




TDI_STATUS
RWanToTdiStatus(
	IN	RWAN_STATUS					RWanStatus
	)
/*++

Routine Description:

	Map the given local status code to an equivalent TDI status code.

Arguments:

	RWanStatus		- Local status code

Return Value:

	TDI Status code.

--*/
{
	TDI_STATUS		TdiStatus;

	switch (RWanStatus)
	{
		case RWAN_STATUS_SUCCESS:
				TdiStatus = TDI_SUCCESS;
				break;
		case RWAN_STATUS_BAD_ADDRESS:
				TdiStatus = TDI_BAD_ADDR;
				break;
		case RWAN_STATUS_BAD_PARAMETER:
				TdiStatus = TDI_INVALID_PARAMETER;
				break;
		case RWAN_STATUS_MISSING_PARAMETER:
				TdiStatus = TDI_INVALID_PARAMETER;
				break;
		case RWAN_STATUS_FAILURE:
		default:
				TdiStatus = TDI_INVALID_STATE;	// XXX: find a better one?
				break;
	}

	return (TdiStatus);
}



PRWAN_CONN_REQUEST
RWanAllocateConnReq(
	VOID
	)
/*++

Routine Description:

	Allocate a structure to hold context about a TDI Connection Request.
	This includes TDI_CONNECT, TDI_DISCONNECT, TDI_LISTEN and TDI_ACCEPT.

Arguments:

	None

Return Value:

	Pointer to allocate structure if successful, else NULL.

--*/
{
	PRWAN_CONN_REQUEST		pConnReq;

	RWAN_ALLOC_MEM(pConnReq, RWAN_CONN_REQUEST, sizeof(RWAN_CONN_REQUEST));

	if (pConnReq != NULL)
	{
		RWAN_SET_SIGNATURE(pConnReq, nrc);
	}

	return (pConnReq);
}




VOID
RWanFreeConnReq(
	IN	PRWAN_CONN_REQUEST			pConnReq
	)
/*++

Routine Description:

	Free a connect request context structure.

Arguments:

	pConnReq		- Points to structure to be freed.

Return Value:

	None

--*/
{
	RWAN_STRUCT_ASSERT(pConnReq, nrc);

	RWAN_FREE_MEM(pConnReq);
}



VOID
RWanAbortConnection(
	IN	CONNECTION_CONTEXT			ConnectionContext
	)
/*++

Routine Description:

	Abortively closes a connection and issues a Disconnect Indication
	to the user. This is called when a send or receive is cancelled,
	implying that an NDIS connection is in place.

Arguments:

	ConnectionContext- Our context for a TDI Connection object.

Return Value:

	None

--*/
{
	RWAN_CONN_ID						ConnId;
	PRWAN_TDI_CONNECTION				pConnObject;

	ConnId = (RWAN_CONN_ID)PtrToUlong(ConnectionContext);

	RWAN_ACQUIRE_CONN_TABLE_LOCK();

	pConnObject = RWanGetConnFromId(ConnId);

	RWAN_RELEASE_CONN_TABLE_LOCK();

	RWanDoAbortConnection(pConnObject);
}




VOID
RWanDoAbortConnection(
	IN	PRWAN_TDI_CONNECTION			pConnObject
	)
/*++

Routine Description:

	Does the actual connection abort. Split out from RWanAbortConnection
	just so that this can be called from elsewhere.

	See comments under RWanAbortConnection.

Arguments:

	pConnObject	- Points to TDI Connection to be aborted.

Return Value:

	None

--*/
{
	PRWAN_NDIS_VC					pVc;
	PRWAN_NDIS_PARTY				pParty;
	PRWAN_TDI_CONNECTION			pLeafConnObject;
	INT								rc;
	BOOLEAN							bIsLockReleased = TRUE;
	ULONG							OldState;
	ULONG							OldLeafState;
	PLIST_ENTRY						pPartyEntry;
	PLIST_ENTRY						pNextPartyEntry;

	RWANDEBUGP(DL_INFO, DC_DISCON,
			("DoAbortConnection: pConnObject x%x/%x, pAddrObject x%x\n",
				pConnObject, (pConnObject? pConnObject->Flags: 0), (pConnObject? pConnObject->pAddrObject: 0)));

	do
	{
		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			break;
		}

		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		//
		//  Make sure we don't do this more than once on a Connection.
		//
		if (pConnObject->State == RWANS_CO_ABORTING)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			break;
		}

		//
		//  Make sure the Conn Object doesn't go away during the time we
		//  need it.
		//
		RWanReferenceConnObject(pConnObject);	// temp ref: RWanAbortConnection

		OldState = pConnObject->State;
		pConnObject->State = RWANS_CO_ABORTING;

		if (RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_ROOT))
		{
			bIsLockReleased = FALSE;

			//
			//  This is a Root Connection object.
			//  Indicate disconnect and schedule Closing each leaf.
			//
			pVc = pConnObject->NdisConnection.pNdisVc;

			if (pVc != NULL)
			{
				for (pPartyEntry = pVc->NdisPartyList.Flink;
					 pPartyEntry != &(pVc->NdisPartyList);
					 pPartyEntry = pNextPartyEntry)
				{
					pParty = CONTAINING_RECORD(pPartyEntry, RWAN_NDIS_PARTY, PartyLink);
					pNextPartyEntry = pParty->PartyLink.Flink;

					pLeafConnObject = pParty->pConnObject;
					RWAN_ASSERT(pLeafConnObject);
					RWAN_STRUCT_ASSERT(pLeafConnObject, ntc);

					RWAN_ACQUIRE_CONN_LOCK(pLeafConnObject);

					if (pLeafConnObject->State == RWANS_CO_ABORTING)
					{
						RWAN_RELEASE_CONN_LOCK(pLeafConnObject);
						continue;
					}
		
#if DBG
					pLeafConnObject->OldState = pLeafConnObject->State;
					pLeafConnObject->OldFlags = pLeafConnObject->Flags;
#endif // DBG
					OldLeafState = pLeafConnObject->State;
					pLeafConnObject->State = RWANS_CO_ABORTING;

					if ((OldLeafState == RWANS_CO_CONNECTED) &&
						(pLeafConnObject->pAddrObject != NULL_PRWAN_TDI_ADDRESS))
					{
						PDisconnectEvent			pDisconInd;
						PVOID						IndContext;
						PVOID						ConnectionHandle;
	
						pDisconInd = pLeafConnObject->pAddrObject->pDisconInd;
						IndContext = pLeafConnObject->pAddrObject->DisconIndContext;
	
						if (pDisconInd != NULL)
						{
							pLeafConnObject->State = RWANS_CO_DISCON_INDICATED;
							ConnectionHandle = pLeafConnObject->ConnectionHandle;
	
							RWAN_RELEASE_CONN_LOCK(pLeafConnObject);
							RWAN_RELEASE_CONN_LOCK(pConnObject);
	
							RWANDEBUGP(DL_FATAL, DC_DISCON,
								("DoAbort[Leaf]: will indicate Discon, pConnObj x%x, pAddrObj x%x\n",
									pLeafConnObject, pLeafConnObject->pAddrObject));
	
							(*pDisconInd)(
								IndContext,
								ConnectionHandle,
								0,			// Disconnect Data Length
								NULL,		// Disconnect Data
								0,			// Disconnect Info Length
								NULL,		// Disconnect Info
								TDI_DISCONNECT_ABORT
								);
	
							RWAN_ACQUIRE_CONN_LOCK(pConnObject);
							RWAN_ACQUIRE_CONN_LOCK(pLeafConnObject);
						}
					}
		
					RWanScheduleDisconnect(pLeafConnObject);
					//
					//  Leaf Conn Object lock is freed within the above.
					//
				}
				//
				//  end For all parties
				//
			}
			//
			//  else Root Conn object has no associated VC.
			//
			rc = RWanDereferenceConnObject(pConnObject);	// temp ref: RWanAbortConnection
			if (rc == 0)
			{
				bIsLockReleased = TRUE;
				break;	// The Conn Object has been deref'ed away.
			}
		}
		else
		{
			//
			//  Not PMP connection.
			//
			pVc = pConnObject->NdisConnection.pNdisVc;

//	157217: this prevents CoSendComplete for pended packets from
//  continuing on to do StartCloseCall.
//			RWAN_UNLINK_CONNECTION_AND_VC(pConnObject, pVc);

			//
			//  First, initiate a network call close.
			//
			RWanStartCloseCall(pConnObject, pVc);

			//
			//  The lock is freed within the above. Reacquire it.
			//
			bIsLockReleased = FALSE;

			RWAN_ACQUIRE_CONN_LOCK(pConnObject);
	
			rc = RWanDereferenceConnObject(pConnObject);	// temp ref: RWanAbortConnection

			if (rc == 0)
			{
				bIsLockReleased = TRUE;
				break;	// The Conn Object has been deref'ed away.
			}

			//
			//  Now, indicate a disconnect to the user, if required & possible.
			//
			if ((OldState == RWANS_CO_CONNECTED) &&
				(pConnObject->pAddrObject != NULL_PRWAN_TDI_ADDRESS))
			{
				PDisconnectEvent			pDisconInd;
				PVOID						IndContext;
				PVOID						ConnectionHandle;

				pDisconInd = pConnObject->pAddrObject->pDisconInd;
				IndContext = pConnObject->pAddrObject->DisconIndContext;

				if (pDisconInd != NULL)
				{
					ConnectionHandle = pConnObject->ConnectionHandle;

					RWAN_RELEASE_CONN_LOCK(pConnObject);

					(*pDisconInd)(
						IndContext,
						ConnectionHandle,
						0,			// Disconnect Data Length
						NULL,		// Disconnect Data
						0,			// Disconnect Info Length
						NULL,		// Disconnect Info
						TDI_DISCONNECT_ABORT
						);

					bIsLockReleased = TRUE;
				}
			}

		}

		if (!bIsLockReleased)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
		}

		break;
	}
	while (FALSE);


	return;
}



VOID
RWanScheduleDisconnect(
	IN	PRWAN_TDI_CONNECTION			pConnObject
	)
/*++

Routine Description:

	Schedule a call to RWanDoTdiDisconnect on the specified connection
	object, as a work item.

	NOTE: The Connection object is locked by the caller.

Arguments:

	pConnObject	- Points to TDI Connection to be aborted.

Return Value:

	None

--*/
{
	NDIS_STATUS			Status;

	RWANDEBUGP(DL_LOUD, DC_DISCON,
		("ScheduleDiscon: pConnObj x%x/x%x, state %d\n",
			pConnObject, pConnObject->Flags, pConnObject->State));

	do
	{
		//
		//  Check if we've already done this.
		//
		if (RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSE_SCHEDULED))
		{
			break;
		}

		RWAN_SET_BIT(pConnObject->Flags, RWANF_CO_CLOSE_SCHEDULED);

		//
		//  Make sure the connection doesn't go away till the
		//  work item is handled.
		//
		RWanReferenceConnObject(pConnObject);	// Schedule Discon ref

		NdisInitializeWorkItem(
			&pConnObject->CloseWorkItem,
			RWanDelayedDisconnectHandler,
			(PVOID)pConnObject);
		
		Status = NdisScheduleWorkItem(&pConnObject->CloseWorkItem);

		RWAN_ASSERT(Status == NDIS_STATUS_SUCCESS);
	}
	while (FALSE);

	RWAN_RELEASE_CONN_LOCK(pConnObject);

	return;
}




VOID
RWanDelayedDisconnectHandler(
	IN	PNDIS_WORK_ITEM					pCloseWorkItem,
	IN	PVOID							Context
	)
/*++

Routine Description:

	Work item routine to initiate a connection teardown.

Arguments:

	pCloseWorkItem	- Points to work item structure embedded in the
					  Connection object.
	Context			- Actually a pointer to the Connection object.

Return Value:

	None

--*/
{
	PRWAN_TDI_CONNECTION	pConnObject;
	ULONG					rc;

	pConnObject = (PRWAN_TDI_CONNECTION)Context;
	RWAN_STRUCT_ASSERT(pConnObject, ntc);

	RWANDEBUGP(DL_LOUD, DC_DISCON,
		("DelayedDiscon handler: pConnObj x%x/x%x, state %d\n",
			pConnObject, pConnObject->Flags, pConnObject->State));

	do
	{
		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		rc = RWanDereferenceConnObject(pConnObject);	// Delayed (scheduled) Discon deref

		if (rc == 0)
		{
			//
			//  The Conn Object is gone.
			//
			break;
		}

		//
		//  Do the Disconnect now.
		//
		RWanDoTdiDisconnect(
			pConnObject,
			NULL,		// pTdiRequest
			NULL,		// pTimeout
			0,			// Flags
			NULL,		// pDisconnInfo
			NULL		// pReturnInfo
			);
		
		//
		//  Conn object lock is released within the above.
		//
		break;
	}
	while (FALSE);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\tdi\macros.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    D:\nt\private\ntos\tdi\rawwan\atm\macros.h

Abstract:

	Macros for the ATM-Specific Raw WAN module.

Revision History:

    Who         When        What
    --------    --------    ----
    arvindm     06-18-97    created

Notes:


--*/
#ifndef __ATMSP_MACROS_H_INCLUDED
#define __ATMSP_MACROS_H_INCLUDED




#define ATMSP_SET_FLAG(Flags, Mask, Val)	\
			(Flags) = ((Flags) & ~(Mask)) | (Val)

#define ATMSP_IS_FLAG_SET(Flags, Mask, Val)	\
			(((Flags) & (Mask)) == (Val))

#define ATMSP_SET_BIT(_Flags, _Bit)			\
			(_Flags) = (_Flags) | (_Bit);

#define ATMSP_RESET_BIT(_Flags, _Bit)			\
			(_Flags) &= ~(_Bit);

#define ATMSP_IS_BIT_SET(_Flags, _Bit)		\
			(((_Flags) & (_Bit)) != 0)


/*++
VOID
ATMSP_INIT_EVENT_STRUCT(
	IN	ATMSP_EVENT	*pEvent
)
--*/
#define ATMSP_INIT_EVENT_STRUCT(pEvent)		NdisInitializeEvent(&((pEvent)->Event))


/*++
NDIS_STATUS
ATMSP_WAIT_ON_EVENT_STRUCT(
	IN	ATMSP_EVENT	*pEvent
)
--*/
#define ATMSP_WAIT_ON_EVENT_STRUCT(pEvent)		\
			(NdisWaitEvent(&((pEvent)->Event), 0), (pEvent)->Status)


/*++
VOID
ATMSP_SIGNAL_EVENT_STRUCT(
	IN	ATMSP_EVENT	*pEvent,
	IN	UINT			Status
)
--*/
#define ATMSP_SIGNAL_EVENT_STRUCT(pEvent, _Status)	\
			{ (pEvent)->Status = _Status; NdisSetEvent(&((pEvent)->Event)); }



/*++
VOID
ATMSP_ALLOC_MEM(
	IN	POPAQUE		pVar,
	IN	OPAQUE		StructureType,
	IN	ULONG		SizeOfStructure
)
--*/
#if DBG
extern
PVOID
RWanAuditAllocMem(
	PVOID			pPointer,
	ULONG			Size,
	ULONG			FileNumber,
	ULONG			LineNumber
);

#define ATMSP_ALLOC_MEM(pVar, StructureType, SizeOfStructure)	\
			pVar = (StructureType *)RWanAuditAllocMem(				\
										(PVOID)(&(pVar)),			\
										(ULONG)(SizeOfStructure),	\
										_FILENUMBER,				\
										__LINE__					\
									);
#else
#define ATMSP_ALLOC_MEM(pVar, StructureType, SizeOfStructure)	\
			NdisAllocateMemoryWithTag((PVOID *)(&pVar), (ULONG)(SizeOfStructure), (ULONG)'naWR');
#endif // DBG


/*++
VOID
ATMSP_FREE_MEM(
	IN	POPAQUE		pMem
)
--*/
#if DBG
extern VOID RWanAuditFreeMem(PVOID	Pointer);

#define ATMSP_FREE_MEM(pMem)	RWanAuditFreeMem((PVOID)(pMem));
#else
#define ATMSP_FREE_MEM(pMem)	NdisFreeMemory((PVOID)(pMem), 0, 0);
#endif // DBG


#define ATMSP_SET_MEM(pMem, bValue, NumberOfBytes)	\
			RtlFillMemory((PVOID)(pMem), (ULONG)(NumberOfBytes), (UCHAR)(bValue));


#define ATMSP_ZERO_MEM(pMem, NumberOfBytes)	\
			RtlZeroMemory((PVOID)pMem, (ULONG)(NumberOfBytes));


#define ATMSP_COPY_MEM(pDst, pSrc, NumberOfBytes)	\
			NdisMoveMemory((PVOID)(pDst), (PVOID)(pSrc), NumberOfBytes);


#define ATMSP_EQUAL_MEM(_pMem1, _pMem2, _Length)	\
			(RtlCompareMemory((PVOID)(_pMem1), (PVOID)(_pMem2), (ULONG)(_Length)) == (_Length))



//
//  Spinlock macros.
//
#define ATMSP_INIT_LOCK(_pLock)		NdisAllocateSpinLock(_pLock)
#define ATMSP_ACQUIRE_LOCK(_pLock)	NdisAcquireSpinLock(_pLock)
#define ATMSP_RELEASE_LOCK(_pLock)	NdisReleaseSpinLock(_pLock)
#define ATMSP_FREE_LOCK(_pLock)		NdisFreeSpinLock(_pLock)

//
//  Doubly linked list manipulation definitions and macros.
//
#define ATMSP_INIT_LIST(_pListHead)					\
			InitializeListHead(_pListHead)

#define ATMSP_IS_LIST_EMPTY(_pListHead)				\
			IsListEmpty(_pListHead)

#define ATMSP_INSERT_HEAD_LIST(_pListHead, _pEntry)	\
			InsertHeadList((_pListHead), (_pEntry))

#define ATMSP_INSERT_TAIL_LIST(_pListHead, _pEntry)	\
			InsertTailList((_pListHead), (_pEntry))

#define ATMSP_DELETE_FROM_LIST(_pEntry)				\
			RemoveEntryList(_pEntry)


#define ATMSP_BLLI_PRESENT(_pBlli)		\
			( (((_pBlli)->Layer2Protocol != SAP_FIELD_ABSENT) &&	\
			   ((_pBlli)->Layer2Protocol != SAP_FIELD_ANY))			\
					 ||												\
			  (((_pBlli)->Layer3Protocol != SAP_FIELD_ABSENT) && 	\
			   ((_pBlli)->Layer3Protocol != SAP_FIELD_ANY))		\
			)


#define ATMSP_BHLI_PRESENT(_pBhli)		\
			(((_pBhli)->HighLayerInfoType != SAP_FIELD_ABSENT) &&	\
			 ((_pBhli)->HighLayerInfoType != SAP_FIELD_ANY))

/*++
ULONG
ROUND_UP(
	IN	ULONG	Val
)
Round up a value so that it becomes a multiple of 4.
--*/
#define ROUND_UP(Val)	(((Val) + 3) & ~0x3)



#if DBG

#define ATMSP_ASSERT(exp)	\
		{																\
			if (!(exp))													\
			{															\
				DbgPrint("NulT: assert " #exp " failed in file %s, line %d\n", __FILE__, __LINE__);	\
				DbgBreakPoint();										\
			}															\
		}

#else

#define ATMSP_ASSERT(exp)		// Nothing

#endif // DBG

#endif // __ATMSP_MACROS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\sys\utils.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\utils.c

Abstract:


Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     05-07-97    Created

Notes:

--*/

#include <precomp.h>


#define _FILENUMBER 'LITU'


RWAN_STATUS
RWanInitGlobals(
	IN	PDRIVER_OBJECT				pDriverObject
	)
/*++

Routine Description:

	Initialize global data structures.

Arguments:

	pDriverObject	- Points to our driver object, from DriverEntry.

Return Value:

	RWAN_STATUS_SUCCESS if initialized successfully, else an appropriate
	error code.

--*/
{
	RWAN_STATUS			RWanStatus;

	pRWanGlobal = &RWanGlobals;

	RWAN_ZERO_MEM(pRWanGlobal, sizeof(RWanGlobals));

	RWAN_SET_SIGNATURE(pRWanGlobal, nlg);
	RWAN_INIT_LIST(&pRWanGlobal->AfInfoList);
	RWAN_INIT_LIST(&pRWanGlobal->ProtocolList);
	RWAN_INIT_LIST(&pRWanGlobal->AdapterList);
	RWAN_INIT_GLOBAL_LOCK();
	RWAN_INIT_ADDRESS_LIST_LOCK();
	RWAN_INIT_CONN_TABLE_LOCK();

	RWAN_INIT_EVENT_STRUCT(&pRWanGlobal->Event);

	pRWanGlobal->MaxConnections = RWanMaxTdiConnections;

#ifdef NT
	pRWanGlobal->pDriverObject = pDriverObject;
	RWAN_INIT_LIST(&pRWanGlobal->DeviceObjList);
#endif // NT

	RWanStatus = RWanInitReceive();

	if (RWanStatus == RWAN_STATUS_SUCCESS)
	{
		RWanStatus = RWanInitSend();

		if (RWanStatus != RWAN_STATUS_SUCCESS)
		{
			RWanShutdownReceive();
		}
	}

	return (RWanStatus);
}




VOID
RWanDeinitGlobals(
	VOID
	)
/*++

Routine Description:

	The flip of RWanInitGlobals.

Arguments:

	None

Return Value:

	None

--*/
{
	RWAN_FREE_EVENT_STRUCT(&pRWanGlobal->Event);
	RWAN_FREE_GLOBAL_LOCK();

	if (pRWanGlobal->pConnTable != NULL)
	{
		RWAN_FREE_MEM(pRWanGlobal->pConnTable);
		pRWanGlobal->pConnTable = NULL;
	}

	RWanShutdownReceive();
	RWanShutdownSend();
}




PRWAN_TDI_PROTOCOL
RWanGetProtocolFromNumber(
	IN	UINT						Protocol
	)
/*++

Routine Description:

	Return the TDI Protocol info block that represents the given
	TDI protocol number.

Arguments:

	Protocol		- The TDI protocol number

Return Value:

	Pointer to TDI Protocol block if found, else NULL.

--*/
{
	PLIST_ENTRY			pAfInfoEntry;
	PRWAN_NDIS_AF_INFO	pAfInfo;

	PLIST_ENTRY			pProtocolEntry;
	PRWAN_TDI_PROTOCOL	pProtocol;
	BOOLEAN				bFound = FALSE;

	RWAN_ACQUIRE_GLOBAL_LOCK();

	for (pAfInfoEntry = pRWanGlobal->AfInfoList.Flink;
		 pAfInfoEntry != &(pRWanGlobal->AfInfoList);
		 pAfInfoEntry = pAfInfoEntry->Flink)
	{
		pAfInfo = CONTAINING_RECORD(pAfInfoEntry, RWAN_NDIS_AF_INFO, AfInfoLink);

		for (pProtocolEntry = pAfInfo->TdiProtocolList.Flink;
			 pProtocolEntry != &(pAfInfo->TdiProtocolList);
			 pProtocolEntry = pProtocolEntry->Flink)
		{

			pProtocol = CONTAINING_RECORD(pProtocolEntry, RWAN_TDI_PROTOCOL, AfInfoLink);

			if (pProtocol->TdiProtocol == Protocol)
			{
				bFound = TRUE;
				break;
			}
		}

		if (bFound)
		{
			break;
		}
	}

	RWAN_RELEASE_GLOBAL_LOCK();

	if (!bFound)
	{
		pProtocol = NULL;
	}

	return (pProtocol);
}




TA_ADDRESS *
RWanGetValidAddressFromList(
	IN	TRANSPORT_ADDRESS UNALIGNED *pAddrList,
	IN	PRWAN_TDI_PROTOCOL			pProtocol
	)
/*++

Routine Description:

	Go through the given transport address list, and return the first
	valid protocol address that we find.

	Valid address: one that matches the address type and length for
	the specified TDI protocol.

Arguments:

	pAddrList		- Points to list of addresses
	pProtocol		- Points to TDI Protocol block

Return Value:

	Pointer to the first valid address in the list if found, else NULL.

--*/
{
	INT						i;
	TA_ADDRESS *	        pAddr;

	pAddr = (TA_ADDRESS *)pAddrList->Address;

	for (i = 0; i < pAddrList->TAAddressCount; i++)
	{
		if ((pAddr->AddressType == pProtocol->SockAddressFamily) &&
			(pAddr->AddressLength >= pProtocol->MaxAddrLength))
		{
			return (pAddr);
		}

		pAddr = (TA_ADDRESS *)
					((PUCHAR)(pAddr->Address) + pAddr->AddressLength);
	}

	return (NULL);
}



PRWAN_TDI_CONNECTION
RWanAllocateConnObject(
	VOID
	)
/*++

Routine Description:

	Allocate a TDI Connection object.

Arguments:

	None

Return Value:

	Pointer to allocated Connection Object, or NULL.

--*/
{
	PRWAN_TDI_CONNECTION		pConnObject;

	RWAN_ALLOC_MEM(pConnObject, RWAN_TDI_CONNECTION, sizeof(RWAN_TDI_CONNECTION));

	if (pConnObject != NULL)
	{
		RWAN_ZERO_MEM(pConnObject, sizeof(RWAN_TDI_CONNECTION));

		RWAN_SET_SIGNATURE(pConnObject, ntc);

		RWAN_INIT_LOCK(&(pConnObject->Lock));
#if DBG
		pConnObject->ntcd_sig = ' gbD';
#endif
	}

	return (pConnObject);
}




VOID
RWanReferenceConnObject(
	IN	PRWAN_TDI_CONNECTION			pConnObject
	)
/*++

Routine Description:

	Add a reference to the specified Connection Object.

Arguments:

	pConnObject		- Pointer to the TDI Connection Object.

Locks on Entry:

	pConnObject

Locks on Exit:

	pConnObject

Return Value:

	None

--*/
{
	RWAN_STRUCT_ASSERT(pConnObject, ntc);
	pConnObject->RefCount++;
}




INT
RWanDereferenceConnObject(
	IN	PRWAN_TDI_CONNECTION			pConnObject
	)
/*++

Routine Description:

	Dereference the specified Connection Object. If the reference
	count goes down to 0, free it.

Arguments:

	pConnObject		- Pointer to the TDI Connection Object.

Locks on Entry:

	pConnObject

Locks on Exit:

	pConnObject, iff it hasn't been freed.

Return Value:

	INT - The resulting reference count.

--*/
{
	INT						RefCount;
	RWAN_DELETE_NOTIFY		DeleteNotify;

	RWAN_STRUCT_ASSERT(pConnObject, ntc);

	RefCount = --pConnObject->RefCount;

	if (RefCount == 0)
	{
		DeleteNotify = pConnObject->DeleteNotify;

		RWAN_RELEASE_CONN_LOCK(pConnObject);

		RWANDEBUGP(DL_EXTRA_LOUD, DC_UTIL,
				("Derefed away: pConnObj x%x, Notify x%x\n",
					pConnObject, DeleteNotify.pDeleteRtn));

		if (DeleteNotify.pDeleteRtn)
		{
			(*DeleteNotify.pDeleteRtn)(DeleteNotify.DeleteContext, TDI_SUCCESS, 0);
		}

		RWAN_FREE_MEM(pConnObject);
	}

	return (RefCount);
}




PRWAN_TDI_ADDRESS
RWanAllocateAddressObject(
	IN	TA_ADDRESS *		        pTransportAddress
	)
/*++

Routine Description:

	Allocate a TDI Address object.

Arguments:

	pTransportAddress	- Points to transport address for which this
						  Address Object is our context.

Return Value:

	Pointer to allocated Address Object, or NULL.

--*/
{
	PRWAN_TDI_ADDRESS		pAddrObject;
	ULONG					Size;
	NDIS_STATUS				Status;

	Size = sizeof(RWAN_TDI_ADDRESS) +
		   pTransportAddress->AddressLength;

	RWAN_ALLOC_MEM(pAddrObject, RWAN_TDI_ADDRESS, Size);

	if (pAddrObject != NULL)
	{
		RWAN_ZERO_MEM(pAddrObject, Size);

		RWAN_SET_SIGNATURE(pAddrObject, nta);

		RWAN_INIT_LOCK(&(pAddrObject->Lock));

		Status = NDIS_STATUS_SUCCESS;

		try
		{
			pAddrObject->AddressType = pTransportAddress->AddressType;
			pAddrObject->AddressLength = pTransportAddress->AddressLength;
			pAddrObject->pAddress = (PVOID)((PUCHAR)pAddrObject + sizeof(RWAN_TDI_ADDRESS));

			RWAN_COPY_MEM(pAddrObject->pAddress,
 						pTransportAddress->Address,
 						pTransportAddress->AddressLength);
 		}
 		except (EXCEPTION_EXECUTE_HANDLER)
 		{
 			Status = NDIS_STATUS_FAILURE;
 		}

 		if (Status != NDIS_STATUS_SUCCESS)
 		{
 			RWAN_FREE_MEM(pAddrObject);
 			pAddrObject = NULL;
 		}
 		else
 		{
			RWAN_INIT_LIST(&pAddrObject->IdleConnList);
			RWAN_INIT_LIST(&pAddrObject->ListenConnList);
			RWAN_INIT_LIST(&pAddrObject->ActiveConnList);
			RWAN_INIT_LIST(&pAddrObject->SapList);

			RWAN_INIT_EVENT_STRUCT(&pAddrObject->Event);
		}

	}

	return (pAddrObject);
}




VOID
RWanReferenceAddressObject(
	IN	PRWAN_TDI_ADDRESS			pAddrObject
	)
/*++

Routine Description:

	Add a reference to the specified Address Object.

Arguments:

	pAddrObject		- Pointer to the TDI Address Object.

Locks on Entry:

	pAddrObject

Locks on Exit:

	pAddrObject

Return Value:

	None

--*/
{
	RWAN_STRUCT_ASSERT(pAddrObject, nta);
	pAddrObject->RefCount++;
}




INT
RWanDereferenceAddressObject(
	IN	PRWAN_TDI_ADDRESS			pAddrObject
	)
/*++

Routine Description:

	Dereference the specified Address Object. If the reference
	count goes down to 0, free it.

Arguments:

	pAddrObject		- Pointer to the TDI Address Object.

Locks on Entry:

	pAddrObject

Locks on Exit:

	pAddrObject, iff it hasn't been freed.

Return Value:

	INT - The resulting reference count.

--*/
{
	INT						RefCount;
	RWAN_DELETE_NOTIFY		DeleteNotify;

	RWAN_STRUCT_ASSERT(pAddrObject, nta);

	RefCount = --pAddrObject->RefCount;

	if (RefCount == 0)
	{
		RWAN_ASSERT(RWAN_IS_LIST_EMPTY(&pAddrObject->IdleConnList));
		RWAN_ASSERT(RWAN_IS_LIST_EMPTY(&pAddrObject->ActiveConnList));
		RWAN_ASSERT(RWAN_IS_LIST_EMPTY(&pAddrObject->ListenConnList));
		RWAN_ASSERT(RWAN_IS_LIST_EMPTY(&pAddrObject->SapList));

		DeleteNotify = pAddrObject->DeleteNotify;

		RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

		RWANDEBUGP(DL_EXTRA_LOUD, DC_UTIL,
				("Derefed away: pAddrObj x%x, Notify x%x\n",
					pAddrObject, DeleteNotify.pDeleteRtn));

		if (DeleteNotify.pDeleteRtn)
		{
			(*DeleteNotify.pDeleteRtn)(DeleteNotify.DeleteContext, (UINT)TDI_ADDR_DELETED, 0);
		}

		RWAN_FREE_MEM(pAddrObject);
	}

	return (RefCount);
}



PRWAN_NDIS_AF
RWanAllocateAf(
	VOID
	)
/*++

Routine Description:

	Allocate an NDIS AF block.

Arguments:

	None

Return Value:

	Pointer to allocated NDIS AF Block, or NULL.

--*/
{
	PRWAN_NDIS_AF		pAf;

	RWAN_ALLOC_MEM(pAf, RWAN_NDIS_AF, sizeof(RWAN_NDIS_AF));

	if (pAf != NULL)
	{
		RWAN_ZERO_MEM(pAf, sizeof(RWAN_NDIS_AF));

		RWAN_SET_SIGNATURE(pAf, naf);

		RWAN_INIT_LOCK(&(pAf->Lock));
		RWAN_INIT_LIST(&(pAf->NdisVcList));
		RWAN_INIT_LIST(&(pAf->NdisSapList));
	}

	RWANDEBUGP(DL_WARN, DC_WILDCARD,
		("Allocated AF x%x\n", pAf));

	return (pAf);
}




VOID
RWanReferenceAf(
	IN	PRWAN_NDIS_AF			pAf
	)
/*++

Routine Description:

	Add a reference to the specified NDIS AF Block.

Arguments:

	pAf		- Pointer to the NDIS AF Block.

Locks on Entry:

	pAf

Locks on Exit:

	pAf

Return Value:

	None

--*/
{
	RWAN_STRUCT_ASSERT(pAf, naf);
	pAf->RefCount++;
}




INT
RWanDereferenceAf(
	IN	PRWAN_NDIS_AF			pAf
	)
/*++

Routine Description:

	Dereference the specified NDIS AF Block. If the reference
	count goes down to 0, free it. Some additional work if
	freeing this: unlink from the adapter, and check if the
	adapter is unbinding.

Arguments:

	pAf		- Pointer to the NDIS AF Block.

Locks on Entry:

	pAf

Locks on Exit:

	pAf, iff it hasn't been freed.

Return Value:

	INT - The resulting reference count.

--*/
{
	INT						RefCount;
	RWAN_DELETE_NOTIFY		DeleteNotify;
	PRWAN_NDIS_ADAPTER		pAdapter;

	RWAN_STRUCT_ASSERT(pAf, naf);

	RefCount = --pAf->RefCount;

	if (RefCount == 0)
	{
		DeleteNotify = pAf->DeleteNotify;

		pAdapter = pAf->pAdapter;

		RWAN_RELEASE_AF_LOCK(pAf);

		RWAN_ACQUIRE_GLOBAL_LOCK();

		//
		//  Unlink from list of AF opens for this NDIS AF
		//
		RWAN_DELETE_FROM_LIST(&(pAf->AfInfoLink));

		RWAN_RELEASE_GLOBAL_LOCK();


		RWAN_ACQUIRE_ADAPTER_LOCK(pAdapter);

		//
		//  Unlink from list of AF opens on this adapter.
		//

		if (RWAN_IS_BIT_SET(pAf->Flags, RWANF_AF_IN_ADAPTER_LIST))
		{
			RWAN_DELETE_FROM_LIST(&(pAf->AfLink));
		}

		//
		//  See if we just deleted the last AF on this adapter, and
		//  we are in the process of unbinding from this adapter.
		//
		if (RWAN_IS_LIST_EMPTY(&pAdapter->AfList) &&
			RWAN_IS_BIT_SET(pAdapter->Flags, RWANF_AD_UNBIND_PENDING))
		{
			RWanCloseAdapter(pAdapter);
			//
			//  Adapter lock is released within the above.
			//
		}
		else
		{
			RWAN_RELEASE_ADAPTER_LOCK(pAdapter);
		}

		RWANDEBUGP(DL_EXTRA_LOUD, DC_UTIL,
				("Derefed away: pAf x%x, Notify x%x\n",
					pAf, DeleteNotify.pDeleteRtn));

		if (DeleteNotify.pDeleteRtn)
		{
			(*DeleteNotify.pDeleteRtn)(DeleteNotify.DeleteContext, TDI_SUCCESS, 0);
		}

		RWAN_FREE_MEM(pAf);
	}

	return (RefCount);
}



#if 0

VOID
RWanReferenceAdapter(
	IN	PRWAN_NDIS_ADAPTER		pAdapter
	)
/*++

Routine Description:

	Add a reference to the specified NDIS ADAPTER Block.

Arguments:

	pAdapter		- Pointer to the NDIS ADAPTER Block.

Locks on Entry:

	pAdapter

Locks on Exit:

	pAdapter

Return Value:

	None

--*/
{
	RWAN_STRUCT_ASSERT(pAdapter, nad);
	pAdapter->RefCount++;
}




INT
RWanDereferenceAdapter(
	IN	PRWAN_NDIS_ADAPTER		pAdapter
	)
/*++

Routine Description:

	Dereference the specified NDIS ADAPTER Block. If the reference
	count goes down to 0, free it.

Arguments:

	pAdapter		- Pointer to the NDIS ADAPTER Block.

Locks on Entry:

	pAdapter

Locks on Exit:

	pAdapter, iff it hasn't been freed.

Return Value:

	INT - The resulting reference count.

--*/
{
	INT						RefCount;
	RWAN_DELETE_NOTIFY		DeleteNotify;

	RWAN_STRUCT_ASSERT(pAdapter, nad);

	RefCount = --pAdapter->RefCount;

	if (RefCount == 0)
	{
		DeleteNotify = pAdapter->DeleteNotify;

		RWAN_RELEASE_ADAPTER_LOCK(pAdapter);

		if (DeleteNotify.pDeleteRtn)
		{
			(*DeleteNotify.pDeleteRtn)(DeleteNotify.DeleteContext, TDI_SUCCESS, 0);
		}

		RWAN_FREE_MEM(pAdapter);
	}

	return (RefCount);
}


#endif // 0

TDI_STATUS
RWanNdisToTdiStatus(
	IN	NDIS_STATUS				Status
	)
/*++

Routine Description:

	Convert an NDIS Status code to an equivalent TDI code.
	TBD: RWanNdisToTdiStatus: support more NDIS status codes.

Arguments:

	Status		- NDIS status code.

Return Value:

	TDI status.

--*/
{
	TDI_STATUS			TdiStatus;

	switch (Status)
	{
		case NDIS_STATUS_SUCCESS:
			TdiStatus = TDI_SUCCESS;
			break;
		
		case NDIS_STATUS_RESOURCES:
		case NDIS_STATUS_VC_NOT_ACTIVATED:
		case NDIS_STATUS_VC_NOT_AVAILABLE:
			TdiStatus = TDI_NO_RESOURCES;
			break;

		case NDIS_STATUS_SAP_IN_USE:
			TdiStatus = TDI_ADDR_IN_USE;
			break;

		default:
			TdiStatus = TDI_NOT_ACCEPTED;
			break;
	}

	return (TdiStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\tdi\atmsp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\atm\atmsp.h

Abstract:

	Private data structure definitions for ATM-specific functions
	for Raw WAN.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     06-03-97    Created

Notes:

--*/


#ifndef __TDI_ATM_ATMSP__H
#define __TDI_ATM_ATMSP__H


//
//  ATM-specific module's context for an NDIS AF open.
//
typedef struct _ATMSP_AF_BLOCK
{
	RWAN_HANDLE						RWanAFHandle;
	LIST_ENTRY						AfBlockLink;		// To list of AF Blocks
	NDIS_CO_LINK_SPEED				LineRate;			// supported by adapter
	ULONG							MaxPacketSize;		// supported by adapter
	ATMSP_QOS						DefaultQoS;
	ULONG							DefaultQoSLength;

} ATMSP_AF_BLOCK, *PATMSP_AF_BLOCK;


//
//  ATM-specific module's context for a TDI Address Object.
//
typedef struct _ATMSP_ADDR_BLOCK
{
	RWAN_HANDLE						RWanAddrHandle;
	ULONG							RefCount;
	ULONG							Flags;
	ATMSP_CONNECTION_ID				ConnectionId;		// Set via SIO_ASSOCIATE_PVC
	LIST_ENTRY						ConnList;			// List of associated conn blocks
	NDIS_SPIN_LOCK					Lock;				// For above list.

} ATMSP_ADDR_BLOCK, *PATMSP_ADDR_BLOCK;

#define ATMSPF_ADDR_PVC_ID_SET		0x00000001


//
//  ATM-specific module's context for a TDI Connection Object that is
//  associated with an address object.
//
typedef struct _ATMSP_CONN_BLOCK
{
	RWAN_HANDLE						RWanConnHandle;
	PATMSP_ADDR_BLOCK				pAddrBlock;
	LIST_ENTRY						ConnLink;			// To List of Conn Blocks
	ATMSP_CONNECTION_ID				ConnectionId;		// Set after conn setup

} ATMSP_CONN_BLOCK, *PATMSP_CONN_BLOCK;


//
//  Global data structure.
//
typedef struct _ATMSP_GLOBAL_INFO
{
	RWAN_HANDLE						RWanSpHandle;
	RWAN_NDIS_AF_CHARS				AfChars;
	RWAN_HANDLE						RWanProtHandle;
	NDIS_STRING						AtmSpDeviceName;
	LARGE_INTEGER					StartTime;
	LIST_ENTRY						AfList;				// List of AF Blocks
	ULONG							AfListSize;			// Size of above
	RWAN_TDI_PROTOCOL_CHARS			TdiChars;

} ATMSP_GLOBAL_INFO, *PATMSP_GLOBAL_INFO;



#define ATMSP_AF_MAJOR_VERSION		3
#define ATMSP_AF_MINOR_VERSION		1


//
//  Overlayed at the AddressType field of struct _TA_ADDRESS is the
//  Sockets ATM address structure, sockaddr_atm, which is defined as
//
//  typedef struct sockaddr_atm {
//		u_short satm_family;
//		ATM_ADDRESS satm_number;
//		ATM_BHLI satm_bhli;
//		ATM_BLLI satm_blli;
//  } sockaddr_atm;
//
//  Ideally we want satm_number to be overlayed with the first byte
//  of Address[] in the _TA_ADDRESS structure, but because of 4-byte
//  packing of sockaddr_atm, there is a hidden u_short just following
//  satm_family.
//
//  The following macro accesses the "true" local version of the ATM
//  socket address given a pointer to the start of Address[i] within
//  struct _TA_ADDRESS.
//
#define TA_POINTER_TO_ATM_ADDR_POINTER(_pTransportAddr)	\
			(ATMSP_SOCKADDR_ATM UNALIGNED *)((PUCHAR)(_pTransportAddr) + sizeof(USHORT))

//
//  The following macro defines the length of an ATM address as required
//  in a TA_ADDRESS Length field.
//
#define TA_ATM_ADDRESS_LENGTH	(sizeof(ATMSP_SOCKADDR_ATM) + sizeof(USHORT))


//
//  Header length of a Transport Address.
//
#define TA_HEADER_LENGTH	(FIELD_OFFSET(TRANSPORT_ADDRESS, Address->Address))

typedef struct _ATMSP_EVENT
{
	NDIS_EVENT			Event;
	NDIS_STATUS			Status;

} ATMSP_EVENT, *PATMSP_EVENT;

#endif // __TDI_ATM_ATMSP__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\samples\atmsmpl\app\utils.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation, All Rights Reserved.

Module Name:

	 utils.c

Abstract:

	 This file contains routines for starting and stopping the driver and 
	 a few other helper routines.

Author:

	 Anil Francis Thomas (10/98)

Environment:

	 User mode

Revision History:

--*/
#include <windows.h>
#include <winioctl.h>
#include <winsvc.h>
#include "assert.h"
#include <stdio.h>

#include "atmsample.h"
#include "utils.h"
#include "atmsmapp.h"

const int   TIMEOUT_COUNT  = 15;


DWORD AtmSmDriverCheckState(
	PDWORD pdwState
	)
/*++
Routine Description:
	 Check whether the driver is installed, removed, running etc.

Arguments:
	 pdwState    -   State of the driver

Return Value:
	 NO_ERROR    - If successful
	 Others      - failure
--*/
{
	SC_HANDLE       hSCMan   = NULL;
	SC_HANDLE       hDriver  = NULL;
	DWORD           dwStatus = NO_ERROR;
	SERVICE_STATUS  ServiceStatus;

	*pdwState = DriverStateNotInstalled;

	do
	{	// break off loop

		hSCMan = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

		if(NULL == hSCMan)
		{

			dwStatus = GetLastError();
			printf("Failed to OpenSCManager. Error %u\n", dwStatus);
			break;
		}

		//open service to see if it exists
		hDriver = OpenService(hSCMan, ATMSM_SERVICE_NAME, SERVICE_ALL_ACCESS);

		if(NULL != hDriver)
		{

			*pdwState = DriverStateInstalled;

			//service does exist
			if(QueryServiceStatus(hDriver, &ServiceStatus))
			{

				switch(ServiceStatus.dwCurrentState)
				{
					case SERVICE_STOPPED:
						printf("AtmSmDrv current status -- STOPPED\n");
						break;

					case SERVICE_RUNNING:
						printf("AtmSmDrv current status -- RUNNING\n");
						*pdwState = DriverStateRunning;
						break;

					default:
						break;
				}
			}

		}
		else
		{
			printf("Failed to OpenService - Service not installed\n");
			// driver not installed.
		}

	} while(FALSE);

	if(NULL != hDriver)
		CloseServiceHandle(hDriver);

	if(NULL != hSCMan)
		CloseServiceHandle(hSCMan);

	return dwStatus;
}


DWORD AtmSmDriverStart(
	)
/*++
Routine Description:
	 Start the AtmSmDrv.Sys.

Arguments:
					 -
Return Value:
	 NO_ERROR    - If successful
	 Others      - failure
--*/
{

	DWORD   dwState, dwStatus;

	if(NO_ERROR != (dwStatus = AtmSmDriverCheckState(&dwState)))
	{
		return dwStatus;
	}

	switch(dwState)
	{

		case DriverStateNotInstalled:
			dwStatus = ERROR_SERVICE_DOES_NOT_EXIST;	 // not installed
			break;

		case DriverStateRunning:
			break;

		case DriverStateInstalled: {

				// the service is installed, start it

				SC_HANDLE       hSCMan   = NULL;
				SC_HANDLE       hDriver  = NULL;
				SERVICE_STATUS  ServiceStatus;
				int             i;

				do
				{ // break off loop

					hSCMan = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

					if(NULL == hSCMan)
					{
						dwStatus = GetLastError();
						printf("Failed to OpenSCManager. Error - %u\n", dwStatus);
						break;
					}

					hDriver = OpenService(hSCMan, ATMSM_SERVICE_NAME, 
									 SERVICE_ALL_ACCESS);

					// start service
					if(!hDriver || !StartService(hDriver, 0, NULL))
					{
						dwStatus = GetLastError();
						printf("Failed to StartService - Error %u\n", dwStatus);
						break;
					}

					dwStatus = ERROR_TIMEOUT;

					// query state of service
					for(i = 0; i < TIMEOUT_COUNT; i++)
					{

						Sleep(1000);

						if(QueryServiceStatus(hDriver, &ServiceStatus))
						{

							if(ServiceStatus.dwCurrentState == SERVICE_RUNNING)
							{
								dwStatus = NO_ERROR;
								break;
							}
						}
					}

				} while(FALSE);

				if(NULL != hDriver)
					CloseServiceHandle(hDriver);

				if(NULL != hSCMan)
					CloseServiceHandle(hSCMan);

				break;
			}
	}

	return dwStatus;
}


DWORD AtmSmDriverStop(
	)
/*++
Routine Description:
	 Stop the AtmSmDrv.Sys.

Arguments:
					 -
Return Value:
	 NO_ERROR    - If successful
	 Others      - failure
--*/
{

	DWORD   dwState, dwStatus;

	if(NO_ERROR != (dwStatus = AtmSmDriverCheckState(&dwState)))
	{
		return dwStatus;
	}

	switch(dwState)
	{

		case DriverStateNotInstalled:
		case DriverStateInstalled: 
			// not running
			break;

		case DriverStateRunning: {

				// the service is running, stop it

				SC_HANDLE       hSCMan   = NULL;
				SC_HANDLE       hDriver  = NULL;
				SERVICE_STATUS  ServiceStatus;
				int             i;

				do
				{	  // break off loop

					hSCMan = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

					if(NULL == hSCMan)
					{
						dwStatus = GetLastError();
						printf("Failed to OpenSCManager. Error %u\n", dwStatus);
						break;
					}


					hDriver = OpenService(hSCMan, ATMSM_SERVICE_NAME, 
									 SERVICE_ALL_ACCESS);

					// stop service
					if(!hDriver || !ControlService(hDriver, 
						SERVICE_CONTROL_STOP, 
						&ServiceStatus))
					{
						dwStatus = GetLastError();
						printf("Failed to StopService. Error %u\n", dwStatus);
						break;
					}

					// query state of service
					i = 0;
					while((ServiceStatus.dwCurrentState != SERVICE_STOPPED) &&
						(i < TIMEOUT_COUNT))
					{
						if(!QueryServiceStatus(hDriver, &ServiceStatus))
							break;

						Sleep(1000);
						i++;
					}

					if(ServiceStatus.dwCurrentState != SERVICE_STOPPED)
						dwStatus = ERROR_TIMEOUT;

				} while(FALSE);

				if(NULL != hDriver)
					CloseServiceHandle(hDriver);

				if(NULL != hSCMan)
					CloseServiceHandle(hSCMan);

				break;
			}
	}

	return dwStatus;
}


DWORD AtmSmOpenDriver(
	OUT HANDLE   *phDriver
	)
/*++
Routine Description:
	 Get a handle to the driver

Arguments:
	 pointer to a handle

Return Value:
	 NO_ERROR or other
--*/
{
	DWORD   dwStatus    = NO_ERROR;
	HANDLE  hDriver;


	hDriver = CreateFile(
					 ATM_SAMPLE_CLIENT_DOS_NAME,
					 GENERIC_READ | GENERIC_WRITE,
					 FILE_SHARE_READ | FILE_SHARE_WRITE,
					 NULL,
					 OPEN_EXISTING,
					 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
					 NULL);

	if(INVALID_HANDLE_VALUE == hDriver)
	{

		dwStatus = GetLastError();
		printf("Failed to open AtmSm Driver. Error %u\n", dwStatus);
	}

	*phDriver = hDriver;

	return dwStatus;
}


VOID AtmSmCloseDriver(
	IN HANDLE   hDriver
	)
/*++
Routine Description:
	 Close the handle to the driver

Arguments:
	 Handle to the driver

Return Value:
	 None
--*/
{
	CloseHandle(hDriver);
}


DWORD AtmSmEnumerateAdapters(
	IN      HANDLE           hDriver,
	IN OUT  PADAPTER_INFO    pAdaptInfo,
	IN OUT  PDWORD           pdwSize
	)
/*++
Routine Description:
	 Enumerate the interfaces of the driver.

	 Note:  This call doesn't pend
Arguments:
	 pointer to a handle

Return Value:
	 NO_ERROR or other
--*/
{
	DWORD       dwStatus    = NO_ERROR;
	DWORD       dwReturnBytes;
	BOOL        bResult;
	OVERLAPPED  Overlapped;

	memset(&Overlapped, 0, sizeof(OVERLAPPED));

	do
	{

		Overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

		if(NULL == Overlapped.hEvent)
		{
			dwStatus = GetLastError();
			break;
		}

		dwReturnBytes = 0;

		// Get the address of adapters
		bResult = DeviceIoControl(
						 hDriver,
						 (ULONG)IOCTL_ENUMERATE_ADAPTERS,
						 NULL,
						 0,
						 pAdaptInfo,
						 *pdwSize,
						 &dwReturnBytes,
						 &Overlapped);

		if(!bResult)
		{

			dwStatus = GetLastError();
			printf("Failed to enumerate AtmSm Driver. Error %u\n", dwStatus);

			// this is a sync operation, it can't pend
			assert(ERROR_IO_PENDING != dwStatus);
		}
		else
			*pdwSize	= dwReturnBytes;


	} while(FALSE);

	if(NULL != Overlapped.hEvent)
		CloseHandle(Overlapped.hEvent);

	return dwStatus;
}


DWORD CloseConnectHandle(
	OVERLAPPED     *pOverlapped
	)
/*++
Routine Description:
	 Close a handle that was obtained when establishing connection to 
	 destinations.
	 
Arguments:
	 pOverlapped  - An overlapped structure with an Event handle set already.

Return Value:
	 Status
--*/
{
	BOOL    bResult;
	DWORD   dwReturnBytes   = 0;
	DWORD   dwStatus        = NO_ERROR;

	do
	{	  // break off loop

		if(!g_ProgramOptions.hSend)
			break;

		printf("Closing SendHandle - 0x%p\n", g_ProgramOptions.hSend);

		ResetEvent(pOverlapped->hEvent);

		// close the connection handle
		bResult = DeviceIoControl(
						 g_ProgramOptions.hDriver,
						 (ULONG)IOCTL_CLOSE_SEND_HANDLE,
						 &g_ProgramOptions.hSend,
						 sizeof(HANDLE),
						 NULL,
						 0,
						 &dwReturnBytes,
						 pOverlapped);

		if(!bResult)
		{

			dwStatus = GetLastError();

			if(ERROR_IO_PENDING != dwStatus)
			{
				printf("Failed to disconnect to destinations. Error %u\n", 
					dwStatus);
				break;
			}

			// the operation is pending
			bResult = GetOverlappedResult(
							 g_ProgramOptions.hDriver,
							 pOverlapped,
							 &dwReturnBytes,
							 TRUE
							 );
			if(!bResult)
			{
				dwStatus = GetLastError();
				printf("Wait for connection to drop, failed. Error - %u\n", 
					dwStatus);
				break;
			}
		}

	} while(FALSE);

	return dwStatus;
}


DWORD CloseReceiveHandle(
	OVERLAPPED     *pOverlapped
	)
/*++
Routine Description:
	 Close a receive handle that was obtained when an adapter was opened for
	 recvs.
	 
Arguments:
	 pOverlapped  - An overlapped structure with an Event handle set already.

Return Value:
	 Status
--*/
{
	BOOL    bResult;
	DWORD   dwReturnBytes   = 0;
	DWORD   dwStatus        = NO_ERROR;

	HANDLE hReceive;                                 

	do
	{	  // break off loop

		if(!g_ProgramOptions.hReceive)
			break;

		hReceive = g_ProgramOptions.hReceive;
		g_ProgramOptions.hReceive = NULL;

		printf("Closing ReceiveHandle - 0x%p\n", g_ProgramOptions.hReceive);

		ResetEvent(pOverlapped->hEvent);

		// close the connection handle
		bResult = DeviceIoControl(
						 g_ProgramOptions.hDriver,
						 (ULONG)IOCTL_CLOSE_RECV_HANDLE,
						 &hReceive,
						 sizeof(HANDLE),
						 NULL,
						 0,
						 &dwReturnBytes,
						 pOverlapped);

		if(!bResult)
		{

			dwStatus = GetLastError();

			if(ERROR_IO_PENDING != dwStatus)
			{
				printf("Failed to close the recv handle. Error %u\n", dwStatus);
				break;
			}

			// the operation is pending
			bResult = GetOverlappedResult(
							 g_ProgramOptions.hDriver,
							 pOverlapped,
							 &dwReturnBytes,
							 TRUE
							 );
			if(!bResult)
			{
				dwStatus = GetLastError();
				printf("Wait for closing the recv handle failed. Error - %u\n",
					dwStatus);
				break;
			}
		}

	} while(FALSE);

	return dwStatus;
}


VOID FillPattern(
	PUCHAR  pBuf,
	DWORD   dwSize
	)
/*++
Routine Description:
	 Fill a Byte pattern: Every Byte has a value Offset % (0xFF+1) 
	 (Values 0 - FF)
	 
Arguments:
	 Buffer and size to be filled.

Return Value:
	 NONE
--*/
{
	DWORD   dw;

	for(dw = 0; dw < dwSize; dw++)
	{
		pBuf[dw] = (UCHAR)(dw % (MAX_BYTE_VALUE+1));
	}
}



BOOL VerifyPattern(
	PUCHAR  pBuf,
	DWORD   dwSize
	)
/*++
Routine Description:
	 Verify that the pattern is correct.
	 
Arguments:
	 Buffer and size to be filled.

Return Value:
	 NONE
--*/
{
	DWORD dw;
	UCHAR uch;

	for(dw = 0; dw < dwSize; dw++)
	{

		uch = (UCHAR)(dw % (MAX_BYTE_VALUE+1));

		if(uch != (UCHAR)pBuf[dw])
		{
			printf("Error verifying data. Pattern wrong at offset %u"
				" Expected - %.2X Got - %.2X\n",
				dw, uch, pBuf[dw]);
			return FALSE;
		}
	}

	return TRUE;
}


char * GetErrorString(
	DWORD dwError
	)
/*++
Routine Description:
	 Get the formated error string from the system, given an error number.

Arguments:
	 dwError     - Error Number

Return Value:
	 ErrorString from the system
--*/
{
#define ERR_STR_LEN  512

	static char szErrorString[ERR_STR_LEN];

	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
		NULL,
		dwError,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		szErrorString,
		ERR_STR_LEN,
		NULL);

	return szErrorString;

#undef ERR_STR_LEN
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\rawwan\tdi\rwanatm.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\atm\rwanatm.h

Abstract:

	Winsock 2 ATM definitions.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     06-18-97    Created

Notes:

--*/


#ifndef __TDI_ATM_RWANATM__H
#define __TDI_ATM_RWANATM__H


typedef struct _ATMSP_WSABUF
{
	ULONG							len;
	PCHAR							buf;

} ATMSP_WSABUF, *PATMSP_WSABUF;


typedef struct _ATMSP_QUALITY_OF_SERVICE
{
	FLOWSPEC						SendingFlowSpec;
	FLOWSPEC						ReceivingFlowSpec;
	ATMSP_WSABUF					ProviderSpecific;

} ATMSP_QOS, *PATMSP_QOS;


typedef struct _ATMSP_BLLI
{
	ULONG							Layer2Protocol;
	ULONG							Layer2UserSpecifiedProtocol;
	ULONG							Layer3Protocol;
	ULONG							Layer3UserSpecifiedProtocol;
	ULONG							Layer3IPI;
	UCHAR							SnapId[5];

} ATMSP_BLLI, *PATMSP_BLLI;


typedef struct _ATMSP_BHLI
{
	ULONG							HighLayerInfoType;
	ULONG							HighLayerInfoLength;
	UCHAR							HighLayerInfo[8];

} ATMSP_BHLI, *PATMSP_BHLI;


typedef struct _atmsp_sockaddr_atm
{
	ATM_ADDRESS						satm_number;
	ATMSP_BLLI						satm_blli;
	ATMSP_BHLI						satm_bhli;

} ATMSP_SOCKADDR_ATM, *LPATMSP_SOCKADDR_ATM;

#define ATMSP_AF_ATM				22
#define TDI_ADDRESS_TYPE_ATM		ATMSP_AF_ATM
#define ATMSP_ATMPROTO_AAL5			0x05
#define ATMSP_SOCK_TYPE				1

#define SOCKATM_E164				1
#define SOCKATM_NSAP				2


typedef struct _atmsp_connection_id
{
	ULONG							DeviceNumber;
	ULONG							Vpi;
	ULONG							Vci;

} ATMSP_CONNECTION_ID, *PATMSP_CONNECTION_ID;


//
//  Winsock2/ATM AAL parameter definition:
//
typedef enum {
	ATMSP_AALTYPE_5			= 5,
	ATMSP_AALTYPE_USER		= 16

} ATMSP_AAL_TYPE, *PATMSP_AAL_TYPE;

typedef struct
{
	ULONG							ForwardMaxCPCSSDUSize;
	ULONG							BackwardMaxCPCSSDUSize;
	UCHAR							Mode;
	UCHAR							SSCSType;

} ATMSP_AAL5_PARAMETERS, *PATMSP_AAL5_PARAMETERS;


typedef struct {
	ULONG							UserDefined;

} ATMSP_AALUSER_PARAMETERS, *PATMSP_AALUSER_PARAMETERS;

typedef struct _atmsp_aal_parameters_ie
{
	ATMSP_AAL_TYPE					AALType;
	union {
		ATMSP_AAL5_PARAMETERS			AAL5Parameters;
		ATMSP_AALUSER_PARAMETERS		AALUserParameters;
	}								AALSpecificParameters;

} ATMSP_AAL_PARAMETERS_IE, *PATMSP_AAL_PARAMETERS_IE;



//
//  Winsock2/ATM Broadband bearer capability code definitions.
//  The BearerClass codes are different.
//
#define ATMSP_BCOB_A				0x01
#define ATMSP_BCOB_C				0x03
#define ATMSP_BCOB_X				0x10

#endif // __TDI_ATM_RWANATM__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\samples\atmsmpl\driver\atmsmdbg.h ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation, All Rights Reserved.

Module Name:

    ATMSMDbg.h

Abstract:

    Debug macros for ATMSMDRV

Author:

    Anil Francis Thomas (10/98)

Environment:

    Kernel

Revision History:

--*/

#ifndef _ATMSMDbg__H
#define _ATMSMDbg__H


#define MEMORY_TAG  'MSDN'

//
// The ID of each source section (Used as the first 28 bits of AtmSmDebugFlag)
//
#define MODULE_INIT         0x00000010

#define MODULE_ADAPTER      0x00000100
#define MODULE_CALLMGR      0x00000200

#define MODULE_WMI          0x00001000
#define MODULE_PACKET       0x00002000

#define MODULE_SEND         0x00010000
#define MODULE_RECV         0x00020000

#define MODULE_MISC         0x00100000
#define MODULE_REQUEST      0x00200000
#define MODULE_IOCTL        0x00400000

#define MODULE_DEBUG        0x10000000



#if DBG

// The value here defines what debug output you wants to see. The value is a 
// combination of DebugLevel and the module IDs
// All messages in the specified modules with urgency lower than 
// specified will be enabled.
extern UINT AtmSmDebugFlag;

//
// Message verbosity: lower values indicate higher urgency. 
// (specified in the last 4 bits of AtmSmDebugFlag)
//
#define ATMSMD_VERY_LOUD        6
#define ATMSMD_IN_OUT           5
#define ATMSMD_LOUD             4
#define ATMSMD_INFO             3
#define ATMSMD_WARN             2
#define ATMSMD_ERR              1
#define ATMSMD_FATAL            0

#define DBG_LVL(DbgFlag) (DbgFlag & 0x0000000F)


#define CheckLockCount(Count) {                                 \
                                                                \
    if ((INT)(Count) < 0) {                                     \
                                                                \
        DbgPrint("Lock Count %d is < 0! File %s, Line %d\n",    \
            Count, __FILE__, __LINE__);                         \
        DbgBreakPoint();                                        \
    }                                                           \
}


#define ATMSMDebugP(Level, Fmt) {                               \
                                                                \
    if((MODULE_ID & AtmSmDebugFlag)                             \
        && (Level <= DBG_LVL(AtmSmDebugFlag))) {                \
                                                                \
        DbgPrint("** AtmSmDrv (0x%X): ",    MODULE_ID );        \
        DbgPrint Fmt;                                           \
    }                                                           \
}


#define DbgVeryLoud(Fmt)    ATMSMDebugP(ATMSMD_VERY_LOUD,  Fmt)
#define DbgInOut(Fmt)       ATMSMDebugP(ATMSMD_IN_OUT,  Fmt)
#define DbgLoud(Fmt)        ATMSMDebugP(ATMSMD_LOUD,  Fmt)
#define DbgInfo(Fmt)        ATMSMDebugP(ATMSMD_INFO,  Fmt)
#define DbgWarn(Fmt)        ATMSMDebugP(ATMSMD_WARN,  Fmt)
#define DbgErr(Fmt)         ATMSMDebugP(ATMSMD_ERR,  Fmt)
#define DbgFatal(Fmt)       ATMSMDebugP(ATMSMD_FATAL, Fmt)

#define TraceIn(x)          DbgInOut(("--> "#x"\n"))
#define TraceOut(x)         DbgInOut(("<-- "#x"\n"))

//
// Memory Allocation/Freeing Auditing:
//

#define INIT_DONE_PATTERN       0x01020102
#define TRAILER_PATTERN         0x0A0B0C0D

//
// The ATMSMD_ALLOCATION structure stores all info about one AtmSmMemAlloc.
//
typedef struct _ATMSMD_ALLOCATION {

        ULONG                       ulSignature;
        struct _ATMSMD_ALLOCATION   *Next;
        struct _ATMSMD_ALLOCATION   *Prev;
        ULONG                       ulModuleNumber;
        ULONG                       ulLineNumber;
        ULONG                       ulSize;
        union
        {
            ULONGLONG               Alignment;
            UINT_PTR                Location;   // where the returned pointer was put
        };

} ATMSMD_ALLOCATION, *PATMSMD_ALLOCATION;


typedef struct _ATMSMD_ALLOC_GLOBAL {

        PATMSMD_ALLOCATION          pAtmSmHead;
        PATMSMD_ALLOCATION          pAtmSmTail;
        ULONG                       ulAtmSmAllocCount;
        NDIS_SPIN_LOCK              AtmSmMemoryLock;
        ULONG                       ulAtmSmInitDonePattern;

} ATMSMD_ALLOC_GLOBAL, *PATMSMD_ALLOC_GLOBAL;

extern
VOID
AtmSmInitializeAuditMem(
    );

extern
VOID
AtmSmShutdownAuditMem(
    );

extern
PVOID
AtmSmAuditAllocMem (
    PVOID       *ppPointer,
    ULONG       ulSize,
    ULONG       ulModuleNumber,
    ULONG       ulLineNumber
    );

extern
VOID
AtmSmAuditFreeMem(
    PVOID       Pointer
    );

#define ATMSM_INITIALIZE_AUDIT_MEM()    AtmSmInitializeAuditMem()
#define ATMSM_SHUTDOWN_AUDIT_MEM()      AtmSmShutdownAuditMem()

#define AtmSmAllocMem(ppPointer, TYPE, Size) \
            *ppPointer = (TYPE)AtmSmAuditAllocMem((PVOID *)ppPointer, Size, \
                                                    MODULE_ID, __LINE__)

#define AtmSmFreeMem(pPointer)  AtmSmAuditFreeMem((PVOID)pPointer)


VOID
PrintATMAddr(
    IN      char            *pStr,
    IN      PATM_ADDRESS    pAtmAddr
    );

#define DumpATMAddress(Level, Str, Addr) {                      \
                                                                \
        if((MODULE_ID & AtmSmDebugFlag)                         \
            && (Level <= DBG_LVL(AtmSmDebugFlag))) {            \
                                                                \
            PrintATMAddr(Str,Addr);                             \
        }                                                       \
    }


#define ATMSM_GET_ENTRY_IRQL(_Irql) \
            _Irql = KeGetCurrentIrql()
#define ATMSM_CHECK_EXIT_IRQL(_EntryIrql, _ExitIrql) \
        {                                       \
            _ExitIrql = KeGetCurrentIrql();     \
            if (_ExitIrql != _EntryIrql)        \
            {                                   \
                DbgPrint("File %s, Line %d, Exit IRQ %d != Entry IRQ %d\n", \
                        __FILE__, __LINE__, _ExitIrql, _EntryIrql);         \
                DbgBreakPoint();                \
            }                                   \
        }

#else   // DBG

//
// No debug
//
#define ATMSM_INITIALIZE_AUDIT_MEM()

#define ATMSM_SHUTDOWN_AUDIT_MEM()

#define AtmSmAllocMem(ppPointer, TYPE, Size) \
            NdisAllocateMemoryWithTag((PVOID *)ppPointer, (ULONG)Size, \
                                                            (ULONG)MEMORY_TAG)

#define AtmSmFreeMem(pPointer)  NdisFreeMemory((PVOID)(pPointer), 0, 0)


#define CheckLockCount(Count)

#define DbgVeryLoud(Fmt)
#define DbgInOut(Fmt)
#define DbgLoud(Fmt)
#define DbgInfo(Fmt)
#define DbgWarn(Fmt)
#define DbgErr(Fmt)
#define DbgFatal(Fmt)

#define TraceIn(x)
#define TraceOut(x)

#define DumpATMAddress(Level, Str, Addr)

#define ATMSM_GET_ENTRY_IRQL(Irql)
#define ATMSM_CHECK_EXIT_IRQL(EntryIrql, ExitIrql)

#endif  // DBG

#endif // _AtmSmDbg__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\samples\atmsmpl\app\utils.h ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation, All Rights Reserved.

Module Name:

    utils.h

Abstract:
    Header file for the helped routines.

Author:

    Anil Francis Thomas (10/98)

Environment:

    User mode

Revision History:

--*/

#ifndef  __ATMSM_UTILS__H_
#define  __ATMSM_UTILS__H_

#define DriverStateNotInstalled 1
#define DriverStateInstalled    2
#define DriverStateRunning      3

#define ATMSM_DRIVER_NAME       "AtmSmDrv.Sys"


DWORD  
AtmSmDriverCheckState(
    PDWORD pdwState
    );

DWORD 
AtmSmDriverStart(
    );

DWORD 
AtmSmDriverStop(
    );


DWORD
AtmSmOpenDriver(
    OUT HANDLE   *phDriver
    );

VOID
AtmSmCloseDriver(
    IN HANDLE   hDriver
    );

DWORD
AtmSmEnumerateAdapters(
    IN      HANDLE           hDriver,
    IN OUT  PADAPTER_INFO    pAdaptInfo,
    IN OUT  PDWORD           pdwSize
    );

DWORD
CloseConnectHandle(
    OVERLAPPED     *pOverlapped
    );

DWORD
CloseReceiveHandle(
    OVERLAPPED     *pOverlapped
    );

BOOL
VerifyPattern(
    PUCHAR  pBuf,
    DWORD   dwSize
    );

VOID
FillPattern(
    PUCHAR  pBuf,
    DWORD   dwSize
    );

char *
GetErrorString(
    DWORD dwError
    );


#endif //  __ATMSM_UTILS__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\samples\atmsmpl\driver\atmsmdbg.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation, All Rights Reserved.

Module Name:

    AtmSmDbg.c

Abstract:

    This module contains all debug-related code.
    In debug mode we use our own memory management scheme to find out memory
    leaks etc.

Author:

    Anil Francis Thomas (10/98)

Environment:

    Kernel

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

#define MODULE_ID   MODULE_DEBUG


#if DBG

// global variable holding alloc Info
ATMSMD_ALLOC_GLOBAL    AtmSmDAllocGlobal;


VOID
AtmSmInitializeAuditMem(
    )
{
    AtmSmDAllocGlobal.pAtmSmHead              = (PATMSMD_ALLOCATION)NULL;
    AtmSmDAllocGlobal.pAtmSmTail              = (PATMSMD_ALLOCATION)NULL;
    AtmSmDAllocGlobal.ulAtmSmAllocCount       = 0;
    
    NdisAllocateSpinLock(&AtmSmDAllocGlobal.AtmSmMemoryLock);

    AtmSmDAllocGlobal.ulAtmSmInitDonePattern  = INIT_DONE_PATTERN;
}


PVOID
AtmSmAuditAllocMem(
    PVOID   *ppPointer,
    ULONG   ulSize,
    ULONG   ulModuleNumber,
    ULONG   ulLineNumber
    )
{
    PUCHAR              pBuffer;
    ULONG UNALIGNED *   pulTrailer;
    PATMSMD_ALLOCATION     pAllocInfo;
    NDIS_STATUS         Status;

    if(INIT_DONE_PATTERN != AtmSmDAllocGlobal.ulAtmSmInitDonePattern){
        ASSERT(FALSE);
        AtmSmInitializeAuditMem();
    }

    Status = NdisAllocateMemoryWithTag(
                (PVOID *)&pAllocInfo,
                sizeof(ATMSMD_ALLOCATION) + ulSize + (2 * sizeof(ULONG)),
                (ULONG)MEMORY_TAG
                );

    if (Status != NDIS_STATUS_SUCCESS)
    {
        DbgErr(("AtmSmAuditAllocMem: Module 0x%X, line %d, Size %d failed!\n",
                                       ulModuleNumber, ulLineNumber, ulSize));
        pBuffer = NULL;
    }
    else
    {
        pBuffer         = (PUCHAR)(pAllocInfo + 1);
        pulTrailer      = (ULONG UNALIGNED *)(pBuffer + ulSize);

        *pulTrailer++   = TRAILER_PATTERN;
        *pulTrailer     = TRAILER_PATTERN;

        pAllocInfo->ulSignature     = (ULONG)MEMORY_TAG;
        pAllocInfo->ulModuleNumber  = ulModuleNumber;
        pAllocInfo->ulLineNumber    = ulLineNumber;
        pAllocInfo->ulSize          = ulSize;
        pAllocInfo->Location        = (UINT_PTR)ppPointer;
        pAllocInfo->Next            = (PATMSMD_ALLOCATION)NULL;

        NdisAcquireSpinLock(&AtmSmDAllocGlobal.AtmSmMemoryLock);

        pAllocInfo->Prev = AtmSmDAllocGlobal.pAtmSmTail;

        if((PATMSMD_ALLOCATION)NULL == AtmSmDAllocGlobal.pAtmSmTail)
        {
            // empty list
            AtmSmDAllocGlobal.pAtmSmHead = AtmSmDAllocGlobal.pAtmSmTail = pAllocInfo;
        }
        else
        {
            AtmSmDAllocGlobal.pAtmSmTail->Next = pAllocInfo;
        }

        AtmSmDAllocGlobal.pAtmSmTail = pAllocInfo;

        AtmSmDAllocGlobal.ulAtmSmAllocCount++;

        NdisReleaseSpinLock(&AtmSmDAllocGlobal.AtmSmMemoryLock);
    }

    DbgLoud(("AtmSmAuditAllocMem: Module %p, line %d, %d bytes, [0x%x] <- 0x%x\n",
              ulModuleNumber, ulLineNumber, ulSize, ppPointer, pBuffer));

    return ((PVOID)pBuffer);

}


VOID
AtmSmAuditFreeMem(
    PVOID   Pointer
    )
{
    PUCHAR              pBuffer = (PUCHAR)Pointer;
    ULONG UNALIGNED *   pulTrailer;
    PATMSMD_ALLOCATION     pAllocInfo;

    pAllocInfo = (PATMSMD_ALLOCATION)(pBuffer - sizeof(ATMSMD_ALLOCATION));

    if(pAllocInfo->ulSignature != MEMORY_TAG){

        DbgErr(("AtmSmAuditFreeMem: unknown buffer %p!\n", Pointer));

        DbgBreakPoint();
        return;
    }

    DbgLoud(("AtmSmAuditFreeMem: Freeing Buffer %p pAudit %p!\n", 
                                                         Pointer, pAllocInfo));

    // check the trailer
    pulTrailer  = (ULONG UNALIGNED *)(pBuffer + pAllocInfo->ulSize);

    if((*pulTrailer != TRAILER_PATTERN) ||
        (*(++pulTrailer) != TRAILER_PATTERN)){

        DbgErr(("AtmSmAuditFreeMem: Trailer over written! Alloc - %p "
                "Trailer - %p\n", pAllocInfo, pulTrailer));

        DbgBreakPoint();
        return;
    }


    NdisAcquireSpinLock(&AtmSmDAllocGlobal.AtmSmMemoryLock);

    pAllocInfo->ulSignature = (ULONG)'DEAD';
    if((PATMSMD_ALLOCATION)NULL != pAllocInfo->Prev)
    {
        pAllocInfo->Prev->Next = pAllocInfo->Next;
    }
    else
    {
        AtmSmDAllocGlobal.pAtmSmHead = pAllocInfo->Next;
    }

    if((PATMSMD_ALLOCATION)NULL != pAllocInfo->Next)
    {
        pAllocInfo->Next->Prev = pAllocInfo->Prev;
    }
    else
    {
        AtmSmDAllocGlobal.pAtmSmTail = pAllocInfo->Prev;
    }

    AtmSmDAllocGlobal.ulAtmSmAllocCount--;

    NdisReleaseSpinLock(&AtmSmDAllocGlobal.AtmSmMemoryLock);

    NdisFreeMemory(pAllocInfo, 0, 0);
}


VOID
AtmSmShutdownAuditMem(
    )
{
    if(AtmSmDAllocGlobal.ulAtmSmAllocCount)
        DbgErr(("Number of memory blocks still allocated - %u\n", 
                                        AtmSmDAllocGlobal.ulAtmSmAllocCount));

    
    NdisFreeSpinLock(&AtmSmDAllocGlobal.AtmSmMemoryLock);

    AtmSmDAllocGlobal.ulAtmSmInitDonePattern  = 'DAED';
}


VOID
PrintATMAddr(
    IN      char            *pStr,
    IN      PATM_ADDRESS    pAtmAddr
    )
/*++
Routine Description:
    Print an ATM_ADDRESS address onto the debugger.

Arguments:
    pStr       - pointer to the string to be printed together with address
    pAtmAddr   - pointer to an NSAP or E164 address

Return Value:
--*/
{
    ULONG   i,j;
    char    HexChars[] = "0123456789ABCDEF";
    ULONG   NumOfDigits;
    PUCHAR  pucAtmAddr = pAtmAddr->Address;
    UCHAR   AddrString[(ATM_ADDRESS_LENGTH*2) + 1];

    if ((NumOfDigits = pAtmAddr->NumberOfDigits) > ATM_ADDRESS_LENGTH){

        NumOfDigits = ATM_ADDRESS_LENGTH;
    }

    j = 0;
    for(i = 0; i < NumOfDigits; i++){
        AddrString[j++] = HexChars[(pucAtmAddr[i] >> 4)];
        AddrString[j++] = HexChars[(pucAtmAddr[i] &0xF)];
    }

    AddrString[j] = '\0';

    DbgPrint("%s(%s, %u): %s\n",
                    pStr,
                    (pAtmAddr->AddressType == ATM_E164) ? "E164" : "NSAP",
                    NumOfDigits,
                    AddrString);
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\samples\atmsmpl\app\atmsmapp.h ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation, All Rights Reserved.

Module Name:

    atmsmapp.h

Abstract:

    Header file of the user mode app that controls the sample driver.

Author:

    Anil Francis Thomas (10/98)

Environment:

    User mode

Revision History:

--*/

#ifndef _ATMSMAPP_H_
#define _ATMSMAPP_H_

#define   NSAP_ADDR_LEN         20
#define   MAX_DESTINATIONS      0
#define   DELIMITOR_CHARS       " ,;"

typedef struct  _ProgramOptions {
    BOOLEAN     fLocalIntf;         // Local Interface Specified
    BOOLEAN     fEnumInterfaces;    // Enumerate all interfaces
    BOOLEAN     fPMP;               // Is point to multipoint
    USHORT      usDrvAction;        // Start. Stop
    USHORT      usSendRecvAction;   // Send or Recv
    DWORD       dwPktSize;          // Send Pkts Size
    DWORD       dwPktInterval;      // Send Pkt Interval
    DWORD       dwNumPkts;          // Send Number of Pkts
    DWORD       dwNumDsts;          // Send to destinations
    HANDLE      hDriver;            // Handle - to the driver
    HANDLE      hReceive;           // Handle - open for recv
    HANDLE      hSend;              // Handle - send to dsts
    UCHAR       ucLocalIntf[NSAP_ADDR_LEN];    // Local Interface
    UCHAR       ucDstAddrs[MAX_DESTINATIONS][NSAP_ADDR_LEN]; // destinations
} PROGRAM_OPTIONS,  *PPROGRAM_OPTIONS;


// usDrvAction
#define START_DRV     1
#define STOP_DRV      2

// usSendRecvAction
#define RECEIVE_PKTS  1
#define SEND_PKTS     2

#define DEFAULT_PKT_SIZE        512
#define MAX_PKT_SIZE            9180

#define DEFAULT_PKT_INTERVAL    10      // millisecs
#define DEFAULT_NUM_OF_PKTS     10

#define MAX_BYTE_VALUE          0xFF

#define CharToHex(c, ucRet) {                       \
                                                    \
    if(c >= '0' && c <= '9')                        \
        ucRet = (UCHAR)(c - '0');                   \
    else                                            \
        if(c >= 'A' && c <= 'F')                    \
            ucRet = (UCHAR)(10 + (c - 'A'));        \
        else                                        \
            if(c >= 'a' && c <= 'f')                \
                ucRet = (UCHAR)(10 + (c - 'a'));    \
            else                                    \
                ucRet = (UCHAR)-1;                  \
                                                    \
}


extern PROGRAM_OPTIONS g_ProgramOptions;

void
Usage(
    );

BOOL
ParseCommandLine(
    int argc,
    char *argv[]
    );

void
EnumerateInterfaces(
    );

DWORD
DoSendPacketsToDestinations(
    );

DWORD
DoRecvPacketsOnAdapter(
    );

BOOL WINAPI
CtrlCHandler(
    DWORD dwCtrlType
    );

BOOL
GetSpecifiedDstAddrs(
    char    *pStr
    );

BOOL
GetATMAddrs(
    char    *pStr,
    UCHAR   ucAddr[]
    );

UINT FindOption(
    char *lptOpt,
    char **ppVal
    );

char *
FormatATMAddr(
    UCHAR   ucAddr[]
    );


#endif // _ATMSMAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\samples\atmsmpl\app\atmsmapp.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation, All Rights Reserved.

Module Name:

	 atmsmapp.c

Abstract:

	 This is the user mode app that controls the sample ATM client.
	 It can be used for 
		  1. Starting / Stopping the driver.
		  2. Sending to one (point - point) or more (PMP) destinations.
		  3. Receive packets that come on any VC to our SAP.

Author:

	 Anil Francis Thomas (10/98)

Environment:

	 User mode

Revision History:

--*/

#include <windows.h>
#include <winioctl.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "atmsample.h"
#include "utils.h"
#include "atmsmapp.h"

PROGRAM_OPTIONS g_ProgramOptions;


int __cdecl main(int argc, char *argv[])
{

	DWORD   dwRetVal = NO_ERROR;

	memset(&g_ProgramOptions, 0, sizeof(PROGRAM_OPTIONS));

	g_ProgramOptions.dwPktSize      = DEFAULT_PKT_SIZE;
	g_ProgramOptions.dwPktInterval  = DEFAULT_PKT_INTERVAL;
	g_ProgramOptions.dwNumPkts      = DEFAULT_NUM_OF_PKTS;


	// parse the command line parameters
	if((argc < 2) || (FALSE == ParseCommandLine(argc, argv)))
	{
		Usage();
		return 1;
	}

	// Is any driver option specified - start, stop etc
	if(g_ProgramOptions.usDrvAction)
	{

		switch(g_ProgramOptions.usDrvAction)
		{

			case START_DRV:
				dwRetVal = AtmSmDriverStart();
				if(NO_ERROR != dwRetVal)
				{
					printf("Failed to start driver. Error %u\n",
						dwRetVal);
				}
				else
					printf("Successfully started the driver.\n");
				break;

			case STOP_DRV:
				dwRetVal = AtmSmDriverStop();
				if(NO_ERROR != dwRetVal)
				{
					printf("Failed to stop driver. Error %u\n",
						dwRetVal);
					return 1;
				}
				else
				{
					printf("Successfully stopped the driver.\n");
					return 0;	// we are done
				}
				break;
		}
	}

	if(NO_ERROR != dwRetVal)
		return dwRetVal;


	do
	{	  // break off loop

		dwRetVal = AtmSmOpenDriver(&g_ProgramOptions.hDriver);

		if(NO_ERROR != dwRetVal)
			break;


		// enumerate the interfaces
		if(g_ProgramOptions.fEnumInterfaces)
			EnumerateInterfaces();


		if(g_ProgramOptions.fLocalIntf)
			printf("\nLocal Interface Address - %s\n", 
				FormatATMAddr(g_ProgramOptions.ucLocalIntf));

		if(g_ProgramOptions.dwNumDsts)
		{
			DWORD dw;

			printf("\nDestinations specified : %u\n", 
				g_ProgramOptions.dwNumDsts);
			for(dw = 0; dw < g_ProgramOptions.dwNumDsts; dw++)
				printf("    %u - %s\n", dw+1, 
					FormatATMAddr(g_ProgramOptions.ucDstAddrs[dw]));

		}

		if(g_ProgramOptions.usSendRecvAction && !g_ProgramOptions.fLocalIntf)
		{
			// for sends and recv we need a local intf
			printf("Error! Specify a local interface to send and recv\n");
			dwRetVal = 1;
			break;
		}

		if((SEND_PKTS == g_ProgramOptions.usSendRecvAction)
			&& !g_ProgramOptions.dwNumDsts)
		{
			// for sends and recv we need a local intf
			printf("Error! Specify destination address(s) to send packets\n");
			dwRetVal = 1;
			break;
		}

		// Set the Cntrl - C Handler
		SetConsoleCtrlHandler(CtrlCHandler, TRUE);

		if(SEND_PKTS == g_ProgramOptions.usSendRecvAction)
			dwRetVal = DoSendPacketsToDestinations();
		else
			if(RECEIVE_PKTS == g_ProgramOptions.usSendRecvAction)
			dwRetVal = DoRecvPacketsOnAdapter();


	}while(FALSE);

	if(NULL != g_ProgramOptions.hDriver)
		AtmSmCloseDriver(g_ProgramOptions.hDriver);

	return(int)dwRetVal;
}


void EnumerateInterfaces()
/*++
Routine Description:
 
	 Enumerate all the adapters that the driver is bound to.  You get the 
	 NSAP addresses for these interfaces.

Arguments:
	 NONE

Return Value:
	 NONE
--*/
{
	DWORD           dw, dwRetVal, dwSize;    
	PADAPTER_INFO   pAI;

	dwSize = sizeof(ADAPTER_INFO) + (sizeof(UCHAR) * 5 * NSAP_ADDRESS_LEN);

	pAI = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize);

	if(!pAI)
	{
		printf("Error not enough memory\n");
		return;
	}

	do
	{ // break off loop

		dwRetVal = AtmSmEnumerateAdapters(
						  g_ProgramOptions.hDriver,
						  pAI,
						  &dwSize);

		if(NO_ERROR != dwRetVal)
		{
			printf("Failed to enumerate adapters. Error - %u\n",
				dwRetVal);
			break;
		}

		printf("\nNumber of adapters - %u\n", pAI->ulNumAdapters);
		for(dw = 0; dw < pAI->ulNumAdapters; dw++)
		{
			printf("    Adapter [%u] - %s\n", dw+1,
				FormatATMAddr(pAI->ucLocalATMAddr[dw]));
		}

	}while(FALSE);


	HeapFree(GetProcessHeap(), 0, pAI);

	return;
}


DWORD DoSendPacketsToDestinations()
/*++
Routine Description:
	 This routine does the sending of packets to one or more destinations.
	 First a connect call is made to get a handle.  That handle is used for
	 further sends.

Arguments:
	 NONE

Return Value:
	 Status
--*/
{
	DWORD           dw, dwSize;
	PCONNECT_INFO   pCI;
	OVERLAPPED      Overlapped;
	BOOL            bResult;
	DWORD           dwReturnBytes;
	PUCHAR          pBuffer     = NULL;
	DWORD           dwStatus    = NO_ERROR;

	memset(&Overlapped, 0, sizeof(OVERLAPPED));

	dwSize  = sizeof(CONNECT_INFO) + (sizeof(UCHAR) * 
					 g_ProgramOptions.dwNumDsts * NSAP_ADDRESS_LEN);

	pCI     = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize);

	if(!pCI)
	{
		printf("Error not enough memory\n");
		return ERROR_NOT_ENOUGH_MEMORY;
	}

	pCI->bPMP           = g_ProgramOptions.fPMP;
	pCI->ulNumDsts      = g_ProgramOptions.dwNumDsts;
	memcpy(pCI->ucLocalATMAddr, g_ProgramOptions.ucLocalIntf,
		(sizeof(UCHAR) * NSAP_ADDR_LEN));
	for(dw = 0; dw < g_ProgramOptions.dwNumDsts; dw++)
		memcpy(pCI->ucDstATMAddrs[dw], g_ProgramOptions.ucDstAddrs[dw],
			(sizeof(UCHAR) * NSAP_ADDR_LEN));


	do
	{	  // break off loop

		Overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

		if(NULL == Overlapped.hEvent)
		{
			dwStatus = GetLastError();
			printf("Failed to create event. Error %u\n", dwStatus);
			break;
		}

		dwReturnBytes = 0;

		// Initiate a connection to destinations
		bResult = DeviceIoControl(
						 g_ProgramOptions.hDriver,
						 (ULONG)IOCTL_CONNECT_TO_DSTS,
						 pCI,
						 dwSize,
						 &g_ProgramOptions.hSend,
						 sizeof(HANDLE),
						 &dwReturnBytes,
						 &Overlapped);

		if(!bResult)
		{

			dwStatus = GetLastError();

			if(ERROR_IO_PENDING != dwStatus)
			{
				printf("Failed to connect to destinations. Error %u\n", 
					dwStatus);
				break;
			}

			// the operation is pending
			bResult = GetOverlappedResult(
							 g_ProgramOptions.hDriver,
							 &Overlapped,
							 &dwReturnBytes,
							 TRUE
							 );
			if(!bResult)
			{
				dwStatus = GetLastError();
				printf("Wait for connection to complete failed. Error - %u\n", 
					dwStatus);
				break;
			}

		}

		// successfully connected
		printf("Successfully connected to destination(s) - Handle - 0x%p\n",
			g_ProgramOptions.hSend);

		// allocate a buffer to send 
		dwSize = g_ProgramOptions.dwPktSize;

		pBuffer   = HeapAlloc(GetProcessHeap(), 0, dwSize);

		if(!pBuffer)
		{
			printf("Error not enough memory\n");
			dwStatus = ERROR_NOT_ENOUGH_MEMORY;
			break;
		}

		FillPattern(pBuffer, dwSize);

		// do the number of sends that were asked to do
		for(dw = 0; dw < g_ProgramOptions.dwNumPkts; dw++)
		{

			ResetEvent(Overlapped.hEvent);
			dwReturnBytes = 0;

			bResult = DeviceIoControl(
							 g_ProgramOptions.hDriver,
							 (ULONG)IOCTL_SEND_TO_DSTS,
							 &g_ProgramOptions.hSend,
							 sizeof(HANDLE),
							 pBuffer,	//Note! the buffer given here
							 dwSize,	//Note! the size given here
							 &dwReturnBytes,
							 &Overlapped);

			if(!bResult)
			{

				dwStatus = GetLastError();

				if(ERROR_IO_PENDING != dwStatus)
				{
					printf("Failed to do sends to destinations. Error %u\n", 
						dwStatus);
					break;
				}

				// the operation is pending
				bResult = GetOverlappedResult(
								 g_ProgramOptions.hDriver,
								 &Overlapped,
								 &dwReturnBytes,
								 TRUE
								 );
				if(!bResult)
				{
					dwStatus = GetLastError();
					printf("Wait for send to complete failed. Error - %u\n", 
						dwStatus);
					break;
				}

				printf("Successfully send packet number %u\n", dw+1);

				Sleep(g_ProgramOptions.dwPktInterval);
			}

		}

	} while(FALSE);


	if(g_ProgramOptions.hSend)
	{
		CloseConnectHandle(&Overlapped);
		g_ProgramOptions.hSend = NULL;
	}

	if(pCI)
		HeapFree(GetProcessHeap(), 0, pCI);

	if(pBuffer)
		HeapFree(GetProcessHeap(), 0, pBuffer);


	if(Overlapped.hEvent)
		CloseHandle(Overlapped.hEvent);

	return dwStatus;
}


DWORD DoRecvPacketsOnAdapter()
/*++
Routine Description:
	 This routine is used to receive packets that come to our SAP on any VCs.
	 Note:  Only one recv can pend at a time.

Arguments:
	 NONE

Return Value:
	 Status
--*/
{
	DWORD                   dw, dwSize;
	POPEN_FOR_RECV_INFO     pORI;
	OVERLAPPED              Overlapped;
	BOOL                    bResult;
	DWORD                   dwReturnBytes;
	PUCHAR                  pBuffer     = NULL;
	DWORD                   dwStatus    = NO_ERROR;

	memset(&Overlapped, 0, sizeof(OVERLAPPED));

	dwSize  = sizeof(OPEN_FOR_RECV_INFO);

	pORI    = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize);

	if(!pORI)
	{
		printf("Error not enough memory\n");
		return ERROR_NOT_ENOUGH_MEMORY;
	}

	memcpy(pORI->ucLocalATMAddr, g_ProgramOptions.ucLocalIntf,
		(sizeof(UCHAR) * NSAP_ADDR_LEN));

	do
	{	  // break off loop

		Overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

		if(NULL == Overlapped.hEvent)
		{
			dwStatus = GetLastError();
			printf("Failed to create event. Error %u\n", dwStatus);
			break;
		}

		dwReturnBytes = 0;

		// Open the adapter for recvs
		bResult = DeviceIoControl(
						 g_ProgramOptions.hDriver,
						 (ULONG)IOCTL_OPEN_FOR_RECV,
						 pORI,
						 dwSize,
						 &g_ProgramOptions.hReceive,
						 sizeof(HANDLE),
						 &dwReturnBytes,
						 &Overlapped);

		if(!bResult)
		{

			dwStatus = GetLastError();

			if(ERROR_IO_PENDING != dwStatus)
			{
				printf("Failed to open adapter for recvs. Error %u\n", 
					dwStatus);
				break;
			}

			// the operation is pending
			bResult = GetOverlappedResult(
							 g_ProgramOptions.hDriver,
							 &Overlapped,
							 &dwReturnBytes,
							 TRUE
							 );
			if(!bResult)
			{
				dwStatus = GetLastError();
				printf("Wait for open to complete failed. Error - %u\n", 
					dwStatus);
				break;
			}

		}

		// successfully connected
		printf("Successfully opened adapter for recvs - Handle - 0x%p\n",
			g_ProgramOptions.hReceive);

		// allocate a buffer to receive data into
		dwSize = MAX_PKT_SIZE;

		pBuffer = HeapAlloc(GetProcessHeap(), 0, dwSize);

		if(!pBuffer)
		{
			printf("Error not enough memory\n");
			dwStatus = ERROR_NOT_ENOUGH_MEMORY;
			break;
		}


		// start receiving packets
		dw = 0;
		while(TRUE)
		{

			dwReturnBytes = 0;
			ResetEvent(Overlapped.hEvent);
			memset(pBuffer, 0, dwSize);

			bResult = DeviceIoControl(
							 g_ProgramOptions.hDriver,
							 (ULONG)IOCTL_RECV_DATA,
							 &g_ProgramOptions.hReceive,
							 sizeof(HANDLE),
							 pBuffer,
							 dwSize,
							 &dwReturnBytes,
							 &Overlapped);

			if(!bResult)
			{

				dwStatus = GetLastError();

				if(ERROR_IO_PENDING != dwStatus)
				{
					printf("Failed to receive data. Error %u\n", dwStatus);
					break;
				}

				// the operation is pending
				bResult = GetOverlappedResult(
								 g_ProgramOptions.hDriver,
								 &Overlapped,
								 &dwReturnBytes,
								 TRUE
								 );
				if(!bResult)
				{
					dwStatus = GetLastError();
					if(dwStatus == ERROR_OPERATION_ABORTED)
					{
						printf("Receive operation is aborted.\n");
					}
					else
					{
						printf("Wait for recv to complete failed. Error - %u\n", 
							dwStatus);
					}
					break;
				}

				printf("Successfully received a packet (%u). Size  %u\n", 
					dw+1, dwReturnBytes);

				VerifyPattern(pBuffer, dwReturnBytes);
			}

			dw++;
		}

	} while(FALSE);


	if(g_ProgramOptions.hReceive)
	{
		CloseReceiveHandle(&Overlapped);
	}

	if(pORI)
		HeapFree(GetProcessHeap(), 0, pORI);

	if(pBuffer)
		HeapFree(GetProcessHeap(), 0, pBuffer);

	if(Overlapped.hEvent)
		CloseHandle(Overlapped.hEvent);

	return dwStatus;
}


BOOL WINAPI CtrlCHandler(
	DWORD dwCtrlType
	)
/*++
Routine Description:
	 This routine is called when Cntrl-C is used to exit the app from recv loop
	 or during sends.  It just cleans up the handles.

Arguments:

Return Value:
	 
--*/
{
	OVERLAPPED Overlapped;

	printf("Control - C Handler\n");

	memset(&Overlapped, 0, sizeof(OVERLAPPED));

	Overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

	if(NULL == Overlapped.hEvent)
	{
		printf("Failed to create event. Error %u\n", GetLastError());
		return FALSE;
	}

	// If Recv was enabled then close that handle
	if(g_ProgramOptions.hReceive)
	{
		CloseReceiveHandle(&Overlapped);
	}

	printf("###-1\n");

	// If Send was enabled then close that handle
	if(g_ProgramOptions.hSend)
	{
		CloseConnectHandle(&Overlapped);
		g_ProgramOptions.hSend = NULL;
	}

	CloseHandle(Overlapped.hEvent);

	printf("###-2\n");

	return FALSE;	 // causes the app to exit
}


void Usage()
{
	printf( "\n This program is used for sending or receiving data over ATM"
		"\n using the ATMSMDRV.SYS.\n\n");

	printf( " Mandatory Arguments:\n\n"

		"    For SEND and RECV:\n"
		"         /INTF:3908...0C100  -   Local ATM adapter to use\n\n");

	printf( " Optional Arguments:\n\n"

		"         /START              -   Start the driver.\n"
		"         /STOP               -   Stop the driver.\n"
		"         /ENUM               -   Enumerate interfaces.\n\n"

		"    For SEND:\n"
		"         /SEND:39..C100,49.. -   ATM addresses of destinations\n"
		"         /PMP                -   Make a PMP call.\n"
		"         /INTVL:100          -   Time interval between sends"
		" (millisec).\n"
		"         /SIZE:512           -   Packet Size (bytes).\n"
		"         /NUMPKTS:10         -   No. of packets to send.\n\n"

		"    For RECV:\n"
		"         /RECV               -   Receive pkts on the adapter\n\n");

	printf( " Example:\n\n"

		"    AtmSmApp  /INTF:4700918100000000613E5BFE010000C100741F00 "
		"/RECV\n"
		"    AtmSmApp  /INTF:4700...41F00 /SEND:4700...41F00,4700...123F00"
		" \n\n");

	printf( " Notes:\n\n"

		"     A PMP call is made, when multiple destinations are specified."
		"\n"
		"     Full NSAP address should be specified. Selector Byte defaults"
		" to 05.\n");
}


//
//  Options are of the form
//
//      /START
//      /NUMPKTS:12

#define START_DRV_OPT           101
#define STOP_DRV_OPT            102
#define ENUM_INTFS_OPT          103
#define LOCAL_INTF_OPT          104
#define SEND_ADDRS_OPT          105
#define RECV_PKTS_OPT           106
#define PKT_INTERVAL_OPT        107
#define PKT_SIZE_OPT            108
#define NUM_PKTS_OPT            109
#define PMP_CONNECTION          110
#define UNKNOWN_OPTION          111

struct _CmdOptions
{
	LPTSTR  lptOption;
	UINT    uOpt;
} CmdOptions[]    = {
	{_T("/START")        , START_DRV_OPT},
	{_T("/STOP")         , STOP_DRV_OPT},
	{_T("/ENUM")         , ENUM_INTFS_OPT},
	{_T("/INTF:")        , LOCAL_INTF_OPT},
	{_T("/SEND:")        , SEND_ADDRS_OPT},
	{_T("/RECV")         , RECV_PKTS_OPT},
	{_T("/INTVL:")       , PKT_INTERVAL_OPT},
	{_T("/SIZE:")        , PKT_SIZE_OPT},
	{_T("/NUMPKTS:")     , NUM_PKTS_OPT},
	{_T("/PMP")          , PMP_CONNECTION},
};

INT iCmdOptionsCounts = sizeof(CmdOptions)/sizeof(struct _CmdOptions);

BOOL ParseCommandLine(
	int argc,
	char * argv[]
	)
/*++
Routine Description:
	 Parse the command line parameters.

Arguments:
	 argc        - number of arguments
	 argv        - arguments

Return Value:
	 TRUE        - if successful
	 FALSE       - failure
--*/
{
	BOOL    bRetVal = TRUE;
	int     iIndx;
	UINT    uOpt;
	char    *pVal;

	for(iIndx = 1; iIndx < argc; iIndx++)
	{

		uOpt = FindOption(argv[iIndx], &pVal);

		switch(uOpt)
		{

			case START_DRV_OPT:
				g_ProgramOptions.usDrvAction = START_DRV;
				break;

			case STOP_DRV_OPT:
				g_ProgramOptions.usDrvAction = STOP_DRV;
				break;

			case ENUM_INTFS_OPT:
				g_ProgramOptions.fEnumInterfaces = TRUE;
				break;

			case LOCAL_INTF_OPT:
				if(!GetATMAddrs(pVal, g_ProgramOptions.ucLocalIntf))
				{
					printf("Local Interface address specified - Bad characters!\n");
					return FALSE;
				}
				g_ProgramOptions.fLocalIntf  = TRUE;
				break;

			case SEND_ADDRS_OPT:
				g_ProgramOptions.usSendRecvAction = SEND_PKTS;

				if(!GetSpecifiedDstAddrs(pVal))
				{
					printf("Destination address(es) specified - Bad characters!\n");
					return FALSE;
				}
				// more than 1 destinations, it is a PMP VC
				if(1 < g_ProgramOptions.dwNumDsts)
					g_ProgramOptions.fPMP = TRUE;

				break;

			case RECV_PKTS_OPT:
				g_ProgramOptions.usSendRecvAction = RECEIVE_PKTS;
				break;

			case PKT_INTERVAL_OPT:
				g_ProgramOptions.dwPktInterval = atol(pVal);
				break;

			case PKT_SIZE_OPT:
				g_ProgramOptions.dwPktSize = atol(pVal);
				if(g_ProgramOptions.dwPktSize > MAX_PKT_SIZE)
					g_ProgramOptions.dwPktSize = MAX_PKT_SIZE;
				break;

			case NUM_PKTS_OPT:
				g_ProgramOptions.dwNumPkts = atol(pVal);
				break;

			case PMP_CONNECTION:
				g_ProgramOptions.fPMP = TRUE;
				break;

			default:
				printf("Unknown switch - %s\n", argv[iIndx]);
				return FALSE;
		}
	}

	return bRetVal;
}

UINT FindOption(
	char *lptOpt,
	char **ppVal
	)
/*++
Routine Description:
	 Find the option number based on the command line switch.

Arguments:
	 lptOpt          - command line option
	 ppVal           - Value associated with the option

Return Value:
	 OPTION_NUMBER   - if success

--*/
{
	int     i;
	UINT    iLen;

	for(i = 0; i < iCmdOptionsCounts; i++)
	{
		if(strlen(lptOpt) >= (iLen = strlen(CmdOptions[i].lptOption)))
			if(0 == _strnicmp(lptOpt, CmdOptions[i].lptOption, iLen))
			{
				*ppVal = lptOpt + iLen;
				return CmdOptions[i].uOpt;
			}
	}

	return UNKNOWN_OPTION;
}


BOOL GetSpecifiedDstAddrs(
	char    *pStr
	)
/*++
Routine Description:
	 Get all the ATM destination addresses specified based from the
	 command line parameter (after /SEND:)

Arguments:
	 pStr        - pointer to what follows after /SEND:

Return Value:
	 TRUE        - if successful
	 FALSE       - failure
--*/
{
	char szTmp[512];
	char *pToken;
	int  i;

	strcpy(szTmp, pStr);

	pToken = strtok(szTmp, DELIMITOR_CHARS);

	i = 0;
	while(pToken)
	{

		if(!GetATMAddrs(pToken, g_ProgramOptions.ucDstAddrs[i]))
			return FALSE;

		pToken = strtok(NULL, DELIMITOR_CHARS);
		i++;
	}

	g_ProgramOptions.dwNumDsts = i;

	return TRUE;
}


BOOL GetATMAddrs(
	char    *pStr,
	UCHAR   ucAddr[]
	)
/*++
Routine Description:
	 Parse the string specified as an ATM (NSAP)address into a 20byte
	 array to hold the address

Arguments:
	 pStr        - pointer to the string holding the address
	 ucAddr      - 20Byte Array holding the ATM address

Return Value:
	 TRUE        - if successful
	 FALSE       - failure
--*/
{
	UCHAR   ucVal;
	int     i;

	for(i = 0; (*pStr != '\0') && (i < NSAP_ADDR_LEN); i++)
	{

		CharToHex(*pStr, ucVal);
		if((UCHAR)-1 == ucVal)
			return FALSE;

		ucAddr[i] = (UCHAR)(ucVal * 16);
		pStr++;

		CharToHex(*pStr, ucVal);
		if((UCHAR)-1 == ucVal)
			return FALSE;

		ucAddr[i] = (UCHAR)(ucAddr[i] + ucVal);
		pStr++;
	}

	return TRUE;
}


char * FormatATMAddr(
	UCHAR   ucAddr[]
	)
/*++
Routine Description:
	 Format a 20 byte ATM [NSAP] address into a character array for printing.

Arguments:
	 ucAddr      - 20Byte Array holding the ATM address

Return Value:
	 String      - pointer to the string holding the address
--*/
{
	static char szStr[NSAP_ADDR_LEN * 2 + 1];
	int  i,j;
	char HexChars[] = "0123456789ABCDEF";

	j = 0;
	for(i = 0; i < NSAP_ADDR_LEN; i++)
	{
		szStr[j++] = HexChars[(ucAddr[i] >> 4)];
		szStr[j++] = HexChars[(ucAddr[i] &0xF)];
	}

	szStr[j] = '\0';

	return szStr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\samples\atmsmpl\driver\adapter.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation, All Rights Reserved.

Module Name:

    adapter.c

Abstract:

    This contains routines related to the adapter (Initialize, 
    Deinitialize, bind, unbind, open, close  etc.)

Author:

    Anil Francis Thomas (10/98)

Environment:

    Kernel

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop


#define MODULE_ID    MODULE_ADAPTER

NDIS_STATUS
AtmSmAllocateAdapter(
    PATMSM_ADAPTER    *ppAdapter
    );

VOID
AtmSmDeallocateAdapter(
    PATMSM_ADAPTER    pAdapt
    );

VOID
AtmSmOpenAdapterComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status,
    IN  NDIS_STATUS             OpenStatus
    );

VOID
AtmSmCloseAdapterComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status
    );



VOID
AtmSmBindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN  NDIS_HANDLE                 BindContext,
    IN  PNDIS_STRING                pDeviceName,
    IN  PVOID                       SystemSpecific1,
    IN  PVOID                       SystemSpecific2
    )

/*++

Routine Description:
    This is called by NDIS when it has an adapter for which there is a
    binding to the AtmSm client.

    We first allocate an Adapter structure. Then we open our configuration
    section for this adapter and save the handle in the Adapter structure.
    Finally, we open the adapter.

    We don't do anything more for this adapter until NDIS notifies us of
    the presence of a Call manager (via our AfRegisterNotify handler).

Arguments:
    pStatus             - Place to return status of this call
    BindContext         - Not used, because we don't pend this call 
    pDeviceName         - The name of the adapter we are requested to bind to
    SystemSpecific1     - Opaque to us; to be used to access configuration info
    SystemSpecific2     - Opaque to us; not used.

Return Value:
    None. We set *pStatus to an error code if something goes wrong before we
    call NdisOpenAdapter, otherwise NDIS_STATUS_PENDING.
--*/
{
    PATMSM_ADAPTER  pAdapt = NULL;    // Pointer to new adapter structure
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    NDIS_STATUS     OpenStatus;
    UINT            MediumIndex;
    NDIS_MEDIUM     MediumArray[] = {NdisMediumAtm};
    ULONG           Length;

    TraceIn(AtmSmBindAdapter);

    DbgLoud(("BindAdapter: Context 0x%x, pDevName 0x%x, SS1 0x%x, SS2 0x%x\n",
                  BindContext, pDeviceName, SystemSpecific1, SystemSpecific2));


    do {

        //
        // Allocate and initialize the Adapter structure. 
        //
        Status = AtmSmAllocateAdapter(&pAdapt);

        if(NDIS_STATUS_SUCCESS != Status)
            break;

        pAdapt->NdisBindContext = BindContext;

        // Status = AtmSmReadAdapterConfiguration(pAdapt);

        if(NDIS_STATUS_SUCCESS != Status)
            break;

        //
        // Now open the adapter below and complete the initialization
        //
        NdisOpenAdapter(&Status,
                        &OpenStatus,
                        &pAdapt->NdisBindingHandle,
                        &MediumIndex,
                        MediumArray,
                        1,
                        AtmSmGlobal.ProtHandle,
                        pAdapt,
                        pDeviceName,
                        0,
                        NULL);

        if(NDIS_STATUS_PENDING != Status){

            AtmSmOpenAdapterComplete((NDIS_HANDLE)pAdapt, 
                                     Status, 
                                     OpenStatus);
        }

        //
        // Return pending since we are bound to call (or have already
        // called) NdisCompleteBindAdapter.
        //
        Status = NDIS_STATUS_PENDING;
        pAdapt->Medium = MediumArray[MediumIndex];

    } while (FALSE);


    if ((NDIS_STATUS_SUCCESS != Status) &&
            (NDIS_STATUS_PENDING != Status)) {

        DbgErr(("Failed to Open Adapter. Error - 0x%X \n", Status));

        if (NULL != pAdapt){

            AtmSmDereferenceAdapter(pAdapt);
        }
    }

    TraceOut(AtmSmBindAdapter);


    *pStatus = Status;
}


VOID
AtmSmOpenAdapterComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status,
    IN  NDIS_STATUS             OpenStatus
    )
/*++

Routine Description:
    Upcall from NDIS to signal completion of a NdisOpenAdapter() call.
    Or we called it from BindAdapter to complete the call.

Arguments:
    ProtocolBindingContext      Pointer to the pAdapt
    Status                      Status of NdisOpenAdapter
    OpenStatus                  OpenAdapter's code

Return Value:

--*/
{
    PATMSM_ADAPTER  pAdapt = (PATMSM_ADAPTER)ProtocolBindingContext;

    TraceIn(AtmSmOpenAdapterComplete);

    // First complete the pending bind call.
    NdisCompleteBindAdapter(pAdapt->NdisBindContext, 
                            Status, 
                            OpenStatus);

    pAdapt->NdisBindContext = NULL; // we don't need the context anymore

    if (NDIS_STATUS_SUCCESS != Status)
    {
        //
        // NdisOpenAdapter() failed - log an error and exit
        //
        DbgErr(("Failed to open adapter. Status - 0x%X \n", Status));

        AtmSmCloseAdapterComplete(pAdapt, Status);
    }
    else
    {
        pAdapt->ulFlags       |= ADAPT_OPENED;

        AtmSmQueryAdapter(pAdapt);

        NdisQueryAdapterInstanceName(
            &pAdapt->BoundToAdapterName,
            pAdapt->NdisBindingHandle);

    }

    TraceOut(AtmSmOpenAdapterComplete);
}



VOID
AtmSmUnbindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 UnbindContext
    )
/*++

Routine Description:

    This routine is called by NDIS when it wants us to unbind
    from an adapter. Or, this may be called from within our Unload
    handler. We undo the sequence of operations we performed
    in our BindAdapter handler.

Arguments:

    pStatus                 - Place to return status of this operation
    ProtocolBindingContext  - Our context for this adapter binding, which
                              is a pointer to an ATMSM Adapter structure.
    UnbindContext           - This is NULL if this routine is called from
                              within our Unload handler. Otherwise (i.e.
                              NDIS called us), we retain this for later use
                              when calling NdisCompleteUnbindAdapter.
Return Value:

    NDIS_STATUS_PENDING or NDIS_STATUS_SUCCESS.

--*/
{
    PATMSM_ADAPTER  pAdapt = (PATMSM_ADAPTER)ProtocolBindingContext;
    NDIS_EVENT      CleanupEvent;       // Used to wait for Close Adapter
#if DBG
    KIRQL           EntryIrql, ExitIrql;
#endif

    TraceIn(AtmSmUnBindAdapter);

    ATMSM_GET_ENTRY_IRQL(EntryIrql);

    DbgInfo(("UnbindAdapter: pAdapter 0x%x, UnbindContext 0x%X\n",
                                                pAdapt, UnbindContext));

    NdisInitializeEvent(&CleanupEvent);

    pAdapt->pCleanupEvent = &CleanupEvent;

    //
    //  Save the unbind context for a later call to
    //  NdisCompleteUnbindAdapter.
    pAdapt->UnbindContext = UnbindContext;


    // ask the adapter to shutdown
    AtmSmShutdownAdapter(pAdapt);

    //
    // Wait for the cleanup to complete
    //
    NdisWaitEvent(&CleanupEvent, 0);

    //
    // Return pending since we always call NdisCompleteUnbindAdapter.
    //
    *pStatus = NDIS_STATUS_PENDING;

    ATMSM_CHECK_EXIT_IRQL(EntryIrql, ExitIrql);

    TraceOut(AtmSmUnBindAdapter);

    return;
}


NDIS_STATUS
AtmSmShutdownAdapter(
    PATMSM_ADAPTER  pAdapt
    )
/*++

Routine Description:

    This routine is called to Shutdown an adapter.

Arguments:
    pAdapt      - Pointer to the adapter

Return Value:

    NDIS_STATUS_PENDING or NDIS_STATUS_SUCCESS
--*/
{
    NDIS_STATUS     Status;
#if DBG
    KIRQL           EntryIrql, ExitIrql;
#endif

    TraceIn(AtmSmShutdownAdapter);

    ATMSM_GET_ENTRY_IRQL(EntryIrql);

    ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);
    
    pAdapt->ulFlags |= ADAPT_SHUTTING_DOWN;


    //
    //  Degister SAP
    //
    if(pAdapt->ulFlags & ADAPT_SAP_REGISTERED){

        pAdapt->ulFlags &=  ~ADAPT_SAP_REGISTERED;

        RELEASE_ADAPTER_GEN_LOCK(pAdapt);

        Status = NdisClDeregisterSap(pAdapt->NdisSapHandle);

        if (NDIS_STATUS_PENDING != Status) {

            AtmSmDeregisterSapComplete(Status, pAdapt);
        }    

        ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);
    }

    //
    //  Remove all VC's.
    //
    while (!IsListEmpty(&pAdapt->ActiveVcHead)) {

        PATMSM_VC pVc;

        pVc = CONTAINING_RECORD(pAdapt->ActiveVcHead.Flink, ATMSM_VC, List);

        RemoveEntryList(&pVc->List);
        InsertHeadList(&pAdapt->InactiveVcHead, &pVc->List);

        RELEASE_ADAPTER_GEN_LOCK(pAdapt);

        // this will result in it getting removed
        AtmSmDisconnectVc(pVc);

        ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);
    }


    //
    //  Close Address Family
    //

    if(pAdapt->ulFlags & ADAPT_AF_OPENED){

        pAdapt->ulFlags &= ~ADAPT_AF_OPENED;

        RELEASE_ADAPTER_GEN_LOCK(pAdapt);

        Status = NdisClCloseAddressFamily(pAdapt->NdisAfHandle);

        if (NDIS_STATUS_PENDING != Status){

            AtmSmCloseAfComplete(Status, pAdapt);
        }

        ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);
    }

    if(pAdapt->pRecvIrp){

        PIRP pRecvIrp = pAdapt->pRecvIrp;

        // there is an Irp pending, complete it
        pRecvIrp->IoStatus.Status       = STATUS_CANCELLED;
        pRecvIrp->Cancel                = TRUE;
        pRecvIrp->IoStatus.Information  = 0;
        IoCompleteRequest(pRecvIrp, IO_NETWORK_INCREMENT);

        pAdapt->pRecvIrp = NULL;
    }

    pAdapt->fAdapterOpenedForRecv = FALSE;

    //
    // Set the interface to closing
    //
    ASSERT ((pAdapt->ulFlags & ADAPT_CLOSING) == 0);
    pAdapt->ulFlags |= ADAPT_CLOSING;

    RELEASE_ADAPTER_GEN_LOCK(pAdapt);


    //  
    //  Close the adapter
    //
    NdisCloseAdapter(
        &Status,
        pAdapt->NdisBindingHandle
        );

    if (Status != NDIS_STATUS_PENDING) {

        AtmSmCloseAdapterComplete(
            (NDIS_HANDLE) pAdapt,
            Status
            );
    }

    ATMSM_CHECK_EXIT_IRQL(EntryIrql, ExitIrql);

    TraceOut(AtmSmShutdownAdapter);

    return Status;
}


VOID
AtmSmCloseAdapterComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status
    )
/*++

Routine Description:
    Called by NDIS or us to complete CloseAdapter call.

Arguments:
    ProtocolBindingContext      - Pointer to the adapter
    Status                      - Status of our close adapter

Return Value:


--*/
{

    PATMSM_ADAPTER  pAdapt = (PATMSM_ADAPTER)ProtocolBindingContext;
    NDIS_HANDLE     UnbindContext = pAdapt->UnbindContext;
#if DBG
    KIRQL           EntryIrql, ExitIrql;
#endif

    TraceIn(AtmSmCloseAdapterComplete);

    ATMSM_GET_ENTRY_IRQL(EntryIrql);

    pAdapt->NdisBindingHandle = NULL;

    //
    // Finally dereference it
    //
    AtmSmDereferenceAdapter(pAdapt);

    if (UnbindContext != (NDIS_HANDLE)NULL) {

        NdisCompleteUnbindAdapter(
            UnbindContext,
            NDIS_STATUS_SUCCESS
            );
    }

    ATMSM_CHECK_EXIT_IRQL(EntryIrql, ExitIrql);

    TraceOut(AtmSmCloseAdapterComplete);
}



NDIS_STATUS
AtmSmAllocateAdapter(
    PATMSM_ADAPTER    *ppAdapter
    )
/*++

Routine Description:
    Called for initializing an Adapter structure.

Arguments:
    ppAdapter        - newly allocated adapter

Return Value:
    NDIS_STATUS_SUCCESS    - If successful
    Others                 - failure

--*/
{
    PATMSM_ADAPTER     pAdapt;
    NDIS_STATUS        Status = NDIS_STATUS_SUCCESS;

    TraceIn(AtmSmAllocateAdapter);

    do {

        AtmSmAllocMem(&pAdapt, PATMSM_ADAPTER, sizeof(ATMSM_ADAPTER));

        if (NULL == pAdapt){

            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // Initialize the adapter structure
        //
        NdisZeroMemory(pAdapt, sizeof(ATMSM_ADAPTER));

        pAdapt->ulSignature    = atmsm_adapter_signature;

        //
        // Put a reference on the adapter
        //
        AtmSmReferenceAdapter(pAdapt);


        // the address is invalid now
        pAdapt->ulFlags |= ADAPT_ADDRESS_INVALID;                 


        // Hard-code the selector Byte
        pAdapt->SelByte = (UCHAR) 0x5;

        INIT_BLOCK_STRUCT(&pAdapt->RequestBlock);

        InitializeListHead(&pAdapt->InactiveVcHead);
        InitializeListHead(&pAdapt->ActiveVcHead);

        NdisAllocateSpinLock(&pAdapt->AdapterLock);

        NdisInitializeTimer(
            &pAdapt->RecvTimerOb,
            AtmSmRecvReturnTimerFunction,
            pAdapt
            );

        //
        // Fill in some defaults.
        //
        pAdapt->MaxPacketSize       = DEFAULT_MAX_PACKET_SIZE;
        pAdapt->LinkSpeed.Inbound   = pAdapt->LinkSpeed.Outbound 
                                    = DEFAULT_SEND_BANDWIDTH;

        pAdapt->VCFlowSpec          = AtmSmDefaultVCFlowSpec;


        //
        // Allocate a Buffer Pool
        //
        NdisAllocateBufferPool(&Status,
                               &pAdapt->BufferPoolHandle,
                               0xFFFFFFFF);

        if (NDIS_STATUS_SUCCESS != Status)
            break;

        //
        // Allocate a packet pool. We need this to pass sends down. We cannot
        // use the same packet descriptor that came down to our send handler
        //
        NdisAllocatePacketPoolEx(&Status,
                                 &pAdapt->PacketPoolHandle,
                                 DEFAULT_NUM_PKTS_IN_POOL,
                                 (0xFFFF - DEFAULT_NUM_PKTS_IN_POOL),
                                 sizeof(PROTO_RSVD));

        if (NDIS_STATUS_SUCCESS != Status)
            break;

    }while(FALSE);


    if(Status == NDIS_STATUS_SUCCESS){

        pAdapt->ulFlags |= ADAPT_CREATED;
        
        // queue it in the Global list of adapters
        ACQUIRE_GLOBAL_LOCK();

        pAdapt->pAdapterNext        = AtmSmGlobal.pAdapterList;
        AtmSmGlobal.pAdapterList    = pAdapt;
        AtmSmGlobal.ulAdapterCount++;

        RELEASE_GLOBAL_LOCK();

    } else {

        // Failed, so cleanup
        LONG lRet = AtmSmDereferenceAdapter(pAdapt);

        ASSERT(0 == lRet);

        if(0 == lRet)
            pAdapt  = NULL;
    }

    *ppAdapter  = pAdapt;

    TraceOut(AtmSmAllocateAdapter);

    return Status;
}


VOID
AtmSmDeallocateAdapter(
    PATMSM_ADAPTER    pAdapt
    )
/*++

Routine Description:
    Called for cleaning up an Adapter structure, when it is not needed anymore.
    We don't get here unless the reference count drops to zero, that means all
    VC's, SAP etc are removed by now.

Arguments:
    pAdapt      - newly allocated adapter

Return Value:
    None
--*/
{
    PPROTO_RSVD     pPRsvd;
    PNDIS_PACKET    pPkt;
    PATMSM_ADAPTER  pTmpAdapt, pPrevAdapt;
    BOOLEAN         fTimerCancelled;

    TraceIn(AtmSmDeallocateAdapter);

    if(!pAdapt)
        return;

    ASSERT(0 == pAdapt->ulRefCount);

    // remove the adapter from the Global list of adapters
    ACQUIRE_GLOBAL_LOCK();

    pPrevAdapt  = NULL;
    pTmpAdapt   = AtmSmGlobal.pAdapterList;

    while(pTmpAdapt &&
        pTmpAdapt != pAdapt){

        pPrevAdapt  = pTmpAdapt;
        pTmpAdapt   = pTmpAdapt->pAdapterNext;
    }

    ASSERT(pTmpAdapt);

    if(pPrevAdapt)
        pPrevAdapt->pAdapterNext = pAdapt->pAdapterNext;
    else
        AtmSmGlobal.pAdapterList   = pAdapt->pAdapterNext;

    AtmSmGlobal.ulAdapterCount--;

    RELEASE_GLOBAL_LOCK();


    ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

    // cancel any recv timer on the adapter
    if(pAdapt->fRecvTimerQueued)
        CANCEL_ADAPTER_RECV_TIMER(pAdapt, &fTimerCancelled);


    //
    // Remove any packets still in the recv queue
    //  
    while(pAdapt->pRecvPktNext){

        pPkt                    = pAdapt->pRecvPktNext; 
        pPRsvd                  = GET_PROTO_RSVD(pPkt);
        pAdapt->pRecvPktNext    = pPRsvd->pPktNext;

        pAdapt->ulRecvPktsCount--;

        RELEASE_ADAPTER_GEN_LOCK(pAdapt);

        NdisReturnPackets(&pPkt, 1);

        ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);
    }

    pAdapt->pRecvLastPkt = NULL;

    // free the buffer pool
    if(pAdapt->BufferPoolHandle)
        NdisFreeBufferPool(pAdapt->BufferPoolHandle);

    // free the pool handle
    if(pAdapt->PacketPoolHandle)
        NdisFreePacketPool(pAdapt->PacketPoolHandle);

    RELEASE_ADAPTER_GEN_LOCK(pAdapt);


    // Free the bound to Adapter Name
    if(pAdapt->BoundToAdapterName.Buffer)
        NdisFreeString(pAdapt->BoundToAdapterName);

    // Free all spinlocks
    NdisFreeSpinLock(&pAdapt->AdapterLock);

    //
    // Signal anyone waiting for this to happen
    //
    if (pAdapt->pCleanupEvent) {
        NdisSetEvent(pAdapt->pCleanupEvent);
    }

    // since memory is not cleared
    pAdapt->ulSignature = atmsm_dead_adapter_signature;

    // free the adapter itself
    AtmSmFreeMem(pAdapt);

    TraceOut(AtmSmDeallocateAdapter);
}


BOOLEAN
AtmSmReferenceAdapter(
    PATMSM_ADAPTER    pAdapt
    )
/*++

Routine Description:
    To keep a refcount on the adapter.

Arguments:
    pAdapt      - adapter

Return Value:
    TRUE    - if the adapter is valid and not closing
    FALSE   - adapter is closing
--*/
{
    BOOLEAN rc = FALSE;

    ASSERT(pAdapt);

    DbgInfo(("AtmSmReferenceAdapter - pAdapt - 0x%X\n", pAdapt));

    if(!pAdapt)
        return FALSE;

    ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

    if(0 == (pAdapt->ulFlags & ADAPT_CLOSING)){

        pAdapt->ulRefCount++;
        rc = TRUE;
    }

    RELEASE_ADAPTER_GEN_LOCK(pAdapt);

    return rc;
}


LONG
AtmSmDereferenceAdapter(
    PATMSM_ADAPTER    pAdapt
    )
/*++

Routine Description:
    To keep a refcount on the adapter.  If the reference drops to 0
    we free the adapter.

Arguments:
    pAdapt      - adapter

Return Value:
    The new Refcount 
--*/
{
    ULONG    ulRet;

    TraceIn(AtmSmDereferenceAdapter);

    DbgInfo(("AtmSmDereferenceAdapter - pAdapt - 0x%X\n", pAdapt));

    ASSERT(pAdapt);

    if(pAdapt){

        ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);
        
        ulRet = --pAdapt->ulRefCount;

        RELEASE_ADAPTER_GEN_LOCK(pAdapt);

        // There are no more references on this adapter
        // hence free it
        if(0 == ulRet)
            AtmSmDeallocateAdapter(pAdapt);

    } else
        ulRet = 0;

    TraceOut(AtmSmDereferenceAdapter);

    return ulRet;
}


NDIS_STATUS
AtmSmQueryAdapterATMAddresses(
    PATMSM_ADAPTER    pAdapt
    )
/*++

Routine Description:
    Send a request to the Call Manager to retrieve the ATM address
    registered with the switch on the given interface.

Arguments:
    pAdapt      - adapter

Return Value:
--*/
{
    PNDIS_REQUEST       pNdisRequest;
    PCO_ADDRESS         pCoAddr;
    NDIS_STATUS         Status;
    UINT                Size;

    TraceIn(AtmSmQueryAdapterATMAddresses);
    
    //
    // Allocate a request to query the configured address
    //
    Size = sizeof(NDIS_REQUEST) + sizeof(CO_ADDRESS_LIST) + sizeof(CO_ADDRESS)
                                                        + sizeof(ATM_ADDRESS);
    AtmSmAllocMem(&pNdisRequest, PNDIS_REQUEST, Size);
    
    if (NULL == pNdisRequest){
        DbgErr(("Failed to get Adapter ATM Address - STATUS_RESOURCES\n"));
        return  NDIS_STATUS_RESOURCES;
    }

    NdisZeroMemory(pNdisRequest, Size);

    pNdisRequest->RequestType = NdisRequestQueryInformation;
    pNdisRequest->DATA.QUERY_INFORMATION.Oid = OID_CO_GET_ADDRESSES;
    pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = 
                                ((PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST));

    pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = 
                                                Size - sizeof(NDIS_REQUEST);

    Status = NdisCoRequest(pAdapt->NdisBindingHandle,
                           pAdapt->NdisAfHandle,
                           NULL,
                           NULL,
                           pNdisRequest);

    if (NDIS_STATUS_PENDING != Status) {

        AtmSmCoRequestComplete(Status, pAdapt, NULL, NULL, pNdisRequest);

    }

    TraceOut(AtmSmQueryAdapterATMAddresses);
   
    return Status;
}


VOID
AtmSmQueryAdapter(
    IN  PATMSM_ADAPTER  pAdapt
    )
/*++

Routine Description:

    Query the miniport we are bound to for the following info:
    1. Line rate
    2. Max packet size

    These will overwrite the defaults we set up when creating the
    adapter.

Arguments:

    pAdapt       Pointer to the adapter

Return Value:

    None

--*/
{

    TraceIn(AtmSmQueryAdapter);

    AtmSmSendAdapterNdisRequest(
                        pAdapt,
                        OID_GEN_CO_LINK_SPEED,
                        (PVOID)&(pAdapt->LinkSpeed),
                        sizeof(NDIS_CO_LINK_SPEED));

    AtmSmSendAdapterNdisRequest(
                        pAdapt,
                        OID_ATM_MAX_AAL5_PACKET_SIZE,
                        (PVOID)&(pAdapt->MaxPacketSize),
                        sizeof(ULONG));

    TraceOut(AtmSmQueryAdapter);

}



NDIS_STATUS
AtmSmPnPEvent(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNET_PNP_EVENT          pNetPnPEvent
    )
/*++

Routine Description:

    This is the NDIS entry point called when NDIS wants to inform
    us about a PNP/PM event happening on an adapter. 

Arguments:

    ProtocolBindingContext  - Our context for this adapter binding, which
                              is a pointer to an ATMSM Adapter structure.

    pNetPnPEvent            - Pointer to the event.

Return Value:

    None

--*/
{
    PATMSM_ADAPTER              pAdapt      = 
                                 (PATMSM_ADAPTER)ProtocolBindingContext;
    PNET_DEVICE_POWER_STATE     pPowerState = 
                                 (PNET_DEVICE_POWER_STATE)pNetPnPEvent->Buffer;
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;


    TraceIn(AtmSmPnPEvent);

    do {

        switch (pNetPnPEvent->NetEvent) {

            case NetEventSetPower:

                switch (*pPowerState) {
                    case NetDeviceStateD0:
                        Status = NDIS_STATUS_SUCCESS;
                        break;

                    default:
                        //
                        // We can't suspend, so we ask NDIS to Unbind us by
                        // returning this status:
                        //
                        Status = NDIS_STATUS_NOT_SUPPORTED;
                        break;
                }
                break;

            case NetEventQueryPower:    // FALLTHRU
            case NetEventQueryRemoveDevice: // FALLTHRU
            case NetEventCancelRemoveDevice:
                Status = NDIS_STATUS_SUCCESS;
                break;

            case NetEventReconfigure:

                if (pAdapt) {

//                    Status = AtmSmReadAdapterConfiguration(pAdapt);

                } else {
                    //
                    // Global changes
                    //
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;

            case NetEventBindList:
            default:
                Status = NDIS_STATUS_NOT_SUPPORTED;
                break;
        }

        break;
    }
    while (FALSE);

    TraceOut(AtmSmPnPEvent);

    return (Status);
}



VOID
AtmSmStatus(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DbgWarn(("StatusIndication: Ignored\n"));
}


VOID
AtmSmReceiveComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    return;
}


VOID
AtmSmStatusComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DbgWarn(("StatusComplete: Ignored\n"));
}


VOID
AtmSmCoStatus(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             ProtocolVcContext   OPTIONAL,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DbgWarn(("CoStatus: Ignored\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\samples\atmsmpl\driver\globals.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation, All Rights Reserved.

Module Name:

    globals.c

Abstract:
    
    This module contains all the global variables defined for the driver

Author:

    Anil Francis Thomas (10/98)

Environment:

    Kernel

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop


ATMSM_GLOBAL        AtmSmGlobal;

#if DBG
UINT                AtmSmDebugFlag = 0xFFFFFFF2;
#endif


ATM_BLLI_IE         AtmSmDefaultBlli =
                        {
                            (ULONG)BLLI_L2_LLC,  // Layer2Protocol
                            (UCHAR)0x00,         // Layer2Mode
                            (UCHAR)0x00,         // Layer2WindowSize
                            (ULONG)0x00000000,   // Layer2UserSpecifiedProtocol
                            (ULONG)SAP_FIELD_ABSENT,  // Layer3Protocol
                            (UCHAR)0x00,         // Layer3Mode
                            (UCHAR)0x00,         // Layer3DefaultPacketSize
                            (UCHAR)0x00,         // Layer3PacketWindowSize
                            (ULONG)0x00000000,   // Layer3UserSpecifiedProtocol
                            (ULONG)0x00000000,   // Layer3IPI,
                            (UCHAR)0x00,         // SnapID[5]
                            (UCHAR)0x00,
                            (UCHAR)0x00,
                            (UCHAR)0x00,
                            (UCHAR)0x00
                        };


ATM_BHLI_IE         AtmSmDefaultBhli =
                        {
                            (ULONG)SAP_FIELD_ABSENT,   // HighLayerInfoType
                            (ULONG)0x00000000,   // HighLayerInfoLength
                            (UCHAR)0x00,         // HighLayerInfo[8]
                            (UCHAR)0x00,
                            (UCHAR)0x00,
                            (UCHAR)0x00,
                            (UCHAR)0x00,
                            (UCHAR)0x00,
                            (UCHAR)0x00,
                            (UCHAR)0x00
                        };

ATMSM_FLOW_SPEC     AtmSmDefaultVCFlowSpec =
                        {
                            DEFAULT_SEND_BANDWIDTH,
                            DEFAULT_MAX_PACKET_SIZE,
                            0,      // we are setting up unidirectional VCs
                            0,      // we are setting up unidirectional VCs
                            SERVICETYPE_BESTEFFORT
                        };

PATMSM_IOCTL_FUNCS   AtmSmFuncProcessIoctl[ATMSM_MAX_FUNCTION_CODE+1]  = 
                        {
                            AtmSmIoctlEnumerateAdapters,
                            AtmSmIoctlOpenForRecv,
                            AtmSmIoctlRecvData,
                            AtmSmIoctlCloseRecvHandle,
                            AtmSmIoctlConnectToDsts,
                            AtmSmIoctlSendToDsts,
                            AtmSmIoctlCloseSendHandle
                        };
                        
//
// Lookup table to verify incoming IOCTL codes.
//
ULONG AtmSmIoctlTable[ATMSM_NUM_IOCTLS] =
{
   IOCTL_ENUMERATE_ADAPTERS,     //DIOC_ENUMERATE_ADAPTERS,
   IOCTL_OPEN_FOR_RECV,          //DIOC_OPEN_FOR_RECV,     
   IOCTL_RECV_DATA,              //DIOC_RECV_DATA,         
   IOCTL_CLOSE_RECV_HANDLE,      //DIOC_CLOSE_RECV_HANDLE, 
   IOCTL_CONNECT_TO_DSTS,        //DIOC_CONNECT_TO_DSTS,   
   IOCTL_SEND_TO_DSTS,           //DIOC_SEND_TO_DSTS,      
   IOCTL_CLOSE_SEND_HANDLE       //DIOC_CLOSE_SEND_HANDLE, 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\samples\atmsmpl\driver\callmgr.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation, All Rights Reserved.

Module Name:

    callmgr.c

Abstract:

    This module contains the interface of the driver with the Call Manager.

Author:

    Anil Francis Thomas (10/98)

Environment:

    Kernel

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop


#define MODULE_ID    MODULE_CALLMGR

VOID
AtmSmCoAfRegisterNotify(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  PCO_ADDRESS_FAMILY          pAddressFamily
    )
/*++

Routine Description:

    This routine is called by NDIS when a Call manager registers its support
    for an Address Family over an adapter. If this is the Address Family we
    are interested in (UNI 3.1), then we register our SAP on this adapter.

Arguments:

    ProtocolBindingContext  - our context passed in NdisOpenAdapter, which is
                              a pointer to our Adapter structure.
    pAddressFamily          - points to a structure describing the 
                              Address Family registered by a Call Manager.

Return Value:

    None

--*/
{
    PATMSM_ADAPTER              pAdapt = (PATMSM_ADAPTER)
                                                ProtocolBindingContext;
    NDIS_STATUS                 Status;
    NDIS_CLIENT_CHARACTERISTICS Chars;

    TraceIn(AtmSmCoAfRegisterNotify);

    if(!AtmSmReferenceAdapter(pAdapt))
        return;

    if ((pAddressFamily->AddressFamily   == CO_ADDRESS_FAMILY_Q2931)   &&
        (pAddressFamily->MajorVersion    == 3)                         &&
        (pAddressFamily->MinorVersion    == 1)                         &&
        (pAdapt->NdisAfHandle           == NULL))
    {
        DbgInfo(("AfNotify: Adapter %X\n", pAdapt));

        //
        // We successfully opened the adapter. Now open the address-family
        //
        pAdapt->AddrFamily.AddressFamily = CO_ADDRESS_FAMILY_Q2931;
        pAdapt->AddrFamily.MajorVersion  = 3;
        pAdapt->AddrFamily.MinorVersion  = 1;

        NdisZeroMemory(&Chars, sizeof(NDIS_CLIENT_CHARACTERISTICS));
        Chars.MajorVersion = 5;
        Chars.MinorVersion = 0;
        Chars.ClCreateVcHandler         = AtmSmCreateVc;
        Chars.ClDeleteVcHandler         = AtmSmDeleteVc;
        Chars.ClRequestHandler          = AtmSmCoRequest;
        Chars.ClRequestCompleteHandler  = AtmSmCoRequestComplete;
        Chars.ClOpenAfCompleteHandler   = AtmSmOpenAfComplete;
        Chars.ClCloseAfCompleteHandler  = AtmSmCloseAfComplete;
        Chars.ClRegisterSapCompleteHandler   = AtmSmRegisterSapComplete;
        Chars.ClDeregisterSapCompleteHandler = AtmSmDeregisterSapComplete;
        Chars.ClMakeCallCompleteHandler      = AtmSmMakeCallComplete;
        Chars.ClModifyCallQoSCompleteHandler = NULL;
        Chars.ClCloseCallCompleteHandler = AtmSmCloseCallComplete;
        Chars.ClAddPartyCompleteHandler  = AtmSmAddPartyComplete;
        Chars.ClDropPartyCompleteHandler = AtmSmDropPartyComplete;
        Chars.ClIncomingCallHandler      = AtmSmIncomingCall;
        Chars.ClIncomingCallQoSChangeHandler = AtmSmIncomingCallQoSChange;
        Chars.ClIncomingCloseCallHandler = AtmSmIncomingCloseCall;
        Chars.ClIncomingDropPartyHandler = AtmSmIncomingDropParty;
        Chars.ClCallConnectedHandler     = AtmSmCallConnected;

        Status = NdisClOpenAddressFamily(pAdapt->NdisBindingHandle,
                                         &pAdapt->AddrFamily,
                                         pAdapt,  // Use this as the Af context
                                         &Chars,
                                         sizeof(NDIS_CLIENT_CHARACTERISTICS),
                                         &pAdapt->NdisAfHandle);
        if (NDIS_STATUS_PENDING != Status)
        {
            AtmSmOpenAfComplete(Status, pAdapt, pAdapt->NdisAfHandle);
        }

    } else {

        // Not UNI3.1, hence remove the reference we added above
        AtmSmDereferenceAdapter(pAdapt);
    }

    TraceOut(AtmSmCoAfRegisterNotify);
}


VOID
AtmSmOpenAfComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             NdisAfHandle
    )
/*++

Routine Description:

    Completion processing for the OpenAf call.

Arguments:

    Status              Status of OpenAf
    ProtocolAfContext   Pointer to the pAdapt
    NdisAfHandle        Ndis Handle to refer to this Af

Return Value:


--*/
{
    PATMSM_ADAPTER  pAdapt= (PATMSM_ADAPTER)ProtocolAfContext;

    TraceIn(AtmSmOpenAfComplete);

    if (NDIS_STATUS_SUCCESS == Status){

        pAdapt->NdisAfHandle = NdisAfHandle;

        pAdapt->ulFlags |= ADAPT_AF_OPENED;

        //
        // Now register our SAP on this interface
        //
        Status = AtmSmRegisterSap(pAdapt);

    } else {

        DbgErr(("Opening of Address Family Failed! Status - 0x%X\n", Status));
    }

    if ((Status != NDIS_STATUS_SUCCESS) && 
                (Status != NDIS_STATUS_PENDING)){

        //
        // Close Address family  (This results in a dereference)
        //
        Status = NdisClCloseAddressFamily(pAdapt->NdisAfHandle);
        if (NDIS_STATUS_PENDING != Status){

            AtmSmCloseAfComplete(Status, pAdapt);
        }

        //
        // Close Adapter (This results in a dereference)
        //
        NdisCloseAdapter(&Status, pAdapt->NdisBindingHandle);
        if (NDIS_STATUS_PENDING != Status){

            AtmSmCloseAdapterComplete(pAdapt, Status);
        }

        // if synchronous - by now the adapter structure wll be freed
    }

    TraceOut(AtmSmOpenAfComplete);
}


NDIS_STATUS
AtmSmRegisterSap(
    IN  PATMSM_ADAPTER  pAdapt
    )
/*++

Routine Description:
    Register the Sap for receiving incoming calls. 

Arguments:

Return Value:

--*/
{
    ULONG           ulSize;
    NDIS_STATUS     Status;
    PATM_SAP        pAtmSap;
    PATM_ADDRESS    pAtmAddress;

    TraceIn(AtmSmRegisterSap);

    do
    {
        //
        // Allocate memory for registering the SAP, if doing it for the 
        // first time.
        //
        ulSize = sizeof(CO_SAP) + sizeof(ATM_SAP) + sizeof(ATM_ADDRESS);

        if (NULL == pAdapt->pSap){

            AtmSmAllocMem(&pAdapt->pSap, PCO_SAP, ulSize);

        }

        if (NULL == pAdapt->pSap){

            Status = NDIS_STATUS_RESOURCES;
            DbgErr(("Failed to allocate memory for Sap\n"));
            break;
        }

        NdisZeroMemory(pAdapt->pSap, ulSize);

        pAdapt->pSap->SapType    = SAP_TYPE_NSAP;
        pAdapt->pSap->SapLength  = sizeof(ATM_SAP) + sizeof(ATM_ADDRESS);

        pAtmSap     = (PATM_SAP)pAdapt->pSap->Sap;
        pAtmAddress = (PATM_ADDRESS)(pAtmSap->Addresses);

        //
        //  Fill in the ATM SAP with default values
        //
        NdisMoveMemory(&pAtmSap->Blli, &AtmSmDefaultBlli, sizeof(ATM_BLLI_IE));
        NdisMoveMemory(&pAtmSap->Bhli, &AtmSmDefaultBhli, sizeof(ATM_BHLI_IE));

        //
        //  ATM Address to "listen" on: Wild card everything except the SEL.
        //
        pAtmSap->NumberOfAddresses  = 1;
        pAtmAddress->AddressType    = SAP_FIELD_ANY_AESA_REST;
        pAtmAddress->NumberOfDigits = ATM_ADDRESS_LENGTH;
        pAtmAddress->Address[ATM_ADDRESS_LENGTH-1]  = pAdapt->SelByte;

        Status = NdisClRegisterSap(pAdapt->NdisAfHandle,
                                   pAdapt,
                                   pAdapt->pSap,
                                   &pAdapt->NdisSapHandle);

        if (Status != NDIS_STATUS_PENDING){

            AtmSmRegisterSapComplete(Status,
                                    pAdapt,
                                    pAdapt->pSap,
                                    pAdapt->NdisSapHandle);
        }
    } while (FALSE);

    if ((Status != NDIS_STATUS_SUCCESS) && 
                (Status != NDIS_STATUS_PENDING)){

        DbgErr(("Registering Sap Failed! Status - 0x%X\n", Status));

        // cleanup done after return
    }

    TraceOut(AtmSmRegisterSap);

    return Status;
}



VOID
AtmSmRegisterSapComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolSapContext,
    IN  PCO_SAP                 pSap,
    IN  NDIS_HANDLE             NdisSapHandle
    )
/*++

Routine Description:
    Called by NDIS or us when the Sap registration completes.

Arguments:


Return Value:


--*/
{
    PATMSM_ADAPTER  pAdapt = (PATMSM_ADAPTER)ProtocolSapContext;

    TraceIn(AtmSmRegisterSapComplete);

    ASSERT (pSap == pAdapt->pSap);

    if (NDIS_STATUS_SUCCESS != Status){

        DbgErr(("RegisterSapComplete failed (%x): Adapter %x\n",
                                                        Status, pAdapt));
        AtmSmFreeMem(pAdapt->pSap);
        pAdapt->pSap = NULL;

    } else {

        ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

        pAdapt->NdisSapHandle  = NdisSapHandle;
        pAdapt->ulFlags       |= ADAPT_SAP_REGISTERED;

        RELEASE_ADAPTER_GEN_LOCK(pAdapt);

    }

    TraceOut(AtmSmRegisterSapComplete);
}


VOID
AtmSmDeregisterSapComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolSapContext
    )
/*++

Routine Description:
    Called by NDIS or us when the Sap Deregistration completes.

Arguments:


Return Value:


--*/
{
    PATMSM_ADAPTER   pAdapt = (PATMSM_ADAPTER)ProtocolSapContext;

    TraceIn(AtmSmDeregisterSapComplete);

    pAdapt->ulFlags &= ~ADAPT_SAP_REGISTERED;

    pAdapt->NdisSapHandle = NULL;

    AtmSmFreeMem(pAdapt->pSap);

    pAdapt->pSap = NULL;

    TraceOut(AtmSmDeregisterSapComplete);
}


VOID
AtmSmCloseAfComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolAfContext
    )
/*++

Routine Description:
    Called by NDIS or us when closing of AF completes.

Arguments:


Return Value:


--*/
{
    PATMSM_ADAPTER   pAdapt = (PATMSM_ADAPTER)ProtocolAfContext;

    pAdapt->ulFlags &= ~ADAPT_AF_OPENED;

    pAdapt->NdisAfHandle = NULL;

    DbgInfo(("CloseAfComplete: pAdapt %x, Flags %x, Ref %x\n",
                    pAdapt, pAdapt->ulFlags, pAdapt->ulRefCount));

    //
    // Nothing much to do except dereference the pAdapt
    //
    AtmSmDereferenceAdapter(pAdapt);
}


NDIS_STATUS
AtmSmCreateVc(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             NdisVcHandle,
    OUT PNDIS_HANDLE            ProtocolVcContext
    )
/*++

Routine Description:

    Entry point called by NDIS when the Call Manager wants to create
    a new endpoint (VC). We allocate a new VC structure, and return 
    a pointer to it as our VC context.

Arguments:

    ProtocolAfContext   - Actually a pointer to the ATMSM adapter structure
    NdisVcHandle        - Handle for this VC for all future references
    ProtocolVcContext  - Place where we (protocol) return our context for the VC

Return Value:

    NDIS_STATUS_SUCCESS if we could create a VC
    NDIS_STATUS_RESOURCES otherwise
--*/
{
    PATMSM_ADAPTER  pAdapt = (PATMSM_ADAPTER)ProtocolAfContext;
    PATMSM_VC       pVc;
    NDIS_STATUS     Status;

    DbgInfo(("CreateVc: NdisVcHandle %x, Adapt - %x\n", NdisVcHandle, pAdapt));

    *ProtocolVcContext  = NULL;


    Status = AtmSmAllocVc(pAdapt, &pVc, VC_TYPE_INCOMING, NdisVcHandle);

    if(NDIS_STATUS_SUCCESS == Status){

        *ProtocolVcContext  = pVc;
    }

    return Status;
}


NDIS_STATUS
AtmSmDeleteVc(
    IN  NDIS_HANDLE                 ProtocolVcContext
    )
/*++

Routine Description:

    Our Delete VC handler. This VC would have been allocated as a result
    of a previous entry into our CreateVcHandler, and possibly used for
    an incoming call.

    We dereference the VC here.

Arguments:

    ProtocolVcContext   - pointer to our VC structure

Return Value:

    NDIS_STATUS_SUCCESS always

--*/
{
    PATMSM_VC  pVc = (PATMSM_VC)ProtocolVcContext;

    DbgInfo(("DeleteVc: For Vc %lx\n", pVc));

    pVc->NdisVcHandle = NULL;
    AtmSmDereferenceVc(pVc);

    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
AtmSmIncomingCall(
    IN  NDIS_HANDLE             ProtocolSapContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    )
/*++

Routine Description:

    Handler for incoming call. We accept the call unless we are shutting down 
    and then do the actual processing when the call processing completes.

Arguments:

    ProtocolSapContext      Pointer to the pAdapt
    ProtocolVcContext       Pointer to the Vc
    CallParameters          Call Parameters

Return Value:


--*/
{
    PATMSM_ADAPTER              pAdapt = (PATMSM_ADAPTER)ProtocolSapContext;
    PATMSM_VC                   pVc    = (PATMSM_VC)ProtocolVcContext;
    Q2931_CALLMGR_PARAMETERS UNALIGNED * CallMgrSpecific;

    ASSERT (pVc->pAdapt == pAdapt);

    DbgInfo(("AtmSmIncomingCall: On Vc %lx\n", pVc));

    //
    // Mark the Vc to indicate the call processing is underway
    //
    ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

    ASSERT ((pVc->ulFlags & (ATMSM_VC_ACTIVE | ATMSM_VC_CALLPROCESSING)) == 0);

    ATMSM_SET_VC_STATE(pVc, ATMSM_VC_CALLPROCESSING);

    RELEASE_ADAPTER_GEN_LOCK(pAdapt);

    //
    // Get the remote atm address from the call-parameters
    //
    CallMgrSpecific = (PQ2931_CALLMGR_PARAMETERS)&CallParameters->
                            CallMgrParameters->CallMgrSpecific.Parameters[0];

    pVc->HwAddr.Address = CallMgrSpecific->CallingParty;

    //
    // Get the max size of packets we can send on this VC, from the
    // AAL5 parameters. Limit it to the size our miniport can support.
    //
    pVc->MaxSendSize = pAdapt->MaxPacketSize; // default

    if (CallMgrSpecific->InfoElementCount > 0) {

        Q2931_IE UNALIGNED *            pIe;
        AAL5_PARAMETERS UNALIGNED *     pAal5;
        ULONG                           IeCount;

        pIe = (PQ2931_IE)CallMgrSpecific->InfoElements;
        for (IeCount = CallMgrSpecific->InfoElementCount;
             IeCount != 0;
             IeCount--) {

            if (pIe->IEType == IE_AALParameters) {

                pAal5 = &(((PAAL_PARAMETERS_IE)pIe->IE)->
                                    AALSpecificParameters.AAL5Parameters);
                //
                // Make sure we don't send more than what the caller can handle.
                //
                if (pAal5->ForwardMaxCPCSSDUSize < pVc->MaxSendSize) {

                    pVc->MaxSendSize = pAal5->ForwardMaxCPCSSDUSize;
                }

                //
                // Make sure the caller doesn't send more than what our
                // miniport can handle.
                //
                if (pAal5->BackwardMaxCPCSSDUSize > pAdapt->MaxPacketSize) {

                    pAal5->BackwardMaxCPCSSDUSize = pAdapt->MaxPacketSize;
                }
                break;
            }
            pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
        }
    }


    return NDIS_STATUS_SUCCESS;
}


VOID
AtmSmCallConnected(
    IN  NDIS_HANDLE             ProtocolVcContext
    )
/*++

Routine Description:

    Last hand-shake in the incoming call path. Move the Vc to the list of 
    active calls.

Arguments:

    ProtocolVcContext   Pointer to VC

Return Value:

    None.

--*/
{
    PATMSM_VC       pVc     = (PATMSM_VC)ProtocolVcContext;
    PATMSM_ADAPTER  pAdapt  = pVc->pAdapt;

    DbgInfo(("AtmSmCallConnected: On pVc %x  pAdapt %x\n", pVc, pAdapt));

    pAdapt = pVc->pAdapt;

    // now we add a reference to the VC
    AtmSmReferenceVc(pVc);

    ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

    ASSERT(ATMSM_GET_VC_STATE(pVc) != ATMSM_VC_ACTIVE);

    ASSERT(ATMSM_GET_VC_STATE(pVc) == ATMSM_VC_CALLPROCESSING);

    ATMSM_SET_VC_STATE(pVc, ATMSM_VC_ACTIVE);

    // remove the Vc from the inactive list
    RemoveEntryList(&pVc->List);

    // insert the vc into the active list
    InsertHeadList(&pAdapt->ActiveVcHead, &pVc->List);

    RELEASE_ADAPTER_GEN_LOCK(pAdapt);

}


VOID
AtmSmMakeCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
/*++

Routine Description:

    Handle completion of an earlier call to NdisClMakeCall. If the call has
    succeeded and if this is a point to multipoint call, initiate Addparty on 
    the rest of the addresses. If it is not multipoint, then send any packets
    pending on the call.

Arguments:

    Status              Result of NdisClMakeCall
    ProtocolVcContext   Pointer to P-P or PMP Vc
    NdisPartyHandle     If successful, the handle for this party
    CallParameters      Pointer to Call parameters

Return Value:

    None.

--*/
{
    PATMSM_VC           pVc     = (PATMSM_VC)ProtocolVcContext;
    PATMSM_ADAPTER      pAdapt  = (PATMSM_ADAPTER)pVc->pAdapt;
    PATMSM_PMP_MEMBER   pMember;
    BOOLEAN             bLockReleased = FALSE;


    DbgInfo(("MakeCallComplete: Status %x, pVc %x, VC flag %x\n",
                        Status, pVc, pVc->ulFlags));

    // Free the call parameters
    AtmSmFreeMem(CallParameters);

    //
    // If this is a point to point connection and we succeeded in connecting
    // then send the packets pending on the VC.
    //
    if(VC_TYPE_PMP_OUTGOING != pVc->VcType){

        PIRP pIrp;


        if(NDIS_STATUS_SUCCESS == Status){
            // successfully connected the P-P call, send any pending packets

            ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

            ATMSM_SET_VC_STATE(pVc, ATMSM_VC_ACTIVE);

            DbgInfo(("PP VC 0x%x successfully connected to destination\n", 
                                                                         pVc));

            // now complete IRP that started this connect call
            pIrp = pVc->pConnectIrp;
            pVc->pConnectIrp = NULL;

            ASSERT(pIrp);

            // remove the Vc from the inactive list
            RemoveEntryList(&pVc->List);

            // insert the vc into the active list
            InsertHeadList(&pAdapt->ActiveVcHead, &pVc->List);

            RELEASE_ADAPTER_GEN_LOCK(pAdapt);

            if(pIrp){

                pIrp->IoStatus.Status = STATUS_SUCCESS;

                // now set the connect context
                *(PHANDLE)(pIrp->AssociatedIrp.SystemBuffer) = (HANDLE)pVc;
                pIrp->IoStatus.Information = sizeof(HANDLE);

                IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
            }

            AtmSmSendQueuedPacketsOnVc(pVc);

        } else {

            // failed to connect the call.  

            // now complete IRP that started this connect call
            PIRP pIrp = pVc->pConnectIrp;
            pVc->pConnectIrp = NULL;

            ASSERT(pIrp);

            if(pIrp){

                pIrp->IoStatus.Status = Status;

                pIrp->IoStatus.Information = 0;

                IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
            }

            DbgInfo(("PP VC 0x%x failed to connect to destination - Status - "
                "0x%x\n", pVc, Status));

            // Cleanup the VC - remove the reference added at create
            AtmSmDereferenceVc(pVc);
        }

        return;
    }


    //
    // This is the completion of the first Make call on a PMP.  If the first
    // has succeeded, we add the rest. If the first one failed, we remove it 
    // and try to make a call on another one.
    //

    ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

    //
    // Get the member we were trying to connect to.
    //
    for (pMember = pVc->pPMPMembers; pMember; pMember = pMember->pNext)
        if(ATMSM_GET_MEMBER_STATE(pMember) == ATMSM_MEMBER_CONNECTING)
            break;

    ASSERT(NULL != pMember);

    pVc->ulNumConnectingMembers--;

    if (NDIS_STATUS_SUCCESS == Status){

        ASSERT(NULL != NdisPartyHandle);

        ATMSM_SET_MEMBER_STATE(pMember, ATMSM_MEMBER_CONNECTED);

        pMember->NdisPartyHandle = NdisPartyHandle;

        pVc->ulNumActiveMembers++;

        //
        // check if the member was invalidated during the call setup
        // if so, remove this guy
        //
        if(ATMSM_IS_MEMBER_INVALID(pMember)){

            RELEASE_ADAPTER_GEN_LOCK(pAdapt);
            bLockReleased = TRUE;

            // This member was invalidated, now drop him off
            AtmSmDropMemberFromVc(pVc, pMember); 
        }
    }
    else
    {
        DbgWarn(("MakeCall error %x, pMember %x to addr:", Status, pMember));

        DumpATMAddress(ATMSMD_ERR, "", &pMember->HwAddr.Address);

        RELEASE_ADAPTER_GEN_LOCK(pAdapt);
        bLockReleased = TRUE;

        //
        // Connection failed. Delete this member from our list of members.
        //
        DeleteMemberInfoFromVc(pVc, pMember);
    }

    if(!bLockReleased) {
    
        RELEASE_ADAPTER_GEN_LOCK(pAdapt);
    }

    //
    // Add anymore members remaining
    //
    AtmSmConnectToPMPDestinations(pVc);

    return;
}


VOID
AtmSmIncomingCloseCall(
    IN  NDIS_STATUS             CloseStatus,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PVOID                   CloseData   OPTIONAL,
    IN  UINT                    Size        OPTIONAL
    )
/*++

Routine Description:

    Indication of an incoming close call from the network. If this
    is not an outgoing PMP VC, then we mark the VC as inactive, and
    move it to the Inactive VC list. If this is on PMP Vc,
    there must be only one party on the PMP connection. We update
    that member's state.

    In any case, we call NdisClCloseCall to complete the handshake.

Arguments:

    CloseStatus         Status of Close
    ProtocolVcContext   Pointer to VC 
    CloseData           Optional Close data (IGNORED)
    Size                Size of Optional Close Data (OPTIONAL)

Return Value:

    None

--*/
{
    PATMSM_VC           pVc             = (PATMSM_VC)ProtocolVcContext;
    PATMSM_ADAPTER      pAdapt          = pVc->pAdapt;
    NDIS_HANDLE         NdisVcHandle    = pVc->NdisVcHandle;
    NDIS_HANDLE         NdisPartyHandle;
    PATMSM_PMP_MEMBER   pMember;
    NDIS_STATUS         Status;


    if (VC_TYPE_PMP_OUTGOING != pVc->VcType){


        DbgInfo(("AtmSmIncomingCloseCall: On Vc 0x%x\n",
                                        ProtocolVcContext));

        ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

        ASSERT (ATMSM_GET_VC_STATE(pVc) != ATMSM_VC_CLOSING);

        NdisPartyHandle = NULL;


        ATMSM_SET_VC_STATE(pVc, ATMSM_VC_CLOSING);


        ASSERT(pVc->HwAddr.SubAddress == NULL);

        RemoveEntryList(&pVc->List);
        InsertHeadList(&pAdapt->InactiveVcHead, &pVc->List);

        RELEASE_ADAPTER_GEN_LOCK(pAdapt);

        pMember = NULL;

        Status = NdisClCloseCall(NdisVcHandle, NdisPartyHandle, NULL, 0);
        
        DbgInfo(("NdisCloseCall Status - 0x%X Vc - 0x%X\n", Status, pVc));

        if (Status != NDIS_STATUS_PENDING){

            AtmSmCloseCallComplete(Status, pVc, (NDIS_HANDLE)pMember);
        }

    } else {

        //
        // May be the net has gone bad
        //
        DbgInfo(("PMP IncomingCloseCall: On Vc %x\n", ProtocolVcContext));

        AtmSmDisconnectVc(pVc);
    }
}


VOID
AtmSmCloseCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             ProtocolPartyContext OPTIONAL
    )
/*++

Routine Description:

    This is called to complete our call to NdisClCloseCall. If the VC
    is other than outgoing PMP, we update its state and dereference it

    If this is an outgoing PMP, we delete the last member

Arguments:

    Status                  Status of NdisClCloseCall
    ProtocolVcContext       Pointer to our VC structure
    ProtocolPartyContext    If the VC is PMP Vc, this is a pointer
                            to the Member that was disconnected.

Return Value:

    None

--*/
{
    PATMSM_VC       pVc             = (PATMSM_VC)ProtocolVcContext;
    PATMSM_ADAPTER  pAdapt          = pVc->pAdapt;
    BOOLEAN         bStopping;

    DbgInfo(("AtmSmCloseCallComplete: On Vc %lx\n", pVc));

    ASSERT(Status == NDIS_STATUS_SUCCESS);

    switch(pVc->VcType){

        case VC_TYPE_INCOMING:
        case VC_TYPE_PP_OUTGOING:

            // Both incoming call and outgoing PP calls

            ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

            ASSERT (ATMSM_GET_VC_STATE(pVc) == ATMSM_VC_CLOSING);
            
            ATMSM_SET_VC_STATE(pVc, ATMSM_VC_CLOSED);

            RELEASE_ADAPTER_GEN_LOCK(pAdapt);

            // Now dereference the VC
            AtmSmDereferenceVc(pVc);

        break;


        case VC_TYPE_PMP_OUTGOING: {

            // Outgoing PMP

            ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

            pVc->ulNumDroppingMembers--;

            ATMSM_SET_VC_STATE(pVc, ATMSM_VC_CLOSED);

            ASSERT(1 == pVc->ulNumTotalMembers);
            ASSERT((0 == pVc->ulNumActiveMembers)      &&
                   (0 == pVc->ulNumConnectingMembers)  &&
                   (0 == pVc->ulNumDroppingMembers));

            RELEASE_ADAPTER_GEN_LOCK(pAdapt);

            if(DeleteMemberInfoFromVc(pVc, 
                (PATMSM_PMP_MEMBER)ProtocolPartyContext)){

            }
        }

        break;

        default:
            ASSERT(FALSE);

    }
}


VOID
AtmSmAddPartyComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolPartyContext,
    IN  NDIS_HANDLE             NdisPartyHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
/*++

Routine Description:

    Completion of NdisClAddParty to add a new party to PMP Vc.
    If successful, update the member's state. Otherwise, delete it.

Arguments:

    Status                  Status of AddParty
    ProtocolPartyContext    Pointer to Member being added
    NdisPartyHandle         Valid if AddParty successful
    CallParameters          Pointer to AddParty call parameters

Return Value:

    None

--*/
{
    PATMSM_PMP_MEMBER   pMember = (PATMSM_PMP_MEMBER)ProtocolPartyContext;
    PATMSM_VC           pVc     = (PATMSM_VC)pMember->pVc;
    PATMSM_ADAPTER      pAdapt  = (PATMSM_ADAPTER)pVc->pAdapt;
    BOOLEAN             bLockReleased = FALSE;

    // Free the memory for CallParameters
    AtmSmFreeMem(CallParameters);

    DbgLoud(("AddPartyComplete: Status %x, pMember %x, NdisPartyHandle %x\n",
                    Status, pMember, NdisPartyHandle));

    ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

    pVc->ulNumConnectingMembers--;

    if (NDIS_STATUS_SUCCESS == Status){

        ATMSM_SET_MEMBER_STATE(pMember, ATMSM_MEMBER_CONNECTED);

        ASSERT(NdisPartyHandle);

        pMember->NdisPartyHandle = NdisPartyHandle;

        pVc->ulNumActiveMembers++;

        //
        // check if the member was invalidated during the call setup
        // if so, remove this guy
        //
        if(ATMSM_IS_MEMBER_INVALID(pMember)){

            RELEASE_ADAPTER_GEN_LOCK(pAdapt);
            bLockReleased = TRUE;

            // This member was invalidated, now drop him off
            AtmSmDropMemberFromVc(pVc, pMember); 
        }

    } else {

        DbgWarn(("MakeCall error %x, pMember %x to addr:", Status, pMember));

        DumpATMAddress(ATMSMD_ERR, "", &pMember->HwAddr.Address);

        RELEASE_ADAPTER_GEN_LOCK(pAdapt);
        bLockReleased = TRUE;

        //
        // Connection failed. Delete this member from our list of members.
        //
        DeleteMemberInfoFromVc(pVc, 
            (PATMSM_PMP_MEMBER)ProtocolPartyContext);

    }

    if(!bLockReleased) {
    
        RELEASE_ADAPTER_GEN_LOCK(pAdapt);
    }

    //
    // Add anymore members remaining
    //
    AtmSmConnectToPMPDestinations(pVc);

}


VOID
AtmSmDropPartyComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolPartyContext
    )
/*++

Routine Description:

    This is called to signify completion of a previous NdisClDropParty,
    to drop a member off a PMP Vc. Delete the member.

Arguments:

    Status                  Status of DropParty
    ProtocolPartyContext    Pointer to Member being dropped

Return Value:

    None.

--*/
{
    PATMSM_PMP_MEMBER   pMember = (PATMSM_PMP_MEMBER)ProtocolPartyContext;
    PATMSM_VC           pVc     = (PATMSM_VC)pMember->pVc;
    PATMSM_ADAPTER      pAdapt  = (PATMSM_ADAPTER)pVc->pAdapt;
    BOOLEAN             IsVcClosing;

    DbgInfo(("DropPartyComplete: Vc - %x Member - %x\n", pVc, pMember));

    ASSERT(Status == NDIS_STATUS_SUCCESS);

    ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

    pVc->ulNumDroppingMembers--;

    IsVcClosing = ((ATMSM_GET_VC_STATE(pVc) == ATMSM_VC_NEED_CLOSING) &&
                   (pVc->ulNumActiveMembers == 1) &&
                   ((pVc->ulNumDroppingMembers + pVc->ulNumConnectingMembers)
                                                                       == 0));
    RELEASE_ADAPTER_GEN_LOCK(pAdapt);

    //
    // Delete this member info structure
    //
    DeleteMemberInfoFromVc(pVc, pMember);

    //
    // If this VC is closing remove the last member in it
    // (This member will issue a close call).
    //
    if(IsVcClosing){

        ASSERT(1 == pVc->ulNumTotalMembers);
        
        AtmSmDropMemberFromVc(pVc, pVc->pPMPMembers);
    }
}


VOID
AtmSmIncomingDropParty(
    IN  NDIS_STATUS             DropStatus,
    IN  NDIS_HANDLE             ProtocolPartyContext,
    IN  PVOID                   CloseData   OPTIONAL,
    IN  UINT                    Size        OPTIONAL
    )
/*++

Routine Description:

    Indication that a Member has dropped off the PMP Vc
    We complete this handshake by calling NdisClDropParty.

Arguments:

    DropStatus              Status
    ProtocolPartyContext    Pointer to Member
    CloseData               Optional Close data (IGNORED)
    Size                    Size of Optional Close Data (OPTIONAL)

Return Value:

    None

--*/
{
    PATMSM_PMP_MEMBER   pMember = (PATMSM_PMP_MEMBER)ProtocolPartyContext;
    PATMSM_VC           pVc     = (PATMSM_VC)pMember->pVc;

    ASSERT(DropStatus == NDIS_STATUS_SUCCESS);

    ASSERT(ATMSM_GET_MEMBER_STATE(pMember) == ATMSM_MEMBER_CONNECTED);

    DbgInfo(("IncomingDropParty: pVc %x, pMember %x, Addr: ", 
                                                    pVc, pMember));

    DumpATMAddress(ATMSMD_INFO, "", &pMember->HwAddr.Address);

 
    AtmSmDropMemberFromVc(pVc, pMember);
}



VOID
AtmSmIncomingCallQoSChange(
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DbgWarn(("QoSChange: Ignored\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\samples\atmsmpl\driver\atmsmdrv.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation, All Rights Reserved.

Module Name:

    atmsmdrv.c

Abstract:
    
    A sample ATM Client driver.
    This sample demonstrates establishment and tear down of P-P or PMP 
    connections over ATM.

    This module contains the driver entry routine.

Author:

    Anil Francis Thomas (10/98)

Environment:

    Kernel

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

#define MODULE_ID   MODULE_INIT

#pragma NDIS_INIT_FUNCTION(DriverEntry)

VOID AtmSmUnload(
   IN  PDRIVER_OBJECT     pDriverObject
   );

VOID AtmSmInitializeGlobal(
   IN  PDRIVER_OBJECT      pDriverObject
   );

VOID AtmSmCleanupGlobal();

NTSTATUS DriverEntry(
   IN  PDRIVER_OBJECT      pDriverObject,
   IN  PUNICODE_STRING     pRegistryPath
   )
/*++

Routine Description:
    This is the "init" routine, called by the system when the AtmSmDrv
    module is loaded. We initialize all our global objects, fill in our
    Dispatch and Unload routine addresses in the driver object, and create
    a device object for receiving I/O requests.

Arguments:
    pDriverObject   - Pointer to the driver object created by the system.
    pRegistryPath   - Pointer to our global registry path. This is ignored.

Return Value:
    NT Status code: STATUS_SUCCESS if successful, error code otherwise.

--*/
{
   NDIS_STATUS                     Status;
   NDIS_PROTOCOL_CHARACTERISTICS   PChars;
   PNDIS_CONFIGURATION_PARAMETER   Param;
   PDEVICE_OBJECT                  pDeviceObject;
   UNICODE_STRING                  DeviceName;
   UNICODE_STRING                  SymbolicName;
   HANDLE                          ThreadHandle;
   int                             i;

   TraceIn(DriverEntry);

#if DBG
   DbgPrint("AtmSmDebugFlag:  Address = %p  Value = 0x%x\n", 
      &AtmSmDebugFlag, AtmSmDebugFlag);
#endif

   DbgLoud(("Sizeof TCHAR = %hu\n",sizeof(TCHAR)));

   AtmSmInitializeGlobal(pDriverObject);

   //
   // Initialize the debug memory allocator
   //
   ATMSM_INITIALIZE_AUDIT_MEM();

   //
   //  Initialize the Driver Object.
   //
   pDriverObject->DriverUnload   = AtmSmUnload;
   pDriverObject->FastIoDispatch = NULL;
   for(i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
   {
      pDriverObject->MajorFunction[i] = AtmSmDispatch;
   }

   do
   { // break off loop

      //
      // Create a device object for atm sample module.  The device object
      // is used by the user mode app for I/O
      //
      RtlInitUnicodeString(&DeviceName, ATM_SAMPLE_CLIENT_DEVICE_NAME);

      Status = IoCreateDevice(
                  pDriverObject,
                  0,
                  &DeviceName,
                  FILE_DEVICE_NETWORK,
                  FILE_DEVICE_SECURE_OPEN,
                  FALSE,
                  &pDeviceObject
                  );
      if(NDIS_STATUS_SUCCESS != Status)
      {
         DbgErr(("Failed to create device object - Error - 0x%X\n",
            Status));
         break;
      }

      // we are doing direct IO for sends and recvs
      pDeviceObject->Flags        |= DO_DIRECT_IO;

      // Save the device object
      AtmSmGlobal.pDeviceObject    = pDeviceObject;

      AtmSmGlobal.ulInitSeqFlag   |= CREATED_IO_DEVICE;

      //
      // Set up a symbolic name for interaction with the user-mode
      // application.
      //
      RtlInitUnicodeString(&SymbolicName, ATM_SAMPLE_CLIENT_SYMBOLIC_NAME);
      IoCreateSymbolicLink(&SymbolicName, &DeviceName);

      AtmSmGlobal.ulInitSeqFlag   |= REGISTERED_SYM_NAME;

      //
      //  We are doing direct I/O.
      //
      pDeviceObject->Flags |= DO_DIRECT_IO;

      //
      // Now register the protocol.
      //
      Status = AtmSmInitializeNdis();

      if(NDIS_STATUS_SUCCESS != Status)
      {
         DbgErr(("Failed to Register protocol - Error - 0x%X\n",
            Status));
         break;
      }

      AtmSmGlobal.ulInitSeqFlag   |= REGISTERED_WITH_NDIS;

   }while(FALSE);


   if(NDIS_STATUS_SUCCESS != Status)
   {
      //
      //  Clean up will happen in Unload routine
      //
   }


   TraceOut(DriverEntry);

   return(Status);
}

VOID AtmSmUnload(
   IN  PDRIVER_OBJECT              pDriverObject
   )
/*++

Routine Description:
    This routine is called by the system prior to unloading us.
    Currently, we just undo everything we did in DriverEntry,
    that is, de-register ourselves as an NDIS protocol, and delete
    the device object we had created.

Arguments:
    pDriverObject   - Pointer to the driver object created by the system.

Return Value:
    None

--*/
{
   UNICODE_STRING          SymbolicName;
   NDIS_STATUS             Status;

   TraceIn(Unload);

   // call the shutdown handler
   AtmSmShutDown();

   // Remove the Symbolic Name created by us
   if(0 != (AtmSmGlobal.ulInitSeqFlag & REGISTERED_SYM_NAME))
   {
      RtlInitUnicodeString(&SymbolicName, ATM_SAMPLE_CLIENT_SYMBOLIC_NAME);
      IoDeleteSymbolicLink(&SymbolicName);
   }

   // Remove the Device created by us
   if(0 != (AtmSmGlobal.ulInitSeqFlag & CREATED_IO_DEVICE))
   {
      IoDeleteDevice(AtmSmGlobal.pDeviceObject);
   }

   ATMSM_SHUTDOWN_AUDIT_MEM();

   AtmSmCleanupGlobal();

   TraceOut(Unload);

   return;
}


VOID AtmSmShutDown()
/*++

Routine Description:
    Called when the system is being shutdown.
    Here we unbind all the adapters that we bound to previously.

Arguments:
    None

Return Value:
    None

--*/
{
   PATMSM_ADAPTER  pAdapt, pNextAdapt;
   NDIS_STATUS     Status;
#if DBG
   KIRQL           EntryIrql, ExitIrql;
#endif

   TraceIn(AtmSmShutDown);

   ATMSM_GET_ENTRY_IRQL(EntryIrql);

   //
   // grab the global lock and Unbind each of the adapters.
   //
   ACQUIRE_GLOBAL_LOCK();


   for(pAdapt = AtmSmGlobal.pAdapterList; pAdapt; pAdapt = pNextAdapt)
   {

      pNextAdapt = pAdapt->pAdapterNext;

      RELEASE_GLOBAL_LOCK();

      AtmSmUnbindAdapter(&Status,
         (NDIS_HANDLE)pAdapt,
         (NDIS_HANDLE)NULL);


      ACQUIRE_GLOBAL_LOCK();

   }

   RELEASE_GLOBAL_LOCK();


   // Deregister from NDIS
   if(0 != (AtmSmGlobal.ulInitSeqFlag & REGISTERED_WITH_NDIS))
      AtmSmDeinitializeNdis();

   ATMSM_CHECK_EXIT_IRQL(EntryIrql, ExitIrql);

   TraceOut(AtmSmShutDown);
}


VOID AtmSmInitializeGlobal(
   IN  PDRIVER_OBJECT      pDriverObject
   )
{
   NdisZeroMemory(&AtmSmGlobal, sizeof(ATMSM_GLOBAL));

   AtmSmGlobal.ulSignature = atmsm_global_signature;

   AtmSmGlobal.pDriverObject = pDriverObject;

   NdisAllocateSpinLock(&AtmSmGlobal.Lock);
}


VOID AtmSmCleanupGlobal()
{
   NdisFreeSpinLock(&AtmSmGlobal.Lock);
}

NDIS_STATUS AtmSmInitializeNdis()
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
   NDIS_STATUS                     Status;
   NDIS_PROTOCOL_CHARACTERISTICS   Chars;

   //
   // Register with NDIS as a protocol. 
   // 
   RtlZeroMemory(&Chars, sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
   Chars.MajorNdisVersion            = 5;
   Chars.MinorNdisVersion            = 0;
   Chars.OpenAdapterCompleteHandler  = AtmSmOpenAdapterComplete;
   Chars.CloseAdapterCompleteHandler = AtmSmCloseAdapterComplete;
   Chars.StatusHandler               = AtmSmStatus;
   Chars.RequestCompleteHandler      = AtmSmRequestComplete;
   Chars.ReceiveCompleteHandler      = AtmSmReceiveComplete;
   Chars.StatusCompleteHandler       = AtmSmStatusComplete;
   Chars.BindAdapterHandler          = AtmSmBindAdapter;
   Chars.UnbindAdapterHandler        = AtmSmUnbindAdapter;
   Chars.PnPEventHandler             = AtmSmPnPEvent;

   Chars.CoSendCompleteHandler       = AtmSmCoSendComplete;
   Chars.CoStatusHandler             = AtmSmCoStatus;
   Chars.CoReceivePacketHandler      = AtmSmCoReceivePacket;
   Chars.CoAfRegisterNotifyHandler   = AtmSmCoAfRegisterNotify;

   RtlInitUnicodeString(&Chars.Name, ATMSM_SERVICE_NAME_L);

   NdisRegisterProtocol(&Status, 
      &AtmSmGlobal.ProtHandle, 
      &Chars, 
      sizeof(Chars));

   return Status;
}


NDIS_STATUS AtmSmDeinitializeNdis()
{
   NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

   TraceIn(AtmSmDeinitializeNdis);

   if(NULL != AtmSmGlobal.ProtHandle)
   {
      NdisDeregisterProtocol(&Status, AtmSmGlobal.ProtHandle);
      AtmSmGlobal.ProtHandle = NULL;
   }

   TraceOut(AtmSmDeinitializeNdis);

   return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\samples\atmsmpl\driver\precomp.h ===
#include <ntddk.h>
#include <ndis.h>
#include <atm.h>
#include "atmsample.h"
#include "atmsmdbg.h"
#include "atmsmdrv.h"
#include "proto.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\samples\atmsmpl\driver\proto.h ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation, All Rights Reserved.

Module Name:

    proto.h

Abstract:

    Ndis Atm Sample protocol. 

Author:

    Anil Francis Thomas (10/98)

Environment:

    Kernel

Revision History:

--*/

#ifndef __PROTO_H
#define __PROTO_H

//
// prototypes from atmsmdrv.c
//
NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT      pDriverObject,
    IN  PUNICODE_STRING     RegistryPath
    );

VOID
AtmSmShutDown(
    );

NDIS_STATUS
AtmSmInitializeNdis(
    );

NDIS_STATUS
AtmSmDeinitializeNdis(
    );


//
// Prototypes in adapter.c
//

VOID
AtmSmBindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN  NDIS_HANDLE                 BindContext,
    IN  PNDIS_STRING                pDeviceName,
    IN  PVOID                       SystemSpecific1,
    IN  PVOID                       SystemSpecific2
    );

VOID
AtmSmOpenAdapterComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status,
    IN  NDIS_STATUS             OpenStatus
    );

VOID
AtmSmUnbindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 UnbindContext
    );

NDIS_STATUS
AtmSmShutdownAdapter(
    PATMSM_ADAPTER  pAdapt
    );

VOID
AtmSmCloseAdapterComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status
    );

BOOLEAN
AtmSmReferenceAdapter(
    PATMSM_ADAPTER    pAdapt
    );

LONG
AtmSmDereferenceAdapter(
    PATMSM_ADAPTER    pAdapt
    );

NDIS_STATUS
AtmSmQueryAdapterATMAddresses(
    PATMSM_ADAPTER    pAdapt
    );

VOID
AtmSmQueryAdapter(
    IN  PATMSM_ADAPTER  pAdapt
    );

NDIS_STATUS
AtmSmPnPEvent(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNET_PNP_EVENT          pNetPnPEvent
    );

VOID
AtmSmStatus(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    );

VOID
AtmSmReceiveComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext
    );

VOID
AtmSmStatusComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext
    );

VOID
AtmSmCoStatus(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             ProtocolVcContext   OPTIONAL,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    );


//
// Prototypes in callmgr.c
//

VOID
AtmSmCoAfRegisterNotify(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  PCO_ADDRESS_FAMILY          pAddressFamily
    );

VOID
AtmSmOpenAfComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             NdisAfHandle
    );

NDIS_STATUS
AtmSmRegisterSap(
    IN  PATMSM_ADAPTER  pAdapt
    );

VOID
AtmSmRegisterSapComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolSapContext,
    IN  PCO_SAP                 Sap,
    IN  NDIS_HANDLE             NdisSapHandle
    );

VOID
AtmSmDeregisterSapComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolSapContext
    );

VOID
AtmSmCloseAfComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolAfContext
    );

NDIS_STATUS
AtmSmCreateVc(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             NdisVcHandle,
    OUT PNDIS_HANDLE            ProtocolVcContext
    );

NDIS_STATUS
AtmSmDeleteVc(
    IN  NDIS_HANDLE                 ProtocolVcContext
    );

NDIS_STATUS
AtmSmIncomingCall(
    IN  NDIS_HANDLE             ProtocolSapContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    );

VOID
AtmSmCallConnected(
    IN  NDIS_HANDLE             ProtocolVcContext
    );

VOID
AtmSmMakeCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

VOID
AtmSmIncomingCloseCall(
    IN  NDIS_STATUS             CloseStatus,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PVOID                   CloseData   OPTIONAL,
    IN  UINT                    Size        OPTIONAL
    );

VOID
AtmSmCloseCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             ProtocolPartyContext OPTIONAL
    );

VOID
AtmSmAddPartyComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolPartyContext,
    IN  NDIS_HANDLE             NdisPartyHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

VOID
AtmSmDropPartyComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolPartyContext
    );

VOID
AtmSmIncomingDropParty(
    IN  NDIS_STATUS             DropStatus,
    IN  NDIS_HANDLE             ProtocolPartyContext,
    IN  PVOID                   CloseData   OPTIONAL,
    IN  UINT                    Size        OPTIONAL
    );

VOID
AtmSmIncomingCallQoSChange(
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );


//
// Prototypes in misc.c
//

NDIS_STATUS
AtmSmAllocVc(
    IN  PATMSM_ADAPTER  pAdapt,
    OUT PATMSM_VC       *ppVc,
    IN  ULONG           VcType,
    IN  NDIS_HANDLE     NdisVcHandle
    );

BOOLEAN
AtmSmReferenceVc(
    IN  PATMSM_VC   pVc
    );

ULONG
AtmSmDereferenceVc(
    IN  PATMSM_VC   pVc
    );

VOID
AtmSmDisconnectVc(
    IN  PATMSM_VC           pVc
    );

BOOLEAN
DeleteMemberInfoFromVc(
    IN  PATMSM_VC           pVc,
    IN  PATMSM_PMP_MEMBER   pMemberToRemove
    );

VOID
AtmSmDropMemberFromVc(
    IN  PATMSM_VC           pVc,
    IN  PATMSM_PMP_MEMBER   pMemberToDrop
    );

PCO_CALL_PARAMETERS
AtmSmPrepareCallParameters(
    IN  PATMSM_ADAPTER          pAdapt,
    IN  PHW_ADDR                pHwAddr,
    IN  BOOLEAN                 IsMakeCall,
    IN  BOOLEAN                 IsMultipointVC
    );

NTSTATUS
VerifyRecvOpenContext(
    PATMSM_ADAPTER      pAdapt
    );

NTSTATUS
VerifyConnectContext(
    PATMSM_VC       pVc
    );

UINT
CopyPacketToIrp(
    PIRP            pIrp,
    PNDIS_PACKET    pPkt
    );

VOID
AtmSmRecvReturnTimerFunction (
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );

VOID
AtmSmConnectToPMPDestinations(
    IN  PATMSM_VC           pVc
    );

VOID
AtmSmConnectPPVC(
    IN  PATMSM_VC           pVc
    );

//
// Prototypes in request.c
//

NDIS_STATUS
AtmSmCoRequest(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    );

VOID
AtmSmCoRequestComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolAfContext,
    IN  NDIS_HANDLE                 ProtocolVcContext   OPTIONAL,
    IN  NDIS_HANDLE                 ProtocolPartyContext    OPTIONAL,
    IN  PNDIS_REQUEST               pNdisRequest
    );

VOID
AtmSmSendAdapterNdisRequest(
    IN  PATMSM_ADAPTER          pAdapt,
    IN  NDIS_OID                Oid,
    IN  PVOID                   pBuffer,
    IN  ULONG                   BufferLength
    );

VOID
AtmSmRequestComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_REQUEST           pRequest,
    IN  NDIS_STATUS             Status
    );


//
// Prototypes in sendrecv.c
//
VOID
AtmSmSendPacketOnVc(
    IN  PATMSM_VC               pVc,
    IN  PNDIS_PACKET            pPacket
    );

VOID
AtmSmSendQueuedPacketsOnVc(
    IN  PATMSM_VC       pVc
    );

VOID
AtmSmCoSendComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNDIS_PACKET            Packet
    );

UINT
AtmSmCoReceivePacket(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_HANDLE ProtocolVcContext,
    IN  PNDIS_PACKET Packet
    );


//
// Prototypes in ioctl.c
//

NTSTATUS
AtmSmDispatch(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    );

NTSTATUS
AtmSmIoctlEnumerateAdapters(
    PIRP                pIrp,
    PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
AtmSmIoctlOpenForRecv(
    PIRP                pIrp,
    PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
AtmSmIoctlRecvData(
    PIRP                pIrp,
    PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
AtmSmIoctlCloseRecvHandle(
    PIRP                pIrp,
    PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
AtmSmIoctlConnectToDsts(
    PIRP                pIrp,
    PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
AtmSmIoctlSendToDsts(
    PIRP                pIrp,
    PIO_STACK_LOCATION  pIrpSp
    );

NTSTATUS
AtmSmIoctlCloseSendHandle(
    PIRP                pIrp,
    PIO_STACK_LOCATION  pIrpSp
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\samples\atmsmpl\driver\ioctl.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation, All Rights Reserved.

Module Name:

    ioctl.c

Abstract:

    This module contains the ioctl interface to this driver

Author:

    Anil Francis Thomas (10/98)

Environment:

    Kernel

Revision History:
   DChen    092499   Bug fixes

--*/
#include "precomp.h"
#pragma hdrstop


#define MODULE_ID    MODULE_IOCTL


NTSTATUS AtmSmDispatch(
   IN  PDEVICE_OBJECT  pDeviceObject,
   IN  PIRP            pIrp
   )
/*++

Routine Description:

    This is the common dispath routine for user Ioctls

Arguments:

Return Value:

    None

--*/
{
   NTSTATUS            Status;
   ULONG               ulBytesWritten = 0;
   PIO_STACK_LOCATION  pIrpSp;


   TraceIn(AtmSmDispatch);

   //
   // Get current Irp stack location
   //
   pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

   pIrp->IoStatus.Information = 0;

   switch(pIrpSp->MajorFunction)
   {

      case IRP_MJ_CREATE: {

            DbgLoud(("IRP_MJ_CREATE\n"));

            InterlockedIncrement(&AtmSmGlobal.ulNumCreates);
            Status = STATUS_SUCCESS;

            break;
         }

      case IRP_MJ_CLOSE: {

            DbgLoud(("IRP_MJ_CLOSE\n"));

            Status = STATUS_SUCCESS;

            break;
         }

      case IRP_MJ_CLEANUP: {

            DbgLoud(("IRP_MJ_CLEANUP\n"));

            Status = STATUS_SUCCESS;

            InterlockedDecrement(&AtmSmGlobal.ulNumCreates);

            break;
         }

      case IRP_MJ_DEVICE_CONTROL: {

            ULONG   ulControlCode;
            ULONG   ulControlFunc;

            ulControlCode   = pIrpSp->Parameters.DeviceIoControl.IoControlCode;
            ulControlFunc   = IoGetFunctionCodeFromCtlCode(ulControlCode);

            // verify the IOCTL codes
            if(DEVICE_TYPE_FROM_CTL_CODE(ulControlCode) == FILE_DEVICE_ATMSM &&
               ulControlFunc < ATMSM_NUM_IOCTLS &&
               AtmSmIoctlTable[ulControlFunc] == ulControlCode)
            {
               // set the status to PENDING by default
               pIrp->IoStatus.Status = STATUS_PENDING;
               
               Status = (*AtmSmFuncProcessIoctl[ulControlFunc])(pIrp, pIrpSp);
            }
            else
            {
               DbgErr(("Unknown IRP_MJ_DEVICE_CONTROL code - %x\n",
                  ulControlCode));
               Status = STATUS_INVALID_PARAMETER;
            }

            break;
         }

      default: {

            DbgErr(("Unknown IRP_MJ_XX - %x\n",pIrpSp->MajorFunction));

            Status = STATUS_INVALID_PARAMETER;

            break;
         }
   }


   if(STATUS_PENDING != Status)
   {
      pIrp->IoStatus.Status = Status;

      IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
   }

   TraceOut(AtmSmDispatch);

   return Status;
}


NTSTATUS AtmSmIoctlEnumerateAdapters(
   PIRP                pIrp,
   PIO_STACK_LOCATION  pIrpSp
   )
/*++

Routine Description:

    This routine is called to enumerate the adapters that we are bound to.
    
    NOTE!  This uses buffered I/O

Arguments:

Return Value:

    Status - doesn't pend

--*/
{
   NTSTATUS            Status = STATUS_SUCCESS;
   ULONG               ulNum, ulOutputBufLen, ulNeededSize;
   PADAPTER_INFO       pAdaptInfo = (PADAPTER_INFO)
                                    pIrp->AssociatedIrp.SystemBuffer;
   PATMSM_ADAPTER      pAdapt;


   TraceIn(AtmSmIoctlEnumerateAdapters);

   ulOutputBufLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;


   ACQUIRE_GLOBAL_LOCK();

   ulNeededSize = sizeof(ADAPTER_INFO) + 
                  (sizeof(UCHAR) * NSAP_ADDRESS_LEN * 
                     (AtmSmGlobal.ulAdapterCount - 1));


   if(ulOutputBufLen < ulNeededSize)
   {

      DbgErr(("Output length is not sufficient\n"));

      RELEASE_GLOBAL_LOCK();

      TraceOut(AtmSmIoctlEnumerateAdapters);
      return STATUS_BUFFER_TOO_SMALL;
   }

   pAdaptInfo->ulNumAdapters = 0;

   ulNum = 0;
   for(pAdapt = AtmSmGlobal.pAdapterList; pAdapt &&
      ulNum < AtmSmGlobal.ulAdapterCount; 
      pAdapt = pAdapt->pAdapterNext)
   {

      if(AtmSmReferenceAdapter(pAdapt))
      {

         ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

         if(0 == (pAdapt->ulFlags & ADAPT_ADDRESS_INVALID))
         {
            // this is a good adapter

            RtlCopyMemory(pAdaptInfo->ucLocalATMAddr[ulNum], 
               pAdapt->ConfiguredAddress.Address,
               (sizeof(UCHAR) * ATM_ADDRESS_LENGTH));

            pAdaptInfo->ulNumAdapters++;
            ulNum++;
         }

         RELEASE_ADAPTER_GEN_LOCK(pAdapt);

         AtmSmDereferenceAdapter(pAdapt);
      }

   }

   RELEASE_GLOBAL_LOCK();

   pIrp->IoStatus.Information = ulOutputBufLen;

   TraceOut(AtmSmIoctlEnumerateAdapters);

   return Status;
}

NTSTATUS AtmSmIoctlOpenForRecv(
   PIRP                pIrp,
   PIO_STACK_LOCATION  pIrpSp
   )
/*++

Routine Description:

    This routine is used to open an adapter for receiving all the packets that
    come to our SAP.  We allow only 1 user to open the adapter for recvs.
    
    NOTE!  This uses buffered I/O

Arguments:

Return Value:

    Status - doesn't Pend

--*/
{
   NTSTATUS            Status = STATUS_SUCCESS;
   ULONG               ulInputBufLen, ulOutputBufLen, ulCompareLength;
   POPEN_FOR_RECV_INFO pOpenInfo = (POPEN_FOR_RECV_INFO)
                                   pIrp->AssociatedIrp.SystemBuffer;
   PATMSM_ADAPTER      pAdapt;

#if DBG
   ATM_ADDRESS         AtmAddr;
#endif

   TraceIn(AtmSmIoctlOpenForRecv);

   ulInputBufLen  = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
   ulOutputBufLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;


   if(ulInputBufLen < sizeof(OPEN_FOR_RECV_INFO))
   {

      DbgErr(("Input length is invalid\n"));
      TraceOut(AtmSmIoctlOpenForRecv);
      return STATUS_INVALID_PARAMETER;
   }

   if(ulOutputBufLen < sizeof(HANDLE))
   {

      DbgErr(("Output length is not sufficient\n"));
      TraceOut(AtmSmIoctlOpenForRecv);
      return STATUS_BUFFER_TOO_SMALL;
   }


#if DBG
   AtmAddr.AddressType     = ATM_NSAP;
   AtmAddr.NumberOfDigits  = ATM_ADDRESS_LENGTH;
   RtlCopyMemory(AtmAddr.Address, pOpenInfo->ucLocalATMAddr, 
      (sizeof(UCHAR) * ATM_ADDRESS_LENGTH));

   DumpATMAddress(ATMSMD_INFO, "Recv Open - Local AtmAddress - ", &AtmAddr);
#endif

   do
   {    // break off loop

      //
      // grab the global lock and find out which adapter is being refered to.
      //
      ACQUIRE_GLOBAL_LOCK();

      // we don't compare the selector byte
      ulCompareLength = sizeof(UCHAR) * (ATM_ADDRESS_LENGTH - 1);

      for(pAdapt = AtmSmGlobal.pAdapterList; pAdapt; 
         pAdapt = pAdapt->pAdapterNext)
      {

         if(ulCompareLength == RtlCompareMemory(
            pOpenInfo->ucLocalATMAddr, 
            pAdapt->ConfiguredAddress.Address, 
            ulCompareLength))
            break;
      }

      if(NULL == pAdapt)
      {
         RELEASE_GLOBAL_LOCK();

         DbgErr(("Specified adapter address not found.\n"));
         Status = STATUS_OBJECT_NAME_INVALID;
         break;
      }

      // we have found the adapter put a reference on it
      if(!AtmSmReferenceAdapter(pAdapt))
      {
         RELEASE_GLOBAL_LOCK();

         DbgErr(("Couldn't put a reference on the adapter.\n"));
         Status = STATUS_UNSUCCESSFUL;
         break;
      }

      RELEASE_GLOBAL_LOCK();

      // we have a reference on the adapter now
      // check if it is already opened for recv's .  We allow only
      // one receiver.
      ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

      if(pAdapt->fAdapterOpenedForRecv)
      {
         // we already have an open for recv
         RELEASE_ADAPTER_GEN_LOCK(pAdapt);

         AtmSmDereferenceAdapter(pAdapt);
      
         DbgErr(("Already opened for recvs.\n"));
         Status = STATUS_UNSUCCESSFUL;
         break;
      }

      pAdapt->fAdapterOpenedForRecv = TRUE;

      RELEASE_ADAPTER_GEN_LOCK(pAdapt);
         
      // now set the opencontext
      *(PHANDLE)(pIrp->AssociatedIrp.SystemBuffer) = (HANDLE)pAdapt;
      pIrp->IoStatus.Information = sizeof(HANDLE);

      DbgInfo(("Success! Recv Open Context - 0x%x\n", pAdapt));

      // remove the reference added when opening for recvs
      AtmSmDereferenceAdapter(pAdapt);

   } while(FALSE);

   TraceOut(AtmSmIoctlOpenForRecv);

   return Status;
}

NTSTATUS AtmSmIoctlRecvData(
   PIRP                pIrp,
   PIO_STACK_LOCATION  pIrpSp
   )
/*++

Routine Description:
    
    This routine is used to transfer data from network packets into the user
    buffers.  If a packet is queued up, then we will immediately complete 
    this reuqest.

    NOTE!  This uses Direct I/O for buffer to recv data

Arguments:

Return Value:

    Status - Success, Pending or error

--*/
{
   NTSTATUS            Status = STATUS_SUCCESS;
   ULONG               ulInputBufLen, ulOutputBufLen;
   PATMSM_ADAPTER      pAdapt;
   ULONG               ulControlCode;

   TraceIn(AtmSmIoctlRecvData);

   ulControlCode   = pIrpSp->Parameters.DeviceIoControl.IoControlCode;

   ASSERT(METHOD_OUT_DIRECT == (ulControlCode & 0x3));

   ulInputBufLen  = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;

   if(ulInputBufLen < sizeof(HANDLE))
   {

      DbgErr(("Input length is invalid\n"));
      TraceOut(AtmSmIoctlRecvData);
      return STATUS_INVALID_PARAMETER;
   }

   ulOutputBufLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

   if(0 == ulOutputBufLen)
   {
      DbgErr(("Output buffer length is 0!\n"));
      TraceOut(AtmSmIoctlRecvData);
      return STATUS_INVALID_PARAMETER;
   }

   DbgLoud(("Recv - Output buffer length = %u\n", ulOutputBufLen));

   pAdapt = (PATMSM_ADAPTER)(*(PHANDLE)(pIrp->AssociatedIrp.SystemBuffer));

   DbgLoud(("Recv Context is 0x%x\n", pAdapt));

   // Note - VerifyRecvOpenContext adds a reference to the adapter
   // if successful, which we remove when we are done

   if(STATUS_SUCCESS != (Status = VerifyRecvOpenContext(pAdapt)))
   {

      TraceOut(AtmSmIoctlRecvData);
      return Status;
   }

   // we have a valid RecvContext - check if a recv is already queued
   do
   { // break off loop

      ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);
      if(pAdapt->pRecvIrp)
      {

         // there is already an Irp pending
         RELEASE_ADAPTER_GEN_LOCK(pAdapt);

         Status = STATUS_UNSUCCESSFUL;
         DbgErr(("There is already a recv pending\n"));

         break;
      }

      // No irps pending, check if a queued packets is there, if so copy
      // else queue ourselves
      if(pAdapt->pRecvPktNext)
      {

         PPROTO_RSVD     pPRsvd;
         PNDIS_PACKET    pPkt;

         pPkt    = pAdapt->pRecvPktNext;
         pPRsvd  = GET_PROTO_RSVD(pPkt);

         pAdapt->pRecvPktNext    = pPRsvd->pPktNext;

         if(pAdapt->pRecvLastPkt == pPkt)
            pAdapt->pRecvLastPkt = NULL;

         pAdapt->ulRecvPktsCount--;

         // release the recv queue lock
         RELEASE_ADAPTER_GEN_LOCK(pAdapt);

         // Copy the packet to the Irp buffer
         // Note this may be partial if the Irp buffer is not large enough
         pIrp->IoStatus.Information = 
            CopyPacketToIrp(pIrp, pPkt);

         // return the packet to the miniport
         NdisReturnPackets(&pPkt, 1);

         // Status success

      }
      else
      {

         // no packets available, queue this Irp

         pAdapt->pRecvIrp = pIrp;

         // release the recv queue lock
         RELEASE_ADAPTER_GEN_LOCK(pAdapt);

         IoMarkIrpPending(pIrp);

         Status = STATUS_PENDING;
      }


   }while(FALSE);

   // remove the reference added while verifying
   AtmSmDereferenceAdapter(pAdapt);


   TraceOut(AtmSmIoctlRecvData);

   return Status;
}

NTSTATUS AtmSmIoctlCloseRecvHandle(
   PIRP                pIrp,
   PIO_STACK_LOCATION  pIrpSp
   )
/*++

Routine Description:

    This routine is used to close a handle that was obtained when the adapter
    was opened for recvs.
    
    NOTE!  This uses buffered I/O

Arguments:

Return Value:

    Status - doesn't pend

--*/
{
   NTSTATUS            Status = STATUS_SUCCESS;
   ULONG               ulInputBufLen;
   PATMSM_ADAPTER      pAdapt;

   TraceIn(AtmSmIoctlCloseRecvHandle);

   ulInputBufLen  = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;

   if(ulInputBufLen < sizeof(HANDLE))
   {

      DbgErr(("Input length is invalid\n"));
      TraceOut(AtmSmIoctlCloseRecvHandle);
      return STATUS_INVALID_PARAMETER;
   }


   pAdapt = (PATMSM_ADAPTER)(*(PHANDLE)(pIrp->AssociatedIrp.SystemBuffer));

   DbgLoud(("Recv Context is 0x%x\n", pAdapt));

   // Note - VerifyRecvOpenContext adds a reference to the adapter
   // if successful, which we remove when we are done

   if(STATUS_SUCCESS != (Status = VerifyRecvOpenContext(pAdapt)))
   {

      DbgInfo(("Couldn't put a reference on the adapter - pAdapt - 0x%x\n",
         pAdapt));
      TraceOut(AtmSmIoctlCloseRecvHandle);
      return Status;
   }

   // we have a valid RecvContext

   ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

   if(pAdapt->pRecvIrp)
   {

      PIRP pRecvIrp = pAdapt->pRecvIrp;

      pAdapt->pRecvIrp = NULL;

      // there is an Irp pending, complete it
      pRecvIrp->IoStatus.Status       = STATUS_CANCELLED;
      pRecvIrp->Cancel                = TRUE;
      pRecvIrp->IoStatus.Information  = 0;
      IoCompleteRequest(pRecvIrp, IO_NETWORK_INCREMENT);

   }

   pAdapt->fAdapterOpenedForRecv = FALSE;

   RELEASE_ADAPTER_GEN_LOCK(pAdapt);

   // remove the reference added while verifying
   AtmSmDereferenceAdapter(pAdapt);

   pIrp->IoStatus.Information = 0;

   TraceOut(AtmSmIoctlCloseRecvHandle);

   return Status;
}

NTSTATUS AtmSmIoctlConnectToDsts(
   PIRP                pIrp,
   PIO_STACK_LOCATION  pIrpSp
   )
/*++

Routine Description:
    This routine is used to initiate a connection to 1 (P-P) or more (PMP)
    destinations.
    
    NOTE!  This uses buffered I/O

Arguments:

Return Value:

    Status - Pending or error

--*/
{
   NTSTATUS            Status          = STATUS_SUCCESS;
   PCONNECT_INFO       pConnectInfo    = (PCONNECT_INFO)
                                         pIrp->AssociatedIrp.SystemBuffer;
   ULONG               ul, ulInputBufLen, ulOutputBufLen, ulCompareLength;
   PATMSM_ADAPTER      pAdapt;
   PATMSM_VC           pVc;

#if DBG
   ATM_ADDRESS         AtmAddr;
#endif

   TraceIn(AtmSmIoctlConnectToDsts);

   ulInputBufLen  = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
   ulOutputBufLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

   if(ulInputBufLen < sizeof(CONNECT_INFO))
   {
      DbgErr(("Input length < sizeof(CONNECT_INFO)\n"));
      TraceOut(AtmSmIoctlConnectToDsts);
      return STATUS_INVALID_PARAMETER;
   }
                                       
   if(pConnectInfo->ulNumDsts == 0)
   {
      DbgErr(("Number of destinations is zero\n"));
      TraceOut(AtmSmIoctlConnectToDsts);
      return STATUS_INVALID_PARAMETER;
   }

   if((ulInputBufLen - (sizeof(CONNECT_INFO))/(sizeof(UCHAR)*ATM_ADDRESS_LENGTH)) 
      < pConnectInfo->ulNumDsts -1)
   {
      DbgErr(("Input length is invalid\n"));
      TraceOut(AtmSmIoctlConnectToDsts);
      return STATUS_INVALID_PARAMETER;
   }

   if(ulOutputBufLen < sizeof(HANDLE))
   {
      DbgErr(("Output length is not sufficient\n"));
      TraceOut(AtmSmIoctlConnectToDsts);
      return STATUS_BUFFER_TOO_SMALL;
   }


#if DBG
   AtmAddr.AddressType     = ATM_NSAP;
   AtmAddr.NumberOfDigits  = ATM_ADDRESS_LENGTH;
   RtlCopyMemory(AtmAddr.Address, pConnectInfo->ucLocalATMAddr, 
      (sizeof(UCHAR) * ATM_ADDRESS_LENGTH));

   DumpATMAddress(ATMSMD_INFO, "Connect to Dsts - Local AtmAddress - ", 
      &AtmAddr);

   DbgInfo(("No of destinations - %u\n", pConnectInfo->ulNumDsts));

   for(ul = 0; ul < pConnectInfo->ulNumDsts; ul++)
   {

      RtlCopyMemory(AtmAddr.Address, pConnectInfo->ucDstATMAddrs[ul], 
         (sizeof(UCHAR) * ATM_ADDRESS_LENGTH));

      DumpATMAddress(ATMSMD_INFO, "    Destination AtmAddress - ", &AtmAddr);
   }

#endif

   do
   {    // break off loop

      // initialize
      Status = STATUS_OBJECT_NAME_INVALID;

      //
      // grab the global lock and find out which adapter is being refered to.
      //
      ACQUIRE_GLOBAL_LOCK();

      // we don't compare the selector byte
      ulCompareLength = sizeof(UCHAR) * (ATM_ADDRESS_LENGTH - 1);

      for(pAdapt = AtmSmGlobal.pAdapterList; pAdapt; 
          pAdapt = pAdapt->pAdapterNext)
      {

         if(ulCompareLength == RtlCompareMemory(
            pConnectInfo->ucLocalATMAddr, 
            pAdapt->ConfiguredAddress.Address, 
            ulCompareLength))
         {
            // create a VC structure
            Status = AtmSmAllocVc(pAdapt, 
                                  &pVc, 
                                  (pConnectInfo->bPMP? 
                                      VC_TYPE_PMP_OUTGOING :
                                      VC_TYPE_PP_OUTGOING), 
                                  NULL);
                
            if(NDIS_STATUS_SUCCESS != Status)
            {
        
               DbgErr(("Failed to create ougoing VC. Status - 0x%X.\n", Status));
        
               Status = STATUS_NO_MEMORY;
            }

            break;
         }
      }

      RELEASE_GLOBAL_LOCK();

      if(Status != NDIS_STATUS_SUCCESS)
      {
         break;
      }

      // no need to add reference here since the allocation of VC
      // will add a reference to the Adapter

      ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

      if(!pConnectInfo->bPMP)
      {

         // this is P-P
         // copy the destination address
         PATM_ADDRESS pAtmAddr = &pVc->HwAddr.Address;

         pAtmAddr->AddressType     = ATM_NSAP;
         pAtmAddr->NumberOfDigits  = ATM_ADDRESS_LENGTH;
         RtlCopyMemory(pAtmAddr->Address, pConnectInfo->ucDstATMAddrs[0], 
            (sizeof(UCHAR) * ATM_ADDRESS_LENGTH));
         // Note: we don't get the correct selector byte from user mode
         //       we assume the selector byte used by the destination is
         //       the same.
         pAtmAddr->Address[ATM_ADDRESS_LENGTH-1] = pAdapt->SelByte;

      }
      else
      {

         for(ul = 0; ul < pConnectInfo->ulNumDsts; ul++)
         {

            PATMSM_PMP_MEMBER   pMember;
            PATM_ADDRESS        pAtmAddr;

            AtmSmAllocMem(&pMember, PATMSM_PMP_MEMBER, 
               sizeof(ATMSM_PMP_MEMBER));

            if(NULL == pMember)
            {


               DbgErr(("Failed to allocate member. No resources\n"));

               // cleanup the members and VC
               while(NULL != (pMember = pVc->pPMPMembers))
               {
                  AtmSmFreeMem(pMember);
                  pVc->ulRefCount--;
               }

               RELEASE_ADAPTER_GEN_LOCK(pAdapt);

               AtmSmDereferenceVc(pVc);

               Status = STATUS_NO_MEMORY;
               break;
            }

            NdisZeroMemory(pMember, sizeof(ATMSM_PMP_MEMBER));

            pMember->ulSignature = atmsm_member_signature;
            pMember->pVc = pVc;
            ATMSM_SET_MEMBER_STATE(pMember, ATMSM_MEMBER_IDLE);
            pAtmAddr = &pMember->HwAddr.Address;

            pAtmAddr->AddressType     = ATM_NSAP;
            pAtmAddr->NumberOfDigits  = ATM_ADDRESS_LENGTH;
            RtlCopyMemory(pAtmAddr->Address, 
               pConnectInfo->ucDstATMAddrs[ul], 
               (sizeof(UCHAR) * ATM_ADDRESS_LENGTH));

            // Note: we don't get the correct selector byte from user mode
            //       we assume the selector byte used by the destination is
            //       the same.
            pAtmAddr->Address[ATM_ADDRESS_LENGTH-1] = pAdapt->SelByte;

            pMember->pNext = pVc->pPMPMembers;
            pVc->pPMPMembers = pMember;
            pVc->ulNumTotalMembers++;

            // Also add a reference for each members
            pVc->ulRefCount++;
         }

      }

      pVc->pConnectIrp  = pIrp;

      IoMarkIrpPending(pIrp);

      // we will return pending
      Status = STATUS_PENDING;

      RELEASE_ADAPTER_GEN_LOCK(pAdapt);

      DbgInfo(("Initiated a VC connection - Adapter 0x%x VC - 0x%x\n", 
         pAdapt, pVc));
      if(!pConnectInfo->bPMP)
      {

         AtmSmConnectPPVC(pVc);

      }
      else
      {

         AtmSmConnectToPMPDestinations(pVc);
      }


   } while(FALSE);


   TraceOut(AtmSmIoctlConnectToDsts);

   return Status;
}

NTSTATUS AtmSmIoctlSendToDsts(
   PIRP                pIrp,
   PIO_STACK_LOCATION  pIrpSp
   )
/*++

Routine Description:
    This routine is used to send a packet to destination(s) for which we 
    already have a connection.
    
    NOTE!  This uses Direct I/O for buffer to send data

Arguments:

Return Value:

    Status - Pending or error
--*/
{
   NTSTATUS            Status = STATUS_SUCCESS;
   ULONG               ulInputBufLen, ulOutputBufLen;
   PATMSM_VC           pVc;
   ULONG               ulControlCode;

   TraceIn(AtmSmIoctlSendToDsts);

   ulControlCode   = pIrpSp->Parameters.DeviceIoControl.IoControlCode;

   ASSERT(METHOD_IN_DIRECT == (ulControlCode & 0x3));

   ulInputBufLen = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;

   if(sizeof(HANDLE) != ulInputBufLen)
   {
      DbgErr(("Input buffer length is invalid!\n"));
      ASSERT(FALSE);
      TraceOut(AtmSmIoctlSendToDsts);
      return STATUS_INVALID_PARAMETER;
   }

   ulOutputBufLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

   if(0 == ulOutputBufLen)
   {
      DbgErr(("Output buffer length is 0!\n"));
      ASSERT(FALSE);
      TraceOut(AtmSmIoctlRecvData);
      return STATUS_INVALID_PARAMETER;
   }

   DbgLoud(("Send - Output buffer length = %u\n", ulOutputBufLen));

   pVc  = (PATMSM_VC)(*(PHANDLE)(pIrp->AssociatedIrp.SystemBuffer));

   DbgLoud(("Connect Context is 0x%x\n", pVc));

   // Note - VerifyConnectContext adds a reference to the VC
   // if successful, which we remove when we are done

   if(STATUS_SUCCESS != (Status = VerifyConnectContext(pVc)))
   {

      TraceOut(AtmSmIoctlSendToDsts);
      return Status;
   }

   // we have a valid ConnectContext
   do
   { // break off loop

      PNDIS_PACKET        pPacket;
      PATMSM_ADAPTER      pAdapt = pVc->pAdapt;
      //
      //  Try to get a packet 
      //

      NdisAllocatePacket(
         &Status,
         &pPacket,
         pAdapt->PacketPoolHandle
         );

      if(NDIS_STATUS_SUCCESS != Status)
      {

         //
         //  No free packets
         //
         Status = STATUS_UNSUCCESSFUL;
         break;
      }

      (GET_PROTO_RSVD(pPacket))->pSendIrp=pIrp;

#ifdef BUG_IN_NEW_DMA

      {
         PNDIS_BUFFER    pBuffer;
         PVOID           pSrcVA    = 
            MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority);
         UINT            uiBufSize = 
            MmGetMdlByteCount(pIrp->MdlAddress);

         if (pSrcVA == NULL)
         {
            Status = NDIS_STATUS_RESOURCES;
            break;
         }

         // allocate the Buffer Descriptor
         NdisAllocateBuffer(&Status,
            &pBuffer,
            pAdapt->BufferPoolHandle,
            pSrcVA,
            uiBufSize);

         if(NDIS_STATUS_SUCCESS != Status)
         {
            NdisFreePacket(pPacket);
            break;
         }

         // add the buffer to the packet
         NdisChainBufferAtFront(pPacket,
            pBuffer);

      }

#else   // BUG_IN_NEW_DMA

      //
      //  Attach the send buffer to the packet
      //
      NdisChainBufferAtFront(pPacket, pIrp->MdlAddress);

#endif  // BUG_IN_NEW_DMA

      IoMarkIrpPending(pIrp);

      Status = STATUS_PENDING;

      // send the packet on the VC
      AtmSmSendPacketOnVc(pVc, pPacket);

   }while(FALSE);

   // remove the reference added to the VC while verifying
   AtmSmDereferenceVc(pVc);

   TraceOut(AtmSmIoctlSendToDsts);

   return Status;
}

NTSTATUS AtmSmIoctlCloseSendHandle(
   PIRP                pIrp,
   PIO_STACK_LOCATION  pIrpSp
   )
/*++

Routine Description:

    This routine is used to close a handle that was obtained when we established
    a connection to destinations.
    
    NOTE!  This uses buffered I/O

Arguments:

Return Value:

    Status - doesn't pend

--*/
{
   NTSTATUS            Status = STATUS_SUCCESS;
   ULONG               ulInputBufLen;
   PATMSM_VC           pVc;

   TraceIn(AtmSmIoctlCloseSendHandle);

   ulInputBufLen  = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;

   if(ulInputBufLen < sizeof(HANDLE))
   {

      DbgErr(("Input length is invalid\n"));
      TraceOut(AtmSmIoctlCloseSendHandle);
      return STATUS_INVALID_PARAMETER;
   }

   pVc = (PATMSM_VC)(*(PHANDLE)(pIrp->AssociatedIrp.SystemBuffer));

   DbgLoud(("Connect Context is 0x%x\n", pVc));

   // Note - VerifyConnectContext adds a reference to the VC
   // if successful, which we remove when we are done

   if(STATUS_SUCCESS != (Status = VerifyConnectContext(pVc)))
   {

      TraceOut(AtmSmIoctlCloseSendHandle);
      return Status;
   }

   // we have a valid Connect Context - disconnect it
   AtmSmDisconnectVc(pVc);

   // remove the reference added to the VC while verifying
   AtmSmDereferenceVc(pVc);

   TraceOut(AtmSmIoctlCloseSendHandle);

   return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\samples\atmsmpl\driver\misc.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation, All Rights Reserved.

Module Name:

    misc.c

Abstract:

    This module contains several miscellaneous routines like, ReferenceVC
    dereferenceVC etc.


Author:

    Anil Francis Thomas (10/98)

Environment:

    Kernel

Revision History:
   DChen    092499   Remove try/except block in VerifyRecvOpenContext

--*/
#include "precomp.h"
#pragma hdrstop


#define MODULE_ID    MODULE_MISC


NDIS_STATUS AtmSmAllocVc(
   IN  PATMSM_ADAPTER  pAdapt,
   OUT PATMSM_VC       *ppVc,
   IN  ULONG           VcType,
   IN  NDIS_HANDLE     NdisVcHandle
   )
/*++

Routine Description:
    This routine is used to create a VC structure and link to an adapter

Arguments:
    pAdapt      - Adapter structure
    ppVc        - pointer to a pointer of Vc
    VcType      - Type of VC to allocate (incoming, pmp outgoing etc)

Return Value:

    NDIS_STATUS_SUCCESS     if we could create a VC
    NDIS_STATUS_RESOURCES   no resources
    NDIS_STATUS_CLOSING     if we couldn't reference the adapter
--*/
{
   PATMSM_VC       pVc;
   NDIS_STATUS     Status;

   *ppVc           = NULL;

   //
   // Add a reference to the adapter for the VC (see if the adapter 
   // is closing)
   //
   if(!AtmSmReferenceAdapter(pAdapt))
      return NDIS_STATUS_CLOSING;

   //
   // Allocate a Vc, initialize it and link it into the Adapter
   //

   AtmSmAllocMem(&pVc, PATMSM_VC, sizeof(ATMSM_VC));

   if(NULL != pVc)
   {

      NdisZeroMemory(pVc, sizeof(ATMSM_VC));

      pVc->ulSignature    = atmsm_vc_signature;

      pVc->NdisVcHandle   = NdisVcHandle;
      pVc->pAdapt         = pAdapt;
      pVc->ulRefCount     = 1;   // Dereferenced when DeleteVc is called.
      pVc->VcType         = VcType;

      pVc->MaxSendSize    = pAdapt->MaxPacketSize; // default

      ATMSM_SET_VC_STATE(pVc, ATMSM_VC_IDLE);

      ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

      InsertHeadList(&pAdapt->InactiveVcHead, &pVc->List);

      RELEASE_ADAPTER_GEN_LOCK(pAdapt);

      Status  = NDIS_STATUS_SUCCESS;

      DbgInfo(("CreateVc: Created Vc %x\n", pVc));

   }
   else
   {

      // Not enough resources, hence remove the reference we added above
      AtmSmDereferenceAdapter(pAdapt);

      Status              = NDIS_STATUS_RESOURCES;

      DbgErr(("CreateVc: Failed - No resources\n"));
   }

   *ppVc = pVc;

   return Status;
}

BOOLEAN AtmSmReferenceVc(
   IN  PATMSM_VC   pVc
   )
/*++

Routine Description:

    Reference the VC.

Arguments:

    pVc  Pointer to the VC.

Return Value:

    TRUE    Referenced
    FALSE   Interface is closing, cannot reference.

--*/
{
   PATMSM_ADAPTER   pAdapt = pVc->pAdapt;
   BOOLEAN          rc     = FALSE;

   DbgInfo(("AtmSmReferenceVc - VC - 0x%X\n", pVc));

   ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

   if(ATMSM_GET_VC_STATE(pVc) != ATMSM_VC_CLOSING)
   {
      pVc->ulRefCount ++;
      rc = TRUE;
   }

   RELEASE_ADAPTER_GEN_LOCK(pAdapt);

   return rc;
}

ULONG AtmSmDereferenceVc(
   IN  PATMSM_VC   pVc
   )
/*++

Routine Description:

    Dereference the VC.  This could result in the VC to be deallocated.

Arguments:

    pVc  Pointer to the VC.

Return Value:

    Reference count

--*/
{
   PATMSM_ADAPTER   pAdapt = pVc->pAdapt;
   ULONG            ulRet;

   TraceIn(AtmSmDereferenceVc);

   DbgInfo(("AtmSmDereferenceVc - VC - 0x%X\n", pVc));

   ASSERT(pVc->ulRefCount > 0);

   ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

   ulRet =  --pVc->ulRefCount;

   if(0 == pVc->ulRefCount)
   {

      PIRP            pIrp;
      ULONG           VcType          = pVc->VcType;
      NDIS_HANDLE     NdisVcHandle    = pVc->NdisVcHandle;


      ASSERT (ATMSM_GET_VC_STATE(pVc) != ATMSM_VC_ACTIVE);

      ASSERT (0 == pVc->ulNumTotalMembers);

      // cleanup a connectIrp if it exists
      pIrp = pVc->pConnectIrp;
      pVc->pConnectIrp = NULL;

      if(pIrp)
      {

         pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

         pIrp->IoStatus.Information = 0;

         IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
      }

      // Remove any send packets pending on the Vc
      while(pVc->pSendPktNext)
      {

         PPROTO_RSVD     pPRsvd;
         PNDIS_PACKET    pPacket;

         pPacket = pVc->pSendPktNext;

         pPRsvd = GET_PROTO_RSVD(pPacket);

         pVc->pSendPktNext = pPRsvd->pPktNext;

         // this is the last packet
         if(pVc->pSendLastPkt == pPacket)
            pVc->pSendLastPkt = NULL;

         pVc->ulSendPktsCount--;

         RELEASE_ADAPTER_GEN_LOCK(pAdapt);

         AtmSmCoSendComplete(NDIS_STATUS_CLOSING, (NDIS_HANDLE)pVc, pPacket);

         ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);
      }


      RemoveEntryList(&pVc->List);

      // this is important - since memory is not cleared
      pVc->ulSignature = atmsm_dead_vc_signature;
      pVc->pAdapt      = NULL;

      AtmSmFreeMem(pVc);

      // Release the lock on the adapter
      RELEASE_ADAPTER_GEN_LOCK(pAdapt);

      if(((VC_TYPE_PP_OUTGOING == VcType)    ||
         (VC_TYPE_PMP_OUTGOING == VcType))  && 
         NdisVcHandle != NULL)
      {

         (VOID)NdisCoDeleteVc(NdisVcHandle);
      }

      // dereference the adapter (to remove the VC reference)
      // should be done after releasing the lock
      AtmSmDereferenceAdapter(pAdapt);

   }
   else
   {

      // Release the lock on the adapter
      RELEASE_ADAPTER_GEN_LOCK(pAdapt);
   }

   TraceOut(AtmSmDereferenceVc);

   return ulRet;
}

BOOLEAN DeleteMemberInfoFromVc(
   IN  PATMSM_VC           pVc,
   IN  PATMSM_PMP_MEMBER   pMemberToRemove
   )
/*++

Routine Description:
    The specified member structure is removed from the VC and the
    structure is freed.

Arguments:
    pVc  Pointer to the VC.

Return Value:
    TRUE  - if removed
    FALSE - otherwise

--*/
{
   PATMSM_ADAPTER      pAdapt = pVc->pAdapt;
   PATMSM_PMP_MEMBER   pMember;
   PATMSM_PMP_MEMBER   pPrevMember = NULL;

   TraceIn(DeleteMemberInfoFromVc);

   ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

   for(pMember = pVc->pPMPMembers; pMember; 
      pPrevMember = pMember, pMember = pMember->pNext)
      if(pMember == pMemberToRemove)
         break;

   ASSERT(pMember);

   if(!pMember)
   {

      RELEASE_ADAPTER_GEN_LOCK(pAdapt);
      return FALSE;
   }

   if(!pPrevMember)
   {

      pVc->pPMPMembers    = pMember->pNext;

   }
   else
   {

      pPrevMember->pNext  = pMember->pNext;
   }

   AtmSmFreeMem(pMember);

   pVc->ulNumTotalMembers--;

   RELEASE_ADAPTER_GEN_LOCK(pAdapt);


   // Now dereference the VC
   AtmSmDereferenceVc(pVc);

   TraceOut(DeleteMemberInfoFromVc);

   return TRUE;
}

VOID AtmSmDisconnectVc(
   IN  PATMSM_VC           pVc
   )
/*++

Routine Description:
    This routine can be used to disconnect a P-P VC or disconnect
    all members of a PMP Vc
    
Arguments:
    pVc             - Pointer to the VC.

Return Value:
    NONE

--*/
{
   NDIS_STATUS     Status;
   PATMSM_ADAPTER  pAdapt = pVc->pAdapt;

   TraceIn(AtmSmDisconnectVc);

   ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

   if(VC_TYPE_PMP_OUTGOING != pVc->VcType)
   {

      //
      // This is a PP VC
      //
      if((ATMSM_GET_VC_STATE(pVc) == ATMSM_VC_SETUP_IN_PROGRESS) ||
         (ATMSM_GET_VC_STATE(pVc) == ATMSM_VC_ACTIVE))
      {

         ATMSM_SET_VC_STATE(pVc, ATMSM_VC_CLOSING);

         RELEASE_ADAPTER_GEN_LOCK(pAdapt);

         Status = NdisClCloseCall(
                     pVc->NdisVcHandle,
                     NULL,        // No party Handle
                     NULL,        // No Buffer
                     0            // Size of above
                     );

         if(NDIS_STATUS_PENDING != Status)
         {

            AtmSmCloseCallComplete(
               Status,
               (NDIS_HANDLE)pVc,
               (NDIS_HANDLE)NULL
               );
         }

      }
      else
      {

         if(ATMSM_GET_VC_STATE(pVc) == ATMSM_VC_IDLE)
         {

            RELEASE_ADAPTER_GEN_LOCK(pAdapt);

            // remove the reference added to the VC while creating
            AtmSmDereferenceVc(pVc);
         }
         else
         {

            RELEASE_ADAPTER_GEN_LOCK(pAdapt);

         }
      }

   }
   else
   {

      PATMSM_PMP_MEMBER   pMember;

      // this is a PMP VC

      //
      // Find a member that we haven't tried drop on.
      //
      while(TRUE)
      {

         for(pMember = pVc->pPMPMembers; pMember != NULL; 
            pMember = pMember->pNext)
         {

            if(0 == (pMember->ulFlags & ATMSM_MEMBER_DROP_TRIED))
            {

               break;
            }
         }


         if(!pMember)  // we are done with all members
            break;

         RELEASE_ADAPTER_GEN_LOCK(pAdapt);

         AtmSmDropMemberFromVc(pVc, pMember);

         ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);
      }

      RELEASE_ADAPTER_GEN_LOCK(pAdapt);

      // remove the reference added to the VC while creating
      AtmSmDereferenceVc(pVc);
   }

   TraceOut(AtmSmDisconnectVc);
}

VOID AtmSmDropMemberFromVc(
   IN  PATMSM_VC           pVc,
   IN  PATMSM_PMP_MEMBER   pMemberToDrop
   )
/*++

Routine Description:
    This is used to drop a member from a PMP VC.  This could be 
    called as a result of incoming Drop request, or we are 
    initiating a drop request.

    Handle all cases
    (a) Not connected to PMP Vc
    (b) Connection being setup (MakeCall or AddParty in progress)
    (c) Connected to PMP Vc
    
Arguments:
    pVc             - Pointer to the VC.
    pMemberToDrop   - pointer to a member that is being dropped

Return Value:
    NONE

--*/
{
   PATMSM_ADAPTER  pAdapt          = (PATMSM_ADAPTER)pVc->pAdapt;
   BOOLEAN         bLockReleased   = FALSE;
   NDIS_STATUS     Status;
   NDIS_HANDLE     NdisVcHandle;
   NDIS_HANDLE     NdisPartyHandle;

   TraceIn(AtmSmDropMemberFromVc);

   DbgInfo(("pAdapt %x, pVc %x pMember %x, ConnSt %x, PartyHandle %x\n",
      pAdapt, pVc, pMemberToDrop, ATMSM_GET_MEMBER_STATE(pMemberToDrop), 
      pMemberToDrop->NdisPartyHandle));

   ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

   pMemberToDrop->ulFlags |= ATMSM_MEMBER_DROP_TRIED;

   switch(ATMSM_GET_MEMBER_STATE(pMemberToDrop))
   {

      case ATMSM_MEMBER_CONNECTED:

         NdisPartyHandle = pMemberToDrop->NdisPartyHandle;

         ASSERT(NdisPartyHandle != NULL);

         if((pVc->ulNumActiveMembers + pVc->ulNumConnectingMembers) 
            > 1)
         {

            //
            //  This is not the last member in connected or connecting
            //  state.  Hence use DropParty.
            //

            ATMSM_SET_MEMBER_STATE(pMemberToDrop, ATMSM_MEMBER_CLOSING);

            pVc->ulNumActiveMembers--;
            pVc->ulNumDroppingMembers++;

            RELEASE_ADAPTER_GEN_LOCK(pAdapt);
            bLockReleased = TRUE;

            Status = NdisClDropParty(
                        NdisPartyHandle, 
                        NULL, 
                        0
                        );

            if(NDIS_STATUS_PENDING != Status)
            {

               AtmSmDropPartyComplete(
                  Status, 
                  (NDIS_HANDLE)pMemberToDrop
                  );
            }
         }
         else
         {

            //
            // This is the last active party. Check if any DropParty()'s are
            // yet to finish.
            //
            if(0 != pVc->ulNumDroppingMembers)
            {
               //
               // This member will have to wait till all DropParty()s are
               // complete. Mark the ClusterControlVc so that we send
               // a CloseCall() when all DropParty()s are done.
               //
               ATMSM_SET_VC_STATE(pVc, ATMSM_VC_NEED_CLOSING);
            }
            else
            {
               //
               // Last active party, and no DropParty pending.
               //
               NdisVcHandle = pVc->NdisVcHandle;


               ATMSM_SET_VC_STATE(pVc, ATMSM_VC_CLOSING);
               ATMSM_SET_MEMBER_STATE(pMemberToDrop, ATMSM_MEMBER_CLOSING);

               pVc->ulNumActiveMembers--;
               pVc->ulNumDroppingMembers++;

               RELEASE_ADAPTER_GEN_LOCK(pAdapt);
               bLockReleased = TRUE;

               Status = NdisClCloseCall(
                           NdisVcHandle,
                           NdisPartyHandle,
                           NULL,
                           0
                           );

               if(NDIS_STATUS_PENDING != Status)
               {

                  AtmSmCloseCallComplete(
                     Status,
                     (NDIS_HANDLE)pVc,
                     (NDIS_HANDLE)pMemberToDrop
                     );
               }
            }
         }
         break;

      case ATMSM_MEMBER_CONNECTING:
         //
         // Mark it so that we'll delete it when the AddParty/MakeCall
         // completes.
         //
         pMemberToDrop->ulFlags |= ATMSM_MEMBER_INVALID;
         break;

      case ATMSM_MEMBER_CLOSING:
         NOTHING;
         break;

      case ATMSM_MEMBER_IDLE:
         //
         // No connection. Just unlink this from the IntF and free it.
         //

         RELEASE_ADAPTER_GEN_LOCK(pAdapt);
         bLockReleased = TRUE;

         DeleteMemberInfoFromVc(pVc, pMemberToDrop);
         break;

      default:
         ASSERT(FALSE);
         break;
   }

   if(!bLockReleased)
   {

      RELEASE_ADAPTER_GEN_LOCK(pAdapt);
   }

   TraceOut(AtmSmDropMemberFromVc);
}

PCO_CALL_PARAMETERS AtmSmPrepareCallParameters(
   IN  PATMSM_ADAPTER          pAdapt,
   IN  PHW_ADDR                pHwAddr,
   IN  BOOLEAN                 IsMakeCall,
   IN  BOOLEAN                 IsMultipointVC
   )
/*++

Routine Description:

    Allocate and fill in call parameters for use in a MakeCall

Arguments:

    pAdapt          - Ptr to Adapter
    pHwAddr         - Points to the Called ATM address and subaddress
    IsMakeCall      - MakeCall or AddParty

Return Value:

    Allocated Call Parameter

--*/
{
   PATMSM_FLOW_SPEC                        pFlowSpec;
   PCO_CALL_PARAMETERS                     pCallParameters;
   PCO_CALL_MANAGER_PARAMETERS             pCallMgrParameters;

   PQ2931_CALLMGR_PARAMETERS               pAtmCallMgrParameters;

   //
   //  All Info Elements that we need to fill:
   //
   Q2931_IE                            UNALIGNED *      pIe;
   AAL_PARAMETERS_IE                   UNALIGNED *      pAalIe;
   ATM_TRAFFIC_DESCRIPTOR_IE           UNALIGNED *      pTrafficDescriptor;
   ATM_BROADBAND_BEARER_CAPABILITY_IE  UNALIGNED *      pBbc;
   ATM_BLLI_IE                         UNALIGNED *      pBlli;
   ATM_QOS_CLASS_IE                    UNALIGNED *      pQos;

   ULONG                               RequestSize;

   RequestSize =   sizeof(CO_CALL_PARAMETERS) +
                   sizeof(CO_CALL_MANAGER_PARAMETERS) +
                   sizeof(Q2931_CALLMGR_PARAMETERS) +
                   (IsMakeCall? ATMSM_MAKE_CALL_IE_SPACE : 
                   ATMSM_ADD_PARTY_IE_SPACE);

   AtmSmAllocMem(&pCallParameters, PCO_CALL_PARAMETERS, RequestSize);

   if(NULL == pCallParameters)
   {

      return(pCallParameters);
   }

   pFlowSpec = &(pAdapt->VCFlowSpec);

   //
   //  Zero out everything
   //
   NdisZeroMemory((PUCHAR)pCallParameters, RequestSize);

   //
   //  Distribute space amongst the various structures
   //
   pCallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)
                        ((PUCHAR)pCallParameters +
                           sizeof(CO_CALL_PARAMETERS));


   //
   //  Set pointers to link the above structures together
   //
   pCallParameters->CallMgrParameters = pCallMgrParameters;
   pCallParameters->MediaParameters = (PCO_MEDIA_PARAMETERS)NULL;


   pCallMgrParameters->CallMgrSpecific.ParamType = 0;
   pCallMgrParameters->CallMgrSpecific.Length =
      sizeof(Q2931_CALLMGR_PARAMETERS) +
      (IsMakeCall? ATMSM_MAKE_CALL_IE_SPACE : 
   ATMSM_ADD_PARTY_IE_SPACE);

   pAtmCallMgrParameters = (PQ2931_CALLMGR_PARAMETERS)
                           pCallMgrParameters->CallMgrSpecific.Parameters;

   if(IsMultipointVC)
      pCallParameters->Flags |= MULTIPOINT_VC;

   //
   //  Call Manager generic flow parameters:
   //    
   pCallMgrParameters->Transmit.TokenRate = (pFlowSpec->SendBandwidth);
   pCallMgrParameters->Transmit.TokenBucketSize = (pFlowSpec->SendMaxSize);
   pCallMgrParameters->Transmit.MaxSduSize = pFlowSpec->SendMaxSize;
   pCallMgrParameters->Transmit.PeakBandwidth = (pFlowSpec->SendBandwidth);
   pCallMgrParameters->Transmit.ServiceType = pFlowSpec->ServiceType;

   //
   // We are setting up unidirectional calls, so receive side values are 0's.
   // Note: for PMP it should be 0 in all cases
   //
   pCallMgrParameters->Receive.ServiceType = pFlowSpec->ServiceType;

   //
   //  Q2931 Call Manager Parameters:
   //

   //
   //  Called address:
   //
   //
   pAtmCallMgrParameters->CalledParty = pHwAddr->Address;

   //  NOTE: Add Called Subaddress IE for E164.

   //
   //  Calling address:
   //
   pAtmCallMgrParameters->CallingParty = pAdapt->ConfiguredAddress;

   //
   //  RFC 1755 (Sec 5) says that the following IEs MUST be present in the
   //  SETUP message, so fill them all.
   //
   //      AAL Parameters
   //      Traffic Descriptor (MakeCall only)
   //      Broadband Bearer Capability (MakeCall only)
   //      Broadband Low Layer Info
   //      QoS (MakeCall only)
   //

   //
   //  Initialize the Info Element list
   //
   pAtmCallMgrParameters->InfoElementCount = 0;
   pIe = (PQ2931_IE)(pAtmCallMgrParameters->InfoElements);


   //
   //  AAL Parameters:
   //

   {
      UNALIGNED AAL5_PARAMETERS   *pAal5;

      pIe->IEType = IE_AALParameters;
      pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE;
      pAalIe = (PAAL_PARAMETERS_IE)pIe->IE;
      pAalIe->AALType = AAL_TYPE_AAL5;
      pAal5 = &(pAalIe->AALSpecificParameters.AAL5Parameters);
      pAal5->ForwardMaxCPCSSDUSize = pFlowSpec->SendMaxSize;
      pAal5->BackwardMaxCPCSSDUSize = pFlowSpec->ReceiveMaxSize;
   }

   pAtmCallMgrParameters->InfoElementCount++;
   pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


   //
   //  Traffic Descriptor:
   //

   if(IsMakeCall)
   {

      pIe->IEType = IE_TrafficDescriptor;
      pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_TRAFFIC_DESCR_IE;
      pTrafficDescriptor = (PATM_TRAFFIC_DESCRIPTOR_IE)pIe->IE;

      if(SERVICETYPE_BESTEFFORT == pFlowSpec->ServiceType)
      {

         pTrafficDescriptor->ForwardTD.PeakCellRateCLP01 =
            BYTES_TO_CELLS(pFlowSpec->SendBandwidth);
         pTrafficDescriptor->BestEffort = TRUE;

      }
      else
      {

         //  Predictive/Guaranteed service 
         // (we map this to CBR, see BBC below)

         pTrafficDescriptor->ForwardTD.PeakCellRateCLP01 =
            BYTES_TO_CELLS(pFlowSpec->SendBandwidth);
         pTrafficDescriptor->BestEffort = FALSE;
      }

      pAtmCallMgrParameters->InfoElementCount++;
      pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
   }

   //
   //  Broadband Bearer Capability
   //

   if(IsMakeCall)
   {

      pIe->IEType = IE_BroadbandBearerCapability;
      pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_BBC_IE;
      pBbc = (PATM_BROADBAND_BEARER_CAPABILITY_IE)pIe->IE;

      pBbc->BearerClass = BCOB_X;
      pBbc->UserPlaneConnectionConfig = UP_P2P;
      if(SERVICETYPE_BESTEFFORT == pFlowSpec->ServiceType)
      {

         pBbc->TrafficType = TT_NOIND;
         pBbc->TimingRequirements = TR_NOIND;
         pBbc->ClippingSusceptability = CLIP_NOT;

      }
      else
      {

         pBbc->TrafficType = TT_CBR;
         pBbc->TimingRequirements = TR_END_TO_END;
         pBbc->ClippingSusceptability = CLIP_SUS;
      }

      pAtmCallMgrParameters->InfoElementCount++;
      pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
   }

   //
   //  Broadband Lower Layer Information
   //

   pIe->IEType = IE_BLLI;
   pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE;
   pBlli = (PATM_BLLI_IE)pIe->IE;
   NdisMoveMemory((PUCHAR)pBlli,
      (PUCHAR)&AtmSmDefaultBlli,
      sizeof(ATM_BLLI_IE));

   pAtmCallMgrParameters->InfoElementCount++;
   pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);

   //
   //  QoS
   //

   if(IsMakeCall)
   {

      pIe->IEType = IE_QOSClass;
      pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_QOS_IE;
      pQos = (PATM_QOS_CLASS_IE)pIe->IE;
      if(SERVICETYPE_BESTEFFORT == pFlowSpec->ServiceType)
      {
         pQos->QOSClassForward = pQos->QOSClassBackward = 0;

      }
      else
      {

         pQos->QOSClassForward = pQos->QOSClassBackward = 1;
      }

      pAtmCallMgrParameters->InfoElementCount++;
      pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
   }

   return(pCallParameters);
}

NTSTATUS VerifyRecvOpenContext(
   PATMSM_ADAPTER      pAdapt
   )
/*++

Routine Description:
    This routine is used to verify that an open context passed is valid

    Note: we add a reference on the adapter 

Arguments:

Return Value:

--*/
{
   NTSTATUS Status = STATUS_SUCCESS;
   
   PATMSM_ADAPTER pAdapter;    
   ULONG ulNum = 0;
   
   if(pAdapt == NULL)
   {
      return STATUS_UNSUCCESSFUL;
   }
                          
   ACQUIRE_GLOBAL_LOCK();
   
   // walk the adapter list to see if this adapter exists
   for(pAdapter = AtmSmGlobal.pAdapterList; pAdapter &&
      ulNum < AtmSmGlobal.ulAdapterCount; 
      pAdapter = pAdapter->pAdapterNext)
   {
      if(pAdapt == pAdapter)
         break;
   }
   
   if(pAdapter == NULL || ulNum == AtmSmGlobal.ulAdapterCount)
   {
      RELEASE_GLOBAL_LOCK();
      return STATUS_UNSUCCESSFUL;
   }

   if(atmsm_adapter_signature != pAdapt->ulSignature)
      Status = STATUS_INVALID_PARAMETER;
   else
   {
      if(AtmSmReferenceAdapter(pAdapt))
      {
         if(FALSE == pAdapt->fAdapterOpenedForRecv)
         {
            Status = STATUS_INVALID_PARAMETER;

            // remove the reference
            AtmSmDereferenceAdapter(pAdapt);
         }
      }
      else
         Status = STATUS_UNSUCCESSFUL;
   }

   RELEASE_GLOBAL_LOCK();

   return Status;
}

NTSTATUS VerifyConnectContext(
   PATMSM_VC       pVc
   )
/*++

Routine Description:
    This routine is used to verify that a connect context passed is valid

    Note: we add a reference on the VC

Arguments:

Return Value:

--*/
{
   NTSTATUS Status = STATUS_SUCCESS;

   try
   {

      if((atmsm_vc_signature != pVc->ulSignature) ||
         (NULL == pVc->pAdapt))
         Status = STATUS_INVALID_PARAMETER;
      else
      {

         if(!AtmSmReferenceVc(pVc))
            Status = STATUS_UNSUCCESSFUL;
         else
         {

            PATMSM_ADAPTER      pAdapt = pVc->pAdapt;

            if(atmsm_adapter_signature != pAdapt->ulSignature)
            {
               Status = STATUS_INVALID_PARAMETER;

               // remove the VC reference
               AtmSmDereferenceVc(pVc);
            }

         }
      }

   }except(EXCEPTION_EXECUTE_HANDLER)
   {

      Status = GetExceptionCode(); 
      DbgErr(("VerifyConnectContext: CC 0x%x exception - 0x%x\n", 
         pVc, Status));
      return Status;
   }

   return Status;
}

UINT CopyPacketToIrp(
   PIRP            pIrp,
   PNDIS_PACKET    pPkt
   )
/*++

Routine Description:
    This routine is used to copy the connects of a packet into the user supplied
    buffer.

Arguments:

Return Value:

--*/
{
   PNDIS_BUFFER    pPktBuffer;
   PVOID           pPktBufferVA, pDstBufferVA;
   UINT            uiBufSize, uiTotalLen, uiMdlSizeLeft;
   UINT            uiCopySize, uiTotalBytesCopied;

   NdisGetFirstBufferFromPacketSafe(pPkt,
      &pPktBuffer,
      &pPktBufferVA,
      &uiBufSize,
      &uiTotalLen,
      NormalPagePriority);

   if (pPktBufferVA == NULL)
   {
      return 0;
   }

   ASSERT(pPktBuffer && (0 != uiBufSize));

   uiTotalBytesCopied  = 0;

   uiMdlSizeLeft = MmGetMdlByteCount(pIrp->MdlAddress);

   pDstBufferVA = MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority);
   if(pDstBufferVA != NULL && uiMdlSizeLeft != 0)
   {
      while(pPktBuffer)
      {
         uiCopySize = (uiMdlSizeLeft < uiBufSize) ? uiMdlSizeLeft :uiBufSize;
   
         // copy the data
         NdisMoveMemory(pDstBufferVA, pPktBufferVA, uiCopySize);
   
         pDstBufferVA         = (PVOID) ((PCHAR)pDstBufferVA + uiCopySize);
         uiTotalBytesCopied  += uiCopySize;
   
         uiMdlSizeLeft       -= uiCopySize;
   
         if(uiMdlSizeLeft <= 0)
            break;
   
         // get the next buffer
         NdisGetNextBuffer(pPktBuffer, &pPktBuffer);
   
         // get details of the new buffer
         if(pPktBuffer)
         {
            NdisQueryBufferSafe(pPktBuffer, &pPktBufferVA, &uiBufSize, NormalPagePriority);
            if(pPktBufferVA == NULL)
               break;
         }
      }
   }

   return uiTotalBytesCopied;
}

VOID AtmSmRecvReturnTimerFunction (
   IN  PVOID                   SystemSpecific1,
   IN  PVOID                   FunctionContext,
   IN  PVOID                   SystemSpecific2,
   IN  PVOID                   SystemSpecific3
   )
/*++

Routine Description:

    This timer function, checks to see there are any buffered packets that has
    been around for a while.  If so it gives the packet back to the miniport
    driver.
    It queues itself back if there are anymore packets in the queue

    We use NdisGetSystemUpTime, since that is all the resolution we want

Arguments:

    SystemSpecific1 -   Not used
    FunctionContext -   Adapter
    SystemSpecific2 -   Not used
    SystemSpecific3 -   Not used

Return Value:

    None.

--*/
{
   PATMSM_ADAPTER  pAdapt = (PATMSM_ADAPTER)FunctionContext;
   ULONG           ulTime;
   BOOLEAN         bShouldQueueTimerAgain = FALSE;

   ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

   pAdapt->fRecvTimerQueued = FALSE;

   NdisGetSystemUpTime(&ulTime);


   // check if any packets have been sitting around for long
   // if so, return them

   while(pAdapt->pRecvPktNext)
   {

      PPROTO_RSVD     pPRsvd;
      PNDIS_PACKET    pPkt;

      pPkt    = pAdapt->pRecvPktNext;
      pPRsvd  = GET_PROTO_RSVD(pPkt);

      if((ulTime - pPRsvd->ulTime) >= RECV_BUFFERING_TIME)
      {

         pAdapt->pRecvPktNext    = pPRsvd->pPktNext;

         if(pAdapt->pRecvLastPkt == pPkt)
            pAdapt->pRecvLastPkt = NULL;

         DbgVeryLoud(("Returning a packet that was buffered too long\n"));

         pAdapt->ulRecvPktsCount--;

         // release the recv queue lock
         RELEASE_ADAPTER_GEN_LOCK(pAdapt);

         // return the packet to the miniport
         NdisReturnPackets(&pPkt, 1);

         ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

      }
      else
      {

         // time hasn't expired for this packet
         ulTime = RECV_BUFFERING_TIME - (ulTime - pPRsvd->ulTime);

         bShouldQueueTimerAgain = TRUE;

         break;
      }
   }

   if(bShouldQueueTimerAgain)
   {

      SET_ADAPTER_RECV_TIMER(pAdapt, ulTime);
   }

   RELEASE_ADAPTER_GEN_LOCK(pAdapt);

   return;
}

VOID AtmSmConnectToPMPDestinations(
   IN  PATMSM_VC           pVc
   )
/*++

Routine Description:

    This will make a call to the destination in PMP case.  It will MakeCall
    to the first member.  Subsequent destinations are added using AddParty.

Arguments:

    pVc           - Ptr to a PMP Vc

Return Value:

    None

--*/
{
   PATMSM_ADAPTER          pAdapt        = (PATMSM_ADAPTER)pVc->pAdapt;
   BOOLEAN                 bLockReleased = FALSE;
   PCO_CALL_PARAMETERS     pCallParameters;
   NDIS_HANDLE             ProtocolVcContext;
   NDIS_HANDLE             ProtocolPartyContext;
   NDIS_STATUS             Status;
   PATMSM_PMP_MEMBER       pMember;

   TraceIn(AtmSmConnectToPMPDestinations);

   ASSERT(VC_TYPE_PMP_OUTGOING == pVc->VcType);

   ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

   do
   {    // break off loop

      // First find any member addresses that is not yet connected
      for(pMember = pVc->pPMPMembers; pMember; pMember = pMember->pNext)
         if(ATMSM_GET_MEMBER_STATE(pMember) == ATMSM_MEMBER_IDLE)
            break;

         // if there are no - more members to be connected then get out
      if(!pMember)
      {
         break;
      }

      ProtocolVcContext    = (NDIS_HANDLE)pVc;
      ProtocolPartyContext = (NDIS_HANDLE)pMember;

      //
      // First see if we have connected 1 or more members
      //
      if(0 == pVc->ulNumActiveMembers)
      {
         // No one is connected yet, so do a MakeCall

         ASSERT(ATMSM_GET_VC_STATE(pVc) != ATMSM_VC_ACTIVE);

         if(NULL == pVc->NdisVcHandle)
         {

            Status = NdisCoCreateVc(
                        pAdapt->NdisBindingHandle,
                        pAdapt->NdisAfHandle,
                        (NDIS_HANDLE)pVc,
                        &pVc->NdisVcHandle
                        );

            if(NDIS_STATUS_SUCCESS != Status)
            {

               break;
            }

            DbgVeryLoud(("AddMembers: Created VC, VC %x, NdisVcHandle %x\n",
               pVc, pVc->NdisVcHandle));
         }

         ASSERT(NULL != pVc->NdisVcHandle);

         pCallParameters = AtmSmPrepareCallParameters(pAdapt, 
                              &pMember->HwAddr, 
                              TRUE,
                              TRUE);
         if(pCallParameters == (PCO_CALL_PARAMETERS)NULL)
         {

            Status = NdisCoDeleteVc(pVc->NdisVcHandle);
            ASSERT(NDIS_STATUS_SUCCESS == Status);

            pVc->NdisVcHandle = NULL;
            Status = NDIS_STATUS_RESOURCES;

            break;
         }

         ATMSM_SET_VC_STATE(pVc, ATMSM_VC_SETUP_IN_PROGRESS);

         ATMSM_SET_MEMBER_STATE(pMember, ATMSM_MEMBER_CONNECTING);

         pVc->ulNumConnectingMembers++;

         RELEASE_ADAPTER_GEN_LOCK(pAdapt);
         bLockReleased = TRUE;

         Status = NdisClMakeCall(
                     pVc->NdisVcHandle,
                     pCallParameters,
                     ProtocolPartyContext,
                     &pMember->NdisPartyHandle
                     );

         if(NDIS_STATUS_PENDING != Status)
         {

            AtmSmMakeCallComplete(
               Status,
               ProtocolVcContext,
               pMember->NdisPartyHandle,
               pCallParameters
               );
         }

      }
      else
      {
         // we have atleast one connected member, add the rest using AddParty

         ASSERT(NULL != pVc->NdisVcHandle);

         pCallParameters = AtmSmPrepareCallParameters(pAdapt, 
                              &pMember->HwAddr, 
                              FALSE,
                              TRUE);
         if(pCallParameters == (PCO_CALL_PARAMETERS)NULL)
         {

            Status = NDIS_STATUS_RESOURCES;
            break;
         }


         ATMSM_SET_VC_STATE(pVc, ATMSM_VC_ADDING_PARTIES);

         ATMSM_SET_MEMBER_STATE(pMember, ATMSM_MEMBER_CONNECTING);

         pVc->ulNumConnectingMembers++;

         RELEASE_ADAPTER_GEN_LOCK(pAdapt);
         bLockReleased = TRUE;

         Status = NdisClAddParty(
                     pVc->NdisVcHandle,
                     ProtocolPartyContext,
                     pCallParameters,
                     &pMember->NdisPartyHandle
                     );

         if(NDIS_STATUS_PENDING != Status)
         {

            AtmSmAddPartyComplete(
               Status,
               ProtocolPartyContext,
               pMember->NdisPartyHandle,
               pCallParameters
               );
         }

      }

   }while(FALSE);

   if(!bLockReleased)
   {

      RELEASE_ADAPTER_GEN_LOCK(pAdapt);
   }


   if(pVc->ulNumActiveMembers && 
      (pVc->ulNumActiveMembers == pVc->ulNumTotalMembers))
   {

      PIRP pIrp;

      //
      //  1 or more members are connected, send any packets pending on the VC.
      //
      ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

      DbgInfo(("PMP VC 0x%x connected - %u members\n", pVc, 
         pVc->ulNumActiveMembers));

      ATMSM_SET_VC_STATE(pVc, ATMSM_VC_ACTIVE);

      // now complete IRP that started this connect call
      pIrp = pVc->pConnectIrp;
      pVc->pConnectIrp = NULL;

      ASSERT(pIrp);

      // remove the Vc from the inactive list
      RemoveEntryList(&pVc->List);

      // insert the vc into the active list
      InsertHeadList(&pAdapt->ActiveVcHead, &pVc->List);

      RELEASE_ADAPTER_GEN_LOCK(pAdapt);

      if(pIrp)
      {

         pIrp->IoStatus.Status = STATUS_SUCCESS;

         // now set the connect context
         *(PHANDLE)(pIrp->AssociatedIrp.SystemBuffer) = (HANDLE)pVc;
         pIrp->IoStatus.Information = sizeof(HANDLE);

         IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
      }

      AtmSmSendQueuedPacketsOnVc(pVc);

   }
   else
   {

      if(0 == pVc->ulNumTotalMembers)
      {

         // now complete IRP that started this connect call
         PIRP pIrp = pVc->pConnectIrp;

         pVc->pConnectIrp = NULL;

         ASSERT(pIrp);

         if(pIrp)
         {

            pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

            pIrp->IoStatus.Information = 0;

            IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
         }

         DbgInfo(("PMP VC 0x%x failed to connect any members\n", pVc));

         // Cleanup the VC - remove the reference added at create
         AtmSmDereferenceVc(pVc);
      }
   }

   TraceOut(AtmSmConnectToPMPDestinations);
}

VOID AtmSmConnectPPVC(
   IN  PATMSM_VC           pVc
   )
/*++

Routine Description:

    This will make a call to the destination in PP case.  It will MakeCall
    to the destination.

Arguments:

    pVc           - Ptr to a PP Vc

Return Value:

    None

--*/
{
   PATMSM_ADAPTER          pAdapt        = (PATMSM_ADAPTER)pVc->pAdapt;
   BOOLEAN                 bLockReleased = FALSE;
   PCO_CALL_PARAMETERS     pCallParameters;
   NDIS_HANDLE             ProtocolVcContext;
   NDIS_STATUS             Status;

   TraceIn(AtmSmConnectPPVC);

   ASSERT(VC_TYPE_PP_OUTGOING == pVc->VcType);

   ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

   do
   {    // break off loop

      ProtocolVcContext    = (NDIS_HANDLE)pVc;

      ASSERT(ATMSM_GET_VC_STATE(pVc) != ATMSM_VC_ACTIVE);

      ASSERT(NULL == pVc->NdisVcHandle);

      if(NULL == pVc->NdisVcHandle)
      {

         Status = NdisCoCreateVc(
                     pAdapt->NdisBindingHandle,
                     pAdapt->NdisAfHandle,
                     (NDIS_HANDLE)pVc,
                     &pVc->NdisVcHandle
                     );

         if(NDIS_STATUS_SUCCESS != Status)
         {

            break;
         }

         DbgVeryLoud(("Connect: Created VC, VC %x, NdisVcHandle %x\n",
            pVc, pVc->NdisVcHandle));
      }

      ASSERT(NULL != pVc->NdisVcHandle);

      pCallParameters = AtmSmPrepareCallParameters(pAdapt, 
                           &pVc->HwAddr, 
                           TRUE,
                           FALSE);
      if(pCallParameters == (PCO_CALL_PARAMETERS)NULL)
      {

         Status = NdisCoDeleteVc(pVc->NdisVcHandle);
         pVc->NdisVcHandle = NULL;

         Status = NDIS_STATUS_RESOURCES;
         break;
      }

      ATMSM_SET_VC_STATE(pVc, ATMSM_VC_SETUP_IN_PROGRESS);

      RELEASE_ADAPTER_GEN_LOCK(pAdapt);
      bLockReleased = TRUE;

      Status = NdisClMakeCall(
                  pVc->NdisVcHandle,
                  pCallParameters,
                  NULL,
                  NULL
                  );

      if(NDIS_STATUS_PENDING != Status)
      {

         AtmSmMakeCallComplete(
            Status,
            ProtocolVcContext,
            NULL,
            pCallParameters
            );
      }

   }while(FALSE);

   if(!bLockReleased)
   {

      RELEASE_ADAPTER_GEN_LOCK(pAdapt);
   }


   TraceOut(AtmSmConnectPPVC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\samples\atmsmpl\driver\atmsmdrv.h ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation, All Rights Reserved.

Module Name:

    atmsmdrv.h

Abstract:

    ATM sample client driver header file. 

    Note : We use one lock per interface.  When there are more VC's per
    interface we could have a locking mechanism that is finer than this.

Author:

    Anil Francis Thomas (10/98)

Environment:

    Kernel

Revision History:

--*/

#ifndef __ATMSMDRV_H_
#define __ATMSMDRV_H_

#define DEFAULT_NUM_PKTS_IN_POOL    512

#define MAX_FREE_PKTS_TO_KEEP       512
#define MAX_PKTS_AT_ONCE_ON_TIMER   25
#define DEFAULT_TIMER_INTERVAL      MIN_DELAY       // in millisec


#define ATM_SAMPLE_CLIENT_DEVICE_NAME     L"\\Device\\ATMSampleClient"
#define ATM_SAMPLE_CLIENT_SYMBOLIC_NAME   L"\\DosDevices\\ATMSampleClient"


//
//
//
typedef struct _HwAddr {
    ATM_ADDRESS         Address;
    PATM_ADDRESS        SubAddress;
} HW_ADDR, *PHW_ADDR;


//
// Flow Specifications for an ATM Connection. The structure
// represents a bidirectional flow.
//
typedef struct _ATMSM_FLOW_SPEC
{
    ULONG                       SendBandwidth;      // Bytes/Sec
    ULONG                       SendMaxSize;        // Bytes
    ULONG                       ReceiveBandwidth;   // Bytes/Sec
    ULONG                       ReceiveMaxSize;     // Bytes
    SERVICETYPE                 ServiceType;

} ATMSM_FLOW_SPEC, *PATMSM_FLOW_SPEC;


//
// used for blocking request
//
typedef struct _ATMSM_BLOCK {
    NDIS_EVENT          Event;
    NDIS_STATUS         Status;
} ATMSM_BLOCK, *PATMSM_BLOCK;

#define INIT_BLOCK_STRUCT(pBlock)    NdisInitializeEvent(&((pBlock)->Event))
#define RESET_BLOCK_STRUCT(pBlock)   NdisResetEvent(&((pBlock)->Event))
#define WAIT_ON_BLOCK_STRUCT(pBlock)                        \
                    (NdisWaitEvent(&((pBlock)->Event), 0), (pBlock)->Status)
#define SIGNAL_BLOCK_STRUCT(pBlock, _Status) {              \
                        (pBlock)->Status = _Status;         \
                        NdisSetEvent(&((pBlock)->Event));   \
                    }

//
//  Some forward declarations
//
typedef struct _AtmSmPMPMember  ATMSM_PMP_MEMBER, *PATMSM_PMP_MEMBER;
typedef struct _AtmSmVc         ATMSM_VC, *PATMSM_VC;
typedef struct _AtmSmAdapter    ATMSM_ADAPTER, *PATMSM_ADAPTER;



//
// used to represent a party in the point to multipoint call
//
typedef struct _AtmSmPMPMember{
    ULONG                   ulSignature;

    PATMSM_PMP_MEMBER       pNext;
    PATMSM_VC               pVc;            // back pointer to the Vc
    ULONG                   ulFlags;        // State and other info
    NDIS_HANDLE             NdisPartyHandle;// NDIS handle for this leaf
    HW_ADDR                 HwAddr;         // From CallingPartyAddress

}ATMSM_PMP_MEMBER, *PATMSM_PMP_MEMBER;

#define atmsm_member_signature   'MMMS'


// Flags in ATMSM_PMP_MEMBER
#define ATMSM_MEMBER_IDLE         0x00000001
#define ATMSM_MEMBER_CONNECTING   0x00000002
#define ATMSM_MEMBER_CONNECTED    0x00000004
#define ATMSM_MEMBER_CLOSING      0x00000008
#define ATMSM_MEMBER_STATES       0x0000000F
#define ATMSM_MEMBER_DROP_TRIED   0x01000000
#define ATMSM_MEMBER_INVALID      0x80000000  // Invalidated entry

#define ATMSM_GET_MEMBER_STATE(_pMember)          \
            (_pMember->ulFlags & ATMSM_MEMBER_STATES)

#define ATMSM_SET_MEMBER_STATE(_pMember, _State)  \
            (_pMember->ulFlags = ((_pMember->ulFlags & ~ATMSM_MEMBER_STATES) \
                                                | _State))
#define ATMSM_IS_MEMBER_INVALID(_pMember)         \
            (_pMember->ulFlags & ATMSM_MEMBER_INVALID)


//
// VC
//
//  Reference count:
//      Incoming call (PP and PMP) VC   1 at create + 1 at call connect
//      Outgoing call (PP)              1 at create 
//      Outgoing call (PMP)             1 at create + 1 for each Member
//
typedef struct _AtmSmVc
{
    // Note Vc signature is used always
    ULONG               ulSignature;

    ULONG               VcType;     
    LIST_ENTRY          List;
    ULONG               ulRefCount;
    ULONG               ulFlags;
    NDIS_HANDLE         NdisVcHandle;
    PATMSM_ADAPTER      pAdapt;
    ULONG               MaxSendSize;// From AAL parameters

    // the following is used in the case of unicast and incoming PMP call
    HW_ADDR             HwAddr;     

    // the following the IRP that initiated an outgoing call
    PIRP                pConnectIrp;

    // the following are used for outgoing PMP calls
    ULONG               ulNumTotalMembers;
    ULONG               ulNumActiveMembers;
    ULONG               ulNumConnectingMembers;
    ULONG               ulNumDroppingMembers;
    PATMSM_PMP_MEMBER   pPMPMembers;

    //
    // Send queue to hold packets when the Vc is connecting
    //
    PNDIS_PACKET        pSendLastPkt;   // cache the last packet for 
                                        // adding to tail
    PNDIS_PACKET        pSendPktNext;
    ULONG               ulSendPktsCount;

} ATMSM_VC, *PATMSM_VC;

#define atmsm_vc_signature          'CVMS'
#define atmsm_dead_vc_signature     'VAED'

#define ATMSM_VC_IDLE                0x00000001      // outgoing
#define ATMSM_VC_ACTIVE              0x00000002      // out\in
#define ATMSM_VC_CALLPROCESSING      0x00000004      // in
#define ATMSM_VC_SETUP_IN_PROGRESS   0x00000008      // out
#define ATMSM_VC_ADDING_PARTIES      0x00000010      // out
#define ATMSM_VC_CLOSING             0x00000020      // out\in
#define ATMSM_VC_CLOSED              0x00000040      // out\in
#define ATMSM_VC_NEED_CLOSING        0x00000080      // pmp out
#define ATMSM_VC_STATES              0x000000FF

#define ATMSM_GET_VC_STATE(_pVc)          \
            (_pVc->ulFlags & ATMSM_VC_STATES)

#define ATMSM_SET_VC_STATE(_pVc, _State)  \
            (_pVc->ulFlags = ((_pVc->ulFlags & ~ATMSM_VC_STATES) \
                                                | _State))
//
// VC types:
//
#define VC_TYPE_INCOMING            ((ULONG)1)
#define VC_TYPE_PP_OUTGOING         ((ULONG)2)
#define VC_TYPE_PMP_OUTGOING        ((ULONG)3)


//
// ADAPTER
//
//  Reference count:
//      1 at create         +
//      1 for Open AF       +
//      1 for each Vc       + 
//      1 for each request  
//
typedef struct _AtmSmAdapter {

    // Note adapter signature is used always
    ULONG               ulSignature;

    PATMSM_ADAPTER      pAdapterNext;

    ULONG               ulRefCount;         // reference count
    ULONG               ulFlags;            // Flags Opened,Closed etc

    NDIS_STRING         BoundToAdapterName; // Adapter we are bound to

    NDIS_HANDLE         NdisBindContext;    // BindContext in BindAdapter
    NDIS_HANDLE         UnbindContext;      // UnBindContext in UnbindAdapter

    NDIS_HANDLE         NdisBindingHandle;  // To the Adapter
    NDIS_MEDIUM         Medium;

    PNDIS_EVENT         pCleanupEvent;      // pointer to an event used in
                                            // Close Adapter

    ATMSM_BLOCK         RequestBlock;       // Used for making requests

    // AF related
    NDIS_HANDLE         NdisAfHandle;
    CO_ADDRESS_FAMILY   AddrFamily;     // For use by NdisClOpenAddressFamily

    // Sap related
    NDIS_HANDLE         NdisSapHandle; 
    PCO_SAP             pSap;            // For use by NdisClRegisterSap


    ATMSM_FLOW_SPEC     VCFlowSpec;


    // Lock used for manipulating Pools and packets
    NDIS_SPIN_LOCK      AdapterLock;

    // Packet Pool Handle
    NDIS_HANDLE         PacketPoolHandle;

    // Buffer Pool Handle
    NDIS_HANDLE         BufferPoolHandle;

    LIST_ENTRY          InactiveVcHead;     // Created Vcs go here.
    LIST_ENTRY          ActiveVcHead;       // Vcs with active calls go here.

    ATM_ADDRESS         ConfiguredAddress;  // Configured address of the adapter

    NDIS_CO_LINK_SPEED  LinkSpeed;
    ULONG               MaxPacketSize;

    // used for recvs on this adapter
    PIRP                pRecvIrp;       // refers to the user request

    //
    // Recv queue (for buffering received packets)
    //
    PNDIS_PACKET        pRecvLastPkt;   // cache the last packet for 
                                        // adding to tail
    PNDIS_PACKET        pRecvPktNext;
    ULONG               ulRecvPktsCount;

    // the timer object for returning packets that are queued
    NDIS_TIMER          RecvTimerOb;


    //
    // Interface Properties
    //
    BOOLEAN             fRecvTimerQueued;

    BOOLEAN             fAdapterOpenedForRecv;    

    UCHAR               SelByte;

} ATMSM_ADAPTER, *PATMSM_ADAPTER;

#define atmsm_adapter_signature         'DAMS'
#define atmsm_dead_adapter_signature    'DAED'

// Values for ulFlags
#define ADAPT_CREATED           0x00000001
#define ADAPT_OPENED            0x00000002
#define ADAPT_AF_OPENED         0x00000004
#define ADAPT_SAP_REGISTERED    0x00000008
#define ADAPT_SHUTTING_DOWN     0x00000010
#define ADAPT_CLOSING           0x00000020
#define ADAPT_ADDRESS_INVALID   0x00010000


//
// Structure used for representing Global Properties
//
typedef struct _AtmSmGlobal {

    ULONG               ulSignature;

    // Initialization sequence flag
    ULONG               ulInitSeqFlag;

    ULONG               ulNumCreates;

    // Global Properties - maintained for reference (to return in Get calls)
    ULONG               ulRecvDelay;        // millisecs
    ULONG               ulSendDelay;        // millisecs
    ULONG               ulSimulateSendPktLoss;  // Percentage
    ULONG               ulSimulateRecvPktLoss;  // Percentage
    BOOLEAN             fSimulateResLimit;
    BOOLEAN             fDontRecv;
    BOOLEAN             fDontSend;


    NDIS_HANDLE         ProtHandle;
    NDIS_HANDLE         MiniportHandle;

    PATMSM_ADAPTER      pAdapterList;
    ULONG               ulAdapterCount;
    PDRIVER_OBJECT      pDriverObject;
    PDEVICE_OBJECT      pDeviceObject;

    // General purpose Lock
    NDIS_SPIN_LOCK      Lock;

}ATMSM_GLOBAL, *PATMSM_GLOBAL;

#define atmsm_global_signature   'LGMS'

// values for ulInitSeqFlag
#define  CREATED_IO_DEVICE      0x00000001
#define  REGISTERED_SYM_NAME    0x00000002
#define  REGISTERED_WITH_NDIS   0x00000004


//
// If the adapter is opened for recvs,
// received data is buffered for a while before returning to the
// miniport.  Buffers passed from the user mode is filled with 
// arriving data.  If no buffers arrive user mode call pends.
//


//
// Prototype of the routines handling DeviceIoCntrl
//
typedef NTSTATUS (*PATMSM_IOCTL_FUNCS)(
    PIRP                pIrp,
    PIO_STACK_LOCATION  pIrpSp
    );

//
// Protocol reserved part of the packet
// This is used for packets send down to miniport below us.
// The pNext is also used while holding these packets in
// our queues (Free, Send, Recv). ulTime is used as the time
// at which the packet was queued
//
typedef struct _ProtRsvd
{
    ULONG               ulTime;         // in milliseconds
    PNDIS_PACKET        pPktNext;
    PIRP                pSendIrp;
} PROTO_RSVD, *PPROTO_RSVD;


#define GET_PROTO_RSVD(pPkt)    \
                    ((PPROTO_RSVD)(pPkt->ProtocolReserved))

//
// Some global data
//
extern  ATMSM_GLOBAL        AtmSmGlobal;
extern  ATM_BLLI_IE         AtmSmDefaultBlli;
extern  ATM_BHLI_IE         AtmSmDefaultBhli;
extern  ATMSM_FLOW_SPEC     AtmSmDefaultVCFlowSpec;
extern  PATMSM_IOCTL_FUNCS  AtmSmFuncProcessIoctl[ATMSM_MAX_FUNCTION_CODE+1];
extern  ULONG               AtmSmIoctlTable[ATMSM_NUM_IOCTLS];

#define BYTES_TO_CELLS(_b)  ((_b)/48)

//
//  Rounded-off size of generic Q.2931 IE header
//
#define ROUND_OFF(_size)        (((_size) + 3) & ~0x4)

#define SIZEOF_Q2931_IE             ROUND_OFF(sizeof(Q2931_IE))
#define SIZEOF_AAL_PARAMETERS_IE    ROUND_OFF(sizeof(AAL_PARAMETERS_IE))
#define SIZEOF_ATM_TRAFFIC_DESCR_IE ROUND_OFF(sizeof(ATM_TRAFFIC_DESCRIPTOR_IE))
#define SIZEOF_ATM_BBC_IE           ROUND_OFF(sizeof(ATM_BROADBAND_BEARER_CAPABILITY_IE))
#define SIZEOF_ATM_BLLI_IE          ROUND_OFF(sizeof(ATM_BLLI_IE))
#define SIZEOF_ATM_QOS_IE           ROUND_OFF(sizeof(ATM_QOS_CLASS_IE))

//
//  Total space required for Information Elements in an outgoing call.
//
#define ATMSM_MAKE_CALL_IE_SPACE (   \
                        SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE +    \
                        SIZEOF_Q2931_IE + SIZEOF_ATM_TRAFFIC_DESCR_IE + \
                        SIZEOF_Q2931_IE + SIZEOF_ATM_BBC_IE + \
                        SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE + \
                        SIZEOF_Q2931_IE + SIZEOF_ATM_QOS_IE )


//
//  Total space required for Information Elements in an outgoing AddParty.
//
#define ATMSM_ADD_PARTY_IE_SPACE (   \
                        SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE +    \
                        SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE )


//
// Some defaults
//
#define DEFAULT_SEND_BANDWIDTH      (ATM_USER_DATA_RATE_SONET_155*100/8)    
                                                    // Bytes/sec
#define DEFAULT_RECV_BANDWIDTH      0
#define DEFAULT_MAX_PACKET_SIZE     9180            // Bytes

#define RECV_BUFFERING_TIME         500             // millisecs

//
// useful Macros
//
#define ACQUIRE_GLOBAL_LOCK()       NdisAcquireSpinLock(&AtmSmGlobal.Lock)
#define RELEASE_GLOBAL_LOCK()       NdisReleaseSpinLock(&AtmSmGlobal.Lock)

#define ACQUIRE_ADAPTER_GEN_LOCK(pA)    NdisAcquireSpinLock(&pA->AdapterLock)
#define RELEASE_ADAPTER_GEN_LOCK(pA)    NdisReleaseSpinLock(&pA->AdapterLock)


#define SET_ADAPTER_RECV_TIMER(pA, uiTimerDelay) {  \
        NdisSetTimer(&pA->RecvTimerOb,              \
                      uiTimerDelay);                \
        pA->fRecvTimerQueued = TRUE;                \
    }

#define CANCEL_ADAPTER_RECV_TIMER(pA, pfTimerCancelled) {   \
        NdisCancelTimer(&pA->RecvTimerOb,                   \
                         pfTimerCancelled);                 \
        pA->fRecvTimerQueued = FALSE;                       \
    }




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\makefile.inc ===
TARGETPATH=obj$(BUILD_ALT_DIR)

C_DEFINES=$(C_DEFINES) -DWIN32 -DUNICODE -D_UNICODE -D_NTSDK=1
C_DEFINES=$(C_DEFINES) -DUSE_HEAP_ALLOC=1 -DMPR50=1 -DENABLE_1394

!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DENABLETRACE
!ENDIF

MSC_WARNING_LEVEL=/W3 /WX

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=$(PROJDIR)\inc\pch.h
PRECOMPILED_OPTION=/Yu /Fp$(O)\pch.pch
PRECOMPILED_TARGET=$(O)\pch.pch
PRECOMPILED_OBJ=$(O)\pch.obj

RCOPTIONS=-N
UMTYPE=windows
USE_STATIC_ATL=1
USE_MSVCRT=1

!IF "$(TARGETTYPE)" == "PROGRAM"
UMLIBS=$(PROJDIR)\lib\$(O)\ncbase.lib
!ELSE
LINKLIBS=$(PROJDIR)\lib\$(O)\ncbase.lib
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\samples\atmsmpl\driver\sendrecv.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation, All Rights Reserved.

Module Name:

    sendrecv.c

Abstract:

    This module contains the send and receive related routine for the driver.

Author:

    Anil Francis Thomas (10/98)

Environment:

    Kernel

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop


#define MODULE_ID    MODULE_SEND


VOID
AtmSmSendPacketOnVc(
    IN  PATMSM_VC               pVc,
    IN  PNDIS_PACKET            pPacket
    )
/*++

Routine Description:

    Attempt to send a packet on a VC, if the VC is connecting, then
    queue the packet on it.

Arguments:

    pVc           - Pointer to the VC
    pPacket       - Packet to be sent

Return Value:

    None

--*/
{
    PATMSM_ADAPTER    pAdapt = pVc->pAdapt;

    DbgInfo(("AtmSmSendPacketOnVc: Packet %x, pVc %lx\n",
                                                pPacket, pVc));


    // if we can add a reference to the VC and if its state is active
    // then we can send a packet on it

    if(!AtmSmReferenceVc(pVc)){

        NDIS_SET_PACKET_STATUS(pPacket, NDIS_STATUS_CLOSING);

        AtmSmCoSendComplete(NDIS_STATUS_CLOSING, (NDIS_HANDLE)pVc, pPacket);
        
        return;
    }

    if(ATMSM_GET_VC_STATE(pVc) == ATMSM_VC_ACTIVE){    

        // we can send on the Vc
        NDIS_SET_PACKET_STATUS(pPacket, NDIS_STATUS_SUCCESS);

        NdisCoSendPackets(pVc->NdisVcHandle, &pPacket, 1);

    } else {
        // we will queue the packet on the Vc

        PPROTO_RSVD     pPRsvd;


        ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);


        pPRsvd = GET_PROTO_RSVD(pPacket);


        pPRsvd->pPktNext = NULL;


        if(pVc->pSendLastPkt){

            pPRsvd = GET_PROTO_RSVD(pVc->pSendLastPkt);

            pPRsvd->pPktNext = pPacket;

        } else
            pVc->pSendPktNext = pPacket;


        pVc->pSendLastPkt = pPacket;

        pVc->ulSendPktsCount++;


        RELEASE_ADAPTER_GEN_LOCK(pAdapt);

    }

    // remove the reference we added above
    AtmSmDereferenceVc(pVc);

    return;
}


VOID
AtmSmSendQueuedPacketsOnVc(
    IN  PATMSM_VC       pVc
    )
/*++

Routine Description:

    When a P-P VC is connected or when a PMP VC has added all parties,
    this routine will start sending any queued packets on ths VC.

    Note:  In this example we won't have any packets to send, since the
    app start sending only once the VC is connected.

Arguments:

    pVc           - pointer to the VC

Return Value:

    None

--*/
{
    PATMSM_ADAPTER  pAdapt = pVc->pAdapt;
    PPROTO_RSVD     pPRsvd;
    PNDIS_PACKET    pPacket;

    TraceIn(AtmSmSendQueuedPacketsOnVc);

    ASSERT(ATMSM_GET_VC_STATE(pVc) == ATMSM_VC_ACTIVE);


    ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

    while(pVc->pSendPktNext){

        pPacket = pVc->pSendPktNext;

        pPRsvd = GET_PROTO_RSVD(pPacket);

        pVc->pSendPktNext = pPRsvd->pPktNext;

        // this is the last packet
        if(pVc->pSendLastPkt == pPacket)
            pVc->pSendLastPkt = NULL;

        pVc->ulSendPktsCount--;

        RELEASE_ADAPTER_GEN_LOCK(pAdapt);

        // we can send the packet now
        NDIS_SET_PACKET_STATUS(pPacket, NDIS_STATUS_SUCCESS);

        NdisCoSendPackets(pVc->NdisVcHandle, &pPacket, 1);

        ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);
    }


    RELEASE_ADAPTER_GEN_LOCK(pAdapt);

    TraceOut(AtmSmSendQueuedPacketsOnVc);

    return;
}

VOID
AtmSmCoSendComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNDIS_PACKET            pPacket
    )
/*++

Routine Description:

    Completion routine for the previously pended send. 

Arguments:

    Status              Status of Completion
    ProtocolVcContext   Pointer to the Vc
    Packet              The packet in question

Return Value:


--*/
{
    PATMSM_VC       pVc = (PATMSM_VC)ProtocolVcContext;
    PPROTO_RSVD     pPRsvd;
    PIRP            pIrp;

    pPRsvd  = GET_PROTO_RSVD(pPacket);

    DbgInfo(("AtmSmCoSendComplete: Packet 0x%x, pVc 0x%lx Status - 0x%x\n",
                                                pPacket, pVc, Status));

    if (Status != NDIS_STATUS_SUCCESS){

        DbgErr(("AtmSmSCoSendComplete: Failed for Vc = %lx, status = %lx\n", 
                                                                pVc,Status));
    }

    pIrp  = pPRsvd->pSendIrp;

#ifdef BUG_IN_NEW_DMA

    {
        PNDIS_BUFFER    pBuffer;

        NdisQueryPacket(pPacket,
                        NULL,
                        NULL,
                        &pBuffer,
                        NULL);

        NdisFreeBuffer(pBuffer);
    }

#else   // BUG_IN_NEW_DMA

    NdisFreePacket(pPacket);

#endif  // BUG_IN_NEW_DMA

    ASSERT(pIrp);

    if(pIrp){

        pIrp->IoStatus.Status = Status;

        // the number of bytes we sent
        if(NDIS_STATUS_SUCCESS == Status){

            pIrp->IoStatus.Information = MmGetMdlByteCount(pIrp->MdlAddress);

        } else {

            pIrp->IoStatus.Information = 0;
        }

        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    }

    return;
}


#undef  MODULE_ID
#define MODULE_ID    MODULE_RECV

UINT
AtmSmCoReceivePacket(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  NDIS_HANDLE     ProtocolVcContext,
    IN  PNDIS_PACKET    pPacket
    )
/*++

Routine Description:
    When we recv a packet, see if we have anyone interested in received
    packets if so copy the info and return.  Else see if miniport is ok
    with us holding the packet.  In that case we will queue the packet
    otherwise return.

Arguments:

    Status              Status of Completion
    ProtocolVcContext   Pointer to the Vc
    Packet              The packet in question

Return Value:


--*/
{
    PATMSM_ADAPTER  pAdapt   = (PATMSM_ADAPTER)ProtocolBindingContext; 
    PATMSM_VC       pVc      = (PATMSM_VC)ProtocolVcContext;
    UINT            uiRetVal = 0;
    BOOLEAN         bLockReleased = FALSE;

    DbgInfo(("AtmSmCoReceivePacket - pVc - 0x%x, pPkt  - 0x%x\n",
                                            pVc, pPacket));

    ASSERT(pAdapt == pVc->pAdapt);

    ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

    do { // break off loop

        if(ADAPT_SHUTTING_DOWN == pAdapt->ulFlags)
            break;

        // no one interested in receivg packet
        if(!pAdapt->fAdapterOpenedForRecv)
            break;

        if(pAdapt->pRecvIrp){

            PIRP pIrp = pAdapt->pRecvIrp;
            
            pAdapt->pRecvIrp = NULL;

            // release the lock
            RELEASE_ADAPTER_GEN_LOCK(pAdapt);

            bLockReleased = TRUE;


            // Copy the packet to the Irp buffer
            // Note this may be partial if the Irp buffer is not large enough
            pIrp->IoStatus.Information = 
                            CopyPacketToIrp(pIrp, pPacket);

            pIrp->IoStatus.Status = STATUS_SUCCESS;

            IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

            break;
        }

        // no pending irps to fill in.
        // so check if we can queue this packet
        if(NDIS_STATUS_RESOURCES == NDIS_GET_PACKET_STATUS(pPacket))
            break;

        // we can queue this packet
        {
        PPROTO_RSVD     pPRsvd;

            pPRsvd = GET_PROTO_RSVD(pPacket);

            NdisGetSystemUpTime(&pPRsvd->ulTime);
            pPRsvd->pPktNext = NULL;

            if(pAdapt->pRecvLastPkt){

                pPRsvd = GET_PROTO_RSVD(pAdapt->pRecvLastPkt);

                pPRsvd->pPktNext = pPacket;

            } else
                pAdapt->pRecvPktNext = pPacket;


            pAdapt->pRecvLastPkt = pPacket;

            pAdapt->ulRecvPktsCount++;

            uiRetVal = 1;

            if(!pAdapt->fRecvTimerQueued){

                SET_ADAPTER_RECV_TIMER(pAdapt, RECV_BUFFERING_TIME);
            }

            break;
        }


    } while(FALSE);

    if(!bLockReleased){
    
        RELEASE_ADAPTER_GEN_LOCK(pAdapt);
    }

    return uiRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\ncatlps.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C A T L P S . C P P
//
//  Contents:   Class implementation for ATL-like property sheet page object.
//
//  Notes:
//
//  Author:     danielwe   28 Feb 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include <atlbase.h>
extern CComModule _Module;  // required by atlcom.h
#include <atlcom.h>
#ifdef SubclassWindow
#undef SubclassWindow
#endif
#include <atlwin.h>
#include "ncatlps.h"

CPropSheetPage::~CPropSheetPage ()
{
    // If we are attached to a window, DWL_USER contains a pointer to this.
    // Remove it since we are going away.
    //
    if (m_hWnd)
    {
        const CPropSheetPage* pps;
        pps = (CPropSheetPage *) ::GetWindowLongPtr(m_hWnd, DWLP_USER);
        if (pps)
        {
            AssertSz (pps == this, "Why isn't DWL_USER equal to 'this'?");
            ::SetWindowLongPtr(m_hWnd, DWLP_USER, NULL);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropSheetPage::CreatePage
//
//  Purpose:    Method to quickly create a property page.
//
//  Arguments:
//      unId    [in]    IDD of dialog resource ID
//      dwFlags [in]    Additional flags to use in the dwFlags field of the
//                      PROPSHEETPAGE struct.
//
//  Returns:    HPROPSHEETPAGE
//
//  Author:     shaunco   28 Feb 1997
//
//  Notes:
//
HPROPSHEETPAGE CPropSheetPage::CreatePage(UINT unId, DWORD dwFlags,
                                          PCWSTR pszHeaderTitle,
                                          PCWSTR pszHeaderSubTitle,
                                          PCWSTR pszTitle,
                                          OPTIONAL HINSTANCE hInstance)
{
    Assert(unId);

    PROPSHEETPAGE   psp = {0};
    HRSRC hrSrc = NULL;
    HGLOBAL hgRes = NULL;
    LPVOID lpv;

    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = dwFlags;

    if (!hInstance)
    {
        psp.hInstance   = _Module.GetModuleInstance();
        psp.pszTemplate = MAKEINTRESOURCE(unId);
    }
    else
    {
        // If resource dll is external to netshell.dll
        hrSrc = FindResource(hInstance, MAKEINTRESOURCE(unId), RT_DIALOG);
        if (hrSrc)
        {
            hgRes = LoadResource(hInstance, hrSrc);
            if (hgRes)
            {
                lpv = LockResource(hgRes);
                if (lpv)
                {
                    psp.hInstance   = NULL;
                    psp.dwFlags    |= PSP_DLGINDIRECT;
                    psp.pResource   = (LPCDLGTEMPLATE)lpv;
                }
                else
                {
                    TraceTag(ttidError, "LockResource failed");
                    return NULL;
                }
            }
            else
            {
                TraceTag(ttidError, "LoadResource failed with error %ld", GetLastError());
                return NULL;
            }
        }
        else
        {
            TraceTag(ttidError, "FindResource failed with error %ld", GetLastError());
            return NULL;
        }
    }
    
    psp.pfnDlgProc  = (DLGPROC)CPropSheetPage::DialogProc;
    psp.pfnCallback = static_cast<LPFNPSPCALLBACK>
            (CPropSheetPage::PropSheetPageProc);
    psp.lParam      = (LPARAM)this;

    psp.pszHeaderTitle = pszHeaderTitle;
    psp.pszHeaderSubTitle = pszHeaderSubTitle;

    psp.pszTitle = pszTitle;

    return ::CreatePropertySheetPage(&psp);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropSheetPage::DialogProc
//
//  Purpose:    Dialog proc for ATL property sheet pages.
//
//  Arguments:
//      hWnd   [in]
//      uMsg   [in]     See the ATL documentation.
//      wParam [in]
//      lParam [in]
//
//  Returns:    LRESULT
//
//  Author:     danielwe   28 Feb 1997
//
//  Notes:
//
LRESULT CALLBACK CPropSheetPage::DialogProc(HWND hWnd, UINT uMsg,
                                            WPARAM wParam, LPARAM lParam)
{
    LRESULT         lRes;
    PROPSHEETPAGE*  ppsp;
    CPropSheetPage* pps;
    BOOL            fRes = FALSE;

    if (uMsg == WM_INITDIALOG)
    {
        ppsp = (PROPSHEETPAGE *)lParam;
        pps = (CPropSheetPage *)ppsp->lParam;
        ::SetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR) pps);
        pps->Attach(hWnd);
    }
    else
    {
        pps = (CPropSheetPage *)::GetWindowLongPtr(hWnd, DWLP_USER);

        // Until we get WM_INITDIALOG, just return FALSE
        if (!pps)
            return FALSE;
    }

    if (pps->ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lRes, 0))
    {
        switch (uMsg)
        {
        case WM_COMPAREITEM:
        case WM_VKEYTOITEM:
        case WM_CHARTOITEM:
        case WM_INITDIALOG:
        case WM_QUERYDRAGICON:
            return lRes;
            break;
        }

        ::SetWindowLongPtr(hWnd, DWLP_MSGRESULT, lRes);
        fRes = TRUE;
    }

    return fRes;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropSheetPage::PropSheetPageProc
//
//  Purpose:    PropSheetPageProc for ATL property sheet pages.
//
//  Arguments:
//      hWnd   [in]
//      uMsg   [in]     See Win32 documentation.
//      ppsp   [in]
//
//  Returns:    UINT
//
//  Author:     billbe   6 Jul 1997
//
//  Notes:
//
UINT CALLBACK CPropSheetPage::PropSheetPageProc(HWND hWnd, UINT uMsg,
                                                LPPROPSHEETPAGE ppsp)
{
    CPropSheetPage* pps;

    // The this pointer was stored in the structure's lParam
    pps = reinterpret_cast<CPropSheetPage *>(ppsp->lParam);

    // This has to be valid since the CreatePage member fcn sets it
    Assert(pps);

    UINT uRet = TRUE;

    // call the correct handler based on uMsg
    //
    if (PSPCB_CREATE == uMsg)
    {
        uRet = pps->UCreatePageCallbackHandler();
    }
    else if (PSPCB_RELEASE == uMsg)
    {
        pps->DestroyPageCallbackHandler();
    }
    else
    {
        AssertSz(FALSE, "Invalid or new message sent to call back!");
    }

    return (uRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\samples\atmsmpl\driver\request.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation, All Rights Reserved.

Module Name:

    request.c

Abstract:

    This module contains the request calls to the miniport driver below.

Author:

    Anil Francis Thomas (10/98)

Environment:

    Kernel

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop


#define MODULE_ID    MODULE_REQUEST


NDIS_STATUS
AtmSmCoRequest(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        pNdisRequest
    )
/*++
Routine Description:

    This routine is called by NDIS when our Call Manager sends us an
    NDIS Request. NDIS Requests that are of significance to us are:
    - OID_CO_ADDRESS_CHANGE
        The set of addresses registered with the switch has changed,
        i.e. address registration is complete. We issue an NDIS Request
        ourselves to get the list of addresses registered.
    - OID_CO_AF_CLOSE
        The Call Manager wants us to shut down this Interface.

    We ignore all other OIDs.

Arguments:

    ProtocolAfContext           - Our context for the Address Family binding,
                                  which is a pointer to the ATMSM Interface.
    ProtocolVcContext           - Our context for a VC, which is a pointer to
                                  an ATMSM VC structure.
    ProtocolPartyContext        - Our context for a Party. Since we don't do
                                  PMP, this is ignored (must be NULL).
    pNdisRequest                - Pointer to the NDIS Request.

Return Value:

    NDIS_STATUS_SUCCESS if we recognized the OID

--*/
{
    PATMSM_ADAPTER  pAdapt= (PATMSM_ADAPTER)ProtocolAfContext;
    BOOLEAN         ValidAf;

    DbgInfo(("CallMgrRequest: Request %lx, Type %d, OID %x\n",
             pNdisRequest, pNdisRequest->RequestType, 
                        pNdisRequest->DATA.SET_INFORMATION.Oid));

    switch(pNdisRequest->DATA.SET_INFORMATION.Oid){

        case OID_CO_ADDRESS_CHANGE:
            
            DbgInfo(("Received: OID_CO_ADDRESS_CHANGE\n"));
          
            ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);
                  
            pAdapt->ulFlags |= ADAPT_ADDRESS_INVALID;                 
            ValidAf = ((pAdapt->ulFlags & ADAPT_AF_OPENED) != 0);
                  
            RELEASE_ADAPTER_GEN_LOCK(pAdapt);

            if (ValidAf)            
                AtmSmQueryAdapterATMAddresses(pAdapt);

            break;

        case OID_CO_AF_CLOSE:

            DbgInfo(("Received: OID_CO_AF_CLOSE\n"));

            if (AtmSmReferenceAdapter(pAdapt)){

                AtmSmShutdownAdapter(pAdapt);

                AtmSmDereferenceAdapter(pAdapt);
            }

            break;

        default:
            break;
    }

    return NDIS_STATUS_SUCCESS;
}


VOID
AtmSmCoRequestComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolAfContext,
    IN  NDIS_HANDLE                 ProtocolVcContext   OPTIONAL,
    IN  NDIS_HANDLE                 ProtocolPartyContext    OPTIONAL,
    IN  PNDIS_REQUEST               pNdisRequest
    )
/*++

Routine Description:

    This routine is called by NDIS when a previous call to NdisCoRequest
    that had pended, is complete. We handle this based on the request
    we had sent, which has to be one of:
    - OID_CO_GET_ADDRESSES
        Get all addresses registered on the specified AF binding.

Arguments:

    Status                      - Status of the Request.
    ProtocolAfContext           - Our context for the Address Family binding,
                                  which is a pointer to the PATMSM_ADAPTER.
    ProtocolVcContext           - Our context for a VC, which is a pointer to
                                  a VC structure.
    ProtocolPartyContext        - Our context for a Party
    pNdisRequest                - Pointer to the NDIS Request.


Return Value:

    None

--*/
{
    PATMSM_ADAPTER  pAdapt  = (PATMSM_ADAPTER)ProtocolAfContext;

    DbgInfo(("CoRequestComplete: Request %lx, Type %d, OID %lx\n",
             pNdisRequest, pNdisRequest->RequestType, 
                    pNdisRequest->DATA.QUERY_INFORMATION.Oid));


    ACQUIRE_ADAPTER_GEN_LOCK(pAdapt);

    
    switch(pNdisRequest->DATA.SET_INFORMATION.Oid){

      case OID_CO_GET_ADDRESSES:

        if (NDIS_STATUS_SUCCESS == Status){

            PCO_ADDRESS_LIST    pCoAddrList;
            UINT                i;

            pCoAddrList = (PCO_ADDRESS_LIST)(pNdisRequest->DATA.
                                    QUERY_INFORMATION.InformationBuffer);

            ASSERT(pCoAddrList->NumberOfAddresses == 1);
            ASSERT(pCoAddrList->NumberOfAddressesAvailable == 1);

            DbgInfo(("CoRequestComplete: Configured address, %d/%d Size %d\n",
                     pCoAddrList->NumberOfAddresses,
                     pCoAddrList->NumberOfAddressesAvailable,
                     pCoAddrList->AddressList.AddressSize));

            ASSERT(pCoAddrList->AddressList.AddressSize == (sizeof(CO_ADDRESS)
                                                        + sizeof(ATM_ADDRESS)));
            NdisMoveMemory(&pAdapt->ConfiguredAddress,
                     pCoAddrList->AddressList.Address,
                     sizeof(ATM_ADDRESS));

            // set the selector byte
            pAdapt->ConfiguredAddress.Address[ATM_ADDRESS_LENGTH-1] =
                                    pAdapt->SelByte;

            pAdapt->ulFlags &= ~ADAPT_ADDRESS_INVALID;                 

            DbgInfo(("CoRequestComplete: Configured Address : "));

            DumpATMAddress(ATMSMD_ERR, "", &pAdapt->ConfiguredAddress);

        } else {

            DbgErr(("CoRequestComplete: CO_GET_ADDRESS Failed %lx\n", Status));

        }
        break;

    }

    
    RELEASE_ADAPTER_GEN_LOCK(pAdapt);

    AtmSmFreeMem(pNdisRequest);

}



VOID
AtmSmSendAdapterNdisRequest(
    IN  PATMSM_ADAPTER          pAdapt,
    IN  NDIS_OID                Oid,
    IN  PVOID                   pBuffer,
    IN  ULONG                   BufferLength
    )   
/*++

Routine Description:

    NDIS Request generator, for sending NDIS requests to the miniport.

Arguments:

    pAdapt          Ptr to Adapter
    Oid             The parameter being queried
    pBuffer         Points to parameter
    BufferLength    Length of above

Return Value:

    None

--*/
{
    NDIS_STATUS             Status;
    PNDIS_REQUEST           pRequest;

    AtmSmAllocMem(&pRequest, PNDIS_REQUEST, sizeof(NDIS_REQUEST));

    if (NULL == pRequest) {
        DbgErr(("AdapterRequest - Not enough memory\n"));
        return;
    }

    NdisZeroMemory(pRequest, sizeof(NDIS_REQUEST));

    //
    // Query for the line rate.
    //
    pRequest->DATA.QUERY_INFORMATION.Oid = Oid;
    pRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
    pRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
    pRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
    pRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;

    RESET_BLOCK_STRUCT(&pAdapt->RequestBlock);

    NdisRequest(&Status,
                pAdapt->NdisBindingHandle,
                pRequest);

    if (NDIS_STATUS_PENDING == Status) {

        Status = WAIT_ON_BLOCK_STRUCT(&pAdapt->RequestBlock);

    } else {

        AtmSmRequestComplete(
                    pAdapt,
                    pRequest,
                    Status);
    }
}


VOID
AtmSmRequestComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_REQUEST           pRequest,
    IN  NDIS_STATUS             Status
    )
/*++

Routine Description:

    Completion of our call to NdisRequest(). Do some follow-up.

Arguments:

    ProtocolBindingContext      Pointer to Adapter
    pRequest                    The request that just completed
    Status                      Status of NdisRequest()

Return Value:

    None

--*/
{
    PATMSM_ADAPTER  pAdapt = (PATMSM_ADAPTER)ProtocolBindingContext;;


    switch (pRequest->DATA.QUERY_INFORMATION.Oid) {

        case OID_ATM_MAX_AAL5_PACKET_SIZE:

            if(NDIS_STATUS_SUCCESS != Status) {

                DbgWarn(("Failed to get Miniport MaxPacketSize. "
                                            "Status - %x\n", Status));
            
                pAdapt->MaxPacketSize = DEFAULT_MAX_PACKET_SIZE;
            }

            if (pAdapt->MaxPacketSize < pAdapt->VCFlowSpec.SendMaxSize) {

                pAdapt->VCFlowSpec.SendMaxSize =
                pAdapt->VCFlowSpec.ReceiveMaxSize = pAdapt->MaxPacketSize;
            }

            DbgInfo(("Miniport Max AAL5 Packet Size: %d (decimal)\n",
                        pAdapt->MaxPacketSize));
            break;

        case OID_GEN_CO_LINK_SPEED: {

            PNDIS_CO_LINK_SPEED     pLinkSpeed = &pAdapt->LinkSpeed;

            if(NDIS_STATUS_SUCCESS != Status) {

                DbgWarn(("Failed to get Miniport LinkSpeed. "
                                            "Status - %x\n", Status));
            

                pAdapt->LinkSpeed.Inbound = pAdapt->LinkSpeed.Outbound = 
                                                    DEFAULT_SEND_BANDWIDTH;
            }
            
            //
            // Convert to bytes/sec
            //
            pLinkSpeed->Outbound = (pLinkSpeed->Outbound * 100 / 8);
            pLinkSpeed->Inbound  = (pLinkSpeed->Inbound * 100 / 8);
            if (pLinkSpeed->Outbound < pAdapt->VCFlowSpec.SendBandwidth) {

                pAdapt->VCFlowSpec.SendBandwidth = pLinkSpeed->Outbound;
            }

            if (pLinkSpeed->Inbound < pAdapt->VCFlowSpec.ReceiveBandwidth){

                pAdapt->VCFlowSpec.ReceiveBandwidth = pLinkSpeed->Inbound;
            }

            DbgInfo(("Miniport Link Speed (decimal, bytes/sec): In %d, "
                    "Out %d\n", pLinkSpeed->Inbound, pLinkSpeed->Outbound));
            break;
        }

        default:
            ASSERT(FALSE);
            break;
    }

    AtmSmFreeMem(pRequest);

    SIGNAL_BLOCK_STRUCT(&pAdapt->RequestBlock , Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\winsock\wshatm.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    D:\nt\private\net\sockets\wshatm\wshatm.c

Abstract:

    This module contains necessary routines for the ATM Windows Sockets
    Helper DLL.  This DLL provides the transport-specific support necessary
    for the Windows Sockets DLL to use ATM as a transport.

Revision History:

    arvindm              20-May-1997    Created based on TCP/IP's helper DLL, wshtcpip

--*/

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <ctype.h>
#include <wchar.h>
#include <tdi.h>

#include <winsock2.h>
#include <mswsock.h>
#include <ws2atm.h>
#include <wsahelp.h>

#include <tdistat.h>
#include <tdiinfo.h>

#include <rwanuser.h>

typedef unsigned long   ulong;
typedef unsigned short  ushort;
typedef unsigned int    uint;
typedef unsigned char   uchar;
#define TL_INSTANCE 0

#include <ws2atmsp.h>

#define NT // temporarily needed by tdiinfo.h...

#include <tdiinfo.h>

#include <basetyps.h>
#include <nspapi.h>

#define ATM_NAME L"ATM"
#define RWAN_NAME L"RawWan"

#define ATM_ADDR_SIZE                           20
#define ATM_ADDR_BLANK_CHAR                     L' '
#define ATM_ADDR_PUNCTUATION_CHAR       L'.'
#define ATM_ADDR_E164_START_CHAR        '+'

#define ATM_AAL5_SOCK_TYPE                      SOCK_RAW


#define ATM_WSA_MULTIPOINT_FLAGS        (WSA_FLAG_MULTIPOINT_C_ROOT |   \
                                                                         WSA_FLAG_MULTIPOINT_C_LEAF |   \
                                                                         WSA_FLAG_MULTIPOINT_D_ROOT |   \
                                                                         WSA_FLAG_MULTIPOINT_D_LEAF)

//
// Define valid flags for WSHOpenSocket2().
//
#define VALID_ATM_FLAGS                         (WSA_FLAG_OVERLAPPED |                  \
                                                                         ATM_WSA_MULTIPOINT_FLAGS)

//
// Maximum expected size of ATM Connection Options: this includes the
// base QOS structure, plus all possible IEs.
//
#if 0
#define MAX_ATM_OPTIONS_LENGTH          \
                                        sizeof(QOS) + \
                                        sizeof(Q2931_IE) + sizeof(AAL_PARAMETERS_IE) + \
                                        sizeof(Q2931_IE) + sizeof(ATM_TRAFFIC_DESCRIPTOR_IE) + \
                                        sizeof(Q2931_IE) + sizeof(ATM_BROADBAND_BEARER_CAPABILITY_IE) + \
                                        (3 * (sizeof(Q2931_IE) + sizeof(ATM_BLLI_IE))) + \
                                        sizeof(Q2931_IE) + sizeof(ATM_CALLED_PARTY_NUMBER_IE) + \
                                        sizeof(Q2931_IE) + sizeof(ATM_CALLED_PARTY_SUBADDRESS_IE) + \
                                        sizeof(Q2931_IE) + sizeof(ATM_CALLING_PARTY_SUBADDRESS_IE) + \
                                        sizeof(Q2931_IE) + sizeof(ATM_CAUSE_IE) + \
                                        sizeof(Q2931_IE) + sizeof(ATM_QOS_CLASS_IE) + \
                                        sizeof(Q2931_IE) + sizeof(ATM_TRANSIT_NETWORK_SELECTION_IE)

#else
//
//  Need much more with ATMUNI 4.0...
//
#define MAX_ATM_OPTIONS_LENGTH  1024
#endif

#if DBG1
#define DBGPRINT(stmt)          { DbgPrint ("WSHATM: "); DbgPrint stmt; }
#else
#define DBGPRINT(stmt)
#endif // DBG1

#if DBG
extern
PVOID
MyRtlAllocateHeap(
        IN      PVOID   HeapHandle,
        IN      ULONG   Flags,
        IN      ULONG   Size,
        IN      ULONG   LineNumber
        );
extern
VOID
MyRtlFreeHeap(
        IN PVOID        HeapHandle,
        IN ULONG        Flags,
        IN PVOID        MemPtr,
        IN ULONG        LineNumber
        );
#define RTL_ALLOCATE_HEAP(_Handle, _Flags, _Size)       MyRtlAllocateHeap(_Handle, _Flags, _Size, __LINE__)
#define RTL_FREE_HEAP(_Handle, _Flags, _Memptr) MyRtlFreeHeap(_Handle, _Flags, _Memptr, __LINE__)
#else
#define RTL_ALLOCATE_HEAP(_Handle, _Flags, _Size)       RtlAllocateHeap(_Handle, _Flags, _Size)
#define RTL_FREE_HEAP(_Handle, _Flags, _Memptr) RtlFreeHeap(_Handle, _Flags, _Memptr)
#endif

#define ATM_AAL5_PACKET_SIZE            65535

//
// Structure and variables to define the triples supported by ATM. The
// first entry of each array is considered the canonical triple for
// that socket type; the other entries are synonyms for the first.
//

typedef struct _MAPPING_TRIPLE {
    INT AddressFamily;
    INT SocketType;
    INT Protocol;
} MAPPING_TRIPLE, *PMAPPING_TRIPLE;

MAPPING_TRIPLE AtmMappingTriples[] = {
                                       AF_ATM,    ATM_AAL5_SOCK_TYPE, ATMPROTO_AAL5,
                                       AF_ATM,    ATM_AAL5_SOCK_TYPE, 0,
                                                                           AF_ATM,    SOCK_RAW,       ATMPROTO_AAL5,
                                       AF_ATM,    SOCK_RAW,       0,
                                       AF_ATM,    0,              ATMPROTO_AAL5,
                                       AF_UNSPEC, 0,              ATMPROTO_AAL5,
                                       AF_UNSPEC, ATM_AAL5_SOCK_TYPE, ATMPROTO_AAL5,
                                       AF_UNSPEC, SOCK_RAW,       ATMPROTO_AAL5
                                                                         };


//
// Winsock 2 WSAPROTOCOL_INFO structures for all supported protocols.
//

#define ATM_UNI_VERSION                 0x00030001      // For UNI 3.1

WSAPROTOCOL_INFOW Winsock2Protocols[] =
    {
        //
        // ATM AAL5
        //

        {
            XP1_GUARANTEED_ORDER                    // dwServiceFlags1
                | XP1_MESSAGE_ORIENTED
                // | XP1_PARTIAL_MESSAGE
                | XP1_IFS_HANDLES
                | XP1_SUPPORT_MULTIPOINT
                | XP1_MULTIPOINT_DATA_PLANE
                | XP1_MULTIPOINT_CONTROL_PLANE
                | XP1_QOS_SUPPORTED,
            0,                                      // dwServiceFlags2
            0,                                      // dwServiceFlags3
            0,                                      // dwServiceFlags4
            PFL_MATCHES_PROTOCOL_ZERO,              // dwProviderFlags
            {                                       // gProviderId
                0, 0, 0,
                { 0, 0, 0, 0, 0, 0, 0, 0 }
            },
            0,                                      // dwCatalogEntryId
            {                                       // ProtocolChain
                BASE_PROTOCOL,                          // ChainLen
                { 0, 0, 0, 0, 0, 0, 0 }                 // ChainEntries
            },
            ATM_UNI_VERSION,                        // iVersion
            AF_ATM,                                 // iAddressFamily
            sizeof(sockaddr_atm),                   // iMaxSockAddr
            sizeof(sockaddr_atm),                   // iMinSockAddr
            ATM_AAL5_SOCK_TYPE,                     // iSocketType
            ATMPROTO_AAL5,                          // iProtocol
            0,                                      // iProtocolMaxOffset
            BIGENDIAN,                              // iNetworkByteOrder
            SECURITY_PROTOCOL_NONE,                 // iSecurityScheme
            ATM_AAL5_PACKET_SIZE,                   // dwMessageSize
            0,                                      // dwProviderReserved
            L"MSAFD ATM AAL5"                       // szProtocol
        }
    };

#define NUM_WINSOCK2_PROTOCOLS  \
            ( sizeof(Winsock2Protocols) / sizeof(Winsock2Protocols[0]) )

//
// The GUID identifying this provider.
//

GUID AtmProviderGuid = { /* {C3656046-3AAF-11d1-A8C3-00C04FC99C9C} */
    0xC3656046,
    0x3AAF,
    0x11D1,
    {0xA8, 0xC3, 0x00, 0xC0, 0x4F, 0xC9, 0x9C, 0x9C}
    };

//
// Given a digit (0-9) represented in ANSI, return its WCHAR representation
//
#define ANSI_TO_WCHAR(_AnsiDigit)       \
                        (L'0' + (WCHAR)((_AnsiDigit) - '0'))


//
// Given a hex digit value (0-15), return its WCHAR representation
// (i.e. 0 -> L'0', 12 -> L'C')
//
#define DIGIT_TO_WCHAR(_Value)          \
                        (((_Value) > 9)? (L'A' + (WCHAR)((_Value) - 10)) :      \
                                                         (L'0' + (WCHAR)((_Value) - 0 )))

//
// The socket context structure for this DLL.  Each open ATM socket
// will have one of these context structures, which is used to maintain
// information about the socket.
//

typedef struct _WSHATM_SOCKET_CONTEXT {
    INT                         AddressFamily;
    INT                         SocketType;
    INT                         Protocol;
    INT                         ReceiveBufferSize;
    SOCKET                              SocketHandle;
    DWORD                       Flags;
    DWORD                       LocalFlags;
    ATM_CONNECTION_ID   ConnectionId;

} WSHATM_SOCKET_CONTEXT, *PWSHATM_SOCKET_CONTEXT;

#define DEFAULT_RECEIVE_BUFFER_SIZE ATM_AAL5_PACKET_SIZE

//
// LocalFlags in WSHATM_SOCKET_CONTEXT:
//
#define WSHATM_SOCK_IS_BOUND                            0x00000001
#define WSHATM_SOCK_IS_PVC                                      0x00000004
#define WSHATM_SOCK_ASSOCIATE_PVC_PENDING       0x00000008


//
// Forward declarations of internal routines.
//

BOOLEAN
IsTripleInList (
    IN PMAPPING_TRIPLE List,
    IN ULONG ListLength,
    IN INT AddressFamily,
    IN INT SocketType,
    IN INT Protocol
    );

INT
WSHAtmSetQoS(
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN LPVOID InputBuffer,
    IN DWORD InputBufferLength
    );

INT
WSHAtmGetQoS(
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned
    );

INT
AtmQueryAtmGlobalInformation(
        IN ATM_OBJECT_ID ObjectId,
        IN LPVOID pContext,
        IN DWORD ContextLength,
        IN LPVOID OutputBuffer,
        IN DWORD OutputBufferLength,
        OUT LPDWORD NumberOfBytesReturned
        );

INT
AtmSetGenericObjectInformation (
    IN HANDLE TdiObjectHandle,
    IN ULONG IoControlCode,
    IN RWAN_OBJECT_ID ObjectId,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );

INT
AtmGetGenericObjectInformation (
    IN HANDLE TdiObjectHandle,
    IN ULONG IoControlCode,
    IN RWAN_OBJECT_ID ObjectId,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
        OUT LPDWORD NumberOfBytesReturned
    );

INT
AtmSetAtmObjectInformation (
    IN HANDLE TdiObjectHandle,
    IN ULONG IoControlCode,
    IN ATM_OBJECT_ID ObjectId,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );

INT
AtmGetAtmObjectInformation (
    IN HANDLE TdiObjectHandle,
    IN ULONG IoControlCode,
    IN ATM_OBJECT_ID ObjectId,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
        OUT LPDWORD NumberOfBytesReturned
    );

INT
AtmAssociatePVC(
    IN SOCKET SocketHandle,
        IN PVOID HelperDllSocketContext,
        IN HANDLE TdiAddressObjectHandle,
        IN HANDLE TdiConnectionObjectHandle,
        IN LPVOID InputBuffer,
        IN DWORD InputBufferLength
        );

INT
AtmDoAssociatePVC(
        IN PWSHATM_SOCKET_CONTEXT Context,
        IN HANDLE TdiAddressObjectHandle
        );



BOOLEAN
DllInitialize (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PVOID Context OPTIONAL
    )
{

    DBGPRINT(("DllInitialize, Reason %d\n", Reason));

    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:

        //
        // We don't need to receive thread attach and detach
        // notifications, so disable them to help application
        // performance.
        //

        DisableThreadLibraryCalls( DllHandle );

        return TRUE;

    case DLL_THREAD_ATTACH:

        break;

    case DLL_PROCESS_DETACH:

        break;

    case DLL_THREAD_DETACH:

        break;
    }

    return TRUE;

} // SockInitialize

INT
WSHGetSockaddrType (
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    OUT PSOCKADDR_INFO SockaddrInfo
    )

/*++

Routine Description:

    This routine parses a sockaddr to determine the type of the
    machine address and endpoint address portions of the sockaddr.
    This is called by the winsock DLL whenever it needs to interpret
    a sockaddr.

Arguments:

    Sockaddr - a pointer to the sockaddr structure to evaluate.

    SockaddrLength - the number of bytes in the sockaddr structure.

    SockaddrInfo - a pointer to a structure that will receive information
        about the specified sockaddr.


Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    UNALIGNED SOCKADDR_ATM *sockaddr = (PSOCKADDR_ATM)Sockaddr;
    ULONG i;

        DBGPRINT(("GetSockaddrType: SockaddrLength %d, satm_family %d, AddrType x%x\n",
                                        SockaddrLength, sockaddr->satm_family, sockaddr->satm_number.AddressType));

    //
    // Make sure that the address family is correct.
    //

    if ( sockaddr->satm_family != AF_ATM ) {
        return WSAEAFNOSUPPORT;
    }

    //
    // Make sure that the length is correct.
    //

    if ( SockaddrLength < sizeof(SOCKADDR_ATM) ) {
        return WSAEFAULT;
    }

#if 0
    //
    // The ATM address part cannot be "absent".
    //
    if ( sockaddr->satm_number.AddressType == SAP_FIELD_ABSENT ) {
        return WSAEINVAL;
    }
#endif

    if ( sockaddr->satm_number.NumofDigits > ATM_ADDR_SIZE ) {
        return WSAEINVAL;
    }

    //
    // The address passed the tests, looks like a good address.
    // Determine the type of the address and endpoint portions
        // of the sockaddr.
    //

    if ( sockaddr->satm_number.AddressType == SAP_FIELD_ANY &&
                 sockaddr->satm_blli.Layer2Protocol == SAP_FIELD_ANY &&
                 sockaddr->satm_blli.Layer3Protocol == SAP_FIELD_ANY &&
                 sockaddr->satm_bhli.HighLayerInfoType == SAP_FIELD_ANY ) {

        SockaddrInfo->AddressInfo = SockaddrAddressInfoWildcard;
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoWildcard;

    } else if ( sockaddr->satm_number.AddressType == SAP_FIELD_ABSENT ) {

        SockaddrInfo->AddressInfo = SockaddrAddressInfoWildcard;
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoWildcard;

        } else {

        SockaddrInfo->AddressInfo = SockaddrAddressInfoNormal;
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoNormal;

    }

    return NO_ERROR;

} // WSHGetSockaddrType


INT
WSHGetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    OUT PCHAR OptionValue,
    OUT PINT OptionLength
    )

/*++

Routine Description:

    This routine retrieves information about a socket for those socket
    options supported in this helper DLL. Currently there are none
    supported.

    This is called by the winsock DLL when a level/option name
        combination is passed to getsockopt() that the winsock DLL does
        not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to getsockopt().

    OptionName - the optname parameter passed to getsockopt().

    OptionValue - the optval parameter passed to getsockopt().

    OptionLength - the optlen parameter passed to getsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHATM_SOCKET_CONTEXT context = HelperDllSocketContext;
    INT err;

        DBGPRINT(("GetSocketInformation: Level %d, OptionName %d, OptionLength %d\n",
                        Level, OptionName, *OptionLength));

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

    //
    // Check if this is an internal request for context information.
    //

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting context information
        // from us.  If an output buffer was not supplied, the Windows
        // Sockets DLL is just requesting the size of our context
        // information.
        //

        if ( OptionValue != NULL ) {

            //
            // Make sure that the buffer is sufficient to hold all the
            // context information.
            //

            if ( *OptionLength < sizeof(*context) ) {
                return WSAEFAULT;
            }

            //
            // Copy in the context information.
            //

            RtlCopyMemory( OptionValue, context, sizeof(*context) );
        }

        *OptionLength = sizeof(*context);

        err = NO_ERROR;

    } else {

        switch ( OptionName ) {

        case SO_MAX_MSG_SIZE:

                        if ( TdiConnectionObjectHandle == NULL ) {

                                DbgPrint("wshatm: SO_MAX_MSG_SIZE: immed return\n");
                                if ( *OptionLength >= sizeof(DWORD) ) {
                                
                                        *(LPDWORD)OptionValue = DEFAULT_RECEIVE_BUFFER_SIZE;
                                        *OptionLength = sizeof(DWORD);
                                        
                                        err = NO_ERROR;
                                
                                } else {

                                        err = WSAEFAULT;
                                
                                }

                        } else {

                                DbgPrint("wshatm: SO_MAX_MSG_SIZE: querying driver\n");
                                err = AtmGetGenericObjectInformation(
                                                TdiConnectionObjectHandle,
                                                IOCTL_RWAN_GENERIC_CONN_HANDLE_QUERY,
                                                RWAN_OID_CONN_OBJECT_MAX_MSG_SIZE,
                                                NULL,   // No Input buffer
                                                0,              // Input Buffer length
                                                OptionValue,    // Output buffer
                                                *OptionLength,  // Output buffer length
                                                OptionLength    // NumberOfBytesReturned
                                                );

                        }
                        break;
                
                default:

                        err = WSAENOPROTOOPT;
                        break;

                }
        }

        return err;

} // WSHGetSocketInformation


INT
WSHGetWildcardSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a wildcard socket address.  A wildcard address
    is one which will bind the socket to an endpoint of the transport's
    choosing.  For ATM, a wildcard address has AddressType and BHLI and
    BLLI Type fields set to SAP_FIELD_ANY.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a wildcard
        address.

    Sockaddr - points to a buffer which will receive the wildcard socket
        address.

    SockaddrLength - receives the length of the wioldcard sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
        PSOCKADDR_ATM   sockaddr;

        DBGPRINT(("GetWildcardAddress\n"));

        sockaddr = (PSOCKADDR_ATM)Sockaddr;

    if ( *SockaddrLength < sizeof(SOCKADDR_ATM) ) {
        return WSAEFAULT;
    }

    *SockaddrLength = sizeof(SOCKADDR_ATM);


        //
        // Prepare the ATM wild card address.
        //
    RtlZeroMemory( sockaddr, sizeof(SOCKADDR_ATM) );

    sockaddr->satm_family = AF_ATM;
    sockaddr->satm_number.AddressType = SAP_FIELD_ABSENT;
        sockaddr->satm_blli.Layer2Protocol = SAP_FIELD_ANY;
        sockaddr->satm_blli.Layer3Protocol = SAP_FIELD_ANY;
        sockaddr->satm_bhli.HighLayerInfoType = SAP_FIELD_ANY;

    return NO_ERROR;

} // WSAGetWildcardSockaddr


DWORD
WSHGetWinsockMapping (
    OUT PWINSOCK_MAPPING Mapping,
    IN DWORD MappingLength
    )

/*++

Routine Description:

    Returns the list of address family/socket type/protocol triples
    supported by this helper DLL.

Arguments:

    Mapping - receives a pointer to a WINSOCK_MAPPING structure that
        describes the triples supported here.

    MappingLength - the length, in bytes, of the passed-in Mapping buffer.

Return Value:

    DWORD - the length, in bytes, of a WINSOCK_MAPPING structure for this
        helper DLL.  If the passed-in buffer is too small, the return
        value will indicate the size of a buffer needed to contain
        the WINSOCK_MAPPING structure.

--*/

{
    DWORD mappingLength;

        DBGPRINT(("GetWinsockMapping\n"));

    mappingLength = sizeof(WINSOCK_MAPPING) - sizeof(MAPPING_TRIPLE) +
                        sizeof(AtmMappingTriples);

    //
    // If the passed-in buffer is too small, return the length needed
    // now without writing to the buffer.  The caller should allocate
    // enough memory and call this routine again.
    //

    if ( mappingLength > MappingLength ) {
        return mappingLength;
    }

    //
    // Fill in the output mapping buffer with the list of triples
    // supported in this helper DLL.
    //

    Mapping->Rows = sizeof(AtmMappingTriples) / sizeof(AtmMappingTriples[0]);
    Mapping->Columns = sizeof(MAPPING_TRIPLE) / sizeof(DWORD);
    RtlMoveMemory(
        Mapping->Mapping,
        AtmMappingTriples,
        sizeof(AtmMappingTriples)
        );

    //
    // Return the number of bytes we wrote.
    //

    return mappingLength;

} // WSHGetWinsockMapping


INT
WSHOpenSocket (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    )
{
    return WSHOpenSocket2(
               AddressFamily,
               SocketType,
               Protocol,
               0,           // Group
               0,           // Flags
               TransportDeviceName,
               HelperDllSocketContext,
               NotificationEvents
               );

} // WSHOpenSocket


INT
WSHOpenSocket2 (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    IN GROUP Group,
    IN DWORD Flags,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    )

/*++

Routine Description:

    Does the necessary work for this helper DLL to open a socket and is
    called by the winsock DLL in the socket() routine.  This routine
    verifies that the specified triple is valid, determines the NT
    device name of the TDI provider that will support that triple,
    allocates space to hold the socket's context block, and
    canonicalizes the triple.

Arguments:

    AddressFamily - on input, the address family specified in the
        socket() call.  On output, the canonicalized value for the
        address family.

    SocketType - on input, the socket type specified in the socket()
        call.  On output, the canonicalized value for the socket type.

    Protocol - on input, the protocol specified in the socket() call.
        On output, the canonicalized value for the protocol.

    Group - Identifies the group for the new socket.

    Flags - Zero or more WSA_FLAG_* flags as passed into WSASocket().

    TransportDeviceName - receives the name of the TDI provider that
        will support the specified triple.

    HelperDllSocketContext - receives a context pointer that the winsock
        DLL will return to this helper DLL on future calls involving
        this socket.

    NotificationEvents - receives a bitmask of those state transitions
        this helper DLL should be notified on.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHATM_SOCKET_CONTEXT context;
    DWORD multipointFlags;
    UNICODE_STRING atmDeviceName;

    //
    // Determine whether this is an ATM socket.
    //

    DBGPRINT(("WSHOpenSocket2: AF %d, Type %d, Proto %d\n",
                        *AddressFamily, *SocketType, *Protocol));

    if ( IsTripleInList(
             AtmMappingTriples,
             sizeof(AtmMappingTriples) / sizeof(AtmMappingTriples[0]),
             *AddressFamily,
             *SocketType,
             *Protocol ) ) {

        //
        // It's an ATM socket. Check the flags.
        //

        if ( ( Flags & ~VALID_ATM_FLAGS ) != 0 ) {

            DBGPRINT(("WSHOpenSocket2: Bad flags x%x\n", Flags));
            return WSAEINVAL;

        }

        if ( ( Flags & ATM_WSA_MULTIPOINT_FLAGS ) != 0 ) {

                //
                //  The only multipoint combinations allowed are:
                //
                //  1. C_ROOT|D_ROOT
                //  2. C_LEAF|D_LEAF
                //

                multipointFlags = ( Flags & ATM_WSA_MULTIPOINT_FLAGS );

                if ( ( multipointFlags != (WSA_FLAG_MULTIPOINT_C_ROOT | WSA_FLAG_MULTIPOINT_D_ROOT) ) &&
                         ( multipointFlags != (WSA_FLAG_MULTIPOINT_C_LEAF | WSA_FLAG_MULTIPOINT_D_LEAF) ) ) {

                    DBGPRINT(("WSHOpenSocket2: Bad multipoint flags x%x\n",
                                        Flags));
                        
                        return WSAEINVAL;

                } else {

                        DBGPRINT(("WSHOpenSocket2: Good multipoint flags x%x\n", Flags));

                }
        }

        //
        // Return the canonical form of a ATM socket triple.
        //

        *AddressFamily = AtmMappingTriples[0].AddressFamily;
        *SocketType = AtmMappingTriples[0].SocketType;
        *Protocol = AtmMappingTriples[0].Protocol;

        //
        // Prepare the name of the TDI device.
        //

        RtlInitUnicodeString( &atmDeviceName, DD_ATM_DEVICE_NAME );

        TransportDeviceName->Buffer = RTL_ALLOCATE_HEAP( RtlProcessHeap( ), 0, atmDeviceName.MaximumLength );

        if ( TransportDeviceName->Buffer == NULL ) {
                
                return WSAEFAULT;

        }

        TransportDeviceName->MaximumLength = atmDeviceName.MaximumLength;
        TransportDeviceName->Length = 0;

        RtlCopyUnicodeString(TransportDeviceName, &atmDeviceName);

    } else {

        //
        // This should never happen if the registry information about this
        // helper DLL is correct.  If somehow this did happen, just return
        // an error.
        //

        DBGPRINT(("WSHOpenSocket2: Triple not found!\n"));

        if ( *Protocol != ATMPROTO_AAL5 ) {
        
                return WSAEPROTONOSUPPORT;
        
        }

        return WSAEINVAL;
    }

    //
    // Allocate context for this socket.  The Windows Sockets DLL will
    // return this value to us when it asks us to get/set socket options.
    //

    context = RTL_ALLOCATE_HEAP( RtlProcessHeap( ), 0, sizeof(*context) );
    if ( context == NULL ) {
        return WSAENOBUFS;
    }

    //
    // Initialize the context for the socket.
    //

    context->AddressFamily = *AddressFamily;
    context->SocketType = *SocketType;
    context->Protocol = *Protocol;
    context->ReceiveBufferSize = DEFAULT_RECEIVE_BUFFER_SIZE;
    context->Flags = Flags;
    context->LocalFlags = 0;

    //
    // Tell the Windows Sockets DLL which state transitions we're
    // interested in being notified of.
    //

    *NotificationEvents =
            WSH_NOTIFY_BIND | WSH_NOTIFY_LISTEN | WSH_NOTIFY_CLOSE;

    //
    // Everything worked, return success.
    //

    *HelperDllSocketContext = context;

    DBGPRINT(("WSHOpenSocket2 success: AF %d, Type %d, Proto %d\n",
                        *AddressFamily, *SocketType, *Protocol));

    return NO_ERROR;

} // WSHOpenSocket


INT
WSHNotify (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD NotifyEvent
    )

/*++

Routine Description:

    This routine is called by the winsock DLL after a state transition
    of the socket.  Only state transitions returned in the
    NotificationEvents parameter of WSHOpenSocket() are notified here.
    This routine allows a winsock helper DLL to track the state of
    socket and perform necessary actions corresponding to state
    transitions.

    If we see a LISTEN event, we call setsockopt() to force AFD to
    allocate data buffers (for options) for incoming connection requests
    on this socket.

    If we see a BIND event for a socket to be used for multipoint
    activity, we tell RAWWAN that the associated address object is
    of multipoint type.

Arguments:

    HelperDllSocketContext - the context pointer given to the winsock
        DLL by WSHOpenSocket().

    SocketHandle - the handle for the socket.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    NotifyEvent - indicates the state transition for which we're being
        called.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHATM_SOCKET_CONTEXT context = HelperDllSocketContext;
    INT err;
    INT Option;
    INT OptionLength = sizeof(Option);
    PCHAR pOption = (PCHAR)&Option;

        DBGPRINT(("Notify: Event = %d\n", NotifyEvent));

        err = NO_ERROR;

        switch (NotifyEvent)
        {
                case WSH_NOTIFY_BIND:

                        DBGPRINT(("NotifyBind: context %x, Flags %x, LocalFlags %x\n",
                                        context, context->Flags, context->LocalFlags));

                        //
                        //  Request the Winsock DLL to set the options.
                        //
                        Option = MAX_ATM_OPTIONS_LENGTH;

                        err = setsockopt(
                                        SocketHandle,
                                        SOL_SOCKET,
                                        SO_CONNOPTLEN,
                                        pOption,
                                        OptionLength
                                        );

                        if ( err != NO_ERROR ) {

                                DBGPRINT(("WSHATM: NotifyBind: setsockopt SO_CONNOPTLEN err %x\n", err));
                                break;
                        }

                        context->LocalFlags |= WSHATM_SOCK_IS_BOUND;

                        if ( ( context->Flags & ATM_WSA_MULTIPOINT_FLAGS ) != 0 ) {
                                
                                //
                                //  Prepare flags for RAWWAN.
                                //
                                Option = 0;

                                if ( context->Flags & WSA_FLAG_MULTIPOINT_C_ROOT ) {

                                        Option |= RWAN_AOFLAG_C_ROOT;
                                
                                }
                        
                                if ( context->Flags & WSA_FLAG_MULTIPOINT_C_LEAF ) {

                                        Option |= RWAN_AOFLAG_C_LEAF;
                                
                                }

                                if ( context->Flags & WSA_FLAG_MULTIPOINT_D_ROOT ) {

                                        Option |= RWAN_AOFLAG_D_ROOT;
                                
                                }

                                if ( context->Flags & WSA_FLAG_MULTIPOINT_D_LEAF ) {

                                        Option |= RWAN_AOFLAG_D_LEAF;
                                
                                }

                                //
                                //  Inform RAWWAN about the Multipoint nature of this
                                //  Address Object.
                                //
                                err = AtmSetGenericObjectInformation(
                                                TdiAddressObjectHandle,
                                                IOCTL_RWAN_GENERIC_ADDR_HANDLE_SET,
                                                RWAN_OID_ADDRESS_OBJECT_FLAGS,
                                                &Option,
                                                sizeof(Option)
                                                );

                                DBGPRINT(("Notify: Bind Notify on PMP endpoint, Option x%x, ret = %d\n",
                                                Option, err));
                        }
                        else if ( ( context->LocalFlags & WSHATM_SOCK_ASSOCIATE_PVC_PENDING ) ) {

                                DBGPRINT(("Notify: Bind Notify will Associate PVC\n"));
                                err = AtmDoAssociatePVC(
                                                context,
                                                TdiAddressObjectHandle
                                                );
                        }

                        break;
                                
                case WSH_NOTIFY_CLOSE:

                        RTL_FREE_HEAP( RtlProcessHeap( ), 0, context );
                        break;
                
                case WSH_NOTIFY_LISTEN:
                        //
                        //  Request the Winsock DLL to set the options.
                        //
                        Option = MAX_ATM_OPTIONS_LENGTH;

                        err = setsockopt(
                                        SocketHandle,
                                        SOL_SOCKET,
                                        SO_CONNOPTLEN,
                                        pOption,
                                        OptionLength
                                        );
                        break;

                default:
                        err = WSAEINVAL;
                        break;
        
        }

    return err;

} // WSHNotify


INT
WSHSetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    IN PCHAR OptionValue,
    IN INT OptionLength
    )

/*++

Routine Description:

    This routine sets information about a socket for those socket
    options supported in this helper DLL.  We don't support any
    options at present.

    This routine is called by the winsock DLL when a level/option
        name combination is passed to setsockopt() that the winsock DLL
        does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to setsockopt().

    OptionName - the optname parameter passed to setsockopt().

    OptionValue - the optval parameter passed to setsockopt().

    OptionLength - the optlen parameter passed to setsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHATM_SOCKET_CONTEXT context = HelperDllSocketContext;
    INT error;
    INT optionValue;

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

        DBGPRINT(("SetSocketInformation: Level %d, Option x%x\n", Level, OptionName));

    //
    // Check if this is an internal request for context information.
    //

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting that we set context
        // information for a new socket.  If the new socket was
        // accept()'ed, then we have already been notified of the socket
        // and HelperDllSocketContext will be valid.  If the new socket
        // was inherited or duped into this process, then this is our
        // first notification of the socket and HelperDllSocketContext
        // will be equal to NULL.
        //
        // Insure that the context information being passed to us is
        // sufficiently large.
        //

        if ( OptionLength < sizeof(*context) ) {
            return WSAEINVAL;
        }

        if ( HelperDllSocketContext == NULL ) {

            //
            // This is our notification that a socket handle was
            // inherited or duped into this process.  Allocate a context
            // structure for the new socket.
            //

            context = RTL_ALLOCATE_HEAP( RtlProcessHeap( ), 0, sizeof(*context) );
            if ( context == NULL ) {
                return WSAENOBUFS;
            }

            //
            // Copy over information into the context block.
            //

            RtlCopyMemory( context, OptionValue, sizeof(*context) );
            context->SocketHandle = SocketHandle;

            //
            // Tell the Windows Sockets DLL where our context information is
            // stored so that it can return the context pointer in future
            // calls.
            //

            *(PWSHATM_SOCKET_CONTEXT *)OptionValue = context;

            return NO_ERROR;

        } else {

            PWSHATM_SOCKET_CONTEXT parentContext;
            INT one = 1;
            INT zero = 0;

            //
            // The socket was accept()'ed and it needs to have the same
            // properties as it's parent.  The OptionValue buffer
            // contains the context information of this socket's parent.
            //

            parentContext = (PWSHATM_SOCKET_CONTEXT)OptionValue;

            ASSERT( context->AddressFamily == parentContext->AddressFamily );
            ASSERT( context->SocketType == parentContext->SocketType );
            ASSERT( context->Protocol == parentContext->Protocol );


            return NO_ERROR;
        }
    }


        return WSAENOPROTOOPT;

#if 0
    //
    // Handle socket-level options.
    //
    optionValue = *OptionValue;

    switch ( OptionName ) {

    case SO_RCVBUF:

        context->ReceiveBufferSize = optionValue;

        break;

    default:

        return WSAENOPROTOOPT;
    }

    return NO_ERROR;
#endif

} // WSHSetSocketInformation


INT
WSHEnumProtocols (
    IN LPINT lpiProtocols,
    IN LPWSTR lpTransportKeyName,
    IN OUT LPVOID lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Enumerates the protocols supported by this helper.

Arguments:

    lpiProtocols - Pointer to a NULL-terminated array of protocol
        identifiers. Only protocols specified in this array will
        be returned by this function. If this pointer is NULL,
        all protocols are returned.

    lpTransportKeyName -

    lpProtocolBuffer - Pointer to a buffer to fill with PROTOCOL_INFO
        structures.

    lpdwBufferLength - Pointer to a variable that, on input, contains
        the size of lpProtocolBuffer. On output, this value will be
        updated with the size of the data actually written to the buffer.

Return Value:

    INT - The number of protocols returned if successful, -1 if not.

--*/

{
    DWORD bytesRequired;
    PPROTOCOL_INFO atmProtocolInfo;
    PPROTOCOL_INFO udpProtocolInfo;
    BOOL useAtm = FALSE;
    DWORD i;

    lpTransportKeyName;         // Avoid compiler warnings.

        DBGPRINT(("EnumProtocols\n"));

    //
    // Make sure that the caller cares about ATM.
    //

    if ( ARGUMENT_PRESENT( lpiProtocols ) ) {

        for ( i = 0; lpiProtocols[i] != 0; i++ ) {
            if ( lpiProtocols[i] == ATMPROTO_AAL5 ) {
                useAtm = TRUE;
            }
        }

    } else {

        useAtm = TRUE;
    }

    if ( !useAtm ) {
        *lpdwBufferLength = 0;
        return 0;
    }

    //
    // Make sure that the caller has specified a sufficiently large
    // buffer.
    //

    bytesRequired = (DWORD)((sizeof(PROTOCOL_INFO) * 1) +
                        ( (wcslen( ATM_NAME ) + 1) * sizeof(WCHAR)));

    if ( bytesRequired > *lpdwBufferLength ) {
        *lpdwBufferLength = bytesRequired;
        return -1;
    }

    //
    // Fill in ATM info, if requested.
    //

    if ( useAtm ) {

        atmProtocolInfo = lpProtocolBuffer;

        atmProtocolInfo->dwServiceFlags = XP_GUARANTEED_ORDER |
                                              XP_MESSAGE_ORIENTED |
                                              XP_SUPPORTS_MULTICAST |
                                              XP_BANDWIDTH_ALLOCATION ;
        atmProtocolInfo->iAddressFamily = AF_ATM;
        atmProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_ATM);
        atmProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_ATM);
        atmProtocolInfo->iSocketType = ATM_AAL5_SOCK_TYPE;
        atmProtocolInfo->iProtocol = ATMPROTO_AAL5;
        atmProtocolInfo->dwMessageSize = 1;
        atmProtocolInfo->lpProtocol = (LPWSTR)
            ( (PBYTE)lpProtocolBuffer + *lpdwBufferLength -
                ( (wcslen( ATM_NAME ) + 1) * sizeof(WCHAR) ) );
        wcscpy( atmProtocolInfo->lpProtocol, ATM_NAME );

        DBGPRINT(("EnumProtocols: lpProtocolBuffer %x, lpProtocol %x, BufLen %d\n",
                                lpProtocolBuffer,
                                atmProtocolInfo->lpProtocol,
                                *lpdwBufferLength));

        }

    *lpdwBufferLength = bytesRequired;

    return (1);

} // WSHEnumProtocols



BOOLEAN
IsTripleInList (
    IN PMAPPING_TRIPLE List,
    IN ULONG ListLength,
    IN INT AddressFamily,
    IN INT SocketType,
    IN INT Protocol
    )

/*++

Routine Description:

    Determines whether the specified triple has an exact match in the
    list of triples.

Arguments:

    List - a list of triples (address family/socket type/protocol) to
        search.

    ListLength - the number of triples in the list.

    AddressFamily - the address family to look for in the list.

    SocketType - the socket type to look for in the list.

    Protocol - the protocol to look for in the list.

Return Value:

    BOOLEAN - TRUE if the triple was found in the list, false if not.

--*/

{
    ULONG i;

    //
    // Walk through the list searching for an exact match.
    //

    for ( i = 0; i < ListLength; i++ ) {

        //
        // If all three elements of the triple match, return indicating
        // that the triple did exist in the list.
        //

        if ( AddressFamily == List[i].AddressFamily &&
             SocketType == List[i].SocketType &&
             Protocol == List[i].Protocol
           ) {
            return TRUE;
        }
    }

    //
    // The triple was not found in the list.
    //

    return FALSE;

} // IsTripleInList



INT
WINAPI
WSHJoinLeaf (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN PVOID LeafHelperDllSocketContext,
    IN SOCKET LeafSocketHandle,
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    IN LPWSABUF CallerData,
    IN LPWSABUF CalleeData,
    IN LPQOS SocketQOS,
    IN LPQOS GroupQOS,
    IN DWORD Flags
    )

/*++

Routine Description:

    Performs the protocol-dependent portion of creating a multicast
    socket.

    TBD: Needs a Lot Of Work!

Arguments:

    The following four parameters correspond to the socket passed into
    the WSAJoinLeaf() API:

    HelperDllSocketContext - The context pointer returned from
        WSHOpenSocket().

    SocketHandle - The handle of the socket used to establish the
        multicast "session".

    TdiAddressObjectHandle - The TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - The TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    The next two parameters correspond to the newly created socket that
    identifies the multicast "session":

    LeafHelperDllSocketContext - The context pointer returned from
        WSHOpenSocket().

    LeafSocketHandle - The handle of the socket that identifies the
        multicast "session".

    Sockaddr - The name of the peer to which the socket is to be joined.

    SockaddrLength - The length of Sockaddr.

    CallerData - Pointer to user data to be transferred to the peer
        during multipoint session establishment.

    CalleeData - Pointer to user data to be transferred back from
        the peer during multipoint session establishment.

    SocketQOS - Pointer to the flowspecs for SocketHandle, one in each
        direction.

    GroupQOS - Pointer to the flowspecs for the socket group, if any.

    Flags - Flags to indicate if the socket is acting as sender,
        receiver, or both.

Return Value:

    INT - 0 if successful, a WinSock error code if not.

--*/

{

        INT err;

        if( Flags != JL_SENDER_ONLY ) {

                return WSAEINVAL;
        
        }

        if (SocketQOS)
        {
                err = WSHAtmSetQoS(
                                        LeafHelperDllSocketContext,
                                        LeafSocketHandle,
                                        SocketQOS,
                                        sizeof(*SocketQOS)
                                        );
        }

        return NO_ERROR;

} // WSHJoinLeaf


INT
WINAPI
WSHGetBroadcastSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a broadcast socket address.  A broadcast address
    may be used as a destination for the sendto() API to send a datagram
    to all interested clients.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a broadcast
        address.

    Sockaddr - points to a buffer which will receive the broadcast socket
        address.

    SockaddrLength - receives the length of the broadcast sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
#if 1
        return WSAEINVAL;
#else

    LPSOCKADDR_ATM addr;

    if( *SockaddrLength < sizeof(SOCKADDR_ATM) ) {

        return WSAEFAULT;

    }

    *SockaddrLength = sizeof(SOCKADDR_ATM);

    //
    // Build the broadcast address.
    //

    addr = (LPSOCKADDR_ATM)Sockaddr;

    RtlZeroMemory(
        addr,
        sizeof(*addr)
        );

    addr->satm_family = AF_ATM;
    addr->satm_number.s_addr = htonl( INADDR_BROADCAST );

    return NO_ERROR;
#endif // 1

} // WSAGetBroadcastSockaddr


INT
WINAPI
WSHGetWSAProtocolInfo (
    IN LPWSTR ProviderName,
    OUT LPWSAPROTOCOL_INFOW * ProtocolInfo,
    OUT LPDWORD ProtocolInfoEntries
    )

/*++

Routine Description:

    Retrieves a pointer to the WSAPROTOCOL_INFOW structure(s) describing
    the protocol(s) supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "RawWan".

    ProtocolInfo - Receives a pointer to the WSAPROTOCOL_INFOW array.

    ProtocolInfoEntries - Receives the number of entries in the array.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    if( ProviderName == NULL ||
        ProtocolInfo == NULL ||
        ProtocolInfoEntries == NULL ) {

        return WSAEFAULT;

    }

        DBGPRINT(("WSHGetWSAProtocolInfo: Provider Name: %ws\n", ProviderName));

    if( _wcsicmp( ProviderName, L"RawWan" ) == 0 ) {

        *ProtocolInfo = Winsock2Protocols;
        *ProtocolInfoEntries = NUM_WINSOCK2_PROTOCOLS;

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetWSAProtocolInfo


INT
WINAPI
WSHAddressToString (
    IN LPSOCKADDR Address,
    IN INT AddressLength,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPWSTR AddressString,
    IN OUT LPDWORD AddressStringLength
    )

/*++

Routine Description:

    Converts a SOCKADDR to a human-readable form.

Arguments:

    Address - The SOCKADDR to convert.

    AddressLength - The length of Address.

    ProtocolInfo - The WSAPROTOCOL_INFOW for a particular provider.

    AddressString - Receives the formatted address string.

    AddressStringLength - On input, contains the length of AddressString.
        On output, contains the number of characters actually written
        to AddressString.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    WCHAR string[64];
    PWCHAR pstring;
    INT length; // Number of WCHARs filled into string
    UINT        i;
    LPSOCKADDR_ATM addr;
    UCHAR Val;

    //
    // Quick sanity checks.
    //

    if( Address == NULL ||
        AddressLength < sizeof(SOCKADDR_ATM) ||
        AddressString == NULL ||
        AddressStringLength == NULL ) {

        return WSAEFAULT;

    }

    addr = (LPSOCKADDR_ATM)Address;

    if( addr->satm_family != AF_ATM ) {

        return WSAEINVAL;

    }

    if ( addr->satm_number.NumofDigits > ATM_ADDR_SIZE ) {
        return WSAEINVAL;
    }

    //
    // Do the conversion.
    //
    length = 0;
    pstring = string;

    //
    // If this is an E.164 address, prepend a '+'.
    // Each entry in the array in satm_number consists of one
        // digit coded in IA5 (ANSI).
    //
    if ( addr->satm_number.AddressType == ATM_E164 ) {

        *pstring++ = L'+';
        length++;

        for ( i = 0; i < addr->satm_number.NumofDigits; i++ ) {

                if ( !iswdigit(addr->satm_number.Addr[i]) ) {
                        return WSAEINVAL;
                    }

                *pstring++ = ANSI_TO_WCHAR(addr->satm_number.Addr[i]);
        }

        length += addr->satm_number.NumofDigits;

    } else {

        //
        // This must be NSAP format. Each entry in the array
                // is a full hex byte (two BCD digits). We'll unpack
                // each array entry into two characters.
        //
        for ( i = 0; i < addr->satm_number.NumofDigits; i++ ) {

                Val = (addr->satm_number.Addr[i] >> 4);
                        *pstring++ = DIGIT_TO_WCHAR(Val);

                Val = (addr->satm_number.Addr[i] & 0xf);
                        *pstring++ = DIGIT_TO_WCHAR(Val);
                }

                length += (2 * addr->satm_number.NumofDigits);
        }

        //
        // Terminate the string.
        //
        *pstring = L'\0';

    length++;   // account for terminator

    if( *AddressStringLength < (DWORD)length ) {

        return WSAEFAULT;

    }

    *AddressStringLength = (DWORD)length;

    RtlCopyMemory(
        AddressString,
        string,
        length * sizeof(WCHAR)
        );

    return NO_ERROR;

} // WSHAddressToString


INT
WINAPI
WSHStringToAddress (
    IN LPWSTR AddressString,
    IN DWORD AddressFamily,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPSOCKADDR Address,
    IN OUT LPINT AddressLength
    )

/*++

Routine Description:

    Fills in a SOCKADDR structure by parsing a human-readable string.

Arguments:

    AddressString - Points to the zero-terminated human-readable string.

    AddressFamily - The address family to which the string belongs.

    ProtocolInfo - The WSAPROTOCOL_INFOW for a particular provider.

    Address - Receives the SOCKADDR structure.

    AddressLength - On input, contains the length of Address. On output,
        contains the number of bytes actually written to Address.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{
    WCHAR string[2*ATM_ADDR_SIZE+1];
    UNICODE_STRING unistring;
    CHAR ansistring[2*ATM_ADDR_SIZE+1];
    ANSI_STRING ansstring;
    PCHAR src;
    PCHAR dst;
    LPWSTR terminator;
    LPSOCKADDR_ATM addr;
    PWCHAR s, d;
    INT numDigits, i;
    NTSTATUS status;

    //
    // Quick sanity checks.
    //

    if( AddressString == NULL ||
        Address == NULL ||
        AddressLength == NULL ||
        *AddressLength < sizeof(SOCKADDR_ATM) ) {

        return WSAEFAULT;

    }

    if( AddressFamily != AF_ATM ) {

        DBGPRINT(("StrToAddr: invalid addrfam %d\n", AddressFamily));
        return WSAEINVAL;

    }


    addr = (LPSOCKADDR_ATM)Address;
    RtlZeroMemory(
        Address,
        sizeof(SOCKADDR_ATM)
        );

    //
    // Strip off all punctuation characters (spaces and periods).
    //
    for ( numDigits = 0, s = AddressString, d = string;
          (numDigits <= sizeof(WCHAR)*ATM_ADDR_SIZE) && (*s != L'\0');
          s++ ) {

                if ( *s == ATM_ADDR_BLANK_CHAR ||
                         *s == ATM_ADDR_PUNCTUATION_CHAR ) {
                         continue;
                }

                *d++ = *s;
                numDigits ++;
        }

        if ( numDigits == 0 ) {

        DBGPRINT(("StrToAddr[%ws]: numdigits after stripping is 0!\n",
                        AddressString));
                return WSAEINVAL;
        }

        //
        // Terminate it and convert into Unicode string.
        //
        *d = L'\0';

        RtlInitUnicodeString(&unistring, string);

        //
        // Convert it into an ANSI string.
        //
        ansstring.Buffer = ansistring;
        ansstring.MaximumLength = 2*ATM_ADDR_SIZE + 1;
        ansstring.Length = 0;

        status = RtlUnicodeStringToAnsiString(&ansstring, &unistring, FALSE);

        if ( status != STATUS_SUCCESS ) {
                DBGPRINT(("StrToAddr[%ws]: RtlUnicodeToAnsi failed (%x)\n",
                                string, status));
                return WSAEINVAL;
        }

        addr->satm_family = AF_ATM;

        src = ansistring;

        if ( *src == ATM_ADDR_E164_START_CHAR ) {

                src ++;
                numDigits --;

                if ( numDigits == 0 ) {
                        DBGPRINT(("StrToAddr[%ws]: AnsiString:[%s], numDigits is 0!\n",
                                                string, ansistring));
                        return WSAEINVAL;
                }

                addr->satm_number.AddressType = ATM_E164;
                addr->satm_number.NumofDigits = numDigits;

                RtlCopyMemory(addr->satm_number.Addr, src, numDigits);

        } else {

                UCHAR           hexString[3];
                ULONG           Val;

                hexString[2] = 0;

                if ( numDigits != 2 * ATM_ADDR_SIZE ) {
                        return WSAEINVAL;
                }

                addr->satm_number.AddressType = ATM_NSAP;
                addr->satm_number.NumofDigits = numDigits/2;

                for ( i = 0; i < ATM_ADDR_SIZE; i++ ) {

                        hexString[0] = *src++;
                        hexString[1] = *src++;

                        status = RtlCharToInteger(hexString, 16, &Val);

                        if ( status != STATUS_SUCCESS ) {
                                DBGPRINT(("StrToAtm[%ws]: index %d, hexString: %s, CharToInt %x\n",
                                                string, hexString, status));
                                return WSAEINVAL;
                        }

                        addr->satm_number.Addr[i] = (UCHAR)Val;
                }

        }

        addr->satm_blli.Layer2Protocol = SAP_FIELD_ABSENT;
        addr->satm_blli.Layer3Protocol = SAP_FIELD_ABSENT;
        addr->satm_bhli.HighLayerInfoType = SAP_FIELD_ABSENT;

    *AddressLength = sizeof(SOCKADDR_ATM);

    return NO_ERROR;

} // WSHStringToAddress


INT
WINAPI
WSHGetProviderGuid (
    IN LPWSTR ProviderName,
    OUT LPGUID ProviderGuid
    )

/*++

Routine Description:

    Returns the GUID identifying the protocols supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "RawWan".

    ProviderGuid - Points to a buffer that receives the provider's GUID.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    if( ProviderName == NULL ||
        ProviderGuid == NULL ) {

        return WSAEFAUL