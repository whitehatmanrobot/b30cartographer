
                wcsncpy(szLocation, ServerName, nLength) ;
            }

            //
            //  show the user and server names. 
            //
            SetDlgItemTextW(DialogHandle, ID_SERVER, szLocation);
            SetDlgItemTextW(DialogHandle, ID_USERNAME, UserName);

            //
            // set limits
            //
            SendDlgItemMessageW( DialogHandle,
                                 ID_PASSWORD,
                                 EM_LIMITTEXT,
                                 PasswordSize - 1,  // minus space for '\0'
                                 0 );

            return TRUE;


        case WM_COMMAND:

            switch (LOWORD(WParam)) {


                case IDHELP:

                    DialogBoxParamW(
                        hmodNW,
                        MAKEINTRESOURCEW(DLG_ENTER_PASSWORD_HELP),
                        (HWND) DialogHandle,
                        (DLGPROC) NwpHelpDlgProc,
                        (LPARAM) 0
                        );

                    return TRUE;

                case IDOK:

                    Result = GetDlgItemTextW( DialogHandle,
                                              ID_PASSWORD,
                                              Password,
                                              PasswordSize
                                              );

                    EndDialog(DialogHandle, (INT) IDOK);  // OK

                    return TRUE;


                case IDCANCEL:


                    EndDialog(DialogHandle, (INT) IDCANCEL);  // CANCEL

                    return TRUE;
            }
    }

    //
    // We didn't process this message
    //
    return FALSE;
}



BOOL
WINAPI
NwpChangePasswordDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    )
/*++

Routine Description:

    This function is the window management message handler for
    the change password dialog.

Arguments:

    DialogHandle - Supplies a handle to display the dialog.

    Message - Supplies the window management message.

    LParam - Supplies the pointer to a buffer which on input
        contains the Server string under which the user
        needs to type in a new credential before browsing.  On
        output, this pointer contains the username and server
        strings entered to the dialog box.

Return Value:

    TRUE - the message was processed.

    FALSE - the message was not processed.

--*/
{
    static PCHANGE_PASS_DLG_PARAM pChangePassParam ;

    switch (Message)
    {
      case WM_INITDIALOG:

        pChangePassParam = (PCHANGE_PASS_DLG_PARAM) LParam;

        NwpCenterDialog(DialogHandle);


        SetDlgItemTextW(DialogHandle, ID_SERVER, pChangePassParam->TreeName);
        SetDlgItemTextW(DialogHandle, ID_USERNAME, pChangePassParam->UserName);

        //
        // set limits
        //
        SendDlgItemMessageW( DialogHandle,
                             ID_OLD_PASSWORD,
                             EM_LIMITTEXT,
                             NW_MAX_PASSWORD_LEN,  // minus space for '\0'
                             0 );

        SendDlgItemMessageW( DialogHandle,
                             ID_NEW_PASSWORD,
                             EM_LIMITTEXT,
                             NW_MAX_PASSWORD_LEN,  // minus space for '\0'
                             0 );

        SendDlgItemMessageW( DialogHandle,
                             ID_CONFIRM_PASSWORD,
                             EM_LIMITTEXT,
                             NW_MAX_PASSWORD_LEN,  // minus space for '\0'
                             0 );

        return TRUE;


      case WM_COMMAND:

        switch (LOWORD(WParam))
        {
            case IDHELP:

                DialogBoxParamW(
                                 hmodNW,
                                 MAKEINTRESOURCEW(DLG_CHANGE_PASSWORD_HELP),
                                 (HWND) DialogHandle,
                                 (DLGPROC) NwpHelpDlgProc,
                                 (LPARAM) 0
                               );

                return TRUE;

            case IDOK:
                {
                    INT    Result;
                    WCHAR  szConfirmPassword[NW_MAX_PASSWORD_LEN + 1];
                    UNICODE_STRING OldPasswordStr;
                    UNICODE_STRING NewPasswordStr;
                    UCHAR EncodeSeed = NW_ENCODE_SEED2;

                    Result = GetDlgItemTextW( DialogHandle,
                                              ID_OLD_PASSWORD,
                                              pChangePassParam->OldPassword,
                                              NW_MAX_PASSWORD_LEN
                                            );

                    Result = GetDlgItemTextW( DialogHandle,
                                              ID_NEW_PASSWORD,
                                              pChangePassParam->NewPassword,
                                              NW_MAX_PASSWORD_LEN
                                            );

                    Result = GetDlgItemTextW( DialogHandle,
                                              ID_CONFIRM_PASSWORD,
                                              szConfirmPassword,
                                              NW_MAX_PASSWORD_LEN
                                            );

                    if ( wcscmp( pChangePassParam->NewPassword,
                                 szConfirmPassword ) )
                    {
                        //
                        // New and Confirm passwords don't match!
                        //
                        (void) NwpMessageBoxError(
                                   DialogHandle,
                                   IDS_CHANGE_PASSWORD_TITLE,
                                   IDS_CHANGE_PASSWORD_CONFLICT,
                                   0,
                                   NULL,
                                   MB_OK | MB_ICONSTOP );

                        SetDlgItemText( DialogHandle,
                                        ID_NEW_PASSWORD,
                                        L"" );

                        SetDlgItemText( DialogHandle,
                                        ID_CONFIRM_PASSWORD,
                                        L"" );

                        SetFocus( GetDlgItem( DialogHandle,
                                              ID_NEW_PASSWORD ));

                        return TRUE;
                    }

                    RtlInitUnicodeString( &OldPasswordStr,
                                          pChangePassParam->OldPassword );
                    RtlInitUnicodeString( &NewPasswordStr,
                                          pChangePassParam->NewPassword );
                    RtlRunEncodeUnicodeString(&EncodeSeed, &OldPasswordStr);
                    RtlRunEncodeUnicodeString(&EncodeSeed, &NewPasswordStr);

                    EndDialog(DialogHandle, (INT) IDOK);  // OK

                    return TRUE;
                }

            case IDCANCEL:

                EndDialog(DialogHandle, (INT) IDCANCEL);  // CANCEL

                return TRUE;

            default:
                return FALSE;
        }
    }

    //
    // We didn't process this message
    //
    return FALSE;
}



BOOL
WINAPI
NwpHelpDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    )
//
// This dialog is used for both Help and Question dialogs.
//
{
    switch (Message) {

        case WM_INITDIALOG:

            NwpCenterDialog(DialogHandle);
            return TRUE;

        case WM_COMMAND:

            switch (LOWORD(WParam))
            {

                case IDOK:
                case IDCANCEL:
                    EndDialog(DialogHandle, IDOK);
                    return TRUE;

                case IDYES:
                    EndDialog(DialogHandle, IDYES);
                    return TRUE;

                case IDNO:
                    EndDialog(DialogHandle, IDNO);
                    return TRUE;

                default:
                    return FALSE ;
            }
    }

    //
    // We didn't process this message
    //
    return FALSE;
}



VOID
NwpGetNoneString(
    LPWSTR pszNone,
    DWORD  cBufferSize
    )
/*++

Routine Description:

    This function gets the <NONE> string from the resource.

Arguments:

    pszNone - Supplies the buffer to store the string.

    cBufferSize - Supplies the buffer size in bytes.

Return Value:

    None.
--*/
{
    INT TextLength;


    TextLength = LoadStringW( hmodNW,
                              IDS_NONE,
                              pszNone,
                              cBufferSize / sizeof( WCHAR) );

    if ( TextLength == 0 )
        *pszNone = 0;
}



VOID
NwpAddNetWareTreeConnectionsToList(
    IN HWND    DialogHandle,
    IN LPWSTR  NtUserName,
    IN LPDWORD lpdwUserLuid,
    IN INT     ControlId
    )
{
    DWORD  status = NO_ERROR;
    DWORD  BufferSize = 2048; // 2KB Buffer
    BYTE   pBuffer[2048];
    DWORD  EntriesRead;
    LRESULT    Result ;

    status = NwGetConnectedTrees( NtUserName,
                                  pBuffer,
                                  BufferSize,
                                  &EntriesRead,
                                  lpdwUserLuid );

    // NwGetConnectedTrees doesn't return ERR_NO_SUCH_USER, so we check for no EntriesRead
    // JimTh, 4/25/02 - It looks to me like NwGetConnectedTrees DOES return ERR_NO_SUCH_USER
	// If none found, check for dotted name (fred.flintstone) or UPN (fred@flintstones.com)
    if ( EntriesRead == 0 )
    {
        // escape any dots in the user name and try again
        WCHAR   EscapedName[NW_MAX_USERNAME_LEN * 2];
        PWSTR   pChar = NtUserName;
        int     i = 0;
        BOOL    bEscaped = FALSE;

        RtlZeroMemory(EscapedName, sizeof(EscapedName));

        do
        {
            if (*pChar == L'.')
            {
                EscapedName[i++] = '\\';
                bEscaped = TRUE;
            }
			// also handle UPN names
            else if (*pChar == L'@') { 
                EscapedName[i] = 0;
                bEscaped = TRUE;
                break;
            }
            EscapedName[i++] = *pChar;
        } while (*pChar++);

        if (bEscaped)
        {
            status = NwGetConnectedTrees( EscapedName,
                                          pBuffer,
                                          BufferSize,
                                          &EntriesRead,
                                          lpdwUserLuid );
        }
    }
    if ( status == NO_ERROR  && EntriesRead > 0 )
    {
        PCONN_INFORMATION pConnInfo = (PCONN_INFORMATION) pBuffer;
        WCHAR             tempTreeName[NW_MAX_TREE_LEN + 1];
        DWORD             dwSize;

        while ( EntriesRead-- )
        {
            dwSize = sizeof( CONN_INFORMATION );
            dwSize += pConnInfo->HostServerLength;
            dwSize += pConnInfo->UserNameLength;

            RtlZeroMemory( tempTreeName,
                           ( NW_MAX_TREE_LEN + 1 ) * sizeof(WCHAR) );

            wcsncpy( tempTreeName,
                     pConnInfo->HostServer,
                     pConnInfo->HostServerLength / sizeof(WCHAR) );

            CharUpperW( tempTreeName );

            //
            // Add the tree name to the list only
            // if it's not added already.
            //
            Result = SendDlgItemMessageW( DialogHandle,
                                          ControlId,
                                          LB_FINDSTRING,
                                          (WPARAM) -1,
                                          (LPARAM) tempTreeName );

            if (Result == LB_ERR)
            {
                Result = SendDlgItemMessageW( DialogHandle,
                                     ControlId,
                                     LB_ADDSTRING,
                                     0,
                                     (LPARAM) tempTreeName );

                if (Result != LB_ERR)
                {
                    LPWSTR lpNdsUserName = NULL;

                    lpNdsUserName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                                                pConnInfo->UserNameLength +
                                                sizeof(WCHAR) );

                    if ( lpNdsUserName )
                    {
                        wcsncpy( lpNdsUserName,
                                 pConnInfo->UserName,
                                 pConnInfo->UserNameLength  / sizeof(WCHAR) );

                        SendDlgItemMessageW( DialogHandle,
                                             ControlId,
                                             LB_SETITEMDATA,
                                             (WPARAM) Result, // index of entry
                                             (LPARAM) lpNdsUserName );
                    }
                }
            }

            pConnInfo = (PCONN_INFORMATION) ( ((BYTE *)pConnInfo) + dwSize );
        }
    }
    else
    {
        *lpdwUserLuid = 0;
    }
}



BOOL
WINAPI
NwpChangePasswdDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    )
/*++

Routine Description:

    This function is the window management message handler for
    the change password dialog.

Arguments:

    DialogHandle - Supplies a handle to display the dialog.

    Message - Supplies the window management message.

    LParam - Supplies the pointer to a buffer which on input
        contains the Server string under which the user
        needs to type in a new credential before browsing.  On
        output, this pointer contains the username and server
        strings entered to the dialog box.

Return Value:

    TRUE - the message was processed.

    FALSE - the message was not processed.

--*/
{
    static LPWSTR UserName;
    static LPWSTR ServerName;
    static DWORD  UserNameSize ;
    static DWORD  ServerNameSize ;
    INT           Result ;
    PPASSWDDLGPARAM DlgParams ;

    switch (Message) {

        case WM_INITDIALOG:

            DlgParams = (PPASSWDDLGPARAM) LParam;
            UserName = DlgParams->UserName ;
            ServerName =  DlgParams->ServerName ;
            UserNameSize = DlgParams->UserNameSize ;
            ServerNameSize =  DlgParams->ServerNameSize ;

            //
            // Position dialog
            //
            NwpCenterDialog(DialogHandle);


            //
            //  setup the default user and server names
            //
            SetDlgItemTextW(DialogHandle, ID_SERVER, ServerName);
            SetDlgItemTextW(DialogHandle, ID_USERNAME, UserName);

            //
            // Username is limited to 256 characters.
            //
            SendDlgItemMessageW(DialogHandle,
                                ID_USERNAME,
                                EM_LIMITTEXT,
                                UserNameSize - 1, // minus space for '\0'
                                0 );

            //
            // Server is limited to 256 characters.
            //
            SendDlgItemMessageW( DialogHandle,
                                 ID_SERVER,
                                 EM_LIMITTEXT,
                                 ServerNameSize - 1, // minus space for '\0'
                                 0 );

            //
            // Add trees to list
            //
            NwpAddToComboBox( DialogHandle,
                              ID_SERVER,
                              NULL,
                              FALSE ) ;

            return TRUE;


        case WM_COMMAND:

            switch (LOWORD(WParam)) {

                case IDOK:

                    Result = GetDlgItemTextW( DialogHandle,
                                              ID_USERNAME,
                                              UserName,
                                              UserNameSize );

                    Result = GetDlgItemTextW( DialogHandle,
                                              ID_SERVER,
                                              ServerName,
                                              ServerNameSize );

                    EndDialog(DialogHandle, (INT) IDOK);  // OK

                    return TRUE;


                case IDCANCEL:

                    EndDialog(DialogHandle, (INT) IDCANCEL);  // CANCEL

                    return TRUE;
            }
    }

    //
    // We didn't process this message
    //
    return FALSE;
}



BOOL
WINAPI
NwpOldPasswordDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    )
//
// This dialog lets the user retype the old password for a specific
// server/tree.
//
{
    static POLD_PW_DLG_PARAM OldPwParam;


    switch (Message) {

        case WM_INITDIALOG:

            OldPwParam = (POLD_PW_DLG_PARAM) LParam;

            NwpCenterDialog(DialogHandle);

            SetDlgItemTextW(DialogHandle, ID_SERVER, OldPwParam->FailedServer);

            SendDlgItemMessageW(
                DialogHandle,
                ID_PASSWORD,
                EM_LIMITTEXT,
                NW_MAX_PASSWORD_LEN,
                0
                );

            return TRUE;

        case WM_COMMAND:

            switch (LOWORD(WParam))
            {

                case IDCANCEL:
                    EndDialog(DialogHandle, IDCANCEL);
                    return TRUE;

                case IDOK:
                {
                    UCHAR EncodeSeed = NW_ENCODE_SEED2;
                    UNICODE_STRING PasswordStr;


                    RtlZeroMemory(
                        OldPwParam->OldPassword,
                        NW_MAX_PASSWORD_LEN * sizeof(WCHAR)
                        );

                    GetDlgItemTextW(
                        DialogHandle,
                        ID_PASSWORD,
                        OldPwParam->OldPassword,
                        NW_MAX_PASSWORD_LEN
                        );

#if DBG
                    IF_DEBUG(LOGON) {
                        KdPrint(("NWPROVAU: Retyped password %ws\n",
                                 OldPwParam->OldPassword));
                    }
#endif
                    RtlInitUnicodeString(&PasswordStr, OldPwParam->OldPassword);
                    RtlRunEncodeUnicodeString(&EncodeSeed, &PasswordStr);

                    EndDialog(DialogHandle, IDOK);
                    return TRUE;
                }

                case IDHELP:

                    DialogBoxParamW(
                        hmodNW,
                        MAKEINTRESOURCEW(DLG_ENTER_OLD_PW_HELP),
                        (HWND) DialogHandle,
                        (DLGPROC) NwpHelpDlgProc,
                        (LPARAM) 0
                        );
                    return TRUE;

                default:
                    return FALSE;
            }
    }

    //
    // We didn't process this message
    //
    return FALSE;
}



BOOL
WINAPI
NwpAltUserNameDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    )
//
// This dialog lets the user retype an alternate username for a specific
// server/tree.
//
{
    static PUSERNAME_DLG_PARAM UserNameParam;

    switch (Message)
    {
        case WM_INITDIALOG:

            UserNameParam = (PUSERNAME_DLG_PARAM) LParam;

            NwpCenterDialog(DialogHandle);

            //
            // Display the server/tree.
            //
            SetDlgItemTextW(
                DialogHandle,
                ID_SERVER,
                UserNameParam->TreeServerName
                );

            //
            // Username is limited to 256 characters.
            //
            SendDlgItemMessageW(
                DialogHandle,
                ID_USERNAME,
                EM_LIMITTEXT,
                256, 
                0
                );

            SetDlgItemTextW(
                DialogHandle,
                ID_USERNAME,
                UserNameParam->UserName
                );

            return TRUE;

        case WM_COMMAND:

            switch (LOWORD(WParam))
            {

                case IDCANCEL:
                    EndDialog(DialogHandle, IDCANCEL);
                    return TRUE;

                case IDOK:
                {
                    RtlZeroMemory(
                        UserNameParam->UserName,
                        256 * sizeof(WCHAR)
                        );

                    GetDlgItemTextW(
                        DialogHandle,
                        ID_USERNAME,
                        UserNameParam->UserName,
                        256
                        );

#if DBG
                    IF_DEBUG(LOGON) {
                        KdPrint(("NWPROVAU: Retyped username %ws\n",
                                 UserNameParam->UserName));
                    }
#endif

                    EndDialog(DialogHandle, IDOK);
                    return TRUE;
                }

                case IDHELP:

                    DialogBoxParamW(
                        hmodNW,
                        MAKEINTRESOURCEW(DLG_ENTER_ALT_UN_HELP),
                        (HWND) DialogHandle,
                        (DLGPROC) NwpHelpDlgProc,
                        (LPARAM) 0
                        );
                    return TRUE;

                default:
                    return FALSE;
            }
    }

    //
    // We didn't process this message
    //
    return FALSE;
}


VOID
EnableAddRemove(
    IN HWND DialogHandle
    )
/*++

Routine Description:

    This function enables and disables Add and Remove buttons
    based on list box selections.

Arguments:

    DialogHandle - Supplies a handle to the windows dialog.

Return Value:

    None.

--*/
{
    LRESULT cSel;


    cSel = SendDlgItemMessageW(
               DialogHandle,
               ID_INACTIVE_LIST,
               LB_GETSELCOUNT,
               0,
               0
               );
    EnableWindow(GetDlgItem(DialogHandle, ID_ADD), cSel != 0);

    cSel = SendDlgItemMessageW(
               DialogHandle,
               ID_ACTIVE_LIST,
               LB_GETSELCOUNT,
               0,
               0
               );
    EnableWindow(GetDlgItem(DialogHandle, ID_REMOVE), cSel != 0);
}




BOOL
WINAPI
NwpSelectServersDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    )
/*++

Routine Description:

    This routine displays two listboxes--an active list which includes
    the trees which the user is currently attached to, and an inactive
    list which displays the rest of the trees on the net.  The user
    can select trees and move them back and forth between the list
    boxes.  When OK is selected, the password is changed on the trees
    in the active listbox.

Arguments:

    DialogHandle - Supplies a handle to the login dialog.

    Message - Supplies the window management message.

    LParam - Supplies the user credential: username, old password and
        new password.  The list of trees from the active listbox
        and the number of entries are returned.

Return Value:

    TRUE - the message was processed.

    FALSE - the message was not processed.

--*/
{
    WCHAR szServer[NW_MAX_SERVER_LEN + 1];
    static PCHANGE_PW_DLG_PARAM Credential;
    DWORD status;
    DWORD UserLuid = 0;
    LRESULT ActiveListBoxCount;
    LRESULT InactiveListBoxCount;

    switch (Message) {

        case WM_INITDIALOG:

            //
            // Get the user credential passed in.
            //
            Credential = (PCHANGE_PW_DLG_PARAM) LParam;

            //
            // Position dialog
            //
            NwpCenterDialog(DialogHandle);

            //
            // Display the username.
            //
            SetDlgItemTextW(
                DialogHandle,
                ID_USERNAME,
                Credential->UserName
                );

            //
            // Display current NetWare tree connections in the active box.
            //
            NwpAddNetWareTreeConnectionsToList(
                DialogHandle,
                Credential->UserName,
                &UserLuid,
                ID_ACTIVE_LIST
                );

            //
            // Display all trees in inactive list box.
            //
            NwpAddTreeNamesToControl(
                DialogHandle,
                ID_INACTIVE_LIST,
                LB_ADDSTRING,
                ID_ACTIVE_LIST,
                LB_FINDSTRING
                );

            //
            // Highlight the first entry of the inactive list.
            //
            SetFocus(GetDlgItem(DialogHandle, ID_INACTIVE_LIST));
            SendDlgItemMessageW(
                DialogHandle,
                ID_INACTIVE_LIST,
                LB_SETSEL,
                TRUE,
                0
                );

            EnableAddRemove(DialogHandle);

            ActiveListBoxCount = SendDlgItemMessageW( DialogHandle,
                                                      ID_ACTIVE_LIST,
                                                      LB_GETCOUNT,
                                                      0,
                                                      0 );

            InactiveListBoxCount = SendDlgItemMessageW( DialogHandle,
                                                        ID_INACTIVE_LIST,
                                                        LB_GETCOUNT,
                                                        0,
                                                        0 );

            if ( ActiveListBoxCount == 0 &&
                 InactiveListBoxCount == 0 )
            {
                    (void) NwpMessageBoxError( DialogHandle,
                                               IDS_NETWARE_TITLE,
                                               IDS_NO_TREES_DETECTED,
                                               0,
                                               NULL,
                                               MB_OK );

                    EndDialog(DialogHandle, (INT) IDOK);
            }

            return TRUE;

        case WM_COMMAND:

            switch (LOWORD(WParam))
            {
                case IDOK:
                {
                    if ((status = NwpGetTreesAndChangePw(
                                      DialogHandle,
                                      szServer,
                                      UserLuid,
                                      Credential
                                      ) != NO_ERROR))
                    {
                        //
                        // System error: e.g. out of memory error.
                        //
                        (void) NwpMessageBoxError(
                                   DialogHandle,
                                   IDS_CHANGE_PASSWORD_TITLE,
                                   0,
                                   status,
                                   NULL,
                                   MB_OK | MB_ICONSTOP );

                        EndDialog(DialogHandle, (INT) -1);
                        return TRUE;
                    }

                    EndDialog(DialogHandle, (INT) IDOK);
                    return TRUE;
                }

                case IDCANCEL:

                    EndDialog(DialogHandle, (INT) IDCANCEL);
                    return TRUE;


                case IDHELP:

                    DialogBoxParamW(
                        hmodNW,
                        MAKEINTRESOURCEW(DLG_PW_SELECT_SERVERS_HELP),
                        (HWND) DialogHandle,
                        (DLGPROC) NwpHelpDlgProc,
                        (LPARAM) 0
                        );

                    return TRUE;



                case ID_ACTIVE_LIST:
                    //
                    // When Remove is pressed the highlights follows
                    // the selected entries over to the other
                    // list box.
                    //
                    if (HIWORD(WParam) == LBN_SELCHANGE) {
                        //
                        // Unselect the other listbox
                        //
                        SendDlgItemMessageW(
                            DialogHandle,
                            ID_INACTIVE_LIST,
                            LB_SETSEL,
                            FALSE,
                            (LPARAM) -1
                            );

                        EnableAddRemove(DialogHandle);
                    }

                    return TRUE;

                case ID_INACTIVE_LIST:

                    //
                    // When Add is pressed the highlights follows
                    // the selected entries over to the other
                    // list box.
                    //
                    if (HIWORD(WParam) == LBN_SELCHANGE) {
                        //
                        // Unselect the other listbox
                        //
                        SendDlgItemMessageW(
                            DialogHandle,
                            ID_ACTIVE_LIST,
                            LB_SETSEL,
                            FALSE,
                            (LPARAM) -1
                            );

                        EnableAddRemove(DialogHandle);
                    }

                    return TRUE;

                case ID_ADD:
                case ID_REMOVE:
                {
                    INT idFrom;
                    INT idTo;
                    LRESULT cSel;
                    INT SelItem;
                    LRESULT iNew;
                    HWND hwndActiveList;
                    HWND hwndInactiveList;

                    hwndActiveList = GetDlgItem(DialogHandle, ID_ACTIVE_LIST);
                    hwndInactiveList = GetDlgItem(DialogHandle, ID_INACTIVE_LIST);

                    //
                    // Set to NOREDRAW to TRUE
                    //
                    SetWindowLong(hwndActiveList, GWL_STYLE,
                    GetWindowLong(hwndActiveList, GWL_STYLE) | LBS_NOREDRAW);
                    SetWindowLong(hwndInactiveList, GWL_STYLE,
                    GetWindowLong(hwndInactiveList, GWL_STYLE) | LBS_NOREDRAW);

                    if (LOWORD(WParam) == ID_ADD)
                    {
                      idFrom = ID_INACTIVE_LIST;
                      idTo = ID_ACTIVE_LIST;
                    }
                    else
                    {
                      idFrom = ID_ACTIVE_LIST;
                      idTo = ID_INACTIVE_LIST;
                    }

                    //
                    // Move current selection from idFrom to idTo
                    //

                    //
                    // Loop terminates when selection count is zero
                    //
                    for (;;) {
                        //
                        // Get count of selected strings
                        //
                        cSel = SendDlgItemMessageW(
                                   DialogHandle,
                                   idFrom,
                                   LB_GETSELCOUNT,
                                   0,
                                   0
                                   );

                        if (cSel == 0) {
                            //
                            // No more selection
                            //
                            break;
                        }

                        //
                        // To avoid flickering as strings are added and
                        // removed from listboxes, no redraw is set for
                        // both listboxes until we are transfering the
                        // last entry, in which case we reenable redraw
                        // so that both listboxes are updated once.
                        //
                        if (cSel == 1) {

                            SetWindowLong(
                                hwndActiveList,
                                GWL_STYLE,
                                GetWindowLong(hwndActiveList, GWL_STYLE) & ~LBS_NOREDRAW
                                );

                            SetWindowLong(
                                hwndInactiveList,
                                GWL_STYLE,
                                GetWindowLong(hwndInactiveList, GWL_STYLE) & ~LBS_NOREDRAW
                                );
                        }

                        //
                        // Get index of first selected item
                        //
                        SendDlgItemMessageW(
                            DialogHandle,
                            idFrom,
                            LB_GETSELITEMS,
                            1,
                            (LPARAM) &SelItem
                            );

                        //
                        // Get server name from list
                        //
                        SendDlgItemMessageW(
                            DialogHandle,
                            idFrom,
                            LB_GETTEXT,
                            (WPARAM) SelItem,
                            (LPARAM) (LPWSTR) szServer
                            );

                        //
                        // Remove entry from list
                        //
                        SendDlgItemMessageW(
                            DialogHandle,
                            idFrom,
                            LB_DELETESTRING,
                            (WPARAM) SelItem,
                            0
                            );

                        //
                        // Add entry to list
                        //
                        iNew = SendDlgItemMessageW(
                                   DialogHandle,
                                   idTo,
                                   LB_ADDSTRING,
                                   0,
                                   (LPARAM) (LPWSTR) szServer
                                   );

                        //
                        // Select the new item
                        //
                        if (iNew != LB_ERR) {
                                SendDlgItemMessageW(
                                    DialogHandle,
                                    idTo,
                                    LB_SETSEL,
                                    TRUE,
                                    iNew
                                    );
                        }

                    } // for

                    EnableAddRemove(DialogHandle);

                } // ID_ADD or ID_REMOVE
            }

    }

    //
    // We didn't process this message
    //
    return FALSE;
}

DWORD
NwpGetTreesAndChangePw(
    IN HWND   DialogHandle,
    IN LPWSTR ServerBuf,
    IN DWORD  UserLuid,
    IN PCHANGE_PW_DLG_PARAM Credential
    )
/*++

Routine Description:

    This routine gets the selected trees from the active list box
    and asks the redirector to change password on them.  If a failure
    is encountered when changing password on a tree, we pop up appropriate
    dialogs to see if user can fix problem.

Arguments:

    DialogHandle - Supplies a handle to the login dialog.

Return Value:

    TRUE - the message was processed.

    FALSE - the message was not processed.

--*/
{
    DWORD status;
    HCURSOR Cursor;
    WCHAR tempOldPassword[NW_MAX_PASSWORD_LEN + 1];
    WCHAR tempNewPassword[NW_MAX_PASSWORD_LEN + 1];
    WCHAR tempUserName[MAX_NDS_NAME_CHARS];

    //
    // Turn cursor into hourglass
    //
    Cursor = LoadCursor(NULL, IDC_WAIT);
    if (Cursor != NULL) {
        SetCursor(Cursor);
        ShowCursor(TRUE);
    }

    Credential->ChangedOne = FALSE;
    Credential->TreeList = NULL;
    Credential->UserList = NULL;

    //
    // Get the number of trees we have to change password on.
    //
    Credential->Entries = (DWORD) SendDlgItemMessageW(
                                                      DialogHandle,
                                                      ID_ACTIVE_LIST,
                                                      LB_GETCOUNT,
                                                      0,
                                                      0 );

    if (Credential->Entries != 0) {

        DWORD Entries;        // Number of entries in remaining list
        DWORD FullIndex;      // Index to the whole tree list
        DWORD i;
        DWORD BytesNeeded = sizeof(LPWSTR) * Credential->Entries +
                            (NW_MAX_SERVER_LEN + 1) * sizeof(WCHAR) * Credential->Entries;
        LPBYTE FixedPortion;
        LPWSTR EndOfVariableData;
        LRESULT Result;

        Entries = Credential->Entries;
        Credential->TreeList = LocalAlloc(0, BytesNeeded);
        Credential->UserList = LocalAlloc(0,
                                          sizeof(LPWSTR) * Credential->Entries);

        if (Credential->TreeList == NULL)
        {
            KdPrint(("NWPROVAU: No memory to change password\n"));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if (Credential->UserList == NULL)
        {
            KdPrint(("NWPROVAU: No memory to change password\n"));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        FixedPortion = (LPBYTE) Credential->TreeList;
        EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                             ROUND_DOWN_COUNT(BytesNeeded, ALIGN_DWORD));

        for (i = 0; i < Entries; i++)
        {
            //
            // Read the user selected list of servers from the dialog.
            //

            SendDlgItemMessageW(
                DialogHandle,
                ID_ACTIVE_LIST,
                LB_GETTEXT,
                (WPARAM) i,
                (LPARAM) (LPWSTR) ServerBuf );

            NwlibCopyStringToBuffer(
                ServerBuf,
                wcslen(ServerBuf),
                (LPCWSTR) FixedPortion,
                &EndOfVariableData,
                &(Credential->TreeList)[i] );

            Result = SendDlgItemMessageW( DialogHandle,
                                          ID_ACTIVE_LIST,
                                          LB_GETITEMDATA,
                                          (WPARAM) i,
                                          0 );

            if ( Result != LB_ERR )
            {
                (Credential->UserList)[i] = (LPWSTR) Result;
            }
            else
            {
                (Credential->UserList)[i] = NULL;
            }

            FixedPortion += sizeof(LPWSTR);
        }

        FullIndex = 0;

        do
        {
            RtlZeroMemory( tempUserName, sizeof(tempUserName) );
            RtlZeroMemory( tempOldPassword, sizeof(tempOldPassword) );
            RtlZeroMemory( tempNewPassword, sizeof(tempNewPassword) );
            RtlCopyMemory( tempOldPassword,
                           Credential->OldPassword,
                           sizeof(tempOldPassword) );
            RtlCopyMemory( tempNewPassword,
                           Credential->NewPassword,
                           sizeof(tempNewPassword) );

            if ( (Credential->UserList)[FullIndex] == NULL )
            {
                // We don't have any connections to tree <current entry>
                // Prompt user to supply a user name for which account
                // we are to change password, or skip . . .

                USERNAME_DLG_PARAM UserNameParam;
                CHANGE_PASS_DLG_PARAM ChangePassParam;

                UserNameParam.UserName = tempUserName;
                UserNameParam.TreeServerName = (Credential->TreeList)[FullIndex];

                SetCursor(Cursor);
                ShowCursor(FALSE);

                Result = DialogBoxParamW(
                             hmodNW,
                             MAKEINTRESOURCEW(DLG_ENTER_ALT_USERNAME),
                             (HWND) DialogHandle,
                             (DLGPROC) NwpAltUserNameDlgProc,
                             (LPARAM) &UserNameParam );

                Cursor = LoadCursor(NULL, IDC_WAIT);

                if (Cursor != NULL)
                {
                    SetCursor(Cursor);
                    ShowCursor(TRUE);
                }

                if ( Result != IDOK )
                {
                    *((Credential->TreeList)[FullIndex]) = L'\0';
                    goto SkipEntry;
                }

                // Now go reverify the credentials for the user name
                // entered by user.

                ChangePassParam.UserName = tempUserName;
                ChangePassParam.TreeName = (Credential->TreeList)[FullIndex];
                ChangePassParam.OldPassword = tempOldPassword;
                ChangePassParam.NewPassword = tempNewPassword;

                SetCursor(Cursor);
                ShowCursor(FALSE);

                Result = DialogBoxParamW(
                                 hmodNW,
                                 MAKEINTRESOURCEW(DLG_CHANGE_PASSWORD3),
                                 (HWND) DialogHandle,
                                 (DLGPROC) NwpChangePasswordDlgProc,
                                 (LPARAM) &ChangePassParam );

                Cursor = LoadCursor(NULL, IDC_WAIT);

                if (Cursor != NULL)
                {
                    SetCursor(Cursor);
                    ShowCursor(TRUE);
                }

                if ( Result != IDOK )
                {
                    *((Credential->TreeList)[FullIndex]) = L'\0';
                    goto SkipEntry;
                }

                goto Next;
            }
            else
            {
                wcscpy( tempUserName, (Credential->UserList)[FullIndex] );
                LocalFree( (Credential->UserList)[FullIndex] );
                (Credential->UserList)[FullIndex] = NULL;
            }

            // Test tempUserName with the user name in Credential->UserName
            // to see if they are similar (i.e. The first part of the
            // NDS distinguish name matches).

            if ( _wcsnicmp( tempUserName + 3,
                            Credential->UserName,
                            wcslen( Credential->UserName ) ) )
            {
                // The names are not similar!
                // Prompt user to ask if they really want to change
                // passwords for dis-similar user on tree <current entry>
                // or skip . . .

                USERNAME_DLG_PARAM UserNameParam;
                CHANGE_PASS_DLG_PARAM ChangePassParam;
                // escape any dots in the user name and try again
                WCHAR   EscapedName[NW_MAX_USERNAME_LEN * 2];
                PWSTR   pChar = Credential->UserName;
                int     i = 0;
                BOOL    bEscaped = FALSE;

                RtlZeroMemory(EscapedName, sizeof(EscapedName));

                do
                {
                    if (*pChar == L'.')
                    {
                        EscapedName[i++] = '\\';
                        bEscaped = TRUE;
                    }
					// also handle UPN names
                    else if (*pChar == L'@') { 
                        EscapedName[i] = 0;
                        bEscaped = TRUE;
                        break;
                    }
                    EscapedName[i++] = *pChar;
                } while (*pChar++);

                if (bEscaped)
                {
                    if ( !_wcsnicmp( tempUserName + 3,
                                    EscapedName,
                                    wcslen( EscapedName ) ) )
                        goto Next;
                }

                UserNameParam.UserName = tempUserName;
                UserNameParam.TreeServerName = (Credential->TreeList)[FullIndex];

                SetCursor(Cursor);
                ShowCursor(FALSE);

                Result = DialogBoxParamW(
                                 hmodNW,
                                 MAKEINTRESOURCEW(DLG_ENTER_ALT_USERNAME),
                                 (HWND) DialogHandle,
                                 (DLGPROC) NwpAltUserNameDlgProc,
                                 (LPARAM) &UserNameParam );

                Cursor = LoadCursor(NULL, IDC_WAIT);

                if (Cursor != NULL)
                {
                    SetCursor(Cursor);
                    ShowCursor(TRUE);
                }

                if ( Result != IDOK )
                {
                    *((Credential->TreeList)[FullIndex]) = L'\0';
                    goto SkipEntry;
                }

                // Now go reverify the credentials for the user name
                // entered by user.

                ChangePassParam.UserName = tempUserName;
                ChangePassParam.TreeName = (Credential->TreeList)[FullIndex];
                ChangePassParam.OldPassword = tempOldPassword;
                ChangePassParam.NewPassword = tempNewPassword;

                SetCursor(Cursor);
                ShowCursor(FALSE);

                Result = DialogBoxParamW(
                                 hmodNW,
                                 MAKEINTRESOURCEW(DLG_CHANGE_PASSWORD3),
                                 (HWND) DialogHandle,
                                 (DLGPROC) NwpChangePasswordDlgProc,
                                 (LPARAM) &ChangePassParam );

                Cursor = LoadCursor(NULL, IDC_WAIT);

                if (Cursor != NULL)
                {
                    SetCursor(Cursor);
                    ShowCursor(TRUE);
                }

                if ( Result != IDOK )
                {
                    *((Credential->TreeList)[FullIndex]) = L'\0';
                    goto SkipEntry;
                }
            }

Next:
            status = NwrChangePassword(
                           NULL,                    // Reserved
                           UserLuid,
                           tempUserName,
                           tempOldPassword, // Encoded passwords
                           tempNewPassword,
                           (LPWSTR) (Credential->TreeList)[FullIndex] );

            if (status == ERROR_INVALID_PASSWORD)
            {
                OLD_PW_DLG_PARAM OldPasswordParam;

#if DBG
                IF_DEBUG(LOGON)
                {
                    KdPrint(("NWPROVAU: First attempt: wrong password on %ws\n",
                             (Credential->TreeList)[FullIndex]));
                }
#endif

                //
                // Display dialog to let user type in an alternate
                // old password.
                //

                //
                // Set up old password buffer to receive from dialog.
                //
                OldPasswordParam.OldPassword = tempOldPassword;

                OldPasswordParam.FailedServer = (Credential->TreeList)[FullIndex];

                SetCursor(Cursor);
                ShowCursor(FALSE);

                Result = DialogBoxParamW(
                                 hmodNW,
                                 MAKEINTRESOURCEW(DLG_ENTER_OLD_PASSWORD),
                                 (HWND) DialogHandle,
                                 (DLGPROC) NwpOldPasswordDlgProc,
                                 (LPARAM) &OldPasswordParam );

                Cursor = LoadCursor(NULL, IDC_WAIT);

                if (Cursor != NULL)
                {
                    SetCursor(Cursor);
                    ShowCursor(TRUE);
                }

                if (Result == IDOK)
                {
                    //
                    // Retry change password with alternate old password on
                    // the failed server.
                    //
                    status = NwrChangePassword(
                                    NULL,            // Reserved
                                    UserLuid,
                                    tempUserName,
                                    tempOldPassword, // Alternate old password
                                    tempNewPassword,
                                    (LPWSTR) (Credential->TreeList)[FullIndex] );
                }
            }

            if (status != NO_ERROR)
            {
                //
                // Either unrecoverable failure or user failed to change
                // password on second attempt.
                //
#if DBG
                IF_DEBUG(LOGON)
                {
                    KdPrint(("NWPROVAU: Failed to change password on %ws %lu\n",
                             (Credential->TreeList)[FullIndex], status));
                }
#endif

                // Pop up error dialog to let user know that password
                // could not be changed.

                (void) NwpMessageBoxError(
                               DialogHandle,
                               IDS_CHANGE_PASSWORD_TITLE,
                               IDS_CP_FAILURE_WARNING,
                               status,
                               (LPWSTR) (Credential->TreeList)[FullIndex], 
                               MB_OK | MB_ICONSTOP );

                *((Credential->TreeList)[FullIndex]) = L'\0';

                if (status == ERROR_NOT_ENOUGH_MEMORY)
                    return status;
            }

SkipEntry:
            //
            // Continue to change password on the rest of the entries
            //
            FullIndex++;
            Entries = Credential->Entries - FullIndex;

        } while (Entries);

        //
        // Caller is responsible for freeing TreeList
        //
    }

    SetCursor(Cursor);
    ShowCursor(FALSE);

    return NO_ERROR;
}


BOOL
WINAPI
NwpChangePasswordSuccessDlgProc(
    HWND DialogHandle,
    UINT Message,
    WPARAM WParam,
    LPARAM LParam
    )
/*++

Routine Description:

Arguments:

    DialogHandle - Supplies a handle to the login dialog.

    Message - Supplies the window management message.

Return Value:

    TRUE - the message was processed.

    FALSE - the message was not processed.

--*/
{
    static PCHANGE_PW_DLG_PARAM Credential;
    DWORD_PTR  Count;
    DWORD  i;

    switch (Message)
    {
        case WM_INITDIALOG:

            //
            // Get the user credential passed in.
            //
            Credential = (PCHANGE_PW_DLG_PARAM) LParam;

            //
            // Position dialog
            //
            NwpCenterDialog(DialogHandle);

            //
            // Put list of NetWare trees that we changed password on in the
            // list box.
            //                                       ID_SERVER );
            for ( i = 0; i < Credential->Entries; i++ )
            {
                if ( *((Credential->TreeList)[i]) != L'\0' )
                {
                    SendDlgItemMessageW( DialogHandle,
                                         ID_SERVER,
                                         LB_ADDSTRING,
                                         0,
                                         (LPARAM) (Credential->TreeList)[i] );
                }
            }

            Count = SendDlgItemMessageW( DialogHandle,
                                         ID_SERVER,
                                         LB_GETCOUNT,
                                         0,
                                         0 );

            if ( Count == 0 )
                EndDialog(DialogHandle, 0);

            return TRUE;


        case WM_COMMAND:

            switch (LOWORD(WParam))
            {
                case IDOK:
                case IDCANCEL:
                    EndDialog(DialogHandle, 0);
                    return TRUE;
            }
    }

    //
    // We didn't process this message
    //
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\client\nwshext.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwshext.h

Abstract:

    All C++ classes used in implementing shell extensions.

Author:

    Yi-Hsin Sung      (yihsins)     20-Oct-1995

Revision History:

--*/

#ifndef _NWSHEXT_H_
#define _NWSHEXT_H_

BOOL
GetNetResourceFromShell(
    LPDATAOBJECT  pDataObj,
    LPNETRESOURCE pBuffer,
    UINT          dwBufferSize
);

/******************************************************************************/

// this class factory object creates context menu handlers for netware objects
class CNWObjContextMenuClassFactory : public IClassFactory
{
protected:
    ULONG   _cRef;

public:
    CNWObjContextMenuClassFactory();
    ~CNWObjContextMenuClassFactory();

    // IUnknown members

    STDMETHODIMP          QueryInterface( REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)  AddRef();
    STDMETHODIMP_(ULONG)  Release();

    // IClassFactory members

    STDMETHODIMP          CreateInstance( LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP          LockServer( BOOL);

};

typedef CNWObjContextMenuClassFactory *LPCNWOBJCONTEXTMENUCLASSFACTORY;

typedef struct _NWMENUITEM
{
    UINT idResourceString;
    UINT idCommand;
} NWMENUITEM, *LPNWMENUITEM;

// this is the actual context menu handler for netware objects
class CNWObjContextMenu : public IContextMenu,
                                 IShellExtInit,
                                 IShellPropSheetExt
{
protected:
    ULONG        _cRef;
    LPDATAOBJECT _pDataObj;
    NWMENUITEM  *_pIdTable;
    BYTE         _buffer[MAX_ONE_NETRES_SIZE];

public:
    BOOL         _fGotClusterInfo;
    DWORD        _dwTotal;
    DWORD        _dwFree;

    DWORD       *_paHelpIds;

    CNWObjContextMenu();
    ~CNWObjContextMenu();

    // IUnknown members

    STDMETHODIMP            QueryInterface( REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IShellContextMenu members

    STDMETHODIMP            QueryContextMenu( HMENU hMenu,
                                              UINT indexMenu,
                                              UINT idCmdFirst,
                                              UINT idCmdLast,
                                              UINT uFlags);

    STDMETHODIMP            InvokeCommand( LPCMINVOKECOMMANDINFO lpcmi);

    STDMETHODIMP            GetCommandString( UINT_PTR idCmd,
                                              UINT uFlags,
                                              UINT FAR *reserved,
                                              LPSTR pszName,
                                              UINT cchMax);

    // IShellExtInit methods

    STDMETHODIMP            Initialize( LPCITEMIDLIST pIDFolder,
                                        LPDATAOBJECT pDataObj,
                                        HKEY hKeyID);

    // IShellPropSheetExt methods

    STDMETHODIMP            AddPages( LPFNADDPROPSHEETPAGE lpfnAddPage,
                                      LPARAM lParam);

    STDMETHODIMP            ReplacePage( UINT uPageID,
                                         LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                                         LPARAM lParam);

    VOID                    FillAndAddPage( LPFNADDPROPSHEETPAGE lpfnAddPage,
                                            LPARAM  lParam,
                                            DLGPROC pfnDlgProc,
                                            LPWSTR  pszTemplate );

    // Other misc methods

    LPNETRESOURCE QueryNetResource()
    {  return ( LPNETRESOURCE ) _buffer; }

};
typedef CNWObjContextMenu *LPCNWOBJCONTEXTMENU;

/******************************************************************************/

// this class factory object creates context menu handlers for netware folders
class CNWFldContextMenuClassFactory : public IClassFactory
{
protected:
    ULONG   _cRef;

public:
    CNWFldContextMenuClassFactory();
    ~CNWFldContextMenuClassFactory();

    // IUnknown members

    STDMETHODIMP          QueryInterface( REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)  AddRef();
    STDMETHODIMP_(ULONG)  Release();

    // IClassFactory members

    STDMETHODIMP          CreateInstance( LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP          LockServer( BOOL);

};

typedef CNWFldContextMenuClassFactory *LPCNWFLDCONTEXTMENUCLASSFACTORY;

// this is the actual context menu handler for netware objects
class CNWFldContextMenu : public IContextMenu,
                                 IShellExtInit
{
protected:
    ULONG        _cRef;
    LPDATAOBJECT _pDataObj;
    BYTE         _buffer[MAX_ONE_NETRES_SIZE];

public:
    CNWFldContextMenu();
    ~CNWFldContextMenu();

    // IUnknown members

    STDMETHODIMP            QueryInterface( REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IShellContextMenu members

    STDMETHODIMP            QueryContextMenu( HMENU hMenu,
                                              UINT indexMenu,
                                              UINT idCmdFirst,
                                              UINT idCmdLast,
                                              UINT uFlags);

    STDMETHODIMP            InvokeCommand( LPCMINVOKECOMMANDINFO lpcmi);

    STDMETHODIMP            GetCommandString( UINT_PTR idCmd,
                                              UINT uFlags,
                                              UINT FAR *reserved,
                                              LPSTR pszName,
                                              UINT cchMax);

    // IShellExtInit methods

    STDMETHODIMP            Initialize( LPCITEMIDLIST pIDFolder,
                                        LPDATAOBJECT pDataObj,
                                        HKEY hKeyID);

    BOOL                    IsNetWareObject( VOID );
    HRESULT                 GetFSObject( LPWSTR pszPath, UINT cbMaxPath );

};
typedef CNWFldContextMenu *LPCNWFLDCONTEXTMENU;

// this class factory object creates context menu handlers
// for Network Neighborhood

class CNWHoodContextMenuClassFactory : public IClassFactory
{
protected:
    ULONG   _cRef;

public:
    CNWHoodContextMenuClassFactory();
    ~CNWHoodContextMenuClassFactory();

    // IUnknown members

    STDMETHODIMP          QueryInterface( REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)  AddRef();
    STDMETHODIMP_(ULONG)  Release();

    // IClassFactory members

    STDMETHODIMP          CreateInstance( LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP          LockServer( BOOL);

};

typedef CNWHoodContextMenuClassFactory *LPCNWHOODCONTEXTMENUCLASSFACTORY;

// this is the actual context menu handler for network neighborhood
class CNWHoodContextMenu : public IContextMenu,
                                  IShellExtInit
{
protected:
    ULONG        _cRef;
    LPDATAOBJECT _pDataObj;

public:
    CNWHoodContextMenu();
    ~CNWHoodContextMenu();

    // IUnknown members

    STDMETHODIMP            QueryInterface( REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IShellContextMenu members

    STDMETHODIMP            QueryContextMenu( HMENU hMenu,
                                              UINT indexMenu,
                                              UINT idCmdFirst,
                                              UINT idCmdLast,
                                              UINT uFlags);

    STDMETHODIMP            InvokeCommand( LPCMINVOKECOMMANDINFO lpcmi);

    STDMETHODIMP            GetCommandString( UINT_PTR idCmd,
                                              UINT uFlags,
                                              UINT FAR *reserved,
                                              LPSTR pszName,
                                              UINT cchMax);

    // IShellExtInit methods

    STDMETHODIMP            Initialize( LPCITEMIDLIST pIDFolder,
                                        LPDATAOBJECT pDataObj,
                                        HKEY hKeyID);

};
typedef CNWHoodContextMenu *LPCNWHOODCONTEXTMENU;


#endif // _NWSHEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\client\nwshcmn.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwshcmn.h

Abstract:

    Common header file for shell extensions

Author:

    Yi-Hsin Sung      (yihsins)     20-Oct-1995

Revision History:

--*/

#ifndef _NWSHCMN_H_
#define _NWSHCMN_H_

#if 0
#define ODS(sz) OutputDebugString(sz)
#else
#define ODS(sz) 
#endif

#define TREECHAR   L'*'

#define MAX_ONE_NETRES_SIZE  1024

extern "C" 
{
extern HINSTANCE hmodNW;
}
extern LONG g_cRefThisDll;         // Reference count of this DLL.

typedef UINT
(WINAPI *SHELLGETNETRESOURCE)( HNRES hnres, 
                               UINT iItem, 
                               LPNETRESOURCE pnres, 
                               UINT cbMax );

typedef UINT
(WINAPI *SHELLDRAGQUERYFILE)( HDROP  hdrop,
                              UINT   iItem,
                              LPWSTR pszItem,
                              UINT   cbMax);

typedef VOID 
(WINAPI *SHELLCHANGENOTIFY)( LONG wEventId,
                             UINT uFlags,
                             LPCVOID dwItem1, 
                             LPCVOID dwItem2 );

typedef BOOL
(WINAPI *SHELLEXECUTEEX)( LPSHELLEXECUTEINFOW lpExecInfo );
    

extern SHELLGETNETRESOURCE g_pFuncSHGetNetResource;
extern SHELLDRAGQUERYFILE  g_pFuncSHDragQueryFile;
extern SHELLCHANGENOTIFY   g_pFuncSHChangeNotify;
extern SHELLEXECUTEEX      g_pFuncSHExecuteEx;
extern WCHAR               g_szProviderName[];

VOID  HideControl( HWND hwndDlg, WORD wID );
VOID  UnHideControl( HWND hwndDlg, WORD wID );
VOID  EnableDlgItem( HWND hwndDlg, WORD wID, BOOL fEnable);

DWORD MsgBoxPrintf( HWND hwnd, UINT uiMsg, UINT uiTitle, UINT uiFlags,...);
DWORD MsgBoxErrorPrintf( HWND hwnd, UINT uiMsg, UINT uiTitle, UINT uiFlags, DWORD errNum, LPWSTR pszInsertStr );
DWORD LoadMsgPrintf( LPWSTR *ppszMessage, UINT uiMsg, ...);
DWORD LoadMsgErrorPrintf( LPWSTR *ppszMessage, UINT uiMsg, DWORD errNum );

#if 0
HRESULT
NWUISetDefaultContext( 
    HWND hParent, 
    LPNETRESOURCE pNetRes
);
#endif

HRESULT
NWUIWhoAmI( 
    HWND hParent, 
    LPNETRESOURCE pNetRes
);

HRESULT
NWUILogOut( 
    HWND hParent, 
    LPNETRESOURCE pNetRes,
    PBOOL pfDisconnected
);

HRESULT
NWUIAttachAs( 
    HWND hParent, 
    LPNETRESOURCE pNetRes
);

HRESULT
NWUIMapNetworkDrive( 
    HWND hParent, 
    LPNETRESOURCE pNetRes
);

HRESULT
NWUIGlobalWhoAmI( 
    HWND hParent 
);

#endif // _NWSHCMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\client\nwshmisc.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwshmisc.cxx

Abstract:

    This module implements misc methods used in the shell extension classes.

Author:

    Yi-Hsin Sung (yihsins)  25-Oct-1995

--*/

#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>
#define  DONT_WANT_SHELLDEBUG
#include <shlobjp.h>

#include "nwshcmn.h"

#define MAX_RESOURCE_STRING_LENGTH  256

VOID HideControl( HWND hwndDlg, WORD wID )
{
    HWND hwndTmp = ::GetDlgItem( hwndDlg, wID );
    ::EnableWindow( hwndTmp, FALSE );
    ::ShowWindow( hwndTmp, FALSE );
}

VOID UnHideControl( HWND hwndDlg, WORD wID )
{
    HWND hwndTmp = ::GetDlgItem( hwndDlg, wID );
    ::EnableWindow( hwndTmp, TRUE );
    ::ShowWindow( hwndTmp, TRUE );
}

VOID EnableDlgItem( HWND hwndDlg, WORD wID, BOOL fEnable)
{
    HWND hwndTmp = ::GetDlgItem( hwndDlg, wID );

    ::EnableWindow( hwndTmp, fEnable);
}

/*
 * LoadErrorPrintf
 * -------------
 *
 * Uses normal printf style format string
 */
DWORD
LoadMsgErrorPrintf(
    LPWSTR *ppszMessage,
    UINT   uiMsg,
    DWORD  errNum
)
{
    DWORD  nLen = 0;
    DWORD  err = NO_ERROR;
    LPWSTR pszError = NULL;
    WCHAR  szError[20];

    *ppszMessage = NULL;

    //
    // Try to get the error string associated with the given number
    // from the system. If we cannot find the string, then
    // just show the number.
    //

    nLen = ::FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM
                            | FORMAT_MESSAGE_IGNORE_INSERTS
                            | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            NULL,        // ignored
                            errNum,      // Message resource id
                            0,           // Language id
                            (LPWSTR) &pszError,
                                         // Return pointer to formatted text
                            256,         // Min.length
                            NULL );

    if ( nLen == 0 || pszError == NULL )
    {
        wsprintf( szError, L"%d", errNum );
    }

    err = LoadMsgPrintf( ppszMessage, uiMsg, pszError? pszError : szError );

    if ( pszError )
        ::LocalFree( pszError );

    return err;
}

/*
 * LoadMsgPrintf
 * -------------
 *
 * Uses normal printf style format string
 */
DWORD
LoadMsgPrintf(
    LPWSTR *ppszMessage,
    UINT    uiMsg,
    ...
    )
{
    WCHAR    szMessage[512];
    DWORD    err = NO_ERROR;
    DWORD    nLen = 0;
    va_list  start;

    va_start( start, uiMsg );

    *ppszMessage = NULL;

    if ( ::LoadString( ::hmodNW, uiMsg, szMessage,
                       sizeof(szMessage)/sizeof(szMessage[0])))
    {
        nLen = ::FormatMessage( FORMAT_MESSAGE_FROM_STRING
                                | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                szMessage,
                                0,           // Message resource id, ignored
                                0,           // Language id
                                (LPWSTR) ppszMessage,
                                             // Return pointer to formatted text
                                256,         // Min.length
                                &start );

        if ( nLen == 0 || *ppszMessage == NULL )
            err = GetLastError();

    }

    va_end(start);

    return err;
}

/*
 * MsgBoxErrorPrintf
 * ------------
 *
 * Message box routine
 *
 */
DWORD
MsgBoxErrorPrintf(
    HWND   hwnd,
    UINT   uiMsg,
    UINT   uiTitle,
    UINT   uiFlags,
    DWORD  errNum,
    LPWSTR pszInsertStr
    )
{
    DWORD  nLen = 0;
    DWORD  err = NO_ERROR;
    LPWSTR pszError = NULL;
    WCHAR  szError[20];

    nLen = ::FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM
                            | FORMAT_MESSAGE_IGNORE_INSERTS
                            | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            NULL,        // ignored
                            errNum,      // Message resource id
                            0,           // Language id
                            (LPWSTR) &pszError,
                                         // Return pointer to formatted text
                            256,         // Min.length
                            NULL );

    if ( nLen == 0 || pszError == NULL )
        wsprintf( szError, L"%d", errNum );

    if ( pszInsertStr )
    {
        err = MsgBoxPrintf( hwnd, uiMsg, uiTitle, uiFlags,
                            pszError? pszError : szError, pszInsertStr );
    }
    else
    {
        err = MsgBoxPrintf( hwnd, uiMsg, uiTitle, uiFlags,
                            pszError? pszError : szError );
    }

    if ( pszError )
        ::LocalFree( pszError );

    return err;

}


/*
 * MsgBoxPrintf
 * ------------
 *
 * Message box routine
 *
 */
DWORD
MsgBoxPrintf(
    HWND hwnd,
    UINT uiMsg,
    UINT uiTitle,
    UINT uiFlags,
    ...
    )
{
    WCHAR  szTitle[MAX_RESOURCE_STRING_LENGTH];
    WCHAR  szMessage[MAX_RESOURCE_STRING_LENGTH];
    LPWSTR lpFormattedMessage = NULL;
    DWORD  err = NO_ERROR;
    va_list start;

    va_start(start,uiFlags);

    if (  ::LoadString( ::hmodNW, uiMsg, szMessage, sizeof(szMessage)/sizeof(szMessage[0]))
       && ::LoadString( ::hmodNW, uiTitle, szTitle, sizeof(szTitle)/sizeof(szTitle[0]))
       )
    {
        DWORD nLen = ::FormatMessage( FORMAT_MESSAGE_FROM_STRING
                                      | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                      szMessage,
                                      0,       // Resource Id, ignored
                                      NULL,    // Language Id, ignored
                                      (LPWSTR) &lpFormattedMessage,
                                               // Return pointer to formatted text
                                      256,     // Min.length
                                      &start );

        if ( nLen == 0 || lpFormattedMessage == NULL )
        {
            err  = GetLastError();
            goto CleanExit;
        }

        err = ::MessageBox( hwnd,
                            lpFormattedMessage,
                            szTitle,
                            uiFlags );

        ::LocalFree( lpFormattedMessage );
    }

CleanExit:

    va_end(start);

    return err;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\client\nwshmenu.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwshmenu.cxx

Abstract:

    This module implements the IContextMenu member functions necessary to support
    the context menu of NetWare shell extension.

Author:

    Yi-Hsin Sung (yihsins)  25-Oct-1995

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>
#define  DONT_WANT_SHELLDEBUG
#include <shlobjp.h>
#include <winnetwk.h>
#include <ntddnwfs.h>
//extern "C"
//{
#include "nwshrc.h"
#include "nwwks.h"
#include "nwutil.h"
//}

#include "nwshcmn.h"
#include "nwshext.h"

#define MAX_VERB_SIZE          128
#define MAX_SHELL_IDLIST_SIZE  512

BOOL g_cfNetResource = 0;  // Clipboard format
BOOL g_cfIDList = 0;

NWMENUITEM aServerVerbs[]    = { { IDO_VERB_WHOAMI, 0 },
                                 { IDO_VERB_LOGOUT, 0 },
                                 { IDO_VERB_ATTACHAS, 0 },
                                 { 0, 0 } };

NWMENUITEM aDSVerbs[]        = { { IDO_VERB_TREEWHOAMI, 0 },
                                 // { IDO_VERB_SETDEFAULTCONTEXT, 0 },
                                 { 0, 0 } };

NWMENUITEM aDSTreeVerbs[]    = { { IDO_VERB_TREEWHOAMI, 0 },
                                 { 0, 0 } };

NWMENUITEM aGlobalVerbs[]    = { { IDO_VERB_GLOBALWHOAMI, 0 },
                                 { 0, 0 } };

NWMENUITEM aDirectoryVerbs[] = { { IDO_VERB_MAPNETWORKDRIVE, 0 },
                                 { 0, 0 } };


NWMENUITEM aHoodVerbs[]      = { { IDO_VERB_GLOBALWHOAMI, 0 },
                                 { 0, 0 } };


HRESULT
InsertCommandsArray( HMENU hMenu,
                     UINT indexMenu,
                     UINT idCmdFirst,
                     LPNWMENUITEM aVerbs );

UINT
LookupCommand( LPNWMENUITEM aVerbs,
               LPCSTR pszCmd );

UINT
LookupResource( LPNWMENUITEM aVerbs,
                UINT uiResourceOffset );

UINT WINAPI
HIDA_GetIDList( LPIDA hida,
                UINT i,
                LPITEMIDLIST pidlOut,
                UINT cbMax);

//
//  FUNCTION: CNWObjContextMenu::QueryContextMenu(HMENU, UINT, UINT, UINT, UINT)
//
//  PURPOSE: Called by the shell just before the context menu is displayed.
//           This is where you add your specific menu items.
//
//  PARAMETERS:
//    hMenu      - Handle to the context menu
//    indexMenu  - Index of where to begin inserting menu items
//    idCmdFirst - Lowest value for new menu ID's
//    idCmtLast  - Highest value for new menu ID's
//    uFlags     - Specifies the context of the menu event
//
//  RETURN VALUE:
//
//
//  COMMENTS:
//

STDMETHODIMP CNWObjContextMenu::QueryContextMenu( HMENU hMenu,
                                                  UINT indexMenu,
                                                  UINT idCmdFirst,
                                                  UINT idCmdLast,
                                                  UINT uFlags )
{
    HRESULT hres;
    LPNETRESOURCE pNetRes = (LPNETRESOURCE) _buffer;

    if ( !::GetNetResourceFromShell( _pDataObj,
                                     pNetRes,
                                     sizeof( _buffer )))
    {
        // We cannot get the net resource of the selected object.

        // Must return number of menu items we added.
        // Nothing added here.
        return ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, 0 ));
    }

    // First, add a menu separator
    if ( InsertMenu( hMenu, indexMenu, MF_SEPARATOR | MF_BYPOSITION, 0, NULL))
        indexMenu++;

    // Next, add menu items depending on display types
    switch ( pNetRes->dwDisplayType )
    {
        case RESOURCEDISPLAYTYPE_ROOT:
        case RESOURCEDISPLAYTYPE_NETWORK:
            hres = InsertCommandsArray( hMenu, indexMenu,
                                        idCmdFirst, _pIdTable = aGlobalVerbs );

            break;

        case RESOURCEDISPLAYTYPE_TREE:
            hres = InsertCommandsArray( hMenu, indexMenu,
                                        idCmdFirst, _pIdTable = aDSTreeVerbs );
            break;

        case RESOURCEDISPLAYTYPE_NDSCONTAINER:
            hres = InsertCommandsArray( hMenu, indexMenu,
                                        idCmdFirst, _pIdTable = aDSVerbs );
            break;

        case RESOURCEDISPLAYTYPE_SERVER:
        {
            // Do we need to check if the server name is local
            // and disallow operation???

            hres = InsertCommandsArray( hMenu, indexMenu,
                                        idCmdFirst, _pIdTable = aServerVerbs );

            if (!SUCCEEDED(hres))
                break;

            LPBYTE pBuffer = NULL;
            DWORD  EntriesRead = 0;
            DWORD_PTR  ResumeKey = 0;
            WCHAR  szServerName[MAX_PATH + 1];

            NwExtractServerName( pNetRes->lpRemoteName, szServerName );

            // See if we are connected.
            DWORD err = NwGetConnectionStatus( szServerName,
                                               &ResumeKey,
                                               &pBuffer,
                                               &EntriesRead );

            if ( err == NO_ERROR && EntriesRead > 0 )
            {
                PCONN_STATUS pConnStatus = (PCONN_STATUS) pBuffer;

                ASSERT( EntriesRead == 1 );

                if ( pConnStatus->fPreferred )
                {
                    // This is a implicit preferred server connection
                    // so, don't show the connection and don't let the user
                    // logout of it since rdr doesn't allow it.
                    ::EnableMenuItem( hMenu,
                                      LookupResource( aServerVerbs,
                                                      IDO_VERB_LOGOUT),
                                      MF_GRAYED | MF_BYCOMMAND);

                }
                else if ( pConnStatus->fNds )
                {
                    BOOL fInDefaultTree = FALSE;

                    err = NwIsServerInDefaultTree( pNetRes->lpRemoteName, &fInDefaultTree );

                    if ( (err == NO_ERROR) && fInDefaultTree )
                    {
                        // NDS connection and in the default tree, disable the Attach As button
                        ::EnableMenuItem( hMenu,
                                          LookupResource( aServerVerbs,
                                                          IDO_VERB_ATTACHAS),
                                          MF_GRAYED | MF_BYCOMMAND );
                    }
                }
            }
            else
            {
                // If we are not attached or if error occurred when getting
                // connection status, then disable the Logout button.
                ::EnableMenuItem( hMenu,
                                  LookupResource( aServerVerbs,
                                                  IDO_VERB_LOGOUT),
                                  MF_GRAYED | MF_BYCOMMAND);
            }

            if ( pBuffer != NULL )
            {
                LocalFree( pBuffer );
                pBuffer = NULL;
            }
            break;
        }

        default:
            // Must return number of menu items we added.
            // Nothing added here.
            hres = ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, 0 ));
            break;

    }

    return hres;
}

//
//  FUNCTION: CNWObjContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO)
//
//  PURPOSE: Called by the shell after the user has selected on of the
//           menu items that was added in QueryContextMenu().
//
//  PARAMETERS:
//    lpcmi - Pointer to an CMINVOKECOMMANDINFO structure
//
//  RETURN VALUE:
//
//
//  COMMENTS:
//

STDMETHODIMP CNWObjContextMenu::InvokeCommand( LPCMINVOKECOMMANDINFO lpcmi )
{
    HRESULT hres = ResultFromScode(E_INVALIDARG);
    UINT idCmd = LookupCommand( _pIdTable , lpcmi->lpVerb );

    if ( !idCmd )
        return hres;

    LPNETRESOURCE pNetRes = (LPNETRESOURCE) _buffer;

    switch ( idCmd )
    {
        case IDO_VERB_GLOBALWHOAMI:
            hres = NWUIGlobalWhoAmI( lpcmi->hwnd );
            break;

        case IDO_VERB_TREEWHOAMI:
            hres = NWUIWhoAmI( lpcmi->hwnd, pNetRes );
            break;

#if 0
        case IDO_VERB_SETDEFAULTCONTEXT:
            hres = NWUISetDefaultContext( lpcmi->hwnd, pNetRes );
            break;
#endif

        case IDO_VERB_WHOAMI:
            hres = NWUIWhoAmI( lpcmi->hwnd, pNetRes );
            break;

        case IDO_VERB_LOGOUT:
        {
            BOOL fDisconnected = FALSE;
            hres = NWUILogOut( lpcmi->hwnd, pNetRes, &fDisconnected );
            if ( hres == NOERROR && fDisconnected )
            {
                // Logout is successful, need to notify shell

                FORMATETC fmte = { g_cfIDList ? g_cfIDList
                                   : (g_cfIDList=RegisterClipboardFormat( CFSTR_SHELLIDLIST)),
                                   (DVTARGETDEVICE FAR *)NULL,
                                   DVASPECT_CONTENT,
                                   -1,
                                   TYMED_HGLOBAL };
                STGMEDIUM medium;

                hres = _pDataObj->GetData( &fmte, &medium);

                if (SUCCEEDED(hres))
                {
                    // We got pointer to IDList
                    LPIDA pida = (LPIDA)GlobalLock(medium.hGlobal);

                    if ( pida )
                    {
                        BYTE  BufIDList[MAX_SHELL_IDLIST_SIZE];
                        LPITEMIDLIST pidl = (LPITEMIDLIST) BufIDList;

                        if ( pidl )
                        {
                            // Convert IDA to IDList for this call
                            HIDA_GetIDList( pida,
                                            0,              // One object should present
                                            pidl ,
                                            MAX_SHELL_IDLIST_SIZE);

                            // Call SHchangeNotify
                            g_pFuncSHChangeNotify( SHCNE_SERVERDISCONNECT,
                                                   SHCNF_IDLIST,
                                                   pidl,
                                                   NULL);
                        }

                        GlobalUnlock(medium.hGlobal);
                    }
                }

            }
            break;
        }

        case IDO_VERB_ATTACHAS:
            hres = NWUIAttachAs( lpcmi->hwnd, pNetRes );
            break;
    }

    return hres;
}


//
//  FUNCTION: CNWObjContextMenu::GetCommandString( UINT, UINT, UINT FAR *, LPSTR, UINT )
//
//  PURPOSE: Called by the shell after the user has selected on of the
//           menu items that was added in QueryContextMenu().
//
//  PARAMETERS:
//
//  RETURN VALUE:
//
//
//  COMMENTS:
//

STDMETHODIMP CNWObjContextMenu::GetCommandString( UINT_PTR idCmd,
                                                  UINT uFlags,
                                                  UINT FAR *reserved,
                                                  LPSTR pszName,
                                                  UINT cchMax )
{
    if ( uFlags == GCS_HELPTEXT && _pIdTable != NULL )
    {
        ::LoadString( ::hmodNW,
                      IDS_VERBS_HELP_BASE + _pIdTable[idCmd].idResourceString,
                      (LPWSTR) pszName,
                      cchMax );

        return NOERROR;
    }

    return E_NOTIMPL;
}

//
//  FUNCTION: CNWFldContextMenu::QueryContextMenu(HMENU, UINT, UINT, UINT, UINT)
//
//  PURPOSE: Called by the shell just before the context menu is displayed.
//           This is where you add your specific menu items.
//
//  PARAMETERS:
//    hMenu      - Handle to the context menu
//    indexMenu  - Index of where to begin inserting menu items
//    idCmdFirst - Lowest value for new menu ID's
//    idCmtLast  - Highest value for new menu ID's
//    uFlags     - Specifies the context of the menu event
//
//  RETURN VALUE:
//
//
//  COMMENTS:
//

STDMETHODIMP CNWFldContextMenu::QueryContextMenu( HMENU hMenu,
                                                  UINT indexMenu,
                                                  UINT idCmdFirst,
                                                  UINT idCmdLast,
                                                  UINT uFlags )
{
    UINT idCmd = idCmdFirst;

    if ( IsNetWareObject() )
    {
        WCHAR szFullPath[MAX_PATH+1];

        if ( GetFSObject( szFullPath, sizeof( szFullPath )) == NOERROR )
        {
            BOOL fUNC = FALSE;

            // Check if the name at least contains the "\\server\share\dir"
            // We need to add "Map Network Drive" menu in this case.
            if (( szFullPath[0] == L'\\') && ( szFullPath[1] == L'\\'))
            {
                LPWSTR pszLastSlash = wcschr( szFullPath + 2, L'\\');
                if ( pszLastSlash )
                    pszLastSlash = wcschr( pszLastSlash+1, L'\\');

                if ( pszLastSlash != NULL )
                    fUNC = TRUE;
            }

            if ( fUNC )
            {
                LPNETRESOURCE pNetRes = (LPNETRESOURCE) _buffer;
                WCHAR szProvider[MAX_PATH+1];

                // Build a net resource that can be used to connect

                // store the provider name first
                wcscpy( szProvider, pNetRes->lpProvider );

                // zero out the memory cause it is filled by IsNetWareObject
                RtlZeroMemory( pNetRes, sizeof(NETRESOURCE));

                pNetRes->dwType = RESOURCETYPE_DISK;
                pNetRes->lpRemoteName = (LPWSTR) ((DWORD_PTR)pNetRes + sizeof(NETRESOURCE));
                wcscpy( pNetRes->lpRemoteName, szFullPath );

                pNetRes->lpProvider = (LPWSTR) ((DWORD_PTR)pNetRes->lpRemoteName + (wcslen(szFullPath)+1)*sizeof(WCHAR));
                wcscpy( pNetRes->lpProvider, szProvider );

                if ( InsertMenu(hMenu, indexMenu, MF_SEPARATOR | MF_BYPOSITION, 0, NULL))
                {
                    indexMenu++;
                }

                return InsertCommandsArray( hMenu, indexMenu,
                                            idCmdFirst, aDirectoryVerbs );
            }
        }
    }

    // Must return number of menu items we added.
    // Nothing added here.
    return ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, 0 ));

}

//
//  FUNCTION: CNWFldContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO)
//
//  PURPOSE: Called by the shell after the user has selected on of the
//           menu items that was added in QueryContextMenu().
//
//  PARAMETERS:
//    lpcmi - Pointer to an CMINVOKECOMMANDINFO structure
//
//  RETURN VALUE:
//
//
//  COMMENTS:
//

STDMETHODIMP CNWFldContextMenu::InvokeCommand( LPCMINVOKECOMMANDINFO lpcmi )
{
    HRESULT hres = ResultFromScode(E_INVALIDARG);
    UINT idCmd = LookupCommand( aDirectoryVerbs , lpcmi->lpVerb );

    if ( !idCmd )
        return hres;

    LPNETRESOURCE pNetRes = (LPNETRESOURCE) _buffer;

    switch ( idCmd )
    {
        case IDO_VERB_MAPNETWORKDRIVE:
            hres = NWUIMapNetworkDrive( lpcmi->hwnd, pNetRes );
            break;
    }

    return hres;
}


//
//  FUNCTION: CNWFldContextMenu::GetCommandString( UINT, UINT, UINT FAR *, LPSTR, UINT )
//
//  PURPOSE: Called by the shell after the user has selected on of the
//           menu items that was added in QueryContextMenu().
//
//  PARAMETERS:
//
//  RETURN VALUE:
//
//
//  COMMENTS:
//

STDMETHODIMP CNWFldContextMenu::GetCommandString( UINT_PTR idCmd,
                                                  UINT uFlags,
                                                  UINT FAR *reserved,
                                                  LPSTR pszName,
                                                  UINT cchMax )
{
    if ( uFlags == GCS_HELPTEXT )
    {
        ::LoadString( ::hmodNW,
                      IDS_VERBS_HELP_BASE + IDO_VERB_MAPNETWORKDRIVE,
                      (LPWSTR) pszName,
                      cchMax );

        return NOERROR;
    }

    return E_NOTIMPL;
}

//
// Method checks if the selected object belongs the netware provider
//
BOOL CNWFldContextMenu::IsNetWareObject( VOID )
{
    LPNETRESOURCE pNetRes = (LPNETRESOURCE) _buffer;

    if ( !::GetNetResourceFromShell( _pDataObj,
                                     pNetRes,
                                     sizeof(_buffer)))
    {
        // Cannot get the NETRESOURCE of the selected object,
        // hence assume that the object is not a NetWare object.
        return FALSE;
    }

    if (  ( pNetRes->lpProvider != NULL )
       && ( _wcsicmp( pNetRes->lpProvider, g_szProviderName ) == 0 )
       )
    {
        return TRUE;
    }

    return FALSE;
}

//
// Method obtains file system name associated with selected shell object
//
HRESULT CNWFldContextMenu::GetFSObject( LPWSTR pszPath, UINT cbMaxPath )
{
    FORMATETC fmte = { CF_HDROP,
                       (DVTARGETDEVICE FAR *) NULL,
                       DVASPECT_CONTENT,
                       -1,
                       TYMED_HGLOBAL };

    STGMEDIUM medium;
    HRESULT hres = _pDataObj->GetData( &fmte, &medium);

    if (SUCCEEDED(hres))
    {
        if ( g_pFuncSHDragQueryFile )
        {
            HDROP hdrop = (HDROP) medium.hGlobal;
            UINT cFiles = (*g_pFuncSHDragQueryFile)( hdrop, (UINT)-1, NULL, 0 );

            (*g_pFuncSHDragQueryFile)( hdrop, 0, pszPath, cbMaxPath );

            ODS(L"CNWFldContextMenu::GetFSObject()\n");
            ODS( pszPath );
            ODS(L"\n");
        }

        //
        // HACK: We are supposed to call ReleaseStgMedium. This is a temporary
        //  hack until OLE 2.01 for Chicago is released.
        //
        if (medium.pUnkForRelease)
        {
            medium.pUnkForRelease->Release();
        }
        else
        {
            GlobalFree(medium.hGlobal);
        }
    }

    return hres;
}


//  FUNCTION: CNWHoodContextMenu::QueryContextMenu(HMENU, UINT, UINT, UINT, UINT)
//
//  PURPOSE: Called by the shell just before the context menu is displayed.
//           This is where you add your specific menu items.
//
//  PARAMETERS:
//    hMenu      - Handle to the context menu
//    indexMenu  - Index of where to begin inserting menu items
//    idCmdFirst - Lowest value for new menu ID's
//    idCmtLast  - Highest value for new menu ID's
//    uFlags     - Specifies the context of the menu event
//
//  RETURN VALUE:
//
//
//  COMMENTS:
//

STDMETHODIMP CNWHoodContextMenu::QueryContextMenu( HMENU hMenu,
                                                   UINT indexMenu,
                                                   UINT idCmdFirst,
                                                   UINT idCmdLast,
                                                   UINT uFlags )
{
    // First, insert a menu separator
    if ( InsertMenu(hMenu, indexMenu, MF_SEPARATOR | MF_BYPOSITION, 0, NULL))
    {
        indexMenu++;
    }

    // Then, insert the verbs
    return InsertCommandsArray( hMenu, indexMenu,
                                idCmdFirst, aHoodVerbs );
}

//
//  FUNCTION: CNWHoodContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO)
//
//  PURPOSE: Called by the shell after the user has selected on of the
//           menu items that was added in QueryContextMenu().
//
//  PARAMETERS:
//    lpcmi - Pointer to an CMINVOKECOMMANDINFO structure
//
//  RETURN VALUE:
//
//
//  COMMENTS:
//

STDMETHODIMP CNWHoodContextMenu::InvokeCommand( LPCMINVOKECOMMANDINFO lpcmi )
{
    HRESULT hres = ResultFromScode(E_INVALIDARG);
    UINT idCmd = LookupCommand( aHoodVerbs , lpcmi->lpVerb );

    if ( !idCmd )
        return hres;

    switch ( idCmd )
    {
        case IDO_VERB_GLOBALWHOAMI:
            hres = NWUIGlobalWhoAmI( lpcmi->hwnd );
            break;
    }

    return hres;
}


//
//  FUNCTION: CNWHoodContextMenu::GetCommandString( UINT, UINT, UINT FAR *, LPSTR, UINT)
//
//  PURPOSE: Called by the shell after the user has selected on of the
//           menu items that was added in QueryContextMenu().
//
//  PARAMETERS:
//
//  RETURN VALUE:
//
//
//  COMMENTS:
//

STDMETHODIMP CNWHoodContextMenu::GetCommandString( UINT_PTR idCmd,
                                                   UINT uFlags,
                                                   UINT FAR *reserved,
                                                   LPSTR pszName,
                                                   UINT cchMax )
{
    if ( uFlags == GCS_HELPTEXT )
    {
        ::LoadString( ::hmodNW,
                      IDS_VERBS_HELP_BASE + IDO_VERB_GLOBALWHOAMI,
                      (LPWSTR) pszName,
                      cchMax );

        return NOERROR;
    }

    return E_NOTIMPL;
}

//
// Method gets the NETRESOURCE of the selected object
//
BOOL GetNetResourceFromShell( LPDATAOBJECT  pDataObj,
                              LPNETRESOURCE pNetRes,
                              UINT          dwBufferSize )
{
    FORMATETC fmte = { g_cfNetResource ? g_cfNetResource
                       : (g_cfNetResource=RegisterClipboardFormat(CFSTR_NETRESOURCES)),
                       (DVTARGETDEVICE FAR *) NULL,
                       DVASPECT_CONTENT,
                       -1,
                       TYMED_HGLOBAL };

    STGMEDIUM medium;
    UINT      cItems;

    if ( pNetRes == NULL )
        return FALSE;

    memset( pNetRes, 0, dwBufferSize );

    if ( !g_pFuncSHGetNetResource )   // Not loaded
        return FALSE;

    HRESULT hres = pDataObj->GetData( &fmte, &medium );

    if (!SUCCEEDED(hres))
        return FALSE;

    HNRES hnres = medium.hGlobal;

    // Get the number of selected items
    cItems = (*g_pFuncSHGetNetResource)( hnres, (UINT)-1, NULL, 0);

    if ( cItems == 0 )   // Nothing selected
        return FALSE;

    // Get the NETRESOURCE of the first item
    (*g_pFuncSHGetNetResource)( hnres, 0, pNetRes, dwBufferSize);

#if DBG
    WCHAR szTemp[32];
    wsprintf(szTemp, L"DisplayType = %d\n", pNetRes->dwDisplayType );

    ODS(L"\n**** GetNetResourceFromShell ***\n");
    ODS(pNetRes->lpProvider );
    ODS(L"\n");
    ODS(pNetRes->lpRemoteName );
    ODS(L"\n");
    ODS(szTemp );
    ODS(L"\n\n");
#endif

    //
    // HACK: We are supposed to call ReleaseStgMedium. This is a temporary
    //  hack until OLE 2.01 for Chicago is released.
    //
    if (medium.pUnkForRelease)
    {
        medium.pUnkForRelease->Release();
    }
    else
    {
        GlobalFree(medium.hGlobal);
    }

    return TRUE;
}

//-------------------------------------------------------------------//

HRESULT InsertCommandsArray( HMENU hMenu,
                             UINT  indexMenu,
                             UINT  idCmdFirst,
                             LPNWMENUITEM aVerbs )
{
    UINT    idNewCmdFirst = idCmdFirst;
    WCHAR   szVerb[MAX_VERB_SIZE];

    for ( int i = 0; aVerbs[i].idResourceString ; i++)
    {
        if ( ::LoadString( ::hmodNW,
                           aVerbs[i].idResourceString + IDS_VERBS_BASE,
                           szVerb,
                           sizeof(szVerb)/sizeof(szVerb[0])))
        {
            if (::InsertMenu( hMenu,
                              indexMenu,
                              MF_STRING | MF_BYPOSITION,
                              idNewCmdFirst,
                              szVerb))
            {
                // Add command id to the array
                aVerbs[i].idCommand = idNewCmdFirst;

                // Update command id and index
                idNewCmdFirst++;
                if (indexMenu != (UINT)-1)
                    indexMenu++;
            }
        }
    }

    return ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS,
                           FACILITY_NULL,
                           (USHORT)(idNewCmdFirst-idCmdFirst)));
}

UINT LookupCommand( LPNWMENUITEM aVerbs, LPCSTR pszCmd )
{
    if ((UINT_PTR)pszCmd > 0xFFFF)
    {
        // Possible that shell will use string commands, but unlikely

        WCHAR szVerb[MAX_VERB_SIZE];
        for ( int i=0; aVerbs[i].idResourceString; i++)
        {
            if ( ::LoadString( ::hmodNW,
                               aVerbs[i].idResourceString + IDS_VERBS_BASE,
                               szVerb,
                               sizeof(szVerb)/sizeof(szVerb[0])))
            {
                if( ::lstrcmpi( (LPCWSTR) pszCmd, szVerb) == 0)
                    return( aVerbs[i].idResourceString);
            }
        }

        return 0;
    }
    else
    {
        return( aVerbs[LOWORD(pszCmd)].idResourceString);
    }
}

UINT LookupResource( LPNWMENUITEM aVerbs, UINT uiResourceOffset )
{
    for ( int i = 0; aVerbs[i].idResourceString; i++ )
    {
        if ( aVerbs[i].idResourceString == uiResourceOffset )
            return aVerbs[i].idCommand;
    }

    return 0;
}

//-------------------------------------------------------------------//

#define _ILSkip(pidl, cb)   ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)       _ILSkip(pidl, (pidl)->mkid.cb)

#define HIDA_GetPIDLFolder(pida)    (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[0])
#define HIDA_GetPIDLItem(pida, i)   (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[i+1])

static
UINT WINAPI MyILGetSize(LPCITEMIDLIST pidl)
{
    UINT cbTotal = 0;
    if (pidl)
    {
        cbTotal += sizeof(pidl->mkid.cb);   // Null terminator
        while (pidl->mkid.cb)
        {
            cbTotal += pidl->mkid.cb;
            pidl = _ILNext(pidl);
        }
    }

    return cbTotal;
}

UINT WINAPI HIDA_GetIDList( LPIDA hida, UINT i, LPITEMIDLIST pidlOut, UINT cbMax)
{
    LPCITEMIDLIST pidlFolder = HIDA_GetPIDLFolder((LPIDA)hida);
    LPCITEMIDLIST pidlItem   = HIDA_GetPIDLItem((LPIDA)hida, i);

    UINT cbFolder  = MyILGetSize(pidlFolder)-sizeof(USHORT);
    UINT cbItem = MyILGetSize(pidlItem);

    if (cbMax < cbFolder+cbItem)
    {
        if (pidlOut)
            pidlOut->mkid.cb = 0;
    }
    else
    {
        memmove(pidlOut, pidlFolder, cbFolder);
        memmove(((LPBYTE)pidlOut)+cbFolder, pidlItem, cbItem);
    }

    return (cbFolder+cbItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\client\nwshhelp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwshhelp.h

Abstract:

    All help ids used in nwprovau.dll

Author:

    Yi-Hsin Sung      (yihsins)     20-Oct-1995

Revision History:

--*/

#ifndef _NWSHHELP_H_
#define _NWSHHELP_H_

#define NO_HELP                ((DWORD) -1)  // Disables Help on a control

#define IDH_DLG_NETWORK_CREDENTIAL_HELP  3001

#ifndef NT1057

// Global WhoAmI dialog
#define IDH_GLOBAL_SERVERLIST  3005
#define IDH_GLOBAL_CONTEXT     3006
#define	IDH_GLOBAL_DETACH	   3007
#define IDH_GLOBAL_CHGPWD      3008

// Server summary sheet
#define IDH_SERVERNAME         3020
#define IDH_COMMENT            3021
#define IDH_VERSION            3022
#define IDH_REVISION           3023
#define IDH_CONNINUSE          3024
#define IDH_MAXCONNS           3025

// Share summary sheet
#define IDH_SHARE_NAME         3030
#define IDH_SHARE_SERVER       3031
#define IDH_SHARE_PATH         3032
#define IDH_SHARE_USED_SPC     3034
#define IDH_SHARE_FREE_SPC     3035
#define IDH_SHARE_MAX_SPC      3036
#define IDH_SHARE_LFN_TXT      3037
#define IDH_SHARE_PIE          3038

// NDS sheet
#define IDH_NDS_NAME           3061
#define IDH_NDS_CLASS          3062
#define IDH_NDS_COMMENT        3063

// Printer summary sheet
#define IDH_PRINTER_NAME       3070
#define IDH_PRINTER_QUEUE      3071

#if 0
// Wkgrp summary sheet
#define IDH_WKGRP_NAME         3040
#define IDH_WKGRP_TYPE         3041

// NDS Admin page
#define IDH_ENABLE_SYSPOL	   3100
#define IDH_VOLUME_LABEL	   3101
#define IDH_VOLUME             3102
#define IDH_DIRECTORY_LABEL    3103
#define IDH_DIRECTORY          3104

#endif
#endif

#endif // _NWSHHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\client\nwshprop.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwshprop.cxx

Abstract:

    This module implements the property pages of shell extension classes.

Author:

    Yi-Hsin Sung (yihsins)  25-Oct-1995

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <commctrl.h>
#include <shellapi.h>
#include <shlobj.h>
#define DONT_WANT_SHELLDEBUG
#include <shlobjp.h>

#include <nwapi32.h>
#include <ndsapi32.h>
#include <nwmisc.h>
#include  <nds.h>
//extern "C"
//{
#include "nwshrc.h"
#include "nwutil.h"
#include "drawpie.h"
//}

#include "nwshcmn.h"
#include "nwshext.h"


LPWSTR WINAPI AddCommas( DWORD dw, LPWSTR pszResult, DWORD dwSize );
LPWSTR WINAPI ShortSizeFormat64( ULONGLONG dw64, LPWSTR szBuf );

#define NAMESPACE_DOS       0
#define NAMESPACE_MAC       1
#define NAMESPACE_UNIX      2
#define NAMESPACE_FTAM      3
#define NAMESPACE_OS2       4


BOOL
CALLBACK
NDSPage_DlgProc(
    HWND hDlg,
    UINT uMessage,
    WPARAM wParam ,
    LPARAM lParam
);

BOOL
CALLBACK
NWPage_DlgProc(
    HWND hDlg,
    UINT uMessage,
    WPARAM wParam ,
    LPARAM lParam
);

//
//  FUNCTION: CNWObjContextMenu::AddPages(LPFNADDPROPSHEETPAGE, LPARAM)
//
//  PURPOSE: Called by the shell just before the property sheet is displayed.
//
//  PARAMETERS:
//    lpfnAddPage -  Pointer to the Shell's AddPage function
//    lParam      -  Passed as second parameter to lpfnAddPage
//
//  RETURN VALUE:
//
//    NOERROR in all cases.  If for some reason our pages don't get added,
//    the Shell still needs to bring up the Properties... sheet.
//
//  COMMENTS:
//

STDMETHODIMP CNWObjContextMenu::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    LPNETRESOURCE pNetRes = (LPNETRESOURCE) _buffer;

    if ( !::GetNetResourceFromShell( _pDataObj, pNetRes, sizeof( _buffer )))
    {
        // We could not get the net resource of the current object,
        // hence we could not add the property pages
        return NOERROR;
    }

    DWORD dwDialogId = 0;
    BOOL  fIsNds = NwIsNdsSyntax( pNetRes->lpRemoteName );

    switch ( pNetRes->dwDisplayType )
    {
        case RESOURCEDISPLAYTYPE_SERVER:
            dwDialogId = DLG_SERVER_SUMMARYINFO;
            break;

        case RESOURCEDISPLAYTYPE_NDSCONTAINER:
            break;

        case RESOURCEDISPLAYTYPE_TREE:
            // We need to set fIsNds to TRUE since a tree name "\\tree"
            // does not look like a NDS name
            // and hence NwIsNDsSyntax will return FALSE.
            fIsNds = TRUE;
            break;

        case RESOURCEDISPLAYTYPE_SHARE:
            if ( pNetRes->dwType == RESOURCETYPE_PRINT )
                dwDialogId = DLG_PRINTER_SUMMARYINFO;
            else
                dwDialogId = DLG_SHARE_SUMMARYINFO;
            break;

        case RESOURCEDISPLAYTYPE_ROOT:
        case RESOURCEDISPLAYTYPE_NETWORK:
        default:
            // No property page need to be added here. Just return success.
            return NOERROR;
    }

    if ( dwDialogId != 0 )
    {
        FillAndAddPage( lpfnAddPage, lParam,
                        (DLGPROC) ::NWPage_DlgProc,
                        MAKEINTRESOURCE( dwDialogId ));
    }

    // NOTE: Do we need to add another property page contain admin tools
    // for chicago peer servers? Probably not!

    if ( fIsNds )
    {
        FillAndAddPage( lpfnAddPage, lParam,
                        (DLGPROC) ::NDSPage_DlgProc,
                        pNetRes->dwDisplayType == RESOURCEDISPLAYTYPE_TREE ?
                            MAKEINTRESOURCE( DLG_NDS_SUMMARYINFO) :
                            MAKEINTRESOURCE( DLG_NDSCONT_SUMMARYINFO));

        // NOTE: Need to add a page for system policy here if the user has admin privileges
        // in the NDS tree.
    }

    return NOERROR;
}

//
//  FUNCTION: CNWObjContextMenu::ReplacePage(UINT, LPFNADDPROPSHEETPAGE, LPARAM)
//
//  PURPOSE: Called by the shell only for Control Panel property sheet
//           extensions
//
//  PARAMETERS:
//    uPageID         -  ID of page to be replaced
//    lpfnReplaceWith -  Pointer to the Shell's Replace function
//    lParam          -  Passed as second parameter to lpfnReplaceWith
//
//  RETURN VALUE:
//
//    E_NOTIMPL, since we don't support this function.  It should never be
//    called.

//  COMMENTS:
//

STDMETHODIMP CNWObjContextMenu::ReplacePage(UINT uPageID,
                                    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                                    LPARAM lParam)
{
    return E_NOTIMPL;
}

VOID CNWObjContextMenu::FillAndAddPage( LPFNADDPROPSHEETPAGE lpfnAddPage,
                                        LPARAM  lParam,
                                        DLGPROC pfnDlgProc,
                                        LPWSTR  pszTemplate )
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    psp.dwSize      = sizeof(psp);  // no extra data.
    psp.dwFlags     = PSP_USEREFPARENT;
    psp.hInstance   = ::hmodNW;
    psp.pfnDlgProc  = pfnDlgProc;
    psp.pcRefParent = (UINT *) &g_cRefThisDll;
    psp.pszTemplate = pszTemplate;
    psp.hIcon       = 0;
    psp.pszTitle    = NULL;
    psp.pfnCallback = NULL;

    psp.lParam      = (LPARAM) this;
    this->AddRef();

    hpage = CreatePropertySheetPage(&psp);

    if (hpage)
    {
        if (!lpfnAddPage(hpage, lParam))
            DestroyPropertySheetPage(hpage);
    }

}

// The following are arrays of help contexts for the property dialogs

static DWORD aServerIds[] = { IDD_SERVER_NAME        ,IDH_SERVERNAME,
                              IDD_SERVER_COMMENT_TXT ,IDH_COMMENT,
                              IDD_SERVER_COMMENT     ,IDH_COMMENT,
                              IDD_SERVER_VERSION_TXT ,IDH_VERSION,
                              IDD_SERVER_VERSION     ,IDH_VERSION,
                              IDD_SERVER_REVISION_TXT,IDH_REVISION,
                              IDD_SERVER_REVISION    ,IDH_REVISION,
                              IDD_SERVER_CONNECT_TXT ,IDH_CONNINUSE,
                              IDD_SERVER_CONNECT     ,IDH_CONNINUSE,
                              IDD_SERVER_MAXCON_TXT  ,IDH_MAXCONNS,
                              IDD_SERVER_MAXCON      ,IDH_MAXCONNS,
                              0, 0 };

static DWORD aPrinterIds[] = { IDD_PRINTER_NAME,       IDH_PRINTER_NAME,
                               IDD_PRINTER_QUEUE_TXT,  IDH_PRINTER_QUEUE,
                               IDD_PRINTER_QUEUE,      IDH_PRINTER_QUEUE,
                               0, 0 };

static DWORD aNDSIds[] = { IDD_NDS_NAME_TXT,    IDH_NDS_NAME,
                           IDD_NDS_NAME,        IDH_NDS_NAME,
                           IDD_NDS_CLASS_TXT,   IDH_NDS_CLASS,
                           IDD_NDS_CLASS,       IDH_NDS_CLASS,
                           IDD_NDS_COMMENT_TXT, IDH_NDS_COMMENT,
                           IDD_NDS_COMMENT,     IDH_NDS_COMMENT,
                           0, 0 };

static DWORD aShareIds[] = { IDD_SHARE_NAME,        IDH_SHARE_NAME,
                             IDD_SHARE_SERVER_TXT,  IDH_SHARE_SERVER,
                             IDD_SHARE_SERVER,      IDH_SHARE_SERVER,
                             IDD_SHARE_PATH_TXT,    IDH_SHARE_PATH,
                             IDD_SHARE_PATH,        IDH_SHARE_PATH,
                             IDD_SHARE_USED_SPC_CLR,IDH_SHARE_USED_SPC,
                             IDD_SHARE_USED_SPC_TXT,IDH_SHARE_USED_SPC,
                             IDD_SHARE_USED_SPC,    IDH_SHARE_USED_SPC,
                             IDD_SHARE_USED_SPC_MB, IDH_SHARE_USED_SPC,
                             IDD_SHARE_FREE_SPC_CLR,IDH_SHARE_FREE_SPC,
                             IDD_SHARE_FREE_SPC_TXT,IDH_SHARE_FREE_SPC,
                             IDD_SHARE_FREE_SPC,    IDH_SHARE_FREE_SPC,
                             IDD_SHARE_FREE_SPC_MB, IDH_SHARE_FREE_SPC,
                             IDD_SHARE_MAX_SPC_TXT, IDH_SHARE_MAX_SPC,
                             IDD_SHARE_MAX_SPC,     IDH_SHARE_MAX_SPC,
                             IDD_SHARE_MAX_SPC_MB,  IDH_SHARE_MAX_SPC,
                             IDD_SHARE_PIE,         IDH_SHARE_PIE,
                             IDD_SHARE_LFN_TXT,     IDH_SHARE_LFN_TXT,
                             0,0 };


#if 0
static DWORD aWGIds[] = { IDD_WRKGRP_NAME,       IDH_WRKGRP_NAME,
                          IDD_WRKGRP_TYPE_TXT,   IDH_WRKGRP_TYPE,
                          IDD_WRKGRP_TYPE,       IDH_WRKGRP_TYPE,
                          0, 0 };

static DWORD aNDSAdminIds[] = { IDD_ENABLE_SYSPOL,  IDH_ENABLE_SYSPOL,
                                IDD_VOLUME_LABEL,   IDH_VOLUME_LABEL,
                                IDD_VOLUME,         IDH_VOLUME,
                                IDD_DIRECTORY_LABEL,IDH_DIRECTORY_LABEL,
                                IDD_DIRECTORY,      IDH_DIRECTORY,
                                0, 0 };
#endif


void NDSPage_InitDialog(
    HWND hDlg,
    LPPROPSHEETPAGE psp
    )
{
    CNWObjContextMenu*  pPSClass = (CNWObjContextMenu*)psp->lParam;
    LPNETRESOURCE       pnr = NULL;
    DWORD               err = NO_ERROR;
    NTSTATUS            ntstatus = STATUS_SUCCESS;
    HANDLE              hTreeConn = NULL;

    if ( pPSClass )
        pnr = pPSClass->QueryNetResource();

    if ( pnr == NULL )
    {
        ASSERT(FALSE);

        // This should not happen. We can always get the net resource which is queried
        // during AddPages.
        return;
    }

    do {  // not a loop, just wanted to break on error

        LPWSTR pszRemoteName = pnr->lpRemoteName;

        if ( pszRemoteName[0] == L' ')   // tree names have a space in front " \\mardev"
            pszRemoteName++;

        if ( pnr->dwDisplayType == RESOURCEDISPLAYTYPE_TREE )
        {
            SetDlgItemText( hDlg, IDD_NDS_NAME, pszRemoteName + 2); // get past backslashes
        }
        else
        {

            //
            //  tommye - fix for bug 5005 - if this is a root server, then 
            //  there is no more \\ past the first, and the wcschr was returning
            //  NULL, causing an AV.  So, if this is a root object, then we'll
            //  just use that object name.
            //

            LPWSTR pName;

            pName = wcschr( pszRemoteName + 2, L'\\');
            if (pName) {
                ++pName;
            }
            else {
                pName = pszRemoteName + 2;
            }

            SetDlgItemText( hDlg, IDD_NDS_NAME, pName);
        }

        DWORD dwOid;

        err = NwOpenAndGetTreeInfo( pszRemoteName,
                                    &hTreeConn,
                                    &dwOid );

        if ( err != NO_ERROR )
        {
            break;
        }

        BYTE  RawResponse[TWO_KB];
        DWORD RawResponseSize = sizeof(RawResponse);

        ntstatus = NwNdsReadObjectInfo( hTreeConn,
                                        dwOid,
                                        RawResponse,
                                        RawResponseSize );

        if ( !NT_SUCCESS( ntstatus ))
        {
            err = RtlNtStatusToDosError(ntstatus);
            break;
        }

        LPBYTE pObjectClass = RawResponse;

        pObjectClass += sizeof( NDS_RESPONSE_GET_OBJECT_INFO ) + sizeof(DWORD);

        ::SetDlgItemText( hDlg, IDD_NDS_CLASS, (LPWSTR) pObjectClass );

        // NOTE: The description can only be read successfully with administrative privilege

        DWORD iterHandle = (DWORD) -1;
        UNICODE_STRING uAttrName;
        PNDS_RESPONSE_READ_ATTRIBUTE pReadAttrResponse = (PNDS_RESPONSE_READ_ATTRIBUTE) RawResponse;

        RtlInitUnicodeString( &uAttrName, L"Description");

        ntstatus = NwNdsReadAttribute( hTreeConn,
                                       dwOid,
                                       &iterHandle,
                                       &uAttrName,
                                       RawResponse,
                                       sizeof(RawResponse));

        if (  !NT_SUCCESS( ntstatus )
           || ( pReadAttrResponse->CompletionCode != 0 )
           || ( pReadAttrResponse->NumAttributes == 0 )
           )
        {
            // we don't need to set the error since this attribute can only be read by admins and
            // we might get an error indicating this.
            break;
        }

        PNDS_ATTRIBUTE pNdsAttribute = (PNDS_ATTRIBUTE)((DWORD_PTR) RawResponse+sizeof(NDS_RESPONSE_READ_ATTRIBUTE));

        LPWSTR pszComment = (LPWSTR) ((DWORD_PTR) pNdsAttribute + 3*sizeof(DWORD)
                                      + pNdsAttribute->AttribNameLength + sizeof(DWORD));
        ::SetDlgItemText(hDlg,IDD_NDS_COMMENT, pszComment);

    } while (FALSE);


    if ( hTreeConn )
        CloseHandle( hTreeConn );

    if ( err != NO_ERROR )
    {
        LPWSTR pszMessage = NULL;

        if ( ::LoadMsgErrorPrintf( &pszMessage,
                                   IDS_MESSAGE_GETINFO_ERROR,
                                   err ) == NO_ERROR )
        {
            UnHideControl( hDlg, IDD_ERROR );
            SetDlgItemText( hDlg, IDD_ERROR, pszMessage);
            ::LocalFree( pszMessage );
        }
    }

    return;
}

BOOL
CALLBACK
NDSPage_DlgProc(
    HWND hDlg,
    UINT uMessage,
    WPARAM wParam ,
    LPARAM lParam)
{

    LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)GetWindowLong(hDlg, DWLP_USER);

    switch (uMessage)
    {
        //
        //  When the shell creates a dialog box for a property sheet page,
        // it passes the pointer to the PROPSHEETPAGE data structure as
        // lParam. The dialog procedures of extensions typically store it
        // in the DWL_USER of the dialog box window.
        //
        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            psp = (LPPROPSHEETPAGE)lParam;

            NDSPage_InitDialog( hDlg, psp);

            break;

        case WM_DESTROY:
        {
            CNWObjContextMenu*  pPSClass = (CNWObjContextMenu *)(psp->lParam);

            if (pPSClass)
                pPSClass->Release();

            SetWindowLong(hDlg, DWLP_USER, NULL);
            break;
        }

        case WM_COMMAND:
            break;

        case WM_NOTIFY:
        {
            switch (((NMHDR *)lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    CNWObjContextMenu *pPSClass =
                        (CNWObjContextMenu *)(psp->lParam);

                    pPSClass->_paHelpIds = aNDSIds;
                    break;
                }

                default:
                    break;
            }
            break;
        }

        case WM_HELP:
        {
            CNWObjContextMenu*  pPSClass = (CNWObjContextMenu *)(psp->lParam);

            if ( pPSClass && pPSClass->_paHelpIds )
            {
                WinHelp( (HWND) ((LPHELPINFO)lParam)->hItemHandle,
                         NW_HELP_FILE,
                         HELP_WM_HELP,
                         (DWORD_PTR)(LPVOID)pPSClass->_paHelpIds );
            }
            break;
        }


        case WM_CONTEXTMENU:
        {
            CNWObjContextMenu*  pPSClass = (CNWObjContextMenu*)(psp->lParam);

            if (pPSClass && pPSClass->_paHelpIds)
            {
                WinHelp( (HWND)wParam,
                         NW_HELP_FILE,
                         HELP_CONTEXTMENU,
                         (DWORD_PTR)(LPVOID)pPSClass->_paHelpIds );
            }
            break;
        }

        default:
            return FALSE;
    }

    return TRUE;

}

#define HIDWORD(_qw)    (DWORD)((_qw)>>32)
#define LODWORD(_qw)    (DWORD)(_qw)

void  Share_InitDialog(HWND hDlg, LPPROPSHEETPAGE psp)
{
    CNWObjContextMenu*  pPSClass = (CNWObjContextMenu *)psp->lParam;
    LPNETRESOURCE       pnr;
    DWORD               err = NO_ERROR;
    BOOL                fDirectoryMap = FALSE;

    if (pPSClass == NULL) {
        return;
    }

    pnr = pPSClass->QueryNetResource();

    if ( pnr == NULL )
    {
        ASSERT(FALSE);

        // This should not happen. We can always get the net resource which is queried
        // during AddPages.
        return;
    }

    do {  // not a loop, just wanted to break out if error occurred

        WCHAR szShare[MAX_PATH+1];
        WCHAR szServer[MAX_PATH+1] = L"";

        // Get the share name
        NwExtractShareName( pnr->lpRemoteName, szShare );
        SetDlgItemText( hDlg, IDD_SHARE_NAME, szShare );

        HideControl( hDlg, IDD_SHARE_PATH_TXT);
        HideControl( hDlg, IDD_SHARE_PATH);
        HideControl( hDlg, IDD_SHARE_LFN_TXT);

        // Get the server name
        if ( NwIsNdsSyntax( pnr->lpRemoteName ))
        {
            NTSTATUS ntstatus = STATUS_SUCCESS;
            HANDLE hTreeConn = NULL;
            DWORD dwOid;

            err = NwOpenAndGetTreeInfo( pnr->lpRemoteName,
                                        &hTreeConn,
                                        &dwOid );

            if ( err != NO_ERROR )
                break;

            BYTE  RawResponse[TWO_KB];
            DWORD RawResponseSize = sizeof(RawResponse);

            DWORD iterHandle = (DWORD) -1;
            UNICODE_STRING uAttrName;
            PNDS_RESPONSE_READ_ATTRIBUTE pReadAttrResponse = (PNDS_RESPONSE_READ_ATTRIBUTE) RawResponse;

            RtlInitUnicodeString( &uAttrName, L"Path");

            ntstatus = NwNdsReadAttribute( hTreeConn,
                                           dwOid,
                                           &iterHandle,
                                           &uAttrName,
                                           RawResponse,
                                           sizeof(RawResponse));

            CloseHandle( hTreeConn );
            hTreeConn = NULL;

            if (  NT_SUCCESS( ntstatus )
               && ( pReadAttrResponse->CompletionCode == 0 )
               && ( pReadAttrResponse->NumAttributes != 0 )
               )
            {
                // We are successful in reading the attribute. Hence this is a directory map.
                fDirectoryMap = TRUE;

                PNDS_ATTRIBUTE pNdsAttribute = (PNDS_ATTRIBUTE)((DWORD_PTR) RawResponse+sizeof(NDS_RESPONSE_READ_ATTRIBUTE));

                PDWORD pdwNameSpace = (PDWORD) ((DWORD_PTR) pNdsAttribute + 3*sizeof(DWORD)
                                                + pNdsAttribute->AttribNameLength
                                                + sizeof(WORD)   // need this due to bug in return value???
                                                + sizeof(DWORD));

                // See if the directory supports long file name
                // Only on directory map will Win95 show LFN support or not.
                if ( *pdwNameSpace == NAMESPACE_OS2 )
                {
                    UnHideControl( hDlg, IDD_SHARE_LFN_TXT );
                }

                // Now, try to get the volume the directory map is on
                PDWORD pdwVolumeLen = (PDWORD) ((DWORD_PTR) pdwNameSpace + sizeof(DWORD));
                LPWSTR pszVolume = (LPWSTR) ((DWORD_PTR) pdwNameSpace + 2*sizeof(DWORD));
                LPWSTR pszPath = (LPWSTR) ((DWORD_PTR) pszVolume + *pdwVolumeLen
                                           + sizeof(WORD)    // need this due to bug in return value???
                                           + sizeof(DWORD));


                WCHAR szFullPath[MAX_PATH+1];
                LPWSTR pszTemp;
                wcscpy( szFullPath, pnr->lpRemoteName );
                if ( pszTemp = wcschr( szFullPath + 2, L'\\'))
                    *(pszTemp + 1) = 0;

                wcscat( szFullPath, pszVolume );

                err = NwGetNdsVolumeInfo( szFullPath, szServer, sizeof(szServer), szShare, sizeof(szShare));


                // Now, display the path of the directory map
                if ( err == NO_ERROR )
                {
                    wcscpy( szFullPath, szShare );
                    wcscat( szFullPath, L"\\");
                    wcscat( szFullPath, pszPath );

                    UnHideControl(hDlg, IDD_SHARE_PATH_TXT);
                    UnHideControl(hDlg, IDD_SHARE_PATH);
                    SetDlgItemText( hDlg, IDD_SHARE_PATH, szFullPath );
                }
            }
            else  // this is a volume
            {

                // For NDS names, the unc path might not contain the server name.
                // So, we need to get the server name that this share is on.
                // Also, we need the original volume name like "SYS" instead of "MARS_SRV0_SYS"
                err = NwGetNdsVolumeInfo( pnr->lpRemoteName, szServer, sizeof(szServer), szShare, sizeof(szShare));
            }

            if ( err != NO_ERROR )
                break;
        }
        else  // in the form \\server\sys
        {
            NwExtractServerName( pnr->lpRemoteName, szServer );
        }

        SetDlgItemText( hDlg, IDD_SHARE_SERVER, szServer);

        NWCONN_HANDLE hConn = NULL;
        if ( NWCAttachToFileServerW( szServer, 0, &hConn ) != SUCCESSFUL )
        {
            err = GetLastError();
            break;
        }

        NWVOL_NUM nVolNum;
        char szAnsiShare[MAX_PATH+1];

        ::CharToOem( szShare, szAnsiShare );
        if ( NWCGetVolumeNumber( hConn, szAnsiShare, &nVolNum ) != SUCCESSFUL )
        {
            err = GetLastError();
            break;
        }

        DWORD           dwSectorSize = 0x200;

        DWORD           dwTotalBlocks = 0;
        DWORD           dwFreeBlocks = 0;
        DWORD           dwPurgeable = 0;
        DWORD           dwNotYetPurged = 0;
        DWORD           dwSectors= 0;
        DWORD           dwTotalDir= 0;
        DWORD           dwAvailDir= 0;

        ULONGLONG       qwTot = 0;
        ULONGLONG       qwFree = 0;

        WCHAR           szFormat[30];
        WCHAR           szTemp[80];
        WCHAR           szTemp2[30];


        // NOTE: 2.x servers does not support NWCGetVolumeUsage.
        // Hence, for 2.x servers, an error will always be shown

        if ( NWCGetVolumeUsage( hConn,
                                nVolNum,
                                &dwTotalBlocks,
                                &dwFreeBlocks,
                                &dwPurgeable,
                                &dwNotYetPurged,
                                &dwTotalDir,
                                &dwAvailDir,
                                (LPBYTE) &dwSectors ) != SUCCESSFUL )
        {
            err = GetLastError();
            break;
        }

        dwFreeBlocks += dwPurgeable;

        qwTot =  (ULONGLONG) dwSectorSize * (ULONGLONG) dwSectors * (ULONGLONG) dwTotalBlocks;

        qwFree = (ULONGLONG) dwSectorSize * (ULONGLONG) dwSectors * (ULONGLONG) dwFreeBlocks;

        if (::LoadString(::hmodNW, IDS_BYTES, szFormat, sizeof(szFormat)/sizeof(szFormat[0])))
        {
            if (!HIDWORD(qwTot-qwFree))
            {
                wsprintf(szTemp, szFormat, AddCommas(LODWORD(qwTot) - LODWORD(qwFree), szTemp2, sizeof(szTemp2)/sizeof(szTemp2[0])));
                SetDlgItemText(hDlg,IDD_SHARE_USED_SPC, szTemp);
            }

            if (!HIDWORD(qwFree))
            {
                wsprintf(szTemp, szFormat, AddCommas(LODWORD(qwFree), szTemp2, sizeof(szTemp2)/sizeof(szTemp2[0])));
                SetDlgItemText(hDlg, IDD_SHARE_FREE_SPC, szTemp);
            }

            if (!HIDWORD(qwTot))
            {
                wsprintf(szTemp, szFormat, AddCommas(LODWORD(qwTot), szTemp2, sizeof(szTemp2)/sizeof(szTemp2[0])));
                SetDlgItemText(hDlg, IDD_SHARE_MAX_SPC, szTemp);
            }
        }

        ShortSizeFormat64(qwTot-qwFree, szTemp);
        SetDlgItemText(hDlg, IDD_SHARE_USED_SPC_MB, szTemp);

        ShortSizeFormat64(qwFree, szTemp);
        SetDlgItemText(hDlg, IDD_SHARE_FREE_SPC_MB, szTemp);

        ShortSizeFormat64(qwTot, szTemp);
        SetDlgItemText(hDlg, IDD_SHARE_MAX_SPC_MB, szTemp);

        pPSClass->_fGotClusterInfo = TRUE;
        pPSClass->_dwTotal = dwTotalBlocks;
        pPSClass->_dwFree  = dwFreeBlocks;

        (VOID) NWCDetachFromFileServer( hConn );

    } while (FALSE);

    if ( err != NO_ERROR )
    {
        LPWSTR pszMessage = NULL;

        HideControl(hDlg, IDD_SHARE_USED_SPC_CLR);
        HideControl(hDlg, IDD_SHARE_USED_SPC_TXT);
        HideControl(hDlg, IDD_SHARE_USED_SPC);
        HideControl(hDlg, IDD_SHARE_USED_SPC_MB);

        HideControl(hDlg, IDD_SHARE_FREE_SPC_CLR);
        HideControl(hDlg, IDD_SHARE_FREE_SPC_TXT);
        HideControl(hDlg, IDD_SHARE_FREE_SPC);
        HideControl(hDlg, IDD_SHARE_FREE_SPC_MB);

        HideControl(hDlg, IDD_SHARE_MAX_SPC_TXT);
        HideControl(hDlg, IDD_SHARE_MAX_SPC);
        HideControl(hDlg, IDD_SHARE_MAX_SPC_MB);

        HideControl(hDlg, IDD_SHARE_PIE);

        if ( ::LoadMsgErrorPrintf( &pszMessage,
                                   IDS_MESSAGE_GETINFO_ERROR,
                                   err ) == NO_ERROR )
        {
            UnHideControl( hDlg, IDD_ERROR );
            SetDlgItemText( hDlg, IDD_ERROR, pszMessage);
            ::LocalFree( pszMessage );
        }
    }


} /* endproc Share_InitDialog */

void  Printer_InitDialog(HWND hDlg, LPPROPSHEETPAGE psp)
{
    CNWObjContextMenu*  pPSClass = (CNWObjContextMenu *)psp->lParam;
    LPNETRESOURCE       pnr;
    DWORD               err = NO_ERROR;

    if (pPSClass == NULL) {
        return;
    }
    pnr = pPSClass->QueryNetResource();

    if ( pnr == NULL )
    {
        ASSERT(FALSE);

        // This should not happen. We can always get the net resource which is queried
        // during AddPages.
        return;
    }

    do {  // not a loop, just wanted to break out if error occurred

        WCHAR szShare[MAX_PATH];
        NwExtractShareName( pnr->lpRemoteName, szShare );


        SetDlgItemText(hDlg,IDD_PRINTER_NAME, szShare);

        if ( NwIsNdsSyntax( pnr->lpRemoteName))
        {
            NTSTATUS ntstatus = STATUS_SUCCESS;
            HANDLE hTreeConn = NULL;
            DWORD dwOid;

            err = NwOpenAndGetTreeInfo( pnr->lpRemoteName,
                                        &hTreeConn,
                                        &dwOid );

            if ( err != NO_ERROR )
                break;

            BYTE  RawResponse[TWO_KB];
            DWORD RawResponseSize = sizeof(RawResponse);

            DWORD iterHandle = (DWORD) -1;
            UNICODE_STRING uAttrName;
            PNDS_RESPONSE_READ_ATTRIBUTE pReadAttrResponse = (PNDS_RESPONSE_READ_ATTRIBUTE) RawResponse;

            RtlInitUnicodeString( &uAttrName, L"Queue Directory");

            ntstatus = NwNdsReadAttribute( hTreeConn,
                                           dwOid,
                                           &iterHandle,
                                           &uAttrName,
                                           RawResponse,
                                           sizeof(RawResponse));

            CloseHandle( hTreeConn );
            hTreeConn = NULL;

            if (  !NT_SUCCESS( ntstatus )
               || ( pReadAttrResponse->CompletionCode != 0 )
               || ( pReadAttrResponse->NumAttributes == 0 )
               )
            {
                // we don't need to set the error since this attribute can only be read by admins and
                // we might get an error indicating this.
                break;
            }

            PNDS_ATTRIBUTE pNdsAttribute = (PNDS_ATTRIBUTE)((DWORD_PTR) RawResponse+sizeof(NDS_RESPONSE_READ_ATTRIBUTE));

            LPWSTR pszQueueFile = (LPWSTR) ((DWORD_PTR) pNdsAttribute + 3*sizeof(DWORD)
                                            + pNdsAttribute->AttribNameLength + sizeof(DWORD));
            ::SetDlgItemText( hDlg, IDD_PRINTER_QUEUE, pszQueueFile);
        }
        else  // bindery server
        {
            NWCONN_HANDLE hConn = NULL;
            WCHAR szServer[MAX_PATH+1];

            NwExtractServerName( pnr->lpRemoteName, szServer );

            if ( NWCAttachToFileServerW( szServer, 0, &hConn ) != SUCCESSFUL )
                err = GetLastError();

            if ( err == NO_ERROR )
            {
                char szAnsiShare[MAX_PATH+1];
                char Buffer[NW_DATA_SIZE];
                NWFLAGS ucMoreFlag, ucPropertyFlag;

                memset( Buffer, 0, sizeof(Buffer));
                ::CharToOem( szShare, szAnsiShare );

                if ( NWCReadPropertyValue( hConn,
                                           szAnsiShare,
                                           OT_PRINT_QUEUE,
                                           "Q_DIRECTORY",
                                           1,
                                           Buffer,
                                           &ucMoreFlag,
                                           &ucPropertyFlag ) != SUCCESSFUL )
                {
                    err = GetLastError();
                }

                if ( err == NO_ERROR )
                {
                    WCHAR uBuffer[NW_DATA_SIZE];

                    ::OemToChar( Buffer, uBuffer );

                    ::SetDlgItemText( hDlg, IDD_PRINTER_QUEUE, (LPWSTR) uBuffer);
                }
                else
                {
                    err = NO_ERROR;  // Only supervisor has read/write so don't show the error.
                }

                (VOID) NWCDetachFromFileServer( hConn );
            }
        }

    } while (FALSE);

    if ( err != NO_ERROR )
    {
        LPWSTR pszMessage = NULL;

        if ( ::LoadMsgErrorPrintf( &pszMessage,
                                   IDS_MESSAGE_GETINFO_ERROR,
                                   err ) == NO_ERROR )
        {
            UnHideControl( hDlg, IDD_ERROR );
            SetDlgItemText( hDlg, IDD_ERROR, pszMessage);
            ::LocalFree( pszMessage );
        }
    }

} /* endproc Printer_InitDialog */

void  Server_InitDialog(HWND hDlg, LPPROPSHEETPAGE psp)
{
    CNWObjContextMenu*  pPSClass = (CNWObjContextMenu *)psp->lParam;
    LPNETRESOURCE       pnr;
    DWORD               err = NO_ERROR;

    if (pPSClass == NULL) {
        return;
    }
    pnr = pPSClass->QueryNetResource();

    if ( pnr == NULL )
    {
        ASSERT(FALSE);

        // This should not happen. We can always get the net resource which is queried
        // during AddPages.
        return;
    }

    do {  // not a loop, just wanted to break out if error occurred

        WCHAR szServer[MAX_PATH];
        NwExtractServerName( pnr->lpRemoteName, szServer );

        SetDlgItemText( hDlg, IDD_SERVER_NAME, szServer );

        //
        // Get some server information
        //

        NWCONN_HANDLE hConn = NULL;
        if ( NWCAttachToFileServerW( szServer, 0, &hConn ) != SUCCESSFUL )
        {
            err = GetLastError();
            break;
        }

        VERSION_INFO vInfo;

        if ( NWCGetFileServerVersionInfo( hConn, &vInfo ) != SUCCESSFUL )
        {
            err = GetLastError();
            break;
        }

        WCHAR szTemp[512];
        char  szAnsiCompany[512];
        char  szAnsiVersion[512];
        char  szAnsiRevision[512];

        if ( NWCGetFileServerDescription( hConn, szAnsiCompany, szAnsiVersion,
                                          szAnsiRevision ) != SUCCESSFUL )
        {
            err = GetLastError();
            break;
        }

        // OemToChar( szAnsiCompany, szTemp );
        // wcscat( szTemp, L" " );
        // OemToChar( szAnsiVersion, szTemp + wcslen( szTemp ));

        OemToChar( szAnsiVersion, szTemp );

        ::SetDlgItemText( hDlg, IDD_SERVER_VERSION, szTemp);

        OemToChar( szAnsiRevision, szTemp );
        ::SetDlgItemText( hDlg, IDD_SERVER_REVISION, szTemp );

        WCHAR szNumber[12];

        ::wsprintf(szNumber,L"%d", vInfo.connsInUse );
        ::SetDlgItemText( hDlg, IDD_SERVER_CONNECT, szNumber);

        ::wsprintf(szNumber,L"%4d", vInfo.ConnsSupported);
        ::SetDlgItemText( hDlg, IDD_SERVER_MAXCON, szNumber);

        (VOID) NWCDetachFromFileServer( hConn );

#if 0
        // Now deal with Chicago specific fields
        if (pPSClass->_fIsPeerServer) {

            pXNCPResp pxresp = (pXNCPResp) pPSClass->_bufServerExInfo.QueryPtr(); ;
            pXGetServerInfoResp lpInfoPtr = (pXGetServerInfoResp)(pxresp+1);
            CHAR    szString[128];
            STRING  *pNWString;

            // Next field is workgroup name
            pNWString = (STRING *)(lpInfoPtr->passThruServer.str+lpInfoPtr->passThruServer.len);
            pNWString = (STRING *)(pNWString->str+pNWString->len);

            // And next after that is comment

            ::OemToCharBuff((LPCSTR)pNWString->str,szString,pNWString->len);
            szString[pNWString->len] = '\0';

            UnHideControl( hDlg, IDD_SERVER_COMMENT_TXT );
            UnHideControl( hDlg, IDD_SERVER_COMMENT );
            ::SetDlgItemText(hDlg,IDD_SERVER_COMMENT,szString);

        } else
#endif

    } while (FALSE);

    if ( err != NO_ERROR )
    {
        LPWSTR pszMessage = NULL;

        if ( ::LoadMsgErrorPrintf( &pszMessage,
                                   IDS_MESSAGE_GETINFO_ERROR,
                                   err ) == NO_ERROR )
        {
            UnHideControl( hDlg, IDD_ERROR );
            SetDlgItemText( hDlg, IDD_ERROR, pszMessage);
            ::LocalFree( pszMessage );
        }
    }

} /* endproc Server_InitDialog */

#if 0
void  Wrkgrp_InitDialog(HWND hDlg, LPPROPSHEETPAGE psp)
{

    CNWObjContextMenu  *pPSClass = (CNWObjContextMenu *)psp->lParam;
    LPNETRESOURCE       pnr;

    if ( pPSClass )
        pnr = (LPNETRESOURCE)pPSClass->_bufNR.QueryPtr();

    if ( pnr )
    {
        // Set name static control
        SetDlgItemText(hDlg,IDD_WRKGRP_NAME, pnr->lpRemoteName);
    }

}
#endif

COLORREF c_crPieColors[] =
{
    RGB(  0,   0, 255),  // Blue
    RGB(255,   0, 255),  // Red-Blue
    RGB(  0,   0, 128),  // 1/2 Blue
    RGB(128,   0, 128),  // 1/2 Red-Blue
} ;

void _DrvPrshtDrawItem(HWND hDlg, LPPROPSHEETPAGE psp, const DRAWITEMSTRUCT * lpdi)
{
    COLORREF crDraw;
    RECT     rcItem = lpdi->rcItem;
    HBRUSH   hbDraw, hbOld;
    SIZE     size;
    HDC      hDC;
    CNWObjContextMenu*    pPSClass = (CNWObjContextMenu *)psp->lParam;

    if (pPSClass->_fGotClusterInfo == FALSE)
        return;

    switch (lpdi->CtlID)
    {
    case IDD_SHARE_PIE:

        hDC = GetDC(hDlg);
        GetTextExtentPoint(hDC, L"W", 1, &size);
        ReleaseDC(hDlg, hDC);

        DrawPie(lpdi->hDC, &lpdi->rcItem,
            pPSClass->_dwTotal ? 1000*(pPSClass->_dwTotal-pPSClass->_dwFree)/pPSClass->_dwTotal : 1000,
            pPSClass->_dwFree==0 || pPSClass->_dwFree==pPSClass->_dwTotal,
            size.cy*2/3, c_crPieColors);

        break;

    case IDD_SHARE_USED_SPC_CLR:
        crDraw = c_crPieColors[DP_USEDCOLOR];
        goto DrawColor;

    case IDD_SHARE_FREE_SPC_CLR:
        crDraw = c_crPieColors[DP_FREECOLOR];
        goto DrawColor;

DrawColor:
        hbDraw = CreateSolidBrush(crDraw);
        if (hbDraw)
        {
            hbOld = (HBRUSH) SelectObject(lpdi->hDC, hbDraw);
            if (hbOld)
            {
                PatBlt(lpdi->hDC, rcItem.left, rcItem.top,
                    rcItem.right-rcItem.left,
                    rcItem.bottom-rcItem.top,
                    PATCOPY);

                SelectObject(lpdi->hDC, hbOld);
            }

            DeleteObject(hbDraw);
        }
        break;

    default:
        break;
    }
}


BOOL CALLBACK NWPage_DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam , LPARAM lParam)
{
   LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)GetWindowLong(hDlg, DWLP_USER);

   switch (uMessage)
   {
      //
      //  When the shell creates a dialog box for a property sheet page,
      // it passes the pointer to the PROPSHEETPAGE data structure as
      // lParam. The dialog procedures of extensions typically store it
      // in the DWLP_USER of the dialog box window.
      //
      case WM_INITDIALOG:
         SetWindowLongPtr(hDlg, DWLP_USER, lParam);
         psp = (LPPROPSHEETPAGE)lParam;

         if (psp->pszTemplate == MAKEINTRESOURCE(DLG_SERVER_SUMMARYINFO))
             Server_InitDialog(hDlg, psp);
         else if (psp->pszTemplate == MAKEINTRESOURCE(DLG_SHARE_SUMMARYINFO))
             Share_InitDialog(hDlg, psp);
         else if (psp->pszTemplate == MAKEINTRESOURCE(DLG_PRINTER_SUMMARYINFO))
             Printer_InitDialog(hDlg, psp);
#if 0
         else if (psp->pszTemplate == MAKEINTRESOURCE(DLG_WRKGRP_SUMMARYINFO))
             Wrkgrp_InitDialog(hDlg, psp);
#endif

         break;

      case WM_DRAWITEM:
         _DrvPrshtDrawItem(hDlg, psp, (DRAWITEMSTRUCT *)lParam);
         break;

      case WM_DESTROY:
         {
            CNWObjContextMenu*  pPSClass = (CNWObjContextMenu *)(psp->lParam);

            if (pPSClass) {
                pPSClass->Release();
            }

            SetWindowLong(hDlg, DWLP_USER, NULL);
         }
         break;

      case WM_COMMAND:
         break;

      case WM_NOTIFY:
         switch (((NMHDR *)lParam)->code) {
             case PSN_SETACTIVE:
             {
                 CNWObjContextMenu *pPSClass = (CNWObjContextMenu *)(psp->lParam);

                 if (psp->pszTemplate == MAKEINTRESOURCE(DLG_SERVER_SUMMARYINFO))
                     pPSClass->_paHelpIds = aServerIds;
                 else if (psp->pszTemplate == MAKEINTRESOURCE(DLG_SHARE_SUMMARYINFO))
                     pPSClass->_paHelpIds = aShareIds;
                 else if (psp->pszTemplate == MAKEINTRESOURCE(DLG_PRINTER_SUMMARYINFO))
                     pPSClass->_paHelpIds = aPrinterIds;
#if 0
                 else if (psp->pszTemplate == MAKEINTRESOURCE(DLG_WRKGRP_SUMMARYINFO))
                     pPSClass->_paHelpIds = aWGIds;
#endif

                 break;
             }

             default:
                 break;
         }

         break;

      case WM_HELP:
        {
            CNWObjContextMenu*  pPSClass = (CNWObjContextMenu *)(psp->lParam);

            if (pPSClass && pPSClass->_paHelpIds)
            {
                WinHelp( (HWND) ((LPHELPINFO)lParam)->hItemHandle,
                         NW_HELP_FILE,
                         HELP_WM_HELP,
                        (DWORD_PTR)(LPVOID)pPSClass->_paHelpIds );
            }
        }

        break;

      case WM_CONTEXTMENU:
        {
            CNWObjContextMenu*  pPSClass = (CNWObjContextMenu*)(psp->lParam);

            if (pPSClass && pPSClass->_paHelpIds)
            {
                WinHelp( (HWND)wParam,
                         NW_HELP_FILE,
                         HELP_CONTEXTMENU,
                         (DWORD_PTR)(LPVOID)pPSClass->_paHelpIds );
            }
            break;
        }

      default:
        return(FALSE);
   }

   return(TRUE);

}

// Regular StrToInt; stops at first non-digit.
int WINAPI MyStrToInt(LPWSTR lpSrc) // atoi()
{

#define ISDIGIT(c)  ((c) >= '0' && (c) <= '9')

    int n = 0;
    BOOL bNeg = FALSE;

    if (*lpSrc == L'-') {
        bNeg = TRUE;
    lpSrc++;
    }

    while (ISDIGIT(*lpSrc)) {
    n *= 10;
    n += *lpSrc - L'0';
    lpSrc++;
    }
    return bNeg ? -n : n;
}

// The following functions are stolen from win\core\shell\shelldll
// takes a DWORD add commas etc to it and puts the result in the buffer
LPWSTR WINAPI AddCommas( DWORD dw, LPWSTR pszResult, DWORD dwSize )
{
    WCHAR  szTemp[30];
    WCHAR  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, sizeof(szSep)/sizeof(szSep[0]));
    nfmt.Grouping = MyStrToInt(szSep);
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, sizeof(szSep)/sizeof(szSep[0]));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

#pragma data_seg(".text", "CODE")
    wsprintf(szTemp, L"%lu", dw);
#pragma data_seg()

    if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszResult, dwSize) == 0)
        lstrcpy(pszResult, szTemp);

    return pszResult;
}

const short pwOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB, IDS_ORDERGB, IDS_ORDERTB};

LPWSTR WINAPI ShortSizeFormat64(ULONGLONG dw64, LPWSTR szBuf)
{
    int i;
    UINT wInt, wLen, wDec;
    WCHAR szTemp[10], szOrder[20], szFormat[5];

    if (dw64 < 1000) {
#pragma data_seg(".text", "CODE")
        wsprintf(szTemp, L"%d", LODWORD(dw64));
#pragma data_seg()
        i = 0;
        goto AddOrder;
    }

    for (i = 1; i< sizeof(pwOrders)/sizeof(pwOrders[0])-1 && dw64 >= 1000L * 1024L; dw64 >>= 10, i++);
        /* do nothing */

    wInt = LODWORD(dw64 >> 10);
    AddCommas(wInt, szTemp, sizeof(szTemp)/sizeof(szTemp[0]));
    wLen = lstrlen(szTemp);
    if (wLen < 3)
    {
        wDec = LODWORD(dw64 - (ULONGLONG)wInt * 1024L) * 1000 / 1024;
        // At this point, wDec should be between 0 and 1000
        // we want get the top one (or two) digits.
        wDec /= 10;
        if (wLen == 2)
            wDec /= 10;

        // Note that we need to set the format before getting the
        // intl char.
#pragma data_seg(".text", "CODE")
        lstrcpy(szFormat, L"%02d");
#pragma data_seg()

        szFormat[2] = L'0' + 3 - wLen;
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                szTemp+wLen, sizeof(szTemp)/sizeof(szTemp[0])-wLen);
        wLen = lstrlen(szTemp);
        wLen += wsprintf(szTemp+wLen, szFormat, wDec);
    }

AddOrder:
    ::LoadString(::hmodNW, pwOrders[i], szOrder, sizeof(szOrder)/sizeof(szOrder[0]));
    wsprintf(szBuf, szOrder, (LPSTR)szTemp);

    return szBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\client\nwshrc.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwshrc.h

Abstract:

    All resource ids used in nwprovau.dll

Author:

    Yi-Hsin Sung      (yihsins)     20-Oct-1995

Revision History:

--*/

#ifndef _NWSHRC_H_
#define _NWSHRC_H_

#include "nwshhelp.h"

#define IDC_STATIC                  -1
#define IDC_LOGOFRAME               599

//
// Icon Ids
//

#define IDI_TREE_ICON               600 
#define IDI_SERVER_ICON             601 
#define IDI_FOLDER_ICON             602 
#define IDI_PRINTER_ICON            603 
#define IDI_NDSCONT_ICON            604 

// Bitmap Ids
#define IDB_SERVER_ICON             701
#define IDB_TREE_ICON               702

//
// Dialog Ids
//

#define DLG_NETWARE_LOGIN           1000
#define DLG_NETWORK_CREDENTIAL      1001
#define DLG_CHANGE_PASSWORD         1002
#define DLG_CHANGE_PASSWORD2        1003
#define DLG_PASSWORD_CHANGE         1004
#define DLG_PASSWORD_PROMPT         1005
#define DLG_PREFERRED_SERVER_HELP   1006
#define DLG_ENTER_PASSWORD_HELP     1007
#define DLG_ENTER_OLD_PASSWORD      1009
#define DLG_PW_SELECT_SERVERS       1010
#define DLG_PW_CHANGED              1011
#define DLG_ENTER_OLD_PW_HELP       1012
#define DLG_PW_SELECT_SERVERS_HELP  1013
#define DLG_ENTER_ALT_USERNAME      1014
#define DLG_ENTER_ALT_UN_HELP       1015
#define DLG_CHANGE_PASSWORD3        1016
#define DLG_CHANGE_PASSWORD_HELP    1017

//
// Dialog Ids for Shell Extension
//
#define DLG_NDS_SUMMARYINFO         1100
#define DLG_SERVER_SUMMARYINFO      1101
#define DLG_SHARE_SUMMARYINFO       1102
#define DLG_PRINTER_SUMMARYINFO     1103
#define DLG_GLOBAL_WHOAMI           1104
#define DLG_NDSCONT_SUMMARYINFO     1105

//
// Help File names, IDs, and macro
//
#define NW_HELP_FILE       (USER_SHARED_DATA->NtProductType == NtProductWinNt ? \
                                   TEXT("nwdoc.hlp") : TEXT("nwdocgw.hlp"))

//
// Control Ids used by all dialogs
//
#ifdef  NT1057
#define IDHELP                      100
#endif

//
// Control Ids used in both the login dialog and the
// change password dialog
//
#define ID_USERNAME                 101
#define ID_SERVER                   102
#define ID_LOCATION                 103
#define ID_PREFERREDSERVER_RB       104
#define ID_DEFAULTCONTEXT_RB        105
#define ID_DEFAULTTREE              106
#define ID_DEFAULTCONTEXT           107

//
// Control Ids used in the login dialog
//
#define ID_PASSWORD                 200

//
// Control Ids used in the change password dialog
//
#define ID_OLD_PASSWORD             300
#define ID_NEW_PASSWORD             301
#define ID_CONFIRM_PASSWORD         302

#define ID_ADD                      304
#define ID_REMOVE                   305
#define ID_ACTIVE_LIST              306
#define ID_INACTIVE_LIST            307
#define ID_ACTIVE_LIST_TITLE        308
#define ID_INACTIVE_LIST_TITLE      309

//
// Control Ids used in the network credential dialog
//
#define ID_VOLUME_PATH              400
#define ID_CONNECT_AS               401
#define ID_CONNECT_PASSWORD         402
#define ID_CONNECT_TEXT             403

//
// Login script
//
#define ID_LOGONSCRIPT              501

//
// Controls common to summaryinfo dialogs
//

#define IDD_ERROR                   200

//
// Controls Ids in DLG_NDS_SUMMARYINFO
//
#define IDD_NDS_NAME_TXT            101
#define IDD_NDS_NAME                102
#define IDD_NDS_CLASS_TXT           103
#define IDD_NDS_CLASS               104
#define IDD_NDS_COMMENT_TXT         105
#define IDD_NDS_COMMENT             106

//
// Controls Ids in DLG_SERVER_SUMMARYINFO
//
#define IDD_SERVER_NAME             101
#define IDD_SERVER_VERSION_TXT      102
#define IDD_SERVER_VERSION          103
#define IDD_SERVER_REVISION_TXT     104
#define IDD_SERVER_REVISION         105
#define IDD_SERVER_COMMENT_TXT      106
#define IDD_SERVER_COMMENT          107
#define IDD_SERVER_CONNECT_TXT      108
#define IDD_SERVER_CONNECT          109
#define IDD_SERVER_MAXCON_TXT       110
#define IDD_SERVER_MAXCON           111

//
// Controls Ids in DLG_SHARE_SUMMARYINFO
//
#define IDD_SHARE_NAME              101
#define IDD_SHARE_SERVER_TXT        102
#define IDD_SHARE_SERVER            103
#define IDD_SHARE_PATH_TXT          104
#define IDD_SHARE_PATH              105
#define IDD_SHARE_USED_SPC_CLR      106
#define IDD_SHARE_USED_SPC_TXT      107
#define IDD_SHARE_USED_SPC          108
#define IDD_SHARE_USED_SPC_MB       109
#define IDD_SHARE_FREE_SPC_CLR      110
#define IDD_SHARE_FREE_SPC_TXT      111
#define IDD_SHARE_FREE_SPC          112
#define IDD_SHARE_FREE_SPC_MB       113
#define IDD_SHARE_MAX_SPC_TXT       114
#define IDD_SHARE_MAX_SPC           115
#define IDD_SHARE_MAX_SPC_MB        116
#define IDD_SHARE_PIE               117
#define IDD_SHARE_LFN_TXT           118

//
// Controls Ids in DLG_PRINTER_SUMMARYINFO
//
#define IDD_PRINTER_NAME            101
#define IDD_PRINTER_QUEUE_TXT       102
#define IDD_PRINTER_QUEUE           103

//
// Controls Ids in DLG_GLOBAL_WHOAMI
//
#define IDD_GLOBAL_SERVERLIST_T     101
#define IDD_GLOBAL_SERVERLIST       102
#define IDD_GLOBAL_SVRLIST_DESC     103
#define IDD_DETACH                  104
#define IDD_REFRESH                 105

// 
// String Ids
//
#define IDS_START                         20000
#define IDS_NONE                          (IDS_START + 0)
#define IDS_NETWARE_PRINT_CAPTION         (IDS_START + 1)
#define IDS_NOTHING_TO_CONFIGURE          (IDS_START + 2)
#define IDS_NETWARE_TITLE                 (IDS_START + 3)
#define IDS_AUTH_FAILURE_TITLE            (IDS_START + 4)
#define IDS_NO_PREFERRED                  (IDS_START + 5)
#define IDS_LOGIN_FAILURE_WARNING         (IDS_START + 6)
#define IDS_AUTH_FAILURE_WARNING          (IDS_START + 7)
#define IDS_CHANGE_PASSWORD_INFO          (IDS_START + 8)
#define IDS_INVALID_SERVER                (IDS_START + 9)
#define IDS_PASSWORD_HAS_EXPIRED          (IDS_START + 10)
#define IDS_AUTH_ACC_RESTRICTION          (IDS_START + 11)
#define IDS_LOGIN_ACC_RESTRICTION         (IDS_START + 12)
#define IDS_PASSWORD_HAS_EXPIRED1         (IDS_START + 13)
#define IDS_BAD_PASSWORDS                 (IDS_START + 14)
#define IDS_CHANGE_PASSWORD_TITLE         (IDS_START + 15)
#define IDS_START_WORKSTATION_FIRST       (IDS_START + 16)
#define IDS_PASSWORD_HAS_EXPIRED0         (IDS_START + 17)
#define IDS_PASSWORD_HAS_EXPIRED2         (IDS_START + 18)
#define IDS_LOGIN_DISABLED                (IDS_START + 19)
#define IDS_START_WORKSTATION_FIRST_NTAS  (IDS_START + 20)
#define IDS_SERVER                        (IDS_START + 21)
#define IDS_CONTEXT                       (IDS_START + 22)
#define IDS_CONNECT_NO_ERROR_TEXT         (IDS_START + 23)
#define IDS_TITLE_LOGOUT                  (IDS_START + 24)
#define IDS_MESSAGE_LOGOUT_QUESTION       (IDS_START + 25)
#define IDS_MESSAGE_LOGOUT_FAILED         (IDS_START + 26)
#define IDS_MESSAGE_NOT_ATTACHED          (IDS_START + 27)
#define IDS_MESSAGE_DETACHED              (IDS_START + 28)
#define IDS_MESSAGE_LOGOUT_CONFIRM        (IDS_START + 29)
#define IDS_TITLE_WHOAMI                  (IDS_START + 30)
#define IDS_MESSAGE_ATTACHED              (IDS_START + 31)
#define IDS_BYTES                         (IDS_START + 32)
#define IDS_ORDERKB                       (IDS_START + 33)
#define IDS_ORDERMB                       (IDS_START + 34)
#define IDS_ORDERGB                       (IDS_START + 35)
#define IDS_ORDERTB                       (IDS_START + 36)
#define IDS_STATE_NOT_LOGGED_IN           (IDS_START + 37)
#define IDS_MESSAGE_NOT_ATTACHED_TO_TREE  (IDS_START + 38)
#define IDS_MESSAGE_ATTACHED_TO_TREE      (IDS_START + 39)
#define IDS_LOGIN_TYPE_NDS                (IDS_START + 40)
#define IDS_LOGIN_TYPE_BINDERY            (IDS_START + 41)
#define IDS_LOGIN_STATUS_SEPARATOR        (IDS_START + 42)
#define IDS_LOGIN_STATUS_AUTHENTICATED    (IDS_START + 43)
#define IDS_LOGIN_STATUS_NOT_AUTHENTICATED (IDS_START + 44)
#define IDS_LOGIN_STATUS_LICENSED         (IDS_START + 45)
#define IDS_LOGIN_STATUS_NOT_LICENSED     (IDS_START + 46)
#define IDS_LOGIN_STATUS_LOGGED_IN        (IDS_START + 47)
#define IDS_LOGIN_STATUS_ATTACHED_ONLY    (IDS_START + 48)
#define IDS_LOGIN_STATUS_NOT_ATTACHED     (IDS_START + 49)
#define IDS_MESSAGE_CONNINFO_ERROR        (IDS_START + 50)
#define IDS_MESSAGE_ADDCONN_ERROR         (IDS_START + 51)
#define IDS_MESSAGE_CONTEXT_ERROR         (IDS_START + 52)
#define IDS_MESSAGE_LOGGED_IN_TREE        (IDS_START + 53)
#define IDS_MESSAGE_NOT_LOGGED_IN_TREE    (IDS_START + 54)
#define IDS_MESSAGE_LOGGED_IN_SERVER      (IDS_START + 55)
#define IDS_MESSAGE_NOT_LOGGED_IN_SERVER  (IDS_START + 56)
#define IDS_MESSAGE_PROPERTIES_ERROR      (IDS_START + 57)
#define IDS_TREE_NAME_MISSING             (IDS_START + 58)
#define IDS_CONTEXT_MISSING               (IDS_START + 59)
#define IDS_SERVER_MISSING                (IDS_START + 60)
#define IDS_CONTEXT_AUTH_FAILURE_WARNING  (IDS_START + 61)
#define IDS_COLUMN_NAME                   (IDS_START + 62)
#define IDS_COLUMN_CONN_TYPE              (IDS_START + 63)
#define IDS_COLUMN_CONN_NUMBER            (IDS_START + 64)
#define IDS_COLUMN_USER                   (IDS_START + 65)
#define IDS_COLUMN_STATUS                 (IDS_START + 66)
#define IDS_MESSAGE_GETINFO_ERROR         (IDS_START + 67)
#define IDS_CP_FAILURE_WARNING            (IDS_START + 68)
#define IDS_CHANGE_PASSWORD_CONFLICT      (IDS_START + 69)
#define IDS_NO_TREES_DETECTED             (IDS_START + 70)
#define IDS_MESSAGE_LOGOUT_FROM_SERVER_FAILED  (IDS_START + 71)

//
// String Ids for Shell Extension
//
#define IDS_MESSAGE_CONTEXT_CHANGED       (IDS_START + 100)

#define IDS_VERBS_BASE                    (IDS_START + 150)
#define IDS_VERBS_HELP_BASE               (IDS_START + 200)

#define IDO_VERB_WHOAMI                   1
#define IDO_VERB_LOGOUT                   2
#define IDO_VERB_ATTACHAS                 3
#define IDO_VERB_GLOBALWHOAMI             4
#define IDO_VERB_SETDEFAULTCONTEXT        5
#define IDO_VERB_MAPNETWORKDRIVE          6
#define IDO_VERB_TREEWHOAMI               7


#define IDS_END                           (IDS_START + 1000)

#endif // _NWSHRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\client\nwwks_c_stub.c ===
#include "nwwks_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\client\nwutil.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwutil.c

Abstract:

    Contains some misc functions used by shell extensions

Author:

    Yi-Hsin Sung    (yihsins)      25-Oct-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddnwfs.h>
#include <ndsapi32.h>
#include <nwmisc.h>
#include "nwclient.h"
#include "nwapi.h"
#include "nwutil.h"

#define  EXTRA_BYTES  256

BOOL
NwIsNdsSyntax(
    IN LPWSTR lpstrUnc
)
{
    HANDLE hTreeConn;
    DWORD  dwOid;
    DWORD  status = NO_ERROR;

    if ( lpstrUnc == NULL )
        return FALSE;

    status = NwOpenAndGetTreeInfo( lpstrUnc, &hTreeConn, &dwOid );

    if ( status != NO_ERROR )
    {
        return FALSE;
    }

    CloseHandle( hTreeConn );

    return TRUE;
}

VOID
NwAbbreviateUserName(
    IN  LPWSTR pszFullName,
    OUT LPWSTR pszUserName
)
{
    if ( pszUserName == NULL )
        return;

    if ( NwIsNdsSyntax( pszFullName ))
    {
        //
        // TRACKING - This part of the code never gets called due to the
        // change in how NwIsNdsSyntax works. Post NT 4.0, get rid of the
        // NwIsNdsSyntax test and run this section of code no matter what.
        // This bug was not fixed in NT4.0 due to the extremely close time
        // to the ship date.
        //
        LPWSTR pszTemp = pszFullName;
        LPWSTR pszLast = pszTemp;

        *pszUserName = 0;

        while ( pszTemp = wcschr( pszTemp, L'='))
        {
            WCHAR NextChar;

            NextChar = *(++pszTemp);

            while ( NextChar != 0 && NextChar != L'.' )
            {     
                *(pszUserName++) = *pszTemp;
                NextChar = *(++pszTemp);
            }

            if ( NextChar == 0 )
            {
                pszLast = NULL;
                break;
            }

            *(pszUserName++) = *pszTemp;   // put back the '.' 
            pszLast = ++pszTemp;
        }

        if ( pszLast != NULL )
        {
            while ( *pszLast != 0 )
                *(pszUserName++) = *(pszLast++);
        }

        *pszUserName = 0;
    }
    else
    {
        wcscpy( pszUserName, pszFullName );
    }
}

VOID 
NwMakePrettyDisplayName(
    IN  LPWSTR pszName 
)
{
    if ( pszName )
    {
        CharLower( pszName );
        CharUpperBuff( pszName, 1);
    }
}

VOID
NwExtractTreeName(
    IN  LPWSTR pszUNCPath,
    OUT LPWSTR pszTreeName
)
{
    LPWSTR pszTemp = NULL;

    if ( pszTreeName == NULL )
        return;

    pszTreeName[0] = 0;

    if ( pszUNCPath == NULL )
        return;

    if ( pszUNCPath[0] == L' ')
        pszUNCPath++;

    if (  ( pszUNCPath[0] != L'\\') || ( pszUNCPath[1] != L'\\') )
        return;

    wcscpy( pszTreeName, pszUNCPath + 2 );      // get past "\\"

    if ( pszTemp = wcschr( pszTreeName, L'\\' )) 
        *pszTemp = 0;
}

VOID
NwExtractServerName(
    IN  LPWSTR pszUNCPath,
    OUT LPWSTR pszServerName
)
{
    LPWSTR pszTemp = NULL;

    if ( pszServerName == NULL ) {
        return;
    }

    pszServerName[0] = 0;

    if ( pszUNCPath == NULL ) {
        return;
    }

    if ( pszUNCPath[0] == L' ') {
        pszUNCPath++;
    }

    if ( ( pszUNCPath[0] != L'\\') || ( pszUNCPath[1] != L'\\') ) {
        return;
    }

    //
    //  tommye - fix for bug 5005 - if there is a NW server having
    //  the same name as a NDS Tree, then NwIsNdsSyntax will return 
    //  TRUE even though the path points to the server (not the tree).
    //  This was blowing up becuase the wschr was returning NULL, and
    //  wasn't being checked.  If this returns NULL, then we'll make 
    //  the assumption that we've got a server name after all.
    //

    if ( NwIsNdsSyntax( pszUNCPath ))
    {
        pszTemp = wcschr( pszUNCPath + 2, L'\\' );  // get past "\\"

        if (pszTemp) {
            wcscpy( pszServerName, pszTemp + 1 );       // get past "\"

            if ( pszTemp = wcschr( pszServerName, L'.' )) {
                *pszTemp = 0;
            }

            return;
        }

    }

    //
    // tommye
    // Fall through - this must be a server name only
    //

    wcscpy( pszServerName, pszUNCPath + 2 );    // get past "\\"

    if ( pszTemp = wcschr( pszServerName, L'\\' )) {
        *pszTemp = 0;
    }
}

VOID
NwExtractShareName(
    IN  LPWSTR pszUNCPath,
    OUT LPWSTR pszShareName
)
{
    LPWSTR pszTemp = NULL;

    if ( pszShareName == NULL ) {
        return;
    }

    pszShareName[0] = 0;

    if (  ( pszUNCPath == NULL )
       || ( pszUNCPath[0] != L'\\')
       || ( pszUNCPath[1] != L'\\')
       )
    {
        return;
    }

    //
    //  tommye - fix for bug 5005 - if there is a NW server having
    //  the same name as a NDS Tree, then NwIsNdsSyntax will return 
    //  TRUE even though the path points to the server (not the tree).
    //  This was blowing up becuase the wschr was returning NULL, and
    //  wasn't being checked.  If this returns NULL, then we'll make 
    //  the assumption that we've got a server name after all.
    //

    if ( NwIsNdsSyntax( pszUNCPath ))
    {
        pszTemp = wcschr( pszUNCPath + 2, L'\\' );  // get past "\\"

        if (pszTemp) {
            wcscpy( pszShareName, pszTemp + 1 );        // get past "\"

            if ( pszTemp = wcschr( pszShareName, L'.' )) {
                *pszTemp = 0;
            }

            return;
        }
    }

    //
    // tommye
    // Fall through - this must be a server name only
    //

    pszTemp = wcschr( pszUNCPath + 2, L'\\' );  // get past "\\"
    wcscpy( pszShareName, pszTemp + 1);         // get past "\"

    if ( pszTemp = wcschr( pszShareName, L'\\' )) {
        *pszTemp = 0;
    }
}

DWORD
NwIsServerInDefaultTree(
    IN  LPWSTR  pszFullServerName,
    OUT BOOL   *pfInDefaultTree
)
{
    DWORD  err = NO_ERROR;
    LPWSTR pszCurrentContext = NULL;
    DWORD  dwPrintOptions;
    WCHAR  szTreeName[MAX_PATH + 1];

    *pfInDefaultTree = FALSE;

    if ( !NwIsNdsSyntax( pszFullServerName ))
    {
        // The full server name does not contain any NDS information
        // In this case, assume the server is not in the tree.
        // If a server belongs the default tree, we would get the full 
        // NDS information.
        return NO_ERROR;
    }

    // Get the current default tree or server name
    err = NwQueryInfo( &dwPrintOptions, &pszCurrentContext );

    if ( (err == NO_ERROR) && ( *pszCurrentContext == TREECHAR))
    {
        // Yes, there is a default tree. 
        // So, get the tree name out of *TREE\CONTEXT
        LPWSTR pszTemp = wcschr( pszCurrentContext, L'\\');
        if ( pszTemp )
            *pszTemp = 0;

        // Need to extract the tree name from full UNC path
        NwExtractTreeName( pszFullServerName, szTreeName );

        if ( _wcsicmp( szTreeName,
                      pszCurrentContext + 1) == 0 ) // get past the tree char
        {
            *pfInDefaultTree = TRUE;
        }
    }

    if ( pszCurrentContext != NULL )
        LocalFree( pszCurrentContext );

    return err;
}

DWORD
NwIsServerOrTreeAttached(
    IN  LPWSTR  pszName,
    OUT BOOL   *pfAttached,
    OUT BOOL   *pfAuthenticated
)
{
    DWORD  err = NO_ERROR;
    DWORD  EntriesRead = 0;
    DWORD_PTR  ResumeKey = 0;
    LPBYTE Buffer = NULL;

    err = NwGetConnectionStatus(
              pszName,
              &ResumeKey,
              &Buffer,
              &EntriesRead );

    *pfAttached = FALSE;
    *pfAuthenticated = FALSE;

    if (( err == NO_ERROR ) && ( EntriesRead > 0 ))
    {
        // For trees, we might get more than one entries back.

        PCONN_STATUS pConnStatus = (PCONN_STATUS) Buffer;

        if ( !pConnStatus->fPreferred )
        {
            // We only need to return as attached if this is not a preferred
            // server implicit connection since we don't want the user to know
            // about this connection ( which rdr does not allow user to delete)

            *pfAttached = TRUE;
            *pfAuthenticated = (pConnStatus->dwConnType != NW_CONN_NOT_AUTHENTICATED);
        }
    }

    if ( Buffer != NULL )
    {
        LocalFree( Buffer );
        Buffer = NULL;
    }

    return err;
}

DWORD
NwGetConnectionInformation(
    IN  LPWSTR  pszName,
    OUT LPBYTE  Buffer,
    IN  DWORD   BufferSize
)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    HANDLE            handleRdr = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;
    UNICODE_STRING    uRdrName;
    WCHAR             RdrPrefix[] = L"\\Device\\NwRdr\\*";
     
    PNWR_REQUEST_PACKET RequestPacket = NULL;
    DWORD             RequestPacketSize = 0;
    DWORD             dwNameLen = 0;

    if ( pszName == NULL )
        return ERROR_INVALID_PARAMETER;

    //
    // Set up the object attributes.
    //

    RtlInitUnicodeString( &uRdrName, RdrPrefix );

    InitializeObjectAttributes( &ObjectAttributes,
                                &uRdrName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntstatus = NtOpenFile( &handleRdr,
                           SYNCHRONIZE | FILE_LIST_DIRECTORY,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_VALID_FLAGS,
                           FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
        goto CleanExit;

    dwNameLen = wcslen(pszName) * sizeof(WCHAR);

    RequestPacketSize = sizeof( NWR_REQUEST_PACKET ) + dwNameLen;

    RequestPacket = (PNWR_REQUEST_PACKET) LocalAlloc( LMEM_ZEROINIT, 
                                                      RequestPacketSize );

    if ( RequestPacket == NULL )
    {
        ntstatus = STATUS_NO_MEMORY;
        goto CleanExit;
    }

    //
    // Fill out the request packet for FSCTL_NWR_GET_CONN_INFO.
    //

    RequestPacket->Version = REQUEST_PACKET_VERSION;
    RequestPacket->Parameters.GetConnInfo.ConnectionNameLength = dwNameLen;

    RtlCopyMemory( &(RequestPacket->Parameters.GetConnInfo.ConnectionName[0]),
                   pszName,
                   dwNameLen );

    ntstatus = NtFsControlFile( handleRdr,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_NWR_GET_CONN_INFO,
                                (PVOID) RequestPacket,
                                RequestPacketSize,
                                (PVOID) Buffer,
                                BufferSize );
 
    if ( NT_SUCCESS( ntstatus ))
        ntstatus = IoStatusBlock.Status;

CleanExit:

    if ( handleRdr != NULL )
        NtClose( handleRdr );

    if ( RequestPacket != NULL )
        LocalFree( RequestPacket );

    return RtlNtStatusToDosError( ntstatus );
}

DWORD
NWPGetConnectionStatus(
    IN     LPWSTR  pszRemoteName,
    IN OUT PDWORD_PTR  ResumeKey,
    OUT    LPBYTE  Buffer,
    IN     DWORD   BufferSize,
    OUT    PDWORD  BytesNeeded,
    OUT    PDWORD  EntriesRead
)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    HANDLE            handleRdr = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;
    UNICODE_STRING    uRdrName;
    WCHAR             RdrPrefix[] = L"\\Device\\NwRdr\\*";
     
    PNWR_REQUEST_PACKET RequestPacket = NULL;
    DWORD             RequestPacketSize = 0;
    DWORD             dwRemoteNameLen = 0;

    //
    // Set up the object attributes.
    //

    RtlInitUnicodeString( &uRdrName, RdrPrefix );

    InitializeObjectAttributes( &ObjectAttributes,
                                &uRdrName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntstatus = NtOpenFile( &handleRdr,
                           SYNCHRONIZE | FILE_LIST_DIRECTORY,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_VALID_FLAGS,
                           FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
        goto CleanExit;

    dwRemoteNameLen = pszRemoteName? wcslen(pszRemoteName)*sizeof(WCHAR) : 0;

    RequestPacketSize = sizeof( NWR_REQUEST_PACKET ) + dwRemoteNameLen;

    RequestPacket = (PNWR_REQUEST_PACKET) LocalAlloc( LMEM_ZEROINIT, 
                                                      RequestPacketSize );

    if ( RequestPacket == NULL )
    {
        ntstatus = STATUS_NO_MEMORY;
        goto CleanExit;
    }

    //
    // Fill out the request packet for FSCTL_NWR_GET_CONN_STATUS.
    //

    RequestPacket->Parameters.GetConnStatus.ResumeKey = *ResumeKey;

    RequestPacket->Version = REQUEST_PACKET_VERSION;
    RequestPacket->Parameters.GetConnStatus.ConnectionNameLength = dwRemoteNameLen;

    RtlCopyMemory( &(RequestPacket->Parameters.GetConnStatus.ConnectionName[0]),
                   pszRemoteName,
                   dwRemoteNameLen );

    ntstatus = NtFsControlFile( handleRdr,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_NWR_GET_CONN_STATUS,
                                (PVOID) RequestPacket,
                                RequestPacketSize,
                                (PVOID) Buffer,
                                BufferSize );
 
    if ( NT_SUCCESS( ntstatus ))
        ntstatus = IoStatusBlock.Status;

    *EntriesRead = RequestPacket->Parameters.GetConnStatus.EntriesReturned;
    *ResumeKey   = RequestPacket->Parameters.GetConnStatus.ResumeKey;
    *BytesNeeded = RequestPacket->Parameters.GetConnStatus.BytesNeeded;

CleanExit:

    if ( handleRdr != NULL )
        NtClose( handleRdr );

    if ( RequestPacket != NULL )
        LocalFree( RequestPacket );

    return RtlNtStatusToDosError( ntstatus );
}


DWORD
NwGetConnectionStatus(
    IN  LPWSTR  pszRemoteName,
    OUT PDWORD_PTR  ResumeKey,
    OUT LPBYTE  *Buffer,
    OUT PDWORD  EntriesRead
)
{
    DWORD err = NO_ERROR;
    DWORD dwBytesNeeded = 0;
    DWORD dwBufferSize  = TWO_KB;

    *Buffer = NULL;
    *EntriesRead = 0;
 
    do { 

        *Buffer = (LPBYTE) LocalAlloc( LMEM_ZEROINIT, dwBufferSize );

        if ( *Buffer == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;

        err = NWPGetConnectionStatus( pszRemoteName,
                                      ResumeKey,
                                      *Buffer,
                                      dwBufferSize,
                                      &dwBytesNeeded,
                                      EntriesRead );

        if ( err == ERROR_INSUFFICIENT_BUFFER )
        {
            dwBufferSize = dwBytesNeeded + EXTRA_BYTES;
            LocalFree( *Buffer );
            *Buffer = NULL;
        }

    } while ( err == ERROR_INSUFFICIENT_BUFFER );

    if ( err == ERROR_INVALID_PARAMETER )  // not attached
    { 
        err = NO_ERROR;
        *EntriesRead = 0;
    }

    return err;
}

DWORD
NwGetNdsVolumeInfo(
    IN  LPWSTR pszName,
    OUT LPWSTR pszServerBuffer,
    IN  WORD   wServerBufferSize,    // in bytes
    OUT LPWSTR pszVolumeBuffer,
    IN WORD   wVolumeBufferSize     // in bytes
)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    HANDLE   handleNdsTree;

    LPWSTR   pszTree, pszVolume, pszTemp;    
    UNICODE_STRING uTree, uVolume;

    UNICODE_STRING uHostServer, uHostVolume;
    WCHAR HostVolumeBuffer[256];

    pszTree = pszName + 2;  // get past two backslashes

    pszTemp = wcschr( pszTree, L'\\' );
    if ( pszTemp ) 
        *pszTemp = 0;
    else
        return ERROR_INVALID_PARAMETER; 
   
    pszVolume = pszTemp + 1;

    RtlInitUnicodeString( &uTree, pszTree );
    RtlInitUnicodeString( &uVolume, pszVolume );
    
    //
    // Open up a handle to the tree.
    //

    ntstatus = NwNdsOpenTreeHandle( &uTree,
                                    &handleNdsTree );

    if ( !NT_SUCCESS( ntstatus )) 
        goto CleanExit;

    //
    // Set up the reply strings.
    //

    uHostServer.Length = 0;
    uHostServer.MaximumLength = wServerBufferSize;
    uHostServer.Buffer = pszServerBuffer;

    RtlZeroMemory( pszServerBuffer, wServerBufferSize );

    if ( pszVolumeBuffer != NULL )
    {
        uHostVolume.Length = 0;
        uHostVolume.MaximumLength = wVolumeBufferSize;
        uHostVolume.Buffer = pszVolumeBuffer;

        RtlZeroMemory( pszVolumeBuffer, wVolumeBufferSize );
    }
    else
    {
        uHostVolume.Length = 0;
        uHostVolume.MaximumLength = sizeof( HostVolumeBuffer );
        uHostVolume.Buffer = HostVolumeBuffer;
    }

    ntstatus = NwNdsGetVolumeInformation( handleNdsTree,
                                          &uVolume,
                                          &uHostServer,
                                          &uHostVolume );

    CloseHandle( handleNdsTree );

CleanExit:

    //
    // Note: This change added to fix NT bug 338991 on Win2000
    //
    if ( ntstatus == STATUS_BAD_NETWORK_PATH )
    {
        ntstatus = STATUS_ACCESS_DENIED;
    }

    if ( pszTemp )
        *pszTemp = L'\\';

    return RtlNtStatusToDosError( ntstatus );
}

DWORD
NwOpenAndGetTreeInfo(
    LPWSTR pszNdsUNCPath,
    HANDLE *phTreeConn,
    DWORD  *pdwOid
)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    WCHAR          lpServerName[NW_MAX_SERVER_LEN];
    UNICODE_STRING ServerName;

    UNICODE_STRING ObjectName;
   
    *phTreeConn = NULL;

    ServerName.Length = 0;
    ServerName.MaximumLength = sizeof( lpServerName );
    ServerName.Buffer = lpServerName;

    ObjectName.Buffer = NULL;
    ObjectName.MaximumLength = ( wcslen( pszNdsUNCPath) + 1 ) * sizeof( WCHAR );

    ObjectName.Length = NwParseNdsUncPath( (LPWSTR *) &ObjectName.Buffer,
                                           pszNdsUNCPath,
                                           PARSE_NDS_GET_TREE_NAME );

    if ( ObjectName.Length == 0 || ObjectName.Buffer == NULL )
    {
        return ERROR_PATH_NOT_FOUND;
    }

    //
    // Open a NDS tree connection handle to \\treename
    //
    ntstatus = NwNdsOpenTreeHandle( &ObjectName, phTreeConn );

    if ( !NT_SUCCESS( ntstatus ))
    {
        return RtlNtStatusToDosError( ntstatus );
    }

    //
    // Get the path to the container to open.
    //
    ObjectName.Length = NwParseNdsUncPath( (LPWSTR *) &ObjectName.Buffer,
                                           pszNdsUNCPath,
                                           PARSE_NDS_GET_PATH_NAME );

    if ( ObjectName.Length == 0 )
    {
        UNICODE_STRING Root;

        RtlInitUnicodeString(&Root, L"[Root]");

        //
        // Resolve the path to get a NDS object id.
        //
        ntstatus =  NwNdsResolveName( *phTreeConn,
                                      &Root,
                                      pdwOid,
                                      &ServerName,
                                      NULL,
                                      0 );

    }
    else
    {
        //
        // Resolve the path to get a NDS object id.
        //
        ntstatus =  NwNdsResolveName( *phTreeConn,
                                      &ObjectName,
                                      pdwOid,
                                      &ServerName,
                                      NULL,
                                      0 );

    }

    if ( ntstatus == STATUS_SUCCESS && ServerName.Length )
    {
        DWORD    dwHandleType;

        //
        // NwNdsResolveName succeeded, but we were referred to
        // another server, though pdwOid is still valid.

        if ( *phTreeConn )
            CloseHandle( *phTreeConn );

        *phTreeConn = NULL;

        //
        // Open a NDS generic connection handle to \\ServerName
        //
        ntstatus = NwNdsOpenGenericHandle( &ServerName,
                                           &dwHandleType,
                                           phTreeConn );

        if ( ntstatus != STATUS_SUCCESS )
        {
            return RtlNtStatusToDosError(ntstatus);
        }

        ASSERT( dwHandleType != HANDLE_TYPE_NCP_SERVER );
    }

    if ( !NT_SUCCESS( ntstatus ))
    {
    
        if ( *phTreeConn != NULL )
        {
            CloseHandle( *phTreeConn );
            *phTreeConn = NULL;
        }
        return RtlNtStatusToDosError(ntstatus);
    }

    return NO_ERROR;

}

DWORD
NwGetConnectedTrees(
    IN  LPWSTR  pszNtUserName,
    OUT LPBYTE  Buffer,
    IN  DWORD   BufferSize,
    OUT LPDWORD lpEntriesRead,
    OUT LPDWORD lpUserLUID
)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    HANDLE            handleRdr = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;
    WCHAR             RdrPrefix[] = L"\\Device\\NwRdr\\*";
    UNICODE_STRING    uRdrName;
    UNICODE_STRING    uNtUserName;

    PNWR_NDS_REQUEST_PACKET Request = NULL;
    BYTE                    RequestBuffer[2048];
    DWORD                   RequestSize = 0;

    *lpEntriesRead = 0;

    //
    // Convert the user name to unicode.
    //

    RtlInitUnicodeString( &uNtUserName, pszNtUserName );

    //
    // Set up the object attributes.
    //

    RtlInitUnicodeString( &uRdrName, RdrPrefix );

    InitializeObjectAttributes( &ObjectAttributes,
                                &uRdrName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntstatus = NtOpenFile( &handleRdr,
                           SYNCHRONIZE | FILE_LIST_DIRECTORY,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_VALID_FLAGS,
                           FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
        goto CleanExit;

    //
    // Fill out the request packet for FSCTL_NWR_NDS_LIST_TREES;
    //

    Request = ( PNWR_NDS_REQUEST_PACKET ) RequestBuffer;

    Request->Parameters.ListTrees.NtUserNameLength = uNtUserName.Length;

    RtlCopyMemory( &(Request->Parameters.ListTrees.NtUserName[0]),
                   uNtUserName.Buffer,
                   uNtUserName.Length );

    RequestSize = sizeof( Request->Parameters.ListTrees ) +
                  uNtUserName.Length +
                  sizeof( DWORD );

    ntstatus = NtFsControlFile( handleRdr,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_NWR_NDS_LIST_TREES,
                                (PVOID) Request,
                                RequestSize,
                                (PVOID) Buffer,
                                BufferSize );

    if ( NT_SUCCESS( ntstatus ))
    {
        ntstatus = IoStatusBlock.Status;
        *lpEntriesRead = Request->Parameters.ListTrees.TreesReturned;
        *lpUserLUID = Request->Parameters.ListTrees.UserLuid.LowPart;
    }

CleanExit:

    if ( handleRdr != NULL )
        NtClose( handleRdr );

    return RtlNtStatusToDosError( ntstatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\client\nwspl.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwspl.h

Abstract:

    Common header for print provider client-side code.

Author:

    Yi-Hsin Sung (yihsins)  15-May-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NWSPL_INCLUDED_
#define _NWSPL_INCLUDED_

#include "nwdlg.h"

typedef struct _NWPORT {
    DWORD   cb;
    struct  _NWPORT *pNext;
    LPWSTR  pName;
} NWPORT, *PNWPORT;

extern LPWSTR   pszRegistryPath;
extern LPWSTR   pszRegistryPortNames;
extern WCHAR    szMachineName[];
extern PNWPORT  pNwFirstPort;
extern CRITICAL_SECTION NwSplSem;

BOOL IsLocalMachine(
    LPWSTR pszName
);

BOOL PortExists(
    LPWSTR  pszPortName,
    LPDWORD pError
);

BOOL PortKnown(
    LPWSTR  pszPortName
);

PNWPORT CreatePortEntry(
    LPWSTR pszPortName
);

BOOL DeletePortEntry(
    LPWSTR pszPortName
);
 
VOID DeleteAllPortEntries(
    VOID
);

DWORD CreateRegistryEntry(
    LPWSTR pszPortName
);

DWORD DeleteRegistryEntry(
    LPWSTR pszPortName
);


#endif // _NWSPL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\client\nwtest.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nwtest.c

Abstract:

    Main program.

Author:

    Glenn Curtis (glennc)     June, 1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include <nwclient.h>
#include <ntmsv1_0.h>
#include <nwsnames.h>
#include <nwcanon.h>
#include <validc.h>
#include <nwevent.h>

#include <nwdlg.h>

#include <nwreg.h>
#include <nwlsa.h>
#include <nwauth.h>
#include <nwapi.h>
#include <nwmisc.h>
#include <ndsapi32.h>

#include <stdlib.h>
#include <stdio.h>      //  printf()
#include <string.h>     //  strtoul()


__cdecl
main(
    int Argc,
    char **Argv
    )
{
    DWORD Status = NO_ERROR;
    WCHAR Domain[256];
    WCHAR UserName[256];
    WCHAR Password[256];
    WCHAR OldPassword[256];
    MSV1_0_INTERACTIVE_LOGON AuthentInfo;
    MSV1_0_INTERACTIVE_LOGON PreviousAuthentInfoType;

    memset( &AuthentInfo, 0, sizeof( MSV1_0_INTERACTIVE_LOGON ));
    memset( &PreviousAuthentInfoType, 0, sizeof( MSV1_0_INTERACTIVE_LOGON ));

    AuthentInfo.LogonDomainName.Length = wcslen( L"NTDEV" ) * sizeof( WCHAR );
    AuthentInfo.LogonDomainName.MaximumLength = 256 * sizeof( WCHAR );
    AuthentInfo.LogonDomainName.Buffer = Domain;
    wcscpy( AuthentInfo.LogonDomainName.Buffer, L"NTDEV" );

    AuthentInfo.UserName.Length = wcslen( L"glennc" ) * sizeof( WCHAR );
    AuthentInfo.UserName.MaximumLength = 256 * sizeof( WCHAR );
    AuthentInfo.UserName.Buffer = UserName;
    wcscpy( AuthentInfo.UserName.Buffer, L"glennc" );

    AuthentInfo.Password.Length = wcslen( L"VWbug01" ) * sizeof( WCHAR );
    AuthentInfo.Password.MaximumLength = 256 * sizeof( WCHAR );
    AuthentInfo.Password.Buffer = Password;
    wcscpy( AuthentInfo.Password.Buffer, L"VWbug01" );

    PreviousAuthentInfoType.LogonDomainName.Length = wcslen( L"NTDEV" ) * sizeof( WCHAR );
    PreviousAuthentInfoType.LogonDomainName.MaximumLength = 256 * sizeof( WCHAR );
    PreviousAuthentInfoType.LogonDomainName.Buffer = Domain;

    PreviousAuthentInfoType.UserName.Length = wcslen( L"glennc" ) * sizeof( WCHAR );
    PreviousAuthentInfoType.UserName.MaximumLength = 256 * sizeof( WCHAR );
    PreviousAuthentInfoType.UserName.Buffer = UserName;

    PreviousAuthentInfoType.Password.Length = wcslen( L"VWbug08" ) * sizeof( WCHAR );
    PreviousAuthentInfoType.Password.MaximumLength = 256 * sizeof( WCHAR );
    PreviousAuthentInfoType.Password.Buffer = OldPassword;
    wcscpy( PreviousAuthentInfoType.Password.Buffer, L"VWbug08" );
    

    Status = NPPasswordChangeNotify( L"MSV1_0:Interactive",
                                     (LPVOID) &AuthentInfo,
                                     NULL,
                                     (LPVOID) &PreviousAuthentInfoType,
                                     L"WinSta0",
                                     NULL,
                                     0 );

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\client\nwspl.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwspl.c

Abstract:

    This module contains the Netware print provider.

Author:

    Yi-Hsin Sung    (yihsins)   15-Apr-1993

Revision History:
    Yi-Hsin Sung    (yihsins)   15-May-1993
        Moved most of the functionality to the server side

    Ram Viswanathan (ramv)      09-Aug-1995
        Added functionality to Add and Delete Printer.


--*/

#include <stdio.h>

#include <nwclient.h>
#include <winspool.h>
#include <winsplp.h>
#include <ntlsa.h>

#include <nwpkstr.h>
#include <splutil.h>
#include <nwreg.h>
#include <nwspl.h>
#include <nwmisc.h>
#include <winsta.h>
//------------------------------------------------------------------
//
// Local Functions
//
//------------------------------------------------------------------
// now all SKUs have TerminalServer flag.  If App Server is enabled, SingleUserTS flag is cleared
#define IsTerminalServer() (BOOLEAN)(!(USER_SHARED_DATA->SuiteMask & (1 << SingleUserTS))) //user mode
DWORD
InitializePortNames(
    VOID
);

VOID
NwpGetUserInfo(
    LPWSTR *ppszUser,
    BOOL   *pfGateway
);

DWORD
NwpGetThreadUserInfo(
    LPWSTR  *ppszUser,
    LPWSTR  *ppszUserSid
);

DWORD
NwpGetUserNameFromSid(
    PSID pUserSid,
    LPWSTR *ppszUserName
);



DWORD
NwpGetLogonUserInfo(
    LPWSTR  *ppszUserSid
);


DWORD
ThreadIsInteractive(
    VOID
);

VOID
pFreeAllContexts();

//------------------------------------------------------------------
//
// Global Variables
//
//------------------------------------------------------------------

HMODULE hmodNW = NULL;
BOOL    fIsWinnt = FALSE ;
WCHAR *pszRegistryPath = NULL;
WCHAR *pszRegistryPortNames=L"PortNames";
WCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 3];
PNWPORT pNwFirstPort = NULL;
CRITICAL_SECTION NwSplSem;
CRITICAL_SECTION NwServiceListCriticalSection; // Used to protect linked
                                               // list of registered services
HANDLE           NwServiceListDoneEvent = NULL;// Used to stop local advertise
                                               // threads.
STATIC HANDLE handleDummy;  // This is a dummy handle used to
                            // return to the clients if we have previously
                            // opened the given printer successfully
                            // and the netware workstation service is not
                            // currently available.

STATIC
PRINTPROVIDOR PrintProvidor = { OpenPrinter,
                                SetJob,
                                GetJob,
                                EnumJobs,
                                AddPrinter,                 // NOT SUPPORTED
                                DeletePrinter,              // NOT SUPPORTED
                                SetPrinter,
                                GetPrinter,
                                EnumPrinters,
                                AddPrinterDriver,           // NOT SUPPORTED
                                EnumPrinterDrivers,         // NOT SUPPORTED
                                GetPrinterDriverW,          // NOT SUPPORTED
                                GetPrinterDriverDirectory,  // NOT SUPPORTED
                                DeletePrinterDriver,        // NOT SUPPORTED
                                AddPrintProcessor,          // NOT SUPPORTED
                                EnumPrintProcessors,        // NOT SUPPORTED
                                GetPrintProcessorDirectory, // NOT SUPPORTED
                                DeletePrintProcessor,       // NOT SUPPORTED
                                EnumPrintProcessorDatatypes,// NOT SUPPORTED
                                StartDocPrinter,
                                StartPagePrinter,           // NOT SUPPORTED
                                WritePrinter,
                                EndPagePrinter,             // NOT SUPPORTED
                                AbortPrinter,
                                ReadPrinter,                // NOT SUPPORTED
                                EndDocPrinter,
                                AddJob,
                                ScheduleJob,
                                GetPrinterData,             // NOT SUPPORTED
                                SetPrinterData,             // NOT SUPPORTED
                                WaitForPrinterChange,
                                ClosePrinter,
                                AddForm,                    // NOT SUPPORTED
                                DeleteForm,                 // NOT SUPPORTED
                                GetForm,                    // NOT SUPPORTED
                                SetForm,                    // NOT SUPPORTED
                                EnumForms,                  // NOT SUPPORTED
                                EnumMonitors,               // NOT SUPPORTED
                                EnumPorts,
                                AddPort,                    // NOT SUPPORTED
                                ConfigurePort,
                                DeletePort,
                                CreatePrinterIC,            // NOT SUPPORTED
                                PlayGdiScriptOnPrinterIC,   // NOT SUPPORTED
                                DeletePrinterIC,            // NOT SUPPORTED
                                AddPrinterConnection,       // NOT SUPPORTED
                                DeletePrinterConnection,    // NOT SUPPORTED
                                PrinterMessageBox,          // NOT SUPPORTED
                                AddMonitor,                 // NOT SUPPORTED
                                DeleteMonitor               // NOT SUPPORTED
};


//------------------------------------------------------------------
//
//  Initialization Functions
//
//------------------------------------------------------------------


BOOL InitializeDll(
    HINSTANCE hdll,
    DWORD     dwReason,
    LPVOID    lpReserved
)
{
    NT_PRODUCT_TYPE ProductType ;

    UNREFERENCED_PARAMETER( lpReserved );

    if ( dwReason == DLL_PROCESS_ATTACH )
    {
        DisableThreadLibraryCalls( hdll );

        hmodNW = hdll;

        //
        // are we a winnt machine?
        //
        fIsWinnt = RtlGetNtProductType(&ProductType) ? 
                       (ProductType == NtProductWinNt) :
                       FALSE ;

        //
        // Initialize the critical section for maintaining the registered
        // service list
        //
        InitializeCriticalSection( &NwServiceListCriticalSection );
        NwServiceListDoneEvent = CreateEventA( NULL, TRUE, FALSE, NULL );
    }
    else if ( dwReason == DLL_PROCESS_DETACH )
    {
        //
        // Free up memories used by the port link list
        //
        DeleteAllPortEntries();

        //
        // Get rid of Service List and Shutdown SAP library
        //
        NwTerminateServiceProvider();

#ifndef NT1057
        //
        // Clean up shell extensions
        //
        NwCleanupShellExtensions();
#endif
        pFreeAllContexts();          // clean up RNR stuff
        DeleteCriticalSection( &NwServiceListCriticalSection );
        if ( NwServiceListDoneEvent )
        {
            CloseHandle( NwServiceListDoneEvent );
            NwServiceListDoneEvent = NULL;
        }
    }

    return TRUE;
}



DWORD
InitializePortNames(
    VOID
)
/*++

Routine Description:

    This is called by the InitializePrintProvidor to initialize the ports
    names used in this providor.

Arguments:

    None.

Return Value:

    Returns NO_ERROR or the error that occurred.

--*/
{
    DWORD err;
    HKEY  hkeyPath;
    HKEY  hkeyPortNames;

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        pszRegistryPath,
                        0,
                        KEY_READ,
                        &hkeyPath );

    if ( !err )
    {
        err = RegOpenKeyEx( hkeyPath,
                            pszRegistryPortNames,
                            0,
                            KEY_READ,
                            &hkeyPortNames );

        if ( !err )
        {
            DWORD i = 0;
            WCHAR Buffer[MAX_PATH];
            DWORD BufferSize;

            while ( !err )
            {
                BufferSize = sizeof(Buffer) / sizeof(WCHAR);

                err = RegEnumValue( hkeyPortNames,
                                    i,
                                    Buffer,
                                    &BufferSize,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL );

                if ( !err )
                    CreatePortEntry( Buffer );

                i++;
            }

            /* We expect RegEnumKeyEx to return ERROR_NO_MORE_ITEMS
             * when it gets to the end of the keys, so reset the status:
             */
            if( err == ERROR_NO_MORE_ITEMS )
                err = NO_ERROR;

            RegCloseKey( hkeyPortNames );
        }
#if DBG
        else
        {
            IF_DEBUG(PRINT)
                KdPrint(("NWSPL [RegOpenKeyEx] (%ws) failed: Error = %d\n",
                         pszRegistryPortNames, err ));
        }
#endif

        RegCloseKey( hkeyPath );
    }
#if DBG
    else
    {
        IF_DEBUG(PRINT)
            KdPrint(("NWSPL [RegOpenKeyEx] (%ws) failed: Error = %d\n",
                      pszRegistryPath, err ));
    }
#endif

    return err;
}

//------------------------------------------------------------------
//
// Print Provider Functions supported by NetWare provider
//
//------------------------------------------------------------------


BOOL
InitializePrintProvidor(
    LPPRINTPROVIDOR pPrintProvidor,
    DWORD           cbPrintProvidor,
    LPWSTR          pszFullRegistryPath
)
/*++

Routine Description:

    This is called by the spooler subsystem to initialize the print
    providor.

Arguments:

    pPrintProvidor      -  Pointer to the print providor structure to be
                           filled in by this function
    cbPrintProvidor     -  Count of bytes of the print providor structure
    pszFullRegistryPath -  Full path to the registry key of this print providor

Return Value:

    Always TRUE.

--*/
{
    //
    //  dfergus 20 Apr 2001 #323700
    //  Prevent Multiple CS Initialization
    //
    static int iCSInit = 0;

    DWORD dwLen;

    if ( !pPrintProvidor || !pszFullRegistryPath || !*pszFullRegistryPath )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    memcpy( pPrintProvidor,
            &PrintProvidor,
            min( sizeof(PRINTPROVIDOR), cbPrintProvidor) );

    //
    // Store the registry path for this print providor
    //
    if ( !(pszRegistryPath = AllocNwSplStr(pszFullRegistryPath)) )
        return FALSE;

    //
    // Store the local machine name
    //
    szMachineName[0] = szMachineName[1] = L'\\';
    dwLen = MAX_COMPUTERNAME_LENGTH;
    GetComputerName( szMachineName + 2, &dwLen );

#if DBG
    IF_DEBUG(PRINT)
    {
        KdPrint(("NWSPL [InitializePrintProvidor] "));
        KdPrint(("RegistryPath = %ws, ComputerName = %ws\n",
                 pszRegistryPath, szMachineName ));
    }
#endif

    //
    //  dfergus 20 Apr 2001 #323700
    //  Prevent Multiple CS Initialization
    //
    if( !iCSInit )
    {
        InitializeCriticalSection( &NwSplSem );
        iCSInit = 1;
    }
    //
    // Ignore the error returned from InitializePortNames.
    // The provider can still function if we cannot get all the port
    // names.
    //
    InitializePortNames();

    return TRUE;
}



BOOL
OpenPrinterW(
    LPWSTR             pszPrinterName,
    LPHANDLE           phPrinter,
    LPPRINTER_DEFAULTS pDefault
)
/*++

Routine Description:

    This routine retrieves a handle identifying the specified printer.

Arguments:

    pszPrinterName -  Name of the printer
    phPrinter      -  Receives the handle that identifies the given printer
    pDefault       -  Points to a PRINTER_DEFAULTS structure. Can be NULL.

Return Value:

    TRUE if the function succeeds, FALSE otherwise. Use GetLastError() for
    extended error information.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(( "NWSPL [OpenPrinter] Name = %ws\n", pszPrinterName ));
#endif

    UNREFERENCED_PARAMETER( pDefault );

    if ( !pszPrinterName )
    {
        SetLastError( ERROR_INVALID_NAME );
        return FALSE;
    }

    RpcTryExcept
    {
        err = NwrOpenPrinter( NULL,
                              pszPrinterName,
                              PortKnown( pszPrinterName ),
                              (LPNWWKSTA_PRINTER_CONTEXT) phPrinter );

        //
        // Make sure there is a port of this name so that
        // EnumPorts will return it.
        //

        if ( !err )
        {

            if ( !PortExists( pszPrinterName, &err ) && !err )
            {
                //
                // We will ignore the errors since it is
                // still OK if we can't add the port.
                // Cannot delete once created, don't create
                // We should not create port entry and registry entry
               
                if ( CreatePortEntry( pszPrinterName ) )
                    CreateRegistryEntry( pszPrinterName );

            }

        }
        
    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
        {
            if ( PortKnown( pszPrinterName ))
            {
                *phPrinter = &handleDummy;
                err = NO_ERROR;
            }
            else
            {
                err = ERROR_INVALID_NAME;
            }
        }
        else
        {
            err = NwpMapRpcError( code );
        }
    }
    RpcEndExcept

    if ( err )
    {
        SetLastError( err );

#if DBG
        IF_DEBUG(PRINT)
            KdPrint(("NWSPL [OpenPrinter] err = %d\n", err));
#endif
    }

    return ( err == NO_ERROR );

}



BOOL
ClosePrinter(
    HANDLE  hPrinter
)
/*++

Routine Description:

    This routine closes the given printer object.

Arguments:

    hPrinter -  Handle of the printer object

Return Value:

    TRUE if the function succeeds, FALSE otherwise. Use GetLastError() for
    extended error information.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(( "NWSPL [ClosePrinter]\n"));
#endif

    //
    // Just return success if the handle is a dummy one
    //
    if ( hPrinter == &handleDummy )
        return TRUE;

    RpcTryExcept
    {
        err = NwrClosePrinter( (LPNWWKSTA_PRINTER_CONTEXT) &hPrinter );
    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;

}



BOOL
GetPrinter(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  pbPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
/*++

Routine Description:

    The routine retrieves information about the given printer.

Arguments:

    hPrinter  -  Handle of the printer
    dwLevel   -  Specifies the level of the structure to which pbPrinter points.
    pbPrinter -  Points to a buffer that receives the PRINTER_INFO object.
    cbBuf     -  Size, in bytes of the array pbPrinter points to.
    pcbNeeded -  Points to a value which specifies the number of bytes copied
                 if the function succeeds or the number of bytes required if
                 cbBuf was too small.

Return Value:

    TRUE if the function succeeds and FALSE otherwise.  GetLastError() can be
    used to retrieve extended error information.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(( "NWSPL [GetPrinter] Level = %d\n", dwLevel ));
#endif

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }
    else if ( ( dwLevel != 1 ) && ( dwLevel != 2 ) && (dwLevel != 3 ))
    {
        SetLastError( ERROR_INVALID_LEVEL );
        return FALSE;
    }

    RpcTryExcept
    {
        err = NwrGetPrinter( (NWWKSTA_PRINTER_CONTEXT) hPrinter,
                             dwLevel,
                             pbPrinter,
                             cbBuf,
                             pcbNeeded );

        if ( !err )
        {
            if ( dwLevel == 1 )
                MarshallUpStructure( pbPrinter, PrinterInfo1Offsets, pbPrinter);
            else
                MarshallUpStructure( pbPrinter, PrinterInfo2Offsets, pbPrinter);
        }

    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;
}



BOOL
SetPrinter(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  pbPrinter,
    DWORD   dwCommand
)
/*++

Routine Description:

    The routine sets the specified by pausing printing, resuming printing, or
    clearing all print jobs.

Arguments:

    hPrinter  -  Handle of the printer
    dwLevel   -  Specifies the level of the structure to which pbPrinter points.
    pbPrinter -  Points to a buffer that supplies the PRINTER_INFO object.
    dwCommand -  Specifies the new printer state.

Return Value:

    TRUE if the function succeeds and FALSE otherwise.  GetLastError() can be
    used to retrieve extended error information.

--*/
{
    DWORD err = NO_ERROR;

    UNREFERENCED_PARAMETER( pbPrinter );

#if DBG
    IF_DEBUG(PRINT)
    {
        KdPrint(( "NWSPL [SetPrinter] Level = %d Command = %d\n",
                  dwLevel, dwCommand ));
    }
#endif

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }

    switch ( dwLevel )
    {
        case 0:
        case 1:
        case 2:
        case 3:
            break;

        default:
            SetLastError( ERROR_INVALID_LEVEL );
            return FALSE;
    }

    RpcTryExcept
    {
        err = NwrSetPrinter( (NWWKSTA_PRINTER_CONTEXT) hPrinter,
                             dwCommand );

    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;
}



BOOL
EnumPrintersW(
    DWORD   dwFlags,
    LPWSTR  pszName,
    DWORD   dwLevel,
    LPBYTE  pbPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
/*++

Routine Description:

    This routine enumerates the available providers, servers, printers
    depending on the given pszName.

Arguments:

    dwFlags    -  Printer type requested
    pszName    -  The name of the container object
    dwLevel    -  The structure level requested
    pbPrinter  -  Points to the array to receive the PRINTER_INFO objects
    cbBuf      -  Size, in bytes of pbPrinter
    pcbNeeded  -  Count of bytes needed
    pcReturned -  Count of PRINTER_INFO objects

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD  err = NO_ERROR;

#if DBG
    IF_DEBUG(PRINT)
    {
        KdPrint(("NWSPL [EnumPrinters] Flags = %d Level = %d",dwFlags,dwLevel));
        if ( pszName )
            KdPrint((" PrinterName = %ws\n", pszName ));
        else
            KdPrint(("\n"));
    }
#endif

    if ( (dwLevel != 1) && (dwLevel != 2) )
    {
        SetLastError( ERROR_INVALID_NAME );  // should be level, but winspool
                                             // is silly.
        return FALSE;
    }
    else if ( !pcbNeeded || !pcReturned )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    RpcTryExcept
    {
        *pcReturned = 0;
        *pcbNeeded = 0;

        if (  ( dwFlags & PRINTER_ENUM_NAME )
           && ( dwLevel == 1 )
           )
        {
            err = NwrEnumPrinters( NULL,
                                   pszName,
                                   pbPrinter,
                                   cbBuf,
                                   pcbNeeded,
                                   pcReturned );

            if ( !err )
            {
                DWORD i;
                for ( i = 0; i < *pcReturned; i++ )
                     MarshallUpStructure( pbPrinter + i*sizeof(PRINTER_INFO_1W),
                                          PrinterInfo1Offsets,
                                          pbPrinter );
            }
        }
        else
        {
            err = ERROR_INVALID_NAME;
        }
    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_NAME;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;
}


//
//  Handle structure
//  This structure was copied from \nw\svcdlls\nwwks\server\spool.c
//           to fix NT bug # 366632.
//
typedef struct _NWSPOOL {
    DWORD      nSignature;             // Signature
    DWORD      errOpenPrinter;         // OpenPrinter API will always return
                                       // success on known printers. This will
                                       // contain the error that we get
                                       // if something went wrong in the API.
    PVOID      pPrinter;               // Points to the corresponding printer
    HANDLE     hServer;                // Opened handle to the server
    struct _NWSPOOL  *pNextSpool;      // Points to the next handle
    DWORD      nStatus;                // Status
    DWORD      nJobNumber;             // StartDocPrinter/AddJob: Job Number
    HANDLE     hChangeEvent;           // WaitForPrinterChange: event to wait on
    DWORD      nWaitFlags;             // WaitForPrinterChange: flags to wait on
    DWORD      nChangeFlags;           // Changes that occurred to the printer
} NWSPOOL, *PNWSPOOL;



DWORD
StartDocPrinter(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  lpbDocInfo
)
/*++

Routine Description:

    This routine informs the print spooler that a document is to be spooled
    for printing.

Arguments:

    hPrinter   -  Handle of the printer
    dwLevel    -  Level of the structure pointed to by lpbDocInfo. Must be 1.
    lpbDocInfo -  Points to the DOC_INFO_1 object

Return Value:

    TRUE if the function succeeds, FALSE otherwise. The extended error
    can be retrieved through GetLastError().

--*/
{
    DWORD err;
    DOC_INFO_1 *pDocInfo1 = (DOC_INFO_1 *) lpbDocInfo;
    LPWSTR pszUser = NULL;
    BOOL fGateway = FALSE;

    DWORD PrintOption = NW_GATEWAY_PRINT_OPTION_DEFAULT;
    LPWSTR pszPreferredSrv = NULL;  

#if DBG
    IF_DEBUG(PRINT)
    {
        KdPrint(( "NWSPL [StartDocPrinter] " ));
        if ( pDocInfo1 )
        {
            if ( pDocInfo1->pDocName )
                KdPrint(("Document %ws", pDocInfo1->pDocName ));
            if ( pDocInfo1->pOutputFile )
                KdPrint(("OutputFile %ws", pDocInfo1->pOutputFile ));
            if ( pDocInfo1->pDatatype )
                KdPrint(("Datatype %ws", pDocInfo1->pDatatype ));
        }
        KdPrint(("\n"));
    }
#endif

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }
    else if ( dwLevel != 1 )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    // ignore the error, just use default value
    NwpGetUserInfo( &pszUser, &fGateway );
    if ( !fGateway ) {
        NwQueryInfo( &PrintOption, &pszPreferredSrv );  
        if (pszPreferredSrv) {
            LocalFree( pszPreferredSrv );
        }
    }
    RpcTryExcept
    {
        err = NwrStartDocPrinter( (NWWKSTA_PRINTER_CONTEXT) hPrinter,
                                  pDocInfo1? pDocInfo1->pDocName : NULL,
                                  pszUser,
                  PrintOption,
                                  fGateway );

    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    LocalFree( pszUser );

    if ( err )
        SetLastError( err );
    //
    // Can't do this, seems to break GSWN printing on multi-homed machines
    // Commenting out code change that tries to return the job id.
    //
    // else
    //    return ((PNWSPOOL) hPrinter)->nJobNumber;

    return err == NO_ERROR;
}



BOOL
WritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcbWritten
)
/*++

Routine Description:

    This routine informs the print spooler that the specified data should be
    written to the given printer.

Arguments:

    hPrinter   -  Handle of the printer object
    pBuf       -  Address of array that contains printer data
    cbBuf      -  Size, in bytes of pBuf
    pcbWritten -  Receives the number of bytes actually written to the printer

Return Value:

    TRUE if it succeeds, FALSE otherwise. Use GetLastError() to get extended
    error.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(( "NWSPL [WritePrinter]\n"));

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }
#endif

    RpcTryExcept
    {
        err = NwrWritePrinter( (NWWKSTA_PRINTER_CONTEXT) hPrinter,
                               pBuf,
                               cbBuf,
                               pcbWritten );
    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;
}



BOOL
AbortPrinter(
    HANDLE  hPrinter
)
/*++

Routine Description:

    This routine deletes a printer's spool file if the printer is configured
    for spooling.

Arguments:

    hPrinter - Handle of the printer object

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(( "NWSPL [AbortPrinter]\n"));

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }
#endif

    RpcTryExcept
    {
        err = NwrAbortPrinter( (NWWKSTA_PRINTER_CONTEXT) hPrinter );
    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;

}



BOOL
EndDocPrinter(
    HANDLE   hPrinter
)
/*++

Routine Description:

    This routine ends the print job for the given printer.

Arguments:

    hPrinter -  Handle of the printer object

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(( "NWSPL [EndDocPrinter]\n"));
#endif

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }

    RpcTryExcept
    {
        err = NwrEndDocPrinter( (NWWKSTA_PRINTER_CONTEXT) hPrinter );
    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;
}



BOOL
GetJob(
    HANDLE   hPrinter,
    DWORD    dwJobId,
    DWORD    dwLevel,
    LPBYTE   pbJob,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded
)
/*++

Routine Description:

    This routine retrieves print-job data for the given printer.

Arguments:

    hPrinter  -  Handle of the printer
    dwJobId   -  Job identifition number
    dwLevel   -  Data structure level of pbJob
    pbJob     -  Address of data-structure array
    cbBuf     -  Count of bytes in array
    pcbNeeded -  Count of bytes retrieved or required

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [GetJob] JobId = %d Level = %d\n", dwJobId, dwLevel));
#endif

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }
    else if (( dwLevel != 1 ) && ( dwLevel != 2 ))
    {
        SetLastError( ERROR_INVALID_LEVEL );
        return FALSE;
    }

    RpcTryExcept
    {
        err = NwrGetJob( (NWWKSTA_PRINTER_CONTEXT) hPrinter,
                         dwJobId,
                         dwLevel,
                         pbJob,
                         cbBuf,
                         pcbNeeded );

        if ( !err )
        {
            if ( dwLevel == 1 )
                MarshallUpStructure( pbJob, JobInfo1Offsets, pbJob );
            else
                MarshallUpStructure( pbJob, JobInfo2Offsets, pbJob );
        }
    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;

}



BOOL
EnumJobs(
    HANDLE  hPrinter,
    DWORD   dwFirstJob,
    DWORD   dwNoJobs,
    DWORD   dwLevel,
    LPBYTE  pbJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
/*++

Routine Description:

    This routine initializes the array of JOB_INFO_1 or JOB_INFO_2 structures
    with data describing the specified print jobs for the given printer.

Arguments:

    hPrinter    -  Handle of the printer
    dwFirstJob  -  Location of first job in the printer
    dwNoJobs    -  Number of jobs to enumerate
    dwLevel     -  Data structure level
    pbJob       -  Address of structure array
    cbBuf       -  Size of pbJob, in bytes
    pcbNeeded   -  Receives the number of bytes copied or required
    pcReturned  -  Receives the number of jobs copied

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [EnumJobs] Level = %d FirstJob = %d NoJobs = %d\n",
                 dwLevel, dwFirstJob, dwNoJobs));
#endif

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }
    else if ( ( dwLevel != 1 ) && ( dwLevel != 2 ) )
    {
        SetLastError( ERROR_INVALID_LEVEL );
        return FALSE;
    }

    RpcTryExcept
    {
        *pcReturned = 0;
        *pcbNeeded = 0;

        err = NwrEnumJobs( (NWWKSTA_PRINTER_CONTEXT) hPrinter,
                           dwFirstJob,
                           dwNoJobs,
                           dwLevel,
                           pbJob,
                           cbBuf,
                           pcbNeeded,
                           pcReturned );

        if ( !err )
        {
            DWORD i;
            DWORD cbStruct;
            DWORD_PTR *pOffsets;

            if ( dwLevel == 1 )
            {
                cbStruct = sizeof( JOB_INFO_1W );
                pOffsets = JobInfo1Offsets;
            }
            else  // dwLevel == 2
            {
                cbStruct = sizeof( JOB_INFO_2W );
                pOffsets = JobInfo2Offsets;
            }

            for ( i = 0; i < *pcReturned; i++ )
                 MarshallUpStructure( pbJob + i * cbStruct, pOffsets, pbJob );
        }

    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;

}



BOOL
SetJob(
    HANDLE  hPrinter,
    DWORD   dwJobId,
    DWORD   dwLevel,
    LPBYTE  pbJob,
    DWORD   dwCommand
)
/*++

Routine Description:

    This routine pauses, cancels, resumes, restarts the specified print job
    in the given printer. The function can also be used to set print job
    parameters such as job position, and so on.

Arguments:

    hPrinter  -  Handle of the printer
    dwJobId   -  Job indentification number
    dwLevel   -  Data structure level
    pbJob     -  Address of data structure
    dwCommand -  Specify the operation to be performed

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
    {
        KdPrint(("NWSPL [SetJob] Level = %d JobId = %d Command = %d\n",
                 dwLevel, dwJobId, dwCommand));
    }
#endif

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }
    else if ( ( dwLevel != 0 ) && ( dwLevel != 1 ) && ( dwLevel != 2 ) )
    {
        SetLastError( ERROR_INVALID_LEVEL );
        return FALSE;
    }
    else if ( ( dwLevel == 0 ) && ( pbJob != NULL ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    RpcTryExcept
    {
        NW_JOB_INFO NwJobInfo;

        if ( dwLevel == 1 )
        {
            NwJobInfo.nPosition = ((LPJOB_INFO_1W) pbJob)->Position;
            NwJobInfo.pUserName = ((LPJOB_INFO_1W) pbJob)->pUserName;
            NwJobInfo.pDocument = ((LPJOB_INFO_1W) pbJob)->pDocument;
        }
        else if ( dwLevel == 2 )
        {
            NwJobInfo.nPosition = ((LPJOB_INFO_2W) pbJob)->Position;
            NwJobInfo.pUserName = ((LPJOB_INFO_2W) pbJob)->pUserName;
            NwJobInfo.pDocument = ((LPJOB_INFO_2W) pbJob)->pDocument;
        }

        err = NwrSetJob( (NWWKSTA_PRINTER_CONTEXT) hPrinter,
                         dwJobId,
                         dwLevel,
                         dwLevel == 0 ? NULL : &NwJobInfo,
                         dwCommand );

    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;

}



BOOL
AddJob(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  pbAddJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
/*++

Routine Description:

    This routine returns a full path and filename of a file that can be used
    to store a print job.

Arguments:

    hPrinter  -  Handle of the printer
    dwLevel   -  Data structure level
    pbAddJob  -  Points to a ADD_INFO_1 structure
    cbBuf     -  Size of pbAddJob, in bytes
    pcbNeeded -  Receives the bytes copied or required

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD err;

    ADDJOB_INFO_1W TempBuffer;
    PADDJOB_INFO_1W OutputBuffer;
    DWORD OutputBufferSize;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(( "NWSPL [AddJob]\n"));
#endif

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }
    else if ( dwLevel != 1 )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // The output buffer size must be at least the size of the fixed
    // portion of the structure marshalled by RPC or RPC will not
    // call the server-side to get the pcbNeeded.  Use our own temporary
    // buffer to force RPC to call the server-side if output buffer
    // specified by the caller is too small.
    //
    if (cbBuf < sizeof(ADDJOB_INFO_1W)) {
        OutputBuffer = &TempBuffer;
        OutputBufferSize = sizeof(ADDJOB_INFO_1W);
    }
    else {
        OutputBuffer = (LPADDJOB_INFO_1W) pbAddJob;
        OutputBufferSize = cbBuf;
    }

    RpcTryExcept
    {
        err = NwrAddJob( (NWWKSTA_PRINTER_CONTEXT) hPrinter,
                         OutputBuffer,
                         OutputBufferSize,
                         pcbNeeded );

    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;
}



BOOL
ScheduleJob(
    HANDLE  hPrinter,
    DWORD   dwJobId
)
/*++

Routine Description:

    This routine informs the print spooler that the specified job can be
    scheduled for spooling.

Arguments:

    hPrinter -  Handle of the printer
    dwJobId  -  Job number that can be scheduled

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(( "NWSPL [ScheduleJob] JobId = %d\n", dwJobId ));
#endif

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return FALSE;
    }

    RpcTryExcept
    {
        err = NwrScheduleJob( (NWWKSTA_PRINTER_CONTEXT) hPrinter,
                              dwJobId );

    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;
}



DWORD
WaitForPrinterChange(
    HANDLE  hPrinter,
    DWORD   dwFlags
)
/*++

Routine Description:

    This function returns when one or more requested changes occur on a
    print server or if the function times out.

Arguments:

    hPrinter -  Handle of the printer to wait on
    dwFlags  -  A bitmask that specifies the changes that the application
                wishes to be notified of.

Return Value:

    Return a bitmask that indicates the changes that occurred.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [WaitForPrinterChange] Flags = %d\n", dwFlags));
#endif

    if ( hPrinter == &handleDummy )
    {
        SetLastError( ERROR_NO_NETWORK );
        return 0;
    }

    RpcTryExcept
    {
        err = NwrWaitForPrinterChange( (NWWKSTA_PRINTER_CONTEXT) hPrinter,
                                       &dwFlags );

    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept

    if ( err )
    {
        SetLastError( err );
        return 0;
    }

    return dwFlags;
}



BOOL
EnumPortsW(
    LPWSTR   pszName,
    DWORD    dwLevel,
    LPBYTE   pbPort,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded,
    LPDWORD  pcReturned
)
/*++

Routine Description:

    This function enumerates the ports available for printing on a
    specified server.

Arguments:

    pszName - Name of the server to enumerate on
    dwLevel - Structure level
    pbPort  - Address of array to receive the port information
    cbBuf   - Size, in bytes, of pbPort
    pcbNeeded  - Address to store the number of bytes needed or copied
    pcReturned - Address to store the number of entries copied

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD err = NO_ERROR;
    DWORD cb = 0;
    PNWPORT pNwPort;
    LPPORT_INFO_1W pPortInfo1;
    LPBYTE pEnd = pbPort + cbBuf;
    LPBYTE pFixedDataEnd = pbPort;
    BOOL FitInBuffer;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [EnumPorts]\n"));
#endif

    if ( dwLevel != 1 )
    {
        SetLastError( ERROR_INVALID_NAME );
        return FALSE;
    }
    else if ( !IsLocalMachine( pszName ) )
    {
        SetLastError( ERROR_INVALID_NAME );
        return FALSE;
    }

    EnterCriticalSection( &NwSplSem );

    pNwPort = pNwFirstPort;
    while ( pNwPort )
    {
        cb += sizeof(PORT_INFO_1W) + ( wcslen( pNwPort->pName)+1)*sizeof(WCHAR);
        pNwPort = pNwPort->pNext;
    }

    *pcbNeeded = cb;
    *pcReturned = 0;

    if ( cb <= cbBuf )
    {
        pEnd = pbPort + cbBuf;

        pNwPort = pNwFirstPort;
        while ( pNwPort )
        {
            pPortInfo1 = (LPPORT_INFO_1W) pFixedDataEnd;
            pFixedDataEnd += sizeof( PORT_INFO_1W );

            FitInBuffer = NwlibCopyStringToBuffer( pNwPort->pName,
                                                   wcslen( pNwPort->pName),
                                                   (LPCWSTR) pFixedDataEnd,
                                                   (LPWSTR *) &pEnd,
                                                   &pPortInfo1->pName );
            ASSERT( FitInBuffer );

            pNwPort = pNwPort->pNext;
            (*pcReturned)++;
        }
    }
    else
    {
        err = ERROR_INSUFFICIENT_BUFFER;
    }

    LeaveCriticalSection( &NwSplSem );

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;
}



BOOL
DeletePortW(
    LPWSTR  pszName,
    HWND    hWnd,
    LPWSTR  pszPortName
)
/*++

Routine Description:

    This routine deletes the port given on the server. A dialog can
    be displayed if needed.

Arguments:

    pszName - Name of the server for which the port should be deleted
    hWnd    - Parent window
    pszPortName - The name of the port to delete

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD err;
    BOOL fPortDeleted;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [DeletePort]\n"));
#endif

    if ( !IsLocalMachine( pszName ) )
    {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }

    fPortDeleted = DeletePortEntry( pszPortName );

    if ( fPortDeleted )
    {
        err = DeleteRegistryEntry( pszPortName );
    }
    else
    {
        err = ERROR_UNKNOWN_PORT;
    }

    if ( err )
        SetLastError( err );

    return err == NO_ERROR;

}



BOOL
ConfigurePortW(
    LPWSTR  pszName,
    HWND    hWnd,
    LPWSTR  pszPortName
)
/*++

Routine Description:

    This routine displays the port configuration dialog box
    for the given port on the given server.

Arguments:

    pszName - Name of the server on which the given port exist
    hWnd    - Parent window
    pszPortName - The name of the port to be configured

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

--*/
{
    DWORD nCurrentThreadId;
    DWORD nWindowThreadId;
    WCHAR szCaption[MAX_PATH];
    WCHAR szMessage[MAX_PATH];

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [ConfigurePort] PortName = %ws\n", pszPortName));
#endif

    if ( !IsLocalMachine( pszName ) )
    {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }
    else if ( !PortKnown( pszPortName ) )
    {
        SetLastError( ERROR_UNKNOWN_PORT );
        return FALSE;
    }

    nCurrentThreadId = GetCurrentThreadId();
    nWindowThreadId  = GetWindowThreadProcessId( hWnd, NULL );

    if ( !AttachThreadInput( nCurrentThreadId, nWindowThreadId, TRUE ))
        KdPrint(("[NWSPL] AttachThreadInput failed with %d.\n",GetLastError()));

    if ( LoadStringW( hmodNW,
                      IDS_NETWARE_PRINT_CAPTION,
                      szCaption,
                      sizeof( szCaption ) / sizeof( WCHAR )))
    {
        if ( LoadStringW( hmodNW,
                          IDS_NOTHING_TO_CONFIGURE,
                          szMessage,
                          sizeof( szMessage ) / sizeof( WCHAR )))
        {
            MessageBox( hWnd, szMessage, szCaption,
                        MB_OK | MB_ICONINFORMATION );
        }
        else
        {
            KdPrint(("[NWSPL] LoadString failed with %d.\n",GetLastError()));
        }
    }
    else
    {
        KdPrint(("[NWSPL] LoadString failed with %d.\n",GetLastError()));
    }

    if ( !AttachThreadInput( nCurrentThreadId, nWindowThreadId, FALSE ))
        KdPrint(("[NWSPL] DetachThreadInput failed with %d.\n",GetLastError()));

    return TRUE;
}

//------------------------------------------------------------------
//
// Print Provider Functions not supported by NetWare provider
//
//------------------------------------------------------------------

BOOL
AddPrinterConnectionW(
    LPWSTR  pszPrinterName
)
{
#if DBG
    IF_DEBUG(PRINT)
    {
        KdPrint(("NWSPL [AddPrinterConnection] PrinterName = %ws\n",
                pszPrinterName));
    }
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
EnumMonitorsW(
    LPWSTR   pszName,
    DWORD    dwLevel,
    LPBYTE   pbMonitor,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded,
    LPDWORD  pcReturned
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [EnumMonitors]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}


BOOL
AddPortW(
    LPWSTR  pszName,
    HWND    hWnd,
    LPWSTR  pszMonitorName
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [AddPort]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}


HANDLE
AddPrinterW(
    LPWSTR  pszName,
    DWORD   dwLevel,
    LPBYTE  pbPrinter
)

// Creates a print queue on the netware server and returns a handle to it
{
#ifdef NOT_USED

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [AddPrinterW]\n"));
#endif

    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
#else

   LPTSTR     pszPrinterName = NULL;
   LPTSTR     pszPServer = NULL;
   LPTSTR     pszQueue  =  NULL;
   HANDLE     hPrinter = NULL;
   DWORD      err;
   PPRINTER_INFO_2 pPrinterInfo;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [AddPrinterW]\n"));
#endif

   pPrinterInfo = (PPRINTER_INFO_2)pbPrinter;  

   
   if (dwLevel != 2)
      {
        err = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
      }


   if (!(pszPrinterName = (LPTSTR)LocalAlloc(LPTR, (wcslen(((PRINTER_INFO_2 *)pbPrinter)->pPrinterName)+1)* sizeof(WCHAR))))
      {
         err = ERROR_NOT_ENOUGH_MEMORY; 
         goto ErrorExit;
      }

      wcscpy(pszPrinterName,pPrinterInfo->pPrinterName);

   // PrinterName is the name represented as \\server\share
  //The pszPServer parameter could have multiple fields separated by semicolons

   
       if (  ( !ValidateUNCName( pszPrinterName ) )
       || ( (pszQueue = wcschr( pszPrinterName + 2, L'\\')) == NULL )
       || ( pszQueue == (pszPrinterName + 2) )
       || ( *(pszQueue + 1) == L'\0' )
       )
          {
             err =  ERROR_INVALID_NAME;
             goto ErrorExit;
          }
      


#if DBG
    IF_DEBUG(PRINT)
        KdPrint(( "NWSPL [AddPrinter] Name = %ws\n",pszPServer));
#endif

   if ( pszPrinterName == NULL  ) 
//PrinterName is a mandatory field but not the list of PServers
    {
#if DBG
            IF_DEBUG(PRINT)
            KdPrint(( "NWSPL [AddPrinter] Printername  not supplied\n" ));
#endif

        SetLastError( ERROR_INVALID_NAME );
        goto ErrorExit;
    }

   //Check to see if there is a port of the same name
   // If so, abort the addprinter operation. 
   // This code was commented earlier 

      if (PortExists(pszPrinterName, &err ) && !err )
         {
#if DBG
            IF_DEBUG(PRINT)
            KdPrint(( "NWSPL [AddPrinter], = %ws; Port exists with same name\n", pszPrinterName ));
#endif
            SetLastError(ERROR_ALREADY_ASSIGNED);
            goto ErrorExit;
         }
         

   // Put all the relevant information into the PRINTER_INFO_2 structure

    RpcTryExcept
    {
       err = NwrAddPrinter   ( NULL, 
                               (LPPRINTER_INFO_2W) pPrinterInfo,
                               (LPNWWKSTA_PRINTER_CONTEXT) &hPrinter
                             );
       if (!err)
       {
#if DBG
         IF_DEBUG(PRINT)
          KdPrint(( "NWSPL [AddPrinter] Name = %ws\n", pszPrinterName ));
#endif
    goto ErrorExit;
       }
    }
   RpcExcept(1)
   {
      DWORD code = RpcExceptionCode();
      err = NwpMapRpcError( code );
      goto ErrorExit;
   }
   RpcEndExcept
   if ( !pszPrinterName) 
      (void)  LocalFree((HLOCAL)pszPrinterName);
   
   return hPrinter;

ErrorExit:
    if ( !pszPrinterName) 
    (void)  LocalFree((HLOCAL)pszPrinterName);

         SetLastError( err);
    return (HANDLE)0x0;      
 
#endif // #ifdef NOT_USED
}

BOOL
DeletePrinter(
    HANDLE  hPrinter
)
{
#ifdef NOT_USED

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [DeletePrinter]\n"));
#endif

    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
#else
   LPWSTR pszPrinterName = NULL ; // Used to delete entry from registry
   DWORD err = NO_ERROR;
   DWORD DoesPortExist;

#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [DeletePrinter]\n"));
#endif

    pszPrinterName = (LPWSTR)LocalAlloc(LPTR,sizeof(WCHAR)*MAX_PATH);

   if(pszPrinterName == NULL)
      {
         err = ERROR_NOT_ENOUGH_MEMORY;
         return FALSE;
      }
   //
   // Just return success if the handle is a dummy one
   //
   if ( hPrinter == &handleDummy )
       {
#if DBG
          IF_DEBUG(PRINT)
          KdPrint(("NWSPL [DeletePrinter] Dummy handle \n"));
#endif
          SetLastError(ERROR_NO_NETWORK);
          return FALSE;
       }
    RpcTryExcept
    {  


        err = NwrDeletePrinter( NULL,
           // pszPrinterName,
                    (LPNWWKSTA_PRINTER_CONTEXT) &hPrinter );
        
    }
    RpcExcept(1)
    {
        DWORD code = RpcExceptionCode();

        if ( code == RPC_S_SERVER_UNAVAILABLE )
            err = ERROR_INVALID_HANDLE;
        else
            err = NwpMapRpcError( code );
    }
    RpcEndExcept
 
        if (!err && PortExists(pszPrinterName, &DoesPortExist) && DoesPortExist)
           {  
              
              if ( DeleteRegistryEntry (pszPrinterName))
                  (void) DeletePortEntry(pszPrinterName);
                  
           }
          
 
    if ( err )
        SetLastError( err );

    return err == NO_ERROR;

#endif // #ifdef NOT_USED
}


BOOL
DeletePrinterConnectionW(
    LPWSTR  pszName
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [DeletePrinterConnection]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}


BOOL
AddPrinterDriverW(
    LPWSTR  pszName,
    DWORD   dwLevel,
    LPBYTE  pbPrinter
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [AddPrinterDriver]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
EnumPrinterDriversW(
    LPWSTR   pszName,
    LPWSTR   pszEnvironment,
    DWORD    dwLevel,
    LPBYTE   pbDriverInfo,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded,
    LPDWORD  pcReturned
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [EnumPrinterDrivers]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
GetPrinterDriverW(
    HANDLE   hPrinter,
    LPWSTR   pszEnvironment,
    DWORD    dwLevel,
    LPBYTE   pbDriverInfo,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [GetPrinterDriver]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
GetPrinterDriverDirectoryW(
    LPWSTR   pszName,
    LPWSTR   pszEnvironment,
    DWORD    dwLevel,
    LPBYTE   pbDriverDirectory,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [GetPrinterDriverDirectory]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
DeletePrinterDriverW(
    LPWSTR  pszName,
    LPWSTR  pszEnvironment,
    LPWSTR  pszDriverName
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [DeletePrinterDriver]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
AddPrintProcessorW(
    LPWSTR  pszName,
    LPWSTR  pszEnvironment,
    LPWSTR  pszPathName,
    LPWSTR  pszPrintProcessorName
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [AddPrintProcessor]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
EnumPrintProcessorsW(
    LPWSTR   pszName,
    LPWSTR   pszEnvironment,
    DWORD    dwLevel,
    LPBYTE   pbPrintProcessorInfo,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded,
    LPDWORD  pcReturned
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [EnumPrintProcessors]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
EnumPrintProcessorDatatypesW(
    LPWSTR   pszName,
    LPWSTR   pszPrintProcessorName,
    DWORD    dwLevel,
    LPBYTE   pbDatatypes,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded,
    LPDWORD  pcReturned
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [EnumPrintProcessorDatatypes]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
GetPrintProcessorDirectoryW(
    LPWSTR   pszName,
    LPWSTR   pszEnvironment,
    DWORD    dwLevel,
    LPBYTE   pbPrintProcessorDirectory,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [GetPrintProcessorDirectory]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
StartPagePrinter(
    HANDLE  hPrinter
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [StartPagePrinter]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
EndPagePrinter(
    HANDLE  hPrinter
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [EndPagePrinter]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
ReadPrinter(
    HANDLE   hPrinter,
    LPVOID   pBuf,
    DWORD    cbBuf,
    LPDWORD  pcbRead
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [ReadPrinter]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

DWORD
GetPrinterDataW(
    HANDLE   hPrinter,
    LPWSTR   pszValueName,
    LPDWORD  pdwType,
    LPBYTE   pbData,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [GetPrinterData]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

DWORD
SetPrinterDataW(
    HANDLE  hPrinter,
    LPWSTR  pszValueName,
    DWORD   dwType,
    LPBYTE  pbData,
    DWORD   cbData
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [SetPrinterData]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
AddForm(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  pbForm
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [AddForm]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
DeleteFormW(
    HANDLE  hPrinter,
    LPWSTR  pszFormName
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [DeleteForm]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
GetFormW(
    HANDLE   hPrinter,
    LPWSTR   pszFormName,
    DWORD    dwLevel,
    LPBYTE   pbForm,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [GetForm]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
SetFormW(
    HANDLE  hPrinter,
    LPWSTR  pszFormName,
    DWORD   dwLevel,
    LPBYTE  pbForm
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [SetForm]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
EnumForms(
    HANDLE   hPrinter,
    DWORD    dwLevel,
    LPBYTE   pbForm,
    DWORD    cbBuf,
    LPDWORD  pcbNeeded,
    LPDWORD  pcReturned
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [EnumForms]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}


HANDLE
CreatePrinterIC(
    HANDLE     hPrinter,
    LPDEVMODE  pDevMode
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [CreatePrinterIC]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
PlayGdiScriptOnPrinterIC(
    HANDLE  hPrinterIC,
    LPBYTE  pbIn,
    DWORD   cbIn,
    LPBYTE  pbOut,
    DWORD   cbOut,
    DWORD   ul
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [PlayGdiScriptOnPrinterIC]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
DeletePrinterIC(
    HANDLE  hPrinterIC
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [DeletePrinterIC]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

DWORD
PrinterMessageBoxW(
    HANDLE  hPrinter,
    DWORD   dwError,
    HWND    hWnd,
    LPWSTR  pszText,
    LPWSTR  pszCaption,
    DWORD   dwType
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [PrinterMessageBox]\n"));
#endif

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
AddMonitorW(
    LPWSTR  pszName,
    DWORD   dwLevel,
    LPBYTE  pbMonitorInfo
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [AddMonitor]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
DeleteMonitorW(
    LPWSTR  pszName,
    LPWSTR  pszEnvironment,
    LPWSTR  pszMonitorName
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [DeleteMonitor]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

BOOL
DeletePrintProcessorW(
    LPWSTR  pszName,
    LPWSTR  pszEnvironment,
    LPWSTR  pszPrintProcessorName
)
{
#if DBG
    IF_DEBUG(PRINT)
        KdPrint(("NWSPL [DeletePrintProcessor]\n"));
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

//------------------------------------------------------------------
//
// Print Provider Miscellaneous Functions
//
//------------------------------------------------------------------

VOID
NwpGetUserInfo(
    LPWSTR *ppszUser,
    BOOL   *pfGateway
)
/*++

Routine Description:

    Get the user information of the impersonating client. 

Arguments:

    ppszUser - A pointer to buffer to store the Unicode string if 
               the impersonated client's user name can be looked up
               successfully. If the conversion was unsuccessful, it points 
               to NULL.

    pfGateway - A pointer to a boolean to store whether the user is
               printing through a gateway or not. We assume that
               if the user sid and the current logon user sid is not
               the same, then the user is printing through gateway.
               Else the user is printing locally.

Return Value:

    None.

--*/
{
    DWORD err;
    LPWSTR pszUserSid = NULL;
 //   LPWSTR pszLogonUserSid = NULL;    //Removed for Multi-user code merge
                                        //Terminal Server doesn't user this varible
                                        //There is no single "Logon User" in Terminal Server

    //
    // If any error occurs while trying to get the username, just
    // assume no user name and not gateway printing.
    //
    *pfGateway = TRUE;
    *ppszUser = NULL;

    if (  ((err = NwpGetThreadUserInfo( ppszUser, &pszUserSid )) == NO_ERROR)
//          && ((err = NwpGetLogonUserInfo( &pszLogonUserSid ))) == NO_ERROR) //Removed from Multi-user code merge
       ) {
         if ( ThreadIsInteractive() ) {
             *pfGateway = FALSE;
         }
         else {
             *pfGateway = TRUE;
         }

#if DBG
            IF_DEBUG(PRINT)
            KdPrint(("NwpGetUserInfo: Thread User= %ws, Thread SID = %ws,\nfGateway = %d\n",
                     *ppszUser, pszUserSid, *pfGateway ));
#endif

//        } else {
//            if ( _wcsicmp( pszUserSid, pszLogonUserSid ) == 0 ) {
//                *pfGateway = FALSE;
//            }

//#if DBG
//            IF_DEBUG(PRINT)
//            KdPrint(("NwpGetUserInfo: Thread User= %ws, Thread SID = %ws,\nCurrent SID = %ws fGateway = %d\n",
//                     *ppszUser, pszUserSid, pszLogonUserSid, *pfGateway ));
//#endif
//        }

        LocalFree( pszUserSid );
    }

}

#define SIZE_OF_TOKEN_INFORMATION   \
     sizeof( TOKEN_USER )               \
     + sizeof( SID )                    \
     + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES

DWORD
NwpGetThreadUserInfo(
    LPWSTR  *ppszUser,
    LPWSTR  *ppszUserSid
)
/*++

Routine Description:

    Get the user name and user sid string of the impersonating client.

Arguments:

    ppszUser - A pointer to buffer to store the Unicode string 
               if the impersonated client's can be looked up. If the
               lookup was unsuccessful, it points to NULL.

    ppszUserSid - A pointer to buffer to store the string if the impersonated
               client's SID can be expanded successfully into unicode string.
               If the conversion was unsuccessful, it points to NULL.

Return Value:

    The error code.

--*/
{
    DWORD       err;
    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
    ULONG       ReturnLength;

    *ppszUser = NULL;
    *ppszUserSid = NULL;

    // We can use OpenThreadToken because this server thread
    // is impersonating a client

    if ( !OpenThreadToken( GetCurrentThread(),
                           TOKEN_READ,
                           TRUE,  /* Open as self */
                           &TokenHandle ))
    {
#if DBG
        IF_DEBUG(PRINT)
            KdPrint(("NwpGetThreadUserInfo: OpenThreadToken failed: Error %d\n",
                      GetLastError()));
#endif
        return(GetLastError());
    }

    // notice that we've allocated enough space for the
    // TokenInformation structure. so if we fail, we
    // return a NULL pointer indicating failure


    if ( !GetTokenInformation( TokenHandle,
                               TokenUser,
                               TokenInformation,
                               sizeof( TokenInformation ),
                               &ReturnLength ))
    {
#if DBG
        IF_DEBUG(PRINT)
            KdPrint(("NwpGetThreadUserInfo: GetTokenInformation failed: Error %d\n",
                      GetLastError()));
#endif
        return(GetLastError());
    }

    CloseHandle( TokenHandle );

    // convert the Sid (pointed to by pSid) to its
    // equivalent Unicode string representation.

    err = NwpGetUserNameFromSid( ((PTOKEN_USER)TokenInformation)->User.Sid,
                                  ppszUser );
    err = err? err : NwpConvertSid( ((PTOKEN_USER)TokenInformation)->User.Sid,
                                    ppszUserSid );

    if ( err )
    {
        if ( *ppszUser )
            LocalFree( *ppszUser );

        if ( *ppszUserSid )
            LocalFree( *ppszUserSid );
    }

    return err;
}

DWORD
NwpGetUserNameFromSid(
    PSID pUserSid,
    LPWSTR *ppszUserName
)
/*++

Routine Description:

    Lookup the user name given the user SID.

Arguments:

    pUserSid - Points to the user sid to be looked up

    ppszUserName - A pointer to buffer to store the string if the impersonated
               client's SID can be expanded successfully into unicode string.
               If the conversion was unsuccessful, it points to NULL.

Return Value:

    The error code.

--*/
{
    NTSTATUS ntstatus;

    LSA_HANDLE hlsa;
    OBJECT_ATTRIBUTES oa;
    SECURITY_QUALITY_OF_SERVICE sqos;
    PLSA_REFERENCED_DOMAIN_LIST plsardl = NULL;
    PLSA_TRANSLATED_NAME plsatn = NULL;

    sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = FALSE;
    InitializeObjectAttributes( &oa, NULL, 0L, NULL, NULL );
    oa.SecurityQualityOfService = &sqos;

    ntstatus = LsaOpenPolicy( NULL,
                              &oa,
                              POLICY_LOOKUP_NAMES,
                              &hlsa );

    if ( NT_SUCCESS( ntstatus ))
    {
        ntstatus = LsaLookupSids( hlsa,
                                  1,
                                  &pUserSid,
                                  &plsardl,
                                  &plsatn );

        if ( NT_SUCCESS( ntstatus ))
        {
            UNICODE_STRING *pUnicodeStr = &((*plsatn).Name);

            *ppszUserName = LocalAlloc( LMEM_ZEROINIT, 
                                        pUnicodeStr->Length+sizeof(WCHAR));

            if ( *ppszUserName != NULL )
            {
                memcpy( *ppszUserName, pUnicodeStr->Buffer, pUnicodeStr->Length );
            }
            else
            {
                ntstatus = STATUS_NO_MEMORY;
            }

            LsaFreeMemory( plsardl );
            LsaFreeMemory( plsatn );
        }
#if DBG
        else
        {
            KdPrint(("NwpGetUserNameFromSid: LsaLookupSids failed: Error = %d\n",
                    GetLastError()));
        }
#endif

        LsaClose( hlsa );
     }
#if DBG
     else
     {
        KdPrint(("NwpGetUserNameFromSid: LsaOpenPolicy failed: Error = %d\n",
                GetLastError()));
     }
#endif

    return RtlNtStatusToDosError( ntstatus );

}

DWORD
NwpGetLogonUserInfo(
    LPWSTR  *ppszUserSid
)
/*++

Routine Description:

    Get the logon user sid string from the registry.

Arguments:

    ppszUserSid - On return, this points to the current logon user
                  sid string. 

Return Value:

    The error code.

--*/
{
    DWORD err;
    HKEY WkstaKey;

    LPWSTR CurrentUser = NULL;

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters to get the sid of the CurrentUser
    //
    err = RegOpenKeyExW(
              HKEY_LOCAL_MACHINE,
              NW_WORKSTATION_REGKEY,
              REG_OPTION_NON_VOLATILE,
              KEY_READ,
              &WkstaKey
              );

    if ( err == NO_ERROR) {

        //
        // Read the current user SID string so that we
        // know which key is the current user key to open.
        //
        err = NwReadRegValue(
                  WkstaKey,
                  NW_CURRENTUSER_VALUENAME,
                  &CurrentUser
                  );

        RegCloseKey( WkstaKey );

        if ( err == NO_ERROR) {
           *ppszUserSid = CurrentUser;
        }
    }

    return(err);
}


#define SIZE_OF_STATISTICS_TOKEN_INFORMATION    \
     sizeof( TOKEN_STATISTICS ) 

DWORD
ThreadIsInteractive(
    VOID
)
/*++

Routine Description:

    Determines if this is an "Interactive" logon thread

Arguments:

    none

Return Value:

    TRUE - Thread is interactive
    FALSE - Thread is not interactive

--*/
{
    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ SIZE_OF_STATISTICS_TOKEN_INFORMATION ];
    WCHAR       LogonIdKeyName[NW_MAX_LOGON_ID_LEN];

    ULONG       ReturnLength;
    LUID        LogonId;
    LONG        RegError;
    HKEY        InteractiveLogonKey;
    HKEY        OneLogonKey;


    // We can use OpenThreadToken because this server thread
    // is impersonating a client

    if ( !OpenThreadToken( GetCurrentThread(),
                           TOKEN_READ,
                           TRUE,  /* Open as self */
                           &TokenHandle ))
    {
#if DBG
        IF_DEBUG(PRINT)
            KdPrint(("ThreadIsInteractive: OpenThreadToken failed: Error %d\n",
                      GetLastError()));
#endif
        return FALSE;
    }

    // notice that we've allocated enough space for the
    // TokenInformation structure. so if we fail, we
    // return a NULL pointer indicating failure


    if ( !GetTokenInformation( TokenHandle,
                               TokenStatistics,
                               TokenInformation,
                               sizeof( TokenInformation ),
                               &ReturnLength ))
    {
#if DBG
        IF_DEBUG(PRINT)
            KdPrint(("ThreadIsInteractive: GetTokenInformation failed: Error %d\n",
                      GetLastError()));
#endif
        return FALSE;
    }

    CloseHandle( TokenHandle );

    LogonId = ((PTOKEN_STATISTICS)TokenInformation)->AuthenticationId;

    RegError = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_INTERACTIVE_LOGON_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ,
                   &InteractiveLogonKey
                   );

    if (RegError != ERROR_SUCCESS) {
#if DBG
        IF_DEBUG(PRINT)
            KdPrint(("ThreadIsInteractive: RegOpenKeyExW failed: Error %d\n",
                      GetLastError()));
#endif
        return FALSE;
    }

    NwLuidToWStr(&LogonId, LogonIdKeyName);

    //
    // Open the <LogonIdKeyName> key under Logon
    //
    RegError = RegOpenKeyExW(
                   InteractiveLogonKey,
                   LogonIdKeyName,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ,
                   &OneLogonKey
                   );

    if ( RegError == ERROR_SUCCESS ) {
        (void) RegCloseKey(OneLogonKey);
        (void) RegCloseKey(InteractiveLogonKey);
        return TRUE;  /* We found it */
    }
    else {
        (void) RegCloseKey(InteractiveLogonKey);
        return FALSE;  /* We did not find it */
    }

}

DWORD
NwpCitrixGetUserInfo(
    LPWSTR  *ppszUserSid
)
/*++

Routine Description:

    Get the user sid string of the client.

Arguments:

    ppszUserSid - A pointer to buffer to store the string.

Return Value:

    The error code.

--*/
{
    DWORD       err;
    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
    ULONG       ReturnLength;

    *ppszUserSid = NULL;

    // We can use OpenThreadToken because this server thread
    // is impersonating a client

    if ( !OpenThreadToken( GetCurrentThread(),
                           TOKEN_READ,
                           TRUE,  /* Open as self */
                           &TokenHandle ))
    {
        err = GetLastError();
    if ( err == ERROR_NO_TOKEN ) {
            if ( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_READ,
                           &TokenHandle )) {
#if DBG
               IF_DEBUG(PRINT)
               KdPrint(("NwpGetThreadUserInfo: OpenThreadToken failed: Error %d\n",
                      GetLastError()));
#endif

               return(GetLastError());
            }
        }
    else
           return( err );
    }

    // notice that we've allocated enough space for the
    // TokenInformation structure. so if we fail, we
    // return a NULL pointer indicating failure


    if ( !GetTokenInformation( TokenHandle,
                               TokenUser,
                               TokenInformation,
                               sizeof( TokenInformation ),
                               &ReturnLength ))
    {
#if DBG
        IF_DEBUG(PRINT)
            KdPrint(("NwpGetThreadUserInfo: GetTokenInformation failed: Error %d\n",
                      GetLastError()));
#endif
        return(GetLastError());
    }

    CloseHandle( TokenHandle );

    // convert the Sid (pointed to by pSid) to its
    // equivalent Unicode string representation.

    err = NwpConvertSid( ((PTOKEN_USER)TokenInformation)->User.Sid,
                                    ppszUserSid );

    if ( err )
    {
        if ( *ppszUserSid )
            LocalFree( *ppszUserSid );
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\client\nwshui.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nwshui.cxx

Abstract:

    This module implements the context menu actions of shell extension classes.

Author:

    Yi-Hsin Sung (yihsins)  25-Oct-1995

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commctrl.h>
#include <shellapi.h>
#include <shlobj.h>
#define  DONT_WANT_SHELLDEBUG
#include <shlobjp.h>
#include <winnetwk.h>
#include <npapi.h>
#include <ntddnwfs.h>
#include <ndsapi32.h>
#include <nwapi.h>
#include <nwwks.h>
#include <nwmisc.h>
//extern "C"
//{
#include "nwutil.h"
//}

#include "nwshcmn.h"
#include "nwshrc.h"

extern "C"
{
NTSTATUS
NwNdsOpenRdrHandle(
    OUT PHANDLE  phandleRdr );
}

#define MAX_ONE_CONN_INFORMATION_SIZE  512
#define NW_ENUM_EXTRA_BYTES            256
#define GLOBAL_WHOAMI_REFRESH_INTERVAL 30000   // in milliseconds, Win95 uses 10000

DWORD
LogoutFromServer(
    LPWSTR pszServer,
    PBOOL  pfDisconnected
);

BOOL
CALLBACK
GlobalWhoAmIDlgProc(
    HWND       hwndDlg,
    UINT       msg,
    WPARAM  wParam,
    LPARAM  lParam );

VOID
GetConnectionStatusString(
    PCONN_STATUS pConnStatus,
    LPBYTE       Buffer,
    DWORD        nSize
);

HRESULT
NWUIWhoAmI(
    HWND hParent,
    LPNETRESOURCE pNetRes
)
{
    DWORD  err = NO_ERROR;
    DWORD_PTR  ResumeKey = 0;
    LPBYTE pBuffer = NULL;
    DWORD  EntriesRead = 0;
    DWORD  dwMessageId;
    WCHAR  szUserName[MAX_PATH+1] = L"";
    WCHAR  szConnType[128];
    WCHAR  szRemoteName[MAX_PATH + 1];

    szConnType[0] = 0;

    if ( pNetRes->dwDisplayType == RESOURCEDISPLAYTYPE_SERVER )
    {
        // Need to extract the server name from full UNC path
        NwExtractServerName( pNetRes->lpRemoteName, szRemoteName );
        dwMessageId = IDS_MESSAGE_NOT_ATTACHED;
    }
    else  // NDS container name
    {
        // Need to extract the tree name from the full UNC path
        szRemoteName[0] = TREECHAR;
        NwExtractTreeName( pNetRes->lpRemoteName, szRemoteName+1);
        dwMessageId = IDS_MESSAGE_NOT_ATTACHED_TO_TREE;
    }

    err = NwGetConnectionStatus( szRemoteName,
                                 &ResumeKey,
                                 &pBuffer,
                                 &EntriesRead );

    if ( err == NO_ERROR  && EntriesRead > 0 )
        // For trees, we'll get more than one entry
    {
        PCONN_STATUS pConnStatus = (PCONN_STATUS) pBuffer;
        LPWSTR pszStart = szConnType;
        DWORD  nSize = sizeof(szConnType)/sizeof(WCHAR);

        if ( EntriesRead > 1 && szRemoteName[0] == TREECHAR )
        {
            // If there is more than one entry for trees,
            // then we need to find one entry where username is not null
            // and the login type is NDS.
            // If we cannot find one, then just use the first one.

            DWORD i;
            PCONN_STATUS pConnStatusTmp = pConnStatus;
            PCONN_STATUS pConnStatusUser = NULL;
            PCONN_STATUS pConnStatusNoUser = NULL;

            for ( i = 0; i < EntriesRead ; i++ )
            {
                 if ( pConnStatusTmp->fNds )
                 {
                     pConnStatusNoUser = pConnStatusTmp;

                     if (  ( pConnStatusTmp->pszUserName != NULL )
                        && (  ( pConnStatusTmp->dwConnType == NW_CONN_NDS_AUTHENTICATED_NO_LICENSE )
                           || ( pConnStatusTmp->dwConnType == NW_CONN_NDS_AUTHENTICATED_LICENSED )
                           )
                        )
                     {
                         // Found it
                         pConnStatusUser = pConnStatusTmp;
                         break;
                     }
                 }

                 // Continue with the next item
                 pConnStatusTmp = (PCONN_STATUS) ( (DWORD_PTR) pConnStatusTmp
                                         + pConnStatusTmp->dwTotalLength);
            }

            if ( pConnStatusUser )  // found one nds entry with a user name
                pConnStatus = pConnStatusUser;
            else if ( pConnStatusNoUser ) // use an nds entry with no user name
                pConnStatus = pConnStatusNoUser;
            // else use the first entry

        }

        if (  szRemoteName[0] == TREECHAR    // A tree
           || !pConnStatus->fPreferred       // A server but not preferred
           )
        {
            // Show this conneciton only if this is a tree or if this is
            // not a implicit connection to the preferred server.

            dwMessageId = pNetRes->dwDisplayType == RESOURCEDISPLAYTYPE_SERVER ?
                          IDS_MESSAGE_ATTACHED : IDS_MESSAGE_ATTACHED_TO_TREE;

            if ( pConnStatus->pszUserName )
            {
                wcscpy( szUserName, pConnStatus->pszUserName );
            }

            if ( pConnStatus->fNds )  // NDS
            {
                LoadString( ::hmodNW, IDS_LOGIN_TYPE_NDS, pszStart, nSize );
                nSize -= wcslen( pszStart );
                pszStart += wcslen( pszStart);

            }
            else  // Bindery
            {
                LoadString( ::hmodNW, IDS_LOGIN_TYPE_BINDERY, pszStart, nSize );
                nSize -= wcslen( pszStart );
                pszStart += wcslen( pszStart);
            }

            LoadString( ::hmodNW, IDS_LOGIN_STATUS_SEPARATOR, pszStart, nSize );
            nSize -= wcslen( pszStart );
            pszStart += wcslen( pszStart);

            GetConnectionStatusString( pConnStatus, (LPBYTE) pszStart, nSize );
        }
    }

    if ( err == NO_ERROR )
    {
        // Popup the message now.
        ::MsgBoxPrintf( hParent,
                        dwMessageId,
                        IDS_TITLE_WHOAMI,
                        MB_OK | MB_SETFOREGROUND | MB_ICONINFORMATION,
                        szRemoteName[0] == TREECHAR? szRemoteName + 1 : szRemoteName,
                        szUserName,
                        szConnType );
    }
    else  // error occurred
    {
        ::MsgBoxErrorPrintf( hParent,
                             IDS_MESSAGE_CONNINFO_ERROR,
                             IDS_TITLE_WHOAMI,
                             MB_OK | MB_SETFOREGROUND | MB_ICONSTOP,
                             err,
                             NULL );
    }

    if ( pBuffer != NULL )
    {
        LocalFree( pBuffer );
        pBuffer = NULL;
    }

    return NOERROR;
}

VOID
GetConnectionStatusString(
    PCONN_STATUS pConnStatus,
    LPBYTE       Buffer,
    DWORD        nSize
)
{
    LPWSTR pszStart = (LPWSTR) Buffer;
    DWORD  dwMessageId = 0;

    if ( pConnStatus->fNds )  // NDS
    {
        if ( pConnStatus->dwConnType == NW_CONN_NOT_AUTHENTICATED )
        {
            dwMessageId = IDS_LOGIN_STATUS_NOT_AUTHENTICATED;
        }
        else if ( pConnStatus->dwConnType == NW_CONN_DISCONNECTED )
        {
            dwMessageId = IDS_LOGIN_STATUS_NOT_ATTACHED;
        }
        else  // authenticated, licensed or unlicensed
        {
            LoadString( ::hmodNW, IDS_LOGIN_STATUS_AUTHENTICATED,
                        pszStart, nSize );
            nSize -= wcslen( pszStart );
            pszStart += wcslen( pszStart);

            if ( pConnStatus->dwConnType == NW_CONN_NDS_AUTHENTICATED_LICENSED )
                dwMessageId = IDS_LOGIN_STATUS_LICENSED;
            else  // NW_CONN_NDS_AUTHENTICATED_NO_LICENSE
                dwMessageId = IDS_LOGIN_STATUS_NOT_LICENSED;
        }
    }
    else  // Bindery
    {
        if ( pConnStatus->dwConnType == NW_CONN_BINDERY_LOGIN )
            dwMessageId = IDS_LOGIN_STATUS_LOGGED_IN;
        else if ( pConnStatus->dwConnType == NW_CONN_DISCONNECTED )
            dwMessageId = IDS_LOGIN_STATUS_NOT_ATTACHED;
        else
            dwMessageId = IDS_LOGIN_STATUS_ATTACHED_ONLY;
    }

    LoadString( ::hmodNW, dwMessageId, pszStart, nSize );
}

HRESULT
NWUIGlobalWhoAmI(
    HWND hParent
)
{
    ::DialogBoxParam( ::hmodNW,
                      MAKEINTRESOURCE(DLG_GLOBAL_WHOAMI),
                      hParent,
                      (DLGPROC) ::GlobalWhoAmIDlgProc,
                      NULL );

    return NOERROR;
}

HRESULT
NWUILogOut(
    HWND hParent,
    LPNETRESOURCE pNetRes,
    PBOOL pfDisconnected
)
{
    DWORD err = NO_ERROR;
    WCHAR szServer[MAX_PATH+1];
    BOOL  fAttached;
    BOOL  fAuthenticated;
    DWORD dwMessageId;

    *pfDisconnected = FALSE;

    // Need to extract the server name from full UNC path
    NwExtractServerName( pNetRes->lpRemoteName, szServer );

    err = NwIsServerOrTreeAttached( szServer, &fAttached, &fAuthenticated );

    if ( err == NO_ERROR && !fAttached )
    {
        dwMessageId = IDS_MESSAGE_NOT_ATTACHED;
    }
    else if ( err == NO_ERROR ) // attached
    {
        int nRet = ::MsgBoxPrintf( hParent,
                                   IDS_MESSAGE_LOGOUT_CONFIRM,
                                   IDS_TITLE_LOGOUT,
                                   MB_YESNO | MB_SETFOREGROUND | MB_ICONQUESTION);

        if ( nRet != IDYES )
            return NOERROR;

        err = LogoutFromServer( szServer, pfDisconnected );

        if ( err == NO_ERROR )
            dwMessageId = IDS_MESSAGE_DETACHED;
        else
            dwMessageId = IDS_MESSAGE_LOGOUT_FAILED;
    }
    else // error occurred
    {
        ::MsgBoxErrorPrintf( hParent,
                             IDS_MESSAGE_CONNINFO_ERROR,
                             IDS_TITLE_LOGOUT,
                             MB_OK | MB_SETFOREGROUND | MB_ICONSTOP,
                             err,
                             NULL );

        return NOERROR;
    }

    ::MsgBoxPrintf( hParent,
                    dwMessageId,
                    IDS_TITLE_LOGOUT,
                    MB_OK | MB_SETFOREGROUND | MB_ICONINFORMATION );

    return NOERROR;
}

DWORD
LogoutFromServer(
    LPWSTR pszServer,
    PBOOL  pfDisconnected
)
{
    DWORD  err = NO_ERROR;
    HANDLE EnumHandle = (HANDLE) NULL;

    LPNETRESOURCE  NetR = NULL;
    LPNETRESOURCEW SavePtr;

    DWORD BytesNeeded = MAX_ONE_NETRES_SIZE;
    DWORD EntriesRead = 0;
    DWORD i;

    *pfDisconnected = FALSE;

    err = NPOpenEnum( RESOURCE_CONNECTED,
                      0,
                      0,
                      NULL,
                      &EnumHandle );

    if ( err != NO_ERROR)
    {
        EnumHandle = (HANDLE) NULL;
        goto CleanExit;
    }

    //
    // Allocate buffer to get server list.
    //
    if ((NetR = (LPNETRESOURCE) LocalAlloc( 0, BytesNeeded )) == NULL)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }

    do {

        EntriesRead = 0xFFFFFFFF;          // Read as many as possible

        err = NwEnumConnections( EnumHandle,
                                 &EntriesRead,
                                 (LPVOID) NetR,
                                 &BytesNeeded,
                                 TRUE );


        if ( err == WN_SUCCESS)
        {
            SavePtr = NetR;

            for (i = 0; i < EntriesRead; i++, NetR++)
            {
                BYTE Buffer[MAX_ONE_CONN_INFORMATION_SIZE];
                BOOL fImplicit;
                LPWSTR pszCurrentServer;

                fImplicit = FALSE;

                if ( NwIsNdsSyntax( NetR->lpRemoteName))
                {
                    // For Nds name, the server name might not be in the full UNC name.
                    // Hence we need to get the server name from the Rdr.

                    DWORD err1 = NwGetConnectionInformation(
                                     NetR->lpLocalName? NetR->lpLocalName : NetR->lpRemoteName,
                                     Buffer,
                                     sizeof(Buffer));

                    if ( err1 != NO_ERROR )
                        continue;   // continue with the next entry if error occurred

                    pszCurrentServer = ((PCONN_INFORMATION) Buffer)->HostServer;

                    // Need to NULL terminate the server name, this will probably used the space
                    // occupied by UserName but since we are not using it, it is probably ok.
                    LPWSTR pszTemp = (LPWSTR) ((DWORD_PTR) pszCurrentServer
                                              + ((PCONN_INFORMATION) Buffer)->HostServerLength );
                    *pszTemp = 0;

                }
                else   // in the form \\server\sys
                {
                    LPWSTR pszTemp;
                    wcscpy( (LPWSTR) Buffer, NetR->lpRemoteName + 2 );  // go past two backslashes

                    if ( pszTemp = wcschr( (LPWSTR) Buffer, L'\\' ))
                        *pszTemp = 0;
                    else
                    {
                        // The remote name contains only \\server, hence if the local name
                        // is null, this is a implicit connection
                        if ( NetR->lpLocalName == NULL )
                            fImplicit = TRUE;
                    }

                    pszCurrentServer = (LPWSTR) Buffer;
                }


                if ( _wcsicmp( pszCurrentServer, pszServer ) == 0 )
                {

                    do {

                        // for implicit connections, we need to try and disconnect until
                        // we deleted all the implicit connections, i.e. until we
                        // get the invalid handle error

                        // NOTE: If we don't pass in CONNECT_UPDATE_PROFILE, shell won't update
                        // the windows that got disconnected. What do we want to do here?
                        err = WNetCancelConnection2(
                                  NetR->lpLocalName? NetR->lpLocalName : NetR->lpRemoteName,
                                  0, // CONNECT_UPDATE_PROFILE,
                                  TRUE );

                        if ( err == NO_ERROR )
                            *pfDisconnected = TRUE;

                    } while ( fImplicit && ( err == NO_ERROR));

                    if ( err == ERROR_INVALID_HANDLE )
                    {
                        // implicit connection will sometimes return this if the explicit connection
                        // is already disconnected
                        err =  NO_ERROR;
                    }

                    if ( err != NO_ERROR )
                    {
                        NetR = SavePtr;
                        goto CleanExit;
                    }
                }
            }

            NetR = SavePtr;
        }
        else if ( err != WN_NO_MORE_ENTRIES)
        {
            if ( err == WN_MORE_DATA)
            {

                //
                // Original buffer was too small.  Free it and allocate
                // the recommended size and then some to get as many
                // entries as possible.
                //

                (void) LocalFree((HLOCAL) NetR);

                BytesNeeded += NW_ENUM_EXTRA_BYTES;

                if ((NetR = (LPNETRESOURCE) LocalAlloc( 0, BytesNeeded )) == NULL)
                {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    goto CleanExit;
                }
            }
            else
            {
                goto CleanExit;
            }
        }

    } while (err != WN_NO_MORE_ENTRIES);

    if ( err == WN_NO_MORE_ENTRIES)
        err = NO_ERROR;

CleanExit:

    if (EnumHandle != (HANDLE) NULL)
        (void) NPCloseEnum( EnumHandle);

    if (NetR != NULL)
    {
        (void) LocalFree( (HLOCAL) NetR);
        NetR = NULL;
    }

    return err;
}

HRESULT
NWUIAttachAs(
    HWND hParent,
    LPNETRESOURCE pNetRes
)
{
    DWORD err = NO_ERROR;
    WCHAR szServerName[MAX_PATH+1];
    BOOL  fAttached;
    BOOL  fAuthenticated;

    // First, see if we are attached to the server.
    // Note, Attach as menu will be disabled on the NDS servers that we are already logged into.

    // Need to extract the server name from full UNC path
    szServerName[0] = szServerName[1] = L'\\';
    NwExtractServerName( pNetRes->lpRemoteName, szServerName + 2 );

    err = NwIsServerOrTreeAttached( szServerName + 2, &fAttached, &fAuthenticated );

    if ( err == NO_ERROR && fAttached && fAuthenticated )
    {
        // Already attached and authenticated to the server.
        // So, ask the user if he wants to log out first.

        int nRet = ::MsgBoxPrintf( hParent,
                                   IDS_MESSAGE_LOGOUT_QUESTION,
                                   IDS_TITLE_LOGOUT,
                                   MB_YESNO | MB_SETFOREGROUND | MB_ICONQUESTION );

        if ( nRet != IDYES )
            return NOERROR;

        BOOL fDisconnected = FALSE;  // can be used to refresh the shell if needed
        err = LogoutFromServer( szServerName + 2, &fDisconnected );

        if ( err != NO_ERROR )
        {
            ::MsgBoxPrintf( hParent,
                            IDS_MESSAGE_LOGOUT_FAILED,
                            IDS_TITLE_LOGOUT,
                            MB_OK | MB_SETFOREGROUND | MB_ICONSTOP );

            return NOERROR;
        }
    }

    // If error occurred, just assume we are not attached to the server and continue on
    // to login to the server.

    DWORD dwConnFlags = CONNECT_INTERACTIVE | CONNECT_PROMPT;

    // See if the server is in the default context tree.
    // If yes, then we don't need to prompt the password first before connecting
    // in WNetAddConnection3.

    BOOL  fInDefaultTree = FALSE;
    err = NwIsServerInDefaultTree( pNetRes->lpRemoteName, &fInDefaultTree );

    if ( (err == NO_ERROR ) && fInDefaultTree )
        dwConnFlags = CONNECT_INTERACTIVE;

    //
    // Now call WNetAddConnection3
    //

    // NOTE: net use \\mars_srv0 will succeed
    // but net use \\marsdev\cn=mars_srv0... will failed
    // Hence, just use the server name to connect.
    LPWSTR pszSave = pNetRes->lpRemoteName;
    pNetRes->lpRemoteName = szServerName;

    err = WNetAddConnection3( hParent,
                              pNetRes,
                              NULL,
                              NULL,
                              dwConnFlags );

    if ( err != WN_SUCCESS && err != WN_CANCEL )
    {
        ::MsgBoxErrorPrintf( hParent,
                             IDS_MESSAGE_ADDCONN_ERROR,
                             IDS_NETWARE_TITLE,
                             MB_OK | MB_SETFOREGROUND | MB_ICONSTOP,
                             err,
                             pNetRes->lpRemoteName );
    }

    pNetRes->lpRemoteName = pszSave;   // restore the original remote name just in case

    return NOERROR;
}


#if 0
HRESULT
NWUISetDefaultContext(
    HWND hParent,
    LPNETRESOURCE pNetRes
)
{
    DWORD  dwPrintOptions;
    LPWSTR pszCurrentContext = NULL;
    WCHAR  szNewContext[MAX_PATH+1];

    DWORD  err = NO_ERROR;
    HANDLE handleRdr = NULL;

    UNICODE_STRING uTree;
    UNICODE_STRING uContext;
    LPWSTR pszContext = NULL;

    // Open a handle to the redirector
    err = RtlNtStatusToDosError( ::NwNdsOpenRdrHandle( &handleRdr ));

    if ( err != NO_ERROR )
        goto CleanExit;

    // Get the print option so that we can use it later
    err = ::NwQueryInfo( &dwPrintOptions, &pszCurrentContext );

    if ( err != NO_ERROR )
        goto CleanExit;

    wcscpy( szNewContext, pNetRes->lpRemoteName + 1 );  // get past 1st '\\'
    szNewContext[0] = TREECHAR;   //  in the format "*TREE\CONTEXT"

    if ( (pszContext = wcschr( szNewContext, L'\\' )) != NULL )
    {
        *pszContext = 0;
        RtlInitUnicodeString( &uContext, pszContext + 1 );
    }
    else
        RtlInitUnicodeString( &uContext, L"");

    RtlInitUnicodeString( &uTree, szNewContext+1 );

    if ( (err = RtlNtStatusToDosError( ::NwNdsSetTreeContext( handleRdr, &uTree, &uContext)))
       == NO_ERROR )
    {
        *pszContext = L'\\';

        if ((err = ::NwSetInfoInRegistry( dwPrintOptions, szNewContext )) == NO_ERROR )
        {
            ::MsgBoxPrintf( hParent,
                            IDS_MESSAGE_CONTEXT_CHANGED,
                            IDS_NETWARE_TITLE,
                            MB_OK | MB_SETFOREGROUND | MB_ICONINFORMATION,
                            pszCurrentContext
                              ? (   *pszCurrentContext == TREECHAR
                                  ? pszCurrentContext + 1
                                  : pszCurrentContext )
                              : L"",
                            szNewContext+1 );
        }
    }

CleanExit:

    if ( err != NO_ERROR )
    {
        ::MsgBoxErrorPrintf( hParent,
                             IDS_MESSAGE_CONTEXT_ERROR,
                             IDS_NETWARE_TITLE,
                             MB_OK | MB_SETFOREGROUND | MB_ICONSTOP,
                             err,
                             szNewContext+1);
    }

    if ( pszCurrentContext != NULL )
    {
        LocalFree( pszCurrentContext );
        pszCurrentContext = NULL;
    }

    if ( handleRdr != NULL )
    {
        ::NtClose( handleRdr );
        handleRdr = NULL;
    }

    return NOERROR;
}
#endif

HRESULT
NWUIMapNetworkDrive(
    HWND hParent,
    LPNETRESOURCE pNetRes
)
{
    HRESULT hres;
    CONNECTDLGSTRUCT cds;

    cds.cbStructure = sizeof(cds);
    cds.hwndOwner   = hParent;
    cds.lpConnRes   = pNetRes;
    cds.dwFlags     = CONNDLG_RO_PATH;

    if (  (( hres = WNetConnectionDialog1( &cds )) == WN_SUCCESS )
       && ( g_pFuncSHChangeNotify )
       )
    {
        WCHAR szPath[4];

        szPath[0] = ((USHORT) cds.dwDevNum) - 1 + L'A';
        szPath[1] = L':';
        szPath[2] = L'\\';
        szPath[3] = 0;

        // Notify shell about added redirection
        (*g_pFuncSHChangeNotify)( SHCNE_DRIVEADD,
                                  SHCNF_FLUSH | SHCNF_PATH | SHCNF_FLUSHNOWAIT,
                                  szPath,
                                  NULL );

        Sleep(1000); // short delay to make sure Shell has updated drive table

        // And we need to open shell window on this path
        if (g_pFuncSHExecuteEx)
        {
            SHELLEXECUTEINFO ExecInfo;

            ::memset(&ExecInfo,0,sizeof(ExecInfo));

            ExecInfo.hwnd         = hParent;
            ExecInfo.lpVerb       = 0;
            ExecInfo.lpFile       = szPath;
            ExecInfo.lpParameters = NULL;
            ExecInfo.lpDirectory  = NULL;
            ExecInfo.nShow        = SW_NORMAL | SW_SHOW;
            ExecInfo.fMask        = SEE_MASK_CLASSNAME;
            ExecInfo.cbSize       = sizeof(SHELLEXECUTEINFO);
            ExecInfo.lpClass      = (LPWSTR) L"Folder";
            ExecInfo.hkeyClass    = NULL;

            (*g_pFuncSHExecuteEx)(&ExecInfo);
        }
    }

    return hres;
}



#define     LB_PCT_NAME     25
#define     LB_PCT_TYPE     11
#define     LB_PCT_CONN     11
#define     LB_PCT_USER     25
#define     LB_PCT_STATUS   27

#define     BITMAP_WIDTH    16
#define     BITMAP_HEIGHT   16

#define     MAPCOLOR        RGB(0, 255, 0)

static UINT uiNDSIconIndex = 0;
static UINT uiServerIconIndex = 0;

/*
 * FillConnectionsListView
 * -----------------------
 *
 * Fill list box with information on active connections
 */
VOID
FillConnectionsListView(
     HWND   hwndDlg
)
{
    HWND      hwndLV = ::GetDlgItem(hwndDlg,IDD_GLOBAL_SERVERLIST);
    LV_ITEM   lvI;
    WCHAR     szSubItemText[MAX_PATH+1];
    UINT      uiInsertedIndex;

    DWORD_PTR     ResumeKey = 0;
    LPBYTE    pConnBuffer = NULL;
    DWORD     EntriesRead = 0;
    DWORD     err = NO_ERROR;

    // Prepare ListView structure
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;

    do {

        if ( pConnBuffer != NULL )
        {
            LocalFree( pConnBuffer );
            pConnBuffer = NULL;
        }

        err = NwGetConnectionStatus( NULL,
                                     &ResumeKey,
                                     &pConnBuffer,
                                     &EntriesRead );


        if (  ( err != NO_ERROR )
           || ( EntriesRead == 0 )
           )
        {
            goto CleanExit;
        }

        PCONN_STATUS pConnStatus = (PCONN_STATUS) pConnBuffer;

        for ( DWORD i = 0; i < EntriesRead; i++)
        {
            // Allocate and initialize new item structure for use in the listbox

            DWORD dwSize;

            //
            // Don't need to show preferred server with only implicit
            // connections since we can't disconnect from it.
            //
            if ( pConnStatus->fPreferred )
            {
                // Continue with the next item
                pConnStatus = (PCONN_STATUS) ( (DWORD_PTR) pConnStatus
                                             + pConnStatus->dwTotalLength);
                continue;
            }

            //
            // Allocate and copy the connection information to be store with
            // the listbox
            //
            PCONN_STATUS pConnStatusKeep =
                (PCONN_STATUS) LocalAlloc( LMEM_ZEROINIT, pConnStatus->dwTotalLength );
            if ( pConnStatusKeep == NULL )
            {
                err  = ERROR_NOT_ENOUGH_MEMORY;
                goto CleanExit;
            }

            memcpy( pConnStatusKeep, pConnStatus, pConnStatus->dwTotalLength );

            dwSize = sizeof(CONN_STATUS);

            if ( pConnStatus->pszServerName )
            {
                pConnStatusKeep->pszServerName =
                    (LPWSTR) ((DWORD_PTR)pConnStatusKeep + dwSize );

                NwMakePrettyDisplayName( pConnStatusKeep->pszServerName );

                dwSize += (wcslen(pConnStatus->pszServerName)+1)*sizeof(WCHAR);
            }

            if ( pConnStatus->pszUserName )
            {
                pConnStatusKeep->pszUserName =
                    (LPWSTR) ((DWORD_PTR)pConnStatusKeep + dwSize );

                dwSize += (wcslen(pConnStatus->pszUserName)+1) * sizeof(WCHAR);

                NwAbbreviateUserName( pConnStatus->pszUserName,
                                      pConnStatusKeep->pszUserName );

                NwMakePrettyDisplayName( pConnStatusKeep->pszUserName );
            }

            if ( pConnStatus->pszTreeName )
            {
                pConnStatusKeep->pszTreeName =
                    (LPWSTR) ((DWORD_PTR)pConnStatusKeep + dwSize );
            }

            //
            // Construct the item to add to the listbox
            //
            lvI.iItem    = i;
            lvI.iSubItem = 0;
            lvI.pszText  = szSubItemText;
            lvI.cchTextMax = sizeof(szSubItemText);

            // Select proper icon
            lvI.iImage = pConnStatusKeep->fNds? uiNDSIconIndex
                                              : uiServerIconIndex;

            lvI.lParam = (LPARAM) pConnStatusKeep;

            wcscpy( szSubItemText, pConnStatusKeep->pszServerName );

            // Insert the item
            uiInsertedIndex = ListView_InsertItem( hwndLV, &lvI);

            if ( uiInsertedIndex != -1 )
            {
                // Added item itself - now for specific columns

                // First, add the column indicating bindery or nds connection
                if ( pConnStatusKeep->fNds )
                {
                    LoadString( ::hmodNW, IDS_LOGIN_TYPE_NDS, szSubItemText,
                                sizeof(szSubItemText)/sizeof(szSubItemText[0]));
                }
                else
                {
                    LoadString( ::hmodNW, IDS_LOGIN_TYPE_BINDERY, szSubItemText,
                                sizeof(szSubItemText)/sizeof(szSubItemText[0]));
                }

                ListView_SetItemText( hwndLV,
                                      uiInsertedIndex,
                                      1,    // SubItem id
                                      szSubItemText );

                // Next, Add the column indicating the connection number

                if (  ( pConnStatusKeep->pszServerName[0] != TREECHAR )
                   && ( pConnStatusKeep->dwConnType != NW_CONN_DISCONNECTED )
                   )
                {
                    // Add connection number only if it is a connection
                    // to a server and not a tree.
                    // A connection number only makes sense when not disconnected
                    ::wsprintf(szSubItemText,L"%4d",pConnStatusKeep->nConnNum );
                    ListView_SetItemText( hwndLV,
                                          uiInsertedIndex,
                                          2,    // SubItem id
                                          szSubItemText );
                }

                // Then, add the column indicating the user name

                *szSubItemText = L'\0';
                if ( pConnStatusKeep->pszUserName )
                {
                    wcscpy( szSubItemText, pConnStatusKeep->pszUserName );

                    ListView_SetItemText( hwndLV,
                                          uiInsertedIndex,
                                          3, // SubItem id
                                          szSubItemText );
                }

                // Last of all, add the column indicating the connection status

                *szSubItemText = L'\0';
                GetConnectionStatusString( pConnStatusKeep,
                                           (LPBYTE) szSubItemText,
                                           sizeof(szSubItemText)/sizeof(szSubItemText[0]));

                ListView_SetItemText( hwndLV,
                                      uiInsertedIndex,
                                      4, // SubItem id
                                      szSubItemText );

            }
            else
            {
                // Failed inserting item in the list,
                // need to delete the allocated CONN_STATUS
                ASSERT( FALSE );
                LocalFree( pConnStatusKeep );
                pConnStatusKeep = NULL;
            }

            // Continue with the next item
            pConnStatus = (PCONN_STATUS) ( (DWORD_PTR) pConnStatus
                                         + pConnStatus->dwTotalLength);
        }

    } while ( ResumeKey != 0 );

CleanExit:

    if ( pConnBuffer != NULL )
    {
        LocalFree( pConnBuffer );
        pConnBuffer = NULL;
    }

    if ( err != NO_ERROR )
    {
        // If error occurred, we will end the dialog

        ::MsgBoxErrorPrintf( hwndDlg,
                             IDS_MESSAGE_CONNINFO_ERROR,
                             IDS_NETWARE_TITLE,
                             MB_OK | MB_SETFOREGROUND | MB_ICONSTOP,
                             err,
                             NULL );

        ::EndDialog( hwndDlg, FALSE);
    }
}


/*
 * CreateConnectionsListView
 * -------------------------
 *
 * Initialize the column headers of the list box
 */
VOID
CreateConnectionsListView(
    HWND    hwndDlg
)
{
    HWND    hwndLV;
    HIMAGELIST  hSmall;
    UINT    uiLBoxWidth;

    InitCommonControls();

    // Get the handle of the listbox
    hwndLV = ::GetDlgItem(hwndDlg,IDD_GLOBAL_SERVERLIST);

    RECT rc;
    ::GetWindowRect( ::GetDlgItem( hwndDlg, IDD_GLOBAL_SERVERLIST ), &rc );
    uiLBoxWidth = rc.right - rc.left;

    // Load image list
    hSmall = ::ImageList_Create(BITMAP_WIDTH,BITMAP_HEIGHT,ILC_MASK,4,0);

    // Load bitmap of the tree/server icon
    HBITMAP hbm;
    hbm = ::LoadBitmap(::hmodNW,MAKEINTRESOURCE(IDB_TREE_ICON));

    if ((uiNDSIconIndex = ImageList_AddMasked(hSmall,hbm,MAPCOLOR)) == -1) {

        ASSERT(FALSE);
    }

    hbm = ::LoadBitmap(::hmodNW,MAKEINTRESOURCE(IDB_SERVER_ICON));

    if ((uiServerIconIndex = ImageList_AddMasked(hSmall,hbm,MAPCOLOR)) == -1) {

        ASSERT(FALSE);
    }

    ImageList_SetBkColor(hSmall, CLR_NONE);

    // Associate image list with list view control
    ListView_SetImageList(hwndLV,hSmall,LVSIL_SMALL);

    // Initialize columns in header
    LV_COLUMN   lvC;
    UINT        uiColumnIndex = 0;
    WCHAR       szColumnName[128];

    lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvC.fmt = LVCFMT_LEFT;
    lvC.cx = (uiLBoxWidth*LB_PCT_NAME)/100;
    lvC.pszText = szColumnName;

    // Add the column header representing the server name
    *szColumnName = L'\0';
    ::LoadString( ::hmodNW,
                  IDS_COLUMN_NAME,
                  szColumnName,
                  sizeof(szColumnName)/sizeof(szColumnName[0]));
    if ( ListView_InsertColumn(hwndLV,uiColumnIndex++,&lvC) == -1) {
        ASSERT(FALSE);
    }

    // Add the column header representing the conneciton type
    *szColumnName = L'\0';
    lvC.cx = (uiLBoxWidth*LB_PCT_TYPE)/100;
    ::LoadString( ::hmodNW,
                  IDS_COLUMN_CONN_TYPE,
                  szColumnName,
                  sizeof(szColumnName)/sizeof(szColumnName[0]));
    if ( ListView_InsertColumn(hwndLV,uiColumnIndex++,&lvC) == -1) {
        ASSERT(FALSE);
    }

    // Add the column header representing the connection number
    *szColumnName = L'\0';
    lvC.cx = (uiLBoxWidth*LB_PCT_CONN)/100;
    lvC.fmt = LVCFMT_RIGHT;

    ::LoadString( ::hmodNW,
                  IDS_COLUMN_CONN_NUMBER,
                  szColumnName,
                  sizeof(szColumnName)/sizeof(szColumnName[0]));
    if ( ListView_InsertColumn(hwndLV,uiColumnIndex++,&lvC) == -1) {
        ASSERT(FALSE);
    }

    // Add the column header representing the name of the user
    *szColumnName = L'\0';
    lvC.cx = (uiLBoxWidth*LB_PCT_USER)/100;
    lvC.fmt = LVCFMT_LEFT;

    ::LoadString( ::hmodNW,
                  IDS_COLUMN_USER,
                  szColumnName,
                  sizeof(szColumnName)/sizeof(szColumnName[0]));

    if ( ListView_InsertColumn(hwndLV,uiColumnIndex++,&lvC) == -1) {
        ASSERT(FALSE);
    }

    // Add the column header representing the status of the connection
    *szColumnName = L'\0';
    lvC.cx = (uiLBoxWidth*LB_PCT_STATUS)/100;
    lvC.fmt = LVCFMT_LEFT;

    ::LoadString( ::hmodNW,
                  IDS_COLUMN_STATUS,
                  szColumnName,
                  sizeof(szColumnName)/sizeof(szColumnName[0]));

    if ( ListView_InsertColumn(hwndLV,uiColumnIndex++,&lvC) == -1) {
        ASSERT(FALSE);
    }

    // Now fill list view window with connection information
    FillConnectionsListView( hwndDlg );

} /* endproc CreateConnectionsListView */


/*
 * GlobalWhoAmI_ListViewCompareProc
 * --------------------------------
 *
 */
LRESULT CALLBACK
GlobalWhoAmI_ListViewCompareProc(
    LPARAM  lParam1,
    LPARAM  lParam2,
    LPARAM  lParamSort
)
{
    PCONN_STATUS    pConnItem1 = (PCONN_STATUS)lParam1;
    PCONN_STATUS    pConnItem2 = (PCONN_STATUS)lParam2;

    int iResult = 0;

    if ( pConnItem1 && pConnItem2 )
    {
        switch(lParamSort)
        {
            case 0:
                iResult = ::_wcsicmp( pConnItem1->pszServerName,
                                      pConnItem2->pszServerName);
                break;

            case 1:
                iResult = pConnItem1->fNds - pConnItem2->fNds;
                break;

            case 2:
                iResult = pConnItem1->nConnNum - pConnItem2->nConnNum;
                break;

            case 3:
            {
                // pszUserName might be NULL, so we need to be careful when
                // comparing them.
                if ( pConnItem1->pszUserName )
                {
                    if ( pConnItem2->pszUserName )
                    {
                        iResult = ::_wcsicmp( pConnItem1->pszUserName,
                                              pConnItem2->pszUserName);
                    }
                    else
                    {
                        iResult = 1;
                    }
                }
                else
                {
                    iResult = -1;
                }
                break;
            }

            case 4:
                iResult = pConnItem1->dwConnType - pConnItem2->dwConnType;
                break;

            default:
                iResult = 0;
                break;
        }
    }

    return (iResult);

}

LRESULT
NotifyHandler(
    HWND   hwndDlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    NM_LISTVIEW *lpNm  = (NM_LISTVIEW *)lParam;
    NMHDR       *lphdr = &lpNm->hdr;

    HWND        hwndLV = ::GetDlgItem(hwndDlg,IDD_GLOBAL_SERVERLIST);

    switch(lphdr->code)
    {
        case LVN_ITEMCHANGED:
            // Check for change in item state, make sure item has received focus
            if (lpNm->uChanged & LVIF_STATE)
            {
                UINT uiSelectedItems = 0;

                uiSelectedItems = ListView_GetSelectedCount(hwndLV);

                EnableWindow( GetDlgItem(hwndDlg, IDD_DETACH),
                              uiSelectedItems? TRUE : FALSE);

                return TRUE;
            }
            break;

        case LVN_COLUMNCLICK:
            ListView_SortItems( hwndLV,
                                GlobalWhoAmI_ListViewCompareProc,
                                (LPARAM)(lpNm->iSubItem));
            return TRUE;        /* we processed a message */

        case LVN_DELETEITEM:
            // Free memory
            LocalFree( (HLOCAL) lpNm->lParam );
            lpNm->lParam = NULL;
            break;

        default:
            break;
    }

    return FALSE;
}


BOOL
DetachResourceProc(
    HWND hwndDlg
)
{
    BOOL          fDetached = FALSE;
    LV_ITEM       lvitem;
    int           index;
    DWORD         err;

    HWND          hwndLV = ::GetDlgItem( hwndDlg, IDD_GLOBAL_SERVERLIST);

    index = -1;  // Start at beginning of item list.

    while ((index = ListView_GetNextItem(hwndLV, index, LVNI_SELECTED)) != -1)
    {
        lvitem.iItem    = index;
        lvitem.mask     = LVIF_PARAM;
        lvitem.iSubItem = 0;

        if ( ListView_GetItem( hwndLV, &lvitem ))
        {
            PCONN_STATUS pConnStatus = (PCONN_STATUS) lvitem.lParam;
            BOOL fDisconnected = FALSE;   // Can be used to refresh
                                          // the shell if needed

            err = LogoutFromServer( pConnStatus->pszServerName,
                                    &fDisconnected );

            if ( err == NO_ERROR )
            {
                fDetached = TRUE;
            }
            else
            {
                NwMakePrettyDisplayName(pConnStatus->pszServerName);
                ::MsgBoxPrintf( hwndDlg,
                                IDS_MESSAGE_LOGOUT_FROM_SERVER_FAILED,
                                IDS_TITLE_LOGOUT,
                                MB_OK | MB_SETFOREGROUND | MB_ICONINFORMATION,
                                pConnStatus->pszServerName );
            }
        }
    }

    return fDetached;
}

static DWORD aWhoAmIIds[] = { IDC_LOGOFRAME,          NO_HELP,
                              IDD_GLOBAL_SERVERLIST_T,IDH_GLOBAL_SERVERLIST,
                              IDD_GLOBAL_SERVERLIST,  IDH_GLOBAL_SERVERLIST,
                              IDD_DETACH,             IDH_GLOBAL_DETACH,
                              IDD_GLOBAL_SVRLIST_DESC,IDH_GLOBAL_SERVERLIST,
                              0, 0 };

/*
 * GlobalWhoAmIDlgProc
 * -------------------
 *
 * WhoAmI information for list of attached servers
 */
BOOL
CALLBACK
GlobalWhoAmIDlgProc(
    HWND    hwndDlg,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    switch (msg)
    {
        case WM_INITDIALOG:
        {
            LPWSTR pszCurrentContext = NULL;
            DWORD dwPrintOptions;

            // Get the current default tree or server name
            DWORD err = ::NwQueryInfo( &dwPrintOptions, &pszCurrentContext );
            if ( err == NO_ERROR )
            {
                LPWSTR pszName;
                WCHAR  szUserName[MAX_PATH+1] = L"";
                WCHAR  szNoName[2] = L"";
                DWORD_PTR  ResumeKey = 0;
                LPBYTE pBuffer = NULL;
                DWORD  EntriesRead = 0;

                DWORD  dwMessageId;

                UNICODE_STRING uContext;
                WCHAR  szContext[MAX_PATH+1];

                szContext[0] = 0;
                uContext.Buffer = szContext;
                uContext.Length = uContext.MaximumLength
                                = sizeof(szContext)/sizeof(szContext[0]);

                if ( pszCurrentContext )
                {
                    pszName = pszCurrentContext;
                }
                else
                {
                    pszName = szNoName;
                }

                if ( pszName[0] == TREECHAR )
                {
                    // Get the tree name from the full name *TREE\CONTEXT

                    LPWSTR pszTemp;
                    if ( pszTemp = wcschr( pszName, L'\\' ))
                        *pszTemp = 0;

                    dwMessageId = IDS_MESSAGE_NOT_LOGGED_IN_TREE;
                }
                else
                {
                    dwMessageId = IDS_MESSAGE_NOT_LOGGED_IN_SERVER;
                }

                if ( pszName[0] != 0 )  // there is preferred server/tree
                {
                    err = NwGetConnectionStatus( pszName,
                                                 &ResumeKey,
                                                 &pBuffer,
                                                 &EntriesRead );
                }

                if ( err == NO_ERROR  && EntriesRead > 0 )
                    // For trees, we'll get more than one entry
                {
                    PCONN_STATUS pConnStatus = (PCONN_STATUS) pBuffer;

                    if ( EntriesRead > 1 && pszName[0] == TREECHAR )
                    {
                        // If there is more than one entry for trees,
                        // then we need to find one entry where username is not null.
                        // If we cannot find one, then just use the first one.

                        DWORD i;
                        PCONN_STATUS pConnStatusTmp = pConnStatus;
                        PCONN_STATUS pConnStatusUser = NULL;
                        PCONN_STATUS pConnStatusNoUser = NULL;

                        for ( i = 0; i < EntriesRead ; i++ )
                        {
                             if ( pConnStatusTmp->fNds )
                             {
                                 pConnStatusNoUser = pConnStatusTmp;

                                 if (  ( pConnStatusTmp->pszUserName != NULL )
                                    && (  ( pConnStatusTmp->dwConnType
                                          == NW_CONN_NDS_AUTHENTICATED_NO_LICENSE )
                                       || ( pConnStatusTmp->dwConnType
                                          == NW_CONN_NDS_AUTHENTICATED_LICENSED )
                                       )
                                    )
                                 {
                                     // Found it
                                     pConnStatusUser = pConnStatusTmp;
                                     break;
                                 }
                             }

                             // Continue with the next item
                             pConnStatusTmp = (PCONN_STATUS)
                                              ( (DWORD_PTR) pConnStatusTmp
                                              + pConnStatusTmp->dwTotalLength);
                        }

                        if ( pConnStatusUser )
                        {
                            // found one nds entry with a user name
                            pConnStatus = pConnStatusUser;
                        }
                        else if ( pConnStatusNoUser )
                        {
                            // use an nds entry with no user name
                            pConnStatus = pConnStatusNoUser;
                        }
                        // else use the first entry
                    }

                    if (  ( pConnStatus->pszUserName )
                       && ( pConnStatus->pszUserName[0] != 0 )
                       )
                    {
                        NwAbbreviateUserName( pConnStatus->pszUserName,
                                              szUserName);

                        NwMakePrettyDisplayName( szUserName );

                        if ( pszName[0] != TREECHAR )
                        {
                            dwMessageId = IDS_MESSAGE_LOGGED_IN_SERVER;
                        }
                        else
                        {
                            dwMessageId = IDS_MESSAGE_LOGGED_IN_TREE;
                        }
                    }

                    if ( pszName[0] == TREECHAR )
                    {
                        // For trees, we need to get the current context

                        // Open a handle to the redirector
                        HANDLE handleRdr = NULL;
                        err = RtlNtStatusToDosError(
                                  ::NwNdsOpenRdrHandle( &handleRdr ));

                        if ( err == NO_ERROR )
                        {
                            UNICODE_STRING uTree;
                            RtlInitUnicodeString( &uTree, pszName+1 ); // get past '*'

                            // Get the current context in the default tree
                            err = RtlNtStatusToDosError(
                                      ::NwNdsGetTreeContext( handleRdr,
                                                             &uTree,
                                                             &uContext));
                        }

                        if ( handleRdr != NULL )
                            ::NtClose( handleRdr );
                    }
                }

                if ( !err )
                {
                    LPWSTR pszText = NULL;
                    err = ::LoadMsgPrintf( &pszText,
                                           dwMessageId,
                                           pszName[0] == TREECHAR?
                                               pszName + 1 : pszName,
                                           szUserName,
                                           szContext );

                    if ( err == NO_ERROR )
                    {
                        ::SetDlgItemText( hwndDlg, IDD_GLOBAL_SERVERLIST_T,
                                          pszText);
                        ::LocalFree( pszText );
                    }
                }

                if ( pBuffer != NULL )
                {
                    LocalFree( pBuffer );
                    pBuffer = NULL;
                }
            }

            if ( pszCurrentContext != NULL )
            {
                LocalFree( pszCurrentContext );
                pszCurrentContext = NULL;
            }

            if ( err != NO_ERROR )
            {
                ::MsgBoxErrorPrintf( hwndDlg,
                                     IDS_MESSAGE_CONNINFO_ERROR,
                                     IDS_NETWARE_TITLE,
                                     MB_OK | MB_SETFOREGROUND | MB_ICONSTOP,
                                     err,
                                     NULL );
                ::EndDialog( hwndDlg, FALSE);
                return TRUE;
            }

            // Fill listview control with connection parameters
            CreateConnectionsListView(hwndDlg);

            UnHideControl( hwndDlg, IDD_DETACH);

            // List view fill defaults to no selected server, disable Detach.
            EnableWindow( GetDlgItem( hwndDlg, IDD_DETACH), FALSE);

            // Set up timer for automatic refresh interval
            ::SetTimer( hwndDlg, 1, GLOBAL_WHOAMI_REFRESH_INTERVAL, NULL);

            // Set focus to list box
            ::SetFocus( ::GetDlgItem( hwndDlg, IDD_GLOBAL_SERVERLIST));

            return FALSE;           /* we set the focus */
        }

        case WM_DESTROY:
            ::KillTimer( hwndDlg, 1);
            break;

        case WM_COMMAND:

            switch (wParam)
            {
                case IDOK:
                case IDCANCEL:
                    ::EndDialog( hwndDlg, FALSE);
                    return TRUE;        /* we processed a message */

                case IDD_DETACH:
                    // Attempt to detach server connection currently selected
                    if ( DetachResourceProc( hwndDlg ))
                    {
                        // If succeeded - refresh window
                        ::SendMessage(hwndDlg,WM_COMMAND,IDD_REFRESH,0L);
                    }

                    return TRUE;        /* we processed a message */

                case IDD_REFRESH:
                {
                    // Refresh connection listbox

                    HWND hwndLV = ::GetDlgItem( hwndDlg, IDD_GLOBAL_SERVERLIST);

                    ::SetFocus( hwndLV );

                    // Clear list
                    ListView_DeleteAllItems( hwndLV );

                    // Now refill list view window
                    FillConnectionsListView( hwndDlg );

                    // List view refill unsets selected server focus, disable Detach.
                    EnableWindow( GetDlgItem( hwndDlg, IDD_DETACH ), FALSE );

                    return TRUE;        /* we processed a message */
                }

                default:
                    break;
            }
            break;

        case WM_NOTIFY:
            // Handle notifications
            if ( NotifyHandler( hwndDlg, msg, wParam, lParam))
                return TRUE;        /* we processed a message */
            break;

        case WM_TIMER:
            ::SendMessage( hwndDlg, WM_COMMAND, IDD_REFRESH, 0L);
            break;

        case WM_HELP:
            ::WinHelp( (HWND) ((LPHELPINFO)lParam)->hItemHandle,
                       NW_HELP_FILE,
                       HELP_WM_HELP,
                       (DWORD_PTR) (LPVOID) aWhoAmIIds );
            return TRUE;

        case WM_CONTEXTMENU:
            ::WinHelp( (HWND) wParam,
                       NW_HELP_FILE,
                       HELP_CONTEXTMENU,
                       (DWORD_PTR) (LPVOID) aWhoAmIIds );
            return TRUE;

    }

    return FALSE;               /* we didn't process the message */

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\client\port.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    port.c

Abstract:

    This module contains the code for port handling

Author:

    Yi-Hsin Sung (yihsins) 15-May-1993

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <winreg.h>
#include <wingdi.h>
#include <winspool.h>

#include <splutil.h>
#include <nwspl.h>

//------------------------------------------------------------------
//
// Local Functions
//
//------------------------------------------------------------------

HMODULE hSpoolssDll = NULL;
FARPROC pfnSpoolssEnumPorts = NULL;

HANDLE
RevertToPrinterSelf(
    VOID
);

BOOL
ImpersonatePrinterClient(
    HANDLE  hToken
);



BOOL
IsLocalMachine(
    LPWSTR pszName
)
{
    if ( !pszName || !*pszName )
        return TRUE;

    if ( *pszName == L'\\' && *(pszName+1) == L'\\')
        if ( !lstrcmpi( pszName, szMachineName) )
            return TRUE;

    return FALSE;

}


BOOL
PortExists(
    LPWSTR  pPortName,
    LPDWORD pError
)
/* PortExists
 *
 * Calls EnumPorts to check whether the port name already exists.
 * This asks every monitor, rather than just this one.
 * The function will return TRUE if the specified port is in the list.
 * If an error occurs, the return is FALSE and the variable pointed
 * to by pError contains the return from GetLastError().
 * The caller must therefore always check that *pError == NO_ERROR.
 */
{
    DWORD cbNeeded;
    DWORD cReturned;
    DWORD cbPorts;
    LPPORT_INFO_1W pPorts;
    DWORD i;
    BOOL  Found = FALSE;

    *pError = NO_ERROR;

    if ( !hSpoolssDll )
    {
        if ( hSpoolssDll = LoadLibrary( L"SPOOLSS.DLL" ))
        {
            pfnSpoolssEnumPorts = GetProcAddress(hSpoolssDll, "EnumPortsW");
            if ( !pfnSpoolssEnumPorts )
            {
                *pError = GetLastError();
                FreeLibrary( hSpoolssDll );
                hSpoolssDll = NULL;
            }
        }
        else
        {
            *pError = GetLastError();
        }
    }

    if ( !pfnSpoolssEnumPorts )
        return FALSE;

    if ( !(*pfnSpoolssEnumPorts)( NULL, 1, NULL, 0, &cbNeeded, &cReturned) )
    {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            cbPorts = cbNeeded;

            EnterCriticalSection( &NwSplSem );

            pPorts = AllocNwSplMem( LMEM_ZEROINIT, cbPorts );
            if ( pPorts )
            {
                if ( (*pfnSpoolssEnumPorts)( NULL, 1, (LPBYTE)pPorts, cbPorts,
                                             &cbNeeded, &cReturned))
                {
                    for ( i = 0; i < cReturned; i++)
                    {
                        if ( !lstrcmpi( pPorts[i].pName, pPortName) )
                            Found = TRUE;
                    }
                }
                else
                {
                    *pError = GetLastError();
                }

                FreeNwSplMem( pPorts, cbPorts );
            }
            else
            {
                *pError = ERROR_NOT_ENOUGH_MEMORY;
            }

            LeaveCriticalSection( &NwSplSem );

        }
        else
        {
            *pError = GetLastError();
        }
    }

    return Found;
}



BOOL
PortKnown(
    LPWSTR   pPortName
)
{
    PNWPORT pNwPort;

    EnterCriticalSection( &NwSplSem );

    pNwPort = pNwFirstPort;

    while ( pNwPort )
    {
        if ( !lstrcmpi( pNwPort->pName, pPortName ) )
        {
            LeaveCriticalSection( &NwSplSem );
            return TRUE;
        }

        pNwPort = pNwPort->pNext;
    }

    LeaveCriticalSection( &NwSplSem );
    return FALSE;

}



PNWPORT
CreatePortEntry(
    LPWSTR   pPortName
)
{
    PNWPORT pNwPort, pPort;
    DWORD cb = sizeof(NWPORT) + (wcslen(pPortName) + 1) * sizeof(WCHAR);

    if ( pNwPort = AllocNwSplMem( LMEM_ZEROINIT, cb))
    {
        pNwPort->pName = wcscpy((LPWSTR)(pNwPort+1), pPortName);
        pNwPort->cb = cb;
        pNwPort->pNext = NULL;

        EnterCriticalSection( &NwSplSem );

        if ( pPort = pNwFirstPort )
        {
            while ( pPort->pNext )
                pPort = pPort->pNext;

            pPort->pNext = pNwPort;
        }
        else
        {
            pNwFirstPort = pNwPort;
        }

        LeaveCriticalSection( &NwSplSem );
    }

    return pNwPort;
}



BOOL
DeletePortEntry(
    LPWSTR   pPortName
)
/*
    Return TRUE when the port name is found and deleted. FALSE otherwise.
*/
{
    BOOL fRetVal;
    PNWPORT pPort, pPrevPort;

    EnterCriticalSection( &NwSplSem );

    pPort = pNwFirstPort;
    while ( pPort && lstrcmpi(pPort->pName, pPortName))
    {
        pPrevPort = pPort;
        pPort = pPort->pNext;
    }

    if (pPort)
    {
        if (pPort == pNwFirstPort)
        {
            pNwFirstPort = pPort->pNext;
        }
        else
        {
            pPrevPort->pNext = pPort->pNext;
        }

        FreeNwSplMem( pPort, pPort->cb );
        fRetVal = TRUE;
    }
    else
    {
        fRetVal = FALSE;
    }

    LeaveCriticalSection( &NwSplSem );

    return fRetVal;
}



VOID
DeleteAllPortEntries(
    VOID
)
{
    PNWPORT pPort, pNextPort;

    for ( pPort = pNwFirstPort; pPort; pPort = pNextPort ) 
    {
        pNextPort = pPort->pNext;
        FreeNwSplMem( pPort, pPort->cb );
    }
}



DWORD
CreateRegistryEntry(
    LPWSTR pPortName
)
{
    DWORD  err;
    HANDLE hToken;
    HKEY   hkeyPath;
    HKEY   hkeyPortNames;

    hToken = RevertToPrinterSelf();

    err = RegCreateKeyEx( HKEY_LOCAL_MACHINE, pszRegistryPath, 0,
                          NULL, 0, KEY_WRITE, NULL, &hkeyPath, NULL );

    if ( !err )
    {
        err = RegCreateKeyEx( hkeyPath, pszRegistryPortNames, 0,
                              NULL, 0, KEY_WRITE, NULL, &hkeyPortNames, NULL );

        if ( !err )
        {
            err = RegSetValueEx( hkeyPortNames,
                                 pPortName,
                                 0,
                                 REG_SZ,
                                 (LPBYTE) L"",
                                 0 );

            RegCloseKey( hkeyPortNames );
        }
        else
        {
            KdPrint(("RegCreateKeyEx (%ws) failed: Error = %d\n",
                      pszRegistryPortNames, err ) );
        }

        RegCloseKey( hkeyPath );
    }
    else
    {
        KdPrint(("RegCreateKeyEx (%ws) failed: Error = %d\n",
                  pszRegistryPath, err ) );
    }

    if ( hToken )
        (void)ImpersonatePrinterClient(hToken);

    return err;
}



DWORD
DeleteRegistryEntry(
    LPWSTR pPortName
)
{
    DWORD  err;
    HANDLE hToken;
    HKEY   hkeyPath;
    HKEY   hkeyPortNames;

    hToken = RevertToPrinterSelf();

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE, pszRegistryPath, 0,
                        KEY_WRITE, &hkeyPath );

    if ( !err )
    {

        err = RegOpenKeyEx( hkeyPath, pszRegistryPortNames, 0,
                            KEY_WRITE, &hkeyPortNames );

        if ( !err )
        {
            err = RegDeleteValue( hkeyPortNames, pPortName );
            RegCloseKey( hkeyPortNames );
        }
        else
        {
            KdPrint(("RegOpenKeyEx (%ws) failed: Error = %d\n",
                      pszRegistryPortNames, err ) );
        }

        RegCloseKey( hkeyPath );

    }
    else
    {
        KdPrint(("RegOpenKeyEx (%ws) failed: Error = %d\n",
                  pszRegistryPath, err ) );
    }

    if ( hToken )
        (void)ImpersonatePrinterClient(hToken);

    return err;
}



HANDLE
RevertToPrinterSelf(
    VOID
)
{
    HANDLE NewToken = NULL;
    HANDLE OldToken;
    NTSTATUS ntstatus;

    ntstatus = NtOpenThreadToken(
                   NtCurrentThread(),
                   TOKEN_IMPERSONATE,
                   TRUE,
                   &OldToken
                   );

    if ( !NT_SUCCESS(ntstatus) ) {
        SetLastError(ntstatus);
        return FALSE;
    }

    ntstatus = NtSetInformationThread(
                 NtCurrentThread(),
                 ThreadImpersonationToken,
                 (PVOID)&NewToken,
                 (ULONG)sizeof(HANDLE)
                 );

    if ( !NT_SUCCESS(ntstatus) ) {
        SetLastError(ntstatus);
        return FALSE;
    }

    return OldToken;
}



BOOL
ImpersonatePrinterClient(
    HANDLE  hToken
)
{
    NTSTATUS ntstatus = NtSetInformationThread(
                            NtCurrentThread(),
                            ThreadImpersonationToken,
                            (PVOID) &hToken,
                            (ULONG) sizeof(HANDLE));

    if ( !NT_SUCCESS(ntstatus) ) {
        SetLastError( ntstatus );
        return FALSE;
    }

    (VOID) NtClose(hToken);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\client\provider.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    provider.c

Abstract:

    This module contains NetWare Network Provider code.  It is the
    client-side wrapper for APIs supported by the Workstation service.

Author:

    Rita Wong  (ritaw)   15-Feb-1993

Revision History:

    Yi-Hsin Sung (yihsins) 10-July-1993
        Moved all dialog handling to nwdlg.c

--*/

#include <nwclient.h>
#include <nwsnames.h>
#include <nwcanon.h>
#include <validc.h>
#include <nwevent.h>
#include <ntmsv1_0.h>
#include <nwdlg.h>
#include <nwreg.h>
#include <nwauth.h>
#include <mpr.h>    // WNFMT_ manifests
#include <nwmisc.h>

#ifndef NT1057
#include <nwutil.h>
#endif

//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

STATIC
BOOL
NwpWorkstationStarted(
    VOID
    );

STATIC
DWORD
NwpMapNameToUNC(
    IN LPWSTR pszName,
    OUT LPWSTR *ppszUNC
    );

STATIC
VOID
NwpGetUncInfo(
    IN LPWSTR lpstrUnc,
    OUT WORD * slashCount,
    OUT BOOL * isNdsUnc
    );

STATIC
LPWSTR
NwpGetUncObjectName(
    IN LPWSTR ContainerName
    );

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

#if DBG
DWORD NwProviderTrace = 0;
#endif


DWORD
APIENTRY
NPGetCaps(
    IN DWORD QueryVal
    )
/*++

Routine Description:

    This function returns the functionality supported by this network
    provider.

Arguments:

    QueryVal - Supplies a value which determines the type of information
        queried regarding the network provider's support in this area.

Return Value:

    Returns a value which indicates the level of support given by this
    provider.

--*/
{

#if DBG
    IF_DEBUG(INIT) {
        KdPrint(("\nNWPROVAU: NPGetCaps %lu\n", QueryVal));
    }
#endif

    switch (QueryVal) {

        case WNNC_SPEC_VERSION:
            return 0x00040000;

        case WNNC_NET_TYPE:
            return WNNC_NET_NETWARE ; 

        case WNNC_USER:
            return WNNC_USR_GETUSER;

        case WNNC_CONNECTION:
            return (WNNC_CON_ADDCONNECTION |
                    WNNC_CON_ADDCONNECTION3 |
                    WNNC_CON_CANCELCONNECTION |
                    WNNC_CON_GETPERFORMANCE |
                    WNNC_CON_GETCONNECTIONS);

        case WNNC_ENUMERATION:
            return ( WNNC_ENUM_GLOBAL |
                     WNNC_ENUM_CONTEXT |
                     WNNC_ENUM_LOCAL );

        case WNNC_START:
            if (NwpWorkstationStarted()) {
                return 1;
            }
            else {
                return 0xffffffff;   // don't know
            }

        case WNNC_DIALOG:
            return WNNC_DLG_FORMATNETWORKNAME
#ifdef NT1057
                 ;
#else
                 | WNNC_DLG_GETRESOURCEPARENT | WNNC_DLG_GETRESOURCEINFORMATION;
#endif

        //
        // The rest are not supported by the NetWare provider
        //
        default:
            return 0;
    }

}

#define NW_EVENT_MESSAGE_FILE          L"nwevent.dll"



DWORD
APIENTRY
NPGetUser(
    LPWSTR  lpName,
    LPWSTR  lpUserName,
    LPDWORD lpUserNameLen
    )
/*++

Routine Description:

    This is used to determine either the current default username, or the
    username used to establish a network connection.

Arguments:

    lpName - Contains the name of the local device the caller is interested
        in, or a network name that the user has made a connection to. This
        may be NULL or the empty string if the caller is interested in the
        name of the user currently logged on to the system. If a network
        name is passed in, and the user is connected to that resource using
        different names, it is possible that a provider cannont resolve 
        which username to return. In this case the provider may make an
        arbitrary choice amonst the possible usernames.

    lpUserName - Points to a buffer to receive the user name. this should
        be a name that can be passed into the NPAddConnection or
        NPAddConnection3 function to re-establish the connection with the
        same user name.

    lpBufferSize - This is used to specify the size (in characters) of the
        buffer passed in. If the call fails because the buffer is not big
        enough, this location will be used to return the required buffer size.

Return Value:

    WN_SUCCESS - If the call is successful. Otherwise, an error code is,
        returned, which may include:

    WN_NOT_CONNECTED - lpName not a redirected device nor a connected network
        name.

    WN_MORE_DATA - The buffer is too small.

    WN_NO_NETWORK - Network not present.

--*/
{
    DWORD  status;
    DWORD  dwUserNameBufferSize = *lpUserNameLen * sizeof(WCHAR);
    DWORD  CharsRequired = 0;

    if (lpName == NULL)
    {
        return WN_NOT_CONNECTED;
    }

    RtlZeroMemory( lpUserName, dwUserNameBufferSize );

#if DBG
    IF_DEBUG(CONNECT)
    {
        KdPrint(("\nNWPROVAU: NPGetUser %ws\n", lpName));
    }
#endif

    RpcTryExcept
    {
            status = NwrGetUser(
                        NULL,
                        lpName,
                        (LPBYTE) lpUserName,
                        dwUserNameBufferSize,
                        &CharsRequired
                        );

            if (status == WN_MORE_DATA)
            {
                //
                // Output buffer too small.
                //
                *lpUserNameLen = CharsRequired;
            }
    }
    RpcExcept(1)
    {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept

    if (status != NO_ERROR)
    {
        SetLastError(status);
    }

    return status;
}


DWORD
APIENTRY
NPAddConnection(
    LPNETRESOURCEW lpNetResource,
    LPWSTR lpPassword,
    LPWSTR lpUserName
    )
/*++

Routine Description:

    This function creates a remote connection.

Arguments:

    lpNetResource - Supplies the NETRESOURCE structure which specifies
        the local DOS device to map, the remote resource to connect to
        and other attributes related to the connection.

    lpPassword - Supplies the password to connect with.

    lpUserName - Supplies the username to connect with.

Return Value:

    NO_ERROR - Successful.

    WN_BAD_VALUE - Invalid value specifed in lpNetResource.

    WN_BAD_NETNAME - Invalid remote resource name.

    WN_BAD_LOCALNAME - Invalid local DOS device name.

    WN_BAD_PASSWORD - Invalid password.

    WN_ALREADY_CONNECTED - Local DOS device name is already in use.

    Other network errors.

--*/
{
    DWORD status = NO_ERROR;
    LPWSTR pszRemoteName = NULL;

    UCHAR EncodeSeed = NW_ENCODE_SEED3;
    UNICODE_STRING PasswordStr;

    LPWSTR CachedUserName = NULL ;
    LPWSTR CachedPassword = NULL ;

    PasswordStr.Length = 0;

    status = NwpMapNameToUNC(
                 lpNetResource->lpRemoteName,
                 &pszRemoteName );

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return status;
    }

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("\nNWPROVAU: NPAddConnection %ws\n", pszRemoteName));
    }
#endif

    RpcTryExcept
    {
        if (lpNetResource->dwType != RESOURCETYPE_ANY &&
            lpNetResource->dwType != RESOURCETYPE_DISK &&
            lpNetResource->dwType != RESOURCETYPE_PRINT)
        {
            status = WN_BAD_VALUE;
        }
        else
        {
#ifdef NT1057
            //
            // no credentials specified, see if we have cached credentials
            //
            if (!lpPassword && !lpUserName) 
            {
                 (void) NwpRetrieveCachedCredentials(
                            pszRemoteName,
                            &CachedUserName,
                            &CachedPassword) ;

                 //
                 // these values will be NULL still if nothing found
                 //
                 lpPassword = CachedPassword ;
                 lpUserName = CachedUserName ;
            }
#endif

            //
            // Encode password.
            //
            RtlInitUnicodeString(&PasswordStr, lpPassword);
            RtlRunEncodeUnicodeString(&EncodeSeed, &PasswordStr);

            status = NwrCreateConnection(
                        NULL,
                        lpNetResource->lpLocalName,
                        pszRemoteName,
                        lpNetResource->dwType,
                        lpPassword,
                        lpUserName
                        );

            if (CachedUserName)
            {
                (void)LocalFree((HLOCAL)CachedUserName);
            }

            if (CachedPassword)
            {
                RtlZeroMemory(CachedPassword,
                              wcslen(CachedPassword) *
                              sizeof(WCHAR)) ;
                (void)LocalFree((HLOCAL)CachedPassword);
            }
        }
    }
    RpcExcept(1)
    {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept

    if (PasswordStr.Length != 0 && !CachedPassword)
    {
        //
        // Restore password to original state
        //
        RtlRunDecodeUnicodeString(NW_ENCODE_SEED3, &PasswordStr);
    }

    if (status == ERROR_SHARING_PAUSED)
    {
        HMODULE MessageDll;
        WCHAR Buffer[1024];
        DWORD MessageLength;
        DWORD err;
        HKEY  hkey;
        LPWSTR pszProviderName = NULL;
    
        //
        // Load the netware message file DLL
        //
        MessageDll = LoadLibraryW(NW_EVENT_MESSAGE_FILE);
    
        if (MessageDll == NULL)
        {
            goto ExitPoint ;
        }

        //
        // Read the Network Provider Name.
        //
        // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
        // \NWCWorkstation\networkprovider
        //
        err = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  NW_WORKSTATION_PROVIDER_PATH,
                  REG_OPTION_NON_VOLATILE,   // options
                  KEY_READ,                  // desired access
                  &hkey
                  );
    
        if ( !err )
        {
            //
            // ignore the return code. if fail, pszProviderName is NULL
            //
            err =  NwReadRegValue(
                      hkey,
                      NW_PROVIDER_VALUENAME,
                      &pszProviderName          // free with LocalFree
                      );
    
            RegCloseKey( hkey );
        }

        if (err)
        {
            (void) FreeLibrary(MessageDll);
            goto ExitPoint ;
        }

        RtlZeroMemory(Buffer, sizeof(Buffer)) ;

        //
        // Get string from message file 
        //
        MessageLength = FormatMessageW(
                            FORMAT_MESSAGE_FROM_HMODULE,
                            (LPVOID) MessageDll,
                            NW_LOGIN_DISABLED,
                            0,
                            Buffer,
                            sizeof(Buffer) / sizeof(WCHAR),
                            NULL
                            );

        if (MessageLength != 0)
        {
            status = WN_EXTENDED_ERROR ;
            WNetSetLastErrorW(NW_LOGIN_DISABLED, 
                              Buffer,
                              pszProviderName) ;
        }

        (void) LocalFree( (HLOCAL) pszProviderName );
        (void) FreeLibrary(MessageDll);

    }

ExitPoint: 

    if (status != NO_ERROR)
    {
        SetLastError(status);
    }
    
    LocalFree( (HLOCAL) pszRemoteName );
    return status;
}


DWORD
APIENTRY
NPAddConnection3(
    HWND   hwndOwner,
    LPNETRESOURCEW lpNetResource,
    LPWSTR lpPassword,
    LPWSTR lpUserName,
    DWORD  dwConnFlags
    )
/*++

Routine Description:

    This function creates a remote connection.

Arguments:

    hwndOwner - Owner window handle for dialog boxes

    lpNetResource - Supplies the NETRESOURCE structure which specifies
        the local DOS device to map, the remote resource to connect to
        and other attributes related to the connection.

    lpPassword - Supplies the password to connect with.

    lpUserName - Supplies the username to connect with.

    dwConnFlags -  CONNECT_UPDATE_PROFILE...

Return Value:

    NO_ERROR - Successful.

    WN_BAD_VALUE - Invalid value specifed in lpNetResource.

    WN_BAD_NETNAME - Invalid remote resource name.

    WN_BAD_LOCALNAME - Invalid local DOS device name.

    WN_BAD_PASSWORD - Invalid password.

    WN_ALREADY_CONNECTED - Local DOS device name is already in use.

    Other network errors.

--*/
{
    DWORD err = NO_ERROR;
    LPWSTR UserName = NULL;
    LPWSTR Password = NULL;

    if (   ( dwConnFlags & CONNECT_PROMPT )
       && !( dwConnFlags & CONNECT_INTERACTIVE )
       )
    {
        return WN_BAD_VALUE;
    }

    if ( !(dwConnFlags & CONNECT_PROMPT ))
    {
        err = NPAddConnection( lpNetResource,
                               lpPassword, 
                               lpUserName );

        if (  ( err == NO_ERROR ) 
           || !( dwConnFlags & CONNECT_INTERACTIVE )  // Cannot popup dialog
           )
        {
            return err;
        }
    }

    for (;;)
    {
        if (  ( err != NO_ERROR )             // CONNECT_PROMPT
           && ( err != WN_BAD_PASSWORD )
           && ( err != WN_ACCESS_DENIED )
           && ( err != ERROR_NO_SUCH_USER )
           )
        {
            // Errors not related to access problems
            break;
        }

        if ( UserName )
        {
            (void) LocalFree( UserName );
            UserName = NULL;
        }
 
        if ( Password )
        {
            memset( Password, 0, wcslen(Password) * sizeof(WCHAR));
            (void) LocalFree( Password );
            Password = NULL;
        }

        //
        // Put up dialog to get username
        // and password.
        //
        err = NwpGetUserCredential( hwndOwner,
                                    lpNetResource->lpRemoteName,
                                    err,
                                    lpUserName,
                                    &UserName,
                                    &Password );

        if ( err != NO_ERROR )
            break;

        err = NPAddConnection( lpNetResource,
                               Password, 
                               UserName );

        if ( err == NO_ERROR )
        {
#if 0
            if ( (UserName != NULL) && (Password != NULL))
            {
                // Checking UserName and Password is to make sure that
                // we have prompted for password
                (VOID) NwpCacheCredentials( lpNetResource->lpRemoteName,
                                            UserName,
                                            Password ) ;
            }
#endif
            break;
        }
    }

    if ( UserName )
        (void) LocalFree( UserName );
 
    if ( Password )
    {
        memset( Password, 0, wcslen(Password) * sizeof(WCHAR));
        (void) LocalFree( Password );
    }

    return err;
}



DWORD
APIENTRY
NPCancelConnection(
    LPWSTR lpName,
    BOOL fForce
    )
/*++

Routine Description:

    This function deletes a remote connection.

Arguments:

    lpName - Supplies the local DOS device, or the remote resource name
        if it is a UNC connection to delete.

    fForce - Supplies the force level to break the connection.  TRUE means
        to forcefully delete the connection, FALSE means end the connection
        only if there are no opened files.

Return Value:

    NO_ERROR - Successful.

    WN_BAD_NETNAME - Invalid remote resource name.

    WN_NOT_CONNECTED - Connection could not be found.

    WN_OPEN_FILES - fForce is FALSE and there are opened files on the
        connection.

    Other network errors.

--*/
{
    DWORD status = NO_ERROR;
    LPWSTR pszName = NULL;

    // 
    // We only need to map remote resource name  
    //

    if ( NwLibValidateLocalName( lpName ) != NO_ERROR )
    {
        status = NwpMapNameToUNC(
                     lpName,
                     &pszName 
                     );

        if (status != NO_ERROR) {
            SetLastError(status);
            return status;
        }
    }

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("\nNWPROVAU: NPCancelConnection %ws, Force %u\n",
                 pszName? pszName : lpName, fForce));
    }
#endif

    RpcTryExcept {

        status = NwrDeleteConnection(
                    NULL,
                    pszName? pszName : lpName,
                    (DWORD) fForce
                    );

    }
    RpcExcept(1) {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept

    if (status != NO_ERROR) {
        SetLastError(status);
    }

    LocalFree( (HLOCAL) pszName );
    return status;

}



DWORD
APIENTRY
NPGetConnection(
    LPWSTR lpLocalName,
    LPWSTR lpRemoteName,
    LPDWORD lpnBufferLen
    )
/*++

Routine Description:

    This function returns the remote resource name for a given local
    DOS device.

Arguments:

    lpLocalName - Supplies the local DOS device to look up.

    lpRemoteName - Output buffer to receive the remote resource name
        mapped to lpLocalName.

    lpnBufferLen - On input, supplies length of the lpRemoteName buffer
        in number of characters.  On output, if error returned is
        WN_MORE_DATA, receives the number of characters required of
        the output buffer to hold the output string.

Return Value:

    NO_ERROR - Successful.

    WN_BAD_LOCALNAME - Invalid local DOS device.

    WN_NOT_CONNECTED - Connection could not be found.

    WN_MORE_DATA - Output buffer is too small.

    Other network errors.

--*/
{

    DWORD status = NO_ERROR;
    DWORD CharsRequired;

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("\nNWPROVAU: NPGetConnection %ws\n", lpLocalName));
    }
#endif

    RpcTryExcept {

        if (lpRemoteName && *lpnBufferLen)
            *lpRemoteName = 0 ;

        status = NwrQueryServerResource(
                    NULL,
                    lpLocalName,
                    (*lpnBufferLen == 0? NULL : lpRemoteName),
                    *lpnBufferLen,
                    &CharsRequired
                    );
         
         if (status == ERROR_INSUFFICIENT_BUFFER)
             status = WN_MORE_DATA;

        if (status == WN_MORE_DATA) {
            *lpnBufferLen = CharsRequired;
        }

    }
    RpcExcept(1) {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept

    if (status != NO_ERROR) {
        SetLastError(status);
    }

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("\nNWPROVAU: NPGetConnection returns %lu\n", status));
        if (status == NO_ERROR) {
            KdPrint(("                                  %ws, BufferLen %lu, CharsRequired %lu\n", lpRemoteName, *lpnBufferLen, CharsRequired));

        }
    }
#endif

    return status;
}


DWORD
APIENTRY
NPGetConnectionPerformance(
    LPCWSTR lpRemoteName,
    LPNETCONNECTINFOSTRUCT lpNetConnectInfo
    )
/*++

Routine Description:

    This function returns information about the expected performance of a
    connection used to access a network resource. The request can only be
    for a network resource to which there is currently a connection.

Arguments:

    lpRemoteName - Contains the local name or remote name for a resource
                   for which a connection exists.

    lpNetConnectInfo - This is a pointer to a NETCONNECTINFOSTRUCT structure
                       which is to be filled if the connection performance
                       of connection lpRemoteName can be determined.

Return Value:

    NO_ERROR - Successful.

    WN_NOT_CONNECTED - Connection could not be found.

    WN_NONETWORK - Network is not present.

    Other network errors.

--*/
{
    DWORD status = NO_ERROR;
    LPWSTR pszRemoteName;

    if ( lpNetConnectInfo == NULL )
    {
            status = ERROR_INVALID_PARAMETER;
            SetLastError(status);
            return status;
    }

    pszRemoteName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                                         ( wcslen(lpRemoteName) + 1 ) *
                                         sizeof(WCHAR) );

    if ( pszRemoteName == NULL )
    {
            status = ERROR_NOT_ENOUGH_MEMORY;
            SetLastError(status);
            return status;
    }

    wcscpy( pszRemoteName, lpRemoteName );
    _wcsupr( pszRemoteName );

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("\nNWPROVAU: NPGetConnectionPerformance %ws\n", pszRemoteName));
    }
#endif

    RpcTryExcept {

        status = NwrGetConnectionPerformance(
                    NULL,
                    pszRemoteName,
                    (LPBYTE) lpNetConnectInfo,
                    sizeof(NETCONNECTINFOSTRUCT) );

    }
    RpcExcept(1)
    {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept

    if (status != NO_ERROR)
    {
        SetLastError(status);
    }

    LocalFree( (HLOCAL) pszRemoteName );
    return status;
}



DWORD
APIENTRY
NPGetUniversalName(
#ifdef NT1057
    LPWSTR  lpLocalPath,
#else
    LPCWSTR lpLocalPath,
#endif
    DWORD  dwInfoLevel,
    LPVOID lpBuffer,
    LPDWORD lpBufferSize
    )
/*++

Routine Description:

    This function returns the universal resource name for a given local
    path.

Arguments:

    lpLocalPath - Supplies the local DOS Path to look up.

    dwInfoLevel - Info level requested.

    lpBuffer - Output buffer to receive the appropruatye structure.

    lpBufferLen - On input, supplies length of the buffer in number of 
        bytes.  On output, if error returned is WN_MORE_DATA, receives 
        the number of bytes required of the output buffer.

Return Value:

    NO_ERROR - Successful.

    WN_BAD_LOCALNAME - Invalid local DOS device.

    WN_NOT_CONNECTED - Connection could not be found.

    WN_MORE_DATA - Output buffer is too small.

    Other network errors.

--*/
{

    DWORD status = NO_ERROR;
    DWORD dwCharsRequired = MAX_PATH + 1 ;
    DWORD dwBytesNeeded ;
    DWORD dwLocalLength ;
    LPWSTR lpRemoteBuffer ;
    WCHAR  szDrive[3] ;

    //
    // check for bad info level
    //
    if ((dwInfoLevel != UNIVERSAL_NAME_INFO_LEVEL) &&
        (dwInfoLevel != REMOTE_NAME_INFO_LEVEL))
    {
        return WN_BAD_VALUE ;
    }

    //
    // check for bad pointers
    //
    if (!lpLocalPath || !lpBuffer || !lpBufferSize)
    {
        return WN_BAD_POINTER ;
    }
 
    //
    // local path must at least have "X:"
    //
    if (((dwLocalLength = wcslen(lpLocalPath)) < 2) ||
        (lpLocalPath[1] != L':') ||
        ((dwLocalLength > 2) && (lpLocalPath[2] != L'\\')))
    {
        return WN_BAD_VALUE ;
    }

    //
    // preallocate some memory
    //
    if (!(lpRemoteBuffer = (LPWSTR) LocalAlloc(
                                        LPTR, 
                                        dwCharsRequired * sizeof(WCHAR))))
    {
        status = GetLastError() ;
        goto ErrorExit ;
    }
    
    szDrive[2] = 0 ;
    wcsncpy(szDrive, lpLocalPath, 2) ;

    //
    // get the remote path by calling the existing API
    //
    status = NPGetConnection(
                 szDrive,
                 lpRemoteBuffer, 
                 &dwCharsRequired) ;

    if (status == WN_MORE_DATA)
    {
        //
        // reallocate the correct size
        //

        if (!(lpRemoteBuffer = (LPWSTR) LocalReAlloc(
                                            (HLOCAL) lpRemoteBuffer, 
                                            dwCharsRequired * sizeof(WCHAR),
                                            LMEM_MOVEABLE)))
        {
            status = GetLastError() ;
            goto ErrorExit ;
        }

        status = NPGetConnection(
                     szDrive,
                     lpRemoteBuffer, 
                     &dwCharsRequired) ;
    }

    if (status != WN_SUCCESS)
    {
        goto ErrorExit ;
    }
    
    //
    // at minimum we will need this size of the UNC name
    // the -2 is because we loose the drive letter & colon.
    //
    dwBytesNeeded = (wcslen(lpRemoteBuffer) +
                     dwLocalLength - 2 + 1) * sizeof(WCHAR) ;

    switch (dwInfoLevel)
    {
        case UNIVERSAL_NAME_INFO_LEVEL:
        {
            LPUNIVERSAL_NAME_INFO lpUniversalNameInfo ;

            //
            // calculate how many bytes we really need
            //
            dwBytesNeeded += sizeof(UNIVERSAL_NAME_INFO) ;

            if (*lpBufferSize < dwBytesNeeded)
            {
                *lpBufferSize = dwBytesNeeded ;
                status = WN_MORE_DATA ;
                break ;
            }
 
            //
            // now we are all set. just stick the data in the buffer
            //
            lpUniversalNameInfo = (LPUNIVERSAL_NAME_INFO) lpBuffer ;

            lpUniversalNameInfo->lpUniversalName = (LPWSTR)
                (((LPBYTE)lpBuffer) + sizeof(UNIVERSAL_NAME_INFO)) ;
            wcscpy(lpUniversalNameInfo->lpUniversalName,
                   lpRemoteBuffer) ;
            wcscat(lpUniversalNameInfo->lpUniversalName,
                   lpLocalPath+2) ;

            break ;
        }

        case REMOTE_NAME_INFO_LEVEL :
        {
            LPREMOTE_NAME_INFO lpRemoteNameInfo ;

            //
            // calculate how many bytes we really need
            //
            dwBytesNeeded *= 2 ;  // essentially twice the info + terminator 
            dwBytesNeeded += (sizeof(REMOTE_NAME_INFO) + sizeof(WCHAR)) ;

            if (*lpBufferSize < dwBytesNeeded)
            {
                *lpBufferSize = dwBytesNeeded ;
                status = WN_MORE_DATA ;
                break ;
            }

            //
            // now we are all set. just stick the data in the buffer
            //
            lpRemoteNameInfo = (LPREMOTE_NAME_INFO) lpBuffer ;

            lpRemoteNameInfo->lpUniversalName = (LPWSTR)
                (((LPBYTE)lpBuffer) + sizeof(REMOTE_NAME_INFO)) ;
            wcscpy(lpRemoteNameInfo->lpUniversalName,
                   lpRemoteBuffer) ;
            wcscat(lpRemoteNameInfo->lpUniversalName,
                   lpLocalPath+2) ;

            lpRemoteNameInfo->lpConnectionName = 
                lpRemoteNameInfo->lpUniversalName + 
                wcslen(lpRemoteNameInfo->lpUniversalName) + 1 ;
            wcscpy(lpRemoteNameInfo->lpConnectionName,
                   lpRemoteBuffer) ;

            lpRemoteNameInfo->lpRemainingPath = 
                lpRemoteNameInfo->lpConnectionName + 
                wcslen(lpRemoteNameInfo->lpConnectionName) + 1 ;
            wcscpy(lpRemoteNameInfo->lpRemainingPath,
                   lpLocalPath+2) ;

            break ;
        }

        default:
            //
            // yikes!
            //
            status = WN_BAD_VALUE ;
            ASSERT(FALSE);
    }

ErrorExit: 

    if (lpRemoteBuffer)
    {
        (void) LocalFree((HLOCAL)lpRemoteBuffer) ;
    }
    return status;
}



DWORD
APIENTRY
NPOpenEnum(
    DWORD dwScope,
    DWORD dwType,
    DWORD dwUsage,
    LPNETRESOURCEW lpNetResource,
    LPHANDLE lphEnum
    )
/*++

Routine Description:

    This function initiates an enumeration of either connections, or
    browsing of network resource.

Arguments:

    dwScope - Supplies the category of enumeration to do--either
        connection or network browsing.

    dwType - Supplies the type of resource to get--either disk,
        print, or it does not matter.

    dwUsage - Supplies the object type to get--either container,
        or connectable usage.

    lpNetResource - Supplies, in the lpRemoteName field, the container
        name to enumerate under.

    lphEnum - Receives the resumable context handle to be used on all
        subsequent calls to get the list of objects under the container.

Return Value:

    NO_ERROR - Successful.

    WN_BAD_VALUE - Either the dwScope, dwType, or the dwUsage specified
        is not acceptable.

    WN_BAD_NETNAME - Invalid remote resource name.

    WN_NOT_CONTAINER - Remote resource name is not a container.

    Other network errors.

--*/
{
    DWORD status = NO_ERROR;

#if DBG
    IF_DEBUG(ENUM)
    {
        KdPrint(("\nNWPROVAU: NPOpenEnum\n"));
    }
#endif


    RpcTryExcept
    {
        if ( ( dwType & RESOURCETYPE_DISK ) ||
             ( dwType & RESOURCETYPE_PRINT ) ||
             ( dwType == RESOURCETYPE_ANY ) )
        {
            switch ( dwScope )
            {
                case RESOURCE_CONNECTED:

                    status = NwrOpenEnumConnections( NULL,
                                                     dwType,
                                                     (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );
                    break;

                case RESOURCE_CONTEXT:

                    status = NwrOpenEnumContextInfo( NULL,
                                                     dwType,
                                                     (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );
                    break;

                case RESOURCE_GLOBALNET:

                    if ( lpNetResource == NULL )
                    {
                        //
                        // Enumerating servers and NDS trees
                        //
                        if ( dwUsage & RESOURCEUSAGE_CONTAINER || dwUsage == 0 )
                        {
                            status = NwrOpenEnumServersAndNdsTrees( NULL,
                                                         (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );
                        }
                        else
                        {
                            //
                            // There is no such thing as a connectable server
                            // object.
                            //
                            status = WN_BAD_VALUE;
                        }
                    }
                    else
                    {
                        BOOL IsEnumVolumes = TRUE;
                        LPWSTR pszRemoteName = NULL;
                        WORD slashCount;
                        BOOL isNdsUnc;

                        NwpGetUncInfo( lpNetResource->lpRemoteName,
                                       &slashCount,
                                       &isNdsUnc );

                        //
                        // Either enumerating volumes, directories, or NDS subtrees
                        //

                        if ( dwUsage & RESOURCEUSAGE_CONNECTABLE ||
                             dwUsage & RESOURCEUSAGE_CONTAINER ||
                             dwUsage == 0 )
                        {
                            LPWSTR tempStrPtr = lpNetResource->lpRemoteName;
                            DWORD dwClassType = 0;

                            //
                            // Get rid of the <space> if a NDS tree name ...
                            //
                            if ( tempStrPtr[0] == L' ' &&
                                 tempStrPtr[1] == L'\\' &&
                                 tempStrPtr[2] == L'\\' )
                                tempStrPtr = &tempStrPtr[1];

                            if ( lpNetResource->dwDisplayType == RESOURCEDISPLAYTYPE_TREE )
                            {
                                if ( ( dwType == RESOURCETYPE_ANY ) ||
                                     ( ( dwType & RESOURCETYPE_DISK ) &&
                                       ( dwType & RESOURCETYPE_PRINT ) ) )
                                { 
                                    status = NwrOpenEnumNdsSubTrees_Any( NULL,
                                                                         tempStrPtr,
                                                                         NULL,
                                                              (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );
                                }
                                else if ( dwType & RESOURCETYPE_DISK ) 
                                {
                                    status = NwrOpenEnumNdsSubTrees_Disk( NULL,
                                                                          tempStrPtr,
                                                                          NULL,
                                                              (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );
                                }
                                else if ( dwType & RESOURCETYPE_PRINT )
                                { 
                                    status = NwrOpenEnumNdsSubTrees_Print( NULL,
                                                                           tempStrPtr,
                                                                           NULL,
                                                              (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );
                                }
                                else
                                {
                                    KdPrint(("NWOpenEnum: Unhandled dwType %lu\n", dwType));
                                }
                            }
                            else if (
                                      ( slashCount < 4 ) &&
                                      ( ( dwType == RESOURCETYPE_ANY ) ||
                                        ( ( dwType & RESOURCETYPE_DISK ) &&
                                          ( dwType & RESOURCETYPE_PRINT ) ) ) &&
                                      ( ( status = NwrOpenEnumNdsSubTrees_Any( NULL,
                                                                               tempStrPtr,
                                                                               &dwClassType,
                                                            (LPNWWKSTA_CONTEXT_HANDLE) lphEnum ) )
                                        ==NO_ERROR )
                                    )
                            {
                                status = NO_ERROR;
                            }
                            else if (
                                      ( slashCount < 4 ) &&
                                      ( dwType & RESOURCETYPE_DISK ) &&
                                      ( ( status = NwrOpenEnumNdsSubTrees_Disk( NULL,
                                                                                tempStrPtr,
                                                                                &dwClassType,
                                                            (LPNWWKSTA_CONTEXT_HANDLE) lphEnum ) )
                                        ==NO_ERROR )
                                    )
                            {
                                status = NO_ERROR;
                            }
                            else if (
                                      ( slashCount < 4 ) &&
                                      ( dwType & RESOURCETYPE_PRINT ) &&
                                      ( ( status = NwrOpenEnumNdsSubTrees_Print( NULL,
                                                                                 tempStrPtr,
                                                                                 &dwClassType,
                                                            (LPNWWKSTA_CONTEXT_HANDLE) lphEnum ) )
                                        ==NO_ERROR )
                                    )
                            {
                                status = NO_ERROR;
                            }
                            else if (
                                     (slashCount < 4
                                      &&
                                      (status == ERROR_NETWORK_ACCESS_DENIED
                                       ||
                                       status == ERROR_GEN_FAILURE
                                       ||
                                       status == ERROR_ACCESS_DENIED
                                       ||
                                       status == ERROR_BAD_NETPATH
                                       ||
                                       status == WN_BAD_NETNAME
                                       ||
                                       status == ERROR_INVALID_NAME))
                                     ||
                                     ( slashCount > 3 && status == NO_ERROR )
                                    )
                            {
                                if (( status == ERROR_NETWORK_ACCESS_DENIED ) &&
                                    ( dwClassType == CLASS_TYPE_NCP_SERVER ))
                                {
                                    status = NO_ERROR;
                                    isNdsUnc = TRUE;
                                    IsEnumVolumes = TRUE;
                                }
                                else if ( ( status == ERROR_NETWORK_ACCESS_DENIED ) &&
                                          ( ( dwClassType == CLASS_TYPE_VOLUME ) ||
                                            ( dwClassType == CLASS_TYPE_DIRECTORY_MAP ) ) )
                                {
                                    status = NO_ERROR;
                                    isNdsUnc = TRUE;
                                    IsEnumVolumes = FALSE;
                                }
                                else
                                {
                                    //
                                    // A third backslash means that we want to
                                    // enumerate the directories.
                                    //

                                    if ( isNdsUnc && slashCount > 3 )
                                        IsEnumVolumes = FALSE;

                                    if ( !isNdsUnc && slashCount > 2 )
                                        IsEnumVolumes = FALSE;

                                    if ( lpNetResource->dwDisplayType == RESOURCEDISPLAYTYPE_SHARE )
                                        IsEnumVolumes = FALSE;
                                }

                                status = NwpMapNameToUNC( tempStrPtr,
                                                          &pszRemoteName );
 
                                if ( status == NO_ERROR )
                                {
                                    if ( IsEnumVolumes ) 
                                    {
                                        LPWSTR pszServerName = pszRemoteName;

                                        // The following 10 lines are a hack to 
                                        // allow the provider to browse past the CN=<server>
                                        // object in an NDS tree.
                                        if ( slashCount == 3 && isNdsUnc == TRUE )
                                        {
                                            pszServerName = (LPWSTR)
                                                          NwpGetUncObjectName( pszRemoteName );

                                            if ( pszServerName == NULL )
                                                pszServerName = pszRemoteName;
                                        }
                                        else if ( dwUsage & RESOURCEUSAGE_ATTACHED )
                                        {
#ifndef NT1057
                                            // This is a bindery server.
                                            // Return WN_NOT_AUTHENTICATED if
                                            // we are not already attached so
                                            // that clients ( explorer ) will
                                            // do NPAddConnection3 to make
                                            // a connection to the server.
                                            BOOL  fAttached;
                                            BOOL  fAuthenticated;

                                            status = NwIsServerOrTreeAttached(
                                                         pszServerName + 2,
                                                         &fAttached,
                                                         &fAuthenticated );

                                            if ( status != NO_ERROR )
                                                break;

                                            if ( !fAttached || !fAuthenticated)
                                            {
                                                // See if the server belongs to
                                                // our provider.
                                                status = NwrOpenEnumVolumes(
                                                             NULL,
                                                             pszServerName,
                                                             (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );

                                                if ( status == NO_ERROR )
                                                {
                                                    // The server belongs to us.
                                                    // Close the handle and
                                                    // return not attached if
                                                    // callee passed in dwUsage
                                                    // flag:
                                                    // RESOURCEUSAGE_ATTACHED.
                                                    // Note: handle will be null
                                                    // after return from 
                                                    // NwrCloseEnum

                                                    NwrCloseEnum( (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );

                                                    status = WN_NOT_AUTHENTICATED;
                                                }
                                                else
                                                {
                                                    // else the server does not 
                                                    // belong to us.
                                                    status = WN_BAD_NETNAME;
                                                }
                                                break;
                                            }
#endif
                                        } // else, this is a bindery server and
                                          // client does not care whether we
                                          // are bindery authenticated.

                                        if ( ( dwType == RESOURCETYPE_ANY ) ||
                                             ( ( dwType & RESOURCETYPE_DISK ) &&
                                               ( dwType & RESOURCETYPE_PRINT ) ) )
                                        { 
                                            status = NwrOpenEnumVolumesQueues(
                                                           NULL,
                                                           pszServerName,
                                                           (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );
                                        }
                                        else if ( dwType & RESOURCETYPE_DISK ) 
                                        {
                                            status = NwrOpenEnumVolumes(
                                                             NULL,
                                                             pszServerName,
                                                             (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );
                                        } 
                                        else if ( dwType & RESOURCETYPE_PRINT )
                                        {
                                            status = NwrOpenEnumQueues(
                                                             NULL,
                                                             pszServerName,
                                                             (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );
                                        }
                                    }
                                    else
                                    {
                                        LPWSTR CachedUserName = NULL ;
                                        LPWSTR CachedPassword = NULL ;

#ifdef NT1057  // Make OpenEnum not interactive on SUR
                                        (void) NwpRetrieveCachedCredentials( pszRemoteName,
                                                                             &CachedUserName,
                                                                             &CachedPassword );

#endif
                                        status = NwrOpenEnumDirectories( 
                                                             NULL,
                                                             pszRemoteName,
                                                             CachedUserName,
                                                             CachedPassword,
                                                             (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );

#ifndef NT1057  // Make OpenEnum not interactive on SUR
                                        if (  (status == ERROR_INVALID_PASSWORD)
                                           || (status == ERROR_NO_SUCH_USER )
                                           )
                                        {
                                            status = WN_NOT_AUTHENTICATED;
                                            break;
                                        }

#else
                                        if ( CachedUserName )
                                        {
                                            (void) LocalFree( (HLOCAL) CachedUserName );
                                        }

                                        if ( CachedPassword )
                                        {
                                            RtlZeroMemory( CachedPassword,
                                                           wcslen(CachedPassword) *
                                                           sizeof( WCHAR ) );

                                            (void) LocalFree( ( HLOCAL ) CachedPassword );
                                        }

                                        if ( ( status == ERROR_INVALID_PASSWORD ) ||
                                             ( status == ERROR_NO_SUCH_USER ) )
                                        {
                                            LPWSTR UserName;
                                            LPWSTR Password;
                                            LPWSTR TmpPtr;

                                            //
                                            // Put up dialog to get username
                                            // and password.
                                            //
                                            status = NwpGetUserCredential( NULL,
                                                                     tempStrPtr,
                                                                     status,
                                                                     NULL,
                                                                     &UserName,
                                                                     &Password);

                                            if ( status == NO_ERROR )
                                            {
                                                status = NwrOpenEnumDirectories(
                                                             NULL,
                                                             pszRemoteName,
                                                             UserName,
                                                             Password,
                                                             (LPNWWKSTA_CONTEXT_HANDLE) lphEnum );

                                                if ( status == NO_ERROR )
                                                {
                                                    status = NwpCacheCredentials(
                                                                 pszRemoteName,
                                                                 UserName,
                                                                 Password ) ;
                                                }

                                                (void) LocalFree( UserName );
                                       
                                                //
                                                // Clear the password
                                                //
                                                TmpPtr = Password;
                                                while ( *TmpPtr != 0 )
                                                    *TmpPtr++ = 0;

                                                (void) LocalFree( Password );
                                            }
                                            else if ( status == ERROR_WINDOW_NOT_DIALOG )
                                            {
                                                //
                                                // Caller is not a GUI app.
                                                //
                                                status = ERROR_INVALID_PASSWORD;
                                            }
                                            else if ( status == WN_CANCEL )
                                            {
                                                //
                                                // Cancel was pressed but we still
                                                // have to return success or MPR
                                                // will popup the error.  Return
                                                // a bogus enum handle.
                                                //
                                                *lphEnum = (HANDLE) 0xFFFFFFFF;
                                                status = NO_ERROR;
                                            }
                                        }
#endif
                                    }
                                }
                                else
                                {
                                    status = WN_BAD_NETNAME;
                                }
                            }
                        }
                        else
                        {
                            status = WN_BAD_VALUE;
                        }

                        if ( pszRemoteName != NULL )
                            LocalFree( (HLOCAL) pszRemoteName );
                    }

                    break;

                default:
                    KdPrint(("NWPROVIDER: Invalid dwScope %lu\n", dwScope));
                    status = WN_BAD_VALUE;
            } // end switch
        }
        else
        {
             status = WN_BAD_VALUE;
        }
    }
    RpcExcept( 1 )
    {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept

    if ( status == ERROR_FILE_NOT_FOUND )
        status = WN_BAD_NETNAME;

    if ( status != NO_ERROR )
    {
        SetLastError( status );
    }

    return status;
}


DWORD
APIENTRY
NPEnumResource(
    HANDLE hEnum,
    LPDWORD lpcCount,
    LPVOID lpBuffer,
    LPDWORD lpBufferSize
    )
/*++

Routine Description:

    This function returns a lists of objects within the container
    specified by the enumeration context handle.

Arguments:

    hEnum - Supplies the resumable enumeration context handle.

        NOTE: If this value is 0xFFFFFFFF, it is not a context
              handle and this routine is required to return
              WN_NO_MORE_ENTRIES.  This hack is to handle the
              case where the user cancelled out of the network
              credential dialog on NwrOpenEnumDirectories and we
              cannot return an error there or we generate an error
              popup.

    lpcCount - On input, supplies the number of entries to get.
      On output, if NO_ERROR is returned, receives the number
      of entries NETRESOURCE returned in lpBuffer.

    lpBuffer - Receives an array of NETRESOURCE entries, each
        entry describes an object within the container.

    lpBufferSize - On input, supplies the size of lpBuffer in
        bytes.  On output, if WN_MORE_DATA is returned, receives
        the number of bytes needed in the buffer to get the
        next entry.

Return Value:


    NO_ERROR - Successfully returned at least one entry.

    WN_NO_MORE_ENTRIES - Reached the end of enumeration and nothing
        is returned.

    WN_MORE_DATA - lpBuffer is too small to even get one entry.

    WN_BAD_HANDLE - The enumeration handle is invalid.

    Other network errors.

--*/
{
    DWORD status = NO_ERROR;
    DWORD BytesNeeded = 0;
    DWORD EntriesRead = 0;

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWPROVAU: NPEnumResource\n"));
    }
#endif

    RpcTryExcept {

        if (hEnum == (HANDLE) 0xFFFFFFFF) {
            status = WN_NO_MORE_ENTRIES;
            goto EndOfTry;
        }

        status = NwrEnum(
                     (NWWKSTA_CONTEXT_HANDLE) hEnum,
                     *lpcCount,
                     (LPBYTE) lpBuffer,
                     *lpBufferSize,
                     &BytesNeeded,
                     &EntriesRead
                     );

        if (status == WN_MORE_DATA) {

            //
            // Output buffer too small to fit a single entry.
            //
            *lpBufferSize = BytesNeeded;
        }
        else if (status == NO_ERROR) {
            *lpcCount = EntriesRead;
        }

EndOfTry: ;

    }
    RpcExcept(1) {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept

    if (status != NO_ERROR && status != WN_NO_MORE_ENTRIES) {
        SetLastError(status);
    }
    else 
    {

        //
        // Convert offsets of strings to pointers
        //
        if (EntriesRead > 0) {
    
            DWORD i;
            LPNETRESOURCEW NetR;


            NetR = lpBuffer;

            for (i = 0; i < EntriesRead; i++, NetR++) {

                if (NetR->lpLocalName != NULL) {
                    NetR->lpLocalName = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                                  (DWORD_PTR) NetR->lpLocalName);
                }

                NetR->lpRemoteName = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                               (DWORD_PTR) NetR->lpRemoteName);

                if (NetR->lpComment != NULL) {
                    NetR->lpComment = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                                (DWORD_PTR) NetR->lpComment);
                }

                if (NetR->lpProvider != NULL) {
                    NetR->lpProvider = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                                 (DWORD_PTR) NetR->lpProvider);
                }
            }
        }
    }

    return status;
}


DWORD
APIENTRY
NPGetResourceInformation(
    LPNETRESOURCEW lpNetResource,
    LPVOID         lpBuffer,
    LPDWORD        cbBuffer,
    LPWSTR       * lplpSystem
    )
/*++

Routine Description:

    This function returns an object which details information
    about a specified network resource.

Arguments:

    lpNetResource - This specifies the network resource for which the
        information is required. The lpRemoteName field of the NETRESOURCE
        specifies the remote name of the network resource whose information
        is required. If the calling program knows the values for the 
        lpProvider and dwType fields, then it should fill them in, otherwise,
        it should set them to NULL. All other fields in the NETRESOURCE are
        ignored and are not initialized.

    lpBuffer - A pointer to the buffer to receive the result, which is
        returned as a single NETRESOURCE entry representing the parent
        resource. The lpRemoteName, lpProvider, dwType, and dwUsage fields
        are returned, all other fields being set to NULL. The remote name
        returned should be in the same syntax as that returned from an 
        enumeration, so that the caller can do a case sensitive string 
        compare to determine whether an enumerated resource is this resource.
        If the provider owns a parent of the network resource, (in other
        words is known to be the correct network to respond to this request),
        then lpProvider should be filled in with a non-null entry. If it is
        known that a network owns a parent of the resource, but that the 
        resource itself is not valid, then lpProvider is returned as a 
        non-null value together with a return status of WN_BAD_VALUE. dwScope
        is returned as RESOURCE_CONTEXT if the network resource is part of
        the user's network context, otherwise it is returned as zero.

    cbBuffer - This specifies the size in bytes of the buffer passed to the
        function call. If the result is WN_MORE_DATA, this will contain the
        buffer size required (in bytes) to hold the NETRESOURCE information.

    lplpSystem - Returned pointer to a string in the buffer pointed to by
        lpBuffer that specifies the part of the resource that is accessed
        through resource type specific system APIs rather than WNet APIs.
        For example, if the input remote resource name was
        "\\server\share\dir", then lpRemoteName is returned pointing to 
        "\\server\share" and lplpSystem points to "\dir", both strings
        being stored in the buffer pointed to by lpBuffer.

Return Value:


    WN_SUCCESS - If the call is successful.

    WN_MORE_DATA - If input buffer is too small.

    WN_BAD_VALUE - Invalid dwScope or dwUsage or dwType, or bad combination
        of parameters is specified (e.g. lpRemoteName does not correspond 
        to dwType).

    WN_BAD_NETNAME - The resource is not recognized by this provider.

--*/
{
    DWORD  status;
    LPWSTR pszRemoteName = NULL;
    DWORD  BytesNeeded = 0;
    DWORD  SystemOffset = 0;

    *lplpSystem = NULL;

    status = NwpMapNameToUNC( lpNetResource->lpRemoteName, &pszRemoteName );

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return status;
    }

#if DBG
    IF_DEBUG(CONNECT)
    {
        KdPrint(("\nNWPROVAU: NPGetResourceInformation %ws\n", pszRemoteName));
    }
#endif

    RpcTryExcept
    {
        if (lpNetResource->dwType != RESOURCETYPE_ANY &&
            lpNetResource->dwType != RESOURCETYPE_DISK &&
            lpNetResource->dwType != RESOURCETYPE_PRINT)
        {
            status = WN_BAD_VALUE;
        }
        else
        {
            status = NwrGetResourceInformation(
                        NULL,
                        pszRemoteName,
                        lpNetResource->dwType,
                        (LPBYTE) lpBuffer,
                        *cbBuffer,
                        &BytesNeeded,
                        &SystemOffset
                        );

            if (status == WN_MORE_DATA)
            {
                //
                // Output buffer too small.
                //
                *cbBuffer = BytesNeeded;
            }
        }
    }
    RpcExcept(1)
    {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept
    if ( pszRemoteName )
        LocalFree( (HLOCAL) pszRemoteName );

    if (status != NO_ERROR)
    {
        SetLastError(status);
    }
    else 
    {
        //
        // Convert offsets of strings to pointers
        //
        DWORD i;
        LPNETRESOURCEW NetR = lpBuffer;

        if (NetR->lpLocalName != NULL)
        {
            NetR->lpLocalName = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                          (DWORD_PTR) NetR->lpLocalName);
        }

        NetR->lpRemoteName = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                       (DWORD_PTR) NetR->lpRemoteName);

        if (NetR->lpComment != NULL)
        {
            NetR->lpComment = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                        (DWORD_PTR) NetR->lpComment);
        }

        if (NetR->lpProvider != NULL)
        {
            NetR->lpProvider = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                         (DWORD_PTR) NetR->lpProvider);
        }

        if (SystemOffset != 0)
        {
            *lplpSystem = (LPWSTR) ((DWORD_PTR) lpBuffer + SystemOffset);
        }
    }

    return status;
}



DWORD
APIENTRY
NPGetResourceParent(
    LPNETRESOURCEW lpNetResource,
    LPVOID         lpBuffer,
    LPDWORD        cbBuffer
    )
/*++

Routine Description:

    This function returns an object which details information
    about the parent of a specified network resource.

Arguments:

    lpNetResource - This specifies the network resource for which the
        parent name is required. The NETRESOURCE could have been obtained via 
        previous NPEnumResource, or constructed by the caller. The lpRemoteName
        field of the NETRESOURCE specifies the remote name of the network 
        resouce whose parent name is required. If the calling program knows
        the values for the lpProvider and dwType fields, then it can fill
        them in, otherwise, they are set to NULL. If the lpProvider field is
        not NULL, then the network provider DLL can assume that the resource
        is owned by its network, but if it is NULL, then it must assume
        that the resource could be for some other network and do whatever
        checking is neccessary to ensure that the result returned is accurate.
        For example, if being asked for the parent of a server, and the server
        is not part of a workgroup, the the network provider DLL should check
        to ensure that the server is part of its network and, if so, return
        its provider name. All other fields in the NETRESOURCE are ignored and
        are not initialized.

    lpBuffer - A pointer to the buffer to receive the result, which is 
        returned as a single NETRESOURCE entry representing the parent
        resource. The lpRemoteName, lpProvider, dwType, and dwUsage fields
        are returned, all other fields being set to NULL. lpProvider should
        be set to NULL if the provider has only done a syntactic check (i.e.
        does not know that the resource is specific to its network). If the
        provider owns a parent of the network resource, (in other words is
        known to be the correct network to respond to this request), then
        lpProvider should be filled in with a non-null entry, even if the
        return is WN_BAD_VALUE. The remote name returned should be in the
        same syntax as that returned from an enumeration, so that the caller
        can do a case sensitive string compare to determine whether an
        enumerated resource is this resource. If a resource has no browse
        parent on the network, the lpRemoteName is returned as NULL. The
        RESOURCEUSAGE_CONNECTABLE value in the dwUsage field does not
        indicate that the resource can currently be connected to, but that
        the resource is connectable when it is available on the network.

    cbBuffer - This specifies the size in bytes of the buffer passed to the
        function call. If the result is WN_MORE_DATA, this will contain the
        buffer size required (in bytes) to hold the NETRESOURCE information.

Return Value:

    WN_SUCCESS - If the call is successful.

    WN_MORE_DATA - If input buffer is too small.

    WN_BAD_VALUE - Invalid dwScope or dwUsage or dwType, or bad combination
        of parameters is specified (e.g. lpRemoteName does not correspond 
        to dwType).

--*/
{
    DWORD  status;
    LPWSTR pszRemoteName = NULL;
    DWORD  BytesNeeded = 0;

    status = NwpMapNameToUNC( lpNetResource->lpRemoteName, &pszRemoteName );

    if (status != NO_ERROR)
    {
        SetLastError(status);
        return status;
    }

#if DBG
    IF_DEBUG(CONNECT)
    {
        KdPrint(("\nNWPROVAU: NPGetResourceParent %ws\n", pszRemoteName));
    }
#endif

    RpcTryExcept
    {
        if (lpNetResource->dwType != RESOURCETYPE_ANY &&
            lpNetResource->dwType != RESOURCETYPE_DISK &&
            lpNetResource->dwType != RESOURCETYPE_PRINT)
        {
            status = WN_BAD_VALUE;
        }
        else
        {
            status = NwrGetResourceParent(
                        NULL,
                        pszRemoteName,
                        lpNetResource->dwType,
                        (LPBYTE) lpBuffer,
                        *cbBuffer,
                        &BytesNeeded
                        );

            if (status == WN_MORE_DATA)
            {
                //
                // Output buffer too small.
                //
                *cbBuffer = BytesNeeded;
            }
        }
    }
    RpcExcept(1)
    {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept
    if ( pszRemoteName )
        LocalFree( (HLOCAL) pszRemoteName );


    if (status != NO_ERROR)
    {
        SetLastError(status);
    }
    else 
    {
        //
        // Convert offsets of strings to pointers
        //
        DWORD i;
        LPNETRESOURCEW NetR = lpBuffer;

        if (NetR->lpLocalName != NULL)
        {
            NetR->lpLocalName = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                          (DWORD_PTR) NetR->lpLocalName);
        }

        NetR->lpRemoteName = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                       (DWORD_PTR) NetR->lpRemoteName);

        if (NetR->lpComment != NULL)
        {
            NetR->lpComment = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                        (DWORD_PTR) NetR->lpComment);
        }

        if (NetR->lpProvider != NULL)
        {
            NetR->lpProvider = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                         (DWORD_PTR) NetR->lpProvider);
        }
    }

    return status;
}



DWORD
APIENTRY
NwEnumConnections(
    HANDLE hEnum,
    LPDWORD lpcCount,
    LPVOID lpBuffer,
    LPDWORD lpBufferSize,
    BOOL    fImplicitConnections
    )
/*++

Routine Description:

    This function returns a lists of connections.

Arguments:

    hEnum - Supplies the resumable enumeration context handle.

        NOTE: If this value is 0xFFFFFFFF, it is not a context
              handle and this routine is required to return
              WN_NO_MORE_ENTRIES.  This hack is to handle the
              case where the user cancelled out of the network
              credential dialog on NwrOpenEnumDirectories and we
              cannot return an error there or we generate an error
              popup.

    lpcCount - On input, supplies the number of entries to get.
      On output, if NO_ERROR is returned, receives the number
      of entries NETRESOURCE returned in lpBuffer.

    lpBuffer - Receives an array of NETRESOURCE entries, each
        entry describes an object within the container.

    lpBufferSize - On input, supplies the size of lpBuffer in
        bytes.  On output, if WN_MORE_DATA is returned, receives
        the number of bytes needed in the buffer to get the
        next entry.

    fImplicitConnections - TRUE is we also want all implicit connections,
        FALSE otherwise.

Return Value:


    NO_ERROR - Successfully returned at least one entry.

    WN_NO_MORE_ENTRIES - Reached the end of enumeration and nothing
        is returned.

    WN_MORE_DATA - lpBuffer is too small to even get one entry.

    WN_BAD_HANDLE - The enumeration handle is invalid.

    Other network errors.

--*/
{
    DWORD status = NO_ERROR;
    DWORD BytesNeeded = 0;
    DWORD EntriesRead = 0;

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWPROVAU: NPEnumResource\n"));
    }
#endif

    RpcTryExcept {

        if (hEnum == (HANDLE) 0xFFFFFFFF) {
            status = WN_NO_MORE_ENTRIES;
            goto EndOfTry;
        }

        status = NwrEnumConnections(
                     (NWWKSTA_CONTEXT_HANDLE) hEnum,
                     *lpcCount,
                     (LPBYTE) lpBuffer,
                     *lpBufferSize,
                     &BytesNeeded,
                     &EntriesRead,
                     fImplicitConnections
                     );

        if (status == WN_MORE_DATA) {

            //
            // Output buffer too small to fit a single entry.
            //
            *lpBufferSize = BytesNeeded;
        }
        else if (status == NO_ERROR) {
            *lpcCount = EntriesRead;
        }

EndOfTry: ;

    }
    RpcExcept(1) {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept

    if (status != NO_ERROR && status != WN_NO_MORE_ENTRIES) {
        SetLastError(status);
    }

    //
    // Convert offsets of strings to pointers
    //
    if (EntriesRead > 0) {

        DWORD i;
        LPNETRESOURCEW NetR;


        NetR = lpBuffer;

        for (i = 0; i < EntriesRead; i++, NetR++) {

            if (NetR->lpLocalName != NULL) {
                NetR->lpLocalName = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                              (DWORD_PTR) NetR->lpLocalName);
            }

            NetR->lpRemoteName = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                           (DWORD_PTR) NetR->lpRemoteName);

            if (NetR->lpComment != NULL) {
                NetR->lpComment = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                            (DWORD_PTR) NetR->lpComment);
            }

            if (NetR->lpProvider != NULL) {
                NetR->lpProvider = (LPWSTR) ((DWORD_PTR) lpBuffer +
                                             (DWORD_PTR) NetR->lpProvider);
            }
        }
    }

    return status;
}


DWORD
APIENTRY
NPCloseEnum(
    HANDLE hEnum
    )
/*++

Routine Description:

    This function closes the enumeration context handle.

Arguments:

    hEnum - Supplies the enumeration context handle.

        NOTE: If this value is 0xFFFFFFFF, it is not a context
              handle.  Just return success.

Return Value:

    NO_ERROR - Successfully returned at least one entry.

    WN_BAD_HANDLE - The enumeration handle is invalid.

--*/
{
    DWORD status = NO_ERROR;

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWPROVAU: NPCloseEnum\n"));
    }
#endif

    RpcTryExcept
    {
        if (hEnum == (HANDLE) 0xFFFFFFFF) {
            status = NO_ERROR;
        }
        else {
            status = NwrCloseEnum(
                        (LPNWWKSTA_CONTEXT_HANDLE) &hEnum
                        );
        }
    }
    RpcExcept(1) {
        status = NwpMapRpcError(RpcExceptionCode());
    }
    RpcEndExcept

    if (status != NO_ERROR) {
        SetLastError(status);
    }
    return status;
}


DWORD
APIENTRY
NPFormatNetworkName(
    LPWSTR lpRemoteName,
    LPWSTR lpFormattedName,
    LPDWORD lpnLength,
    DWORD dwFlags,
    DWORD dwAveCharPerLine
    )
/*++

Routine Description:

    This function takes a fully-qualified UNC name and formats it
    into a shorter form for display.  Only the name of the object
    within the container is returned for display.

    We only support formatting of the remote resource name to the
    abbreviated form for display during enumeration where the container
    name is displayed prior to the object within it.

Arguments:

    lpRemoteName - Supplies the fully-qualified UNC name.

    lpFormatedName - Output buffer to receive the formatted name.

    lpnLength - On input, supplies the length of the lpFormattedName
        buffer in characters.  On output, if WN_MORE_DATA is returned,
        receives the length in number of characters required of the
        output buffer to hold the formatted name.

    dwFlags - Supplies a bitwise set of flags indicating the type
        of formatting required on lpRemoteName.

    dwAveCharPerLine - Ignored.

Return Value:

    NO_ERROR - Successfully returned at least one entry.

    WN_MORE_DATA - lpFormattedName buffer is too small.

    WN_BAD_VALUE - lpRemoteName is NULL.

    ERROR_NOT_SUPPORTED - dwFlags that does not contain the
        WNFMT_INENUM bit.

--*/
{
    DWORD status = NO_ERROR;

    LPWSTR NextBackSlash;
    LPWSTR Source;
    DWORD SourceLen;

#if DBG
    IF_DEBUG(OTHER) 
        KdPrint(("\nNWPROVAU: NPFormatNetworkName\n"));
#endif

    if (lpRemoteName == NULL) 
    {
        status = WN_BAD_VALUE;
        goto CleanExit;
    }

    if (dwFlags & WNFMT_INENUM) 
    {
        BYTE   i;
        WORD   length     = (WORD) wcslen( lpRemoteName );
        WORD   slashCount = 0;
        WORD   dotCount   = 0;
        WORD   Start      = 0;
        WORD   End        = length;
        BOOL   isNdsUnc   = FALSE;
        BOOL   couldBeNdsUnc = FALSE;

        if ( lpRemoteName[0] == L' ' )
            couldBeNdsUnc = TRUE;

        for ( i = 0; i < length; i++ )
        {
            if ( lpRemoteName[i] == L'\\' )
            {
                slashCount++;
                if ( i + 1 < length )
                {
                    Start = i + 1;
                }
            }

            if ( couldBeNdsUnc &&
                 ( ( lpRemoteName[i] == L'.' ) ||
                   ( lpRemoteName[i] == L'=' ) ) )
                isNdsUnc = TRUE;

            if ( dotCount < 1 && isNdsUnc && lpRemoteName[i] == L'.' )
            {
                End = i - 1;
                dotCount++;
            }
        }

        if ( i > length )
            End = length - 1;

        if ( slashCount > 3 || ( isNdsUnc != TRUE && slashCount != 3 && dotCount == 0 ) )
            End = i - 1;

        Source = &lpRemoteName[Start];
        SourceLen = End - Start + 1;

        if ( SourceLen + 1 > *lpnLength ) 
        {
            *lpnLength = SourceLen + 1;
            status = WN_MORE_DATA;
        }
        else 
        {
            wcsncpy( lpFormattedName, Source, SourceLen );
            lpFormattedName[SourceLen] = 0x00000000;
            status = NO_ERROR;
        }
    }
    else if ( dwFlags & WNFMT_MULTILINE ) 
    {

        DWORD i, j, k = 0; 
        DWORD nLastBackSlash = 0;
        DWORD BytesNeeded = ( wcslen( lpRemoteName ) + 1 +
                              2 * wcslen( lpRemoteName ) / dwAveCharPerLine
                            ) * sizeof( WCHAR); 

        if ( *lpnLength < (BytesNeeded/sizeof(WCHAR)) )
        {
            *lpnLength = BytesNeeded/sizeof(WCHAR);
            status = WN_MORE_DATA;
            goto CleanExit;
        }

        for ( i = 0, j = 0; lpRemoteName[i] != 0; i++, j++ )
        {
            if ( lpRemoteName[i] == L'\\' )
                nLastBackSlash = i;

            if ( k == dwAveCharPerLine )
            {
                if ( lpRemoteName[i] != L'\\' )
                {
                    DWORD m, n;
                    for ( n = nLastBackSlash, m = ++j ; n <= i ; n++, m-- )  
                    {
                        lpFormattedName[m] = lpFormattedName[m-1];
                    }
                    lpFormattedName[m] = L'\n';
                    k = i - nLastBackSlash - 1;
                }
                else
                {
                    lpFormattedName[j++] = L'\n';
                    k = 0;
                }
            }

            lpFormattedName[j] = lpRemoteName[i];
            k++;
        }

        lpFormattedName[j] = 0;

    }
    else if ( dwFlags & WNFMT_ABBREVIATED )
    {
        //
        // we dont support abbreviated form for now because we look bad
        // in comdlg (fileopen) if we do.
        //

        DWORD nLength;
        nLength = wcslen( lpRemoteName ) + 1 ;
        if (nLength >  *lpnLength)
        {
            *lpnLength = nLength;
            status = WN_MORE_DATA;
            goto CleanExit;
        }
        else
        {
            wcscpy( lpFormattedName, lpRemoteName ); 
        }

#if 0
        DWORD i, j, k;
        DWORD BytesNeeded = dwAveCharPerLine * sizeof( WCHAR); 
        DWORD nLength;

        if ( *lpnLength < BytesNeeded )
        {
            *lpnLength = BytesNeeded;
            status = WN_MORE_DATA;
            goto CleanExit;
        }

        nLength = wcslen( lpRemoteName );
        if ( ( nLength + 1) <= dwAveCharPerLine )
        {
            wcscpy( lpFormattedName, lpRemoteName ); 
        }
        else
        {
            lpFormattedName[0] = lpRemoteName[0];
            lpFormattedName[1] = lpRemoteName[1];

            for ( i = 2; lpRemoteName[i] != L'\\'; i++ )
                lpFormattedName[i] = lpRemoteName[i];

            for ( j = dwAveCharPerLine-1, k = nLength; j >= (i+3); j--, k-- )
            {
                lpFormattedName[j] = lpRemoteName[k];
                if ( lpRemoteName[k] == L'\\' )
                {
                    j--;
                    break;
                }
            }

            lpFormattedName[j] = lpFormattedName[j-1] = lpFormattedName[j-2] = L'.';
        
            for ( k = i; k < (j-2); k++ )
                lpFormattedName[k] = lpRemoteName[k];
            
        }

#endif 

    }     
    else   // some unknown flags
    {
        status = ERROR_NOT_SUPPORTED;
    }

CleanExit:

    if (status != NO_ERROR) 
        SetLastError(status);

    return status;
}


STATIC
BOOL
NwpWorkstationStarted(
    VOID
    )
/*++

Routine Description:

    This function queries the service controller to see if the
    NetWare workstation service has started.  If in doubt, it returns
    FALSE.

Arguments:

    None.

Return Value:

    Returns TRUE if the NetWare workstation service has started,
    FALSE otherwise.

--*/
{
    SC_HANDLE ScManager;
    SC_HANDLE Service;
    SERVICE_STATUS ServiceStatus;
    BOOL IsStarted = FALSE;

    ScManager = OpenSCManagerW(
                    NULL,
                    NULL,
                    SC_MANAGER_CONNECT
                    );

    if (ScManager == NULL) {
        return FALSE;
    }

    Service = OpenServiceW(
                  ScManager,
                  NW_WORKSTATION_SERVICE,
                  SERVICE_QUERY_STATUS
                  );

    if (Service == NULL) {
        CloseServiceHandle(ScManager);
        return FALSE;
    }

    if (! QueryServiceStatus(Service, &ServiceStatus)) {
        CloseServiceHandle(ScManager);
        CloseServiceHandle(Service);
        return FALSE;
    }


    if ( (ServiceStatus.dwCurrentState == SERVICE_RUNNING) ||
         (ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING) ||
         (ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING) ||
         (ServiceStatus.dwCurrentState == SERVICE_PAUSED) ) {

        IsStarted = TRUE;
    }

    CloseServiceHandle(ScManager);
    CloseServiceHandle(Service);

    return IsStarted;
}



DWORD
NwpMapNameToUNC(
    IN  LPWSTR pszName,
    OUT LPWSTR *ppszUNC 
    )
/*++

Routine Description:

    This routine validates the given name as a netwarepath or UNC path. 
    If it is a netware path, this routine will convert the 
    Netware path name to UNC name. 

Arguments:

    pszName - Supplies the netware name or UNC name
    ppszUNC - Points to the converted UNC name

Return Value:

    NO_ERROR or the error that occurred.

--*/
{
    DWORD err = NO_ERROR;

    LPWSTR pszSrc = pszName;
    LPWSTR pszDest;

    BOOL fSlash = FALSE;
    BOOL fColon = FALSE;
    DWORD nServerLen = 0;
    DWORD nVolLen = 0;
    BOOL fFirstToken = TRUE;

    *ppszUNC = NULL;
                               
    //
    // The name cannot be NULL or empty string
    //
    if ( pszName == NULL || *pszName == 0) 
        return WN_BAD_NETNAME;

#if DBG
    IF_DEBUG(CONNECT) 
        KdPrint(("NwpMapNameToUNC: Source = %ws\n", pszName ));
#endif

    //
    // Get rid of the <space> if a NDS tree name ...
    //
    if ( pszName[0] == L' ' &&
         pszName[1] == L'\\' &&
         pszName[2] == L'\\' )
        pszName = &pszName[1];

    //
    // Check if the given name is a valid UNC name
    //
    err = NwLibCanonRemoteName( NULL,     // "\\Server" is valid UNC path
                                pszName,
                                ppszUNC,
                                NULL );

    //
    // The given name is a valid UNC name, so return success!
    //
    if ( err == NO_ERROR )
        return err;

    //
    // Allocate the buffer to store the mapped UNC name
    // We allocate 3 extra characters, two for the backslashes in front
    // and one for the ease of parsing below.
    //
    if ((*ppszUNC = (LPVOID) LocalAlloc( 
                                 LMEM_ZEROINIT,
                                 (wcslen( pszName) + 4) * sizeof( WCHAR)
                                 )) == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy( *ppszUNC, L"\\\\" );
    pszDest = *ppszUNC + 2;   // Skip past two backslashes

    //
    // Parse the given string and put the converted string into *ppszUNC
    // In the converted string, we will substitute 0 for all slashes
    // for the time being.
    //
    for ( ; *pszSrc != 0; pszSrc++ )
    { 
        if (  ( *pszSrc == L'/' )
           || ( *pszSrc == L'\\' )
           )
        {
            //
            // Two consecutive backslashes are bad
            //
            if ( (*(pszSrc+1) ==  L'/') ||  (*(pszSrc+1) == L'\\'))
            {
                LocalFree( *ppszUNC );
                *ppszUNC = NULL;
                return WN_BAD_NETNAME;
            }

            if ( !fSlash )
                fSlash = TRUE;

            *pszDest++ = 0;
        }
        else if ( (*pszSrc == L':') && fSlash && !fColon )
        {
            fColon = TRUE;
            if ( *(pszSrc+1) != 0 )
                *pszDest++ = 0;
 
        }
        else
        {
            *pszDest++ = *pszSrc;
            if (( fSlash ) && ( !fColon))
                nVolLen++; 
            else if ( !fSlash )
                nServerLen++; 
        }
    }

    //
    // Note: *ppszUNC is already terminated with two '\0' because we initialized
    //       the whole buffer to zero.
    // 

    if (  ( nServerLen == 0 )
       || ( fSlash && nVolLen == 0 )
       || ( fSlash && nVolLen != 0 && !fColon )
       )
    {
        LocalFree( *ppszUNC );
        *ppszUNC = NULL;
        return WN_BAD_NETNAME;
    }

    //
    // At this point, we know the name is a valid Netware syntax
    //     i.e. SERVER[/VOL:/dir]
    // We now need to validate that all the characters used in the
    // servername, volume, directory are valid characters
    //

    pszDest = *ppszUNC + 2;   // Skip past the first two backslashes
    while ( *pszDest != 0 )
    {
         DWORD nLen = wcslen( pszDest );
         
         if (  ( fFirstToken &&  !IS_VALID_SERVER_TOKEN( pszDest, nLen )) 
            || ( !fFirstToken && !IS_VALID_TOKEN( pszDest, nLen )) 
            )
         { 
             LocalFree( *ppszUNC );
             *ppszUNC = NULL;
             return WN_BAD_NETNAME;
         }
     
         fFirstToken = FALSE;
         pszDest += nLen + 1;
    }

    //
    // The netware name is valid! Convert 0 back to backslash in 
    // converted string.
    //

    pszDest = *ppszUNC + 2;   // Skip past the first two backslashes
    while ( *pszDest != 0 )
    {
        if ( (*(pszDest+1) == 0 ) && (*(pszDest+2) != 0 ) )
        {
            *(pszDest+1) = L'\\';
        }
        pszDest++;
    }
                  
#if DBG
    IF_DEBUG(CONNECT) 
        KdPrint(("NwpMapNameToUNC: Destination = %ws\n", *ppszUNC ));
#endif
    return NO_ERROR;
}


STATIC
VOID
NwpGetUncInfo(
    IN LPWSTR lpstrUnc,
    OUT WORD * slashCount,
    OUT BOOL * isNdsUnc
    )
{
    BYTE   i;
    WORD   length = (WORD) wcslen( lpstrUnc );

    *isNdsUnc = FALSE;
    *slashCount = 0;

    for ( i = 0; i < length; i++ )
    {
        if ( ( lpstrUnc[i] == L'.' ) && ( *slashCount == 3 ) )
        {
            *isNdsUnc = TRUE;
        }

        if ( lpstrUnc[i] == L'\\' )
        {
            *slashCount += 1;
        }
    }
}


STATIC
LPWSTR
NwpGetUncObjectName(
    IN LPWSTR ContainerName
)
{
    WORD length = 2;
    WORD totalLength = (WORD) wcslen( ContainerName );

    if ( totalLength < 2 )
        return 0;

    while ( length < totalLength )
    {
        if ( ContainerName[length] == L'.' )
            ContainerName[length] = L'\0';

        length++;
    }

    length = 2;

    while ( length < totalLength && ContainerName[length] != L'\\' )
    {
        length++;
    }

    if ( ( ContainerName[length + 1] == L'C' ||
           ContainerName[length + 1] == L'c' ) &&
         ( ContainerName[length + 2] == L'N' ||
           ContainerName[length + 2] == L'n' ) &&
         ContainerName[length + 3] == L'=' )
    {
        ContainerName[length + 2] = L'\\';
        ContainerName[length + 3] = L'\\';

        return (ContainerName + length + 2);
    }

    ContainerName[length - 1] = L'\\';

    return (ContainerName + length - 1);
}
    

STATIC
WORD
NwpGetSlashCount(
    IN LPWSTR lpstrUnc
    )
{
    WORD   count = 0;
    BYTE   i;
    WORD   length = (WORD) wcslen( lpstrUnc );

    for ( i = 0; i < length; i++ )
    {
        if ( lpstrUnc[i] == L'\\' )
        {
            count++;
        }
    }

    return count;
}


DWORD
NwpMapRpcError(
    IN DWORD RpcError
    )
/*++

Routine Description:

    This routine maps the RPC error into a more meaningful windows
    error for the caller.

Arguments:

    RpcError - Supplies the exception error raised by RPC

Return Value:

    Returns the mapped error.

--*/
{

    switch (RpcError) {

        case RPC_S_UNKNOWN_IF:
        case RPC_S_SERVER_UNAVAILABLE:
            return WN_NO_NETWORK;

        case RPC_S_INVALID_BINDING:
        case RPC_X_SS_IN_NULL_CONTEXT:
        case RPC_X_SS_CONTEXT_DAMAGED:
        case RPC_X_SS_HANDLES_MISMATCH:
        case ERROR_INVALID_HANDLE:
            return ERROR_INVALID_HANDLE;

        case RPC_X_NULL_REF_POINTER:
            return ERROR_INVALID_PARAMETER;

        case EXCEPTION_ACCESS_VIOLATION:
            return ERROR_INVALID_ADDRESS;

        default:
            return RpcError;
    }
}

DWORD
NwRegisterGatewayShare(
    IN LPWSTR ShareName,
    IN LPWSTR DriveName
    )
/*++

Routine Description:

    This routine remembers that a gateway share has been created so
    that it can be cleanup up when NWCS is uninstalled.

Arguments:

    ShareName - name of share
    DriveName - name of drive that is shared

Return Status:

    Win32 error of any failure.

--*/
{
    return ( NwpRegisterGatewayShare(ShareName, DriveName) ) ;
}

DWORD
NwCleanupGatewayShares(
    VOID
    )
/*++

Routine Description:

    This routine cleans up all persistent share info and also tidies
    up the registry for NWCS. Later is not needed in uninstall, but is
    there so we have a single routine that cvompletely disables the
    gateway.

Arguments:

    None.

Return Status:

    Win32 error for failed APIs.

--*/
{
    return ( NwpCleanupGatewayShares() ) ;
}

DWORD
NwClearGatewayShare(
    IN LPWSTR ShareName
    )
/*++

Routine Description:

    This routine deletes a specific share from the remembered gateway
    shares in the registry.

Arguments:

    ShareName - share value to delete

Return Status:

    Win32 status code.

--*/
{
    return ( NwpClearGatewayShare( ShareName ) ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\idl\imports.h ===
#include <windef.h>

#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define PSECURITY_DESCRIPTOR DWORD
#endif

#include <stdarg.h>
#include <winbase.h>
#include <wingdi.h>
#include <winspool.h>
#define _INC_WINDOWS
#include <winsock2.h>
#include <wsipx.h>
#include <nspapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\inc\nwlsa.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwlsa.h

Abstract:

    Header for LSA helper routines used by both the client and
    server sides of the workstation service.

Author:

    Rita Wong      (ritaw)      22-Mar-1993

Revision History:

--*/

#ifndef _NWLSA_INCLUDED_
#define _NWLSA_INCLUDED_

#include <ntlsa.h>

#ifdef __cplusplus
extern "C" {
#endif

DWORD
NwOpenPolicy(
    IN ACCESS_MASK DesiredAccess,
    OUT LSA_HANDLE *PolicyHandle
    );

DWORD
NwOpenSecret(
    IN ACCESS_MASK DesiredAccess,
    IN LSA_HANDLE PolicyHandle,
    IN LPWSTR LsaSecretName,
    OUT PLSA_HANDLE SecretHandle
    );

DWORD
NwFormSecretName(
    IN  LPWSTR UserName,
    OUT LPWSTR *LsaSecretName
    );

DWORD
NwSetPassword(
    IN LPWSTR UserName,
    IN LPWSTR Password
    );

DWORD
NwDeletePassword(
    IN LPWSTR UserName
    );

DWORD
NwGetPassword(
    IN  LPWSTR UserName,
    OUT PUNICODE_STRING *Password,
    OUT PUNICODE_STRING *OldPassword
    );

#ifdef __cplusplus
} // extern "C"
#endif

#define LAST_USER     L"LastUser"
#define GATEWAY_USER  L"GatewayUser"

#endif // _NWLSA_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\client\tconn.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    tconnect.c

Abstract:

    Test for workstation connection APIs.

Author:

    Rita Wong (ritaw) 17-Feb-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef UNICODE
#define UNICODE
#endif


#include <stdio.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winnetwk.h>
#include <npapi.h>

#define REDIR_NOT_READY

DWORD
TestCreateConnection(
    IN  LPWSTR LocalName OPTIONAL,
    IN  LPWSTR RemoteName,
    IN  LPWSTR Password OPTIONAL,
    IN  LPWSTR UserName OPTIONAL,
    IN  DWORD ExpectedError
    );

DWORD
TestDeleteConnection(
    IN  LPWSTR ConnectionName,
    IN  BOOL ForceFlag,
    IN  DWORD ExpectedError
    );

DWORD
TestOpenEnum(
    IN DWORD Scope,
    IN LPNETRESOURCEW NetR OPTIONAL,
    OUT LPHANDLE EnumHandle,
    IN  DWORD ExpectedError
    );

DWORD
TestEnum(
    IN HANDLE EnumHandle,
    IN DWORD EntriesRequested,
    IN LPVOID Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    IN DWORD ExpectedError
    );

VOID
PrintNetResource(
    LPNETRESOURCE NetR
    );


BYTE WorkBuffer[1024];
BYTE WorkBuffer2[1024];

void __cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD status;

    LPWSTR LocalName;
    LPWSTR RemoteName;
    LPWSTR Password;
    LPWSTR UserName;

    NETRESOURCEW NetR;
    HANDLE EnumHandle;
    DWORD BytesNeeded;


    LocalName = L"E:";
    RemoteName = L"\\\\MyServerName\\A_Volume\\A_Directory";
    Password = L"MyPassword";
    UserName = L"MyUserName";


    TestCreateConnection(
        LocalName,
        RemoteName,
        Password,
        UserName,
        WN_SUCCESS
        );

    TestDeleteConnection(
        LocalName,
        TRUE,
        WN_SUCCESS
        );

    //-------------------------//

    TestCreateConnection(
        NULL,
        RemoteName,
        NULL,
        NULL,
        WN_SUCCESS
        );

    TestDeleteConnection(
        RemoteName,
        TRUE,
        WN_SUCCESS
        );

    //-------------------------//

    TestCreateConnection(
        L"LPT1",
        RemoteName,
        NULL,
        NULL,
        ERROR_INVALID_PARAMETER
        );

    //-------------------------//

    TestCreateConnection(
        LocalName,
        L"\\\\Server",
        NULL,
        NULL,
        ERROR_INVALID_NAME
        );

    //-------------------------//

    printf("\n");

    //-------------------------//

#ifdef REDIR_NOT_READY

    if (argc == 2) {

        ANSI_STRING AStr;
        UNICODE_STRING UStr;


        RtlZeroMemory(WorkBuffer2, sizeof(WorkBuffer2));
        UStr.Buffer = WorkBuffer2;
        UStr.MaximumLength = sizeof(WorkBuffer2);

        RtlInitString(&AStr, argv[1]);

        RtlAnsiStringToUnicodeString(
            &UStr,
            &AStr,
            FALSE
            );

        NetR.lpRemoteName = UStr.Buffer;
    }
    else {
        NetR.lpRemoteName = L"lanman";
    }

    //-------------------------//

    TestOpenEnum(
        RESOURCE_GLOBALNET,
        &NetR,
        &EnumHandle,
        WN_SUCCESS
        );

    TestEnum(
        EnumHandle,
        0xFFFFFFFF,
        WorkBuffer,
        sizeof(WorkBuffer),
        &BytesNeeded,
        WN_SUCCESS
        );

    TestEnum(
        EnumHandle,
        0xFFFFFFFF,
        WorkBuffer,
        sizeof(WorkBuffer),
        &BytesNeeded,
        WN_NO_MORE_ENTRIES
        );

    (void) NPCloseEnum(EnumHandle);

    //-------------------------//

    printf("\n");

    //-------------------------//

    TestOpenEnum(
        RESOURCE_GLOBALNET,
        &NetR,
        &EnumHandle,
        WN_SUCCESS
        );

    TestEnum(
        EnumHandle,
        0xFFFFFFFF,
        WorkBuffer,
        200,
        &BytesNeeded,
        WN_SUCCESS
        );

    TestEnum(
        EnumHandle,
        0xFFFFFFFF,
        WorkBuffer,
        sizeof(NETRESOURCEW) + 5,
        &BytesNeeded,
        WN_MORE_DATA
        );

    TestEnum(
        EnumHandle,
        0xFFFFFFFF,
        WorkBuffer,
        BytesNeeded,
        &BytesNeeded,
        WN_SUCCESS
        );

    TestEnum(
        EnumHandle,
        0xFFFFFFFF,
        WorkBuffer,
        sizeof(WorkBuffer),
        &BytesNeeded,
        WN_SUCCESS
        );

    TestEnum(
        EnumHandle,
        0xFFFFFFFF,
        WorkBuffer,
        0,
        &BytesNeeded,
        WN_NO_MORE_ENTRIES
        );

    (void) NPCloseEnum(EnumHandle);

#else

    NetR.lpRemoteName = L"\\\\S";

    TestOpenEnum(
        RESOURCE_GLOBALNET,
        &NetR,
        &EnumHandle,
        WN_SUCCESS
        );

    //-------------------------//

    NetR.lpRemoteName = L"\\\\A Long Server Name";

    TestOpenEnum(
        RESOURCE_GLOBALNET,
        &NetR,
        &EnumHandle,
        WN_SUCCESS
        );

    //-------------------------//

    NetR.lpRemoteName = L"\\\\S\\";

    TestOpenEnum(
        RESOURCE_GLOBALNET,
        &NetR,
        &EnumHandle,
        ERROR_INVALID_NAME
        );

    //-------------------------//

    NetR.lpRemoteName = L"lanman";

    TestOpenEnum(
        RESOURCE_GLOBALNET,
        &NetR,
        &EnumHandle,
        ERROR_INVALID_NAME
        );

    //-------------------------//

    NetR.lpRemoteName = L"\\\\S\\Y";

    TestOpenEnum(
        RESOURCE_GLOBALNET,
        &NetR,
        &EnumHandle,
        WN_SUCCESS
        );

    //-------------------------//

    NetR.lpRemoteName = L"\\\\Server\\Volume\\Dir";

    TestOpenEnum(
        RESOURCE_GLOBALNET,
        &NetR,
        &EnumHandle,
        WN_SUCCESS
        );

#endif

}


DWORD
TestCreateConnection(
    IN  LPWSTR LocalName OPTIONAL,
    IN  LPWSTR RemoteName,
    IN  LPWSTR Password OPTIONAL,
    IN  LPWSTR UserName OPTIONAL,
    IN  DWORD ExpectedError
    )
{
    DWORD status;
    NETRESOURCEW NetR;


    printf("\nTestCreateConnection: Local %ws, Remote %ws", LocalName, RemoteName);

    if (ARGUMENT_PRESENT(UserName)) {
        printf(" UserName %ws", UserName);
    }

    if (ARGUMENT_PRESENT(Password)) {
        printf(" Password %ws", Password);

    }

    printf("\n");

    NetR.lpLocalName = LocalName;
    NetR.lpRemoteName = RemoteName;

    NetR.dwType = RESOURCETYPE_ANY;

    status = NPAddConnection(
                &NetR,
                Password,
                UserName
                );

    if (status != WN_SUCCESS) {
        status = GetLastError();
    }

    if (status != ExpectedError) {
        printf("    FAILED: expected %lu got %lu\n", ExpectedError, status);
    }
    else {
        printf("    SUCCESS: got %lu as expected\n", status);
    }

    return status;

}

DWORD
TestDeleteConnection(
    IN  LPWSTR ConnectionName,
    IN  BOOL ForceFlag,
    IN  DWORD ExpectedError
    )
{
    DWORD status;


    printf("\nTestDeleteConnection: Connection %ws, ForceFlag %u\n",
           ConnectionName, ForceFlag);

    status = NPCancelConnection(
                 ConnectionName,
                 ForceFlag
                 );

    if (status != WN_SUCCESS) {
        status = GetLastError();
    }

    if (status != ExpectedError) {
        printf("    FAILED: expected %lu got %lu\n", ExpectedError, status);
    }
    else {
        printf("    SUCCESS: got %lu as expected\n", status);
    }

    return status;
}

DWORD
TestOpenEnum(
    IN DWORD Scope,
    IN LPNETRESOURCEW NetR OPTIONAL,
    OUT LPHANDLE EnumHandle,
    IN  DWORD ExpectedError
    )
{
    DWORD status;


    if (NetR != NULL) {
        printf("\nTestOpenEnum: Remote %ws\n", NetR->lpRemoteName);
    }

    status = NPOpenEnum(
                   Scope,
                   0,
                   0,
                   NetR,
                   EnumHandle
                   );


    if (status != WN_SUCCESS) {
        status = GetLastError();
    }

    if (status != ExpectedError) {
        printf("    FAILED: expected %lu got %lu\n", ExpectedError, status);
    }
    else {
        printf("    SUCCESS: got %lu as expected\n", status);
    }

    return status;
}

DWORD
TestEnum(
    IN HANDLE EnumHandle,
    IN DWORD EntriesRequested,
    IN LPVOID Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    IN DWORD ExpectedError
    )
{
    DWORD status;
    DWORD EntriesRead = EntriesRequested;

    DWORD i;
    LPNETRESOURCE NetR = Buffer;


    *BytesNeeded = BufferSize;

    printf("\nTestEnum: EntriesRequested x%08lx, BufferSize %lu\n",
           EntriesRead, *BytesNeeded);

    status = NPEnumResource(
                 EnumHandle,
                 &EntriesRead,
                 Buffer,
                 BytesNeeded
                 );

    if (status == WN_SUCCESS) {

        printf("         EntriesRead is %lu\n", EntriesRead);

        for (i = 0; i < EntriesRead; i++, NetR++) {
            PrintNetResource(NetR);
        }

    }
    else if (status != WN_NO_MORE_ENTRIES) {

        status = GetLastError();

        if (status == WN_MORE_DATA) {
            printf("         BytesNeeded is %lu\n", *BytesNeeded);
        }
    }

    if (status != ExpectedError) {
        printf("    FAILED: expected %lu got %lu\n", ExpectedError, status);
    }
    else {
        printf("    SUCCESS: got %lu as expected\n", status);
    }

    return status;
}

VOID
PrintNetResource(
    LPNETRESOURCE NetR
    )
{
    if (NetR->lpLocalName != NULL) {
        printf("%-7ws", NetR->lpLocalName);
    }

    printf(" %-ws\n", NetR->lpRemoteName);

    if (NetR->lpComment != NULL) {
        printf(" %-ws\n", NetR->lpComment);
    }

    if (NetR->lpProvider != NULL) {
        printf(" %-ws\n", NetR->lpProvider);
    }

    printf("Scope: x%lx", NetR->dwScope);
    printf(" Type: x%lx", NetR->dwType);
    printf(" DisplayType: x%lx", NetR->dwDisplayType);
    printf(" Usage: x%lx\n", NetR->dwUsage);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\inc\nwreg.h ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    nwreg.h

Abstract:

    Header which specifies the misc registry parameters and helper
    routines used by the workstation service.

Author:

    Rita Wong      (ritaw)      22-Mar-1993

Revision History:

    ChuckC        11-Dec-93     Split off the registry names to nwrnames.h

--*/

#ifndef _NWREG_INCLUDED_
#define _NWREG_INCLUDED_

#include <nwrnames.h>

//
// Default print option
//
#define NW_PRINT_OPTION_DEFAULT 0x98
#define NW_GATEWAY_PRINT_OPTION_DEFAULT 0x88

#define NW_DOMAIN_USER_SEPARATOR     L'*'
#define NW_DOMAIN_USER_SEPARATOR_STR L"*"

#define NW_MAX_LOGON_ID_LEN 17

#ifdef __cplusplus
extern "C" {
#endif

DWORD
NwReadRegValue(
    IN HKEY Key,
    IN LPWSTR ValueName,
    OUT LPWSTR *Value
    );

VOID
NwLuidToWStr(
    IN PLUID LogonId,
    OUT LPWSTR LogonIdStr
    );

VOID
NwWStrToLuid(
    IN LPWSTR LogonIdStr,
    OUT PLUID LogonId
    );


DWORD                              // Terminal Server
NwDeleteInteractiveLogon(
    IN PLUID Id OPTIONAL
    );

VOID
NwDeleteCurrentUser(
    VOID
    );

DWORD
NwDeleteServiceLogon(
    IN PLUID Id OPTIONAL
    );

DWORD
NwpRegisterGatewayShare(
    IN LPWSTR ShareName,
    IN LPWSTR DriveName
    );

DWORD
NwpClearGatewayShare(
    IN LPWSTR ShareName
    );

DWORD
NwpCleanupGatewayShares(
    VOID
    );

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _NWREG_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\inc\nwmisc.h ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    nwmisc.h

Abstract:

    Header which specifies the misc routines used by the workstation service.

Author:

    Chuck Y Chan   (chuckc)     2-Mar-1994

Revision History:

    Glenn A Curtis (glennc)     18-Jul-1995

--*/

#ifndef _NWMISC_INCLUDED_
#define _NWMISC_INCLUDED_

#include <winsock2.h>
#include <basetyps.h>
#include <nspapi.h>
#include "sapcmn.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// RPC pipe name
//
#define NWWKS_INTERFACE_NAME   TEXT("nwwks")


DWORD
NwGetGraceLoginCount(
    LPWSTR  Server,
    LPWSTR  UserName,
    LPDWORD lpResult
    );

//
// Commonly reference value for NCP Server name length
//
#define NW_MAX_SERVER_LEN      48


//
// Flags used for the function NwParseNdsUncPath()
//
#define  PARSE_NDS_GET_TREE_NAME    0
#define  PARSE_NDS_GET_PATH_NAME    1
#define  PARSE_NDS_GET_OBJECT_NAME  2


WORD
NwParseNdsUncPath(
    IN OUT LPWSTR * Result,
    IN LPWSTR ContainerName,
    IN ULONG flag
    );

//
// NDS Object class type identifiers
//
#define CLASS_TYPE_ALIAS                1
#define CLASS_TYPE_AFP_SERVER           2
#define CLASS_TYPE_BINDERY_OBJECT       3
#define CLASS_TYPE_BINDERY_QUEUE        4
#define CLASS_TYPE_COMPUTER             5
#define CLASS_TYPE_COUNTRY              6
#define CLASS_TYPE_DIRECTORY_MAP        7
#define CLASS_TYPE_GROUP                8
#define CLASS_TYPE_LOCALITY             9
#define CLASS_TYPE_NCP_SERVER          10
#define CLASS_TYPE_ORGANIZATION        11
#define CLASS_TYPE_ORGANIZATIONAL_ROLE 12
#define CLASS_TYPE_ORGANIZATIONAL_UNIT 13
#define CLASS_TYPE_PRINTER             14
#define CLASS_TYPE_PRINT_SERVER        15
#define CLASS_TYPE_PROFILE             16
#define CLASS_TYPE_QUEUE               17
#define CLASS_TYPE_TOP                 18
#define CLASS_TYPE_UNKNOWN             19
#define CLASS_TYPE_USER                20
#define CLASS_TYPE_VOLUME              21

#define CLASS_NAME_ALIAS               L"Alias"
#define CLASS_NAME_AFP_SERVER          L"AFP Server"
#define CLASS_NAME_BINDERY_OBJECT      L"Bindery Object"
#define CLASS_NAME_BINDERY_QUEUE       L"Bindery Queue"
#define CLASS_NAME_COMPUTER            L"Computer"
#define CLASS_NAME_COUNTRY             L"Country"
#define CLASS_NAME_DIRECTORY_MAP       L"Directory Map"
#define CLASS_NAME_GROUP               L"Group"
#define CLASS_NAME_LOCALITY            L"Locality"
#define CLASS_NAME_NCP_SERVER          L"NCP Server"
#define CLASS_NAME_ORGANIZATION        L"Organization"
#define CLASS_NAME_ORGANIZATIONAL_ROLE L"Organizational Role"
#define CLASS_NAME_ORGANIZATIONAL_UNIT L"Organizational Unit"
#define CLASS_NAME_PRINTER             L"Printer"
#define CLASS_NAME_PRINT_SERVER        L"Print Server"
#define CLASS_NAME_PROFILE             L"Profile"
#define CLASS_NAME_QUEUE               L"Queue"
#define CLASS_NAME_TOP                 L"Top"
#define CLASS_NAME_UNKNOWN             L"Unknown"
#define CLASS_NAME_USER                L"User"
#define CLASS_NAME_VOLUME              L"Volume"


//
// Node structure in the registered service link list and
// functions to add/remove items from the link list
//

typedef struct _REGISTERED_SERVICE {
    WORD nSapType;                      // SAP Type
    BOOL fAdvertiseBySap;               // TRUE if advertise by SAP agent
    LPSERVICE_INFO pServiceInfo;        // Info about this service
    struct _REGISTERED_SERVICE *Next;   // Points to the next service node
} REGISTERED_SERVICE, *PREGISTERED_SERVICE;


PREGISTERED_SERVICE
GetServiceItemFromList(
    IN WORD   nSapType,
    IN LPWSTR pServiceName
);

DWORD
NwRegisterService(
    IN LPSERVICE_INFO lpServiceInfo,
    IN WORD nSapType,
    IN HANDLE hEventHandle
);

DWORD
NwDeregisterService(
    IN LPSERVICE_INFO lpServiceInfo,
    IN WORD nSapType
);

DWORD
NwGetService(
    IN  LPWSTR  Reserved,
    IN  WORD    nSapType,
    IN  LPWSTR  lpServiceName,
    IN  DWORD   dwProperties,
    OUT LPBYTE  lpServiceInfo,
    IN  DWORD   dwBufferLength,
    OUT LPDWORD lpdwBytesNeeded
);

VOID
NwInitializeServiceProvider(
    VOID
    );

VOID
NwTerminateServiceProvider(
    VOID
    );

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _NWMISC_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\inc\nwauth.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:  

    nwauth.h

Abstract:

    Header for data structures provided by the NetWare
    authentication package.

Author:

    Rita Wong      (ritaw)      4-Feb-1994

Revision History:

--*/

#ifndef _NWAUTH_INCLUDED_
#define _NWAUTH_INCLUDED_

#include <nwcons.h>

//
// Name of the authentication package.
//
#define NW_AUTH_PACKAGE_NAME  "NETWARE_AUTHENTICATION_PACKAGE_V1_0"

//
//  LsaCallAuthenticationPackage() submission and response
//  message types.
//

typedef enum _NWAUTH_MESSAGE_TYPE {
    NwAuth_GetCredential = 0,
    NwAuth_SetCredential
} NWAUTH_MESSAGE_TYPE, *PNWAUTH_MESSAGE_TYPE;

//
// NwAuth_GetCredential submit buffer and response
//
typedef struct _NWAUTH_GET_CREDENTIAL_REQUEST {
    NWAUTH_MESSAGE_TYPE MessageType;
    LUID LogonId;
} NWAUTH_GET_CREDENTIAL_REQUEST, *PNWAUTH_GET_CREDENTIAL_REQUEST;

typedef struct _NWAUTH_GET_CREDENTIAL_RESPONSE {
    WCHAR UserName[NW_MAX_USERNAME_LEN + 1];
    WCHAR Password[NW_MAX_PASSWORD_LEN + 1];
} NWAUTH_GET_CREDENTIAL_RESPONSE, *PNWAUTH_GET_CREDENTIAL_RESPONSE;


//
// NwAuth_SetCredential submit buffer
//
typedef struct _NWAUTH_SET_CREDENTIAL_REQUEST {
    NWAUTH_MESSAGE_TYPE MessageType;
    LUID LogonId;
    WCHAR UserName[NW_MAX_USERNAME_LEN + 1];
    WCHAR Password[NW_MAX_PASSWORD_LEN + 1];
} NWAUTH_SET_CREDENTIAL_REQUEST, *PNWAUTH_SET_CREDENTIAL_REQUEST;

#define NW_ENCODE_SEED   0x5C
#define NW_ENCODE_SEED2  0xA9
#define NW_ENCODE_SEED3  0x83

#endif // _NWAUTH_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\inc\rnrdefs.h ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    nwmisc.h

Abstract:

    Header which specifies the misc routines used by the workstation service.

Author:

    Arnold Miller (arnoldm)     15-Feb-1996

Revision History:


--*/
#ifndef __RNRDEFS_H__
#define __RNRDEFS_H__

#include "sapcmn.h"

//
// Bit defs for the protocols
//

#define IPX_BIT            1
#define SPX_BIT            2
#define SPXII_BIT          4

//
// forwards\
//

struct _SAP_RNR_CONTEXT;
//
// Bindery control
//

typedef struct _BinderyControl
{
    LONG lIndex;
} BINDERYCONTROL, *PBINDERYCONTROL;

//
// SAP RnR context information. This is linked off of the
// SAP_BCAST_CONTROL defined ahead
//

typedef struct _SAP_DATA
{
    struct _SAP_DATA *  sapNext;
                                     // save everything except hop count
    WORD         sapid;              // for a sanity check
    CHAR         sapname[48];        // what we don't know
    BYTE         socketAddr[IPX_ADDRESS_LENGTH];         // and what we seek
} SAP_DATA, *PSAP_DATA;
    
//
//
// Sap bcast control
// An important note. fFlags is set only by the thread executing
// a LookupServiceBegin or a LookupServiceNext. It may be tested by
// any thread. Its counterpart, dwControlFlags in SAP_RNR_CONTEXT
// is reserved for setting by LookupServiceBegin and LookupServiceEnd. Once
// again any thread may look at it. This insures no loss of data on an
// MP machine without needing a critical section.
//

typedef struct _SAP_BCAST_CONTROL
{
    DWORD dwIndex;                 // loop control
    DWORD dwTickCount;             // tick count of last send
    DWORD fFlags;                  // various flags
    PVOID pvArg;
    SOCKET s;
    CRITICAL_SECTION csMonitor;    // This is to keep
                                   // out internal structures sane. Note
                                   // it does not provide rational
                                   // serialization. In particular,  if
                                   // multiple threads use the same
                                   // handle simultaneously, there is no
                                   // guaranteed serialization.
    PSAP_DATA psdNext1;            // next to return
    PSAP_DATA psdHead;             // list head
    PSAP_DATA psdTail;
    struct _SAP_RNR_CONTEXT * psrc;  // need this   
    DWORD (*Func)(PVOID pvArg1, PSAP_IDENT_HEADER pSap, PDWORD pdwErr);
    BOOL  (*fCheckCancel)(PVOID pvArg1);
    WORD    wQueryType;
} SAP_BCAST_CONTROL, *PSAP_BCAST_CONTROL;

//
// Flags for above

#define SBC_FLAG_NOMORE  0x1

//
// Structure used by the old RnR Sap lookup as the pvArg value in
// SAP_BCAST control
//

#ifndef _NTDEF_
typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength), length_is(Length) ]
#endif // MIDL_PASS
    PCHAR Buffer;
} OEM_STRING;
#endif

typedef struct _OldRnRSap
{
    OEM_STRING * poem;
    HANDLE hCancel;
    LPVOID lpCsAddrBuffer;
    LPDWORD lpdwBufferLength;
    DWORD   nProt;
    LPDWORD lpcAddress;
} OLDRNRSAP, *POLDRNRSAP;

//
// Return codes from the coroutine
//

#define dwrcDone      1       // all done, return success
#define dwrcCancel    2       // all done, return cancelled
#define dwrcNoWait    3       // keep going, but never wait.
#define dwrcNil       4       // do whatever you want

//
// Sap service query packet format
//

typedef struct _SAP_REQUEST {
    USHORT QueryType;
    USHORT ServerType;
} SAP_REQUEST, *PSAP_REQUEST; 

#define QT_GENERAL_QUERY 1
#define QT_NEAREST_QUERY 3

// The context information we put inside of an RNRNSHANDLE structure
// to keep track of what we are doing
// N.B. See comment on SAP_BCAST_CONTROL about the use of dwControlFlags.
//

typedef struct _SAP_RNR_CONTEXT
{
    struct _SAP_RNR_CONTEXT * pNextContext;
    LONG      lSig;
    LONG      lInUse;
    DWORD     dwCount;                // count of queries made
    DWORD     fFlags;                 // always nice to have
    DWORD     dwControlFlags;
    DWORD     fConnectionOriented;
    WORD      wSapId;                // the type desired
    HANDLE    Handle;                 // the corresponding RnR handle
    DWORD     nProt;
    GUID      gdType;                // the type we are seeking
    GUID      gdProvider;
    HANDLE    hServer;
    WCHAR     wszContext[48];
    WCHAR     chwName[48];            // the name, if any 
    CHAR      chName[48];             // OEM form of the name for SAP
    DWORD     dwUnionType;            // type of lookup, once we know
    union
    {
        SAP_BCAST_CONTROL sbc;
        BINDERYCONTROL    bc;
    } u_type;
    PVOID     pvVersion;              // a trick to get the version here.
} SAP_RNR_CONTEXT, *PSAP_RNR_CONTEXT;

#define RNR_SIG 0xaabbccdd
//
// union types
//

#define LOOKUP_TYPE_NIL     0
#define LOOKUP_TYPE_SAP     1
#define LOOKUP_TYPE_BINDERY 2

      
#define SAP_F_END_CALLED  0x1             // generic  cancel


//
// Defs for the bindery Class info
// This defines the format of each ClassInfo property segement. It looks
// somewhat like an actual ClassInfo, but considerably compressed. Note
// due to marshalling problems, any complex value, such as a GUID,
// should be stored as a string and then imported. Hence, we define
// types for what we can anticipate.
// 

typedef struct _BinderyClasses
{
    BYTE     bType;
    BYTE     bSizeOfType;
    BYTE     bSizeOfString;
    BYTE     bOffset;              // where the data area begins
    BYTE     bFlags;
    BYTE     bFiller;
    WORD     wNameSpace;           // the applicable namespace
    CHAR     cDataArea[120];       // where the type and string are placed
} BINDERYCLASSES, *PBINDERYCLASSES;

#define BT_DWORD  1           // DWORD
#define BT_WORD   2           // WORD
#define BT_GUID   3           // a string GUID (ASCII)
#define BT_STR    3           // an OEM string
#define BT_OID    4           // an object ID (TBD)
#define BT_BSTR   5           // a binary string (very dangerous)
#define BT_WSTR   6           // UNICODE string. Unmarshalled!


#define RNRTYPE "RNR_TYPE"    // prop containing the GUID
#define RNRCLASSES "RNR_CLASSES" // the other property
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\lib\lsa.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    lsa.c

Abstract:

    This module provides helpers to call LSA, particularly for
    manipulating secret objects.

Author:

    Rita Wong (ritaw)     22-Apr-1993

--*/

#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winerror.h>
#include <winbase.h>

#include <nwlsa.h>

//-------------------------------------------------------------------//
//                                                                   //
// Constants and Macros                                              //
//                                                                   //
//-------------------------------------------------------------------//

#define NW_SECRET_PREFIX               L"_MS_NWCS_"


DWORD
NwOpenPolicy(
    IN ACCESS_MASK DesiredAccess,
    OUT LSA_HANDLE *PolicyHandle
    )
/*++

Routine Description:

    This function gets a handle to the local security policy by calling
    LsaOpenPolicy.

Arguments:

    DesiredAccess - Supplies the desired access to the local security
        policy.

    PolicyHandle - Receives a handle to the opened policy.

Return Value:

    NO_ERROR - Policy handle is returned.

    Error from LSA.

--*/
{
    NTSTATUS ntstatus;
    OBJECT_ATTRIBUTES ObjAttributes;


    //
    // Open a handle to the local security policy.  Initialize the
    // objects attributes structure first.
    //
    InitializeObjectAttributes(
        &ObjAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    ntstatus = LsaOpenPolicy(
                   NULL,
                   &ObjAttributes,
                   DesiredAccess,
                   PolicyHandle
                   );

    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("NWWORKSTATION: LsaOpenPolicy returns %08lx\n",
                 ntstatus));

        return RtlNtStatusToDosError(ntstatus);
    }

    return NO_ERROR;
}


DWORD
NwOpenSecret(
    IN ACCESS_MASK DesiredAccess,
    IN LSA_HANDLE PolicyHandle,
    IN LPWSTR LsaSecretName,
    OUT PLSA_HANDLE SecretHandle
    )
/*++

Routine Description:

    This function opens a handle to the specified secret object.

Arguments:

    DesiredAccess - Supplies the desired access to the secret object.

    PolicyHandle - Supplies a handle to an already opened LSA policy.

    LsaSecretName - Supplies the name of the secret to open.

    SecretHandle - Receives the handle of the opened secret.

Return Value:

    NO_ERROR - Secret handle is returned.

    Error from LSA.

--*/
{
    NTSTATUS ntstatus;
    UNICODE_STRING SecretNameString;


    RtlInitUnicodeString(&SecretNameString, LsaSecretName);

    ntstatus = LsaOpenSecret(
                   PolicyHandle,
                   &SecretNameString,
                   DesiredAccess,
                   SecretHandle
                   );


    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("NWWORKSTATION: LsaOpenSecret %ws returns %08lx\n",
                 LsaSecretName, ntstatus));

        return RtlNtStatusToDosError(ntstatus);
    }

    return NO_ERROR;
}


DWORD
NwFormSecretName(
    IN  LPWSTR Qualifier,
    OUT LPWSTR *LsaSecretName
    )
/*++

Routine Description:

    This function creates a secret name from the user name.
    It also allocates the buffer to return the created secret name which
    must be freed by the caller using LocalFree when done with it.

Arguments:

    Qualifier - Supplies the qualifier which forms part of part of the secret
        object name we are creating.

    LsaSecretName - Receives a pointer to the buffer which contains the
        secret object name.

Return Value:

    NO_ERROR - Successfully returned secret name.

    ERROR_NOT_ENOUGH_MEMORY - Failed to allocate buffer to hold the secret
        name.

--*/
{
    if ((*LsaSecretName = (LPWSTR)LocalAlloc(
                              0,
                              (wcslen(NW_SECRET_PREFIX) +
                               wcslen(Qualifier) +
                               1) * sizeof(WCHAR)
                              )) == NULL) {

        KdPrint(("NWWORKSTATION: NwFormSecretName: LocalAlloc failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(*LsaSecretName, NW_SECRET_PREFIX);
    wcscat(*LsaSecretName, Qualifier);

    return NO_ERROR;
}



DWORD
NwSetPassword(
    IN LPWSTR Qualifier,
    IN LPWSTR Password
    )
/*++

Routine Description:

    This function opens ( creates one if needed ) the LSA secret object, 
    and sets it with the specified password.

Arguments:

    Qualifier - Supplies the qualifier which forms part of part of the secret
        object name to be created.

    Password - Supplies the user specified password for an account.

Return Value:

    NO_ERROR - Secret object for the password is created and set with new value.

    Error from LSA.

--*/
{
    DWORD status;
    NTSTATUS ntstatus;
    LSA_HANDLE PolicyHandle;

    LSA_HANDLE SecretHandle;
    UNICODE_STRING SecretNameString;
    LPWSTR LsaSecretName;

    UNICODE_STRING NewPasswordString;
    UNICODE_STRING OldPasswordString;


    //
    // Open a handle to the local security policy.
    //
    if ((status = NwOpenPolicy(
                      POLICY_CREATE_SECRET,
                      &PolicyHandle
                      )) != NO_ERROR) {
        KdPrint(("NWWORKSTATION: NwCreatePassword: NwOpenPolicy failed\n"));
        return status;
    }

    //
    // Create the LSA secret object.  But first, form a secret name.
    //
    if ((status = NwFormSecretName(
                      Qualifier,
                      &LsaSecretName
                      )) != NO_ERROR) {
        (void) LsaClose(PolicyHandle);
        return status;
    }

    RtlInitUnicodeString(&SecretNameString, LsaSecretName);

    ntstatus = LsaCreateSecret(
                   PolicyHandle,
                   &SecretNameString,
                   SECRET_SET_VALUE | DELETE,
                   &SecretHandle
                   );


    //
    // note: ignore object already exists error. just use the existing
    //       object. this could be because the user didnt completely cleanup
    //       during deinstall. the unique names makes it unlikely to be a real
    //       collision.
    //
    if ( ntstatus == STATUS_OBJECT_NAME_COLLISION ) {
        ntstatus = NwOpenSecret(
                       SECRET_SET_VALUE,
                       PolicyHandle,
                       LsaSecretName,
                       &SecretHandle
                       );
    }

    //
    // Don't need the name or policy handle anymore.
    //
    (void) LocalFree((HLOCAL) LsaSecretName);
    (void) LsaClose(PolicyHandle);

    if (! NT_SUCCESS(ntstatus)) {

        KdPrint(("NWWORKSTATION: NwCreatePassword: LsaCreateSecret or LsaOpenSecret returned %08lx for %ws\n", ntstatus, LsaSecretName));

        return RtlNtStatusToDosError(ntstatus);
    }
    

    RtlInitUnicodeString(&OldPasswordString, NULL);
    RtlInitUnicodeString(&NewPasswordString, Password);

    ntstatus = LsaSetSecret(
                   SecretHandle,
                   &NewPasswordString,
                   &OldPasswordString
                   );

    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("NWWORKSTATION NwCreatePassword: LsaSetSecret returned %08lx\n",
                 ntstatus));

        status = RtlNtStatusToDosError(ntstatus);

        //
        // Delete the secret object
        //
        ntstatus = LsaDelete(SecretHandle);

        if (! NT_SUCCESS(ntstatus)) {
            KdPrint(("NWWORKSTATION: NwCreatePassword: LsaDelete to restore back to original returned %08lx\n",
                     ntstatus));
            (void) LsaClose(SecretHandle);
        }

        //
        // Secret handle is closed by LsaDelete if successfully deleted.
        //
        return status;
    }

    (void) LsaClose(SecretHandle);

    return NO_ERROR;
}



DWORD
NwDeletePassword(
    IN LPWSTR Qualifier
    )
/*++

Routine Description:

    This function deletes the LSA secret object whose name is derived
    from the specified Qualifier.

Arguments:

    Qualifier - Supplies the qualifier which forms part of part of the secret
        object name to be deleted.

Return Value:

    NO_ERROR - Secret object for password is deleted.

    Error from LSA.

--*/
{
    DWORD status;
    NTSTATUS ntstatus;

    LSA_HANDLE PolicyHandle;

    LSA_HANDLE SecretHandle;
    LPWSTR LsaSecretName;


    //
    // Open a handle to the local security policy.
    //
    if ((status = NwOpenPolicy(
            POLICY_VIEW_LOCAL_INFORMATION,
            &PolicyHandle
            )) != NO_ERROR) {
        KdPrint(("NWWORKSTATION: NwDeletePassword: NwOpenPolicy failed\n"));
        return status;
    }

    //
    // Get the secret object name from the specified user name.
    //
    if ((status = NwFormSecretName(
                      Qualifier,
                      &LsaSecretName
                      )) != NO_ERROR) {
        (void) LsaClose(PolicyHandle);
        return status;
    }

    status = NwOpenSecret(
                 DELETE,
                 PolicyHandle,
                 LsaSecretName,
                 &SecretHandle
                 );

    //
    // Don't need the name or policy handle anymore.
    //
    (void) LocalFree((HLOCAL) LsaSecretName);
    (void) LsaClose(PolicyHandle);

    if (status != NO_ERROR) {
        KdPrint(("NWWORKSTATION: NwDeletePassword: NwOpenSecret failed\n"));
        return status;
    }

    ntstatus = LsaDelete(SecretHandle);

    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("NWWORKSTATION: NwDeletePassword: LsaDelete returned %08lx\n",
                 ntstatus));
        (void) LsaClose(SecretHandle);
        return RtlNtStatusToDosError(ntstatus);
    }

    return NO_ERROR;
}



DWORD
NwGetPassword(
    IN  LPWSTR Qualifier,
    OUT PUNICODE_STRING *Password,
    OUT PUNICODE_STRING *OldPassword
    )
/*++

Routine Description:

    This function retrieves the current password and old password
    values from the service secret object given the user name.

Arguments:

    Qualifier - Supplies the qualifier which forms part of the key to the
        secret object name.

    Password - Receives a pointer to the string structure that contains
        the password.

    OldPassword - Receives a pointer to the string structure that
        contains the old password.

Return Value:

    NO_ERROR - Secret object for password is changed to new value.

    Error from LSA.

--*/
{
    DWORD status;
    NTSTATUS ntstatus;

    LSA_HANDLE PolicyHandle;
    LSA_HANDLE SecretHandle;

    LPWSTR LsaSecretName;


    //
    // Open a handle to the local security policy to read the
    // value of the secret.
    //
    if ((status = NwOpenPolicy(
                      POLICY_VIEW_LOCAL_INFORMATION,
                      &PolicyHandle
                      )) != NO_ERROR) {
        return status;
    }

    //
    // Get the secret object name from the specified user name.
    //
    if ((status = NwFormSecretName(
                      Qualifier,
                      &LsaSecretName
                      )) != NO_ERROR) {
        (void) LsaClose(PolicyHandle);
        return status;
    }

    status = NwOpenSecret(
                 SECRET_QUERY_VALUE,
                 PolicyHandle,
                 LsaSecretName,
                 &SecretHandle
                 );

    //
    // Don't need the name or policy handle anymore.
    //
    (void) LocalFree((HLOCAL) LsaSecretName);
    (void) LsaClose(PolicyHandle);

    if (status != NO_ERROR) {
        KdPrint(("NWWORKSTATION: ScGetSecret: ScOpenSecret failed\n"));
        return status;
    }

    //
    // Query the old value of the secret object so that we can
    // we can restore it if we fail to change the password later.
    //
    ntstatus = LsaQuerySecret(
                   SecretHandle,
                   Password,
                   NULL,                   // don't need set time
                   OldPassword,
                   NULL                    // don't need set time
                   );

    (void) LsaClose(SecretHandle);

    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("NWWORKSTATION: NwGetPassword: LsaQuerySecret for previous values returned %08lx\n",
                 ntstatus));

        return RtlNtStatusToDosError(ntstatus);
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\inc\sapcmn.h ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    sapcmn.h.h

Abstract:

    Header containing the most basic common SAP definitions. This
    was derived from the larger file, nwmisc.h in order to
    be available to either the old RNR or the new RNR routines.

Author:

    Arnold Miller (ArnoldM)     8-Dec-95

Revision History:

    ArnoldM 8-Dec-95 Created from pieces of nwmisc.h
--*/

#ifndef __SAPCMN_H__
#define __SAPCMN_H__
//
// Definitions common to client and server side files (getaddr.c and service.c)
//

#define IPX_ADDRESS_LENGTH         12
#define IPX_ADDRESS_NETNUM_LENGTH  4
#define SAP_ADDRESS_LENGTH         15
#define SAP_ADVERTISE_FREQUENCY    60000  // 60 seconds
#define SAP_MAXRECV_LENGTH         544
#define SAP_OBJECT_NAME_MAX_LENGTH 48

//
// N.B. Keep the following defines in synch.
//
#define NW_RDR_PREFERRED_SERVER   L"\\Device\\Nwrdr\\*"
#define NW_RDR_NAME               L"\\Device\\Nwrdr\\"
#define NW_RDR_PREFERRED_SUFFIX    L"*"
//
// Sap server identification packet format
//

typedef struct _SAP_IDENT_HEADER {
    USHORT ServerType;
    UCHAR  ServerName[48];
    UCHAR  Address[IPX_ADDRESS_LENGTH];
    USHORT HopCount;
} SAP_IDENT_HEADER, *PSAP_IDENT_HEADER;


//
// Sap server identification packet format - Extended
//

typedef struct _SAP_IDENT_HEADER_EX {
    USHORT ResponseType;
    USHORT ServerType;
    UCHAR  ServerName[SAP_OBJECT_NAME_MAX_LENGTH];
    UCHAR  Address[IPX_ADDRESS_LENGTH];
    USHORT HopCount;
} SAP_IDENT_HEADER_EX, *PSAP_IDENT_HEADER_EX;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\inc\splutil.h ===
/*++

Copyright (c) 1992-1993 Microsoft Corporation

Module Name:

    splutil.h

Abstract:

    Header file for utilities used in Novell Print Provider

Author:

    Yi-Hsin Sung (yihsins) 12-Apr-1993

Revision History:

--*/

#ifndef _SPLUTIL_H_
#define _SPLUTIL_H_

#define offsetof(type, identifier) (DWORD_PTR)(&(((type)0)->identifier))

#ifdef __cplusplus
extern "C" {
#endif

extern DWORD_PTR PrinterInfo1Offsets[];
extern DWORD_PTR PrinterInfo2Offsets[];
extern DWORD_PTR PrinterInfo3Offsets[];
extern DWORD_PTR JobInfo1Offsets[];
extern DWORD_PTR JobInfo2Offsets[];
extern DWORD_PTR AddJobInfo1Offsets[];

VOID
MarshallUpStructure(
   LPBYTE      lpStructure,
   PDWORD_PTR  lpOffsets,
   LPBYTE      lpBufferStart
);

VOID
MarshallDownStructure(
   LPBYTE      lpStructure,
   PDWORD_PTR  lpOffsets,
   LPBYTE      lpBufferStart
);

LPVOID
AllocNwSplMem(
    IN DWORD flags,
    IN DWORD cb
    );

VOID
FreeNwSplMem(
    IN LPVOID pMem,
    IN DWORD  cb
    );

LPWSTR
AllocNwSplStr(
    IN LPWSTR pStr
    );

VOID
FreeNwSplStr(
    IN LPWSTR pStr
);

BOOL
ValidateUNCName(
    IN LPWSTR pName
);

LPWSTR
GetNextElement(
               OUT LPWSTR *pPtr,
               IN  WCHAR token
);

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _SPLUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\lib\misc.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    api.c

Abstract:

    This module contains misc APIs that are used by the
    NWC wksta.

Author:

    ChuckC         2-Mar-94        Created


Revision History:

--*/


#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <nwcons.h>
#include <nwmisc.h>
#include <nwapi32.h>
#include "nwstatus.h"
#include "nwevent.h"

DWORD
NwMapStatus(
    IN  NTSTATUS NtStatus
    );

DWORD
NwOpenPreferredServer(
    PHANDLE ServerHandle
    );

NTSTATUS
NwOpenHandle(
    IN PUNICODE_STRING ObjectName,
    IN BOOL ValidateFlag,
    OUT PHANDLE ObjectHandle
    );

NTSTATUS
NwCallNtOpenFile(
    OUT PHANDLE ObjectHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PUNICODE_STRING ObjectName,
    IN ULONG OpenOptions
   );


//
// list of error mappings known for E3H calls. we do not have a single list
// because Netware reuses the numbers depending on call.
//

typedef struct _ERROR_MAP_ENTRY
{
    UCHAR NetError;
    NTSTATUS ResultingStatus;
}  ERROR_MAP_ENTRY ;

ERROR_MAP_ENTRY Error_Map_Bindery[] =
{

    //
    //  NetWare specific error mappings. Specific to E3H.
    //
    {  1, STATUS_DISK_FULL },
    {128, STATUS_SHARING_VIOLATION },
    {129, STATUS_INSUFF_SERVER_RESOURCES },
    {130, STATUS_ACCESS_DENIED },
    {131, STATUS_DATA_ERROR },
    {132, STATUS_ACCESS_DENIED },
    {133, STATUS_ACCESS_DENIED },
    {134, STATUS_ACCESS_DENIED },
    {135, STATUS_OBJECT_NAME_INVALID },
    {136, STATUS_INVALID_HANDLE },
    {137, STATUS_ACCESS_DENIED },
    {138, STATUS_ACCESS_DENIED },
    {139, STATUS_ACCESS_DENIED },
    {140, STATUS_ACCESS_DENIED },
    {141, STATUS_SHARING_VIOLATION },
    {142, STATUS_SHARING_VIOLATION },
    {143, STATUS_ACCESS_DENIED },
    {144, STATUS_ACCESS_DENIED },
    {145, STATUS_OBJECT_NAME_COLLISION },
    {146, STATUS_OBJECT_NAME_COLLISION },
    {147, STATUS_ACCESS_DENIED },
    {148, STATUS_ACCESS_DENIED },
    {150, STATUS_INSUFF_SERVER_RESOURCES },
    {151, STATUS_NO_SPOOL_SPACE },
    {152, STATUS_NO_SUCH_DEVICE },
    {153, STATUS_DISK_FULL },
    {154, STATUS_NOT_SAME_DEVICE },
    {155, STATUS_INVALID_HANDLE },
    {156, STATUS_OBJECT_PATH_NOT_FOUND },
    {157, STATUS_INSUFF_SERVER_RESOURCES },
    {158, STATUS_OBJECT_PATH_INVALID },
    {159, STATUS_SHARING_VIOLATION },
    {160, STATUS_DIRECTORY_NOT_EMPTY },
    {161, STATUS_DATA_ERROR },
    {162, STATUS_SHARING_VIOLATION },
    {192, STATUS_ACCESS_DENIED },
    {198, STATUS_ACCESS_DENIED },
    {211, STATUS_ACCESS_DENIED },
    {212, STATUS_PRINT_QUEUE_FULL },
    {213, STATUS_PRINT_CANCELLED },
    {214, STATUS_ACCESS_DENIED },
    {215, STATUS_PASSWORD_RESTRICTION },
    {216, STATUS_PASSWORD_RESTRICTION },
    {220, STATUS_ACCOUNT_DISABLED },
    {222, STATUS_PASSWORD_EXPIRED },
    {223, STATUS_PASSWORD_EXPIRED },
    {239, STATUS_OBJECT_NAME_INVALID },
    {240, STATUS_OBJECT_NAME_INVALID },
    {251, STATUS_INVALID_PARAMETER },
    {252, STATUS_NO_MORE_ENTRIES },
    {253, STATUS_FILE_LOCK_CONFLICT },
    {254, STATUS_FILE_LOCK_CONFLICT },
    {255, STATUS_UNSUCCESSFUL}
};


ERROR_MAP_ENTRY Error_Map_General[] =
{
    {  1, STATUS_DISK_FULL },
    {128, STATUS_SHARING_VIOLATION },
    {129, STATUS_INSUFF_SERVER_RESOURCES },
    {130, STATUS_ACCESS_DENIED },
    {131, STATUS_DATA_ERROR },
    {132, STATUS_ACCESS_DENIED },
    {133, STATUS_ACCESS_DENIED },
    {134, STATUS_ACCESS_DENIED },
    {135, STATUS_OBJECT_NAME_INVALID },
    {136, STATUS_INVALID_HANDLE },
    {137, STATUS_ACCESS_DENIED },
    {138, STATUS_ACCESS_DENIED },
    {139, STATUS_ACCESS_DENIED },
    {140, STATUS_ACCESS_DENIED },
    {141, STATUS_SHARING_VIOLATION },
    {142, STATUS_SHARING_VIOLATION },
    {143, STATUS_ACCESS_DENIED },
    {144, STATUS_ACCESS_DENIED },
    {145, STATUS_OBJECT_NAME_COLLISION },
    {146, STATUS_OBJECT_NAME_COLLISION },
    {147, STATUS_ACCESS_DENIED },
    {148, STATUS_ACCESS_DENIED },
    {150, STATUS_INSUFF_SERVER_RESOURCES },
    {151, STATUS_NO_SPOOL_SPACE },
    {152, STATUS_NO_SUCH_DEVICE },
    {153, STATUS_DISK_FULL },
    {154, STATUS_NOT_SAME_DEVICE },
    {155, STATUS_INVALID_HANDLE },
    {156, STATUS_OBJECT_PATH_NOT_FOUND },
    {157, STATUS_INSUFF_SERVER_RESOURCES },
    {158, STATUS_OBJECT_PATH_INVALID },
    {159, STATUS_SHARING_VIOLATION },
    {160, STATUS_DIRECTORY_NOT_EMPTY },
    {161, STATUS_DATA_ERROR },
    {162, STATUS_SHARING_VIOLATION },
    {192, STATUS_ACCESS_DENIED },
    {198, STATUS_ACCESS_DENIED },
    {211, STATUS_ACCESS_DENIED },
    {212, STATUS_PRINT_QUEUE_FULL },
    {213, STATUS_PRINT_CANCELLED },
    {214, STATUS_ACCESS_DENIED },
    {215, STATUS_DEVICE_BUSY },
    {216, STATUS_DEVICE_DOES_NOT_EXIST },
    {220, STATUS_ACCOUNT_DISABLED },
    {222, STATUS_PASSWORD_EXPIRED },
    {223, STATUS_PASSWORD_EXPIRED },
    {239, STATUS_OBJECT_NAME_INVALID },
    {240, STATUS_OBJECT_NAME_INVALID },
    {251, STATUS_INVALID_PARAMETER },
    {252, STATUS_NO_MORE_ENTRIES },
    {253, STATUS_FILE_LOCK_CONFLICT },
    {254, STATUS_FILE_LOCK_CONFLICT },
    {255, STATUS_UNSUCCESSFUL}
};

#define NUM_ERRORS(x)  (sizeof(x)/sizeof(x[0]))

DWORD
NwMapBinderyCompletionCode(
    IN  NTSTATUS NtStatus
    )
/*++

Routine Description:

    This function takes a bindery completion code embedded in an NT status
    code and maps it to the appropriate Win32 error code. Used specifically
    for E3H operations.

Arguments:

    NtStatus - Supplies the NT status (that contains the code in low 16 bits)

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD i; UCHAR code ;

    //
    // A small optimization for the most common case.
    //
    if (NtStatus == STATUS_SUCCESS)
        return NO_ERROR;

    //
    // Map connection errors specially.
    //

    if ( ( (NtStatus & 0xFFFF0000) == 0xC0010000) &&
         ( (NtStatus & 0xFF00) != 0 ) )
    {
        return ERROR_UNEXP_NET_ERR;
    }

    //
    // if facility code not set, assume it is NT Status
    //
    if ( (NtStatus & 0xFFFF0000) != 0xC0010000)
        return RtlNtStatusToDosError(NtStatus);

    code = (UCHAR)(NtStatus & 0x000000FF);
    for (i = 0; i < NUM_ERRORS(Error_Map_Bindery); i++)
    {
        if (Error_Map_Bindery[i].NetError == code)
            return( NwMapStatus(Error_Map_Bindery[i].ResultingStatus));
    }

    //
    // if cannot find let NwMapStatus do its best
    //
    return NwMapStatus(NtStatus);
}



DWORD
NwMapStatus(
    IN  NTSTATUS NtStatus
    )
/*++

Routine Description:

    This function takes an NT status code and maps it to the appropriate
    Win32 error code. If facility code is set, assume it is NW specific

Arguments:

    NtStatus - Supplies the NT status.

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD i; UCHAR code ;

    //
    // A small optimization for the most common case.
    //
    if (NtStatus == STATUS_SUCCESS)
        return NO_ERROR;

    //
    // Map connection errors specially.
    //

    if ( ( (NtStatus & 0xFFFF0000) == 0xC0010000) &&
         ( (NtStatus & 0xFF00) != 0 ) )
    {
        return ERROR_UNEXP_NET_ERR;
    }

    //
    // if facility code set, assume it is NW Completion code
    //
    if ( (NtStatus & 0xFFFF0000) == 0xC0010000)
    {
        code = (UCHAR)(NtStatus & 0x000000FF);
        for (i = 0; i < NUM_ERRORS(Error_Map_General); i++)
        {
            if (Error_Map_General[i].NetError == code)
            {
                //
                // map it to NTSTATUS and then drop thru to map to Win32
                //
                NtStatus = Error_Map_General[i].ResultingStatus ;
                break ;
            }
        }
    }

    switch (NtStatus) {
        case STATUS_OBJECT_NAME_COLLISION:
            return ERROR_ALREADY_ASSIGNED;

        case STATUS_OBJECT_NAME_NOT_FOUND:
            return ERROR_NOT_CONNECTED;

        case STATUS_IMAGE_ALREADY_LOADED:
        case STATUS_REDIRECTOR_STARTED:
            return ERROR_SERVICE_ALREADY_RUNNING;

        case STATUS_REDIRECTOR_HAS_OPEN_HANDLES:
            return ERROR_REDIRECTOR_HAS_OPEN_HANDLES;

        case STATUS_NO_MORE_FILES:
        case STATUS_NO_MORE_ENTRIES:
            return WN_NO_MORE_ENTRIES;

        case STATUS_MORE_ENTRIES:
            return WN_MORE_DATA;

        case STATUS_CONNECTION_IN_USE:
            return ERROR_DEVICE_IN_USE;

        case NWRDR_PASSWORD_HAS_EXPIRED:
            return NW_PASSWORD_HAS_EXPIRED;

        case STATUS_INVALID_DEVICE_REQUEST:
            return ERROR_CONNECTION_INVALID;

        default:
            return RtlNtStatusToDosError(NtStatus);
    }
}

DWORD
NwGetGraceLoginCount(
    LPWSTR  Server,
    LPWSTR  UserName,
    LPDWORD lpResult
    )
/*++

Routine Description:

    Get the number grace logins for a user.

Arguments:

    Server - the server to authenticate against

    UserName - the user account

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD status ;
    HANDLE hConn ;
    CHAR UserNameO[NW_MAX_USERNAME_LEN+1] ;
    BYTE LoginControl[128] ;
    BYTE MoreFlags, PropFlags ;

    //
    // skip the backslashes if present
    //
    if (*Server == L'\\')
        Server += 2 ;

    //
    // attach to the NW server
    //
    if (status = NWAttachToFileServerW(Server,
                                       0,
                                       &hConn))
    {
        return status ;
    }

    //
    // convert unicode UserName to OEM, and then call the NCP
    //
    if ( !WideCharToMultiByte(CP_OEMCP,
                              0,
                              UserName,
                              -1,
                              UserNameO,
                              sizeof(UserNameO),
                              NULL,
                              NULL))
    {
        status = GetLastError() ;
    }
    else
    {
        status = NWReadPropertyValue( hConn,
                                      UserNameO,
                                      OT_USER,
                                      "LOGIN_CONTROL",
                                      1,
                                      LoginControl,
                                      &MoreFlags,
                                      &PropFlags) ;
    }

    //
    // dont need these anymore. if any error, bag out
    //
    (void) NWDetachFromFileServer(hConn) ;


    if (status == NO_ERROR)
        *lpResult = (DWORD) LoginControl[7] ;

    return status ;
}


WORD
NwParseNdsUncPath(
    IN OUT LPWSTR * Result,
    IN LPWSTR ContainerName,
    IN ULONG flag
)
/*++

Routine Description:

    This function is used to extract either the tree name, fully distinguished
    name path to an object, or object name, out of a complete NDS UNC path.

Arguments:

    Result - parsed result buffer.
    ContainerName - Complete NDS UNC path that is to be parsed.
    flag - Flag indicating operation to be performed:

         PARSE_NDS_GET_TREE_NAME
         PARSE_NDS_GET_PATH_NAME
         PARSE_NDS_GET_OBJECT_NAME


Return Value:

    Length of string in result buffer. If error occured, 0 is returned.

--*/ // NwParseNdsUncPath
{
    unsigned short length = 2;
    unsigned short totalLength = (USHORT) wcslen( ContainerName );

    if ( totalLength < 2 )
        return 0;

    //
    // First get length to indicate the character in the string that indicates the
    // "\" in between the tree name and the rest of the UNC path.
    //
    // Example:  \\<tree name>\<path to object>[\|.]<object>
    //                        ^
    //                        |
    //
    while ( length < totalLength && ContainerName[length] != L'\\' )
    {
        length++;
    }

    if ( flag == PARSE_NDS_GET_TREE_NAME )
    {
        *Result = (LPWSTR) ( ContainerName + 2 );

        return ( length - 2 ) * sizeof( WCHAR ); // Take off 2 for the two \\'s
    }

    if ( flag == PARSE_NDS_GET_PATH_NAME && length == totalLength )
    {
        *Result = ContainerName;

        return 0;
    }

    if ( flag == PARSE_NDS_GET_PATH_NAME )
    {
        *Result = ContainerName + length + 1;

        return ( totalLength - length - 1 ) * sizeof( WCHAR );
    }

    *Result = ContainerName + totalLength - 1;
    length = 1;

    while ( **Result != L'\\' )
    {
        *Result--;
        length++;
    }

    *Result++;
    length--;

    return length * sizeof( WCHAR );
}


DWORD
NwOpenAServer(
    PWCHAR pwszServName,
    PHANDLE ServerHandle,
    BOOL    fVerify
    )
/*++

Routine Description:

    This routine opens a handle to a server.

Arguments:

    ServerHandle - Receives an opened handle to the preferred or
        nearest server.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    UNICODE_STRING AServer;
    WCHAR wszName[sizeof(NW_RDR_NAME) + (48 * sizeof(WCHAR))];
    DWORD wLen;


    if(!pwszServName)
    {
        pwszServName = NW_RDR_PREFERRED_SERVER;
        RtlInitUnicodeString(&AServer, wszName);
    }
    else
    {
        wLen = wcslen(pwszServName);
        if(wLen > 47)
        {
            return(WSAEFAULT);
        }
        wcscpy(wszName, NW_RDR_NAME);
        wcscat(wszName, pwszServName);
        RtlInitUnicodeString(&AServer, wszName);
    }

    return RtlNtStatusToDosError(
               NwOpenHandle(&AServer, fVerify, ServerHandle)
               );

}


DWORD
NwOpenPreferredServer(
    PHANDLE ServerHandle
    )
/*++

Routine Description:

    This routine opens a handle to the preferred server.  If the
    preferred server has not been specified, a handle to the
    nearest server is opened instead.

Arguments:

    ServerHandle - Receives an opened handle to the preferred or
        nearest server.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    UNICODE_STRING PreferredServer;


    //
    // The NetWare redirector recognizes "*" to mean the preferred
    // or nearest server.
    //
    RtlInitUnicodeString(&PreferredServer, NW_RDR_PREFERRED_SERVER);

    return RtlNtStatusToDosError(
               NwOpenHandle(&PreferredServer, FALSE, ServerHandle)
               );

}


NTSTATUS
NwOpenHandle(
    IN PUNICODE_STRING ObjectName,
    IN BOOL ValidateFlag,
    OUT PHANDLE ObjectHandle
    )
/*++

Routine Description:

    This function opens a handle to \Device\Nwrdr\<ObjectName>.

Arguments:

    ObjectName - Supplies the name of the redirector object to open.

    ValidateFlag - Supplies a flag which if TRUE, opens the handle to
        the object by validating the default user account.

    ObjectHandle - Receives a pointer to the opened object handle.

Return Value:

    STATUS_SUCCESS or reason for failure.

--*/
{
    ACCESS_MASK DesiredAccess = SYNCHRONIZE;


    if (ValidateFlag) {

        //
        // The redirector only authenticates the default user credential
        // if the remote resource is opened with write access.
        //
        DesiredAccess |= FILE_WRITE_DATA;
    }


    *ObjectHandle = NULL;

    return NwCallNtOpenFile(
               ObjectHandle,
               DesiredAccess,
               ObjectName,
               FILE_SYNCHRONOUS_IO_NONALERT
               );

}


NTSTATUS
NwCallNtOpenFile(
    OUT PHANDLE ObjectHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PUNICODE_STRING ObjectName,
    IN ULONG OpenOptions
    )
{

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;



    InitializeObjectAttributes(
        &ObjectAttributes,
        ObjectName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    ntstatus = NtOpenFile(
                   ObjectHandle,
                   DesiredAccess,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   OpenOptions
                   );

    if (!NT_ERROR(ntstatus) &&
        !NT_INFORMATION(ntstatus) &&
        !NT_WARNING(ntstatus))  {

        ntstatus = IoStatusBlock.Status;

    }

    return ntstatus;
}


BOOL
NwConvertToUnicode(
    OUT LPWSTR *UnicodeOut,
    IN LPSTR  OemIn
    )
/*++

Routine Description:

    This function converts the given OEM string to a Unicode string.
    The Unicode string is returned in a buffer allocated by this
    function and must be freed with LocalFree.

Arguments:

    UnicodeOut - Receives a pointer to the Unicode string.

    OemIn - This is a pointer to an ansi string that is to be converted.

Return Value:

    TRUE - The conversion was successful.

    FALSE - The conversion was unsuccessful.  In this case a buffer for
        the unicode string was not allocated.

--*/
{
    NTSTATUS ntstatus;
    DWORD BufSize;
    UNICODE_STRING UnicodeString;
    OEM_STRING OemString;


    //
    // Allocate a buffer for the unicode string.
    //

    BufSize = (strlen(OemIn) + 1) * sizeof(WCHAR);

    *UnicodeOut = LocalAlloc(LMEM_ZEROINIT, BufSize);

    if (*UnicodeOut == NULL) {
        KdPrint(("NWWORKSTATION: NwConvertToUnicode:LocalAlloc failed %lu\n",
                 GetLastError()));
        return FALSE;
    }

    //
    // Initialize the string structures
    //
    RtlInitAnsiString((PANSI_STRING) &OemString, OemIn);

    UnicodeString.Buffer = *UnicodeOut;
    UnicodeString.MaximumLength = (USHORT) BufSize;
    UnicodeString.Length = 0;

    //
    // Call the conversion function.
    //
    ntstatus = RtlOemStringToUnicodeString(
                   &UnicodeString,     // Destination
                   &OemString,         // Source
                   FALSE               // Allocate the destination
                   );

    if (ntstatus != STATUS_SUCCESS) {

        KdPrint(("NWWORKSTATION: NwConvertToUnicode: RtlOemStringToUnicodeString failure x%08lx\n",
                 ntstatus));

        (void) LocalFree((HLOCAL) *UnicodeOut);
        *UnicodeOut = NULL;
        return FALSE;
    }

    *UnicodeOut = UnicodeString.Buffer;

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\lib\splutil.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    splutil.c

Abstract:

    This module provides all the utility functions for the netware print 
    provider.
 
Author:

    Yi-Hsin Sung    (yihsins)   15-Apr-1993

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winspool.h>
#include <splutil.h>

DWORD_PTR PrinterInfo1Offsets[]={offsetof(LPPRINTER_INFO_1W, pDescription),
                             offsetof(LPPRINTER_INFO_1W, pName),
                             offsetof(LPPRINTER_INFO_1W, pComment),
                             0xFFFFFFFF};

DWORD_PTR PrinterInfo2Offsets[]={offsetof(LPPRINTER_INFO_2W, pServerName),
                             offsetof(LPPRINTER_INFO_2W, pPrinterName),
                             offsetof(LPPRINTER_INFO_2W, pShareName),
                             offsetof(LPPRINTER_INFO_2W, pPortName),
                             offsetof(LPPRINTER_INFO_2W, pDriverName),
                             offsetof(LPPRINTER_INFO_2W, pComment),
                             offsetof(LPPRINTER_INFO_2W, pLocation),
                             offsetof(LPPRINTER_INFO_2W, pDevMode),
                             offsetof(LPPRINTER_INFO_2W, pSepFile),
                             offsetof(LPPRINTER_INFO_2W, pPrintProcessor),
                             offsetof(LPPRINTER_INFO_2W, pDatatype),
                             offsetof(LPPRINTER_INFO_2W, pParameters),
                             offsetof(LPPRINTER_INFO_2W, pSecurityDescriptor),
                             0xFFFFFFFF};

DWORD_PTR PrinterInfo3Offsets[]={offsetof(LPPRINTER_INFO_3, pSecurityDescriptor),
                             0xFFFFFFFF};      

DWORD_PTR JobInfo1Offsets[]={offsetof(LPJOB_INFO_1W, pPrinterName),
                         offsetof(LPJOB_INFO_1W, pMachineName),
                         offsetof(LPJOB_INFO_1W, pUserName),
                         offsetof(LPJOB_INFO_1W, pDocument),
                         offsetof(LPJOB_INFO_1W, pDatatype),
                         offsetof(LPJOB_INFO_1W, pStatus),
                         0xFFFFFFFF};

DWORD_PTR JobInfo2Offsets[]={offsetof(LPJOB_INFO_2W, pPrinterName),
                         offsetof(LPJOB_INFO_2W, pMachineName),
                         offsetof(LPJOB_INFO_2W, pUserName),
                         offsetof(LPJOB_INFO_2W, pDocument),
                         offsetof(LPJOB_INFO_2W, pNotifyName),
                         offsetof(LPJOB_INFO_2W, pDatatype),
                         offsetof(LPJOB_INFO_2W, pPrintProcessor),
                         offsetof(LPJOB_INFO_2W, pParameters),
                         offsetof(LPJOB_INFO_2W, pDriverName),
                         offsetof(LPJOB_INFO_2W, pDevMode),
                         offsetof(LPJOB_INFO_2W, pStatus),
                         offsetof(LPJOB_INFO_2W, pSecurityDescriptor),
                         0xFFFFFFFF};

DWORD_PTR AddJobInfo1Offsets[]={offsetof(LPADDJOB_INFO_1W, Path),
                         0xFFFFFFFF};


VOID
MarshallUpStructure(
   LPBYTE  lpStructure,
   PDWORD_PTR lpOffsets,
   LPBYTE  lpBufferStart
)
{
   register DWORD i=0;

   while (lpOffsets[i] != -1) {

      if ((*(LPBYTE *)(lpStructure+lpOffsets[i]))) {
         (*(LPBYTE *)(lpStructure+lpOffsets[i]))+=(DWORD_PTR)lpBufferStart;
      }

      i++;
   }
}



VOID
MarshallDownStructure(
   LPBYTE  lpStructure,
   PDWORD_PTR lpOffsets,
   LPBYTE  lpBufferStart
)
{
    register DWORD i=0;

    if (!lpStructure)
        return;

    while (lpOffsets[i] != -1) {

        if ((*(LPBYTE*)(lpStructure+lpOffsets[i]))) {
            (*(LPBYTE*)(lpStructure+lpOffsets[i]))-=(DWORD_PTR)lpBufferStart;
        }

        i++;
    }
}



LPVOID
AllocNwSplMem(
    DWORD flags,
    DWORD cb
)
/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    flags - Flags to be passed to LocalAlloc

    cb    - The amount of memory to allocate in bytes

Return Value:

    NON-NULL   - A pointer to the allocated memory

--*/
{
    LPDWORD  pMem;
    DWORD    cbNew;

#if DBG
    cbNew = cb + 2*sizeof(DWORD);
    if (cbNew & 3)
        cbNew += sizeof(DWORD) - (cbNew & 3);
#else
    cbNew = cb;
#endif

    pMem = (LPDWORD) LocalAlloc( flags, cbNew );

    if ( !pMem ) 
    {
        KdPrint(("Memory Allocation in AllocNwSplMem failed for %d bytes\n", cbNew));
        return NULL;
    }

#if DBG
    *pMem = cb;
    *(LPDWORD)((LPBYTE)pMem+cbNew-sizeof(DWORD)) = 0xdeadbeef;
    return (LPVOID) (pMem + 1);
#else
    return (LPVOID) pMem;
#endif

}



VOID
FreeNwSplMem(
   LPVOID pMem,
   DWORD  cb
)
/*++

Routine Description:

    This function will frees the local memory allocated by AllocSplMem.
    Extra checking will be performed in the debug version to ensure that
    the size to be freed is indeed the size we allocated through AllocSplMem.

Arguments:

    pMem - A pointer to the allocated memory
    cb   - The amount of memory to free 

Return Value:

--*/
{
    DWORD   cbNew;
    LPDWORD pNewMem;

    if ( !pMem )
        return;

    pNewMem = pMem;
#if DBG
    pNewMem--;
    cbNew = cb + 2*sizeof(DWORD);
    if ( cbNew & 3 )
        cbNew += sizeof(DWORD) - (cbNew & 3);

    if (  ( *pNewMem != cb )
       || (*(LPDWORD)((LPBYTE)pNewMem + cbNew - sizeof(DWORD)) != 0xdeadbeef)
       )
    {
        KdPrint(("Corrupt Memory in FreeNwSplMem : %0lx\n", pNewMem ));
        return;
    }
#else
    cbNew = cb;
#endif

    LocalFree( (LPVOID) pNewMem );
}



LPWSTR
AllocNwSplStr(
    LPWSTR pStr
)
/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL   - A pointer to the allocated memory containing the string

--*/
{
   LPWSTR pMem;

   if ( !pStr )
      return NULL;

   if ( pMem = AllocNwSplMem(0, (wcslen(pStr) + 1) * sizeof(WCHAR)))
      wcscpy(pMem, pStr);

   return pMem;
}



VOID
FreeNwSplStr(
   LPWSTR pStr
)
/*++

Routine Description:

    This function will frees the string allocated by AllocSplStr.
    Extra checking will be performed in the debug version to ensure that
    the size to be freed is indeed the size we allocated through AllocSplStr.

Arguments:

    pStr - A pointer to the allocated string 

Return Value:

--*/
{
   if ( pStr ) 
       FreeNwSplMem(pStr, (wcslen(pStr) + 1) * sizeof(WCHAR));
}



BOOL
ValidateUNCName(
   LPWSTR pName
)    
/*++

Routine Description:

    This function will checks whether the given name is a valid UNC 
    name ( in the form \\server\name) or not. 

Arguments:

    pName - The supplied name

Return Value:

    TRUE  - The name given is a valid UNC name 
    FALSE - Otherwise 

--*/
{
   if (   pName 
      && (*pName++ == L'\\') 
      && (*pName++ == L'\\') 
      && (wcschr(pName, L'\\'))
      )
   {
      return TRUE;
   }

   return FALSE;
}

#ifndef NOT_USED

LPWSTR 
GetNextElement(LPWSTR *pPtr, WCHAR token)
{
    LPWSTR pszRestOfString = *pPtr;
    LPWSTR pszRetval = NULL;
    LPWSTR pszStr    = NULL;

    if ( *pszRestOfString == L'\0') 
        return NULL;

    if ((pszStr = wcschr (pszRestOfString, token))== NULL )
    {
        pszRetval = *pPtr;
        *pPtr += wcslen(*pPtr);
        return pszRetval;
    }
    else
    {
        *pszStr = L'\0';
        pszRetval =  *pPtr ;
        *pPtr = ++pszStr ;
        return pszRetval ;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\server\connect.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    connect.c

Abstract:

    This module contains tree connections routines supported by
    NetWare Workstation service.

Author:

    Rita Wong  (ritaw)   15-Feb-1993

Revision History:

--*/

#include <nw.h>
#include <handle.h>
#include <nwauth.h>
#include <nwcanon.h>
#include <nwreg.h>
#include <winbasep.h>


#define NW_ENUM_EXTRA_BYTES    256

extern BOOL NwLUIDDeviceMapsEnabled;

//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

DWORD
NwAllocAndGetUncName(
    IN LPWSTR LocalName,
    IN DWORD LocalNameLength,
    OUT LPWSTR *UncName
    );

DWORD
NwDeleteAllInRegistry(
    VOID
    );

DWORD
NwDeleteUidSymLinks(
    IN LUID Uid,
    IN ULONG WinStationId
    );


LPTSTR
NwReturnSessionPath(
                    IN  LPTSTR LocalDeviceName
                   );

//-------------------------------------------------------------------//



DWORD
NwrCreateConnection(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR LocalName OPTIONAL,
    IN LPWSTR RemoteName,
    IN DWORD Type,
    IN LPWSTR Password OPTIONAL,
    IN LPWSTR UserName OPTIONAL
    )
/*++

Routine Description:

    This function creates a tree connection to the specified RemoteName
    (UNC name) and maps it to the LocalName (local device name), if
    it is specified.  The password and user name are the credentials
    used to create the connection, if specified; otherwise, the
    interactive logged on user's credentials are used by default.

    NOTE: This code now calls a helper routine to do the work, this helper
    routine (NwCreateConnection) is identical to the code that used to be
    here with the exception that the helper does call ImpersonateClient(). 
    We now do the client impersonation outside of the helper routine.

Arguments:

    Reserved - Must be NULL.

    LocalName - Supplies the local device name to map to the created tree
        connection.  Only drive letter device names are accepted.  (No
        LPT or COM).

    RemoteName - Supplies the UNC name of the remote resource in the format
        of Server\Volume\Directory.  It must be a disk resource.

    Type - Supplies the connection type.

    Password - Supplies the password to use to make the connection to the
        server.

    UserName - Supplies the user name to use to make the connection.

Return Value:

    NO_ERROR - Operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Out of memory allocating internal work buffers.

    WN_BAD_NETNAME - Remote resource name is invalid.

    WN_BAD_LOCALNAME - Local DOS device name is invalid.

    ERROR_BAD_NETPATH - The UNC name does not exist on the network.

    ERROR_INVALID_PARAMETER - LPT or COM LocalName was specified.

    Other errors from the redirector.

--*/
{
    DWORD status;
    BOOL Impersonate = FALSE ;

    UNREFERENCED_PARAMETER(Reserved);

    //
    // Impersonate the client
    //
    if ((status = NwImpersonateClient()) != NO_ERROR)
    {
        goto CleanExit;
    }

    Impersonate = TRUE ;

    status = NwCreateConnection( LocalName,
                                 RemoteName,
                                 Type,
                                 Password,
                                 UserName );

CleanExit:
 
    if (Impersonate) {
        (void) NwRevertToSelf();
    }

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("NWWORKSTATION: NwrCreateConnection returns %lu\n", status));
    }
#endif

    return status;
}


DWORD
NwrDeleteConnection(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR ConnectionName,
    IN DWORD UseForce
    )
/*++

Routine Description:

    This function deletes an existing connection.

Arguments:

    Reserved - Must be NULL.

    ConnectionName - Supplies the local device name or UNC name which
        specifies the connection to delete.  If UNC name is specified,
        the UNC connection must exist.


    UseForce - Supplies a flag which if TRUE specifies to tear down
        the connection eventhough files are opened.  If FALSE, the
        connection is deleted only if there are no opened files.

Return Value:

    NO_ERROR - Operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Out of memory allocating internal work buffers.

    WN_BAD_NETNAME - ConnectionName is invalid.

    ERROR_BAD_NETPATH - The UNC name does not exist on the network.

    ERROR_INVALID_PARAMETER - LPT or COM LocalName was specified.

    Other errors from the redirector.

--*/
{
    DWORD status;

    LPWSTR ConnectName = NULL;
    DWORD ConnectLength;

    LPWSTR LocalName;
    LPWSTR UncName = NULL;

    BOOL Impersonate = FALSE ;

    UNREFERENCED_PARAMETER(Reserved);

    if (*ConnectionName == 0) {
        return ERROR_INVALID_PARAMETER;
    }

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("\nNWWORKSTATION: NwrDeleteConnection: ConnectionName %ws, Force %lu\n",
                 ConnectionName, UseForce));
    }
#endif

    if ((status = NwLibCanonLocalName(
                      ConnectionName,
                      &ConnectName,
                      &ConnectLength
                      )) == NO_ERROR) {

        //
        // Get the UNC name mapped to this drive letter so that we can
        // open a handle to it for deletion.
        //
    // ----Multi-user---------
    // Need to impersonate the client
        if ((status = NwImpersonateClient()) != NO_ERROR) {
                goto CleanExit;
        }
        Impersonate = TRUE ;

        if ((status = NwAllocAndGetUncName(
                          ConnectName,
                          ConnectLength,
                          &UncName
                          )) != NO_ERROR) {

            if (status == WN_NOT_CONNECTED && 
                NwGetGatewayResource(ConnectName,
                                     NULL, 
                                     0, 
                                     NULL) == WN_MORE_DATA)
            {
                status = ERROR_DEVICE_IN_USE ;
            }

            (void) LocalFree((HLOCAL) ConnectName);

            if (Impersonate) {
                (void) NwRevertToSelf();
            }

            return status;
        }

        LocalName = ConnectName;

    }
    else {

        //
        // Not a device name.  See if it is a UNC name.
        //
        if ((status = NwLibCanonRemoteName(
                          NULL,
                          ConnectionName,
                          &ConnectName,
                          NULL
                          )) != NO_ERROR) {

            return status;
        }

        UncName = ConnectName;
        LocalName = NULL;

    }


    if ( !Impersonate ) {
        if ((status = NwImpersonateClient()) != NO_ERROR) {
            goto CleanExit;
        }
        Impersonate = TRUE ;
    }
    //
    // To delete a connection, a tree connection handle must be opened to
    // it so that the handle can be specified to the redirector to delete
    // the connection.
    //
    status = NwOpenHandleToDeleteConn(
                 UncName,
                 LocalName,
                 UseForce,
                 FALSE,
                 TRUE
                 );

    if ( status == ERROR_FILE_NOT_FOUND )
        status = ERROR_BAD_NETPATH;

CleanExit:

    if (Impersonate) {
        (void) NwRevertToSelf();
    }
    if (UncName != NULL && UncName != ConnectName) {
        (void) LocalFree((HLOCAL) UncName);
    }

    if (ConnectName != NULL) {
        (void) LocalFree((HLOCAL) ConnectName);
    }

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("NWWORKSTATION: NwrDeleteConnection returns %lu\n", status));
    }
#endif

    return status;
}


DWORD
NwrQueryServerResource(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR LocalName,
    OUT LPWSTR RemoteName,
    IN DWORD RemoteNameLen,
    OUT LPDWORD CharsRequired
    )
/*++

Routine Description:

    This function looks up the UNC name associated with the given DOS
    device name.

Arguments:

    Reserved - Must be NULL.

    LocalName - Supplies the local device name to look up.

    RemoteName - Receives the UNC name mapped to the LocalName.

    RemoteNameLen - Supplies the length of the RemoteName buffer.

    CharsRequired - Receives the length required of the RemoteName buffer
        to get the UNC name.  This value is only returned if the return
        code is ERROR_MORE_DATA.

Return Value:

    NO_ERROR - Operation was successful.

    WN_BAD_LOCALNAME - LocalName was invalid.

    ERROR_INVALID_PARAMETER - LPT or COM LocalName was specified.

    ERROR_MORE_DATA - RemoteName buffer was too small.

    ERROR_NOT_CONNECTED - LocalName does not map to any server resource.

--*/
{
    DWORD status;

    LPWSTR Local;
    DWORD LocalLength;

    BOOL Impersonate = FALSE ;

    UNREFERENCED_PARAMETER(Reserved);

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("\nNWWORKSTATION: NwrQueryServerResource: LocalName %ws, RemoteNameLen %lu\n",
                 LocalName, RemoteNameLen));
    }
#endif

    //
    // Canonicalize the LocalName
    //
    if ((status = NwLibCanonLocalName(
                      LocalName,
                      &Local,
                      &LocalLength
                      )) != NO_ERROR) {

        return WN_BAD_LOCALNAME;
    }

    if ((status = NwImpersonateClient()) != NO_ERROR)
    {
        goto CleanExit;
    }

    Impersonate = TRUE ;

    status = NwGetServerResource(
                 Local,
                 LocalLength,
                 RemoteName,
                 RemoteNameLen,
                 CharsRequired
                 );

    if (status == WN_NOT_CONNECTED)
    {
        status = NwGetGatewayResource(
                     Local,
                     RemoteName,
                     RemoteNameLen,
                     CharsRequired
                     );
    }

CleanExit:

    if (Impersonate) {
        (void) NwRevertToSelf();
    }

    (void) LocalFree((HLOCAL) Local);

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("NWWORKSTATION: NwrQueryServerResource returns %lu\n", status));

        if (status == NO_ERROR) {
            KdPrint(("              RemoteName is %ws\n", RemoteName));
        }
        else if (status == ERROR_MORE_DATA) {
            KdPrint(("              RemoteNameLen %lu too small.  Need %lu\n",
                     RemoteNameLen, *CharsRequired));
        }
    }
#endif

    return status;
}


DWORD
NwrOpenEnumConnections(
    IN LPWSTR Reserved OPTIONAL,
    IN DWORD ConnectionType,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function creates a new context handle and initializes it
    for enumerating the connections.

Arguments:

    Reserved - Unused.

    EnumHandle - Receives the newly created context handle.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - if the memory for the context could
        not be allocated.

    NO_ERROR - Call was successful.

--*/
{
    LPNW_ENUM_CONTEXT ContextHandle;


    UNREFERENCED_PARAMETER(Reserved);

#if DBG
    IF_DEBUG(CONNECT) {
       KdPrint(("\nNWWORKSTATION: NwrOpenEnumConnections\n"));
    }
#endif

    //
    // Allocate memory for the context handle structure.
    //
    ContextHandle = (PVOID) LocalAlloc(
                                LMEM_ZEROINIT,
                                sizeof(NW_ENUM_CONTEXT)
                                );

    if (ContextHandle == NULL) {
        KdPrint(("NWWORKSTATION: NwrOpenEnumConnections LocalAlloc Failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize contents of the context handle structure.
    //
    ContextHandle->Signature = NW_HANDLE_SIGNATURE;
    ContextHandle->HandleType = NwsHandleListConnections;
    ContextHandle->ResumeId = 0;
    ContextHandle->ConnectionType = 0;

    if ( ConnectionType == RESOURCETYPE_ANY ) {
        ContextHandle->ConnectionType = CONNTYPE_ANY;
    }
    else {
        
        if ( ConnectionType & RESOURCETYPE_DISK ) 
            ContextHandle->ConnectionType |= CONNTYPE_DISK;

        if ( ConnectionType & RESOURCETYPE_PRINT ) 
            ContextHandle->ConnectionType |= CONNTYPE_PRINT;
    }
         
         

    //
    // Return the newly created context.
    //
    *EnumHandle = (LPNWWKSTA_CONTEXT_HANDLE) ContextHandle;

    return NO_ERROR;
}


DWORD
NwrGetConnectionPerformance(
    IN  LPWSTR Reserved OPTIONAL,
    IN  LPWSTR lpRemoteName,
    OUT LPBYTE lpNetConnectInfo,
    IN  DWORD  dwBufferSize
    )
/*++

Routine Description:

    This function returns information about the expected performance of a
    connection used to access a network resource. The request can only be
    for a network resource to which there is currently a connection.

Arguments:

    Reserved - Unused.

    lpRemoteName - Contains the local name or remote name for a resource
                   for which a connection exists.

    lpNetConnectInfo - This is a pointer to a NETCONNECTINFOSTRUCT structure
                       which is to be filled if the connection performance
                       of connection lpRemoteName can be determined.

Return Value:

    NO_ERROR - Successful.

    WN_NOT_CONNECTED - Connection could not be found.

    WN_NONETWORK - Network is not present.

    Other network errors.

--*/
{
    DWORD             status = NO_ERROR;
    LPNETCONNECTINFOSTRUCT lpNetConnInfo =
                       (LPNETCONNECTINFOSTRUCT) lpNetConnectInfo;
    NTSTATUS          ntstatus;
    IO_STATUS_BLOCK   IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK       DesiredAccess = SYNCHRONIZE | FILE_LIST_DIRECTORY;
    //
    //  dfergus 19 Apr 2001 - #333280
    //  Init hRdr so test for null is valid
    HANDLE            hRdr = NULL;

    WCHAR OpenString[] = L"\\Device\\Nwrdr\\*";
    UNICODE_STRING OpenName;
    UNICODE_STRING ConnectionName;

    PNWR_REQUEST_PACKET Request = NULL;
    ULONG BufferSize = 0;
    ULONG RequestSize;
    BOOL  Impersonate = FALSE ;

    UNREFERENCED_PARAMETER(Reserved);
    UNREFERENCED_PARAMETER(dwBufferSize);

    if (lpRemoteName == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    BufferSize = sizeof(NWR_REQUEST_PACKET) +
        ( ( wcslen(lpRemoteName) + 1 ) * sizeof(WCHAR) );

    //
    // Impersonate the client
    //
    if ((status = NwImpersonateClient()) != NO_ERROR)
    {
        goto ExitWithClose;
    }

    Impersonate = TRUE;

    //
    // Allocate buffer space.
    //
    Request = (PNWR_REQUEST_PACKET) LocalAlloc( LMEM_ZEROINIT, BufferSize );

    if ( Request == NULL )
    {
        KdPrint(("NWWORKSTATION: NwrGetConnectionPerformance LocalAlloc Failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlInitUnicodeString( &OpenName, OpenString );

    InitializeObjectAttributes( &ObjectAttributes,
                                &OpenName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntstatus = NtOpenFile( &hRdr,
                           DesiredAccess,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_VALID_FLAGS,
                           FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
    {
        status = RtlNtStatusToDosError(ntstatus);
        goto ExitWithClose;
    }

    //
    // Fill out the request packet for FSCTL_NWR_GET_CONN_PERFORMANCE.
    //
    RtlInitUnicodeString( &ConnectionName, lpRemoteName );

    Request->Parameters.GetConnPerformance.RemoteNameLength =
        ConnectionName.Length;
    RtlCopyMemory( Request->Parameters.GetConnPerformance.RemoteName,
                   ConnectionName.Buffer,
                   ConnectionName.Length );

    RequestSize = sizeof( NWR_REQUEST_PACKET ) + ConnectionName.Length;

    ntstatus = NtFsControlFile( hRdr,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_NWR_GET_CONN_PERFORMANCE,
                                (PVOID) Request,
                                RequestSize,
                                NULL,
                                0 );

    if ( !NT_SUCCESS( ntstatus ) )
    {
        status = RtlNtStatusToDosError(ntstatus);
        goto ExitWithClose;
    }

    lpNetConnInfo->cbStructure = sizeof(NETCONNECTINFOSTRUCT);
    lpNetConnInfo->dwFlags = Request->Parameters.GetConnPerformance.dwFlags;
    lpNetConnInfo->dwSpeed = Request->Parameters.GetConnPerformance.dwSpeed;
    lpNetConnInfo->dwDelay = Request->Parameters.GetConnPerformance.dwDelay;
    lpNetConnInfo->dwOptDataSize =
        Request->Parameters.GetConnPerformance.dwOptDataSize;

ExitWithClose:
    if ( Request )
        LocalFree( Request );
 
    if ( Impersonate )
    {
        (void) NwRevertToSelf();
    }

    if ( hRdr )
       NtClose( hRdr );

    return status;
}



DWORD
NwAllocAndGetUncName(
    IN LPWSTR LocalName,
    IN DWORD LocalNameLength,
    OUT LPWSTR *UncName
    )
/*++

Routine Description:

    This function calls an internal routine to ask the redirector for the
    UNC name of a given DOS device name.  It also allocates the output
    buffer to hold the UNC name.

Arguments:

    LocalName - Supplies the DOS device name.

    LocalNameLength - Supplies the length of the DOS device name (chars).

    UncName - Receives a pointer to the output buffer allocated by this
        routine which contains the UNC name of the DOS device.

Return Value:

    NO_ERROR - Operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Could not allocate output buffer.

    Other errors from the redirector.
--*/
{
    DWORD status;
    DWORD UncNameLength;



    *UncName = (PVOID) LocalAlloc(
                           LMEM_ZEROINIT,
                           (MAX_PATH + 1) * sizeof(WCHAR)
                           );

    if (*UncName == NULL) {
        KdPrint(("NWWORKSTATION: NwAllocAndGetUncName LocalAlloc Failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    status = NwGetServerResource(
                 LocalName,
                 LocalNameLength,
                 *UncName,
                 MAX_PATH + 1,
                 &UncNameLength
                 );

    if ((status == ERROR_MORE_DATA) || (status == ERROR_INSUFFICIENT_BUFFER)) {

        //
        // Our output buffer was too small.  Try again.
        //
        (void) LocalFree((HLOCAL) *UncName);

        *UncName = (PVOID) LocalAlloc(
                               LMEM_ZEROINIT,
                               UncNameLength * sizeof(WCHAR)
                               );

        if (*UncName == NULL) {
            KdPrint(("NWWORKSTATION: NwAllocAndGetUncName LocalAlloc Failed %lu\n",
                     GetLastError()));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        status = NwGetServerResource(
                     LocalName,
                     LocalNameLength,
                     *UncName,
                     UncNameLength,
                     &UncNameLength
                     );

    }

    //
    // callers will only free this if success.
    //
    if (status != NO_ERROR) 
    {
        (void) LocalFree((HLOCAL) *UncName);
        *UncName = NULL ;
    }

    return status;
}


DWORD
NwOpenHandleToDeleteConn(
    IN LPWSTR UncName,
    IN LPWSTR LocalName OPTIONAL,
    IN DWORD UseForce,
    IN BOOL IsStopWksta,
    IN BOOL ImpersonatingClient
    )
/*++

Routine Description:

    This function deletes an active connection by opening a tree connection
    handle to the connection first, and specifying this handle to the
    redirector to delete.  This is because the workstation service does
    not keep any connection information.

Arguments:

    UncName - Supplies the UNC name of the connection to delete.

    LocalName - Supplies the DOS device name of the connection, if any.

    UseForce - Supplies a flag which if TRUE specifies to tear down
        the connection eventhough files are opened.  If FALSE, the
        connection is deleted only if there are no opened files.

    IsStopWksta - Supplies a flag which if TRUE indicates that we must
        delete the symbolic link, even when we have failed to delete the
        connection in the redirector.  As much as possible must be cleaned
        up because the workstation service is stopping.  A value of FALSE,
        indicates that the delete is aborted if we cannot delete it in
        the redirector.

    ImpersonatingClient - Flag that indicates whether the thread has
        called NwImpersonateClient. The gateway service functions don't
        impersonate, where as the client service operations do.

Return Value:

    NO_ERROR - Operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Could not allocate output buffer.

    Other errors from the redirector.
--*/
{
    DWORD status;
    NTSTATUS ntstatus ;

    UNICODE_STRING TreeConnectStr;
    HANDLE TreeConnection = NULL;



    TreeConnectStr.Buffer = NULL;

    //
    // Create an NT-style tree connection name, either: \Device\Nwrdr\Server\Vol
    // or \Device\Nwrdr\X:\Server\Vol, if LocalName is specified.
    //
    if ((status = NwCreateTreeConnectName(
                      UncName,
                      LocalName,
                      &TreeConnectStr
                      )) != NO_ERROR) {
        return status;
    }

    ntstatus = NwCallNtOpenFile( &TreeConnection, 
                                 SYNCHRONIZE | DELETE, 
                                 &TreeConnectStr, 
                                 FILE_CREATE_TREE_CONNECTION  
                                   | FILE_SYNCHRONOUS_IO_NONALERT
                                   | FILE_DELETE_ON_CLOSE
                                 );
    //
    // treat the 2 as the same in order to return nicer error to user
    //
    if (ntstatus == STATUS_OBJECT_NAME_INVALID)
        ntstatus = STATUS_OBJECT_NAME_NOT_FOUND ; 
    status = NwMapStatus(ntstatus) ;

    if (status == NO_ERROR) {

        //
        // Ask the redirector to delete the tree connection.
        //
        status = NwNukeConnection(
                     TreeConnection,
                     UseForce
                     );

        (void) CloseHandle(TreeConnection);
    }

    if (ARGUMENT_PRESENT(LocalName) &&
        (status == NO_ERROR || IsStopWksta))
    {
        //
        // Delete the symbolic link we created.
        //
        NwDeleteSymbolicLink(
            LocalName,
            TreeConnectStr.Buffer,
            NULL,
            ImpersonatingClient
            );
    }

    if (TreeConnectStr.Buffer != NULL) {
        (void) LocalFree((HLOCAL) TreeConnectStr.Buffer);
    }

    return status;
}


VOID
DeleteAllConnections(
    VOID
    )
/*++

Routine Description:

    This function deletes all active connections returned by the
    redirector ENUMERATE_CONNECTIONS fsctl on workstation termination.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD status;
    NWWKSTA_CONTEXT_HANDLE EnumHandle;
    LPNETRESOURCEW NetR = NULL;

    DWORD BytesNeeded = 256;
    DWORD EntriesRead;


    status = NwrOpenEnumConnections(NULL, RESOURCETYPE_ANY, &EnumHandle);
    if ( status != NO_ERROR )
        return;

    //
    // Allocate buffer to get connection list.
    //
    if ((NetR = (LPVOID) LocalAlloc(
                             0,
                             BytesNeeded
                             )) == NULL) {

        status = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }

    do {

        status = NwEnumerateConnections(
                     &((LPNW_ENUM_CONTEXT) EnumHandle)->ResumeId,
                     (DWORD) -1,
                     (LPBYTE) NetR,
                     BytesNeeded,
                     &BytesNeeded,
                     &EntriesRead,
                     CONNTYPE_ANY,
                     NULL
                     );

        if (status == NO_ERROR) {

            DWORD i;
            LPNETRESOURCEW SavePtr = NetR;
            LPWSTR Local;


            for (i = 0; i < EntriesRead; i++, NetR++) {

                Local = NetR->lpLocalName;

                if (NetR->lpLocalName && *(NetR->lpLocalName) == 0) {
                    Local = NULL;
                }

                (void) NwOpenHandleToDeleteConn(
                           NetR->lpRemoteName,
                           Local,
                           TRUE,
                           TRUE,
                           FALSE
                           );
            }

            NetR = SavePtr;

        }
        else if (status == WN_MORE_DATA) {

            //
            // Original buffer was too small.  Free it and allocate
            // the recommended size and then some to get as many
            // entries as possible.
            //

            (void) LocalFree((HLOCAL) NetR);

            BytesNeeded += NW_ENUM_EXTRA_BYTES;

            if ((NetR = (LPVOID) LocalAlloc(
                                     0,
                                     BytesNeeded
                                     )) == NULL) {

                status = ERROR_NOT_ENOUGH_MEMORY;
                goto CleanExit;
            }
        }
        else {
            // give up if see any other return code
            break ;
        }

    } while (status != WN_NO_MORE_ENTRIES);

CleanExit:
    (void) NwrCloseEnum(&EnumHandle);

    if (NetR != NULL) {
        (void) LocalFree((HLOCAL) NetR);
    }
    (void) NwDeleteAllInRegistry();
}



DWORD
NwCreateSymbolicLink(
    IN  LPWSTR Local,
    IN  LPWSTR TreeConnectStr,
    IN  BOOL   bGateway,
    IN  BOOL   ImpersonatingClient
    )
/*++

Routine Description:

    This function creates a symbolic link object for the specified local
    device name which is linked to the tree connection name that has a
    format of \Device\NwRdr\Device:\Server\Volume\Directory.

Arguments:

    Local - Supplies the local device name.

    TreeConnectStr - Supplies the tree connection name string which is
        the link target of the symbolick link object.

    ImpersonatingClient - Flag that indicates whether the thread has
        called NwImpersonateClient. The gateway service functions don't
        impersonate, where as the client service operations do.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    WCHAR    TempBuf[64];
    LPWSTR   Session = NULL;                       //Terminal Server Addition
    NTSTATUS Status = NO_ERROR;                 
    BOOL     ResetToClient = FALSE;
    DWORD    LocalLength = wcslen(Local);

    //
    // Multiple session support
    //
    if (bGateway)
    {
        //Because this is Gateway connect, force sessionID 0
        if (!DosPathToSessionPath( 0,
                                   Local,
                                   &Session ))
        {
            Status = GetLastError();
            goto Exit;
        }
    }
    else
    {
        Session = NwReturnSessionPath(Local);
        if (Session == 0)
        {
            Status = GetLastError();
            goto Exit;
        }
    }

    if ( (NwLUIDDeviceMapsEnabled == FALSE) && ImpersonatingClient )
    {
        (void) NwRevertToSelf();
        ResetToClient = TRUE;
    }

    if (LocalLength > 2)
    {
        LPWSTR UncName;

        //
        // Local device is LPTn:
        //

        //
        // Check to see if we already have this UNC name mapped.
        //
        if (NwAllocAndGetUncName(
                Local,
                LocalLength,
                &UncName
                ) == NO_ERROR)
        {
            LocalFree((HLOCAL) UncName);
            Status = ERROR_ALREADY_ASSIGNED;
            goto Exit;
        }
    }
    else
    {
        //
        // Local device is X:
        //

        if (! QueryDosDeviceW( Session,
                               TempBuf,
                               sizeof(TempBuf) / sizeof(WCHAR) ))
        {
            if (GetLastError() != ERROR_FILE_NOT_FOUND)
            {
                //
                // Most likely failure occurred because our output
                // buffer is too small.  It still means someone already
                // has an existing symbolic link for this device.
                //
                Status = ERROR_ALREADY_ASSIGNED;
                goto Exit;
            }
        }
        else
        {
            //
            // QueryDosDevice successfully an existing symbolic link--
            // somebody is already using this device.
            //
            Status = ERROR_ALREADY_ASSIGNED;
            goto Exit;
        }
    }

    //
    // Create a symbolic link object to the device we are redirecting
    //
    if (! DefineDosDeviceW(
              DDD_RAW_TARGET_PATH | DDD_NO_BROADCAST_SYSTEM,
              Session,
              TreeConnectStr
              ))
    {
        Status = GetLastError();
        goto Exit;
    }

Exit:

    if ( ResetToClient )
    {
        (void) NwImpersonateClient();
    }

    if (Session)
    {
        LocalFree(Session);
    }
    return Status;
}



VOID
NwDeleteSymbolicLink(
    IN  LPWSTR LocalDeviceName,
    IN  LPWSTR TreeConnectStr,
    IN  LPWSTR SessionDeviceName, //Terminal Server Addition
                                  // This parameter is required because 
                                  // the device created is per session
    IN  BOOL   ImpersonatingClient
    )
/*++

Routine Description:

    This function deletes the symbolic link we had created earlier for
    the device.

Arguments:

    LocalDeviceName - Supplies the local device name string of which the
        symbolic link object is created.

    TreeConnectStr - Supplies a pointer to the Unicode string which
        contains the link target string we want to match and delete.

    ImpersonatingClient - Flag that indicates whether the thread has
        called NwImpersonateClient. The gateway service functions don't
        impersonate, where as the client service operations do.

Return Value:

    None.

--*/
{
    BOOLEAN DeleteSession = FALSE;
    BOOL    ResetToClient = FALSE;

    if (LocalDeviceName != NULL ||
        SessionDeviceName != NULL) {

        if (SessionDeviceName == NULL) {
            SessionDeviceName = NwReturnSessionPath(LocalDeviceName);
            if ( SessionDeviceName == NULL ) return;
            DeleteSession = TRUE;
        }

        if ( (NwLUIDDeviceMapsEnabled == FALSE) && ImpersonatingClient )
        {
            (void) NwRevertToSelf();
            ResetToClient = TRUE;
        }

        if (! DefineDosDeviceW(
                              DDD_REMOVE_DEFINITION  | 
                              DDD_RAW_TARGET_PATH |
                              DDD_EXACT_MATCH_ON_REMOVE | 
                              DDD_NO_BROADCAST_SYSTEM,
                              //                  LocalDeviceName,
                              SessionDeviceName,
                              TreeConnectStr
                              ))
        {
#if DBG
            IF_DEBUG(CONNECT) {
                KdPrint(("NWWORKSTATION: DefineDosDevice DEL of %ws %ws returned %lu\n",
                         LocalDeviceName, TreeConnectStr, GetLastError()));
            }
#endif
        }
#if DBG
        else {
            IF_DEBUG(CONNECT) {
                KdPrint(("NWWORKSTATION: DefineDosDevice DEL of %ws %ws returned successful\n",
                         LocalDeviceName, TreeConnectStr));
            }

        }
#endif

    }

    if ( SessionDeviceName && DeleteSession) {
        LocalFree( SessionDeviceName );
    }

    if ( ResetToClient )
    {
        (void) NwImpersonateClient();
    }
}


DWORD
NwCreateGWConnection(
    IN LPWSTR RemoteName,
    IN LPWSTR UserName,
    IN LPWSTR Password,
    IN BOOL   KeepConnection
    )
/*++

Routine Description:

    This function creates a tree connection to the specified RemoteName
    (UNC name). It is only used by the Gateway and DOES NOT impersonate.

Arguments:

    RemoteName - Supplies the UNC name of the remote resource in the format
        of Server\Volume\Directory.  It must be a disk resource.

Return Value:

    NO_ERROR - Operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Out of memory allocating internal work buffers.

    WN_BAD_NETNAME - Remote resource name is invalid.

    WN_BAD_LOCALNAME - Local DOS device name is invalid.

    ERROR_BAD_NETPATH - The UNC name does not exist on the network.

    ERROR_INVALID_PARAMETER - LPT or COM LocalName was specified.

    Other errors from the redirector.

--*/
{
    DWORD status;
    LPWSTR Unc = NULL;
    LPWSTR User = NULL;
    UNICODE_STRING TreeConnectStr;
    HANDLE TreeConnection;

    TreeConnectStr.Buffer = NULL;

    //
    // Canonicalize the remote name, if it is not \\Server.
    //
    if ((status = NwLibCanonRemoteName(
                      NULL,
                      RemoteName,
                      &Unc,           // Must be freed with LocalFree when done.
                      NULL
                      )) != NO_ERROR) 
    {
        status = WN_BAD_NETNAME;
        goto CleanExit;
    }

    if (UserName != NULL) {

        //
        // Canonicalize username
        //
        if ((status = NwLibCanonUserName(
                          UserName,
                          &User,     // Must be freed with LocalFree when done.
                          NULL
                          )) != NO_ERROR) {

            status = WN_BAD_VALUE;
            goto CleanExit;
        }
    }

    //
    // Create an NT-style tree connection name
    //
    if ((status = NwCreateTreeConnectName(
                      Unc,
                      NULL,
                      &TreeConnectStr
                      )) != NO_ERROR) 
    {
        goto CleanExit;
    }


    //
    // Create the tree connection while impersonating the client so
    // that redirector can get to caller's logon id.
    //
    status = NwOpenCreateConnection(
                 &TreeConnectStr,
                 User,
                 Password,
                 Unc,
                 SYNCHRONIZE | GENERIC_WRITE,
                 FILE_CREATE,          // Fail if already exist
                 FILE_CREATE_TREE_CONNECTION |
                     FILE_SYNCHRONOUS_IO_NONALERT,
                 RESOURCETYPE_DISK,
                 &TreeConnection,
                 NULL
                 );


    if (status != NO_ERROR) {

        if (  (status == ERROR_NOT_CONNECTED) 
           || (status == ERROR_FILE_NOT_FOUND )
           )
        {
            status = ERROR_BAD_NETPATH;
        }
    }
    else 
    {

        //
        // Just close the connection handle.
        //
        (void) NtClose(TreeConnection);


        //
        // delete the connect we just created. ignore this error.
        //
        if (!KeepConnection)
        {
            (void) NwOpenHandleToDeleteConn(
                         RemoteName,
                         NULL,
                         FALSE,
                         FALSE,
                         FALSE
                         );
        }
    }


CleanExit:

    if (User != NULL) {
        (void) LocalFree((HLOCAL) User);
    }

    if (Unc != NULL) {
        (void) LocalFree((HLOCAL) Unc);
    }

    if (TreeConnectStr.Buffer != NULL) {
        (void) LocalFree((HLOCAL) TreeConnectStr.Buffer);
    }

    return status;
}

DWORD
NwDeleteGWConnection(
    IN LPWSTR ConnectionName
    )
/*++

Routine Description:

    This function deletes an existing connection.

Arguments:

    ConnectionName - Supplies the local device name or UNC name which
        specifies the connection to delete.  If UNC name is specified,
        the UNC connection must exist.

Return Value:

    NO_ERROR - Operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Out of memory allocating internal work buffers.

    WN_BAD_NETNAME - ConnectionName is invalid.

    ERROR_BAD_NETPATH - The UNC name does not exist on the network.

    ERROR_INVALID_PARAMETER - LPT or COM LocalName was specified.

    Other errors from the redirector.

--*/
{
    DWORD status;

    LPWSTR ConnectName = NULL;
    DWORD ConnectLength;

    if (!ConnectionName || *ConnectionName == 0) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // See if it is a UNC name.
    //
    if ((status = NwLibCanonRemoteName(
                          NULL,
                          ConnectionName,
                          &ConnectName,
                          NULL
                          )) != NO_ERROR) {

        return status;
    }

    //
    // To delete a connection, a tree connection handle must be opened to
    // it so that the handle can be specified to the redirector to delete
    // the connection.
    //
    status = NwOpenHandleToDeleteConn(
                 ConnectName,
                 NULL,
                 TRUE,
                 FALSE,
                 FALSE
                 );

    if ( status == ERROR_FILE_NOT_FOUND )
        status = ERROR_BAD_NETPATH;

    if (ConnectName != NULL) {
        (void) LocalFree((HLOCAL) ConnectName);
    }

    return status;
}


DWORD
NwCreateConnection(
    IN LPWSTR LocalName OPTIONAL,
    IN LPWSTR RemoteName,
    IN DWORD Type,
    IN LPWSTR Password OPTIONAL,
    IN LPWSTR UserName OPTIONAL
    )
/*++

Routine Description:

    This function creates a tree connection to the specified RemoteName
    (UNC name) and maps it to the LocalName (local device name), if
    it is specified.  The password and user name are the credentials
    used to create the connection, if specified; otherwise, the
    interactive logged on user's credentials are used by default.

    NOTE: This code used to be NwrCreateConnection, except that it used
    to have the ImpersonateClient() call in it. Now this code is here, and
    NwrCreateConnection calls this function and handles the client
    impersonation there. The reason for this is to allow the print spooler
    code to call this helper routine without calling Impersonate client a
    second time, thus reverting the credentials to that of services.exe.

    4/15/99 - GlennC - Assumption is that this routine is currently only
    called while impersonating the client (NwImpersonateClient == TRUE)!!!

Arguments:

    LocalName - Supplies the local device name to map to the created tree
        connection.  Only drive letter device names are accepted.  (No
        LPT or COM).

    RemoteName - Supplies the UNC name of the remote resource in the format
        of Server\Volume\Directory.  It must be a disk resource.

    Type - Supplies the connection type.

    Password - Supplies the password to use to make the connection to the
        server.

    UserName - Supplies the user name to use to make the connection.

Return Value:

    NO_ERROR - Operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Out of memory allocating internal work buffers.

    WN_BAD_NETNAME - Remote resource name is invalid.

    WN_BAD_LOCALNAME - Local DOS device name is invalid.

    ERROR_BAD_NETPATH - The UNC name does not exist on the network.

    ERROR_INVALID_PARAMETER - LPT or COM LocalName was specified.

    Other errors from the redirector.

--*/
{
    DWORD status;

    DWORD LocalLength;

    LPWSTR Local = NULL;
    LPWSTR Unc = NULL;
    LPWSTR User = NULL;

    UNICODE_STRING TreeConnectStr;
    UNICODE_STRING EncodedPassword;
    HANDLE TreeConnection;

    TreeConnectStr.Buffer = NULL;

    EncodedPassword.Length = 0;

    //
    // If local device is an empty string, it will be treated as a pointer to
    // NULL.
    //
    if (LocalName != NULL && *LocalName != 0) {

        //
        // Local device name is not NULL, canonicalize it
        //
#if DBG
        IF_DEBUG(CONNECT) {
            KdPrint(("\nNWWORKSTATION: NwCreateConnection: LocalName %ws\n", LocalName));
        }
#endif

        if ((status = NwLibCanonLocalName(
                          LocalName,
                          &Local,     // Must be freed with LocalFree when done.
                          &LocalLength
                          )) != NO_ERROR) {

            return WN_BAD_LOCALNAME;
        }
    }

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("NWWORKSTATION: NwCreateConnection: RemoteName %ws\n", RemoteName));
    }
#endif

    //
    // Canonicalize the remote name, if it is not \\Server.
    //
    status = NwLibCanonRemoteName(
                      Local,
                      RemoteName,
                      &Unc,           // Must be freed with LocalFree when done.
                      NULL
                      );

    if (status != NO_ERROR)
    {
        status = WN_BAD_NETNAME;
        goto CleanExit;
    }

    //
    // Canonicalize user name.
    //
    if (UserName != NULL) {

        //
        // Canonicalize username
        //
#if DBG
        IF_DEBUG(CONNECT) {
            KdPrint(("NWWORKSTATION: NwCreateConnection: UserName %ws\n",
                     UserName));
        }
#endif

        if ((status = NwLibCanonUserName(
                          UserName,
                          &User,     // Must be freed with LocalFree when done.
                          NULL
                          )) != NO_ERROR) {

#ifdef QFE_BUILD
            //
            // if not valid, just ignore the username. this works
            // around MPR bug where if you pass say domain\user to NWRDR
            // as first provider, and he throws it out, then the next one
            // doesnt get a chance.
            //
            // TRACKING - this should be removed when MPR bug #4051 is fixed
            // and all platforms we ship NWRDR have that fix.
            //
            UserName = NULL ;
            status = NO_ERROR;
#else
            status = WN_BAD_VALUE;
            goto CleanExit;
#endif
        }
    }

    //
    // For password any syntax or length is accepted.
    //
    if (Password != NULL) {

#if DBG
        IF_DEBUG(CONNECT) {
            KdPrint(("NWWORKSTATION: NwCreateConnection: Password %ws\n",
                     Password));
        }
#endif
        //
        // Decode the password
        //
        RtlInitUnicodeString(&EncodedPassword, Password);
        RtlRunDecodeUnicodeString(NW_ENCODE_SEED3, &EncodedPassword);
    }

    //
    // Create an NT-style tree connection name
    //
    if ((status = NwCreateTreeConnectName(
                      Unc,
                      Local,
                      &TreeConnectStr
                      )) != NO_ERROR) {
        goto CleanExit;
    }

    if (Local != NULL) {

        //
        // Create symbolic link for local device name.
        //

        if ((status = NwCreateSymbolicLink(
                          Local,
                          TreeConnectStr.Buffer,
                          FALSE,        //Not a gateway
                          TRUE          // We are impersonating the client!
                          )) != NO_ERROR)
        {
            goto CleanExit;
        }
    }

    //
    // Create the tree connection while impersonating the client so
    // that redirector can get to caller's logon id.
    //

    status = NwOpenCreateConnection(
                 &TreeConnectStr,
                 User,
                 Password,
                 Unc,
                 SYNCHRONIZE | GENERIC_WRITE,
                 FILE_CREATE,          // Fail if already exist
                 FILE_CREATE_TREE_CONNECTION |
                     FILE_SYNCHRONOUS_IO_NONALERT,
                 Type,
                 &TreeConnection,
                 NULL
                 );

    //
    // If there's a problem creating the tree connection, remove symbolic
    // link if any.
    //
    if (status != NO_ERROR) {

        if ( (status == ERROR_NOT_CONNECTED) ||
             (status == ERROR_FILE_NOT_FOUND) ||
             (status == ERROR_INVALID_NAME) )
        {
            status = ERROR_BAD_NETPATH;
        }

        if ( status == ERROR_CONNECTION_INVALID )
        {
            status = WN_BAD_NETNAME;
        }

        //
        // Delete the symbolic link we created.
        //
        NwDeleteSymbolicLink(
            Local,
            TreeConnectStr.Buffer,
            NULL,
            TRUE          // We are impersonating the client!
            );
    }
    else {

        //
        // Just close the connection handle.
        //
        (void) NtClose(TreeConnection);
    }

CleanExit:
    if (Local != NULL) {
        (void) LocalFree((HLOCAL) Local);
    }

    if (Unc != NULL) {
        (void) LocalFree((HLOCAL) Unc);
    }

    if (User != NULL) {
        (void) LocalFree((HLOCAL) User);
    }

    if (TreeConnectStr.Buffer != NULL) {
        (void) LocalFree((HLOCAL) TreeConnectStr.Buffer);
    }

    //
    // Put the password back the way we found it.
    //
    if (EncodedPassword.Length != 0) {

        UCHAR Seed = NW_ENCODE_SEED3;

        RtlRunEncodeUnicodeString(&Seed, &EncodedPassword);
    }


#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("NWWORKSTATION: NwCreateConnection returns %lu\n", status));
    }
#endif

    return status;
}

//Terminal Server
DWORD
NwDeleteAllInRegistry(
                      VOID
                     )
/*++

Routine Description:

    This function spins through the registry deleting the symbolic
    links and closing all connections for all logons.

    This is neccessary since the the users are not neccessarily in the
    system context.

Arguments:

    none

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    LONG RegError;


    HKEY InteractiveLogonKey;
    DWORD Index = 0;
    WCHAR LogonIdName[NW_MAX_LOGON_ID_LEN];
    LUID LogonId;
    HKEY  OneLogonKey;
    ULONG WinStationId = 0L;
    PULONG pWinId = NULL;


    RegError = RegOpenKeyExW(
                            HKEY_LOCAL_MACHINE,
                            NW_INTERACTIVE_LOGON_REGKEY,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ,
                            &InteractiveLogonKey
                            );

    if (RegError == ERROR_SUCCESS) {

        do {

            RegError = RegEnumKeyW(
                                  InteractiveLogonKey,
                                  Index,
                                  LogonIdName,
                                  sizeof(LogonIdName) / sizeof(WCHAR)
                                  );

            if (RegError == ERROR_SUCCESS) {

                //
                // Got a logon id key.
                //

                NwWStrToLuid(LogonIdName, &LogonId);

                //
                // Open the <LogonIdName> key under Logon
                //
                RegError = RegOpenKeyExW(
                                        InteractiveLogonKey,
                                        LogonIdName,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ,
                                        &OneLogonKey
                                        );

                if ( RegError != ERROR_SUCCESS ) {
                    KdPrint(("NWWORKSTATION: NwDeleteAllInRegistry: RegOpenKeyExW failed, Not interactive Logon: Error %d\n", GetLastError()));
                } else {

                    //
                    // Read the WinStation value.
                    //
                    RegError = NwReadRegValue(
                                             OneLogonKey,
                                             NW_WINSTATION_VALUENAME,
                                             (LPWSTR *) &pWinId
                                             );

                    (void) RegCloseKey(OneLogonKey);

                    if ( RegError != NO_ERROR ) {
                        KdPrint(("NWWORKSTATION: NwDeleteAllInRegistry: Could not read SID from reg %lu\n", RegError));
                        continue;
                    } else {
                        if (pWinId != NULL) {
                            WinStationId = *pWinId;
                            (void) LocalFree((HLOCAL) pWinId);
                        }
                        NwDeleteUidSymLinks( LogonId, WinStationId );
                    }
                }

            } else if (RegError != ERROR_NO_MORE_ITEMS) {
                KdPrint(("NWWORKSTATION: NwDeleteAllInRegistry failed to enum logon IDs RegError=%lu\n",
                         RegError));
            }

            Index++;

        } while (RegError == ERROR_SUCCESS);

        (void) RegCloseKey(InteractiveLogonKey);
    }

    NwCloseAllConnections();  

    return NO_ERROR;
}

DWORD
    NwDeleteUidSymLinks(
                       IN LUID Uid,
                       IN ULONG WinStationId
                       )
/*++

Routine Description:

    This function deletes all symbolic links for a given UID/Winstation.

Arguments:

    None.

Return Value:

    NO_ERROR 

--*/
{
    DWORD status= NO_ERROR;
    NWWKSTA_CONTEXT_HANDLE EnumHandle;
    LPNETRESOURCEW NetR = NULL;

    DWORD BytesNeeded = 256;
    DWORD EntriesRead;
    WCHAR LocalUidCombo[256];
    UNICODE_STRING TreeConnectStr;


    status = NwrOpenEnumConnections(NULL, RESOURCETYPE_ANY, &EnumHandle);
    if ( status != NO_ERROR )
        return status;

    //
    // Allocate buffer to get connection list.
    //
    if ((NetR = (LPVOID) LocalAlloc(
                                   0,
                                   BytesNeeded
                                   )) == NULL) {

        status = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }

    do {

        status = NwEnumerateConnections(
                                       &((LPNW_ENUM_CONTEXT) EnumHandle)->ResumeId,
                                       0xFFFFFFFF,
                                       (LPBYTE) NetR,
                                       BytesNeeded,
                                       &BytesNeeded,
                                       &EntriesRead,
                                       CONNTYPE_ANY | CONNTYPE_UID,
                                       &Uid
                                       );

        if (status == NO_ERROR) {

            DWORD i;
            LPNETRESOURCEW SavePtr = NetR;
            LPWSTR Local;


            for (i = 0; i < EntriesRead; i++, NetR++) {

                Local = NetR->lpLocalName;
                TreeConnectStr.Buffer = NULL;

                if (NetR->lpLocalName && *(NetR->lpLocalName) == 0) {
                    Local = NULL;
                } else if ((status = NwCreateTreeConnectName(
                                                            NetR->lpRemoteName,
                                                            Local,
                                                            &TreeConnectStr
                                                            )) != NO_ERROR) {
                    Local = NULL;
                }

                if ( Local != NULL ) {
                    swprintf(LocalUidCombo, L"%ws:%x", Local, WinStationId);
                    //
                    // Delete the symbolic link we created.
                    //
                    if (! DefineDosDeviceW(
                                          DDD_REMOVE_DEFINITION  |
                                          DDD_RAW_TARGET_PATH |
                                          DDD_EXACT_MATCH_ON_REMOVE |
                                          0x80000000,
                                          LocalUidCombo,
                                          TreeConnectStr.Buffer
                                          )) {

#if DBG
                        IF_DEBUG(CONNECT) {
                            KdPrint(("NWWORKSTATION: DefineDosDevice DEL of %ws %ws returned %lu\n",
                                     LocalUidCombo, TreeConnectStr.Buffer, GetLastError()));
                        }
#endif
                    }
#if DBG
                    else {
                        IF_DEBUG(CONNECT) {
                            KdPrint(("NWWORKSTATION: DefineDosDevice DEL of %ws %ws returned successful\n",
                                     LocalUidCombo, TreeConnectStr.Buffer));
                        }
                    }
#endif
                    if (TreeConnectStr.Buffer != NULL) {
                        (void) LocalFree((HLOCAL) TreeConnectStr.Buffer);
                        TreeConnectStr.Buffer = NULL;
                    }
                }

            }

            NetR = SavePtr;

        } else if (status == WN_MORE_DATA) {

            //
            // Original buffer was too small.  Free it and allocate
            // the recommended size and then some to get as many
            // entries as possible.
            //

            (void) LocalFree((HLOCAL) NetR);

            BytesNeeded += NW_ENUM_EXTRA_BYTES;

            if ((NetR = (LPVOID) LocalAlloc(
                                           0,
                                           BytesNeeded
                                           )) == NULL) {

                status = ERROR_NOT_ENOUGH_MEMORY;
                goto CleanExit;
            }
        } else {
            // give up if see any other return code
            break ;
        }

    } while (status != WN_NO_MORE_ENTRIES);

    CleanExit:
    (void) NwrCloseEnum(&EnumHandle);

    if (NetR != NULL) {
        (void) LocalFree((HLOCAL) NetR);
    }
    return NO_ERROR;
}
//
// Terminal Server Addition
//

LPTSTR
NwReturnSessionPath(
                    IN  LPTSTR LocalDeviceName
                   )
/*++

Routine Description:

    This function returns the per session path to access the
    specific dos device for multiple session support.


Arguments:

    LocalDeviceName - Supplies the local device name specified by the API
        caller.

Return Value:

    LPTSTR - Pointer to per session path in newly allocated memory
             by LocalAlloc().

--*/
{
    BOOL  rc;
    DWORD SessionId;
    CLIENT_ID ClientId;
    LPTSTR SessionDeviceName = NULL;
    NTSTATUS status;

    if ((status = NwGetSessionId(&SessionId)) != NO_ERROR) {
        return NULL;
    }

    rc = DosPathToSessionPath(
                             SessionId,
                             LocalDeviceName,
                             &SessionDeviceName
                             );

    if ( !rc ) {
        return NULL;
    }

    return SessionDeviceName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\server\address.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    address.c

Abstract:

    This module contains the code to support NPGetAddressByName.

Author:

    Yi-Hsin Sung (yihsins)    18-Apr-94

Revision History:

    yihsins      Created

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <nwxchg.h>
#include <ntddnwfs.h>
#include <rpc.h>
#include <rpcdce.h>
#include "handle.h"
#include "rnrdefs.h"
#include "sapcmn.h"
#include <time.h>

VOID
DummyRoutine()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\lib\reg.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    reg.c

Abstract:

    This module provides helpers to call the registry used by both
    the client and server sides of the workstation.

Author:

    Rita Wong (ritaw)     22-Apr-1993

--*/


#include <stdlib.h>
#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winerror.h>
#include <winbase.h>
#include <winreg.h>
#include <winsvc.h>

#include <nwsnames.h>
#include <nwreg.h>
#include <nwapi.h>
#include <lmcons.h>
#include <lmerr.h>

#define LMSERVER_LINKAGE_REGKEY   L"System\\CurrentControlSet\\Services\\LanmanServer\\Linkage"
#define OTHERDEPS_VALUENAME       L"OtherDependencies"
#define LANMAN_SERVER             L"LanmanServer"

//
// Forward Declare
//

static
DWORD
NwRegQueryValueExW(
    IN      HKEY    hKey,
    IN      LPWSTR  lpValueName,
    OUT     LPDWORD lpReserved,
    OUT     LPDWORD lpType,
    OUT     LPBYTE  lpData,
    IN OUT  LPDWORD lpcbData
    );

static
DWORD
EnumAndDeleteShares(
    VOID
    ) ;

DWORD 
CalcNullNullSize(
    WCHAR *pszNullNull
    )  ;

WCHAR *
FindStringInNullNull(
    WCHAR *pszNullNull,
    WCHAR *pszString
    ) ;

VOID
RemoveNWCFromNullNullList(
    WCHAR *OtherDeps
    ) ;

DWORD RemoveNwcDependency(
    VOID
    ) ;



DWORD
NwReadRegValue(
    IN HKEY Key,
    IN LPWSTR ValueName,
    OUT LPWSTR *Value
    )
/*++

Routine Description:

    This function allocates the output buffer and reads the requested
    value from the registry into it.

Arguments:

    Key - Supplies opened handle to the key to read from.

    ValueName - Supplies name of the value to retrieve data.

    Value - Returns a pointer to the output buffer which points to
        the memory allocated and contains the data read in from the
        registry.  This pointer must be freed with LocalFree when done.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - Failed to create buffer to read value into.

    Error from registry call.

--*/
{
    LONG    RegError;
    DWORD   NumRequired = 0;
    DWORD   ValueType;
    

    //
    // Set returned buffer pointer to NULL.
    //
    *Value = NULL;

    RegError = NwRegQueryValueExW(
                   Key,
                   ValueName,
                   NULL,
                   &ValueType,
                   (LPBYTE) NULL,
                   &NumRequired
                   );

    if (RegError != ERROR_SUCCESS && NumRequired > 0) {

        if ((*Value = (LPWSTR) LocalAlloc(
                                      LMEM_ZEROINIT,
                                      (UINT) NumRequired
                                      )) == NULL) {

            KdPrint(("NWWORKSTATION: NwReadRegValue: LocalAlloc of size %lu failed %lu\n",
                     NumRequired, GetLastError()));

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        RegError = NwRegQueryValueExW(
                       Key,
                       ValueName,
                       NULL,
                       &ValueType,
                       (LPBYTE) *Value,
                       &NumRequired
                       );
    }
    else if (RegError == ERROR_SUCCESS) {
        KdPrint(("NWWORKSTATION: NwReadRegValue got SUCCESS with NULL buffer."));
        return ERROR_FILE_NOT_FOUND;
    }

    if (RegError != ERROR_SUCCESS) {

        if (*Value != NULL) {
            (void) LocalFree((HLOCAL) *Value);
            *Value = NULL;
        }

        return (DWORD) RegError;
    }

    return NO_ERROR;
}


static
DWORD
NwRegQueryValueExW(
    IN HKEY hKey,
    IN LPWSTR lpValueName,
    OUT LPDWORD lpReserved,
    OUT LPDWORD lpType,
    OUT LPBYTE  lpData,
    IN OUT LPDWORD lpcbData
    )
/*++

Routine Description:

    This routine supports the same functionality as Win32 RegQueryValueEx
    API, except that it works.  It returns the correct lpcbData value when
    a NULL output buffer is specified.

    This code is stolen from the service controller.

Arguments:

    same as RegQueryValueEx

Return Value:

    NO_ERROR or reason for failure.

--*/
{    
    NTSTATUS ntstatus;
    UNICODE_STRING ValueName;
    PKEY_VALUE_FULL_INFORMATION KeyValueInfo;
    DWORD BufSize;


    UNREFERENCED_PARAMETER(lpReserved);

    //
    // Make sure we have a buffer size if the buffer is present.
    //
    if ((ARGUMENT_PRESENT(lpData)) && (! ARGUMENT_PRESENT(lpcbData))) {
        return ERROR_INVALID_PARAMETER;
    }

    RtlInitUnicodeString(&ValueName, lpValueName);

    //
    // Allocate memory for the ValueKeyInfo
    //
    BufSize = *lpcbData + sizeof(KEY_VALUE_FULL_INFORMATION) +
              ValueName.Length
              - sizeof(WCHAR);  // subtract memory for 1 char because it's included
                                // in the sizeof(KEY_VALUE_FULL_INFORMATION).

    KeyValueInfo = (PKEY_VALUE_FULL_INFORMATION) LocalAlloc(
                                                     LMEM_ZEROINIT,
                                                     (UINT) BufSize
                                                     );

    if (KeyValueInfo == NULL) {
        KdPrint(("NWWORKSTATION: NwRegQueryValueExW: LocalAlloc failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ntstatus = NtQueryValueKey(
                   hKey,
                   &ValueName,
                   KeyValueFullInformation,
                   (PVOID) KeyValueInfo,
                   (ULONG) BufSize,
                   (PULONG) &BufSize
                   );

    if ((NT_SUCCESS(ntstatus) || (ntstatus == STATUS_BUFFER_OVERFLOW))
          && ARGUMENT_PRESENT(lpcbData)) {

        *lpcbData = KeyValueInfo->DataLength;
    }

    if (NT_SUCCESS(ntstatus)) {

        if (ARGUMENT_PRESENT(lpType)) {
            *lpType = KeyValueInfo->Type;
        }


        if (ARGUMENT_PRESENT(lpData)) {
            memcpy(
                lpData,
                (LPBYTE)KeyValueInfo + KeyValueInfo->DataOffset,
                KeyValueInfo->DataLength
                );
        }
    }

    (void) LocalFree((HLOCAL) KeyValueInfo);

    return RtlNtStatusToDosError(ntstatus);

}

VOID
NwLuidToWStr(
    IN PLUID LogonId,
    OUT LPWSTR LogonIdStr
    )
/*++

Routine Description:

    This routine converts a LUID into a string in hex value format so
    that it can be used as a registry key.

Arguments:

    LogonId - Supplies the LUID.

    LogonIdStr - Receives the string.  This routine assumes that this
        buffer is large enough to fit 17 characters.

Return Value:

    None.

--*/
{
    swprintf(LogonIdStr, L"%08lx%08lx", LogonId->HighPart, LogonId->LowPart);
}

VOID
NwWStrToLuid(
    IN LPWSTR LogonIdStr,
    OUT PLUID LogonId
    )
/*++

Routine Description:

    This routine converts a string in hex value format into a LUID.

Arguments:

    LogonIdStr - Supplies the string.

    LogonId - Receives the LUID.

Return Value:

    None.

--*/
{
    swscanf(LogonIdStr, L"%08lx%08lx", &LogonId->HighPart, &LogonId->LowPart);
}


DWORD
NwDeleteInteractiveLogon(
    IN PLUID Id OPTIONAL
    )
/*++

Routine Description:

    This routine deletes a specific interactive logon ID key in the registry
    if a logon ID is specified, otherwise it deletes all interactive logon
    ID keys.

Arguments:

    Id - Supplies the logon ID to delete.  NULL means delete all.

Return Status:

    None.

--*/
{
    LONG RegError;
    LONG DelError = ERROR_SUCCESS;
    HKEY InteractiveLogonKey;

    WCHAR LogonIdKey[NW_MAX_LOGON_ID_LEN];


    RegError = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_INTERACTIVE_LOGON_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ | KEY_WRITE | DELETE,
                   &InteractiveLogonKey
                   );

    if (RegError != ERROR_SUCCESS) {
        return RegError;
    }

    if (ARGUMENT_PRESENT(Id)) {

        //
        // Delete the key specified.
        //
        NwLuidToWStr(Id, LogonIdKey);

        DelError = RegDeleteKeyW(InteractiveLogonKey, LogonIdKey);

        if ( DelError )
            KdPrint(("     NwDeleteInteractiveLogon: failed to delete logon %lu\n", DelError));

    }
    else {

        //
        // Delete all interactive logon ID keys.
        //

        do {

            RegError = RegEnumKeyW(
                           InteractiveLogonKey,
                           0,
                           LogonIdKey,
                           sizeof(LogonIdKey) / sizeof(WCHAR)
                           );

            if (RegError == ERROR_SUCCESS) {

                //
                // Got a logon id key, delete it.
                //

                DelError = RegDeleteKeyW(InteractiveLogonKey, LogonIdKey);
            }
            else if (RegError != ERROR_NO_MORE_ITEMS) {
                KdPrint(("     NwDeleteInteractiveLogon: failed to enum logon IDs %lu\n", RegError));
            }

        } while (RegError == ERROR_SUCCESS);
    }

    (void) RegCloseKey(InteractiveLogonKey);

    return ((DWORD) DelError);
}

VOID
NwDeleteCurrentUser(
    VOID
    )
/*++

Routine Description:

    This routine deletes the current user value under the parameters key.

Arguments:

    None.

Return Value:

    None.

--*/
{
    LONG RegError;
    HKEY WkstaKey;

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters
    //
    RegError = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_WORKSTATION_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ | KEY_WRITE | DELETE,
                   &WkstaKey
                   );

    if (RegError != NO_ERROR) {
        KdPrint(("NWPROVAU: NwpInitializeRegistry open NWCWorkstation\\Parameters key unexpected error %lu!\n",
                 RegError));
        return;
    }

    //
    // Delete CurrentUser value first so that the workstation won't be
    // reading this stale value. Ignore error since it may not exist.
    //
    (void) RegDeleteValueW(
               WkstaKey,
               NW_CURRENTUSER_VALUENAME
               );

    (void) RegCloseKey(WkstaKey);
}

DWORD
NwDeleteServiceLogon(
    IN PLUID Id OPTIONAL
    )
/*++

Routine Description:

    This routine deletes a specific service logon ID key in the registry
    if a logon ID is specified, otherwise it deletes all service logon
    ID keys.

Arguments:

    Id - Supplies the logon ID to delete.  NULL means delete all.

Return Status:

    None.

--*/
{
    LONG RegError;
    LONG DelError = STATUS_SUCCESS;
    HKEY ServiceLogonKey;

    WCHAR LogonIdKey[NW_MAX_LOGON_ID_LEN];


    RegError = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_SERVICE_LOGON_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ | KEY_WRITE | DELETE,
                   &ServiceLogonKey
                   );

    if (RegError != ERROR_SUCCESS) {
        return RegError;
    }

    if (ARGUMENT_PRESENT(Id)) {

        //
        // Delete the key specified.
        //
        NwLuidToWStr(Id, LogonIdKey);

        DelError = RegDeleteKeyW(ServiceLogonKey, LogonIdKey);

    }
    else {

        //
        // Delete all service logon ID keys.
        //

        do {

            RegError = RegEnumKeyW(
                           ServiceLogonKey,
                           0,
                           LogonIdKey,
                           sizeof(LogonIdKey) / sizeof(WCHAR)
                           );

            if (RegError == ERROR_SUCCESS) {

                //
                // Got a logon id key, delete it.
                //

                DelError = RegDeleteKeyW(ServiceLogonKey, LogonIdKey);
            }
            else if (RegError != ERROR_NO_MORE_ITEMS) {
                KdPrint(("     NwDeleteServiceLogon: failed to enum logon IDs %lu\n", RegError));
            }

        } while (RegError == ERROR_SUCCESS);
    }

    (void) RegCloseKey(ServiceLogonKey);

    return ((DWORD) DelError);
}

    

DWORD
NwpRegisterGatewayShare(
    IN LPWSTR ShareName,
    IN LPWSTR DriveName
    )
/*++

Routine Description:

    This routine remembers that a gateway share has been created so
    that it can be cleanup up when NWCS is uninstalled.

Arguments:

    ShareName - name of share
    DriveName - name of drive that is shared

Return Status:

    Win32 error of any failure.

--*/
{
    DWORD status ;


    //
    // make sure we have valid parameters
    //
    if (ShareName && DriveName)
    {
        HKEY hKey ;
        DWORD dwDisposition ;

        //
        //
        // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
        // \NWCWorkstation\Shares (create it if not there)
        //
        status  = RegCreateKeyExW(
                      HKEY_LOCAL_MACHINE,
                      NW_WORKSTATION_GATEWAY_SHARES,
                      0, 
                      L"",
                      REG_OPTION_NON_VOLATILE,
                      KEY_WRITE,                 // desired access
                      NULL,                      // default security
                      &hKey,
                      &dwDisposition             // ignored
                      );

        if ( status ) 
            return status ;

        //
        // wtite out value with valuename=sharename, valuedata=drive
        //
        status = RegSetValueExW(
                     hKey,
                     ShareName,
                     0,
                     REG_SZ,
                     (LPBYTE) DriveName,
                     (wcslen(DriveName)+1) * sizeof(WCHAR)) ;
    
        (void) RegCloseKey( hKey );
    }
    else
        status = ERROR_INVALID_PARAMETER ;
    
    return status ;

}

DWORD
NwpCleanupGatewayShares(
    VOID
    )
/*++

Routine Description:

    This routine cleans up all persistent share info and also tidies
    up the registry for NWCS. Later is not needed in uninstall, but is
    there so we have a single routine that completely disables the
    gateway.

Arguments:

    None.

Return Status:

    Win32 error for failed APIs.

--*/
{
    DWORD status, FinalStatus = NO_ERROR ;
    HKEY WkstaKey = NULL, 
         ServerLinkageKey = NULL ;
    LPWSTR OtherDeps = NULL ;

    //
    // Enumeratre and delete all shares
    //
    FinalStatus = status = EnumAndDeleteShares() ;

    //
    // if update registry by cleaning out both Drive and Shares keys.
    // ignore return values here. the keys may not be present.
    //
    (void) RegDeleteKeyW(
                      HKEY_LOCAL_MACHINE,
                      NW_WORKSTATION_GATEWAY_DRIVES
                      ) ;

    (void) RegDeleteKeyW(
                      HKEY_LOCAL_MACHINE,
                      NW_WORKSTATION_GATEWAY_SHARES
                      ) ;
    
    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters
    //
    status  = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_WORKSTATION_REGKEY,
                   REG_OPTION_NON_VOLATILE,   // options
                   KEY_WRITE,                 // desired access
                   &WkstaKey
                   );

    if (status  == ERROR_SUCCESS) 
    {
        //
        // delete the gateway account and gateway enabled flag.
        // ignore failures here (the values may not be present)
        //
        (void) RegDeleteValueW(
                       WkstaKey,
                       NW_GATEWAYACCOUNT_VALUENAME
                       ) ;
        (void) RegDeleteValueW(
                       WkstaKey,
                       NW_GATEWAY_ENABLE
                       ) ;

        (void) RegCloseKey( WkstaKey );
    }

    //
    // store new status if necessary
    //
    if (FinalStatus == NO_ERROR)
        FinalStatus = status ;

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \LanmanServer\Linkage
    //
    status  = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   LMSERVER_LINKAGE_REGKEY,
                   REG_OPTION_NON_VOLATILE,   // options
                   KEY_WRITE | KEY_READ,      // desired access
                   &ServerLinkageKey
                   );

    if (status  == ERROR_SUCCESS) 
    {
        //
        // remove us from the OtherDependencies.
        // ignore read failures here (it may not be present)
        //
        status = NwReadRegValue(
                       ServerLinkageKey,
                       OTHERDEPS_VALUENAME,
                       &OtherDeps
                       );

        if (status == NO_ERROR)
        {
            //
            // this call munges the list to remove NWC if there.
            //
            RemoveNWCFromNullNullList(OtherDeps) ;
            
            status = RegSetValueExW(
                       ServerLinkageKey,
                       OTHERDEPS_VALUENAME,
                       0,
                       REG_MULTI_SZ,
                       (BYTE *)OtherDeps,
                       CalcNullNullSize(OtherDeps) * sizeof(WCHAR)) ;

            (void) LocalFree(OtherDeps) ;

            (void) RemoveNwcDependency() ;    // make this happen right away
                                              // ignore errors - reboot will fix
        }
        else
        {
            status = NO_ERROR ;
        }

        (void) RegCloseKey( ServerLinkageKey );
    }
    
    //
    // store new status if necessary
    //
    if (FinalStatus == NO_ERROR)
        FinalStatus = status ;


    return (FinalStatus) ;
}

DWORD
NwpClearGatewayShare(
    IN LPWSTR ShareName
    )
/*++

Routine Description:

    This routine deletes a specific share from the remembered gateway
    shares in the registry.

Arguments:

    ShareName - share value to delete

Return Status:

    Win32 status code.

--*/
{
    DWORD status = NO_ERROR ;

    //
    // check that paramter is non null
    //
    if (ShareName)
    {
        HKEY hKey ;

        //
        //
        // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
        // \NWCWorkstation\Drives
        //
        status  = RegOpenKeyExW(
                      HKEY_LOCAL_MACHINE,
                      NW_WORKSTATION_GATEWAY_SHARES,
                      REG_OPTION_NON_VOLATILE,   // options
                      KEY_WRITE,                 // desired access
                      &hKey
                      );

        if ( status ) 
            return status ;

        status = RegDeleteValueW(
                     hKey,
                     ShareName
                     ) ;
    
        (void) RegCloseKey( hKey );
    }
    else
        status = ERROR_INVALID_PARAMETER ;

    return status ;
}

typedef NET_API_STATUS (*PF_NETSHAREDEL) (
    LPWSTR server,
    LPWSTR name,
    DWORD  reserved) ;

#define NETSHAREDELSTICKY_API   "NetShareDelSticky"
#define NETSHAREDEL_API         "NetShareDel"
#define NETAPI_DLL             L"NETAPI32"

DWORD
EnumAndDeleteShares(
    VOID
    )
/*++

Routine Description:

    This routine removes all persister share info in the server for 
    all gateway shares.

Arguments:

    None.

Return Status:

    Win32 error code.

--*/
{
    DWORD err, i, type ;
    HKEY hKey = NULL ;
    FILETIME FileTime ;
    HANDLE hNetapi = NULL ;
    PF_NETSHAREDEL pfNetShareDel, pfNetShareDelSticky ;
    WCHAR Class[256], Share[NNLEN+1], Device[MAX_PATH+1] ;
    DWORD dwClass, dwSubKeys, dwMaxSubKey, dwMaxClass,
          dwValues, dwMaxValueName, dwMaxValueData, dwSDLength,
          dwShareLength, dwDeviceLength ;

    //
    // load the library so that not everyone needs link to netapi32
    //
    if (!(hNetapi = LoadLibraryW(NETAPI_DLL)))
        return (GetLastError()) ; 
 
    //
    // get addresses of the 2 functions we are interested in
    //
    if (!(pfNetShareDel = (PF_NETSHAREDEL) GetProcAddress(hNetapi,
                                               NETSHAREDEL_API)))
    {
        err = GetLastError() ; 
        goto ExitPoint ; 
    }

    if (!(pfNetShareDelSticky = (PF_NETSHAREDEL) GetProcAddress(hNetapi,
                                                     NETSHAREDELSTICKY_API)))
    {
        err = GetLastError() ; 
        goto ExitPoint ; 
    }

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCGateway\Shares
    //
    err = RegOpenKeyExW(
              HKEY_LOCAL_MACHINE,
              NW_WORKSTATION_GATEWAY_SHARES,
              REG_OPTION_NON_VOLATILE,   // options
              KEY_READ,                  // desired access
              &hKey
              );

    if ( err ) 
        goto ExitPoint ;

    //
    // read the info about that key
    //
    dwClass = sizeof(Class)/sizeof(Class[0]) ;
    err = RegQueryInfoKeyW(hKey,  
                           Class,
                           &dwClass, 
                           NULL, 
                           &dwSubKeys, 
                           &dwMaxSubKey, 
                           &dwMaxClass,
                           &dwValues, 
                           &dwMaxValueName, 
                           &dwMaxValueData, 
                           &dwSDLength,
                           &FileTime) ;
    if ( err ) 
    {
        goto ExitPoint ;
    }

    //
    // for each value found, we have a share to delete
    //
    for (i = 0; i < dwValues; i++)
    {
        dwShareLength = sizeof(Share)/sizeof(Share[0]) ;
        dwDeviceLength = sizeof(Device) ;
        type = REG_SZ ;
        err = RegEnumValueW(hKey,
                            i,
                            Share,
                            &dwShareLength,
                            NULL, 
                            &type,
                            (LPBYTE)Device,
                            &dwDeviceLength) ;

        //
        // cleanup the share. try delete the share proper. if not
        // there, remove the sticky info instead.
        //
        if (!err) 
        {
            err = (*pfNetShareDel)(NULL, Share, 0) ;

            if (err == NERR_NetNameNotFound) 
            {
                (void) (*pfNetShareDelSticky)(NULL, Share, 0) ;
            }
        }

        //
        // ignore errors within the loop. we can to carry on to 
        // cleanup as much as possible.
        //
        err = NO_ERROR ;
    }



ExitPoint:

    if (hKey)
        (void) RegCloseKey( hKey );

    if (hNetapi)
        (void) FreeLibrary(hNetapi) ;

    return err  ;
}


DWORD 
CalcNullNullSize(
    WCHAR *pszNullNull
    ) 
/*++

Routine Description:

        Walk thru a NULL NULL string, counting the number of
        characters, including the 2 nulls at the end.

Arguments:

        Pointer to a NULL NULL string

Return Status:
        
        Count of number of *characters*. See description.

--*/
{

    DWORD dwSize = 0 ;
    WCHAR *pszTmp = pszNullNull ;

    if (!pszNullNull)
        return 0 ;

    while (*pszTmp) 
    {
        DWORD dwLen = wcslen(pszTmp) + 1 ;

        dwSize +=  dwLen ;
        pszTmp += dwLen ;
    }

    return (dwSize+1) ;
}

WCHAR *
FindStringInNullNull(
    WCHAR *pszNullNull,
    WCHAR *pszString
)
/*++

Routine Description:

    Walk thru a NULL NULL string, looking for the search string

Arguments:

    pszNullNull: the string list we will search.
    pszString:   what we are searching for.

Return Status:

    The start of the string if found. Null, otherwise.

--*/
{
    WCHAR *pszTmp = pszNullNull ;

    if (!pszNullNull || !*pszNullNull)
        return NULL ;
   
    do {

        if  (_wcsicmp(pszTmp,pszString)==0)
            return pszTmp ;
 
        pszTmp +=  wcslen(pszTmp) + 1 ;

    } while (*pszTmp) ;

    return NULL ;
}

VOID
RemoveNWCFromNullNullList(
    WCHAR *OtherDeps
    )
/*++

Routine Description:

    Remove the NWCWorkstation string from a null null string.

Arguments:

    OtherDeps: the string list we will munge.

Return Status:

    None.

--*/
{
    LPWSTR pszTmp0, pszTmp1 ;

    //
    // find the NWCWorkstation string
    //
    pszTmp0 = FindStringInNullNull(OtherDeps, NW_WORKSTATION_SERVICE) ;

    if (!pszTmp0)
        return ;

    pszTmp1 = pszTmp0 + wcslen(pszTmp0) + 1 ;  // skip past it

    //
    // shift the rest up
    //
    memmove(pszTmp0, pszTmp1, CalcNullNullSize(pszTmp1)*sizeof(WCHAR)) ;
}

DWORD RemoveNwcDependency(
    VOID
    )
{
    SC_HANDLE ScManager = NULL;
    SC_HANDLE Service = NULL;
    LPQUERY_SERVICE_CONFIGW lpServiceConfig = NULL;
    DWORD err = NO_ERROR, dwBufferSize = 4096, dwBytesNeeded = 0;
    LPWSTR Deps = NULL ;

    lpServiceConfig = (LPQUERY_SERVICE_CONFIGW) LocalAlloc(LPTR, dwBufferSize) ;

    if (lpServiceConfig ==  NULL) {
        err = GetLastError();
        goto ExitPoint ;
    }

    ScManager = OpenSCManagerW(
                    NULL,
                    NULL,
                    SC_MANAGER_CONNECT
                    );

    if (ScManager == NULL) {

        err = GetLastError();
        goto ExitPoint ;
    }

    Service = OpenServiceW(
                  ScManager,
                  LANMAN_SERVER,
                  (SERVICE_QUERY_CONFIG | SERVICE_CHANGE_CONFIG)
                  );

    if (Service == NULL) {
        err = GetLastError();
        goto ExitPoint ;
    }

    if (!QueryServiceConfigW(
             Service, 
             lpServiceConfig,   // address of service config. structure  
             dwBufferSize,      // size of service configuration buffer 
             &dwBytesNeeded     // address of variable for bytes needed  
             )) {

        err = GetLastError();

        if (err == ERROR_INSUFFICIENT_BUFFER) {

            err = NO_ERROR ;
            dwBufferSize = dwBytesNeeded ;
            lpServiceConfig = (LPQUERY_SERVICE_CONFIGW) 
                                  LocalAlloc(LPTR, dwBufferSize) ;

            if (lpServiceConfig ==  NULL) {
                err = GetLastError();
                goto ExitPoint ;
            }

            if (!QueryServiceConfigW(
                     Service,
                     lpServiceConfig,   // address of service config. structure
                     dwBufferSize,      // size of service configuration buffer
                     &dwBytesNeeded     // address of variable for bytes needed
                     )) {

                err = GetLastError();
            }
        }

        if (err != NO_ERROR) {
            
            goto ExitPoint ;
        }
    }

    Deps = lpServiceConfig->lpDependencies ;

    RemoveNWCFromNullNullList(Deps) ;
 
    if (!ChangeServiceConfigW(
           Service,
           SERVICE_NO_CHANGE,     // service type       (no change)
           SERVICE_NO_CHANGE,     // start type         (no change)
           SERVICE_NO_CHANGE,     // error control      (no change)
           NULL,                  // binary path name   (NULL for no change)
           NULL,                  // load order group   (NULL for no change)
           NULL,                  // tag id             (NULL for no change)
           Deps,                
           NULL,                  // service start name (NULL for no change)
           NULL,                  // password           (NULL for no change)
           NULL                   // display name       (NULL for no change)
           )) {

        err = GetLastError();
        goto ExitPoint ;
    }


ExitPoint:

    if (ScManager) {

        CloseServiceHandle(ScManager);
    }

    if (Service) {

        CloseServiceHandle(Service);
    }

    if (lpServiceConfig) {

        (void) LocalFree(lpServiceConfig) ;
    }

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\server\device.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    device.c

Abstract:

    This module contains the support routines for the APIs that call
    into the NetWare redirector

Author:

    Rita Wong       (ritaw)     20-Feb-1991
    Colin Watson    (colinw)    30-Dec-1992

Revision History:

--*/

#include <nw.h>
#include <nwcons.h>
#include <nwxchg.h>
#include <nwapi32.h>
#include <nwstatus.h>
#include <nwmisc.h>
#include <nwcons.h>
#include <nds.h>
#include <svcguid.h>
#include <tdi.h>
#include <nwreg.h>

#define NW_LINKAGE_REGISTRY_PATH  L"NWCWorkstation\\Linkage"
#define NW_BIND_VALUENAME         L"Bind"

#define TWO_KB                  2048
#define EIGHT_KB                8192
#define EXTRA_BYTES              256

#define TREECHAR                L'*'
#define BUFFSIZE                1024

//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//


STATIC
NTSTATUS
BindToEachTransport(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

DWORD
NwBindTransport(
    IN  LPWSTR TransportName,
    IN  DWORD QualityOfService
    );

DWORD
GetConnectedBinderyServers(
    OUT LPNW_ENUM_CONTEXT ContextHandle
    );

DWORD
GetTreeEntriesFromBindery(
    OUT LPNW_ENUM_CONTEXT ContextHandle
    );

DWORD
NwGetConnectionStatus(
    IN     LPWSTR  pszServerName,
    IN OUT PDWORD_PTR  ResumeKey,
    OUT    LPBYTE  *Buffer,
    OUT    PDWORD  EntriesRead
    );


VOID
GetLuid(
    IN OUT PLUID plogonid
    );

VOID
GetNearestDirServer(
    IN  LPWSTR  TreeName,
    OUT LPDWORD lpdwReplicaAddressSize,
    OUT LPBYTE  lpReplicaAddress
    );

VOID
GetPreferredServerAddress(
    IN  LPWSTR  PreferredServerName,
    OUT LPDWORD lpdwReplicaAddressSize,
    OUT LPBYTE  lpReplicaAddress
    );

BOOL
NwpCompareTreeNames(
    LPWSTR lpServiceInstanceName,
    LPWSTR lpTreeName
    );

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

//
// Handle to the Redirector FSD
//
STATIC HANDLE RedirDeviceHandle = NULL;

//
// Redirector name in NT string format
//
STATIC UNICODE_STRING RedirDeviceName;

extern BOOL NwLUIDDeviceMapsEnabled;


DWORD
NwInitializeRedirector(
    VOID
    )
/*++

Routine Description:

    This routine initializes the NetWare redirector FSD.

Arguments:

    None.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD error;
    NWR_REQUEST_PACKET Rrp;


    //
    // Initialize global handles
    //
    RedirDeviceHandle = NULL;

    //
    // Initialize the global NT-style redirector device name string.
    //
    RtlInitUnicodeString(&RedirDeviceName, DD_NWFS_DEVICE_NAME_U);

    //
    // Load driver
    //
    error = NwLoadOrUnloadDriver(TRUE);

    if (error != NO_ERROR && error != ERROR_SERVICE_ALREADY_RUNNING) {
        return error;
    }

    if ((error = NwOpenRedirector()) != NO_ERROR) {

        //
        // Unload the redirector driver
        //
        (void) NwLoadOrUnloadDriver(FALSE);
        return error;
    }

    //
    // Send the start FSCTL to the redirector
    //
    Rrp.Version = REQUEST_PACKET_VERSION;

    return NwRedirFsControl(
                RedirDeviceHandle,
                FSCTL_NWR_START,
                &Rrp,
                sizeof(NWR_REQUEST_PACKET),
                NULL,
                0,
                NULL
                );
}



DWORD
NwOpenRedirector(
    VOID
    )
/*++

Routine Description:

    This routine opens the NT NetWare redirector FSD.

Arguments:

    None.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    return RtlNtStatusToDosError(
               NwOpenHandle(&RedirDeviceName, FALSE, &RedirDeviceHandle)
               );
}



DWORD
NwShutdownRedirector(
    VOID
    )
/*++

Routine Description:

    This routine stops the NetWare Redirector FSD and unloads it if
    possible.

Arguments:

    None.

Return Value:

    NO_ERROR or ERROR_REDIRECTOR_HAS_OPEN_HANDLES

--*/
{
    NWR_REQUEST_PACKET Rrp;
    DWORD error;


    Rrp.Version = REQUEST_PACKET_VERSION;

    error = NwRedirFsControl(
                RedirDeviceHandle,
                FSCTL_NWR_STOP,
                &Rrp,
                sizeof(NWR_REQUEST_PACKET),
                NULL,
                0,
                NULL
                );

    (void) NtClose(RedirDeviceHandle);

    RedirDeviceHandle = NULL;

    if (error != ERROR_REDIRECTOR_HAS_OPEN_HANDLES) {

        //
        // Unload the redirector only if all its open handles are closed.
        //
        (void) NwLoadOrUnloadDriver(FALSE);
    }

    return error;
}


DWORD
NwLoadOrUnloadDriver(
    BOOL Load
    )
/*++

Routine Description:

    This routine loads or unloads the NetWare redirector driver.

Arguments:

    Load - Supplies the flag which if TRUE load the driver; otherwise
        unloads the driver.

Return Value:

    NO_ERROR or reason for failure.

--*/
{

    LPWSTR DriverRegistryName;
    UNICODE_STRING DriverRegistryString;
    NTSTATUS ntstatus;
    BOOLEAN WasEnabled;


    DriverRegistryName = (LPWSTR) LocalAlloc(
                                      LMEM_FIXED,
                                      (UINT) (sizeof(SERVICE_REGISTRY_KEY) +
                                              (wcslen(NW_DRIVER_NAME) *
                                               sizeof(WCHAR)))
                                      );

    if (DriverRegistryName == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ntstatus = RtlAdjustPrivilege(
                   SE_LOAD_DRIVER_PRIVILEGE,
                   TRUE,
                   FALSE,
                   &WasEnabled
                   );

    if (! NT_SUCCESS(ntstatus)) {
        (void) LocalFree(DriverRegistryName);
        return RtlNtStatusToDosError(ntstatus);
    }

    wcscpy(DriverRegistryName, SERVICE_REGISTRY_KEY);
    wcscat(DriverRegistryName, NW_DRIVER_NAME);

    RtlInitUnicodeString(&DriverRegistryString, DriverRegistryName);

    if (Load) {
        ntstatus = NtLoadDriver(&DriverRegistryString);
    }
    else {
        ntstatus = NtUnloadDriver(&DriverRegistryString);
    }

    (void) RtlAdjustPrivilege(
               SE_LOAD_DRIVER_PRIVILEGE,
               WasEnabled,
               FALSE,
               &WasEnabled
               );

    (void) LocalFree(DriverRegistryName);

    if (Load) {
        if (ntstatus != STATUS_SUCCESS && ntstatus != STATUS_IMAGE_ALREADY_LOADED) {
            LPWSTR SubString[1];

            KdPrint(("NWWORKSTATION: NtLoadDriver returned %08lx\n", ntstatus));

            SubString[0] = NW_DRIVER_NAME;

            NwLogEvent(
                EVENT_NWWKSTA_CANT_CREATE_REDIRECTOR,
                1,
                SubString,
                ntstatus
                );
        }
    }

    if (ntstatus == STATUS_OBJECT_NAME_NOT_FOUND) {
        return ERROR_FILE_NOT_FOUND;
    }

    return NwMapStatus(ntstatus);
}


DWORD
NwRedirFsControl(
    IN  HANDLE FileHandle,
    IN  ULONG RedirControlCode,
    IN  PNWR_REQUEST_PACKET Rrp,
    IN  ULONG RrpLength,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG Information OPTIONAL
    )
/*++

Routine Description:

Arguments:

    FileHandle - Supplies a handle to the file or device on which the service
        is being performed.

    RedirControlCode - Supplies the NtFsControlFile function code given to
        the redirector.

    Rrp - Supplies the redirector request packet.

    RrpLength - Supplies the length of the redirector request packet.

    SecondBuffer - Supplies the second buffer in call to NtFsControlFile.

    SecondBufferLength - Supplies the length of the second buffer.

    Information - Returns the information field of the I/O status block.

Return Value:

    NO_ERROR or reason for failure.

--*/

{
    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;


    //
    // Send the request to the Redirector FSD.
    //
    ntstatus = NtFsControlFile(
                   FileHandle,
                   NULL,
                   NULL,
                   NULL,
                   &IoStatusBlock,
                   RedirControlCode,
                   (PVOID) Rrp,
                   RrpLength,
                   SecondBuffer,
                   SecondBufferLength
                   );

    if (ntstatus == STATUS_SUCCESS) {
        ntstatus = IoStatusBlock.Status;
    }

    if (ARGUMENT_PRESENT(Information)) {
        *Information = (ULONG) IoStatusBlock.Information;
    }

#if DBG
    if (ntstatus != STATUS_SUCCESS) {
        IF_DEBUG(DEVICE) {
            KdPrint(("NWWORKSTATION: fsctl to redir returns %08lx\n", ntstatus));
        }
    }
#endif

    return NwMapStatus(ntstatus);
}


DWORD
NwBindToTransports(
    VOID
    )

/*++

Routine Description:

    This routine binds to every transport specified under the linkage
    key of the NetWare Workstation service.

Arguments:

    None.

Return Value:

    NET_API_STATUS - success/failure of the operation.

--*/

{
    NTSTATUS ntstatus;
    PRTL_QUERY_REGISTRY_TABLE QueryTable;
    ULONG NumberOfBindings = 0;


    //
    // Ask the RTL to call us back for each subvalue in the MULTI_SZ
    // value \NWCWorkstation\Linkage\Bind.
    //

    if ((QueryTable = (PVOID) LocalAlloc(
                                  LMEM_ZEROINIT,
                                  sizeof(RTL_QUERY_REGISTRY_TABLE) * 2
                                  )) == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    QueryTable[0].QueryRoutine = (PRTL_QUERY_REGISTRY_ROUTINE) BindToEachTransport;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = NW_BIND_VALUENAME;
    QueryTable[0].EntryContext = NULL;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = NULL;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    ntstatus = RtlQueryRegistryValues(
                   RTL_REGISTRY_SERVICES,
                   NW_LINKAGE_REGISTRY_PATH,
                   QueryTable,
                   &NumberOfBindings,
                   NULL
                   );

    (void) LocalFree((HLOCAL) QueryTable);

    //
    // If failed to bind to any transports, the workstation will
    // not start.
    //

    if (! NT_SUCCESS(ntstatus)) {
#if DBG
        IF_DEBUG(INIT) {
            KdPrint(("NwBindToTransports: RtlQueryRegistryValues failed: "
                      "%lx\n", ntstatus));
        }
#endif
        return RtlNtStatusToDosError(ntstatus);
    }

    if (NumberOfBindings == 0) {

#if 0
    //
    // tommye - MS  24187 / MCS 255 
    //

    //
    // We don't want to log an event unnecessarily and panic the user that
    // G/CSNW could not bind. This could have been caused by the user unbinding
    // G/CSNW and rebooting.
    //

        NwLogEvent(
            EVENT_NWWKSTA_NO_TRANSPORTS,
            0,
            NULL,
            NO_ERROR
            );
#endif

        KdPrint(("NWWORKSTATION: NwBindToTransports: could not bind "
                 "to any transport\n"));

        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}


STATIC
NTSTATUS
BindToEachTransport(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    DWORD error;
    LPDWORD NumberOfBindings = Context;
    LPWSTR SubStrings[2];
    static DWORD QualityOfService = 65536;


    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueLength);
    UNREFERENCED_PARAMETER(EntryContext);

    //
    // The value type must be REG_SZ (translated from REG_MULTI_SZ by
    // the RTL).
    //
    if (ValueType != REG_SZ) {

        SubStrings[0] = ValueName;
        SubStrings[1] = NW_LINKAGE_REGISTRY_PATH;

        NwLogEvent(
            EVENT_NWWKSTA_INVALID_REGISTRY_VALUE,
            2,
            SubStrings,
            NO_ERROR
            );

            KdPrint(("NWWORKSTATION: Skipping invalid value %ws\n", ValueName));

        return STATUS_SUCCESS;
    }

    //
    // The value data is the name of the transport device object.
    //

    //
    // Bind to the transport.
    //

#if DBG
    IF_DEBUG(INIT) {
        KdPrint(("NWWORKSTATION: Binding to transport %ws with QOS %lu\n",
                ValueData, QualityOfService));
    }
#endif

    error = NwBindTransport(ValueData, QualityOfService--);

    if (error != NO_ERROR) {

        //
        // If failed to bind to one transport, don't fail starting yet.
        // Try other transports.
        //
        SubStrings[0] = ValueData;

        NwLogEvent(
            EVENT_NWWKSTA_CANT_BIND_TO_TRANSPORT,
            1,
            SubStrings,
            error
            );
    }
    else {
        (*NumberOfBindings)++;
    }

    return STATUS_SUCCESS;
}


DWORD
NwBindTransport(
    IN  LPWSTR TransportName,
    IN  DWORD QualityOfService
    )
/*++

Routine Description:

    This function binds the specified transport to the redirector
    and the datagram receiver.

    NOTE: The transport name length pass to the redirector and
          datagram receiver is the number of bytes.

Arguments:

    TransportName - Supplies the name of the transport to bind to.

    QualityOfService - Supplies a value which specifies the search
        order of the transport with respect to other transports.  The
        highest value is searched first.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;
    DWORD RequestPacketSize;
    DWORD TransportNameSize = wcslen(TransportName) * sizeof(WCHAR);

    PNWR_REQUEST_PACKET Rrp;


    //
    // Size of request packet buffer
    //
    RequestPacketSize = TransportNameSize + sizeof(NWR_REQUEST_PACKET);

    //
    // Allocate memory for redirector/datagram receiver request packet
    //
    if ((Rrp = (PVOID) LocalAlloc(LMEM_ZEROINIT, (UINT) RequestPacketSize)) == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Get redirector to bind to transport
    //
    Rrp->Version = REQUEST_PACKET_VERSION;
    Rrp->Parameters.Bind.QualityOfService = QualityOfService;

    Rrp->Parameters.Bind.TransportNameLength = TransportNameSize;
    wcscpy((LPWSTR) Rrp->Parameters.Bind.TransportName, TransportName);

    if ((status = NwRedirFsControl(
                      RedirDeviceHandle,
                      FSCTL_NWR_BIND_TO_TRANSPORT,
                      Rrp,
                      RequestPacketSize,
                      NULL,
                      0,
                      NULL
                      )) != NO_ERROR) {

        KdPrint(("NWWORKSTATION: NwBindTransport fsctl to bind to transport %ws failed\n",
                 TransportName));
    }

    (void) LocalFree((HLOCAL) Rrp);
    return status;
}


DWORD
NwGetCallerLuid (
    IN OUT  PLUID pLuid
    )
/*++

Routine Description:

    Retrieves the caller's LUID from the effective access_token
    The effective access_token will be the thread's token if
    impersonating, else the process' token

Arguments:

    pLuid [IN OUT] - pointer to a buffer to hold the LUID

Return Value:

    STATUS_SUCCESS - operations successful, did not encounter any errors

    STATUS_INVALID_PARAMETER - pLuid is NULL

    STATUS_NO_TOKEN - could not find a token for the user

    appropriate NTSTATUS code - an unexpected error encountered

--*/

{
    TOKEN_STATISTICS TokenStats;
    HANDLE   hToken    = NULL;
    DWORD    dwLength  = 0;
    NTSTATUS Status;
    ULONG DosError;

    if( (pLuid == NULL) || (sizeof(*pLuid) != sizeof(LUID)) ) {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    // Get the access token
    // Try to get the impersonation token, else the primary token
    //
    Status = NtOpenThreadToken( NtCurrentThread(), TOKEN_READ, TRUE, &hToken );

    if( Status == STATUS_NO_TOKEN ) {

        Status = NtOpenProcessToken( NtCurrentProcess(), TOKEN_READ, &hToken );

    }

    if( NT_SUCCESS(Status) ) {

        //
        // Query the LUID for the user.
        //

        Status = NtQueryInformationToken( hToken,
                                          TokenStatistics,
                                          &TokenStats,
                                          sizeof(TokenStats),
                                          &dwLength );

        if( NT_SUCCESS(Status) ) {
            RtlCopyLuid( pLuid, &(TokenStats.AuthenticationId) );
        }
    }

    if( hToken != NULL ) {
        NtClose( hToken );
    }

    DosError = RtlNtStatusToDosError(Status);

    return( (DWORD)DosError );
}


DWORD
NwCreateTreeConnectName(
    IN  LPWSTR UncName,
    IN  LPWSTR LocalName OPTIONAL,
    OUT PUNICODE_STRING TreeConnectStr
    )
/*++

Routine Description:

    This function replaces \\ with \Device\NwRdr\LocalName:\ in the
    UncName to form the NT-style tree connection name.  LocalName:\ is part
    of the tree connection name only if LocalName is specified.  A buffer
    is allocated by this function and returned as the output string.

Arguments:

    UncName - Supplies the UNC name of the shared resource.

    LocalName - Supplies the local device name for the redirection.

    TreeConnectStr - Returns a string with a newly allocated buffer that
        contains the NT-style tree connection name.

Return Value:

    NO_ERROR - the operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Could not allocate output buffer.

--*/
{
    WCHAR LUIDBuffer[NW_MAX_LOGON_ID_LEN];
    DWORD UncNameLength = wcslen(UncName);
    LUID CallerLuid;
    BOOLEAN UseLUID;

    //UseLUID = (ARGUMENT_PRESENT(LocalName) && NwLUIDDeviceMapsEnabled);

    //
    // Temporary disable passing the LUID until LUID support is added in
    // the nwrdr.sys for parsing the device name
    //
    UseLUID = FALSE;

    //
    // Initialize tree connect string maximum length to hold
    // If LUID DosDevices enabled && LocalName Specified,
    //       \Device\NwRdr\LocalName:XXXXXXXXxxxxxxxx\Server\Volume\Path
    //       XXXXXXXX - LUID.HighPart
    //       xxxxxxxx - LUID.LowPart
    // else
    //       \Device\NwRdr\LocalName:\Server\Volume\Path
    //
    if( UseLUID ) {
        DWORD DosError;

        DosError = NwGetCallerLuid(&CallerLuid);
        if( DosError != NO_ERROR) {
            return DosError;
        }
    }

    TreeConnectStr->MaximumLength = RedirDeviceName.Length +
        sizeof(WCHAR) +                                // For '\'
        (ARGUMENT_PRESENT(LocalName) ? (wcslen(LocalName) * sizeof(WCHAR)) : 0) +
        (UseLUID ? NW_MAX_LOGON_ID_LEN * sizeof(WCHAR): 0) +
        (USHORT) (UncNameLength * sizeof(WCHAR));      // Includes '\' and
                                                       // term char


    if ((TreeConnectStr->Buffer = (PWSTR) LocalAlloc(
                                              LMEM_ZEROINIT,
                                              (UINT) TreeConnectStr->MaximumLength
                                              )) == NULL) {
        KdPrint(("NWWORKSTATION: NwCreateTreeConnectName LocalAlloc failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy \Device\NwRdr
    //
    RtlCopyUnicodeString(TreeConnectStr, &RedirDeviceName);

    //
    // Concatenate \LocalName:
    //
    if (ARGUMENT_PRESENT(LocalName)) {

        wcscat(TreeConnectStr->Buffer, L"\\");
        TreeConnectStr->Length += sizeof(WCHAR);

        wcscat(TreeConnectStr->Buffer, LocalName);

        TreeConnectStr->Length += (USHORT) (wcslen(LocalName) * sizeof(WCHAR));

        //
        // Concatenate the caller's LUID
        //
        if( UseLUID ) {
            _snwprintf( LUIDBuffer,
                        sizeof(LUIDBuffer)/sizeof(WCHAR),
                        L"%08x%08x",
                        CallerLuid.HighPart,
                        CallerLuid.LowPart );

            wcscat(TreeConnectStr->Buffer, LUIDBuffer);

            TreeConnectStr->Length += (USHORT) (wcslen(LUIDBuffer) * sizeof(WCHAR));
        }
    }

    //
    // Concatenate \Server\Volume\Path
    //
    wcscat(TreeConnectStr->Buffer, &UncName[1]);
    TreeConnectStr->Length += (USHORT) ((UncNameLength - 1) * sizeof(WCHAR));

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("NWWORKSTATION: NwCreateTreeConnectName %ws, maxlength %u, length %u\n",
                 TreeConnectStr->Buffer, TreeConnectStr->MaximumLength,
                 TreeConnectStr->Length));
    }
#endif

    return NO_ERROR;
}



DWORD
NwOpenCreateConnection(
    IN PUNICODE_STRING TreeConnectionName,
    IN LPWSTR UserName OPTIONAL,
    IN LPWSTR Password OPTIONAL,
    IN LPWSTR UncName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN ULONG ConnectionType,
    OUT PHANDLE TreeConnectionHandle,
    OUT PULONG_PTR Information OPTIONAL
    )
/*++

Routine Description:

    This function asks the redirector to either open an existing tree
    connection (CreateDisposition == FILE_OPEN), or create a new tree
    connection if one does not exist (CreateDisposition == FILE_CREATE).

    The password and user name passed to the redirector via the EA buffer
    in the NtCreateFile call.  The EA buffer is NULL if neither password
    or user name is specified.

    The redirector expects the EA descriptor strings to be in ANSI
    but the password and username themselves are in Unicode.

Arguments:

    TreeConnectionName - Supplies the name of the tree connection in NT-style
        file name format: \Device\NwRdr\Server\Volume\Directory

    UserName - Supplies the user name to create the tree connection with.

    Password - Supplies the password to create the tree connection with.

    DesiredAccess - Supplies the access need on the connection handle.

    CreateDisposition - Supplies the create disposition value to either
        open or create the tree connection.

    CreateOptions - Supplies the options used when creating or opening
        the tree connection.

    ConnectionType - Supplies the type of the connection (DISK, PRINT,
        or ANY).

    TreeConnectionHandle - Returns the handle to the tree connection
        created/opened by the redirector.

    Information - Returns the information field of the I/O status block.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;
    NTSTATUS ntstatus;

    OBJECT_ATTRIBUTES UncNameAttributes;
    IO_STATUS_BLOCK IoStatusBlock;

    PFILE_FULL_EA_INFORMATION EaBuffer = NULL;
    PFILE_FULL_EA_INFORMATION Ea;
    ULONG EaBufferSize = 0;

    UCHAR EaNamePasswordSize = (UCHAR) (ROUND_UP_COUNT(
                                            strlen(EA_NAME_PASSWORD) + sizeof(CHAR),
                                            ALIGN_WCHAR
                                            ) - sizeof(CHAR));
    UCHAR EaNameUserNameSize = (UCHAR) (ROUND_UP_COUNT(
                                            strlen(EA_NAME_USERNAME) + sizeof(CHAR),
                                            ALIGN_WCHAR
                                            ) - sizeof(CHAR));

    UCHAR EaNameTypeSize = (UCHAR) (ROUND_UP_COUNT(
                                        strlen(EA_NAME_TYPE) + sizeof(CHAR),
                                        ALIGN_DWORD
                                        ) - sizeof(CHAR));

    USHORT PasswordSize = 0;
    USHORT UserNameSize = 0;
    USHORT TypeSize = sizeof(ULONG);



    InitializeObjectAttributes(
        &UncNameAttributes,
        TreeConnectionName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Calculate the number of bytes needed for the EA buffer to put the
    // password or user name.
    //
    if (ARGUMENT_PRESENT(Password)) {

#if DBG
        IF_DEBUG(CONNECT) {
            KdPrint(("NWWORKSTATION: NwOpenCreateConnection password is %ws\n",
                     Password));
        }
#endif

        PasswordSize = (USHORT) (wcslen(Password) * sizeof(WCHAR));

        EaBufferSize = ROUND_UP_COUNT(
                           FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                           EaNamePasswordSize + sizeof(CHAR) +
                           PasswordSize,
                           ALIGN_DWORD
                           );
    }

    if (ARGUMENT_PRESENT(UserName)) {

#if DBG
        IF_DEBUG(CONNECT) {
            KdPrint(("NWWORKSTATION: NwOpenCreateConnection username is %ws\n",
                     UserName));
        }
#endif

        UserNameSize = (USHORT) (wcslen(UserName) * sizeof(WCHAR));

        EaBufferSize += ROUND_UP_COUNT(
                            FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                            EaNameUserNameSize + sizeof(CHAR) +
                            UserNameSize,
                            ALIGN_DWORD
                            );
    }

    EaBufferSize += FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                    EaNameTypeSize + sizeof(CHAR) +
                    TypeSize;

    //
    // Allocate the EA buffer
    //
    if ((EaBuffer = (PFILE_FULL_EA_INFORMATION) LocalAlloc(
                                                    LMEM_ZEROINIT,
                                                    (UINT) EaBufferSize
                                                    )) == NULL) {
        status = GetLastError();
        goto FreeMemory;
    }

    Ea = EaBuffer;

    if (ARGUMENT_PRESENT(Password)) {

        //
        // Copy the EA name into EA buffer.  EA name length does not
        // include the zero terminator.
        //
        strcpy((LPSTR) Ea->EaName, EA_NAME_PASSWORD);
        Ea->EaNameLength = EaNamePasswordSize;

        //
        // Copy the EA value into EA buffer.  EA value length does not
        // include the zero terminator.
        //
        wcscpy(
            (LPWSTR) &(Ea->EaName[EaNamePasswordSize + sizeof(CHAR)]),
            Password
            );

        Ea->EaValueLength = PasswordSize;

        Ea->NextEntryOffset = ROUND_UP_COUNT(
                                  FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  EaNamePasswordSize + sizeof(CHAR) +
                                  PasswordSize,
                                  ALIGN_DWORD
                                  );

        Ea->Flags = 0;
        (ULONG_PTR) Ea += Ea->NextEntryOffset;
    }

    if (ARGUMENT_PRESENT(UserName)) {

        //
        // Copy the EA name into EA buffer.  EA name length does not
        // include the zero terminator.
        //
        strcpy((LPSTR) Ea->EaName, EA_NAME_USERNAME);
        Ea->EaNameLength = EaNameUserNameSize;

        //
        // Copy the EA value into EA buffer.  EA value length does not
        // include the zero terminator.
        //
        wcscpy(
            (LPWSTR) &(Ea->EaName[EaNameUserNameSize + sizeof(CHAR)]),
            UserName
            );

        Ea->EaValueLength = UserNameSize;

        Ea->NextEntryOffset = ROUND_UP_COUNT(
                                  FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  EaNameUserNameSize + sizeof(CHAR) +
                                  UserNameSize,
                                  ALIGN_DWORD
                                  );
        Ea->Flags = 0;

        (ULONG_PTR) Ea += Ea->NextEntryOffset;

    }

    //
    // Copy the connection type name into EA buffer.  EA name length
    // does not include the zero terminator.
    //
    strcpy((LPSTR) Ea->EaName, EA_NAME_TYPE);
    Ea->EaNameLength = EaNameTypeSize;

    *((PULONG) &(Ea->EaName[EaNameTypeSize + sizeof(CHAR)])) = ConnectionType;

    Ea->EaValueLength = TypeSize;

    //
    // Terminate the EA.
    //
    Ea->NextEntryOffset = 0;
    Ea->Flags = 0;

    //
    // Create or open a tree connection
    //
    ntstatus = NtCreateFile(
                   TreeConnectionHandle,
                   DesiredAccess,
                   &UncNameAttributes,
                   &IoStatusBlock,
                   NULL,
                   FILE_ATTRIBUTE_NORMAL,
                   FILE_SHARE_VALID_FLAGS,
                   CreateDisposition,
                   CreateOptions,
                   (PVOID) EaBuffer,
                   EaBufferSize
                   );

    if (ntstatus == NWRDR_PASSWORD_HAS_EXPIRED) {
        //
        // wait till other thread is not using the popup data struct.
        // if we timeout, then we just lose the popup.
        //
        switch (WaitForSingleObject(NwPopupDoneEvent, 3000))
        {
            case WAIT_OBJECT_0:
            {
                LPWSTR lpServerStart, lpServerEnd ;
                WCHAR UserNameW[NW_MAX_USERNAME_LEN+1] ;
                DWORD dwUserNameWSize = sizeof(UserNameW)/sizeof(UserNameW[0]) ;
                DWORD dwServerLength, dwGraceLogins ;
                DWORD dwMessageId = NW_PASSWORD_HAS_EXPIRED ;

                //
                // get the current username
                //
                if (UserName)
                {
                    wcscpy(UserNameW, UserName) ;
                }
                else
                {
                    if (!GetUserNameW(UserNameW, &dwUserNameWSize))
                    {
                        SetEvent(NwPopupDoneEvent) ;
                        break ;
                    }
                }

                //
                // allocate string and fill in the username
                //
                if (!(PopupData.InsertStrings[0] =
                    (LPWSTR)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                       sizeof(WCHAR) * (wcslen(UserNameW)+1))))
                {
                    SetEvent(NwPopupDoneEvent) ;
                    break ;
                }
                wcscpy(PopupData.InsertStrings[0], UserNameW) ;

                //
                // find the server name from unc name
                //
                lpServerStart = (*UncName == L'\\') ? UncName+2 : UncName ;
                lpServerEnd = wcschr(lpServerStart,L'\\') ;
                dwServerLength = lpServerEnd ? (DWORD) (lpServerEnd-lpServerStart) :
                                 wcslen(lpServerStart) ;

                //
                // allocate string and fill in the server insert string
                //
                if (!(PopupData.InsertStrings[1] =
                    (LPWSTR)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                       sizeof(WCHAR) * (dwServerLength+1))))
                {
                    (void) LocalFree((HLOCAL) PopupData.InsertStrings[0]);
                    SetEvent(NwPopupDoneEvent) ;
                    break ;
                }
                wcsncpy(PopupData.InsertStrings[1],
                        lpServerStart,
                        dwServerLength) ;

                //
                // now call the NCP. if an error occurs while getting
                // the grace login count, dont use it.
                //
                if (NwGetGraceLoginCount(
                                     PopupData.InsertStrings[1],
                                     UserNameW,
                                     &dwGraceLogins) != NO_ERROR)
                {
                    dwMessageId = NW_PASSWORD_HAS_EXPIRED1 ;
                    dwGraceLogins = 0 ;
                }

                //
                // stick the number of grace logins in second insert string.
                //
                if (!(PopupData.InsertStrings[2] =
                    (LPWSTR)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                       sizeof(WCHAR) * 16)))
                {
                    (void) LocalFree((HLOCAL) PopupData.InsertStrings[0]);
                    (void) LocalFree((HLOCAL) PopupData.InsertStrings[1]);
                    SetEvent(NwPopupDoneEvent) ;
                    break ;
                }

                wsprintfW(PopupData.InsertStrings[2], L"%d", dwGraceLogins);
                PopupData.InsertCount = 3 ;
                PopupData.MessageId = dwMessageId ;

        //--Mutl-user change ----
                GetLuid( &PopupData.LogonId );          

                //
                // all done at last, trigger the other thread do the popup
                //
                SetEvent(NwPopupEvent) ;
                break ;

            }

            default:
                break ; // dont bother if we cannot
        }
    }

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = IoStatusBlock.Status;
    }

    if (ntstatus == NWRDR_PASSWORD_HAS_EXPIRED) {
        ntstatus = STATUS_SUCCESS ;
    }

    if (ARGUMENT_PRESENT(Information)) {
        *Information = IoStatusBlock.Information;
    }

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("NWWORKSTATION: NtCreateFile returns %lx\n", ntstatus));
    }
#endif

    status = NwMapStatus(ntstatus);

FreeMemory:
    if (EaBuffer != NULL) {
        RtlZeroMemory( EaBuffer, EaBufferSize );  // Clear the password
        (void) LocalFree((HLOCAL) EaBuffer);
    }

    return status;
}


DWORD
NwNukeConnection(
    IN HANDLE TreeConnection,
    IN DWORD UseForce
    )
/*++

Routine Description:

    This function asks the redirector to delete an existing tree
    connection.

Arguments:

    TreeConnection - Supplies the handle to an existing tree connection.

    UseForce - Supplies the force flag to delete the tree connection.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;
    NWR_REQUEST_PACKET Rrp;            // Redirector request packet


    //
    // Tell the redirector to delete the tree connection
    //
    Rrp.Version = REQUEST_PACKET_VERSION;
    Rrp.Parameters.DeleteConn.UseForce = (BOOLEAN) UseForce;

    status = NwRedirFsControl(
                 TreeConnection,
                 FSCTL_NWR_DELETE_CONNECTION,
                 &Rrp,
                 sizeof(NWR_REQUEST_PACKET),
                 NULL,
                 0,
                 NULL
                 );

    return status;
}


DWORD
NwGetServerResource(
    IN LPWSTR LocalName,
    IN DWORD LocalNameLength,
    OUT LPWSTR RemoteName,
    IN DWORD RemoteNameLen,
    OUT LPDWORD CharsRequired
    )
/*++

Routine Description:

    This function

Arguments:


Return Value:


--*/
{
    DWORD status = NO_ERROR;

    BYTE Buffer[sizeof(NWR_REQUEST_PACKET) + 2 * sizeof(WCHAR)];
    PNWR_REQUEST_PACKET Rrp = (PNWR_REQUEST_PACKET) Buffer;


    //
    // local device name should not be longer than 4 characters e.g. LPTx, X:
    //
    if ( LocalNameLength > 4 )
        return ERROR_INVALID_PARAMETER;

    Rrp->Version = REQUEST_PACKET_VERSION;

    wcsncpy(Rrp->Parameters.GetConn.DeviceName, LocalName, LocalNameLength);
    Rrp->Parameters.GetConn.DeviceNameLength = LocalNameLength * sizeof(WCHAR);

    status = NwRedirFsControl(
                 RedirDeviceHandle,
                 FSCTL_NWR_GET_CONNECTION,
                 Rrp,
                 sizeof(NWR_REQUEST_PACKET) +
                     Rrp->Parameters.GetConn.DeviceNameLength,
                 RemoteName,
                 RemoteNameLen * sizeof(WCHAR),
                 NULL
                 );

    if (status == ERROR_INSUFFICIENT_BUFFER) {
        *CharsRequired = Rrp->Parameters.GetConn.BytesNeeded / sizeof(WCHAR);
    }
    else if (status == ERROR_FILE_NOT_FOUND) {

        //
        // Redirector could not find the specified LocalName
        //
        status = WN_NOT_CONNECTED;
    }

    return status;

}


DWORD
NwEnumerateConnections(
    IN OUT PDWORD_PTR ResumeId,
    IN DWORD_PTR EntriesRequested,
    IN LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead,
    IN DWORD ConnectionType,
    IN PLUID LogonId
    )
/*++

Routine Description:

    This function asks the redirector to enumerate all existing
    connections.

Arguments:

    ResumeId - On input, supplies the resume ID of the next entry
        to begin the enumeration.  This ID is an integer value that
        is either the smaller or the same value as the ID of the
        next entry to return.  On output, this ID indicates the next
        entry to start resuming from for the subsequent call.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned iff ERROR_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

    ConnectionType - The type of connected resource wanted ( DISK, PRINT, ...)

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;
    NWR_REQUEST_PACKET Rrp;            // Redirector request packet


    //
    // Tell the redirector to enumerate all connections.
    //
    Rrp.Version = REQUEST_PACKET_VERSION;

    Rrp.Parameters.EnumConn.ResumeKey = *ResumeId;
    Rrp.Parameters.EnumConn.EntriesRequested = (ULONG) EntriesRequested;
    Rrp.Parameters.EnumConn.ConnectionType = ConnectionType;


    //Multi-user change
    if (LogonId != NULL ) {
        Rrp.Parameters.EnumConn.Uid = *LogonId;
    }
    //
    // This is good to do, the the fix below is also needed.
    //
    Rrp.Parameters.EnumConn.EntriesReturned = 0;

    status = NwRedirFsControl(
                 RedirDeviceHandle,
                 FSCTL_NWR_ENUMERATE_CONNECTIONS,
                 &Rrp,
                 sizeof(NWR_REQUEST_PACKET),
                 Buffer,                      // User output buffer
                 BufferSize,
                 NULL
                 );

    *EntriesRead = Rrp.Parameters.EnumConn.EntriesReturned;


    //
    // Strange bug on shutdown
    // WinLogon was clearing connections after the shutdown
    //
    if (status == ERROR_INVALID_HANDLE ) {
        KdPrint(("NWWORKSTATION: NwEnumerateConnections Invalid Handle!\n"));
        *EntriesRead = 0;
    }
    else if (status == WN_MORE_DATA) {
        *BytesNeeded = Rrp.Parameters.EnumConn.BytesNeeded;

        //
        // NP specs expect WN_SUCCESS in this case.
        //
        if (*EntriesRead)
            status = WN_SUCCESS ;
    }

    *ResumeId = Rrp.Parameters.EnumConn.ResumeKey;

    return status;
}


DWORD
NwGetNextServerEntry(
    IN HANDLE PreferredServer,
    IN OUT LPDWORD LastObjectId,
    OUT LPSTR ServerName
    )
/*++

Routine Description:

    This function uses an opened handle to the preferred server to
    scan it bindery for all file server objects.

Arguments:

    PreferredServer - Supplies the handle to the preferred server on
        which to scan the bindery.

    LastObjectId - On input, supplies the object ID to the last file
        server object returned, which is the resume handle to get the
        next file server object.  On output, receives the object ID
        of the file server object returned.

    ServerName - Receives the name of the returned file server object.

Return Value:

    NO_ERROR - Successfully gotten a file server name.

    WN_NO_MORE_ENTRIES - No other file server object past the one
        specified by LastObjectId.

--*/
{
    NTSTATUS ntstatus;
    WORD ObjectType;


#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("NWWORKSTATION: NwGetNextServerEntry LastObjectId %lu\n",
                 *LastObjectId));
    }
#endif

    ntstatus = NwlibMakeNcp(
                   PreferredServer,
                   FSCTL_NWR_NCP_E3H,    // Bindery function
                   58,                   // Max request packet size
                   59,                   // Max response packet size
                   "bdwp|dwc",           // Format string
                   0x37,                 // Scan bindery object
                   *LastObjectId,        // Previous ID
                   0x4,                  // File server object
                   "*",                  // Wildcard to match all
                   LastObjectId,         // Current ID
                   &ObjectType,          // Ignore
                   ServerName            // Currently returned server
                   );

#if DBG
    if (ntstatus == STATUS_SUCCESS) {
        IF_DEBUG(ENUM) {
            KdPrint(("NWWORKSTATION: NwGetNextServerEntry NewObjectId %08lx, ServerName %s\n",
                     *LastObjectId, ServerName));
        }
    }
#endif

    return NwMapBinderyCompletionCode(ntstatus);
}


DWORD
GetConnectedBinderyServers(
    OUT LPNW_ENUM_CONTEXT ContextHandle
    )
/*++

Routine Description:

    This function is a helper routine for the function
    NwGetNextServerConnection. It allocates a buffer to cache
    bindery server names returned from calls to the redirector. Since the
    redirector may return duplicate bindery server names, this
    function checks to see if the server name already exist in the buffer
    before adding it.

Arguments:

    ContextHandle - Used to track cached bindery information and the
                    current server name pointer in the cache buffer.

Return Value:

    NO_ERROR - Successfully returned a server name and cache buffer.

    WN_NO_MORE_ENTRIES - No other server object past the one
        specified by CH->ResumeId.

    ERROR_NOT_ENOUGH_MEMORY - Function was unable to allocate a buffer.

++*/
{
    DWORD_PTR  ResumeKey = 0;
    LPBYTE pBuffer = NULL;
    DWORD  EntriesRead = 0;
    BYTE   tokenIter;
    LPWSTR tokenPtr;
    BOOL   fAddToList;
    DWORD  status = NwGetConnectionStatus( NULL,
                                           &ResumeKey,
                                           &pBuffer,
                                           &EntriesRead );

    if ( status == NO_ERROR  && EntriesRead > 0 )
    {
        DWORD i;
        PCONN_STATUS pConnStatus = (PCONN_STATUS) pBuffer;

        ContextHandle->ResumeId = 0;
        ContextHandle->NdsRawDataCount = 0;
        ContextHandle->NdsRawDataSize = (NW_MAX_SERVER_LEN + 2) * EntriesRead;
        ContextHandle->NdsRawDataBuffer =
                    (DWORD_PTR) LocalAlloc( LMEM_ZEROINIT,
                                        ContextHandle->NdsRawDataSize );

        if ( ContextHandle->NdsRawDataBuffer == 0 )
        {
            KdPrint(("NWWORKSTATION: GetConnectedBinderyServers LocalAlloc failed %lu\n",
                     GetLastError()));

            ContextHandle->NdsRawDataSize = 0;

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        for ( i = 0; i < EntriesRead ; i++ )
        {
            fAddToList = FALSE;

            if ( pConnStatus->fNds == 0 &&
                 ( pConnStatus->dwConnType == NW_CONN_BINDERY_LOGIN ||
                   pConnStatus->dwConnType == NW_CONN_NDS_AUTHENTICATED_NO_LICENSE ||
                   pConnStatus->dwConnType == NW_CONN_NDS_AUTHENTICATED_LICENSED ||
                   pConnStatus->dwConnType == NW_CONN_DISCONNECTED ) )
            {
                fAddToList = TRUE;
                tokenPtr = (LPWSTR) ContextHandle->NdsRawDataBuffer;
                tokenIter = 0;

                //
                // Walk through buffer to see if the tree name already exists.
                //
                while ( tokenIter < ContextHandle->NdsRawDataCount )
                {
                    if ( !wcscmp( tokenPtr, pConnStatus->pszServerName ) )
                    {
                        fAddToList = FALSE;
                    }

                    tokenPtr = tokenPtr + wcslen( tokenPtr ) + 1;
                    tokenIter++;
                }
            }

            //
            //  Add the new tree name to end of buffer if needed.
            //
            if ( fAddToList )
            {
                wcscpy( tokenPtr, pConnStatus->pszServerName );
                _wcsupr( tokenPtr );
                ContextHandle->NdsRawDataCount += 1;
            }

            pConnStatus = (PCONN_STATUS) ( pConnStatus +
                                           pConnStatus->dwTotalLength );
        }

        if ( pBuffer != NULL )
        {
            LocalFree( pBuffer );
            pBuffer = NULL;
        }

        if ( ContextHandle->NdsRawDataCount > 0 )
        {
            //
            // Set ResumeId to point to the first entry in buffer
            // and have NdsRawDataCount set to the number
            // of tree entries left in buffer (ie. substract 1)
            //
            ContextHandle->ResumeId = ContextHandle->NdsRawDataBuffer;
            ContextHandle->NdsRawDataCount -= 1;
        }

        return NO_ERROR;
    }

    return WN_NO_MORE_ENTRIES;
}


DWORD
NwGetNextServerConnection(
    OUT LPNW_ENUM_CONTEXT ContextHandle
    )
/*++

Routine Description:

    This function queries the redirector for bindery server connections

Arguments:

    ContextHandle - Receives the name of the returned bindery server.

Return Value:

    NO_ERROR - Successfully returned a server name.

    WN_NO_MORE_ENTRIES - No other server objects past the one
        specified by CH->ResumeId exist.

--*/
{
#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("NWWORKSTATION: NwGetNextServerConnection ResumeId %lu\n",
                 ContextHandle->ResumeId));
    }
#endif

    if ( ContextHandle->ResumeId == (DWORD_PTR) -1 &&
         ContextHandle->NdsRawDataBuffer == 0 &&
         ContextHandle->NdsRawDataCount == 0 )
    {
        //
        // Fill the buffer and point ResumeId to the last
        // server entry name in it. NdsRawDataCount will be
        // set to one less than the number of server names in buffer.
        //
        return GetConnectedBinderyServers( ContextHandle );
    }

    if ( ContextHandle->NdsRawDataBuffer != 0 &&
         ContextHandle->NdsRawDataCount > 0 )
    {
        //
        // Move ResumeId to point to the next entry in the buffer
        // and decrement the NdsRawDataCount by one. Watch for case
        // where we backed up to -1.
        //
        if (ContextHandle->ResumeId == (DWORD_PTR) -1) {

            //
            // Reset to start of buffer.
            //
            ContextHandle->ResumeId = ContextHandle->NdsRawDataBuffer;
        }
        else {

            //
            // Treat as pointer and advance as need.
            //
            ContextHandle->ResumeId =
                       ContextHandle->ResumeId +
                       ( ( wcslen( (LPWSTR) ContextHandle->ResumeId ) + 1 ) *
                       sizeof(WCHAR) );
        }
        ContextHandle->NdsRawDataCount -= 1;

        return NO_ERROR;
    }

    if ( ContextHandle->NdsRawDataBuffer != 0 &&
         ContextHandle->NdsRawDataCount == 0 )
    {
        //
        // We already have a buffer and processed all server names
        // in it, and there is no more data to get.
        // So free the memory used for the buffer and return
        // WN_NO_MORE_ENTRIES to tell WinFile that we are done.
        //
        (void) LocalFree( (HLOCAL) ContextHandle->NdsRawDataBuffer );

        ContextHandle->NdsRawDataBuffer = 0;
        ContextHandle->NdsRawDataSize = 0;

        return WN_NO_MORE_ENTRIES;
    }

    //
    // Were done
    //
    return WN_NO_MORE_ENTRIES;
}


DWORD
GetTreeEntriesFromBindery(
    OUT LPNW_ENUM_CONTEXT ContextHandle
    )
/*++

Routine Description:

    This function is a helper routine for the function NwGetNextNdsTreeEntry.
    It allocates a buffer (if needed) to cache NDS tree names returned from
    calls to the bindery. Since the bindery often returns duplicates of a
    NDS tree name, this function checks to see if the tree name already
    exist in the buffer before adding it to it if not present.

Arguments:

    ContextHandle - Used to track cached bindery information and the
                    current tree name pointer in the cache buffer.

Return Value:

    NO_ERROR - Successfully returned a NDS tree name and cache buffer.

    WN_NO_MORE_ENTRIES - No other NDS tree object past the one
        specified by CH->ResumeId.

    ERROR_NOT_ENOUGH_MEMORY - Function was unable to allocate a buffer.

++*/
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    SERVERNAME TreeName;
    LPWSTR UTreeName = NULL; //Unicode tree name
    DWORD tempDataId;
    WORD ObjectType;
    BYTE iter;
    BYTE tokenIter;
    LPWSTR tokenPtr;
    BOOL fAddToList;

    //
    // Check to see if we need to allocate a buffer for use
    //
    if ( ContextHandle->NdsRawDataBuffer == 0x00000000 )
    {
        ContextHandle->NdsRawDataId = (DWORD) ContextHandle->ResumeId;
        ContextHandle->NdsRawDataSize = EIGHT_KB;
        ContextHandle->NdsRawDataBuffer =
                    (DWORD_PTR) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                ContextHandle->NdsRawDataSize );

        if ( ContextHandle->NdsRawDataBuffer == 0 )
        {
            KdPrint(("NWWORKSTATION: GetTreeEntriesFromBindery LocalAlloc failed %lu\n",
                     GetLastError()));

            ContextHandle->NdsRawDataSize = 0;
            ContextHandle->NdsRawDataId = (DWORD) -1;

            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // Repeatedly call bindery to fill buffer with NDS tree names until
    // buffer is full.
    //
    while ( ntstatus == STATUS_SUCCESS )
    {
        RtlZeroMemory( TreeName, sizeof( TreeName ) );

        tempDataId = ContextHandle->NdsRawDataId;

        ntstatus = NwlibMakeNcp(
                   ContextHandle->TreeConnectionHandle,
                   FSCTL_NWR_NCP_E3H,            // Bindery function
                   58,                           // Max request packet size
                   59,                           // Max response packet size
                   "bdwp|dwc",                   // Format string
                   0x37,                         // Scan bindery object
                   ContextHandle->NdsRawDataId,  // Previous ID
                   0x278,                        // Directory server object
                   "*",                          // Wildcard to match all
                   &ContextHandle->NdsRawDataId, // Current ID
                   &ObjectType,                  // Ignore
                   TreeName                      // Currently returned NDS tree
                   );

        //
        // We got a tree name, clean it up (i.e. get rid of underscores ),
        // and add it to buffer if unique.
        //
        if ( ntstatus == STATUS_SUCCESS )
        {
            iter = 31;

            while ( TreeName[iter] == '_' && iter > 0 )
            {
                iter--;
            }

            TreeName[iter + 1] = '\0';

            //
            // Convert tree name to a UNICODE string and proccess it,
            // else just skip it and move on to the next tree name.
            //
            if ( NwConvertToUnicode( &UTreeName, TreeName ) )
            {
               tokenPtr = (LPWSTR) ContextHandle->NdsRawDataBuffer;
               tokenIter = 0;
               fAddToList = TRUE;

               //
               // Walk through buffer to see if the tree name already exists.
               //
               while ( tokenIter < ContextHandle->NdsRawDataCount )
               {
                   if ( !wcscmp( tokenPtr, UTreeName ) )
                   {
                       fAddToList = FALSE;
                   }

                   tokenPtr = tokenPtr + wcslen( tokenPtr ) + 1;
                   tokenIter++;
               }

               //
               //  Add the new tree name to end of buffer if needed.
               //
               if ( fAddToList )
               {
                   DWORD BytesNeededToAddTreeName = (wcslen(UTreeName)+1) * sizeof(WCHAR);
                   DWORD NumberOfBytesAvailable =(DWORD) ( ContextHandle->NdsRawDataBuffer +
                                            ContextHandle->NdsRawDataSize -
                                            (DWORD_PTR) tokenPtr );

                   if ( BytesNeededToAddTreeName < NumberOfBytesAvailable )
                   {
                       wcscpy( tokenPtr, UTreeName );
                       ContextHandle->NdsRawDataCount += 1;
                   }
                   else
                   {
                       ContextHandle->NdsRawDataId = tempDataId;
                       ntstatus = ERROR_NOT_ENOUGH_MEMORY;
                   }
               }

               (void) LocalFree((HLOCAL) UTreeName);
            }
        }
    }

    //
    // We are done filling buffer, and there are no more tree names
    // to request. Set id to indicate last value.
    //
    if ( ntstatus == STATUS_NO_MORE_ENTRIES )
    {
        ContextHandle->NdsRawDataId = (DWORD) -1;
        ntstatus = STATUS_SUCCESS;
    }

    //
    // We are done because the buffer is full. So we return NO_ERROR to
    // indicate completion, and leave ContextHandle->NdsRawDataId as is
    // to indicate where we left off.
    //
    if ( ntstatus == ERROR_NOT_ENOUGH_MEMORY )
    {
        ntstatus = STATUS_SUCCESS;
    }

    if ( ContextHandle->NdsRawDataCount == 0 )
    {
        if ( ContextHandle->NdsRawDataBuffer )
            (void) LocalFree( (HLOCAL) ContextHandle->NdsRawDataBuffer );

        ContextHandle->NdsRawDataBuffer = 0;
        ContextHandle->NdsRawDataSize = 0;
        ContextHandle->NdsRawDataId = (DWORD) -1;

        return WN_NO_MORE_ENTRIES;
    }

    if ( ContextHandle->NdsRawDataCount > 0 )
    {
        //
        // Set ResumeId to point to the first entry in buffer
        // and have NdsRawDataCount set to the number
        // of tree entries left in buffer (ie. substract 1)
        //
        ContextHandle->ResumeId = ContextHandle->NdsRawDataBuffer;
        ContextHandle->NdsRawDataCount -= 1;

        return NO_ERROR;
    }

    if ( ContextHandle->NdsRawDataBuffer )
        (void) LocalFree( (HLOCAL) ContextHandle->NdsRawDataBuffer );

    ContextHandle->NdsRawDataBuffer = 0;
    ContextHandle->NdsRawDataSize = 0;
    ContextHandle->NdsRawDataId = (DWORD) -1;

    return NwMapStatus( ntstatus );
}


DWORD
NwGetNextNdsTreeEntry(
    OUT LPNW_ENUM_CONTEXT ContextHandle
    )
/*++

Routine Description:

    This function uses an opened handle to the preferred server to
    scan it bindery for all NDS tree objects.

Arguments:

    ContextHandle - Receives the name of the returned NDS tree object
    given the current preferred server connection and CH->ResumeId.

Return Value:

    NO_ERROR - Successfully returned a NDS tree name.

    WN_NO_MORE_ENTRIES - No other NDS tree objects past the one
        specified by CH->ResumeId exist.

--*/
{
#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("NWWORKSTATION: NwGetNextNdsTreeEntry ResumeId %lu\n",
                 ContextHandle->ResumeId));
    }
#endif

    if ( ContextHandle->ResumeId == (DWORD_PTR) -1 &&
         ContextHandle->NdsRawDataBuffer == 0 &&
         ContextHandle->NdsRawDataCount == 0 )
    {
        //
        // Fill the buffer and point ResumeId to the last
        // tree entry name in it. NdsRawDataCount will be
        // set to one less than the number of tree names in buffer.
        //
        return GetTreeEntriesFromBindery( ContextHandle );
    }

    if ( ContextHandle->NdsRawDataBuffer != 0 &&
         ContextHandle->NdsRawDataCount > 0 )
    {
        //
        // Move ResumeId to point to the next entry in the buffer
        // and decrement the NdsRawDataCount by one. Watch for case
        // where we backed up to -1.
        //
        if (ContextHandle->ResumeId == (DWORD_PTR) -1) {

            //
            // Reset to start of buffer.
            //
            ContextHandle->ResumeId = ContextHandle->NdsRawDataBuffer;
        }
        else {

            //
            // Move ResumeId to point to the next entry in the buffer
            // and decrement the NdsRawDataCount by one
            //
            ContextHandle->ResumeId =
                       ContextHandle->ResumeId +
                       ( ( wcslen( (LPWSTR) ContextHandle->ResumeId ) + 1 ) *
                       sizeof(WCHAR) );
        }

        ContextHandle->NdsRawDataCount -= 1;

        return NO_ERROR;
    }

    if ( ContextHandle->NdsRawDataBuffer != 0 &&
         ContextHandle->NdsRawDataCount == 0 &&
         ContextHandle->NdsRawDataId != (DWORD) -1 )
    {
        //
        // We already have a buffer and processed all tree names
        // in it, and there is more data in the bindery to get.
        // So go get it and point ResumeId to the last tree
        // entry name in the buffer and set NdsRawDataCount to
        // one less than the number of tree names in buffer.
        //
        return GetTreeEntriesFromBindery( ContextHandle );
    }

    if ( ContextHandle->NdsRawDataBuffer != 0 &&
         ContextHandle->NdsRawDataCount == 0 &&
         ContextHandle->NdsRawDataId == (DWORD) -1 )
    {
        //
        // We already have a buffer and processed all tree names
        // in it, and there is no more data in the bindery to get.
        // So free the memory used for the buffer and return
        // WN_NO_MORE_ENTRIES to tell WinFile that we are done.
        //
        (void) LocalFree( (HLOCAL) ContextHandle->NdsRawDataBuffer );

        ContextHandle->NdsRawDataBuffer = 0;
        ContextHandle->NdsRawDataSize = 0;

        return WN_NO_MORE_ENTRIES;
    }

    //
    // We should never hit this area!
    //
    return WN_NO_MORE_ENTRIES;
}


DWORD
NwGetNextVolumeEntry(
    IN HANDLE ServerConnection,
    IN DWORD NextVolumeNumber,
    OUT LPSTR VolumeName
    )
/*++

Routine Description:

    This function lists the volumes on the server specified by
    an opened tree connection handle to the server.

Arguments:

    ServerConnection - Supplies the tree connection handle to the
        server to enumerate volumes from.

    NextVolumeNumber - Supplies the volume number which to look
        up the name.

    VolumeName - Receives the name of the volume associated with
        NextVolumeNumber.

Return Value:

    NO_ERROR - Successfully gotten the volume name.

    WN_NO_MORE_ENTRIES - No other volume name associated with the
         specified volume number.

--*/
{
    NTSTATUS ntstatus;

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("NWWORKSTATION: NwGetNextVolumeEntry volume number %lu\n",
                 NextVolumeNumber));
    }
#endif

    ntstatus = NwlibMakeNcp(
                   ServerConnection,
                   FSCTL_NWR_NCP_E2H,       // Directory function
                   4,                       // Max request packet size
                   19,                      // Max response packet size
                   "bb|p",                  // Format string
                   0x6,                     // Get volume name
                   (BYTE) NextVolumeNumber, // Previous ID
                   VolumeName               // Currently returned server
                   );

    return NwMapStatus(ntstatus);
}


DWORD
NwRdrLogonUser(
    IN PLUID LogonId,
    IN LPWSTR UserName,
    IN DWORD UserNameSize,
    IN LPWSTR Password OPTIONAL,
    IN DWORD PasswordSize,
    IN LPWSTR PreferredServer OPTIONAL,
    IN DWORD PreferredServerSize,
    IN LPWSTR NdsPreferredServer OPTIONAL,
    IN DWORD NdsPreferredServerSize,
    IN DWORD PrintOption
    )
/*++

Routine Description:

    This function tells the redirector the user logon credential.

Arguments:

    UserName - Supplies the user name.

    UserNameSize - Supplies the size in bytes of the user name string without
        the NULL terminator.

    Password - Supplies the password.

    PasswordSize - Supplies the size in bytes of the password string without
        the NULL terminator.

    PreferredServer - Supplies the preferred server name.

    PreferredServerSize - Supplies the size in bytes of the preferred server
        string without the NULL terminator.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;

    PNWR_REQUEST_PACKET Rrp;            // Redirector request packet

    DWORD RrpSize = sizeof(NWR_REQUEST_PACKET) +
                        UserNameSize +
                        PasswordSize +
                        PreferredServerSize;
    LPBYTE Dest;
    BYTE   lpReplicaAddress[sizeof(TDI_ADDRESS_IPX)];
    DWORD  ReplicaAddressSize = 0;


#if DBG
    IF_DEBUG(LOGON) {
        BYTE PW[128];


        RtlZeroMemory(PW, sizeof(PW));

        if (PasswordSize > (sizeof(PW) - 1)) {
            memcpy(PW, Password, sizeof(PW) - 1);
        }
        else {
            memcpy(PW, Password, PasswordSize);
        }

        KdPrint(("NWWORKSTATION: NwRdrLogonUser: UserName %ws\n", UserName));
        KdPrint(("                               Password %ws\n", PW));
        if ( PreferredServer )
            KdPrint(("                               Server   %ws\n", PreferredServer ));
    }
#endif

    if ( PreferredServer &&
         PreferredServer[0] == TREECHAR &&
         PreferredServer[1] )
    {
        WCHAR  TreeName[MAX_NDS_NAME_CHARS + 1];
        LPWSTR lpTemp;

        //
        // Find the nearest dir server for the tree that the user wants to
        // connect to.
        //
        // Citrix Terminal Server Merge
        // 12/09/96 cjc  PreferredServer also includes organizational units -
        //               not just the tree name so the size of it can be
        //               > MAX_NDS_TREE_NAME_LEN and when it is, the wcscpy
        //               below overwrites other stack data and causes errors
        //               during NW logins.

        if ( PreferredServerSize > (MAX_NDS_TREE_NAME_LEN*sizeof(WCHAR)) ) {
             memcpy(TreeName, PreferredServer+1, 
                    (MAX_NDS_TREE_NAME_LEN*sizeof(WCHAR)) );
             TreeName[MAX_NDS_TREE_NAME_LEN] = L'\0';
        }
        else {
            wcscpy( TreeName, PreferredServer + 1 );
        }

        lpTemp = wcschr( TreeName, L'\\' );
        if (lpTemp) {
            lpTemp[0] = L'\0';
        }

        if (NdsPreferredServer != NULL) {

            KdPrint(("NWWORKSTATION: NdsPreferredServer: %ws\n", PreferredServer));

            GetPreferredServerAddress( NdsPreferredServer/*L"red_41b"*/,
                                       &ReplicaAddressSize,
                                       lpReplicaAddress );
        } else {
            GetNearestDirServer( TreeName,
                                 &ReplicaAddressSize,
                                 lpReplicaAddress );
        }

        RrpSize += ReplicaAddressSize;
    }


    if ( PreferredServer &&
         PreferredServer[0] == TREECHAR &&
         !PreferredServer[1] )
    {
        PreferredServerSize = 0;
    }

    //
    // Allocate the request packet
    //
    if ((Rrp = (PVOID) LocalAlloc(
                           LMEM_ZEROINIT,
                           RrpSize
                           )) == NULL) {

        KdPrint(("NWWORKSTATION: NwRdrLogonUser LocalAlloc failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Tell the redirector the user logon credential.
    //
    Rrp->Version = REQUEST_PACKET_VERSION;

    RtlCopyLuid(&(Rrp->Parameters.Logon.LogonId), LogonId);

#if DBG
    IF_DEBUG(LOGON) {
        KdPrint(("NWWORKSTATION: NwRdrLogonUser passing to Rdr logon ID %lu %lu\n",
                 *LogonId, *((PULONG) ((DWORD_PTR) LogonId + sizeof(ULONG)))));
    }
#endif

    Rrp->Parameters.Logon.UserNameLength = UserNameSize;
    Rrp->Parameters.Logon.PasswordLength = PasswordSize;
    Rrp->Parameters.Logon.ServerNameLength = PreferredServerSize;
    Rrp->Parameters.Logon.ReplicaAddrLength = ReplicaAddressSize;
    Rrp->Parameters.Logon.PrintOption = PrintOption;

    memcpy(Rrp->Parameters.Logon.UserName, UserName, UserNameSize);
    Dest = (LPBYTE) ((DWORD_PTR) Rrp->Parameters.Logon.UserName + UserNameSize);

    if (PasswordSize > 0)
    {
        memcpy(Dest, Password, PasswordSize);
        Dest = (LPBYTE) ((DWORD_PTR) Dest + PasswordSize);
    }

    if (PreferredServerSize > 0)
    {
        memcpy(Dest, PreferredServer, PreferredServerSize);

        if (ReplicaAddressSize > 0)
        {
            Dest = (LPBYTE) ((DWORD_PTR) Dest + PreferredServerSize);
            memcpy(Dest, lpReplicaAddress, ReplicaAddressSize);
        }
    }

    status = NwRedirFsControl(
                 RedirDeviceHandle,
                 FSCTL_NWR_LOGON,
                 Rrp,
                 RrpSize,
                 NULL,              // No logon script in this release
                 0,
                 NULL
                 );

    RtlZeroMemory(Rrp, RrpSize);   // Clear the password
    (void) LocalFree((HLOCAL) Rrp);

    return status;
}


VOID
NwRdrChangePassword(
    IN PNWR_REQUEST_PACKET Rrp
    )
/*++

Routine Description:

    This function tells the redirector the new password for a user on
    a particular server.

Arguments:

    Rrp - Supplies the username, new password and servername.

    RrpSize - Supplies the size of the request packet.

Return Value:

    None.

--*/
{

    //
    // Tell the redirector the user new password.
    //
    Rrp->Version = REQUEST_PACKET_VERSION;

    (void) NwRedirFsControl(
               RedirDeviceHandle,
               FSCTL_NWR_CHANGE_PASS,
               Rrp,
               sizeof(NWR_REQUEST_PACKET) +
                   Rrp->Parameters.ChangePass.UserNameLength +
                   Rrp->Parameters.ChangePass.PasswordLength +
                   Rrp->Parameters.ChangePass.ServerNameLength,
               NULL,
               0,
               NULL
               );

}


DWORD
NwRdrSetInfo(
    IN DWORD PrintOption,
    IN DWORD PacketBurstSize,
    IN LPWSTR PreferredServer OPTIONAL,
    IN DWORD PreferredServerSize,
    IN LPWSTR ProviderName OPTIONAL,
    IN DWORD ProviderNameSize
    )
/*++

Routine Description:

    This function passes some workstation configuration and current user's
    preference to the redirector. This includes the network provider name, the
    packet burst size, the user's selected preferred server and print option.

Arguments:

    PrintOption  - The current user's print option

    PacketBurstSize - The packet burst size stored in the registry

    PreferredServer - The preferred server the current user selected
    PreferredServerSize - Supplies the size in bytes of the preferred server
                   string without the NULL terminator.

    ProviderName - Supplies the provider name.
    ProviderNameSize - Supplies the size in bytes of the provider name
                   string without the NULL terminator.


Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;

    PNWR_REQUEST_PACKET Rrp;            // Redirector request packet

    DWORD RrpSize = sizeof(NWR_REQUEST_PACKET) +
                        PreferredServerSize +
                        ProviderNameSize;

    LPBYTE Dest;
    BOOL Impersonate = FALSE;

    //
    // Allocate the request packet
    //
    if ((Rrp = (PVOID) LocalAlloc(
                           LMEM_ZEROINIT,
                           RrpSize
                           )) == NULL) {

        KdPrint(("NWWORKSTATION: NwRdrSetInfo LocalAlloc failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Rrp->Version = REQUEST_PACKET_VERSION;

    Rrp->Parameters.SetInfo.PrintOption = PrintOption;
    Rrp->Parameters.SetInfo.MaximumBurstSize = PacketBurstSize;

    Rrp->Parameters.SetInfo.PreferredServerLength = PreferredServerSize;
    Rrp->Parameters.SetInfo.ProviderNameLength  = ProviderNameSize;

    if (ProviderNameSize > 0) {
        memcpy( Rrp->Parameters.SetInfo.PreferredServer,
                PreferredServer, PreferredServerSize);
    }

    Dest = (LPBYTE) ((DWORD_PTR) Rrp->Parameters.SetInfo.PreferredServer
                     + PreferredServerSize);

    if (ProviderNameSize > 0) {
        memcpy(Dest, ProviderName, ProviderNameSize);
    }

    /* --- Multi-user change
     *   For print options
     *   It's OK if it doesn't work
     */
    if ((status = NwImpersonateClient()) == NO_ERROR)
    {
        Impersonate = TRUE;
    }

    status = NwRedirFsControl(
                 RedirDeviceHandle,
                 FSCTL_NWR_SET_INFO,
                 Rrp,
                 RrpSize,
                 NULL,
                 0,
                 NULL
                 );

    if ( Impersonate ) {
        (void) NwRevertToSelf() ;
    }

    (void) LocalFree((HLOCAL) Rrp);


    if ( status != NO_ERROR )
    {
        KdPrint(("NwRedirFsControl: FSCTL_NWR_SET_INFO failed with %d\n",
                status ));
    }

    return status;
}


DWORD
NwRdrLogoffUser(
    IN PLUID LogonId
    )
/*++

Routine Description:

    This function asks the redirector to log off the interactive user.

Arguments:

    None.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;
    NWR_REQUEST_PACKET Rrp;            // Redirector request packet


    //
    // Tell the redirector to logoff user.
    //
    Rrp.Version = REQUEST_PACKET_VERSION;

    RtlCopyLuid(&Rrp.Parameters.Logoff.LogonId, LogonId);

    status = NwRedirFsControl(
                 RedirDeviceHandle,
                 FSCTL_NWR_LOGOFF,
                 &Rrp,
                 sizeof(NWR_REQUEST_PACKET),
                 NULL,
                 0,
                 NULL
                 );

    return status;
}


DWORD
NwConnectToServer(
    IN LPWSTR ServerName
    )
/*++

Routine Description:

    This function opens a handle to \Device\Nwrdr\ServerName, given
    ServerName, and then closes the handle if the open was successful.
    It is to validate that the current user credential can access
    the server.

Arguments:

    ServerName - Supplies the name of the server to validate the
        user credential.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;
    UNICODE_STRING ServerStr;
    HANDLE ServerHandle;



    ServerStr.MaximumLength = (wcslen(ServerName) + 2) *
                                  sizeof(WCHAR) +          // \ServerName0
                                  RedirDeviceName.Length;  // \Device\Nwrdr

    if ((ServerStr.Buffer = (PWSTR) LocalAlloc(
                                        LMEM_ZEROINIT,
                                        (UINT) ServerStr.MaximumLength
                                        )) == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy \Device\NwRdr
    //
    RtlCopyUnicodeString(&ServerStr, &RedirDeviceName);

    //
    // Concatenate \ServerName
    //
    wcscat(ServerStr.Buffer, L"\\");
    ServerStr.Length += sizeof(WCHAR);

    wcscat(ServerStr.Buffer, ServerName);
    ServerStr.Length += (USHORT) (wcslen(ServerName) * sizeof(WCHAR));


    status = NwOpenCreateConnection(
                 &ServerStr,
                 NULL,
                 NULL,
                 ServerName,
                 SYNCHRONIZE | FILE_WRITE_DATA,
                 FILE_OPEN,
                 FILE_SYNCHRONOUS_IO_NONALERT,
                 RESOURCETYPE_DISK,
                 &ServerHandle,
                 NULL
                 );

    if (status == ERROR_FILE_NOT_FOUND) {
        status = ERROR_BAD_NETPATH;
    }

    (void) LocalFree((HLOCAL) ServerStr.Buffer);

    if (status == NO_ERROR || status == NW_PASSWORD_HAS_EXPIRED) {
        (void) NtClose(ServerHandle);
    }

    return status;
}

DWORD
NWPGetConnectionStatus(
    IN     LPWSTR  pszRemoteName,
    IN OUT PDWORD_PTR  ResumeKey,
    OUT    LPBYTE  Buffer,
    IN     DWORD   BufferSize,
    OUT    PDWORD  BytesNeeded,
    OUT    PDWORD  EntriesRead
)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    HANDLE            handleRdr = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;
    UNICODE_STRING    uRdrName;
    WCHAR             RdrPrefix[] = L"\\Device\\NwRdr\\*";

    PNWR_REQUEST_PACKET RequestPacket = NULL;
    DWORD             RequestPacketSize = 0;
    DWORD             dwRemoteNameLen = 0;

    //
    // Set up the object attributes.
    //

    RtlInitUnicodeString( &uRdrName, RdrPrefix );

    InitializeObjectAttributes( &ObjectAttributes,
                                &uRdrName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntstatus = NtOpenFile( &handleRdr,
                           SYNCHRONIZE | FILE_LIST_DIRECTORY,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_VALID_FLAGS,
                           FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
        goto CleanExit;

    dwRemoteNameLen = pszRemoteName? wcslen(pszRemoteName)*sizeof(WCHAR) : 0;

    RequestPacketSize = sizeof( NWR_REQUEST_PACKET ) + dwRemoteNameLen;

    RequestPacket = (PNWR_REQUEST_PACKET) LocalAlloc( LMEM_ZEROINIT,
                                                      RequestPacketSize );

    if ( RequestPacket == NULL )
    {
        ntstatus = STATUS_NO_MEMORY;
        goto CleanExit;
    }

    //
    // Fill out the request packet for FSCTL_NWR_GET_CONN_STATUS.
    //

    RequestPacket->Parameters.GetConnStatus.ResumeKey = *ResumeKey;

    RequestPacket->Version = REQUEST_PACKET_VERSION;
    RequestPacket->Parameters.GetConnStatus.ConnectionNameLength = dwRemoteNameLen;

    RtlCopyMemory( &(RequestPacket->Parameters.GetConnStatus.ConnectionName[0]),
                   pszRemoteName,
                   dwRemoteNameLen );

    ntstatus = NtFsControlFile( handleRdr,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_NWR_GET_CONN_STATUS,
                                (PVOID) RequestPacket,
                                RequestPacketSize,
                                (PVOID) Buffer,
                                BufferSize );

    if ( NT_SUCCESS( ntstatus ))
        ntstatus = IoStatusBlock.Status;

    *EntriesRead = RequestPacket->Parameters.GetConnStatus.EntriesReturned;
    *ResumeKey   = RequestPacket->Parameters.GetConnStatus.ResumeKey;
    *BytesNeeded = RequestPacket->Parameters.GetConnStatus.BytesNeeded;

CleanExit:

    if ( handleRdr != NULL )
        NtClose( handleRdr );

    if ( RequestPacket != NULL )
        LocalFree( RequestPacket );

    return RtlNtStatusToDosError( ntstatus );
}

DWORD
NwGetConnectionStatus(
    IN  LPWSTR  pszRemoteName,
    OUT PDWORD_PTR  ResumeKey,
    OUT LPBYTE  *Buffer,
    OUT PDWORD  EntriesRead
)
{
    DWORD err = NO_ERROR;
    DWORD dwBytesNeeded = 0;
    DWORD dwBufferSize  = TWO_KB;

    *Buffer = NULL;
    *EntriesRead = 0;

    do {

        *Buffer = (LPBYTE) LocalAlloc( LMEM_ZEROINIT, dwBufferSize );

        if ( *Buffer == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;

        err = NWPGetConnectionStatus( pszRemoteName,
                                      ResumeKey,
                                      *Buffer,
                                      dwBufferSize,
                                      &dwBytesNeeded,
                                      EntriesRead );

        if ( err == ERROR_INSUFFICIENT_BUFFER )
        {
            dwBufferSize = dwBytesNeeded + EXTRA_BYTES;
            LocalFree( *Buffer );
            *Buffer = NULL;
        }

    } while ( err == ERROR_INSUFFICIENT_BUFFER );

    if ( err == ERROR_INVALID_PARAMETER )  // not attached
    {
        err = NO_ERROR;
        *EntriesRead = 0;
    }

    return err;
}

VOID
GetNearestDirServer(
    IN  LPWSTR  TreeName,
    OUT LPDWORD lpdwReplicaAddressSize,
    OUT LPBYTE  lpReplicaAddress
    )
{
    WCHAR Buffer[BUFFSIZE];
    PWSAQUERYSETW Query = (PWSAQUERYSETW)Buffer;
    HANDLE hRnr;
    DWORD dwQuerySize = BUFFSIZE;
    GUID gdService = SVCID_NETWARE(0x278);
    WSADATA wsaData;
    WCHAR  ServiceInstanceName[] = L"*";

    WSAStartup(MAKEWORD(1, 1), &wsaData);

    memset(Query, 0, sizeof(*Query));

    //
    // putting a "*" in the lpszServiceInstanceName causes
    // the query to look for all server instances. Putting a
    // specific name in here will search only for instance of
    // that name. If you have a specific name to look for,
    // put a pointer to the name here.
    //
    Query->lpszServiceInstanceName = ServiceInstanceName;
    Query->dwNameSpace = NS_SAP;
    Query->dwSize = sizeof(*Query);
    Query->lpServiceClassId = &gdService;

    //
    // Find the servers. The flags indicate:
    // LUP_NEAREST: look for nearest servers
    // LUP_DEEP : if none are found on the local segement look
    //            for server using a general query
    // LUP_RETURN_NAME: return the name
    // LUP_RETURN_ADDR: return the server address
    //
    // if only servers on the local segment are acceptable, omit
    // setting LUP_DEEP
    //
    if( WSALookupServiceBegin( Query,
                               LUP_NEAREST |
                               LUP_DEEP |
                               LUP_RETURN_NAME |
                               LUP_RETURN_ADDR,
                               &hRnr ) == SOCKET_ERROR )
    {
        //
        // Something went wrong, return no address. The redirector will
        // have to come up with a dir server on its own.
        //
        *lpdwReplicaAddressSize = 0;
        return ;
    }
    else
    {
        //
        // Ready to look for one of them ...
        //
        Query->dwSize = BUFFSIZE;

        while( WSALookupServiceNext( hRnr,
                                     0,
                                     &dwQuerySize,
                                     Query ) == NO_ERROR )
        {
            //
            // Found a dir server, now see if it is a server for the NDS tree
            // TreeName.
            //
            if ( NwpCompareTreeNames( Query->lpszServiceInstanceName,
                                      TreeName ) )
            {
                *lpdwReplicaAddressSize = sizeof(TDI_ADDRESS_IPX);
                memcpy( lpReplicaAddress,
                        Query->lpcsaBuffer->RemoteAddr.lpSockaddr->sa_data,
                        sizeof(TDI_ADDRESS_IPX) );

                WSALookupServiceEnd(hRnr);
                return ;
            }
        }

        //
        // Could not find a dir server, return no address. The redirector will
        // have to come up with a dir server on its own.
        //
        *lpdwReplicaAddressSize = 0;
        WSALookupServiceEnd(hRnr);
    }
}

BOOL
NwpCompareTreeNames(
    LPWSTR lpServiceInstanceName,
    LPWSTR lpTreeName
    )
{
    DWORD  iter = 31;

    while ( lpServiceInstanceName[iter] == '_' && iter > 0 )
    {
        iter--;
    }

    lpServiceInstanceName[iter + 1] = '\0';

    if ( !_wcsicmp( lpServiceInstanceName, lpTreeName ) )
    {
        return TRUE;
    }

    return FALSE;
}


#define SIZE_OF_STATISTICS_TOKEN_INFORMATION    \
     sizeof( TOKEN_STATISTICS ) 

VOID
GetLuid(
    IN OUT PLUID plogonid
)
/*++

Routine Description:

    Returns an LUID

Arguments:

    none

Return Value:

    LUID

--*/
{
    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ SIZE_OF_STATISTICS_TOKEN_INFORMATION ];
    ULONG       ReturnLength;
    LUID        NullId = { 0, 0 };


    // We can use OpenThreadToken because this server thread
    // is impersonating a client

    if ( !OpenThreadToken( GetCurrentThread(),
                           TOKEN_READ,
                           TRUE,  /* Open as self */
                           &TokenHandle ))
    {
#if DBG
        KdPrint(("GetLuid: OpenThreadToken failed: Error %d\n",
                      GetLastError()));
#endif
        *plogonid = NullId;
        return;
    }

    // notice that we've allocated enough space for the
    // TokenInformation structure. so if we fail, we
    // return a NULL pointer indicating failure


    if ( !GetTokenInformation( TokenHandle,
                               TokenStatistics,
                               TokenInformation,
                               sizeof( TokenInformation ),
                               &ReturnLength ))
    {
#if DBG
        KdPrint(("GetLuid: GetTokenInformation failed: Error %d\n",
                      GetLastError()));
#endif
        *plogonid = NullId;
        return;
    }

    CloseHandle( TokenHandle );

    *plogonid = ( ((PTOKEN_STATISTICS)TokenInformation)->AuthenticationId );
    return;
}

DWORD
NwCloseAllConnections(
    VOID
    )
/*++

Routine Description:

    This routine closes all connections.  It is used when stopping the
    redirector.

Arguments:

    None.

Return Value:

    NO_ERROR or error

--*/
{
    NWR_REQUEST_PACKET Rrp;
    DWORD error;


    Rrp.Version = REQUEST_PACKET_VERSION;

    error = NwRedirFsControl(
                RedirDeviceHandle,
                FSCTL_NWR_CLOSEALL,
                &Rrp,
                sizeof(NWR_REQUEST_PACKET),
                NULL,
                0,
                NULL
                );

    return error;
}



VOID
GetPreferredServerAddress(
    IN  LPWSTR  PreferredServerName,
    OUT LPDWORD lpdwReplicaAddressSize,
    OUT LPBYTE  lpReplicaAddress
    )
{
    WCHAR Buffer[1024];
    PWSAQUERYSETW Query = (PWSAQUERYSETW)Buffer;
    HANDLE hRnr;
    DWORD dwQuerySize = 1024;
    GUID gdService = SVCID_NETWARE( 0x4 );
    WSADATA wsaData;
    PWCHAR  ServiceInstanceName = PreferredServerName;

    WSAStartup(MAKEWORD(1, 1), &wsaData);

    memset(Query, 0, sizeof(*Query));

    //
    // putting a "*" in the lpszServiceInstanceName causes
    // the query to look for all server instances. Putting a
    // specific name in here will search only for instance of
    // that name. If you have a specific name to look for,
    // put a pointer to the name here.
    //
    Query->lpszServiceInstanceName = ServiceInstanceName;
    Query->dwNameSpace = NS_SAP;
    Query->dwSize = sizeof(*Query);
    Query->lpServiceClassId = &gdService;

    //
    // Find the servers. The flags indicate:
    // LUP_NEAREST: look for nearest servers
    // LUP_DEEP : if none are found on the local segement look
    //            for server using a general query
    // LUP_RETURN_NAME: return the name
    // LUP_RETURN_ADDR: return the server address
    //
    // if only servers on the local segment are acceptable, omit
    // setting LUP_DEEP
    //
    if( WSALookupServiceBeginW( Query,
                            // LUP_NEAREST |
                               LUP_DEEP |
                               LUP_RETURN_NAME |
                               LUP_RETURN_ADDR,
                               &hRnr ) == SOCKET_ERROR )
    {
        //
        // Something went wrong, return no address. The redirector will
        // have to come up with a dir server on its own.
        //
        *lpdwReplicaAddressSize = 0;
        return ;
    }
    else
    {
        //
        // Ready to look for one of them ...
        //
        Query->dwSize = 1024;

        while( WSALookupServiceNextW( hRnr,
                                     0,
                                     &dwQuerySize,
                                     Query ) == NO_ERROR )
        {
            //
            // Found a dir server, now see if it is a server for the NDS tree
            // TreeName.
            //
        //    if ( NwpCompareTreeNames( Query->lpszServiceInstanceName,
        //    TreeName ) )
            {
                *lpdwReplicaAddressSize = sizeof(TDI_ADDRESS_IPX);
                memcpy( lpReplicaAddress,
                        Query->lpcsaBuffer->RemoteAddr.lpSockaddr->sa_data,
                        sizeof(TDI_ADDRESS_IPX) );

                WSALookupServiceEnd(hRnr);
                return ;
            }
        }

        //
        // Could not find a dir server, return no address. The redirector will
        // have to come up with a dir server on its own.
        //
        *lpdwReplicaAddressSize = 0;
        WSALookupServiceEnd(hRnr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\server\handle.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    handle.h

Abstract:

    Header which defines the context handle structure.

Author:

    Rita Wong      (ritaw)      18-Feb-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NW_HANDLE_INLUDED_
#define _NW_HANDLE_INLUDED_

//
// Signature value in handle
//
#define NW_HANDLE_SIGNATURE        0x77442323

//
// Flags used to indicate whether Context Handles are using NDS or not
//
#define CURRENTLY_ENUMERATING_NON_NDS 0
#define CURRENTLY_ENUMERATING_NDS     1

//
// Context handle type
//
typedef enum _NW_ENUM_TYPE {

    NwsHandleListConnections = 10,
    NwsHandleListContextInfo_Tree,
    NwsHandleListContextInfo_Server,
    NwsHandleListServersAndNdsTrees,
    NwsHandleListVolumes,
    NwsHandleListQueues,
    NwsHandleListVolumesQueues,
    NwsHandleListDirectories,
    NwsHandleListPrintServers,
    NwsHandleListPrintQueues,
    NwsHandleListNdsSubTrees_Disk,
    NwsHandleListNdsSubTrees_Print,
    NwsHandleListNdsSubTrees_Any

} NW_ENUM_TYPE, *PNW_ENUM_TYPE;

//
// Data associated with each opened context handle
//
typedef struct _NW_ENUM_CONTEXT {

    //
    // For block identification
    //
    DWORD Signature;

    //
    // Handle type
    //
    NW_ENUM_TYPE HandleType;

    //
    // Resume ID.  This may be the identifier for the next entry
    // to list or may be the last entry listed for the connection handle
    // indicated by the flag dwUsingNds.
    //
    DWORD_PTR ResumeId;

    //
    // Type of object requested. Valid only when the handle type 
    // is NwsHandleListConnections.
    // 
    DWORD ConnectionType;

    //
    // Internal handle to the object we have opened to perform
    // the enumeration.  This value exists only if the handle
    // type is NwsHandleListVolumes, NwsHandleListDirectories,
    // or NwsHandleListNdsSubTrees.
    //
    HANDLE TreeConnectionHandle;

    //
    // Value used to indicate the maximum number of volumes supported on
    // a server. This is used for connection handles that enumerate volumes
    // or volumes and queues (NwsHandleListVolumes or
    // NwsHandleListVolumesQueues).
    //
    DWORD dwMaxVolumes;

    //
    // Flag used to indicate whether enumeration ResumeId is for
    // NDS trees or servers.
    //
    DWORD dwUsingNds;

    //
    // Object identifier for NDS tree enumeration. The Oid of the
    // container/oject in the path of ContainerName.
    //
    DWORD dwOid;

    //
    // The size of the buffer used for caching rdr data under enumeration.
    //
    DWORD NdsRawDataSize;

    //
    // The object identifier of the last object read from the rdr that was
    // put into the local cache buffer NdsRawDataBuffer.
    //
    DWORD NdsRawDataId;

    //
    // The number of objects currently in the local cache buffer NdsRawDataBuffer.
    //
    DWORD NdsRawDataCount;

    //
    // The local cache buffer used for rdr data enumeration.
    //
    DWORD_PTR NdsRawDataBuffer;

    //
    // Full path name of the container object we are enumerating
    // from.
    //
    //    For NwsHandleListVolumes handle type this string points to:
    //         "\\ServerName"
    //
    //    For NwsHandleListDirectories handle type this string points to:
    //         "\\ServerName\Volume\"
    //                 or
    //         "\\ServerName\Volume\Directory\"
    //
    WCHAR ContainerName[1];

} NW_ENUM_CONTEXT, *LPNW_ENUM_CONTEXT;


#endif // _NW_HANDLE_INLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\server\credentl.c ===
/*++

Copyright (c) 1993, 1994  Microsoft Corporation

Module Name:

    credentl.c

Abstract:

    This module contains credential management routines supported by
    NetWare Workstation service.

Author:

    Rita Wong  (ritaw)   15-Feb-1993

Revision History:

    13-Apr-1994   Added change password code written by ColinW, AndyHe,
                  TerenceS, and RitaW.

--*/

#include <nw.h>
#include <nwreg.h>
#include <nwlsa.h>
#include <nwauth.h>
#include <nwxchg.h>
#include <nwapi.h>


//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

//
// Variables to coordinate reading of user logon credential from the
// registry if the user logged on before the workstation is started.
//
STATIC BOOL NwLogonNotifiedRdr;


STATIC
DWORD
NwpRegisterLogonProcess(
    OUT PHANDLE LsaHandle,
    OUT PULONG AuthPackageId
    );

STATIC
VOID
NwpGetServiceCredentials(
    IN HANDLE LsaHandle,
    IN ULONG AuthPackageId
    );

STATIC
DWORD
NwpGetCredentialInLsa(
    IN HANDLE LsaHandle,
    IN ULONG AuthPackageId,
    IN PLUID LogonId,
    OUT LPWSTR *UserName,
    OUT LPWSTR *Password
    );

STATIC
VOID
NwpGetInteractiveCredentials(
    IN HANDLE LsaHandle,
    IN ULONG AuthPackageId
    );

DWORD
NwrLogonUser(
    IN LPWSTR Reserved OPTIONAL,
    IN PLUID LogonId,
    IN LPWSTR UserName,
    IN LPWSTR Password OPTIONAL,
    IN LPWSTR PreferredServerName OPTIONAL,
    IN LPWSTR NdsPreferredServerName OPTIONAL,
    OUT LPWSTR LogonCommand OPTIONAL,
    IN DWORD LogonCommandLength,
    IN DWORD PrintOption
    )
/*++

Routine Description:

    This function logs on the user to NetWare network.  It passes the
    user logon credential to the redirector to be used as the default
    credential when attaching to any server.

Arguments:

    Reserved - Must be NULL.

    UserName - Specifies the name of the user who logged on.

    Password - Specifies the password of the user who logged on.

    PreferredServerName - Specifies the user's preferred server.

    LogonCommand - Receives the string which is the command to execute
        on the command prompt for the user if logon is successful.

Return Value:

    NO_ERROR or error from redirector.

--*/
{
    DWORD status;
    LUID SystemId = SYSTEM_LUID ;

    UNREFERENCED_PARAMETER(Reserved);

    EnterCriticalSection(&NwLoggedOnCritSec);

    status = NwRdrLogonUser(
                 LogonId,
                 UserName,
                 wcslen(UserName) * sizeof(WCHAR),
                 Password,
                 (ARGUMENT_PRESENT(Password) ?
                     wcslen(Password) * sizeof(WCHAR) :
                     0),
                 PreferredServerName,
                 (ARGUMENT_PRESENT(PreferredServerName) ?
                     wcslen(PreferredServerName) * sizeof(WCHAR) :
                     0),
                 NdsPreferredServerName,
                 (ARGUMENT_PRESENT(NdsPreferredServerName) ?
                     wcslen(NdsPreferredServerName) * sizeof(WCHAR) :
                     0),
                 PrintOption
                 );

    if (status == NO_ERROR || status == NW_PASSWORD_HAS_EXPIRED) {
        NwLogonNotifiedRdr = TRUE;
        if (RtlEqualLuid(LogonId, &SystemId))
            GatewayLoggedOn = TRUE ;
    }

    LeaveCriticalSection(&NwLoggedOnCritSec);


    if (ARGUMENT_PRESENT(LogonCommand) && (LogonCommandLength >= sizeof(WCHAR))) {
        LogonCommand[0] = 0;
    }

    return status;
}


DWORD
NwrLogoffUser(
    IN LPWSTR Reserved OPTIONAL,
    IN PLUID LogonId
    )
/*++

Routine Description:

    This function tells the redirector to log off the interactive
    user.

Arguments:

    Reserved - Must be NULL.
   
    LogonId  - PLUID identifying the logged on process. if NULL, then gateway.

Return Value:


--*/
{
    DWORD status = NO_ERROR ;
    LUID SystemId = SYSTEM_LUID ;

    UNREFERENCED_PARAMETER(Reserved);

    EnterCriticalSection(&NwLoggedOnCritSec);

    if (GatewayLoggedOn || !RtlEqualLuid(LogonId, &SystemId))
        status = NwRdrLogoffUser(LogonId);

    if (status == NO_ERROR && RtlEqualLuid(LogonId, &SystemId))
        GatewayLoggedOn = FALSE ;

    LeaveCriticalSection(&NwLoggedOnCritSec);

    return status ;
}


DWORD
NwrSetInfo(
    IN LPWSTR Reserved OPTIONAL,
    IN DWORD  PrintOption,
    IN LPWSTR PreferredServerName OPTIONAL
    )
/*++

Routine Description:

    This function sets the preferred server and print option in
    the redirector for the interactive user.

Arguments:

    Reserved - Must be NULL.

    PreferredServerName - Specifies the user's preferred server.

    PrintOption - Specifies the user's print option flag

Return Value:

    NO_ERROR or error from redirector.

--*/
{
    DWORD err;

    UNREFERENCED_PARAMETER(Reserved);

    err = NwRdrSetInfo(
              PrintOption,
              NwPacketBurstSize,  // just reset to current
              PreferredServerName,
              (PreferredServerName != NULL ?
                  wcslen( PreferredServerName) * sizeof( WCHAR ) : 0 ),
              NwProviderName,    // just reset to current
              wcslen( NwProviderName ) * sizeof( WCHAR ) 
              );

    return err;
}

DWORD
NwrSetLogonScript(
    IN LPWSTR Reserved OPTIONAL,
    IN DWORD  ScriptOptions
    )
/*++

Routine Description:

    This function sets logon script related info. Currently, all that is
    supported is to turn the Run Logon Scripts Synchronously flag on and off.
    We do this using the global flag and not per user because at NPLogonNotify
    time we dont have per user registry yet. And rather than turn on & leave
    on, we turn on as need so that users that dont run NW scripts dont need 
    wait.

Arguments:

    Reserved - Must be NULL.

    ScriptOptions - options for logon scripts.

Return Value:

    Win32 error from calls made.

--*/
{
    DWORD dwSync, err = NO_ERROR ;
    HKEY hKeyWinLogon = NULL, hKeyNWC = NULL ;
    UNREFERENCED_PARAMETER(Reserved);


    if (!IsTerminalServer()) {

        // Setting global flags isn't multi-user, see userinit.c for multi-user implementation

        //
        // ***  Note that in this function we intentionally do not impersonate  ***
        // ***  since we are modifying registry under \SOFTWARE & \SYSTEM.      ***
        //

        //
        // Check the parameters. 
        //
        if (ScriptOptions ==  SYNC_LOGONSCRIPT) {
            dwSync = 1 ;   // this is value WinLogon needs to sync login scripts.
        } else if (ScriptOptions ==  RESET_SYNC_LOGONSCRIPT) {
            dwSync = 0 ;
        } else {
            return(ERROR_INVALID_PARAMETER) ;
        }

        //
        //
        // Open HKEY_LOCAL_MACHINE\System\CurrentVersion\Services\NwcWorkstation
        // \Parameters.  We use this location to record the fact we temporarily
        // turned on the Sync Scripts Flag.
        //
        err  = RegOpenKeyExW(
                            HKEY_LOCAL_MACHINE,
                            NW_WORKSTATION_REGKEY,
                            0, 
                            KEY_READ | KEY_WRITE,               // desired access
                            &hKeyNWC) ;
        if ( err ) {
            return err ;
        }

        //
        // We are resetting. Check if we turned the flag on. If no, then leave
        // it be.
        //
        if (ScriptOptions ==  RESET_SYNC_LOGONSCRIPT) {
            DWORD dwType, dwValue = 0 ;
            DWORD dwSize = sizeof(dwValue) ;

            err = RegQueryValueExW(
                                  hKeyNWC,
                                  NW_SYNCLOGONSCRIPT_VALUENAME,
                                  NULL,
                                  &dwType,                             // ignored
                                  (LPBYTE) &dwValue,
                                  &dwSize) ;

            if ((err != NO_ERROR) || (dwValue == 0)) {
                //
                // value not there or zero. ie. assume we didnt set. quit now.
                //
                goto ExitPoint ;
            }
        }

        //
        //
        // Open HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion
        // \WinLogon.
        //
        err  = RegOpenKeyExW(
                            HKEY_LOCAL_MACHINE,
                            WINLOGON_REGKEY,
                            0, 
                            KEY_READ | KEY_WRITE,            // desired access
                            &hKeyWinLogon) ;
        if ( err ) {
            goto ExitPoint ;
        }

        //
        // We are setting. Check if flag is already on. If yes, then leave
        // it be.
        //
        if (ScriptOptions ==  SYNC_LOGONSCRIPT) {
            DWORD dwType, dwValue = 0 ;
            DWORD dwSize = sizeof(dwValue) ;

            err = RegQueryValueExW(
                                  hKeyWinLogon,
                                  SYNCLOGONSCRIPT_VALUENAME,
                                  NULL,
                                  &dwType,                     // ignored
                                  (LPBYTE) &dwValue,
                                  &dwSize) ;

            if ((err == NO_ERROR) && (dwValue == 1)) {
                //
                // already on. nothing to do. just return.
                //
                goto ExitPoint ;
            }
        }
        //
        // Write out value to make logon scripts synchronous. Or to reset it.
        //
        err = RegSetValueExW(
                            hKeyWinLogon,
                            SYNCLOGONSCRIPT_VALUENAME,
                            0,
                            REG_DWORD,
                            (LPBYTE) &dwSync,          // either 1 or 0.
                            sizeof(dwSync)) ;

        if (err == NO_ERROR) {
            DWORD dwValue = (ScriptOptions == SYNC_LOGONSCRIPT) ? 1 : 0 ;
            //
            // We have successfully set WinLogon flag. Record (or clear) 
            // our own flag.
            //
            err = RegSetValueExW(
                                hKeyNWC,
                                NW_SYNCLOGONSCRIPT_VALUENAME,
                                0,
                                REG_DWORD,
                                (LPBYTE) &dwValue,   
                                sizeof(dwValue)) ;
        }

    } //if IsTerminalServer()
ExitPoint: 

    if (hKeyWinLogon) 
        (void) RegCloseKey( hKeyWinLogon );
    if (hKeyNWC) 
        (void) RegCloseKey( hKeyNWC );

    return err;
}


DWORD
NwrValidateUser(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR PreferredServerName 
    )
/*++

Routine Description:

    This function checks whether the user can be authenticated
    successfully on the given server.

Arguments:

    Reserved - Must be NULL.

    PreferredServerName - Specifies the user's preferred server.

Return Value:

    NO_ERROR or error that occurred during authentication.

--*/
{
    DWORD status ;
    UNREFERENCED_PARAMETER(Reserved);


    if (  ( PreferredServerName != NULL ) 
       && ( *PreferredServerName != 0 )
       )
    {
        //
        // Impersonate the client
        //
        if ((status = NwImpersonateClient()) != NO_ERROR)
        {
           return status ;
        }

        status = NwConnectToServer( PreferredServerName ) ;

        (void) NwRevertToSelf() ;

        return status ;

    }

    return NO_ERROR;
}


VOID
NwInitializeLogon(
    VOID
    )
/*++

Routine Description:

    This function initializes the data in the workstation which handles
    user logon.  It is called by the initialization thread.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Initialize logon flag.  When the redirector LOGON FsCtl has been
    // called, this flag will be set to TRUE.  Initialize the
    // critical section to serialize access to NwLogonNotifiedRdr flag.
    //
    NwLogonNotifiedRdr = FALSE;


}



VOID
NwGetLogonCredential(
    VOID
    )
/*++

Routine Description:

    This function reads the user and service logon IDs from the registry so
    that it can get the credentials from LSA.

    It handles the case where the user has logged on before the workstation
    is started.  This function is called by the initialization thread
    after opening up the RPC interface so that if user logon is happening
    concurrently, the provider is given a chance to call the NwrLogonUser API
    first, making it no longer necessary for the workstation to also
    retrieve the credential from the registry.

Arguments:

    None.

Return Value:

    None.

--*/
{

    DWORD status;

    HANDLE LsaHandle;
    ULONG AuthPackageId = 0;


    EnterCriticalSection(&NwLoggedOnCritSec);

    if (NwLogonNotifiedRdr) {
        //
        // Logon credential's already made known to the redirector by
        // the provider calling the NwrLogonUser API.
        //
#if DBG
        IF_DEBUG(LOGON) {
            KdPrint(("\nNWWORKSTATION: Redirector already has logon credential\n"));
        }
#endif
        LeaveCriticalSection(&NwLoggedOnCritSec);
        return;
    }

#if DBG
    IF_DEBUG(LOGON) {
        KdPrint(("NWWORKSTATION: Main init--NwGetLogonCredential\n"));
    }
#endif

    status = NwpRegisterLogonProcess(&LsaHandle, &AuthPackageId);

    if (status != NO_ERROR) {
        LeaveCriticalSection(&NwLoggedOnCritSec);
        return;
    }

    //
    // Tell the redirector about service credentials
    //
    NwpGetServiceCredentials(LsaHandle, AuthPackageId);
    //
    // Tell the redirector about interactive credentials
    //
    NwpGetInteractiveCredentials(LsaHandle, AuthPackageId);

    (void) LsaDeregisterLogonProcess(LsaHandle);

    LeaveCriticalSection(&NwLoggedOnCritSec);
}

STATIC
VOID
NwpGetServiceCredentials(
    IN HANDLE LsaHandle,
    IN ULONG AuthPackageId
    )
/*++

Routine Description:

    This function reads the service logon IDs from the registry
    so that it can get the service credentials from LSA.  It then
    notifies the redirector of the service logons.

Arguments:

    LsaHandle - Supplies the handle to LSA.

    AuthPackageId - Supplies the NetWare authentication package ID.

Return Value:

    None.

--*/
{
    DWORD status;
    LONG RegError;

    LPWSTR UserName = NULL;
    LPWSTR Password = NULL;

    HKEY ServiceLogonKey;
    DWORD Index = 0;
    WCHAR LogonIdKey[NW_MAX_LOGON_ID_LEN];
    LUID LogonId;


    RegError = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_SERVICE_LOGON_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ,
                   &ServiceLogonKey
                   );

    if (RegError == ERROR_SUCCESS) {

        do {

            RegError = RegEnumKeyW(
                           ServiceLogonKey,
                           Index,
                           LogonIdKey,
                           sizeof(LogonIdKey) / sizeof(WCHAR)
                           );

            if (RegError == ERROR_SUCCESS) {

                //
                // Got a logon id key.
                //

                NwWStrToLuid(LogonIdKey, &LogonId);

                status = NwpGetCredentialInLsa(
                             LsaHandle,
                             AuthPackageId,
                             &LogonId,
                             &UserName,
                             &Password
                             );

                if (status == NO_ERROR) {

                    (void) NwRdrLogonUser(
                               &LogonId,
                               UserName,
                               wcslen(UserName) * sizeof(WCHAR),
                               Password,
                               wcslen(Password) * sizeof(WCHAR),
                               NULL,
                               0,
                               NULL,
                               0,
                               NW_PRINT_OPTION_DEFAULT                 
                               );

                    //
                    // Freeing the UserName pointer frees both the
                    // username and password buffers.
                    //
                    (void) LsaFreeReturnBuffer((PVOID) UserName);

                }

            }
            else if (RegError != ERROR_NO_MORE_ITEMS) {
                KdPrint(("NWWORKSTATION: NwpGetServiceCredentials failed to enum logon IDs RegError=%lu\n",
                         RegError));
            }

            Index++;

        } while (RegError == ERROR_SUCCESS);

        (void) RegCloseKey(ServiceLogonKey);
    }
}


STATIC
VOID
NwpGetInteractiveCredentials(
    IN HANDLE LsaHandle,
    IN ULONG AuthPackageId
    )
/*++

Routine Description:

    This function reads the interactive logon IDs from the registry
    so that it can get the interactive credentials from LSA.  It then
    notifies the redirector of the interactive logons.

Arguments:

    LsaHandle - Supplies the handle to LSA.

    AuthPackageId - Supplies the NetWare authentication package ID.

Return Value:

    None.

--*/
{
    DWORD status;
    LONG RegError;

    LPWSTR UserName = NULL;
    LPWSTR Password = NULL;

    HKEY InteractiveLogonKey;
    DWORD Index = 0;
    WCHAR LogonIdName[NW_MAX_LOGON_ID_LEN];
    LUID LogonId;
    DWORD PrintOption;
    HKEY WkstaOptionKey = NULL;
    HKEY CurrentUserOptionKey = NULL;
    HKEY  OneLogonKey;
    LPWSTR UserSid = NULL;
    PDWORD pPrintOption = NULL;
    LPWSTR PreferredServer = NULL;
    LPWSTR NdsPreferredServer = NULL;


    RegError = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_INTERACTIVE_LOGON_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ,
                   &InteractiveLogonKey
                   );

    if (RegError == ERROR_SUCCESS) {

        do {

            RegError = RegEnumKeyW(
                           InteractiveLogonKey,
                           Index,
                           LogonIdName,
                           sizeof(LogonIdName) / sizeof(WCHAR)
                           );

            if (RegError == ERROR_SUCCESS) {

                //
                // Got a logon id key.
                //

                NwWStrToLuid(LogonIdName, &LogonId);

                status = NwpGetCredentialInLsa(
                             LsaHandle,
                             AuthPackageId,
                             &LogonId,
                             &UserName,
                             &Password
                             );

                if (status == NO_ERROR) {

            UserSid = NULL;

                    //
                    // Open the <LogonIdName> key under Logon
                    //
                    RegError = RegOpenKeyExW(
                        InteractiveLogonKey,
                        LogonIdName,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ,
                        &OneLogonKey
                    );

                    if ( RegError != ERROR_SUCCESS ) {
                        KdPrint(("NWWORKSTATION: NwpGetInteractiveLogonCredential: RegOpenKeyExW failed, Not interactive Logon: Error %d\n", GetLastError()));
                    }
            else {

                        //
                        // Read the SID value.
                        //
                        status = NwReadRegValue(
                            OneLogonKey,
                            NW_SID_VALUENAME,
                            (LPWSTR *) &UserSid
                        );

                        (void) RegCloseKey(OneLogonKey);

            if ( status != NO_ERROR ) {
                            KdPrint(("NWWORKSTATION: NwpGetInteractiveLogonCredential: Could not read SID from reg %lu\n", status));
                            UserSid = NULL;
                        }
                     }
             
             if ( UserSid ) {

                        PrintOption = NW_PRINT_OPTION_DEFAULT;
                        PreferredServer = NULL;

                        //
                        // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet
            // \Services\NWCWorkstation\Parameters\Option
                        //
                        RegError = RegOpenKeyExW(
                            HKEY_LOCAL_MACHINE,
                            NW_WORKSTATION_OPTION_REGKEY,
                            REG_OPTION_NON_VOLATILE,   // options
                            KEY_READ,                  // desired access
                            &WkstaOptionKey
                        );

                        if (RegError != ERROR_SUCCESS) {
                            KdPrint(("NWWORKSTATION: NwpGetInteractiveCredentials: RegOpenKeyExW Parameter\\Option returns unexpected error %lu!!\n",
                            RegError));
                            goto NoOption;
                        }

                        //
                        // Open the <UserSid> key under Option
                        //
                        RegError = RegOpenKeyExW(
                            WkstaOptionKey,
                            UserSid,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ,
                            &CurrentUserOptionKey
                        );

                        if (RegError != ERROR_SUCCESS) {
                            KdPrint(("NWWORKSTATION: NwpGetInteractiveCredentials: RegOpenKeyExW Parameter\\Option\\SID returns unexpected error %lu!!\n",
                            RegError));
                            (void) RegCloseKey(WkstaOptionKey);
                            goto NoOption;
                        }

                        //
                        // Read the preferred server value.
                        //
                        status = NwReadRegValue(
                            CurrentUserOptionKey,
                            NW_SERVER_VALUENAME,
                            &PreferredServer
                        );

                        if (status != NO_ERROR) {
                           KdPrint(("NWWORKSTATION: NwpGetInteractiveCredentials: Could not read preferred server from reg %lu\n", status));
                           PreferredServer = NULL;
                        }

                        //
                        // Read the preferred NDS server value (if one exists).
                        //

                        status = NwReadRegValue(
                                               CurrentUserOptionKey,
                                               NW_NDS_SERVER_VALUENAME,
                                               &NdsPreferredServer
                                               );

                        if (status != NO_ERROR) {

#if DBG
                            IF_DEBUG(LOGON) {
                                KdPrint(("NWWORKSTATION: NwGetLogonCredential: Could not read preferred NDS server from reg %lu\n", status));
                            }
#endif

                            NdsPreferredServer = NULL;
                        }
                        //
                        // Read the print option value.
                        //
                        status = NwReadRegValue(
                            CurrentUserOptionKey,
                            NW_PRINTOPTION_VALUENAME,
                            (LPWSTR *) &pPrintOption
                        );
                        if (status != NO_ERROR) {
#if DBG
                            IF_DEBUG(LOGON) {
                                 KdPrint(("NWWORKSTATION: NwGetLogonCredential: Could not read print option from reg %lu\n", status));
                            }
#endif
                            PrintOption = NW_PRINT_OPTION_DEFAULT;
                        }
            else {
                           if ( pPrintOption != NULL ) {
                   PrintOption = *pPrintOption;
                               (void) LocalFree((HLOCAL) pPrintOption);
                   pPrintOption = NULL;
                           }
               else {
                               PrintOption = NW_PRINT_OPTION_DEFAULT;
               }
            }

                        (void) RegCloseKey(CurrentUserOptionKey);
                        (void) RegCloseKey(WkstaOptionKey);

NoOption:
                        (void) NwRdrLogonUser(
                                   &LogonId,
                                   UserName,
                                   wcslen(UserName) * sizeof(WCHAR),
                                   Password,
                                   wcslen(Password) * sizeof(WCHAR),
                                   PreferredServer,
                                   ((PreferredServer != NULL) ?
                                      wcslen(PreferredServer) * sizeof(WCHAR) :
                                      0),

                                   NdsPreferredServer,
                                   ((NdsPreferredServer != NULL) ?
                                   wcslen(NdsPreferredServer) * sizeof(WCHAR) :
                                   0),
                                   PrintOption
                                   );

                        //
                        // Freeing the UserName pointer frees both the
                        // username and password buffers.
                        //
                        (void) LsaFreeReturnBuffer((PVOID) UserName);

                        if (UserSid != NULL) {
                            (void) LocalFree((HLOCAL) UserSid);
                UserSid = NULL;
                        }

                        if (PreferredServer != NULL) {
                            (void) LocalFree((HLOCAL) PreferredServer);
                PreferredServer = NULL;
                        }
                    }

                }

            }
            else if (RegError != ERROR_NO_MORE_ITEMS) {
                KdPrint(("NWWORKSTATION: NwpGetInteractiveCredentials failed to enum logon IDs RegError=%lu\n",
                         RegError));
            }

            Index++;

        } while (RegError == ERROR_SUCCESS);

        (void) RegCloseKey(InteractiveLogonKey);
    }
}

DWORD
NwGatewayLogon(
    VOID
    )
/*++

Routine Description:

    This function reads the gateway logon credential from the registry,
    LSA secret, and does the gateway logon.

Arguments:

    None.

Return Value:

    NO_ERROR or reason for failure.

--*/
{

    DWORD status = NO_ERROR;
    LONG RegError;
    LUID  LogonId = SYSTEM_LUID ;
    DWORD GatewayEnabled, RegValueType, GatewayEnabledSize ;

    HKEY WkstaKey = NULL;
    LPWSTR GatewayAccount = NULL;

    PUNICODE_STRING Password = NULL;
    PUNICODE_STRING OldPassword = NULL;


    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters
    //
    RegError = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_WORKSTATION_REGKEY,
                   REG_OPTION_NON_VOLATILE,   // options
                   KEY_READ,                  // desired access
                   &WkstaKey
                   );

    if (RegError != ERROR_SUCCESS) {
        return RegError; 
    }

    //
    // Check to see if it is enabled
    //
    RegValueType = REG_DWORD ; 
    GatewayEnabled = 0 ;
    GatewayEnabledSize = sizeof(GatewayEnabled) ;
    RegError = RegQueryValueExW(
                   WkstaKey,
                   NW_GATEWAY_ENABLE, 
                   NULL, 
                   &RegValueType, 
                   (LPBYTE)&GatewayEnabled,
                   &GatewayEnabledSize) ;

    if (status != NO_ERROR || GatewayEnabled == 0) {
        goto CleanExit;
    }


    //
    // Read the gateway account from the registry.
    //
    status = NwReadRegValue(
                 WkstaKey,
                 NW_GATEWAYACCOUNT_VALUENAME,
                 &GatewayAccount
                 );

    if (status != NO_ERROR) {
        goto CleanExit;
    }

    //
    // Read the password from its secret object in LSA.
    //
    status = NwGetPassword(
                 GATEWAY_USER,
                 &Password,      // Must be freed with LsaFreeMemory
                 &OldPassword    // Must be freed with LsaFreeMemory
                 );

    if (status != NO_ERROR) {
        goto CleanExit;
    }

    EnterCriticalSection(&NwLoggedOnCritSec);

    status = NwRdrLogonUser(
               &LogonId,
               GatewayAccount,
               ((GatewayAccount != NULL) ?
                   wcslen(GatewayAccount) * sizeof(WCHAR) :
                   0),
               Password->Buffer,
               Password->Length,
               NULL,
               0,
               NULL,
               0,
           NwGatewayPrintOption  );

    if (status == NO_ERROR)
        GatewayLoggedOn = TRUE ;

    LeaveCriticalSection(&NwLoggedOnCritSec);

    if (status != NO_ERROR)
    {
        //
        // log the error in the event log
        //

        WCHAR Number[16] ;
        LPWSTR InsertStrings[1] ;

        wsprintfW(Number, L"%d", status) ;
        InsertStrings[0] = Number ;

        NwLogEvent(EVENT_NWWKSTA_GATEWAY_LOGON_FAILED,
                   1, 
                   InsertStrings,
                   0) ;
    }
    else
    {
 
        //
        // create the gateway redirections if any. not fatal if error.
        // the function will log any errors to event log.
        //
        if (Password->Length)
        {
            LPWSTR Passwd = (LPWSTR) LocalAlloc(LPTR, 
                                           Password->Length + sizeof(WCHAR)) ;
            if (Passwd)
            {
                wcsncpy(Passwd, 
                        Password->Buffer, 
                        Password->Length / sizeof(WCHAR)) ;
                (void) NwCreateRedirections(GatewayAccount,
                                            Passwd) ;
                RtlZeroMemory((LPBYTE)Passwd,
                                      Password->Length) ;
                (void) LocalFree((HLOCAL)Passwd); 
            }
        }
        else
        {
            (void) NwCreateRedirections(GatewayAccount,
                                        NULL) ;
        }
    }


CleanExit:

    if (Password != NULL) {
        if (Password->Buffer)
            RtlZeroMemory(Password->Buffer, Password->Length) ;
        (void) LsaFreeMemory((PVOID) Password);
    }

    if (OldPassword != NULL) {
        if (OldPassword->Buffer)
            RtlZeroMemory(OldPassword->Buffer, OldPassword->Length) ;
        (void) LsaFreeMemory((PVOID) OldPassword);
    }

    if (GatewayAccount != NULL) {
        (void) LocalFree((HLOCAL) GatewayAccount);
    }

    (void) RegCloseKey(WkstaKey);
    return status ;
}

DWORD
NwGatewayLogoff(
    VOID
    )
/*++

Routine Description:

    This function logs off the gateway account.

Arguments:

    None.

Return Value:

    NO_ERROR or reason for failure.

--*/
{

    DWORD status = NO_ERROR;
    LUID  LogonId = SYSTEM_LUID ;

    EnterCriticalSection(&NwLoggedOnCritSec);

    if (GatewayLoggedOn) 
    {
         status = NwRdrLogoffUser(&LogonId);

         if (status == NO_ERROR)
             GatewayLoggedOn = FALSE ;
    }

    LeaveCriticalSection(&NwLoggedOnCritSec);

    return status ;

}

STATIC
DWORD
NwpRegisterLogonProcess(
    OUT PHANDLE LsaHandle,
    OUT PULONG AuthPackageId
    )
/*++

Routine Description:

    This function registers the workstation service as a logon process
    so that it can call LSA to retrieve user credentials.

Arguments:

    LsaHandle - Receives the handle to LSA.

    AuthPackageId - Receives the NetWare authentication package ID.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status = NO_ERROR;
    NTSTATUS ntstatus;
    STRING InputString;
    LSA_OPERATIONAL_MODE SecurityMode = 0;

    //
    // Register this process as a logon process so that we can call
    // NetWare authentication package.
    //
    RtlInitString(&InputString, "Client Service for NetWare");

    ntstatus = LsaRegisterLogonProcess(
                   &InputString,
                   LsaHandle,
                   &SecurityMode
                   );

    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("NWPROVAU: NwInitializeLogon: LsaRegisterLogonProcess returns x%08lx\n",
                 ntstatus));
        return RtlNtStatusToDosError(ntstatus);
    }

    //
    // Look up the Netware authentication package
    //
    RtlInitString(&InputString, NW_AUTH_PACKAGE_NAME);

    ntstatus = LsaLookupAuthenticationPackage(
                   *LsaHandle,
                   &InputString,
                   AuthPackageId
                   );

    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("NWPROVAU: NwpSetCredential: LsaLookupAuthenticationPackage returns x%08lx\n",
                 ntstatus));

        (void) LsaDeregisterLogonProcess(*LsaHandle);
    }

    status = RtlNtStatusToDosError(ntstatus);

    return status;
}

STATIC
DWORD
NwpGetCredentialInLsa(
    IN HANDLE LsaHandle,
    IN ULONG AuthPackageId,
    IN PLUID LogonId,
    OUT LPWSTR *UserName,
    OUT LPWSTR *Password
    )
/*++

Routine Description:

    This function retrieves the username and password information
    from LSA given the logon ID.

Arguments:

    LsaHandle - Supplies the handle to LSA.

    AuthPackageId - Supplies the NetWare authentication package ID.

    LogonId - Supplies the logon ID.

    UserName - Receives a pointer to the username.

    Password - Receives a pointer to the password.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;
    NTSTATUS ntstatus;
    NTSTATUS AuthPackageStatus;

    NWAUTH_GET_CREDENTIAL_REQUEST GetCredRequest;
    PNWAUTH_GET_CREDENTIAL_RESPONSE GetCredResponse;
    ULONG ResponseLength;

    UNICODE_STRING PasswordStr;

    //
    // Ask authentication package for credential.
    //
    GetCredRequest.MessageType = NwAuth_GetCredential;
    RtlCopyLuid(&GetCredRequest.LogonId, LogonId);

    ntstatus = LsaCallAuthenticationPackage(
                   LsaHandle,
                   AuthPackageId,
                   &GetCredRequest,
                   sizeof(GetCredRequest),
                   (PVOID *) &GetCredResponse,
                   &ResponseLength,
                   &AuthPackageStatus
                   );

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = AuthPackageStatus;
    }
    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("NWPROVAU: NwpGetCredentialInLsa: LsaCallAuthenticationPackage returns x%08lx\n",
                 ntstatus));
        status = RtlNtStatusToDosError(ntstatus);
    }
    else {

        *UserName = GetCredResponse->UserName;
        *Password = GetCredResponse->Password;

        //
        // Decode the password.
        //
        RtlInitUnicodeString(&PasswordStr, GetCredResponse->Password);
        RtlRunDecodeUnicodeString(NW_ENCODE_SEED, &PasswordStr);

        status = NO_ERROR;
    }

    return status;
}

DWORD
NwrChangePassword(
    IN LPWSTR Reserved OPTIONAL,
    IN DWORD  UserLuid,
    IN LPWSTR UserName,
    IN LPWSTR OldPassword,
    IN LPWSTR NewPassword,
    IN LPWSTR TreeName
    )
/*++

Routine Description:

    This function changes the password for the specified user on
    the list of servers.  If we encounter a failure on changing
    password for a particular server, we:

        1) Send the new password over to the server to verify if it is
           already the current password.

        2) If not, return ERROR_INVALID_PASSWORD and the index into
           the Servers array indicating the server which failed so that
           we can prompt the user to enter an alternate old password.

    When the password has been changed successfully on a server, we
    notify the redirector so that the cached credential can be updated.

    NOTE: All errors returned from this routine, except for the fatal
          ERROR_NOT_ENOUGH_MEMORY error, indicates that the password
          could not be changed on a particular server indexed by
          LastProcessed.  The client-side continues to call us with
          the remaining list of servers.

          If you add to this routine to return other fatal errors,
          please make sure the client-side code aborts from calling
          us with the rest of the servers on getting those errors.

Arguments:

    Reserved - Must be NULL.


Return Value:

    ERROR_BAD_NETPATH - Could not connect to the server indexed by
        LastProcessed.

    ERROR_BAD_USERNAME - The username could not be found on the server
        indexed by LastProcessed.

    ERROR_INVALID_PASSWORD - The change password operation failed on
        the server indexed by LastProcessed.

    ERROR_NOT_ENOUGH_MEMORY - Out of memory error.  This fatal error
        will terminate the client-side from trying to process password
        change request on the remaining servers.

--*/
{
    DWORD status;
    NTSTATUS ntstatus;
    HANDLE hNwRdr = NULL;
    UNICODE_STRING UserNameStr;
    UNICODE_STRING OldPasswordStr;
    UNICODE_STRING NewPasswordStr;
    UNICODE_STRING TreeNameStr;
    BOOL fImpersonateClient = FALSE;

    UNREFERENCED_PARAMETER( Reserved ) ;
    UNREFERENCED_PARAMETER( UserLuid ) ;

    RtlInitUnicodeString( &UserNameStr, UserName );

    RtlInitUnicodeString( &OldPasswordStr, OldPassword );
    RtlRunDecodeUnicodeString( NW_ENCODE_SEED2, &OldPasswordStr );

    RtlInitUnicodeString( &NewPasswordStr, NewPassword );
    RtlRunDecodeUnicodeString( NW_ENCODE_SEED2, &NewPasswordStr );

    RtlInitUnicodeString( &TreeNameStr, TreeName );

    //
    // Impersonate the client
    //
    if ((status = NwImpersonateClient()) != NO_ERROR)
    {
        goto ErrorExit;
    }

    fImpersonateClient = TRUE;

    //
    // Open a NDS tree connection handle to \\treename
    //
    ntstatus = NwNdsOpenTreeHandle( &TreeNameStr, &hNwRdr );

    if ( ntstatus != STATUS_SUCCESS )
    {
        status = RtlNtStatusToDosError(ntstatus);
        goto ErrorExit;
    }
 
    (void) NwRevertToSelf() ;
    fImpersonateClient = FALSE;

    ntstatus = NwNdsChangePassword( hNwRdr,
                                    &TreeNameStr,
                                    &UserNameStr,
                                    &OldPasswordStr,
                                    &NewPasswordStr );

    if ( ntstatus != NO_ERROR )
    {
        status = RtlNtStatusToDosError(ntstatus);
        goto ErrorExit;
    }

    CloseHandle( hNwRdr );
    hNwRdr = NULL;

    return NO_ERROR ;

ErrorExit:

    if ( fImpersonateClient )
        (void) NwRevertToSelf() ;

    if ( hNwRdr )
        CloseHandle( hNwRdr );

    hNwRdr = NULL;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\server\enum.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    enum.c

Abstract:

    This module contains server, volume, and directory enumeration
    routines supported by NetWare Workstation service.

Author:

    Rita Wong  (ritaw)   15-Feb-1993

Revision History:

--*/

#include <stdlib.h>
#include <nw.h>
#include <splutil.h>
#include <nwmisc.h>
#include <nwreg.h>
#include <nds.h>
#include <nwapi32.h>


VOID
GetLuid(
    IN OUT PLUID plogonid
);

//-------------------------------------------------------------------//
//                                                                   //
// Definitions                                                       //
//                                                                   //
//-------------------------------------------------------------------//

//
// Other definitions
//
#define   ONE_KB 1024
#define   TWO_KB 2048
#define  FOUR_KB 4096
#define EIGHT_KB 8192

#define TREECHAR             L'*'

#define NW_VOLUME_NAME_LEN   256
#define NW_MAX_VOLUME_NUMBER  64

//
// This structure is orginally defined in nwapi32.c, it is redefined
// here so that the routine NWGetFileServerVersionInfo() can be called
// with it.
//
typedef struct _NWC_SERVER_INFO {
    HANDLE          hConn ;
    UNICODE_STRING  ServerString ;
} NWC_SERVER_INFO ;

//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

DWORD
NwrOpenEnumServersCommon(
    IN  NW_ENUM_TYPE EnumType,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    );

DWORD
NwrOpenEnumCommon(
    IN LPWSTR ContainerName,
    IN NW_ENUM_TYPE EnumType,
    IN DWORD_PTR StartingPoint,
    IN BOOL ValidateUserFlag,
    IN LPWSTR UserName OPTIONAL,
    IN LPWSTR Password OPTIONAL,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    OUT LPDWORD ClassTypeOfNDSLeaf,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    );

DWORD
NwEnumContextInfo(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwEnumServersAndNdsTrees(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwEnumPrintServers(
    IN  LPNW_ENUM_CONTEXT ContextHandle,
    IN  DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN  DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwEnumVolumes(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwEnumNdsSubTrees_Disk(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwEnumNdsSubTrees_Print(
    IN  LPNW_ENUM_CONTEXT ContextHandle,
    IN  DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN  DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwEnumNdsSubTrees_Any(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwEnumQueues(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwEnumVolumesQueues(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwEnumDirectories(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwEnumPrintQueues(
    IN  LPNW_ENUM_CONTEXT ContextHandle,
    IN  DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN  DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwGetFirstDirectoryEntry(
    IN HANDLE DirHandle,
    OUT LPWSTR *DirEntry
    );

DWORD
NwGetNextDirectoryEntry(
    IN HANDLE DirHandle,
    OUT LPWSTR *DirEntry
    );

DWORD
NwGetFirstNdsSubTreeEntry(
    OUT LPNW_ENUM_CONTEXT ContextHandle,
    IN  DWORD BufferSize
    );

DWORD
NwGetNextNdsSubTreeEntry(
    OUT LPNW_ENUM_CONTEXT ContextHandle
    );

BYTE
NwGetSubTreeData(
    IN  DWORD_PTR NdsRawDataPtr,
    OUT LPWSTR *  SubTreeName,
    OUT LPDWORD   ResourceScope,
    OUT LPDWORD   ResourceType,
    OUT LPDWORD   ResourceDisplayType,
    OUT LPDWORD   ResourceUsage,
    OUT LPWSTR  * StrippedObjectName
    );

VOID
NwStripNdsUncName(
    IN  LPWSTR   ObjectName,
    OUT LPWSTR * StrippedObjectName
    );

#define VERIFY_ERROR_NOT_A_NDS_TREE     0x1010FFF0
#define VERIFY_ERROR_PATH_NOT_FOUND     0x1010FFF1

DWORD
NwVerifyNDSObject(
    IN  LPWSTR   lpNDSObjectNamePath,
    OUT LPWSTR * lpFullNDSObjectNamePath,
    OUT LPDWORD  lpClassType,
    OUT LPDWORD  lpResourceScope,
    OUT LPDWORD  lpResourceType,
    OUT LPDWORD  lpResourceDisplayType,
    OUT LPDWORD  lpResourceUsage
    );

DWORD
NwVerifyBinderyObject(
    IN  LPWSTR   lpBinderyObjectNamePath,
    OUT LPWSTR * lpFullBinderyObjectNamePath,
    OUT LPDWORD  lpClassType,
    OUT LPDWORD  lpResourceScope,
    OUT LPDWORD  lpResourceType,
    OUT LPDWORD  lpResourceDisplayType,
    OUT LPDWORD  lpResourceUsage
    );

DWORD
NwGetNDSPathInfo(
    IN  LPWSTR   lpNDSObjectNamePath,
    OUT LPWSTR * lpSystemObjectNamePath,
    OUT LPWSTR * lpSystemPathPart,
    OUT LPDWORD  lpClassType,
    OUT LPDWORD  lpResourceScope,
    OUT LPDWORD  lpResourceType,
    OUT LPDWORD  lpResourceDisplayType,
    OUT LPDWORD  lpResourceUsage
    );

DWORD
NwGetBinderyPathInfo(
    IN  LPWSTR   lpBinderyObjectNamePath,
    OUT LPWSTR * lpSystemObjectNamePath,
    OUT LPWSTR * lpSystemPathPart,
    OUT LPDWORD  lpClassType,
    OUT LPDWORD  lpResourceScope,
    OUT LPDWORD  lpResourceType,
    OUT LPDWORD  lpResourceDisplayType,
    OUT LPDWORD  lpResourceUsage
    );

BOOL
NwGetRemoteNameParent(
    IN  LPWSTR   lpRemoteName,
    OUT LPWSTR * lpRemoteNameParent
    );

int __cdecl
SortFunc(
    IN CONST VOID *p1,
    IN CONST VOID *p2
    );

DWORD
NwGetConnectionInformation(
    IN  LPWSTR lpName,
    OUT LPWSTR lpUserName,
    OUT LPWSTR lpHostServer
    );


VOID
NwpGetUncInfo(
    IN LPWSTR lpstrUnc,
    OUT WORD * slashCount,
    OUT BOOL * isNdsUnc,
    OUT LPWSTR * FourthSlash
    );

DWORD
NwpGetCurrentUserRegKey(
    IN  DWORD DesiredAccess,
    OUT HKEY  *phKeyCurrentUser
    );

DWORD
NwQueryInfo(
    OUT LPWSTR *ppszPreferredSrv
    );


DWORD
NwrOpenEnumContextInfo(
    IN  LPWSTR Reserved OPTIONAL,
    IN  DWORD  ConnectionType,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function creates a new context handle and initializes it
    for enumerating context information (i.e. NDS user context objects
    and/or NetWare bindery server connections).

Arguments:

    Reserved - Unused.

    EnumHandle - Receives the newly created context handle.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - if the memory for the context could
        not be allocated.

    NO_ERROR - Call was successful.

--*/
{
    LPWSTR pszCurrentContext = NULL;
    DWORD  dwPrintOptions;
    DWORD  status = NwQueryInfo( &pszCurrentContext );
    WCHAR  Context[MAX_NDS_NAME_CHARS];
    LPNW_ENUM_CONTEXT ContextHandle;

    UNREFERENCED_PARAMETER(Reserved);
    UNREFERENCED_PARAMETER(ConnectionType);


#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWWORKSTATION: NwrOpenEnumContextInfo\n"));
    }
#endif

    if ( pszCurrentContext &&
         status == NO_ERROR )
    {
        if ( pszCurrentContext[0] == TREECHAR )
        {
            wcscpy( Context, L"\\\\" );
            wcscat( Context, pszCurrentContext + 1 );

            LocalFree( pszCurrentContext );
            pszCurrentContext = NULL;

            return NwrOpenEnumCommon(
                       Context,
                       NwsHandleListContextInfo_Tree,
                       (DWORD_PTR) -1,
                       FALSE,
                       NULL,
                       NULL,
                       0,
                       0,
                       NULL,
                       EnumHandle
                       );
        }
        else
        {
            //
            // The user does not have a preferred NDS tree and context. They
            // may have only a preferred server.
            //
            if ( pszCurrentContext[0] != 0 )
            {
                //
                // There is a prefered server.
                //
                LocalFree( pszCurrentContext );
                pszCurrentContext = NULL;

                ContextHandle = (PVOID) LocalAlloc(
                                            LMEM_ZEROINIT,
                                            sizeof(NW_ENUM_CONTEXT)
                                            );

                if (ContextHandle == NULL)
                {
                    KdPrint(("NWWORKSTATION: NwrOpenEnumContextInfo LocalAlloc Failed %lu\n", GetLastError()));
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                //
                // Initialize contents of the context handle structure.
                //
                ContextHandle->Signature = NW_HANDLE_SIGNATURE;
                ContextHandle->HandleType = NwsHandleListContextInfo_Server;
                ContextHandle->dwUsingNds = CURRENTLY_ENUMERATING_NON_NDS;
                ContextHandle->ResumeId = (DWORD_PTR) -1;

                // The following are set to zero due to the LMEM_ZEROINIT.
                // ContextHandle->NdsRawDataBuffer = 0;
                // ContextHandle->NdsRawDataSize = 0;
                // ContextHandle->NdsRawDataId = 0;
                // ContextHandle->NdsRawDataCount = 0;
                // ContextHandle->TreeConnectionHandle = 0;
                // ContextHandle->ConnectionType = 0;

                //
                // Return the newly created context.
                //
                *EnumHandle = (LPNWWKSTA_CONTEXT_HANDLE) ContextHandle;

                return NO_ERROR;
            }
        }
    }

    //
    // There is no information in the registry about the current user.
    // We go ahead and make an enumeration handle and return success.
    // Later, during a call to NPEnumResource, we will return zero items.
    // This is done because there is no valid return code to tell the
    // callee that we have no context information to provide.
    //
    ContextHandle = (PVOID) LocalAlloc( LMEM_ZEROINIT,
                                        sizeof(NW_ENUM_CONTEXT) );

    if (ContextHandle == NULL)
    {
        KdPrint(("NWWORKSTATION: NwrOpenEnumContextInfo LocalAlloc Failed %lu\n", GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize contents of the context handle structure.
    //
    ContextHandle->Signature = NW_HANDLE_SIGNATURE;
    ContextHandle->HandleType = NwsHandleListContextInfo_Server;
    ContextHandle->dwUsingNds = CURRENTLY_ENUMERATING_NON_NDS;
    ContextHandle->ResumeId = 0; // This will tell NwrEnum to
                                 // give up (i.e. we are done).

    // The following are set to zero due to the LMEM_ZEROINIT.
    // ContextHandle->NdsRawDataBuffer = 0;
    // ContextHandle->NdsRawDataSize = 0;
    // ContextHandle->NdsRawDataId = 0;
    // ContextHandle->NdsRawDataCount = 0;
    // ContextHandle->TreeConnectionHandle = 0;
    // ContextHandle->ConnectionType = 0;

    //
    // Return the newly created context.
    //
    *EnumHandle = (LPNWWKSTA_CONTEXT_HANDLE) ContextHandle;

    return NO_ERROR;
}



DWORD
NwrOpenEnumServersAndNdsTrees(
    IN LPWSTR Reserved OPTIONAL,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function creates a new context handle and initializes it
    for enumerating the servers and NDS trees on the network.

Arguments:

    Reserved - Unused.

    EnumHandle - Receives the newly created context handle.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - if the memory for the context could
        not be allocated.

    NO_ERROR - Call was successful.

--*/ // NwrOpenEnumServersAndNdsTrees
{
    UNREFERENCED_PARAMETER(Reserved);

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint( ("\nNWWORKSTATION: NwrOpenEnumServersAndNdsTrees\n") );
    }
#endif

    return NwrOpenEnumServersCommon(
               NwsHandleListServersAndNdsTrees,
               EnumHandle
               );
}



DWORD
NwOpenEnumPrintServers(
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function creates a new context handle and initializes it
    for enumerating the print servers on the network.

Arguments:

    Reserved   - Unused.
    EnumHandle - Receives the newly created context handle.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - if the memory for the context could
        not be allocated.

    NO_ERROR - Call was successful.

--*/ // NwOpenEnumPrintServers
{

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint( ("\nNWWORKSTATION: NwOpenEnumPrintServers\n") );
    }
#endif

    return NwrOpenEnumServersCommon(
               NwsHandleListPrintServers,
               EnumHandle
               );
}


DWORD
NwrOpenEnumVolumes(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR ServerName,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function calls a common routine which creates a new context
    handle and initializes it for enumerating the volumes on a server.

Arguments:

    Reserved - Unused.

    ServerName - Supplies the name of the server to enumerate volumes.
        This name is prefixed by \\.

    EnumHandle - Receives the newly created context handle.

Return Value:

    NO_ERROR or reason for failure.

--*/ // NwrOpenEnumVolumes
{
    UNREFERENCED_PARAMETER(Reserved);

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWWORKSTATION: NwrOpenEnumVolumes %ws\n",
                 ServerName));
    }
#endif

    return NwrOpenEnumCommon(
               ServerName,
               NwsHandleListVolumes,
               0,
               FALSE,
               NULL,
               NULL,
               FILE_OPEN,
               FILE_SYNCHRONOUS_IO_NONALERT,
               NULL,
               EnumHandle
               );
}


DWORD
NwrOpenEnumNdsSubTrees_Disk(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR ParentPathName,
    OUT LPDWORD ClassTypeOfNDSLeaf,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function calls a common routine which creates a new context
    handle and initializes it for enumerating the DISK object types
    and containers of a sub-tree in a NDS tree.

Arguments:

    Reserved - Unused.

    ParentPathName - Supplies the name of the tree and the path to a container
    to enumerate sub-trees.

    EnumHandle - Receives the newly created context handle.

Return Value:

    NO_ERROR or reason for failure.

--*/ // NwrOpenEnumNdsSubTrees_Disk
{

    UNREFERENCED_PARAMETER(Reserved);

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWWORKSTATION: NwrOpenEnumNdsSubTrees_Disk %ws\n",
                 ParentPathName));
    }
#endif

    return NwrOpenEnumCommon(
               ParentPathName,
               NwsHandleListNdsSubTrees_Disk,
               0,
               FALSE,
               NULL,
               NULL,
               0,
               0,
               ClassTypeOfNDSLeaf,
               EnumHandle
               );
}


DWORD
NwrOpenEnumNdsSubTrees_Print(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR ParentPathName,
    OUT LPDWORD ClassTypeOfNDSLeaf,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function calls a common routine which creates a new context
    handle and initializes it for enumerating the PRINT object types
    and containers of a sub-tree in a NDS tree.

Arguments:

    Reserved - Unused.

    ParentPathName - Supplies the name of the tree and the path to a container
    to enumerate sub-trees.

    EnumHandle - Receives the newly created context handle.

Return Value:

    NO_ERROR or reason for failure.

--*/ // NwrOpenEnumNdsSubTrees_Print
{
#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWWORKSTATION: NwrOpenEnumNdsSubTrees_Print %ws\n",
                 ParentPathName));
    }
#endif

    return NwrOpenEnumCommon(
               ParentPathName,
               NwsHandleListNdsSubTrees_Print,
               0,
               FALSE,
               NULL,
               NULL,
               0,
               0,
               ClassTypeOfNDSLeaf,
               EnumHandle
               );
}


DWORD
NwrOpenEnumNdsSubTrees_Any(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR ParentPathName,
    OUT LPDWORD ClassTypeOfNDSLeaf,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function calls a common routine which creates a new context
    handle and initializes it for enumerating the ANY object types
    and containers of a sub-tree in a NDS tree.

Arguments:

    Reserved - Unused.

    ParentPathName - Supplies the name of the tree and the path to a container
    to enumerate sub-trees.

    EnumHandle - Receives the newly created context handle.

Return Value:

    NO_ERROR or reason for failure.

--*/ // NwrOpenEnumNdsSubTrees_Any
{

    UNREFERENCED_PARAMETER(Reserved);

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWWORKSTATION: NwrOpenEnumNdsSubTrees_Any %ws\n",
                 ParentPathName));
    }
#endif

    return NwrOpenEnumCommon(
               ParentPathName,
               NwsHandleListNdsSubTrees_Any,
               0,
               FALSE,
               NULL,
               NULL,
               0,
               0,
               ClassTypeOfNDSLeaf,
               EnumHandle
               );
}


DWORD
NwrOpenEnumQueues(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR ServerName,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function calls a common routine which creates a new context
    handle and initializes it for enumerating the volumes on a server.

Arguments:

    Reserved - Unused.

    ServerName - Supplies the name of the server to enumerate volumes.
        This name is prefixed by \\.

    EnumHandle - Receives the newly created context handle.

Return Value:

    NO_ERROR or reason for failure.

--*/ // NwrOpenEnumQueues
{

    UNREFERENCED_PARAMETER(Reserved);

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWWORKSTATION: NwrOpenEnumQueues %ws\n",
                 ServerName));
    }
#endif

    return NwrOpenEnumCommon(
               ServerName,
               NwsHandleListQueues,
               (DWORD_PTR) -1,
               TRUE,
               NULL,
               NULL,
               FILE_OPEN,
               FILE_SYNCHRONOUS_IO_NONALERT,
               NULL,
               EnumHandle
               );
}


DWORD
NwrOpenEnumVolumesQueues(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR ServerName,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function calls a common routine which creates a new context
    handle and initializes it for enumerating the volumes/queues on a server.

Arguments:

    Reserved - Unused.

    ServerName - Supplies the name of the server to enumerate volumes.
        This name is prefixed by \\.

    EnumHandle - Receives the newly created context handle.

Return Value:

    NO_ERROR or reason for failure.

--*/ // NwrOpenEnumVolumesQueues
{

    DWORD status;
    UNREFERENCED_PARAMETER(Reserved);

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWWORKSTATION: NwrOpenEnumVolumesQueues %ws\n",
                 ServerName));
    }
#endif

    status = NwrOpenEnumCommon(
               ServerName,
               NwsHandleListVolumesQueues,
               0,
               FALSE,
               NULL,
               NULL,
               FILE_OPEN,
               FILE_SYNCHRONOUS_IO_NONALERT,
               NULL,
               EnumHandle
               );

    if ( status == NO_ERROR )
        ((LPNW_ENUM_CONTEXT) *EnumHandle)->ConnectionType = CONNTYPE_DISK;

    return status;
}


DWORD
NwrOpenEnumDirectories(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR ParentPathName,
    IN LPWSTR UserName OPTIONAL,
    IN LPWSTR Password OPTIONAL,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function calls a common routine which creates a new context
    handle and initializes it for enumerating the volumes on a server.

Arguments:

    Reserved - Unused.

    ParentPathName - Supplies the parent path name in the format of
        \\Server\Volume.

    UserName - Supplies the username to connect with.

    Password - Supplies the password to connect with.

    EnumHandle - Receives the newly created context handle.

Return Value:

    NO_ERROR or reason for failure.

--*/ //NwrOpenEnumDirectories
{
    UNREFERENCED_PARAMETER(Reserved);

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWWORKSTATION: NwrOpenEnumDirectories %ws\n",
                 ParentPathName));
    }
#endif

    return NwrOpenEnumCommon(
               ParentPathName,
               NwsHandleListDirectories,
               0,
               FALSE,
               UserName,
               Password,
               FILE_CREATE,
               FILE_CREATE_TREE_CONNECTION |
                   FILE_SYNCHRONOUS_IO_NONALERT,
               NULL,
               EnumHandle
               );
}


DWORD
NwOpenEnumPrintQueues(
    IN LPWSTR ServerName,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function calls a common routine which creates a new context
    handle and initializes it for enumerating the print queues on a server.

Arguments:

    Reserved - Unused.

    ServerName - Supplies the name of the server to enumerate volumes.
        This name is prefixed by \\.

    EnumHandle - Receives the newly created context handle.

Return Value:

    NO_ERROR or reason for failure.

--*/ // NwOpenEnumPrintQueues
{

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWWORKSTATION: NwOpenEnumPrintQueues %ws\n",
                 ServerName));
    }
#endif

    return NwrOpenEnumCommon(
               ServerName,
               NwsHandleListPrintQueues,
               (DWORD_PTR) -1,
               TRUE,
               NULL,
               NULL,
               FILE_OPEN,
               FILE_SYNCHRONOUS_IO_NONALERT,
               NULL,
               EnumHandle
               );
}


DWORD
NwrOpenEnumServersCommon(
    IN  NW_ENUM_TYPE EnumType,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function creates a new context handle and initializes it
    for enumerating the servers on the network.

Arguments:

    EnumType   - Supplies the type of the object we want to enumerate

    EnumHandle - Receives the newly created context handle.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - if the memory for the context could
        not be allocated.

    NO_ERROR - Call was successful.

--*/ // NwrOpenEnumServersCommon
{
    DWORD status = NO_ERROR;
    LPNW_ENUM_CONTEXT ContextHandle = NULL;

    //
    // Allocate memory for the context handle structure.
    //
    ContextHandle = (PVOID) LocalAlloc(
                                LMEM_ZEROINIT,
                                sizeof(NW_ENUM_CONTEXT)
                                );

    if (ContextHandle == NULL) {
        KdPrint((
            "NWWORKSTATION: NwrOpenEnumServersCommon LocalAlloc Failed %lu\n",
            GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize contents of the context handle structure.
    //
    ContextHandle->Signature = NW_HANDLE_SIGNATURE;
    ContextHandle->HandleType = EnumType;
    ContextHandle->ResumeId = (DWORD_PTR) -1;
    ContextHandle->NdsRawDataBuffer = 0x00000000;
    ContextHandle->NdsRawDataSize = 0x00000000;
    ContextHandle->NdsRawDataId = 0x00000000;
    ContextHandle->NdsRawDataCount = 0x00000000;

    //
    // Set flag to indicate that we are going to enumerate NDS trees first.
    //
    ContextHandle->dwUsingNds = CURRENTLY_ENUMERATING_NDS;

    //
    // Impersonate the client
    //
    if ((status = NwImpersonateClient()) != NO_ERROR)
    {
        goto CleanExit;
    }

    //
    // We enum servers and nds trees from the preferred server.
    //
    status = NwOpenPreferredServer(
                 &ContextHandle->TreeConnectionHandle
                 );

    (void) NwRevertToSelf() ;

    if (status == NO_ERROR)
    {
        //
        // Return the newly created context.
        //
        *EnumHandle = (LPNWWKSTA_CONTEXT_HANDLE) ContextHandle;

        return status;
    }

CleanExit:
    if ( ContextHandle )
    {
        ContextHandle->Signature = 0x0BADBAD0;

        (void) LocalFree((HLOCAL) ContextHandle);
    }

    return status;
}


DWORD
NwrOpenEnumCommon(
    IN LPWSTR ContainerName,
    IN NW_ENUM_TYPE EnumType,
    IN DWORD_PTR StartingPoint,
    IN BOOL  ValidateUserFlag,
    IN LPWSTR UserName OPTIONAL,
    IN LPWSTR Password OPTIONAL,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    OUT LPDWORD ClassTypeOfNDSLeaf,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function is common code for creating a new context handle
    and initializing it for enumerating either volumes, directories,
    or NDS subtrees.

Arguments:

    ContainerName - Supplies the full path name to the container object
                    we are enumerating from.

    EnumType - Supplies the type of the object we want to enumerate

    StartingPoint - Supplies the initial resume ID.

    UserName - Supplies the username to connect with.

    Password - Supplies the password to connect with.

    EnumHandle - Receives the newly created context handle.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - if the memory for the context could
        not be allocated.

    NO_ERROR - Call was successful.

    Other errors from failure to open a handle to the server.

--*/ // NwrOpenEnumCommon
{
    DWORD status = NO_ERROR;
    NTSTATUS ntstatus = STATUS_SUCCESS;
    LPNW_ENUM_CONTEXT ContextHandle = NULL;
    LPWSTR StrippedContainerName = NULL;
    BOOL  fImpersonate = FALSE ;

    if ( ClassTypeOfNDSLeaf )
        *ClassTypeOfNDSLeaf = 0;

    //
    // Before we do anything, we need to convert the UNC passed to
    // us. We need to get rid of any CN=XXX.OU=YYY.O=ZZZ references, and
    // convert them to XXX.YYY.ZZZ format. Any NETRESOURCE that we generate
    // will look like \\TREE\XXX.YYY.ZZZ for a NDS Unc. We do this to
    // work around to a bug in WOW.EXE, that prevents 16 bit apps from
    // being launched when the user types NDS paths with the CN= stuff in it.
    // 
    NwStripNdsUncName( ContainerName, &StrippedContainerName );

    if ( StrippedContainerName == NULL )
    {
        KdPrint(("NWWORKSTATION: NwrOpenEnumCommon LocalAlloc Failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Allocate memory for the context handle structure and space for
    // the ContainerName plus \.  Now need one more for NULL terminator
    // because it's already included in the structure.
    //
    ContextHandle = (PVOID) LocalAlloc(
                                        LMEM_ZEROINIT,
                                        sizeof(NW_ENUM_CONTEXT) +
                                        (wcslen(StrippedContainerName) + 1) * sizeof(WCHAR)
                                      );

    if (ContextHandle == NULL)
    {
        if ( StrippedContainerName )
        {
            (void) LocalFree((HLOCAL) StrippedContainerName);
            StrippedContainerName = NULL;
        }

        KdPrint(("NWWORKSTATION: NwrOpenEnumCommon LocalAlloc Failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize contents of the context handle structure.
    //
    ContextHandle->Signature = NW_HANDLE_SIGNATURE;
    ContextHandle->HandleType = EnumType;
    ContextHandle->ResumeId = StartingPoint;

    //
    // These are set to zero due to LMEM_ZEROINIT.
    //
    // ContextHandle->NdsRawDataBuffer = 0;
    // ContextHandle->NdsRawDataSize = 0;
    // ContextHandle->NdsRawDataId = 0;
    // ContextHandle->NdsRawDataCount = 0;
    // ContextHandle->TreeConnectionHandle = 0;

    //
    // Impersonate the client
    //
    if ( ( status = NwImpersonateClient() ) != NO_ERROR )
    {
        goto ErrorExit;
    }

    fImpersonate = TRUE;

    if ( EnumType == NwsHandleListNdsSubTrees_Disk ||
         EnumType == NwsHandleListNdsSubTrees_Print ||
         EnumType == NwsHandleListNdsSubTrees_Any ||
         EnumType == NwsHandleListContextInfo_Tree )
    {
        WCHAR          lpServerName[NW_MAX_SERVER_LEN];
        UNICODE_STRING ServerName;
        UNICODE_STRING ObjectName;

        ServerName.Length = 0;
        ServerName.MaximumLength = sizeof( lpServerName );
        ServerName.Buffer = lpServerName;

        ObjectName.Buffer = NULL;

        if ( EnumType == NwsHandleListContextInfo_Tree )
        {
            ContextHandle->dwUsingNds = CURRENTLY_ENUMERATING_NON_NDS;
        }
        else
        {
            ContextHandle->dwUsingNds = CURRENTLY_ENUMERATING_NDS;
        }

        ObjectName.MaximumLength = ( wcslen( StrippedContainerName ) + 1 ) *
                                   sizeof( WCHAR );

        ObjectName.Length = NwParseNdsUncPath( (LPWSTR *) &ObjectName.Buffer,
                                               StrippedContainerName,
                                               PARSE_NDS_GET_TREE_NAME );

        if ( ObjectName.Length == 0 || ObjectName.Buffer == NULL )
        {
            status = ERROR_PATH_NOT_FOUND;
            goto ErrorExit;
        }

        //
        // Open a NDS tree connection handle to \\treename
        //
        ntstatus = NwNdsOpenTreeHandle( &ObjectName,
                                      &ContextHandle->TreeConnectionHandle );

        if ( ntstatus != STATUS_SUCCESS )
        {
            status = RtlNtStatusToDosError(ntstatus);
            goto ErrorExit;
        }


        //
        // Get the path to the container to open.
        //
        ObjectName.Length = NwParseNdsUncPath( (LPWSTR *) &ObjectName.Buffer,
                                               StrippedContainerName,
                                               PARSE_NDS_GET_PATH_NAME
                                             );

        if ( ObjectName.Length == 0 )
        {
            UNICODE_STRING Root;

            RtlInitUnicodeString(&Root, L"[Root]");

            //
            // Resolve the path to get a NDS object id of [Root].
            //
            ntstatus =  NwNdsResolveName( ContextHandle->TreeConnectionHandle,
                                          &Root,
                                          &ContextHandle->dwOid,
                                          &ServerName,
                                          NULL,
                                          0 );

            if ( ntstatus != STATUS_SUCCESS )
            {
                status = RtlNtStatusToDosError(ntstatus);
                goto ErrorExit;
            }

            wcscpy(ContextHandle->ContainerName, StrippedContainerName);
        }
        else
        {
            //
            // Resolve the path to get a NDS object id.
            //
            ntstatus =  NwNdsResolveName( ContextHandle->TreeConnectionHandle,
                                          &ObjectName,
                                          &ContextHandle->dwOid,
                                          &ServerName,
                                          NULL,
                                          0 );

            if ( ntstatus != STATUS_SUCCESS )
            {
                status = RtlNtStatusToDosError(ntstatus);
                goto ErrorExit;
            }

            wcscpy(ContextHandle->ContainerName, StrippedContainerName);
        }

        if ( ServerName.Length )
        {
            DWORD    dwHandleType;

            //
            // NwNdsResolveName succeeded, but we were referred to
            // another server, though ContextHandle->dwOid is still valid.

            if ( ContextHandle->TreeConnectionHandle )
                CloseHandle( ContextHandle->TreeConnectionHandle );

            ContextHandle->TreeConnectionHandle = 0;

            //
            // Open a NDS generic connection handle to \\ServerName
            //
            ntstatus = NwNdsOpenGenericHandle( &ServerName,
                                               &dwHandleType,
                                               &ContextHandle->TreeConnectionHandle );

            if ( ntstatus != STATUS_SUCCESS )
            {
                status = RtlNtStatusToDosError(ntstatus);
                goto ErrorExit;
            }

            ASSERT( dwHandleType == HANDLE_TYPE_NCP_SERVER );
        }

        //
        // Check to see if object is either a Server, Directory Map, or Volume.
        // If so, the object is a known leaf in terms of NDS, and therefore cannot
        // be enumerated through NwNdsList API calls. We fail the OpenEnum call in these
        // cases and pass back the type of object the leaf node was. This way the code in
        // NWPROVAU!NPOpenEnum can call NwrOpenEnumServer, NwrOpenEnumVolume, or
        // NwrOpenEnumDirectories accordingly.
        //
        {
            BYTE RawResponse[TWO_KB];
            DWORD RawResponseSize = sizeof(RawResponse);
            DWORD dwStrLen;
            PBYTE pbRawGetInfo;

            ntstatus = NwNdsReadObjectInfo( ContextHandle->TreeConnectionHandle,
                                            ContextHandle->dwOid,
                                            RawResponse,
                                            RawResponseSize );

            if ( ntstatus != NO_ERROR )
            {
                status = RtlNtStatusToDosError(ntstatus);
                goto ErrorExit;
            }

            (void) NwRevertToSelf() ;
            fImpersonate = FALSE;

            pbRawGetInfo = RawResponse;

            //
            // The structure of a NDS_RESPONSE_GET_OBJECT_INFO consists of 4 DWORDs
            // followed by two standard NDS format UNICODE strings. Below we jump pbRawGetInfo
            // into the buffer, past the 4 DWORDs.
            //
            pbRawGetInfo += sizeof ( NDS_RESPONSE_GET_OBJECT_INFO );

            //
            // Now we get the length of the first string (Base Class).
            //
            dwStrLen = * ( DWORD * ) pbRawGetInfo;

            //
            // Now we point pbRawGetInfo to the first WCHAR of the first string (Base Class).
            //
            pbRawGetInfo += sizeof( DWORD );

            //
            // If the object is either a NCP Server, Volume, or a Directory Map, we fail
            // the OpenEnum call and return the class type of the NDS leaf object. We do
            // this because we cannot enumerate through NwNdsList() calls any subordinates,
            // all browsing below these types are done through system redirector calls. So
            // the client side of the provider will instead call NwOpenEnumVolumes or
            // NwOpenEnumDirectories, respectively.
            //
            if ( !wcscmp( (LPWSTR) pbRawGetInfo, L"NCP Server" ) )
            {
                if ( ClassTypeOfNDSLeaf )
                    *ClassTypeOfNDSLeaf = CLASS_TYPE_NCP_SERVER;
                status = ERROR_NETWORK_ACCESS_DENIED;
                goto ErrorExit;
            }

            if ( !wcscmp( (LPWSTR) pbRawGetInfo, L"Volume" ) )
            {
                if ( ClassTypeOfNDSLeaf )
                    *ClassTypeOfNDSLeaf = CLASS_TYPE_VOLUME;
                status = ERROR_NETWORK_ACCESS_DENIED;
                goto ErrorExit;
            }

            if ( !wcscmp( (LPWSTR) pbRawGetInfo, L"Directory Map" ) )
            {
                if ( ClassTypeOfNDSLeaf )
                    *ClassTypeOfNDSLeaf = CLASS_TYPE_DIRECTORY_MAP;
                status = ERROR_NETWORK_ACCESS_DENIED;
                goto ErrorExit;
            }
        } // End of block
    }
    else // EnumType is something other than a NDS Sub-tree
    {
        UNICODE_STRING TreeConnectStr;

        TreeConnectStr.Buffer = NULL;
        ContextHandle->dwUsingNds = CURRENTLY_ENUMERATING_NON_NDS;

        wcscpy(ContextHandle->ContainerName, StrippedContainerName);
        wcscat(ContextHandle->ContainerName, L"\\");

        //
        // Open a tree connection handle to \Device\NwRdr\ContainerName
        //
        status = NwCreateTreeConnectName( StrippedContainerName,
                                          NULL,
                                          &TreeConnectStr );

        if ( status != NO_ERROR )
        {
            goto ErrorExit;
        }

        status = NwOpenCreateConnection( &TreeConnectStr,
                                         UserName,
                                         Password,
                                         StrippedContainerName,
                                         FILE_LIST_DIRECTORY | SYNCHRONIZE |
                                          ( ValidateUserFlag? FILE_WRITE_DATA : 0 ),
                                         CreateDisposition,
                                         CreateOptions,
                                         RESOURCETYPE_DISK, // When connecting beyond servername
                                         &ContextHandle->TreeConnectionHandle,
                                         NULL );

        (void) LocalFree((HLOCAL) TreeConnectStr.Buffer);
    }

    if (status == NO_ERROR)
    {
        VERSION_INFO vInfo;

        if ( EnumType == NwsHandleListVolumes ||
             EnumType == NwsHandleListVolumesQueues )
        {
            NWC_SERVER_INFO ServerInfo;

            ServerInfo.hConn = ContextHandle->TreeConnectionHandle;
            ServerInfo.ServerString.Length = 0;
            ServerInfo.ServerString.MaximumLength = 0;
            ServerInfo.ServerString.Buffer = NULL;

            status = NWGetFileServerVersionInfo( (HANDLE) &ServerInfo,
                                                 &vInfo );

            if ( status )
            {
                ContextHandle->dwMaxVolumes = NW_MAX_VOLUME_NUMBER;
                status = NO_ERROR;
            }
            else
            {
                ContextHandle->dwMaxVolumes = (DWORD) vInfo.maxVolumes;

                if ( ContextHandle->dwMaxVolumes == 0 )
                {
                    ContextHandle->dwMaxVolumes = NW_MAX_VOLUME_NUMBER;
                }
            }
        }

        (void) NwRevertToSelf() ;
        fImpersonate = FALSE;

        if ( StrippedContainerName )
        {
            (void) LocalFree((HLOCAL) StrippedContainerName);
            StrippedContainerName = NULL;
        }

        //
        // Return the newly created context.
        //
        *EnumHandle = (LPNWWKSTA_CONTEXT_HANDLE) ContextHandle;

        return status;
    }

ErrorExit:

    if ( fImpersonate )
        (void) NwRevertToSelf() ;

    if ( StrippedContainerName )
    {
        (void) LocalFree((HLOCAL) StrippedContainerName);
    }

    if ( ContextHandle )
    {
        if ( ContextHandle->TreeConnectionHandle )
            CloseHandle( ContextHandle->TreeConnectionHandle );

        ContextHandle->Signature = 0x0BADBAD0;

        (void) LocalFree((HLOCAL) ContextHandle);
    }

    *EnumHandle = NULL;

    if (status == ERROR_NOT_CONNECTED)
    {
        //
        // Object name not found.  We should return path not found.
        //
        status = ERROR_PATH_NOT_FOUND;
    }

    return status;
}


DWORD
NwrEnum(
    IN NWWKSTA_CONTEXT_HANDLE EnumHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function

Arguments:

    EnumHandle - Supplies a pointer to the context handle which identifies
        what type of object we are enumerating and the string of the
        container name to concatenate to the returned object.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned iff WN_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

Return Value:

    NO_ERROR - At least one entry was written to output buffer,
        irregardless of the number requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit a single entry.

    WN_BAD_HANDLE - The specified enumeration handle is invalid.

--*/ // NwrEnum
{
    DWORD status;
    LPNW_ENUM_CONTEXT ContextHandle = (LPNW_ENUM_CONTEXT) EnumHandle;
    BOOL  fImpersonate = FALSE ;

    if (ContextHandle->Signature != NW_HANDLE_SIGNATURE) {
        return WN_BAD_HANDLE;
    }

    //
    // Impersonate the client
    //
    if ((status = NwImpersonateClient()) != NO_ERROR)
    {
        goto CleanExit;
    }
    fImpersonate = TRUE ;

    *EntriesRead = 0;
    *BytesNeeded = 0;

    RtlZeroMemory(Buffer, BufferSize);

    switch (ContextHandle->HandleType) {
        case NwsHandleListConnections:
        {
            if (!(ContextHandle->ConnectionType & CONNTYPE_SYMBOLIC))
            {
                status = NwEnumerateConnections(
                             &ContextHandle->ResumeId,
                             EntriesRequested,
                             Buffer,
                             BufferSize,
                             BytesNeeded,
                             EntriesRead,
                             ContextHandle->ConnectionType,
                 NULL
                             );
                if (status != ERROR_NO_MORE_ITEMS)
                    break;
                else
                {
                    //
                    // finished with all redir connections. look for
                    // symbolic ones. we got NO MORE ITEMS back, so we just
                    // carry one with the next set with the same buffers.
                    //
                    ContextHandle->ConnectionType |= CONNTYPE_SYMBOLIC ;
                    ContextHandle->ResumeId = 0 ;
                }
            }

            if (ContextHandle->ConnectionType & CONNTYPE_SYMBOLIC)
            {
                //
                // This works around a weirdness in
                // QueryDosDevices called by NwrEnumGWDevices.
                // While impersonating the Win32 API will just fail.
                //
                (void) NwRevertToSelf() ;
                fImpersonate = FALSE ;

                status =  NwrEnumGWDevices(
                              NULL,
                              &((DWORD) ContextHandle->ResumeId),
                              Buffer,
                              BufferSize,
                              BytesNeeded,
                              EntriesRead) ;

                //
                // if we have more items, MPR expects success. map
                // accordingly.
                //
                if ((status == ERROR_MORE_DATA) && *EntriesRead)
                {
                    status = NO_ERROR ;
                }

                //
                // if nothing left, map to the distinguished MPR error
                //
                else if ((status == NO_ERROR) && (*EntriesRead == 0))
                {
                    status = ERROR_NO_MORE_ITEMS ;
                }
                break ;
            }
        }

        case NwsHandleListContextInfo_Tree:
        case NwsHandleListContextInfo_Server:

            status = NwEnumContextInfo(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );
            break;

        case NwsHandleListServersAndNdsTrees:

            status = NwEnumServersAndNdsTrees(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );
            break;

        case NwsHandleListVolumes:

            status = NwEnumVolumes(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );
            break;

        case NwsHandleListNdsSubTrees_Disk:

            status = NwEnumNdsSubTrees_Disk(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );

            break;

        case NwsHandleListNdsSubTrees_Print:

            status = NwEnumNdsSubTrees_Print(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );

            break;

        case NwsHandleListNdsSubTrees_Any:

            status = NwEnumNdsSubTrees_Any(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );

            break;

        case NwsHandleListQueues:

            status = NwEnumQueues(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );
            break;

        case NwsHandleListVolumesQueues:

            status = NwEnumVolumesQueues(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );
            break;

        case NwsHandleListDirectories:

            status = NwEnumDirectories(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );

            break;

        case NwsHandleListPrintServers:

            status = NwEnumPrintServers(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );
            break;

        case NwsHandleListPrintQueues:

            status = NwEnumPrintQueues(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );
            break;

        default:
            KdPrint(("NWWORKSTATION: NwrEnum unexpected handle type %lu\n",
                     ContextHandle->HandleType));
            ASSERT(FALSE);
            status = WN_BAD_HANDLE;
            goto CleanExit ;
    }

    if (*EntriesRead > 0) {

        switch ( ContextHandle->HandleType ) {
            case NwsHandleListConnections:
            case NwsHandleListContextInfo_Tree:
            case NwsHandleListContextInfo_Server:
            case NwsHandleListServersAndNdsTrees:
            case NwsHandleListVolumes:
            case NwsHandleListQueues:
            case NwsHandleListVolumesQueues:
            case NwsHandleListDirectories:
            case NwsHandleListNdsSubTrees_Disk:
            case NwsHandleListNdsSubTrees_Any:
            {
                DWORD i;
                LPNETRESOURCEW NetR = (LPNETRESOURCEW) Buffer;

                //
                // Replace pointers to strings with offsets as need
                //

                if ((ContextHandle->HandleType == NwsHandleListConnections)
                   && (ContextHandle->ConnectionType & CONNTYPE_SYMBOLIC))
                {
                    //
                    // NwrEnumGWDevices already return offsets.
                    //
                    break ;
                }

                for (i = 0; i < *EntriesRead; i++, NetR++) {

                    if (NetR->lpLocalName != NULL) {
                        NetR->lpLocalName = (LPWSTR)
                            ((DWORD_PTR) (NetR->lpLocalName) - (DWORD_PTR) Buffer);
                    }

                    NetR->lpRemoteName =
                        (LPWSTR) ((DWORD_PTR) (NetR->lpRemoteName) - (DWORD_PTR)Buffer);

                    if (NetR->lpComment != NULL) {
                        NetR->lpComment = (LPWSTR) ((DWORD_PTR) (NetR->lpComment) -
                                                    (DWORD_PTR) Buffer);
                    }

                    if (NetR->lpProvider != NULL) {
                        NetR->lpProvider =
                            (LPWSTR) ((DWORD_PTR) (NetR->lpProvider) -
                                      (DWORD_PTR) Buffer);
                    }
                }
                break;
            }

            case NwsHandleListPrintServers:
            case NwsHandleListPrintQueues:
            case NwsHandleListNdsSubTrees_Print:
            {
                DWORD i;
                PRINTER_INFO_1W *pPrinterInfo1 = (PRINTER_INFO_1W *) Buffer;

                //
                // Sort the entries in the buffer
                //
                if ( *EntriesRead > 1 )
                    qsort( Buffer, *EntriesRead,
                           sizeof( PRINTER_INFO_1W ), SortFunc );

                //
                // Replace pointers to strings with offsets
                //
                for (i = 0; i < *EntriesRead; i++, pPrinterInfo1++) {

                    MarshallDownStructure( (LPBYTE) pPrinterInfo1,
                                           PrinterInfo1Offsets,
                                           Buffer );
                }
                break;
            }

            default:
                KdPrint(("NWWORKSTATION: NwrEnum (pointer to offset code) unexpected handle type %lu\n", ContextHandle->HandleType));
                ASSERT( FALSE );
                break;
        }
    }

CleanExit:

    if (fImpersonate)
        (void) NwRevertToSelf() ;

    return status;
}


DWORD
NwrEnumConnections(
    IN NWWKSTA_CONTEXT_HANDLE EnumHandle,
    IN DWORD EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead,
    IN DWORD  fImplicitConnections
    )
/*++

Routine Description:

    This function is an alternate to NwrEnum. It only accepts handles
    that are opened with ListConnections. This function takes a flag
    indicating whether we need to show all implicit connections or not.

Arguments:

    ContextHandle - Supplies the enum context handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned iff ERROR_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

    fImplicitConnections - TRUE if we also want to get implicit connections,
        FALSE otherwise.

Return Value:

    NO_ERROR - At least one entry was written to output buffer,
        irregardless of the number requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    ERROR_MORE_DATA - The buffer was too small to fit a single entry.

--*/ // NwrEnumConnections
{
    DWORD status;
    LPNW_ENUM_CONTEXT ContextHandle = (LPNW_ENUM_CONTEXT) EnumHandle;

    if (  (ContextHandle->Signature != NW_HANDLE_SIGNATURE)
       || ( ContextHandle->HandleType != NwsHandleListConnections )
       )
    {
        return WN_BAD_HANDLE;
    }

    *EntriesRead = 0;
    *BytesNeeded = 0;

    RtlZeroMemory(Buffer, BufferSize);

    if ( fImplicitConnections )
        ContextHandle->ConnectionType |= CONNTYPE_IMPLICIT;

    if ((status = NwImpersonateClient()) != NO_ERROR)
        goto ErrorExit;

    status = NwEnumerateConnections(
               &ContextHandle->ResumeId,
               EntriesRequested,
               Buffer,
               BufferSize,
               BytesNeeded,
               EntriesRead,
               ContextHandle->ConnectionType,
           NULL
               );

    if (*EntriesRead > 0) {

        //
        // Replace pointers to strings with offsets
        //

        DWORD i;
        LPNETRESOURCEW NetR = (LPNETRESOURCEW) Buffer;

        for (i = 0; i < *EntriesRead; i++, NetR++) {

            if (NetR->lpLocalName != NULL) {
                NetR->lpLocalName = (LPWSTR)
                    ((DWORD_PTR) (NetR->lpLocalName) - (DWORD_PTR) Buffer);
            }

            NetR->lpRemoteName =
                (LPWSTR) ((DWORD_PTR) (NetR->lpRemoteName) - (DWORD_PTR)Buffer);

            if (NetR->lpComment != NULL) {
                NetR->lpComment = (LPWSTR) ((DWORD_PTR) (NetR->lpComment) -
                                            (DWORD_PTR) Buffer);
            }

            if (NetR->lpProvider != NULL) {
                NetR->lpProvider = (LPWSTR) ((DWORD_PTR) (NetR->lpProvider) -
                                             (DWORD_PTR) Buffer);
            }
        }
    }
    (void) NwRevertToSelf();

ErrorExit:    
    return status;
}


DWORD
NwEnumContextInfo(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates all of the bindery servers that are currently
    connected, then sets the context handle so that the next NPEnumResource
    call goes to the NDS subtree for the user's NDS context information
    (if using NDS).

Arguments:

    ContextHandle - Supplies the enum context handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned iff WN_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

Return Value:

    NO_ERROR - At least one entry was written to output buffer,
        irregardless of the number requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit a single entry.

--*/ // NwEnumContextInfo
{
    DWORD status = NO_ERROR;
    DWORD_PTR tempResumeId = 0;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    BOOL FitInBuffer = TRUE;
    DWORD EntrySize;
    DWORD LastObjectId = (DWORD) ContextHandle->ResumeId;

    while ( ContextHandle->dwUsingNds == CURRENTLY_ENUMERATING_NON_NDS &&
            FitInBuffer &&
            EntriesRequested > *EntriesRead &&
            status == NO_ERROR )
    {
        tempResumeId = ContextHandle->ResumeId;

        status = NwGetNextServerConnection( ContextHandle );

        if ( status == NO_ERROR && ContextHandle->ResumeId != 0 )
        {
            //
            // Pack bindery server name into output buffer.
            //
            status = NwWriteNetResourceEntry(
                         &FixedPortion,
                         &EndOfVariableData,
                         L"\\\\",
                         NULL,
                         (LPWSTR) ContextHandle->ResumeId, // A server name
                         RESOURCE_CONTEXT,
                         RESOURCEDISPLAYTYPE_SERVER,
                         RESOURCEUSAGE_CONTAINER,
                         RESOURCETYPE_ANY,
                         NULL,
                         NULL,
                         &EntrySize
                         );

            if (status == WN_MORE_DATA)
            {
                //
                // Could not write current entry into output buffer,
                // backup ResumeId to previous entry.
                //
                ContextHandle->ResumeId = tempResumeId;
                ContextHandle->NdsRawDataCount += 1;

                if (*EntriesRead)
                {
                    //
                    // Still return success because we got at least one.
                    //
                    status = NO_ERROR;
                }
                else
                {
                    *BytesNeeded = EntrySize;
                }

                FitInBuffer = FALSE;
            }
            else if (status == NO_ERROR)
            {
                //
                // Note that we've returned the current entry.
                //
                (*EntriesRead)++;
            }
        }
        else if ( status == WN_NO_MORE_ENTRIES )
        {
            //
            // We processed the last item in list, so
            // start enumerating servers.
            //
            ContextHandle->ResumeId = 0;
            LastObjectId = 0;

            if ( ContextHandle->HandleType == NwsHandleListContextInfo_Tree )
            {
                ContextHandle->dwUsingNds = CURRENTLY_ENUMERATING_NDS;
            }
        }
    }

    if ( ContextHandle->dwUsingNds == CURRENTLY_ENUMERATING_NDS )
    {
        ContextHandle->HandleType = NwsHandleListNdsSubTrees_Any;
        status = NO_ERROR;
    }

    //
    // User asked for more than there are entries.  We just say that
    // all is well.
    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    // entries.  The user has to call this API again and get WN_NO_MORE_ENTRIES
    // before knowing that the last call had actually reached the end of list.
    //
    if (*EntriesRead && status == WN_NO_MORE_ENTRIES)
    {
        status = NO_ERROR;
    }

    return status;
}


DWORD
NwEnumServersAndNdsTrees(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates all the servers and NDS trees on the local
    network by: 1) scanning the bindery for file server objects on the
    preferred server and 2) scanning the bindery for directory servers
    (NDS trees) on the preferred server. The server and tree entries are
    returned in an array of NETRESOURCE entries; each servername is
    prefixed by \\.

    The ContextHandle->ResumeId field is initially -1 before
    enumeration begins and contains the object ID of the last server
    or NDS tree object returned, depending on the value of
    ContextHandle->dwUsingNds.

Arguments:

    ContextHandle - Supplies the enum context handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned iff WN_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

Return Value:

    NO_ERROR - At least one entry was written to output buffer,
        irregardless of the number requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit a single entry.

--*/ // NwEnumServersAndNdsTrees
{
    DWORD status = NO_ERROR;
    DWORD_PTR tempResumeId = 0;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    BOOL FitInBuffer = TRUE;
    DWORD EntrySize;

    SERVERNAME ServerName;          // OEM server name
    LPWSTR UServerName = NULL;      // Unicode server name
    DWORD LastObjectId = (DWORD) ContextHandle->ResumeId;

    while ( ContextHandle->dwUsingNds == CURRENTLY_ENUMERATING_NDS &&
            FitInBuffer &&
            EntriesRequested > *EntriesRead &&
            status == NO_ERROR )
    {
        tempResumeId = ContextHandle->ResumeId;

        //
        // Call the scan bindery object NCP to scan for all NDS
        // tree objects.
        //
        status = NwGetNextNdsTreeEntry( ContextHandle );

        if ( status == NO_ERROR && ContextHandle->ResumeId != 0 )
        {
            //
            // Pack tree name into output buffer.
            //
            status = NwWriteNetResourceEntry(
                         &FixedPortion,
                         &EndOfVariableData,
                         L"\\\\",
                         NULL,
                         (LPWSTR) ContextHandle->ResumeId, // This is a NDS tree name
                         RESOURCE_GLOBALNET,
                         RESOURCEDISPLAYTYPE_TREE,
                         RESOURCEUSAGE_CONTAINER,
                         RESOURCETYPE_ANY,
                         NULL,
                         NULL,
                         &EntrySize
                         );

            if (status == WN_MORE_DATA)
            {
                //
                // Could not write current entry into output buffer, backup ResumeId to
                // previous entry.
                //
                ContextHandle->ResumeId = tempResumeId;
                ContextHandle->NdsRawDataCount += 1;

                if (*EntriesRead)
                {
                    //
                    // Still return success because we got at least one.
                    //
                    status = NO_ERROR;
                }
                else
                {
                    *BytesNeeded = EntrySize;
                }

                FitInBuffer = FALSE;
            }
            else if (status == NO_ERROR)
            {
                //
                // Note that we've returned the current entry.
                //
                (*EntriesRead)++;
            }
        }
        else if ( status == WN_NO_MORE_ENTRIES )
        {
            //
            // We processed the last item in list, so
            // start enumerating servers.
            //
            ContextHandle->dwUsingNds = CURRENTLY_ENUMERATING_NON_NDS;
            ContextHandle->ResumeId = (DWORD_PTR) -1;
            LastObjectId = (DWORD) -1;
        }
    }

    if ( status == WN_NO_MORE_ENTRIES)
    {
        status = NO_ERROR;
    }

    while ( ContextHandle->dwUsingNds == CURRENTLY_ENUMERATING_NON_NDS &&
            FitInBuffer &&
            EntriesRequested > *EntriesRead &&
            status == NO_ERROR )
    {
        RtlZeroMemory(ServerName, sizeof(ServerName));

        //
        // Call the scan bindery object NCP to scan for all file
        // server objects.
        //
        status = NwGetNextServerEntry(
                     ContextHandle->TreeConnectionHandle,
                     &LastObjectId,
                     ServerName
                     );

        if (status == NO_ERROR && NwConvertToUnicode(&UServerName, ServerName))
        {
            //
            // Pack server name into output buffer.
            //
            status = NwWriteNetResourceEntry(
                         &FixedPortion,
                         &EndOfVariableData,
                         L"\\\\",
                         NULL,
                         UServerName,
                         RESOURCE_GLOBALNET,
                         RESOURCEDISPLAYTYPE_SERVER,
                         RESOURCEUSAGE_CONTAINER,
                         RESOURCETYPE_ANY,
                         NULL,
                         NULL,
                         &EntrySize
                         );

            if (status == WN_MORE_DATA)
            {
                //
                // Could not write current entry into output buffer.
                //

                if (*EntriesRead)
                {
                    //
                    // Still return success because we got at least one.
                    //
                    status = NO_ERROR;
                }
                else
                {
                    *BytesNeeded = EntrySize;
                }

                FitInBuffer = FALSE;
            }
            else if (status == NO_ERROR)
            {
                //
                // Note that we've returned the current entry.
                //
                (*EntriesRead)++;

                ContextHandle->ResumeId = (DWORD_PTR) LastObjectId;
            }

            (void) LocalFree((HLOCAL) UServerName);
        }
    }

    //
    // User asked for more than there are entries.  We just say that
    // all is well.
    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    // entries.  The user has to call this API again and get WN_NO_MORE_ENTRIES
    // before knowing that the last call had actually reached the end of list.
    //
    if (*EntriesRead && status == WN_NO_MORE_ENTRIES)
    {
        status = NO_ERROR;
    }

    return status;
}



DWORD
NwEnumVolumes(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates all the volumes on a server by
    iteratively getting the volume name for each volume number from
    0 - 31 until we run into the first volume number that does not
    map to a volume name (this method assumes that volume numbers
    are used contiguously in ascending order).  The volume entries
    are returned in an array of NETRESOURCE entries; each volume
    name if prefixed by \\Server\.

    The ContextHandle->ResumeId field always indicates the next
    volume entry to return.  It is initially set to 0, which indicates
    the first volume number to get.

Arguments:

    ContextHandle - Supplies the enum context handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned iff WN_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

Return Value:

    NO_ERROR - At least one entry was written to output buffer,
        irregardless of the number requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit a single entry.

--*/ // NwEnumVolumes
{
    DWORD status = NO_ERROR;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    BOOL FitInBuffer = TRUE;
    DWORD EntrySize;

    CHAR VolumeName[NW_VOLUME_NAME_LEN]; // OEM volume name
    LPWSTR UVolumeName = NULL;           // Unicode volume name
    DWORD NextVolumeNumber = (DWORD) ContextHandle->ResumeId;
    DWORD MaxVolumeNumber = ContextHandle->dwMaxVolumes;
    ULONG Failures = 0;

    if (NextVolumeNumber == MaxVolumeNumber) {
        //
        // Reached the end of enumeration
        //
        return WN_NO_MORE_ENTRIES;
    }

    while (FitInBuffer &&
           EntriesRequested > *EntriesRead &&
           NextVolumeNumber < MaxVolumeNumber &&
           status == NO_ERROR) {

        RtlZeroMemory(VolumeName, sizeof(VolumeName));

        //
        // Call the scan bindery object NCP to scan for all file
        // volume objects.
        //
        
        status = NwGetNextVolumeEntry(
                     ContextHandle->TreeConnectionHandle,
                     NextVolumeNumber++,
                     VolumeName
                     );

        if (status == NO_ERROR) {

            if (VolumeName[0] == 0) {

                //
                // Got an empty volume name back for the next volume number
                // which indicates there is no volume associated with the
                // volume number but still got error success.
                //
                // Treat this as having reached the end of the enumeration
                // only if we've gotten two three empty volumes in a row
                // or reached the max number of volumes because there are
                // some cases where there are holes in the way that volumes
                // are allocated.
                //

                Failures++;
                    
                if ( Failures <= 3 ) {
                
                    continue;

                } else {
 
                    NextVolumeNumber = MaxVolumeNumber;
                    ContextHandle->ResumeId = MaxVolumeNumber;
   
                    if (*EntriesRead == 0) {
                        status = WN_NO_MORE_ENTRIES;
                    }
                }

            } else if (NwConvertToUnicode(&UVolumeName, VolumeName)) {

                //
                // Pack volume name into output buffer.
                //
                status = NwWriteNetResourceEntry(
                             &FixedPortion,
                             &EndOfVariableData,
                             ContextHandle->ContainerName,
                             NULL,
                             UVolumeName,
                             RESOURCE_GLOBALNET,
                             RESOURCEDISPLAYTYPE_SHARE,
#ifdef NT1057
                             RESOURCEUSAGE_CONNECTABLE |
                             RESOURCEUSAGE_CONTAINER,
#else
                             RESOURCEUSAGE_CONNECTABLE |
                             RESOURCEUSAGE_NOLOCALDEVICE,
#endif
                             RESOURCETYPE_DISK,
                             NULL,
                             NULL,
                             &EntrySize
                             );

                if (status == WN_MORE_DATA) {

                    //
                    // Could not write current entry into output buffer.
                    //

                    if (*EntriesRead) {
                        //
                        // Still return success because we got at least one.
                        //
                        status = NO_ERROR;
                    }
                    else {
                        *BytesNeeded = EntrySize;
                    }

                    FitInBuffer = FALSE;
                }
                else if (status == NO_ERROR) {

                    //
                    // Note that we've returned the current entry.
                    //
                    (*EntriesRead)++;

                    ContextHandle->ResumeId = NextVolumeNumber;
                }

                (void) LocalFree((HLOCAL) UVolumeName);
            }

            //
            // We got an entry, so reset the failure counter.
            //

            Failures = 0;
        }
    }

    //
    // User asked for more than there are entries.  We just say that
    // all is well.
    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    // entries.  The user has to call this API again and get WN_NO_MORE_ENTRIES
    // before knowing that the last call had actually reached the end of list.
    //
    if (*EntriesRead && status == WN_NO_MORE_ENTRIES) {
        status = NO_ERROR;
    }

    return status;
}


DWORD
NwEnumNdsSubTrees_Disk(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates the sub-trees of a given NDS tree
    handle. It returns the fully-qualified UNC path of the sub-tree
    entries in an array of NETRESOURCE entries.

    The ContextHandle->ResumeId field is 0 initially, and contains
    a pointer to the subtree name string of the last sub-tree
    returned.  If there are no more sub-trees to return, this
    field is set to -1.

Arguments:

    ContextHandle - Supplies the enum context handle.  It contains
        an opened NDS tree handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned iff WN_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

Return Value:

    NO_ERROR - At least one entry was written to output buffer,
        irregardless of the number requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit a single entry.

--*/ // NwEnumNdsSubTrees_Disk
{
    DWORD status = NO_ERROR;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    BOOL   FitInBuffer = TRUE;
    DWORD  EntrySize = 0;

    LPWSTR SubTreeName = NULL;
    DWORD  ResourceScope = 0;
    DWORD  ResourceType = 0;
    DWORD  ResourceDisplayType = 0;
    DWORD  ResourceUsage = 0;
    LPWSTR StrippedObjectName = NULL;

    if (ContextHandle->ResumeId == (DWORD_PTR) -1)
    {
        //
        // Reached the end of enumeration.
        //
        return WN_NO_MORE_ENTRIES;
    }

    while (FitInBuffer &&
           EntriesRequested > *EntriesRead &&
           status == NO_ERROR)
    {
        if ( ContextHandle->ResumeId == 0 )
        {
            //
            // Get the first subtree entry.
            //
            status = NwGetFirstNdsSubTreeEntry( ContextHandle, BufferSize );
        }

        //
        // Either ResumeId contains the first entry we just got from
        // NwGetFirstDirectoryEntry or it contains the next directory
        // entry to return.
        //
        if (status == NO_ERROR && ContextHandle->ResumeId != 0)
        {
            BYTE   ClassType;
            LPWSTR newPathStr = NULL;
            LPWSTR tempStr = NULL;
            WORD   tempStrLen;

            //
            // Get current subtree data from ContextHandle
            //
            ClassType = NwGetSubTreeData( ContextHandle->ResumeId,
                                          &SubTreeName,
                                          &ResourceScope,
                                          &ResourceType,
                                          &ResourceDisplayType,
                                          &ResourceUsage,
                                          &StrippedObjectName );

            if ( StrippedObjectName == NULL )
            {
                KdPrint(("NWWORKSTATION: NwEnumNdsSubTrees_Disk LocalAlloc Failed %lu\n",
                        GetLastError()));

                return ERROR_NOT_ENOUGH_MEMORY;
            }

            switch( ClassType )
            {
                case CLASS_TYPE_COUNTRY:
                case CLASS_TYPE_DIRECTORY_MAP:
                case CLASS_TYPE_NCP_SERVER:
                case CLASS_TYPE_ORGANIZATION:
                case CLASS_TYPE_ORGANIZATIONAL_UNIT:
                case CLASS_TYPE_VOLUME:

                    //
                    // Need to build a string with the new NDS UNC path for subtree object
                    //
                    newPathStr = (PVOID) LocalAlloc( LMEM_ZEROINIT,
                                       ( wcslen( StrippedObjectName ) +
                                         wcslen( ContextHandle->ContainerName ) +
                                         3 ) * sizeof(WCHAR) );

                    if ( newPathStr == NULL )
                    {
                        KdPrint(("NWWORKSTATION: NwEnumNdsSubTrees_Disk LocalAlloc Failed %lu\n",
                                GetLastError()));

                        return ERROR_NOT_ENOUGH_MEMORY;
                    }

                    tempStrLen = NwParseNdsUncPath( (LPWSTR *) &tempStr,
                                                    ContextHandle->ContainerName,
                                                    PARSE_NDS_GET_TREE_NAME );

                    tempStrLen /= sizeof( WCHAR );

                    if ( tempStrLen > 0 )
                    {
                        wcscpy( newPathStr, L"\\\\" );
                        wcsncat( newPathStr, tempStr, tempStrLen );
                        wcscat( newPathStr, L"\\" );
                        wcscat( newPathStr, StrippedObjectName );
                    }

                    (void) LocalFree((HLOCAL) StrippedObjectName );
                    StrippedObjectName = NULL;

                    tempStrLen = NwParseNdsUncPath( (LPWSTR *) &tempStr,
                                                    ContextHandle->ContainerName,
                                                    PARSE_NDS_GET_PATH_NAME );

                    tempStrLen /= sizeof( WCHAR );

                    if ( tempStrLen > 0 )
                    {
                        wcscat( newPathStr, L"." );
                        wcsncat( newPathStr, tempStr, tempStrLen );
                    }

                    //
                    // Pack subtree name into output buffer.
                    //
                    status = NwWriteNetResourceEntry(
                                 &FixedPortion,
                                 &EndOfVariableData,
                                 NULL,
                                 NULL,
                                 newPathStr,
                                 ResourceScope,
                                 ResourceDisplayType,
                                 ResourceUsage,
                                 ResourceType,
                                 NULL,
                                 NULL,
                                 &EntrySize );

                    if ( status == NO_ERROR )
                    {
                        //
                        // Note that we've returned the current entry.
                        //
                        (*EntriesRead)++;
                    }

                    if ( newPathStr )
                        (void) LocalFree( (HLOCAL) newPathStr );

                break;

                case CLASS_TYPE_ALIAS:
                case CLASS_TYPE_AFP_SERVER:
                case CLASS_TYPE_BINDERY_OBJECT:
                case CLASS_TYPE_BINDERY_QUEUE:
                case CLASS_TYPE_COMPUTER:
                case CLASS_TYPE_GROUP:
                case CLASS_TYPE_LOCALITY:
                case CLASS_TYPE_ORGANIZATIONAL_ROLE:
                case CLASS_TYPE_PRINTER:
                case CLASS_TYPE_PRINT_SERVER:
                case CLASS_TYPE_PROFILE:
                case CLASS_TYPE_QUEUE:
                case CLASS_TYPE_TOP:
                case CLASS_TYPE_UNKNOWN:
                case CLASS_TYPE_USER:
                break;

                default:
                    KdPrint(("NWWORKSTATION: NwEnumNdsSubTrees_Disk - Unhandled switch statement case %lu\n", ClassType ));
                    ASSERT( FALSE );
                break;
            }

            if (status == WN_MORE_DATA)
            {
                //
                // Could not write current entry into output buffer.
                //

                if (*EntriesRead)
                {
                    //
                    // Still return success because we got at least one.
                    //
                    status = NO_ERROR;
                }
                else
                {
                    *BytesNeeded = EntrySize;
                }

                FitInBuffer = FALSE;
            }
            else if (status == NO_ERROR)
            {
                //
                // Get next directory entry.
                //
                status = NwGetNextNdsSubTreeEntry( ContextHandle );
            }
        }

        if (status == WN_NO_MORE_ENTRIES)
        {
            ContextHandle->ResumeId = (DWORD_PTR) -1;
        }
    }

    //
    // User asked for more than there are entries.  We just say that
    // all is well.
    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    // entries.  The user has to call this API again and get WN_NO_MORE_ENTRIES
    // before knowing that the last call had actually reached the end of list.
    //
    if (*EntriesRead && status == WN_NO_MORE_ENTRIES) {
        status = NO_ERROR;
    }

#if DBG
    IF_DEBUG(ENUM)
    {
        KdPrint(("NwEnumNdsSubTrees_Disk returns %lu\n", status));
    }
#endif

    return status;
}


DWORD
NwEnumNdsSubTrees_Print(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates all the NDS subtree objects that are either containers,
    queues, printers, or servers from a given NDS tree or subtree. The entries are
    returned in an array of PRINTER_INFO_1 entries and each name is prefixed
    by the parent path in NDS UNC style (ex. \\tree\CN=foo.OU=bar.O=blah).

    The ContextHandle->ResumeId field is initially (DWORD_PTR) -1 before
    enumeration begins and contains the object ID of the last NDS object returned.

Arguments:

    ContextHandle - Supplies the enum context handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is (DWORD_PTR) -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes copied or required to get all
        the requested entries.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.

Return Value:

    NO_ERROR - Buffer contains all the entries requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit the requested entries.

--*/ // NwEnumNdsSubTrees_Print
{
    DWORD status = NO_ERROR;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    DWORD EntrySize;
    BOOL FitInBuffer = TRUE;

    LPWSTR SubTreeName = NULL;
    DWORD  ResourceScope = 0;
    DWORD  ResourceType = 0;
    DWORD  ResourceDisplayType = 0;
    DWORD  ResourceUsage = 0;
    LPWSTR StrippedObjectName = NULL;
    BYTE   ClassType = 0;
    LPWSTR newPathStr = NULL;
    LPWSTR tempStr = NULL;
    WORD   tempStrLen = 0;

    while ( EntriesRequested > *EntriesRead &&
            ( (status == NO_ERROR) || (status == ERROR_INSUFFICIENT_BUFFER)))
    {
        if (ContextHandle->ResumeId == 0)
        {
            //
            // Get the first subtree entry.
            //
            status = NwGetFirstNdsSubTreeEntry( ContextHandle, BufferSize );
        }

        //
        // Either ResumeId contains the first entry we just got from
        // NwGetFirstDirectoryEntry or it contains the next directory
        // entry to return.
        //
        if (status == NO_ERROR && ContextHandle->ResumeId != 0)
        {

            //
            // Get current subtree data from ContextHandle
            //
            ClassType = NwGetSubTreeData( ContextHandle->ResumeId,
                                          &SubTreeName,
                                          &ResourceScope,
                                          &ResourceType,
                                          &ResourceDisplayType,
                                          &ResourceUsage,
                                          &StrippedObjectName );

            if ( StrippedObjectName == NULL )
            {
                KdPrint(("NWWORKSTATION: NwEnumNdsSubTrees_Print LocalAlloc Failed %lu\n",
                        GetLastError()));

                return ERROR_NOT_ENOUGH_MEMORY;
            }

            switch( ClassType )
            {

                case CLASS_TYPE_COUNTRY:
                case CLASS_TYPE_ORGANIZATION:
                case CLASS_TYPE_ORGANIZATIONAL_UNIT:
                case CLASS_TYPE_NCP_SERVER:
                case CLASS_TYPE_QUEUE:
                    //
                    // Need to build a string with the new NDS UNC path for subtree object
                    //
                    newPathStr = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                                       ( wcslen( StrippedObjectName ) +
                                       wcslen( ContextHandle->ContainerName ) +
                                       2 ) * sizeof(WCHAR) );

                    if ( newPathStr == NULL )
                    {
                        KdPrint(("NWWORKSTATION: NwEnumNdsSubTrees_Print LocalAlloc Failed %lu\n",
                                GetLastError()));

                        return ERROR_NOT_ENOUGH_MEMORY;
                    }

                    tempStrLen = NwParseNdsUncPath( (LPWSTR *) &tempStr,
                                                    ContextHandle->ContainerName,
                                                    PARSE_NDS_GET_TREE_NAME );

                    tempStrLen /= sizeof( WCHAR );

                    if ( tempStrLen > 0 )
                    {
                        wcsncpy( newPathStr, tempStr, tempStrLen );
                        wcscat( newPathStr, L"\\" );
                        wcscat( newPathStr, StrippedObjectName );
                    }

                    (void) LocalFree((HLOCAL) StrippedObjectName );
                    StrippedObjectName = NULL;

                    tempStrLen = NwParseNdsUncPath( (LPWSTR *) &tempStr,
                                                    ContextHandle->ContainerName,
                                                    PARSE_NDS_GET_PATH_NAME );

                    tempStrLen /= sizeof( WCHAR );

                    if ( tempStrLen > 0 )
                    {
                        wcscat( newPathStr, L"." );
                        wcsncat( newPathStr, tempStr, tempStrLen );
                    }

                    switch( ClassType )
                    {
                        case CLASS_TYPE_COUNTRY:
                        case CLASS_TYPE_ORGANIZATION:
                        case CLASS_TYPE_ORGANIZATIONAL_UNIT:
                            //
                            // Pack sub-tree container name into output buffer.
                            //
                            status = NwWritePrinterInfoEntry(
                                         &FixedPortion,
                                         &EndOfVariableData,
                                         NULL,
                                         newPathStr,
                                         PRINTER_ENUM_CONTAINER | PRINTER_ENUM_ICON1,
                                         &EntrySize );

                        break;

                        case CLASS_TYPE_NCP_SERVER:
                            //
                            // Pack server name into output buffer.
                            //
                            status = NwWritePrinterInfoEntry(
                                         &FixedPortion,
                                         &EndOfVariableData,
                                         NULL,
                                         newPathStr,
                                         PRINTER_ENUM_CONTAINER | PRINTER_ENUM_ICON3,
                                         &EntrySize );

                        break;

                        case CLASS_TYPE_QUEUE:
                            //
                            // Pack print server queue name into output buffer.
                            //
                            status = NwWritePrinterInfoEntry(
                                         &FixedPortion,
                                         &EndOfVariableData,
                                         L"\\\\",
                                         newPathStr,
                                         PRINTER_ENUM_ICON8,
                                         &EntrySize );
                        break;

                        default:
KdPrint(("NWWORKSTATION: NwEnumNdsSubTrees_Print - Unhandled switch statement case %lu\n", ClassType ));
                            ASSERT(FALSE);
                        break;
                    }

                    switch ( status )
                    {
                        case ERROR_INSUFFICIENT_BUFFER:
                            FitInBuffer = FALSE;
                            // Falls through

                        case NO_ERROR:
                            *BytesNeeded += EntrySize;
                            (*EntriesRead)++;
                            break;

                        default:
                            break;
                    }

                    if ( newPathStr )
                        (void) LocalFree( (HLOCAL) newPathStr );

                break;

                case CLASS_TYPE_ALIAS:
                case CLASS_TYPE_AFP_SERVER:
                case CLASS_TYPE_BINDERY_OBJECT:
                case CLASS_TYPE_BINDERY_QUEUE:
                case CLASS_TYPE_COMPUTER:
                case CLASS_TYPE_DIRECTORY_MAP:
                case CLASS_TYPE_GROUP:
                case CLASS_TYPE_LOCALITY:
                case CLASS_TYPE_ORGANIZATIONAL_ROLE:
                case CLASS_TYPE_PRINTER:
                case CLASS_TYPE_PRINT_SERVER:
                case CLASS_TYPE_PROFILE:
                case CLASS_TYPE_TOP:
                case CLASS_TYPE_UNKNOWN:
                case CLASS_TYPE_USER:
                case CLASS_TYPE_VOLUME:
                break;

                default:
KdPrint(("NWWORKSTATION: NwEnumNdsSubTrees_Print - Unhandled switch statement case %lu\n", ClassType ));
                    ASSERT( FALSE );
                break;
            }

            if ( status == NO_ERROR || status == ERROR_INSUFFICIENT_BUFFER )
            {
                //
                // Get next directory entry.
                //
                status = NwGetNextNdsSubTreeEntry( ContextHandle );
            }
        }
    }

    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    // entries.  The user has to call this API again and get WN_NO_MORE_ENTRIES
    // before knowing that the last call had actually reached the end of list.
    //
    if ( !FitInBuffer )
    {
        *EntriesRead = 0;
        status = ERROR_INSUFFICIENT_BUFFER;
    }
    else if (*EntriesRead && status == WN_NO_MORE_ENTRIES)
    {
        status = NO_ERROR;
    }

    return status;
}


DWORD
NwEnumNdsSubTrees_Any(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates the sub-trees of a given NDS tree
    handle. It returns the fully-qualified UNC path of ANY sub-tree
    entries in an array of NETRESOURCE entries.

    The ContextHandle->ResumeId field is 0 initially, and contains
    a pointer to the subtree name string of the last sub-tree
    returned.  If there are no more sub-trees to return, this
    field is set to (DWORD_PTR) -1.

Arguments:

    ContextHandle - Supplies the enum context handle.  It contains
        an opened NDS tree handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is (DWORD_PTR) -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned iff WN_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

Return Value:

    NO_ERROR - At least one entry was written to output buffer,
        irregardless of the number requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit a single entry.

--*/ // NwEnumNdsSubTrees_Any
{
    DWORD status = NO_ERROR;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    BOOL   FitInBuffer = TRUE;
    DWORD  EntrySize = 0;

    LPWSTR SubTreeName = NULL;
    DWORD  ResourceScope = 0;
    DWORD  ResourceType = 0;
    DWORD  ResourceDisplayType = 0;
    DWORD  ResourceUsage = 0;
    LPWSTR StrippedObjectName = NULL;

    if (ContextHandle->ResumeId == (DWORD_PTR) -1)
    {
        //
        // Reached the end of enumeration.
        //
        return WN_NO_MORE_ENTRIES;
    }

    while (FitInBuffer &&
           EntriesRequested > *EntriesRead &&
           status == NO_ERROR)
    {
        if ( ContextHandle->ResumeId == 0 )
        {
            //
            // Get the first subtree entry.
            //
            status = NwGetFirstNdsSubTreeEntry( ContextHandle, BufferSize );
        }

        //
        // Either ResumeId contains the first entry we just got from
        // NwGetFirstDirectoryEntry or it contains the next directory
        // entry to return.
        //
        if (status == NO_ERROR && ContextHandle->ResumeId != 0)
        {
            BYTE   ClassType;
            LPWSTR newPathStr = NULL;
            LPWSTR tempStr = NULL;
            WORD   tempStrLen;

            //
            // Get current subtree data from ContextHandle
            //
            ClassType = NwGetSubTreeData( ContextHandle->ResumeId,
                                          &SubTreeName,
                                          &ResourceScope,
                                          &ResourceType,
                                          &ResourceDisplayType,
                                          &ResourceUsage,
                                          &StrippedObjectName );

            if ( StrippedObjectName == NULL )
            {
                KdPrint(("NWWORKSTATION: NwEnumNdsSubTrees_Any LocalAlloc Failed %lu\n",
                        GetLastError()));

                return ERROR_NOT_ENOUGH_MEMORY;
            }

            switch( ClassType )
            {
                case CLASS_TYPE_COUNTRY:
                case CLASS_TYPE_ORGANIZATION:
                case CLASS_TYPE_ORGANIZATIONAL_UNIT:
                case CLASS_TYPE_VOLUME:
                case CLASS_TYPE_DIRECTORY_MAP:
                case CLASS_TYPE_NCP_SERVER:
                case CLASS_TYPE_QUEUE:

                    //
                    // Need to build a string with the new NDS UNC path for subtree object
                    //
                    newPathStr = (PVOID) LocalAlloc( LMEM_ZEROINIT,
                                       ( wcslen( StrippedObjectName ) +
                                         wcslen( ContextHandle->ContainerName ) +
                                         3 ) * sizeof(WCHAR) );

                    if ( newPathStr == NULL )
                    {
                        KdPrint(("NWWORKSTATION: NwEnumNdsSubTrees_Any LocalAlloc Failed %lu\n",
                                GetLastError()));

                        return ERROR_NOT_ENOUGH_MEMORY;
                    }

                    tempStrLen = NwParseNdsUncPath( (LPWSTR *) &tempStr,
                                                    ContextHandle->ContainerName,
                                                    PARSE_NDS_GET_TREE_NAME );

                    tempStrLen /= sizeof( WCHAR );

                    if ( tempStrLen > 0 )
                    {
                        wcscpy( newPathStr, L"\\\\" );
                        wcsncat( newPathStr, tempStr, tempStrLen );
                        wcscat( newPathStr, L"\\" );
                        wcscat( newPathStr, StrippedObjectName );
                    }

                    (void) LocalFree((HLOCAL) StrippedObjectName );
                    StrippedObjectName = NULL;

                    tempStrLen = NwParseNdsUncPath( (LPWSTR *) &tempStr,
                                                    ContextHandle->ContainerName,
                                                    PARSE_NDS_GET_PATH_NAME );

                    tempStrLen /= sizeof( WCHAR );

                    if ( tempStrLen > 0 )
                    {
                        wcscat( newPathStr, L"." );
                        wcsncat( newPathStr, tempStr, tempStrLen );
                    }

                    //
                    // Pack subtree name into output buffer.
                    //
                    status = NwWriteNetResourceEntry(
                                 &FixedPortion,
                                 &EndOfVariableData,
                                 NULL,
                                 NULL,
                                 newPathStr,
                                 ResourceScope,
                                 ResourceDisplayType,
                                 ResourceUsage,
                                 ResourceType,
                                 NULL,
                                 NULL,
                                 &EntrySize );

                    if ( status == NO_ERROR )
                    {
                        //
                        // Note that we've returned the current entry.
                        //
                        (*EntriesRead)++;
                    }

                    if ( newPathStr )
                        (void) LocalFree( (HLOCAL) newPathStr );

                break;

                case CLASS_TYPE_ALIAS:
                case CLASS_TYPE_AFP_SERVER:
                case CLASS_TYPE_BINDERY_OBJECT:
                case CLASS_TYPE_BINDERY_QUEUE:
                case CLASS_TYPE_COMPUTER:
                case CLASS_TYPE_GROUP:
                case CLASS_TYPE_LOCALITY:
                case CLASS_TYPE_ORGANIZATIONAL_ROLE:
                case CLASS_TYPE_PRINTER:
                case CLASS_TYPE_PRINT_SERVER:
                case CLASS_TYPE_PROFILE:
                case CLASS_TYPE_TOP:
                case CLASS_TYPE_UNKNOWN:
                case CLASS_TYPE_USER:
                break;

                default:
                    KdPrint(("NWWORKSTATION: NwEnumNdsSubTrees_Any - Unhandled switch statement case %lu\n", ClassType ));
                    ASSERT( FALSE );
                break;
            }

            if (status == WN_MORE_DATA)
            {
                //
                // Could not write current entry into output buffer.
                //

                if (*EntriesRead)
                {
                    //
                    // Still return success because we got at least one.
                    //
                    status = NO_ERROR;
                }
                else
                {
                    *BytesNeeded = EntrySize;
                }

                FitInBuffer = FALSE;
            }
            else if (status == NO_ERROR)
            {
                //
                // Get next directory entry.
                //
                status = NwGetNextNdsSubTreeEntry( ContextHandle );
            }
        }

        if (status == WN_NO_MORE_ENTRIES)
        {
            ContextHandle->ResumeId = (DWORD_PTR) -1;
        }
    }

    //
    // User asked for more than there are entries.  We just say that
    // all is well.
    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    // entries.  The user has to call this API again and get WN_NO_MORE_ENTRIES
    // before knowing that the last call had actually reached the end of list.
    //
    if (*EntriesRead && status == WN_NO_MORE_ENTRIES) {
        status = NO_ERROR;
    }

#if DBG
    IF_DEBUG(ENUM)
    {
        KdPrint(("NwEnumNdsSubTrees_Any returns %lu\n", status));
    }
#endif

    return status;
}


DWORD
NwEnumVolumesQueues(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates all the volumes and queues on a server.
    The queue entries are returned in an array of NETRESOURCE entries;
    each queue name is prefixed by \\Server\.

Arguments:

    ContextHandle - Supplies the enum context handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is (DWORD_PTR) -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned if WN_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

Return Value:

    NO_ERROR - At least one entry was written to output buffer,
        irregardless of the number requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit a single entry.

--*/ // NwEnumVolumesQueues
{
    DWORD status = NO_ERROR;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    BOOL FitInBuffer = TRUE;
    DWORD EntrySize;

    CHAR VolumeName[NW_VOLUME_NAME_LEN]; // OEM volume name
    LPWSTR UVolumeName = NULL;           // Unicode volume name
    DWORD NextObject = (DWORD) ContextHandle->ResumeId;
    DWORD MaxVolumeNumber = ContextHandle->dwMaxVolumes;
    ULONG Failures = 0;

    //
    // tommye - bug 139466
    //
    // removed if (NextObject >= 0) becaue NextObject is a DWORD
    //

    while (FitInBuffer &&
           EntriesRequested > *EntriesRead &&
           ContextHandle->ConnectionType == CONNTYPE_DISK &&
           (NextObject < MaxVolumeNumber) &&
           status == NO_ERROR) {


        RtlZeroMemory(VolumeName, sizeof(VolumeName));

        //
        // Call the scan bindery object NCP to scan for all file
        // volume objects.
        //
        status = NwGetNextVolumeEntry(
                     ContextHandle->TreeConnectionHandle,
                     NextObject++,
                     VolumeName
                     );

        if (status == NO_ERROR) {

            if (VolumeName[0] == 0) {

                //
                // Got an empty volume name back for the next volume number
                // which indicates there is no volume associated with the
                // volume number but still got error success.
                //
                // Treat this as having reached the end of the enumeration
                // if we have had three failures in a row.  This will allow
                // us to function when there are small holes in the drive
                // list.
                //

                Failures++;

                if ( Failures <= 3 ) {

                    continue;

                } else {

                    NextObject = (DWORD) -1;
                    ContextHandle->ResumeId = (DWORD_PTR) -1;
                    ContextHandle->ConnectionType = CONNTYPE_PRINT;

                }

            } else if (NwConvertToUnicode(&UVolumeName, VolumeName)) {

                //
                // Pack volume name into output buffer.
                //
                status = NwWriteNetResourceEntry(
                             &FixedPortion,
                             &EndOfVariableData,
                             ContextHandle->ContainerName,
                             NULL,
                             UVolumeName,
                             RESOURCE_GLOBALNET,
                             RESOURCEDISPLAYTYPE_SHARE,
#ifdef NT1057
                             RESOURCEUSAGE_CONNECTABLE |
                             RESOURCEUSAGE_CONTAINER,
#else
                             RESOURCEUSAGE_CONNECTABLE |
                             RESOURCEUSAGE_NOLOCALDEVICE,
#endif
                             RESOURCETYPE_DISK,
                             NULL,
                             NULL,
                             &EntrySize
                             );

                if (status == WN_MORE_DATA) {

                    //
                    // Could not write current entry into output buffer.
                    //

                    if (*EntriesRead) {
                        //
                        // Still return success because we got at least one.
                        //
                        status = NO_ERROR;
                    }
                    else {
                        *BytesNeeded = EntrySize;
                    }

                    FitInBuffer = FALSE;
                }
                else if (status == NO_ERROR) {

                    //
                    // Note that we've returned the current entry.
                    //
                    (*EntriesRead)++;

                    ContextHandle->ResumeId = NextObject;
                }

                (void) LocalFree((HLOCAL) UVolumeName);
            }

            //
            // Reset the failures counter.
            //

            Failures = 0;
        }
    }

    //
    // User asked for more than there are entries.  We just say that
    // all is well.
    //
    if (*EntriesRead && status == WN_NO_MORE_ENTRIES)
    {
        status = NO_ERROR;
    }

    if ( *EntriesRead == 0 &&
         status == NO_ERROR &&
         ContextHandle->ConnectionType == CONNTYPE_DISK )
    {
        ContextHandle->ConnectionType = CONNTYPE_PRINT;
        ContextHandle->ResumeId = (DWORD_PTR) -1;
    }

    //
    // The user needs to be validated on a netware311 server to
    // get the print queues. So, we need to close the handle and
    // open a new one with WRITE access. If any error occurred while
    // we are enumerating the print queues, we will abort and
    // assume there are no print queues on the server.
    //

    if ( FitInBuffer &&
         EntriesRequested > *EntriesRead &&
         ContextHandle->ConnectionType == CONNTYPE_PRINT &&
         status == NO_ERROR )
    {
         UNICODE_STRING TreeConnectStr;
         DWORD QueueEntriesRead = 0;

         (void) NtClose(ContextHandle->TreeConnectionHandle);

         //
         // Open a tree connection handle to \Device\NwRdr\ContainerName
         //
         status = NwCreateTreeConnectName(
                      ContextHandle->ContainerName,
                      NULL,
                      &TreeConnectStr );

         if (status != NO_ERROR)
             return (*EntriesRead? NO_ERROR: WN_NO_MORE_ENTRIES );


         status = NwOpenCreateConnection(
                      &TreeConnectStr,
                      NULL,
                      NULL,
                      ContextHandle->ContainerName,
                      FILE_LIST_DIRECTORY | SYNCHRONIZE |  FILE_WRITE_DATA,
                      FILE_OPEN,
                      FILE_SYNCHRONOUS_IO_NONALERT,
                      RESOURCETYPE_PRINT, // Only matters when connecting beyond servername
                      &ContextHandle->TreeConnectionHandle,
                      NULL );

         (void) LocalFree((HLOCAL) TreeConnectStr.Buffer);

         if (status != NO_ERROR)
             return (*EntriesRead? NO_ERROR: WN_NO_MORE_ENTRIES );

         status = NwEnumQueues(
                      ContextHandle,
                      EntriesRequested == (DWORD_PTR) -1?
                          EntriesRequested : (EntriesRequested - *EntriesRead),
                      FixedPortion,
                      (DWORD) ((LPBYTE) EndOfVariableData - (LPBYTE) FixedPortion),
                      BytesNeeded,
                      &QueueEntriesRead );

         if ( status == NO_ERROR )
         {
             *EntriesRead += QueueEntriesRead;
         }
         else if ( *EntriesRead )
         {
             //
             // As long as we read something into the buffer,
             // we should return success.
             //
             status = NO_ERROR;
             *BytesNeeded = 0;
         }

    }

    if ( status == NO_ERROR &&
         *EntriesRead == 0 &&
         ContextHandle->ConnectionType == CONNTYPE_PRINT )
    {
        return WN_NO_MORE_ENTRIES;
    }

    return status;

}



DWORD
NwEnumQueues(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates all the queues on a server.
    The queue entries are returned in an array of NETRESOURCE entries;
    each queue name is prefixed by \\Server\.

Arguments:

    ContextHandle - Supplies the enum context handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is (DWORD_PTR) -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned iff WN_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

Return Value:

    NO_ERROR - At least one entry was written to output buffer,
        irregardless of the number requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit a single entry.

--*/ // NwEnumQueues
{
    DWORD status = NO_ERROR;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    BOOL FitInBuffer = TRUE;
    DWORD EntrySize;

    DWORD NextObject = (DWORD) ContextHandle->ResumeId;

    SERVERNAME QueueName;          // OEM queue name
    LPWSTR UQueueName = NULL;      // Unicode queue name

    while ( FitInBuffer &&
            EntriesRequested > *EntriesRead &&
            status == NO_ERROR ) {

        RtlZeroMemory(QueueName, sizeof(QueueName));

        //
        // Call the scan bindery object NCP to scan for all file
        // volume objects.
        //
        status = NwGetNextQueueEntry(
                     ContextHandle->TreeConnectionHandle,
                     &NextObject,
                     QueueName
                     );

        if (status == NO_ERROR && NwConvertToUnicode(&UQueueName, QueueName)) {

            //
            // Pack server name into output buffer.
            //
            status = NwWriteNetResourceEntry(
                         &FixedPortion,
                         &EndOfVariableData,
                         ContextHandle->ContainerName,
                         NULL,
                         UQueueName,
                         RESOURCE_GLOBALNET,
                         RESOURCEDISPLAYTYPE_SHARE,
                         RESOURCEUSAGE_CONNECTABLE,
                         RESOURCETYPE_PRINT,
                         NULL,
                         NULL,
                         &EntrySize
                         );

            if (status == WN_MORE_DATA) {

                 //
                 // Could not write current entry into output buffer.
                 //

                 if (*EntriesRead) {
                     //
                     // Still return success because we got at least one.
                     //
                     status = NO_ERROR;
                 }
                 else {
                     *BytesNeeded = EntrySize;
                 }

                 FitInBuffer = FALSE;
            }
            else if (status == NO_ERROR) {

                 //
                 // Note that we've returned the current entry.
                 //
                 (*EntriesRead)++;

                 ContextHandle->ResumeId = (DWORD_PTR) NextObject;
            }

            (void) LocalFree((HLOCAL) UQueueName);
        }
    }

    if (*EntriesRead && status == WN_NO_MORE_ENTRIES) {
        status = NO_ERROR;
    }

    return status;
}


DWORD
NwEnumDirectories(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates the directories of a given directory
    handle by calling NtQueryDirectoryFile.  It returns the
    fully-qualified UNC path of the directory entries in an array
    of NETRESOURCE entries.

    The ContextHandle->ResumeId field is 0 initially, and contains
    a pointer to the directory name string of the last directory
    returned.  If there are no more directories to return, this
    field is set to (DWORD_PTR) -1.

Arguments:

    ContextHandle - Supplies the enum context handle.  It contains
        an opened directory handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is (DWORD_PTR) -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned iff WN_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

Return Value:

    NO_ERROR - At least one entry was written to output buffer,
        irregardless of the number requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit a single entry.

--*/ // NwEnumDirectories
{
    DWORD status = NO_ERROR;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    BOOL FitInBuffer = TRUE;
    DWORD EntrySize;

    if (ContextHandle->ResumeId == (DWORD_PTR) -1) {
        //
        // Reached the end of enumeration.
        //
        return WN_NO_MORE_ENTRIES;
    }

    while (FitInBuffer &&
           EntriesRequested > *EntriesRead &&
           status == NO_ERROR) {

        if (ContextHandle->ResumeId == 0) {

            //
            // Get the first directory entry.
            //
            status = NwGetFirstDirectoryEntry(
                         ContextHandle->TreeConnectionHandle,
                         (LPWSTR *) &ContextHandle->ResumeId
                         );
        }

        //
        // Either ResumeId contains the first entry we just got from
        // NwGetFirstDirectoryEntry or it contains the next directory
        // entry to return.
        //
        if (ContextHandle->ResumeId != 0) {

            //
            // Pack directory name into output buffer.
            //
            status = NwWriteNetResourceEntry(
                         &FixedPortion,
                         &EndOfVariableData,
                         ContextHandle->ContainerName,
                         NULL,
                         (LPWSTR) ContextHandle->ResumeId,
                         RESOURCE_GLOBALNET,
                         RESOURCEDISPLAYTYPE_SHARE,
#ifdef NT1057
                         RESOURCEUSAGE_CONNECTABLE |
                         RESOURCEUSAGE_CONTAINER,
#else
                         RESOURCEUSAGE_CONNECTABLE |
                         RESOURCEUSAGE_NOLOCALDEVICE,
#endif
                         RESOURCETYPE_DISK,
                         NULL,
                         NULL,
                         &EntrySize
                         );

            if (status == WN_MORE_DATA) {

                //
                // Could not write current entry into output buffer.
                //

                if (*EntriesRead) {
                    //
                    // Still return success because we got at least one.
                    //
                    status = NO_ERROR;
                }
                else {
                    *BytesNeeded = EntrySize;
                }

                FitInBuffer = FALSE;
            }
            else if (status == NO_ERROR) {

                //
                // Note that we've returned the current entry.
                //
                (*EntriesRead)++;

                //
                // Free memory allocated to save resume point, which is
                // a buffer that contains the last directory we returned.
                //
                if (ContextHandle->ResumeId != 0) {
                    (void) LocalFree((HLOCAL) ContextHandle->ResumeId);
                    ContextHandle->ResumeId = 0;
                }

                //
                // Get next directory entry.
                //
                status = NwGetNextDirectoryEntry(
                             (LPWSTR) ContextHandle->TreeConnectionHandle,
                             (LPWSTR *) &ContextHandle->ResumeId
                             );

            }
        }

        if (status == WN_NO_MORE_ENTRIES) {
            ContextHandle->ResumeId = (DWORD_PTR) -1;
        }
    }

    //
    // User asked for more than there are entries.  We just say that
    // all is well.
    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    // entries.  The user has to call this API again and get WN_NO_MORE_ENTRIES
    // before knowing that the last call had actually reached the end of list.
    //
    if (*EntriesRead && status == WN_NO_MORE_ENTRIES) {
        status = NO_ERROR;
    }

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("EnumDirectories returns %lu\n", status));
    }
#endif

    return status;
}


DWORD
NwEnumPrintServers(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates all the servers and NDS tree on the local network
    by scanning the bindery for file server or directory objects on the
    preferred server.  The server and tree entries are returned in an
    array of PRINTER_INFO_1 entries; each entry name is prefixed by
    \\.

    The ContextHandle->ResumeId field is initially (DWORD_PTR) -1 before
    enumeration begins and contains the object ID of the last server
    object returned.

Arguments:

    ContextHandle - Supplies the enum context handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is (DWORD_PTR) -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes copied or required to get all
        the requested entries.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.

Return Value:

    NO_ERROR - Buffer contains all the entries requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit the requested entries.

--*/ // NwEnumPrintServers
{
    DWORD status = NO_ERROR;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    DWORD EntrySize;
    BOOL FitInBuffer = TRUE;

    SERVERNAME ServerName;          // OEM server name
    LPWSTR UServerName = NULL;      // Unicode server name
    DWORD LastObjectId = (DWORD) ContextHandle->ResumeId;
    WCHAR TempBuffer[500];

    while ( EntriesRequested > *EntriesRead &&
            ContextHandle->dwUsingNds == CURRENTLY_ENUMERATING_NDS &&
            ((status == NO_ERROR) || (status == ERROR_INSUFFICIENT_BUFFER)))
    {
        //
        // Call the scan bindery object NCP to scan for all NDS
        // tree objects.
        //
        status = NwGetNextNdsTreeEntry( ContextHandle );

        if ( status == NO_ERROR && ContextHandle->ResumeId != 0 )
        {
            //
            // Put tree name into a buffer
            //
            RtlZeroMemory( TempBuffer, 500 );
            wcscat( TempBuffer, (LPWSTR) ContextHandle->ResumeId );

            //
            // Pack server name into output buffer.
            //
            status = NwWritePrinterInfoEntry(
                         &FixedPortion,
                         &EndOfVariableData,
                         NULL,
                         TempBuffer, // This is a NDS tree name
                         PRINTER_ENUM_CONTAINER | PRINTER_ENUM_ICON1,
                         &EntrySize
                         );

            switch ( status )
            {
                case ERROR_INSUFFICIENT_BUFFER:
                    FitInBuffer = FALSE;
                    // Falls through

                case NO_ERROR:
                    *BytesNeeded += EntrySize;
                    (*EntriesRead)++;
                    // ContextHandle->ResumeId = LastObjectId;
                    break;

                default:
                    break;
            }
        }
        else if ( status == WN_NO_MORE_ENTRIES )
        {
            //
            // We processed the last item in list, so
            // start enumerating servers.
            //
            ContextHandle->dwUsingNds = CURRENTLY_ENUMERATING_NON_NDS;
            ContextHandle->ResumeId = (DWORD_PTR) -1;
            LastObjectId = (DWORD) -1;
        }
    }

    status = NO_ERROR;

    while ( EntriesRequested > *EntriesRead &&
            ContextHandle->dwUsingNds == CURRENTLY_ENUMERATING_NON_NDS &&
            ((status == NO_ERROR) || (status == ERROR_INSUFFICIENT_BUFFER))) {

        RtlZeroMemory(ServerName, sizeof(ServerName));

        //
        // Call the scan bindery object NCP to scan for all file
        // server objects.
        //
        status = NwGetNextServerEntry(
                     ContextHandle->TreeConnectionHandle,
                     &LastObjectId,
                     ServerName
                     );

        if (status == NO_ERROR && NwConvertToUnicode(&UServerName,ServerName)) {

            //
            // Pack server name into output buffer.
            //
            status = NwWritePrinterInfoEntry(
                         &FixedPortion,
                         &EndOfVariableData,
                         NULL,
                         UServerName,
                         PRINTER_ENUM_CONTAINER | PRINTER_ENUM_ICON3,
                         &EntrySize
                         );

            switch ( status )
            {
                case ERROR_INSUFFICIENT_BUFFER:
                    FitInBuffer = FALSE;
                    // Falls through

                case NO_ERROR:
                    *BytesNeeded += EntrySize;
                    (*EntriesRead)++;
                    ContextHandle->ResumeId = (DWORD_PTR) LastObjectId;
                    break;

                default:
                    break;
            }

            (void) LocalFree((HLOCAL) UServerName);
        }
    }

    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    // entries.  The user has to call this API again and get WN_NO_MORE_ENTRIES
    // before knowing that the last call had actually reached the end of list.
    //
    if ( !FitInBuffer ) {
        *EntriesRead = 0;
        status = ERROR_INSUFFICIENT_BUFFER;
    }
    else if (*EntriesRead && status == WN_NO_MORE_ENTRIES) {
        status = NO_ERROR;
    }

    return status;
}


DWORD
NwEnumPrintQueues(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates all the print queues on a server by scanning
    the bindery on the server for print queues objects.
    The print queues entries are returned in an array of PRINTER_INFO_1 entries
    and each printer name is prefixed by \\Server\.

    The ContextHandle->ResumeId field is initially (DWORD_PTR) -1 before
    enumeration begins and contains the object ID of the last print queue
    object returned.

Arguments:

    ContextHandle - Supplies the enum context handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is (DWORD_PTR) -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes copied or required to get all
        the requested entries.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.

Return Value:

    NO_ERROR - Buffer contains all the entries requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit the requested entries.

--*/ // NwEnumPrintQueues
{
    DWORD status = NO_ERROR;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    DWORD EntrySize;
    BOOL FitInBuffer = TRUE;

    SERVERNAME QueueName;          // OEM queue name
    LPWSTR UQueueName = NULL;      // Unicode queue name
    DWORD LastObjectId = (DWORD) ContextHandle->ResumeId;

    while ( EntriesRequested > *EntriesRead &&
            ( (status == NO_ERROR) || (status == ERROR_INSUFFICIENT_BUFFER))) {

        RtlZeroMemory(QueueName, sizeof(QueueName));

        //
        // Call the scan bindery object NCP to scan for all file
        // volume objects.
        //
        status = NwGetNextQueueEntry(
                     ContextHandle->TreeConnectionHandle,
                     &LastObjectId,
                     QueueName
                     );

        if (status == NO_ERROR && NwConvertToUnicode(&UQueueName, QueueName)) {

            //
            // Pack server name into output buffer.
            //
            status = NwWritePrinterInfoEntry(
                         &FixedPortion,
                         &EndOfVariableData,
                         ContextHandle->ContainerName,
                         UQueueName,
                         PRINTER_ENUM_ICON8,
                         &EntrySize
                         );

            switch ( status )
            {
                case ERROR_INSUFFICIENT_BUFFER:
                    FitInBuffer = FALSE;
                    // Falls through

                case NO_ERROR:
                    *BytesNeeded += EntrySize;
                    (*EntriesRead)++;
                    ContextHandle->ResumeId = (DWORD_PTR) LastObjectId;
                    break;

                default:
                    break;
            }

            (void) LocalFree((HLOCAL) UQueueName);
        }
    }

    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    // entries.  The user has to call this API again and get WN_NO_MORE_ENTRIES
    // before knowing that the last call had actually reached the end of list.
    //
    if ( !FitInBuffer ) {
        *EntriesRead = 0;
        status = ERROR_INSUFFICIENT_BUFFER;
    }
    else if (*EntriesRead && status == WN_NO_MORE_ENTRIES) {
        status = NO_ERROR;
    }

    return status;
}


DWORD
NwrCloseEnum(
    IN OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function closes an enum context handle.

Arguments:

    EnumHandle - Supplies a pointer to the enum context handle.

Return Value:

    WN_BAD_HANDLE - Handle is not recognizable.

    NO_ERROR - Call was successful.

--*/ // NwrCloseEnum
{

    LPNW_ENUM_CONTEXT ContextHandle = (LPNW_ENUM_CONTEXT) *EnumHandle;
    DWORD status = NO_ERROR ;

#if DBG
    IF_DEBUG(ENUM)
    {
       KdPrint(("\nNWWORKSTATION: NwrCloseEnum\n"));
    }
#endif

    if (ContextHandle->Signature != NW_HANDLE_SIGNATURE)
    {
        ASSERT(FALSE);
        return WN_BAD_HANDLE;
    }

    //
    // Resume handle for listing directories is a buffer which contains
    // the last directory returned.
    //
    if (ContextHandle->HandleType == NwsHandleListDirectories &&
        ContextHandle->ResumeId != 0 &&
        ContextHandle->ResumeId != (DWORD_PTR) -1)
    {
        (void) LocalFree((HLOCAL) ContextHandle->ResumeId);
    }

    //
    // NdsRawDataBuffer handle for listing NDS tree subordinates is a buffer which contains
    // the last data chunk returned from redirector.
    //
    if ( ( ContextHandle->HandleType == NwsHandleListNdsSubTrees_Disk ||
           ContextHandle->HandleType == NwsHandleListNdsSubTrees_Print ||
           ContextHandle->HandleType == NwsHandleListNdsSubTrees_Any ||
           ContextHandle->HandleType == NwsHandleListServersAndNdsTrees ) &&
         ContextHandle->NdsRawDataBuffer )
    {
        (void) LocalFree((HLOCAL) ContextHandle->NdsRawDataBuffer);
        ContextHandle->NdsRawDataBuffer = 0;
    }

    if (ContextHandle->TreeConnectionHandle != (HANDLE) NULL)
    {
        if (ContextHandle->HandleType == NwsHandleListDirectories)
        {
            //
            // Delete the UNC connection created so that we can browse
            // directories.
            //
            (void) NwNukeConnection(ContextHandle->TreeConnectionHandle, TRUE);
        }

        if ( ContextHandle->HandleType == NwsHandleListNdsSubTrees_Disk ||
             ContextHandle->HandleType == NwsHandleListNdsSubTrees_Print ||
             ContextHandle->HandleType == NwsHandleListNdsSubTrees_Any )
        {
            //
            // Get rid of the connection to the NDS tree.
            //
            (void) CloseHandle(ContextHandle->TreeConnectionHandle);
            ContextHandle->TreeConnectionHandle = 0;
        }
        else
        {
            (void) NtClose(ContextHandle->TreeConnectionHandle);
            ContextHandle->TreeConnectionHandle = 0;
        }
    }

    ContextHandle->Signature = 0x0BADBAD0;
    (void) LocalFree((HLOCAL) ContextHandle);

    *EnumHandle = NULL;

    return status;
}


DWORD
NwrGetUser(
    IN  LPWSTR Reserved OPTIONAL,
    IN  LPWSTR  lpName,
    OUT LPBYTE  lpUserName,
    IN  DWORD   dwUserNameBufferSize,
    OUT LPDWORD lpdwCharsRequired
    )
/*++

Routine Description:

    This is used to determine either the current default username, or the
    username used to establish a network connection.

Arguments:

    Reserved - Unused.

    lpName - The connection for which user information is requested.

    lpUserName - The buffer to receive the user name associated with the
        connection referred to by lpName.

    dwUserNameLen - The size of the buffer lpUserName.

    lpdwCharsRequired - If return status is WN_MORE_DATA, then this is set to
        the value which indicates the number of characters that the buffer
        lpUserName must hold. Otherwise, this is not set.


Return Value:

    WN_SUCCESS - If the call is successful. Otherwise, an error code is,
        returned, which may include:

    WN_NOT_CONNECTED - lpName not a redirected device nor a connected network
        name.

    WN_MORE_DATA - The buffer is too small.

--*/ // NwrGetUser
{
    DWORD status = NO_ERROR;
    WCHAR lpTempUserName[512];
    WCHAR lpTempHostName[512];

    if (lpName == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    status = NwGetConnectionInformation( lpName, lpTempUserName, lpTempHostName );

    if ( status == ERROR_BAD_NETPATH )           
    {
        return WN_NOT_CONNECTED; 
    }
    if ( status != NO_ERROR )
    {
        return status;
    }

    if ( ( ( wcslen( lpTempUserName ) + 1 ) * sizeof(WCHAR) ) > dwUserNameBufferSize )
    {
        *lpdwCharsRequired = wcslen( lpTempUserName ) + 1;
        return WN_MORE_DATA;
    }

    wcscpy( (LPWSTR) lpUserName, lpTempUserName );

    return WN_SUCCESS;
}


DWORD
NwrGetResourceInformation(
    IN  LPWSTR Reserved OPTIONAL,
    IN  LPWSTR  lpRemoteName,
    IN  DWORD   dwType,
    OUT LPBYTE  lpBuffer,
    IN  DWORD   dwBufferSize,
    OUT LPDWORD lpdwBytesNeeded,
    OUT LPDWORD lpdwSystemOffset
    )
/*++

Routine Description:

    This function returns an object which details information
    about a specified network resource.

Arguments:

    Reserved - Unused.
    lpRemoteName - The full path name to be verified.
    dwType - The type of the value, if the calling client knows it.
    lpBuffer - A pointer to a buffer to receive a single NETRESOURCE entry.
    dwBufferSize - The size of the buffer.
    lpdwBytesNeeded - The buffer size needed if WN_MORE_DATA is returned.
    lpdwSystemOffset - A DWORD that is an offset value to the beginning of a
    string that specifies the part of the resource that is accessed through
    resource type specific APIs rather than WNet APIs. The string is stored
    in the same buffer as the returned NETRESOURCE structure, lpBuffer.

Return Value:

    WN_SUCCESS - If the call is successful.

    WN_MORE_DATA - If input buffer is too small.

    WN_BAD_VALUE - Invalid dwScope or dwUsage or dwType, or bad combination
        of parameters is specified (e.g. lpRemoteName does not correspond
        to dwType).

    WN_BAD_NETNAME - The resource is not recognized by this provider.

--*/ // NwrGetResourceInformation
{
    DWORD    status = NO_ERROR;
    DWORD    EntrySize;

    LPBYTE   FixedPortion = lpBuffer;
    LPWSTR   EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(dwBufferSize,ALIGN_DWORD));
    LPWSTR   lpObjectPathName = NULL;
    LPWSTR   lpSystemPathPart = NULL;
    LPWSTR   lpSystem = NULL;
    DWORD    ClassType;
    DWORD    ResourceScope = RESOURCE_CONTEXT; // prefix issue
    DWORD    ResourceType = 0;
    DWORD    ResourceDisplayType;
    DWORD    ResourceUsage;
    BOOL     fReturnBadNetName = FALSE;

    if (lpRemoteName == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *lpdwSystemOffset = 0;

    status = NwGetNDSPathInfo( lpRemoteName,
                               &lpObjectPathName,
                               &lpSystemPathPart,
                               &ClassType,
                               &ResourceScope,
                               &ResourceType,
                               &ResourceDisplayType,
                               &ResourceUsage );

    if ( status == VERIFY_ERROR_NOT_A_NDS_TREE )
    {
       //
       // Code to handle \\SERVER\VOL\... here!
       //
       status = NwGetBinderyPathInfo( lpRemoteName,
                                      &lpObjectPathName,
                                      &lpSystemPathPart,
                                      &ClassType,
                                      &ResourceScope,
                                      &ResourceType,
                                      &ResourceDisplayType,
                                      &ResourceUsage );
    }

    if ( status == VERIFY_ERROR_PATH_NOT_FOUND )
    {
        fReturnBadNetName = TRUE;
        status = NO_ERROR;
    }

    if ( status == NO_ERROR &&
         dwType != RESOURCETYPE_ANY &&
         ResourceType != RESOURCETYPE_ANY &&
         dwType != ResourceType )
    {
        status = WN_BAD_VALUE;
    }

    if ( status == NO_ERROR )
    {
        //
        // Pack subtree name into output buffer.
        //
        status = NwWriteNetResourceEntry( &FixedPortion,
                                          &EndOfVariableData,
                                          NULL,
                                          NULL,
                                          lpObjectPathName == NULL ? NwProviderName : lpObjectPathName,
                                          ResourceScope,
                                          ResourceDisplayType,
                                          ResourceUsage,
                                          ResourceType,
                                          lpSystemPathPart,
                                          &lpSystem,
                                          &EntrySize );

        if ( lpObjectPathName )
            (void) LocalFree( (HLOCAL) lpObjectPathName );
    }
    else
    {
        if ( lpSystemPathPart != NULL )
        {
            (void) LocalFree( (HLOCAL) lpSystemPathPart );
            lpSystemPathPart = NULL;
        }

        return status;
    }

    if ( status != NO_ERROR )
    {
        if (status == WN_MORE_DATA)
        {
            //
            // Could not write current entry into output buffer.
            //
            *lpdwBytesNeeded = EntrySize;
        }

        if ( lpSystemPathPart != NULL )
        {
            (void) LocalFree( (HLOCAL) lpSystemPathPart );
            lpSystemPathPart = NULL;
        }

        if ( fReturnBadNetName )
            return WN_BAD_NETNAME;

        return status;
    }
    else
    {
        LPNETRESOURCEW NetR = (LPNETRESOURCEW) lpBuffer;

        //
        // Replace pointers to strings with offsets as need
        //

        if (NetR->lpLocalName != NULL)
        {
            NetR->lpLocalName = (LPWSTR) ((DWORD_PTR) (NetR->lpLocalName) - (DWORD_PTR) lpBuffer);
        }

        NetR->lpRemoteName = (LPWSTR) ((DWORD_PTR) (NetR->lpRemoteName) - (DWORD_PTR) lpBuffer);

        if (NetR->lpComment != NULL)
        {
            NetR->lpComment = (LPWSTR) ((DWORD_PTR) (NetR->lpComment) - (DWORD_PTR) lpBuffer);
        }

        if (NetR->lpProvider != NULL)
        {
            NetR->lpProvider = (LPWSTR) ((DWORD_PTR) (NetR->lpProvider) - (DWORD_PTR) lpBuffer);
        }

        if (lpSystem != NULL)
        {
            *lpdwSystemOffset = (DWORD)((DWORD_PTR) lpSystem - (DWORD_PTR) lpBuffer);
        }

        if ( lpSystemPathPart != NULL )
        {
            (void) LocalFree( (HLOCAL) lpSystemPathPart );
            lpSystemPathPart = NULL;
        }

        if ( fReturnBadNetName )
            return WN_BAD_NETNAME;

        return WN_SUCCESS;
    }
}


DWORD
NwrGetResourceParent(
    IN  LPWSTR Reserved OPTIONAL,
    IN  LPWSTR  lpRemoteName,
    IN  DWORD   dwType,
    OUT LPBYTE  lpBuffer,
    IN  DWORD   dwBufferSize,
    OUT LPDWORD lpdwBytesNeeded
    )
/*++

Routine Description:

    This function returns an object which details information
    about the parent of a specified network resource.

Arguments:

    Reserved - Unused.
    lpRemoteName - The full path name of object to find the parent of.
    dwType - The type of the value, if the calling client knows it.
    lpBuffer - A pointer to a buffer to receive a single NETRESOURCE entry.
    dwBufferSize - The size of the buffer.
    lpdwBytesNeeded - The buffer size needed if WN_MORE_DATA is returned.

Return Value:

    WN_SUCCESS - If the call is successful.

    WN_MORE_DATA - If input buffer is too small.

    WN_BAD_VALUE - Invalid dwScope or dwUsage or dwType, or bad combination
        of parameters is specified (e.g. lpRemoteName does not correspond
        to dwType).

--*/ // NwrGetResourceParent
{
    DWORD    status = NO_ERROR;
    DWORD    EntrySize;

    LPBYTE   FixedPortion = lpBuffer;
    LPWSTR   EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(dwBufferSize,ALIGN_DWORD));
    LPWSTR   lpRemoteNameParent = NULL;
    LPWSTR   lpFullObjectPathName = NULL;
    DWORD    ClassType;
    DWORD    ResourceScope;
    DWORD    ResourceType;
    DWORD    ResourceDisplayType;
    DWORD    ResourceUsage;
    BOOL     fReturnBadNetName = FALSE;

    if (lpRemoteName == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( ! NwGetRemoteNameParent( lpRemoteName, &lpRemoteNameParent ) )
    {
        return WN_BAD_NETNAME;
    }

    status = NwVerifyNDSObject( lpRemoteNameParent,
                                &lpFullObjectPathName,
                                &ClassType,
                                &ResourceScope,
                                &ResourceType,
                                &ResourceDisplayType,
                                &ResourceUsage );

    if ( status == VERIFY_ERROR_NOT_A_NDS_TREE )
    {
       status = NwVerifyBinderyObject( lpRemoteNameParent,
                                       &lpFullObjectPathName,
                                       &ClassType,
                                       &ResourceScope,
                                       &ResourceType,
                                       &ResourceDisplayType,
                                       &ResourceUsage );
    }

    if ( lpRemoteNameParent )
        (void) LocalFree( (HLOCAL) lpRemoteNameParent );

    if ( status == VERIFY_ERROR_PATH_NOT_FOUND )
    {
        fReturnBadNetName = TRUE;
        status = NO_ERROR;
    }

    if ( status == NO_ERROR )
    {
        //
        // Pack subtree name into output buffer.
        //
        status = NwWriteNetResourceEntry( &FixedPortion,
                                          &EndOfVariableData,
                                          NULL,
                                          NULL,
                                          lpFullObjectPathName == NULL ? NwProviderName : lpFullObjectPathName,
                                          ResourceScope,
                                          ResourceDisplayType,
                                          ResourceUsage,
                                          ResourceType,
                                          NULL,
                                          NULL,
                                          &EntrySize );

        if ( lpFullObjectPathName )
            (void) LocalFree( (HLOCAL) lpFullObjectPathName );
    }
    else
    {
        return status;
    }

    if ( status != NO_ERROR )
    {
        if (status == WN_MORE_DATA)
        {
            //
            // Could not write current entry into output buffer.
            //
            *lpdwBytesNeeded = EntrySize;
        }

        if ( fReturnBadNetName )
            return WN_BAD_NETNAME;

        return status;
    }
    else
    {
        LPNETRESOURCEW NetR = (LPNETRESOURCEW) lpBuffer;

        //
        // Replace pointers to strings with offsets as need
        //

        if (NetR->lpLocalName != NULL)
        {
            NetR->lpLocalName = (LPWSTR) ((DWORD_PTR) (NetR->lpLocalName) - (DWORD_PTR) lpBuffer);
        }

        NetR->lpRemoteName = (LPWSTR) ((DWORD_PTR) (NetR->lpRemoteName) - (DWORD_PTR) lpBuffer);

        if (NetR->lpComment != NULL)
        {
            NetR->lpComment = (LPWSTR) ((DWORD_PTR) (NetR->lpComment) - (DWORD_PTR) lpBuffer);
        }

        if (NetR->lpProvider != NULL)
        {
            NetR->lpProvider = (LPWSTR) ((DWORD_PTR) (NetR->lpProvider) - (DWORD_PTR) lpBuffer);
        }

        if ( fReturnBadNetName )
            return WN_BAD_NETNAME;

        return WN_SUCCESS;
    }
}


VOID
NWWKSTA_CONTEXT_HANDLE_rundown(
    IN NWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function is called by RPC when a client terminates with an
    opened handle.  This allows us to clean up and deallocate any context
    data associated with the handle.

Arguments:

    EnumHandle - Supplies the handle opened for an enumeration.

Return Value:

    None.

--*/
{
    //
    // Call our close handle routine.
    //
    NwrCloseEnum(&EnumHandle);
}


DWORD
NwGetFirstNdsSubTreeEntry(
    OUT LPNW_ENUM_CONTEXT ContextHandle,
    IN  DWORD BufferSize
    )
/*++

Routine Description:

    This function is called by NwEnumNdsSubTrees to get the first
    subtree entry given a handle to a NDS tree.  It allocates
    the output buffer to hold the returned subtree name; the
    caller should free this output buffer with LocalFree when done.

Arguments:

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Out of memory allocating output
        buffer.

    Other errors from NwNdsList.

--*/ // NwGetFirstNdsSubTreeEntry
{
    NTSTATUS ntstatus;

    ContextHandle->NdsRawDataSize = BufferSize;

    //
    // Determine size of NDS raw data buffer to use.
    //
    if ( ContextHandle->NdsRawDataSize < EIGHT_KB )
        ContextHandle->NdsRawDataSize = EIGHT_KB;

	else	//	dfergus 19 Apr 2001 - 346859
			//	if buffer too big, set to max NDS buffer size
		if (ContextHandle->NdsRawDataSize > 0xFC00) // NW_MAX_BUFFER = 0xFC00
		    ContextHandle->NdsRawDataSize = 0xFC00;


    //
    // Create NDS raw data buffer.
    //
    ContextHandle->NdsRawDataBuffer = (DWORD_PTR)
                           LocalAlloc( LMEM_ZEROINIT, 
                                       ContextHandle->NdsRawDataSize );

    if ( ContextHandle->NdsRawDataBuffer == 0 )
    {
        KdPrint(("NWWORKSTATION: NwGetFirstNdsSubTreeEntry LocalAlloc Failed %lu\n", GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Set up to get initial NDS subordinate list.
    //
    ContextHandle->NdsRawDataId = INITIAL_ITERATION;

    ntstatus = NwNdsList( ContextHandle->TreeConnectionHandle,
                        ContextHandle->dwOid,
                        &ContextHandle->NdsRawDataId,
                        (LPBYTE) ContextHandle->NdsRawDataBuffer,
                        ContextHandle->NdsRawDataSize );

    //
    // If error, clean up the ContextHandle and return.
    //
    if ( ntstatus != STATUS_SUCCESS ||
         ((PNDS_RESPONSE_SUBORDINATE_LIST)
             ContextHandle->NdsRawDataBuffer)->SubordinateEntries == 0 )
    {
        if ( ContextHandle->NdsRawDataBuffer )
            (void) LocalFree( (HLOCAL) ContextHandle->NdsRawDataBuffer );
        ContextHandle->NdsRawDataBuffer = 0;
        ContextHandle->NdsRawDataSize = 0;
        ContextHandle->NdsRawDataId = INITIAL_ITERATION;
        ContextHandle->NdsRawDataCount = 0;
        ContextHandle->ResumeId = 0;

        return WN_NO_MORE_ENTRIES;
    }

    ContextHandle->NdsRawDataCount = ((PNDS_RESPONSE_SUBORDINATE_LIST)
                                       ContextHandle->NdsRawDataBuffer)->SubordinateEntries - 1;

    ContextHandle->ResumeId = ContextHandle->NdsRawDataBuffer +
                              sizeof( NDS_RESPONSE_SUBORDINATE_LIST );

    // Multi-user code merge                  
    // 12/05/96 cjc Fix problem with FileManager not showing all the NDS entries.
    //              Problem occurs when the NDS entries don't fit in 1 NCP packet;
    //              need to keep track of the Iteration # and redo NCP.

    ContextHandle->NdsRawDataId = ((PNDS_RESPONSE_SUBORDINATE_LIST)                           
                                    ContextHandle->NdsRawDataBuffer)->IterationHandle;

    return RtlNtStatusToDosError(ntstatus);
}


DWORD
NwGetNextNdsSubTreeEntry(
    OUT LPNW_ENUM_CONTEXT ContextHandle
    )
/*++

Routine Description:

    This function is called by NwEnumNdsSubTrees to get the next
    NDS subtree entry given a handle to a NDS tree.  It allocates
    the output buffer to hold the returned subtree name; the
    caller should free this output buffer with LocalFree when done.

Arguments:

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Out of memory allocating output
        buffer.

    Other errors from NwNdsList.

--*/ // NwGetNextDirectoryEntry
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    PBYTE pbRaw;
    DWORD dwStrLen;


    if ( ContextHandle->NdsRawDataCount == 0 &&
         ContextHandle->NdsRawDataId == INITIAL_ITERATION )
        return WN_NO_MORE_ENTRIES;

    if ( ContextHandle->NdsRawDataCount == 0 &&
         ContextHandle->NdsRawDataId != INITIAL_ITERATION )
    {
        ntstatus = NwNdsList( ContextHandle->TreeConnectionHandle,
                            ContextHandle->dwOid,
                            &ContextHandle->NdsRawDataId,
                            (LPBYTE) ContextHandle->NdsRawDataBuffer,
                            ContextHandle->NdsRawDataSize );

        //
        // If error, clean up the ContextHandle and return.
        //
        if (ntstatus != STATUS_SUCCESS)
        {
            if ( ContextHandle->NdsRawDataBuffer )
                (void) LocalFree( (HLOCAL) ContextHandle->NdsRawDataBuffer );
            ContextHandle->NdsRawDataBuffer = 0;
            ContextHandle->NdsRawDataSize = 0;
            ContextHandle->NdsRawDataId = INITIAL_ITERATION;
            ContextHandle->NdsRawDataCount = 0;

            return WN_NO_MORE_ENTRIES;
        }

        ContextHandle->NdsRawDataCount = ((PNDS_RESPONSE_SUBORDINATE_LIST)
                                           ContextHandle->NdsRawDataBuffer)->SubordinateEntries - 1;

        ContextHandle->ResumeId = ContextHandle->NdsRawDataBuffer +
                                  sizeof( NDS_RESPONSE_SUBORDINATE_LIST );

        // ---Multi-user change --- 
        // 12/05/96 cjc Fix problem with FileManager not showing all the NDS entries.
        //              Problem occurs when the NDS entries don't fit in 1 NCP packet;
        //              need to keep track of the Iteration # and redo NCP.

        ContextHandle->NdsRawDataId = ((PNDS_RESPONSE_SUBORDINATE_LIST)                           
                                       ContextHandle->NdsRawDataBuffer)->IterationHandle;
        return RtlNtStatusToDosError(ntstatus);
    }

    ContextHandle->NdsRawDataCount--;

    //
    // Move pointer past the fixed header portion of a NDS_RESPONSE_SUBORDINATE_ENTRY
    //
    pbRaw = (BYTE *) ContextHandle->ResumeId;
    pbRaw += sizeof( NDS_RESPONSE_SUBORDINATE_ENTRY );

    //
    // Move pointer past the length value of the Class Name string
    // of a NDS_RESPONSE_SUBORDINATE_ENTRY
    //
    dwStrLen = * (DWORD *) pbRaw;
    pbRaw += sizeof( DWORD );

    //
    // Move pointer past the Class Name string of a NDS_RESPONSE_SUBORDINATE_ENTRY
    //
    pbRaw += ROUNDUP4( dwStrLen );

    //
    // Move pointer past the length value of the Object Name string
    // of a NDS_RESPONSE_SUBORDINATE_ENTRY
    //
    dwStrLen = * (DWORD *) pbRaw;
    pbRaw += sizeof( DWORD );

    ContextHandle->ResumeId = (DWORD_PTR) ( pbRaw + ROUNDUP4( dwStrLen ) );

    return RtlNtStatusToDosError(ntstatus);
}


BYTE
NwGetSubTreeData(
    IN DWORD_PTR NdsRawDataPtr,
    OUT LPWSTR * SubTreeName,
    OUT LPDWORD  ResourceScope,
    OUT LPDWORD  ResourceType,
    OUT LPDWORD  ResourceDisplayType,
    OUT LPDWORD  ResourceUsage,
    OUT LPWSTR * StrippedObjectName
    )
/*++

Routine Description:

    This function is called by NwEnumNdsSubTrees to get the information
    needed to describe a single NETRESOURCE from an entry in the
    NdsRawDataBuffer.

Arguments:

    NdsRawDataPtr - Supplies the pointer to a buffer with the NDS raw data.

    SubTreeName - Receives a pointer to the returned subtree object name
                  found in buffer.

    ResourceScope - Receives the value of the scope for the subtree object
                    found in buffer.

    ResourceType - Receives the value of the type for the subtree object
                   found in buffer.

    ResourceDisplayType - Receives the value of the display type for the
                          subtree object found in buffer.

    ResourceUsage - Receives the value of the usage for the subtree object
                    found in buffer.

    StrippedObjectName - A pointer to receive the address of a buffer which
                         will contain the formatted object name. Callee must
                         free buffer with LocalFree().

Return Value:

    A DWORD with a value that is used to represent NDS object class type..

--*/ // NwGetSubTreeData
{
    PNDS_RESPONSE_SUBORDINATE_ENTRY pSubEntry =
                             (PNDS_RESPONSE_SUBORDINATE_ENTRY) NdsRawDataPtr;
    PBYTE pbRaw;
    DWORD dwStrLen;
    LPWSTR ClassNameStr;

    pbRaw = (BYTE *) pSubEntry;

    //
    // The structure of a NDS_RESPONSE_SUBORDINATE_ENTRY consists of 4 DWORDs
    // followed by two standard NDS format UNICODE strings. Below we jump pbRaw
    // into the buffer, past the 4 DWORDs.
    //
    pbRaw += sizeof( NDS_RESPONSE_SUBORDINATE_ENTRY );

    //
    // Now we get the length of the first string (Base Class).
    //
    dwStrLen = * (DWORD *) pbRaw;

    //
    // Now we point pbRaw to the first WCHAR of the first string (Base Class).
    //
    pbRaw += sizeof( DWORD_PTR );

    ClassNameStr = (LPWSTR) pbRaw;

    //
    // Move pbRaw into the buffer, past the first UNICODE string (WORD aligned)
    //
    pbRaw += ROUNDUP4( dwStrLen );

    //
    // Now we get the length of the second string (Entry Name).
    //
    dwStrLen = * (DWORD *) pbRaw;

    //
    // Now we point pbRaw to the first WCHAR of the second string (Entry Name).
    //
    pbRaw += sizeof( DWORD_PTR );

    *SubTreeName = (LPWSTR) pbRaw;

    //
    // Strip off any CN= stuff from the object name.
    //
    NwStripNdsUncName( *SubTreeName, StrippedObjectName );

    *ResourceScope = RESOURCE_GLOBALNET;

    if ( !wcscmp( ClassNameStr, CLASS_NAME_ALIAS ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        *ResourceUsage = 0;

        return CLASS_TYPE_ALIAS;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_AFP_SERVER ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        *ResourceUsage = 0;

        return CLASS_TYPE_AFP_SERVER;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_BINDERY_OBJECT ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        *ResourceUsage = 0;

        return CLASS_TYPE_BINDERY_OBJECT;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_BINDERY_QUEUE ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        *ResourceUsage = 0;

        return CLASS_TYPE_BINDERY_QUEUE;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_COMPUTER ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        *ResourceUsage = 0;

        return CLASS_TYPE_COMPUTER;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_COUNTRY ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_NDSCONTAINER;
        *ResourceUsage = RESOURCEUSAGE_CONTAINER;

        return CLASS_TYPE_COUNTRY;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_DIRECTORY_MAP ) )
    {
        *ResourceType = RESOURCETYPE_DISK;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_SHARE;
#ifdef NT1057
        *ResourceUsage = RESOURCEUSAGE_CONNECTABLE |
                         RESOURCEUSAGE_CONTAINER;
#else
        *ResourceUsage = RESOURCEUSAGE_CONNECTABLE |
                         RESOURCEUSAGE_NOLOCALDEVICE;
#endif

        return CLASS_TYPE_DIRECTORY_MAP;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_GROUP ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GROUP;
        *ResourceUsage = 0;

        return CLASS_TYPE_GROUP;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_LOCALITY ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        *ResourceUsage = 0;

        return CLASS_TYPE_LOCALITY;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_NCP_SERVER ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_SERVER;
        *ResourceUsage = RESOURCEUSAGE_CONTAINER;

        return CLASS_TYPE_NCP_SERVER;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_ORGANIZATION ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_NDSCONTAINER;
        *ResourceUsage = RESOURCEUSAGE_CONTAINER;

        return CLASS_TYPE_ORGANIZATION;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_ORGANIZATIONAL_ROLE ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        *ResourceUsage = 0;

        return CLASS_TYPE_ORGANIZATIONAL_ROLE;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_ORGANIZATIONAL_UNIT ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_NDSCONTAINER;
        *ResourceUsage = RESOURCEUSAGE_CONTAINER;

        return CLASS_TYPE_ORGANIZATIONAL_UNIT;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_PRINTER ) )
    {
        *ResourceType = RESOURCETYPE_PRINT;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_SHARE;
        *ResourceUsage = RESOURCEUSAGE_CONNECTABLE;

        return CLASS_TYPE_PRINTER;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_PRINT_SERVER ) )
    {
        *ResourceType = RESOURCETYPE_PRINT;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_SERVER;
        *ResourceUsage = RESOURCEUSAGE_CONTAINER;

        return CLASS_TYPE_PRINT_SERVER;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_PROFILE ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        *ResourceUsage = 0;

        return CLASS_TYPE_PROFILE;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_QUEUE ) )
    {
        *ResourceType = RESOURCETYPE_PRINT;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_SHARE;
        *ResourceUsage = RESOURCEUSAGE_CONNECTABLE;

        return CLASS_TYPE_QUEUE;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_TOP ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        *ResourceUsage = 0;

        return CLASS_TYPE_TOP;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_USER ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        *ResourceUsage = 0;

        return CLASS_TYPE_USER;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_VOLUME ) )
    {
        *ResourceType = RESOURCETYPE_DISK;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_SHARE;
#ifdef NT1057
        *ResourceUsage = RESOURCEUSAGE_CONNECTABLE |
                         RESOURCEUSAGE_CONTAINER;
#else
        *ResourceUsage = RESOURCEUSAGE_CONNECTABLE |
                         RESOURCEUSAGE_NOLOCALDEVICE;
#endif

        return CLASS_TYPE_VOLUME;
    }

    //
    // Otherwise if ClassNameStr is something other than Unknown, report it
    //
    if ( wcscmp( ClassNameStr, CLASS_NAME_UNKNOWN ) )
    {
        KdPrint(("NWWORKSTATION: NwGetSubTreeData failed to recognize"));
        KdPrint((" ClassName: %S\n", ClassNameStr));
        KdPrint(("    Setting object attributes to Unknown for now . . .\n"));
    }

    *ResourceType = RESOURCETYPE_ANY;
    *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
    *ResourceUsage = 0;

    return CLASS_TYPE_UNKNOWN;
}


VOID
NwStripNdsUncName(
    IN  LPWSTR   ObjectName,
    OUT LPWSTR * StrippedObjectName
    )
{
    WORD slashCount;
    BOOL isNdsUnc;
    LPWSTR FourthSlash;
    LPWSTR TreeName;
    LPWSTR ObjectPath;
    DWORD  TreeNameLen;
    DWORD  ObjectPathLen;
    DWORD  PrefixBytes;
    DWORD  CurrentPathIndex;
    DWORD  StrippedNameLen;
    DWORD  StrippedNameMaxLen = MAX_NDS_NAME_CHARS;
    WCHAR  StrippedName[MAX_NDS_NAME_CHARS];

    *StrippedObjectName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                                               (wcslen(ObjectName) + 1) *
                                               sizeof(WCHAR) );

    if ( *StrippedObjectName == NULL )
    {
        return;
    }

    NwpGetUncInfo( ObjectName, &slashCount, &isNdsUnc, &FourthSlash );

    if ( slashCount >= 2 )
    {
        TreeNameLen = NwParseNdsUncPath( &TreeName,
                                         ObjectName, 
                                         PARSE_NDS_GET_TREE_NAME );

        TreeNameLen /= sizeof(WCHAR);

        wcscpy( *StrippedObjectName, L"\\\\" );
        wcsncat( *StrippedObjectName, TreeName, TreeNameLen );

        ObjectPathLen = NwParseNdsUncPath( &ObjectPath,
                                           ObjectName,
                                           PARSE_NDS_GET_PATH_NAME );

        if ( ObjectPathLen == 0 )
        {
            _wcsupr( *StrippedObjectName );

            return;
        }

        wcscat( *StrippedObjectName, L"\\" );
    }
    else
    {
        wcscpy( *StrippedObjectName, L"" );

        ObjectPath = ObjectName;
        ObjectPathLen = wcslen(ObjectName) * sizeof(WCHAR);
    }

    CurrentPathIndex = 0;
    PrefixBytes = 0;
    StrippedNameLen = 0;

    //
    // All of these indexes are in BYTES, not WCHARS!
    //
    while ( ( CurrentPathIndex < ObjectPathLen ) &&
            ( StrippedNameLen < StrippedNameMaxLen ) )
    {
        if ( ObjectPath[CurrentPathIndex / sizeof( WCHAR )] == L'=' )
        {
            CurrentPathIndex += sizeof( WCHAR );
            StrippedNameLen -= PrefixBytes;
            PrefixBytes = 0;

            continue;
        }

        StrippedName[StrippedNameLen / sizeof( WCHAR )] =
            ObjectPath[CurrentPathIndex / sizeof( WCHAR )];

        StrippedNameLen += sizeof( WCHAR );
        CurrentPathIndex += sizeof( WCHAR );

        if ( ObjectPath[CurrentPathIndex / sizeof( WCHAR )] == L'.' )
        {
            PrefixBytes = 0;
            PrefixBytes -= sizeof( WCHAR );
        }
        else
        {
            PrefixBytes += sizeof( WCHAR );
        }
    }

    StrippedName[StrippedNameLen / sizeof( WCHAR )] = L'\0';

    wcscat( *StrippedObjectName, StrippedName );
    _wcsupr( *StrippedObjectName );
}


DWORD
NwVerifyNDSObject(
    IN  LPWSTR   lpNDSObjectNamePath,
    OUT LPWSTR * lpFullNDSObjectNamePath,
    OUT LPDWORD  lpClassType,
    OUT LPDWORD  lpResourceScope,
    OUT LPDWORD  lpResourceType,
    OUT LPDWORD  lpResourceDisplayType,
    OUT LPDWORD  lpResourceUsage
    )
{
    DWORD    status = NO_ERROR;
    NTSTATUS ntstatus = STATUS_SUCCESS;
    UNICODE_STRING TreeServerName;
    UNICODE_STRING PathString;
    HANDLE   ConnectionHandle = NULL;
    DWORD    dwHandleType;
    DWORD    dwOid;
    BOOL     fImpersonate = FALSE ;

    if ( lpNDSObjectNamePath == NULL )
    {
        //
        // Handle this as if we are at the root of our provider hierarchy.
        //
        *lpResourceScope = RESOURCE_GLOBALNET;
        *lpResourceType = RESOURCETYPE_ANY;
#ifdef NT1057
        *lpResourceDisplayType = 0;
#else
        *lpResourceDisplayType = RESOURCEDISPLAYTYPE_NETWORK;
#endif
        *lpResourceUsage = RESOURCEUSAGE_CONTAINER;

        *lpFullNDSObjectNamePath = NULL;

        return NO_ERROR;
    }

    TreeServerName.Buffer = NULL;
    PathString.Buffer = NULL;
    TreeServerName.MaximumLength = ( wcslen( lpNDSObjectNamePath ) + 1 ) * sizeof( WCHAR );
    PathString.MaximumLength = ( wcslen( lpNDSObjectNamePath ) + 1 ) * sizeof( WCHAR );

    TreeServerName.Length = NwParseNdsUncPath( (LPWSTR *) &TreeServerName.Buffer,
                                           lpNDSObjectNamePath,
                                           PARSE_NDS_GET_TREE_NAME );

    if ( TreeServerName.Length == 0 || TreeServerName.Buffer == NULL )
    {
        //
        // lpNDSObjectNamePath is not in the form \\name[\blah.blah.blah][\foo][\bar]...
        //
        status = WN_BAD_NETNAME;
        goto ErrorExit;
    }

    //
    // Impersonate the client
    //
    if ( ( status = NwImpersonateClient() ) != NO_ERROR )
    {
        goto ErrorExit;
    }

    fImpersonate = TRUE;

    //
    // Open a connection handle to \\name
    //
    ntstatus = NwNdsOpenGenericHandle( &TreeServerName,
                                       &dwHandleType,
                                       &ConnectionHandle );

    if ( ntstatus != STATUS_SUCCESS )
    {
        //
        // The first part of lpNDSObjectNamePath was neither a NDS tree nor a NCP Server.
        //
        status = WN_BAD_NETNAME;
        goto ErrorExit;
    }

    if ( dwHandleType != HANDLE_TYPE_NDS_TREE )
    {
        //
        // The first part of lpNDSObjectNamePath was not a NDS tree.
        //
        status = VERIFY_ERROR_NOT_A_NDS_TREE;
        goto ErrorExit;
    }

    //
    // Adjust TreeServerName.Length to number of characters.
    //
    TreeServerName.Length /= sizeof(WCHAR);

    //
    // The lpNDSObjectNamePath points to a NDS tree. Now verify that the path is valid.
    //
    PathString.Length = NwParseNdsUncPath( (LPWSTR *) &PathString.Buffer,
                                           lpNDSObjectNamePath,
                                           PARSE_NDS_GET_PATH_NAME );

    if ( PathString.Length == 0 )
    {
        LPWSTR treeNameStr = NULL;

        if ( fImpersonate )
            (void) NwRevertToSelf() ;

        if ( ConnectionHandle )
            CloseHandle( ConnectionHandle );

        *lpResourceScope = RESOURCE_GLOBALNET;
        *lpResourceType = RESOURCETYPE_ANY;
        *lpResourceDisplayType = RESOURCEDISPLAYTYPE_TREE;
        *lpResourceUsage = RESOURCEUSAGE_CONTAINER;

        //
        // Need to build a string with the new NDS UNC path for subtree object
        //
        treeNameStr = (PVOID) LocalAlloc( LMEM_ZEROINIT,
                                          ( TreeServerName.Length + 3 ) * sizeof(WCHAR) );

        if ( treeNameStr == NULL )
        {
            KdPrint(("NWWORKSTATION: NwVerifyNDSObject LocalAlloc Failed %lu\n",
            GetLastError()));
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        wcscpy( treeNameStr, L"\\\\" );
        wcsncat( treeNameStr, TreeServerName.Buffer, TreeServerName.Length );
        _wcsupr( treeNameStr );

        *lpFullNDSObjectNamePath = treeNameStr;

        return NO_ERROR;
    }
    else
    {
        WCHAR          lpServerName[NW_MAX_SERVER_LEN];
        UNICODE_STRING ServerName;

        ServerName.Length = 0;
        ServerName.MaximumLength = sizeof( lpServerName );
        ServerName.Buffer = lpServerName;

        //
        // Resolve the path to get a NDS object id.
        //
        ntstatus =  NwNdsResolveName( ConnectionHandle,
                                      &PathString,
                                      &dwOid,
                                      &ServerName,
                                      NULL,
                                      0 );

        if ( ntstatus == STATUS_SUCCESS && ServerName.Length )
        {
            DWORD    dwHandleType;

            //
            // NwNdsResolveName succeeded, but we were referred to
            // another server, though ContextHandle->dwOid is still valid.

            if ( ConnectionHandle )
                CloseHandle( ConnectionHandle );

            ConnectionHandle = NULL;

            //
            // Open a NDS generic connection handle to \\ServerName
            //
            ntstatus = NwNdsOpenGenericHandle( &ServerName,
                                               &dwHandleType,
                                               &ConnectionHandle );

            if ( ntstatus != STATUS_SUCCESS )
            {
                status = RtlNtStatusToDosError(ntstatus);
                goto ErrorExit;
            }

            ASSERT( dwHandleType != HANDLE_TYPE_NCP_SERVER );
        }
    }

    if ( ntstatus != STATUS_SUCCESS )
    {
        LPWSTR treeNameStr = NULL;

        *lpResourceScope = RESOURCE_GLOBALNET;
        *lpResourceType = RESOURCETYPE_ANY;
        *lpResourceDisplayType = RESOURCEDISPLAYTYPE_TREE;
        *lpResourceUsage = RESOURCEUSAGE_CONTAINER;

        //
        // Need to build a string with the new NDS UNC path for subtree object
        //
        treeNameStr = (PVOID) LocalAlloc( LMEM_ZEROINIT,
                                          ( TreeServerName.Length + 3 ) * sizeof(WCHAR) );

        if ( treeNameStr == NULL )
        {
            KdPrint(("NWWORKSTATION: NwVerifyNDSObject LocalAlloc Failed %lu\n",
            GetLastError()));
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        wcscpy( treeNameStr, L"\\\\" );
        wcsncat( treeNameStr, TreeServerName.Buffer, TreeServerName.Length );
        _wcsupr( treeNameStr );

        *lpFullNDSObjectNamePath = treeNameStr;

        status = VERIFY_ERROR_PATH_NOT_FOUND;
        goto ErrorExit;
    }

    //
    // Check to see what kind of object is pointed to by lpRemoteName.
    //
    {
        BYTE   RawResponse[TWO_KB];
        PBYTE  pbRawGetInfo;
        DWORD  RawResponseSize = sizeof(RawResponse);
        DWORD  dwStrLen;
        LPWSTR  TreeObjectName;
        LPWSTR StrippedObjectName = NULL;
        LPWSTR newPathStr = NULL;

        ntstatus = NwNdsReadObjectInfo( ConnectionHandle,
                                        dwOid,
                                        RawResponse,
                                        RawResponseSize );

        if ( ntstatus != NO_ERROR )
        {
            status = RtlNtStatusToDosError(ntstatus);
            goto ErrorExit;
        }

        //
        // Get current subtree data from ContextHandle
        //
        *lpClassType = NwGetSubTreeData( (DWORD_PTR) RawResponse,
                                         &TreeObjectName,
                                         lpResourceScope,
                                         lpResourceType,
                                         lpResourceDisplayType,
                                         lpResourceUsage,
                                         &StrippedObjectName );

        if ( StrippedObjectName == NULL )
        {
            KdPrint(("NWWORKSTATION: NwVerifyNDSObject LocalAlloc Failed %lu\n",
            GetLastError()));
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        //
        // Need to build a string with the new NDS UNC path for subtree object
        //
        newPathStr = (PVOID) LocalAlloc( LMEM_ZEROINIT,
                                         ( wcslen( StrippedObjectName ) +
                                           TreeServerName.Length + 4 )
                                         * sizeof(WCHAR) );

        if ( newPathStr == NULL )
        {
            (void) LocalFree((HLOCAL) StrippedObjectName);

            KdPrint(("NWWORKSTATION: NwVerifyNDSObject LocalAlloc Failed %lu\n",
            GetLastError()));
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        wcscpy( newPathStr, L"\\\\" );
        wcsncat( newPathStr, TreeServerName.Buffer, TreeServerName.Length );
        wcscat( newPathStr, L"\\" );
        wcscat( newPathStr, StrippedObjectName );
        _wcsupr( newPathStr );

        //
        // Don't need the StrippedObjectName string anymore
        //
        (void) LocalFree((HLOCAL) StrippedObjectName);
        StrippedObjectName = NULL;

        *lpFullNDSObjectNamePath = newPathStr;
        status = NO_ERROR;
    } // End of Block

ErrorExit:

    if ( fImpersonate )
        (void) NwRevertToSelf() ;

    if ( ConnectionHandle )
        CloseHandle( ConnectionHandle );

    return status;
}


DWORD
NwVerifyBinderyObject(
    IN  LPWSTR   lpBinderyObjectPathName,
    OUT LPWSTR * lpFullBinderyObjectPathName,
    OUT LPDWORD  lpClassType,
    OUT LPDWORD  lpResourceScope,
    OUT LPDWORD  lpResourceType,
    OUT LPDWORD  lpResourceDisplayType,
    OUT LPDWORD  lpResourceUsage
    )
{
    DWORD    status = NO_ERROR;
    HANDLE   ConnectionHandle = NULL;
    BOOL     fImpersonate = FALSE ;
    BOOL     fResourceTypeDisk = FALSE ;
    BOOL     fIsNdsUnc = FALSE ;
    UNICODE_STRING BinderyConnectStr;
    ULONG    CreateDisposition = 0;
    ULONG    CreateOptions = 0;
    WORD     wSlashCount;
    LPWSTR   FourthSlash;

    if ( lpBinderyObjectPathName == NULL )
    {
        //
        // Handle this as if we are at the root of our provider hierarchy.
        //
        *lpResourceScope = RESOURCE_GLOBALNET;
        *lpResourceType = RESOURCETYPE_ANY;
#ifdef NT1057
        *lpResourceDisplayType = 0;
#else
        *lpResourceDisplayType = RESOURCEDISPLAYTYPE_NETWORK;
#endif
        *lpResourceUsage = RESOURCEUSAGE_CONTAINER;

        *lpFullBinderyObjectPathName = NULL;

        return NO_ERROR;
    }

    //
    // Open a connection handle to \\server\vol\...
    //

    BinderyConnectStr.Buffer = NULL;

    //
    // Find out if we are looking at a \\server, \\server\vol, or
    // \\server\vol\dir . . .
    //
    NwpGetUncInfo( lpBinderyObjectPathName,
                   &wSlashCount,
                   &fIsNdsUnc,
                   &FourthSlash );

    if ( wSlashCount > 2 )
        fResourceTypeDisk = TRUE;

    //
    // Impersonate the client
    //
    if ( ( status = NwImpersonateClient() ) != NO_ERROR )
    {
        goto ErrorExit;
    }

    fImpersonate = TRUE;

    //
    // Open a tree connection handle to \Device\NwRdr\ContainerName
    //
    status = NwCreateTreeConnectName( lpBinderyObjectPathName,
                                      NULL,
                                      &BinderyConnectStr );

    if ( status != NO_ERROR )
    {
        status = WN_BAD_NETNAME;
        goto ErrorExit;
    }

    CreateDisposition = FILE_OPEN;
    CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT;

    status = NwOpenCreateConnection( &BinderyConnectStr,
                                     NULL,
                                     NULL,
                                     lpBinderyObjectPathName,
                                     FILE_LIST_DIRECTORY | SYNCHRONIZE,
                                     CreateDisposition,
                                     CreateOptions,
                                     RESOURCETYPE_DISK, // When connecting beyond servername
                                     &ConnectionHandle,
                                     NULL );

    if ( status == NO_ERROR )
    {
        LPWSTR BinderyNameStr = NULL;

        //
        // Need to build a string with the new UNC path for bindery object
        //
        BinderyNameStr = (PVOID) LocalAlloc( LMEM_ZEROINIT,
                                             ( wcslen( lpBinderyObjectPathName ) + 1 )
                                             * sizeof(WCHAR) );

        if ( BinderyNameStr == NULL )
        {
            KdPrint(("NWWORKSTATION: NwVerifyBinderyObject LocalAlloc Failed %lu\n",
            GetLastError()));
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        wcscpy( BinderyNameStr, lpBinderyObjectPathName );
        _wcsupr( BinderyNameStr );

        *lpFullBinderyObjectPathName = BinderyNameStr;

        if ( BinderyConnectStr.Buffer )
            (void) LocalFree((HLOCAL) BinderyConnectStr.Buffer);

        if ( fImpersonate )
            (void) NwRevertToSelf() ;

        if ( ConnectionHandle )
        {
            *lpResourceScope = RESOURCE_GLOBALNET;
            *lpResourceType = fResourceTypeDisk ?
                              RESOURCETYPE_DISK :
                              RESOURCETYPE_ANY;
            *lpResourceDisplayType = fResourceTypeDisk ?
                                     RESOURCEDISPLAYTYPE_SHARE :
                                     RESOURCEDISPLAYTYPE_SERVER;
#ifdef NT1057
            *lpResourceUsage = fResourceTypeDisk ?
                               RESOURCEUSAGE_CONNECTABLE |
                               RESOURCEUSAGE_CONTAINER :
                               RESOURCEUSAGE_CONTAINER;
#else
            *lpResourceUsage = fResourceTypeDisk ?
                               RESOURCEUSAGE_CONNECTABLE |
                               RESOURCEUSAGE_NOLOCALDEVICE :
                               RESOURCEUSAGE_CONTAINER;
#endif

            CloseHandle( ConnectionHandle );
        }

        return NO_ERROR;
    }

ErrorExit:

    *lpFullBinderyObjectPathName = NULL;

    if ( BinderyConnectStr.Buffer )
        (void) LocalFree((HLOCAL) BinderyConnectStr.Buffer);

    if ( fImpersonate )
        (void) NwRevertToSelf() ;

    if ( ConnectionHandle )
        CloseHandle( ConnectionHandle );

    return WN_BAD_NETNAME;
}


DWORD
NwGetNDSPathInfo(
    IN  LPWSTR   lpNDSObjectNamePath,
    OUT LPWSTR * lppSystemObjectNamePath,
    OUT LPWSTR * lpSystemPathPart,
    OUT LPDWORD  lpClassType,
    OUT LPDWORD  lpResourceScope,
    OUT LPDWORD  lpResourceType,
    OUT LPDWORD  lpResourceDisplayType,
    OUT LPDWORD  lpResourceUsage
    )
{
    DWORD    status = NO_ERROR;
    WORD     slashCount;
    BOOL     isNdsUnc;
    BOOL     fReturnBadNetName = FALSE;
    LPWSTR   FourthSlash;
    LPWSTR   lpSystemPath = NULL;

    *lpSystemPathPart = NULL;

    NwpGetUncInfo( lpNDSObjectNamePath,
                   &slashCount,
                   &isNdsUnc,
                   &FourthSlash );

    if ( slashCount <= 3 )
    {
        //
        // Path is to a possible NDS object, check to see if so and if valid...
        //

        status = NwVerifyNDSObject( lpNDSObjectNamePath,
                                    lppSystemObjectNamePath,
                                    lpClassType,
                                    lpResourceScope,
                                    lpResourceType,
                                    lpResourceDisplayType,
                                    lpResourceUsage );

        *lpSystemPathPart = NULL;

        return status;
    }
    else
    {
        //
        // Path is to a directory, see if directory exists . . .
        //
        status = NwVerifyBinderyObject( lpNDSObjectNamePath,
                                        lppSystemObjectNamePath,
                                        lpClassType,
                                        lpResourceScope,
                                        lpResourceType,
                                        lpResourceDisplayType,
                                        lpResourceUsage );
    }

    if ( status == WN_BAD_NETNAME )
    {
        fReturnBadNetName = TRUE;
        status = NO_ERROR;
    }

    if ( status == NO_ERROR )
    {
        WCHAR TempNDSObjectNamePath[256];

        //
        // Test \\tree\obj.obj... component and
        // return network resource for valid parent and the string,
        // lpSystemPathPart, for the directory part ( \dir1\...).
        //

        if ( *lppSystemObjectNamePath != NULL )
        {
            (void) LocalFree( (HLOCAL) (*lppSystemObjectNamePath) );
            *lppSystemObjectNamePath = NULL;
        }

        lpSystemPath = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                                            ( wcslen( FourthSlash ) + 1 ) *
                                              sizeof( WCHAR ) );

        if ( lpSystemPath == NULL )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy( lpSystemPath, FourthSlash );
        *FourthSlash = L'\0';

        wcscpy( TempNDSObjectNamePath, lpNDSObjectNamePath );
        *FourthSlash = L'\\';

        //
        // See if \\tree\obj.obj.... exists . . .
        //
        status = NwVerifyNDSObject( TempNDSObjectNamePath,
                                    lppSystemObjectNamePath,
                                    lpClassType,
                                    lpResourceScope,
                                    lpResourceType,
                                    lpResourceDisplayType,
                                    lpResourceUsage );

        if ( status != NO_ERROR )
        {
            LocalFree( lpSystemPath );
            lpSystemPath = NULL;
        }
    }

    *lpSystemPathPart = lpSystemPath;

    //
    // The provider spec for this function used to tell us to create a 
    // NETRESOURCE, even if the system part of the path was invalid, while
    // returning WN_BAD_NETNAME. Now we return SUCCESS and the NETRESOURCE, 
    // irregardless of whether the lpSystem part is valid.
    // if ( fReturnBadNetName == TRUE )
    // {
    //     return WN_BAD_NETNAME;
    // }

    return status;
}


DWORD
NwGetBinderyPathInfo(
    IN  LPWSTR   lpBinderyObjectNamePath,
    OUT LPWSTR * lppSystemObjectNamePath,
    OUT LPWSTR * lpSystemPathPart,
    OUT LPDWORD  lpClassType,
    OUT LPDWORD  lpResourceScope,
    OUT LPDWORD  lpResourceType,
    OUT LPDWORD  lpResourceDisplayType,
    OUT LPDWORD  lpResourceUsage
    )
{
    DWORD    status = NO_ERROR;
    WORD     slashCount;
    BOOL     isNdsUnc;
    LPWSTR   FourthSlash;
    LPWSTR   lpSystemPath = NULL;

    *lpSystemPathPart = NULL;

    NwpGetUncInfo( lpBinderyObjectNamePath,
                   &slashCount,
                   &isNdsUnc,
                   &FourthSlash );

    if ( slashCount <= 3 )
    {
        //
        // Path is to a server or volume, check to see which and if valid . . .
        //

        status = NwVerifyBinderyObject( lpBinderyObjectNamePath,
                                        lppSystemObjectNamePath,
                                        lpClassType,
                                        lpResourceScope,
                                        lpResourceType,
                                        lpResourceDisplayType,
                                        lpResourceUsage );

        *lpSystemPathPart = NULL;

        return status;
    }
    else
    {
        //
        // Path is to a directory, see if directory exists . . .
        //
        status = NwVerifyBinderyObject( lpBinderyObjectNamePath,
                                        lppSystemObjectNamePath,
                                        lpClassType,
                                        lpResourceScope,
                                        lpResourceType,
                                        lpResourceDisplayType,
                                        lpResourceUsage );
    }

    if ( status == WN_BAD_NETNAME )
    {
        WCHAR TempBinderyObjectNamePath[256];

        //
        // Path is to a invalid directory. Test \\server\volume component and
        // return network resource for valid parent and the string,
        // lpSystemPathPart, for the directory part ( \dir1\...).
        //

        lpSystemPath = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                                            ( wcslen( FourthSlash ) + 1 ) *
                                              sizeof( WCHAR ) );

        if ( lpSystemPath == NULL )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy( lpSystemPath, FourthSlash );
        *FourthSlash = L'\0';

        wcscpy( TempBinderyObjectNamePath, lpBinderyObjectNamePath );
        *FourthSlash = L'\\';

        //
        // See if \\server\volume exists . . .
        //
        status = NwVerifyBinderyObject( TempBinderyObjectNamePath,
                                        lppSystemObjectNamePath,
                                        lpClassType,
                                        lpResourceScope,
                                        lpResourceType,
                                        lpResourceDisplayType,
                                        lpResourceUsage );

        if ( status != NO_ERROR )
        {
            LocalFree( lpSystemPath );
            lpSystemPath = NULL;
        }

        //
        // Return SUCCESS, since the NETRESOURCE for \\server\volume that
        // we are describing is at least valid, even though the lpSystem
        // part in not. This is a change in the provider spec (4/25/96).
        //
        // else
        // {
        //     status = WN_BAD_NETNAME;
        // }
    }
    else
    {
        //
        // Path is to a valid directory. Return resource information for the
        // \\server\volume component and the string, lpSystemPathPart, for the
        // directory part ( \dir1\...).
        //
        NwpGetUncInfo( *lppSystemObjectNamePath,
                       &slashCount,
                       &isNdsUnc,
                       &FourthSlash );

        lpSystemPath = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                                            ( wcslen( FourthSlash ) + 1 ) *
                                              sizeof( WCHAR ) );

        if ( lpSystemPath == NULL )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy( lpSystemPath, FourthSlash );
        *FourthSlash = L'\0';

        *lpResourceScope = RESOURCE_GLOBALNET;
        *lpResourceType =  RESOURCETYPE_DISK;
        *lpResourceDisplayType = RESOURCEDISPLAYTYPE_SHARE;
#ifdef NT1057
        *lpResourceUsage = RESOURCEUSAGE_CONNECTABLE |
                           RESOURCEUSAGE_CONTAINER;
#else
        *lpResourceUsage = RESOURCEUSAGE_CONNECTABLE |
                           RESOURCEUSAGE_NOLOCALDEVICE;
#endif

        status = NO_ERROR;
    }

    *lpSystemPathPart = lpSystemPath;

    return status;
}


BOOL
NwGetRemoteNameParent(
    IN  LPWSTR   lpRemoteName,
    OUT LPWSTR * lpRemoteNameParent
    )
{
    unsigned short iter = 0;
    unsigned short totalLength = (USHORT) wcslen( lpRemoteName );
    unsigned short slashCount = 0;
    unsigned short dotCount = 0;
    unsigned short thirdSlash = 0;
    unsigned short lastSlash = 0;
    unsigned short parentNDSSubTree = 0;
    LPWSTR         newRemoteNameParent = NULL;

    if ( totalLength < 2 )
        return FALSE;

    //
    // Get thirdSlash to indicate the character in the string that indicates the
    // "\" in between the tree name and the rest of the UNC path. Set parentNDSSubTree
    // if available. And always set lastSlash to the most recent "\" seen as you walk.
    //
    // Example:  \\<tree name>\path.to.object[\|.]<object>
    //                        ^    ^
    //                        |    |
    //                thirdSlash  parentNDSSubTree
    //
    while ( iter < totalLength )
    {
        if ( lpRemoteName[iter] == L'\\' )
        {
            slashCount += 1;
            if ( slashCount == 3 )
                thirdSlash = iter;

            lastSlash = iter;
        }

        if ( lpRemoteName[iter] == L'.' )
        {
            dotCount += 1;
            if ( dotCount == 1 )
                parentNDSSubTree = iter;
        }

        iter++;
    }

    if ( slashCount > 3 )
    {
        newRemoteNameParent = (PVOID) LocalAlloc( LMEM_ZEROINIT,
                                                  ( lastSlash + 1 ) *
                                                  sizeof(WCHAR));

        if ( newRemoteNameParent == NULL )
        {
            KdPrint(("NWWORKSTATION: NwGetRemoteNameParent LocalAlloc Failed %lu\n",
            GetLastError()));
            return FALSE;
        }

        wcsncpy( newRemoteNameParent, lpRemoteName, lastSlash );
        _wcsupr( newRemoteNameParent );

        *lpRemoteNameParent = newRemoteNameParent;

        return TRUE;
    }

    if ( slashCount == 3 )
    {
        if ( dotCount == 0 )
        {
            newRemoteNameParent = (PVOID) LocalAlloc( LMEM_ZEROINIT,
                                                      ( lastSlash + 1 ) *
                                                      sizeof(WCHAR));

            if ( newRemoteNameParent == NULL )
            {
                KdPrint(("NWWORKSTATION: NwGetRemoteNameParent LocalAlloc Failed %lu\n",
                GetLastError()));
                return FALSE;
            }

            wcsncpy( newRemoteNameParent, lpRemoteName, lastSlash );
            _wcsupr( newRemoteNameParent );

            *lpRemoteNameParent = newRemoteNameParent;

            return TRUE;
        }
        else
        {
            newRemoteNameParent = (PVOID) LocalAlloc( LMEM_ZEROINIT,
                                                      ( totalLength -
                                                        ( parentNDSSubTree - thirdSlash )
                                                        + 1 )
                                                      * sizeof(WCHAR) );

            if ( newRemoteNameParent == NULL )
            {
                KdPrint(("NWWORKSTATION: NwGetRemoteNameParent LocalAlloc Failed %lu\n",
                GetLastError()));
                return FALSE;
            }

            wcsncpy( newRemoteNameParent, lpRemoteName, thirdSlash + 1 );
            wcscat( newRemoteNameParent, &lpRemoteName[parentNDSSubTree+1] );
            _wcsupr( newRemoteNameParent );

            *lpRemoteNameParent = newRemoteNameParent;

            return TRUE;
        }
    }

    // Else we set lpRemoteNameParent to NULL, to indicate that we are at the top and
    // return TRUE.
    *lpRemoteNameParent = NULL;

    return TRUE;
}


DWORD
NwGetFirstDirectoryEntry(
    IN HANDLE DirHandle,
    OUT LPWSTR *DirEntry
    )
/*++

Routine Description:

    This function is called by NwEnumDirectories to get the first
    directory entry given a handle to the directory.  It allocates
    the output buffer to hold the returned directory name; the
    caller should free this output buffer with LocalFree when done.

Arguments:

    DirHandle - Supplies the opened handle to the container
        directory find a directory within it.

    DirEntry - Receives a pointer to the returned directory
        found.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Out of memory allocating output
        buffer.

    Other errors from NtQueryDirectoryFile.

--*/ // NwGetFirstDirectoryEntry
{
    DWORD status = NO_ERROR;
    NTSTATUS ntstatus = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;

    PFILE_DIRECTORY_INFORMATION DirInfo;

    UNICODE_STRING StartFileName;

#if DBG
    DWORD i = 0;
#endif

    //
    // Allocate a large buffer to get one directory information entry.
    //
    DirInfo = (PVOID) LocalAlloc(
                          LMEM_ZEROINIT,
                          sizeof(FILE_DIRECTORY_INFORMATION) +
                              (MAX_PATH * sizeof(WCHAR))
                          );

    if (DirInfo == NULL) {
        KdPrint(("NWWORKSTATION: NwGetFirstDirectoryEntry LocalAlloc Failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlInitUnicodeString(&StartFileName, L"*");

    ntstatus = NtQueryDirectoryFile(
                   DirHandle,
                   NULL,
                   NULL,
                   NULL,
                   &IoStatusBlock,
                   DirInfo,
                   sizeof(FILE_DIRECTORY_INFORMATION) +
                       (MAX_PATH * sizeof(WCHAR)),
                   FileDirectoryInformation,   // Info class requested
                   TRUE,                       // Return single entry
                   &StartFileName,             // Redirector needs this
                   TRUE                        // Restart scan
                   );

    //
    // For now, if buffer to NtQueryDirectoryFile is too small, just give
    // up.  We may want to try to reallocate a bigger buffer at a later time.
    //

    if (ntstatus == STATUS_SUCCESS) {
        ntstatus = IoStatusBlock.Status;
    }

    if (ntstatus != STATUS_SUCCESS) {

        if (ntstatus == STATUS_NO_MORE_FILES) {
            //
            // We ran out of entries.
            //
            status = WN_NO_MORE_ENTRIES;
        }
        else {
            KdPrint(("NWWORKSTATION: NwGetFirstDirectoryEntry: NtQueryDirectoryFile returns %08lx\n",
                     ntstatus));
            status = RtlNtStatusToDosError(ntstatus);
        }

        goto CleanExit;
    }

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("GetFirst(%u) got %ws, attributes %08lx\n", ++i,
                 DirInfo->FileName, DirInfo->FileAttributes));
    }
#endif

    //
    // Scan until we find the first directory entry that is not "." or ".."
    //
    while (!(DirInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
           memcmp(DirInfo->FileName, L".", DirInfo->FileNameLength) == 0 ||
           memcmp(DirInfo->FileName, L"..", DirInfo->FileNameLength) == 0) {

        ntstatus = NtQueryDirectoryFile(
                       DirHandle,
                       NULL,
                       NULL,
                       NULL,
                       &IoStatusBlock,
                       DirInfo,
                       sizeof(FILE_DIRECTORY_INFORMATION) +
                           (MAX_PATH * sizeof(WCHAR)),
                       FileDirectoryInformation,   // Info class requested
                       TRUE,                       // Return single entry
                       NULL,
                       FALSE                       // Restart scan
                       );

        if (ntstatus == STATUS_SUCCESS) {
            ntstatus = IoStatusBlock.Status;
        }

        if (ntstatus != STATUS_SUCCESS) {

            if (ntstatus == STATUS_NO_MORE_FILES) {
                //
                // We ran out of entries.
                //
                status = WN_NO_MORE_ENTRIES;
            }
            else {
                KdPrint(("NWWORKSTATION: NwGetFirstDirectoryEntry: NtQueryDirectoryFile returns %08lx\n",
                         ntstatus));
                status = RtlNtStatusToDosError(ntstatus);
            }

            goto CleanExit;
        }

#if DBG
        IF_DEBUG(ENUM) {
            KdPrint(("GetFirst(%u) got %ws, attributes %08lx\n", ++i,
                     DirInfo->FileName, DirInfo->FileAttributes));
        }
#endif
    }

    //
    // Allocate the output buffer for the returned directory name
    //
    *DirEntry = (PVOID) LocalAlloc(
                            LMEM_ZEROINIT,
                            DirInfo->FileNameLength + sizeof(WCHAR)
                            );

    if (*DirEntry == NULL) {
        KdPrint(("NWWORKSTATION: NwGetFirstDirectoryEntry LocalAlloc Failed %lu\n",
                 GetLastError()));
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }

    memcpy(*DirEntry, DirInfo->FileName, DirInfo->FileNameLength);

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("NWWORKSTATION: NwGetFirstDirectoryEntry returns %ws\n",
                 *DirEntry));
    }
#endif

    status = NO_ERROR;

CleanExit:
    (void) LocalFree((HLOCAL) DirInfo);

    //
    // We could not find any directories under the requested
    // so we need to treat this as no entries.
    //
    if ( status == ERROR_FILE_NOT_FOUND )
        status = WN_NO_MORE_ENTRIES;

    return status;
}



DWORD
NwGetNextDirectoryEntry(
    IN HANDLE DirHandle,
    OUT LPWSTR *DirEntry
    )
/*++

Routine Description:

    This function is called by NwEnumDirectories to get the next
    directory entry given a handle to the directory.  It allocates
    the output buffer to hold the returned directory name; the
    caller should free this output buffer with LocalFree when done.

Arguments:

    DirHandle - Supplies the opened handle to the container
        directory find a directory within it.

    DirEntry - Receives a pointer to the returned directory
        found.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Out of memory allocating output
        buffer.

    Other errors from NtQueryDirectoryFile.

--*/ // NwGetNextDirectoryEntry
{
    DWORD status = NO_ERROR;
    NTSTATUS ntstatus = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;

    PFILE_DIRECTORY_INFORMATION DirInfo;

    //
    // Allocate a large buffer to get one directory information entry.
    //
    DirInfo = (PVOID) LocalAlloc(
                          LMEM_ZEROINIT,
                          sizeof(FILE_DIRECTORY_INFORMATION) +
                              (MAX_PATH * sizeof(WCHAR))
                          );

    if (DirInfo == NULL) {
        KdPrint(("NWWORKSTATION: NwGetNextDirectoryEntry LocalAlloc Failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do {

        ntstatus = NtQueryDirectoryFile(
                       DirHandle,
                       NULL,
                       NULL,
                       NULL,
                       &IoStatusBlock,
                       DirInfo,
                       sizeof(FILE_DIRECTORY_INFORMATION) +
                           (MAX_PATH * sizeof(WCHAR)),
                       FileDirectoryInformation,   // Info class requested
                       TRUE,                       // Return single entry
                       NULL,
                       FALSE                       // Restart scan
                       );

        if (ntstatus == STATUS_SUCCESS) {
            ntstatus = IoStatusBlock.Status;
        }

    } while (ntstatus == STATUS_SUCCESS &&
             !(DirInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY));


    if (ntstatus != STATUS_SUCCESS) {

        if (ntstatus == STATUS_NO_MORE_FILES) {
            //
            // We ran out of entries.
            //
            status = WN_NO_MORE_ENTRIES;
        }
        else {
            KdPrint(("NWWORKSTATION: NwGetNextDirectoryEntry: NtQueryDirectoryFile returns %08lx\n",
                     ntstatus));
            status = RtlNtStatusToDosError(ntstatus);
        }

        goto CleanExit;
    }


    //
    // Allocate the output buffer for the returned directory name
    //
    *DirEntry = (PVOID) LocalAlloc(
                            LMEM_ZEROINIT,
                            DirInfo->FileNameLength + sizeof(WCHAR)
                            );

    if (*DirEntry == NULL) {
        KdPrint(("NWWORKSTATION: NwGetNextDirectoryEntry LocalAlloc Failed %lu\n",
                 GetLastError()));
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }

    memcpy(*DirEntry, DirInfo->FileName, DirInfo->FileNameLength);

#if DBG
   IF_DEBUG(ENUM) {
        KdPrint(("NWWORKSTATION: NwGetNextDirectoryEntry returns %ws\n",
                 *DirEntry));
    }
#endif

    status = NO_ERROR;

CleanExit:
    (void) LocalFree((HLOCAL) DirInfo);

    return status;
}


DWORD
NwWriteNetResourceEntry(
    IN OUT LPBYTE * FixedPortion,
    IN OUT LPWSTR * EndOfVariableData,
    IN LPWSTR ContainerName OPTIONAL,
    IN LPWSTR LocalName OPTIONAL,
    IN LPWSTR RemoteName,
    IN DWORD ScopeFlag,
    IN DWORD DisplayFlag,
    IN DWORD UsageFlag,
    IN DWORD ResourceType,
    IN LPWSTR SystemPath OPTIONAL,
    OUT LPWSTR * lppSystem OPTIONAL,
    OUT LPDWORD EntrySize
    )
/*++

Routine Description:

    This function packages a NETRESOURCE entry into the user output buffer.
    It is called by the various enum resource routines.

Arguments:

    FixedPortion - Supplies a pointer to the output buffer where the next
        entry of the fixed portion of the use information will be written.
        This pointer is updated to point to the next fixed portion entry
        after a NETRESOURCE entry is written.

    EndOfVariableData - Supplies a pointer just off the last available byte
        in the output buffer.  This is because the variable portion of the
        user information is written into the output buffer starting from
        the end.

        This pointer is updated after any variable length information is
        written to the output buffer.

    ContainerName - Supplies the full path qualifier to make RemoteName
        a full UNC name.

    LocalName - Supplies the local device name, if any.

    RemoteName - Supplies the remote resource name.

    ScopeFlag - Supplies the flag which indicates whether this is a
        CONNECTED or GLOBALNET resource.

    DisplayFlag - Supplies the flag which tells the UI how to display
        the resource.

    UsageFlag - Supplies the flag which indicates that the RemoteName
        is either a container or a connectable resource or both.

    SystemPath - Supplies the optional system path data to be stored in the
        NETRESOURCE buffer. This is used by the NPGetResourceInformation
        helper routines.

    lppSystem - If SystemPath is provided, this will point to the location
        in the NETRESOURCE buffer that contains the system path string.

    EntrySize - Receives the size of the NETRESOURCE entry in bytes.

Return Value:

    NO_ERROR - Successfully wrote entry into user buffer.

    ERROR_NOT_ENOUGH_MEMORY - Failed to allocate work buffer.

    WN_MORE_DATA - Buffer was too small to fit entry.

--*/ // NwWriteNetResourceEntry
{
    BOOL FitInBuffer = TRUE;
    LPNETRESOURCEW NetR = (LPNETRESOURCEW) *FixedPortion;
    LPWSTR RemoteBuffer;
    LPWSTR lpSystem;

    *EntrySize = sizeof(NETRESOURCEW) +
                     (wcslen(RemoteName) + wcslen(NwProviderName) + 2) *
                          sizeof(WCHAR);


    if (ARGUMENT_PRESENT(LocalName)) {
        *EntrySize += (wcslen(LocalName) + 1) * sizeof(WCHAR);
    }

    if (ARGUMENT_PRESENT(ContainerName)) {
        *EntrySize += wcslen(ContainerName) * sizeof(WCHAR);
    }

    if (ARGUMENT_PRESENT(SystemPath)) {
        *EntrySize += wcslen(SystemPath) * sizeof(WCHAR);
    }

    *EntrySize = ROUND_UP_COUNT( *EntrySize, ALIGN_DWORD);

    //
    // See if buffer is large enough to fit the entry.
    //
    if ((LPWSTR) ( *FixedPortion + *EntrySize) > *EndOfVariableData) {

        return WN_MORE_DATA;
    }

    NetR->dwScope = ScopeFlag;
    NetR->dwType = ResourceType;
    NetR->dwDisplayType = DisplayFlag;
    NetR->dwUsage = UsageFlag;
    NetR->lpComment = NULL;

    //
    // Update fixed entry pointer to next entry.
    //
    (*FixedPortion) += sizeof(NETRESOURCEW);

    //
    // RemoteName
    //
    if (ARGUMENT_PRESENT(ContainerName)) {

        //
        // Prefix the RemoteName with its container name making the
        // it a fully-qualified UNC name.
        //
        RemoteBuffer = (PVOID) LocalAlloc(
                                   LMEM_ZEROINIT,
                                   (wcslen(RemoteName) + wcslen(ContainerName) + 1) *
                                        sizeof(WCHAR)
                                   );

        if (RemoteBuffer == NULL) {
            KdPrint(("NWWORKSTATION: NwWriteNetResourceEntry LocalAlloc failed %lu\n",
                     GetLastError()));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(RemoteBuffer, ContainerName);
        wcscat(RemoteBuffer, RemoteName);
    }
    else {
        RemoteBuffer = RemoteName;
    }

    FitInBuffer = NwlibCopyStringToBuffer(
                      RemoteBuffer,
                      wcslen(RemoteBuffer),
                      (LPCWSTR) *FixedPortion,
                      EndOfVariableData,
                      &NetR->lpRemoteName
                      );

    if (ARGUMENT_PRESENT(ContainerName)) {
        (void) LocalFree((HLOCAL) RemoteBuffer);
    }

    ASSERT(FitInBuffer);

    //
    // LocalName
    //
    if (ARGUMENT_PRESENT(LocalName)) {
        FitInBuffer = NwlibCopyStringToBuffer(
                          LocalName,
                          wcslen(LocalName),
                          (LPCWSTR) *FixedPortion,
                          EndOfVariableData,
                          &NetR->lpLocalName
                          );

        ASSERT(FitInBuffer);
    }
    else {
        NetR->lpLocalName = NULL;
    }

    //
    // SystemPath
    //
    if (ARGUMENT_PRESENT(SystemPath)) {
        FitInBuffer = NwlibCopyStringToBuffer(
                          SystemPath,
                          wcslen(SystemPath),
                          (LPCWSTR) *FixedPortion,
                          EndOfVariableData,
                          &lpSystem
                          );

        ASSERT(FitInBuffer);
    }
    else {
        lpSystem = NULL;
    }

    if (ARGUMENT_PRESENT(lppSystem)) {
        *lppSystem = lpSystem;
    }

    //
    // ProviderName
    //
    FitInBuffer = NwlibCopyStringToBuffer(
                      NwProviderName,
                      wcslen(NwProviderName),
                      (LPCWSTR) *FixedPortion,
                      EndOfVariableData,
                      &NetR->lpProvider
                      );

    ASSERT(FitInBuffer);

    if (! FitInBuffer) {
        return WN_MORE_DATA;
    }

    return NO_ERROR;
}


DWORD
NwWritePrinterInfoEntry(
    IN OUT LPBYTE *FixedPortion,
    IN OUT LPWSTR *EndOfVariableData,
    IN LPWSTR ContainerName OPTIONAL,
    IN LPWSTR RemoteName,
    IN DWORD  Flags,
    OUT LPDWORD EntrySize
    )
/*++

Routine Description:

    This function packages a PRINTER_INFO_1 entry into the user output buffer.

Arguments:

    FixedPortion - Supplies a pointer to the output buffer where the next
        entry of the fixed portion of the use information will be written.
        This pointer is updated to point to the next fixed portion entry
        after a PRINT_INFO_1 entry is written.

    EndOfVariableData - Supplies a pointer just off the last available byte
        in the output buffer.  This is because the variable portion of the
        user information is written into the output buffer starting from
        the end.

        This pointer is updated after any variable length information is
        written to the output buffer.

    ContainerName - Supplies the full path qualifier to make RemoteName
        a full UNC name.

    RemoteName - Supplies the remote resource name.

    Flags - Supplies the flag which indicates that the RemoteName
            is either a container or not and the icon to use.

    EntrySize - Receives the size of the PRINTER_INFO_1 entry in bytes.

Return Value:

    NO_ERROR - Successfully wrote entry into user buffer.

    ERROR_NOT_ENOUGH_MEMORY - Failed to allocate work buffer.

    ERROR_INSUFFICIENT_BUFFER - Buffer was too small to fit entry.

--*/ // NwWritePrinterInfoEntry
{
    BOOL FitInBuffer = TRUE;
    PRINTER_INFO_1W *pPrinterInfo1 = (PRINTER_INFO_1W *) *FixedPortion;
    LPWSTR RemoteBuffer;

    *EntrySize = sizeof(PRINTER_INFO_1W) +
                     ( 2 * wcslen(RemoteName) + 2) * sizeof(WCHAR);

    if (ARGUMENT_PRESENT(ContainerName)) {
        *EntrySize += wcslen(ContainerName) * sizeof(WCHAR);
    }
    else {
        // 3 is for the length of "!\\"
        *EntrySize += (wcslen(NwProviderName) + 3) * sizeof(WCHAR);
    }

    *EntrySize = ROUND_UP_COUNT( *EntrySize, ALIGN_DWORD);

    //
    // See if buffer is large enough to fit the entry.
    //
    if ((LPWSTR) (*FixedPortion + *EntrySize) > *EndOfVariableData) {

        return ERROR_INSUFFICIENT_BUFFER;
    }

    pPrinterInfo1->Flags = Flags;
    pPrinterInfo1->pComment = NULL;

    //
    // Update fixed entry pointer to next entry.
    //
    (*FixedPortion) += sizeof(PRINTER_INFO_1W);

    //
    // Name
    //
    if (ARGUMENT_PRESENT(ContainerName)) {

        //
        // Prefix the RemoteName with its container name making the
        // it a fully-qualified UNC name.
        //
        RemoteBuffer = (PVOID) LocalAlloc(
                                   LMEM_ZEROINIT,
                                   (wcslen(ContainerName) + wcslen(RemoteName)
                                    + 1) * sizeof(WCHAR) );

        if (RemoteBuffer == NULL) {
            KdPrint(("NWWORKSTATION: NwWritePrinterInfoEntry LocalAlloc failed %lu\n", GetLastError()));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(RemoteBuffer, ContainerName);
        wcscat(RemoteBuffer, RemoteName);
    }
    else {
        //
        // Prefix the RemoteName with its provider name
        //
        RemoteBuffer = (PVOID) LocalAlloc(
                                   LMEM_ZEROINIT,
                                   (wcslen(RemoteName) +
                                    wcslen(NwProviderName) + 4)
                                    * sizeof(WCHAR) );

        if (RemoteBuffer == NULL) {
            KdPrint(("NWWORKSTATION: NwWritePrinterInfoEntry LocalAlloc failed %lu\n", GetLastError()));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(RemoteBuffer, NwProviderName );
        wcscat(RemoteBuffer, L"!\\\\" );
        wcscat(RemoteBuffer, RemoteName);
    }

    FitInBuffer = NwlibCopyStringToBuffer(
                      RemoteBuffer,
                      wcslen(RemoteBuffer),
                      (LPCWSTR) *FixedPortion,
                      EndOfVariableData,
                      &pPrinterInfo1->pName );

    (void) LocalFree((HLOCAL) RemoteBuffer);

    ASSERT(FitInBuffer);

    //
    // Description
    //
    FitInBuffer = NwlibCopyStringToBuffer(
                      RemoteName,
                      wcslen(RemoteName),
                      (LPCWSTR) *FixedPortion,
                      EndOfVariableData,
                      &pPrinterInfo1->pDescription );

    ASSERT(FitInBuffer);

    if (! FitInBuffer) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    return NO_ERROR;
}


int __cdecl
SortFunc(
    IN CONST VOID *p1,
    IN CONST VOID *p2
)
/*++

Routine Description:

    This function is used in qsort to compare the descriptions of
    two printer_info_1 structure.

Arguments:

    p1 - Points to a PRINTER_INFO_1 structure
    p2 - Points to a PRINTER_INFO_1 structure to compare with p1

Return Value:

    Same as return value of lstrccmpi.

--*/
{
    PRINTER_INFO_1W *pFirst  = (PRINTER_INFO_1W *) p1;
    PRINTER_INFO_1W *pSecond = (PRINTER_INFO_1W *) p2;

    return lstrcmpiW( pFirst->pDescription, pSecond->pDescription );
}



DWORD
NwGetConnectionInformation(
    IN  LPWSTR lpName,
    OUT LPWSTR lpUserName,
    OUT LPWSTR lpHostServer
    )
{
    DWORD status = NO_ERROR;
    NTSTATUS ntstatus = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess = SYNCHRONIZE | FILE_LIST_DIRECTORY;
    HANDLE hRdr = NULL;
    BOOL  fImpersonate = FALSE ;

    WCHAR OpenString[] = L"\\Device\\Nwrdr\\*";
    UNICODE_STRING OpenName;

    OEM_STRING OemArg;
    UNICODE_STRING ConnectionName;
    WCHAR ConnectionBuffer[512];

    ULONG BufferSize = 512;
    ULONG RequestSize, ReplyLen;
    PNWR_REQUEST_PACKET Request;
    BYTE *Reply;

    PCONN_INFORMATION pConnInfo;
    UNICODE_STRING Name;

    //
    // Allocate buffer space.
    //

    Request = (PNWR_REQUEST_PACKET) LocalAlloc( LMEM_ZEROINIT, BufferSize );

    if ( !Request )
    {
       status = ERROR_NOT_ENOUGH_MEMORY;

        goto ErrorExit;
    }

    //
    // Impersonate the client
    //
    if ( ( status = NwImpersonateClient() ) != NO_ERROR )
    {
        goto ErrorExit;
    }

    fImpersonate = TRUE;

    //
    // Convert the connect name to unicode.
    //
    ConnectionName.Length = wcslen( lpName )* sizeof(WCHAR);
    ConnectionName.MaximumLength = sizeof( ConnectionBuffer );
    ConnectionName.Buffer = ConnectionBuffer;

    wcscpy( ConnectionName.Buffer, lpName );
    _wcsupr( ConnectionName.Buffer );

    //
    // Set up the object attributes.
    //

    RtlInitUnicodeString( &OpenName, OpenString );

    InitializeObjectAttributes( &ObjectAttributes,
                                &OpenName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntstatus = NtOpenFile( &hRdr,
                           DesiredAccess,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_VALID_FLAGS,
                           FILE_SYNCHRONOUS_IO_NONALERT );

    if ( ntstatus != STATUS_SUCCESS )
    {
        status = RtlNtStatusToDosError(ntstatus);

        goto ErrorExit;
    }

    //
    // Fill out the request packet for FSCTL_NWR_GET_CONN_INFO.
    //

    Request->Parameters.GetConnInfo.ConnectionNameLength = ConnectionName.Length;
    RtlCopyMemory( &(Request->Parameters.GetConnInfo.ConnectionName[0]),
                   ConnectionBuffer,
                   ConnectionName.Length );

    RequestSize = sizeof( Request->Parameters.GetConnInfo ) + ConnectionName.Length;
    Reply = ((PBYTE)Request) + RequestSize;
    ReplyLen = BufferSize - RequestSize;

    ntstatus = NtFsControlFile( hRdr,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_NWR_GET_CONN_INFO,
                                (PVOID) Request,
                                RequestSize,
                                (PVOID) Reply,
                                ReplyLen );

    if ( ntstatus != STATUS_SUCCESS )
    {
        status = RtlNtStatusToDosError(ntstatus);

        goto ErrorExit;
    }

    (void) NwRevertToSelf() ;
    fImpersonate = FALSE;

    NtClose( hRdr );

    pConnInfo = (PCONN_INFORMATION) Reply;
    wcscpy( lpUserName, pConnInfo->UserName );
    wcscpy( lpHostServer, pConnInfo->HostServer );

    LocalFree( Request );

    return NO_ERROR;

ErrorExit:

    if ( fImpersonate )
        (void) NwRevertToSelf() ;

    if ( Request )
        LocalFree( Request );

    if ( hRdr )
        NtClose( hRdr );

   return status;
}


VOID
NwpGetUncInfo(
    IN LPWSTR lpstrUnc,
    OUT WORD * slashCount,
    OUT BOOL * isNdsUnc,
    OUT LPWSTR * FourthSlash
    )
{
    BYTE   i;
    WORD   length = (WORD) wcslen( lpstrUnc );

    *isNdsUnc = (BOOL) FALSE;
    *slashCount = 0;
    *FourthSlash = NULL;

    for ( i = 0; i < length; i++ )
    {
        if ( lpstrUnc[i] == L'=' )
        {
            *isNdsUnc = TRUE;
        }

        if ( lpstrUnc[i] == L'\\' )
        {
            *slashCount += 1;

            if ( *slashCount == 4 )
            {
                *FourthSlash = &lpstrUnc[i];
            }
        }
    }
}


DWORD
NwpGetCurrentUserRegKey(
    IN  DWORD DesiredAccess,
    OUT HKEY  *phKeyCurrentUser
    )
/*++

Routine Description:

    This routine opens the current user's registry key under
    \HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NWCWorkstation\Parameters

Arguments:

    DesiredAccess - The access mask to open the key with

    phKeyCurrentUser - Receives the opened key handle

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD err;
    HKEY hkeyWksta;
    LPWSTR CurrentUser;

    HKEY hInteractiveLogonKey;                       //Multi-user
    HKEY OneLogonKey;                                //Multi-user
    LUID logonid;                                    //Multi-user
    WCHAR LogonIdKeyName[NW_MAX_LOGON_ID_LEN];       //Multi-user

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters
    //
    err = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_WORKSTATION_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ,
                   &hkeyWksta
                   );

    if ( err ) {
        KdPrint(("NWPROVAU: NwGetCurrentUserRegKey open Parameters key unexpected error %lu!\n", err));
        return err;
    }


    //
    // Impersonate the client
    //
    if ( ( err = NwImpersonateClient() ) != NO_ERROR ) {
        (void) RegCloseKey( hkeyWksta );
        return err;
    }

    //
    // Get the NT logon id
    //
    GetLuid( &logonid );

    //
    // Revert
    //
    (void) NwRevertToSelf() ;

    // Open interactive user section

    err = RegOpenKeyExW(
                       HKEY_LOCAL_MACHINE,
                       NW_INTERACTIVE_LOGON_REGKEY,
                       REG_OPTION_NON_VOLATILE,
                       KEY_READ,
                       &hInteractiveLogonKey
                       );

    if ( err ) {
        KdPrint(("NWPROVAU: NwGetCurrentUserRegKey open Interactive logon key unexpected error %lu!\n", err));
        (void) RegCloseKey( hkeyWksta );
        return err;
    }

    // Open the logonid

    NwLuidToWStr(&logonid, LogonIdKeyName);

    err = RegOpenKeyExW(
                       hInteractiveLogonKey,
                       LogonIdKeyName,
                       REG_OPTION_NON_VOLATILE,
                       KEY_READ,
                       &OneLogonKey
                       );

    (void) RegCloseKey( hInteractiveLogonKey );

    if ( err ) {
        KdPrint(("NWPROVAU: NwGetCurrentUserRegKey open logon key unexpected error %lu!\n", err));
        (void) RegCloseKey( hkeyWksta );
        return err;
    }

    // Read SID 

    err = NwReadRegValue(
                        OneLogonKey,
                        NW_SID_VALUENAME,
                        &CurrentUser
                        );

    if ( err ) {
        KdPrint(("NWPROVAU: NwGetCurrentUserRegKey read user Sid unexpected error %lu!\n", err));
        (void) RegCloseKey( hkeyWksta );
        return err;
    }

    (void) RegCloseKey( OneLogonKey );


    (void) RegCloseKey( hkeyWksta );

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters\Option
    //
    err = RegOpenKeyExW(
                       HKEY_LOCAL_MACHINE,
                       NW_WORKSTATION_OPTION_REGKEY,
                       REG_OPTION_NON_VOLATILE,
                       KEY_READ,
                       &hkeyWksta
                       );

    if ( err ) {
        KdPrint(("NWPROVAU: NwGetCurrentUserRegKey open Parameters\\Option key unexpected error %lu!\n", err));
        return err;
    }

    //
    // Open current user's key
    //
    err = RegOpenKeyExW(
              hkeyWksta,
              CurrentUser,
              REG_OPTION_NON_VOLATILE,
              DesiredAccess,
              phKeyCurrentUser
              );

    if ( err == ERROR_FILE_NOT_FOUND)
    {
        DWORD Disposition;

        //
        // Create <NewUser> key under NWCWorkstation\Parameters\Option
        //
        err = RegCreateKeyExW(
                  hkeyWksta,
                  CurrentUser,
                  0,
                  WIN31_CLASS,
                  REG_OPTION_NON_VOLATILE,
                  DesiredAccess,
                  NULL,                      // security attr
                  phKeyCurrentUser,
                  &Disposition
                  );

    }

    if ( err ) {
        KdPrint(("NWPROVAU: NwGetCurrentUserRegKey open or create of Parameters\\Option\\%ws key failed %lu\n", CurrentUser, err));
    }

    (void) RegCloseKey( hkeyWksta );
    (void) LocalFree((HLOCAL)CurrentUser) ;
    return err;
}


DWORD
NwQueryInfo(
    OUT LPWSTR *ppszPreferredSrv
    )
/*++

Routine Description:
    This routine gets the user's preferred server and print options from
    the registry.

Arguments:

    ppszPreferredSrv - Receives the user's preferred server


Return Value:

    Returns the appropriate Win32 error.

--*/
{

    HKEY hKeyCurrentUser = NULL;
    DWORD BufferSize;
    DWORD BytesNeeded;
    DWORD ValueType;
    LPWSTR PreferredServer ;
    DWORD err ;

    //
    // get to right place in registry and allocate dthe buffer
    //
    if (err = NwpGetCurrentUserRegKey( KEY_READ, &hKeyCurrentUser))
    {
        //
        // If somebody mess around with the registry and we can't find
        // the registry, just use the defaults.
        //
        *ppszPreferredSrv = NULL;
        return NO_ERROR;
    }

    BufferSize = sizeof(WCHAR) * (MAX_PATH + 2) ;
    PreferredServer = (LPWSTR) LocalAlloc(LPTR, BufferSize) ;
    if (!PreferredServer)
        return (GetLastError()) ;

    //
    // Read PreferredServer value into Buffer.
    //
    BytesNeeded = BufferSize ;

    err = RegQueryValueExW( hKeyCurrentUser,
                            NW_SERVER_VALUENAME,
                            NULL,
                            &ValueType,
                            (LPBYTE) PreferredServer,
                            &BytesNeeded );

    if (err != NO_ERROR)
    {
        //
        // set to empty and carry on
        //
        PreferredServer[0] = 0;
    }

    if (hKeyCurrentUser != NULL)
        (void) RegCloseKey(hKeyCurrentUser) ;
    *ppszPreferredSrv = PreferredServer ;
    return NO_ERROR ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\server\inswks.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    tacc.c

Abstract:

    Test for accounts.

Author:

    Rita Wong (ritaw) 02-May-1992

Environment:

    User Mode - Win32

Revision History:

--*/

#include <stdio.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifndef UNICODE
#define UNICODE
#endif

#include <windows.h>

#include <nwsnames.h>



DWORD
TestOpenSCManager(
    OUT LPSC_HANDLE hScManager,
    IN  LPWSTR DatabaseName,
    IN  DWORD DesiredAccess,
    IN  DWORD ExpectedError
    );

DWORD
TestCreateService(
    IN SC_HANDLE hScManager,
    IN LPWSTR ServiceName,
    IN DWORD ServiceType,
    IN LPWSTR BinaryPath,
    IN LPWSTR Dependencies
    );


void __cdecl
main(
    void
    )
{
    DWORD status;
    SC_HANDLE hScManager;
    SC_HANDLE hService;
    LONG RegError;
    HKEY ServiceKey;
    HKEY LinkageKey;
    DWORD Disposition;
    DWORD Type = 0x00000007;

    PWCHAR Dependencies = L"MSIPX\0Streams\0Mup\0";


    //
    // Valid desired access
    //
    if (TestOpenSCManager(
               &hScManager,
               NULL,
               SC_MANAGER_CONNECT | SC_MANAGER_CREATE_SERVICE,
               NO_ERROR
               ) == NO_ERROR) {

        //
        // Install NwRdr file system driver
        //
        status = TestCreateService(
                     hScManager,
                     L"NwRdr",
                     SERVICE_FILE_SYSTEM_DRIVER,
                     L"\\SystemRoot\\System32\\Drivers\\nwrdr.sys",
                     NULL
                     );

        if (status != NO_ERROR) {
            (void) CloseServiceHandle(hScManager);
            return;
        }

        //
        // Install NWCWorkstation service own process
        //
        status = TestCreateService(
                     hScManager,
                     NW_SERVICE_WORKSTATION,
                     SERVICE_WIN32_SHARE_PROCESS,
                     L"%SystemRoot%\\System32\\nwsvc.exe",
                     Dependencies
                     );

        (void) CloseServiceHandle(hScManager);

        if (status != NO_ERROR) {
            return;
        }

        //
        // Write the linkage key under the NWCWorkstation key
        //
        RegError = RegOpenKeyExW(
                       HKEY_LOCAL_MACHINE,
                       L"System\\CurrentControlSet\\Services\\NWCWorkstation",
                       REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_CREATE_SUB_KEY,
                       &ServiceKey
                       );

        if (RegError != ERROR_SUCCESS) {
            printf("RegOpenKeyExW failed %ld\n", RegError);
            return;
        }

        RegError = RegCreateKeyExW(
                       ServiceKey,
                       L"Linkage",
                       0,
                       WIN31_CLASS,
                       REG_OPTION_NON_VOLATILE, // options
                       KEY_WRITE,
                       NULL,
                       &LinkageKey,
                       &Disposition
                       );

        RegCloseKey(ServiceKey);

        if (RegError != ERROR_SUCCESS) {
            printf("RegCreateKeyExW failed %ld\n", RegError);
            return;
        }

        RegError = RegSetValueExW(
                       LinkageKey,
                       L"Bind",
                       0,
                       REG_MULTI_SZ,
                       L"\\Device\\Streams\\IPX\0",
                       (wcslen(L"\\Device\\Streams\\IPX\0") + 1)
                            * sizeof(WCHAR)
                       );

        RegCloseKey(LinkageKey);

        if (RegError != ERROR_SUCCESS) {
            printf("RegSetValueEx failed %ld\n", RegError);
            return;
        }

        //
        // Add a system event entry for the NetWare workstation
        //
        RegError = RegCreateKeyExW(
                       HKEY_LOCAL_MACHINE,
                       L"System\\CurrentControlSet\\Services\\Eventlog\\System\\NWCWorkstation",
                       0,
                       WIN31_CLASS,
                       REG_OPTION_NON_VOLATILE,
                       KEY_WRITE,
                       NULL,
                       &ServiceKey,
                       &Disposition
                       );

        if (RegError != ERROR_SUCCESS) {
            printf("RegCreateKeyExW of eventlog entry failed %ld\n", RegError);
            return;
        }

        RegError = RegSetValueExW(
                       ServiceKey,
                       L"EventMessageFile",
                       0,
                       REG_EXPAND_SZ,
                       L"%SystemRoot%\\System32\\nwevent.dll",
                       wcslen(L"%SystemRoot%\\System32\\nwevent.dll")
                            * sizeof(WCHAR)
                       );

        if (RegError != ERROR_SUCCESS) {
            printf("RegSetValueExW of EventMessageFile value failed %ld\n", RegError);
            RegCloseKey(ServiceKey);
            return;
        }

        RegError = RegSetValueExW(
                       ServiceKey,
                       L"TypesSupported",
                       0,
                       REG_DWORD,
                       &Type,
                       sizeof(DWORD)
                       );

        RegCloseKey(ServiceKey);

        if (RegError != ERROR_SUCCESS) {
            printf("RegSetValueExW of TypesSupported value failed %ld\n", RegError);
            return;
        }

        printf("Successfully installed transport for NWCWorkstation\n");
    }

}


DWORD
TestOpenSCManager(
    OUT LPSC_HANDLE hScManager,
    IN  LPWSTR DatabaseName,
    IN  DWORD DesiredAccess,
    IN  DWORD ExpectedError
    )
{
    DWORD status = NO_ERROR;


    if (DatabaseName != NULL) {
        printf("OpenSCManager: DatabaseName=%ws, DesiredAccess=%08lx\n",
               DatabaseName, DesiredAccess);
    }
    else {
        printf("OpenSCManager: DatabaseName=(null), DesiredAccess=%08lx\n",
               DesiredAccess);
    }

    *hScManager = OpenSCManager(
                      NULL,
                      DatabaseName,
                      DesiredAccess
                      );

    if (*hScManager == (SC_HANDLE) NULL) {

        status = GetLastError();

        if (ExpectedError != status) {
            printf("    FAILED.  Expected %lu, got %lu\n",
                   ExpectedError, status);
            return status;
        }
    }
    else {
        if (ExpectedError != NO_ERROR) {
            printf("    FAILED.  Expected %lu, got NO_ERROR\n",
                   ExpectedError);
            return NO_ERROR;
        }
    }

    printf("    Got %lu as expected\n", status);

    return status;

}

DWORD
TestCreateService(
    IN SC_HANDLE hScManager,
    IN LPWSTR ServiceName,
    IN DWORD ServiceType,
    IN LPWSTR BinaryPath,
    IN LPWSTR Dependencies
    )
{
    DWORD status = NO_ERROR;
    SC_HANDLE hService;


    hService = CreateService(
                   hScManager,
                   ServiceName,
                   NULL,
                   0,
                   ServiceType,
                   SERVICE_DEMAND_START,
                   SERVICE_ERROR_NORMAL,
                   BinaryPath,
                   NULL,
                   NULL,
                   Dependencies,
                   NULL,
                   NULL
                   );

    if (hService == (SC_HANDLE) NULL) {
        status = GetLastError();
        printf("CreateService: %ws failed %lu\n", ServiceName, status);
        return status;
    }

    printf("CreateService: Successfully created %ws\n", ServiceName);

    (void) CloseServiceHandle(hService);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\server\gateway.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    gateway.c

Abstract:

    This module contains gateway devices routines supported by
    NetWare Workstation service.

Author:

    Chuck Y Chan    (ChuckC)  31-Oct-1993

Revision History:

--*/

#include <nw.h>
#include <handle.h>
#include <nwreg.h>
#include <nwlsa.h>
#include <nwapi.h>

#include <lmcons.h>
#include <lmshare.h>

#include <winsta.h>
#include <winbasep.h>              //DosPathToSessionPath


extern BOOL NwLUIDDeviceMapsEnabled;

//
//-------------------------------------------------------------------//
//                                                                   //
// External Function Prototypes                                      //
//                                                                   //
//-------------------------------------------------------------------//
//
// GetProcAddress typedef for winsta.dll function WinStationEnumerateW
//
typedef BOOLEAN (*PWINSTATION_ENUMERATE) (
                                          HANDLE  hServer,
                                          PSESSIONIDW *ppLogonId,
                                          PULONG  pEntries
                                          );
//
// GetProcAddress typedef for winsta.dll function WinStationFreeMemory
//
typedef BOOLEAN (*PWINSTATION_FREE_MEMORY) ( PVOID);

LPTSTR
NwReturnSessionPath(
                    IN  LPTSTR LocalDeviceName
                   );

//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

DWORD
NwPopulateGWDosDevice(
                      LPWSTR DeviceName, 
                      LPWSTR GetwayPath
                     );
//
// wrapper round the RPC routines.
//

DWORD
NwrEnumGWDevices( 
    LPWSTR Reserved,
    PDWORD Index,
    LPBYTE Buffer,
    DWORD BufferSize,
    LPDWORD BytesNeeded,
    LPDWORD EntriesRead
    )
/*++

Routine Description:

    This routine enumerates the special gateway devices (redirections)
    that are cureently in use.

Arguments:

    Index - Point to start enumeration. Should be zero for first call.
            This is set by the function and can be used to resume the
            enumeration.

    Buffer - buffer for return data
    
    BufferSize - size of buffer in bytes

    BytesNeeded - number of bytes needed to return all the data

    EntriesRead - number of entries read 

Return Value:

    Returns the appropriate Win32 error. If NO_ERROR or ERROR_MORE_DATA
    then EntriesRead will indicated the number of valid entries in buffer.

--*/
{
    UNREFERENCED_PARAMETER(Reserved);

    return ( NwEnumerateGWDevices( 
                 Index,
                 Buffer,
                 BufferSize,
                 BytesNeeded,
                 EntriesRead
           ) ) ;
}


DWORD
NwrAddGWDevice( 
    LPWSTR Reserved,
    LPWSTR DeviceName,
    LPWSTR RemoteName,
    LPWSTR AccountName,
    LPWSTR Password,
    DWORD  Flags
    )
/*++

Routine Description:

    This routine adds a gateway redirection.

Arguments:

    DeviceName - the drive to redirect

    RemoteName - the remote network resource to redirect to

    Flags - supplies the options (eg. UpdateRegistry & make this sticky)

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD status ;
    UNREFERENCED_PARAMETER(Reserved);

    //
    // make connection to the server to ensure we have a connection.
    // if GatewayConnectionAlways is false, the function will immediately
    // delete the connection, so this will just be an access check.
    //
    status = NwCreateGWConnection( RemoteName,
                                   AccountName,
                                   Password,
                                   GatewayConnectionAlways) ;

    if (status != NO_ERROR)
    {
        return status ;
    }

    //
    // make the symbolic link
    //
    return ( NwCreateGWDevice( 
                 DeviceName,
                 RemoteName,
                 Flags
           ) ) ;
}


DWORD
NwrDeleteGWDevice( 
    LPWSTR Reserved,
    LPWSTR DeviceName,
    DWORD  Flags
    )
/*++

Routine Description:

    This routine enumerates the special gateway devices (redirections)
    that are cureently in use.

Arguments:

    Index - Point to start enumeration. Should be zero for first call.
            This is set by the function and can be used to resume the
            enumeration.

    Buffer - buffer for return data
    
    BufferSize - size of buffer in bytes

    BytesNeeded - number of bytes needed to return all the data

    EntriesRead - number of entries read 

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    UNREFERENCED_PARAMETER(Reserved);

    return ( NwRemoveGWDevice( 
                 DeviceName,
                 Flags
           ) ) ;
}


DWORD
NwrQueryGatewayAccount(
    LPWSTR   Reserved,
    LPWSTR   AccountName,
    DWORD    AccountNameLen,
    LPDWORD  AccountCharsNeeded,
    LPWSTR   Password,
    DWORD    PasswordLen,
    LPDWORD  PasswordCharsNeeded
    )
/*++

Routine Description:

    Query the gateway account info. specifically, the Account name and
    the passeord stored as an LSA secret. 

Arguments:

    AccountName         - buffer used to return account name 

    AccountNameLen      - length of buffer 

    AccountCharsNeeded  - number of chars needed. only set properly if
                          AccountNameLen is too small.

    Password            - buffer used to return account name 

    PasswordLen         - length of buffer 

    PasswordCharsNeeded - number of chars needed, only set properly if 
                          PasswordLen is too small.


Return Value:

    Returns the appropriate Win32 error.

--*/
{
    UNREFERENCED_PARAMETER(Reserved);

    return ( NwQueryGWAccount(
                 AccountName,
                 AccountNameLen,
                 AccountCharsNeeded,
                 Password,
                 PasswordLen,
                 PasswordCharsNeeded
           ) ) ;
}


DWORD
NwrSetGatewayAccount(
    LPWSTR Reserved,
    LPWSTR AccountName,
    LPWSTR Password
    )
/*++

Routine Description:

    Set the account and password to be used for gateway access.

Arguments:

    AccountName - the account  (NULL terminated)

    Password - the password string (NULL terminated)

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    UNREFERENCED_PARAMETER(Reserved);

    return ( NwSetGWAccount(
                 AccountName,
                 Password
           ) ) ;
}


//
// actual functions
//



DWORD
NwEnumerateGWDevices( 
    LPDWORD Index,
    LPBYTE Buffer,
    DWORD BufferSize,
    LPDWORD BytesNeeded,
    LPDWORD EntriesRead
    )
/*++

Routine Description:

    This routine enumerates the special gateway devices (redirections)
    that are cureently in use.

Arguments:

    Index - Point to start enumeration. Should be zero for first call.
            This is set by the function and can be used to resume the
            enumeration.

    Buffer - buffer for return data
    
    BufferSize - size of buffer in bytes

    BytesNeeded - number of bytes needed to return all the data

    EntriesRead - number of entries read 

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD NwRdrNameLength, NwProviderNameSize ;
    DWORD i, status ;
    DWORD Length, Count, BytesRequired, SkipCount ;
    WCHAR Drive[3] ;
    WCHAR Path[MAX_PATH+1] ;
    NETRESOURCEW *lpNetRes = NULL ;
    LPBYTE BufferEnd = NULL ;

    if (!Buffer)
    {
        return ERROR_INVALID_PARAMETER;
    }

    lpNetRes = (NETRESOURCEW *) Buffer;
    BufferEnd = Buffer + ROUND_DOWN_COUNT(BufferSize,ALIGN_WCHAR);

    //
    // init the parts of the drives string we never change
    //
    Drive[1] = L':' ;
    Drive[2] = 0 ;
    
    Count = 0 ;
    BytesRequired = 0 ;
    SkipCount = *Index ;
    NwProviderNameSize = wcslen(NwProviderName) + 1 ;
    NwRdrNameLength = sizeof(DD_NWFS_DEVICE_NAME_U)/sizeof(WCHAR) - 1 ;


    //
    // for all logical drives
    //
    for (i = 0; i <26 ; i++)
    {
        BOOL GatewayDrive = FALSE ;

        Drive[0] = L'A' + (USHORT)i ;

        //
        // get the symbolic link
        //
        Length = QueryDosDeviceW(Drive, 
                                 Path, 
                                 sizeof(Path)/sizeof(Path[0])) ;

        //
        // the value must be at least as long as our device name
        //
        if (Length >= NwRdrNameLength + 4)
        {
            //
            // and it must match the following criteria:
            //    1) start with \device\nwrdr
            //    2) must have '\' after \device\nwrdr
            //    3) must not have colon (ie. must be`
            //       \\device\nwrdr\server\share, and not 
            //       \\device\nwrdr\x:\server\share
            //

            if ((_wcsnicmp(Path,DD_NWFS_DEVICE_NAME_U,NwRdrNameLength) 
                    == 0) 
                && (Path[NwRdrNameLength] == '\\')
                && (Path[NwRdrNameLength+2] != ':'))
            {
                //
                // if this is an indexed read, skip the first N.
                // this is inefficient, but we do not expect to
                // have to go thru this very often. there are few
                // such devices, and any reasonable buffer (even 1K)
                // should get them all first time.
                //

                if (SkipCount)
                    SkipCount-- ;
                else
                    GatewayDrive = TRUE ;   // found a drive we want
            }
        }

        if (GatewayDrive)
        {
            //
            // we meet all criteria above
            //

            DWORD UncSize ;
 
            UncSize = Length - NwRdrNameLength + 2 ;
            BytesRequired += ( sizeof(NETRESOURCE) +
                           (UncSize * sizeof(WCHAR)) +
                           (NwProviderNameSize * sizeof(WCHAR)) +
                           (3 * sizeof(WCHAR))) ;       // 3 for drive, X:\0

            if (BytesRequired <= BufferSize)
            {
                LPWSTR lpStr = (LPWSTR) BufferEnd ;
                
                Count++ ;

                // 
                // copy the drive name 
                // 
                lpStr -= 3 ; 
                wcscpy(lpStr, Drive) ;
                lpNetRes->lpLocalName = (LPWSTR) ((LPBYTE)lpStr - Buffer)  ;

                // 
                // copy the UNC name 
                // 
                lpStr -= UncSize ; // for the UNC name 
                lpStr[0] = L'\\' ;
                wcscpy(lpStr+1, Path+NwRdrNameLength) ;
                lpNetRes->lpRemoteName = (LPWSTR) ((LPBYTE)lpStr - Buffer)  ;

                // 
                // copy the provider name 
                // 
                lpStr -= NwProviderNameSize ; // for the provider name
                wcscpy(lpStr, NwProviderName) ;
                lpNetRes->lpProvider = (LPWSTR) ((LPBYTE)lpStr - Buffer)  ;

                // 
                // set up the rest of the structure
                // 
                lpNetRes->dwScope = RESOURCE_CONNECTED ;
                lpNetRes->dwType = RESOURCETYPE_DISK ;
                lpNetRes->dwDisplayType = 0 ;
                lpNetRes->dwUsage = 0 ;
                lpNetRes->lpComment = 0 ;

                lpNetRes++ ;
                BufferEnd = (LPBYTE) lpStr ;
            }
        }

    }


    *EntriesRead = Count ;              // set number of entries
    *Index += Count ;                   // move index
    *BytesNeeded = BytesRequired ;      // set bytes needed
    
    if (BytesRequired == 0)             // no info left
        return (ERROR_NO_MORE_ITEMS) ;

    if (BytesRequired > BufferSize)
    {
        return (ERROR_MORE_DATA) ;
    }

    return NO_ERROR ;
}


DWORD
NwCreateGWDevice( 
    LPWSTR DeviceName,
    LPWSTR RemoteName,
    DWORD  Flags
    )
/*++

Routine Description:

    This routine adds a gateway redirection.

Arguments:

    DeviceName - the drive to redirect

    RemoteName - the remote network resource to redirect to

    Flags - supplies the options (eg. UpdateRegistry & make this sticky)

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    LPWSTR ConnectName = NULL;
    DWORD status ;
    WCHAR Path [MAX_PATH + 1] ;

    //
    // validate/canon the name. Use a drive to specific we allow UNC only.
    //
    if ((status = NwLibCanonRemoteName( L"A:",   
                          RemoteName,
                          &ConnectName,
                          NULL
                          )) != NO_ERROR) 
    {
        return status;
    }

    //
    // build up the full name of \device\nwrdr\server\volume
    //
    wcscpy(Path, DD_NWFS_DEVICE_NAME_U) ;
    wcscat(Path, ConnectName+1 ) ;

    //
    // create the symbolic link, Gateway specific, since there is no true user contacts
    //
    status = NwCreateSymbolicLink(DeviceName, Path, TRUE, FALSE) ;

    (void) LocalFree((HLOCAL) ConnectName);

    //
    // if update registry is set, write it out
    //
    if ((status == NO_ERROR) && (Flags & NW_GW_UPDATE_REGISTRY))
    {
        HKEY hKey ;
        DWORD dwDisposition ;

        //
        //
        // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
        // \NWCWorkstation\Drives (create it if not there)
        //
        status  = RegCreateKeyExW(
                      HKEY_LOCAL_MACHINE,
                      NW_WORKSTATION_GATEWAY_DRIVES,
                      0, 
                      L"",
                      REG_OPTION_NON_VOLATILE,
                      KEY_WRITE,                 // desired access
                      NULL,                      // default security
                      &hKey,
                      &dwDisposition             // ignored
                      );

        if ( status ) 
            return status ;

        status = RegSetValueExW(
                     hKey,
                     DeviceName,
                     0,
                     REG_SZ,
                     (LPBYTE) RemoteName,
                     (wcslen(RemoteName)+1) * sizeof(WCHAR)) ;

        RegCloseKey( hKey );


        if (status == ERROR_SUCCESS && IsTerminalServer() &&
            (NwLUIDDeviceMapsEnabled == FALSE)) {
            status = NwPopulateGWDosDevice(DeviceName, Path) ;
        }
    }

    return status ;

}

DWORD
NwRemoveGWDevice( 
    LPWSTR DeviceName,
    DWORD  Flags
    )
/*++

Routine Description:

    This routine deletes a gateway redirection.

Arguments:

    DeviceName - the drive to delete

    Flags - supplies the options (eg. UpdateRegistry & make this sticky)

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD status ;
    LPWSTR Local = NULL ;
    //LPWSTR SessionDeviceName;

    if (status = NwLibCanonLocalName(DeviceName,
                                     &Local,
                                     NULL))
        return status ;

    //SessionDeviceName = NwReturnSessionPath(Local);
    //if ( SessionDeviceName == NULL ) {
    //    return ERROR_NOT_ENOUGH_MEMORY;
    //}

    //
    // delete the symbolic link
    //
    if (! DefineDosDeviceW(DDD_REMOVE_DEFINITION  | DDD_RAW_TARGET_PATH,
                           Local,
                           //SessionDeviceName,
                           DD_NWFS_DEVICE_NAME_U))
    {
        status = ERROR_INVALID_DRIVE ;
    }

    //if ( SessionDeviceName ) {
    //    LocalFree( SessionDeviceName );
    //}

    //
    // If cleanup deleted (dangling) share is set go do it now.
    // We loop thru all the shares looking for one that matches that drive.
    // Then we ask the server to nuke that dangling share.
    //
    if ((status == NO_ERROR) && (Flags & NW_GW_CLEANUP_DELETED))
    {
        HKEY hKey ;
        DWORD err ;

        //
        //
        // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
        // \NWCWorkstation\Shares
        //
        err = RegOpenKeyExW(
                      HKEY_LOCAL_MACHINE,
                      NW_WORKSTATION_GATEWAY_SHARES,
                      REG_OPTION_NON_VOLATILE,   // options
                      KEY_READ | KEY_WRITE,      // desired access
                      &hKey
                      );

        if (err == NO_ERROR) 
        {
            WCHAR Path[MAX_PATH + 1], ShareName[MAX_PATH+1] ;
            DWORD dwType, i = 0, dwPathSize, dwShareNameSize ;

            do {

                dwPathSize = sizeof(Path), 
                dwShareNameSize = sizeof(ShareName)/sizeof(ShareName[0]) ;
                dwType = REG_SZ ;

                err = RegEnumValueW(hKey,
                                    i,
                                    ShareName,
                                    &dwShareNameSize,
                                    NULL, 
                                    &dwType,
                                    (LPBYTE)Path,
                                    &dwPathSize) ;

                //
                // Look for matching drive, eg. "X:"
                // If have match, cleanup as best we can and break out now.
                //
                if ((err == NO_ERROR) &&
                    (_wcsnicmp(Path,DeviceName,2) == 0))
                {
                    (void) NetShareDelSticky( NULL,
                                              ShareName, 
                                              0 ) ;
                    (void) RegDeleteValueW(hKey, 
                                           ShareName) ;
                    break ;
                }
            
                i++ ;

            } while (err == NO_ERROR) ;

            RegCloseKey( hKey );
        }

    }

    //
    // if update registry is set, write it out
    //
    if ((status == NO_ERROR) && (Flags & NW_GW_UPDATE_REGISTRY))
    {
        HKEY hKey ;
        WCHAR Path[MAX_PATH + 1] ;
        DWORD dwType, dwSize = sizeof(Path) ;

        //
        //
        // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
        // \NWCWorkstation\Drives
        //
        status  = RegOpenKeyExW(
                      HKEY_LOCAL_MACHINE,
                      NW_WORKSTATION_GATEWAY_DRIVES,
                      REG_OPTION_NON_VOLATILE,   // options
                      KEY_READ | KEY_WRITE,      // desired access
                      &hKey
                      );

        if ( status ) 
            goto ExitPoint ;

        if (GatewayConnectionAlways)
        {
            //
            // Read the remote path and delete the connection
            // if we made one in the first place.
            //
            status = RegQueryValueExW(
                             hKey,
                             Local,
                             NULL,
                             &dwType,
                             (LPBYTE) Path,
                             &dwSize 
                             );
    
            if (status == NO_ERROR)
            {
                (void) NwDeleteGWConnection(Path) ;
            }
        }

        status = RegDeleteValueW(
                     hKey,
                     DeviceName
                     ) ;
    
        RegCloseKey( hKey );
    }

ExitPoint:

    if (Local)
        (void) LocalFree((HLOCAL)Local) ;

    return status ;
}

DWORD
NwGetGatewayResource(
    IN LPWSTR LocalName,
    OUT LPWSTR RemoteName,
    IN DWORD RemoteNameLen,
    OUT LPDWORD CharsRequired
    )
/*++

Routine Description:

    For a gateway devicename, get the network resource associated with it.

Arguments:

    LocalName - name of devive to query

    RemoteName - buffer to return the network resource

    RemoteNameLen - size of buffer (chars)

    CharsRequired - the number of chars needed

Return Value:

    WN_SUCCESS - success (the device is a gateway redirection)

    WN_MORE_DATA -  buffer too small, but device is a gateway redirection

    WN_NOT_CONNECTED -  not a gateway redirection

--*/
{
    WCHAR Path[MAX_PATH+1] ;
    DWORD Length ;
    DWORD NwRdrNameLength ;

    NwRdrNameLength = sizeof(DD_NWFS_DEVICE_NAME_U)/sizeof(WCHAR) - 1 ;

    //
    // retrieve symbolic link for the device
    //
    Length = QueryDosDeviceW(LocalName, 
                             Path, 
                             sizeof(Path)/sizeof(Path[0])) ;

    //
    // the result is only interesting if it can at least fit:
    //     \device\nwrdr\x\y
    //
    if (Length >= NwRdrNameLength + 4)
    {
        //
        // check to make sure that the prefix is coreect, and that
        // it is not of form:  \device\nwrdr\x:\...
        //
        if ((_wcsnicmp(Path,DD_NWFS_DEVICE_NAME_U,NwRdrNameLength) == 0) 
            && (Path[NwRdrNameLength] == '\\')
            && (Path[NwRdrNameLength+2] != ':'))
        {
            //
            // check buffer size
            //
            if (RemoteNameLen < ((Length - NwRdrNameLength) + 1))
            {
                if (CharsRequired)
                    *CharsRequired = ((Length - NwRdrNameLength) + 1) ;
                return WN_MORE_DATA ;
            }
            
            *RemoteName = L'\\' ;
            wcscpy(RemoteName+1,Path+NwRdrNameLength) ; 
            return WN_SUCCESS ;
        }
    }

    return WN_NOT_CONNECTED ;
}


DWORD
NwQueryGWAccount(
    LPWSTR   AccountName,
    DWORD    AccountNameLen,
    LPDWORD  AccountCharsNeeded,
    LPWSTR   Password,
    DWORD    PasswordLen,
    LPDWORD  PasswordCharsNeeded
    )
/*++

Routine Description:

    Query the gateway account info. specifically, the Account name and
    the passeord stored as an LSA secret. 

Arguments:

    AccountName         - buffer used to return account name 

    AccountNameLen      - length of buffer 

    AccountCharsNeeded  - number of chars needed. only set properly if
                          AccountNameLen is too small.

    Password            - buffer used to return account name 

    PasswordLen         - length of buffer 

    PasswordCharsNeeded - number of chars needed, only set properly if 
                          PasswordLen is too small.


Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD status = NO_ERROR ;
    LONG RegError;

    HKEY WkstaKey = NULL;
    LPWSTR GatewayAccount = NULL;

    PUNICODE_STRING StoredPassword = NULL;
    PUNICODE_STRING StoredOldPassword = NULL;

    if ( !AccountName || !Password )
    {
        return ERROR_INVALID_PARAMETER;
    }

    *AccountCharsNeeded =  0 ;
    *PasswordCharsNeeded =  0 ;

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters
    //
    RegError = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_WORKSTATION_REGKEY,
                   REG_OPTION_NON_VOLATILE,   // options
                   KEY_READ,                  // desired access
                   &WkstaKey
                   );

    if (RegError != ERROR_SUCCESS) 
    {
        return (RegError);
    }

    //
    // Read the gateway account from the registry.
    //
    status = NwReadRegValue(
                 WkstaKey,
                 NW_GATEWAYACCOUNT_VALUENAME,
                 &GatewayAccount
                 );

    if (status != NO_ERROR) 
    {
        if (status != ERROR_FILE_NOT_FOUND) 
            goto CleanExit;

        if (AccountNameLen > 0)
            *AccountName = 0 ;
        status = NO_ERROR ;
    }
    else 
    {
        *AccountCharsNeeded = wcslen(GatewayAccount) + 1 ;
        if (*AccountCharsNeeded > AccountNameLen)
        {
            status = ERROR_INSUFFICIENT_BUFFER ;
            goto CleanExit;
        }
        wcscpy(AccountName,GatewayAccount);
    }    

    //
    // Read the password from its secret object in LSA.
    //
    status = NwGetPassword(
                 GATEWAY_USER,
                 &StoredPassword,      // Must be freed with LsaFreeMemory
                 &StoredOldPassword    // Must be freed with LsaFreeMemory
                 );

    if (status != NO_ERROR) 
    {
        if (status != ERROR_FILE_NOT_FOUND) 
            goto CleanExit;

        if (PasswordLen > 0)
            *Password = 0 ;

        status = NO_ERROR ;
    }
    else 
    {
        *PasswordCharsNeeded =  StoredPassword->Length/sizeof(WCHAR) + 1 ;
        if ((StoredPassword->Length/sizeof(WCHAR)) >= PasswordLen)
        {
            status = ERROR_INSUFFICIENT_BUFFER ;
            goto CleanExit;
        }
        wcsncpy(Password, 
                StoredPassword->Buffer, 
                StoredPassword->Length/sizeof(WCHAR)); 
        Password[StoredPassword->Length/sizeof(WCHAR)] = 0 ;
    }    


CleanExit:

    if (StoredPassword != NULL) {
        (void) LsaFreeMemory((PVOID) StoredPassword);
    }

    if (StoredOldPassword != NULL) {
        (void) LsaFreeMemory((PVOID) StoredOldPassword);
    }

    if (GatewayAccount != NULL) {
        (void) LocalFree((HLOCAL) GatewayAccount);
    }

    (void) RegCloseKey(WkstaKey);

    return status ;
}

DWORD
NwSetGWAccount(
    LPWSTR AccountName,
    LPWSTR Password
    )
/*++

Routine Description:

    Set the account and password to be used for gateway access.

Arguments:

    AccountName - the account  (NULL terminated)

    Password - the password string (NULL terminated)

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD status ;
    HKEY WkstaKey = NULL;

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters
    //
    status = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_WORKSTATION_REGKEY,
                   REG_OPTION_NON_VOLATILE,   // options
                   KEY_WRITE,                 // desired access
                   &WkstaKey
                   );

    if (status != ERROR_SUCCESS) 
    {
        return (status);
    }

    //
    // Write the account name out 
    //
    status = RegSetValueExW(
                   WkstaKey,
                   NW_GATEWAYACCOUNT_VALUENAME,
                   0,
                   REG_SZ,
                   (LPVOID) AccountName,
                   (wcslen(AccountName) + 1) * sizeof(WCHAR)
                   );

    if (status == NO_ERROR) 
    {
        status = NwSetPassword(
                     GATEWAY_USER, 
                     Password) ;
    }

    return status ;
}


DWORD
NwCreateRedirections(
    LPWSTR Account,
    LPWSTR Password
    )
/*++

Routine Description:

    Create the gateway redirections from what is stored in registry.
    As we go along, we validate that we have access to it using the
    gateway account.

Arguments:

    AccountName - the account  (NULL terminated)

    Password - the password string (NULL terminated)

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD err, i, type ;
    HKEY hKey ;
    FILETIME FileTime ;
    WCHAR Class[256], Device[64], Path[MAX_PATH+1] ;
    DWORD dwClass, dwSubKeys, dwMaxSubKey, dwMaxClass,
          dwValues, dwMaxValueName, dwMaxValueData, dwSDLength,
          dwDeviceLength, dwPathLength ;

    //
    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCGateway\Parameters
    //
    err = RegOpenKeyExW(
              HKEY_LOCAL_MACHINE,
              NW_WORKSTATION_GATEWAY_DRIVES,
              REG_OPTION_NON_VOLATILE,   // options
              KEY_READ,                  // desired access
              &hKey
              );

    if ( err ) 
        return err ;

    dwClass = sizeof(Class)/sizeof(Class[0]) ;
    err = RegQueryInfoKeyW(hKey,  
                           Class,
                           &dwClass, 
                           NULL, 
                           &dwSubKeys, 
                           &dwMaxSubKey, 
                           &dwMaxClass,
                           &dwValues, 
                           &dwMaxValueName, 
                           &dwMaxValueData, 
                           &dwSDLength,
                           &FileTime) ;
    if ( err ) 
    {
        RegCloseKey( hKey );
        return err ;
    }

    //
    // for each value we have a redirection to recreate
    //
    for (i = 0; i < dwValues; i++)
    {
        dwDeviceLength = sizeof(Device)/sizeof(Device[0]) ;
        dwPathLength = sizeof(Path) ;
        type = REG_SZ ;
        err = RegEnumValueW(hKey,
                            i,
                            Device,
                            &dwDeviceLength,
                            NULL, 
                            &type,
                            (LPBYTE)Path,
                            &dwPathLength) ;

        //
        // connect to the server. this will take up a connection but
        // it will also make sure we have one. on a low limit server, if
        // we rely on UNC then it is quite likely that other people will
        // come along & use up all the connections, preventing the Gateway
        // from getting to it.
        //
        // user may turn this off by setting Registry value that results
        // GatewayConnectionAlways being false.
        //
        // regardless of result, we carry on. so if server is down & comes
        // up later, the symbolic link to UNC will still work.
        //
        if (!err)
        {
            (void) NwCreateGWConnection( Path,
                                         Account,
                                         Password, 
                                         GatewayConnectionAlways) ;
        }

        //
        // create the symbolic link
        //
        if (!err) 
        {
            err = NwCreateGWDevice(Device, Path, 0L) ;
        }

        if (err)
        {
            //
            // log the error in the event log
            //

            WCHAR Number[16] ;
            LPWSTR InsertStrings[3] ;

            wsprintfW(Number, L"%d", err) ;
            InsertStrings[0] = Device ;
            InsertStrings[1] = Path ;
            InsertStrings[2] = Number ;

            NwLogEvent(EVENT_NWWKSTA_CANNOT_REDIRECT_DEVICES,
                       3, 
                       InsertStrings,
                       0) ;
        }
    }

    RegCloseKey( hKey );


    return NO_ERROR  ;
}

DWORD
NwDeleteRedirections(
    VOID
    )
/*++

Routine Description:

    Delete all gateway devices

Arguments:

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    LPBYTE Buffer ;
    DWORD i, status, Index, BufferSize, EntriesRead, BytesNeeded ;
    LPNETRESOURCE lpNetRes ;

    Index = 0 ;

    //
    // below is good initial guess
    //
    BufferSize =  26 * (sizeof(NETRESOURCE) +
                      (3 + MAX_PATH + 1 + MAX_PATH + 1) * sizeof(WCHAR)) ;
    Buffer = (LPBYTE) LocalAlloc(LPTR, BufferSize) ;

    if (!Buffer)
        return (GetLastError()) ;

    lpNetRes = (LPNETRESOURCE) Buffer ;

    status = NwrEnumGWDevices(NULL,
                              &Index,
                              Buffer,
                              BufferSize,
                              &BytesNeeded,
                              &EntriesRead) ;

    //
    // reallocate as need
    //
    if (status == ERROR_MORE_DATA || status == ERROR_INSUFFICIENT_BUFFER)
    {
        Buffer = (LPBYTE) LocalReAlloc((HLOCAL)Buffer, 
                                               BytesNeeded, 
                                               LMEM_ZEROINIT) ;
        if (!Buffer)
            return (GetLastError()) ;
        Index = 0 ;
        BufferSize = BytesNeeded ;
        status = NwrEnumGWDevices(NULL,
                                  &Index,
                                  Buffer,
                                  BufferSize,
                                  &BytesNeeded,
                                  &EntriesRead) ;

    }

    if (status != NO_ERROR)
        return status ;

    //
    // loop thru and delete all the devices
    //
    for (i = 0; i < EntriesRead; i++)
    {
        status = NwrDeleteGWDevice(NULL,
                                   (LPWSTR)((LPBYTE)Buffer + 
                                            (DWORD_PTR)lpNetRes->lpLocalName),
                                   0L) ;

        //
        // no need report the error, since we are shutting down.
        // there is no real deletion here - just removing the symbolic link.
        //

        lpNetRes++ ;
    }

    return NO_ERROR ;
}


DWORD
NwPopulateGWDosDevice(
                      IN LPWSTR DeviceName, 
                      IN LPWSTR GatewayPath
                     )
/*++

Routine Description:

    This routine poplaute the gateway dos device to all the active terminal sessions

Arguments:

    DeviceName - the drive to redirect

    GatewayPath - the remote network resource of the gateway drive

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD status = ERROR_SUCCESS;
    HMODULE hwinsta = NULL;
    PWINSTATION_ENUMERATE pfnWinStationEnumerate;
    PWINSTATION_FREE_MEMORY pfnWinStationFreeMemory;
    PSESSIONIDW pSessionIds = NULL;
    ULONG SessionCount;
    ULONG SessionId;
    LPWSTR pSessionPath = NULL;

    /*
     * Dynmaically load the winsta.dll
     */

    if ( (hwinsta = LoadLibraryW( L"WINSTA" )) == NULL ) {
        status = ERROR_DLL_NOT_FOUND;
        goto Exit;
    }
    pfnWinStationEnumerate  = (PWINSTATION_ENUMERATE)
                              GetProcAddress( hwinsta, "WinStationEnumerateW" );

    pfnWinStationFreeMemory = (PWINSTATION_FREE_MEMORY)
                              GetProcAddress( hwinsta, "WinStationFreeMemory" );

    if (!pfnWinStationEnumerate || !pfnWinStationFreeMemory) {
        status = ERROR_INVALID_DLL;
        goto Exit;
    }

    /*
     * Enumerate Sessions
     */
    
    if ( !pfnWinStationEnumerate( NULL,              //Enumerate self
                                &pSessionIds,
                                &SessionCount ) ) {
        status = GetLastError();
        goto Exit;
    }

    /*
     * Loop through the session, skip the console, ie SessionId = 0
     * Since the gateway device is always created for the console
     */
    for ( SessionId = 1; SessionId < SessionCount; SessionId++ ) {
        if (
            (pSessionIds[SessionId].State != State_Idle) &&
            (pSessionIds[SessionId].State != State_Down) &&
            (pSessionIds[SessionId].State != State_Disconnected)
           ) {

            WCHAR TempBuf[64];
            //
            // Create a Gateway Dos Device for those terminal sessions
            //
            if (!DosPathToSessionPath(
                                      SessionId,
                                      DeviceName, 
                                      &pSessionPath
                                      )) {
                status = GetLastError();
                goto Exit;
            }


            if (!QueryDosDeviceW(
                                pSessionPath,
                                TempBuf,
                                sizeof(TempBuf)
                                )) {
    
                if (GetLastError() != ERROR_FILE_NOT_FOUND) {
    
                    //
                    // Most likely failure occurred because our output
                    // buffer is too small.  It still means someone already
                    // has an existing symbolic link for this device for this session.
                    // It is ok, just skip this session
                    //
                    continue;
                }
                // This path is OK
            }
            else {
                //
                // QueryDosDevice successfully an existing symbolic link--
                // somebody is already using this device for this session. 
                // Skip this session and continue...
                //
                continue;
            }
    
            //
            // Create a symbolic link object to the device we are redirecting
            //
            if (! DefineDosDeviceW(
                                  DDD_RAW_TARGET_PATH | DDD_NO_BROADCAST_SYSTEM,
                                  pSessionPath,
                                  GatewayPath
                                  )) {
                //Cannot create device for this session. 
                status = GetLastError();
                goto Exit;
            }
        } //if (pSessionID...
    } //for (SessionID
           
Exit:    
    if (pSessionIds) {
       pfnWinStationFreeMemory( pSessionIds );
    }

    if (pSessionPath) {
        LocalFree(pSessionPath);
    }

    if (hwinsta) {
        FreeLibrary(hwinsta);
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\server\nwmain.c ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    nwmain.c

Abstract:

    Main module of the NetWare workstation service.

Author:

    Rita Wong      (ritaw)      11-Dec-1992

Environment:

    User Mode - Win32

Revision History:

--*/


#include <nw.h>
#include <nwreg.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <nwmisc.h>
#include <winsta.h>


//
//
// GetProcAddr Prototype for winsta.dll function WinStationSetInformationW
//

typedef BOOLEAN (*PWINSTATION_SET_INFORMATION) (
                    HANDLE hServer,
                    ULONG SessionId,
                    WINSTATIONINFOCLASS WinStationInformationClass,
                    PVOID pWinStationInformation,
                    ULONG WinStationInformationLength
                    );

//
//
// GetProcAddr Prototype for winsta.dll function WinStationSendMessageW
//

typedef BOOLEAN
(*PWINSTATION_SEND_MESSAGE) (
    HANDLE hServer,
    ULONG LogonId,
    LPWSTR  pTitle,
    ULONG TitleLength,
    LPWSTR  pMessage,
    ULONG MessageLength,
    ULONG Style,
    ULONG Timeout,
    PULONG pResponse,
    BOOLEAN DoNotWait
    );
//------------------------------------------------------------------
//
// Local Definitions
//
//------------------------------------------------------------------

#define NW_EVENT_MESSAGE_FILE         L"nwevent.dll"
#define NW_MAX_POPUP_MESSAGE_LENGTH   512

#define REG_WORKSTATION_PROVIDER_PATH L"System\\CurrentControlSet\\Services\\NWCWorkstation\\networkprovider"
#define REG_PROVIDER_VALUE_NAME       L"Name"

#define REG_WORKSTATION_PARAMETERS_PATH L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Parameters"
#define REG_BURST_VALUE_NAME          L"MaxBurstSize"
#define REG_GATEWAY_VALUE_NAME        L"GatewayPrintOption"
#define REG_DISABLEPOPUP_VALUE_NAME   L"DisablePopup"
#define REG_GW_NOCONNECT_VALUE_NAME   L"GWDontConnectAtStart"

#define REG_SETUP_PATH                L"System\\Setup"
#define REG_SETUP_VALUE_NAME          L"SystemSetupInProgress"

//
// QFE release does not have this. so for QFE, we make it a no-op bit.
//
#ifdef QFE_BUILD
#define MB_SERVICE_NOTIFICATION       0
#endif

//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

DWORD
NwInitialize(
    OUT LPDWORD NwInitState
    );

DWORD
NwInitializeCritSects(
    VOID
    );

VOID
NwInitializeWkstaInfo(
    VOID
    );

DWORD
NwInitializeMessage(
    VOID
    );

BOOL NwShutdownNotify(
    DWORD dwCtrlType
    );

VOID
NwShutdown(
    IN DWORD ErrorCode,
    IN DWORD NwInitState
    );

VOID
NwShutdownMessage(
    VOID
    );

VOID
NwControlHandler(
    IN DWORD Opcode
    );

DWORD
NwUpdateStatus(
    VOID
    );

VOID
NwMessageThread(
    IN HANDLE RdrHandle
    );

VOID
NwDisplayMessage(
    IN LUID LogonId,
    IN LPWSTR Server,
    IN LPWSTR Message
    );

VOID
NwDisplayPopup(
    IN LPNWWKS_POPUP_DATA lpPopupData
    );

BOOL
SendMessageIfUserW(
    LUID   LogonId,
    LPWSTR pMessage,
    LPWSTR pTitle
    );

BOOL
NwSetupInProgress(
    VOID
    );

BOOL
NwGetLUIDDeviceMapsEnabled(
    VOID
    );

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

//
// For service control
//
STATIC SERVICE_STATUS NwStatus;
STATIC SERVICE_STATUS_HANDLE NwStatusHandle = 0;
HANDLE NwDoneEvent = NULL ;

//
// For popping up errors.
//
HANDLE NwPopupEvent = NULL ;
HANDLE NwPopupDoneEvent = NULL ;
NWWKS_POPUP_DATA  PopupData ;

//
// For NTAS vs Winnt
//
BOOL fIsWinnt = TRUE; // default is this is Workstation (FALSE = Server)

//
// Flag to control DBCS translations
//

extern LONG Japan = 0;

//
// Data global to nwsvc.exe
//
PSVCHOST_GLOBAL_DATA NwsvcGlobalData;

//
// Handle for receiving server messages
//
STATIC HANDLE NwRdrMessageHandle;

//
// Stores the network and print provider name
//
WCHAR NwProviderName[MAX_PATH] = L"";

// Stores the packet burst size
DWORD NwPacketBurstSize = 32 * 1024;

//
// remember if gateway is logged on
//
BOOL  GatewayLoggedOn = FALSE ;

//
// should gateway always take up a connection?
//
BOOL  GatewayConnectionAlways = TRUE ;

//
// critical sections used
//
CRITICAL_SECTION NwLoggedOnCritSec;
CRITICAL_SECTION NwPrintCritSec;  // protect the linked list of printers

BOOL NwLUIDDeviceMapsEnabled;

//-------------------------------------------------------------------//

VOID
SvchostPushServiceGlobals(
    PSVCHOST_GLOBAL_DATA  pGlobals
    )
{
    NwsvcGlobalData = pGlobals;
}


VOID
ServiceMain(
    DWORD NumArgs,
    LPTSTR *ArgsArray
    )
/*++

Routine Description:

    This is the main entry point of the NetWare workstation service.  After
    the service has been initialized, this thread will wait on NwDoneEvent
    for a signal to terminate the service.

Arguments:

    NumArgs - Supplies the number of strings specified in ArgsArray.

    ArgsArray -  Supplies string arguments that are specified in the
        StartService API call.  This parameter is ignored.

Return Value:

    None.

--*/
{

    DWORD NwInitState = 0;


    UNREFERENCED_PARAMETER(NumArgs);
    UNREFERENCED_PARAMETER(ArgsArray);

    //
    // Make sure svchost.exe gave us the global data
    //

    ASSERT(NwsvcGlobalData != NULL);

    if (NwInitialize(&NwInitState) != NO_ERROR) {
        return;
    }

    //
    // Wait until we are told to stop.
    //
    (void) WaitForSingleObject(
               NwDoneEvent,
               INFINITE
               );

    NwShutdown(
        NO_ERROR,          // Normal termination
        NwInitState
        );
}


DWORD
NwInitialize(
    OUT LPDWORD NwInitState
    )
/*++

Routine Description:

    This function initializes the NetWare workstation service.

Arguments:

    NwInitState - Returns a flag to indicate how far we got with initializing
        the service before an error occurred.

Return Value:

    NO_ERROR or reason for failure.

Notes:

    See IMPORTANT NOTE below.

--*/
{
    DWORD status;
    NT_PRODUCT_TYPE ProductType ;
    LCID lcid;

    //
    // are we a winnt machine?
    //
#ifdef GATEWAY_ENABLED
    fIsWinnt = RtlGetNtProductType(&ProductType) ?
                   (ProductType == NtProductWinNt) :
                   FALSE ;
#else
    fIsWinnt = TRUE;
#endif

    //
    // initialize all our critical sections as soon as we can
    //
    status = NwInitializeCritSects();

    if (status != NO_ERROR)
    {
        KdPrint(("NWWORKSTATION: NwInitializeCritSects error %lu\n", status));
        return status;
    }

    //
    // Initialize all the status fields so that subsequent calls to
    // SetServiceStatus need to only update fields that changed.
    //
    NwStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    NwStatus.dwCurrentState = SERVICE_START_PENDING;
    NwStatus.dwControlsAccepted = 0;
    NwStatus.dwCheckPoint = 1;
    NwStatus.dwWaitHint = 5000;
    NwStatus.dwWin32ExitCode = NO_ERROR;
    NwStatus.dwServiceSpecificExitCode = 0;

    //
    // Initialize workstation to receive service requests by registering the
    // control handler.
    //
    if ((NwStatusHandle = RegisterServiceCtrlHandlerW(
                              NW_WORKSTATION_SERVICE,
                              NwControlHandler
                              )) == 0) {

        status = GetLastError();
        KdPrint(("NWWORKSTATION: RegisterServiceCtrlHandlerW error %lu\n", status));
        return status;
    }

    //
    // Tell Service Controller that we are start pending.
    //
    (void) NwUpdateStatus();

    //
    // Don't run during GUI-mode setup (doing so can cause migration of
    // registry keys the service opens to fail, deleting share names)
    //
    if (NwSetupInProgress())
    {
        //
        // Fail silently so there's no Eventlog message to panic the user
        //
        NwShutdown(NO_ERROR, *NwInitState);

        //
        // Bit of a hack since ServiceMain will wait on the NwDoneEvent
        // (which hasn't yet been created) if NwInitialize returns anything
        // other than NO_ERROR.  This error code isn't used for anything
        // other than telling ServiceMain to return without waiting.
        //
        return ERROR_SERVICE_DISABLED;
    }

    //
    // Create events to synchronize message popups
    //
    if (((NwPopupEvent = CreateEvent(
                          NULL,      // no security descriptor
                          FALSE,     // use automatic reset
                          FALSE,     // initial state: not signalled
                          NULL       // no name
                          )) == NULL)
       || ((NwPopupDoneEvent = CreateEvent(
                          NULL,      // no security descriptor
                          FALSE,     // use automatic reset
                          TRUE,      // initial state: signalled
                          NULL       // no name
                          )) == NULL))
    {
        status = GetLastError();
        NwShutdown(status, *NwInitState);
        return status;
    }

    //
    // Create event to synchronize termination
    //
    if ((NwDoneEvent = CreateEvent(
                          NULL,      // no security descriptor
                          TRUE,      // do not use automatic reset
                          FALSE,     // initial state: not signalled
                          NULL       // no name
                          )) == NULL) {

        status = GetLastError();
        NwShutdown(status, *NwInitState);
        return status;
    }
    (*NwInitState) |= NW_EVENTS_CREATED;


    //
    // Load the redirector.
    //
    if ((status = NwInitializeRedirector()) != NO_ERROR) {
        NwShutdown(status, *NwInitState);
        return status;
    }
    (*NwInitState) |= NW_RDR_INITIALIZED;

    //
    // Service still start pending.  Update checkpoint to reflect that
    // we are making progress.
    //
    NwStatus.dwCheckPoint++;
    (void) NwUpdateStatus();

    //
    // Bind to transports
    //
    status = NwBindToTransports();

    //
    // tommye MS 24187 / MCS 255
    //
    
    //
    // G/CSNW has been unbound in the connection manager and so, we haven't
    // found the linkage key to bind to.
    //
    
    if (status == ERROR_INVALID_PARAMETER) {
    
        //
        // Fail silently so there's no Eventlog message to panic the user
        //
    
        NwShutdown(NO_ERROR, *NwInitState);
    
        //
        // Bit of a hack since SvcEntry_NWCS will wait on the NwDoneEvent
        // (which hasn't yet been created) if NwInitialize returns anything
        // other than NO_ERROR.  This error code isn't used for anything
        // other than telling SvcEntry_NWCS to return without waiting.
        //
    
        return ERROR_SERVICE_DISABLED;
    
    } else if (status != NO_ERROR) {

        NwShutdown(status, *NwInitState);
        return status;
    }
    (*NwInitState) |= NW_BOUND_TO_TRANSPORTS;

    //
    // Service still start pending.  Update checkpoint to reflect that
    // we are making progress.
    //
    NwStatus.dwCheckPoint++;
    (void) NwUpdateStatus();

    //
    // Initialize credential management.
    //
    NwInitializeLogon();

    //
    // Setup thread to receive server messages.  Even if not successful,
    // just press on as the workstation is mostly functional.
    //
    if ((status = NwInitializeMessage()) == NO_ERROR) {
        (*NwInitState) |= NW_INITIALIZED_MESSAGE;
    }

    //
    // Service still start pending.  Update checkpoint to reflect that
    // we are making progress.
    //
    NwStatus.dwCheckPoint++;
    (void) NwUpdateStatus();

    //
    // Read some workstation information stored in the registry
    // and passes some info to the redirector. This has to be
    // done before opening up the RPC interface.
    //
    NwInitializeWkstaInfo();

    //
    // Initialize the server side print provider.
    //
    NwInitializePrintProvider();

    //
    // Initialize the service provider.
    //
    NwInitializeServiceProvider();

    //
    // tommye - MS 176469
    //
    // No longer supporting the Gateway - so just force it to be disabled
    //

#ifdef GATEWAY_ENABLED

    //
    // Login the Gateway account. if not setup, this is a no-op.
    // Failures are non fatal.
    //
    if ((status = NwGatewayLogon()) == NO_ERROR) {
        (*NwInitState) |= NW_GATEWAY_LOGON;
    }
#endif

    //
    // Service still start pending.  Update checkpoint to reflect that
    // we are making progress.
    //
    NwStatus.dwCheckPoint++;
    (void) NwUpdateStatus();

    //
    // Open up the RPC interface
    //
    status = NwsvcGlobalData->StartRpcServer(
                 NWWKS_INTERFACE_NAME,
                 nwwks_ServerIfHandle
                 );

    if (status != NO_ERROR) {
        NwShutdown(status, *NwInitState);
        return status;
    }
    (*NwInitState) |= NW_RPC_SERVER_STARTED;

    //
    // Set up the hook to handle computer shut down.
    //
    // IMPORTANT NOTE: this is the last step after everything else
    // has suceeded. When shutdown handler is called, it assumes that
    // the redir is fully initialized.
    //
    if ( !SetConsoleCtrlHandler( NwShutdownNotify, TRUE ))
    {
        KdPrint(("SetConsoleCtrlHandler failed with %d\n", GetLastError()));
        NwShutdown( status, *NwInitState );
        return GetLastError();
    }

    //
    // We are done with workstation startup.
    //
    NwStatus.dwCurrentState = SERVICE_RUNNING;
    NwStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | 
                                  SERVICE_ACCEPT_SHUTDOWN;
    NwStatus.dwCheckPoint = 0;
    NwStatus.dwWaitHint = 0;
    NwStatus.dwWin32ExitCode = NO_ERROR;

    if ((status = NwUpdateStatus()) != NO_ERROR) {
        NwShutdown(status, *NwInitState);
        return status;
    }

    //
    // Read user and service logon credentias from the registry, in
    // case user logged on before workstation was started.
    // Eg. restart workstation.
    //
    NwGetLogonCredential();


#if 0
    //
    // check that the NWLINK has the right sockopts
    //
    // see comment on the actual function
    //
    if (!NwIsNWLinkVersionOK())
    {
        //
        // log the error in the event log
        //

        LPWSTR InsertStrings[1] ;

        NwLogEvent(EVENT_NWWKSTA_WRONG_NWLINK_VERSION,
                   0,
                   InsertStrings,
                   0) ;
    }
#endif

    //
    // Check to see if we're in a DBCS environment.
    //
    NtQueryDefaultLocale( TRUE, &lcid );
    Japan = 0;
    if (PRIMARYLANGID(lcid) == LANG_JAPANESE ||
        PRIMARYLANGID(lcid) == LANG_KOREAN ||
        PRIMARYLANGID(lcid) == LANG_CHINESE) {

        Japan = 1;
    }

    NwLUIDDeviceMapsEnabled = NwGetLUIDDeviceMapsEnabled();
    //
    // Successful initialization
    //
    return NO_ERROR;
}


BOOL NwShutdownNotify(
    IN DWORD dwCtrlType
    )
/*++

Routine Description:

    This function is a control handler used in SetConsoleCtrlHandler.
    We are only interested in CTRL_SHUTDOWN_EVENT. On shutdown, we
    need to notify redirector to shut down and then delete the
    CurrentUser key in the registry.

Arguments:

    dwCtrlType - The control type that occurred. We will only
                 process CTRL_SHUTDOWN_EVENT.

Return Value:

    TRUE if we don't want the default or other handlers to be called.
    FALSE otherwise.

Note:

    This Handler is registered after all the Init steps have completed.
    As such, it does not check for what state the service is in as it
    cleans up.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(INIT)
        KdPrint(("NwShutdownNotify\n"));
#endif

    if ( dwCtrlType != CTRL_SHUTDOWN_EVENT )
    {
        return FALSE;
    }

    //
    // stop the RPC server
    //
    (void) NwsvcGlobalData->StopRpcServer(nwwks_ServerIfHandle);

    //
    // get rid of all connections
    //
    (void) DeleteAllConnections();

    NwGatewayLogoff() ;

    err = NwShutdownRedirector();

    if ( err != NO_ERROR )
        KdPrint(("Shut down redirector failed with %d\n", err ));
#if DBG
    else
    {
        IF_DEBUG(INIT)
        KdPrint(("NwShutdownRedirector success!\n"));
    }
#endif

    //
    // Delete all logon session information in the registry.
    //
     NwDeleteInteractiveLogon(NULL);

    (void) NwDeleteServiceLogon(NULL);

    return FALSE;  // The default handler will terminate the process.
}


VOID
NwShutdown(
    IN DWORD ErrorCode,
    IN DWORD NwInitState
    )
/*++

Routine Description:

    This function shuts down the Workstation service.

Arguments:

    ErrorCode - Supplies the error code of the failure

    NwInitState - Supplies a flag to indicate how far we got with initializing
        the service before an error occurred, thus the amount of clean up
        needed.

Return Value:

    None.

--*/
{
    DWORD status = NO_ERROR;

    //
    // Service stop still pending.  Update checkpoint counter and the
    // status with the Service Controller.
    //
    (NwStatus.dwCheckPoint)++;
    (void) NwUpdateStatus();

    if (NwInitState & NW_RPC_SERVER_STARTED) {
        NwsvcGlobalData->StopRpcServer(nwwks_ServerIfHandle);
    }

    if (NwInitState & NW_INITIALIZED_MESSAGE) {
        NwShutdownMessage();
    }

    if (NwInitState & NW_GATEWAY_LOGON)
    {
        (void) NwDeleteRedirections() ;
    }

    //
    // Service stop still pending.  Update checkpoint counter and the
    // status with the Service Controller.
    //
    (NwStatus.dwCheckPoint)++;
    (void) NwUpdateStatus();

    if (NwInitState & NW_BOUND_TO_TRANSPORTS) {
        DeleteAllConnections();
        NwGatewayLogoff() ;
    }

    //
    // Clean up the service provider.
    //
    // NwTerminateServiceProvider(); NOT CALLED! This is done at DLL unload time already.

    //
    // Clean up the server side print provider
    //
    NwTerminatePrintProvider();

    //
    // Service stop still pending.  Update checkpoint counter and the
    // status with the Service Controller.
    //
    (NwStatus.dwCheckPoint)++;
    (void) NwUpdateStatus();

    if (NwInitState & NW_RDR_INITIALIZED) {
        //
        // Unload the redirector
        //
        status = NwShutdownRedirector();
    }

    if (NwInitState & NW_EVENTS_CREATED) {
        //
        // Close handle to termination event and popup event
        //
        if (NwDoneEvent) CloseHandle(NwDoneEvent);
        if (NwPopupEvent) CloseHandle(NwPopupEvent);
        if (NwPopupDoneEvent) CloseHandle(NwPopupDoneEvent);
    }

    //
    // We are done with cleaning up.  Tell Service Controller that we are
    // stopped.
    //
    NwStatus.dwCurrentState = SERVICE_STOPPED;
    NwStatus.dwControlsAccepted = 0;

    if ((ErrorCode == NO_ERROR) &&
        (status == ERROR_REDIRECTOR_HAS_OPEN_HANDLES)) {
        ErrorCode = status;
    }

    //
    // Deregister the control handler
    //
    (void) SetConsoleCtrlHandler( NwShutdownNotify, FALSE ) ;

    NwStatus.dwWin32ExitCode = ErrorCode;
    NwStatus.dwServiceSpecificExitCode = 0;

    NwStatus.dwCheckPoint = 0;
    NwStatus.dwWaitHint = 0;

    (void) NwUpdateStatus();
}


VOID
NwControlHandler(
    IN DWORD Opcode
    )
/*++

Routine Description:

    This is the service control handler of the Workstation service.

Arguments:

    Opcode - Supplies a value which specifies the action for the
        service to perform.

Return Value:

    None.

--*/
{
    switch (Opcode) {

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:

            if ((NwStatus.dwCurrentState != SERVICE_STOP_PENDING) && 
                (NwStatus.dwCurrentState != SERVICE_STOPPED)){

                NwStatus.dwCurrentState = SERVICE_STOP_PENDING;
                NwStatus.dwCheckPoint = 1;
                NwStatus.dwWaitHint = 60000;

                //
                // Send the status response.
                //
                (void) NwUpdateStatus();

                if (! SetEvent(NwDoneEvent)) {

                    //
                    // Problem with setting event to terminate Workstation
                    // service.
                    //
                    KdPrint(("NWWORKSTATION: Error setting NwDoneEvent %lu\n",
                             GetLastError()));

                    ASSERT(FALSE);
                }
                return;
            }
            break;

        case SERVICE_CONTROL_INTERROGATE:
            break;

    }

    //
    // Send the status response.
    //
    (void) NwUpdateStatus();
}


DWORD
NwUpdateStatus(
    VOID
    )
/*++

Routine Description:

    This function updates the workstation service status with the Service
    Controller.

Arguments:

    None.

Return Value:

    Return code from SetServiceStatus.

--*/
{
    DWORD status = NO_ERROR;


    if (NwStatusHandle == 0) {
        KdPrint(("NWWORKSTATION: Cannot call SetServiceStatus, no status handle.\n"));
        return ERROR_INVALID_HANDLE;
    }

    if (! SetServiceStatus(NwStatusHandle, &NwStatus)) {

        status = GetLastError();

        KdPrint(("NWWORKSTATION: SetServiceStatus error %lu\n", status));
    }

    return status;
}



VOID
NwInitializeWkstaInfo(
    VOID
    )
/*++

Routine Description:

    This function reads some workstation info, including the packet burst
    size and the provider name. We will ignore all errors that occurred when
    reading from the registry and use the default values instead.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD err;
    HKEY  hkey;
    DWORD dwTemp;
    DWORD dwSize = sizeof( dwTemp );
    LPWSTR pszProviderName = NULL;

    //
    // Read the Network and Print Provider Name.
    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\networkprovider
    //
    err = RegOpenKeyExW(
              HKEY_LOCAL_MACHINE,
              REG_WORKSTATION_PROVIDER_PATH,
              REG_OPTION_NON_VOLATILE,   // options
              KEY_READ,                  // desired access
              &hkey
              );

    if ( !err )
    {
        //
        // Read the network provider name
        //
        err = NwReadRegValue(
                  hkey,
                  REG_PROVIDER_VALUE_NAME,
                  &pszProviderName
                  );

        if ( !err )
        {
            wcscpy( NwProviderName, pszProviderName );
            (void) LocalFree( (HLOCAL) pszProviderName );

#if DBG
            IF_DEBUG(INIT)
            {
                KdPrint(("\nNWWORKSTATION: Provider Name = %ws\n",
                        NwProviderName ));
            }
#endif
        }

        RegCloseKey( hkey );
    }

    if ( err )
    {
        KdPrint(("Error %d when reading provider name.\n", err ));
    }


    //
    // Read the Packet Burst Size
    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters
    //
    err = RegOpenKeyExW(
              HKEY_LOCAL_MACHINE,
              REG_WORKSTATION_PARAMETERS_PATH,
              REG_OPTION_NON_VOLATILE,   // options
              KEY_READ,                  // desired access
              &hkey
              );

    if ( !err )
    {
        err = RegQueryValueExW( hkey,
                                REG_BURST_VALUE_NAME,
                                NULL,
                                NULL,
                                (LPBYTE) &dwTemp,
                                &dwSize );

        if ( !err )
        {
            NwPacketBurstSize = dwTemp;

#if DBG
            IF_DEBUG(INIT)
            {
                KdPrint(("\nNWWORKSTATION: Packet Burst Size = %d\n",
                        NwPacketBurstSize ));
            }
#endif
        }

        err = RegQueryValueExW( hkey,
                                REG_GATEWAY_VALUE_NAME,
                                NULL,
                                NULL,
                                (LPBYTE) &dwTemp,
                                &dwSize );

        if ( !err )
        {
            NwGatewayPrintOption = dwTemp;

#if DBG
            IF_DEBUG(INIT)
            {
                KdPrint(("\nNWWORKSTATION: Gateway Print Option = %d\n",
                        NwGatewayPrintOption ));
            }
#endif
        }

        err = RegQueryValueExW( hkey,
                                REG_GW_NOCONNECT_VALUE_NAME,
                                NULL,
                                NULL,
                                (LPBYTE) &dwTemp,
                                &dwSize );

        if ( !err )
        {
            if (dwTemp == 1)
                GatewayConnectionAlways = FALSE ;
        }

        RegCloseKey( hkey );
    }

    //
    // Passes the information to the redirector
    //
    (void) NwRdrSetInfo(
               NW_PRINT_OPTION_DEFAULT,
               NwPacketBurstSize,
               NULL,
               0,
               NwProviderName,
               ((NwProviderName != NULL) ?
                  wcslen( NwProviderName) * sizeof( WCHAR ) : 0 )
               );

}



DWORD
NwInitializeMessage(
    VOID
    )
/*++

Routine Description:

    This routine opens a handle to the redirector device to receive
    server messages and creates a thread to wait for the incoming
    messages.

Arguments:

    None.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;
    UNICODE_STRING RdrName;

    HKEY  hkey;
    DWORD dwTemp;
    DWORD dwSize = sizeof( dwTemp );
    BOOL  fDisablePopup = FALSE ;

    HANDLE ThreadHandle;
    DWORD ThreadId;

    //
    // Read the Disable Popup Flag. By default it is cleared.
    // We only set to TRUE if we find the value.
    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters
    //
    status = RegOpenKeyExW(
              HKEY_LOCAL_MACHINE,
              REG_WORKSTATION_PARAMETERS_PATH,
              REG_OPTION_NON_VOLATILE,   // options
              KEY_READ,                  // desired access
              &hkey
              );

    if ( status == NO_ERROR )
    {
        status = RegQueryValueExW( hkey,
                                REG_DISABLEPOPUP_VALUE_NAME,
                                NULL,
                                NULL,
                                (LPBYTE) &dwTemp,
                                &dwSize );

        if ( status == NO_ERROR )
        {
            fDisablePopup = (dwTemp == 1);
        }

        RegCloseKey( hkey );
    }

    if (fDisablePopup)
    {
        return NO_ERROR ;
    }

    RtlInitUnicodeString(&RdrName, DD_NWFS_DEVICE_NAME_U);

    status = NwMapStatus(
                 NwCallNtOpenFile(
                     &NwRdrMessageHandle,
                     FILE_GENERIC_READ | SYNCHRONIZE,
                     &RdrName,
                     0  // Handle for async call
                     )
                 );

    if (status != NO_ERROR) {
        return status;
    }

    //
    // Create the thread to wait for incoming messages
    //
    ThreadHandle = CreateThread(
                       NULL,
                       0,
                       (LPTHREAD_START_ROUTINE) NwMessageThread,
                       (LPVOID) NwRdrMessageHandle,
                       0,
                       &ThreadId
                       );

    if (ThreadHandle == NULL) {
        (void) NtClose(NwRdrMessageHandle);
        return GetLastError();
    }

    return NO_ERROR;
}


VOID
NwShutdownMessage(
    VOID
    )
{
    (void) NtClose(NwRdrMessageHandle);
}


VOID
NwMessageThread(
    IN HANDLE RdrHandle
    )
{
    NTSTATUS getmsg_ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    DWORD ReturnVal, NumEventsToWaitOn ;
    HANDLE EventsToWaitOn[3];

    //BYTE OutputBuffer[48 * sizeof(WCHAR) + 256 * sizeof(WCHAR)];  //Need more space for terminal server
    BYTE OutputBuffer[ 2 * sizeof(ULONG) + 48 * sizeof(WCHAR) + 256 * sizeof(WCHAR)]; // Need space for UID to redirect message to correct user

    PNWR_SERVER_MESSAGE ServerMessage = (PNWR_SERVER_MESSAGE) OutputBuffer;
    BOOL DoFsctl = TRUE ;
    NWWKS_POPUP_DATA LocalPopupData ;


    EventsToWaitOn[0] = NwDoneEvent;
    EventsToWaitOn[1] = NwPopupEvent;
    EventsToWaitOn[2] = RdrHandle;

    while (TRUE) {
        if (DoFsctl)
        {
            getmsg_ntstatus = NtFsControlFile(
                                  RdrHandle,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &IoStatusBlock,
                                  FSCTL_NWR_GET_MESSAGE,
                                  NULL,
                                  0,
                                  OutputBuffer,
                                  sizeof(OutputBuffer)
                                  );

            DoFsctl = FALSE ;
        }

        if (NT_SUCCESS(getmsg_ntstatus))
        {
            NumEventsToWaitOn = 3 ;
        }
        else
        {
            NumEventsToWaitOn = 2 ;
        }

        ReturnVal = WaitForMultipleObjects(
                        NumEventsToWaitOn,
                        EventsToWaitOn,
                        FALSE,           // Wait for any one
                        INFINITE
                        );

        switch (ReturnVal) {

            case WAIT_OBJECT_0 :
                //
                // Workstation is terminating.  Just die.
                //
                ExitThread(0);
                break;

            case WAIT_OBJECT_0 + 1:
                //
                // We have a popup to do. Grab the data and Set the
                // event so that the structure can be used once more.
                //
                LocalPopupData = PopupData ;
                RtlZeroMemory(&PopupData, sizeof(PopupData)) ;
                if (! SetEvent(NwPopupDoneEvent)) {
                    //
                    // should not happen
                    //
                    KdPrint(("NWWORKSTATION: Error setting NwPopupDoneEvent %lu\n",
                             GetLastError()));

                    ASSERT(FALSE);
                }

                NwDisplayPopup(&LocalPopupData) ;
                break;

            case WAIT_OBJECT_0 + 2:
            {
                NTSTATUS ntstatus ;

                //
                // GET_MESSAGE fsctl completed.
                //
                ntstatus = IoStatusBlock.Status;
                DoFsctl = TRUE ;

                if (ntstatus == STATUS_SUCCESS) {
                    NwDisplayMessage(
                                    ServerMessage->LogonId,
                                    ServerMessage->Server,
                                    (LPWSTR) ((UINT_PTR) ServerMessage +
                                              ServerMessage->MessageOffset)
                                    );
                }
                else {
                    KdPrint(("NWWORKSTATION: GET_MESSAGE fsctl failed %08lx\n", ntstatus));
                }

                break;
            }

            case WAIT_FAILED:
            default:
                //
                // Don't care.
                //
                break;
        }

    }
}


VOID
NwDisplayMessage(
    IN LUID LogonId,   /* Need to send to a user station - for terminal server */
    IN LPWSTR Server,
    IN LPWSTR Message
    )
/*++

Routine Description:

    This routine puts up a popup message with the text received from
    a server.

Arguments:

    Server - Supplies the name of the server which the message was
        received from.

    Message - Supplies the message to put up received from the server.

Return Value:

    None.

--*/
{
    HMODULE MessageDll;

    WCHAR Title[128];
    WCHAR Buffer[NW_MAX_POPUP_MESSAGE_LENGTH];

    DWORD MessageLength;
    DWORD CharsToCopy;

#if DBG
    IF_DEBUG(MESSAGE)
    {
        KdPrint(("Server: (%ws), Message: (%ws)\n", Server, Message));
    }
#endif

    //
    // Load the netware message file DLL
    //
    MessageDll = LoadLibraryW(NW_EVENT_MESSAGE_FILE);

    if (MessageDll == NULL) {
        return;
    }

    RtlZeroMemory(Buffer, sizeof(Buffer)) ;
    MessageLength = FormatMessageW(
                        FORMAT_MESSAGE_FROM_HMODULE,
                        (LPVOID) MessageDll,
                        fIsWinnt? NW_MESSAGE_TITLE : NW_MESSAGE_TITLE_NTAS,
                        0,
                        Title,
                        sizeof(Title) / sizeof(WCHAR),
                        NULL
                        );

    if (MessageLength == 0) {
        KdPrint(("NWWORKSTATION: FormatMessageW of title failed\n"));
        return;
    }


    //
    // Get string from message file to display where the message come
    // from.
    //
    MessageLength = FormatMessageW(
                        FORMAT_MESSAGE_FROM_HMODULE |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        (LPVOID) MessageDll,
                        NW_MESSAGE_FROM_SERVER,
                        0,
                        Buffer,
                        sizeof(Buffer) / sizeof(WCHAR),
                        (va_list *) &Server
                        );


    if (MessageLength != 0) {

        CharsToCopy = wcslen(Message);

        if (MessageLength + 1 + CharsToCopy > NW_MAX_POPUP_MESSAGE_LENGTH) {

            //
            // Message is too big.  Truncate the message.
            //
            CharsToCopy = NW_MAX_POPUP_MESSAGE_LENGTH - (MessageLength + 1);

        }

        wcsncpy(&Buffer[MessageLength], Message, CharsToCopy);

        if (IsTerminalServer()) {
            (void) SendMessageToLogonIdW( LogonId, Buffer, Title );
        } else {
            (void) MessageBeep(MB_ICONEXCLAMATION);
            (void) MessageBoxW(
                              NULL,
                              Buffer,
                              Title,
                              MB_OK | MB_SETFOREGROUND |
                              MB_SYSTEMMODAL | MB_SERVICE_NOTIFICATION
                              );
        }


    }
    else {
        KdPrint(("NWWORKSTATION: FormatMessageW failed %lu\n", GetLastError()));
    }

    (void) FreeLibrary(MessageDll);
}

VOID
NwDisplayPopup(
    IN LPNWWKS_POPUP_DATA lpPopupData
    )
/*++

Routine Description:

    This routine puts up a popup message for the given Id.

Arguments:

    MessageId - Supplies the message to put up.

Return Value:

    None.

--*/
{
    HMODULE MessageDll;

    WCHAR Title[128];
    WCHAR Buffer[NW_MAX_POPUP_MESSAGE_LENGTH];

    DWORD MessageLength;
    DWORD i ;

    //
    // Load the netware message file DLL
    //
    MessageDll = LoadLibraryW(NW_EVENT_MESSAGE_FILE);

    if (MessageDll == NULL) {
        return;
    }

    MessageLength = FormatMessageW(
                        FORMAT_MESSAGE_FROM_HMODULE,
                        (LPVOID) MessageDll,
                        NW_MESSAGE_TITLE,
                        0,
                        Title,
                        sizeof(Title) / sizeof(WCHAR),
                        NULL
                        );

    if (MessageLength == 0) {
        KdPrint(("NWWORKSTATION: FormatMessageW of title failed\n"));
        return;
    }


    //
    // Get string from message file to display where the message come
    // from.
    //
    MessageLength = FormatMessageW(
                        FORMAT_MESSAGE_FROM_HMODULE |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        (LPVOID) MessageDll,
                        lpPopupData->MessageId,
                        0,
                        Buffer,
                        sizeof(Buffer) / sizeof(WCHAR),
                        (va_list *) &(lpPopupData->InsertStrings)
                        );

    for (i = 0; i < lpPopupData->InsertCount; i++)
        (void) LocalFree((HLOCAL)lpPopupData->InsertStrings[i]) ;


    if (MessageLength != 0) {
        if (IsTerminalServer()) {
            //--- Multiuser change -----
            (void) SendMessageToLogonIdW( lpPopupData->LogonId, Buffer, Title );
        } else {
            (void) MessageBeep(MB_ICONEXCLAMATION);

            (void) MessageBoxW(
                              NULL,
                              Buffer,
                              Title,
                              MB_OK | MB_SETFOREGROUND |
                              MB_SYSTEMMODAL | MB_SERVICE_NOTIFICATION
                              );
        }

    }
    else {
        KdPrint(("NWWORKSTATION: FormatMessageW failed %lu\n", GetLastError()));
    }

    (void) FreeLibrary(MessageDll);
}

#if 0

//
// This code was needed when we used to have a version of NwLink from MCS
// that didnt do the sockopts we needed. It used to be called by NwInitialize()
// and if the check failed, we logged an event
//

BOOL
NwIsNWLinkVersionOK(
    void
    )
/*++

Routine Description:

    This routine puts checks if the NWLINK version supports the
    sockopts added for IPX/SPX. if not, barf.

    Arguments:

    None.

    Return Value:

    TRUE is the version is OK, FALSE otherwise.

--*/
{
    int err ;
    SOCKET s ;
    WORD VersionRequested ;
    WSADATA wsaData ;
    IPX_NETNUM_DATA buf;
    int buflen = sizeof(buf);

    BOOL NeedCleanup = FALSE ;
    BOOL NeedClose = FALSE ;
    BOOL result = TRUE ;

    VersionRequested = MAKEWORD(1,1) ;

    if (err = WSAStartup(VersionRequested,
                         &wsaData))
    {
        //
        // cant even get winsock initialized. this is not a question
        // of wrong version. we will fail later. return TRUE
        //
        result = TRUE ;
        goto ErrorExit ;
    }
    NeedCleanup = TRUE ;

    s = socket(AF_IPX,
               SOCK_DGRAM,
               NSPROTO_IPX
              );

    if (s == INVALID_SOCKET)
    {
        //
        // cant even open socket. this is not a question
        // of wrong version. we will fail later. return TRUE
        //
        result = TRUE ;
        goto ErrorExit ;
    }
    NeedClose = TRUE ;

    if (err = getsockopt(s,
                         NSPROTO_IPX,
                         IPX_GETNETINFO,
                         (char FAR*)&buf,
                         &buflen
                         ))
    {
        err = WSAGetLastError() ;
        if (err == WSAENOPROTOOPT)
        {
             //
             // we got a no supported call. we know this is OLD
             // return FALSE
             //
             result = FALSE ;
             goto ErrorExit ;
        }
    }

    //
    // everything dandy. return TRUE
    //
    result = TRUE ;

ErrorExit:

    if (NeedClose)
        closesocket(s) ;
    if (NeedCleanup)
        WSACleanup() ;

    return result ;
}

#endif


DWORD
NwInitializeCritSects(
    VOID
    )
{
    static BOOL s_fBeenInitialized;

    DWORD dwError = NO_ERROR;
    BOOL  fFirst  = FALSE;

    if (!s_fBeenInitialized)
    {
        s_fBeenInitialized = TRUE;

        __try
        {
            //
            // Initialize the critical section to serialize access to
            // NwLogonNotifiedRdr flag. This is also used to serialize
            // access to GetewayLoggedOnFlag
            //
            InitializeCriticalSection( &NwLoggedOnCritSec );
            fFirst = TRUE;

            //
            // Initialize the critical section used by the print provider
            //
            InitializeCriticalSection( &NwPrintCritSec );
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            //
            // InitializeCriticalSection() can throw an out of memory exception
            //
            KdPrint(("NwInitializeCritSects: Caught exception %d\n",
                     GetExceptionCode()));

            if (fFirst)
            {
                DeleteCriticalSection( &NwLoggedOnCritSec );
            }

            dwError = ERROR_NOT_ENOUGH_MEMORY;

            s_fBeenInitialized = FALSE;
        }
    }

    return dwError;
}


BOOL
NwSetupInProgress(
    VOID
    )
{
    HKEY   hKey;
    DWORD  dwErr;
    DWORD  dwValue;
    DWORD  cbValue = sizeof(DWORD);

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         REG_SETUP_PATH,
                         0,
                         KEY_QUERY_VALUE,
                         &hKey);

    if (dwErr != ERROR_SUCCESS)
    {
        return FALSE;
    }

    dwErr = RegQueryValueEx(hKey,
                            REG_SETUP_VALUE_NAME,
                            NULL,
                            NULL,
                            (LPBYTE) &dwValue,
                            &cbValue);

    RegCloseKey(hKey);

    if (dwErr != ERROR_SUCCESS)
    {
        return FALSE;
    }

    return dwValue;
}


//
// Multi-User Addition
//
/*****************************************************************************
 *
 *  SendMessageToLogonIdW
 *
 *   Send the supplied Message to the WinStation of LogonId
 *
 * ENTRY:
 *   LogonId (input)
 *     LogonId of WinStation to attempt to deliver the message to
 *
 *   pMessage (input)
 *     Pointer to message
 *
 *   pTitle (input)
 *     Pointer to title to use for the message box.
 *
 * EXIT:
 *   TRUE - Delivered the message
 *   FALSE - Could not deliver the message
 *
 ****************************************************************************/

BOOL
SendMessageToLogonIdW(
    LUID    LogonId,
    LPWSTR  pMessage,
    LPWSTR  pTitle
    )
{
    WCHAR LogonIdKeyName[NW_MAX_LOGON_ID_LEN];
    LONG  RegError;
    HKEY  InteractiveLogonKey;
    HKEY  OneLogonKey;
    ULONG TitleLength;
    ULONG MessageLength, Response;
    DWORD status;
    ULONG WinStationId;
    PULONG pWinId = NULL;
    BEEPINPUT BeepStruct;
    HMODULE hwinsta = NULL;
    PWINSTATION_SET_INFORMATION pfnWinStationSetInformation;
    PWINSTATION_SEND_MESSAGE    pfnWinStationSendMessage;
    BOOL bStatus = TRUE;

    RegError = RegOpenKeyExW(
                            HKEY_LOCAL_MACHINE,
                            NW_INTERACTIVE_LOGON_REGKEY,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ,
                            &InteractiveLogonKey
                            );

    if (RegError != ERROR_SUCCESS) {
        KdPrint(("SendMessageToLogonId: RegOpenKeyExW failed: Error %d\n",
                 GetLastError()));
        bStatus = FALSE;
        goto Exit;
    }

    NwLuidToWStr(&LogonId, LogonIdKeyName);

    //
    // Open the <LogonIdKeyName> key under Logon
    //
    RegError = RegOpenKeyExW(
                            InteractiveLogonKey,
                            LogonIdKeyName,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ,
                            &OneLogonKey
                            );

    if ( RegError != ERROR_SUCCESS ) {
#if DBG
        IF_DEBUG(PRINT)
        KdPrint(("SendMessageToLogonId: RegOpenKeyExW failed, Not interactive Logon: Error %d\n",
                 GetLastError()));
#endif
        (void) RegCloseKey(InteractiveLogonKey);
        bStatus = FALSE;
        goto Exit;
    }

    //
    // Read the WinStation ID value.
    //
    status = NwReadRegValue(
                           OneLogonKey,
                           NW_WINSTATION_VALUENAME,
                           (LPWSTR *) &pWinId
                           );

    (void) RegCloseKey(OneLogonKey);
    (void) RegCloseKey(InteractiveLogonKey);

    if (status != NO_ERROR) {
        KdPrint(("NWWORKSTATION: SendMessageToLogonId: Could not read WinStation ID ID from reg %lu\n", status));
        bStatus = FALSE;
        goto Exit;
    } else if (pWinId != NULL) {
        WinStationId = *pWinId;
        (void) LocalFree((HLOCAL) pWinId);
    } else {
        bStatus = FALSE;
        goto Exit;
    }

    if ( WinStationId == 0L ) {
        (void) MessageBeep(MB_ICONEXCLAMATION);

        (void) MessageBoxW(
                          NULL,
                          pMessage,
                          pTitle,
                          MB_OK | MB_SETFOREGROUND |
                          MB_SYSTEMMODAL | MB_SERVICE_NOTIFICATION
                          );
        bStatus = TRUE;
        goto Exit;
    }

    /*
     *  Beep the WinStation
     */
    BeepStruct.uType = MB_ICONEXCLAMATION;

    /* Nevermind any errors it's just a Beep */

    /*
    *  Get handle to winsta.dll
    */
    if ( (hwinsta = LoadLibraryW( L"WINSTA" )) != NULL ) {

        pfnWinStationSetInformation  = (PWINSTATION_SET_INFORMATION)
                                       GetProcAddress( hwinsta, "WinStationSetInformationW" );

        pfnWinStationSendMessage = (PWINSTATION_SEND_MESSAGE)
                                   GetProcAddress( hwinsta, "WinStationSendMessageW" );

        if (pfnWinStationSetInformation) {
            (void) pfnWinStationSetInformation( SERVERNAME_CURRENT,
                                                WinStationId,
                                                WinStationBeep,
                                                &BeepStruct,
                                                sizeof( BeepStruct ) );
        }

        if (pfnWinStationSendMessage) {

            // Now attempt to send the message

            TitleLength = (wcslen( pTitle ) + 1) * sizeof(WCHAR);
            MessageLength = (wcslen( pMessage ) + 1) * sizeof(WCHAR);

            if ( !pfnWinStationSendMessage( SERVERNAME_CURRENT,
                                            WinStationId,
                                            pTitle,
                                            TitleLength,
                                            pMessage,
                                            MessageLength,
                                            MB_OK | MB_SETFOREGROUND |
                                            MB_SYSTEMMODAL | MB_SERVICE_NOTIFICATION,
                                            (ULONG)-1,
                                            &Response,
                                            TRUE ) ) {

                bStatus = FALSE;
                goto Exit;
            }
        } else {
            bStatus = FALSE;
            goto Exit;
        }
    }
Exit:

    if (hwinsta) {
        FreeLibrary(hwinsta);
    }
    return(bStatus);
}

BOOL
NwGetLUIDDeviceMapsEnabled(
    VOID
    )

/*++

Routine Description:

    This function calls NtQueryInformationProcess() to determine if
    LUID device maps are enabled


Arguments:

    none

Return Value:

    TRUE - LUID device maps are enabled

    FALSE - LUID device maps are disabled

--*/

{

    NTSTATUS   Status;
    ULONG      LUIDDeviceMapsEnabled;
    BOOL       Result;

    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessLUIDDeviceMapsEnabled,
                                        &LUIDDeviceMapsEnabled,
                                        sizeof(LUIDDeviceMapsEnabled),
                                        NULL
                                      );

    if (!NT_SUCCESS( Status )) {
#if DBG
        IF_DEBUG(PRINT)
        KdPrint(("NwGetLUIDDeviceMapsEnabled: Fail to check LUID DosDevices Enabled: Status 0x%lx\n",
                 Status));
#endif

        Result = FALSE;
    }
    else {
        Result = (LUIDDeviceMapsEnabled != 0);
    }

    return( Result );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\server\nwwks_s_stub.c ===
#include "nwwks_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\server\nw.h ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    nw.h

Abstract:

    Main header of the NetWare Workstation service included by all
    modules.

Author:

    Rita Wong      (ritaw)      11-Dec-1992

Environment:

    User Mode -Win32

Revision History:

--*/

#ifndef _NW_INCLUDED_
#define _NW_INCLUDED_

//
// Includes
//
#include <stdlib.h>
#include <string.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windef.h>
#include <winbase.h>
#include <winerror.h>
#include <winsvc.h>
#include <winreg.h>
#include <winspool.h>

#include <svcs.h>       // intrinsic service definitions

#include <align.h>
#include <nwcanon.h>
#include <nwpkstr.h>

#include <rpc.h>
#include <nwwks.h>

#include <nwevent.h>
#include <ntddnwfs.h>
#include <nwsnames.h>
#include <handle.h>
#include <ndsapi32.h>
#include <ntddnwfs.h>

#define NW_DRIVER_NAME       DD_NWFS_FILESYS_NAME_U


//
// Debug trace level bits for turning on/off trace statements in the
// Workstation service
//

//
// Initialization and reading info from registry
//
#define NW_DEBUG_INIT         0x00000001

//
// Connection APIs
//
#define NW_DEBUG_CONNECT      0x00000002

//
// Enumeration APIs
//
#define NW_DEBUG_ENUM         0x00000004

//
// Credential management APIs
//
#define NW_DEBUG_LOGON        0x00000008

//
// Queue management APIs
//
#define NW_DEBUG_QUEUE        0x00000010

//
// Print Provider APIs
//
#define NW_DEBUG_PRINT        0x00000020

//
// Calls to redirector
//
#define NW_DEBUG_DEVICE       0x00000040

//
// Message APIs
//
#define NW_DEBUG_MESSAGE      0x00000080

#if DBG

extern DWORD WorkstationTrace;

#define IF_DEBUG(DebugCode) if (WorkstationTrace & NW_DEBUG_ ## DebugCode)

#define STATIC

#else

#define IF_DEBUG(DebugCode) if (FALSE)

#define STATIC static

#endif // DBG

//
// Initialization states
//
#define NW_EVENTS_CREATED         0x00000001
#define NW_RDR_INITIALIZED        0x00000002
#define NW_BOUND_TO_TRANSPORTS    0x00000004
#define NW_RPC_SERVER_STARTED     0x00000008
#define NW_INITIALIZED_MESSAGE    0x00000010
#define NW_GATEWAY_LOGON          0x00000020

//
// Key path to redirector driver entry
//
#define SERVICE_REGISTRY_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"
// now all SKUs have TerminalServer flag.  If App Server is enabled, SingleUserTS flag is cleared
#define IsTerminalServer() (BOOLEAN)(!(USER_SHARED_DATA->SuiteMask & (1 << SingleUserTS))) //user mode

//
// Event that will be signaled when the service is stopping
//
extern HANDLE NwDoneEvent;

//
// Events for controlling popups, and the global popup data.
//
extern HANDLE NwPopupEvent;
extern HANDLE NwPopupDoneEvent;

typedef struct _NWWKS_POPUP_DATA {
    DWORD  MessageId ;
    LUID   LogonId;
    DWORD  InsertCount ;
    LPWSTR InsertStrings[10] ;
} NWWKS_POPUP_DATA, *LPNWWKS_POPUP_DATA ;

extern NWWKS_POPUP_DATA PopupData ;

//
// Flag to control DBCS translations
//

extern LONG Japan;

//
// Name of the network provider and print provider
//
extern WCHAR NwProviderName[];
extern DWORD NwPacketBurstSize;
extern DWORD NwPrintOption;
extern DWORD NwGatewayPrintOption;
extern BOOL  GatewayLoggedOn ;
extern BOOL  GatewayConnectionAlways ;

//
// critical sections used 
//
extern CRITICAL_SECTION NwLoggedOnCritSec;
extern CRITICAL_SECTION NwServiceListCriticalSection; 
extern CRITICAL_SECTION NwPrintCritSec;  
//
// Functions from device.c
//
DWORD
NwInitializeRedirector(
    VOID
    );

DWORD
NwOpenRedirector(
    VOID
    );

DWORD
NwShutdownRedirector(
    VOID
    );

DWORD
NwLoadOrUnloadDriver(
    BOOL Load
    );

DWORD
NwBindToTransports(
    VOID
    );

DWORD
NwOpenPreferredServer(
    PHANDLE ServerHandle
    );

VOID
NwInitializePrintProvider(
    VOID
    );

VOID
NwTerminatePrintProvider(
    VOID
    );

DWORD
NwRedirFsControl(
    IN  HANDLE FileHandle,
    IN  ULONG RedirControlCode,
    IN  PNWR_REQUEST_PACKET Rrp,
    IN  ULONG RrpLength,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG Information OPTIONAL
    );

DWORD
NwCreateTreeConnectName(
    IN  LPWSTR UncName,
    IN  LPWSTR LocalName OPTIONAL,
    OUT PUNICODE_STRING TreeConnectStr
    );

DWORD
NwOpenCreateConnection(
    IN PUNICODE_STRING TreeConnectionName,
    IN LPWSTR UserName OPTIONAL,
    IN LPWSTR Password OPTIONAL,
    IN LPWSTR UncName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN ULONG ConnectionType,
    OUT PHANDLE TreeConnectionHandle,
    OUT PULONG_PTR Information OPTIONAL
    );

DWORD
NwNukeConnection(
    IN HANDLE TreeConnection,
    IN DWORD UseForce
    );

DWORD
NwGetServerResource(
    IN LPWSTR LocalName,
    IN DWORD LocalNameLength,
    OUT LPWSTR RemoteName,
    IN DWORD RemoteNameLen,
    OUT LPDWORD CharsRequired
    );

DWORD
NwEnumerateConnections(
    IN OUT PDWORD_PTR ResumeId,
    IN DWORD_PTR EntriesRequested,
    IN LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead,
    IN DWORD ConnectionType,
    IN PLUID LogonId
    );

DWORD
NwGetNextServerEntry(
    IN HANDLE PreferredServer,
    IN OUT LPDWORD LastObjectId,
    OUT LPSTR ServerName
    );

DWORD
NwGetNextServerConnection(
    OUT LPNW_ENUM_CONTEXT ContextHandle
    );

DWORD
NwGetNextNdsTreeEntry(
    OUT LPNW_ENUM_CONTEXT ContextHandle
    );

DWORD
NwGetNextVolumeEntry(
    IN HANDLE ServerConnection,
    IN DWORD LastObjectId,
    OUT LPSTR VolumeName
    );

DWORD
NwRdrLogonUser(
    IN PLUID LogonId,
    IN LPWSTR UserName,
    IN DWORD UserNameSize,
    IN LPWSTR Password OPTIONAL,
    IN DWORD PasswordSize,
    IN LPWSTR PreferredServer OPTIONAL,
    IN DWORD PreferredServerSize,
    IN LPWSTR NdsPreferredServer OPTIONAL,
    IN DWORD NdsPreferredServerSize,
    IN DWORD PrintOption
    );

VOID
NwRdrChangePassword(
    IN PNWR_REQUEST_PACKET Rrp
    );

DWORD
NwRdrSetInfo(
    IN DWORD  PrintOption,
    IN DWORD  PacketBurstSize,
    IN LPWSTR PreferredServer,
    IN DWORD  PreferredServerSize,
    IN LPWSTR ProviderName,
    IN DWORD  ProviderNameSize
    );

DWORD
NwRdrLogoffUser(
    IN PLUID LogonId
    );

DWORD
NwConnectToServer(
    IN LPWSTR ServerName
    );

NTSTATUS
NwOpenHandle(
    IN PUNICODE_STRING ObjectName,
    IN BOOL ValidateFlag,
    OUT PHANDLE ObjectHandle
    );

NTSTATUS
NwCallNtOpenFile(
    OUT PHANDLE ObjectHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PUNICODE_STRING ObjectName,
    IN ULONG OpenOptions
    );

//
// Functions from queue.c
//
DWORD
NwGetNextQueueEntry(
    IN HANDLE PreferredServer,
    IN OUT LPDWORD LastObjectId,
    OUT LPSTR QueueName
    );

DWORD
NwAttachToNetwareServer(
    IN  LPWSTR  ServerName,
    OUT LPHANDLE phandleServer
    );

//
// Functions from enum.c
//
DWORD
NwOpenEnumPrintServers(
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    );

DWORD
NwOpenEnumPrintQueues(
    IN LPWSTR ServerName,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    );

DWORD
NwWriteNetResourceEntry(
    IN OUT LPBYTE * FixedPortion,
    IN OUT LPWSTR * EndOfVariableData,
    IN LPWSTR ContainerName OPTIONAL,
    IN LPWSTR LocalName OPTIONAL,
    IN LPWSTR RemoteName,
    IN DWORD ScopeFlags,
    IN DWORD DisplayFlags,
    IN DWORD UsageFlags,
    IN DWORD ResourceType,
    IN LPWSTR SystemPath OPTIONAL,
    OUT LPWSTR * lppSystem OPTIONAL,
    OUT LPDWORD BytesNeeded
    );

DWORD
NwCloseAllConnections(
    VOID
    );

DWORD
NwWritePrinterInfoEntry(
    IN OUT LPBYTE *FixedPortion,
    IN OUT LPWSTR *EndOfVariableData,
    IN LPWSTR ContainerName OPTIONAL,
    IN LPWSTR RemoteName,
    IN DWORD  Flags,
    OUT LPDWORD BytesNeeded
    );

//
// Functions from credentl.c
//
VOID
NwInitializeLogon(
    VOID
    );

VOID
NwGetLogonCredential(
    VOID
    );

DWORD
NwGatewayLogon(
    VOID
    );

DWORD
NwGatewayLogoff(
    VOID
    );

//
// Functions from util.c
//
DWORD
NwMapStatus(
    IN  NTSTATUS NtStatus
    );

DWORD
NwMapBinderyCompletionCode(
    IN  NTSTATUS NtStatus
    );

DWORD
NwImpersonateClient(
    VOID
    );

DWORD
NwRevertToSelf(
    VOID
    );

VOID
NwLogEvent(
    DWORD MessageId,
    DWORD NumberOfSubStrings,
    LPWSTR *SubStrings,
    DWORD ErrorCode
    );

BOOL
NwConvertToUnicode(
    OUT LPWSTR *UnicodeOut,
    IN LPSTR  OemIn
    );

VOID
DeleteAllConnections(
    VOID
    );

//
// Functions from connect.c
//
DWORD
NwCreateSymbolicLink(
    IN  LPWSTR Local,
    IN  LPWSTR TreeConnectStr,
    IN  BOOL   bGateway,             //Multi-user changes. 
    IN  BOOL ImpersonatingClient
    );

VOID
NwDeleteSymbolicLink(
    IN  LPWSTR LocalDeviceName,
    IN  LPWSTR TreeConnectStr,
    IN  LPWSTR SessionDeviceName,    //Terminal Server Addition
    IN  BOOL ImpersonatingClient
    );

DWORD
NwOpenHandleToDeleteConn(
    IN  LPWSTR UncName,
    IN  LPWSTR LocalName OPTIONAL,
    IN  DWORD UseForce,
    IN  BOOL IsStopWksta,
    IN  BOOL ImpersonatingClient
    );

DWORD
NwCreateConnection(
    IN LPWSTR LocalName OPTIONAL,
    IN LPWSTR RemoteName,
    IN DWORD Type,
    IN LPWSTR Password OPTIONAL,
    IN LPWSTR UserName OPTIONAL
    );

//
// Functions from gateway.c
//
DWORD
NwEnumerateGWDevices(
    LPDWORD Index,
    LPBYTE Buffer,
    DWORD BufferSize,
    LPDWORD BytesNeeded,
    LPDWORD EntriesRead
    ) ;

DWORD
NwCreateGWDevice(
    LPWSTR DeviceName,
    LPWSTR RemoteName,
    DWORD  Flags
    ) ;

DWORD
NwRemoveGWDevice(
    LPWSTR DeviceName,
    DWORD  Flags
    ) ;

DWORD
NwQueryGWAccount(
    LPWSTR   AccountName,
    DWORD    AccountNameLen,
    LPDWORD  AccountCharsNeeded,
    LPWSTR   Password,
    DWORD    PasswordLen,
    LPDWORD  PasswordCharsNeeded
    ) ;

DWORD
NwSetGWAccount(
    LPWSTR AccountName,
    LPWSTR Password
    ) ;

DWORD
NwGetGatewayResource(
    IN LPWSTR LocalName,
    OUT LPWSTR RemoteName,
    IN DWORD RemoteNameLen,
    OUT LPDWORD CharsRequired
    );

DWORD
NwCreateRedirections(
    LPWSTR Account,
    LPWSTR Password
    );

DWORD
NwDeleteRedirections(
    VOID
    );

DWORD
NwCreateGWConnection(
    IN LPWSTR RemoteName,
    IN LPWSTR UserName,
    IN LPWSTR Password,
    IN BOOL   KeepConnection
    );

DWORD
NwDeleteGWConnection(
    IN LPWSTR RemoteName
    );


//
// (Functions from citrix.c)
// Terminal Server Addition
//
BOOL
SendMessageToLogonIdW(
    IN LUID    LogonId,
    IN LPWSTR  pMessage,
    IN LPWSTR  pTitle
    );




NTSTATUS
NwGetSessionId(
    OUT PULONG pSessionId
    );


#endif // _NW_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\socket.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    socket.c

Abstract:

    Contains functions to create, delete and manipulate IPX sockets and SPX
    connections

    Contents:
        CreateSocket
        AllocateTemporarySocket
        QueueSocket
        DequeueSocket
        FindSocket
        FindActiveSocket
        ReopenSocket
        KillSocket
        KillShortLivedSockets
        AllocateConnection
        DeallocateConnection
        FindConnection
        QueueConnection
        DequeueConnection
        KillConnection
        AbortOrTerminateConnection
        CheckPendingSpxRequests
        (CheckSocketState)
        (CheckSelectRead)
        (CheckSelectWrite)
        (AsyncReadAction)
        (AsyncWriteAction)
        (CompleteAccept)
        (CompleteReceive)
        (CompleteConnect)
        (CompleteSend)

Author:

    Richard L Firth (rfirth) 25-Oct-1993

Environment:

    User-mode Win32

Revision History:

    25-Oct-1993 rfirth
        Created

--*/

#include "vw.h"
#pragma hdrstop

//
// miscellaneous manifests
//

#define ARBITRARY_CONNECTION_INCREMENT  2

//
// macros
//

#define ALLOCATE_CONNECTION_NUMBER()    (ConnectionNumber += ARBITRARY_CONNECTION_INCREMENT)

//
// private data
//

PRIVATE LPSOCKET_INFO SocketList = NULL;
PRIVATE LPCONNECTION_INFO ConnectionList = NULL;
PRIVATE WORD ConnectionNumber = ARBITRARY_CONNECTION_NUMBER;

//
// private functions
//

PRIVATE
BOOL
CheckSocketState(
    IN SOCKET Socket,
    OUT LPBOOL Readable,
    OUT LPBOOL Writeable,
    OUT LPBOOL Error
    );


PRIVATE
VOID
CheckSelectRead(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo,
    OUT BOOL *CheckRead
    );

PRIVATE
VOID
CheckSelectWrite(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo,
    OUT BOOL *CheckWrite
    );

PRIVATE
VOID
AsyncReadAction(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo,
    OUT BOOL *ReadPerformed
    );

PRIVATE
VOID
AsyncWriteAction(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo,
    OUT BOOL *WritePerformed
    );

PRIVATE
VOID
CompleteAccept(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    );

PRIVATE
VOID
CompleteReceive(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    );

PRIVATE
VOID
CompleteConnect(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    );

PRIVATE
VOID
CompleteSend(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    );

#if SPX_HACK
PRIVATE VOID ModifyFirstReceive(LPBYTE, LPDWORD, WORD, SOCKET);
#endif

//
// public functions
//


int
CreateSocket(
    IN SOCKET_TYPE SocketType,
    IN OUT ULPWORD pSocketNumber,
    OUT SOCKET* pSocket
    )

/*++

Routine Description:

    Creates a socket for IPX or SPX (a connection). Once the socket is created
    we have to bind it to the IPX/SPX 'socket' - i.e. port. We also need to
    change a few things about the standard socket:

        * if this is an SPX request then we must set the REUSEADDR socket option
          since there may typically be several connect requests over the same
          WinSock socket: we need to be able to bind multiple connections to the
          same socket number

        * all sockets opened by this function are put into non-blocking mode
        * all sockets opened by this function will return the packet header in
          any received data (IPX_RECVHDR)

    The requested socket number can be 0 in which case we bind to a dynamic
    socket number. We always return the number of the socket bound to: if not 0
    on input, this should always be the same value as that requested in
    pSocketNumber

    If any WinSock call fails (and the socket was created) then we close the
    socket before returning

Arguments:

    SocketType      - SOCKET_TYPE_IPX or SOCKET_TYPE_SPX
    pSocketNumber   - input: socket number to bind (can be 0)
                      output: socket number bound
    pSocket         - pointer to address of socket identifier to return

Return Value:

    int
        Success - IPX_SUCCESS/SPX_SUCCESS (0)

        Failure - IPX_SOCKET_TABLE_FULL
                    WinSock cannot create the socket

                  IPX_SOCKET_ALREADY_OPEN
                    Assume the request was for an IPX socket: we do not allow
                    multiple IPX sockets to be bound to the same socket number,
                    only SPX


--*/

{
    SOCKET s;
    SOCKADDR_IPX socketAddress;
    BOOL true = TRUE;
    int rc;
    int status = IPX_SOCKET_TABLE_FULL; // default error

    s = socket(AF_IPX,
               (SocketType == SOCKET_TYPE_SPX) ? SOCK_SEQPACKET : SOCK_DGRAM,
               (SocketType == SOCKET_TYPE_SPX) ? NSPROTO_SPX : NSPROTO_IPX
                );

    if (s != INVALID_SOCKET) {

        //
        // for stream (SPX) sockets, we need multiple sockets bound to the
        // same socket number if we are to have multiple connections on the
        // same SPX socket
        //

        if (SocketType == SOCKET_TYPE_SPX) {
            rc = setsockopt(s,
                            SOL_SOCKET,
                            SO_REUSEADDR,
                            (char FAR*)&true,
                            sizeof(true)
                            );
            if (rc == SOCKET_ERROR) {

                IPXDBGPRINT((__FILE__, __LINE__,
                            FUNCTION_ANY,
                            IPXDBG_LEVEL_ERROR,
                            "CreateSocket: setsockopt(SO_REUSEADDR) returns %d\n",
                            WSAGetLastError()
                            ));

            } else {
                rc = setsockopt(s,
                                SOL_SOCKET,
                                SO_OOBINLINE,
                                (char FAR*)&true,
                                sizeof(true)
                                );

                if (rc == SOCKET_ERROR) {

                    IPXDBGPRINT((__FILE__, __LINE__,
                                FUNCTION_ANY,
                                IPXDBG_LEVEL_ERROR,
                                "CreateSocket: setsockopt(SO_OOBINLINE) returns %d\n",
                                WSAGetLastError()
                                ));

                }
            }
        } else {

            //
            // allow broadcasts to be transmitted on IPX sockets
            //

            rc = setsockopt(s,
                            SOL_SOCKET,
                            SO_BROADCAST,
                            (char FAR*)&true,
                            sizeof(true)
                            );
        }
        if (!rc) {

            //
            // bind the socket to the local socket number (port)
            //

            ZeroMemory(&socketAddress, sizeof(socketAddress));
            socketAddress.sa_family = AF_IPX;
            socketAddress.sa_socket = *pSocketNumber;
            rc = bind(s, (LPSOCKADDR)&socketAddress, sizeof(socketAddress));
            if (rc != SOCKET_ERROR) {

                int length = sizeof(socketAddress);

                ZeroMemory(&socketAddress, sizeof(socketAddress));
                socketAddress.sa_family = AF_IPX;

                //
                // use getsockname() to find the (big-endian) socket value that
                // was actually assigned: should only be different from
                // *pSocketNumber if the latter was 0 on input
                //

                rc = getsockname(s, (LPSOCKADDR)&socketAddress, &length);
                if (rc != SOCKET_ERROR) {

                    u_long arg = !0;

                    //
                    // put the socket into non-blocking mode. Neither IPX nor
                    // SPX sockets are blocking: the app starts an I/O request
                    // and if it doesn't complete immediately, will be completed
                    // by AES which periodically polls the outstanding I/O
                    // requests
                    //

                    rc = ioctlsocket(s, FIONBIO, &arg);
                    if (rc != SOCKET_ERROR) {

                        //
                        // return protocol header on receive frames
                        //

                        rc = setsockopt(s,
                                        NSPROTO_IPX,
                                        IPX_RECVHDR,
                                        (char FAR*)&true,
                                        sizeof(true)
                                        );
                        if (rc != SOCKET_ERROR) {
                            *pSocketNumber = socketAddress.sa_socket;
                            *pSocket = s;
                            status = IPX_SUCCESS;
                        } else {

                            IPXDBGPRINT((__FILE__, __LINE__,
                                        FUNCTION_ANY,
                                        IPXDBG_LEVEL_ERROR,
                                        "CreateSocket: setsockopt(RECVHDR) returns %d\n",
                                        WSAGetLastError()
                                        ));

                        }
                    } else {

                        IPXDBGPRINT((__FILE__, __LINE__,
                                    FUNCTION_ANY,
                                    IPXDBG_LEVEL_ERROR,
                                    "CreateSocket: ioctlsocket(FIONBIO) returns %d\n",
                                    WSAGetLastError()
                                    ));

                    }
                } else {

                    IPXDBGPRINT((__FILE__, __LINE__,
                                FUNCTION_ANY,
                                IPXDBG_LEVEL_ERROR,
                                "CreateSocket: getsockname() returns %d\n",
                                WSAGetLastError()
                                ));

                }
            } else {

                //
                // bind() failed - either an expected error (the requested socket
                // is already in use), or (horror) an unexpected error, in which
                // case report table full (?)
                //

                switch (WSAGetLastError()) {
                case WSAEADDRINUSE:

                    ASSERT(*pSocketNumber != 0);
                    ASSERT(SocketType == SOCKET_TYPE_IPX);

                    status = IPX_SOCKET_ALREADY_OPEN;
                    break;

                default:

                    IPXDBGPRINT((__FILE__, __LINE__,
                                FUNCTION_ANY,
                                IPXDBG_LEVEL_ERROR,
                                "CreateSocket: bind() on socket %#x returns %d\n",
                                s,
                                WSAGetLastError()
                                ));

                }
            }
        }
    } else {

        //
        // the socket() call failed - treat as table full
        //

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_ERROR,
                    "CreateSocket: socket() returns %d\n",
                    WSAGetLastError()
                    ));

    }
    if (status != IPX_SUCCESS) {
        if (s != INVALID_SOCKET) {
            closesocket(s);
        }
    }
    return status;
}


LPSOCKET_INFO
AllocateTemporarySocket(
    VOID
    )

/*++

Routine Description:

    Allocates a temporary socket. Creates an IPX socket having a dynamically
    allocated socket number

Arguments:

    None.

Return Value:

    LPSOCKET_INFO
        Success - pointer to SOCKET_INFO structure
        Failure - NULL

--*/

{
    LPSOCKET_INFO pSocketInfo;
    int rc;

    pSocketInfo = AllocateSocket();
    if (pSocketInfo) {

        //
        // assumption: the SOCKET_INFO structure was zeroed by LocalAlloc(LPTR,..
        // hence the SocketNumber fields is 0. This causes CreateSocket to
        // generate a dynamic socket number
        //

        rc = CreateSocket(SOCKET_TYPE_IPX,
                          &pSocketInfo->SocketNumber,
                          &pSocketInfo->Socket
                          );
        if (rc == IPX_SUCCESS) {
            pSocketInfo->Flags |= SOCKET_FLAG_TEMPORARY;
        } else {
            DeallocateSocket(pSocketInfo);
            pSocketInfo = NULL;
        }
    }
    return pSocketInfo;
}


VOID
QueueSocket(
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Add a SOCKET_INFO structure to the list (LIFO) of (opened) sockets

Arguments:

    pSocketInfo - pointer to filled-in SOCKET_INFO structure

Return Value:

    None.

--*/

{
    RequestMutex();
    pSocketInfo->Next = SocketList;
    SocketList = pSocketInfo;
    ReleaseMutex();
}


LPSOCKET_INFO
DequeueSocket(
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Remove a SOCKET_INFO structure from the list

Arguments:

    pSocketInfo - pointer to SOCKET_INFO structure to remove

Return Value:

    LPSOCKET_INFO
        pSocketInfo - should be this value
        NULL - couldn't find pSocketInfo (should not get this!)

--*/

{
    LPSOCKET_INFO prev, p;

    ASSERT(SocketList);

    RequestMutex();
    prev = (LPSOCKET_INFO)&SocketList;
    p = SocketList;
    while (p) {
        if (p == pSocketInfo) {
            prev->Next = p->Next;
            p->Next = NULL;
            break;
        } else {
            prev = p;
            p = p->Next;
        }
    }

    if (!p) {

        //
        // should never reach here
        //

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_FATAL,
                    "DequeueSocket: can't find socket structure %08x on queue\n",
                    pSocketInfo
                    ));

    }

    ReleaseMutex();
    return p;
}


LPSOCKET_INFO
FindSocket(
    IN WORD SocketNumber
    )

/*++

Routine Description:

    Locate a SOCKET_INFO structure in the list, by (big-endian) socket number

    Assumes:    1. There is 1 and only 1 SOCKET_INFO structure that contains
                   SocketNumber

Arguments:

    SocketNumber    - big-endian socket number to find

Return Value:

    LPSOCKET_INFO
        NULL - couldn't find requested socket
        !NULL - pointer to discovered SOCKET_INFO structure

--*/

{
    LPSOCKET_INFO p;

    RequestMutex();
    p = SocketList;
    while (p) {
        if (p->SocketNumber == SocketNumber) {
            break;
        } else {
            p = p->Next;
        }
    }
    ReleaseMutex();
    return p;
}


LPSOCKET_INFO
FindActiveSocket(
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Find a SOCKET_INFO structure with pending send or receive. Called as FindFirst,
    FindNext - first call made with pSocketInfo == NULL: enters critical section
    if an active socket is found, returns pointer

    Subsequent calls are made with pSocketInfo pointing to last returned
    SOCKET_INFO. This continues the search. When search exhausted, critical
    section is released

Arguments:

    pSocketInfo - pointer to SOCKET_INFO structure: first time must be NULL

Return Value:

    LPSOCKET_INFO - next active SOCKET_INFO structure or NULL

--*/

{
    if (!pSocketInfo) {
        RequestMutex();
        pSocketInfo = SocketList;
    } else {
        pSocketInfo = pSocketInfo->Next;
    }
    for (; pSocketInfo; pSocketInfo = pSocketInfo->Next) {
        if (pSocketInfo->Flags & (SOCKET_FLAG_SENDING | SOCKET_FLAG_LISTENING)) {
            return pSocketInfo;
        }
    }
    ReleaseMutex();
    return NULL;
}


int
ReopenSocket(
    LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Called expressly to close an IPX socket and reassign the descriptor to SPX.
    Note that after this function completes, IPXSendPacket and IPXListenForPacket
    cannot be made agains the IPX socket

Arguments:

    pSocketInfo - pointer to SOCKET_INFO which currently describes an IPX socket

Return Value:

    int - return code from CreateSocket

--*/

{
    int rc;

    rc = closesocket(pSocketInfo->Socket);
    if (rc == SOCKET_ERROR) {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_ERROR,
                    "ReopenSocket: closesocket() returns %d\n",
                    WSAGetLastError()
                    ));

    }

    //
    // mark this socket as connection-based (SPX) socket
    //

    pSocketInfo->SpxSocket = TRUE;

    //
    // re-open the socket for SPX use
    //

    return CreateSocket(SOCKET_TYPE_SPX,
                        &pSocketInfo->SocketNumber,
                        &pSocketInfo->Socket
                        );
}


VOID
KillSocket(
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    closes a socket, removes the SOCKET_INFO structure from the list and cancels
    any pending send, listen or timed events associated with the socket

Arguments:

    pSocketInfo - identifying socket to kill

Return Value:

    None.

--*/

{

    int rc;

    //
    // remove the SOCKET_INFO structure from the list of sockets. Cancel
    // any pending ECB requests and any IPX timed events that have the
    // same socket number
    //

    DequeueSocket(pSocketInfo);
    rc = closesocket(pSocketInfo->Socket);
    if (rc == SOCKET_ERROR) {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_ERROR,
                    "KillSocket: closesocket() returns %d\n",
                    WSAGetLastError()
                    ));

    }

    //
    // the socket has been removed from SocketList: no need to grab mutex to
    // perform the following
    //

    CancelTimedEvents(pSocketInfo->SocketNumber, 0, 0);
    CancelSocketQueue(&pSocketInfo->ListenQueue);
    CancelSocketQueue(&pSocketInfo->HeaderQueue);
    CancelSocketQueue(&pSocketInfo->SendQueue);
    if (pSocketInfo->SpxSocket) {

        LPCONNECTION_INFO pConnectionInfo;

        while (pConnectionInfo = pSocketInfo->Connections) {
            DequeueConnection(pSocketInfo, pConnectionInfo);
            KillConnection(pConnectionInfo);
        }
    }
    DeallocateSocket(pSocketInfo);
}


VOID
KillShortLivedSockets(
    IN WORD Owner
    )

/*++

Routine Description:

    For all those sockets created by a DOS process as SHORT_LIVED, terminate
    the sockets, cancelling any outstanding ECBs

Arguments:

    Owner   - DOS PDB which opened sockets

Return Value:

    None.

--*/

{
    LPSOCKET_INFO pSocketInfo;

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "KillShortLivedSockets(%04x)\n",
                Owner
                ));

    RequestMutex();

    //
    // kill any non-socket (AES) timed events owned by this DOS process
    //

    CancelTimedEvents(0, Owner, 0);

    //
    // kill all sockets owned by this PDB
    //

    pSocketInfo = SocketList;
    while (pSocketInfo) {

        LPSOCKET_INFO next;

        next = pSocketInfo->Next;
        if (!pSocketInfo->LongLived && (pSocketInfo->Owner == Owner)) {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_INFO,
                        "KillShortLivedSockets: Socket %04x owned by %04x\n",
                        B2LW(pSocketInfo->SocketNumber),
                        pSocketInfo->Owner
                        ));

            KillSocket(pSocketInfo);
        }
        pSocketInfo = next;
    }
    ReleaseMutex();
}


LPCONNECTION_INFO
AllocateConnection(
    LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Allocates a CONNECTION_INFO structure. If successful, links it at the head
    of ConnectionList

Arguments:

    pSocketInfo - pointer to owner SOCKET_INFO

Return Value:

    LPCONNECTION_INFO
        Success - !NULL
        Failure - NULL

--*/

{
    LPCONNECTION_INFO pConnectionInfo;

    pConnectionInfo = (LPCONNECTION_INFO)LocalAlloc(LPTR, sizeof(*pConnectionInfo));
    if (pConnectionInfo) {
        RequestMutex();
        pConnectionInfo->ConnectionId = ALLOCATE_CONNECTION_NUMBER();
        pConnectionInfo->List = ConnectionList;
        ConnectionList = pConnectionInfo;
        ReleaseMutex();

#if SPX_HACK
        pConnectionInfo->Flags = CF_1ST_RECEIVE;
#endif
    }

    return pConnectionInfo;
}


VOID
DeallocateConnection(
    IN LPCONNECTION_INFO pConnectionInfo
    )

/*++

Routine Description:

    Undoes the work of AllocateConnection - removes pConnectionInfo from
    ConnectionList and deallocates the structure

Arguments:

    pConnectionInfo - pointer to CONNECTION_INFO to deallocate

Return Value:

    None.

--*/

{
    LPCONNECTION_INFO p;
    LPCONNECTION_INFO prev = (LPCONNECTION_INFO)&ConnectionList;

    RequestMutex();
    for (p = ConnectionList; p != pConnectionInfo; ) {
        prev = p;
        p = p->List;
    }

    //
    // if p is NULL or differs from pConnectionInfo then there's a problem
    //

    ASSERT(p);

    //
    // special case if pConnectionInfo is first on list: can't say
    // &ConnectionList->List - accesses one pointer beyond ConnectionList
    // which is WRONG
    //

    if (prev == (LPCONNECTION_INFO)&ConnectionList) {
        ConnectionList = p->List;
    } else {
        prev->List = p->List;
    }
    FREE_OBJECT(pConnectionInfo);
    ReleaseMutex();
}


LPCONNECTION_INFO
FindConnection(
    IN WORD ConnectionId
    )

/*++

Routine Description:

    Returns a pointer to CONNECTION_INFO given a unique connection ID

Arguments:

    ConnectionId    - value to find

Return Value:

    LPCONNECTION_INFO
        Success - !NULL
        Failure - NULL

--*/

{
    LPCONNECTION_INFO pConnectionInfo;

    RequestMutex();
    for (pConnectionInfo = ConnectionList; pConnectionInfo; ) {
        if (pConnectionInfo->ConnectionId == ConnectionId) {
            break;
        } else {
            pConnectionInfo = pConnectionInfo->List;
        }
    }
    ReleaseMutex();
    return pConnectionInfo;
}


VOID
QueueConnection(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    )

/*++

Routine Description:

    Adds a CONNECTION_INFO to the list of connections owned by a SOCKET_INFO.
    Points the CONNECTION_INFO back to the SOCKET_INFO

Arguments:

    pSocketInfo     - owning SOCKET_INFO
    pConnectionInfo - CONNECTION_INFO to add

Return Value:

    None.

--*/

{
    pConnectionInfo->Next = pSocketInfo->Connections;
    pSocketInfo->Connections = pConnectionInfo;
    pConnectionInfo->OwningSocket = pSocketInfo;
}


LPCONNECTION_INFO
DequeueConnection(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    )

/*++

Routine Description:

    Removes a CONNECTION_INFO from the list of connections owned by a SOCKET_INFO

Arguments:

    pSocketInfo     - owning SOCKET_INFO
    pConnectionInfo - CONNECTION_INFO to remove

Return Value:

    LPCONNECTION_INFO
        Success - pointer to removed CONNECTION_INFO (should be same as
                  pConnectionInfo)
        Failure - NULL (not expected)

--*/

{
    LPCONNECTION_INFO prev = (LPCONNECTION_INFO)&pSocketInfo->Connections;
    LPCONNECTION_INFO p = prev->Next;

    while (p && p != pConnectionInfo) {
        prev = p;
        p = p->Next;
    }

    ASSERT(p == pConnectionInfo);

    prev->Next = p->Next;
    p->OwningSocket = NULL;
    return p;
}


VOID
KillConnection(
    IN LPCONNECTION_INFO pConnectionInfo
    )

/*++

Routine Description:

    Closes a socket belonging to a connection and cancels all outstanding
    requests. The CONNECTION_INFO is deallocated

Arguments:

    pConnectionInfo - pointer to CONNECTION_INFO to kill

Return Value:

    None.

--*/

{
    if (pConnectionInfo->Socket) {
        closesocket(pConnectionInfo->Socket);
    }
    CancelConnectionQueue(&pConnectionInfo->ConnectQueue);
    CancelConnectionQueue(&pConnectionInfo->AcceptQueue);
    CancelConnectionQueue(&pConnectionInfo->ListenQueue);
    CancelConnectionQueue(&pConnectionInfo->SendQueue);
    DeallocateConnection(pConnectionInfo);
}


VOID
AbortOrTerminateConnection(
    IN LPCONNECTION_INFO pConnectionInfo,
    IN BYTE CompletionCode
    )

/*++

Routine Description:

    Aborts or terminates a connection: closes the socket, dequeues and completes
    all outstanding ECBs with relevant code and deallocates the CONNECTION_INFO
    structure

    The CONNECTION_INFO must NOT be queued on a SOCKET_INFO when this routine
    is called

Arguments:

    pConnectionInfo - pointer to CONNECTION_INFO to kill
    CompletionCode  - completion code to put in pending ECBs

Return Value:

    None.

--*/

{
    if (pConnectionInfo->Socket) {
        closesocket(pConnectionInfo->Socket);
    }
    AbortQueue(&pConnectionInfo->ConnectQueue, CompletionCode);
    AbortQueue(&pConnectionInfo->AcceptQueue, CompletionCode);
    AbortQueue(&pConnectionInfo->ListenQueue, CompletionCode);
    AbortQueue(&pConnectionInfo->SendQueue, CompletionCode);
    DeallocateConnection(pConnectionInfo);
}


VOID
CheckPendingSpxRequests(
    BOOL *pfOperationPerformed
    )

/*++

Routine Description:

    Checks the open non-blocking SPX sockets for:

        errors
        outgoing established connections (connect)
        incoming established connections (listen/accept)
        data to receive (recv)
        send completions (send)

Arguments:

    None.

Return Value:

    None.

--*/

{
    LPSOCKET_INFO pSocketInfo;
    
    *pfOperationPerformed = FALSE ;

    RequestMutex();
    pSocketInfo = SocketList;
    while (pSocketInfo) {
        if (pSocketInfo->SpxSocket) {

            LPCONNECTION_INFO pConnectionInfo;

            pConnectionInfo = pSocketInfo->Connections;
            while (pConnectionInfo) {

                LPCONNECTION_INFO next;

                //
                // pluck out the Next field now, in case this CONNECTION_INFO
                // is destroyed as the result of an error
                //

                next = pConnectionInfo->Next;

                //
                // if this connection has an active socket or we have issued
                // SPXListenForConnection against the socket then check the
                // state
                //

                if (pConnectionInfo->Socket
                    || (pConnectionInfo->State == CI_WAITING)) {

                    SOCKET sock;
                    BOOL readable;
                    BOOL writeable;
                    BOOL sockError;

                    CheckSelectRead(pSocketInfo, 
                                    pConnectionInfo,
                                    &readable);

                    CheckSelectWrite(pSocketInfo, 
                                     pConnectionInfo,
                                     &writeable);

                    sock = pConnectionInfo->Socket
                         ? pConnectionInfo->Socket
                         : pSocketInfo->Socket
                         ;

                    if (CheckSocketState(sock, &readable, &writeable, &sockError)) {
                        if (!sockError) {
                            if (readable) {
                                AsyncReadAction(pSocketInfo, 
                                                pConnectionInfo,
                                                pfOperationPerformed);
                            }
                            if (writeable) {
                                AsyncWriteAction(pSocketInfo, 
                                                 pConnectionInfo,
                                                 pfOperationPerformed);
                            }
                        } else {

                            IPXDBGPRINT((__FILE__, __LINE__,
                                        FUNCTION_ANY,
                                        IPXDBG_LEVEL_ERROR,
                                        "CheckPendingSpxRequests: socket %x has error. Connection %08x state %d\n",
                                        sock,
                                        pConnectionInfo,
                                        pConnectionInfo->State
                                        ));

                            //
                            // irrespective of the error, we just abort any
                            // connection that gets an error
                            //

                            DequeueConnection(pConnectionInfo->OwningSocket,
                                              pConnectionInfo
                                              );
                            AbortOrTerminateConnection(pConnectionInfo,
                                                       ECB_CC_CONNECTION_ABORTED
                                                       );
                        }
                    } else {

                        IPXDBGPRINT((__FILE__, __LINE__,
                                    FUNCTION_ANY,
                                    IPXDBG_LEVEL_ERROR,
                                    "CheckPendingSpxRequests: CheckSocketState returns %d\n",
                                    WSAGetLastError()
                                    ));

                    }
                } else {

                    IPXDBGPRINT((__FILE__, __LINE__,
                                FUNCTION_ANY,
                                IPXDBG_LEVEL_ERROR,
                                "CheckPendingSpxRequests: connection %04x (%08x) in weird state?\n",
                                pConnectionInfo->ConnectionId,
                                pConnectionInfo
                                ));

                }
                pConnectionInfo = next;
            }
        }
        pSocketInfo = pSocketInfo->Next;
    }
    ReleaseMutex();
}


PRIVATE
BOOL
CheckSocketState(
    IN SOCKET Socket,
    OUT LPBOOL Readable,
    OUT LPBOOL Writeable,
    OUT LPBOOL Error
    )

/*++

Routine Description:

    Given a socket descriptor, checks to see if it is in one of the following
    states:

        readable    - if waiting for a connection, connection has been made
                      else if established, data is ready to be received

        writeable   - if waiting to make a connection, connection has been
                      made, else if established, we can send data on this
                      socket

        error       - some error has occurred on the socket

Arguments:

    Socket      - socket descriptor to check
    Readable    - returned TRUE if readable
    Writeable   - returned TRUE if writeable
    Error       - returned TRUE if error on socket

Return Value:

    BOOL
        TRUE    - contents of Readable, Writeable and Error are valid
        FALSE   - an error occurred performing the select

--*/

{
    fd_set errors;
    fd_set reads;
    fd_set writes;
    int n;
    static struct timeval timeout = {0, 0};

    FD_ZERO(&errors);
    FD_ZERO(&reads);
    FD_ZERO(&writes);

    if (*Readable)
        FD_SET(Socket, &reads);
    if (*Writeable)
        FD_SET(Socket, &writes);
    FD_SET(Socket, &errors);

    n = select(0, &reads, &writes, &errors, &timeout);

    if (n != SOCKET_ERROR) {
        *Readable = (BOOL)(reads.fd_count == 1);
        *Writeable = (BOOL)(writes.fd_count == 1);
        *Error = (BOOL)(errors.fd_count == 1);
        return TRUE;
    } else if (n) {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "CheckSocketState: select returns %d\n",
                    WSAGetLastError()
                    ));

    }
    return FALSE;
}


PRIVATE
VOID
AsyncReadAction(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo,
    OUT BOOL *ReadPerformed
    )

/*++

Routine Description:

    A connection has some read action to complete - complete a pending
    SPXListenForConnection or SPXListenForSequencedPacket

Arguments:

    pSocketInfo     - pointer to SOCKET_INFO
    pConnectionInfo - pointer to CONNECTION_INFO

Return Value:

    None.

--*/

{
    *ReadPerformed = FALSE ;

    switch (pConnectionInfo->State) {
    case CI_STARTING:

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "AsyncReadAction: STARTING connection %04x (%08x) readable\n",
                    pConnectionInfo->ConnectionId,
                    pConnectionInfo
                    ));

        break;

    case CI_WAITING:
        if (pConnectionInfo->AcceptQueue.Head) {
            CompleteAccept(pSocketInfo, pConnectionInfo);
            *ReadPerformed = TRUE ;
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "AsyncReadAction: connection %04x (%08x): no AcceptQueue\n",
                        pConnectionInfo->ConnectionId,
                        pConnectionInfo
                        ));

        }
        break;

    case CI_ESTABLISHED:
        if (pSocketInfo->ListenQueue.Head) {
            CompleteReceive(pSocketInfo, pConnectionInfo);
            *ReadPerformed = TRUE ;
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_WARNING,
                        "AsyncReadAction: connection %04x (%08x): no ListenQueue\n",
                        pConnectionInfo->ConnectionId,
                        pConnectionInfo
                        ));

        }
        break;

    case CI_TERMINATING:

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "AsyncReadAction: TERMINATING connection %04x (%08x) readable\n",
                    pConnectionInfo->ConnectionId,
                    pConnectionInfo
                    ));

        break;
    }
}


PRIVATE
VOID
AsyncWriteAction(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo,
    OUT BOOL *WritePerformed
    )

/*++

Routine Description:

    A connection has some write action to complete - complete a pending
    SPXEstablishConnection or SPXSendSequencedPacket

Arguments:

    pSocketInfo     - pointer to SOCKET_INFO
    pConnectionInfo - pointer to CONNECTION_INFO

Return Value:

    None.

--*/

{
    *WritePerformed = FALSE ;

    switch (pConnectionInfo->State) {
    case CI_STARTING:
        if (pConnectionInfo->ConnectQueue.Head) {
            CompleteConnect(pSocketInfo, pConnectionInfo);
            *WritePerformed = TRUE ;
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "AsyncWriteAction: connection %04x (%08x): no ConnectQueue\n",
                        pConnectionInfo->ConnectionId,
                        pConnectionInfo
                        ));

        }
        break;

    case CI_WAITING:

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "AsyncWriteAction: WAITING connection %04x (%08x) is writeable\n",
                    pConnectionInfo->ConnectionId,
                    pConnectionInfo
                    ));

        break;

    case CI_ESTABLISHED:
        if (pConnectionInfo->SendQueue.Head) {
            CompleteSend(pSocketInfo, pConnectionInfo);
            *WritePerformed = TRUE ;
        } else {
/*
            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_WARNING,
                        "AsyncWriteAction: connection %04x (%08x): no SendQueue\n",
                        pConnectionInfo->ConnectionId,
                        pConnectionInfo
                        ));
*/
        }
        break;

    case CI_TERMINATING:

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "AsyncWriteAction: TERMINATING connection %04x (%08x) writeable\n",
                    pConnectionInfo->ConnectionId,
                    pConnectionInfo
                    ));

        break;
    }
}

PRIVATE
VOID
CheckSelectRead(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo,
    OUT BOOL *CheckRead
    )

/*++

Routine Description:

    See if want to check for Read readiness in select statement.

Arguments:

    pSocketInfo     - pointer to SOCKET_INFO
    pConnectionInfo - pointer to CONNECTION_INFO

Return Value:

    None.

--*/

{
    *CheckRead = FALSE ;

    switch (pConnectionInfo->State) 
    {
    case CI_WAITING:

        if (pConnectionInfo->AcceptQueue.Head) 
            *CheckRead = TRUE ;
        break;

    case CI_ESTABLISHED:

        if (pSocketInfo->ListenQueue.Head) 
            *CheckRead = TRUE ;
        break;

    default:

        break;
    }
}


PRIVATE
VOID
CheckSelectWrite(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo,
    OUT BOOL *CheckWrite
    )

/*++

Routine Description:

    See if want to check for Write readiness in select statement.

Arguments:

    pSocketInfo     - pointer to SOCKET_INFO
    pConnectionInfo - pointer to CONNECTION_INFO

Return Value:

    None.

--*/

{
    *CheckWrite = FALSE ;

    switch (pConnectionInfo->State) 
    {
    
    case CI_STARTING:

        if (pConnectionInfo->ConnectQueue.Head) 
            *CheckWrite = TRUE ;
        break;

    case CI_ESTABLISHED:

        if (pConnectionInfo->SendQueue.Head) 
            *CheckWrite = TRUE ;
        break;

    default:

        break;
    }
}



PRIVATE
VOID
CompleteAccept(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    )

/*++

Routine Description:

    Complete a SPXListenForConnection

Arguments:

    pSocketInfo     - pointer to SOCKET_INFO
    pConnectionInfo - pointer to CONNECTION_INFO

Return Value:

    None.

--*/

{
    SOCKET conn;
    SOCKADDR_IPX remoteAddress;
    int addressLength = sizeof(remoteAddress);
    LPXECB pXecb = pConnectionInfo->AcceptQueue.Head;
    BOOL true = TRUE;
    int rc;

    conn = accept(pSocketInfo->Socket, (LPSOCKADDR)&remoteAddress, &addressLength);
    if (conn != SOCKET_ERROR) {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "CompleteAccept: connection %04x (%08x) socket=%x\n",
                    pConnectionInfo->ConnectionId,
                    pConnectionInfo,
                    conn
                    ));

        //
        // we want to receive the frame headers from this socket
        //

        rc = setsockopt(conn,
                        NSPROTO_IPX,
                        IPX_RECVHDR,
                        (char FAR*)&true,
                        sizeof(true)
                        );
        rc = !SOCKET_ERROR;
        if (rc != SOCKET_ERROR) {

            //
            // update the CONNECTION_INFO structure with the actual socket
            // identifier and set the connection state to established
            //

            pConnectionInfo->Socket = conn;
            pConnectionInfo->State = CI_ESTABLISHED;

            //
            // update the app's ECB with the connection ID
            //

            SPX_ECB_CONNECTION_ID(pXecb->Ecb) = pConnectionInfo->ConnectionId;

            //
            // and with the partner address info
            //

            CopyMemory(&pXecb->Ecb->DriverWorkspace,
                       &remoteAddress.sa_netnum,
                       sizeof(pXecb->Ecb->DriverWorkspace)
                       );

            //
            // fill in the immediate address field
            //

            CopyMemory(&pXecb->Ecb->ImmediateAddress,
                       &remoteAddress.sa_nodenum,
                       sizeof(pXecb->Ecb->ImmediateAddress)
                       );

            //
            // remove the XECB from AcceptQueue and complete the SPXListenForConnection ECB
            //

            DequeueEcb(pXecb, &pConnectionInfo->AcceptQueue);

            IPXDUMPECB((pXecb->Ecb,
                        HIWORD(pXecb->EcbAddress),
                        LOWORD(pXecb->EcbAddress),
                        ECB_TYPE_SPX,
                        FALSE,
                        FALSE,
                        IS_PROT_MODE(pXecb)
                        ));

            CompleteOrQueueEcb(pXecb, ECB_CC_SUCCESS);
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "CompleteAccept: setsockopt(IPX_RECVHDR) returns %d\n",
                        WSAGetLastError()
                        ));

            closesocket(conn);
            DequeueEcb(pXecb, &pConnectionInfo->AcceptQueue);
            DequeueConnection(pSocketInfo, pConnectionInfo);
            DeallocateConnection(pConnectionInfo);
            CompleteOrQueueEcb(pXecb, ECB_CC_CONNECTION_ABORTED);
        }
    } else {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_ERROR,
                    "CompleteAccept: accept() returns %d\n",
                    WSAGetLastError()
                    ));

    }
}


PRIVATE
VOID
CompleteReceive(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    )

/*++

Routine Description:

    Complete a SPXListenForSequencedPacket

Arguments:

    pSocketInfo     - pointer to SOCKET_INFO
    pConnectionInfo - pointer to CONNECTION_INFO

Return Value:

    None.

--*/

{
    LPXECB pXecb;
    int rc;
    BOOL conn_q;
    LPXECB_QUEUE pQueue;
    int len;
    BOOL completeRequest;
    BYTE status;

    //
    // receive packets while there are listen ECBs and data waiting
    //

    while (1) {
        if (pConnectionInfo->ListenQueue.Head) {
            pQueue = &pConnectionInfo->ListenQueue;
            pXecb = pConnectionInfo->ListenQueue.Head;
            conn_q = TRUE;

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_INFO,
                        "CompleteReceive: XECB %08x from CONNECTION_INFO %08x\n",
                        pXecb,
                        pConnectionInfo
                        ));


        } else if (pSocketInfo->ListenQueue.Head) {
            pQueue = &pSocketInfo->ListenQueue;
            pXecb = pSocketInfo->ListenQueue.Head;
            conn_q = FALSE;

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_INFO,
                        "CompleteReceive: XECB %08x from SOCKET_INFO %08x\n",
                        pXecb,
                        pSocketInfo
                        ));

        } else {
            break;
        }

        rc = recv(pConnectionInfo->Socket, pXecb->Data, pXecb->Length, 0);

        if (rc != SOCKET_ERROR) {
            len = rc;
            status = ECB_CC_SUCCESS;
            completeRequest = TRUE;
        } else {
            rc = WSAGetLastError();
            if (rc == WSAEMSGSIZE) {
                len = pXecb->Length;
                status = ECB_CC_PACKET_OVERFLOW;
                completeRequest = TRUE;
            } else {
                completeRequest = FALSE;

                //
                // if no data to receive, quit the loop (don't go down error path)
                //

                if (rc == WSAEWOULDBLOCK) {
                    break;
                }
            }

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "CompleteReceive: error %d on socket %08x (CID %04x)\n",
                        rc,
                        pConnectionInfo->Socket,
                        pConnectionInfo->ConnectionId
                        ));

            DUMPXECB(pXecb);

        }
        if( rc == WSAEDISCON ) {

            //
            // handle the disconnect case - we still need to complete the
            // ECB.
            //

            LPSPX_PACKET pPacket = (LPSPX_PACKET)pXecb->Buffer;

            status = ECB_CC_SUCCESS;


            pPacket->DestinationConnectId = pConnectionInfo->ConnectionId;
            pPacket->SourceConnectId = pConnectionInfo->RemoteConnectionId;
            pPacket->DataStreamType = SPX_DS_TERMINATE ;
            pPacket->Checksum = 0xffff;
            pPacket->Length = L2BW(SPX_HEADER_LENGTH);
            pPacket->TransportControl = 0;
            pPacket->PacketType = 5;

            pXecb->Length = SPX_HEADER_LENGTH ;
            ScatterData(pXecb);

            DequeueEcb(pXecb, pQueue);

            //
            // Put the remote node address in the ECB's immediate address
            // field
            //

            CopyMemory(pXecb->Ecb->ImmediateAddress,
                       pConnectionInfo->RemoteNode,
                       sizeof(pXecb->Ecb->ImmediateAddress)
                       );

            CompleteOrQueueIo(pXecb, status);

            DequeueConnection(pConnectionInfo->OwningSocket, pConnectionInfo);
            AbortOrTerminateConnection(pConnectionInfo, ECB_CC_CONNECTION_ABORTED);
            break ;

        }
        else if (completeRequest) {

#if SPX_HACK
            if (pConnectionInfo->Flags & CF_1ST_RECEIVE) {
                pConnectionInfo->Flags &= ~CF_1ST_RECEIVE;
                ModifyFirstReceive(pXecb->Data, &len, pSocketInfo->SocketNumber, pConnectionInfo->Socket);
            }
#endif

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_INFO,
                        "CompleteReceive: recv() on socket %#x returns %d bytes (Addr=%08x)\n",
                        pConnectionInfo->Socket,
                        len,
                        pXecb->Data
                        ));

            IPXDUMPDATA((pXecb->Data, 0, 0, FALSE, (WORD)len));

            pXecb->Length -= (USHORT) len;
            pXecb->ActualLength += (USHORT)len;
            pXecb->Data += len;
            if (pXecb->ActualLength >= SPX_HEADER_LENGTH) {
                if (pXecb->Flags & XECB_FLAG_FIRST_RECEIVE) {

                    LPSPX_PACKET pPacket = (LPSPX_PACKET)pXecb->Buffer;

                    //
                    // record in the SPX header the local connection id we invented
                    //

                    pPacket->DestinationConnectId = pConnectionInfo->ConnectionId;

                    //
                    // record the actual frame length from the header
                    //

                    pXecb->FrameLength = B2LW(((LPSPX_PACKET)pXecb->Buffer)->Length);
                    pXecb->Flags &=  ~XECB_FLAG_FIRST_RECEIVE;

                    IPXDBGPRINT((__FILE__, __LINE__,
                                FUNCTION_ANY,
                                IPXDBG_LEVEL_INFO,
                                "CompleteReceive: FrameLength=%x (%d)\n",
                                pXecb->FrameLength,
                                pXecb->FrameLength
                                ));

                }

                //
                // if we received all the data in the packet (according to length
                // field in the SPX header) OR we ran out of buffer space, remove
                // the ECB from its queue and complete it
                //

                if (!pXecb->Length || (pXecb->ActualLength == pXecb->FrameLength)) {
                    if (pXecb->Flags & XECB_FLAG_BUFFER_ALLOCATED) {

                        //
                        // update the XECB.Length field to reflect the amount of
                        // data received and copy it to the fragmented buffers 
                        // in VDM. do not overflow buffer if FrameLength turns
                        // out to be larger than we expect.
                        //

                        pXecb->Length = min(pXecb->FrameLength,
                                            pXecb->ActualLength);
                        ScatterData(pXecb);
                    }
                    DequeueEcb(pXecb, pQueue);

                    // DUMPXECB(pXecb);


                    IPXDUMPECB((pXecb->Ecb,
                                HIWORD(pXecb->EcbAddress),
                                LOWORD(pXecb->EcbAddress),
                                ECB_TYPE_SPX,
                                TRUE,
                                TRUE,
                                IS_PROT_MODE(pXecb)
                                ));

                    //
                    // Put the remote node address in the ECB's immediate address
                    // field
                    //

                    CopyMemory(pXecb->Ecb->ImmediateAddress,
                               pConnectionInfo->RemoteNode,
                               sizeof(pXecb->Ecb->ImmediateAddress)
                               );
                    CompleteOrQueueIo(pXecb, status);
                } else {

                    //
                    // partial receive. If the listen ECB came off the socket
                    // queue then put it on the connection queue: this is the
                    // ECB that will be used for this connection until all data
                    // received or we get an error
                    //

                    if (!conn_q) {
                        DequeueEcb(pXecb, &pSocketInfo->ListenQueue);
                        QueueEcb(pXecb,
                                 &pConnectionInfo->ListenQueue,
                                 CONNECTION_LISTEN_QUEUE
                                 );
                    }

                    //
                    // not enough data to satisfy read: don't continue yet
                    //

                    break;
                }
            }
        } else {

            //
            // error occurred - abort the connection
            //

            if (!conn_q) {
                DequeueEcb(pXecb, &pSocketInfo->ListenQueue);
                QueueEcb(pXecb,
                         &pConnectionInfo->ListenQueue,
                         CONNECTION_LISTEN_QUEUE
                         );
            }
            DequeueConnection(pConnectionInfo->OwningSocket, pConnectionInfo);
            AbortOrTerminateConnection(pConnectionInfo, ECB_CC_CONNECTION_ABORTED);

            //
            // don't continue in this case
            //

            break;
        }
    }
}


PRIVATE
VOID
CompleteConnect(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    )

/*++

Routine Description:

    Complete a SPXEstablishConnection

Arguments:

    pSocketInfo     - pointer to SOCKET_INFO
    pConnectionInfo - pointer to CONNECTION_INFO

Return Value:

    None.

--*/

{
    LPXECB pXecb = pConnectionInfo->ConnectQueue.Head;
/*
    LPSPX_PACKET pPacket;

    //
    // the connection ID also appears in the first segment of the establish
    // ECB
    //

    pPacket = (LPSPX_PACKET)GET_FAR_POINTER(&ECB_FRAGMENT(pXecb->Ecb, 0)->Address,
                                                          IS_PROT_MODE(pXecb)
                                                          );
    pPacket->Checksum = 0xffff;
    pPacket->Length = L2BW(SPX_HEADER_LENGTH);
    pPacket->TransportControl = 0;
    pPacket->PacketType = 5;
    pPacket->Source.Socket = pSocketInfo->SocketNumber;
    pPacket->ConnectionControl = 0xc0;
    pPacket->DataStreamType = 0;
    pPacket->SourceConnectId = pConnectionInfo->ConnectionId;
    pPacket->DestinationConnectId = 0xffff;
    pPacket->SequenceNumber = 0;
    pPacket->AckNumber = 0;
    pPacket->AllocationNumber = 0;
*/

    pConnectionInfo->State = CI_ESTABLISHED;

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "CompleteConnect: connection %04x (%08x) completed\n",
                pConnectionInfo->ConnectionId,
                pConnectionInfo
                ));

    DUMPCONN(pConnectionInfo);

    DequeueEcb(pXecb, &pConnectionInfo->ConnectQueue);

    IPXDUMPECB((pXecb->Ecb,
                HIWORD(pXecb->EcbAddress),
                LOWORD(pXecb->EcbAddress),
                ECB_TYPE_SPX,
                TRUE,
                TRUE,
                IS_PROT_MODE(pXecb)
                ));

    CompleteOrQueueEcb(pXecb, ECB_CC_SUCCESS);
}


PRIVATE
VOID
CompleteSend(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    )

/*++

Routine Description:

    Complete a SPXSendSequencedPacket

Arguments:

    pSocketInfo     - pointer to SOCKET_INFO
    pConnectionInfo - pointer to CONNECTION_INFO

Return Value:

    None.

--*/

{
    LPXECB pXecb = pConnectionInfo->SendQueue.Head;
    int rc;
    BYTE status;

    LPSPX_PACKET pPacket;  //Multi-User addition
    int flags = 0;             //Multi-User addition

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "CompleteSend: sending %d (0x%x) bytes from %08x\n",
                pXecb->Length,
                pXecb->Length,
                pXecb->Data
                ));

    IPXDUMPECB((pXecb->Ecb,
                HIWORD(pXecb->EcbAddress),
                LOWORD(pXecb->EcbAddress),
                ECB_TYPE_SPX,
                TRUE,
                TRUE,
                IS_PROT_MODE(pXecb)
                ));

    //======Multi-User code merge ==============================
    // 2/18/97 cjc Code copied from _VwSPXSendSequencedPacket (vwspx.c) to fix
    //             problem where EndOfMessage bit was being set prematurely and
    //             caused BSPXCOM8 error messages with Btrieve.

    //
    // if the app set the END_OF_MESSAGE bit in the ConnectionControl
    // field then set the flags to 0: NWLink will automatically set the
    // end-of-message bit in the packet; otherwise set flags to MSG_PARTIAL
    // to indicate to NWLink that it *shouldn't* set the bit in the packet
    //
    pPacket = (LPSPX_PACKET)GET_FAR_POINTER(
                                    &(ECB_FRAGMENT(pXecb->Ecb, 0)->Address),
                                    IS_PROT_MODE(pXecb)
                                    );
    if (pPacket) {
        flags = (pPacket->ConnectionControl & SPX_END_OF_MESSAGE)
              ? 0
              : MSG_PARTIAL
              ;
    }

    rc = send(pConnectionInfo->Socket, pXecb->Data, pXecb->Length, flags);

    //rc = send(pConnectionInfo->Socket, pXecb->Data, pXecb->Length, 0); //Original
    //======Multi-User code merge End ==============================
    if (rc == pXecb->Length) {

        //
        // all data sent
        //

        status = ECB_CC_SUCCESS;
    } else if (rc == SOCKET_ERROR) {
        rc = WSAGetLastError();
        if (rc == WSAEWOULDBLOCK) {

            //
            // huh???
            //

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "CompleteSend: send() returns WSAEWOODBLOCK??\n"
                        ));

            //
            // leave ECB on queue
            //

            return;
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "CompleteSend: send() returns %d\n",
                        rc
                        ));

            status = ECB_CC_CONNECTION_ABORTED;
        }
    } else {

        //
        // partial data sent. Update the buffer pointer and length fields
        // and leave this ECB at the head of the send queue
        //

        pXecb->Data += rc;
        pXecb->Length -= (WORD)rc;
        return;
    }
    DequeueEcb(pXecb, &pConnectionInfo->SendQueue);
    CompleteOrQueueIo(pXecb, status);
}

#if SPX_HACK

PRIVATE
VOID
ModifyFirstReceive(
    LPBYTE Buffer,
    LPDWORD pLength,
    WORD SocketNumber,
    SOCKET Socket
    )
{
    WORD len = *(LPWORD)pLength;

    if ((*(ULPWORD)Buffer != 0xffff) && (*(ULPWORD)(Buffer+2) != L2BW(len))) {

        LPSPX_PACKET packet;
        SOCKADDR_IPX remote;
        int rc;
        int remlen;

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "ModifyFirstReceive: Modifying: Buffer=%08x Length=%04x SocketNumber=%04x Socket=%08x\n",
                    Buffer,
                    len,
                    B2LW(SocketNumber),
                    Socket
                    ));

        MoveMemory(Buffer+42, Buffer, len);
        packet = (LPSPX_PACKET)Buffer;
        packet->Checksum = 0xffff;
        packet->Length = L2BW(42+len);
        packet->TransportControl = 0;
        packet->PacketType = 5;
        CopyMemory((LPVOID)&packet->Destination,
                   (LPVOID)&MyInternetAddress.sa_netnum,
                   sizeof(INTERNET_ADDRESS)
                   );
        packet->Destination.Socket = SocketNumber;
        rc = getpeername(Socket, (LPSOCKADDR)&remote, &remlen);
        if (rc != SOCKET_ERROR) {
            CopyMemory((LPVOID)&packet->Source,
                       (LPVOID)&remote.sa_netnum,
                       sizeof(NETWARE_ADDRESS)
                       );
        } else {
            ZeroMemory((LPVOID)&packet->Source, sizeof(NETWARE_ADDRESS));
        }
        packet->ConnectionControl = 0x40;
        packet->DataStreamType = 0;
        packet->SourceConnectId = 0;
        packet->DestinationConnectId = 0;
        packet->SequenceNumber = 0;
        packet->AckNumber = 0;
        packet->AllocationNumber = 0;
        *pLength += 42;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\server\queue.h ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    queue.h

Abstract:

    Header file included by the print provider

Author:

    Yi-Hsin Sung (yihsins)   15-May-1993

Environment:

    User Mode -Win32

Revision History:

--*/

#ifndef _NW_QUEUE_INCLUDED_
#define _NW_QUEUE_INCLUDED_


//
// Functions from queue.c
//

typedef BYTE JOBTIME[6];

DWORD
NwGetQueueId(
    IN  HANDLE  handleServer,
    IN  LPWSTR  QueueName,
    OUT LPDWORD QueueId
    );

DWORD
NwCreateQueueJobAndFile(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  LPWSTR  DocumentName,
    IN  LPWSTR  UserName,
    IN  DWORD   fGateway,
    IN  DWORD   PrintOption,                //Multi-User addition
    IN  LPWSTR  QueueName,
    OUT LPWORD  JobId
    );

DWORD
NwCloseFileAndStartQueueJob(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId
    );

DWORD
NwRemoveJobFromQueue(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId
    );

DWORD
NwRemoveAllJobsFromQueue(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId
    );

DWORD
NwReadQueueCurrentStatus(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    OUT LPBYTE  QueueStatus,
    OUT LPBYTE  NumberOfJobs
    );

DWORD
NwSetQueueCurrentStatus(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  BYTE    QueueStatus
    );

DWORD
NwGetQueueJobList(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    OUT LPWORD  NumberOfJobs,
    OUT LPWORD  JobIdList
    );

DWORD
NwReadQueueJobEntry(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId,
    OUT JOBTIME TargetExecutionTime,
    OUT JOBTIME JobEntryTime,
    OUT LPBYTE  JobPosition,
    OUT LPBYTE  JobControlFlags,
    OUT LPSTR   TextJobDescription,
    OUT LPSTR   UserName
    );

DWORD
NwGetQueueJobsFileSize(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId,
    OUT LPDWORD FileSize
    );

DWORD
NwChangeQueueJobPosition(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId,
    IN  BYTE    NewPosition
    );

DWORD
NwChangeQueueJobEntry(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId,
    IN  DWORD   dwCommand,
    IN  PNW_JOB_INFO  pNwJobInfo 
    );

DWORD
NwGetQueueJobs(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  LPWSTR  PrinterName,
    IN  DWORD   FirstJobRequested,
    IN  DWORD   EntriesRequested,
    IN  DWORD   Level,
    OUT LPBYTE  Buffer,
    IN  DWORD   cbBuf,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD Entries
    );

DWORD
NwGetQueueJobInfo(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId,
    IN  LPWSTR  PrinterName,
    IN  DWORD   Level,
    IN OUT LPBYTE  *FixedPortion,
    IN OUT LPWSTR  *EndOfVariableData,
    OUT LPDWORD EntrySize
    );

#ifndef NOT_USED
 
DWORD 
NwDestroyQueue (
    IN  HANDLE hServer,
    IN  DWORD dwQueueId
);  

DWORD 
NwAssocPServers ( 
                  IN HANDLE hServer,
                  IN LPWSTR pswQueue,
                  IN LPWSTR pszPServer
                );


DWORD
NwCreateQueue ( 
                 IN HANDLE hServer, 
                 IN LPWSTR pszQueue,
                 OUT  LPDWORD  pQueueId 
               );

#endif // #ifndef NOT_USED

#endif // _NW_QUEUE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\socket.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    socket.h

Abstract:

    Contains macros, prototypes and structures for socket.c

Author:

    Richard L Firth (rfirth) 25-Oct-1993

Revision History:

    25-Oct-1993 rfirth
        Created

--*/

#define ARBITRARY_CONNECTION_NUMBER 0x6c8e

//
// forward declarations
//

typedef struct _FIFO *LPFIFO;
typedef struct _XECB *LPXECB;
typedef struct _XECB_QUEUE *LPXECB_QUEUE;
typedef struct _SOCKET_INFO* LPSOCKET_INFO;
typedef struct _CONNECTION_INFO *LPCONNECTION_INFO;

//
// FIFO - standard single-linked FIFO queue structure
//

typedef struct _FIFO {
    LPVOID Head;
    LPVOID Tail;
} FIFO;

//
// function type for cancelling XECB/ECB
//

typedef BYTE (*ECB_CANCEL_ROUTINE)(LPXECB);

//
// QUEUE_ID - indicator of which queue an ECB is on
//

typedef enum {
    NO_QUEUE = 0x10cadd1e,
    ASYNC_COMPLETION_QUEUE = 0xCC5055C0,    // arbitrary numbers make life interesting
    TIMER_QUEUE,
    SOCKET_LISTEN_QUEUE,
    SOCKET_SEND_QUEUE,
    SOCKET_HEADER_QUEUE,  // special queue for small ECBs that cannot hold data
    CONNECTION_CONNECT_QUEUE,
    CONNECTION_ACCEPT_QUEUE,
    CONNECTION_SEND_QUEUE,
    CONNECTION_LISTEN_QUEUE
} QUEUE_ID;

//
// XECB - our copy of the ECB (IPX or AES)
//

typedef struct _XECB {
    LPXECB Next;
    LPECB Ecb;                          // points to ECB in DOS memory
    ECB_ADDRESS EcbAddress;             // segmented address of ECB in DOS memory
    ESR_ADDRESS EsrAddress;             // Event Service Routine in DOS memory
    LPBYTE Buffer;                      // address of 32-bit buffer
    LPBYTE Data;                        // moveable data pointer
    WORD FrameLength;                   // actual size of frame (from IPX/SPX header)
    WORD ActualLength;                  // same as FrameLength. Not decremented
    WORD Length;                        // length of 32-bit buffer
    WORD Ticks;                         // for AES
    WORD SocketNumber;                  // number of owning socket
    WORD Owner;                         // owning DOS Task ID
    DWORD TaskId;                       // owning Windows Task ID
    DWORD Flags;                        // see below
    QUEUE_ID QueueId;                   // identifies the queue for quick location
    LPVOID OwningObject;                // which SOCKET_INFO or CONNECTION_INFO the queue is on
    DWORD RefCount;                     // the dreaded reference count
} XECB;

//
// XECB flags
//

#define XECB_FLAG_AES               0x00000000
#define XECB_FLAG_IPX               0x00000001
#define XECB_FLAG_TEMPORARY_SOCKET  0x00000002
#define XECB_FLAG_BUFFER_ALLOCATED  0x00000004
#define XECB_FLAG_LISTEN            0x00000008
#define XECB_FLAG_SEND              0x00000010
#define XECB_FLAG_TIMER             0x00000020
#define XECB_FLAG_ASYNC             0x00000040
#define XECB_FLAG_FIRST_RECEIVE     0x00000080
#define XECB_FLAG_SPX               0x00000100
#define XECB_FLAG_PROTMODE          0x00000200

#define IS_PROT_MODE(p) (((p)->Flags & XECB_FLAG_PROTMODE) ? TRUE : FALSE)

//
// XECB_QUEUE - queue of XECBs
//

typedef struct _XECB_QUEUE {
    LPXECB Head;
    LPXECB Tail;
} XECB_QUEUE;

//
// SOCKET_INFO - maintains info about IPX sockets
//

typedef struct _SOCKET_INFO {
    LPSOCKET_INFO Next;
    WORD SocketNumber;                  // big-endian socket (bound port)
    WORD Owner;                         // DOS PDB
    DWORD TaskId;                       // Windows owner
    SOCKET Socket;                      // the WinSock socket handle
    DWORD Flags;

    BOOL LongLived;                     // TRUE if keep-alive when app dies
    BOOL SpxSocket;                     // TRUE if socket opened for SPX

    DWORD PendingSends;                 // used by cancel
    DWORD PendingListens;               // used by cancel

    //
    // ListenQueue is used for IPXListenForPacket and SPXListenForSequencedPacket
    //

    XECB_QUEUE ListenQueue;             // pool of listening ECBs against this socket

    //
    // SendQueue is used by IPX for IPXSendPacket
    //

    XECB_QUEUE SendQueue;               // queue of pending send ECBs against this socket

    //
    // HeaderQueue is used to hold small ECBs that can only take header info.
    // We have this separate queue to make sure that we do not put ECBs that
    // really cant accept any data into the Listen Queue.
    //

    XECB_QUEUE HeaderQueue;             // pool of header ECBs against this socket

    LPCONNECTION_INFO Connections;
} SOCKET_INFO;

#define SOCKET_FLAG_LISTENING       0x00000001
#define SOCKET_FLAG_SENDING         0x00000002
#define SOCKET_FLAG_TEMPORARY       0x80000000

//
// CONNECTION_INFO - maintains info about SPX sockets
//

typedef struct _CONNECTION_INFO {
    LPCONNECTION_INFO Next;             // next CONNECTION_INFO by OwningSocket
    LPCONNECTION_INFO List;             // all CONNECTION_INFO are linked together
    LPSOCKET_INFO OwningSocket;         // back-pointer to SOCKET_INFO
    SOCKET Socket;                      // handle to socket
    DWORD TaskId;                       // identifies windows task/owner
    WORD ConnectionId;                  // analogous to SocketNumber
    BYTE Flags;
    BYTE State;
    XECB_QUEUE ConnectQueue;            // outgoing connections being made
    XECB_QUEUE AcceptQueue;             // waiting for incoming connections
    XECB_QUEUE SendQueue;               // packet sends on this connection
    XECB_QUEUE ListenQueue;             // partially complete receive
    BYTE RemoteNode[6];
    WORD RemoteConnectionId;
} CONNECTION_INFO;

//
// CONNECTION_INFO Flag field values
//

#define CF_1ST_RECEIVE  0x80            // hack-o-rama till NWLink timing problem fixed

//
// CONNECTION_INFO State field values
//

#define CI_WAITING      0x01
#define CI_STARTING     0x02
#define CI_ESTABLISHED  0x03
#define CI_TERMINATING  0x04

//
// one-line function macros
//

#define AllocateSocket()    (LPSOCKET_INFO)LocalAlloc(LPTR, sizeof(SOCKET_INFO))
#define DeallocateSocket(p) FREE_OBJECT(p)

//
// SocketType parameter for CreateSocket
//

typedef enum {
    SOCKET_TYPE_IPX,
    SOCKET_TYPE_SPX
} SOCKET_TYPE;

//
// function prototypes
//

int
CreateSocket(
    IN SOCKET_TYPE SocketType,
    IN OUT ULPWORD pSocketNumber,
    OUT SOCKET* pSocket
    );

LPSOCKET_INFO
AllocateTemporarySocket(
    VOID
    );

VOID
QueueSocket(
    IN LPSOCKET_INFO pSocketInfo
    );

LPSOCKET_INFO
DequeueSocket(
    IN LPSOCKET_INFO pSocketInfo
    );

LPSOCKET_INFO
FindSocket(
    IN WORD SocketNumber
    );

LPSOCKET_INFO
FindActiveSocket(
    IN LPSOCKET_INFO pSocketInfo
    );

int
ReopenSocket(
    LPSOCKET_INFO pSocketInfo
    );

VOID
KillSocket(
    IN LPSOCKET_INFO pSocketInfo
    );

VOID
KillShortLivedSockets(
    IN WORD Owner
    );

LPCONNECTION_INFO
AllocateConnection(
    LPSOCKET_INFO pSocketInfo
    );

VOID
DeallocateConnection(
    IN LPCONNECTION_INFO pConnectionInfo
    );

LPCONNECTION_INFO
FindConnection(
    IN WORD ConnectionId
    );

VOID
QueueConnection(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    );

LPCONNECTION_INFO
DequeueConnection(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    );

VOID
KillConnection(
    IN LPCONNECTION_INFO pConnectionInfo
    );

VOID
AbortOrTerminateConnection(
    IN LPCONNECTION_INFO pConnectionInfo,
    IN BYTE CompletionCode
    );

VOID
CheckPendingSpxRequests(
    BOOL *pfOperationPerformed
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\server\queue.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    queue.c

Abstract:

    This module contains the support routines for the queue APIs that call
    into the NetWare redirector

Author:

    Yi-Hsin Sung    (yihsins)   24-Apr-1993

Revision History:

--*/

#include <nw.h>
#include <nwxchg.h>
#include <nwapi.h>
#include <nwreg.h>
#include <queue.h>
#include <splutil.h>
//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

DWORD
NwWriteJobInfoEntry(
    IN OUT LPBYTE *FixedPortion,
    IN OUT LPWSTR *EndOfVariableData,
    IN DWORD   Level,
    IN WORD    JobId,
    IN LPWSTR  PrinterName,
    IN LPWSTR  JobDescription,
    IN LPWSTR  UserName,
    IN BYTE    JobControlFlags,
    IN BYTE    JobPosition,
    IN LPBYTE  JobEntryTime,
    IN JOBTIME TargetExecutionTime,
    IN DWORD   FileSize
    );

DWORD 
ConvertToSystemTime( 
    IN  JOBTIME      JobTime, 
    OUT LPSYSTEMTIME pSystemTime
    );

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

#define NW_RDR_SERVER_PREFIX L"\\Device\\Nwrdr\\"

#define QF_USER_HOLD      0x40
#define QF_OPERATOR_HOLD  0x80

//
// Stores the current user's print control options
//
//DWORD NwPrintOption = NW_PRINT_OPTION_DEFAULT;  - Commented out for multi-user code merge. We don't use global flag anymore
//                                                  The print option is passed from the client for each user
                               // Default Print Control Flags: Suppress form 
                               // feed, banner on, notify on
DWORD NwGatewayPrintOption = NW_GATEWAY_PRINT_OPTION_DEFAULT; 
                               // Gateway default print control flags: 
                               // Suppress form feed, banner on, notify off



DWORD
NwAttachToNetwareServer(
    IN  LPWSTR  ServerName,
    OUT LPHANDLE phandleServer
    )
/*++

Routine Description:

    This routine opens a handle to the given server.

Arguments:

    ServerName    - The server name to attach to.
    phandleServer - Receives an opened handle to the preferred or
                    nearest server.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    NTSTATUS            ntstatus;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;

    LPWSTR FullName;
    UNICODE_STRING UServerName;

    FullName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                                    (UINT) ( wcslen( NW_RDR_SERVER_PREFIX) +
                                             wcslen( ServerName ) - 1) *
                                             sizeof(WCHAR)
                                  );

    if ( FullName == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy( FullName, NW_RDR_SERVER_PREFIX );
    wcscat( FullName, ServerName + 2 );    // Skip past the prefix "\\"

    RtlInitUnicodeString( &UServerName, FullName );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UServerName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open a handle to the preferred server.
    //
    ntstatus = NtOpenFile(
                   phandleServer,
                   SYNCHRONIZE | GENERIC_WRITE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if ( NT_SUCCESS(ntstatus)) {
        ntstatus = IoStatusBlock.Status;
    }

    if (! NT_SUCCESS(ntstatus)) {
        *phandleServer = NULL;
    }

    LocalFree( FullName );
    return RtlNtStatusToDosError(ntstatus);
}



DWORD
NwGetNextQueueEntry(
    IN HANDLE PreferredServer,
    IN OUT LPDWORD LastObjectId,
    OUT LPSTR QueueName
    )
/*++

Routine Description:

    This function uses an opened handle to the preferred server to
    scan it bindery for all print queue objects.

Arguments:

    PreferredServer - Supplies the handle to the preferred server on
        which to scan the bindery.

    LastObjectId - On input, supplies the object ID to the last print
        queue object returned, which is the resume handle to get the
        next print queue object.  On output, receives the object ID
        of the print queue object returned.

    QueueName - Receives the name of the returned print queue object.

Return Value:

    NO_ERROR - Successfully gotten a print name.

    WN_NO_MORE_ENTRIES - No other print queue object past the one
        specified by LastObjectId.

--*/
{
    NTSTATUS ntstatus;
    WORD ObjectType;

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("NWWORKSTATION: NwGetNextQueueEntry LastObjectId %lu\n",
                 *LastObjectId));
    }
#endif

    ntstatus = NwlibMakeNcp(
                   PreferredServer,
                   FSCTL_NWR_NCP_E3H,    // Bindery function
                   58,                   // Max request packet size
                   59,                   // Max response packet size
                   "bdwp|dwc",           // Format string
                   0x37,                 // Scan bindery object
                   *LastObjectId,        // Previous ID
                   0x3,                  // Print Queue object
                   "*",                  // Wildcard to match all
                   LastObjectId,         // Current ID
                   &ObjectType,          // Ignore
                   QueueName             // Currently returned print queue
                   );

    //
    // Unmap Japanese special chars
    //
    UnmapSpecialJapaneseChars(QueueName,(WORD)lstrlenA(QueueName));

#if DBG
    if ( NT_SUCCESS(ntstatus)) {
        IF_DEBUG(ENUM) {
            KdPrint(("NWWORKSTATION: NwGetNextQueueEntry NewObjectId %08lx, QueueName %s\n", *LastObjectId, QueueName));
        }
    }
#endif

    return NwMapBinderyCompletionCode(ntstatus);
}



DWORD
NwGetQueueId(
    IN  HANDLE  handleServer,
    IN  LPWSTR  QueueName,
    OUT LPDWORD QueueId
    )
/*++

Routine Description:

    This function opens a handle to the server and  scan its bindery
    for the given queue object id.

Arguments:
    handleServer - Supplies the handle of the server on which to
                   scan the bindery.

    QueueName - Supplies the name of the print queue.

    QueueId - On output, supplies the object ID of the given queue.


Return Value:

    NO_ERROR - Successfully gotten a file server name.

--*/
{

    NTSTATUS ntstatus;

    UNICODE_STRING UQueueName;
    OEM_STRING     OemQueueName;

#if DBG
    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwGetQueueId %ws\n",
                 QueueName ));
    }
#endif

    RtlInitUnicodeString( &UQueueName, QueueName);
    ntstatus = RtlUnicodeStringToOemString( &OemQueueName, &UQueueName, TRUE);

    //
    // Map Japanese special characters
    //
    MapSpecialJapaneseChars(OemQueueName.Buffer,OemQueueName.Length);

    if ( NT_SUCCESS(ntstatus))
    {
        ntstatus = NwlibMakeNcp(
                       handleServer,
                       FSCTL_NWR_NCP_E3H,    // Bindery function
                       58,                   // Max request packet size
                       59,                   // Max response packet size
                       "bdwp|d",             // Format string
                       0x37,                 // Scan bindery object
                       0xFFFFFFFF,           // Previous ID
                       0x3,                  // Print Queue object
                       OemQueueName.Buffer,  // Queue Name
                       QueueId               // Queue ID
                       );
    }

#if DBG
    if ( NT_SUCCESS(ntstatus)) {
        IF_DEBUG(QUEUE) {
            KdPrint(("NWWORKSTATION: NwGetQueueId QueueId %08lx\n",
                     *QueueId ));
        }
   }
#endif

    RtlFreeOemString( &OemQueueName );
    return NwMapBinderyCompletionCode(ntstatus);

}



DWORD
NwCreateQueueJobAndFile(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  LPWSTR  DocumentName,
    IN  LPWSTR  UserName,
    IN  DWORD   fGateway,
    IN  DWORD   PrintOption,               //Multi-user change
    IN  LPWSTR  QueueName,
    OUT LPWORD  JobId
    )
/*++

Routine Description:

    This function uses an opened handle to a server to
    enter a new job into the queue with the given QueueId.

Arguments:

    handleServer - Supplies the handle to the server on
                which add the job.

    QueueId   - Supplies the id of the queue in which to add the job.
    DocumentName  - Supplies the name of the document to be printed
    UserName   - Supplies the banner name to be printed
    fGateway   - TRUE if gateway printing, FALSE otherwise
    QueueName  - Supplies the header name to be printed
    JobId  - Receives the job id of the newly added job.

Return Value:

    NO_ERROR - Successfully added the job to the queue.

--*/
{
    NTSTATUS ntstatus = STATUS_SUCCESS;

    UNICODE_STRING UDocumentName;
    OEM_STRING     OemDocumentName;
    UNICODE_STRING UUserName;
    OEM_STRING     OemUserName;
    UNICODE_STRING UQueueName;
    OEM_STRING     OemQueueName;

#if DBG
    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwCreateQueueJobAndFile QueueId %08lx\n",
                 QueueId ));
    }
#endif

    if ( UserName )
    {
        RtlInitUnicodeString( &UUserName, UserName);
        ntstatus = RtlUnicodeStringToOemString( &OemUserName,
                                                &UUserName,
                                                TRUE );
    }

    if ( NT_SUCCESS(ntstatus) && DocumentName )
    {
        RtlInitUnicodeString( &UDocumentName, DocumentName);
        ntstatus = RtlUnicodeStringToOemString( &OemDocumentName,
                                                &UDocumentName,
                                                TRUE );
    }

    if ( NT_SUCCESS(ntstatus) && QueueName )
    {
        RtlInitUnicodeString( &UQueueName, QueueName);
        ntstatus = RtlUnicodeStringToOemString( &OemQueueName,
                                                &UQueueName,
                                                TRUE );
    }

    if ( NT_SUCCESS( ntstatus)) {

        LPSTR pszDocument, pszUser, pszQueue;

        pszDocument = DocumentName? OemDocumentName.Buffer : "";
        pszUser = UserName? OemUserName.Buffer : "";
        pszQueue = QueueName? OemQueueName.Buffer : "";

        //Multi-user uses passed print flag
        //
        ntstatus = NwlibMakeNcp(
                               handleServer,
                               FSCTL_NWR_NCP_E3H,        // Bindery function
                               263,                      // Max request packet size
                               56,                       // Max response packet size
                               "bd_ddw_b_Cbbwwww_C-C-_|_w", // Format string
                               0x68,                     // Create Queue Job and File object
                               QueueId,                  // Queue ID
                               6,                        // Skip bytes
                               0xffffffff,               // Target Server ID number
                               0xffffffff, 0xffff,       // Target Execution time
                               11,                       // Skip bytes
                               0x00,                     // Job Control Flags
                               26,                       // Skip bytes
                               pszDocument,              // TextJobDescription
                               50,                       // Skip bytes
                               0,                         // Version number (clientarea)
                               8,                        // Tab Size
                               1,                        // Number of copies
                               PrintOption,              // Print Control Flags
                               0x3C,                     // Maximum lines
                               0x84,                     // Maximum characters
                               22,                       // Skip bytes
                               pszUser,                  // Banner Name
                               12,                       // Max Length of pszUser
                               pszQueue,                 // Header Name
                               12,                       // Max Length of pszQueue
                               14 + 80,                  // Skip remainder of client area
                               22,                       // Skip bytes
                               JobId                     // Job ID 
                               );


    }

#if DBG
    if ( NT_SUCCESS( ntstatus)) {
        IF_DEBUG(QUEUE) {
            KdPrint(("NWWORKSTATION: NwCreateQueueJobAndFile JobId %d\n", 
                    *JobId ));
        }
    }
#endif

    if ( DocumentName )
        RtlFreeOemString( &OemDocumentName );
    if ( UserName )
        RtlFreeOemString( &OemUserName );
    if ( QueueName )
        RtlFreeOemString( &OemQueueName );
    return NwMapStatus(ntstatus);
}



DWORD
NwCloseFileAndStartQueueJob(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId
    )
/*++

Routine Description:

    This function uses an opened handle to a server to
    close a job file and mark the job file ready for service.

Arguments:

    handleServer - Supplies the handle to the server on
                which add the job.

    QueueId   - Supplies the id of the queue in which to add the job.
    JobId     - Supplies the job id.

Return Value:

    NO_ERROR - Successfully added the job to the queue.

--*/
{
    NTSTATUS ntstatus;

#if DBG
    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwCloseFileAndStartQueueJob QueueId %08lx JobId %d\n", QueueId, JobId ));
    }
#endif

    // Two versions of CloseFileAndStartQueueJobNCP

    ntstatus = NwlibMakeNcp(
                   handleServer,
                   FSCTL_NWR_NCP_E3H,        // Bindery function
                   9,                        // Max request packet size
                   2,                        // Max response packet size
                   "bdw|",                   // Format string
                   0x69,                     // Close File And Start Queue Job
                   QueueId,                  // Queue ID
                   JobId );                  // Job ID 

    return NwMapStatus(ntstatus);
}



DWORD
NwRemoveJobFromQueue(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId
    )
/*++

Routine Description:

    This function removes a job from a queue and closes the associate file.

Arguments:

    handleServer - Supplies the handle to the server on
                   which to remove the job.

    QueueId - Supplies the id of the queue in which to remove the job.
    JobId   - Supplies the job id to be removed.

Return Value:

    NO_ERROR - Successfully removed the job from the queue.

--*/
{
    NTSTATUS ntstatus;

#if DBG
    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwRemoveJobFromQueue QueueId %08lx JobId %d\n",
                  QueueId, JobId ));
    }
#endif

    ntstatus = NwlibMakeNcp(
                   handleServer,
                   FSCTL_NWR_NCP_E3H,        // Bindery function
                   9,                        // Max request packet size
                   2,                        // Max response packet size
                   "bdw|",                   // Format string
                   0x6A,                     // Remove Job From Queue
                   QueueId,                  // Queue ID
                   JobId );                  // Job ID 

    return NwMapStatus(ntstatus);
}


DWORD
NwRemoveAllJobsFromQueue(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId
    )
/*++

Routine Description:

    This function removes all jobs from a queue.

Arguments:

    handleServer - Supplies the handle to the server on
                   which to remove all jobs.

    QueueId - Supplies the id of the queue in which to remove all jobs.

Return Value:

    NO_ERROR - Successfully removed all jobs from the queue.

--*/
{
    DWORD err;
    WORD  JobCount = 0;
    WORD  pwJobList[250];
    WORD  i;

#if DBG
    IF_DEBUG(QUEUE) 
    {
        KdPrint(("NWWORKSTATION: NwRemoveAllJobsFromQueue QueueId %08lx\n", 
                QueueId ));
    }
#endif

    pwJobList[0] = 0;
    err = NwGetQueueJobList( handleServer,
                             QueueId,
                             &JobCount,
                             pwJobList );

    for ( i = 0; !err && i < JobCount; i++ )
    {
        err = NwRemoveJobFromQueue( handleServer,
                                    QueueId,
                                    pwJobList[i] );

    }

    return err;
}


DWORD
NwReadQueueCurrentStatus(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    OUT LPBYTE  QueueStatus,
    OUT LPBYTE  NumberOfJobs
    )
/*++

Routine Description:

    This function uses an opened handle to a server to
    query the status of the queue with the given QueueId.

Arguments:

    handleServer - Supplies the handle to the server on
                   which add the job.
    QueueId      - Supplies the id of the queue
    QueueStatus  - Receives the status of the queue
    NumberOfJobs - Receives the number of jobs in the queue.

Return Value:

    NO_ERROR - Successfully retrieved the status of the queue.

--*/
{
    NTSTATUS ntstatus;

#if DBG
    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwReadQueueCurrentStatus QueueId %08lx\n",
                 QueueId ));
    }
#endif

    ntstatus = NwlibMakeNcp(
                   handleServer,
                   FSCTL_NWR_NCP_E3H,        // Bindery function
                   7,                        // Max request packet size
                   135,                      // Max response packet size
                   "bd|==bb",                // Format string
                   0x66,                     // ReadQueueCurrentStatus
                   QueueId,                  // Queue ID
                   QueueStatus,              // Queue status
                   NumberOfJobs              // Number of jobs in the queue
                   );

#if DBG
    if ( NT_SUCCESS( ntstatus)) {
        IF_DEBUG(QUEUE) {
            KdPrint(("NWWORKSTATION: NwReadQueueCurrentStatus QueueStatus %d Number of Jobs %d\n", *QueueStatus, *NumberOfJobs ));
        }
    }
#endif

    return NwMapStatus(ntstatus);
}


DWORD
NwSetQueueCurrentStatus(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  BYTE    QueueStatus
    )
/*++

Routine Description:

    This function uses an opened handle to a server to
    set the status (pause/ready...) of the queue with the given QueueId.

Arguments:

    handleServer - Supplies the handle to the server on
                   which add the job.
    QueueId      - Supplies the id of the queue
    QueueStatus  - Supplies the status of the queue

Return Value:

    NO_ERROR - Successfully set the status of the queue.

--*/
{
    NTSTATUS ntstatus;

#if DBG
    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwSetQueueCurrentStatus QueueId %08lx\n",
                 QueueId ));
    }
#endif

    ntstatus = NwlibMakeNcp(
                   handleServer,
                   FSCTL_NWR_NCP_E3H,        // Bindery function
                   8,                        // Max request packet size
                   2,                        // Max response packet size
                   "bdb|",                   // Format string
                   0x67,                     // ReadQueueCurrentStatus
                   QueueId,                  // Queue ID
                   QueueStatus               // Queue status
                   );

    return NwMapStatus(ntstatus);
}


DWORD
NwGetQueueJobList(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    OUT LPWORD  NumberOfJobs,
    OUT LPWORD  JobIdList
    )
/*++

Routine Description:

    This function uses an opened handle to a server to
    get the job list of the queue with the given QueueId.

Arguments:

    handleServer - Supplies the handle to the server on
                   which add the job.
    QueueId      - Supplies the id of the queue
    NumberOfJobs - Receives the number of jobs in the queue.
    JobIdList    - Receives the array of job ids  in the queue

Return Value:

    NO_ERROR - Successfully added the job to the queue.

--*/
{
    NTSTATUS ntstatus;
#if DBG
    WORD i;

    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwGetQueueJobList QueueId %08lx\n",
                 QueueId ));
    }
#endif

    ntstatus = NwlibMakeNcp(
                   handleServer,
                   FSCTL_NWR_NCP_E3H,        // Bindery function
                   7,                        // Max request packet size
                   506,                      // Max response packet size
                   "bd|W",                   // Format string
                   0x6B,                     // Get Queue Job List
                   QueueId,                  // Queue ID
                   NumberOfJobs,             // Number of jobs in the queue
                   JobIdList                 // Array of job ids
                   );

#if DBG
    if ( NT_SUCCESS(ntstatus)) {
        IF_DEBUG(QUEUE) {
            KdPrint(("NWWORKSTATION: NwGetQueueJobList Number of Jobs %d\nJob List = ", *NumberOfJobs ));
            for ( i = 0; i < *NumberOfJobs; i++ )
                KdPrint(("%d ", JobIdList[i] ));
            KdPrint(("\n"));
        }
    }
#endif

    return NwMapStatus(ntstatus);
}



DWORD
NwReadQueueJobEntry(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId,
    OUT JOBTIME TargetExecutionTime,
    OUT JOBTIME JobEntryTime,
    OUT LPBYTE  JobPosition,
    OUT LPBYTE  JobControlFlags,
    OUT LPSTR   TextJobDescription,
    OUT LPSTR   UserName
    )
/*++

Routine Description:

    This function uses an opened handle to a server to
    get the information about the job with the given JobId
    in the given QueueId.

Arguments:

    handleServer - Supplies the handle to the server on
                   which add the job.
    QueueId      - Supplies the id of the queue
    JobId        - Supplies the job we are interested in

    TargetExecutionTime -
    JobEntryTime -
    JobPosition  -
    JobControlsFlags -
    TextJobDescription -

Return Value:

    NO_ERROR - Successfully added the job to the queue.

--*/
{
    NTSTATUS ntstatus;

#if DBG
    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwReadQueueJobEntry QueueId %08lx JobId %d\n",
                  QueueId, JobId ));
    }
#endif

    ntstatus = NwlibMakeNcp(
                   handleServer,
                   FSCTL_NWR_NCP_E3H,        // Bindery function
                   9,                        // Max request packet size
                   258,                      // Max response packet size
                   "bdw|_rr==bb_C_c",        // Format string
                   0x6C,                     // Read Queue Job Entry
                   QueueId,                  // Queue ID
                   JobId,                    // Job ID 
                   10,                       // Skip bytes
                   TargetExecutionTime,      // Array storing execution time
                   6,                        // Size of TargetExecutionTime
                   JobEntryTime,             // Array storing job entry time
                   6,                        // Size of JobEntryTime
                   JobPosition,              // Job Position
                   JobControlFlags,          // Job Control Flag
                   26,                       // Skip bytes
                   TextJobDescription,       // Array storing the description
                   50,                       // Maximum size in the above array
                   32,                       // Skip bytes
                   UserName                  // Banner Name
                   );

#if DBG
    if ( NT_SUCCESS( ntstatus)) {
        IF_DEBUG(QUEUE) {
            KdPrint(("NWWORKSTATION: NwReadQueueJobEntry JobPosition %d Status %d Description %s\n", *JobPosition, *JobControlFlags, TextJobDescription ));
        }
    }
#endif

    return NwMapStatus(ntstatus);
}



DWORD
NwGetQueueJobsFileSize(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId,
    OUT LPDWORD FileSize
    )
/*++

Routine Description:

    This function uses an opened handle to a server to
    get the file size of the given job.

Arguments:

    handleServer - Supplies the handle to the server on
                   which add the job.
    QueueId      - Supplies the id of the queue
    JobId        - Identifying the job we are interested in
    FileSize     - Receives the file size of the given job

Return Value:

    NO_ERROR - Successfully retrieved the file size.

--*/
{
    NTSTATUS ntstatus;

#if DBG
    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwGetQueueJobsFileSize QueueId %08lx JobId %d\n", QueueId, JobId ));
    }
#endif

    ntstatus = NwlibMakeNcp(
                   handleServer,
                   FSCTL_NWR_NCP_E3H,        // Bindery function
                   9,                        // Max request packet size
                   12,                       // Max response packet size
                   "bdw|===d",               // Format string
                   0x78,                     // Get Queue Job's File Size
                   QueueId,                  // Queue ID
                   JobId,                    // Job ID 
                   FileSize                  // File Size
                   );

#if DBG
    if ( NT_SUCCESS( ntstatus)) {
        IF_DEBUG(QUEUE) {
            KdPrint(("NWWORKSTATION: NwGetQueueJobsFileSize File Size %d\n",
                    *FileSize ));
        }
    }
#endif

    return NwMapStatus(ntstatus);
}



DWORD
NwChangeQueueJobPosition(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId,
    IN  BYTE    NewPosition
    )
/*++

Routine Description:

    This function uses an opened handle to a server to
    get the change a job's position in a queue.

Arguments:

    handleServer - Supplies the handle to the server on
                   which add the job.
    QueueId      - Supplies the id of the queue
    JobId        - Identifying the job we are interested in
    NewPosition  - Supplies the new position of the job 

Return Value:

    NO_ERROR - Successfully retrieved the file size.

--*/
{
    NTSTATUS ntstatus;

#if DBG
    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwChangeQueueJobPosition QueueId %08lx JobId %d NewPosition %d\n", QueueId, JobId, NewPosition ));
    }
#endif

    ntstatus = NwlibMakeNcp(
                   handleServer,
                   FSCTL_NWR_NCP_E3H,        // Bindery function
                   10,                       // Max request packet size
                   2,                        // Max response packet size
                   "bdwb|",                  // Format string
                   0x6E,                     // Change Queue Job Position
                   QueueId,                  // Queue ID
                   JobId,                    // Job ID 
                   NewPosition               // New position of the job
                   );

    return NwMapStatus(ntstatus);
}



DWORD
NwChangeQueueJobEntry(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId,
    IN  DWORD   dwCommand,
    IN  PNW_JOB_INFO pNwJobInfo
    )
/*++

Routine Description:

    This function uses an opened handle to a server to
    get the change a job's position in a queue.

Arguments:

    handleServer - Supplies the handle to the server on
                   which add the job.
    QueueId      - Supplies the id of the queue
    JobId        - Identifying the job we are interested in
    JobControlFlags - Supplies the new job control flags
    pNwJobInfo   - 

Return Value:

    NO_ERROR - Successfully retrieved the file size.

--*/
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    DWORD TargetServerId;
    JOBTIME TargetExecutionTime;
    WORD JobType;
    BYTE JobControlFlags;
    BYTE TextJobDescription[50];
    BYTE ClientRecordArea[152];

    UNICODE_STRING UDocumentName;
    UNICODE_STRING UUserName;
    OEM_STRING     OemDocumentName, *pOemDocumentName = NULL;
    OEM_STRING     OemUserName, *pOemUserName = NULL;
    LPSTR          pszDocument, pszUser;

#if DBG
    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwChangeQueueJobEntry QueueId %08lx JobId %d dwCommand %d\n", QueueId, JobId, dwCommand ));
    }
#endif

    TextJobDescription[0] = 0;
    if ( pNwJobInfo )
    {
        if ( pNwJobInfo->pUserName )
        {
            RtlInitUnicodeString( &UUserName, pNwJobInfo->pUserName);
            ntstatus = RtlUnicodeStringToOemString( &OemUserName,
                                                    &UUserName,
                                                    TRUE );
            if ( NT_SUCCESS(ntstatus) )
                pOemUserName = &OemUserName ;  // record to free later
        }

        if ( NT_SUCCESS(ntstatus) && pNwJobInfo->pDocument )
        {
            RtlInitUnicodeString( &UDocumentName, pNwJobInfo->pDocument);
            ntstatus = RtlUnicodeStringToOemString( &OemDocumentName,
                                                    &UDocumentName,
                                                    TRUE );
            if ( NT_SUCCESS(ntstatus) )
                pOemDocumentName = &OemDocumentName ;  // record to free later
        }

        if ( NT_SUCCESS( ntstatus)) 
        {
            pszDocument = pNwJobInfo->pDocument? OemDocumentName.Buffer : "";
            pszUser = pNwJobInfo->pUserName? OemUserName.Buffer: "";
        }
    }

    if ( NT_SUCCESS( ntstatus))
    {
        ntstatus = NwlibMakeNcp(
                       handleServer,
                       FSCTL_NWR_NCP_E3H,        // Bindery function
                       9,                        // Max request packet size
                       258,                      // Max response packet size
                       "bdw|_dr_w-b_rr",         // Format string
                       0x6C,                     // Read Queue Job Entry
                       QueueId,                  // Queue ID
                       JobId,                    // Job ID 
                       6,                        // Skip bytes
                       &TargetServerId,          // Target Server ID Number
                       TargetExecutionTime,      // Target Execution Time
                       6,                        // sizeof TargetExecutionTime
                       8,                        // Skip bytes 
                       &JobType,                 // Job Type
                       &JobControlFlags,         // Job Control flags
                       26,                       // Skip bytes
                       TextJobDescription,       // TextJobDescription
                       50,                       // sizeof TextJobDescription
                       ClientRecordArea,         // Client record area
                       152                       // sizeof ClientRecordArea
                       );
    }

    if ( NT_SUCCESS( ntstatus))
    {
        switch ( dwCommand )
        {
            case JOB_CONTROL_PAUSE:
                JobControlFlags |=  QF_USER_HOLD;
                break;

            case JOB_CONTROL_RESUME:
                JobControlFlags &= ~( QF_USER_HOLD | QF_OPERATOR_HOLD );
                break;
   
            default:
                break;
                
        }

        ntstatus = NwlibMakeNcp(
                       handleServer,
                       FSCTL_NWR_NCP_E3H,        // Bindery function
                       263,                      // Max request packet size
                       2,                        // Max response packet size
                       "bd_dr_ww-b_CrCr|",       // Format string
                       0x6D,                     // Change Queue Job Entry
                       QueueId,                  // Queue ID
                       6,                        // Skip bytes
                       TargetServerId,           // Target Server ID Number
                       TargetExecutionTime,      // Target Execution Time
                       6,                        // sizeof TargetExecutionTime
                       6,                        // Skip bytes
                       JobId,                    // Job ID 
                       JobType,                  // Job Type
                       JobControlFlags,          // Job Control Flags
                       26,                       // Skip bytes
                       pNwJobInfo? pszDocument
                                 : TextJobDescription,    // Description
                       50,                       // Skip bytes of Description
                       ClientRecordArea,         // Client Record Area
                       32,                       // First 32 bytes of the above
                       pNwJobInfo? pszUser
                                 : (LPSTR) &ClientRecordArea[32], // Banner Name
                       13,                       // sizeof BannerName
                       &ClientRecordArea[45],    // Rest of the Client Area
                       107                       // sizeof the above
                       );
    }

    if ( pOemDocumentName )
        RtlFreeOemString( pOemDocumentName );

    if ( pOemUserName )
        RtlFreeOemString( pOemUserName );

    return NwMapStatus(ntstatus);
}



DWORD
NwGetQueueJobs(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  LPWSTR  PrinterName,
    IN  DWORD   FirstJobRequested,
    IN  DWORD   EntriesRequested,
    IN  DWORD   Level,
    OUT LPBYTE  Buffer,
    IN  DWORD   cbBuf,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD Entries
    )
/*++

Routine Description:


Arguments:

    handleServer - Supplies the handle to the server on
                   which add the job.
    QueueId      - Supplies the id of the queue

Return Value:


--*/
{
    DWORD err = NO_ERROR;

    DWORD i;
    WORD  JobCount = 0;
    WORD  pwJobList[250];

    DWORD EntrySize = 0;
    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = ( LPWSTR ) ( Buffer + cbBuf );

#if DBG
    IF_DEBUG(QUEUE)
        KdPrint(("NWWORKSTATION: NwGetQueueJobs QueueId %08lx\n", QueueId));
#endif

    *BytesNeeded = 0;
    *Entries = 0;

    err = NwGetQueueJobList( handleServer,
                             QueueId,
                             &JobCount,
                             pwJobList );


    if ( err )
    {
        KdPrint(("NWWORKSTATION: NwGetQueueJobList Error %d\n", err ));
        return err;
    }

    for ( i = 0; (i < EntriesRequested) && ( i+FirstJobRequested+1 <= JobCount);
          i++ )
    {
        err = NwGetQueueJobInfo( handleServer,
                                 QueueId,
                                 pwJobList[i+FirstJobRequested],
                                 PrinterName,
                                 Level,
                                 &FixedPortion,
                                 &EndOfVariableData,
                                 &EntrySize );
                             
        if ( err != NO_ERROR && err != ERROR_INSUFFICIENT_BUFFER )
             break;

        *BytesNeeded += EntrySize;
    }


    if ( err == ERROR_INSUFFICIENT_BUFFER ) 
    {
        *Entries = 0;
    }
    else if ( err == NO_ERROR )
    {
        *Entries = i;
    }

    return err;
}



DWORD
NwGetQueueJobInfo(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId,
    IN  LPWSTR  PrinterName,
    IN  DWORD   Level,
    IN OUT LPBYTE  *FixedPortion,
    IN OUT LPWSTR  *EndOfVariableData,
    OUT LPDWORD EntrySize
    )
/*++

Routine Description:


Arguments:

    handleServer - Supplies the handle to the server on
                   which add the job.
    QueueId      - Supplies the id of the queue

Return Value:


--*/
{
    DWORD err;
    LPWSTR UTextJobDescription = NULL;
    LPWSTR UUserName = NULL;

    JOBTIME TargetExecutionTime;
    JOBTIME JobEntryTime;
    BYTE  JobPosition;
    BYTE  JobControlFlags;
    CHAR  UserName[14];
    CHAR  TextJobDescription[50];
    DWORD FileSize = 0;

    TextJobDescription[0] = 0;

    err = NwReadQueueJobEntry( handleServer,
                               QueueId,
                               JobId,
                               TargetExecutionTime,
                               JobEntryTime,
                               &JobPosition,
                               &JobControlFlags,
                               TextJobDescription,
                               UserName );

    if ( err )
    {
        KdPrint(("NWWORKSTATION: NwReadQueueJobEntry JobId %d Error %d\n",
                  JobId, err ));
        return err;
    }

    if (!NwConvertToUnicode( &UTextJobDescription, TextJobDescription ))
    {
        err = ERROR_NOT_ENOUGH_MEMORY ;
        goto ErrorExit ;
    }

    if (!NwConvertToUnicode( &UUserName, UserName ))
    {
        err = ERROR_NOT_ENOUGH_MEMORY ;
        goto ErrorExit ;
    }

    *EntrySize = ( Level == 1? sizeof( JOB_INFO_1W ) : sizeof( JOB_INFO_2W ))
                 + ( wcslen( UTextJobDescription ) + wcslen( UUserName) + 
                     wcslen( PrinterName ) + 3 ) * sizeof( WCHAR );
    //
    // See if the buffer is large enough to fit the entry
    //
    if ( (LPWSTR)( *FixedPortion + *EntrySize ) > *EndOfVariableData )
    {
        err = ERROR_INSUFFICIENT_BUFFER; 
        goto ErrorExit ;
    }

    if ( Level == 2 )
    {
        err = NwGetQueueJobsFileSize( handleServer,
                                      QueueId,
                                      JobId,
                                      &FileSize );

        if ( err )
        {
            KdPrint(("NWWORKSTATION: NwGetQueueJobsFileSize JobId %d Error %d\n", JobId, err ));
            goto ErrorExit ;
        }
    }

    err = NwWriteJobInfoEntry( FixedPortion,
                               EndOfVariableData,
                               Level,
                               JobId,
                               PrinterName,
                               UTextJobDescription,
                               UUserName,
                               JobControlFlags,
                               JobPosition,
                               JobEntryTime,
                               TargetExecutionTime,
                               FileSize );

ErrorExit: 

    if (UTextJobDescription)
        (void) LocalFree((HLOCAL) UTextJobDescription) ;
    if (UUserName)
        (void) LocalFree((HLOCAL) UUserName) ;

    return err;
}



DWORD
NwWriteJobInfoEntry(
    IN OUT LPBYTE *FixedPortion,
    IN OUT LPWSTR *EndOfVariableData,
    IN DWORD Level,
    IN WORD  JobId,
    IN LPWSTR PrinterName,
    IN LPWSTR JobDescription,
    IN LPWSTR UserName,
    IN BYTE  JobControlFlags,
    IN BYTE  JobPosition,
    IN JOBTIME JobEntryTime,
    IN JOBTIME TargetExecutionTime,
    IN DWORD  FileSize
    )
/*++

Routine Description:

    This function packages a JOB_INFO_1 or JOB_INFO_2 entry into the
    user output buffer.

Arguments:

    FixedPortion - Supplies a pointer to the output buffer where the next
        entry of the fixed portion of the use information will be written.
        This pointer is updated to point to the next fixed portion entry
        after a PRINT_INFO_1 entry is written.

    EndOfVariableData - Supplies a pointer just off the last available byte
        in the output buffer.  This is because the variable portion of the
        user information is written into the output buffer starting from
        the end.

        This pointer is updated after any variable length information is
        written to the output buffer.

Return Value:

    NO_ERROR - Successfully wrote entry into user buffer.

    ERROR_INSUFFICIENT_BUFFER - Buffer was too small to fit entry.

--*/
{
    DWORD err = NO_ERROR;
    BOOL FitInBuffer = TRUE;
    DWORD JobStatus = 0;

    JOB_INFO_1W *pJobInfo1 = (JOB_INFO_1W *) *FixedPortion;
    JOB_INFO_2W *pJobInfo2 = (JOB_INFO_2W *) *FixedPortion;


    if (  ( JobControlFlags & QF_USER_HOLD )
       || ( JobControlFlags & QF_OPERATOR_HOLD )
       )
    {
        JobStatus = JOB_STATUS_PAUSED;
    }

    //
    // See if buffer is large enough to fit the entry.
    //

    if ( Level == 1 )
    {
        pJobInfo1->JobId = JobId;
        pJobInfo1->Position = JobPosition;
        pJobInfo1->Status = JobStatus;
        if ( err = ConvertToSystemTime( JobEntryTime, &pJobInfo1->Submitted ))
            return err;

        pJobInfo1->pMachineName = NULL;
        pJobInfo1->pDatatype = NULL;
        pJobInfo1->pStatus = NULL;
        pJobInfo1->Priority = 0;
        pJobInfo1->TotalPages = 0;
        pJobInfo1->PagesPrinted = 0;

        //
        // Update fixed entry pointer to next entry.
        //
        (*FixedPortion) += sizeof(JOB_INFO_1W);

        //
        // PrinterName
        //
        FitInBuffer = NwlibCopyStringToBuffer(
                          PrinterName,
                          wcslen(PrinterName),
                          (LPCWSTR) *FixedPortion,
                          EndOfVariableData,
                          &pJobInfo1->pPrinterName
                          );

        ASSERT(FitInBuffer);

        //
        // UserName
        //
        FitInBuffer = NwlibCopyStringToBuffer(
                          UserName,
                          wcslen(UserName),
                          (LPCWSTR) *FixedPortion,
                          EndOfVariableData,
                          &pJobInfo1->pUserName
                          );

        ASSERT(FitInBuffer);

        //
        // Description
        //
        FitInBuffer = NwlibCopyStringToBuffer(
                          JobDescription,
                          wcslen(JobDescription),
                          (LPCWSTR) *FixedPortion,
                          EndOfVariableData,
                          &pJobInfo1->pDocument
                          );

        ASSERT(FitInBuffer);
    }
    else  // Level == 2
    {
        pJobInfo2->JobId = JobId;
        pJobInfo2->Position = JobPosition;
        pJobInfo2->Status = JobStatus;
        if ( err = ConvertToSystemTime( JobEntryTime, &pJobInfo2->Submitted ))
            return err;

        pJobInfo2->StartTime = 0;
        pJobInfo2->Size = FileSize;

        pJobInfo2->pMachineName = NULL;
        pJobInfo2->pNotifyName = NULL;
        pJobInfo2->pDatatype = NULL;
        pJobInfo2->pPrintProcessor = NULL;
        pJobInfo2->pParameters = NULL;
        pJobInfo2->pDriverName = NULL;
        pJobInfo2->pDevMode = NULL;
        pJobInfo2->pStatus = NULL;
        pJobInfo2->pSecurityDescriptor = NULL;
        pJobInfo2->Priority = 0;
        pJobInfo2->TotalPages = 0;
        pJobInfo2->UntilTime = 0;
        pJobInfo2->Time = 0;
        pJobInfo2->PagesPrinted = 0;

        //
        // Update fixed entry pointer to next entry.
        //
        (*FixedPortion) += sizeof(JOB_INFO_2W);

        //
        // PrinterName
        //
        FitInBuffer = NwlibCopyStringToBuffer(
                          PrinterName,
                          wcslen(PrinterName),
                          (LPCWSTR) *FixedPortion,
                          EndOfVariableData,
                          &pJobInfo2->pPrinterName
                          );

        ASSERT(FitInBuffer);

        //
        // UserName
        //
        FitInBuffer = NwlibCopyStringToBuffer(
                          UserName,
                          wcslen(UserName),
                          (LPCWSTR) *FixedPortion,
                          EndOfVariableData,
                          &pJobInfo2->pUserName
                          );

        ASSERT(FitInBuffer);

        //
        // Description
        //
        FitInBuffer = NwlibCopyStringToBuffer(
                          JobDescription,
                          wcslen(JobDescription),
                          (LPCWSTR) *FixedPortion,
                          EndOfVariableData,
                          &pJobInfo2->pDocument
                          );

        ASSERT(FitInBuffer);
    }

    if (!FitInBuffer)
        return ERROR_INSUFFICIENT_BUFFER;

    return NO_ERROR;
}



DWORD 
ConvertToSystemTime( 
    IN  JOBTIME      JobTime,
    OUT LPSYSTEMTIME pSystemTime 
)
/*++

Routine Description:

Arguments:
    JobTime -
    pSystemTime -

Return Value:

--*/
{
    FILETIME fileTimeLocal, fileTimeUTC;
    
    pSystemTime->wYear   = JobTime[0] + 1900;
    pSystemTime->wMonth  = JobTime[1];
    pSystemTime->wDay    = JobTime[2];
    pSystemTime->wDayOfWeek = 0;
    pSystemTime->wHour   = JobTime[3];
    pSystemTime->wMinute = JobTime[4];
    pSystemTime->wSecond = JobTime[5];
    pSystemTime->wMilliseconds = 0;

    if (  ( !SystemTimeToFileTime( pSystemTime, &fileTimeLocal ) )
       || ( !LocalFileTimeToFileTime( &fileTimeLocal, &fileTimeUTC ) )
       || ( !FileTimeToSystemTime( &fileTimeUTC, pSystemTime ) )
       )
    {
        KdPrint(("NWWORKSTATION: Time Conversion Error = %d\n",GetLastError()));
        return GetLastError();
    }

    return NO_ERROR;
}

#ifndef NOT_USED

DWORD

 NwCreateQueue ( IN  HANDLE hServer, 
                 IN  LPWSTR pszQueue,
                 OUT LPDWORD  pQueueId 
               )

/*+++
Routine Description:
  
   Uses the handle opened to a server to create a queue on the server.
   Return the Queue Id if successful.
   
Arguments:

        hServer   : Handle to the file Server
        pszQueue : Name of the queue that you are creating on the server
        pQueueId : Address of QueueId

        
Return Value:

    An error condition as it arises.
    NO_ERROR: Successful in adding printer name
    ERROR   : otherwise 
--*/

{
   NTSTATUS ntstatus;
   WORD ObjectType;
   UNICODE_STRING UQueueName;
   OEM_STRING OemQueueName;

   *pQueueId = 0;
#if DBG
    IF_DEBUG(PRINT) {
        KdPrint(("NWWORKSTATION: NwCreateQueue : %ws\n",
                 pszQueue));
    }
#endif

    RtlInitUnicodeString( &UQueueName, pszQueue);
    ntstatus = RtlUnicodeStringToOemString( &OemQueueName, &UQueueName, TRUE);

    if ( NT_SUCCESS(ntstatus))
       {
       
          ntstatus = NwlibMakeNcp(
                           hServer,
                           FSCTL_NWR_NCP_E3H,
                           174,
                           6,
                           "bwpbp|d",
                           0x64,                          //Create Queue
                           0x0003,                       // Queue Type = Print Queue
                           OemQueueName.Buffer,          //Queue Name
                           0x00,                         // Directory Handle
                           "SYS:SYSTEM",                //queue created in SYS:SYSTEM directory
                           pQueueId
                           );


       }
    else 
       {
          goto Exit;
       }

    if ( NT_SUCCESS(ntstatus)) {
#if DBG
        IF_DEBUG(ENUM) {
            KdPrint(("NWWORKSTATION: NwCreateQueue successful\n" ));
        }
#endif

    }
    else
       goto FreeExit;
      
   // Change Property Security on Q_OPERATORS

    ntstatus = NwlibMakeNcp (
                    hServer,
                    FSCTL_NWR_NCP_E3H,
                    70,
                    2,
                    "bwpbp|",         
                    0x3B,
                    0x0003,
                    OemQueueName.Buffer,
                    0x1,                             //New Property security
                    "Q_OPERATORS"
                    );
                            


    if ( NT_SUCCESS(ntstatus)) {
#if DBG
        IF_DEBUG(PRINT) {
            KdPrint(("NWWORKSTATION: Change Property Security  successful\n" ));
        }
#endif

    }
    else
       //unable to add new property security, so destroy queue and go to end
 {
    (void) NwDestroyQueue( hServer, 
                           *pQueueId );

    goto FreeExit;
 }
       

   // Add Bindery Object of Type Queue to Set

   ntstatus = NwlibMakeNcp (
                       hServer,
                       FSCTL_NWR_NCP_E3H,    // Bindery function
                       122,
                         2,
                       "bwppwp|",
                       0x41,
                       0x0003,
                       OemQueueName.Buffer,
                       "Q_OPERATORS",
                       0x0001,
                       "SUPERVISOR"
                       );
 


    if ( NT_SUCCESS(ntstatus)) {

#if DBG
        IF_DEBUG(PRINT) {
            KdPrint(("NWWORKSTATION: Add Bindery Object:Q_OPERATORS\n" ));
        }
#endif

    }
    else
 {
       (void)NwDestroyQueue(hServer,*pQueueId);
       goto FreeExit;

 }
   // Add Bindery Object to Set of Q_USERS 

   ntstatus = NwlibMakeNcp (
                       hServer,
                       FSCTL_NWR_NCP_E3H,    // Bindery function
                       122,
                         2,
                       "bwppwp|",
                       0x41,
                       0x0003,
                       OemQueueName.Buffer,
                       "Q_USERS",
                       0x0002,
                       "EVERYONE"
                       );
 
      // bunch of parameters to Add Bindery Object to Set Q_USERS 

 
    if ( NT_SUCCESS(ntstatus)) {
#if DBG
        IF_DEBUG(PRINT) {
            KdPrint(("NWWORKSTATION: AddBinderyObjecttoSet Q_USERS\n" ));
        }
#endif


    }


FreeExit: RtlFreeOemString( &OemQueueName);
Exit:
    return NwMapBinderyCompletionCode(ntstatus);
}

 
DWORD 
NwAssocPServers ( IN HANDLE hServer,
                  IN LPWSTR  pszQueue,
                  IN LPWSTR pszPServer
                )

/*+++
Routine Description:
  
   Associates a list of Q Servers with a queue id. This list is supplied
   to this routine as pszPServer with entries separated by semicolons   
   
Arguments:

        hServer   : Handle to the file Server
        pszQueue :  Name of the queue to which to associate the Q servers
        pszPServer  : List of Q Servers.

        
Return Value:

    An error condition as it arises.
    0x0 is returned if there is no error

--*/

{
  LPWSTR pszPServerlist = NULL;
  LPWSTR pszNextPServer = NULL;
  DWORD  err = 0x00000000 ;
  NTSTATUS ntstatus ;
  UNICODE_STRING UQueueName, UNextPServer;
  OEM_STRING    OemQueueName,OemNextPServer;


   if (pszPServer == NULL)
      return  NO_ERROR;
      
   if((pszPServerlist = AllocNwSplStr(pszPServer)) == NULL)
      {
        err = ERROR_NOT_ENOUGH_MEMORY;
        return err;
      }

    RtlInitUnicodeString( &UQueueName, pszQueue);
    ntstatus = RtlUnicodeStringToOemString( &OemQueueName, &UQueueName, TRUE);
  
    if (! NT_SUCCESS(ntstatus))
    {
      goto Exit;
    }

   while( (pszNextPServer = GetNextElement(&pszPServerlist, L';')) != NULL )
      {      
         RtlInitUnicodeString( &UNextPServer, pszNextPServer);
         ntstatus = RtlUnicodeStringToOemString( &OemNextPServer, &UNextPServer, TRUE);
         
          
         if ( !NT_SUCCESS(ntstatus))
            {
               RtlFreeOemString(&OemNextPServer);
               goto Exit;
            }
       //NwlibMakeNcp should associate a print server with a printer

       // Add Bindery Object to Set
       
       ntstatus = NwlibMakeNcp (
                        hServer,
                        FSCTL_NWR_NCP_E3H,    // Bindery function
                        122,
                        2,
                        "bwppwp|",
                         0x41,
                         0x0003,
                        OemQueueName.Buffer,
                        "Q_SERVERS",
                        0x0007,       // Object of type Print Server      
                        OemNextPServer.Buffer
                        );

         RtlFreeOemString(&OemNextPServer);
         if (!( NT_SUCCESS(ntstatus)))
            { 
               RtlFreeOemString(&OemNextPServer);
               goto Exit;
          
            }
      }
  RtlFreeOemString(&OemQueueName);

Exit:  

        return NwMapBinderyCompletionCode(ntstatus);

}

 
DWORD 
 NwDestroyQueue (HANDLE hServer,
                  DWORD dwQueueId)

/*+++
Routine Description:
  
   Makes the Ncp call to destroy the queue given by dwQueueId

   
Arguments:

        dwQueueId : Id of the queue you are creating.
        
Return Value:

    An error condition as it arises.
    0x0 is returned if there is no error

---*/

{
   
   NTSTATUS ntstatus;

   ntstatus = NwlibMakeNcp( 
                   hServer,
                   FSCTL_NWR_NCP_E3H,
                   7,
                   2,
                   "bd|",
                   0x65,
                   dwQueueId
                 );

#if DBG
    if ( NT_SUCCESS(ntstatus)) {
        IF_DEBUG(PRINT) {
            KdPrint(("NWWORKSTATION: Queue successfully destroyed\n"));
        }
    }
#endif

    return NwMapBinderyCompletionCode(ntstatus);

}

#endif // #ifndef NOT_USED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\util.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    util.c

Abstract:

    ntVdm netWare (Vw) IPX/SPX Functions

    Vw: The peoples' network

    Contains various utility routines

    Contents:
        GetInternetAddress
        GetMaxPacketSize
        RetrieveEcb
        RetrieveXEcb
        (AllocateXecb)
        (DeallocateXecb)
        ScheduleEvent
        ScanTimerList
        CancelTimerEvent
        CancelTimedEvents
        CancelAsyncEvent
        CancelSocketEvent
        CancelConnectionEvent
        QueueEcb
        DequeueEcb
        CancelSocketQueue
        CancelConnectionQueue
        AbortQueue
        AbortConnectionEvent
        StartIpxSend
        GetIoBuffer
        (ReleaseIoBuffer)
        GatherData
        ScatterData
        IpxReceiveFirst
        IpxReceiveNext
        (IpxSendFirst)
        IpxSendNext
        (QueueReceiveRequest)
        (DequeueReceiveRequest)
        (QueueSendRequest)
        (DequeueSendRequest)
        CompleteOrQueueIo
        CompleteIo
        CompleteOrQueueEcb
        CompleteEcb
        (QueueAsyncCompletion)
        EsrCallback
        VWinEsrCallback
        FifoAddHead
        FifoAdd
        FifoRemove
        FifoNext

Author:

    Richard L Firth (rfirth) 30-Sep-1993

Environment:

    User-mode Win32

Revision History:

    30-Sep-1993 rfirth
        Created

--*/

#include "vw.h"
#pragma hdrstop

//
// private routine prototypes
//

PRIVATE
LPXECB
AllocateXecb(
    VOID
    );

PRIVATE
VOID
DeallocateXecb(
    IN LPXECB pXecb
    );

PRIVATE
VOID
ReleaseIoBuffer(
    IN LPXECB pXecb
    );

PRIVATE
VOID
IpxSendFirst(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    );

PRIVATE
VOID
QueueReceiveRequest(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    );

PRIVATE
LPXECB
DequeueReceiveRequest(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    );

PRIVATE
VOID
QueueSendRequest(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    );

PRIVATE
LPXECB
DequeueSendRequest(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    );

PRIVATE
VOID
QueueAsyncCompletion(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    );

//
// private data
//

//
// TimerList - singly-linked list of timed events, in order of duration
//

PRIVATE LPXECB TimerList = NULL;

//
// AsyncCompletionQueue - keeps list of completed ECBs awaiting removal via
// ESR callback
//

PRIVATE FIFO AsyncCompletionQueue = {NULL, NULL};

//
// sort-of-private data (matches not-really-global data in other modules)
//

//
// SerializationCritSec - grab this when manipulating SOCKET_INFO list
//

CRITICAL_SECTION SerializationCritSec;

//
// AsyncCritSec - grab this when manipulating AsyncCompletionQueue
//

CRITICAL_SECTION AsyncCritSec;

//
// functions
//


int
GetInternetAddress(
    IN OUT LPSOCKADDR_IPX InternetAddress
    )

/*++

Routine Description:

    Gets the node and net numbers for this station

Arguments:

    InternetAddress - pointer to SOCKADDR_IPX structure to fill with internetwork
                      address for this station

Return Value:

    int
        Success - 0
        Failure - SOCKET_ERROR

--*/

{
    SOCKET s;
    int rc;
    int structureLength = sizeof(*InternetAddress);

    s = socket(AF_IPX, SOCK_DGRAM, NSPROTO_IPX);
    if (s != INVALID_SOCKET) {

        //
        // make dynamic binding (socket number = 0)
        //

        ZeroMemory(InternetAddress, structureLength);
        InternetAddress->sa_family = AF_IPX;
        rc = bind(s, (LPSOCKADDR)InternetAddress, structureLength);
        if (rc != SOCKET_ERROR) {
            rc = getsockname(s, (LPSOCKADDR)InternetAddress, &structureLength);
            if (rc) {

                IPXDBGPRINT((__FILE__, __LINE__,
                            FUNCTION_ANY,
                            IPXDBG_LEVEL_ERROR,
                            "GetInternetAddress: getsockname() returns %d\n",
                            WSAGetLastError()
                            ));

            }
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "GetInternetAddress: bind() returns %d\n",
                        WSAGetLastError()
                        ));

        }
        closesocket(s);
    } else {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_ERROR,
                    "GetInternetAddress: socket() returns %d\n",
                    WSAGetLastError()
                    ));

        rc = SOCKET_ERROR;
    }
    return rc;
}


int
GetMaxPacketSize(
    OUT LPWORD MaxPacketSize
    )

/*++

Routine Description:

    Returns the maximum packet allowed by the underlying transport

Arguments:

    MaxPacketSize   - pointer to returned maximum packet size

Return Value:

    int
        Success - 0
        Failure - SOCKET_ERROR

--*/

{
    SOCKET s;
    int maxLen, maxLenSize = sizeof(maxLen);
    int rc;
    SOCKADDR_IPX ipxAddr;

    s = socket(AF_IPX, SOCK_DGRAM, NSPROTO_IPX);
    if (s != SOCKET_ERROR) {

        //
        // set socket to 0 - causes any applicable address to be bound
        //

        ZeroMemory(&ipxAddr, sizeof(ipxAddr));
        ipxAddr.sa_family = AF_IPX;
        rc = bind(s, (LPSOCKADDR)&ipxAddr, sizeof(ipxAddr));
        if (rc != SOCKET_ERROR) {

            rc = getsockopt(s,
                            NSPROTO_IPX,
                            IPX_MAXSIZE,
                            (char FAR*)&maxLen,
                            &maxLenSize
                            );
            if (rc != SOCKET_ERROR) {

                //
                // IPX_MAXSIZE always returns the amount of data that can be
                // transmitted in a single frame. 16-bit IPX/SPX requires that
                // the IPX header length be included in the data size
                //

                maxLen += IPX_HEADER_LENGTH;
            } else {

                IPXDBGPRINT((__FILE__, __LINE__,
                            FUNCTION_ANY,
                            IPXDBG_LEVEL_ERROR,
                            "GetMaxPacketSize: getsockopt() returns %d\n",
                            WSAGetLastError()
                            ));

            }
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "GetMaxPacketSize: bind() returns %d\n",
                        WSAGetLastError()
                        ));

        }
        closesocket(s);
    } else {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_ERROR,
                    "GetMaxPacketSize: socket() returns %d\n",
                    WSAGetLastError()
                    ));

        rc = SOCKET_ERROR;
    }

    *MaxPacketSize = (rc != SOCKET_ERROR) ? maxLen : MAXIMUM_IPX_PACKET_LENGTH;

    return rc;
}


LPXECB
RetrieveEcb(
    IN BYTE EcbType
    )

/*++

Routine Description:

    Returns pointer to 32-bit extended ECB structure which contains flat pointer
    to IPX or AES ECB in VDM memory

    We allocate the extended ECB for 3 reasons:

        1. Avoids 16-bit app scribbling over our control fields
        2. Don't have to make unaligned references to all fields (still need some)
        3. Don't have enough space in AES ECB to remember all the stuff we need

    However, we do update the 16-bit ECB's LinkAddress field. We use this as a
    pointer to the 32-bit XECB we allocate in this routine. This just saves us
    having to traverse all the lists looking for the address of the 16-bit ECB
    (which we could still do as a fall-back)

Arguments:

    EcbType - type of ECB - AES, IPX or SPX

Return Value:

    LPXECB  - 32-bit pointer to extended ECB structure

--*/

{
    WORD segment;
    WORD offset;
    LPECB pEcb;

    segment = IPX_GET_ECB_SEGMENT();
    offset = IPX_GET_ECB_OFFSET();
    pEcb = (LPIPX_ECB)POINTER_FROM_WORDS(segment, offset, sizeof(IPX_ECB));

    return RetrieveXEcb(EcbType, pEcb, (ECB_ADDRESS)MAKELONG(offset,segment));
}


LPXECB
RetrieveXEcb(
    IN BYTE EcbType,
    LPECB pEcb,
    ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    worker for RetrieveEcb, callable from windows functions (ex DOS parms)

Arguments:

    EcbType     - type of ECB - AES, IPX or SPX
    pEcb        - pointer to the 16-bit ECB
    EcbAddress  - address (seg:off in DWORD) of 16-bit ECB

Return Value:

    LPXECB

--*/

{
    LPXECB pXecb;

    if (pEcb) {

        // 
        // tommye - MS 30525
        // Make sure the pEcb is valid - we'll go ahead
        // and do this before we alloc the XEcb.
        //

        try {
            BYTE x;

            // Just deref the ptr to make sure it is okay

            x = pEcb->InUse;

        } except(1) {

            //
            // bad pointer: bogus ECB
            //

            return NULL;
        }

        //
        // allocate and fill-in 32-bit extended ECB structure. If can't allocate
        // then return NULL
        //

        pXecb = AllocateXecb();
        if (pXecb) {
            pXecb->Ecb = pEcb;
            pXecb->EcbAddress = EcbAddress;
            pXecb->EsrAddress = pEcb->EsrAddress;

            //
            // set flags - IPX/AES, SPX, protect-mode
            //

            pXecb->Flags |= (((EcbType == ECB_TYPE_IPX) || (EcbType == ECB_TYPE_SPX))
                            ? XECB_FLAG_IPX
                            : XECB_FLAG_AES)
                         | ((EcbType == ECB_TYPE_SPX) ? XECB_FLAG_SPX : 0)
                         | ((getMSW() & MSW_PE) ? XECB_FLAG_PROTMODE : 0);

            //
            // this XECB is not yet on a queue
            //

            pXecb->QueueId = NO_QUEUE;

            //
            // mark the 16-bit ECB as being used. We use an undefined value to
            // make sure it gets set/reset in the right places
            //

            pEcb->InUse = ECB_IU_TEMPORARY;

            //
            // use the LinkAddress field in the 16-bit ECB to point to the XECB.
            // We use this when cancelling the ECB
            //

            pEcb->LinkAddress = pXecb;

            //
            // AES and IPX ECBs have different sizes and different layouts
            //

            if ((EcbType == ECB_TYPE_IPX) || (EcbType == ECB_TYPE_SPX)) {
                pXecb->SocketNumber = pEcb->SocketNumber;
            }
        }
    } else {
        pXecb = NULL;
    }
    return pXecb;
}


PRIVATE
LPXECB
AllocateXecb(
    VOID
    )

/*++

Routine Description:

    Allocate an XECB; zero it; set the reference count to 1

Arguments:

    None.

Return Value:

    LPXECB

--*/

{
    LPXECB pXecb;

    pXecb = (LPXECB)LocalAlloc(LPTR, sizeof(*pXecb));
    if (pXecb) {
        pXecb->RefCount = 1;
    }
    return pXecb;
}


PRIVATE
VOID
DeallocateXecb(
    IN LPXECB pXecb
    )

/*++

Routine Description:

    decrement the XECB reference count (while holding SerializationCritSec). If
    goes to 0 then free the structure (else other thread is also holding pointer
    to XECB)

Arguments:

    pXecb   - XECB to deallocate

Return Value:

    None.

--*/

{
    RequestMutex();
    --pXecb->RefCount;
    if (!pXecb->RefCount) {

#if DBG
        FillMemory(pXecb, sizeof(*pXecb), 0xFF);
#endif

        FREE_OBJECT(pXecb);
    }
    ReleaseMutex();
}


VOID
ScheduleEvent(
    IN LPXECB pXecb,
    IN WORD Ticks
    )

/*++

Routine Description:

    Adds an ECB to the TimerList, ordered by Ticks. The value of Ticks cannot
    be zero

    Assumes 1. Ticks != 0
            2. pXecb->Next is already NULL (as result of LocalAlloc(LPTR,...)

Arguments:

    pXecb   - pointer to XECB describing IPX or AES ECB to queue
    Ticks   - number of ticks to elapse before ECB is cooked

Return Value:

    None.

--*/

{
    ASSERT(Ticks);
    ASSERT(pXecb->Next == NULL);

    RequestMutex();
    if (!TimerList) {
        TimerList = pXecb;
    } else {
        if (TimerList->Ticks > Ticks) {
            TimerList->Ticks -= Ticks;
            pXecb->Next = TimerList;
            TimerList = pXecb;
        } else {

            LPXECB previous = (LPXECB)TimerList;
            LPXECB this = previous->Next;

            Ticks -= TimerList->Ticks;
            while (this && Ticks > this->Ticks) {
                Ticks -= this->Ticks;
                previous = this;
                this = this->Next;
            }
            previous->Next = pXecb;
            pXecb->Next = this;
        }
    }
    pXecb->Ticks = Ticks;
    pXecb->QueueId = TIMER_QUEUE;
    ReleaseMutex();
}


VOID
ScanTimerList(
    VOID
    )

/*++

Routine Description:

    Called once per tick. Decrements the tick count of the ECB at the head of
    the list. If it goes to zero, completes the ECB and any subsequent ECBs
    which whose tick count would go to zero

Arguments:

    None.

Return Value:

    None.

--*/

{
    LPXECB pXecb;

    RequestMutex();
    pXecb = TimerList;
    if (pXecb) {

        //
        // Decrement if not already zero. Can be zero because the ECB at the
        // front of the list could have been Cancelled. This makes sure we
        // do not wrap around to 0xFFFF !!!
        //

        if (pXecb->Ticks != 0)
            --pXecb->Ticks;

        if (!pXecb->Ticks) {

            //
            // complete all ECBs that would go to 0 on this tick
            //

            while (pXecb->Ticks <= 1) {
                TimerList = pXecb->Next;

                IPXDBGPRINT((__FILE__, __LINE__,
                            FUNCTION_ANY,
                            IPXDBG_LEVEL_INFO,
                            "ScanTimerList: ECB %04x:%04x is done\n",
                            HIWORD(pXecb->EcbAddress),
                            LOWORD(pXecb->EcbAddress)
                            ));

                CompleteOrQueueEcb(pXecb, ECB_CC_SUCCESS);
                pXecb = TimerList;
                if (!pXecb) {
                    break;
                }
            }
        }
    }

    ReleaseMutex();
}


BYTE
CancelTimerEvent(
    IN LPXECB pXecb
    )

/*++

Routine Description:

    Cancels a pending event on the timer list

Arguments:

    pXecb   - pointer to XECB to cancel

Return Value:

    BYTE
        Success - IPX_SUCCESS
        Failure - IPX_ECB_NOT_IN_USE

--*/

{
    LPXECB listptr;
    LPXECB previous = (LPXECB)&TimerList;
    BYTE status;

    RequestMutex();
    listptr = TimerList;
    while (listptr && listptr != pXecb) {
        previous = listptr;
        listptr = listptr->Next;
    }
    if (listptr) {

        //
        // take the XECB out of the list and complete the ECB (in VDM memory).
        // Does not generate a call-back to the ESR. When CompleteEcb returns,
        // the XECB has been deallocated
        //

        previous->Next = listptr->Next;

        ASSERT(pXecb->RefCount == 2);

        --pXecb->RefCount;
        CompleteEcb(pXecb, ECB_CC_CANCELLED);
        status = IPX_SUCCESS;
    } else {
        status = IPX_ECB_NOT_IN_USE;
    }
    ReleaseMutex();
    return status;
}


VOID
CancelTimedEvents(
    IN WORD SocketNumber,
    IN WORD Owner,
    IN DWORD TaskId
    )

/*++

Routine Description:

    traverses the TimerList cancelling any IPX or AES events owned by any of
    SocketNumber, Owner or TaskId

    Assumes valid SocketNumber, Owner or TaskId cannot be 0

Arguments:

    SocketNumber    - owning socket of IPX events to cancel
    Owner           - owning DOS PDB
    TaskID          - owning Windows Task ID

Return Value:

    None.

--*/

{
    LPXECB pXecb;
    LPXECB prev = (LPXECB)&TimerList;
    LPXECB next;

    RequestMutex();
    pXecb = TimerList;
    while (pXecb) {

        next = pXecb->Next;

        if ((SocketNumber && (pXecb->SocketNumber == SocketNumber))
        || (Owner && !(pXecb->Flags & XECB_FLAG_IPX) && (pXecb->Owner == Owner))
        || (TaskId && (pXecb->TaskId == TaskId))) {

            prev->Next = next;

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_INFO,
                        "CancelTimedEvents: cancelling ECB %08x (%04x:%04x)\n",
                        pXecb,
                        HIWORD(pXecb->EcbAddress),
                        LOWORD(pXecb->EcbAddress)
                        ));

            CompleteEcb(pXecb, ECB_CC_CANCELLED);
        }
        else
        {
            prev = pXecb ;
        }
        pXecb = next;
    }
    ReleaseMutex();
}


BYTE
CancelAsyncEvent(
    IN LPXECB pXecb
    )

/*++

Routine Description:

    Called to cancel an event currently on the async completion list. We don't
    cancel these events - just return 0xF9 (ECB cannot be cancelled). It is a
    race to see who gets there first - us with the cancel, or the ESR callback.
    In this case it is fairly immaterial

Arguments:

    pXecb   - pointer to XECB to cancel (ignored)

Return Value:

    BYTE    - IPX_CANNOT_CANCEL

--*/

{
    //
    // we call DeallocateXecb to reduce the reference count. If the other thread
    // really tried to deallocate it in the short time we've been looking at it
    // on the cancel path, the call will finish up what the other thread started
    //

    DeallocateXecb(pXecb);
    return IPX_CANNOT_CANCEL;
}


BYTE
CancelSocketEvent(
    IN LPXECB pXecb
    )

/*++

Routine Description:

    Called to cancel a pending send or listen from a socket queue. Request can
    be IPX or SPX. If IPX event, then the ECB is on either the SendQueue or
    ListenQueue. If SPX, it may be on a CONNECTION_INFO ConnectQueue,
    AcceptQueue, SendQueue or ListenQueue, or if it is an
    SPXListenForSequencedPacket request that is still in the pool then it may
    be on the owning SOCKET_INFO ListenQueue

Arguments:

    pXecb   - pointer to XECB describing ECB to cancel

Return Value:

    BYTE    - IPX_SUCCESS

--*/

{
    LPXECB ptr;
    LPVOID pObject;

    RequestMutex();
    pObject = pXecb->OwningObject;
    switch (pXecb->QueueId) {
    case SOCKET_LISTEN_QUEUE:
        if (pXecb->Flags & XECB_FLAG_SPX) {
            ptr = DequeueEcb(pXecb, &((LPSOCKET_INFO)pObject)->ListenQueue);
        } else {
            ptr = DequeueReceiveRequest(pXecb, (LPSOCKET_INFO)pObject);
        }
        break;

    case SOCKET_SEND_QUEUE:
        if (pXecb->Flags & XECB_FLAG_SPX) {
            ptr = DequeueEcb(pXecb, &((LPSOCKET_INFO)pObject)->SendQueue);
        } else {
            ptr = DequeueSendRequest(pXecb, (LPSOCKET_INFO)pObject);
        }
        break;

    case SOCKET_HEADER_QUEUE:                  // SPX only
        if (pXecb->Flags & XECB_FLAG_SPX) {
            ptr = DequeueEcb(pXecb, &((LPSOCKET_INFO)pObject)->HeaderQueue);
        } else {
            ASSERT(FALSE);
        }
        break;
    }
    ReleaseMutex();
    if (ptr) {
        CompleteIo(ptr, ECB_CC_CANCELLED);
    }
    return IPX_SUCCESS;
}


BYTE
CancelConnectionEvent(
    IN LPXECB pXecb
    )

/*++

Routine Description:

    Cancels a pending SPXListenForConnection or SPXListenForSequencedPacket, the
    only cancellable SPX requests

Arguments:

    pXecb   - pointer to SPX XECB to cancel

Return Value:

    BYTE    - IPX_SUCCESS

--*/

{
    LPXECB ptr;
    LPVOID pObject;
    LPXECB_QUEUE pQueue;

    RequestMutex();
    pObject = pXecb->OwningObject;
    switch (pXecb->QueueId) {
    case CONNECTION_ACCEPT_QUEUE:
        pQueue = &((LPCONNECTION_INFO)pObject)->AcceptQueue;
        break;

    case CONNECTION_LISTEN_QUEUE:
        pQueue = &((LPCONNECTION_INFO)pObject)->ListenQueue;
        break;
    }
    ptr = DequeueEcb(pXecb, pQueue);
    ReleaseMutex();
    if (ptr) {
        CompleteIo(ptr, ECB_CC_CANCELLED);
    }
    return IPX_SUCCESS;
}


VOID
QueueEcb(
    IN LPXECB pXecb,
    IN LPXECB_QUEUE Queue,
    IN QUEUE_ID QueueId
    )

/*++

Routine Description:

    Adds an XECB to a queue and sets the queue identifier in the XECB.

Arguments:

    pXecb   - pointer to XECB to queue
    Queue   - pointer to queue to add XECB to (at tail)
    QueueId - identifies Queue

Return Value:

    None.

--*/

{
    LPVOID owningObject = NULL;

#define CONTAINER_STRUCTURE(p, t, f) (LPVOID)(((LPBYTE)(p)) - (UINT_PTR)(&((t)0)->f))

    pXecb->QueueId = QueueId;
    switch (QueueId) {
    case SOCKET_LISTEN_QUEUE:
        if (Queue->Tail && (Queue->Tail->Length < pXecb->Length)) {
            FifoAddHead((LPFIFO)Queue, (LPFIFO)pXecb);
        } else {
            FifoAdd((LPFIFO)Queue, (LPFIFO)pXecb);
        }
        owningObject = CONTAINER_STRUCTURE(Queue, LPSOCKET_INFO, ListenQueue);
        break;

    case SOCKET_SEND_QUEUE:
        FifoAdd((LPFIFO)Queue, (LPFIFO)pXecb);
        owningObject = CONTAINER_STRUCTURE(Queue, LPSOCKET_INFO, SendQueue);
        break;

    case SOCKET_HEADER_QUEUE:
        FifoAdd((LPFIFO)Queue, (LPFIFO)pXecb);
        owningObject = CONTAINER_STRUCTURE(Queue, LPSOCKET_INFO, HeaderQueue);
        break;

    case CONNECTION_CONNECT_QUEUE:
        FifoAdd((LPFIFO)Queue, (LPFIFO)pXecb);
        owningObject = CONTAINER_STRUCTURE(Queue, LPCONNECTION_INFO, ConnectQueue);
        break;

    case CONNECTION_ACCEPT_QUEUE:
        FifoAdd((LPFIFO)Queue, (LPFIFO)pXecb);
        owningObject = CONTAINER_STRUCTURE(Queue, LPCONNECTION_INFO, AcceptQueue);
        break;

    case CONNECTION_SEND_QUEUE:
        FifoAdd((LPFIFO)Queue, (LPFIFO)pXecb);
        owningObject = CONTAINER_STRUCTURE(Queue, LPCONNECTION_INFO, SendQueue);
        break;

    case CONNECTION_LISTEN_QUEUE:
        FifoAdd((LPFIFO)Queue, (LPFIFO)pXecb);
        owningObject = CONTAINER_STRUCTURE(Queue, LPCONNECTION_INFO, ListenQueue);
        break;
    }
    pXecb->OwningObject = owningObject;
}


LPXECB
DequeueEcb(
    IN LPXECB pXecb,
    IN LPXECB_QUEUE Queue
    )

/*++

Routine Description:

    Removes pXecb from Queue and resets the XECB queue identifier (to NO_QUEUE)

Arguments:

    pXecb   - pointer to XECB to remove
    Queue   - queue from which to remove pXecb

Return Value:

    LPXECB
        pointer to removed XECB

--*/

{
    LPXECB p;

    p = (LPXECB)FifoRemove((LPFIFO)Queue, (LPFIFO)pXecb);
    pXecb->QueueId = NO_QUEUE;
    pXecb->OwningObject = NULL;
    return pXecb;
}


VOID
CancelSocketQueue(
    IN LPXECB_QUEUE pXecbQueue
    )

/*++

Routine Description:

    Cancels all pending ECBs on a SOCKET_INFO queue

Arguments:

    pXecbQueue  - pointer to (socket/connection) queue

Return Value:

    None.

--*/

{
    LPXECB ptr;

    while (ptr = pXecbQueue->Head) {
        CancelSocketEvent(ptr);
    }
}


VOID
CancelConnectionQueue(
    IN LPXECB_QUEUE pXecbQueue
    )

/*++

Routine Description:

    Cancels all pending ECBs on a CONNECTION_INFO queue

Arguments:

    pXecbQueue  - pointer to XECB queue on CONNECTION_INFO

Return Value:

    None.

--*/

{
    LPXECB ptr;

    while (ptr = pXecbQueue->Head) {
        CancelConnectionEvent(ptr);
    }
}


VOID
AbortQueue(
    IN LPXECB_QUEUE pXecbQueue,
    IN BYTE CompletionCode
    )

/*++

Routine Description:

    Aborts or terminates an ECB queue from a CONNECTION_INFO structure

Arguments:

    pXecbQueue      - pointer to queue
    CompletionCode  - to put in aborted/terminated ECBs

Return Value:

    None.

--*/

{
    LPXECB ptr;

    while (ptr = pXecbQueue->Head) {
        AbortConnectionEvent(ptr, CompletionCode);
    }
}


VOID
AbortConnectionEvent(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    )

/*++

Routine Description:

    Aborts a connection ECB

Arguments:

    pXecb           - pointer to SPX XECB to cancel
    CompletionCode  - value to put in ECB

Return Value:

    None.

--*/

{
    LPXECB ptr;
    LPCONNECTION_INFO pConnectionInfo;
    LPXECB_QUEUE pQueue;

    pConnectionInfo = (LPCONNECTION_INFO)pXecb->OwningObject;
    switch (pXecb->QueueId) {
    case CONNECTION_CONNECT_QUEUE:
        pQueue = &pConnectionInfo->ConnectQueue;
        break;

    case CONNECTION_ACCEPT_QUEUE:
        pQueue = &pConnectionInfo->AcceptQueue;
        break;

    case CONNECTION_SEND_QUEUE:
        pQueue = &pConnectionInfo->SendQueue;
        break;

    case CONNECTION_LISTEN_QUEUE:
        pQueue = &pConnectionInfo->ListenQueue;
        break;
    }
    ptr = DequeueEcb(pXecb, pQueue);
    if (ptr) {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "AbortConnectionEvent: Aborting ECB %04x:%04x\n",
                    HIWORD(pXecb->EcbAddress),
                    LOWORD(pXecb->EcbAddress)
                    ));

        SPX_ECB_CONNECTION_ID(ptr->Ecb) = pConnectionInfo->ConnectionId;
        CompleteOrQueueIo(ptr, CompletionCode);
    }
}


VOID
StartIpxSend(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Starts a send operation for IPXSendPacket(). Allocates a send buffer if
    the ECB has >1 fragment else uses a pointer to the single fragment buffer
    in 16-bit address space

    Fills in various fields in the ECB and IPX header

    Assumes:    1. By the time this function is called, we already know we have
                   a valid non-zero fragment count and the first fragment is
                   big enough to hold an IPX packet header

    When this function terminates, the ECB is either completed or queued

Arguments:

    pXecb       - pointer to XECB describing ECB to use for sending
    pSocketInfo - pointer to SOCKET_INFO structure

Return Value:

    None.

--*/

{
    BOOL success;
    int packetLength = 0;
    LPFRAGMENT pFragment;
    int fragmentCount;
    LPIPX_ECB pEcb = (LPIPX_ECB)pXecb->Ecb;

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "StartIpxSend: %d frag(s), 1: address=%x (%04x:%04x), len=%04x\n",
                READ_WORD(&pEcb->FragmentCount),
                GET_FAR_POINTER(&(ECB_FRAGMENT(pEcb, 0)->Address), IS_PROT_MODE(pXecb)),
                GET_SELECTOR(&(ECB_FRAGMENT(pEcb, 0)->Address)),
                GET_OFFSET(&(ECB_FRAGMENT(pEcb, 0)->Address)),
                READ_WORD(&(ECB_FRAGMENT(pEcb, 0)->Length))
                ));

    //
    // mark the ECB as being used by IPX (for send)
    //

    pEcb->InUse = ECB_IU_SENDING;

    //
    // the total send buffer size cannot exceed the maximum packet size
    //

    fragmentCount = (int)pEcb->FragmentCount;

    ASSERT(fragmentCount);

    pFragment = (LPFRAGMENT)&(ECB_FRAGMENT(pEcb, 0)->Address);
    while (fragmentCount--) {
        packetLength += pFragment->Length;
        ++pFragment;
    }
    if (packetLength <= MyMaxPacketSize) {
        success = GetIoBuffer(pXecb, TRUE, IPX_HEADER_LENGTH);
        if (success) {

            LPIPX_PACKET pPacket = (LPIPX_PACKET)GET_FAR_POINTER(
                                            &(ECB_FRAGMENT(pEcb, 0)->Address),
                                            IS_PROT_MODE(pXecb)
                                            );

            //
            // fill in the following fields in the IPX header:
            //
            //  Checksum
            //  Length
            //  TransportControl
            //  Source (network, node, socket)
            //
            //  Does real IPX modify these fields in app memory?
            //  If so, does the app expect modified fields?
            //  If not, we need to always copy then modify memory,
            //  even if only 1 fragment
            //

            pPacket->Checksum = 0xFFFF;
            pPacket->Length = L2BW((WORD)packetLength);
            pPacket->TransportControl = 0;
            CopyMemory((LPBYTE)&pPacket->Source,
                       &MyInternetAddress.sa_netnum,
                       sizeof(MyInternetAddress.sa_netnum)
                       + sizeof(MyInternetAddress.sa_nodenum)
                       );
            pPacket->Source.Socket = pSocketInfo->SocketNumber;

            //
            // if we allocated a buffer then there is >1 fragment. Collect them
            //

            if (pXecb->Flags & XECB_FLAG_BUFFER_ALLOCATED) {
                GatherData(pXecb, IPX_HEADER_LENGTH);
            }

            //
            // initiate the send. IPX_ECB_BUFFER32(pEcb) points to the data to send,
            // IPX_ECB_LENGTH32(pEcb) is the size of data to send
            //

            IpxSendFirst(pXecb, pSocketInfo);
        } else {

            //
            // couldn't allocate a buffer? Comes under the heading of
            // hardware error?
            //

            CompleteEcb(pXecb, ECB_CC_HARDWARE_ERROR);
            if (pSocketInfo->Flags & SOCKET_FLAG_TEMPORARY) {
                KillSocket(pSocketInfo);
            }
        }
    } else {

        //
        // packet larger than MyMaxPacketSize
        //

        CompleteOrQueueEcb(pXecb, ECB_CC_BAD_REQUEST);
        if (pSocketInfo->Flags & SOCKET_FLAG_TEMPORARY) {
            KillSocket(pSocketInfo);
        }
    }
}


BOOL
GetIoBuffer(
    IN OUT LPXECB pXecb,
    IN BOOL Send,
    IN WORD HeaderLength
    )

/*++

Routine Description:

    Allocate a buffer based on the ECB fragment list. If there is only 1 fragment
    we use the address of the buffer in the VDM. If >1 fragment, we allocate a
    32-bit buffer large enough to hold all the 16-bit fragments

    We trim the buffer requirement for a send buffer: we do not send the IPX/SPX
    header with the data: it will be provided by the transport

    Assumes:    1. If called for a send buffer, the first fragment has already
                   been verified as >= HeaderLength

Arguments:

    pXecb           - pointer to XECB which points to IPX_ECB containing fragment
                      list to allocate buffer for
    Send            - TRUE if this request is to get a send buffer
    HeaderLength    - length of the (untransmitted) header portion

Return Value:

    BOOL
        TRUE    - Buffer allocated, XECB updated with address, length and flags
        FALSE   - either ECB contains bad fragment descriptor list or we
                  couldn't allocate a buffer

--*/

{
    WORD fragmentCount;
    WORD bufferLength = 0;
    LPBYTE bufferPointer = NULL;
    WORD flags = 0;
    int i;
    int fragIndex = 0;  // index of fragment address to use if no allocation required
    LPIPX_ECB pEcb = (LPIPX_ECB)pXecb->Ecb;

    fragmentCount = READ_WORD(&pEcb->FragmentCount);

    for (i = 0; i < (int)fragmentCount; ++i) {
        bufferLength += ECB_FRAGMENT(pEcb, i)->Length;
    }
    if (bufferLength) {

        //
        // exclude the IPX header from send buffer. If the first send fragment
        // contains only the IPX header, reduce the fragment count by 1
        //

        if (Send) {
            bufferLength -= HeaderLength;
            if (ECB_FRAGMENT(pEcb, 0)->Length == HeaderLength) {
                --fragmentCount;
                fragIndex = 1;
            }
        }
        if (bufferLength) {
            if (fragmentCount > 1) {
                bufferPointer = AllocateBuffer(bufferLength);
                if (bufferPointer) {
                    flags = XECB_FLAG_BUFFER_ALLOCATED;
                } else {

                    //
                    // need a buffer; failed to allocate it
                    //

                    return FALSE;
                }
            } else {

                //
                // fragmentCount must be 1 (else bufferLength would be 0)
                //

                bufferPointer = GET_FAR_POINTER(
                                    &ECB_FRAGMENT(pEcb, fragIndex)->Address,
                                    IS_PROT_MODE(pXecb)
                                    );
                if (Send && !fragIndex) {

                    //
                    // if we are allocating a send buffer AND there is only 1
                    // fragment AND it is the first fragment then the one and
                    // only fragment must contain the IPX header and the data.
                    // Advance the data pointer past the IPX header
                    //

                    bufferPointer += HeaderLength;
                }
            }
        } else {

            //
            // sending 0 bytes!!!
            //

        }
    } else {

        //
        // fragments but no buffer length? Sounds like a malformed packet
        //

        return FALSE;
    }

    //
    // bufferPointer is either the address of a buffer in 32-bit memory which
    // must be gather/scattered when the I/O operation completes, or it is the
    // address of a single fragment buffer in 16-bit memory. In the former case
    // flags is ECB_ALLOCATE_32 and the latter 0
    //

    pXecb->Buffer = pXecb->Data = bufferPointer;
    pXecb->Length = bufferLength;
    pXecb->Flags |= flags;
    return TRUE;
}


PRIVATE
VOID
ReleaseIoBuffer(
    IN LPXECB pXecb
    )

/*++

Routine Description:

    Deallocates I/O buffer attached to XECB and zaps associated XECB fields

Arguments:

    pXecb   - pointer to XECB owning buffer to be released

Return Value:

    None.

--*/

{
    if (pXecb->Flags & XECB_FLAG_BUFFER_ALLOCATED) {
        DeallocateBuffer(pXecb->Buffer);
        pXecb->Buffer = pXecb->Data = NULL;
        pXecb->Flags &= ~XECB_FLAG_BUFFER_ALLOCATED;
    }
}


VOID
GatherData(
    IN LPXECB pXecb,
    IN WORD HeaderLength
    )

/*++

Routine Description:

    Copies data from fragmented 16-bit memory into single 32-bit memory buffer.
    Used to send data. We exclude the IPX header: this information is supplied
    by the transport

    Assumes:    1. The fragment descriptor list has been verified: we know that
                   the first fragment contains at least the IPX header

Arguments:

    pXecb           - pointer to XECB structure. The following IPX_ECB and XECB
                      fields must contain coherent values:

                        IPX_ECB.FragmentCount
                        XECB.Buffer

    HeaderLength    - length of the (untransmitted) header portion

Return Value:

    None.

--*/

{
    int fragmentCount;
    WORD length;
    ULPBYTE pData16;
    ULPBYTE pData32;
    LPFRAGMENT pFragment;
    LPIPX_ECB pEcb = (LPIPX_ECB)pXecb->Ecb;

    fragmentCount = (int)pEcb->FragmentCount;
    pFragment = (LPFRAGMENT)&(ECB_FRAGMENT(pEcb, 0)->Address);
    pData32 = pXecb->Buffer;

    //
    // if the 1st fragment contains more than the IPX/SPX header, copy the data
    // after the header
    //

    if (pFragment->Length > HeaderLength) {

        LPBYTE fragAddr = GET_FAR_POINTER(&pFragment->Address,
                                          IS_PROT_MODE(pXecb)
                                          );

        length = pFragment->Length - HeaderLength;
        CopyMemory((LPVOID)pData32,
                   fragAddr + HeaderLength,
                   length
                   );
        pData32 += length;
    }

    //
    // copy subsequent fragments
    //

    ++pFragment;
    while (--fragmentCount) {
        pData16 = GET_FAR_POINTER(&pFragment->Address, IS_PROT_MODE(pXecb));
        if (pData16 == NULL) {
            break;
        }
        length = pFragment->Length;
        CopyMemory((PVOID)pData32, (CONST VOID*)pData16, (ULONG)length);
        pData32 += length;
        ++pFragment;
    }
}


VOID
ScatterData(
    IN LPXECB pXecb
    )

/*++

Routine Description:

    Copies data from 32-bit memory to 16-bit. The data must be fragmented if
    this function has been called (i.e. we determined there were >1 fragments
    and allocated a single 32-bit buffer to cover them)

Arguments:

    pXecb   - pointer to XECB containing 32-bit buffer info

Return Value:

    None.

--*/

{
    int fragmentCount;
    int length;
    WORD length16;
    WORD length32;
    ULPBYTE pData16;
    ULPBYTE pData32;
    LPFRAGMENT pFragment;
    LPIPX_ECB pEcb = (LPIPX_ECB)pXecb->Ecb;

    fragmentCount = (int)pEcb->FragmentCount;
    pFragment = (LPFRAGMENT)&(ECB_FRAGMENT(pEcb, 0)->Address);
    pData32 = pXecb->Buffer;
    length32 = pXecb->Length;
    while (length32) {
        pData16 = GET_FAR_POINTER(&pFragment->Address, IS_PROT_MODE(pXecb));
        if (pData16 == NULL) {
            break;
        }

        length16 = pFragment->Length;
        length = min(length16, length32);
        CopyMemory((PVOID)pData16, (CONST VOID*)pData32, (ULONG)length);
        pData32 += length;
        length32 -= (WORD) length;
        ++pFragment;
        --fragmentCount;

        ASSERT(fragmentCount >= 0);

    }
}


VOID
IpxReceiveFirst(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Performs a receive against a non-blocking socket. This is the first
    receive call for this ECB. If the receive completes immediately with data
    or an error that isn't WSAEWOULDBLOCK then the ECB is completed. If the
    receives completes with a WSAEWOULDBLOCK error then the request is queued
    for deferred processing by the AES thread

    Unlike send, receives are not serialized. If there are already receives
    pending against the socket there could be a clash between this function
    and IpxReceiveNext(), called from the AES thread. In this case, we expect
    Winsock to do the right thing and serialize the callers

Arguments:

    pXecb           - pointer to XECB describing receive ECB
    pSocketInfo     - pointer to socket structure

Return Value:

    None.

--*/

{
    SOCKADDR_IPX from;
    int fromLen = sizeof(from);
    int rc;
    BYTE status;
    BOOL error;

    rc = recvfrom(pSocketInfo->Socket,
                  (char FAR*)pXecb->Buffer,
                  (int)pXecb->Length,
                  0,    // flags
                  (LPSOCKADDR)&from,
                  &fromLen
                  );
    if (rc != SOCKET_ERROR) {
        error = FALSE;
        status = ECB_CC_SUCCESS;
    } else {
        error = TRUE;
        rc = WSAGetLastError();
        if (rc == WSAEWOULDBLOCK) {
            RequestMutex();
            QueueReceiveRequest(pXecb, pSocketInfo);
            ReleaseMutex();
        } else if (rc == WSAEMSGSIZE) {
            error = FALSE;
            status = ECB_CC_BAD_REQUEST;
            rc = pXecb->Length;
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "IpxReceiveFirst: recvfrom() returns %d (buflen=%d)\n",
                        rc,
                        pXecb->Length
                        ));

            CompleteOrQueueIo(pXecb, ECB_CC_BAD_REQUEST);
        }
    }
    if (!error) {

        //
        // rc = bytes received, or 0 = connection terminated (even for DGRAM?)
        //

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "IpxReceiveFirst: bytes received = %d (%x)\n",
                    rc,
                    rc
                    ));
/*
        VwDumpEcb(pXecb->Ecb,
                  HIWORD(pXecb->EcbAddress),
                  LOWORD(pXecb->EcbAddress),
                  FALSE,
                  TRUE,
                  TRUE,
                  IS_PROT_MODE(pXecb)
                  );
*/

        IPXDUMPDATA((pXecb->Buffer, 0, 0, FALSE, (WORD)rc));

        //
        // if the receive buffers are fragmented, copy the data to 16-bit memory
        // (else single buffer: its already there (dude))
        //

        if (pXecb->Flags & XECB_FLAG_BUFFER_ALLOCATED) {

            //
            // update the ECB_LENGTH32 field to reflect the amount of data received
            //

            pXecb->Length = (WORD)rc;
            ScatterData(pXecb);

            //
            // we have finished with the 32-bit buffer: deallocate it
            //

            ReleaseIoBuffer(pXecb);
        }

        //
        // update the ImmediateAddress field in the ECB with the node address
        // of the sender
        //

        CopyMemory(pXecb->Ecb->ImmediateAddress, from.sa_nodenum, sizeof(from.sa_nodenum));

        //
        // if this ECB has a non-NULL ESR then queue for asynchronous completion
        // else complete immediately (app must poll InUse field)
        //

        CompleteOrQueueEcb(pXecb, status);
    }
}


VOID
IpxReceiveNext(
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Attempts to complete an IPXListenForPacket request that has been deferred due
    to the fact the socket was blocked.

    The ECB containing all the receive information is at the head of the
    ListenQueue on pSocketInfo

    We can use any queued listen ECB, but it just so happens we use the one at
    the head of the FIFO

    Note: SerializationCritSec is held when this function is called.

Arguments:

    pSocketInfo - pointer to SOCKET_INFO structure with pending IPX send request

Return Value:

    None.

--*/

{
    LPXECB pXecb;
    SOCKADDR_IPX from;
    int fromLen = sizeof(from);
    int rc;
    BYTE status;
    BOOL error;

    ASSERT(pSocketInfo);

    pXecb = (LPXECB)pSocketInfo->ListenQueue.Head;

    ASSERT(pXecb);

    rc = recvfrom(pSocketInfo->Socket,
                  (char FAR*)pXecb->Buffer,
                  (int)pXecb->Length,
                  0,    // flags
                  (LPSOCKADDR)&from,
                  &fromLen
                  );
    if (rc != SOCKET_ERROR) {
        error = FALSE;
        status = ECB_CC_SUCCESS;
    } else {
        error = TRUE;
        rc = WSAGetLastError();
        if (rc == WSAEMSGSIZE) {
            error = FALSE;
            status = ECB_CC_BAD_REQUEST;
            rc = pXecb->Length;
        } else if (rc != WSAEWOULDBLOCK) {
            DequeueReceiveRequest(pXecb, pSocketInfo);

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "IpxReceiveNext: recvfrom() returns %d\n",
                        rc
                        ));

            CompleteOrQueueIo(pXecb, ECB_CC_CANCELLED);
        }
    }
    if (!error) {
/*
        VwDumpEcb(pXecb->Ecb,
                  HIWORD(pXecb->EcbAddress),
                  LOWORD(pXecb->EcbAddress),
                  FALSE,
                  TRUE,
                  TRUE,
                  IS_PROT_MODE(pXecb)
                  );
*/
        //
        // data received. Remove ECB from queue
        //

        DequeueReceiveRequest(pXecb, pSocketInfo);

        //
        // rc = bytes received, or 0 = connection terminated (even for DGRAM?)
        //

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "IpxReceiveNext: ECB %04x:%04x bytes received = %d (%x)\n",
                    HIWORD(pXecb->EcbAddress),
                    LOWORD(pXecb->EcbAddress),
                    rc,
                    rc
                    ));

        IPXDUMPDATA((pXecb->Buffer, 0, 0, FALSE, (WORD)rc));

        //
        // if the receive buffers are fragmented, copy the data to 16-bit memory
        // (else single buffer: its already there (dude))
        //

        if (pXecb->Flags & XECB_FLAG_BUFFER_ALLOCATED) {

            //
            // update the IPX_ECB_LENGTH32 field to reflect the amount of data received
            //

            pXecb->Length = (WORD)rc;
            ScatterData(pXecb);
            ReleaseIoBuffer(pXecb);
        }

        //
        // update the ImmediateAddress field in the ECB with the node address
        // of the sender
        //

        CopyMemory(pXecb->Ecb->ImmediateAddress,
                   from.sa_nodenum,
                   sizeof(from.sa_nodenum)
                   );

        //
        // if this ECB has a non-NULL ESR then queue for asynchronous completion
        // else complete immediately (app must poll InUse field)
        //

        CompleteOrQueueEcb(pXecb, ECB_CC_SUCCESS);
    }
}


PRIVATE
VOID
IpxSendFirst(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Tries to send an IPX packet. This is the first attempt to send the packet
    described in the ECB. If the send succeeds or fails with an error other
    than WSAEWOULDBLOCK we complete the ECB. If the send attempt fails because
    the transport can't accept the request at this time, we queue it for later
    when the AES thread will attempt to send it.

    If there is already a send being attempted then we just queue this request
    and let AES handle it in IpxSendNext()

Arguments:

    pXecb       - pointer to XECB
    pSocketInfo - pointer to SOCKET_INFO structure

Return Value:

    None.

--*/

{
    RequestMutex();
    if (pSocketInfo->Flags & SOCKET_FLAG_SENDING) {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "IpxSendFirst: queueing ECB %04x:%04x\n",
                    HIWORD(pXecb->EcbAddress),
                    LOWORD(pXecb->EcbAddress)
                    ));

        QueueSendRequest(pXecb, pSocketInfo);
    } else {

        SOCKADDR_IPX to;
        LPIPX_PACKET pPacket;
        int length;
        int rc;
        LPIPX_ECB pEcb = (LPIPX_ECB)pXecb->Ecb;
        int type;
/*
        VwDumpEcb(pXecb->Ecb,
                  HIWORD(pXecb->EcbAddress),
                  LOWORD(pXecb->EcbAddress),
                  FALSE,
                  TRUE,
                  TRUE,
                  IS_PROT_MODE(pXecb)
                  );
*/
        length = (int)pXecb->Length;

        //
        // the first fragment holds the destination address info
        //

        pPacket = (LPIPX_PACKET)GET_FAR_POINTER(&ECB_FRAGMENT(pEcb, 0)->Address,
                                                IS_PROT_MODE(pXecb)
                                                );
        to.sa_family = AF_IPX;

        //
        // copy the destination net number as a DWORD (4 bytes) from the
        // destination network address structure in the IPX packet header
        //

        *(ULPDWORD)&to.sa_netnum[0] = *(ULPDWORD)&pPacket->Destination.Net[0];
        //
        // copy the immediate (destination) node number as a DWORD (4 bytes) and
        // a WORD (2 bytes) from the Destination network address structure in
        // the IPX packet header. pPacket is an unaligned pointer, so we are
        // safe
        //

        *(ULPDWORD)&to.sa_nodenum[0] = *(ULPDWORD)&pPacket->Destination.Node[0];

        *(LPWORD)&to.sa_nodenum[4] = *(ULPWORD)&pPacket->Destination.Node[4];

        //
        // copy the destination socket number from the IPX packet header as a
        // WORD (2 bytes). Again, the aligned pointer will save us
        //

        to.sa_socket = pPacket->Destination.Socket;

        type = (int)pPacket->PacketType;
        rc = setsockopt(pSocketInfo->Socket,
                        NSPROTO_IPX,
                        IPX_PTYPE,
                        (char FAR*)&type,
                        sizeof(type)
                        );
        if (rc) {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "IpxSendFirst: setsockopt(IPX_PTYPE) returns %d\n",
                        WSAGetLastError()
                        ));

        }
        rc = sendto(pSocketInfo->Socket,
                    (char FAR*)pXecb->Buffer,
                    length,
                    0,  // flags
                    (LPSOCKADDR)&to,
                    sizeof(to)
                    );
        if (rc == length) {

            //
            // all data sent
            //

            IPXDUMPDATA((pXecb->Buffer, 0, 0, FALSE, (WORD)rc));

            CompleteOrQueueIo(pXecb, ECB_CC_SUCCESS);
            if (pSocketInfo->Flags & SOCKET_FLAG_TEMPORARY) {
                KillSocket(pSocketInfo);
            }
        } else if (rc == SOCKET_ERROR) {
            rc = WSAGetLastError();
            if (rc == WSAEWOULDBLOCK) {

                IPXDBGPRINT((__FILE__, __LINE__,
                            FUNCTION_ANY,
                            IPXDBG_LEVEL_INFO,
                            "IpxSendFirst: queueing ECB %04x:%04x (after sendto)\n",
                            HIWORD(pXecb->EcbAddress),
                            LOWORD(pXecb->EcbAddress)
                            ));

                QueueSendRequest(pXecb, pSocketInfo);
            } else {

                IPXDBGPRINT((__FILE__, __LINE__,
                            FUNCTION_ANY,
                            IPXDBG_LEVEL_ERROR,
                            "IpxSendFirst: sendto() returns %d\n",
                            rc
                            ));

                CompleteIo(pXecb, ECB_CC_UNDELIVERABLE);
                if (pSocketInfo->Flags & SOCKET_FLAG_TEMPORARY) {
                    KillSocket(pSocketInfo);
                }
            }
        } else {

            //
            // send should send all the data or return an error
            //

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_FATAL,
                        "IpxSendFirst: sendto() returns unexpected %d (length = %d)\n",
                        rc,
                        length
                        ));
        }
    }
    ReleaseMutex();
}


VOID
IpxSendNext(
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Attempts to complete an IPXSendPacket request that has been deferred due
    to the fact the socket was blocked.

    The ECB containing all the send information is at the head of the SendQueue
    on pSocketInfo

    The SendQueue is serialized in FIFO order

    Note: SerializationCritSec is held when this function is called.

Arguments:

    pSocketInfo - pointer to SOCKET_INFO structure with pending IPX send request

Return Value:

    None.

--*/

{
    SOCKADDR_IPX to;
    LPIPX_PACKET pPacket;
    int length;
    int rc;
    LPXECB pXecb;
    LPIPX_ECB pEcb;
    int type;

    pXecb = (LPXECB)pSocketInfo->SendQueue.Head;
    pEcb = (LPIPX_ECB)pXecb->Ecb;

    ASSERT(pXecb);
    ASSERT(pEcb);
/*
    VwDumpEcb(pXecb->Ecb,
              HIWORD(pXecb->EcbAddress),
              LOWORD(pXecb->EcbAddress),
              FALSE,
              TRUE,
              TRUE,
              IS_PROT_MODE(pXecb)
              );
*/
    length = (int)pXecb->Length;

    //
    // even though we have a 32-bit pointer to the IPX packet buffer which
    // may be in 16- or 32-bit memory, we still need unaligned access
    //

    pPacket = (LPIPX_PACKET)pXecb->Buffer;
    to.sa_family = AF_IPX;

    //
    // copy the destination net number as a DWORD (4 bytes) from the
    // destination network address structure in the IPX packet header
    //

    *(ULPDWORD)&to.sa_netnum[0] = *(ULPDWORD)&pPacket->Destination.Net[0];
    //
    // copy the immediate (destination) node number as a DWORD (4 bytes) and
    // a WORD (2 bytes) from the Destination network address structure in
    // the IPX packet header. pPacket is an unaligned pointer, so we are
    // safe
    //

    *(ULPDWORD)&to.sa_nodenum[0] = *(ULPDWORD)&pPacket->Destination.Node[0];
    *(LPWORD)&to.sa_nodenum[4] = *(ULPWORD)&pPacket->Destination.Node[4];

    //
    // copy the destination socket number from the IPX packet header as a
    // WORD (2 bytes). Again, the aligned pointer will save us
    //

    to.sa_socket = pPacket->Destination.Socket;

    type = (int)pPacket->PacketType;
    rc = setsockopt(pSocketInfo->Socket,
                    NSPROTO_IPX,
                    IPX_PTYPE,
                    (char FAR*)&type,
                    sizeof(type)
                    );
    if (rc) {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_ERROR,
                    "IpxSendNext: setsockopt(IPX_PTYPE) returns %d\n",
                    WSAGetLastError()
                    ));

    }
    rc = sendto(pSocketInfo->Socket,
                (char FAR*)pPacket,
                length,
                0,  // flags
                (LPSOCKADDR)&to,
                sizeof(to)
                );
    if (rc == length) {

        //
        // all data sent - dequeue it
        //


        IPXDUMPDATA((pXecb->Buffer, 0, 0, FALSE, (WORD)rc));

        DequeueEcb(pXecb, &pSocketInfo->SendQueue);
        if (pXecb->EsrAddress) {
            if (pXecb->Flags & XECB_FLAG_BUFFER_ALLOCATED) {
                ReleaseIoBuffer(pXecb);
            }
            QueueAsyncCompletion(pXecb, ECB_CC_SUCCESS);
        } else {
            CompleteIo(pXecb, ECB_CC_SUCCESS);
        }
        if (pSocketInfo->Flags & SOCKET_FLAG_TEMPORARY) {
            KillSocket(pSocketInfo);
        }
    } else if (rc == SOCKET_ERROR) {

        //
        // if the socket is still blocked, there's nothing to do - just leave
        // the request hanging around till next time
        //

        rc = WSAGetLastError();
        if (rc != WSAEWOULDBLOCK) {
            DequeueSendRequest(pXecb, pSocketInfo);

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "IpxSendNext: sendto() returns %d\n",
                        rc
                        ));

            CompleteIo(pXecb, ECB_CC_UNDELIVERABLE);
            if (pSocketInfo->Flags & SOCKET_FLAG_TEMPORARY) {
                KillSocket(pSocketInfo);
            }
        }
    } else {

        //
        // send should send all the data or return an error
        //

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_FATAL,
                    "IpxSendNext: sendto() returns unexpected %d (length = %d)\n",
                    rc,
                    length
                    ));
    }
}


PRIVATE
VOID
QueueReceiveRequest(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Add a listen XECB to queue of listen XECBs on a SOCKET_INFO structure

Arguments:

    pXecb       - pointer to listen XECB to queue
    pSocketInfo - pointer to SOCKET_INFO structure

Return Value:

    None.

--*/

{
    QueueEcb(pXecb, &pSocketInfo->ListenQueue, SOCKET_LISTEN_QUEUE);
    ++pSocketInfo->PendingListens;
    pSocketInfo->Flags |= SOCKET_FLAG_LISTENING;
}


PRIVATE
LPXECB
DequeueReceiveRequest(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Remove a listen XECB from queue of listen XECBs on a SOCKET_INFO structure

Arguments:

    pXecb       - pointer to listen XECB to dequeue
    pSocketInfo - pointer to SOCKET_INFO structure

Return Value:

    LPXECB

--*/

{
    LPXECB ptr;

    ptr = (LPXECB)DequeueEcb(pXecb, &pSocketInfo->ListenQueue);
    if (ptr) {

        ASSERT(ptr == pXecb);

        --pSocketInfo->PendingListens;
        if (!pSocketInfo->PendingListens) {
            pSocketInfo->Flags &= ~SOCKET_FLAG_LISTENING;
        }

        pXecb->Ecb->InUse = ECB_IU_AWAITING_PROCESSING;
    }
    return ptr;
}


PRIVATE
VOID
QueueSendRequest(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Add a send XECB to queue of send XECBs on a SOCKET_INFO structure

Arguments:

    pXecb       - pointer to send XECB to queue
    pSocketInfo - pointer to SOCKET_INFO structure

Return Value:

    None.

--*/

{
    QueueEcb(pXecb, &pSocketInfo->SendQueue, SOCKET_SEND_QUEUE);
    ++pSocketInfo->PendingSends;
    pSocketInfo->Flags |= SOCKET_FLAG_SENDING;
    pXecb->Ecb->InUse = ECB_IU_SEND_QUEUED;
}


PRIVATE
LPXECB
DequeueSendRequest(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Remove a send XECB from queue of send XECBs on a SOCKET_INFO structure

Arguments:

    pXecb       - pointer to send XECB to dequeue
    pSocketInfo - pointer to SOCKET_INFO structure

Return Value:

    LPXECB

--*/

{
    LPXECB ptr;

    ptr = (LPXECB)DequeueEcb(pXecb, &pSocketInfo->SendQueue);
    if (ptr) {

        ASSERT(ptr == pXecb);

        --pSocketInfo->PendingSends;
        if (!pSocketInfo->PendingSends) {
            pSocketInfo->Flags &= ~SOCKET_FLAG_SENDING;
        }
        pXecb->Ecb->InUse = ECB_IU_AWAITING_PROCESSING;
    }
    return ptr;
}


VOID
CompleteOrQueueIo(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    )

/*++

Routine Description:

    Returns any allocated buffer resource then completes or queues the ECB

Arguments:

    pXecb           - pointer to XECB structure
    CompletionCode  - value to put in CompletionCode field

Return Value:

    None.

--*/

{
    //
    // if we allocated a buffer, free it
    //

    if (pXecb->Flags & XECB_FLAG_BUFFER_ALLOCATED) {
        ReleaseIoBuffer(pXecb);
    }
    CompleteOrQueueEcb(pXecb, CompletionCode);
}


VOID
CompleteIo(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    )

/*++

Routine Description:

    Completes a send/receive request by returning any allocated buffer resource
    and setting the ECB InUse and CompletionCode fields

Arguments:

    pXecb           - pointer to XECB structure
    CompletionCode  - value to put in CompletionCode field

Return Value:

    None.

--*/

{
    //
    // if we allocated a buffer, free it
    //

    if (pXecb->Flags & XECB_FLAG_BUFFER_ALLOCATED) {
        ReleaseIoBuffer(pXecb);
    }
    CompleteEcb(pXecb, CompletionCode);
}


VOID
CompleteOrQueueEcb(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    )

/*++

Routine Description:

    Queues an XECB for completion by ESR or completes it now

Arguments:

    pXecb           - pointer to XECB describing ECB to complete
    CompletionCode  - value to put in ECB CompletionCode field

Return Value:

    None.

--*/

{
    if (pXecb->EsrAddress) {
        QueueAsyncCompletion(pXecb, CompletionCode);
    } else {
        CompleteIo(pXecb, CompletionCode);
    }
}


VOID
CompleteEcb(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    )

/*++

Routine Description:

    Sets the CompletionCode field in the ECB and sets the InUse field to 0.
    Deallocates the XECB structure

Arguments:

    pXecb           - pointer to XECB describing ECB in 16-bit memory to update
    CompletionCode  - value to put in CompletionCode field

Return Value:

    None.

--*/

{
    LPIPX_ECB pEcb = (LPIPX_ECB)pXecb->Ecb;

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "CompleteEcb: completing ECB @%04x:%04x w/ %02x\n",
                HIWORD(pXecb->EcbAddress),
                LOWORD(pXecb->EcbAddress),
                CompletionCode
                ));

    //
    // if this is really an AES ECB then CompletionCode is actually the first
    // byte of the AES workspace. It shouldn't matter that we write into this
    // field - we are supposed to own it
    //

    pEcb->CompletionCode = CompletionCode;
    pEcb->InUse = ECB_IU_NOT_IN_USE;

    //
    // reset the LinkAddress field. This means we have completed the ECB
    //

    pEcb->LinkAddress = NULL;

    //
    // finally, deallocate the XECB. This mustn't have any allocated resources
    // (like a buffer)
    //

    DeallocateXecb(pXecb);
}


PRIVATE
VOID
QueueAsyncCompletion(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    )

/*++

Routine Description:

    Add an XECB to the (serialized) async completion queue and raise a simulated
    hardware interrupt in the VDM.

    The interrupt will cause the VDM to start executing at the ISR in the TSR
    which will call-back to find the address for the ESR, then execute it

Arguments:

    pXecb           - pointer to XECB describing IPX or AES ECB to add to async
                      completion list
    CompletionCode  - the ECB in VDM memory will be updated with this completion
                      code

Return Value:

    None.

--*/

{

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "QueueAsyncCompletion: completing ECB @%04x:%04x w/ %02x\n",
                HIWORD(pXecb->EcbAddress),
                LOWORD(pXecb->EcbAddress),
                CompletionCode
                ));

    pXecb->Ecb->CompletionCode = CompletionCode;
    pXecb->QueueId = ASYNC_COMPLETION_QUEUE;
    EnterCriticalSection(&AsyncCritSec);
    FifoAdd(&AsyncCompletionQueue, (LPFIFO)pXecb);
    LeaveCriticalSection(&AsyncCritSec);

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "QueueAsyncCompletion: ECB @ %04x:%04x ESR @ %04x:%04x\n",
                HIWORD(pXecb->EcbAddress),
                LOWORD(pXecb->EcbAddress),
                HIWORD(pXecb->EsrAddress),
                LOWORD(pXecb->EsrAddress)
                ));

    VDDSimulateInterrupt(Ica, IcaLine, 1);
}


VOID
EsrCallback(
    VOID
    )

/*++

Routine Description:

    Callback function from within 16-bit TSR ESR function. Returns the address
    of the next completed ECB in ES:SI

    Any allocated resources (e.g. 32-bit buffer) must have been freed by the
    time the ESR callback happens

Arguments:

    None.

Return Value:

    None.

--*/

{
    WORD segment = 0;
    WORD offset = 0;
    BYTE flags = 0;

    VWinEsrCallback( &segment, &offset, &flags );

    setES(segment);
    setSI(offset);
    setAL(flags);
}


VOID
VWinEsrCallback(
    WORD *pSegment,
    WORD *pOffset,
    BYTE *pFlags
    )

/*++

Routine Description:

    Callback function from within 16-bit function. Returns the address
    of the next completed ECB

    Any allocated resources (e.g. 32-bit buffer) must have been freed by the
    time the ESR callback happens

Arguments:

    None.

Return Value:

    None.

--*/

{
    LPXECB pXecb;

    EnterCriticalSection(&AsyncCritSec);
    pXecb = AsyncCompletionQueue.Head;
    if (pXecb) {

        WORD msw = getMSW();

        if ((msw & MSW_PE) ^ IS_PROT_MODE(pXecb)) {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_INFO,
                        "EsrCallback: ECB @ %04x:%04x NOT for this proc mode (%d)\n",
                        HIWORD(pXecb->EcbAddress),
                        LOWORD(pXecb->EcbAddress),
                        msw & MSW_PE
                        ));

            pXecb = NULL;
        } else {
            pXecb = (LPXECB)FifoNext(&AsyncCompletionQueue);
        }
    } else {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_FATAL,
                    "EsrCallback: no ECBs on AsyncCompletionQueue!\n"
                    ));

    }
    LeaveCriticalSection(&AsyncCritSec);

    if (pXecb) {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "EsrCallback: ECB @ %04x:%04x ESR @ %04x:%04x\n",
                    HIWORD(pXecb->EcbAddress),
                    LOWORD(pXecb->EcbAddress),
                    HIWORD(pXecb->EsrAddress),
                    LOWORD(pXecb->EsrAddress)
                    ));

        *pSegment = HIWORD(pXecb->EcbAddress);
        *pOffset  = LOWORD(pXecb->EcbAddress);
        pXecb->Ecb->LinkAddress = NULL;
        pXecb->Ecb->InUse = ECB_IU_NOT_IN_USE;
        *pFlags = (BYTE)((pXecb->Flags & XECB_FLAG_IPX) ? ECB_TYPE_IPX : ECB_TYPE_AES);
        DeallocateXecb(pXecb);
        setCF(0);
    } else {
        setCF(1);
    }
}


VOID
FifoAddHead(
    IN LPFIFO pFifo,
    IN LPFIFO pElement
    )

/*++

Routine Description:

    Adds an element to the head of a (single-linked) FIFO list

Arguments:

    pFifo       - pointer to FIFO structure
    pElement    - pointer to (FIFO) element to add to list

Return Value:

    None.

--*/

{
    if (!pFifo->Head) {
        pFifo->Head = pFifo->Tail = pElement;
        pElement->Head = NULL;
    } else {
        pElement->Head = pFifo->Head;
        pFifo->Head = pElement;
    }
}

VOID
FifoAdd(
    IN LPFIFO pFifo,
    IN LPFIFO pElement
    )

/*++

Routine Description:

    Adds an element to the tail of a (single-linked) FIFO list

Arguments:

    pFifo       - pointer to FIFO structure
    pElement    - pointer to (FIFO) element to add to list

Return Value:

    None.

--*/

{
    if (!pFifo->Head) {
        pFifo->Head = pFifo->Tail = pElement;
    } else {
        ((LPFIFO)pFifo->Tail)->Head = pElement;
    }
    pFifo->Tail = pElement;
    pElement->Head = NULL;
}


LPFIFO
FifoRemove(
    IN LPFIFO pFifo,
    IN LPFIFO pElement
    )

/*++

Routine Description:

    Removes an element from a (single-linked) FIFO list

Arguments:

    pFifo       - pointer to FIFO structure
    pElement    - pointer to (FIFO) element to remove (single-linked)

Return Value:

    PFIFO
        NULL - pElement not on list
        !NULL - pElement removed from list

--*/

{
    LPFIFO p;
    LPFIFO prev = (LPFIFO)pFifo;

    p = (LPFIFO)pFifo->Head;
    while (p && (p != pElement)) {
        prev = p;
        p = p->Head;
    }
    if (p) {
        prev->Head = p->Head;
        if (pFifo->Head == NULL) {
            pFifo->Tail = NULL;
        } else if (pFifo->Tail == p) {
            pFifo->Tail = prev;
        }
    }
    return p;
}


LPFIFO
FifoNext(
    IN LPFIFO pFifo
    )

/*++

Routine Description:

    Remove element at head of FIFO queue

Arguments:

    pFifo   - pointer to FIFO

Return Value:

    LPFIFO
        NULL - nothing on queue
        !NULL - removed element

--*/

{
    LPFIFO p;
    LPFIFO prev = (LPFIFO)pFifo;

    p = (LPFIFO)pFifo->Head;
    if (p) {
        pFifo->Head = p->Head;
        if (!pFifo->Head) {
            pFifo->Tail = NULL;
        }
    }
    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\server\service.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    getaddr.c

Abstract:

    This module contains the code to support NPGetAddressByName.

Author:

    Yi-Hsin Sung (yihsins)    18-Apr-94
    Glenn A. Curtis (glennc)  18-Jul-95

Revision History:

    yihsins      Created
    glennc       Modified     18-Jul-95

--*/

#ifndef QFE_BUILD

#include <nw.h>
#include <winsock.h>
#include <wsipx.h>
#include <nspapi.h>
#include <nspapip.h>
#include <wsnwlink.h>
#include <svcguid.h>
#include <nwsap.h>
#include <align.h>
#include <nwmisc.h>

#define WSOCK_VER_REQD        0x0101

DWORD
NwrGetService(
    IN LPWSTR Reserved,
    IN WORD   nSapType,
    IN LPWSTR lpServiceName,
    IN DWORD  dwProperties,
    OUT LPBYTE lpServiceInfo,
    IN DWORD  dwBufferLength,
    OUT LPDWORD lpdwBytesNeeded
    )
/*++

Routine Description:

    This routine calls NwGetService to, in turn, get the service info.

Arguments:

    Reserved - unused

    nSapType - SAP type

    lpServiceName - service name

    dwProperties -  specifys the properties of the service info needed

    lpServiceInfo - on output, contains the SERVICE_INFO

    dwBufferLength - size of buffer pointed by lpServiceInfo

    lpdwBytesNeeded - if the buffer pointed by lpServiceInfo is not large
                      enough, this will contain the bytes needed on output

Return Value:

    Win32 error.

--*/
{
    return NwGetService( Reserved,
                         nSapType,
                         lpServiceName,
                         dwProperties,
                         lpServiceInfo,
                         dwBufferLength,
                         lpdwBytesNeeded );
}

DWORD
NwrSetService(
    IN LPWSTR Reserved,
    IN DWORD  dwOperation,
    IN LPSERVICE_INFO lpServiceInfo,
    IN WORD   nSapType
    )
/*++

Routine Description:

    This routine registers or deregisters the service info.

Arguments:

    Reserved - unused

    dwOperation - SERVICE_REGISTER or SERVICE_DEREGISTER

    lpServiceInfo - contains the service information

    nSapType - SAP type

Return Value:

    Win32 error.

--*/
{
    DWORD err = NO_ERROR;

    UNREFERENCED_PARAMETER( Reserved );

    //
    // Check if all parameters passed in are valid
    //

    if ( (lpServiceInfo->lpServiceName == NULL) || (wcslen( lpServiceInfo->lpServiceName ) > SAP_OBJECT_NAME_MAX_LENGTH-1) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    switch ( dwOperation )
    {
        case SERVICE_REGISTER:
            err = NwRegisterService( lpServiceInfo, nSapType, NwDoneEvent );
            break;

        case SERVICE_DEREGISTER:
            err = NwDeregisterService( lpServiceInfo, nSapType );
            break;

        default:
            err = ERROR_INVALID_PARAMETER;
            break;
    }

    return err;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\server\spool.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    spool.c

Abstract:

    This module contains the Netware print provider.

Author:

    Yi-Hsin Sung    (yihsins)   15-May-1993

Revision History:

--*/

#include <stdio.h>
#include <stdlib.h>
#include <nw.h>
#include <nwreg.h>
#include <nwpkstr.h>
#include <splutil.h>
#include <queue.h>
#include <nwmisc.h>

//------------------------------------------------------------------
//
// Local Definitions
//
//------------------------------------------------------------------

#define NW_SIGNATURE           0x574E       /* "NW" is the signature */

#define SPOOL_STATUS_STARTDOC  0x00000001
#define SPOOL_STATUS_ADDJOB    0x00000002
#define SPOOL_STATUS_ABORT     0x00000003

#define PRINTER_CHANGE_VALID   0x55770F07
#define PRINTER_CHANGE_DEFAULT_TIMEOUT_VALUE  10000
#define PRINTER_CHANGE_MINIMUM_TIMEOUT_VALUE  1000
#define REG_TIMEOUT_PATH       L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Parameters"
#define REG_TIMEOUT_VALUE_NAME L"PrintNotifyTimeout"

#define NDS_MAX_NAME_CHARS 256
#define NDS_MAX_NAME_SIZE  ( NDS_MAX_NAME_CHARS * 2 )

//
// Printer structure
//
typedef struct _NWPRINTER {
    LPWSTR  pszServer;                 // Server Name
    LPWSTR  pszQueue;                  // Queue Name
    LPWSTR  pszUncConnection;          // UNC Connection Name
                                       // (only present if NDS print queue
    DWORD   nQueueId;                  // Queue Id
    struct _NWPRINTER *pNextPrinter;   // Points to the next printer
    struct _NWSPOOL   *pSpoolList;     // Points to the list of open handles
} NWPRINTER, *PNWPRINTER;

//
//  Handle structure
//
typedef struct _NWSPOOL {
    DWORD      nSignature;             // Signature
    DWORD      errOpenPrinter;         // OpenPrinter API will always return
                                       // success on known printers. This will
                                       // contain the error that we get
                                       // if something went wrong in the API.
    PNWPRINTER pPrinter;               // Points to the corresponding printer
    HANDLE     hServer;                // Opened handle to the server
    struct _NWSPOOL  *pNextSpool;      // Points to the next handle
    DWORD      nStatus;                // Status
    DWORD      nJobNumber;             // StartDocPrinter/AddJob: Job Number
    HANDLE     hChangeEvent;           // WaitForPrinterChange: event to wait on
    DWORD      nWaitFlags;             // WaitForPrinterChange: flags to wait on
    DWORD      nChangeFlags;           // Changes that occurred to the printer
} NWSPOOL, *PNWSPOOL;

//------------------------------------------------------------------
//
// Global Variables
//
//------------------------------------------------------------------


// Stores the timeout value used in WaitForPrinterChange ( in milliseconds )
STATIC DWORD NwTimeOutValue = PRINTER_CHANGE_DEFAULT_TIMEOUT_VALUE;

// Points to the link list of printers
STATIC PNWPRINTER NwPrinterList = NULL;

//------------------------------------------------------------------
//
// Local Function Prototypes
//
//------------------------------------------------------------------

VOID
NwSetPrinterChange(
    IN PNWSPOOL pSpool,
    IN DWORD nFlags
);

PNWPRINTER
NwFindPrinterEntry(
    IN LPWSTR pszServer,
    IN LPWSTR pszQueue
);

DWORD
NwCreatePrinterEntry(
    IN LPWSTR pszServer,
    IN LPWSTR pszQueue,
    OUT PNWPRINTER *ppPrinter,
    OUT PHANDLE phServer
);

VOID
NwRemovePrinterEntry(
    IN PNWPRINTER pPrinter
);

LPWSTR
NwGetUncObjectName(
    IN LPWSTR ContainerName
);



VOID
NwInitializePrintProvider(
    VOID
)
/*++

Routine Description:

    This routine initializes the server side print provider when
    the workstation service starts up.

Arguments:

    None.

Return Value:

--*/
{
    DWORD err;
    HKEY  hkey;
    DWORD dwTemp;
    DWORD dwSize = sizeof( dwTemp );

    //
    // Read the time out value from the registry.
    // We will ignore all errors since we can always have a default time out.
    // The default will be used if the key does not exist.
    //
    err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                         REG_TIMEOUT_PATH,
                         0,
                         KEY_READ,
                         &hkey );

    if ( !err )
    {
        err = RegQueryValueExW( hkey,
                                REG_TIMEOUT_VALUE_NAME,
                                NULL,
                                NULL,
                                (LPBYTE) &dwTemp,
                                &dwSize );

        if ( !err )
        {
            NwTimeOutValue = dwTemp;

            //
            // tommye - bug 139469 - removed 
            //  if (NwTimeOutValue >= 0) because NwtimeOutValue is a DWORD
            //
            // Use the minimum timeout value if the
            // value set in the registry is too small.
            //

            if (NwTimeOutValue <= PRINTER_CHANGE_MINIMUM_TIMEOUT_VALUE)
            {
                NwTimeOutValue = PRINTER_CHANGE_MINIMUM_TIMEOUT_VALUE;
            }
        }

        RegCloseKey( hkey );
    }

}



VOID
NwTerminatePrintProvider(
    VOID
)
/*++

Routine Description:

    This routine cleans up the server side print provider when
    the workstation service shut downs.

Arguments:

    None.

Return Value:

--*/
{
    PNWPRINTER pPrinter, pNext;
    PNWSPOOL pSpool, pNextSpool;

    for ( pPrinter = NwPrinterList; pPrinter; pPrinter = pNext )
    {
         pNext = pPrinter->pNextPrinter;

         pPrinter->pNextPrinter = NULL;

         for ( pSpool = pPrinter->pSpoolList; pSpool; pSpool = pNextSpool )
         {
              pNextSpool = pSpool->pNextSpool;
              if ( pSpool->hChangeEvent )
                  CloseHandle( pSpool->hChangeEvent );
              (VOID) NtClose( pSpool->hServer );

              //
              // Free all memory associated with the context handle
              //
              FreeNwSplMem( pSpool, sizeof( NWSPOOL) );
         }

         pPrinter->pSpoolList = NULL;
         FreeNwSplStr( pPrinter->pszServer );
         FreeNwSplStr( pPrinter->pszQueue );
         if ( pPrinter->pszUncConnection )
         {
             (void) NwrDeleteConnection( NULL,
                                         pPrinter->pszUncConnection,
                                         FALSE );
             FreeNwSplStr( pPrinter->pszUncConnection );
         }
         FreeNwSplMem( pPrinter, sizeof( NWPRINTER));
    }

    NwPrinterList = NULL;
    NwTimeOutValue = PRINTER_CHANGE_DEFAULT_TIMEOUT_VALUE;
}



DWORD
NwrOpenPrinter(
    IN LPWSTR Reserved,
    IN LPWSTR pszPrinterName,
    IN DWORD  fKnownPrinter,
    OUT LPNWWKSTA_PRINTER_CONTEXT phPrinter
)
/*++

Routine Description:

    This routine retrieves a handle identifying the specified printer.

Arguments:

    Reserved       -  Unused
    pszPrinterName -  Name of the printer
    fKnownPrinter  -  TRUE if we have successfully opened the printer before,
                      FALSE otherwise.
    phPrinter      -  Receives the handle that identifies the given printer

Return Value:


--*/
{
    DWORD      err;
    PNWSPOOL   pSpool = NULL;
    LPWSTR     pszServer = NULL;
    LPWSTR     pszQueue  = NULL;
    PNWPRINTER pPrinter = NULL;
    BOOL       fImpersonate = FALSE ;
    HANDLE     hServer;
    BOOL       isPrinterNameValid;

    UNREFERENCED_PARAMETER( Reserved );

    if ( pszPrinterName[0] == L' ' &&
         pszPrinterName[1] == L'\\' &&
         pszPrinterName[2] == L'\\' )
    {
        if ( (pszServer = AllocNwSplStr( pszPrinterName + 1 )) == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;
        isPrinterNameValid = ValidateUNCName( pszPrinterName + 1 );
    }
    else
    {
        if ( (pszServer = AllocNwSplStr( pszPrinterName )) == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;
        isPrinterNameValid = ValidateUNCName( pszPrinterName );
    }

    CharUpperW( pszServer );   // convert in place

    //
    // ValidatePrinterName
    //
    if (  ( !isPrinterNameValid )
       || ( (pszQueue = wcschr( pszServer + 2, L'\\')) == NULL )
       || ( pszQueue == (pszServer + 2) )
       || ( *(pszQueue + 1) == L'\0' )
       )
    {
        FreeNwSplStr( pszServer );
        return ERROR_INVALID_NAME;
    }

    *pszQueue = L'\0';   // put a '\0' in place of '\\'
    pszQueue++;          // Get past the '\0'

    if ( !(pSpool = AllocNwSplMem( LMEM_ZEROINIT, sizeof( NWSPOOL))))
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    //
    // Impersonate the client
    //
    if ((err = NwImpersonateClient()) != NO_ERROR)
    {
        goto ErrorExit;
    }
    fImpersonate = TRUE ;

    EnterCriticalSection( &NwPrintCritSec );

    if ((err = NwCreatePrinterEntry( pszServer, pszQueue, &pPrinter, &hServer)))
    {
        if ( !fKnownPrinter )
        {
            LeaveCriticalSection( &NwPrintCritSec );
            goto ErrorExit;
        }
    }

    //
    // Construct the print queue context handle to give back to the caller
    //
    pSpool->nSignature  = NW_SIGNATURE;
    pSpool->errOpenPrinter = err;

    pSpool->hServer = hServer;
    pSpool->nStatus     = 0;
    pSpool->nJobNumber  = 0;
    pSpool->hChangeEvent= NULL;
    pSpool->nWaitFlags  = 0;
    pSpool->nChangeFlags= 0;

    if ( !err )
    {
        pSpool->pPrinter    = pPrinter;
        pSpool->pNextSpool  = pPrinter->pSpoolList;
        pPrinter->pSpoolList= pSpool;
    }
    else
    {
        pSpool->pPrinter    = NULL;
        pSpool->pNextSpool  = NULL;
    }

    // We know about this printer before but failed to retrieve
    // it this time. Clean up the error and return successfully.
    // The error code is stored in the handle above which
    // will be returned on subsequent calls using this
    // dummy handle.
    err = NO_ERROR;

    LeaveCriticalSection( &NwPrintCritSec );

ErrorExit:

    if (fImpersonate)
        (void) NwRevertToSelf() ;

    if ( err )
    {
        if ( pSpool )
            FreeNwSplMem( pSpool, sizeof( NWSPOOL) );
    }
    else
    {
        *phPrinter = (NWWKSTA_PRINTER_CONTEXT) pSpool;
    }

    //
    // Free up all allocated memories
    //
    *(pszServer + wcslen( pszServer)) = L'\\';
    FreeNwSplStr( pszServer );

    return err;

}



DWORD
NwrClosePrinter(
    IN OUT LPNWWKSTA_PRINTER_CONTEXT phPrinter
)
/*++

Routine Description:

    This routine closes the given printer object.

Arguments:

    phPrinter -  Handle of the printer object

Return Value:

--*/
{
    PNWSPOOL pSpool = (PNWSPOOL) *phPrinter;
    PNWPRINTER pPrinter;
    PNWSPOOL pCur, pPrev = NULL;


    if ( !pSpool || ( pSpool->nSignature != NW_SIGNATURE ))
        return ERROR_INVALID_HANDLE;

    //
    // If OpenPrinter failed, then this is a dummy handle.
    // We just need to free up the memory.
    //
    if ( pSpool->errOpenPrinter )
    {
        //
        // invalidate the signature, but leave a recognizable value
        //
        pSpool->nSignature += 1 ;
        FreeNwSplMem( pSpool, sizeof( NWSPOOL) );
        *phPrinter = NULL;
        return NO_ERROR;
    }

    pPrinter = pSpool->pPrinter;
    ASSERT( pPrinter );

    //
    // Call EndDocPrinter if the user has not already done so
    //
    if ( pSpool->nStatus == SPOOL_STATUS_STARTDOC )
    {
        (void) NwrEndDocPrinter( *phPrinter );
    }
    else if ( pSpool->nStatus == SPOOL_STATUS_ADDJOB )
    {
        (void) NwrScheduleJob( *phPrinter, pSpool->nJobNumber );
    }

    if ( pSpool->hChangeEvent )
        CloseHandle( pSpool->hChangeEvent );

    pSpool->hChangeEvent = NULL;
    pSpool->nChangeFlags = 0;
    (VOID) NtClose( pSpool->hServer );


    EnterCriticalSection( &NwPrintCritSec );

    for ( pCur = pPrinter->pSpoolList; pCur;
          pPrev = pCur, pCur = pCur->pNextSpool )
    {
        if ( pCur == pSpool )
        {
            if ( pPrev )
                pPrev->pNextSpool = pCur->pNextSpool;
            else
                pPrinter->pSpoolList = pCur->pNextSpool;
            break;
        }

    }

    ASSERT( pCur );

    if ( pPrinter->pSpoolList == NULL )
    {
#if DBG
        IF_DEBUG(PRINT)
        {
            KdPrint(("*************DELETED PRINTER ENTRY: %ws\\%ws\n\n",
                    pPrinter->pszServer, pPrinter->pszQueue ));
        }
#endif

        NwRemovePrinterEntry( pPrinter );
    }

    LeaveCriticalSection( &NwPrintCritSec );

    //
    // invalidate the signature, but leave a recognizable value
    //
    pSpool->nSignature += 1 ;

    pSpool->pNextSpool = NULL;
    pSpool->pPrinter = NULL;

    //
    // Free all memory associated with the context handle
    //
    FreeNwSplMem( pSpool, sizeof( NWSPOOL) );

    //
    // indicate to RPC we are done
    //
    *phPrinter = NULL;

    return NO_ERROR;
}



DWORD
NwrGetPrinter(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter,
    IN DWORD dwLevel,
    IN OUT LPBYTE pbPrinter,
    IN DWORD cbBuf,
    OUT LPDWORD pcbNeeded
)
/*++

Routine Description:

    The routine retrieves information about the given printer.

Arguments:

    hPrinter  -  Handle of the printer
    dwLevel   -  Specifies the level of the structure to which pbPrinter points.
    pbPrinter -  Points to a buffer that receives the PRINTER_INFO object.
    cbBuf     -  Size, in bytes of the array pbPrinter points to.
    pcbNeeded -  Points to a value which specifies the number of bytes copied
                 if the function succeeds or the number of bytes required if
                 cbBuf was too small.

Return Value:

--*/
{
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;
    PNWPRINTER pPrinter;

    LPBYTE pbEnd = pbPrinter + cbBuf;
    BOOL   fFitInBuffer;
    DWORD_PTR  *pOffsets;

    if ( !pSpool || pSpool->nSignature != NW_SIGNATURE )
    {
        return ERROR_INVALID_HANDLE;
    }
    else if ( pSpool->errOpenPrinter )
    {
        return pSpool->errOpenPrinter;
    }
    else if ( ( dwLevel != 1 ) && ( dwLevel != 2 ) && ( dwLevel != 3 ))
    {
        return ERROR_INVALID_LEVEL;
    }

    if ( !pbPrinter )
    {
        if ( cbBuf == 0 )
        {
            //
            // Calculate size needed
            //
            pPrinter = pSpool->pPrinter;
            ASSERT( pPrinter );

            if ( dwLevel == 1 )
            {
                *pcbNeeded = sizeof( PRINTER_INFO_1W ) +
                             (   wcslen( pPrinter->pszServer )
                               + wcslen( pPrinter->pszQueue ) + 2 ) * sizeof( WCHAR );
            }
            else if ( dwLevel == 2 )
            {
                *pcbNeeded = sizeof( PRINTER_INFO_2W ) +
                             ( 2*wcslen( pPrinter->pszServer ) +
                               2*wcslen( pPrinter->pszQueue ) + 4 ) * sizeof( WCHAR );
            }
            else  // Level == 3
            {
                PRINTER_INFO_3 *pPrinterInfo3 = (PRINTER_INFO_3 *) pbPrinter;

                *pcbNeeded = sizeof( PRINTER_INFO_3 );
            }
            return ERROR_INSUFFICIENT_BUFFER;
        }
        else
            return ERROR_INVALID_PARAMETER;
    }

    pPrinter = pSpool->pPrinter;
    ASSERT( pPrinter );

    if ( dwLevel == 1 )
    {
        PRINTER_INFO_1W *pPrinterInfo1 = (PRINTER_INFO_1W *) pbPrinter;
        LPBYTE pbFixedEnd = pbPrinter + sizeof( PRINTER_INFO_1W );

        //
        // Calculate size needed
        //
        *pcbNeeded = sizeof( PRINTER_INFO_1W ) +
                     (   wcslen( pPrinter->pszServer )
                       + wcslen( pPrinter->pszQueue ) + 2 ) * sizeof( WCHAR );

        if ( cbBuf < *pcbNeeded )
            return ERROR_INSUFFICIENT_BUFFER;

        pOffsets = PrinterInfo1Offsets;

        //
        // Fill in the structure
        //
        pPrinterInfo1->Flags    = PRINTER_ENUM_REMOTE | PRINTER_ENUM_NAME;
        pPrinterInfo1->pComment = NULL;

        fFitInBuffer = NwlibCopyStringToBuffer(
                           pPrinter->pszServer,
                           wcslen( pPrinter->pszServer ),
                           (LPWSTR) pbFixedEnd,
                           (LPWSTR *) &pbEnd,
                           &pPrinterInfo1->pDescription );

        ASSERT( fFitInBuffer );

        fFitInBuffer = NwlibCopyStringToBuffer(
                           pPrinter->pszQueue,
                           wcslen( pPrinter->pszQueue ),
                           (LPWSTR) pbFixedEnd,
                           (LPWSTR *) &pbEnd,
                           &pPrinterInfo1->pName );

        ASSERT( fFitInBuffer );

    }
    else if ( dwLevel == 2 )
    {
        DWORD  err;
        BYTE   nQueueStatus;
        BYTE   nNumJobs;
        PRINTER_INFO_2W *pPrinterInfo2 = (PRINTER_INFO_2W *) pbPrinter;
        LPBYTE pbFixedEnd = pbPrinter + sizeof( PRINTER_INFO_2W );

        //
        // Check if the buffer is big enough to hold all the data
        //

        *pcbNeeded = sizeof( PRINTER_INFO_2W ) +
                     ( 2*wcslen( pPrinter->pszServer ) +
                       2*wcslen( pPrinter->pszQueue ) + 4 ) * sizeof( WCHAR );

        if ( cbBuf < *pcbNeeded )
            return ERROR_INSUFFICIENT_BUFFER;

        pOffsets = PrinterInfo2Offsets;

        err = NwReadQueueCurrentStatus( pSpool->hServer,
                                        pPrinter->nQueueId,
                                        &nQueueStatus,
                                        &nNumJobs );

        if ( err )
            return err;

        pPrinterInfo2->Status = (nQueueStatus & 0x05)? PRINTER_STATUS_PAUSED
                                                     : 0;
        pPrinterInfo2->cJobs  = nNumJobs;

        fFitInBuffer = NwlibCopyStringToBuffer(
                           pPrinter->pszServer,
                           wcslen( pPrinter->pszServer ),
                           (LPCWSTR) pbFixedEnd,
                           (LPWSTR *) &pbEnd,
                           &pPrinterInfo2->pServerName );

        ASSERT( fFitInBuffer );

        pbEnd -= ( wcslen( pPrinter->pszQueue) + 1 ) * sizeof( WCHAR );
        wcscpy( (LPWSTR) pbEnd, pPrinter->pszQueue );
        pbEnd -= ( wcslen( pPrinter->pszServer) + 1 ) * sizeof( WCHAR );
        wcscpy( (LPWSTR) pbEnd, pPrinter->pszServer );
        *(pbEnd + wcslen( pPrinter->pszServer )*sizeof(WCHAR))= L'\\';
        pPrinterInfo2->pPrinterName = (LPWSTR) pbEnd;

        fFitInBuffer = NwlibCopyStringToBuffer(
                           pPrinter->pszQueue,
                           wcslen( pPrinter->pszQueue ),
                           (LPCWSTR) pbFixedEnd,
                           (LPWSTR *) &pbEnd,
                           &pPrinterInfo2->pShareName );

        ASSERT( fFitInBuffer );

        pPrinterInfo2->pPortName = NULL;
        pPrinterInfo2->pDriverName = NULL;
        pPrinterInfo2->pComment = NULL;
        pPrinterInfo2->pLocation = NULL;
        pPrinterInfo2->pDevMode = NULL;
        pPrinterInfo2->pSepFile = NULL;
        pPrinterInfo2->pPrintProcessor = NULL;
        pPrinterInfo2->pDatatype = NULL;
        pPrinterInfo2->pParameters = NULL;
        pPrinterInfo2->pSecurityDescriptor = NULL;
        pPrinterInfo2->Attributes = PRINTER_ATTRIBUTE_QUEUED;
        pPrinterInfo2->Priority = 0;
        pPrinterInfo2->DefaultPriority = 0;
        pPrinterInfo2->StartTime = 0;
        pPrinterInfo2->UntilTime = 0;
        pPrinterInfo2->AveragePPM = 0;
    }
    else  // Level == 3
    {
        PRINTER_INFO_3 *pPrinterInfo3 = (PRINTER_INFO_3 *) pbPrinter;

        *pcbNeeded = sizeof( PRINTER_INFO_3 );

        if ( cbBuf < *pcbNeeded )
            return ERROR_INSUFFICIENT_BUFFER;

        pOffsets = PrinterInfo3Offsets;
        pPrinterInfo3->pSecurityDescriptor = NULL;
    }

    MarshallDownStructure( pbPrinter, pOffsets, pbPrinter );
    return NO_ERROR;
}



DWORD
NwrSetPrinter(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter,
    IN DWORD  dwCommand
)
/*++

Routine Description:

    The routine sets information about the given printer.

Arguments:

    hPrinter  -  Handle of the printer
    dwCommand -  Specifies the new printer state

Return Value:

--*/
{
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;
    DWORD err = NO_ERROR;
    PNWPRINTER pPrinter;

    if ( !pSpool || pSpool->nSignature != NW_SIGNATURE )
    {
        return ERROR_INVALID_HANDLE;
    }
    else if ( pSpool->errOpenPrinter )
    {
        return pSpool->errOpenPrinter;
    }

    pPrinter = pSpool->pPrinter;
    ASSERT( pPrinter );

    switch ( dwCommand )
    {
        case PRINTER_CONTROL_PAUSE:
        case PRINTER_CONTROL_RESUME:
        {
            BYTE nQueueStatus = 0;
            BYTE nNumJobs;

            //
            // Get the original queue status so that we don't overwrite
            // some of the bits.
            //
            err = NwReadQueueCurrentStatus( pSpool->hServer,
                                            pPrinter->nQueueId,
                                            &nQueueStatus,
                                            &nNumJobs );

            if ( !err )
            {
                //
                // Clear the pause bits, and leave the rest alone.
                //
                nQueueStatus &= ~0x05;
            }

            if ( dwCommand == PRINTER_CONTROL_PAUSE )
            {
                nQueueStatus |= 0x04;
            }

            err = NwSetQueueCurrentStatus( pSpool->hServer,
                                           pPrinter->nQueueId,
                                           nQueueStatus );
            if ( !err )
                NwSetPrinterChange( pSpool, PRINTER_CHANGE_SET_PRINTER );
            break;
        }

        case PRINTER_CONTROL_PURGE:

            err = NwRemoveAllJobsFromQueue( pSpool->hServer,
                                            pPrinter->nQueueId );
            if ( !err )
                NwSetPrinterChange( pSpool, PRINTER_CHANGE_SET_PRINTER |
                                            PRINTER_CHANGE_DELETE_JOB );
            break;

        default:
            //
            // dwCommand is 0 so that means
            // some properties of the printer has changed.
            // We will ignore the properties that
            // are being modified since most properties
            // are stored in the registry by spooler.
            // All we need to do is to signal WaitForPrinterChange to
            // return so that print manager will refresh its data.
            //

            ASSERT( dwCommand == 0 );
            NwSetPrinterChange( pSpool, PRINTER_CHANGE_SET_PRINTER );
            break;
    }

    return err;
}



DWORD
NwrEnumPrinters(
    IN LPWSTR Reserved,
    IN LPWSTR pszName,
    IN OUT LPBYTE pbPrinter,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
)
/*++

Routine Description:

    This routine enumerates the available providers, servers, printers
    depending on the given pszName.

Arguments:

    Reserved   -  Unused
    pszName    -  The name of the container object
    pbPrinter  -  Points to the array to receive the PRINTER_INFO objects
    cbBuf      -  Size, in bytes of pbPrinter
    pcbNeeded  -  Count of bytes needed
    pcReturned -  Count of PRINTER_INFO objects

Return Value:

--*/
{
    PRINTER_INFO_1W *pPrinterInfo1 = (PRINTER_INFO_1W *) pbPrinter;

    *pcbNeeded = 0;
    *pcReturned = 0;

    if ( ( cbBuf != 0 ) && !pbPrinter )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( !pszName )   // Enumerate the provider name
    {
        BOOL   fFitInBuffer;
        LPBYTE pbFixedEnd = pbPrinter + sizeof( PRINTER_INFO_1W );
        LPBYTE pbEnd = pbPrinter + cbBuf;

        *pcbNeeded = sizeof( PRINTER_INFO_1W ) +
                     ( 2 * wcslen( NwProviderName ) +
                       + 2) * sizeof(WCHAR);

        if ( *pcbNeeded > cbBuf )
            return ERROR_INSUFFICIENT_BUFFER;

        pPrinterInfo1->Flags = PRINTER_ENUM_ICON1 |
                               PRINTER_ENUM_CONTAINER |
                               PRINTER_ENUM_EXPAND;
        pPrinterInfo1->pComment = NULL;

        fFitInBuffer = NwlibCopyStringToBuffer(
                           NwProviderName,
                           wcslen( NwProviderName ),
                           (LPWSTR) pbFixedEnd,
                           (LPWSTR *) &pbEnd,
                           &pPrinterInfo1->pDescription );

        ASSERT( fFitInBuffer );

        fFitInBuffer = NwlibCopyStringToBuffer(
                           NwProviderName,
                           wcslen( NwProviderName ),
                           (LPWSTR) pbFixedEnd,
                           (LPWSTR *) &pbEnd,
                           &pPrinterInfo1->pName );

        ASSERT( fFitInBuffer );

        MarshallDownStructure( pbPrinter, PrinterInfo1Offsets, pbPrinter );
        *pcReturned = 1;
    }

    else if ( pszName && *pszName )
    {
        DWORD  err;
        LPWSTR pszFullName;
        LPWSTR pszServer;
        NWWKSTA_CONTEXT_HANDLE handle;
        BYTE bTemp = 0;
        LPBYTE pbTempBuf = pbPrinter ? pbPrinter : &bTemp;

        if ( (pszFullName = LocalAlloc( 0, (wcslen( pszName ) + 1) *
                                           sizeof(WCHAR) ) ) == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;

        wcscpy( pszFullName, pszName );
        pszServer = wcschr( pszFullName, L'!');

        if ( pszServer )
            *pszServer++ = 0;

        if ( lstrcmpiW( pszFullName, NwProviderName ) )
        {
            LocalFree( pszFullName );
            return ERROR_INVALID_NAME;
        }

        if ( !pszServer )  // Enumerate servers
        {
            LocalFree( pszFullName );

            err = NwOpenEnumPrintServers( &handle );

            if ( err != NO_ERROR )
            {
                return err;
            }

            err = NwrEnum( handle,
                           (DWORD_PTR) -1,
                           pbTempBuf,
                           cbBuf,
                           pcbNeeded,
                           pcReturned );

            if ( err != NO_ERROR )
            {
                NwrCloseEnum( &handle );
                return err;
            }

            err = NwrCloseEnum( &handle );

            if ( err != NO_ERROR )
            {
                return err;
            }
        }
        else  // Enumerate NDS sub-trees or print queues
        {
            LPWSTR tempStrPtr = pszServer;
            DWORD  dwClassType = 0;

            if ( tempStrPtr[0] == L'\\' &&
                 tempStrPtr[1] == L'\\' &&
                 tempStrPtr[2] == L' ' )
                 tempStrPtr = &tempStrPtr[1];

            err = NwrOpenEnumNdsSubTrees_Print( NULL, tempStrPtr, &dwClassType, &handle );

            if ( err == ERROR_NETWORK_ACCESS_DENIED && dwClassType == CLASS_TYPE_NCP_SERVER )
            {
                // An error code from the above NwOpenEnumNdsSubTrees could have
                // failed because the object was a server, which cannot be enumerated
                // with the NDS tree APIs. If so we try to get the print queues with the
                // regular NW APIs.

                tempStrPtr = NwGetUncObjectName( tempStrPtr );

                err = NwOpenEnumPrintQueues( tempStrPtr, &handle );

                if ( err != NO_ERROR )
                {
                    LocalFree( pszFullName );
                    return err;
                }
            }

            if ( err != NO_ERROR )
            {
                // An error code from the above NwOpenEnumNdsSubTrees could have
                // failed because the object was not a part of an NDS tree.
                // So we try to get the print queues with the regular NW APIs.

                err = NwOpenEnumPrintQueues( tempStrPtr, &handle );

                if ( err != NO_ERROR )
                {
                    LocalFree( pszFullName );
                    return err;
                }
            }

            //
            // Get rid of the allocated temp buffer that we've been using
            // indirectly through tempStrPtr and pszServer.
            //
            LocalFree( pszFullName );

            err = NwrEnum( handle,
                           0xFFFFFFFF,
                           pbTempBuf,
                           cbBuf,
                           pcbNeeded,
                           pcReturned );

            if ( err != NO_ERROR )
            {
                NwrCloseEnum( &handle );
                return err;
            }

            err = NwrCloseEnum( &handle );

            if ( err != NO_ERROR )
            {
                return err;
            }
        }
    }

    return NO_ERROR;
}


DWORD
NwrStartDocPrinter(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter,
    IN LPWSTR pszDocument,
    IN LPWSTR pszUser,
    IN DWORD  PrintOptions,                 //Multi-User Addition
    IN DWORD  fGateway
)
/*++

Routine Description:

    This routine informs the print spooler that a document is to be spooled
    for printing.

Arguments:

    hPrinter    -  Handle of the printer
    pszDocument -  Name of the document to be printed
    pszUser     -  Name of the user submitting the print job
    fGateway    -  TRUE if it is gateway printing

Return Value:

--*/
{
    DWORD err;
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;

    if ( !pSpool || (pSpool->nSignature != NW_SIGNATURE) )
    {
        err = ERROR_INVALID_HANDLE;
    }
    else if ( pSpool->errOpenPrinter )
    {
        err = pSpool->errOpenPrinter;
    }
    else if ( pSpool->nStatus != 0 )
    {
        err = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Get pSpool->nJobNumber from CreateQueueJobAndFile
        //

        PNWPRINTER pPrinter = pSpool->pPrinter;
        WORD  nJobNumber = 0;

        ASSERT( pPrinter );
        err = NwCreateQueueJobAndFile( pSpool->hServer,
                                       pPrinter->nQueueId,
                                       pszDocument,
                                       pszUser,
                                       fGateway,
                                       PrintOptions,           //Multi-User addition
                                       pPrinter->pszQueue,
                                       &nJobNumber );

        if ( !err )
        {
            pSpool->nJobNumber = nJobNumber;
            pSpool->nStatus = SPOOL_STATUS_STARTDOC;
            NwSetPrinterChange( pSpool, PRINTER_CHANGE_ADD_JOB |
                                        PRINTER_CHANGE_SET_PRINTER );
        }
    }

    return err;
}



DWORD
NwrWritePrinter(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter,
    IN LPBYTE pBuf,
    IN DWORD cbBuf,
    OUT LPDWORD pcbWritten
)
/*++

Routine Description:

    This routine informs the print spooler that the specified data should be
    written to the given printer.

Arguments:

    hPrinter   -  Handle of the printer object
    pBuf       -  Address of array that contains printer data
    cbBuf      -  Size, in bytes of pBuf
    pcbWritten -  Receives the number of bytes actually written to the printer

Return Value:

--*/
{
    DWORD err = NO_ERROR;
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;

    if ( !pSpool || ( pSpool->nSignature != NW_SIGNATURE))
    {
        err = ERROR_INVALID_HANDLE;
    }
    else if ( pSpool->errOpenPrinter )
    {
        err = pSpool->errOpenPrinter;
    }
    else if ( pSpool->nStatus != SPOOL_STATUS_STARTDOC )
    {
        err = ERROR_INVALID_PARAMETER;
    }
    else
    {
        NTSTATUS ntstatus;
        IO_STATUS_BLOCK IoStatusBlock;
        PNWPRINTER pPrinter = pSpool->pPrinter;

        ASSERT( pPrinter );
        ntstatus = NtWriteFile( pSpool->hServer,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                pBuf,
                                cbBuf,
                                NULL,
                                NULL );

        if ( NT_SUCCESS(ntstatus))
            ntstatus = IoStatusBlock.Status;

        if ( NT_SUCCESS(ntstatus) )
        {
            *pcbWritten = (DWORD) IoStatusBlock.Information;
            NwSetPrinterChange( pSpool, PRINTER_CHANGE_WRITE_JOB );
        }
        else
        {
            KdPrint(("NWWORKSTATION: NtWriteFile failed 0x%08lx\n", ntstatus));
            *pcbWritten = 0;
            err = RtlNtStatusToDosError( ntstatus );
        }
    }

    return err;
}



DWORD
NwrAbortPrinter(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter
)
/*++

Routine Description:

    This routine deletes a printer's spool file if the printer is configured
    for spooling.

Arguments:

    hPrinter - Handle of the printer object

Return Value:

--*/
{
    DWORD err;
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;

    if ( !pSpool || ( pSpool->nSignature != NW_SIGNATURE ))
    {
        err = ERROR_INVALID_HANDLE;
    }
    else if ( pSpool->errOpenPrinter )
    {
        err = pSpool->errOpenPrinter;
    }
    else if ( pSpool->nStatus != SPOOL_STATUS_STARTDOC )
    {
        err = ERROR_INVALID_PARAMETER;
    }
    else
    {
        PNWPRINTER pPrinter = pSpool->pPrinter;

        ASSERT( pPrinter );
        err = NwRemoveJobFromQueue( pSpool->hServer,
                                    pPrinter->nQueueId,
                                    (WORD) pSpool->nJobNumber );

        if ( !err )
        {
            pSpool->nJobNumber = 0;
            pSpool->nStatus = SPOOL_STATUS_ABORT;
            NwSetPrinterChange( pSpool, PRINTER_CHANGE_SET_JOB );
        }
    }

    return err;
}



DWORD
NwrEndDocPrinter(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter
)
/*++

Routine Description:

    This routine ends the print job for the given printer.

Arguments:

    hPrinter -  Handle of the printer object

Return Value:

--*/
{
    DWORD err = NO_ERROR;
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;

    if ( !pSpool || ( pSpool->nSignature != NW_SIGNATURE ))
    {
        err = ERROR_INVALID_HANDLE;
    }
    else if ( pSpool->errOpenPrinter )
    {
        err = pSpool->errOpenPrinter;
    }
    else if (  ( pSpool->nStatus != SPOOL_STATUS_STARTDOC )
            && ( pSpool->nStatus != SPOOL_STATUS_ABORT )
            )
    {
        err = ERROR_INVALID_PARAMETER;
    }
    else
    {
        PNWPRINTER pPrinter = pSpool->pPrinter;

        ASSERT( pPrinter );

        if ( pSpool->nStatus == SPOOL_STATUS_STARTDOC )
        {
             err = NwCloseFileAndStartQueueJob( pSpool->hServer,
                                                pPrinter->nQueueId,
                                                (WORD) pSpool->nJobNumber );

             if ( !err )
                 NwSetPrinterChange( pSpool, PRINTER_CHANGE_SET_JOB );
        }

        if ( !err )
        {
            pSpool->nJobNumber = 0;
            pSpool->nStatus = 0;
        }
    }

    return err;
}



DWORD
NwrGetJob(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter,
    IN DWORD dwJobId,
    IN DWORD dwLevel,
    IN OUT LPBYTE pbJob,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded
)
/*++

Routine Description:


Arguments:

    hPrinter  -  Handle of the printer
    dwJobId   -
    dwLevel   -
    pbJob     -
    cbBuf     -
    pcbNeeded -

Return Value:

--*/
{
    DWORD err;
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;

    if ( !pSpool || pSpool->nSignature != NW_SIGNATURE )
    {
        err = ERROR_INVALID_HANDLE;
    }
    // allow NULL for bpJob if cbBuf is 0.
    // Relies on NwGetQueueJobInfo to properly handle NULL pointer in request to fill pcbNeeded
    else if ( (cbBuf != 0) && ( !pbJob ) )
    {
        err = ERROR_INVALID_PARAMETER;
    }
    else if ( pSpool->errOpenPrinter )
    {
        err = pSpool->errOpenPrinter;
    }
    else if (( dwLevel != 1 ) && ( dwLevel != 2 ))
    {
        err = ERROR_INVALID_LEVEL;
    }
    else
    {
        DWORD  nPrinterLen;
        LPWSTR pszPrinter;
        LPBYTE FixedPortion = pbJob;
        LPWSTR EndOfVariableData = (LPWSTR) (pbJob + cbBuf);
        PNWPRINTER pPrinter = pSpool->pPrinter;

        ASSERT( pPrinter );

        pszPrinter = AllocNwSplMem( LMEM_ZEROINIT,
                         nPrinterLen = ( wcslen( pPrinter->pszServer) +
                         wcslen( pPrinter->pszQueue) + 2) * sizeof(WCHAR));

        if ( pszPrinter == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;

        wcscpy( pszPrinter, pPrinter->pszServer );
        wcscat( pszPrinter, L"\\" );
        wcscat( pszPrinter, pPrinter->pszQueue );

        *pcbNeeded = 0;
        err = NwGetQueueJobInfo( pSpool->hServer,
                                 pPrinter->nQueueId,
                                 (WORD) dwJobId,
                                 pszPrinter,
                                 dwLevel,
                                 &FixedPortion,
                                 &EndOfVariableData,
                                 pcbNeeded );

        FreeNwSplMem( pszPrinter, nPrinterLen );

        if ( !err )
        {
            switch( dwLevel )
            {
                case 1:
                    MarshallDownStructure( pbJob, JobInfo1Offsets, pbJob );
                    break;

                case 2:
                    MarshallDownStructure( pbJob, JobInfo2Offsets, pbJob );
                    break;

                default:
                    ASSERT( FALSE );
                    break;
            }
        }

    }

    return err;
}



DWORD
NwrEnumJobs(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter,
    IN DWORD dwFirstJob,
    IN DWORD dwNoJobs,
    IN DWORD dwLevel,
    IN OUT LPBYTE pbJob,
    IN DWORD cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
)
/*++

Routine Description:


Arguments:

    hPrinter    -  Handle of the printer
    dwFirstJob  -
    dwNoJobs    -
    dwLevel     -
    pbJob       -
    cbBuf       -
    pcbNeeded   -
    pcReturned  -

Return Value:

--*/
{
    DWORD err;
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;


    if ( !pSpool || pSpool->nSignature != NW_SIGNATURE )
    {
        err = ERROR_INVALID_HANDLE;
    }
    // allow NULL for bpJob if cbBuf is 0.
    // Relies on NwGetQueueJobInfo to properly handle NULL pointer in request to fill pcbNeeded
    else if ( (cbBuf != 0) && ( !pbJob ) )
    {
        err = ERROR_INVALID_PARAMETER;
    }
    else if ( pSpool->errOpenPrinter )
    {
        err = pSpool->errOpenPrinter;
    }
    else if ( ( dwLevel != 1 ) && ( dwLevel != 2 ) )
    {
        err = ERROR_INVALID_LEVEL;
    }
    else
    {
        PNWPRINTER pPrinter = pSpool->pPrinter;
        LPWSTR pszPrinter;
        DWORD nPrinterLen;

        ASSERT( pPrinter );
        pszPrinter = AllocNwSplMem( LMEM_ZEROINIT,
                         nPrinterLen = ( wcslen( pPrinter->pszServer ) +
                         wcslen( pPrinter->pszQueue) + 2) * sizeof(WCHAR));

        if ( pszPrinter == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;

        wcscpy( pszPrinter, pPrinter->pszServer );
        wcscat( pszPrinter, L"\\" );
        wcscat( pszPrinter, pPrinter->pszQueue );

        err = NwGetQueueJobs( pSpool->hServer,
                              pPrinter->nQueueId,
                              pszPrinter,
                              dwFirstJob,
                              dwNoJobs,
                              dwLevel,
                              pbJob,
                              cbBuf,
                              pcbNeeded,
                              pcReturned );

        FreeNwSplMem( pszPrinter, nPrinterLen );

        if ( !err )
        {
            DWORD_PTR *pOffsets;
            DWORD cbStruct;
            DWORD cReturned = *pcReturned;
            LPBYTE pbBuffer = pbJob;

            switch( dwLevel )
            {
                case 1:
                    pOffsets = JobInfo1Offsets;
                    cbStruct = sizeof( JOB_INFO_1W );
                    break;

                case 2:
                    pOffsets = JobInfo2Offsets;
                    cbStruct = sizeof( JOB_INFO_2W );
                    break;

                default:
                    ASSERT( FALSE );
                    break;
            }

            while ( cReturned-- )
            {
                MarshallDownStructure( pbBuffer, pOffsets, pbJob );
                pbBuffer += cbStruct;
            }
        }
    }

    return err;
}



DWORD
NwrSetJob(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter,
    IN DWORD  dwJobId,
    IN DWORD  dwLevel,
    IN PNW_JOB_INFO  pNwJobInfo,
    IN DWORD  dwCommand
)
/*++

Routine Description:


Arguments:

    hPrinter  -  Handle of the printer
    dwJobId   -
    dwLevel   -
    pNwJobInfo-
    dwCommand -

Return Value:

--*/
{
    DWORD err = NO_ERROR;
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;
    PNWPRINTER pPrinter;

    if ( !pSpool || pSpool->nSignature != NW_SIGNATURE )
    {
        err = ERROR_INVALID_HANDLE;
    }
    else if ( ( dwLevel != 0 ) && ( !pNwJobInfo ) )
    {
        err = ERROR_INVALID_PARAMETER;
    }
    else if ( pSpool->errOpenPrinter )
    {
        err = pSpool->errOpenPrinter;
    }
    else if ( ( dwLevel != 0 ) && ( dwLevel != 1 ) && ( dwLevel != 2 ) )
    {
        err = ERROR_INVALID_LEVEL;
    }

    if ( err )
        return err;

    pPrinter = pSpool->pPrinter;
    ASSERT( pPrinter );

    if ( ( dwCommand == JOB_CONTROL_CANCEL ) ||
         ( dwCommand == JOB_CONTROL_DELETE ) )
    {
        err = NwRemoveJobFromQueue( pSpool->hServer,
                                    pPrinter->nQueueId,
                                    (WORD) dwJobId );

        if ( !err )
            NwSetPrinterChange( pSpool, PRINTER_CHANGE_DELETE_JOB |
                                        PRINTER_CHANGE_SET_PRINTER );

        // Since the job is removed, we don't need to change other
        // information about it.
    }
    else
    {
        if ( dwLevel != 0 )
        {
            if ( pNwJobInfo->nPosition != JOB_POSITION_UNSPECIFIED )
            {
                err = NwChangeQueueJobPosition( pSpool->hServer,
                                                pPrinter->nQueueId,
                                                (WORD) dwJobId,
                                                (BYTE) pNwJobInfo->nPosition );
            }
        }

        if ( ( !err ) && ( dwCommand == JOB_CONTROL_RESTART ))
        {
            err = ERROR_NOT_SUPPORTED;
        }
        else if ( !err )
        {
            err = NwChangeQueueJobEntry( pSpool->hServer,
                                         pPrinter->nQueueId,
                                         (WORD) dwJobId,
                                         dwCommand,
                                         pNwJobInfo );
        }

        if ( !err )
            NwSetPrinterChange( pSpool, PRINTER_CHANGE_SET_JOB );
    }

    return err;
}



DWORD
NwrAddJob(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter,
    OUT LPADDJOB_INFO_1W pAddInfo1,
    IN DWORD cbBuf,
    OUT LPDWORD pcbNeeded
    )
/*++

Routine Description:


Arguments:

    hPrinter  - Handle of the printer.
    pAddInfo1 - Output buffer to hold ADDJOB_INFO_1W structure.
    cbBuf     - Output buffer size in bytes.
    pcbNeeded - Required output buffer size in bytes.

Return Value:

--*/
{
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;
    PNWPRINTER pPrinter;


    if ( !pSpool || ( pSpool->nSignature != NW_SIGNATURE )) {
        return ERROR_INVALID_HANDLE;
    }

    if ( pSpool->errOpenPrinter ) {
        return pSpool->errOpenPrinter;
    }

    if ( pSpool->nStatus != 0 )  {
        return ERROR_INVALID_PARAMETER;
    }

    pPrinter = pSpool->pPrinter;
    ASSERT( pPrinter );

    *pcbNeeded = sizeof(ADDJOB_INFO_1W) +
                 (wcslen(pPrinter->pszServer) +
                  wcslen(pPrinter->pszQueue) + 2) * sizeof(WCHAR);

    if (cbBuf < *pcbNeeded) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Write UNC path name into the output buffer.
    //
    //	dfergus 19 Apr 2001 - 348006
    //	DWORD cast
    pAddInfo1->Path = (LPWSTR) ((DWORD) pAddInfo1 + sizeof(ADDJOB_INFO_1W));
    //
    wcscpy(pAddInfo1->Path, pPrinter->pszServer);
    wcscat(pAddInfo1->Path, L"\\" );
    wcscat(pAddInfo1->Path, pPrinter->pszQueue);

    //
    // Return special job id value which the client (winspool.drv) looks
    // for and does an FSCTL call to our redirector to get the real
    // job id.  We cannot return a real job id at this point because
    // the CreateQueueJobAndFile NCP is not issue until the client opens
    // the UNC name we return in this API.
    //
    pAddInfo1->JobId = (DWORD) -1;

    //
    // Save context information
    //
    pSpool->nJobNumber = pAddInfo1->JobId;
    pSpool->nStatus = SPOOL_STATUS_ADDJOB;

#if DBG
    IF_DEBUG(PRINT) {
        KdPrint(("NWWORKSTATION: NwrAddJob Path=%ws, JobId=%lu, BytesNeeded=%lu\n",
                 pAddInfo1->Path, pAddInfo1->JobId, *pcbNeeded));
    }
#endif

    NwSetPrinterChange( pSpool, PRINTER_CHANGE_ADD_JOB |
                                PRINTER_CHANGE_SET_PRINTER );

    return NO_ERROR;
}



DWORD
NwrScheduleJob(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter,
    IN DWORD dwJobId
    )
/*++

Routine Description:


Arguments:

    hPrinter -  Handle of the printer
    dwJobId  -  Job identification number

Return Value:

--*/
{
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;
    PNWPRINTER pPrinter;


    if ( !pSpool || ( pSpool->nSignature != NW_SIGNATURE )) {
        return ERROR_INVALID_HANDLE;
    }

    if ( pSpool->errOpenPrinter ) {
        return pSpool->errOpenPrinter;
    }

    if (pSpool->nStatus != SPOOL_STATUS_ADDJOB) {
        return ERROR_INVALID_PARAMETER;
    }

    pPrinter = pSpool->pPrinter;
    ASSERT( pPrinter );

    pSpool->nJobNumber = 0;
    pSpool->nStatus = 0;

    NwSetPrinterChange( pSpool, PRINTER_CHANGE_SET_JOB );

    return NO_ERROR;
}



DWORD
NwrWaitForPrinterChange(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter,
    IN OUT LPDWORD pdwFlags
)
/*++

Routine Description:


Arguments:

    hPrinter -  Handle of the printer
    pdwFlags -

Return Value:

--*/
{
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;
    HANDLE hChangeEvent = NULL;
    DWORD  nRetVal;
    HANDLE ahWaitEvents[2];
    DWORD err = NO_ERROR;

    if ( !pSpool || ( pSpool->nSignature != NW_SIGNATURE ))
    {
        return ERROR_INVALID_HANDLE;
    }
    else if ( pSpool->errOpenPrinter )
    {
        return pSpool->errOpenPrinter;
    }
    else if ( pSpool->hChangeEvent )
    {
        return ERROR_ALREADY_WAITING;
    }
    else if ( !(*pdwFlags & PRINTER_CHANGE_VALID ))
    {
        return ERROR_INVALID_PARAMETER;
    }


    if ( pSpool->nChangeFlags & *pdwFlags )
    {
        //
        // There is a change since we last called
        //

        *pdwFlags &= pSpool->nChangeFlags;

        EnterCriticalSection( &NwPrintCritSec );
        pSpool->nChangeFlags = 0;
        LeaveCriticalSection( &NwPrintCritSec );

        return NO_ERROR;
    }

    hChangeEvent = CreateEvent( NULL,
                                FALSE,   // automatic reset
                                FALSE,   // initial state not signalled
                                NULL );

    if ( !hChangeEvent )
    {
        KdPrint(("WaitForPrinterChange: CreateEvent failed with error %d\n",
                 GetLastError() ));
        return GetLastError();
    }


    pSpool->nWaitFlags = *pdwFlags;

    EnterCriticalSection( &NwPrintCritSec );
    pSpool->hChangeEvent = hChangeEvent;
    pSpool->nChangeFlags = 0;
    LeaveCriticalSection( &NwPrintCritSec );

    ahWaitEvents[0] = pSpool->hChangeEvent;
    ahWaitEvents[1] = NwDoneEvent;

    nRetVal = WaitForMultipleObjects( 2,        // Two events to wait for
                                      ahWaitEvents,
                                      FALSE,    // Wait for one to signal
                                      NwTimeOutValue );

    switch ( nRetVal )
    {
        case WAIT_FAILED:
            err = GetLastError();
            break;

        case WAIT_TIMEOUT:
        case WAIT_OBJECT_0 + 1:    // treats service stopping as timeout
            *pdwFlags |= PRINTER_CHANGE_TIMEOUT;
            break;

        case WAIT_OBJECT_0:
            *pdwFlags &= pSpool->nChangeFlags;
            break;

        default:
            KdPrint(("WaitForPrinterChange: WaitForMultipleObjects returned with %d\n", nRetVal ));
            *pdwFlags |= PRINTER_CHANGE_TIMEOUT;
            break;
    }

    if ( ( !err ) && ( nRetVal != WAIT_OBJECT_0 + 1 ) )
    {
        pSpool->nWaitFlags = 0;

        EnterCriticalSection( &NwPrintCritSec );
        pSpool->nChangeFlags = 0;
        pSpool->hChangeEvent = NULL;
        LeaveCriticalSection( &NwPrintCritSec );
    }

    if ( !CloseHandle( hChangeEvent ) )
    {
        KdPrint(("WaitForPrinterChange: CloseHandle failed with error %d\n",
                  GetLastError()));
    }

    return err;
}



VOID
NwSetPrinterChange(
    PNWSPOOL pSpool,
    DWORD nFlags
)
{
    PNWPRINTER pPrinter = pSpool->pPrinter;
    PNWSPOOL pCurSpool = pSpool;

    EnterCriticalSection( &NwPrintCritSec );

    do {

        if ( pCurSpool->nWaitFlags & nFlags )
        {
            pCurSpool->nChangeFlags |= nFlags;

            if ( pCurSpool->hChangeEvent )
            {
                SetEvent( pCurSpool->hChangeEvent );
                pCurSpool->hChangeEvent = NULL;
            }
        }

        pCurSpool = pCurSpool->pNextSpool;
        if ( pCurSpool == NULL )
            pCurSpool = pPrinter->pSpoolList;

    } while ( pCurSpool && (pCurSpool != pSpool) );

    LeaveCriticalSection( &NwPrintCritSec );
}



PNWPRINTER
NwFindPrinterEntry(
    IN LPWSTR pszServer,
    IN LPWSTR pszQueue
)
{
    PNWPRINTER pPrinter = NULL;

    //
    // Check to see if we already have the given printer in our printer
    // link list. If yes, return the printer.
    //

    for ( pPrinter = NwPrinterList; pPrinter; pPrinter = pPrinter->pNextPrinter)
    {
        if (  ( lstrcmpiW( pPrinter->pszServer, pszServer ) == 0 )
           && ( lstrcmpiW( pPrinter->pszQueue, pszQueue ) == 0 )
           )
        {
            return pPrinter;
        }
    }

    return NULL;
}



DWORD
NwCreatePrinterEntry(
    IN LPWSTR pszServer,
    IN LPWSTR pszQueue,
    OUT PNWPRINTER *ppPrinter,
    OUT PHANDLE phServer
)
{
    DWORD          err = NO_ERROR;
    DWORD          nQueueId = 0;
    HANDLE         TreeHandle = NULL;
    UNICODE_STRING TreeName;
    PNWPRINTER     pNwPrinter = NULL;
    BOOL           fCreatedNWConnection = FALSE;

    LPWSTR lpRemoteName = NULL;
    DWORD  dwBufSize = ( wcslen(pszServer) + wcslen(pszQueue) + 2 )
                       * sizeof(WCHAR);

    lpRemoteName = (LPWSTR) AllocNwSplMem( LMEM_ZEROINIT, dwBufSize );

    if ( lpRemoteName == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    wcscpy( lpRemoteName, pszServer );
    wcscat( lpRemoteName, L"\\" );
    wcscat( lpRemoteName, pszQueue );

    *ppPrinter = NULL;
    *phServer = NULL;

    //
    // See if we already know about this print queue.
    //
    pNwPrinter = NwFindPrinterEntry( pszServer, pszQueue );

/* Changing to get queue status to verify access instead
    if ( pNwPrinter == NULL )
    {
        // We don't know about this NetWare print queue. We need to see if
        // we are authorized to use this queue. If so, then go ahead
        // and continue to open printer. Otherwise, fail with not
        // authorized error code.

        err = NwCreateConnection( NULL,
                                  lpRemoteName,
                                  RESOURCETYPE_PRINT,
                                  NULL,
                                  NULL );

        if ( err != NO_ERROR )
        {
            if ( ( err == ERROR_INVALID_PASSWORD ) ||
                 ( err == ERROR_ACCESS_DENIED ) ||
                 ( err == ERROR_NO_SUCH_USER ) )
            {
                err = ERROR_ACCESS_DENIED;
            }

            FreeNwSplMem( lpRemoteName, dwBufSize );

            return err;
        }

        fCreatedNWConnection = TRUE;
    }
*/

    //
    // See if pszServer is really a NDS tree name, if so call
    // NwNdsGetQueueInformation to get the QueueId and possible referred
    // server for which we open handle.
    //

    RtlInitUnicodeString( &TreeName, pszServer + 2 );

    err = NwNdsOpenTreeHandle( &TreeName, &TreeHandle );

    if ( err == NO_ERROR )
    {
        NTSTATUS ntstatus;
        WCHAR    szRefServer[NDS_MAX_NAME_CHARS];
        UNICODE_STRING ObjectName;
        UNICODE_STRING QueuePath;

        ObjectName.Buffer = szRefServer;
        ObjectName.MaximumLength = NDS_MAX_NAME_CHARS;
        ObjectName.Length = 0;

        RtlInitUnicodeString( &QueuePath, pszQueue );

        ntstatus = NwNdsGetQueueInformation( TreeHandle,
                                             &QueuePath,
                                             &ObjectName,
                                             &nQueueId );

        if ( TreeHandle )
        {
            CloseHandle( TreeHandle );
            TreeHandle = NULL;
        }

        if ( ntstatus )
        {
            err = RtlNtStatusToDosError( ntstatus );
            goto ErrorExit;
        }

        //
        // If we got a referred server, it's name would look like:
        // "CN=SERVER.OU=DEV.O=MICROSOFT" . . . Convert it to "C\\SERVER"
        //
        if ( ObjectName.Length > 0 )
        {
            WORD i;
            LPWSTR EndOfServerName = NULL;

            //
            // First convert the referred server name to
            // "C\\SERVER.OU=DEV.O=MICROSOFT"
            //
            szRefServer[1] = L'\\';
            szRefServer[2] = L'\\';

            //
            // Put a NULL terminator at the first '.'
            //
            EndOfServerName = wcschr( szRefServer + 3, L'.' );
            if (EndOfServerName)
                *EndOfServerName = L'\0';

            //
            // pszServer now equals the referred server "C\\SERVER"
            //

            //
            // Get the handle of the referred server skipping the 'C' character.
            //
            err = NwAttachToNetwareServer( szRefServer + 1, phServer);
        }
    }
    else // Not an NDS tree, so get handle of server.
    {

        err = NwAttachToNetwareServer( pszServer, phServer);

        if ( err == NO_ERROR )
        {
            if ( err = NwGetQueueId( *phServer, pszQueue, &nQueueId))
                err = ERROR_INVALID_NAME;
        }
    }

    if ( ( err == ERROR_INVALID_PASSWORD ) ||
         ( err == ERROR_ACCESS_DENIED ) ||
         ( err == ERROR_NO_SUCH_USER ) )
    {
        err = ERROR_ACCESS_DENIED;
        goto ErrorExit;
    }
    else if ( err != NO_ERROR )
    {
        err = ERROR_INVALID_NAME;
        goto ErrorExit;
    }

    //
    // Test to see if there already was a entry for this print queue. If so,
    // we can now return with NO_ERROR since pNwPrinter and phServer are
    // now set.
    //
    if ( pNwPrinter )
    {
        if ( lpRemoteName )
        {
            FreeNwSplMem( lpRemoteName, dwBufSize );
        }

        *ppPrinter = pNwPrinter;

        return NO_ERROR;
    }

    //
    // The printer entry was not found in our list of printers in the
    // call to NwFindPrinterEntry. So, we must create one.
    //
    // First, verify access rights
    else
    {
        BYTE nQueueStatus;
        BYTE nJobCount;

        err = NwReadQueueCurrentStatus(*phServer, nQueueId, &nQueueStatus, &nJobCount);

        if ( ( err == ERROR_INVALID_PASSWORD ) ||
            ( err == ERROR_ACCESS_DENIED ) ||
            ( err == ERROR_NO_SUCH_USER ) )
        {
            err = ERROR_ACCESS_DENIED;
            goto ErrorExit;
        }
        else if ( err != NO_ERROR )
        {
            err = ERROR_INVALID_NAME;
            goto ErrorExit;
        }

    }

    if ( *ppPrinter = AllocNwSplMem( LMEM_ZEROINIT, sizeof(NWPRINTER) ))
    {
        if ( !( (*ppPrinter)->pszServer = AllocNwSplStr( pszServer )) )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }
        else if ( !( (*ppPrinter)->pszQueue = AllocNwSplStr( pszQueue )))
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        if ( fCreatedNWConnection )
        {
             if ( !( (*ppPrinter)->pszUncConnection =
                                   AllocNwSplStr( lpRemoteName )) )
             {
                 err = ERROR_NOT_ENOUGH_MEMORY;
                 goto ErrorExit;
             }

             FreeNwSplMem( lpRemoteName, dwBufSize );
             lpRemoteName = NULL;
        }
        else
        {
            (*ppPrinter)->pszUncConnection = NULL;
        }

#if DBG
        IF_DEBUG(PRINT)
        {
            KdPrint(("*************CREATED PRINTER ENTRY: %ws\\%ws\n\n",
                    (*ppPrinter)->pszServer, (*ppPrinter)->pszQueue ));
        }
#endif

        (*ppPrinter)->nQueueId = nQueueId;
        (*ppPrinter)->pSpoolList = NULL;
        (*ppPrinter)->pNextPrinter = NwPrinterList;
        NwPrinterList = *ppPrinter;

        err = NO_ERROR;
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    if ( err == NO_ERROR )
        return err;

ErrorExit:

    if ( *phServer )
    {
        (VOID) NtClose( *phServer );
        *phServer = NULL;
    }

    if ( *ppPrinter )
    {
        if ( (*ppPrinter)->pszServer )
        {
            FreeNwSplStr( (*ppPrinter)->pszServer );
        }

        if ( (*ppPrinter)->pszQueue )
        {
            FreeNwSplStr( (*ppPrinter)->pszQueue );
        }

        if ( (*ppPrinter)->pszUncConnection )
        {
            (void) NwrDeleteConnection( NULL,
                                        (*ppPrinter)->pszUncConnection,
                                        FALSE );
            FreeNwSplStr( (*ppPrinter)->pszUncConnection );
        }

        FreeNwSplMem( *ppPrinter, sizeof( NWPRINTER));
        *ppPrinter = NULL;
    }

    if ( lpRemoteName )
    {
        FreeNwSplMem( lpRemoteName, dwBufSize );
    }

    return err;
}



VOID
NwRemovePrinterEntry(
    IN PNWPRINTER pPrinter
)
{
    PNWPRINTER pCur, pPrev = NULL;

    ASSERT( pPrinter->pSpoolList == NULL );
    pPrinter->pSpoolList = NULL;

    for ( pCur = NwPrinterList; pCur; pPrev = pCur, pCur = pCur->pNextPrinter )
    {
        if ( pCur == pPrinter )
        {
            if ( pPrev )
                pPrev->pNextPrinter = pCur->pNextPrinter;
            else
                NwPrinterList = pCur->pNextPrinter;
            break;
        }
    }

    ASSERT( pCur );

    pPrinter->pNextPrinter = NULL;
    FreeNwSplStr( pPrinter->pszServer );
    FreeNwSplStr( pPrinter->pszQueue );
    if ( pPrinter->pszUncConnection )
    {
        (void) NwrDeleteConnection( NULL,
                                    pPrinter->pszUncConnection,
                                    FALSE );
        FreeNwSplStr( pPrinter->pszUncConnection );
    }
    FreeNwSplMem( pPrinter, sizeof( NWPRINTER));
}



VOID
NWWKSTA_PRINTER_CONTEXT_rundown(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter
    )
/*++

Routine Description:

    This function is called by RPC when a client terminates with an
    opened handle.  This allows us to clean up and deallocate any context
    data associated with the handle.

Arguments:

    hPrinter - Supplies the opened handle

Return Value:

    None.

--*/
{
    (void) NwrClosePrinter(&hPrinter);
}



LPWSTR
NwGetUncObjectName(
    IN LPWSTR ContainerName
)
{
    WORD length = 2;
    WORD totalLength = (WORD) wcslen( ContainerName );

    if ( totalLength < 2 )
        return 0;

    while ( length < totalLength )
    {
        if ( ContainerName[length] == L'.' )
            ContainerName[length] = L'\0';

        length++;
    }

    length = 2;

    while ( length < totalLength && ContainerName[length] != L'\\' )
    {
        length++;
    }

    ContainerName[length + 2] = L'\\';
    ContainerName[length + 3] = L'\\';

    return (ContainerName + length + 2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\svcdlls\nwwks\server\util.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module contains miscellaneous utility routines used by the
    NetWare Workstation service.

Author:

    Rita Wong  (ritaw)   08-Feb-1993

Revision History:

--*/

#include <nw.h>
#include <nwstatus.h>

//
// Debug trace flag for selecting which trace statements to output
//
#if DBG

DWORD WorkstationTrace = 0;

#endif // DBG



// Terminal Server Addition - 
DWORD
NwImpersonateClient(
    VOID
    )
/*++

Routine Description:

    This function calls RpcImpersonateClient to impersonate the current caller
    of an API.

Arguments:

    None.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;


    if ((status = RpcImpersonateClient(NULL)) != NO_ERROR) {
        KdPrint(("NWWORKSTATION: Fail to impersonate client %ld\n", status));
    }

    return status;
}


// Terminal Server Addition - 
DWORD
NwRevertToSelf(
    VOID
    )
/*++

Routine Description:

    This function calls RpcRevertToSelf to undo an impersonation.

Arguments:

    None.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;


    if ((status = RpcRevertToSelf()) != NO_ERROR) {
        KdPrint(("NWWORKSTATION: Fail to revert to self %ld\n", status));
        ASSERT(FALSE);
    }

    return status;
}


VOID
NwLogEvent(
    DWORD MessageId,
    DWORD NumberOfSubStrings,
    LPWSTR *SubStrings,
    DWORD ErrorCode
    )
{

    HANDLE LogHandle;


    LogHandle = RegisterEventSourceW (
                    NULL,
                    NW_WORKSTATION_SERVICE
                    );

    if (LogHandle == NULL) {
        KdPrint(("NWWORKSTATION: RegisterEventSourceW failed %lu\n",
                 GetLastError()));
        return;
    }

    if (ErrorCode == NO_ERROR) {

        //
        // No error codes were specified
        //
        (void) ReportEventW(
                   LogHandle,
                   EVENTLOG_ERROR_TYPE,
                   0,            // event category
                   MessageId,
                   (PSID) NULL,
                   (WORD) NumberOfSubStrings,
                   0,
                   SubStrings,
                   (PVOID) NULL
                   );

    }
    else {

        //
        // Log the error code specified as binary data
        //
        (void) ReportEventW(
                   LogHandle,
                   EVENTLOG_ERROR_TYPE,
                   0,            // event category
                   MessageId,
                   (PSID) NULL,
                   (WORD) NumberOfSubStrings,
                   sizeof(DWORD),
                   SubStrings,
                   (PVOID) &ErrorCode
                   );
    }

    DeregisterEventSource(LogHandle);
}



//---------------------------------------------------------------------------------//
// NwGetSessionId - This routine assumed that the thread is already executed in    //
// the client context. It just get the session ID without impersonating.           //
//---------------------------------------------------------------------------------// 

NTSTATUS
NwGetSessionId(
    OUT PULONG pSessionId
    )
/*++

Routine Description:

    This function gets the session id of the current thread.

    Arguments:

    pSessionId - Returns the session id of the current process.

Return Value:

    DWORD - NERR_Success or reason for failure.

--*/
{
    NTSTATUS ntstatus;
    HANDLE CurrentThreadToken;
    ULONG SessionId;
    ULONG ReturnLength;


    ntstatus = NtOpenThreadToken(
                   NtCurrentThread(),
                   TOKEN_QUERY,
                   TRUE,              // Use workstation service's security
                                      // context to open thread token
                   &CurrentThreadToken
                   );


    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("[Wksta] Cannot open the current thread token %08lx\n",
                     ntstatus));
        goto Exit;
    }

    //
    // Get the session id of the current thread
    //


    ntstatus = NtQueryInformationToken(
                  CurrentThreadToken,
                  TokenSessionId,
                  &SessionId,
                  sizeof(ULONG),
                  &ReturnLength
                  );


    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("[Wksta] Cannot query current thread's token %08lx\n",
                     ntstatus));
        NtClose(CurrentThreadToken);
        goto Exit;
    }


    NtClose(CurrentThreadToken);

    *pSessionId = SessionId;

Exit:

    return ntstatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\vw.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vw.h

Abstract:

    Top-level include file for VWIPXSPX DLL. Pulls in all other required header
    files

Author:

    Richard L Firth (rfirth) 25-Oct-1993

Revision History:

    25-Oct-1993 rfirth
        Created

--*/

//
// all include files required by VWIPXSPX.DLL
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#define FD_SETSIZE MAX_OPEN_SOCKETS
#include <winsock.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <vddsvc.h> // GetVDMAddress, GetVDMPointer
#undef getMSW

extern  WORD getMSW(VOID);

#include "vwvdm.h"
#include "vwdll.h"
#include "vwipxspx.h"
#include "vwasync.h"
#include "vwmisc.h"
#include "vwipx.h"
#include "vwspx.h"
#include "socket.h"
#include "util.h"
#include "vwdebug.h"
#include "vwinapi.h"
#include "vwint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\vwdebug.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwdebug.c

Abstract:

    Contains debug routines for VWIPXSPX.DLL

    Contents:
        VwDebugStart
        VwDebugEnd
        VwDebugPrint
        VwDumpData
        VwDumpEcb
        VwDumpFragment
        VwDumpPacketHeader
        VwDumpXecb
        VwDumpSocketInfo
        VwDumpConnectionInfo
        VwDumpConnectionStats
        VwLog
        CheckInterrupts

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    User-mode Win32

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

#include "vw.h"
#pragma hdrstop

#if DBG

//
// private prototypes
//

int PokeLevelString(LPSTR, DWORD, DWORD, LPSTR);
LPSTR StripNameFromPath(LPSTR);

//
// private data
//

DWORD VwDebugFlags = 0;
DWORD VwDebugFunctions = 0;
DWORD VwShow = SHOW_ECBS | SHOW_HEADERS;
DWORD VwDebugLevel = IPXDBG_MIN_LEVEL;
DWORD VwDebugDump = 0;
BOOL VwDebugInitialized = FALSE;
FILE* hVwDebugLog = NULL;
DWORD DebugFlagsEx = 0 ;

//
// functions
//

VOID VwDebugStart() {

    //
    // a little run-time diagnostication, madam?
    //

    LPSTR ptr;

    if (VwDebugInitialized) {
        return;
    }

    //
    // override VwDebugFlags from VWFLAGS environment variable
    //

    if (ptr = getenv("VWFLAGS")) {
        VwDebugFlags = (DWORD)strtoul(ptr, NULL, 0);
    }
    if (ptr = getenv("VWFUNCS")) {
        VwDebugFunctions = (DWORD)strtoul(ptr, NULL, 0);
    }
    if (ptr = getenv("VWSHOW")) {
        VwShow = (DWORD)strtoul(ptr, NULL, 0);
    }
    if (ptr = getenv("VWLEVEL")) {
        VwDebugLevel = strtoul(ptr, NULL, 0);
        if (VwDebugLevel > IPXDBG_MAX_LEVEL) {
            VwDebugLevel = IPXDBG_MAX_LEVEL;
        }
    }
    if (ptr = getenv("VWDUMP")) {
        VwDebugDump = strtoul(ptr, NULL, 0);
    }
    IF_DEBUG(TO_FILE) {
        if ((hVwDebugLog = fopen(VWDEBUG_FILE, "w+")) == NULL) {
            VwDebugFlags &= ~DEBUG_TO_FILE;
        } else {

#if 0

            char currentDirectory[256];
            int n;

            currentDirectory[0] = 0;
            if (n = GetCurrentDirectory(sizeof(currentDirectory), currentDirectory)) {
                if (currentDirectory[n-1] == '\\') {
                    currentDirectory[n-1] = 0;
                }
            }

            DbgPrint("VWIPXSPX: Writing debug output to %s\\" VWDEBUG_FILE "\n", currentDirectory);
#endif

        }
    }
    VwDebugInitialized = TRUE;
}

VOID VwDebugEnd() {
    IF_DEBUG(TO_FILE) {
        fflush(hVwDebugLog);
        fclose(hVwDebugLog);
    }
}

VOID VwDebugPrint(LPSTR Module, DWORD Line, DWORD Function, DWORD Level, LPSTR Format, ...) {

    char buf[1024];
    va_list p;

    IF_DEBUG(NOTHING) {
        return;
    }

    //
    // only log something if we are tracking this Function and Level is above
    // (or equal to) the filter cut-off or Level >= minimum alert level (error)
    //

    if (((Function & VwDebugFunctions) && (Level >= VwDebugLevel)) || (Level >= IPXDBG_LEVEL_ERROR)) {
        va_start(p, Format);
        vsprintf(buf+PokeLevelString(Module, Line, Level, buf), Format, p);
        VwLog(buf);
        va_end(p);
    }
}

int PokeLevelString(LPSTR Module, DWORD Line, DWORD Level, LPSTR Buffer) {

    int length;
    static char levelString[4] = " : ";
    char level;

    switch (Level) {
    case IPXDBG_LEVEL_INFO:
        level = 'I';
        break;

    case IPXDBG_LEVEL_WARNING:
        level = 'W';
        break;

    case IPXDBG_LEVEL_ERROR:
        level = 'E';
        break;

    case IPXDBG_LEVEL_FATAL:
        level = 'F';
        break;
    }

    levelString[0] = level;
    strcpy(Buffer, levelString);
    length = strlen(levelString);

    if (Level >= IPXDBG_LEVEL_ERROR) {
        length += sprintf(Buffer + length, "%s [% 5d]: ", StripNameFromPath(Module), Line);
    }

    return length;
}

LPSTR StripNameFromPath(LPSTR Path) {

    LPSTR p;

    p = strrchr(Path, '\\');
    return p ? p+1 : Path;
}

VOID VwDumpData(ULPBYTE Address, WORD Seg, WORD Off, BOOL InVdm, WORD Size) {

    char buf[128];
    int i, len;

    IF_NOT_DEBUG(DATA) {
        return;
    }

    while (Size) {
        len = min(Size, 16);
        if (InVdm) {
            sprintf(buf, "%04x:%04x ", Seg, Off);
        } else {
            sprintf(buf, "%p  ", Address);
        }
        for (i = 0; i < len; ++i) {
            sprintf(&buf[10+i*3], "%02.2x ", Address[i] & 0xff);
        }
        for (i = len; i < 17; ++i) {
            strcat(buf, "   ");
        }
        for (i = 0; i < len; ++i) {

            char ch;

            ch = Address[i];
            buf[61+i] =  ((ch < 32) || (ch > 127)) ? '.' : ch;
        }
        buf[61+i++] = '\n';
        buf[61+i] = 0;
        VwLog(buf);
        Address += len;
        Size -= (WORD)len;
        Off += (WORD)len;
    }
    VwLog("\n");
}

VOID VwDumpEcb(LPECB pEcb, WORD Seg, WORD Off, BYTE Type, BOOL Frags, BOOL Data, BOOL Mode) {

    char buf[512];
    int n;
    char* bufptr;

    IF_NOT_DEBUG(ECB) {
        return;
    }

    IF_NOT_SHOW(ECBS) {
        VwDumpData((ULPBYTE)pEcb,
                   Seg,
                   Off,
                   TRUE,
                   (WORD)((Type == ECB_TYPE_AES)
                        ? sizeof(AES_ECB)
                        : (sizeof(IPX_ECB) + sizeof(FRAGMENT) * (pEcb->FragmentCount - 1)))
                   );
        return;
    }

    n = sprintf(buf,
                "\n"
                "%s ECB @ %04x:%04x:\n"
                "LinkAddress      %04x:%04x\n"
                "EsrAddress       %04x:%04x\n"
                "InUse            %02x\n",
                (Type == ECB_TYPE_AES)
                    ? "AES"
                    : (Type == ECB_TYPE_IPX)
                        ? "IPX"
                        : "SPX",
                Seg,
                Off,
                GET_SEGMENT(&pEcb->LinkAddress),
                GET_OFFSET(&pEcb->LinkAddress),
                GET_SEGMENT(&pEcb->EsrAddress),
                GET_OFFSET(&pEcb->EsrAddress),
                pEcb->InUse
                );
    bufptr = buf + n;
    if (Type == ECB_TYPE_AES) {
        sprintf(bufptr,
                "AesWorkspace     %02x-%02x-%02x-%02x-%02x\n",
                ((LPAES_ECB)pEcb)->AesWorkspace[0] & 0xff,
                ((LPAES_ECB)pEcb)->AesWorkspace[1] & 0xff,
                ((LPAES_ECB)pEcb)->AesWorkspace[2] & 0xff,
                ((LPAES_ECB)pEcb)->AesWorkspace[3] & 0xff,
                ((LPAES_ECB)pEcb)->AesWorkspace[4] & 0xff
                );
    } else {
        sprintf(bufptr,
                "CompletionCode   %02x\n"
                "SocketNumber     %04x\n"
                "IpxWorkspace     %08x\n"
                "DriverWorkspace  %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n"
                "ImmediateAddress %02x-%02x-%02x-%02x-%02x-%02x\n"
                "FragmentCount    %04x\n",
                pEcb->CompletionCode,
                B2LW(pEcb->SocketNumber),
                pEcb->IpxWorkspace,
                pEcb->DriverWorkspace[0] & 0xff,
                pEcb->DriverWorkspace[1] & 0xff,
                pEcb->DriverWorkspace[2] & 0xff,
                pEcb->DriverWorkspace[3] & 0xff,
                pEcb->DriverWorkspace[4] & 0xff,
                pEcb->DriverWorkspace[5] & 0xff,
                pEcb->DriverWorkspace[6] & 0xff,
                pEcb->DriverWorkspace[7] & 0xff,
                pEcb->DriverWorkspace[8] & 0xff,
                pEcb->DriverWorkspace[9] & 0xff,
                pEcb->DriverWorkspace[10] & 0xff,
                pEcb->DriverWorkspace[11] & 0xff,
                pEcb->ImmediateAddress[0] & 0xff,
                pEcb->ImmediateAddress[1] & 0xff,
                pEcb->ImmediateAddress[2] & 0xff,
                pEcb->ImmediateAddress[3] & 0xff,
                pEcb->ImmediateAddress[4] & 0xff,
                pEcb->ImmediateAddress[5] & 0xff,
                pEcb->FragmentCount
                );
    }

    VwLog(buf);

    if ((Type != ECB_TYPE_AES) && Frags) {

        ASSERT(pEcb->FragmentCount < 10);

        VwDumpFragment(pEcb->FragmentCount,
                       (LPFRAGMENT)(pEcb + 1),
                       Type,
                       Data,
                       Mode
                       );
    }
}

VOID VwDumpFragment(WORD Count, LPFRAGMENT pFrag, BYTE Type, BOOL Data, BOOL Mode) {

    char buf[256];
    int i;

    IF_NOT_DEBUG(FRAGMENTS) {
        return;
    }

    for (i = 0; i < Count; ++i) {
        sprintf(buf,
                "Fragment %d:\n"
                "    Address      %04x:%04x\n"
                "    Length       %04x\n",
                i + 1,
                GET_SEGMENT(&pFrag->Address),
                GET_OFFSET(&pFrag->Address),
                pFrag->Length
                );
        VwLog(buf);
        if (Data) {

            ULPBYTE ptr;
            WORD size;
            WORD offset;

            ptr = GET_FAR_POINTER(&pFrag->Address, Mode);
            size = pFrag->Length;
            offset = GET_OFFSET(&pFrag->Address);

            //
            // this allows us to show headers vs. raw data
            //

            IF_SHOW(HEADERS) {
                if (i == 0) {
                    VwDumpPacketHeader(ptr, Type);

                    if (Type == ECB_TYPE_IPX) {
                        ptr += IPX_HEADER_LENGTH;
                        size -= IPX_HEADER_LENGTH;
                        offset += IPX_HEADER_LENGTH;
                    } else {
                        ptr += SPX_HEADER_LENGTH;
                        size -= SPX_HEADER_LENGTH;
                        offset += SPX_HEADER_LENGTH;
                    }
                }
            }

            VwDumpData(ptr,
                       GET_SEGMENT(&pFrag->Address),
                       offset,
                       TRUE,
                       size
                       );
        }
        ++pFrag;
    }
}

VOID VwDumpPacketHeader(ULPBYTE pPacket, BYTE Type) {

    char buf[512];

    IF_NOT_DEBUG(HEADERS) {
        return;
    }

    sprintf(buf,
            "Checksum         %04x\n"
            "Length           %04x\n"
            "TransportControl %02x\n"
            "PacketType       %02x\n"
            "Destination      %02x-%02x-%02x-%02x : %02x-%02x-%02x-%02x-%02x-%02x : %04x\n"
            "Source           %02x-%02x-%02x-%02x : %02x-%02x-%02x-%02x-%02x-%02x : %04x\n",
            ((LPIPX_PACKET)pPacket)->Checksum,
            B2LW(((LPIPX_PACKET)pPacket)->Length),
            ((LPIPX_PACKET)pPacket)->TransportControl,
            ((LPIPX_PACKET)pPacket)->PacketType,
            ((LPIPX_PACKET)pPacket)->Destination.Net[0] & 0xff,
            ((LPIPX_PACKET)pPacket)->Destination.Net[1] & 0xff,
            ((LPIPX_PACKET)pPacket)->Destination.Net[2] & 0xff,
            ((LPIPX_PACKET)pPacket)->Destination.Net[3] & 0xff,
            ((LPIPX_PACKET)pPacket)->Destination.Node[0] & 0xff,
            ((LPIPX_PACKET)pPacket)->Destination.Node[1] & 0xff,
            ((LPIPX_PACKET)pPacket)->Destination.Node[2] & 0xff,
            ((LPIPX_PACKET)pPacket)->Destination.Node[3] & 0xff,
            ((LPIPX_PACKET)pPacket)->Destination.Node[4] & 0xff,
            ((LPIPX_PACKET)pPacket)->Destination.Node[5] & 0xff,
            B2LW(((LPIPX_PACKET)pPacket)->Destination.Socket),
            ((LPIPX_PACKET)pPacket)->Source.Net[0] & 0xff,
            ((LPIPX_PACKET)pPacket)->Source.Net[1] & 0xff,
            ((LPIPX_PACKET)pPacket)->Source.Net[2] & 0xff,
            ((LPIPX_PACKET)pPacket)->Source.Net[3] & 0xff,
            ((LPIPX_PACKET)pPacket)->Source.Node[0] & 0xff,
            ((LPIPX_PACKET)pPacket)->Source.Node[1] & 0xff,
            ((LPIPX_PACKET)pPacket)->Source.Node[2] & 0xff,
            ((LPIPX_PACKET)pPacket)->Source.Node[3] & 0xff,
            ((LPIPX_PACKET)pPacket)->Source.Node[4] & 0xff,
            ((LPIPX_PACKET)pPacket)->Source.Node[5] & 0xff,
            B2LW(((LPIPX_PACKET)pPacket)->Source.Socket)
            );
    VwLog(buf);
    if (Type == ECB_TYPE_SPX) {
        sprintf(buf,
                "ConnectControl   %02x\n"
                "DataStreamType   %02x\n"
                "SourceConnectId  %04x\n"
                "DestConnectId    %04x\n"
                "SequenceNumber   %04x\n"
                "AckNumber        %04x\n"
                "AllocationNumber %04x\n",
                ((LPSPX_PACKET)pPacket)->ConnectionControl,
                ((LPSPX_PACKET)pPacket)->DataStreamType,
                B2LW(((LPSPX_PACKET)pPacket)->SourceConnectId),
                B2LW(((LPSPX_PACKET)pPacket)->DestinationConnectId),
                B2LW(((LPSPX_PACKET)pPacket)->SequenceNumber),
                B2LW(((LPSPX_PACKET)pPacket)->AckNumber),
                B2LW(((LPSPX_PACKET)pPacket)->AllocationNumber)
                );
        VwLog(buf);
    }
    VwLog("\n");
}

VOID VwDumpXecb(LPXECB pXecb) {

    char buf[512];

    IF_NOT_DEBUG(XECB) {
        return;
    }

    sprintf(buf,
            "XECB @ %p:\n"
            "Next           %p\n"
            "Ecb            %p\n"
            "EcbAddress     %08x\n"
            "EsrAddress     %08x\n"
            "Buffer         %p\n"
            "Data           %p\n"
            "FrameLength    %04x\n"
            "ActualLength   %04x\n"
            "Length         %04x\n"
            "Ticks          %04x\n"
            "SocketNumber   %04x\n"
            "Owner          %04x\n"
            "TaskId         %08x\n"
            "Flags          %08x\n"
            "QueueId        %08x\n"
            "OwningObject   %p\n"
            "RefCount       %08x\n",
            pXecb,
            pXecb->Next,
            pXecb->Ecb,
            pXecb->EcbAddress,
            pXecb->EsrAddress,
            pXecb->Buffer,
            pXecb->Data,
            pXecb->FrameLength,
            pXecb->ActualLength,
            pXecb->Length,
            pXecb->Ticks,
            B2LW(pXecb->SocketNumber),
            pXecb->Owner,
            pXecb->TaskId,
            pXecb->Flags,
            pXecb->QueueId,
            pXecb->OwningObject,
            pXecb->RefCount
            );
    VwLog(buf);
}

VOID VwDumpSocketInfo(LPSOCKET_INFO pSocketInfo) {

    char buf[512];

    IF_NOT_DEBUG(SOCKINFO) {
        return;
    }

    sprintf(buf,
            "SOCKET_INFO @ %p:\n"
            "Next           %p\n"
            "SocketNumber   %04x\n"
            "Owner          %04x\n"
            "TaskId         %08x\n"
            "Socket         %08x\n"
            "Flags          %08x\n"
            "LongLived      %d\n"
            "SpxSocket      %d\n"
            "PendingSends   %08x\n"
            "PendingListens %08x\n"
            "ListenQueue    %p, %p\n"
            "SendQueue      %p, %p\n"
            "HeaderQueue    %p, %p\n"
            "Connections    %p\n",
            pSocketInfo,
            pSocketInfo->Next,
            B2LW(pSocketInfo->SocketNumber),
            pSocketInfo->Owner,
            pSocketInfo->TaskId,
            pSocketInfo->Socket,
            pSocketInfo->Flags,
            pSocketInfo->LongLived,
            pSocketInfo->SpxSocket,
            pSocketInfo->PendingSends,
            pSocketInfo->PendingListens,
            pSocketInfo->ListenQueue.Head,
            pSocketInfo->ListenQueue.Tail,
            pSocketInfo->SendQueue.Head,
            pSocketInfo->SendQueue.Tail,
            pSocketInfo->HeaderQueue.Head,
            pSocketInfo->HeaderQueue.Tail,
            pSocketInfo->Connections
            );
    VwLog(buf);
}

VOID VwDumpConnectionInfo(LPCONNECTION_INFO pConnectionInfo) {

    char buf[512];

    IF_NOT_DEBUG(CONNINFO) {
        return;
    }

    sprintf(buf,
            "CONNECTION_INFO @ %p:\n"
            "Next           %p\n"
            "List           %p\n"
            "OwningSocket   %p\n"
            "Socket         %08x\n"
            "TaskId         %08x\n"
            "ConnectionId   %04x\n"
            "Flags          %02x\n"
            "State          %02x\n"
            "ConnectQueue   %p, %p\n"
            "AcceptQueue    %p, %p\n"
            "SendQueue      %p, %p\n"
            "ListenQueue    %p, %p\n",
            pConnectionInfo,
            pConnectionInfo->Next,
            pConnectionInfo->List,
            pConnectionInfo->OwningSocket,
            pConnectionInfo->Socket,
            pConnectionInfo->TaskId,
            pConnectionInfo->ConnectionId,
            pConnectionInfo->Flags,
            pConnectionInfo->State,
            pConnectionInfo->ConnectQueue.Head,
            pConnectionInfo->ConnectQueue.Tail,
            pConnectionInfo->AcceptQueue.Head,
            pConnectionInfo->AcceptQueue.Tail,
            pConnectionInfo->SendQueue.Head,
            pConnectionInfo->SendQueue.Tail,
            pConnectionInfo->ListenQueue.Head,
            pConnectionInfo->ListenQueue.Tail
            );
    VwLog(buf);
}

VOID VwDumpConnectionStats(LPSPX_CONNECTION_STATS pStats) {

    char buf[1024];

    IF_NOT_DEBUG(STATS) {
        return;
    }

    sprintf(buf,
            "State                      %02x\n"
            "WatchDog                   %02x\n"
            "LocalConnectionId          %04x\n"
            "RemoteConnectionId         %04x\n"
            "LocalSequenceNumber        %04x\n"
            "LocalAckNumber             %04x\n"
            "LocalAllocNumber           %04x\n"
            "RemoteAckNumber            %04x\n"
            "RemoteAllocNumber          %04x\n"
            "LocalSocket                %04x\n"
            "ImmediateAddress           %02x-%02x-%02x-%02x-%02x-%02x\n"
            "RemoteNetwork              %02x-%02x-%02x-%02x\n"
            "RemoteNode                 %02x-%02x-%02x-%02x-%02x-%02x\n"
            "RemoteSocket               %04x\n"
            "RetransmissionCount        %04x\n"
            "EstimatedRoundTripDelay    %04x\n"
            "RetransmittedPackets       %04x\n",
            pStats->State,
            pStats->WatchDog,
            B2LW(pStats->LocalConnectionId),
            B2LW(pStats->RemoteConnectionId),
            B2LW(pStats->LocalSequenceNumber),
            B2LW(pStats->LocalAckNumber),
            B2LW(pStats->LocalAllocNumber),
            B2LW(pStats->RemoteAckNumber),
            B2LW(pStats->RemoteAllocNumber),
            B2LW(pStats->LocalSocket),
            pStats->ImmediateAddress[0] & 0xff,
            pStats->ImmediateAddress[1] & 0xff,
            pStats->ImmediateAddress[2] & 0xff,
            pStats->ImmediateAddress[3] & 0xff,
            pStats->ImmediateAddress[4] & 0xff,
            pStats->ImmediateAddress[5] & 0xff,
            pStats->RemoteNetwork[0] & 0xff,
            pStats->RemoteNetwork[1] & 0xff,
            pStats->RemoteNetwork[2] & 0xff,
            pStats->RemoteNetwork[3] & 0xff,
            pStats->RemoteNode[0] & 0xff,
            pStats->RemoteNode[1] & 0xff,
            pStats->RemoteNode[2] & 0xff,
            pStats->RemoteNode[3] & 0xff,
            pStats->RemoteNode[4] & 0xff,
            pStats->RemoteNode[5] & 0xff,
            B2LW(pStats->RemoteSocket),
            B2LW(pStats->RetransmissionCount),
            B2LW(pStats->EstimatedRoundTripDelay),
            B2LW(pStats->RetransmittedPackets)
            );

    VwLog(buf);
}

VOID VwLog(LPSTR buf) {

    IF_DEBUG(NOTHING) {
        return;
    }

    IF_DEBUG(TO_FILE) {
        fputs(buf, hVwDebugLog);
        IF_DEBUG(FLUSH) {
            fflush(hVwDebugLog);
        }
    } else IF_DEBUG(TO_DBG) {
        OutputDebugString(buf);
    }
}

VOID CheckInterrupts(LPSTR name) {

    IF_DEBUG(CHECK_INT) {

        LPWORD pDosIntFlag = (LPWORD)GET_POINTER(0x40, 0x314, 2, FALSE);

        if ((getIF() == 0) || !(*pDosIntFlag & 0x200)) {
            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "*** CheckInterrupts: ints off in %s (IF=%d, 40:314=%04x)\n",
                        name,
                        getIF(),
                        *pDosIntFlag
                        ));
        }
    }
}

extern LPCONNECTION_INFO ConnectionList ;
extern LPSOCKET_INFO SocketList ;

VOID VwDumpAll(VOID)
{
    char buf[512];
    LPCONNECTION_INFO pConnectionInfo;
    LPSOCKET_INFO pSocketInfo;

    if (DebugFlagsEx == 0)
        return ;

    DebugFlagsEx = 0 ;

    RequestMutex();


    pSocketInfo = SocketList;
    while (pSocketInfo) {

        LPXECB pXecb ;

        if (!(pSocketInfo->SpxSocket)) {
            pSocketInfo = pSocketInfo->Next;
            continue ;
        }

        sprintf(buf,
            "%sSOCKET_INFO @ %p:\n"
            "    SocketNumber   %04x\n"
            "    Owner          %04x\n"
            "    TaskId         %08x\n"
            "    Socket         %08x\n"
            "    Flags          %08x\n"
            "    LongLived      %d\n"
            "    PendingSends   %08x\n"
            "    PendingListens %08x\n"
            "    ListenQueue    %p, %p\n"
            "    SendQueue      %p, %p\n"
            "    HeaderQueue    %p, %p\n"
            "    Connections    %p\n\n",
            (pSocketInfo->SpxSocket)?"SPX ":"",
            pSocketInfo,
            B2LW(pSocketInfo->SocketNumber),
            pSocketInfo->Owner,
            pSocketInfo->TaskId,
            pSocketInfo->Socket,
            pSocketInfo->Flags,
            pSocketInfo->LongLived,
            pSocketInfo->PendingSends,
            pSocketInfo->PendingListens,
            pSocketInfo->ListenQueue.Head,
            pSocketInfo->ListenQueue.Tail,
            pSocketInfo->SendQueue.Head,
            pSocketInfo->SendQueue.Tail,
            pSocketInfo->HeaderQueue.Head,
            pSocketInfo->HeaderQueue.Tail,
            pSocketInfo->Connections
            );
        OutputDebugString(buf);

        pConnectionInfo = pSocketInfo->Connections ;

        while(pConnectionInfo) {
            sprintf(buf,
                "CONNECTION_INFO @ %p:\n"
                "    List           %p\n"
                "    OwningSocket   %p\n"
                "    Socket         %08x\n"
                "    TaskId         %08x\n"
                "    ConnectionId   %04x\n"
                "    Flags          %02x\n"
                "    State          %02x\n"
                "    ConnectQueue   %p, %p\n"
                "    AcceptQueue    %p, %p\n"
                "    SendQueue      %p, %p\n"
                "    ListenQueue    %p, %p\n\n",
                pConnectionInfo,
                pConnectionInfo->List,
                pConnectionInfo->OwningSocket,
                pConnectionInfo->Socket,
                pConnectionInfo->TaskId,
                pConnectionInfo->ConnectionId,
                pConnectionInfo->Flags,
                pConnectionInfo->State,
                pConnectionInfo->ConnectQueue.Head,
                pConnectionInfo->ConnectQueue.Tail,
                pConnectionInfo->AcceptQueue.Head,
                pConnectionInfo->AcceptQueue.Tail,
                pConnectionInfo->SendQueue.Head,
                pConnectionInfo->SendQueue.Tail,
                pConnectionInfo->ListenQueue.Head,
                pConnectionInfo->ListenQueue.Tail
                );
            OutputDebugString(buf);
            pConnectionInfo = pConnectionInfo->Next ;
        }

        pXecb = pSocketInfo->ListenQueue.Head ;
        while(pXecb) {
            sprintf(buf,
                    "    XECB @ %p: (Ecb %p)\n"
                    "        EcbAddress/EsrAddress  %08x  %08x\n"
                    "        Flags/RefCount         %08x  %08x\n"
                    "        Buffer/QueueId         %p  %08x\n"
                    "        OwningObject           %p\n",
                    pXecb,
                    pXecb->Ecb,
                    pXecb->EcbAddress,
                    pXecb->EsrAddress,
                    pXecb->Flags,
                    pXecb->RefCount,
                    pXecb->Buffer,
                    pXecb->QueueId,
                    pXecb->OwningObject
                    );
            OutputDebugString(buf);
            pXecb =  pXecb->Next ;
        }
        pSocketInfo = pSocketInfo->Next;
    }
    ReleaseMutex();
}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\vwasync.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vwipx.h

Abstract:

    Contains function prototypes for VWASYNC.C

Author:

    Richard L Firth (rfirth) 25-Oct-1993

Revision History:

    25-Oct-1993 rfirth
        Created

--*/

DWORD
VwAesThread(
    IN LPVOID Parameters
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\util.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    util.h

Abstract:

    Contains macros, prototypes and structures for util.c

Author:

    Richard L Firth (rfirth) 25-Oct-1993

Revision History:

    25-Oct-1993 rfirth
        Created

--*/

//
// external data
//

extern CRITICAL_SECTION SerializationCritSec;

//
// one-line function macros
//

#define RequestMutex()  EnterCriticalSection(&SerializationCritSec)
#define ReleaseMutex()  LeaveCriticalSection(&SerializationCritSec)

//
// function prototypes
//

int
GetInternetAddress(
    IN OUT LPSOCKADDR_IPX InternetAddress
    );

int
GetMaxPacketSize(
    OUT LPWORD MaxPacketSize
    );

LPXECB
RetrieveEcb(
    IN BYTE Type
    );

LPXECB
RetrieveXEcb(
    IN BYTE  Type,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

VOID
ScheduleEvent(
    IN LPXECB pXecb,
    IN WORD Ticks
    );

VOID
ScanTimerList(
    VOID
    );

BYTE
CancelTimerEvent(
    IN LPXECB pXecb
    );

VOID
CancelTimedEvents(
    IN WORD SocketNumber,
    IN WORD Owner,
    IN DWORD TaskId
    );

BYTE
CancelAsyncEvent(
    IN LPXECB pXecb
    );

BYTE
CancelSocketEvent(
    IN LPXECB pXecb
    );

BYTE
CancelConnectionEvent(
    IN LPXECB pXecb
    );

VOID
QueueEcb(
    IN LPXECB pXecb,
    IN LPXECB_QUEUE Queue,
    IN QUEUE_ID QueueId
    );

LPXECB
DequeueEcb(
    IN LPXECB pXecb,
    IN LPXECB_QUEUE Queue
    );

VOID
CancelSocketQueue(
    IN LPXECB_QUEUE pXecbQueue
    );

VOID
CancelConnectionQueue(
    IN LPXECB_QUEUE pXecbQueue
    );

VOID
AbortQueue(
    IN LPXECB_QUEUE pXecbQueue,
    IN BYTE CompletionCode
    );

VOID
AbortConnectionEvent(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    );

VOID
StartIpxSend(
    IN LPXECB pEcb,
    IN LPSOCKET_INFO pSocketInfo
    );

BOOL
GetIoBuffer(
    IN OUT LPXECB pXecb,
    IN BOOL Send,
    IN WORD HeaderLength
    );

VOID
GatherData(
    IN LPXECB pXecb,
    IN WORD HeaderLength
    );

VOID
ScatterData(
    IN LPXECB pXecb
    );

VOID
IpxReceiveFirst(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    );

VOID
IpxReceiveNext(
    IN LPSOCKET_INFO pSocketInfo
    );

VOID
IpxSendNext(
    IN LPSOCKET_INFO pSocketInfo
    );

VOID
CompleteOrQueueIo(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    );

VOID
CompleteIo(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    );

VOID
CompleteOrQueueEcb(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    );

VOID
CompleteEcb(
    IN LPXECB pEcb,
    IN BYTE CompletionCode
    );

VOID
EsrCallback(
    VOID
    );

VOID
VWinEsrCallback(
    WORD *pSegment,
    WORD *pOffset,
    BYTE *pFlags
    );

VOID
FifoAddHead(
    IN LPFIFO pFifo,
    IN LPFIFO pElement
    );

VOID
FifoAdd(
    IN LPFIFO pFifo,
    IN LPFIFO pElement
    );

LPFIFO
FifoRemove(
    IN LPFIFO pFifo,
    IN LPFIFO pElement
    );

LPFIFO
FifoNext(
    IN LPFIFO pFifo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\vwdll.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwdll.c

Abstract:

    ntVdm netWare (Vw) IPX/SPX Functions

    Vw: The peoples' network

    VDD functions for DOS/WOW IPX/SPX support

    Contents:
        VwDllEntryPoint
        VwInitialize
        VWinInitialize
        VwDispatcher
        VwInvalidFunction

Author:

    Richard L Firth (rfirth) 30-Sep-1993

Environment:

    User-mode Win32

Revision History:

    30-Sep-1993 rfirth
        Created

--*/

#include "vw.h"
#pragma hdrstop

//
// private prototypes
//

PRIVATE
VOID
VwInvalidFunction(
    VOID
    );

//
// private data
//

PRIVATE
VOID
(*VwDispatchTable[])(VOID) = {
    VwIPXOpenSocket,                // 0x00
    VwIPXCloseSocket,               // 0x01
    VwIPXGetLocalTarget,            // 0x02
    VwIPXSendPacket,                // 0x03
    VwIPXListenForPacket,           // 0x04
    VwIPXScheduleIPXEvent,          // 0x05
    VwIPXCancelEvent,               // 0x06
    VwIPXScheduleAESEvent,          // 0x07
    VwIPXGetIntervalMarker,         // 0x08
    VwIPXGetInternetworkAddress,    // 0x09
    VwIPXRelinquishControl,         // 0x0A
    VwIPXDisconnectFromTarget,      // 0x0B
    VwInvalidFunction,              // 0x0C
    VwInvalidFunction,              // 0x0D     old-style GetMaxPacketSize
    VwInvalidFunction,              // 0x0E
    VwInvalidFunction,              // 0x0F     internal send packet function
    VwSPXInitialize,                // 0x10
    VwSPXEstablishConnection,       // 0x11
    VwSPXListenForConnection,       // 0x12
    VwSPXTerminateConnection,       // 0x13
    VwSPXAbortConnection,           // 0x14
    VwSPXGetConnectionStatus,       // 0x15
    VwSPXSendSequencedPacket,       // 0x16
    VwSPXListenForSequencedPacket,  // 0x17
    VwInvalidFunction,              // 0x18
    VwInvalidFunction,              // 0x19
    VwIPXGetMaxPacketSize,          // 0x1A
    VwInvalidFunction,              // 0x1B
    VwInvalidFunction,              // 0x1C
    VwInvalidFunction,              // 0x1D
    VwInvalidFunction,              // 0x1E
    VwIPXGetInformation,            // 0x1F
    VwIPXSendWithChecksum,          // 0x20
    VwIPXGenerateChecksum,          // 0x21
    VwIPXVerifyChecksum             // 0x22
};

#define MAX_IPXSPX_FUNCTION LAST_ELEMENT(VwDispatchTable)

WSADATA WsaData = {0};
HANDLE hAesThread = NULL;

//
// global data
//

SOCKADDR_IPX MyInternetAddress;
WORD MyMaxPacketSize;
int Ica;
BYTE IcaLine;

//
// not-really-global data
//

extern CRITICAL_SECTION SerializationCritSec;
extern CRITICAL_SECTION AsyncCritSec;

//
// functions
//


BOOL
WINAPI
VwDllEntryPoint(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    Called when the process attaches (LoadLibrary/init) and detaches (FreeLibrary/
    process termination) from this DLL

    Attach:
        initialize Winsock DLL
        get internet address for this station
        get maximum packet size supported by transport (IPX)
        create AES thread

    Detach:
        terminate Winsock DLL

Arguments:

    DllHandle   - unused
    Reason      - checked for process attach/detach
    Context     - unused

Return Value:

    BOOLEAN

--*/

{
    DWORD aesThreadId;  // unused outside of this function

    static BOOL CriticalSectionsAreInitialized = FALSE;

    UNREFERENCED_PARAMETER(DllHandle);
    UNREFERENCED_PARAMETER(Context);

    IPXDBGSTART();

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "VwDllEntryPoint: %s\n",
                Reason == DLL_PROCESS_ATTACH ? "DLL_PROCESS_ATTACH"
                : Reason == DLL_PROCESS_DETACH ? "DLL_PROCESS_DETACH"
                : Reason == DLL_THREAD_ATTACH ? "DLL_THREAD_ATTACH"
                : Reason == DLL_THREAD_DETACH ? "DLL_THREAD_DETACH"
                : "?"
                ));

    if (Reason == DLL_PROCESS_ATTACH) {

        int err;

        //
        // TRACKING: get ICA values from new VDD service. Right now we grab
        // line 4 on the slave (base = 0x70, modifier = 0x03)
        //

        Ica = ICA_SLAVE;
        IcaLine = 3;

        err = WSAStartup(MAKEWORD(1, 1), &WsaData);
        if (err) {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_FATAL,
                        "VwDllEntryPoint: WSAStartup() returns %d\n",
                        err
                        ));

            return FALSE;
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_INFO,
                        "VwDllEntryPoint: WsaData:\n"
                         "\twVersion       : 0x%04x\n"
                         "\twHighVersion   : 0x%04x\n"
                         "\tszDescription  : \"%s\"\n"
                         "\tszSystemStatus : \"%s\"\n"
                         "\tiMaxSockets    : %d\n"
                         "\tiMaxUdpDg      : %d\n"
                         "\tlpVendorInfo   : 0x%08x\n",
                         WsaData.wVersion,
                         WsaData.wHighVersion,
                         WsaData.szDescription,
                         WsaData.szSystemStatus,
                         WsaData.iMaxSockets,
                         WsaData.iMaxUdpDg,
                         WsaData.lpVendorInfo
                         ));

        }

        //
        // retrieve the internet address for this station. Used in
        // IPXGetInternetworkAddress() and IPXSendPacket()
        //

        err = GetInternetAddress(&MyInternetAddress);
        if (err) {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_FATAL,
                        "VwDllEntryPoint: GetInternetAddress() returns %d\n",
                        WSAGetLastError()
                        ));

            goto attach_error_exit;
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_INFO,
                        "VwDllEntryPoint: MyInternetAddress:\n"
                        "\tNet  : %02.2x-%02.2x-%02.2x-%02.2x\n"
                        "\tNode : %02.2x-%02.2x-%02.2x-%02.2x-%02.2x-%02.2x\n",
                        MyInternetAddress.sa_netnum[0] & 0xff,
                        MyInternetAddress.sa_netnum[1] & 0xff,
                        MyInternetAddress.sa_netnum[2] & 0xff,
                        MyInternetAddress.sa_netnum[3] & 0xff,
                        MyInternetAddress.sa_nodenum[0] & 0xff,
                        MyInternetAddress.sa_nodenum[1] & 0xff,
                        MyInternetAddress.sa_nodenum[2] & 0xff,
                        MyInternetAddress.sa_nodenum[3] & 0xff,
                        MyInternetAddress.sa_nodenum[4] & 0xff,
                        MyInternetAddress.sa_nodenum[5] & 0xff
                        ));

        }

        //
        // get the maximum packet size supported by IPX. Used in
        // IPXGetMaxPacketSize()
        //

        err = GetMaxPacketSize(&MyMaxPacketSize);
        if (err) {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_FATAL,
                        "VwDllEntryPoint: GetMaxPacketSize() returns %d\n",
                        WSAGetLastError()
                        ));

            goto attach_error_exit;
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_INFO,
                        "VwDllEntryPoint: GetMaxPacketSize: %04x (%d)\n",
                        MyMaxPacketSize,
                        MyMaxPacketSize
                        ));

        }

        hAesThread = CreateThread(NULL,
                                  0,
                                  (LPTHREAD_START_ROUTINE)VwAesThread,
                                  NULL,
                                  0,
                                  &aesThreadId
                                  );
        if (hAesThread == NULL) {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_FATAL,
                        "VwDllEntryPoint: CreateThread() returns %d\n",
                        GetLastError()
                        ));

            goto attach_error_exit;
        }

        //
        // finally initialize any critical sections
        //

        InitializeCriticalSection(&SerializationCritSec);
        InitializeCriticalSection(&AsyncCritSec);
        CriticalSectionsAreInitialized = TRUE;
    } else if (Reason == DLL_PROCESS_DETACH) {
        if (hAesThread != NULL) {
            WaitForSingleObject(hAesThread, ONE_TICK * 2);
            CloseHandle(hAesThread);
        }

        WSACleanup();

        if (CriticalSectionsAreInitialized) {
            DeleteCriticalSection(&SerializationCritSec);
            DeleteCriticalSection(&AsyncCritSec);
        }

        IPXDBGEND();
    }
    return TRUE;

attach_error_exit:

    //
    // here if any fatal errors on process attach after successfully performing
    // WSAStartup
    //

    WSACleanup();
    return FALSE;
}

BYTE
VWinInitialize(
    VOID
    )
/*++

Routine Description:

    Called by interface when nwipxspx.dll is loaded. We
    return the IRQ value.

Arguments:

    None.

Return Value:

    The IRQ value.

--*/

{
    return 0x73;
}



VOID
VwInitialize(
    VOID
    )

/*++

Routine Description:

    Called by VDD interface when DLL loaded via call to RegisterModule. We
    get the IRQ value and return it as an interrupt vector in BX

Arguments:

    None.

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "VwInitialize\n"
                ));

    //
    // only lines on slave PIC are available. Currently, lines 3, 4 and 7 are
    // not used. We'll grab line 3 here, but in the future we expect a function
    // to return the available IRQ line
    //

    setBX( VWinInitialize() );
}


VOID
VwDispatcher(
    VOID
    )

/*++

Routine Description:

    Branches to relevant IPX/SPX handler for DOS calls, based on contents of
    VDM BX register.

    Control transfered here from 16-bit entry point, either as result of call
    to far address returned from INT 2Fh/AH=7A or INT 7Ah

    Special: we use BX = 0xFFFF to indicate that the app is terminating. The
    TSR hooks INT 0x2F/AX=0x1122 (IFSResetEnvironment)

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD dispatchIndex;

    dispatchIndex = (DWORD)getBX() & 0x7fff;

    if (dispatchIndex <= MAX_IPXSPX_FUNCTION) {
        VwDispatchTable[dispatchIndex]();
    } else if (dispatchIndex == 0x7FFE) {
        EsrCallback();
    } else if (dispatchIndex == 0x7FFF) {
        VwTerminateProgram();
    } else {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_ERROR,
                    "ERROR: VwDispatcher: dispatchIndex = %x\n",
                    dispatchIndex
                    ));

        setAX(ERROR_INVALID_FUNCTION);
        setCF(1);
    }
}


PRIVATE
VOID
VwInvalidFunction(
    VOID
    )

/*++

Routine Description:

    Just alerts us to the fact that an invalid function request was made.
    Useful if any app makes a bad call, or we miss out a required function
    during design/implementation

Arguments:

    None.

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "VwInvalidFunction: BX=%04x\n",
                getBX()
                ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\vwasync.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwasync.c

Abstract:

    ntVdm netWare (Vw) IPX/SPX Functions

    Vw: The peoples' network

    Contains Asyncrhonous Event Scheduler (thread)

    Contents:
        VwAesThread
        (CheckPendingIpxRequests)

Author:

    Richard L Firth (rfirth) 30-Sep-1993

Environment:

    User-mode Win32

Revision History:

    30-Sep-1993 rfirth
        Created

--*/

#include "vw.h"
#pragma hdrstop

//
// private routine prototypes
//

PRIVATE
VOID
CheckPendingIpxRequests(
    VOID
    );

//
// global data
//

WORD AesTickCount;

//
// functions
//


#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif
DWORD
VwAesThread(
    IN LPVOID Parameters
    )

/*++

Routine Description:

    Provides the functionality of the Asynchronous Event Scheduler (AES) in the
    Netware world:

        - updates the tick count
        - completes any matured timer events
        - checks any pending requests and schedules the next action

    This thread wakes up every PC tick (1/18 second)

Arguments:

    Parameters  - unused

Return Value:

    DWORD
        0

--*/

{
    BOOL fOperationPerformed = FALSE ;
    static int n = 1 ;

    UNREFERENCED_PARAMETER(Parameters);

    while (TRUE)
    {
        //
        // we will always yield in this loop to be friendly to others,
        // but occasionally we will forcefully do a non zero sleep for
        // lower priority threads to run.
        //
        if ((n % 100) == 0)
        {
            Sleep(ONE_TICK) ;
            n = 1 ;
        }
        if (!fOperationPerformed && ((n % 4) == 0))
        {
            Sleep(10) ;
            n++ ;
        }
        else
        {
            Sleep(0) ;
            n++ ;
        }

        ++AesTickCount;
        ScanTimerList();
        CheckPendingIpxRequests();
        CheckPendingSpxRequests(&fOperationPerformed);
    }

    return 0;   // compiler-pacifier
}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif



PRIVATE
VOID
CheckPendingIpxRequests(
    VOID
    )

/*++

Routine Description:

    Polls the opened, active non-blocking IPX sockets to see if there is anything
    to do (data to receive, availability to send, timeouts)

Arguments:

    None.

Return Value:

    None.

--*/

{
    LPSOCKET_INFO pActiveSocket = NULL;

    //
    // search SOCKET_INFO structures for something to do. Could do select()
    // but we have most of the info anyway. We use the BFI filter mechanism
    //

    while (pActiveSocket = FindActiveSocket(pActiveSocket)) {
        if (pActiveSocket->Flags & SOCKET_FLAG_SENDING) {
            IpxSendNext(pActiveSocket);
        }
        if (pActiveSocket->Flags & SOCKET_FLAG_LISTENING) {
            IpxReceiveNext(pActiveSocket);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\vwdll.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vwdll.h

Abstract:

    Contains external data declarations for VWDLL.C

Author:

    Richard L Firth (rfirth) 25-Oct-1993

Revision History:

    25-Oct-1993 rfirth
        Created

--*/

extern SOCKADDR_IPX MyInternetAddress;
extern WORD MyMaxPacketSize;
extern int Ica;
extern BYTE IcaLine;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\vwdebug.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwdebug.h

Abstract:

    Prototypes, structures, manifests, macros for VWIPXSPX debug routines

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

#ifndef _VWDEBUG_H_
#define _VWDEBUG_H_

//
// debug flags
//

#define DEBUG_ANY       0xFFFFFFFF      // any debug flags set
#define DEBUG_NOTHING   0x00000001      // no debug output
#define DEBUG_CHECK_INT 0x00080000      // check interrupts (DOS)
#define DEBUG_STATS     0x00100000      // dump connection stats
#define DEBUG_DATA      0x00200000      // dump data (send)
#define DEBUG_FRAGMENTS 0x00400000      // dump fragments
#define DEBUG_HEADERS   0x00800000      // dump IPX/SPX headers
#define DEBUG_ECB       0x01000000      // dump 16-bit ECBs
#define DEBUG_XECB      0x02000000      // dump 32-bit XECBs
#define DEBUG_SOCKINFO  0x04000000      // dump SOCKET_INFO structs
#define DEBUG_CONNINFO  0x08000000      // dump CONNECTION_INFO structs
#define DEBUG_DLL       0x10000000      // include DLL attach/detach info
#define DEBUG_FLUSH     0x20000000      // flush every write
#define DEBUG_TO_FILE   0x40000000      // write debug stuff to file
#define DEBUG_TO_DBG    0x80000000      // debug stuff to debugger

#define VWDEBUG_FILE    "VWDEBUG.LOG"

//
// function designators
//

#define FUNCTION_ANY                            0xFFFFFFFF
#define FUNCTION_IPXOpenSocket                  0x00000001  // 0x00
#define FUNCTION_IPXCloseSocket                 0x00000002  // 0x01
#define FUNCTION_IPXGetLocalTarget              0x00000004  // 0x02
#define FUNCTION_IPXSendPacket                  0x00000008  // 0x03
#define FUNCTION_IPXListenForPacket             0x00000010  // 0x04
#define FUNCTION_IPXScheduleIPXEvent            0x00000020  // 0x05
#define FUNCTION_IPXCancelEvent                 0x00000040  // 0x06
#define FUNCTION_IPXScheduleAESEvent            0x00000080  // 0x07
#define FUNCTION_IPXGetIntervalMarker           0x00000100  // 0x08
#define FUNCTION_IPXGetInternetworkAddress      0x00000200  // 0x09
#define FUNCTION_IPXRelinquishControl           0x00000400  // 0x0A
#define FUNCTION_IPXDisconnectFromTarget        0x00000800  // 0x0B
#define FUNCTION_InvalidFunction_0C             0x00001000  // 0x0C
#define FUNCTION_InvalidFunction_0D             0x00002000  // 0x0D
#define FUNCTION_InvalidFunction_0E             0x00004000  // 0x0E
#define FUNCTION_InvalidFunction_0F             0x00008000  // 0x0F
#define FUNCTION_SPXInitialize                  0x00010000  // 0x10
#define FUNCTION_SPXEstablishConnection         0x00020000  // 0x11
#define FUNCTION_SPXListenForConnection         0x00040000  // 0x12
#define FUNCTION_SPXTerminateConnection         0x00080000  // 0x13
#define FUNCTION_SPXAbortConnection             0x00100000  // 0x14
#define FUNCTION_SPXGetConnectionStatus         0x00200000  // 0x15
#define FUNCTION_SPXSendSequencedPacket         0x00400000  // 0x16
#define FUNCTION_SPXListenForSequencedPacket    0x00800000  // 0x17
#define FUNCTION_InvalidFunction_18             0x01000000  // 0x18
#define FUNCTION_InvalidFunction_19             0x02000000  // 0x19
#define FUNCTION_IPXGetMaxPacketSize            0x04000000  // 0x1A
#define FUNCTION_InvalidFunction_1B             0x08000000  // 0x1B
#define FUNCTION_InvalidFunction_1C             0x10000000  // 0x1C
#define FUNCTION_InvalidFunction_1D             0x20000000  // 0x1D
#define FUNCTION_InvalidFunction_1E             0x40000000  // 0x1E
#define FUNCTION_IPXGetInformation              0x80000000  // 0x1F
#define FUNCTION_IPXSendWithChecksum            0xFFFFFFFF  // 0x20
#define FUNCTION_IPXGenerateChecksum            0xFFFFFFFF  // 0x21
#define FUNCTION_IPXVerifyChecksum              0xFFFFFFFF  // 0x22

//
// debug levels
//

#define IPXDBG_LEVEL_ALL        0
#define IPXDBG_LEVEL_INFO       1
#define IPXDBG_LEVEL_WARNING    2
#define IPXDBG_LEVEL_ERROR      3
#define IPXDBG_LEVEL_FATAL      4

#define IPXDBG_MIN_LEVEL        IPXDBG_LEVEL_ALL
#define IPXDBG_MAX_LEVEL        IPXDBG_LEVEL_FATAL

//
// info dump flags (VWDUMP)
//

#define DUMP_ECB_IN         0x00000001
#define DUMP_ECB_OUT        0x00000002
#define DUMP_SEND_DATA      0x00000004
#define DUMP_RECEIVE_DATA   0x00000008

//
// show flags
//

#define SHOW_ECBS           0x00000001  // show ECBs vs. raw data
#define SHOW_HEADERS        0x00000002  // show IPX/SPX headers vs. raw data

#if DBG

extern DWORD VwDebugFlags;
extern DWORD VwDebugFunctions;
extern DWORD VwShow;
extern DWORD DebugFlagsEx;


#define IF_DEBUG(f)     if (VwDebugFlags & DEBUG_ ## f)
#define IF_NOT_DEBUG(f) if (!(VwDebugFlags & DEBUG_ ## f))
#define IF_SHOW(f)      if (VwShow & SHOW_ ## f)
#define IF_NOT_SHOW(f)  if (!(VwShow & SHOW_ ## f))
#define PRIVATE
#define IPXDBGPRINT(x)  VwDebugPrint x
#define IPXDBGSTART()   VwDebugStart()
#define IPXDBGEND()     VwDebugEnd()
#define VWASSERT(a, b)  ASSERT((a) == (b))
#define IPXDUMPDATA(x)  VwDumpData x
#define IPXDUMPECB(x)   VwDumpEcb x
#define DUMPXECB(x)     VwDumpXecb(x)
#define DUMPCONN(x)     VwDumpConnectionInfo(x)
#define DUMPSTATS(x)    VwDumpConnectionStats(x)
#define CHECK_INTERRUPTS(s) CheckInterrupts(s)
#define DUMPALL()       VwDumpAll()

#else

#define IF_DEBUG(f)     if (0)
#define IF_NOT_DEBUG(f) if (0)
#define IF_SHOW(f)      if (0)
#define IF_NOT_SHOW(f)  if (0)
#define PRIVATE         static
#define IPXDBGPRINT(x)
#define IPXDBGSTART()
#define IPXDBGEND()
#define VWASSERT(a, b)  a
#define IPXDUMPDATA(x)
#define IPXDUMPECB(x)
#define DUMPXECB(x)
#define DUMPCONN(x)
#define DUMPSTATS(x)
#define CHECK_INTERRUPTS(s)
#define DUMPALL()

#endif

//
// debug function prototypes
//

extern VOID VwDebugStart(VOID);
extern VOID VwDebugEnd(VOID);
extern VOID VwDebugPrint(LPSTR, DWORD, DWORD, DWORD, LPSTR, ...);
extern VOID VwDumpData(ULPBYTE, WORD, WORD, BOOL, WORD);
extern VOID VwDumpEcb(LPECB, WORD, WORD, BYTE, BOOL, BOOL, BOOL);
extern VOID VwDumpFragment(WORD, LPFRAGMENT, BYTE, BOOL, BOOL);
extern VOID VwDumpPacketHeader(ULPBYTE, BYTE);
extern VOID VwDumpXecb(LPXECB);
extern VOID VwDumpSocketInfo(LPSOCKET_INFO);
extern VOID VwDumpConnectionInfo(LPCONNECTION_INFO);
extern VOID VwDumpConnectionStats(LPSPX_CONNECTION_STATS);
extern VOID VwLog(LPSTR);
extern VOID CheckInterrupts(LPSTR);
extern VOID VwDumpAll(VOID);

#endif  // _VWDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\vwinapi.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwinapi.h

Abstract:

    Contains function prototypes for WIN IPX/SPX functions

Author:


Environment:

    User-mode Win32

Revision History:

    28-Oct-1993 yihsins
        Created

--*/

WORD
VWinIPXCancelEvent(
    IN DWORD IPXTaskID,
    IN LPECB pEcb
    );

VOID
VWinIPXCloseSocket(
    IN DWORD IPXTaskID,
    IN WORD socketNumber
    );

VOID
VWinIPXDisconnectFromTarget(
    IN DWORD IPXTaskID,
    OUT LPBYTE pNetworkAddress
    );

VOID
VWinIPXGetInternetworkAddress(
    IN DWORD IPXTaskID,
    OUT LPINTERNET_ADDRESS pNetworkAddress
    );

WORD
VWinIPXGetIntervalMarker(
    IN DWORD IPXTaskID
    );

WORD
VWinIPXGetLocalTarget(
    IN DWORD IPXTaskID,
    IN LPBYTE pNetworkAddress,
    OUT LPBYTE pImmediateAddress,
    OUT ULPWORD pTransportTime
    );

WORD
VWinIPXGetLocalTargetAsync(
    IN LPBYTE pSendAGLT,
    OUT LPBYTE pListenAGLT,
    IN WORD windowsHandle
    );

WORD
VWinIPXGetMaxPacketSize(
    VOID
    );

WORD
VWinIPXInitialize(
    IN OUT ULPDWORD pIPXTaskID,
    IN WORD maxECBs,
    IN WORD maxPacketSize
    );

VOID
VWinIPXListenForPacket(
    DWORD IPXTaskID,
    LPECB pEcb,
    ECB_ADDRESS EcbAddress
    );

WORD
VWinIPXOpenSocket(
    IN DWORD  IPXTaskID,
    IN OUT ULPWORD pSocketNumber,
    IN BYTE socketType
    );

VOID
VWinIPXRelinquishControl(
    VOID
    );

VOID
VWinIPXScheduleIPXEvent(
    IN DWORD IPXTaskID,
    IN WORD time,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

VOID
VWinIPXSendPacket(
    IN DWORD IPXTaskID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

WORD
VWinIPXSPXDeinit(
    IN DWORD IPXTaskID
    );

VOID
VWinSPXAbortConnection(
    IN WORD SPXConnectionID
    );

WORD
VWinSPXEstablishConnection(
    IN DWORD IPXTaskID,
    IN BYTE retryCount,
    IN BYTE watchDog,
    OUT ULPWORD pSPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

WORD
VWinSPXGetConnectionStatus(
    IN DWORD IPXTaskID,
    IN WORD SPXConnectionID,
    IN LPSPX_CONNECTION_STATS pConnectionStats
    );

WORD
VWinSPXInitialize(
    IN OUT DWORD UNALIGNED* pIPXTaskID,
    IN WORD maxECBs,
    IN WORD maxPacketSize,
    OUT LPBYTE pMajorRevisionNumber,
    OUT LPBYTE pMinorRevisionNumber,
    OUT WORD UNALIGNED* pMaxConnections,
    OUT WORD UNALIGNED* pAvailableConnections
    );

VOID
VWinSPXListenForConnection(
    IN DWORD IPXTaskID,
    IN BYTE retryCount,
    IN BYTE watchDog,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );


VOID
VWinSPXListenForSequencedPacket(
    IN DWORD IPXTaskID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

VOID
VWinSPXSendSequencedPacket(
    IN DWORD IPXTaskID,
    IN WORD SPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

VOID
VWinSPXTerminateConnection(
    IN DWORD IPXTaskID,
    IN WORD SPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\vwint.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwint.h

Abstract:

    Contains internal function prototypes used by DOS/WIN IPX/SPX functions

Author:

    Yi-Hsin Sung (yihsins)   28-Oct-1993

Environment:

    User-mode Win32

Revision History:

    28-Oct-1993 yihsins
        Created

--*/

WORD
_VwIPXCancelEvent(
    IN LPECB pEcb
    );

VOID
_VwIPXCloseSocket(
    IN WORD SocketNumber
    );

VOID
_VwIPXGetInternetworkAddress(
    OUT LPINTERNET_ADDRESS pNetworkAddress
    );

WORD
_VwIPXGetIntervalMarker(
    VOID
    );

WORD
_VwIPXGetLocalTarget(
    IN LPBYTE pNetworkAddress,
    OUT LPBYTE pImmediateAddress,
    OUT ULPWORD pTransportTime
    );

WORD
_VwIPXGetMaxPacketSize(
    OUT ULPWORD pRetryCount
    );

WORD
_VwIPXListenForPacket(
    IN OUT LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

WORD
_VwIPXOpenSocket(
    IN OUT ULPWORD pSocketNumber,
    IN BYTE SocketType,
    IN WORD DosPDB
    );

VOID
_VwIPXRelinquishControl(
    VOID
    );

VOID
_VwIPXScheduleIPXEvent(
    IN WORD Time,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

VOID
_VwIPXSendPacket(
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress,
    IN WORD DosPDB
    );

VOID
_VwSPXAbortConnection(
    IN WORD SPXConnectionID
    );

WORD
_VwSPXEstablishConnection(
    IN BYTE RetryCount,
    IN BYTE WatchDog,
    OUT ULPWORD pSPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

WORD
_VwSPXGetConnectionStatus(
    IN WORD SPXConnectionID,
    OUT LPSPX_CONNECTION_STATS pStats
    );

WORD
_VwSPXInitialize(
    OUT ULPBYTE pMajorRevisionNumber,
    OUT ULPBYTE pMinorRevisionNumber,
    OUT ULPWORD pMaxConnections,
    OUT ULPWORD pAvailableConnections
    );

VOID
_VwSPXListenForConnection(
    IN BYTE RetryCount,
    IN BYTE WatchDog,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

VOID
_VwSPXListenForSequencedPacket(
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

VOID
_VwSPXSendSequencedPacket(
    IN WORD SPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

VOID
_VwSPXTerminateConnection(
    IN WORD SPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\vwinapi.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwinapi.c

Abstract:

    ntVdm netWare (Vw) IPX/SPX Functions

    Contains handlers for WOW IPX/SPX calls (netware functions). The IPX/SPX
    APIs use WinSock to perform the actual operations

    Contents:
        VWinIPXCancelEvent
        VWinIPXCloseSocket
        VWinIPXDisconnectFromTarget
        VWinIPXGetInternetworkAddress
        VWinIPXGetIntervalMarker
        VWinIPXGetLocalTarget
        VWinIPXGetLocalTargetAsync
        VWinIPXGetMaxPacketSize
        VWinIPXInitialize
        VWinIPXListenForPacket
        VWinIPXOpenSocket
        VWinIPXRelinquishControl
        VWinIPXScheduleIPXEvent
        VWinIPXSendPacket
        VWinIPXSPXDeinit

        VWinSPXAbortConnection
        VWinSPXEstablishConnection
        VWinSPXGetConnectionStatus
        VWinSPXInitialize
        VWinSPXListenForConnection
        VWinSPXListenForSequencedPacket
        VWinSPXSendSequencedPacket
        VWinSPXTerminateConnection

Author:

    Yi-Hsin Sung ( yihsins ) 28-Oct-1993

Environment:

    User-mode Win32

Revision History:

    28-Oct-1993 yihsins
        Created

--*/

#include "vw.h"
#pragma hdrstop

//
// functions
//


WORD
VWinIPXCancelEvent(
    IN DWORD IPXTaskID,
    IN LPECB pEcb
    )

/*++

Routine Description:

    Cancels event described by an ECB

    This call is Synchronous

Arguments:

    Inputs
        IPXTaskID
        pECB

Return Value:

    00h Success
    F9h Can't cancel ECB
    FFh ECB not in use

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXCancelEvent,
                IPXDBG_LEVEL_INFO,
                "VWinIPXCancelEvent\n"
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    return _VwIPXCancelEvent( pEcb );
}


VOID
VWinIPXCloseSocket(
    IN DWORD IPXTaskID,
    IN WORD socketNumber
    )

/*++

Routine Description:

    Closes a socket and cancels any outstanding events on the socket.
    Closing an unopened socket does not return an error
    ESRs in cancelled ECBs are not called

    This call is Synchronous

Arguments:

    Inputs
        IPXTaskID
        socketNumber

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXCloseSocket,
                IPXDBG_LEVEL_INFO,
                "VWinIPXCloseSocket(%#x)\n",
                B2LW(socketNumber)
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    _VwIPXCloseSocket( socketNumber );
}


VOID
VWinIPXDisconnectFromTarget(
    IN DWORD IPXTaskID,
    IN LPBYTE pNetworkAddress
    )

/*++

Routine Description:

    Performs no action for NTVDM IPX

    This call is Synchronous

Arguments:

    Inputs
        IPXTaskID
        pNetworkAddress

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXDisconnectFromTarget,
                IPXDBG_LEVEL_INFO,
                "VWinIPXDisconnectFromTarget\n"
                ));
}


VOID
VWinIPXGetInternetworkAddress(
    IN DWORD IPXTaskID,
    OUT LPINTERNET_ADDRESS pNetworkAddress
    )

/*++

Routine Description:

    Returns a buffer containing the net number and node number for this
    station.

    This function cannot return an error (!)

    Assumes:    1. GetInternetAddress has been successfully called in the
                   DLL initialization phase

    This call is Synchronous

Arguments:

    Inputs
        IPXTaskID

    Outputs
        pNetworkAddress

Return Value:

    None.

--*/

{

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetInternetworkAddress,
                IPXDBG_LEVEL_INFO,
                "VWinIPXGetInternetworkAddress\n"
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    _VwIPXGetInternetworkAddress( pNetworkAddress );

}


WORD
VWinIPXGetIntervalMarker(
    IN DWORD IPXTaskID
    )

/*++

Routine Description:

    Just returns the tick count maintained by Asynchronous Event Scheduler

    This call is Synchronous

Arguments:

    Inputs
        IPXTaskID

    Outputs

Return Value:

    The tick count.

--*/

{
    WORD intervalMarker = _VwIPXGetIntervalMarker();

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetIntervalMarker,
                IPXDBG_LEVEL_INFO,
                "VWinIPXGetIntervalMarker: Returning %04x\n",
                intervalMarker
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    return intervalMarker;
}


WORD
VWinIPXGetLocalTarget(
    IN DWORD IPXTaskID,
    IN LPBYTE pNetworkAddress,
    OUT LPBYTE pImmediateAddress,
    OUT ULPWORD pTransportTime
    )

/*++

Routine Description:

    Given a target address of the form (network address {4}, node address {6}),
    returns the node address of the target if on the same network, or the node
    address of the router which knows how to get to the next hop in reaching the
    eventual target

    This call is Synchronous

Arguments:

    Inputs
        IPXTaskID
        pNetworkAddress

    Outputs
        pImmediateAddress
        pTransportTime


Return Value:

    00h Success
    F1h Ipx/Spx Not Initialized
    FAh No path to destination node found

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetLocalTarget,
                IPXDBG_LEVEL_INFO,
                "VWinIPXGetLocalTarget\n"
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    return _VwIPXGetLocalTarget( pNetworkAddress,
                                 pImmediateAddress,
                                 pTransportTime );
}


WORD
VWinIPXGetLocalTargetAsync(
    IN LPBYTE pSendAGLT,
    OUT LPBYTE pListenAGLT,
    IN WORD windowsHandle
    )

/*++

Routine Description:

    description-of-function.

    This call is Asynchronous

Arguments:

    pSendAGLT
    pListenAGLT
    windowsHandle

Return Value:

    00h Success
    F1h Ipx/Spx Not Initialized
    FAh No Local Target Identified

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "VWinIPXGetLocalTargetAsync\n"
                ));

    return IPX_SUCCESS;   // return success for now
}


WORD
VWinIPXGetMaxPacketSize(
    VOID
    )

/*++

Routine Description:

    Returns the maximum packet size the underlying network can handle

    Assumes:    1. A successfull call to GetMaxPacketSize has been made during
                   DLL initialization
                2. Maximum packet size is constant

    This call is Synchronous

Arguments:

    Inputs
        None.

Return Value:

    The max packet size.

--*/

{
    //
    // this is a WORD function in DOS and Windows: always return MaxPacketSize
    // in AX
    //

    WORD maxPacketSize = _VwIPXGetMaxPacketSize( NULL );

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetMaxPacketSize,
                IPXDBG_LEVEL_INFO,
                "VWinIPXGetMaxPacketSize: PacketSize=%d\n",
                maxPacketSize
                ));

    return maxPacketSize;
}


WORD
VWinIPXInitialize(
    IN OUT ULPDWORD pIPXTaskID,
    IN WORD maxECBs,
    IN WORD maxPacketSize
    )

/*++

Routine Description:

    Get the entry address for the IPX Interface.

Arguments:

    Inputs
        maxECBs
        maxPacketSize

    Output
        pIPXTaskID

Return Value:

    00h Success
    F0h Ipx NotInstalled
    F1h Ipx/Spx Not Initialized
    F2h No Dos Memory
    F3h No Free Ecb
    F4h Lock Failed
    F5h Over the maximum limit
    F6h Ipx/Spx Previously Initialized

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "VWinIPXInitialize (MaxECBs=%04x, MaxPacketSize=%04x)\n",
                maxECBs,
                maxPacketSize
                ));

    UNREFERENCED_PARAMETER( maxECBs );          // ignore for now
    UNREFERENCED_PARAMETER( maxPacketSize );    // ignore for now

    return IPX_SUCCESS;
}


VOID
VWinIPXListenForPacket(
    IN DWORD IPXTaskID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Queue a listen request against a socket. All listen requests will be
    completed asynchronously, unless cancelled by app

    This call is Asynchronous

Arguments:

    Inputs
        IPXTaskID
        pEcb
        EcbAddress

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXListenForPacket,
                IPXDBG_LEVEL_INFO,
                "VWinIPXListenForPacket(%04x:%04x)\n",
                HIWORD(EcbAddress),
                LOWORD(EcbAddress)
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    (VOID) _VwIPXListenForPacket( pEcb, EcbAddress );
}


WORD
VWinIPXOpenSocket(
    IN DWORD IPXTaskID,
    IN OUT ULPWORD pSocketNumber,
    IN BYTE socketType
    )

/*++

Routine Description:

    Opens a socket for use by IPX or SPX.Puts the socket into non-blocking mode.
    The socket will be bound to IPX.

    This call is Synchronous

Arguments:

    Inputs
        IPXTaskID
        *pSocketNumber
        socketType - Socket Longevity flag

    Outputs
        pSocketNumber - Assigned socket number

Return Value:

    00h Success
    F0h Ipx Not Installed
    F1h Ipx/Spx Not Initialized
    FEh Socket table full
    FFh Socket already open

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXOpenSocket,
                IPXDBG_LEVEL_INFO,
                "VwIPXOpenSocket(Life=%02x, Socket=%04x)\n",
                socketType,
                B2LW(*pSocketNumber)
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    return _VwIPXOpenSocket( pSocketNumber,
                             socketType,
                             0 );

}


VOID
VWinIPXRelinquishControl(
    VOID
    )

/*++

Routine Description:

    Just sleep for a nominal amount. Netware seems to be dependent on the
    default setting of the PC clock, so one timer tick (1/18 second) would
    seem to be a good value

    This call is Synchronous

Arguments:

    None.

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXRelinquishControl,
                IPXDBG_LEVEL_INFO,
                "VWinIPXRelinquishControl\n"
                ));

    _VwIPXRelinquishControl();
}


VOID
VWinIPXScheduleIPXEvent(
    IN DWORD IPXTaskID,
    IN WORD time,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Schedules a an event to occur in some number of ticks. When the tick count
    reaches 0, the ECB InUse field is cleared and any ESR called

    This call is Asynchronous

Arguments:

    Inputs
        IPXTaskID
        time
        pEcb
        EcbAddress

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXScheduleIPXEvent,
                IPXDBG_LEVEL_INFO,
                "VWinIPXScheduleIPXEvent(%04x:%04x, Time:%04x)\n",
                HIWORD( EcbAddress ),
                LOWORD( EcbAddress ),
                time
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    _VwIPXScheduleIPXEvent( time, pEcb, EcbAddress );
}


VOID
VWinIPXSendPacket(
    IN DWORD IPXTaskID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Sends a packet to the target machine/router. This call can be made on a
    socket that is not open

    The app must have filled in the following IPX_ECB fields:

        EsrAddress
        Socket
        ImmediateAddress
        FragmentCount
        fragment descriptor fields

    and the following IPX_PACKET fields:

        PacketType
        Destination.Net
        Destination.Node
        Destination.Socket

    This call is Asynchronous

Arguments:

    Inputs
        IPXTaskID
        pEcb
        EcbAddress

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXSendPacket,
                IPXDBG_LEVEL_INFO,
                "VWinIPXSendPacket(%04x:%04x)\n",
                HIWORD( EcbAddress ),
                LOWORD( EcbAddress )
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    _VwIPXSendPacket( pEcb, EcbAddress, 0);
}


WORD
VWinIPXSPXDeinit(
    IN DWORD IPXTaskID
    )

/*++

Routine Description:

    Release any resources allocated to an application by NWIPXSPX.DLL
    for use by other applications.

    This call is Synchronous

Arguments:

    None.

Return Value:

    00h Successful
    F1h IPX/SPX Not Initialized

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "VwIPXSPXDeinit\n"
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );
    return IPX_SUCCESS;
}


VOID
VWinSPXAbortConnection(
    IN WORD SPXConnectionID
    )

/*++

Routine Description:

    Abort an SPX connection.

    This call is Synchronous

Arguments:

    SPXConnectionID

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXAbortConnection,
                IPXDBG_LEVEL_INFO,
                "VWinSPXAbortConnection(%04x)\n",
                SPXConnectionID
                ));

    _VwSPXAbortConnection(SPXConnectionID);
}


WORD
VWinSPXEstablishConnection(
    IN DWORD IPXTaskID,
    IN BYTE retryCount,
    IN BYTE watchDog,
    OUT ULPWORD pSPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Establish a connection with a listening socket.

    This call is Synchronous

Arguments:

    Inputs
        IPXTaskID
        retryCount
        watchDog
        pEcb
        EcbAddress

    Outputs
        pSPXConnectionID
        pEcb

Return Value:

    00h  Success
    EFh  Connection Table Full
    F1h  IPX/SPX Not Initialized
    FDh  Malformed Packet
    FFh  Socket Not Opened

--*/

{

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXEstablishConnection,
                IPXDBG_LEVEL_INFO,
                "VWinSPXEstablishConnection(%02x, %02x, %04x:%04x)\n",
                retryCount,
                watchDog,
                HIWORD(EcbAddress),
                LOWORD(EcbAddress)
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    return _VwSPXEstablishConnection( retryCount,
                                      watchDog,
                                      pSPXConnectionID,
                                      pEcb,
                                      EcbAddress );
}


WORD
VWinSPXGetConnectionStatus(
    IN DWORD IPXTaskID,
    IN WORD SPXConnectionID,
    IN LPSPX_CONNECTION_STATS pConnectionStats
    )

/*++

Routine Description:

    Return the status of an SPX connection.

    This call is Synchronous

Arguments:

    Inputs
        IPXTaskID
        SPXConnectionID

    Outputs
        pConnectionStats

Return Value:

    00h  Success
    EEh  Invalid Connection
    F1h  IPX/SPX Not Initialized

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXGetConnectionStatus,
                IPXDBG_LEVEL_INFO,
                "VWinSPXGetConnectionStatus\n"
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    return _VwSPXGetConnectionStatus( SPXConnectionID,
                                      pConnectionStats );
}


WORD
VWinSPXInitialize(
    IN OUT ULPDWORD pIPXTaskID,
    IN WORD maxECBs,
    IN WORD maxPacketSize,
    OUT LPBYTE pMajorRevisionNumber,
    OUT LPBYTE pMinorRevisionNumber,
    OUT ULPWORD pMaxConnections,
    OUT ULPWORD pAvailableConnections
    )

/*++

Routine Description:

    Informs the app that SPX is present on this station

    This call is Synchronous

Arguments:

    pIPXTaskID              - on input, specifies how resources will be
                              allocated:

                                0x00000000  - directly to calling application
                                0xFFFFFFFE  - directly to calling application,
                                              but multiple initializations are
                                              allowed
                                0xFFFFFFFF  - resources allocated in a pool for
                                              multiple applications
    maxECBs                 - maximum number of outstanding ECBs
    maxPacketSize           - maximum packet size to be sent by the app
    pMajorRevisionNumber    - returned SPX major version #
    pMinorRevisionNumber    - returned SPX minor version #
    pMaxConnections         - maximum connections supported by this SPX version
    pAvailableConnections   - number of connections available to this app

Return Value:

    WORD
        0x0000  SPX not installed
        0x00F1  IPX/SPX not installed
        0x00F2  no DOS memory
        0x00F3  no free ECBs
        0x00F4  lock failed
        0x00F5  exceeded maximum limit
        0x00F6  IPX/SPX already initialized
        0x00FF  SPX installed

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXInitialize,
                IPXDBG_LEVEL_INFO,
                "VWinSPXInitialize\n"
               ));

    UNREFERENCED_PARAMETER( maxECBs );        // ignore for now
    UNREFERENCED_PARAMETER( maxPacketSize );  // ignore for now

    //
    // do the same thing as 16-bit windows and return the task ID unchanged
    //

//    *pIPXTaskID = 0;

    return _VwSPXInitialize( pMajorRevisionNumber,
                             pMinorRevisionNumber,
                             pMaxConnections,
                             pAvailableConnections );
}


VOID
VWinSPXListenForConnection(
    IN DWORD IPXTaskID,
    IN BYTE retryCount,
    IN BYTE watchDog,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Listens for an incoming connection request

    This call is Asynchronous

Arguments:

    Inputs
        IPXTaskID
        retryCount
        watchDogFlag
        pEcb
        EcbAddress

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXListenForConnection,
                IPXDBG_LEVEL_INFO,
                "VWinSPXListenForConnection(%02x, %02x, %04x:%04x)\n",
                retryCount,
                watchDog,
                HIWORD(EcbAddress),
                LOWORD(EcbAddress)
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    _VwSPXListenForConnection( retryCount,
                               watchDog,
                               pEcb,
                               EcbAddress );
}


VOID
VWinSPXListenForSequencedPacket(
    IN DWORD IPXTaskID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Attempts to receive an SPX packet.

    This call is Asynchronous

Arguments:

    Inputs
        IPXTaskID
        pEcb
        EcbAddress

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXListenForSequencedPacket,
                IPXDBG_LEVEL_INFO,
                "VWinSPXListenForSequencedPacket(%04x:%04x)\n",
                HIWORD(EcbAddress),
                LOWORD(EcbAddress)
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    _VwSPXListenForSequencedPacket( pEcb,
                                    EcbAddress );
}


VOID
VWinSPXSendSequencedPacket(
    IN DWORD IPXTaskID,
    IN WORD SPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Sends a packet on an SPX connection

    This call is Asynchronous

Arguments:

    Inputs
        IPXTaskID
        SPXConnectionID
        pEcb
        EcbAddress

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXSendSequencedPacket,
                IPXDBG_LEVEL_INFO,
                "VWinSPXSendSequencedPacket(%04x, %04x:%04x)\n",
                SPXConnectionID,
                HIWORD(EcbAddress),
                LOWORD(EcbAddress)
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    _VwSPXSendSequencedPacket( SPXConnectionID,
                               pEcb,
                               EcbAddress );
}


VOID
VWinSPXTerminateConnection(
    IN DWORD IPXTaskID,
    IN WORD SPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Terminate an SPX connection by passing a connection ID and an
    ECB address to SPX. Then return control to the calling application.

    This call is Asynchronous

Arguments:

    Inputs
        IPXTaskID
        SPXConnectionID
        pEcb
        EcbAddress

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXTerminateConnection,
                IPXDBG_LEVEL_INFO,
                "VWinSPXTerminateConnection(%04x, %04x:%04x)\n",
                SPXConnectionID,
                HIWORD(EcbAddress),
                LOWORD(EcbAddress)
                ));

    // ignore IPXTaskID for now

    UNREFERENCED_PARAMETER( IPXTaskID );

    _VwSPXTerminateConnection(SPXConnectionID, pEcb, EcbAddress);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\vwipx.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vwipx.h

Abstract:

    Contains function prototypes for VWIPX.C

Author:

    Richard L Firth (rfirth) 25-Oct-1993

Revision History:

    25-Oct-1993 rfirth
        Created

--*/

VOID
VwIPXCancelEvent(
    VOID
    );

VOID
VwIPXCloseSocket(
    VOID
    );

VOID
VwIPXDisconnectFromTarget(
    VOID
    );

VOID
VwIPXGenerateChecksum(
    VOID
    );

VOID
VwIPXGetInformation(
    VOID
    );

VOID
VwIPXGetInternetworkAddress(
    VOID
    );

VOID
VwIPXGetIntervalMarker(
    VOID
    );

VOID
VwIPXGetLocalTarget(
    VOID
    );

VOID
VwIPXGetLocalTargetAsync(
    VOID
    );

VOID
VwIPXGetMaxPacketSize(
    VOID
    );

VOID
VwIPXInitialize(
    VOID
    );

VOID
VwIPXListenForPacket(
    VOID
    );

VOID
VwIPXOpenSocket(
    VOID
    );

VOID
VwIPXRelinquishControl(
    VOID
    );

VOID
VwIPXScheduleAESEvent(
    VOID
    );

VOID
VwIPXScheduleIPXEvent(
    VOID
    );

VOID
VwIPXSendPacket(
    VOID
    );

VOID
VwIPXSendWithChecksum(
    VOID
    );

VOID
VwIPXSPXDeinit(
    VOID
    );

VOID
VwIPXVerifyChecksum(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\vwipxspx.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwipxspx.h

Abstract:

    Contains manifests, typedefs, structures, macros for NTVDM IPX/SPX support

Author:

    Richard L Firth (rfirth) 30-Sep-1993

Environment:

    Structures are expected to live in segmented VDM address space, but be
    accessible from flat 32-bit protect mode. The VDM can be in real or protect
    mode

Revision History:

    30-Sep-1993 rfirth
        Created

--*/

#ifndef _VWIPXSPX_H_
#define _VWIPXSPX_H_

//
// FREE_OBJECT - in free version, just calls LocalFree. For debug version, fills
// memory with some arbitrary value, then frees the pointer and checks that what
// LocalFree thought that the pointer pointed at a valid, freeable object
//

#if DBG

#define FREE_OBJECT(p)      {\
                                FillMemory(p, sizeof(*p), 0xFF);\
                                VWASSERT(LocalFree((HLOCAL)(p)), NULL);\
                            }
#else

#define FREE_OBJECT(p)      VWASSERT(LocalFree((HLOCAL)(p)), NULL)

#endif

//
// simple function macros
//

//#define AllocateXecb()      (LPXECB)LocalAlloc(LPTR, sizeof(XECB))
//#define DeallocateXecb(p)   FREE_OBJECT(p)
#define AllocateBuffer(s)   (LPVOID)LocalAlloc(LMEM_FIXED, (s))
#define DeallocateBuffer(p) FREE_OBJECT(p)

//
// pseudo-types for 16-bit addresses
//

#define ESR_ADDRESS DWORD
#define ECB_ADDRESS DWORD

//
// from Novell documentation, the default maximum open sockets. Max max is 150
//

#ifndef DEFAULT_MAX_OPEN_SOCKETS
#define DEFAULT_MAX_OPEN_SOCKETS    20
#endif

#ifndef MAX_OPEN_SOCKETS
#define MAX_OPEN_SOCKETS        150
#endif

#define SPX_INSTALLED           0xFF

#define MAX_LISTEN_QUEUE_SIZE   5   // ?

//
// misc. macros
//

//
// B2LW, L2Bx - big-endian to little-endian macros
//

#define B2LW(w)                 (WORD)(((WORD)(w) << 8) | ((WORD)(w) >> 8))
#define B2LD(d)                 (DWORD)(B2LW((DWORD)(d) << 16) | B2LW((DWORD)(d) >> 16))
#define L2BW(w)                 B2LW(w)
#define L2BD(d)                 B2LD(d)

//
// miscellaneous manifests
//

#define ONE_TICK    (1000/18)           // 1/18 sec in milliseconds (55.55 mSec)
#define SLEEP_TIME  ONE_TICK            // amount of time we Sleep() during IPXRelinquishControl

//
// options for IPXGetInformation
//

#define IPX_ODI                     0x0001
#define IPX_CHECKSUM_FUNCTIONS      0x0002

//
// IPX/SPX structures. The following structures are in VDM format, and should
// be packed on a byte-boundary
//
// Netware maintains certain structure fields in network (big-endian) format
//

#include <packon.h>

//
// INTERNET_ADDRESS - structure returned by IPXGetInternetworkAddress
//

typedef struct {
    BYTE Net[4];
    BYTE Node[6];
} INTERNET_ADDRESS ;

typedef INTERNET_ADDRESS UNALIGNED *LPINTERNET_ADDRESS;

//
// NETWARE_ADDRESS - address of an application on the network, as defined by
// its network segment, node address and socket number
//

typedef struct {
    BYTE Net[4];                        // hi-lo
    BYTE Node[6];                       // hi-lo
    WORD Socket;                        // hi-lo
} NETWARE_ADDRESS ;

typedef NETWARE_ADDRESS UNALIGNED *LPNETWARE_ADDRESS;

//
// FRAGMENT - ECB/IPX/SPX buffers are split into 'fragments'
//

typedef struct {
    LPVOID Address;                     // offset-segment
    WORD Length;                        // hi-lo
} FRAGMENT ;

typedef FRAGMENT UNALIGNED *LPFRAGMENT;

//
// IPX_PACKET - format of packet submitted to IPX for sending. The maximum
// size of an IPX packet is 576 bytes, 30 bytes header, 546 bytes data
//

typedef struct {
    WORD Checksum;                      // always set to 0xFFFF
    WORD Length;                        // set by IPX - header + data
    BYTE TransportControl;              // set by IPX to 0. Used by routers

    //
    // for IPX, PacketType is 0 (Unknown Packet Type) or 4 (Packet Exchange
    // Packet)
    //

    BYTE PacketType;
    NETWARE_ADDRESS Destination;
    NETWARE_ADDRESS Source;
    BYTE Data[];                        // 546 bytes max.
} IPX_PACKET ;

typedef IPX_PACKET UNALIGNED *LPIPX_PACKET;

#define IPX_HEADER_LENGTH           sizeof(IPX_PACKET)
#define MAXIMUM_IPX_PACKET_LENGTH   576
#define MAXIMUM_IPX_DATA_LENGTH     (MAXIMUM_IPX_PACKET_LENGTH - IPX_HEADER_LENGTH)

#define IPX_PACKET_TYPE             4

//
// SPX_PACKET - format of packet submitted to SPX for sending. The maximum
// size of an SPX packet is 576 bytes, 42 bytes header, 534 bytes data
//

typedef struct {
    WORD Checksum;                      // always set to 0xFFFF
    WORD Length;                        // set by IPX - header + data
    BYTE TransportControl;              // set by IPX to 0. Used by routers

    //
    // for SPX, PacketType is set to 5 (Sequenced Packet Protocol Packet)
    //

    BYTE PacketType;
    NETWARE_ADDRESS Destination;
    NETWARE_ADDRESS Source;

    //
    // ConnectionControl is a bitmap which control bi-directional flow over a
    // link. The bits are defined (by Xerox SPP) as:
    //
    //      0-3 undefined
    //      4   end-of-message
    //          This is the only bit which can be directly manipulated by an
    //          app. The bit is passed through unchanged by SPX
    //      5   attention
    //          Ignored by SPX, but passed through
    //      6   acknowledge
    //          Set by SPX if an ack is required
    //      7   system packet
    //          Set by SPX if the packet is internal control. An app should
    //          never see this bit (i.e. should never see a system packet)
    //

    BYTE ConnectionControl;

    //
    // DataStreamType defines the type of data in the packet:
    //
    //      0x00 - 0xFD client-defined.
    //                      Ignored by SPX
    //      0xFE        end-of-connection.
    //                      When active connection is terminated, SPX
    //                      generates and sends a packet with this bit set.
    //                      This will be the last packet sent on the connection
    //      0xFF        end-of-connection acknowledgement
    //                      SPX generates a system packet to acknowledge an
    //                      end-of-connection packet
    //

    BYTE DataStreamType;
    WORD SourceConnectId;               // assigned by SPX
    WORD DestinationConnectId;
    WORD SequenceNumber;                // managed by SPX
    WORD AckNumber;                     // managed by SPX
    WORD AllocationNumber;              // managed by SPX
    BYTE Data[];                        // 534 bytes max.

} SPX_PACKET ;

typedef SPX_PACKET UNALIGNED *LPSPX_PACKET;

#define SPX_HEADER_LENGTH           sizeof(SPX_PACKET)
#define MAXIMUM_SPX_PACKET_LENGTH   MAXIMUM_IPX_PACKET_LENGTH
#define MAXIMUM_SPX_DATA_LENGTH     (MAXIMUM_SPX_PACKET_LENGTH - SPX_HEADER_LENGTH)

#define SPX_PACKET_TYPE             5

//
// ConnectionControl flags
//

#define SPX_CONNECTION_RESERVED 0x0F
#define SPX_END_OF_MESSAGE      0x10
#define SPX_ATTENTION           0x20
#define SPX_ACK_REQUIRED        0x40
#define SPX_SYSTEM_PACKET       0x80

//
// DataStreamType values
//

#define SPX_DS_ESTABLISH        0x00
#define SPX_DS_TERMINATE        0xfe

//
// IPX_ECB - Event Control Block. This structure is used by most IPX/SPX APIs,
// especially when deferred IPX/AES processing is required. The following
// structure is a socket-based ECB
//

typedef struct {

    //
    // LinkAddress is reserved for use by IPX. We use it to link the ECB onto
    // a queue. We appropriate the space used for an x86 segmented address
    // (real or protect mode) as a flat 32-bit pointer
    //

    ULPVOID LinkAddress;                // offset-segment

    //
    // EsrAddress is non-NULL if an Event Service Routine will be called when
    // the event described by the ECB completes. This will always be an x86
    // segmented address (real or protect mode)
    //

    ESR_ADDRESS EsrAddress;             // offset-segment

    //
    // IPX uses the InUse field to mark the ECB as owned by IPX (!0) or by the
    // app (0):
    //
    //      0xF8    App tried to send a packet while IPX was busy; IPX queued
    //              the ECB
    //      0xFA    IPX is processing the ECB
    //      0xFB    IPX has used the ECB for some event and put it on a queue
    //              for processing
    //      0xFC    the ECB is waiting for an AES event to occur
    //      0xFD    the ECB is waiting for an IPX event to occur
    //      0xFE    IPX is listening on a socket for incoming packets
    //      0xFF    IPX is using the ECB to send a packet
    //

    BYTE InUse;

    //
    // CompletionCode is used to return a status from a deferred request. This
    // field is not valid until InUse has been set to 0
    //
    // NOTE: We have to differentiate between AES and IPX ECBs on callbacks: due
    // to their different sizes, we store the 16-bit segment and offset in
    // different places. In order to differentiate the ECBs, we use CompletionCode
    // field (AesWorkspace[0]) as the owner. The real CompletionCode for IPX ECBs
    // goes in IPX_ECB_COMPLETE (DriverWorkspace[7]). But only for completed ECBs
    // that have an ESR
    //

    BYTE CompletionCode;
    WORD SocketNumber;                  // hi-lo

    //
    // the first word of IpxWorkspace is used to return the connection ID of
    // an SPX connection
    //

    DWORD IpxWorkspace;
    BYTE DriverWorkspace[12];

    //
    // ImmediateAddress is the local network node at the remote end of this
    // connection. It is either the node address of the remote machine if it
    // is on this LAN, or it is the node address of the router if the remote
    // machine is on a different LAN
    //
    // This field must be initialized when talking over IPX, but not SPX
    //

    BYTE ImmediateAddress[6];

    //
    // FragmentCount - number of FRAGMENT structures that comprise the request.
    // Must be at least 1
    //

    WORD FragmentCount;

    //
    // FragmentCount fragments start here
    //

} IPX_ECB ;

typedef IPX_ECB UNALIGNED *LPIPX_ECB;

//
// ECB InUse values
//

#define ECB_IU_NOT_IN_USE               0x00
#define ECB_IU_TEMPORARY                0xCC
#define ECB_IU_LISTENING_SPX            0xF7    // same as win16 (by observation)
#define ECB_IU_SEND_QUEUED              0xF8
#define ECB_IU_AWAITING_CONNECTION      0xF9    // same as win16 (by observation)
#define ECB_IU_BEING_PROCESSED          0xFA
#define ECB_IU_AWAITING_PROCESSING      0xFB
#define ECB_IU_AWAITING_AES_EVENT       0xFC
#define ECB_IU_AWAITING_IPX_EVENT       0xFD
#define ECB_IU_LISTENING                0xFE
#define ECB_IU_SENDING                  0xFF

//
// ECB CompletionCode values
//

#define ECB_CC_SUCCESS                  0x00
#define ECB_CC_CONNECTION_TERMINATED    0xEC
#define ECB_CC_CONNECTION_ABORTED       0xED
#define ECB_CC_INVALID_CONNECTION       0xEE
#define ECB_CC_CONNECTION_TABLE_FULL    0xEF
#define ECB_CC_CANNOT_CANCEL            0xF9
#define ECB_CC_CANCELLED                0xFC
#define ECB_CC_BAD_REQUEST              0xFD
#define ECB_CC_BAD_SEND_REQUEST         0xFD
#define ECB_CC_PACKET_OVERFLOW          0xFD
#define ECB_CC_UNDELIVERABLE            0xFE
#define ECB_CC_SOCKET_TABLE_FULL        0xFE
#define ECB_CC_BAD_LISTEN_REQUEST       0xFF
#define ECB_CC_HARDWARE_ERROR           0xFF
#define ECB_CC_NON_EXISTENT_SOCKET      0xFF

//
// we commandeer certain (reserved) fields for our own internal use:
//
//  LPECB   EcbLink     LinkAddress
//  PVOID   Buffer32    DriverWorkspace[0]
//  WORD    Length32    DriverWorkspace[4]
//  WORD    Flags32     DriverWorkspace[6]
//  WORD    OriginalEs  DriverWorkspace[8]
//  WORD    OriginalSi  DriverWorkspace[10]
//

#define ECB_TYPE(p)         (((LPIPX_ECB)(p))->CompletionCode)
#define IPX_ECB_SEGMENT(p)  (WORD)*((ULPWORD)&(((LPIPX_ECB)(p))->IpxWorkspace)+0)
#define IPX_ECB_OFFSET(p)   (WORD)*((ULPWORD)&(((LPIPX_ECB)(p))->IpxWorkspace)+2)
#define IPX_ECB_BUFFER32(p) (ULPVOID)*(ULPVOID*)&(((LPIPX_ECB)(p))->DriverWorkspace[0])
#define IPX_ECB_LENGTH32(p) (WORD)*(ULPWORD)&(((LPIPX_ECB)(p))->DriverWorkspace[4])
#define IPX_ECB_FLAGS32(p)  (((LPIPX_ECB)(p))->DriverWorkspace[6])
#define IPX_ECB_COMPLETE(p) (((LPIPX_ECB)(p))->DriverWorkspace[7])

#define SPX_ECB_CONNECTION_ID(p)    (WORD)*(ULPWORD)&(((LPIPX_ECB)(p))->IpxWorkspace)

//
// ECB Flags32 flags
//

#define ECB_FLAG_BUFFER_ALLOCATED   0x01

//
// ECB types
//

#define ECB_TYPE_AES    0
#define ECB_TYPE_IPX    1
#define ECB_TYPE_SPX    2

//
// ECB owners
//

#define ECB_OWNER_IPX   0xFF
#define ECB_OWNER_AES   0x00

//
// ECB_FRAGMENT - macro which gives the address of the first fragment structure
// within a socket-based ECB
//

#define ECB_FRAGMENT(p, n)  ((LPFRAGMENT)(((LPIPX_ECB)(p) + 1)) + (n))

//
// AES_ECB - used by AES, these socket-less ECBs are used to schedule events
//

typedef struct {
    ULPVOID LinkAddress;                // offset-segment
    ESR_ADDRESS EsrAddress;             // offset-segment
    BYTE InUse;

    //
    // first 3 bytes overlay CompletionCode (1) and SocketNumber (2) fields of
    // IPX_ECB. Last 2 bytes overlay first 2 bytes of IpxWorkspace (4) field of
    // IPX_ECB. We use the 1st byte of the common unused fields as the ECB type
    // (send/receive/timed-event)
    //

    BYTE AesWorkspace[5];
} AES_ECB ;

typedef AES_ECB UNALIGNED *LPAES_ECB;

//
// as with IPX_ECB, we 'borrow' some of the reserved fields for our own use
//

#define AES_ECB_SEGMENT(p)  (WORD)*(ULPWORD)&(((LPAES_ECB)(p))->AesWorkspace[1])
#define AES_ECB_OFFSET(p)   (WORD)*(ULPWORD)&(((LPAES_ECB)(p))->AesWorkspace[3])

//
// LPECB - points to either IPX_ECB or AES_ECB. Both in VDM workspace
//

#define LPECB LPIPX_ECB

//
// SPX_CONNECTION_STATS - returned by SPXGetConnectionStatus. All WORD fields
// are to be returned HiLo (ie to Hawaii). All fields come back from NT SPX
// transport in HiLo format also (this was changed recently, used to be in
// Intel order).
//

typedef struct {
    BYTE State;
    BYTE WatchDog;
    WORD LocalConnectionId;
    WORD RemoteConnectionId;
    WORD LocalSequenceNumber;
    WORD LocalAckNumber;
    WORD LocalAllocNumber;
    WORD RemoteAckNumber;
    WORD RemoteAllocNumber;
    WORD LocalSocket;
    BYTE ImmediateAddress[6];
    BYTE RemoteNetwork[4];
    BYTE RemoteNode[6];
    WORD RemoteSocket;
    WORD RetransmissionCount;
    WORD EstimatedRoundTripDelay;
    WORD RetransmittedPackets;
    WORD SuppressedPackets;
} SPX_CONNECTION_STATS ;

typedef SPX_CONNECTION_STATS UNALIGNED* LPSPX_CONNECTION_STATS;

#include <packoff.h>

//
// 16-bit parameter get/set macros. These may change depending on requirements
// of real/protect mode parameters (e.g. stack based vs. register based)
//

#define IPX_GET_AES_ECB(p)          (p) = (LPAES_ECB)POINTER_FROM_WORDS(getES(), getSI(), sizeof(AES_ECB))
#define IPX_GET_IPX_ECB(p)          (p) = (LPIPX_ECB)POINTER_FROM_WORDS(getES(), getSI(), sizeof(IPX_ECB))
#define IPX_GET_SOCKET(s)           (s) = (WORD)getDX()
#define IPX_GET_SOCKET_LIFE(l)      (l) = (BYTE)getBP()
#define IPX_GET_SOCKET_OWNER(o)     (o) = (WORD)getCX()
#define IPX_GET_BUFFER(p, s)        (p) = (ULPBYTE)POINTER_FROM_WORDS(getES(), getSI(), (s))
#define IPX_GET_ECB_SEGMENT()       getES()
#define IPX_GET_ECB_OFFSET()        getSI()

#define IPX_SET_STATUS(s)           setAL((BYTE)(s))
#define IPX_SET_SOCKET(s)           setDX((WORD)(s))
#define IPX_SET_INFORMATION(v)      setDX((WORD)(v))

#define SPX_SET_STATUS(s)           setAL((BYTE)(s))
#define SPX_SET_CONNECTION_ID(i)    setDX((WORD)(i))

//
// macros returning 16-bit API parameters - may fetch register contents or values
// from stack/memory
//

#define ECB_PARM_SEGMENT()          getES()
#define ECB_PARM_OFFSET()           getSI()
#define ECB_PARM_ADDRESS()          (ECB_ADDRESS)MAKELONG(getSI(), getES())

#define AES_ECB_PARM()              RetrieveEcb(ECB_TYPE_AES)

#define IPX_ECB_PARM()              RetrieveEcb(ECB_TYPE_IPX)
#define IPX_SOCKET_PARM()           getDX()
#define IPX_SOCKET_LIFE_PARM()      (BYTE)getBP()
#define IPX_SOCKET_OWNER_PARM()     getCX()
#define IPX_BUFFER_PARM(s)          (ULPBYTE)POINTER_FROM_WORDS(getES(), getSI(), (s))
#define IPX_TICKS_PARM()            getBP()

#define SPX_RETRY_COUNT_PARM()      (BYTE)getBP()
#define SPX_WATCHDOG_FLAG_PARM()    ((BYTE)(getBP() >> 8))
#define SPX_ECB_PARM()              RetrieveEcb(ECB_TYPE_IPX)
#define SPX_CONNECTION_PARM()       getDX()
#define SPX_BUFFER_PARM(s)          (ULPBYTE)POINTER_FROM_WORDS(getES(), getSI(), (s))

//
// IPX error codes - same codes used in different circumstances
//

#define IPX_SUCCESS                 0x00
#define IPX_CANNOT_CANCEL           0xF9
#define IPX_NO_PATH_TO_DESTINATION  0xFA
#define IPX_CANCELLED               0xFC
#define IPX_BAD_REQUEST             0xFD
#define IPX_SOCKET_TABLE_FULL       0xFE
#define IPX_UNDELIVERABLE           0xFE
#define IPX_SOCKET_ALREADY_OPEN     0xFF
#define IPX_HARDWARE_ERROR          0xFF
#define IPX_NON_EXISTENT_SOCKET     0xFF
#define IPX_ECB_NOT_IN_USE          0xFF

//
// SPX error codes - same codes used in different circumstances
//

#define SPX_SUCCESS                 0x00
#define SPX_CONNECTION_TERMINATED   0xEC
#define SPX_CONNECTION_ABORTED      0xED
#define SPX_INVALID_CONNECTION      0xEE
#define SPX_CONNECTION_TABLE_FULL   0xEF
#define SPX_SOCKET_CLOSED           0xFC
#define SPX_PACKET_OVERFLOW         0xFD
#define SPX_BAD_SEND_REQUEST        0xFD    // malformed packet
#define SPX_BAD_LISTEN_REQUEST      0xFF
#define SPX_NON_EXISTENT_SOCKET     0xFF

#endif // _VWIPXSPX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\vwipx.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwipx.c

Abstract:

    ntVdm netWare (Vw) IPX/SPX Functions

    Vw: The peoples' network

    Internal worker routines for DOS/WOW IPX calls (netware functions).
    The IPX APIs use WinSock to perform the actual operations

    Contents:
        _VwIPXCancelEvent
        _VwIPXCloseSocket
        _VwIPXGetInternetworkAddress
        _VwIPXGetIntervalMarker
        _VwIPXGetLocalTarget
        _VwIPXGetMaxPacketSize
        _VwIPXListenForPacket
        _VwIPXOpenSocket
        _VwIPXRelinquishControl
        _VwIPXScheduleIPXEvent
        _VwIPXSendPacket

Author:

    Richard L Firth (rfirth) 30-Sep-1993

Environment:

    User-mode Win32

Revision History:

    30-Sep-1993 rfirth
        Created

--*/

#include "vw.h"
#pragma hdrstop

extern WORD AesTickCount;

//
// functions
//


WORD
_VwIPXCancelEvent(
    IN LPECB pEcb
    )

/*++

Routine Description:

    Internal routine shared by DOS and WIN that cancels event
    described by an ECB

    This call is Synchronous

Arguments:

    Inputs
        pECB

Return Value:

    00h Success
    F9h Can't cancel ECB
    FFh ECB not in use

--*/

{
    LPXECB pXecb;
    WORD status;

    if (!pEcb) {
        return IPX_ECB_NOT_IN_USE;
    }

    //
    // if the ECB is still in the state we left it then LinkAddress will be the
    // address of the XECB which subsequently points back to the ECB. If both
    // these pan out then we have an ECB which we have at least seen before.
    // Maybe we can cancel it?
    //
    // Note: we grab the serialization semaphore here just in case the AES thread
    // is about to complete the ECB
    //

    status = IPX_CANNOT_CANCEL;
    RequestMutex();
    pXecb = (LPXECB)pEcb->LinkAddress;
    if (pXecb) {
        try {
            if (pXecb->Ecb == pEcb) {
                status = IPX_SUCCESS;

                //
                // pXecb ok: increase reference count in case other thread tries
                // to deallocate it while we're trying to cancel it
                //

                ++pXecb->RefCount;
            }
        } except(1) {

            //
            // bad pointer: bogus ECB
            //

        }
    } else {

        //
        // NULL pointer: event probably completed already
        //

        status = IPX_ECB_NOT_IN_USE;
    }
    ReleaseMutex();
    if (status == IPX_SUCCESS) {

        ECB_CANCEL_ROUTINE cancelRoutine;

        //
        // we have an ECB to cancel. If we still have it, it will be on one of
        // the socket queues, the timer list or the async completion list. If
        // the latter we are in a race. Treat such events as already happened.
        // We will cancel events on the timer list and queued send and receive
        // events only
        //

        switch (pXecb->QueueId) {
        case NO_QUEUE:
            status = ECB_CC_CANCELLED;
            goto cancel_exit;

        case ASYNC_COMPLETION_QUEUE:
            cancelRoutine = CancelAsyncEvent;
            break;

        case TIMER_QUEUE:
            cancelRoutine = CancelTimerEvent;
            break;

        case SOCKET_HEADER_QUEUE:        //Multi-User Addition
        case SOCKET_LISTEN_QUEUE:
        case SOCKET_SEND_QUEUE:
            cancelRoutine = CancelSocketEvent;
            break;

        case CONNECTION_CONNECT_QUEUE:
        case CONNECTION_SEND_QUEUE:

            //
            // SPXEstablishConnection and SPXSendSequencedPacket cannot be
            // cancelled using IPXCancelEvent
            //

            status = ECB_CC_CANNOT_CANCEL;
            goto cancel_exit;

        case CONNECTION_ACCEPT_QUEUE:
        case CONNECTION_LISTEN_QUEUE:
            cancelRoutine = CancelConnectionEvent;
            break;
        }
        return cancelRoutine(pXecb);
    }

    //
    // app tried to sneak us an unknown ECB, -OR- the ECB was stomped on,
    // destroying the LinkAddress and hence the address of the XECB. We
    // could search the various lists looking for an XECB whose Ecb field
    // matches pEcb, but if the app has scribbled over the ECB when we
    // (make that Novell) told it not to, chances are it would fail real
    // well on DOS. Probable worst case is that the app is terminating and
    // the ECB may sometime later call an ESR which won't be there. Crashola
    //

cancel_exit:

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXCancelEvent,
                IPXDBG_LEVEL_ERROR,
                "VwIPXCancelEvent: cannot find/cancel ECB %04x:%04x\n",
                HIWORD(pEcb),
                LOWORD(pEcb)
                ));

    pEcb->CompletionCode = (BYTE)status;
    pEcb->InUse = ECB_IU_NOT_IN_USE;
    return status;
}


VOID
_VwIPXCloseSocket(
    IN WORD socketNumber
    )

/*++

Routine Description:

    Closes a socket and cancels any outstanding events on the socket.
    Closing an unopened socket does not return an error
    ESRs in cancelled ECBs are not called

    This call is Synchronous

Arguments:

    Inputs
        socketNumber

Return Value:

    None.

--*/

{
    LPSOCKET_INFO pSocketInfo;

    pSocketInfo = FindSocket(socketNumber);
    if (pSocketInfo != NULL) {
        KillSocket(pSocketInfo);
    } else {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_IPXCloseSocket,
                    IPXDBG_LEVEL_WARNING,
                    "_VwIPXCloseSocket: can't locate socket 0x%04x\n",
                    B2LW(socketNumber)
                    ));

    }
}


VOID
_VwIPXGetInternetworkAddress(
    IN LPINTERNET_ADDRESS pNetworkAddress
    )

/*++

Routine Description:

    Returns a buffer containing the net number and node number for this
    station.

    This function cannot return an error (!)

    Assumes:    1. GetInternetAddress has been successfully called in the
                   DLL initialization phase

    This call is Synchronous

Arguments:

    Inputs
        Nothing.

    Outputs
        pNetworkAddress

Return Value:

    None.

--*/

{
    CopyMemory((LPBYTE)pNetworkAddress,
               (LPBYTE)&MyInternetAddress.sa_netnum,
               sizeof(*pNetworkAddress)
               );

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetInternetworkAddress,
                IPXDBG_LEVEL_INFO,
                "VwIPXGetInternetworkAddress: %02x-%02x-%02x-%02x : %02x-%02x-%02x-%02x-%02x-%02x\n",
                pNetworkAddress->Net[0] & 0xff,
                pNetworkAddress->Net[1] & 0xff,
                pNetworkAddress->Net[2] & 0xff,
                pNetworkAddress->Net[3] & 0xff,
                pNetworkAddress->Node[0] & 0xff,
                pNetworkAddress->Node[1] & 0xff,
                pNetworkAddress->Node[2] & 0xff,
                pNetworkAddress->Node[3] & 0xff,
                pNetworkAddress->Node[4] & 0xff,
                pNetworkAddress->Node[5] & 0xff
                ));

}


WORD
_VwIPXGetIntervalMarker(
    VOID
    )

/*++

Routine Description:

    Just returns the tick count maintained by Asynchronous Event Scheduler

    This call is Synchronous

Arguments:

    None.

Return Value:

    The tick count.

--*/

{
//    Sleep(0);
    Sleep(1);         //Multi-User change
    return AesTickCount;
}


WORD
_VwIPXGetLocalTarget(
    IN LPBYTE pNetworkAddress,
    OUT LPBYTE pImmediateAddress,
    OUT ULPWORD pTransportTime
    )

/*++

Routine Description:

    Given a target address of the form (network address {4}, node address {6}),
    returns the node address of the target if on the same network, or the node
    address of the router which knows how to get to the next hop in reaching the
    eventual target

    This call is Synchronous

Arguments:

    Inputs
        pNetworkAddress

    Outputs
        pImmediateAddress
        pTransportTime

Return Value:

    00h Success
    F1h Ipx/Spx Not Initialized
    FAh No path to destination node found

--*/

{
    //
    // the transport handles real routing, so we always return the immediate
    // address as the target address. The transport will only look at the
    // target when routing
    //

    CopyMemory( pImmediateAddress,
                pNetworkAddress + 4,
                6
              );

    *pTransportTime = 1; // ticks

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetLocalTarget,
                IPXDBG_LEVEL_INFO,
                "VwIPXGetLocalTarget: IN: %02x-%02x-%02x-%02x:%02x-%02x-%02x-%02x-%02x-%02x OUT: %02x-%02x-%02x-%02x-%02x-%02x\n",
                ((LPINTERNET_ADDRESS)pNetworkAddress)->Net[0] & 0xff,
                ((LPINTERNET_ADDRESS)pNetworkAddress)->Net[1] & 0xff,
                ((LPINTERNET_ADDRESS)pNetworkAddress)->Net[2] & 0xff,
                ((LPINTERNET_ADDRESS)pNetworkAddress)->Net[3] & 0xff,
                ((LPINTERNET_ADDRESS)pNetworkAddress)->Node[0] & 0xff,
                ((LPINTERNET_ADDRESS)pNetworkAddress)->Node[1] & 0xff,
                ((LPINTERNET_ADDRESS)pNetworkAddress)->Node[2] & 0xff,
                ((LPINTERNET_ADDRESS)pNetworkAddress)->Node[3] & 0xff,
                ((LPINTERNET_ADDRESS)pNetworkAddress)->Node[4] & 0xff,
                ((LPINTERNET_ADDRESS)pNetworkAddress)->Node[5] & 0xff,
                pImmediateAddress[0] & 0xff,
                pImmediateAddress[1] & 0xff,
                pImmediateAddress[2] & 0xff,
                pImmediateAddress[3] & 0xff,
                pImmediateAddress[4] & 0xff,
                pImmediateAddress[5] & 0xff
                ));

    return IPX_SUCCESS;
}



WORD
_VwIPXGetMaxPacketSize(
    OUT ULPWORD pRetryCount
    )

/*++

Routine Description:

    Returns the maximum packet size the underlying network can handle

    Assumes:    1. A successfull call to GetMaxPacketSize has been made during
                   DLL initialization
                2. Maximum packet size is constant

    This call is Synchronous

Arguments:

    Outputs
        pRetryCount


Return Value:

    The maximum packet size.

--*/

{
    if ( pRetryCount ) {
        *pRetryCount = 5;   // arbitrary?
    }
    return MyMaxPacketSize;
}


WORD
_VwIPXListenForPacket(
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Queue a listen request against a socket. All listen requests will be
    completed asynchronously, unless cancelled by app

    This call is Asynchronous

Arguments:

    Inputs
        pEcb
        EcbAddress

Return Value:

    None.

--*/

{
    LPXECB pXecb = RetrieveXEcb(ECB_TYPE_IPX, pEcb, EcbAddress);
    LPSOCKET_INFO pSocketInfo;

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXListenForPacket,
                IPXDBG_LEVEL_INFO,
                "_VwIPXListenForPacket(%04x:%04x) socket=%04x ESR=%04x:%04x\n",
                HIWORD(EcbAddress),
                LOWORD(EcbAddress),
                B2LW(pXecb->SocketNumber),
                HIWORD(pXecb->EsrAddress),
                LOWORD(pXecb->EsrAddress)
                ));

    //
    // don't know what real IPX/SPX does if it gets a NULL pointer
    //

    if (!pXecb) {
        return IPX_BAD_REQUEST;
    }

    //
    // the socket must be open already before we can perform a listen
    //

    pSocketInfo = FindSocket(pXecb->SocketNumber);

    //
    // we also return NON_EXISTENT_SOCKET (0xFF) if the socket is in use for SPX
    //

    //
    // There is nothing in the netware documentation that explains
    // what gets returned if this is the case, only a warning about IPX listens
    // and sends can't be made on a socket open for SPX. Really definitive
    //

    if (!pSocketInfo || pSocketInfo->SpxSocket) {
        CompleteEcb(pXecb, ECB_CC_NON_EXISTENT_SOCKET);
        return IPX_NON_EXISTENT_SOCKET;
    }

    //
    // initiate the receive. It may complete if there is data waiting or an
    // error occurs, otherwise the ECB will be placed in a receive pending queue
    // for this socket
    //

    if (GetIoBuffer(pXecb, FALSE, IPX_HEADER_LENGTH)) {
        pXecb->Ecb->InUse = ECB_IU_LISTENING;
        IpxReceiveFirst(pXecb, pSocketInfo);
    } else {
        CompleteEcb(pXecb, ECB_CC_CANCELLED);
    }

    //
    // return success. Any errors will be communicated asynchronously - either
    // indirectly by relevant values in CompletionCode and InUse fields of the
    // ECB or directly by an ESR callback
    //

    return IPX_SUCCESS;
}


WORD
_VwIPXOpenSocket(
    IN OUT ULPWORD pSocketNumber,
    IN BYTE socketType,
    IN WORD dosPDB
    )

/*++

Routine Description:

    Opens a socket for use by IPX or SPX. Puts the socket into non-blocking mode.
    The socket will be bound to IPX

    This call is Synchronous

Arguments:
    Inputs
        *pSocketNumber - The requested socket number
        socketType -  Socket Longevity flag
        dosPDB - DOS PDB. This parameter is not part of the IPX API.
                 Added because we need to remember which DOS executable created
                 the socket: we need to clean-up short-lived sockets when the
                 executable terminates

    Outputs
        pSocketNumber - Assigned socket number

Return Value:

    00h Success
    F0h Ipx Not Installed
    F1h Ipx/Spx Not Initialized
    FEh Socket table full
    FFh Socket already open

--*/

{
    LPSOCKET_INFO pSocketInfo;
    WORD status;

    if ((pSocketInfo = AllocateSocket()) == NULL) {
        return IPX_SOCKET_TABLE_FULL;
    }
    status = (WORD) CreateSocket(SOCKET_TYPE_IPX, pSocketNumber, &pSocketInfo->Socket);
    if (status == IPX_SUCCESS) {

        //
        // set up the SOCKET_INFO fields and add it to our list of open sockets
        //

        pSocketInfo->Owner = dosPDB;
        pSocketInfo->SocketNumber = *pSocketNumber;

        //
        // treat socketType == 0 as short-lived, anything else as long-lived.
        // There doesn't appear to be an error return if the flag is not 0 or 0xFF
        //

        pSocketInfo->LongLived = (BOOL)(socketType != 0);
        QueueSocket(pSocketInfo);

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_IPXOpenSocket,
                    IPXDBG_LEVEL_INFO,
                    "_VwIPXOpenSocket: created socket %04x\n",
                    B2LW(*pSocketNumber)
                    ));

    } else {
        DeallocateSocket(pSocketInfo);

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_IPXOpenSocket,
                    IPXDBG_LEVEL_ERROR,
                    "_VwIPXOpenSocket: Failure: returning %x\n",
                    status
                    ));

    }
    return status;
}


VOID
_VwIPXRelinquishControl(
    VOID
    )

/*++

Routine Description:

    Just sleep for a nominal amount. 

    This call is Synchronous

Arguments:

    None.

Return Value:

    None.

--*/
{
    Sleep(0);
}



VOID
_VwIPXScheduleIPXEvent(
    IN WORD time,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Schedules a an event to occur in some number of ticks. When the tick count
    reaches 0, the ECB InUse field is cleared and any ESR called

    This call is Asynchronous

Arguments:

    Inputs
        time - the delay time ( number of 1/18 second ticks )
        pEcb
        EcbAddress

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    LPXECB pXecb = RetrieveXEcb(ECB_TYPE_IPX, pEcb, EcbAddress);

    // tommye - MS 30525
    //
    // Make sure the xecb alloc didn't fail
    //

    if (pXecb == NULL) {
        return;
    }

    ScheduleEvent(pXecb, time);
}


VOID
_VwIPXSendPacket(
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress,
    IN WORD DosPDB
    )

/*++

Routine Description:

    Sends a packet to the target machine/router. This call can be made on a
    socket that is not open

    The app must have filled in the following IPX_ECB fields:

        EsrAddress
        Socket
        ImmediateAddress
        FragmentCount
        fragment descriptor fields

    and the following IPX_PACKET fields:

        PacketType
        Destination.Net
        Destination.Node
        Destination.Socket

    This call is Asynchronous

Arguments:

    Inputs
        pEcb
        EcbAddress
        DosPDB

Return Value:

    None.

--*/

{
    LPXECB pXecb = RetrieveXEcb(ECB_TYPE_IPX, pEcb, EcbAddress);
    LPSOCKET_INFO pSocketInfo;

    // tommye - MS 30525
    //
    // Make sure the XEcb alloc didn't fail
    //

    if (pXecb == NULL) {
        return;
    }

    //
    // this function returns no immediate status so we must assume that the
    // ECB pointer is valid
    //

    //
    // check the ECB for correctness
    //

    if ((pXecb->Ecb->FragmentCount == 0)
    || (ECB_FRAGMENT(pXecb->Ecb, 0)->Length < IPX_HEADER_LENGTH)) {
        CompleteEcb(pXecb, ECB_CC_BAD_REQUEST);
        return;
    }

    //
    // IPXSendPacket() can be called on an unopened socket: we must try to
    // temporarily allocate the socket
    //
    //  Q: Is the following scenario possible with real IPX:
    //      IPXSendPacket() on unopened socket X
    //      Send fails & gets queued
    //      app makes IPXOpenSocket() call on X; X gets opened
    //
    //  Currently, we would create the temporary socket and fail IPXOpenSocket()
    //  because it is already open!
    //

    pSocketInfo = FindSocket(pXecb->SocketNumber);
    if (!pSocketInfo) {

        //
        // when is temporary socket deleted? After send completed?
        // when app dies? when? Novell documentation is not specific (used
        // to say something else :-))
        //

        pSocketInfo = AllocateTemporarySocket();
        if (pSocketInfo) {

            //
            // set up the SOCKET_INFO fields and add it to our list of open sockets
            //

            pSocketInfo->Owner = DosPDB;

            //
            // temporary sockets are always short-lived
            //

            pSocketInfo->LongLived = FALSE;
            QueueSocket(pSocketInfo);

        } else {

            CompleteEcb(pXecb, ECB_CC_SOCKET_TABLE_FULL);
            return;
        }
    } else if (pSocketInfo->SpxSocket) {

        //
        // see complaint in IPXListenForPacket
        //
        // can't make IPX requests on socket opened for SPX
        //

        CompleteEcb(pXecb, ECB_CC_NON_EXISTENT_SOCKET);
        return;
    }

    //
    // start the send: tries to send the data in one go. Either succeeds, fails
    // with an error, or queues the ECB for subsequent attempts via AES/IPX
    // deferred processing.
    //
    // In the first 2 cases, the ECB has been completed already
    //

    StartIpxSend(pXecb, pSocketInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\vwdos.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwdos.c

Abstract:

    ntVdm netWare (Vw) IPX/SPX Functions

    Vw: The peoples' network

    Contains handlers for DOS IPX/SPX calls (netware functions). The IPX APIs
    use WinSock to perform the actual operations

    Contents:
        VwIPXCancelEvent
        VwIPXCloseSocket
        VwIPXDisconnectFromTarget
        VwIPXGenerateChecksum
        VwIPXGetInformation
        VwIPXGetInternetworkAddress
        VwIPXGetIntervalMarker
        VwIPXGetLocalTarget
        VwIPXGetLocalTargetAsync
        VwIPXGetMaxPacketSize
        VwIPXInitialize
        VwIPXListenForPacket
        VwIPXOpenSocket
        VwIPXRelinquishControl
        VwIPXScheduleAESEvent
        VwIPXScheduleIPXEvent
        VwIPXSendPacket
        VwIPXSendWithChecksum
        VwIPXSPXDeinit
        VwIPXVerifyChecksum

        VwSPXAbortConnection
        VwSPXEstablishConnection
        VwSPXGetConnectionStatus
        VwSPXInitialize
        VwSPXListenForConnection
        VwSPXListenForSequencedPacket
        VwSPXSendSequencedPacket
        VwSPXTerminateConnection

Author:

    Richard L Firth (rfirth) 30-Sep-1993

Environment:

    User-mode Win32

Revision History:

    30-Sep-1993 rfirth
        Created

--*/

#include "vw.h"
#pragma hdrstop

//
// functions
//


VOID
VwIPXCancelEvent(
    VOID
    )

/*++

Routine Description:

    Cancels event described by an ECB

    This call is Synchronous

Arguments:

    Inputs
        BX      06h
        ES:SI   ECB

    Outputs
        AL      Completion code:
                    00h Success
                    F9h Can't cancel ECB
                    FFh ECB not in use

Return Value:

    None.

--*/

{
    LPECB pEcb;
    WORD status;

    CHECK_INTERRUPTS("VwIPXCancelEvent");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXCancelEvent,
                IPXDBG_LEVEL_INFO,
                "VwIPXCancelEvent(%04x:%04x)\n",
                getES(),
                getSI()
                ));

    IPX_GET_IPX_ECB(pEcb);

    status = _VwIPXCancelEvent( pEcb );

    IPX_SET_STATUS(status);
}


VOID
VwIPXCloseSocket(
    VOID
    )

/*++

Routine Description:

    Closes a socket and cancels any outstanding events on the socket.
    Closing an unopened socket does not return an error
    ESRs in cancelled ECBs are not called

    This call is Synchronous

Arguments:

    Inputs
        BX      01h
        DX      Socket Number

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    WORD socketNumber;

    CHECK_INTERRUPTS("VwIPXCloseSocket");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXCloseSocket,
                IPXDBG_LEVEL_INFO,
                "VwIPXCloseSocket(%#x)\n",
                B2LW(IPX_SOCKET_PARM())
                ));

    IPX_GET_SOCKET(socketNumber);

    _VwIPXCloseSocket( socketNumber );

}


VOID
VwIPXDisconnectFromTarget(
    VOID
    )

/*++

Routine Description:

    Performs no action for NTVDM IPX

    This call is Synchronous

Arguments:

    Inputs
        BX      0Bh
        ES:SI   Request buffer:
                    Destination Network DB 4 DUP (?)
                    Destination Node    DB 6 DUP (?)
                    Destination Socket  DB 2 DUP (?)

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    CHECK_INTERRUPTS("VwIPXDisconnectFromTarget");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXDisconnectFromTarget,
                IPXDBG_LEVEL_INFO,
                "VwIPXDisconnectFromTarget\n"
                ));
}


VOID
VwIPXGenerateChecksum(
    VOID
    )

/*++

Routine Description:

    Generates checksum for a transmit ECB

    This call is Synchronous

Arguments:

    Inputs
        BX      21h
        ES:SI   ECB address

    Outputs
        No registers
        ECB checksum field is updated

Return Value:

    None.

--*/

{
    CHECK_INTERRUPTS("VwIPXGenerateChecksum");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGenerateChecksum,
                IPXDBG_LEVEL_INFO,
                "VwIPXGenerateChecksum\n"
                ));
}


VOID
VwIPXGetInformation(
    VOID
    )

/*++

Routine Description:

    Returns a bit-map of supported functions

    This call is Synchronous

Arguments:

    Inputs
        BX      1Fh
        DX      0000h

    Outputs
        DX      Bit map:
                    0001h   Set if IPX is IPXODI.COM, not dedicated IPX
                    0002h   Set if checksum functions (20h, 21h, 22h) supported

Return Value:

    None.

--*/

{
    CHECK_INTERRUPTS("VwIPXGetInformation");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetInformation,
                IPXDBG_LEVEL_INFO,
                "VwIPXGetInformation\n"
                ));

    IPX_SET_INFORMATION(IPX_ODI);
}


VOID
VwIPXGetInternetworkAddress(
    VOID
    )

/*++

Routine Description:

    Returns a buffer containing the net number and node number for this
    station.

    This function cannot return an error (!)

    Assumes:    1. GetInternetAddress has been successfully called in the
                   DLL initialization phase

    This call is Synchronous

Arguments:

    Inputs
        BX      09h

    Outputs
        ES:SI   Buffer
                    Network Address DB 4 DUP (?)
                    Node Address    DB 6 DUP (?)

Return Value:

    None.

--*/

{
    LPINTERNET_ADDRESS pAddr;

    CHECK_INTERRUPTS("VwIPXGetInternetworkAddress");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetInternetworkAddress,
                IPXDBG_LEVEL_INFO,
                "VwIPXGetInternetworkAddress(%04x:%04x)\n",
                getES(),
                getSI()
                ));

    pAddr = (LPINTERNET_ADDRESS)IPX_BUFFER_PARM(sizeof(*pAddr));
    if (pAddr) {
        _VwIPXGetInternetworkAddress( pAddr );
    }
}


VOID
VwIPXGetIntervalMarker(
    VOID
    )

/*++

Routine Description:

    Just returns the tick count maintained by Asynchronous Event Scheduler

    This call is Synchronous

Arguments:

    Inputs
        BX      08h

    Outputs
        AX      Interval marker

Return Value:

    None.

--*/

{
    CHECK_INTERRUPTS("VwIPXGetIntervalMarker");

    setAX( _VwIPXGetIntervalMarker() );

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetIntervalMarker,
                IPXDBG_LEVEL_INFO,
                "VwIPXGetIntervalMarker: Returning %04x\n",
                getAX()
                ));
}


VOID
VwIPXGetLocalTarget(
    VOID
    )

/*++

Routine Description:

    Given a target address of the form (network address {4}, node address {6}),
    returns the node address of the target if on the same network, or the node
    address of the router which knows how to get to the next hop in reaching the
    eventual target

    This call is Synchronous

Arguments:

    Inputs
        BX      02h
        ES:SI   Request buffer
                    Destination Network DB 4 DUP (?)
                    Destination Node    DB 6 DUP (?)
                    Destination Socket  DB 2 DUP (?)
        ES:DI   Response buffer
                    Local Target DB 6 DUP (?)

    Outputs
        AL      Completion code
                    00h Success
                    FAh No path to destination node found
        AH      Number of hops to destination
        CX      Transport time

Return Value:

    None.

--*/

{
    LPBYTE pImmediateAddress;
    LPBYTE pNetworkAddress;
    WORD   transportTime;
    WORD   status;

    CHECK_INTERRUPTS("VwIPXGetLocalTarget");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetLocalTarget,
                IPXDBG_LEVEL_INFO,
                "VwIPXGetLocalTarget(target buf @ %04x:%04x, local buf @ %04x:%04x)\n",
                getES(),
                getSI(),
                getES(),
                getDI()
                ));


    pImmediateAddress = POINTER_FROM_WORDS(getES(), getDI(), 6);
    pNetworkAddress = POINTER_FROM_WORDS(getES(), getSI(), 12);

    if (pImmediateAddress && pNetworkAddress) {
        status = _VwIPXGetLocalTarget( pNetworkAddress,
                                       pImmediateAddress,
                                       &transportTime );
    }
    else {
        status = IPX_BAD_REQUEST;
    }


    setCX( transportTime );
    setAH(1);

    IPX_SET_STATUS(status);
}


VOID
VwIPXGetLocalTargetAsync(
    VOID
    )

/*++

Routine Description:

    description-of-function.

    This call is Asynchronous

Arguments:

    None.

Return Value:

    None.

--*/

{
    CHECK_INTERRUPTS("VwIPXGetLocalTargetAsync");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "VwIPXGetLocalTargetAsync\n"
                ));
}


VOID
VwIPXGetMaxPacketSize(
    VOID
    )

/*++

Routine Description:

    Returns the maximum packet size the underlying network can handle

    Assumes:    1. A successfull call to GetMaxPacketSize has been made during
                   DLL initialization
                2. Maximum packet size is constant

    This call is Synchronous

Arguments:

    Inputs
        BX      1Ah

    Outputs
        AX      Maximum packet size
        CX      IPX retry count

Return Value:

    None.

--*/

{
    WORD maxPacketSize;
    WORD retryCount;

    CHECK_INTERRUPTS("VwIPXGetMaxPacketSize");

    maxPacketSize = _VwIPXGetMaxPacketSize( &retryCount );

    setAX(maxPacketSize);

    //
    // The DOS Assembly and C manuals differ slightly here: DOS says
    // we return the IPX retry count in CX. There is no corresponding parameter
    // in the C interface?
    //

    setCX(retryCount);

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetMaxPacketSize,
                IPXDBG_LEVEL_INFO,
                "VwIPXGetMaxPacketSize: PacketSize=%d, RetryCount=%d\n",
                getAX(),
                getCX()
                ));
}


VOID
VwIPXInitialize(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    CHECK_INTERRUPTS("VwIPXInitialize");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "VwIPXInitialize\n"
                ));
}


VOID
VwIPXListenForPacket(
    VOID
    )

/*++

Routine Description:

    Queue a listen request against a socket. All listen requests will be
    completed asynchronously, unless cancelled by app

    This call is Asynchronous

Arguments:

    Inputs
        BX      04h
        ES:SI   ECB address

    Outputs
        AL      Completion code
                    FFh Socket doesn't exist

Return Value:

    None.

--*/

{
    LPECB pEcb;
    WORD  status;

    CHECK_INTERRUPTS("VwIPXListenForPacket");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXListenForPacket,
                IPXDBG_LEVEL_INFO,
                "VwIPXListenForPacket(%04x:%04x)\n",
                getES(),
                getSI()
                ));

    IPX_GET_IPX_ECB(pEcb);

    status = _VwIPXListenForPacket( pEcb, ECB_PARM_ADDRESS() );

    IPX_SET_STATUS(status);
}


VOID
VwIPXOpenSocket(
    VOID
    )

/*++

Routine Description:

    Opens a socket for use by IPX or SPX. Puts the socket into non-blocking mode.
    The socket will be bound to IPX

    This call is Synchronous

Arguments:

    Inputs
        AL      Socket Longevity flag
                    This parameter is actually in BP - AX has been sequestered
                    by the VDD dispatcher
        BX      00h
        DX      Requested Socket Number

        CX      DOS PDB. This parameter is not part of the IPX API.
                Added because we need to remember which DOS executable created
                the socket: we need to clean-up short-lived sockets when the
                executable terminates

    Outputs
        AL      Completion code:
                    00h Success
                    FFh Socket already open
                    FEh Socket table full
        DX      Assigned socket number

Return Value:

    None.

--*/

{
    BYTE socketLife;
    WORD socketNumber;
    WORD status;

    CHECK_INTERRUPTS("VwIPXOpenSocket");

    IPX_GET_SOCKET_LIFE(socketLife);
    IPX_GET_SOCKET(socketNumber);

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXOpenSocket,
                IPXDBG_LEVEL_INFO,
                "VwIPXOpenSocket(Life=%02x, Socket=%04x, Owner=%04x)\n",
                socketLife,
                B2LW(socketNumber),
                IPX_SOCKET_OWNER_PARM()
                ));


    status = _VwIPXOpenSocket( &socketNumber,
                               socketLife,
                               IPX_SOCKET_OWNER_PARM() );

    if ( status == IPX_SUCCESS )
        IPX_SET_SOCKET(socketNumber);

    IPX_SET_STATUS(status);
}


VOID
VwIPXRelinquishControl(
    VOID
    )

/*++

Routine Description:

    Just sleep for a nominal amount. Netware seems to be dependent on the
    default setting of the PC clock, so one timer tick (1/18 second) would
    seem to be a good value

    This call is Synchronous

Arguments:

    Inputs
        BX      0Ah

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    CHECK_INTERRUPTS("VwIPXRelinquishControl");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXRelinquishControl,
                IPXDBG_LEVEL_INFO,
                "VwIPXRelinquishControl\n"
                ));

    _VwIPXRelinquishControl();

}


VOID
VwIPXScheduleAESEvent(
    VOID
    )

/*++

Routine Description:

    Schedules a an event to occur in some number of ticks. When the tick count
    reaches 0, the ECB InUse field is cleared and any ESR called

    This call is Asynchronous

Arguments:

    Inputs
        BX      07h
        AX      Delay time - number of 1/18 second ticks
        ES:SI   ECB address

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    LPXECB pXecb = AES_ECB_PARM();
    WORD ticks = IPX_TICKS_PARM();

    if (pXecb == NULL) {
        return;
    }

    CHECK_INTERRUPTS("VwIPXScheduleAESEvent");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXScheduleAESEvent,
                IPXDBG_LEVEL_INFO,
                "VwIPXScheduleAESEvent(%04x:%04x, %04x)\n",
                getES(),
                getSI(),
                ticks
                ));

    ScheduleEvent(pXecb, ticks);
}


VOID
VwIPXScheduleIPXEvent(
    VOID
    )

/*++

Routine Description:

    Schedules a an event to occur in some number of ticks. When the tick count
    reaches 0, the ECB InUse field is cleared and any ESR called

    This call is Asynchronous

Arguments:

    Inputs
        BX      05h
        AX      Delay time - number of 1/18 second ticks
        ES:SI   ECB address

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    LPECB pEcb;
    WORD ticks = IPX_TICKS_PARM();

    CHECK_INTERRUPTS("VwIPXScheduleIPXEvent");

    IPX_GET_IPX_ECB(pEcb);

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXScheduleIPXEvent,
                IPXDBG_LEVEL_INFO,
                "VwIPXScheduleIPXEvent(%04x:%04x, %04x)\n",
                getES(),
                getSI(),
                ticks
                ));

    _VwIPXScheduleIPXEvent( ticks, pEcb, ECB_PARM_ADDRESS() );

}


VOID
VwIPXSendPacket(
    VOID
    )

/*++

Routine Description:

    Sends a packet to the target machine/router. This call can be made on a
    socket that is not open

    The app must have filled in the following IPX_ECB fields:

        EsrAddress
        Socket
        ImmediateAddress
        FragmentCount
        fragment descriptor fields

    and the following IPX_PACKET fields:

        PacketType
        Destination.Net
        Destination.Node
        Destination.Socket

    This call is Asynchronous

Arguments:

    Inputs
        BX      03h
        CX      DOS PDB. This parameter is not part of the IPX API.
                Added because we need to remember which DOS executable owns the
                socket IF WE MUST CREATE A TEMPORTARY SOCKET: we need to clean-up
                short-lived sockets when the executable terminates
        ES:SI   ECB Address

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    LPECB pEcb;
    WORD owner;

    CHECK_INTERRUPTS("VwIPXSendPacket");

    IPX_GET_IPX_ECB(pEcb);

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXSendPacket,
                IPXDBG_LEVEL_INFO,
                "VwIPXSendPacket(%04x:%04x), owner = %04x\n",
                getES(),
                getSI(),
                IPX_SOCKET_OWNER_PARM()
                ));

    _VwIPXSendPacket(pEcb,
                     ECB_PARM_ADDRESS(),
                     IPX_SOCKET_OWNER_PARM()
                     );
}


VOID
VwIPXSendWithChecksum(
    VOID
    )

/*++

Routine Description:

    description-of-function.

    This call is Asynchronous

Arguments:

    None.

Return Value:

    None.

--*/

{
    CHECK_INTERRUPTS("VwIPXSendWithChecksum");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXSendWithChecksum,
                IPXDBG_LEVEL_INFO,
                "VwIPXSendWithChecksum\n"
                ));
}


VOID
VwIPXSPXDeinit(
    VOID
    )

/*++

Routine Description:

    description-of-function.

    This call is Synchronous

Arguments:

    None.

Return Value:

    None.

--*/

{
    CHECK_INTERRUPTS("VwIPXSPXDeinit");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "VwIPXSPXDeinit\n"
                ));
}


VOID
VwIPXVerifyChecksum(
    VOID
    )

/*++

Routine Description:

    description-of-function.

    This call is Synchronous

Arguments:

    None.

Return Value:

    None.

--*/

{
    CHECK_INTERRUPTS("VwIPXVerifyChecksum");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXVerifyChecksum,
                IPXDBG_LEVEL_INFO,
                "VwIPXVerifyChecksum\n"
                ));
}


VOID
VwSPXAbortConnection(
    VOID
    )

/*++

Routine Description:

    Aborts this end of a connection

    This call is Asynchronous

Arguments:

    Inputs
        BX      14h
        DX      Connection ID

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    WORD connectionId = SPX_CONNECTION_PARM();

    CHECK_INTERRUPTS("VwSPXAbortConnection");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXAbortConnection,
                IPXDBG_LEVEL_INFO,
                "VwSPXAbortConnection(%04x)\n",
                connectionId
                ));

    _VwSPXAbortConnection(connectionId);
}


VOID
VwSPXEstablishConnection(
    VOID
    )

/*++

Routine Description:

    Creates a connection with a remote SPX socket. The remote end can be on
    this machine (i.e. same app in DOS world)

    This call is Asynchronous

Arguments:

    Inputs
        BX      11h
        AL      Retry count
        AH      WatchDog flag
        ES:SI   ECB Address

    Outputs
        AL      Completion code:
                    00h Attempting to talk to remote
                    EFh Local connection table full
                    FDh Fragment count not 1; buffer size not 42
                    FFh Send socket not open
        DX      Connection ID

Return Value:

    None.

--*/

{
    WORD status;
    BYTE retryCount = SPX_RETRY_COUNT_PARM();
    BYTE watchDogFlag = SPX_WATCHDOG_FLAG_PARM();
    WORD connectionId = 0;
    LPECB pEcb;

    CHECK_INTERRUPTS("VwSPXEstablishConnection");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXEstablishConnection,
                IPXDBG_LEVEL_INFO,
                "VwSPXEstablishConnection(%02x, %02x, %04x:%04x)\n",
                retryCount,
                watchDogFlag,
                ECB_PARM_SEGMENT(),
                ECB_PARM_OFFSET()
                ));

    IPX_GET_IPX_ECB( pEcb );

    IPXDUMPECB((pEcb, getES(), getSI(), ECB_TYPE_SPX, TRUE, TRUE, FALSE));

    status = _VwSPXEstablishConnection( retryCount,
                                        watchDogFlag,
                                        &connectionId,
                                        pEcb,
                                        ECB_PARM_ADDRESS() );


    SPX_SET_CONNECTION_ID( connectionId );
    SPX_SET_STATUS( status );
}


VOID
VwSPXGetConnectionStatus(
    VOID
    )

/*++

Routine Description:

    Returns buffer crammed full of useful statistics or something (hu hu huh)

    This call is Synchronous

Arguments:

    Inputs
        BX      15h
        DX      Connection ID
        ES:SI   Buffer address

    Outputs
        AL      Completion code:
                    00h Connection is active
                    EEh No such connection

        on output, buffer in ES:SI contains:

            BYTE    ConnectionStatus
            BYTE    WatchDogActive
            WORD    LocalConnectionID
            WORD    RemoteConnectionID
            WORD    SequenceNumber
            WORD    LocalAckNumber
            WORD    LocalAllocationNumber
            WORD    RemoteAckNumber
            WORD    RemoteAllocationNumber
            WORD    LocalSocket
            BYTE    ImmediateAddress[6]
            BYTE    RemoteNetwork[4]
            WORD    RetransmissionCount
            WORD    RetransmittedPackets
            WORD    SuppressedPackets

Return Value:

    None.

--*/

{
    WORD status;
    WORD connectionId = SPX_CONNECTION_PARM();
    LPSPX_CONNECTION_STATS pStats = (LPSPX_CONNECTION_STATS)SPX_BUFFER_PARM(sizeof(*pStats));

    CHECK_INTERRUPTS("VwSPXGetConnectionStatus");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXGetConnectionStatus,
                IPXDBG_LEVEL_INFO,
                "VwSPXGetConnectionStatus: connectionId=%04x\n",
                connectionId
                ));

    status = _VwSPXGetConnectionStatus( connectionId,
                                        pStats );


    SPX_SET_STATUS(status);
}


VOID
VwSPXInitialize(
    VOID
    )

/*++

Routine Description:

    Informs the app that SPX is present on this station

    This call is Synchronous

Arguments:

    Inputs
        BX      10h
        AL      00h

    Outputs
        AL      Installation flag:
                    00h Not installed
                    FFh Installed
        BH      SPX Major revision number
        BL      SPX Minor revision number
        CX      Maximum SPX connections supported
                    normally from SHELL.CFG
        DX      Available SPX connections

Return Value:

    None.

--*/

{
    WORD status;
    BYTE majorRevisionNumber;
    BYTE minorRevisionNumber;
    WORD maxConnections;
    WORD availableConnections;

    CHECK_INTERRUPTS("VwSPXInitialize");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXInitialize,
                IPXDBG_LEVEL_INFO,
                "VwSPXInitialize\n"
                ));


    status = _VwSPXInitialize( &majorRevisionNumber,
                               &minorRevisionNumber,
                               &maxConnections,
                               &availableConnections );


    setBH( majorRevisionNumber );
    setBL( minorRevisionNumber );
    setCX( maxConnections );
    setDX( availableConnections );
    SPX_SET_STATUS(status);
}


VOID
VwSPXListenForConnection(
    VOID
    )

/*++

Routine Description:

    Listens for an incoming connection request

    This call is Asynchronous

Arguments:

    Inputs
        BX      12h
        AL      Retry count
        AH      SPX WatchDog flag
        ES:SI   ECB Address

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    BYTE retryCount = SPX_RETRY_COUNT_PARM();
    BYTE watchDogFlag = SPX_WATCHDOG_FLAG_PARM();
    LPECB pEcb;

    CHECK_INTERRUPTS("VwSPXListenForConnection");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXListenForConnection,
                IPXDBG_LEVEL_INFO,
                "VwSPXListenForConnection(%02x, %02x, %04x:%04x)\n",
                retryCount,
                watchDogFlag,
                ECB_PARM_SEGMENT(),
                ECB_PARM_OFFSET()
                ));

    IPX_GET_IPX_ECB( pEcb );

    IPXDUMPECB((pEcb, getES(), getSI(), ECB_TYPE_SPX, TRUE, FALSE, FALSE));

    _VwSPXListenForConnection( retryCount,
                               watchDogFlag,
                               pEcb,
                               ECB_PARM_ADDRESS() );
}


VOID
VwSPXListenForSequencedPacket(
    VOID
    )

/*++

Routine Description:

    Attempts to receive an SPX packet. This call is made against the top-level
    socket (the socket in SPX-speak, not the connection). We can receive a
    packet from any connection assigned to this socket. In this function, we
    just queue the ECB (since there is no return status, we expect that the
    app has supplied an ESR) and let AES handle it

    This call is Asynchronous

Arguments:

    Inputs
        BX      17h
        ES:SI   ECB Address

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    LPECB pEcb;

    CHECK_INTERRUPTS("VwSPXListenForSequencedPacket");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXListenForSequencedPacket,
                IPXDBG_LEVEL_INFO,
                "VwSPXListenForSequencedPacket(%04x:%04x)\n",
                ECB_PARM_SEGMENT(),
                ECB_PARM_OFFSET()
                ));

    IPX_GET_IPX_ECB( pEcb );

    IPXDUMPECB((pEcb, getES(), getSI(), ECB_TYPE_SPX, TRUE, FALSE, FALSE));

    _VwSPXListenForSequencedPacket( pEcb,
                                    ECB_PARM_ADDRESS());

}


VOID
VwSPXSendSequencedPacket(
    VOID
    )

/*++

Routine Description:

    Sends a packet on an SPX connection

    This call is Asynchronous

Arguments:

    Inputs
        BX      16h
        DX      Connection ID
        ES:SI   ECB address

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    WORD connectionId = SPX_CONNECTION_PARM();
    LPECB pEcb;

    CHECK_INTERRUPTS("VwSPXSendSequencedPacket""VwSPXSendSequencedPacket");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXSendSequencedPacket,
                IPXDBG_LEVEL_INFO,
                "VwSPXSendSequencedPacket(%04x, %04x:%04x)\n",
                connectionId,
                getES(),
                getSI()
                ));

    IPX_GET_IPX_ECB( pEcb );

    IPXDUMPECB((pEcb, getES(), getSI(), ECB_TYPE_SPX, TRUE, TRUE, FALSE));

    _VwSPXSendSequencedPacket( connectionId,
                               pEcb,
                               ECB_PARM_ADDRESS() );

}


VOID
VwSPXTerminateConnection(
    VOID
    )

/*++

Routine Description:

    Terminates a connection

    This call is Asynchronous

Arguments:

    Inputs
        BX      13h
        DX      Connection ID
        ES:SI   ECB Address

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    WORD connectionId = SPX_CONNECTION_PARM();
    LPECB pEcb;

    CHECK_INTERRUPTS("VwSPXTerminateConnection");

    IPX_GET_IPX_ECB( pEcb );

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXTerminateConnection,
                IPXDBG_LEVEL_INFO,
                "VwSPXTerminateConnection(%04x, %04x:%04x)\n",
                connectionId,
                ECB_PARM_SEGMENT(),
                ECB_PARM_OFFSET()
                ));

    _VwSPXTerminateConnection(connectionId, pEcb, ECB_PARM_ADDRESS());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\asmmacro.inc ===
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    asmmacro.inc
;
;Abstract:
;
;    Contains macros to extend masm functionality:
;
;       jmpc
;       jmpnc
;       jmpne
;       jmps
;       _mkjmp
;
;
;Author:
;
;    Richard L Firth (rfirth) 24-Sep-1991
;
;Environment:
;
;    DOS application mode only
;
;Revision History:
;
;    24-Sep-1991 rfirth
;        Created
;
;--



DEFINED_BIT=020h
;ISDEFINED equ %(.type <thing> and DEFINED_BIT)
LABEL_DEFINED equ <(.type &label and DEFINED_BIT)>

DEBUG_MACROS    = 0
;DEBUG_MACROS    = 1


;***    jmpa
;*
;*      jump to label if above. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpa    macro   label
        _mkjmp  ja,jna,&label
endm

;***    jmpc
;*
;*      jump to label if below. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpb    macro   label
        _mkjmp  jb,jnb,&label
endm

;***    jmpc
;*
;*      jump to label if carry flag set. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpc    macro   label
        _mkjmp  jc,jnc,&label
endm



;***    jmpnc
;*
;*      jump to label if carry flag NOT set. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpnc   macro   label
        _mkjmp  jnc,jc,&label
endm



;***    jmpne
;*
;*      jump to label if zero flag NOT set. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpne   macro   label
        _mkjmp  jne,je,&label
endm



;***    jmpe
;*
;*      jump to label if zero flag set. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpe    macro   label
        _mkjmp  je,jne,&label
endm



;***    jmps
;*
;*      jump to label. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmps    macro   label
        local   l,dist
dist=&label-$
if1
if (.type label and DEFINED_BIT)
if ((dist gt 129) or (dist lt -126))
if DEBUG_MACROS
        %out pass1: &label defined and near
endif
        jmp     &label
else
if DEBUG_MACROS
        %out pass1: &label defined and short
endif
        jmp     short &label
endif
else
if DEBUG_MACROS
        %out pass1: &label not defined
endif
        org     $+3
endif
else
if ((dist gt 129) or (dist lt -126))
if DEBUG_MACROS
        %out pass2: &label defined and near
endif
        jmp     &label
else
if DEBUG_MACROS
        %out pass2: &label defined and short
endif
        jmp     short &label
        org     $+1
endif
endif
l:
endm



;***    _mkjmp
;*
;*      Make a jmp<?> macro. Generate instruction sequence for jump with or
;*      without conditional test. Jump may be short (+127/-128 bytes) or near
;*      (+32767/-32768 bytes)
;*
;*      ENTRY   is      - short jump instruction
;*              in      - near jump instruction
;*              label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

_put macro s,v
if2
if DEBUG_MACROS
%out s = v
endif
endif
endm

_mkjmp  macro   is, in, label
        local   l

;;
;; if pass 1 and label is already known, generate correct instruction
;;

if1
if (.type &label and DEFINED_BIT)

;;
;; if label is too far away for short jump instruction, make jump <condition>
;; into jump <NOT condition> round jump to label followed by a near jump to
;; label
;;

if (((&label - $) gt 129) or ((&label - $) lt -126))
        &in     l       ;; short jump, NOT condition
        jmp     &label  ;; jump to where we want to go
else
        &is     &label  ;; short jump
endif

;;
;; if pass 1 and we don't know about the label yet, adjust the program
;; counter by the max. number of bytes taken up by this macro (5 - 2 for
;; short jump, 3 for near jump)
;;

else
        nop
        nop
        nop
        nop
        nop
endif

;;
;; pass 2 - do same stuff as for pass 1
;;

else
if (((&label - $) gt 129) or ((&label - $) lt -126))
 if ((&label-$) gt 129)
        _put    <label distance>, %(&label-$)
 else
        _put    <label distance>, %($-&label)
 endif
        &in     l
        jmp     &label
else

;;
;; label is within +127/-128 bytes of current instruction - generate short
;; jump instruction and put the program counter forward past the space
;; reserved during pass 1
;;

        _put    <label distance>, %(&label-$)
        &is     &label
        nop
        nop
        nop
endif
endif
l:
endm



oldjmps macro   label
if2
if (((&label - $) gt 127) or (($ - &label) lt -128))
        jmp     short l
        jmp     &label
else
        jmp     short &label
        org     $+3
endif
else
;;
;; if this is pass 1 just take up max amount of space so phases don't get
;; screwed
;;
        org     $+5
endif
l:
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\debugmac.inc ===
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    debugmac.inc
;
;Abstract:
;
;    Contains debugging macros:
;
;       DbgBreakPoint
;       DbgUnsupported
;       DbgDEBUG
;       DbgPrint
;       DbgPrintTty
;       DbgPrintString
;       DbgPrintHexDword
;       DbgPrintHexWord
;       DbgPrintHexByte
;       DbgPrintNearPointer
;       DbgPrintFarPointer
;
;Author:
;
;    Richard L Firth (rfirth) 13-Sep-1991
;
;Environment:
;
;    DOS application mode only
;
;[Notes:]
;
;    optional-notes
;
;Revision History:
;
;    13-Sep-1991 rfirth
;        Created
;
;--


;***    DbgBreakPoint
;*
;*      Same as NT routine of same name. No-op in non-DEBUG version
;*
;*      ENTRY
;*
;*      EXIT
;*
;*      RETURNS
;*
;*      ASSUMES
;*
;***

DbgBreakPoint macro
if DEBUG
        int     3
endif
endm

;***    DbgUnsupported
;*
;*      Causes the 32-bit support code to display a message about an unsupported
;*      service code, and dumps the 16-bit registers. Used to discover when an
;*      unsupported int 2f/11 call or int 21/5f call is being made
;*
;*      ENTRY
;*
;*      EXIT
;*
;*      RETURNS
;*
;*      ASSUMES
;*
;***

DbgUnsupported macro
if DEBUG
        SVC     -1
endif
endm

;***    DbgDEBUG
;*
;*      Prints the string "DEBUG: " to console using Bios Int 10h/ah=0eh
;*
;*      ENTRY   nothing
;*
;*      EXIT    nothing
;*
;*      USES    ax
;*
;*      ASSUMES 286+
;*
;***

DbgDEBUG macro
        mov     ax,(14 shl 8) + 'D'
        int     10h
        mov     al,'E'
        int     10h
        mov     al,'B'
        int     10h
        mov     al,'U'
        int     10h
        mov     al,'G'
        int     10h
        mov     al,':'
        int     10h
        mov     al,' '
        int     10h
endm



;***    DbgCrLf
;*
;*      Prints CR,LF to console using Bios Int 10h/ah=0eh
;*
;*      ENTRY   nothing
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgCrLf macro
        push    ax
        mov     ax,(14 shl 8) + 13
        int     10h
        mov     al,10
        int     10h
        pop     ax
endm



;***    DbgPrint
;*
;*      Prints an ASCIZ string to console using Bios Int 10h
;*
;*      ENTRY   string  - address of ASCIZ string to print
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrint macro string
if DEBUG                        ;; no macro if not debug version
        pushf                   ;; save regs used by DbgPrintTty
        push    ax
        push    bx
        push    si
        push    ds
        mov     ax,seg string
        mov     ds,ax
        mov     si,offset string;; ds:si = address of string
        DbgPrintTty             ;; display it on console
        pop     ds
        pop     si
        pop     bx
        pop     ax
        popf
endif
endm



;***    DbgPrintTty
;*
;*      Prints an ASCIZ string in ds:si to console using Bios Int 10h
;*
;*      ENTRY   page    - if present defines which Bios video page to use
;*                        Defaults to 0
;*              ds:si   - address of ASCIZ string to print
;*
;*      EXIT    nothing
;*
;*      USES    al, bh, si, flags
;*
;*      ASSUMES 286+
;*
;***

DbgPrintTty macro page
        local   l1,l2

if DEBUG                        ;; no macro if not debug version
        mov     ah,14           ;; Bios Int write character as TTY function
ifb <page>
        sub     bh,bh
else
        mov     bh,page
endif
        cld                     ;; autoincrement lodsb
l1:     lodsb                   ;; al := next character; si := next character addr
        or      al,al           ;; eof string?
        jz      l2              ;; yes
        int     10h             ;; display it to console
        jmp     short l1        ;; go round again
l2:
endif
endm



;***    DbgPrintString
;*
;*      Prints a string to console using Bios Int 10h. Note that this macro
;*      does not do printf style substitutions. The string "DEBUG: " will be
;*      displayed if the banner parm is not blank
;*
;*      ENTRY   string  - character string. Needn't be zero-terminated
;*              banner  - the "DEBUG: " banner will be printed if not blank
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrintString macro string, banner
        local   s1
        local   l1

if DEBUG                        ;; no macro if not debug version
        jmp     short l1
s1      db      &string,0
l1:     pushf                   ;; don't destroy direction flag
        pusha                   ;; save gp regs
ifb <banner>
        DbgDEBUG                ;; Display "DEBUG: "
endif
        push    ds              ;; save user's data seg
        push    cs
        pop     ds              ;; ds == cs
        mov     si,offset cs:s1 ;; si := string offset
        DbgPrintTty             ;; display ds:si to console
        pop     ds              ;; restore user's data seg
        popa                    ;; restore gp regs
        popf                    ;; restore direction flag+
endif
endm



;***    DbgPrintHexDword
;*
;*      Prints a dword to console in hex notation using Bios Int 10h
;*
;*      ENTRY   dword   - dword to print
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrintHexDword macro dword
if DEBUG                        ;; no macro if not debug version
        DbgPrint    <"DbgPrintHexDword not implemented yet",13,10>
endif
endm



;***    DbgPrintHexWord
;*
;*      Prints a word to console in hex notation using Bios Int 10h
;*
;*      ENTRY   word    - to print. Can be memory or register
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrintHexWord macro word
        local   l1, l2
if DEBUG                        ;; no macro if not debug version
        pushf                   ;; don't use any registers
        push    ax
        push    cx
        push    dx
ifdifi <word>,<ax>
        mov     ax,word
endif
        mov     cx,4
l1:     rol     ax,4
        mov     dx,ax
        and     al,0fh
        cmp     al,9
        jle     l2
        add     al,'a'-('9'+1)
l2:     add     al,'0'
        mov     ah,14
        int     10h
        mov     ax,dx
        loop    l1
        pop     dx
        pop     cx
        pop     ax
        popf
endif
endm



;***    DbgPrintHexByte
;*
;*      Prints a string to console using Bios Int 10h. Note that this macro
;*      does not do printf style substitutions
;*
;*      ENTRY   string  - character string. Needn't be zero-terminated
;*
;*      EXIT
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrintHexByte macro byte
if DEBUG                        ;; no macro if not debug version
        DbgPrint    <"DbgPrintHexByte not implemented yet",13,10>
endif
endm



DbgPrintNearPointer macro nearptr
endm



DbgPrintFarPointer macro farptr
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\segorder.inc ===
;/*++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    segorder.inc
;
;Abstract:
;
;    This module contains the segment order and segment macros
;
;Author:
;
;    Richard Firth (rfirth) 05-Sep-1991
;
;Environment:
;
;    Dos mode only
;
;Notes:
;
;    When initially loaded, the NT VDM redir has the following order:
;
;       +----------------------+
;       |                      |
;       |    Resident Code     |
;       |                      |
;       +----------------------+
;       |                      |
;       |    Resident Data     |
;       |                      |
;       +----------------------+ ----------------+
;       |                      |                 |
;       | Initialisation Code  | <- entry point  v
;       |                      |
;       +----------------------+
;       |                      |                 all the stuff between these
;       | Initialisation Data  |                 arrows is discarded if we stay
;       |                      |                 resident. Note that the redir
;       +----------------------+                 does not uninstall
;       |                      |
;       | Initialisation Stack |                 ^
;       |                      |                 |
;       +----------------------+ ----------------+
;
;Revision History:
;
;    05-Sep-1991 rfirth
;        Created
;
;--*/



ResidentStart   segment public para 'code'
ResidentStart   ends

ResidentCode    segment public word 'code'
ResidentCode    ends

ResidentData    segment public word 'data'
ResidentData    ends

ResidentEnd     segment public para 'data'
ResidentEnd     ends

ResidentGroup   group   ResidentStart, ResidentCode, ResidentData, ResidentEnd

InitCode        segment public para 'init'
InitCode        ends

InitData        segment public word 'init'
InitData        ends

InitStack       segment stack para 'stack'
InitStack       ends

;
; macros to avoid having to type in/possibly alter segment header guff
;

ResidentCodeStart macro
ResidentCode    segment public word 'code'
endm

ResidentCodeEnd macro
ResidentCode    ends
endm

ResidentDataStart macro
ResidentData    segment public word 'data'
endm

ResidentDataEnd macro
ResidentData    ends
endm

InitCodeStart   macro
InitCode        segment public para 'init'
endm

InitCodeEnd     macro
InitCode        ends
endm

InitDataStart   macro
InitData        segment public word 'init'
endm

InitDataEnd     macro
InitData        ends
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\vwmisc.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwmisc.c

Abstract:

    ntVdm netWare (Vw) IPX/SPX Functions

    Vw: The peoples' network

    Contains miscellaneous (non-IPX/SPX) functions

    Contents:
        VwTerminateProgram

Author:

    Richard L Firth (rfirth) 30-Sep-1993

Environment:

    User-mode Win32

Revision History:

    30-Sep-1993 rfirth
        Created

--*/

#include "vw.h"
#pragma hdrstop

//
// functions
//


VOID
VwTerminateProgram(
    VOID
    )

/*++

Routine Description:

    When a DOS program terminates, we must close any open sockets that were
    specified as SHORT_LIVED

Arguments:

    None.

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "VwTerminateProgram: PDB=%04x\n",
                getCX()
                ));

    KillShortLivedSockets(getCX());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\vwmisc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vwipx.h

Abstract:

    Contains function prototypes for VWMISC.C

Author:

    Richard L Firth (rfirth) 25-Oct-1993

Revision History:

    25-Oct-1993 rfirth
        Created

--*/

VOID
VwTerminateProgram(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\vwvdm.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vwvdm.h

Abstract:

    Contains macros, manifests, includes for dealing with VDM

Author:

    Richard L Firth (rfirth) 25-Oct-1993

Revision History:

    25-Oct-1993 rfirth
        Created

--*/

#ifndef _VWVDM_H_
#define _VWVDM_H_

//
// unaligned pointers - non-Intel platforms must use UNALIGNED to access data
// in VDM which can (and most likely will) be aligned on odd-byte and word
// boundaries
//

#ifndef ULPBYTE
#define ULPBYTE BYTE UNALIGNED FAR*
#endif

#ifndef ULPWORD
#define ULPWORD WORD UNALIGNED FAR*
#endif

#ifndef ULPDWORD
#define ULPDWORD DWORD UNALIGNED FAR*
#endif

#ifndef ULPVOID
#define ULPVOID VOID UNALIGNED FAR*
#endif

//
// VDM macros
//

//
// POINTER_FROM_WORDS - returns 32-bit pointer to address in VDM memory described
// by seg:off. If seg:off = 0:0, returns NULL
//

#define POINTER_FROM_WORDS(seg, off, size) \
    _inlinePointerFromWords((WORD)(seg), (WORD)(off), (WORD)(size))

//
// _inlinePointerFromWords - the POINTER_FROM_WORDS macro is inefficient if the
// arguments are calls to eg. getES(), getBX() - the calls are made twice if
// the pointer turns out to be non-zero. Use an inline function to achieve the
// same results, but only call function arguments once
//

__inline LPVOID _inlinePointerFromWords(WORD seg, WORD off, WORD size) {
    return (seg | off)
        ? (LPVOID)GetVDMPointer((ULONG)(MAKELONG(off, seg)), size, (CHAR)((getMSW() & MSW_PE) ? TRUE : FALSE))
        : NULL;
}

//
// GET_POINTER - does the same thing as POINTER_FROM_WORDS, but we know beforehand
// which processor mode we are in
//

#define GET_POINTER(seg, off, size, mode) \
    _inlineGetPointer((WORD)(seg), (WORD)(off), (WORD)(size), (BOOL)(mode))

__inline LPVOID _inlineGetPointer(WORD seg, WORD off, WORD size, BOOL mode) {
    return (seg | off)
        ? (LPVOID)GetVDMPointer(MAKELONG(off, seg), size, (UCHAR)mode)
        : NULL;
}

//
// GET_FAR_POINTER - same as READ_FAR_POINTER with the same proviso as for
// GET_POINTER
//

#define GET_FAR_POINTER(addr, mode) ((LPBYTE)(GET_POINTER(GET_SELECTOR(addr), GET_OFFSET(addr), sizeof(LPBYTE), mode)))

//
// GET_SELECTOR - retrieves the selector word from the intel 32-bit far pointer
// (DWORD) pointed at by <pointer> (remember: stored as offset, segment)
//

#define GET_SELECTOR(pointer)   READ_WORD((LPWORD)(pointer)+1)

//
// GET_SEGMENT - same as GET_SELECTOR
//

#define GET_SEGMENT(pointer)    GET_SELECTOR(pointer)

//
// GET_OFFSET - retrieves the offset word from an intel 32-bit far pointer
// (DWORD) pointed at by <pointer> (remember: stored as offset, segment)
//

#define GET_OFFSET(pointer)     READ_WORD((LPWORD)(pointer))

//
// READ_FAR_POINTER - read the pair of words in VDM memory, currently pointed at
// by a 32-bit flat pointer and convert them to a 32-bit flat pointer
//

#define READ_FAR_POINTER(addr)  ((LPBYTE)(POINTER_FROM_WORDS(GET_SELECTOR(addr), GET_OFFSET(addr), sizeof(LPBYTE))))

//
// READ_WORD - read a single 16-bit little-endian word from VDM memory. On non
// Intel platforms, use unaligned pointer to access data
//

#define READ_WORD(addr)         (*((ULPWORD)(addr)))

//
// READ_DWORD - read a 4-byte little-endian double word from VDM memory. On non
// Intel platforms, use unaligned pointer to access data
//

#define READ_DWORD(addr)        (*((ULPDWORD)(addr)))

//
// ARRAY_ELEMENTS - gives the number of elements of a particular type in an
// array
//

#define ARRAY_ELEMENTS(a)   (sizeof(a)/sizeof((a)[0]))

//
// LAST_ELEMENT - returns the index of the last element in array
//

#define LAST_ELEMENT(a)     (ARRAY_ELEMENTS(a)-1)

#endif // _VWVDM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\vwspx.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vwspx.h

Abstract:

    Contains function prototypes for VWSPX.C

Author:

    Richard L Firth (rfirth) 25-Oct-1993

Revision History:

    25-Oct-1993 rfirth
        Created

--*/

VOID
VwSPXAbortConnection(
    VOID
    );

VOID
VwSPXEstablishConnection(
    VOID
    );

VOID
VwSPXGetConnectionStatus(
    VOID
    );

VOID
VwSPXInitialize(
    VOID
    );

VOID
VwSPXListenForConnection(
    VOID
    );

VOID
VwSPXListenForSequencedPacket(
    VOID
    );

VOID
VwSPXSendSequencedPacket(
    VOID
    );

VOID
VwSPXTerminateConnection(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\dll\vwspx.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwspx.c

Abstract:

    ntVdm netWare (Vw) IPX/SPX Functions

    Vw: The peoples' network

    Contains internal routines for DOS/WOW SPX calls (netware functions).
    The SPX APIs use WinSock to perform the actual operations

    Contents:
        _VwSPXAbortConnection
        _VwSPXEstablishConnection
        _VwSPXGetConnectionStatus
        _VwSPXInitialize
        _VwSPXListenForConnection
        _VwSPXListenForSequencedPacket
        _VwSPXSendSequencedPacket
        _VwSPXTerminateConnection

    The SPX functions build on the IPX functions (VWIPX.C). SPX maintains
    connections, IPX maintains sockets. A socket may have a list of connections

Author:

    Richard L Firth (rfirth) 30-Sep-1993

Environment:

    User-mode Win32

Revision History:

    30-Sep-1993 rfirth
        Created

--*/

#include "vw.h"
#pragma hdrstop

//
// functions
//


VOID
_VwSPXAbortConnection(
    IN WORD SPXConnectionID
    )

/*++

Routine Description:

    Aborts a connection. Because NWLink doesn't differentiate between abrupt
    and graceful closes, this function has the same effect as
    VwSPXTerminateConnection

Arguments:

    SPXConnectionID - connection to abort

Return Value:

    None.

--*/

{
    LPCONNECTION_INFO pConnectionInfo;

    RequestMutex();
    pConnectionInfo = FindConnection(SPXConnectionID);
    if (pConnectionInfo) {
        DequeueConnection(pConnectionInfo->OwningSocket, pConnectionInfo);
        AbortOrTerminateConnection(pConnectionInfo, ECB_CC_CONNECTION_ABORTED);
    } else {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_SPXAbortConnection,
                    IPXDBG_LEVEL_ERROR,
                    "VwSPXAbortConnection: cannot find connection %04x\n",
                    SPXConnectionID
                    ));

    }
    ReleaseMutex();
}


WORD
_VwSPXEstablishConnection(
    IN BYTE retryCount,
    IN BYTE watchDogFlag,
    OUT ULPWORD pSPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Creates a connection with a remote SPX socket. The remote end can be on
    this machine (i.e. same app in DOS world)

    This call is Asynchronous

Arguments:

    Inputs
        retryCount
        watchDogFlag
        pEcb
        EcbAddress

    Outputs
        pSPXConnectionID

Return Value:

    00h Attempting to talk to remote
    EFh Local connection table full
    FDh Fragment count not 1; buffer size not 42
    FFh Send socket not open

--*/

{
    LPXECB pXecb = RetrieveXEcb(ECB_TYPE_SPX, pEcb, EcbAddress);
    LPSOCKET_INFO pSocketInfo;
    LPCONNECTION_INFO pConnectionInfo;
    WORD connectionId;
    LPSPX_PACKET pPacket;
    SOCKADDR_IPX destination;
    int rc;
    SOCKET s;

    // tommye - MS 30525
    //
    // Make sure the xecb alloc didn't fail
    // We don't know what the real SPX does if a malloc fails.
    //

    if (pXecb == NULL) {
        return SPX_BAD_SEND_REQUEST;
    }

    pSocketInfo = FindSocket(pXecb->SocketNumber);
    if (!pSocketInfo) {
        CompleteEcb(pXecb, ECB_CC_NON_EXISTENT_SOCKET);
        return SPX_NON_EXISTENT_SOCKET;
    }

    //
    // if no outstanding IPX operations, change socket to SPX
    //

    if (!pSocketInfo->SpxSocket) {
        if (!(pSocketInfo->PendingSends && pSocketInfo->PendingListens)) {
            rc = ReopenSocket(pSocketInfo);
        } else {
            rc = ECB_CC_BAD_SEND_REQUEST;
        }
        if (rc != SPX_SUCCESS) {
            CompleteOrQueueEcb(pXecb, (BYTE)rc);
            return SPX_BAD_SEND_REQUEST;
        }
    }

    //
    // real SPX will use the ECB to send an ESTABLISH CONNECTION packet. This
    // is handled for us within the SPX transport. Nevertheless we must check
    // the fragment and dismiss the request if its not sufficient
    //

    if ((pXecb->Ecb->FragmentCount != 1)
    || (ECB_FRAGMENT(pXecb->Ecb, 0)->Length < SPX_HEADER_LENGTH)) {
        CompleteEcb(pXecb, ECB_CC_BAD_SEND_REQUEST);
        return SPX_BAD_SEND_REQUEST;
    }

    //
    // the socket is open for SPX. Allocate a connection/connection ID
    //

    pConnectionInfo = AllocateConnection(pSocketInfo);
    if (pConnectionInfo) {

        //
        // create new socket, bound to the same local address as the parent
        // socket. This is the 'connection'
        //

#if REUSEADDR

        connectionId = pSocketInfo->SocketNumber;
        rc = CreateSocket(SOCKET_TYPE_SPX, &connectionId, &pConnectionInfo->Socket);
        s = pConnectionInfo->Socket;
//        if (rc == SPX_SUCCESS) {

#else

        s = socket(AF_IPX, SOCK_SEQPACKET, NSPROTO_SPX);
        if (s != INVALID_SOCKET) {

            u_long arg = !0;

            //
            // put the socket in non-blocking I/O mode
            //

            rc = ioctlsocket(s, FIONBIO, &arg);
            if (rc != SOCKET_ERROR) {

                int true = 1;

                rc = setsockopt(s,
                                NSPROTO_IPX,
                                IPX_RECVHDR,
                                (char FAR*)&true,
                                sizeof(true)
                                );
                if (rc != SOCKET_ERROR) {
                    pConnectionInfo->Socket = s;
                } else {

                    IPXDBGPRINT((__FILE__, __LINE__,
                                FUNCTION_SPXEstablishConnection,
                                IPXDBG_LEVEL_ERROR,
                                "VwSPXEstablishConnection: setsockopt(IPX_RECVHDR) returns %d\n",
                                WSAGetLastError()
                                ));

                }
            } else {

                IPXDBGPRINT((__FILE__, __LINE__,
                            FUNCTION_SPXEstablishConnection,
                            IPXDBG_LEVEL_ERROR,
                            "VwSPXEstablishConnection: ioctlsocket(FIONBIO) returns %d\n",
                            WSAGetLastError()
                            ));

            }
        } else {
            rc = WSAGetLastError();

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_SPXEstablishConnection,
                        IPXDBG_LEVEL_ERROR,
                        "VwSPXEstablishConnection: socket() returns %d\n",
                        rc
                        ));

        }

#endif

    } else {
        rc = !SPX_SUCCESS;
    }

    if (rc == SPX_SUCCESS) {
        pConnectionInfo->State = CI_STARTING;
        connectionId = pConnectionInfo->ConnectionId;

        //
        // set the ECB InUse field to 0xF7. Same as snowball by observation (and
        // probably correct anyway since it looks as though 0xF7 means 'waiting
        // to receive SPX packet', which is true in this case - normally SPX
        // creates a connection by sending an establish frame then waits for the
        // ack frame
        //

        pXecb->Ecb->InUse = ECB_IU_LISTENING_SPX;
    } else {

        //
        // if we failed to get CONNECTION_INFO or create the new socket, return
        // immediately with an error (socket table full?)
        //

        if (s != INVALID_SOCKET) {
            closesocket(s);
        }
        if (pConnectionInfo) {
            DeallocateConnection(pConnectionInfo);
        }
        CompleteEcb(pXecb, ECB_CC_CONNECTION_TABLE_FULL);
        return SPX_CONNECTION_TABLE_FULL;
    }

    //
    // get the destination info from the SPX header in VDM memory and set up the
    // connection. If the connect request would wait then we leave AES to
    // periodically check the progress of the request
    //

    pPacket = (LPSPX_PACKET)GET_FAR_POINTER(&ECB_FRAGMENT(pXecb->Ecb, 0)->Address,
                                                          IS_PROT_MODE(pXecb)
                                                          );

    if (pPacket == NULL) {
        CompleteEcb(pXecb, ECB_CC_BAD_SEND_REQUEST);
        return SPX_BAD_SEND_REQUEST;
    }

    //
    // fill in the packet details (app shouldn't look at these until the command
    // completes). In 16-bit SPX, these values are filled in by the transport.
    // Our transport does not return these values, so we have to 'invent' them,
    // but since they are fairly static it should be ok (maybe the transport
    // should return them)
    //

    pPacket->Checksum = 0xffff;
    pPacket->Length = L2BW(SPX_HEADER_LENGTH);
    pPacket->TransportControl = 0;
    pPacket->PacketType = SPX_PACKET_TYPE;
    pPacket->Source.Socket = pSocketInfo->SocketNumber;
    pPacket->ConnectionControl = SPX_SYSTEM_PACKET | SPX_ACK_REQUIRED;
    pPacket->DataStreamType = SPX_DS_ESTABLISH;
    pPacket->SourceConnectId = pConnectionInfo->ConnectionId;
    pPacket->DestinationConnectId = 0xffff;
    pPacket->SequenceNumber = 0;
    pPacket->AckNumber = 0;
    pPacket->AllocationNumber = 0;

    //
    // get the destination address info
    //

    CopyMemory(&destination.sa_netnum,
               (LPBYTE)&pPacket->Destination,
               sizeof(pPacket->Destination)
               );
    destination.sa_family = AF_IPX;

    //
    // initiate the connection
    //

    rc = connect(s, (LPSOCKADDR)&destination, sizeof(destination));
    if (rc != SOCKET_ERROR) {

        //
        // add the CONNECTION_INFO structure to the list of connections owned
        // by this socket and set the connection state to ESTABLISHED
        //

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_SPXEstablishConnection,
                    IPXDBG_LEVEL_INFO,
                    "VwSPXEstablishConnection: socket connected\n"
                    ));

        RequestMutex();
        QueueConnection(pSocketInfo, pConnectionInfo);
        pConnectionInfo->State = CI_ESTABLISHED;
        ReleaseMutex();

        //
        // the connection ID also appears in the first segment of the establish
        // ECB
        //

        pPacket->SourceConnectId = connectionId;

        //
        // the SPXEstablishConnection ECB is done!
        //

        CompleteEcb(pXecb, ECB_CC_SUCCESS);
    } else {
        rc = WSAGetLastError();
        if (rc == WSAEWOULDBLOCK) {

            //
            // the connect request is in progress. Add it to the queue of
            // pending SPXEstablishConnection requests (SHOULD ONLY BE 1 PER
            // CONNECTION!!!) and add the CONNECTION_INFO structure to the
            // owning SOCKET_INFO structure
            //

            RequestMutex();
            QueueEcb(pXecb,
                     &pConnectionInfo->ConnectQueue,
                     CONNECTION_CONNECT_QUEUE
                     );
            QueueConnection(pSocketInfo, pConnectionInfo);
            ReleaseMutex();

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_SPXEstablishConnection,
                        IPXDBG_LEVEL_INFO,
                        "VwSPXEstablishConnection: connect() queued\n"
                        ));

        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_SPXEstablishConnection,
                        IPXDBG_LEVEL_ERROR,
                        "VwSPXEstablishConnection: connect(%x) returns %d\n",
                        s,
                        rc
                        ));

            //
            // the connect request failed. Deallocate all resources (socket,
            // CONNECTION_INFO, XECB) and return failure
            //

            closesocket(pConnectionInfo->Socket);
            DeallocateConnection(pConnectionInfo);
            CompleteEcb(pXecb, ECB_CC_CONNECTION_ABORTED);
            return SPX_CONNECTION_ABORTED;
        }
    }

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXEstablishConnection,
                IPXDBG_LEVEL_INFO,
                "VwSPXEstablishConnection: returning %04x\n",
                connectionId
                ));

    *pSPXConnectionID = connectionId;
    return SPX_SUCCESS;
}


WORD
_VwSPXGetConnectionStatus(
    IN WORD connectionId,
    OUT LPSPX_CONNECTION_STATS pStats
    )

/*++

Routine Description:

    Returns buffer crammed full of useful statistics or something (hu hu huh)

    This call is Synchronous

Arguments:

    Inputs
        connectionId
        pStats

    Outputs
        on output, buffer in pStats contains:

            BYTE    ConnectionStatus
            BYTE    WatchDogActive
            WORD    LocalConnectionID
            WORD    RemoteConnectionID
            WORD    SequenceNumber
            WORD    LocalAckNumber
            WORD    LocalAllocationNumber
            WORD    RemoteAckNumber
            WORD    RemoteAllocationNumber
            WORD    LocalSocket
            BYTE    ImmediateAddress[6]
            BYTE    RemoteNetwork[4]
            WORD    RetransmissionCount
            WORD    RetransmittedPackets
            WORD    SuppressedPackets

Return Value:
    00h Connection is active
    EEh No such connection

--*/

{
    int rc;
    IPX_SPXCONNSTATUS_DATA buf;
    int buflen = sizeof(buf);
    LPCONNECTION_INFO pConnectionInfo;

    pConnectionInfo = FindConnection(connectionId);
    if (!pConnectionInfo) {
        return SPX_INVALID_CONNECTION;
    }

    //
    // get the stats
    //

    rc = getsockopt(pConnectionInfo->Socket,
                    NSPROTO_IPX,
                    IPX_SPXGETCONNECTIONSTATUS,
                    (char FAR*)&buf,
                    &buflen
                    );
    if (rc == SOCKET_ERROR) {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_SPXGetConnectionStatus,
                    IPXDBG_LEVEL_ERROR,
                    "VwSPXGetConnectionStatus: getsockopt() returns %d\n",
                    WSAGetLastError()
                    ));

        //
        // the request to get the stats failed - probably because the socket is
        // not yet connected. Fill in those bits we know about
        //

        ZeroMemory((LPBYTE)pStats, sizeof(*pStats));
    } else {

        //
        // copy the returned fields
        //

        pStats->RemoteConnectionId       = buf.RemoteConnectionId;
        pStats->LocalSequenceNumber      = buf.LocalSequenceNumber;
        pStats->LocalAckNumber           = buf.LocalAckNumber;
        pStats->LocalAllocNumber         = buf.LocalAllocNumber;
        pStats->RemoteAckNumber          = buf.RemoteAckNumber;
        pStats->RemoteAllocNumber        = buf.RemoteAllocNumber;
        pStats->LocalSocket              = buf.LocalSocket;
        CopyMemory(&pStats->ImmediateAddress,
                   &buf.ImmediateAddress,
                   sizeof(buf.ImmediateAddress)
                   );

        //
        // copy remote network as a DWORD. Endian format is same for both
        //

        *(ULPDWORD)&pStats->RemoteNetwork = *(LPDWORD)&buf.RemoteNetwork;
        CopyMemory(&pStats->RemoteNode,
                   &buf.RemoteNode,
                   sizeof(buf.RemoteNode)
                   );
        pStats->RemoteSocket             = buf.RemoteSocket;
        pStats->RetransmissionCount      = buf.RetransmissionCount;
        pStats->EstimatedRoundTripDelay  = buf.EstimatedRoundTripDelay;
        pStats->RetransmittedPackets     = buf.RetransmittedPackets;
        pStats->SuppressedPackets        = buf.SuppressedPacket;
    }

    //
    // fill in common, known fields
    //

    pStats->State = pConnectionInfo->State; // not returned by NWIPX
    pStats->WatchDog = 0x02;    // see novell dog-umentation
    pStats->LocalConnectionId = L2BW(pConnectionInfo->ConnectionId);
    pStats->LocalSocket = pConnectionInfo->OwningSocket->SocketNumber;

    DUMPSTATS(pStats);

    //
    // we are returning some kind o stats - therefore success
    //

    return SPX_SUCCESS;
}


WORD
_VwSPXInitialize(
    OUT ULPBYTE pMajorRevisionNumber,
    OUT ULPBYTE pMinorRevisionNumber,
    OUT ULPWORD pMaxConnections,
    OUT ULPWORD pAvailableConnections
    )

/*++

Routine Description:

    Informs the app that SPX is present on this station

    This call is Synchronous

Arguments:

    Inputs

    Outputs
        pMajorRevisionNumber - SPX Major revision number
        pminorRevisionNumber - SPX Minor revision number
        pMaxConnections -  Maximum SPX connections supported
                           normally from SHELL.CFG
        pAvailableConnections - Available SPX connections

Return Value:

    00h Not installed
    FFh Installed

--*/

{

    //
    // The following values are returned same as per Windows For Workgroups
    // v3.10
    //

    *pMajorRevisionNumber = 3;
    *pMinorRevisionNumber = 10;
    *pMaxConnections = 128;
    *pAvailableConnections = *pMaxConnections - 1 ;

    return SPX_INSTALLED;
}


VOID
_VwSPXListenForConnection(
    IN BYTE retryCount,
    IN BYTE watchDogFlag,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Listens for an incoming connection request

    This call is Asynchronous

Arguments:

    Inputs
        retryCount
        watchDogFlag
        pEcb
        EcbAddress

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    LPXECB pXecb = RetrieveXEcb(ECB_TYPE_SPX, pEcb, EcbAddress);
    LPSOCKET_INFO pSocketInfo;
    LPCONNECTION_INFO pConnectionInfo;
    SOCKET sock;
    SOCKET conn;
    SOCKADDR_IPX remoteAddress;
    int rc;
    BYTE completionCode;

    // tommye - MS 30525
    //
    // Make sure the xecb alloc didn't fail
    //

    if (pXecb == NULL) {
        IPXDBGPRINT((__FILE__, __LINE__, 
                    FUNCTION_SPXListenForConnection,
                    IPXDBG_LEVEL_ERROR,
                    "RetrieveXEcb returned NULL pointer"
                    ));
        return;
    }

    //
    // it turns out that SPXListenForConnection doesn't need a fragment to
    // receive connection info - that is handled by SPXListenForSequencedPacket
    // that the app has dutifully initiated
    //

    pSocketInfo = FindSocket(pXecb->SocketNumber);
    if (!pSocketInfo) {
        completionCode = ECB_CC_NON_EXISTENT_SOCKET;
        goto lc_completion_exit;
    }

    //
    // if no outstanding IPX operations, change socket to SPX
    //

    if (!pSocketInfo->SpxSocket) {
        if (!(pSocketInfo->PendingSends && pSocketInfo->PendingListens)) {
            rc = ReopenSocket(pSocketInfo);
        } else {
            rc = ECB_CC_BAD_LISTEN_REQUEST;
        }
        if (rc != SPX_SUCCESS) {
            completionCode = (BYTE)rc;
            goto lc_completion_exit;
        }
    }

    //
    // the socket is open for SPX. Allocate a connection/connection ID
    //

    pConnectionInfo = AllocateConnection(pSocketInfo);
    if (!pConnectionInfo) {
        completionCode = ECB_CC_CONNECTION_TABLE_FULL;
        goto lc_completion_exit;
    }

    //
    // put the socket into listening state and try to accept a connection
    //

    sock = pSocketInfo->Socket;

    //
    // If the socket is already listening, will probably return an
    // error: just queue
    //

    rc = listen(sock, MAX_LISTEN_QUEUE_SIZE);
    if (rc != SOCKET_ERROR) {

        int addressLength = sizeof(remoteAddress);

        conn = accept(sock, (LPSOCKADDR)&remoteAddress, &addressLength);
        if (conn != SOCKET_ERROR) {

            //
            // we want to receive the frame headers from this socket
            //

            BOOL bval = TRUE;

            rc = setsockopt(conn,
                            NSPROTO_IPX,
                            IPX_RECVHDR,
                            (char FAR*)&bval,
                            sizeof(bval)
                            );
            if (rc != SOCKET_ERROR) {

                //
                // update the CONNECTION_INFO structure with the actual socket
                // identifier and set the connection state to established
                //

                pConnectionInfo->Socket = conn;
                pConnectionInfo->State = CI_ESTABLISHED;

                //
                // add the CONNECTION_INFO structure to the list of connections owned
                // by this socket
                //

                RequestMutex();
                QueueConnection(pSocketInfo, pConnectionInfo);
                ReleaseMutex();

                //
                // update the app's ECB with the connection ID
                //

                SPX_ECB_CONNECTION_ID(pXecb->Ecb) = pConnectionInfo->ConnectionId;

                //
                // and with the partner address info
                //

                CopyMemory(&pXecb->Ecb->DriverWorkspace,
                           &remoteAddress.sa_netnum,
                           sizeof(pXecb->Ecb->DriverWorkspace)
                           );
                completionCode = ECB_CC_SUCCESS;
                goto lc_completion_exit;
            } else {

                IPXDBGPRINT((__FILE__, __LINE__,
                            FUNCTION_SPXListenForConnection,
                            IPXDBG_LEVEL_ERROR,
                            "VwSPXListenForConnection: setsockopt(RECVHDR) returns %d\n",
                            WSAGetLastError()
                            ));

                closesocket(conn);
                completionCode = ECB_CC_CONNECTION_ABORTED;
                goto lc_deallocate_exit;
            }
        } else {
            rc = WSAGetLastError();
            if (rc == WSAEWOULDBLOCK) {

                //
                // the accept request is in progress. Add it to the queue of
                // pending SPXListenForConnection requests (SHOULD ONLY BE 1 PER
                // CONNECTION!!!) and add the CONNECTION_INFO structure to the
                // owning SOCKET_INFO structure
                //

                pConnectionInfo->State = CI_WAITING; // waiting for incoming connect
                RequestMutex();
                QueueEcb(pXecb,
                         &pConnectionInfo->AcceptQueue,
                         CONNECTION_ACCEPT_QUEUE
                         );
                QueueConnection(pSocketInfo, pConnectionInfo);
                pXecb->Ecb->InUse = ECB_IU_AWAITING_CONNECTION;
                ReleaseMutex();
            } else {

                //
                // the accept request failed. Deallocate all resources
                // (CONNECTION_INFO, XECB) and complete the ECB with a failure
                // indication
                //

                IPXDBGPRINT((__FILE__, __LINE__,
                            FUNCTION_SPXListenForConnection,
                            IPXDBG_LEVEL_ERROR,
                            "VwSPXListenForConnection: accept() returns %d\n",
                            rc
                            ));

                completionCode = ECB_CC_CONNECTION_ABORTED;
                goto lc_deallocate_exit;
            }
        }
    } else {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_SPXListenForConnection,
                    IPXDBG_LEVEL_ERROR,
                    "VwSPXListenForConnection: listen() returns %d\n",
                    WSAGetLastError()
                    ));

        //
        // listen failed? Bogus. Complete the ECB and we're outta here
        //

        completionCode = ECB_CC_CONNECTION_ABORTED;
        goto lc_deallocate_exit;
    }

    //
    // here if we queued the listen request
    //

    return;

lc_deallocate_exit:
    DeallocateConnection(pConnectionInfo);

lc_completion_exit:
    CompleteEcb(pXecb, completionCode);
}


VOID
_VwSPXListenForSequencedPacket(
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Attempts to receive an SPX packet. This call is made against the top-level
    socket (the socket in SPX-speak, not the connection). We can receive a
    packet from any connection assigned to this socket. In this function, we
    just queue the ECB (since there is no return status, we expect that the
    app has supplied an ESR) and let AES handle it

    This call is Asynchronous

Arguments:

    Inputs
        pEcb
        EcbAddress

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    LPXECB pXecb = RetrieveXEcb(ECB_TYPE_SPX, pEcb, EcbAddress);
    LPSOCKET_INFO pSocketInfo;
    int rc;
    BOOL dummy ;
    BYTE status;

    // tommye - MS 30525
    //
    // Make sure the xecb alloc didn't fail
    //

    if (pXecb == NULL) {
        IPXDBGPRINT((__FILE__, __LINE__, 
                    FUNCTION_SPXListenForSequencedPacket,
                    IPXDBG_LEVEL_ERROR,
                    "RetrieveXEcb returned NULL pointer"
                    ));
        return;
    }

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXListenForSequencedPacket,
                IPXDBG_LEVEL_INFO,
                "VwSPXListenForSequencedPacket(%04x:%04x) socket=%04x ESR=%04x:%04x\n",
                HIWORD(pXecb->EcbAddress),
                LOWORD(pXecb->EcbAddress),
                B2LW(pXecb->SocketNumber),
                HIWORD(pXecb->EsrAddress),
                LOWORD(pXecb->EsrAddress)
                ));

    pSocketInfo = FindSocket(pXecb->SocketNumber);
    if (!pSocketInfo) {
        status = ECB_CC_NON_EXISTENT_SOCKET;
        goto lp_exit;
    }

    //
    // if no outstanding IPX operations, change socket to SPX
    //

    if (!pSocketInfo->SpxSocket) {
        if (!(pSocketInfo->PendingSends && pSocketInfo->PendingListens)) {
            rc = ReopenSocket(pSocketInfo);
        } else {
            rc = ECB_CC_BAD_LISTEN_REQUEST;
        }
        if (rc != SPX_SUCCESS) {
            status = (BYTE)rc;
            goto lp_exit;
        }
    }

    //
    // the first fragment must be large enough to hold an SPX packet header
    //

    if ((pXecb->Ecb->FragmentCount == 0)
    || (ECB_FRAGMENT(pXecb->Ecb, 0)->Length < SPX_HEADER_LENGTH)) {
        status = ECB_CC_BAD_LISTEN_REQUEST;
        goto lp_exit;
    }

    //
    // we have a socket and the receive buffer looks good. Get a buffer for recv()
    //

    if (!GetIoBuffer(pXecb, FALSE, SPX_HEADER_LENGTH)) {
        status = ECB_CC_BAD_LISTEN_REQUEST;
        goto lp_exit;
    } else {

        //
        // when recv() is attempted against this request, it will be the first
        // time we tried to receive anything to this buffer. That means (if we
        // get anything) that the buffer will contain the length of the entire
        // frame
        //

        pXecb->Flags |= XECB_FLAG_FIRST_RECEIVE;
    }

    //
    // mark the VDM ECB as in use
    //

    pXecb->Ecb->InUse = ECB_IU_LISTENING_SPX;

    //
    // add this ECB to the queue of listens for the top-level socket and quit
    //

    RequestMutex();

    if ((pXecb->Ecb->FragmentCount == 1) &&
        (ECB_FRAGMENT(pXecb->Ecb, 0)->Length == SPX_HEADER_LENGTH))
    {
        QueueEcb(pXecb, &pSocketInfo->HeaderQueue, SOCKET_HEADER_QUEUE);
    }
    else
    {
        QueueEcb(pXecb, &pSocketInfo->ListenQueue, SOCKET_LISTEN_QUEUE);
    }

    ReleaseMutex();

    //
    // see if we are ready to rock
    //

    CheckPendingSpxRequests(&dummy);
    return;

lp_exit:
    CompleteOrQueueEcb(pXecb, status);
}


VOID
_VwSPXSendSequencedPacket(
    IN WORD connectionId,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Sends a packet on an SPX connection

    This call is Asynchronous

Arguments:

    Inputs
        connectionId
        pEcb
        EcbAddress

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    LPXECB pXecb = RetrieveXEcb(ECB_TYPE_SPX, pEcb, EcbAddress);
    LPCONNECTION_INFO pConnectionInfo;
    int rc;
    BOOL addToQueue;
    LPSPX_PACKET pPacket;

    // tommye - MS 30525
    //
    // Make sure the xecb alloc didn't fail
    //

    if (pXecb == NULL) {
        IPXDBGPRINT((__FILE__, __LINE__, 
                    FUNCTION_SPXSendSequencedPacket, 
                    IPXDBG_LEVEL_ERROR,
                    "RetrieveXEcb returned NULL pointer"
                    ));
        return;
    }

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXSendSequencedPacket,
                IPXDBG_LEVEL_INFO,
                "VwSPXSendSequencedPacket(%04x:%04x) Connection=%04x ESR=%04x:%04x\n",
                HIWORD(pXecb->EcbAddress),
                LOWORD(pXecb->EcbAddress),
                connectionId,
                HIWORD(pXecb->EsrAddress),
                LOWORD(pXecb->EsrAddress)
                ));

    IPXDUMPECB((pXecb->Ecb,
                HIWORD(pXecb->EcbAddress),
                LOWORD(pXecb->EcbAddress),
                ECB_TYPE_SPX,
                TRUE,
                TRUE,
                IS_PROT_MODE(pXecb)
                ));

    //
    // find the connection. No need to check if this is an SPX socket: if we
    // can't find the connection, its a bad connection, else the socket must
    // be open for SPX
    //

    pConnectionInfo = FindConnection(connectionId);
    if (!pConnectionInfo || (pConnectionInfo->State != CI_ESTABLISHED)) {
        CompleteOrQueueEcb(pXecb, ECB_CC_INVALID_CONNECTION);
        return;
    }

    //
    // the first fragment must be large enough to hold an SPX packet header
    //

    if ((pXecb->Ecb->FragmentCount == 0)
    || (ECB_FRAGMENT(pXecb->Ecb, 0)->Length < SPX_HEADER_LENGTH)) {
        CompleteOrQueueEcb(pXecb, ECB_CC_BAD_SEND_REQUEST);
        return;
    }
    if (!GetIoBuffer(pXecb, TRUE, SPX_HEADER_LENGTH)) {
        CompleteOrQueueEcb(pXecb, ECB_CC_BAD_SEND_REQUEST);
        return;
    }

    pPacket = (LPSPX_PACKET)GET_FAR_POINTER(
                                    &(ECB_FRAGMENT(pXecb->Ecb, 0)->Address),
                                    IS_PROT_MODE(pXecb)
                                    );

    //
    // fill in the following fields in the SPX header:
    //
    //  Checksum
    //  Length
    //  TransportControl
    //  Source (network, node, socket)
    //
    // Does real IPX modify these fields in app memory?
    //         If so, does the app expect modified fields?
    //         If not, we need to always copy then modify memory,
    //         even if only 1 fragment
    //

    pPacket->Checksum = 0xFFFF;

    //
    // since the transport adds the SPX header, we subtracted the length of
    // the header from our transmit length; add it back when updating the
    // header in the app's space
    //

    pPacket->Length = L2BW(pXecb->Length + SPX_HEADER_LENGTH);
    pPacket->TransportControl = 0;
    CopyMemory((LPBYTE)&pPacket->Source,
               &MyInternetAddress.sa_netnum,
               sizeof(MyInternetAddress.sa_netnum)
               + sizeof(MyInternetAddress.sa_nodenum)
               );
    pPacket->Source.Socket = pConnectionInfo->OwningSocket->SocketNumber;

    //
    // if we allocated a buffer then there is >1 fragment. Collect them
    //

    if (pXecb->Flags & XECB_FLAG_BUFFER_ALLOCATED) {
        GatherData(pXecb, SPX_HEADER_LENGTH);
    }

    //
    // mark the VDM ECB as in use
    //

    pXecb->Ecb->InUse = ECB_IU_SENDING;

    //
    // if there is a send queued on this connection already, add this request
    // to the back of the queue and let AES do the rest
    //

    RequestMutex();
    if (pConnectionInfo->SendQueue.Head) {
        addToQueue = TRUE;
    } else {

        int dataStreamType;

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_SPXSendSequencedPacket,
                    IPXDBG_LEVEL_INFO,
                    "VwSPXSendSequencedPacket: sending %d (0x%x) bytes from %08x\n",
                    pXecb->Length,
                    pXecb->Length,
                    pXecb->Data
                    ));

        //
        // no outstanding sends queued for this connection. Start sending this
        // packet
        //

        dataStreamType = (int)pPacket->DataStreamType;
        rc = setsockopt(pConnectionInfo->Socket,
                        NSPROTO_IPX,
                        IPX_DSTYPE,
                        (char FAR*)&dataStreamType,
                        sizeof(dataStreamType)
                        );
        if (rc != SOCKET_ERROR) {

            //
            // if the app set the END_OF_MESSAGE bit in the ConnectionControl
            // field then set the flags to 0: NWLink will automatically set the
            // end-of-message bit in the packet; otherwise set flags to MSG_PARTIAL
            // to indicate to NWLink that it *shouldn't* set the bit in the packet
            //

            int flags = (pPacket->ConnectionControl & SPX_END_OF_MESSAGE)
                      ? 0
                      : MSG_PARTIAL
                      ;

            rc = send(pConnectionInfo->Socket, pXecb->Data, pXecb->Length, flags);

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_SPXSendSequencedPacket,
                        IPXDBG_LEVEL_INFO,
                        "VwSPXSendSequencedPacket: send() returns %d\n",
                        rc
                        ));

            if (rc == pXecb->Length) {

                //
                // all data sent
                //

                CompleteOrQueueIo(pXecb, ECB_CC_SUCCESS);
                addToQueue = FALSE;
            } else if (rc == SOCKET_ERROR) {
                rc = WSAGetLastError();
                if (rc == WSAEWOULDBLOCK) {

                    //
                    // can't send right now. Queue it for AES
                    //

                    addToQueue = TRUE;
                }
            } else {

                //
                // partial data sent. Update the buffer pointer and length fields
                // and queue this request
                //

                pXecb->Data += rc;
                pXecb->Length -= (WORD)rc;
                addToQueue = TRUE;
            }
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_SPXSendSequencedPacket,
                        IPXDBG_LEVEL_ERROR,
                        "VwSPXSendSequencedPacket: setsockopt(IPX_DSTYPE) returns %d\n",
                        WSAGetLastError()
                        ));

            CompleteOrQueueIo(pXecb, ECB_CC_BAD_REQUEST);
        }
    }

    //
    // if addToQueue set then we can't do anything right now - add this
    // request to the send queue
    //

    if (addToQueue) {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_SPXSendSequencedPacket,
                    IPXDBG_LEVEL_WARNING,
                    "VwSPXSendSequencedPacket: adding XECB %08x to send queue\n",
                    pXecb
                    ));

        QueueEcb(pXecb, &pConnectionInfo->SendQueue, CONNECTION_SEND_QUEUE);
    }
    ReleaseMutex();
}


VOID
_VwSPXTerminateConnection(
    IN WORD SPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Terminates a connection

Arguments:

    SPXConnectionID - connection to terminate
    pEcb            - pointer to 16-bit ECB to use
    EcbAddress      - address of 16-bit ECB in 16:16 format

Return Value:

    None.

--*/

{
    LPCONNECTION_INFO pConnectionInfo;
    LPXECB pXecb = RetrieveXEcb(ECB_TYPE_SPX, pEcb, EcbAddress);
    BYTE status;
    BYTE completionCode;

    // tommye - MS 30525
    //
    // Make sure the xecb alloc didn't fail
    //

    if (pXecb == NULL) {
        return;
    }

    RequestMutex();
    pConnectionInfo = FindConnection(SPXConnectionID);
    if (pConnectionInfo) {

        //
        // once dequeued, pConnectionInfo no longer points to OwningSocket
        //

        WORD socketNumber = pConnectionInfo->OwningSocket->SocketNumber;

        DequeueConnection(pConnectionInfo->OwningSocket, pConnectionInfo);
        if ((pXecb->Ecb->FragmentCount >= 1)
        && (ECB_FRAGMENT(pXecb->Ecb, 0)->Length >= SPX_HEADER_LENGTH)) {

            LPSPX_PACKET pPacket;
            SOCKADDR_IPX remote;
            int remoteLen = sizeof(remote);

            completionCode = ECB_CC_CONNECTION_TERMINATED;
            status = ECB_CC_SUCCESS;

            //
            // fill in the packet header: this would normally contain the
            // acknowledgement packet from the remote partner
            //

            pPacket = (LPSPX_PACKET)GET_FAR_POINTER(
                                        &(ECB_FRAGMENT(pXecb->Ecb, 0)->Address),
                                        IS_PROT_MODE(pXecb)
                                        );
            if (pPacket == NULL) {
                completionCode = ECB_CC_CONNECTION_ABORTED;
                status = ECB_CC_BAD_REQUEST;
            }
            else {
                pPacket->Checksum = 0xffff;
                pPacket->Length = L2BW(SPX_HEADER_LENGTH);
                pPacket->TransportControl = 0;
                pPacket->PacketType = SPX_PACKET_TYPE;
                getpeername(pConnectionInfo->Socket, (LPSOCKADDR)&remote, &remoteLen);
                CopyMemory((LPBYTE)&pPacket->Destination,
                           (LPBYTE)&remote.sa_netnum,
                           sizeof(NETWARE_ADDRESS)
                           );
                CopyMemory((LPBYTE)&pPacket->Source,
                           (LPBYTE)&MyInternetAddress.sa_netnum,
                           sizeof(INTERNET_ADDRESS)
                           );
                pPacket->Source.Socket = socketNumber;
                pPacket->ConnectionControl = SPX_ACK_REQUIRED;
                pPacket->DataStreamType = SPX_DS_TERMINATE;
                pPacket->SourceConnectId = pConnectionInfo->ConnectionId;
                pPacket->DestinationConnectId = 0;
                pPacket->SequenceNumber = 0;
                pPacket->AckNumber = 0;
                pPacket->AllocationNumber = 0;
            }

        } else {
            completionCode = ECB_CC_CONNECTION_ABORTED;
            status = ECB_CC_BAD_REQUEST;
        }
        AbortOrTerminateConnection(pConnectionInfo, completionCode);
    } else {
        status = ECB_CC_INVALID_CONNECTION;
    }
    ReleaseMutex();
    CompleteOrQueueEcb(pXecb, status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=vwipxspx

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\makefile.inc ===
!IF 0

Copyright (c) 1991 & 1993  Microsoft Corporation

Module Name:

    makefile

Abstract:

    makefile for Vdm NetWare Redir program

Author:

    Richard L Firth (rfirth) 13-Sep-1991

Revision History:

    13-Sep-1991 rfirth
        Created

!ENDIF

!include $(NTMAKEENV)\makefile.plt

#
# Because we've invoked nmake from within a makefile, macros defined
# in a previous makefile (ie, sources, sources.inc, makefile.def)
# are not defined at this point unless they're defined on the command
# line.  This makefile assumes the LANGUAGE and ALT_PROJECT_TARGET macros
# defined in $(LANGUAGE)\sources.inc are passed to this invokation of nmake
# on the command line.
#

!if "$(PROCESSOR_ARCHITECTURE)" == "x86"
TARGET_DIRECTORY=i386
!elseif "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
TARGET_DIRECTORY=alpha
!endif

#
# set the LANGUAGE info
#

!IFNDEF LANGUAGE
LANGUAGE=USA
!ENDIF

DEST=$(LANGUAGE)\$(_OBJ_DIR)\$(TARGET_DIRECTORY)

.SUFFIXES:
.SUFFIXES:  .asm .h


PATH=$(PATH_TOOLS16);$(PATH)

ASM         = masm
LINK        = link16

#
# convert NTDEBUG into DEBUG flag. NTDEBUG can be not present or retail, either
# of which mean no debugging; or ntsd, cvp or sym, which means debugging support
# required
#

!IF $(FREEBUILD)
DEBUGGING=0
!ELSE
DEBUGGING=1
!ENDIF

#
# assembler and linker debugging options
#

!IF $(DEBUGGING)
ASMDEBUG    =/DDEBUG=1 /Zi
LINKDEBUG   =/CO
!ELSE
ASMDEBUG    =/DDEBUG=0
LINKDEBUG   =
!ENDIF

ASMINC      =/I. /I..\..\inc /I..\..\inc\$(LANGUAGE) /I$(SDK_INC16_PATH)
ASMFLAGS    =/Mx
LINKFLAGS   =/MAP /CP:1

#
# any other non-debug related options (for assembler) go in USERDEFS
#

USERDEFS    =/DCALL_DOS

#
# Inference rules - asm to obj, h to inc
#

.asm{$(DEST)\}.obj:
    @rem Setting the MASM env var keeps the masm command line below 128 chars
    set MASM=$(ASMDEBUG) $(USERDEFS) $(ASMINC)
    $(ASM) $<,$@;

.h.inc:
    h2inc $< -o $*.inc

.asm.lst:
    $(ASM) $(ASMINC) $(ASMDEBUG) $(USERDEFS) /d /L $<;

#
# what it is we're building
#

TARGET      = $(DEST)\vwipxspx.exe
MAPFILE     = $(TARGET:.exe=.map)
DEFFILE     = ;

OBJS        = $(DEST)\vwipxspx.obj

LIBS        =

#
# how to build it
#

all:    makedir $(TARGET)

$(TARGET):  $(OBJS)
    $(LINK) @<<
$(OBJS)
$(TARGET) $(LINKFLAGS) $(LINKDEBUG)
$(MAPFILE)
$(LIBS)
$(DEFFILE)
<<


#
# where to put it
#

     if not exist $(DEST) md $(DEST)
     binplace -o $(ALT_PROJECT_TARGET) $(TARGET)
     binplace -o $(ALT_PROJECT_TARGET) $(MAPFILE)

#
# clean build - delete all objs
#

#clean:  makedir clean2
clean:  clean2

clean2:
    if exist messages.inc del messages.inc
    if exist $(DEST)\*.obj del $(DEST)\*.obj
    $(MAKE)

#
# makedir - ensure the subdirectory for the object files exists
#

makedir:
    @-if not exist $(DEST) md $(DEST)

#
# file dependencies
#

$(DEST)\vwipxspx.obj:   \
        vwipxspx.asm    \
        debugmac.inc    \
        asmmacro.inc    \
        segorder.inc    \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\vwipxspx.asm ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwipxspx.asm

Abstract:

    Contains handlers for 16-bit (DOS) netware IPX/SPX emulation. Creates TSR

    Contents:
        start
        InstallationCheck
        InstallVdd
        InstallInterruptHandlers
        VwIpxEntryPoint
        VwIpxDispatcher
        VwIpx7ADispatcher
        DispatchWithFeeling
        VwIpxEsrFunction

Author:

    Richard L Firth (rfirth) 30-Sep-1993

Environment:

    DOS Real mode only

Revision History:

    30-Sep-1993 rfirth
        Created

--*/

endif

;
; DOS include files
;
        
.xlist
.xcref
include ..\..\..\..\public\sdk\inc\isvbop.inc      ; NTVDM BOP mechanism
include dossym.inc      ; includes MS-DOS version etc
include pdb.inc         ; PSP defines
include syscall.inc     ; AssignOper
include segorder.inc    ; load order of 'redir' segments
include debugmac.inc    ; debug display macros
include asmmacro.inc    ; jumps which may be short or near
include messages.inc    ; internationalisationable (prestidigitation) messages
.cref
.list

InitStack segment stack para 'stack'

        dw      256 dup (?)

InitStack ends

InitDataStart

bad_ver_msg             db      NLS_MSG_001,c_CR,c_LF
BAD_VER_MSG_LEN         equ     $-bad_ver_msg
                        db      '$'     ; for INT 21/09 display string

already_loaded_msg      db      NLS_MSG_002,c_CR,c_LF
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

cannot_load_msg         db      NLS_MSG_003,c_CR, c_LF
CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg

;
; strings used to load/dispatch NWIPXSPX.DLL
;

DllName         db      "VWIPXSPX.DLL",0
InitFunc        db      "VwInitialize",0
DispFunc        db      "VwDispatcher",0

InitDataEnd

InitCodeStart
        assume  cs:InitCode
        assume  ds:nothing
        assume  es:nothing
        assume  ss:nothing

        public  start
start   proc    near

;
; when we start up we could be on any old PC - even an original, so don't
; assume anything other than a model-T processor
;

        .8086

;
; Set the data segment while we're at it - all paths set it sooner
; or later. NOTE: es will point to the PSP until we change it!
;

        mov     dx,InitData
        mov     ds,dx

        assume  ds:InitData

;
; first off, get the DOS version. If we're not running on NT (VDM) then this
; TSR's not going to do much, so exit. Exit using various methods, depending
; on the DOS version (don't you hate compatibility?)
;

        mov     ah,30h
        int     21h
        jc      ancient_version         ; version not even supported

;
; version is 2.0 or higher. Check it out. al = major#, ah = minor#
;

        cmp     al,major_version
        jne     invalid_version

;
; okay, we're at least 5.0. But are we NT?
;

        mov     ax,3306h
        int     21h
        jc      invalid_version         ; ?
        cmp     bl,5
        jne     invalid_version
        cmp     bh,50
        jne     invalid_version

;
; what do you know? We're actually running on NT (unless some evil programmer
; has pinched int 21h/30h and broken it!). Enable minimum instruction set
; for NTVDM (286 on RISC).
;

        .286c

;
; perform an installation check. Bail if we're there dude ((C) Beavis & Butthead)
;

        call    InstallationCheck
        jnz     already_here            ; nope - IPX/SPX support installed already

;
; We should find some way of deferring loading the 32-bit DLL until an
; IPX/SPX function is called, to speed-up loading. However, if we later find we
; cannot load the DLL, it may be too late: there is no way of consistently
; returning an error and we cannot unload the TSR
;

        call    InstallVdd              ; returns IRQ in BX
        jc      initialization_error
        call    InstallInterruptHandlers

        assume  es:nothing

;
; free the environment segment
;

        mov     es,es:[PDB_environ]
        mov     ah,49h
        int     21h                     ; free environment segment

;
; finally terminate and stay resident
;

        mov     dx,ResidentEnd
        sub     dx,ResidentStart        ; number of paragraphs in resident code
        add     dx,10h                  ; additional for PSP (PDB)
        mov     ax,3100h
        int     21h                     ; terminate and stay resident

;
; here if the MS-DOS version check (Ah=30h) call is not supported
;

ancient_version:
        mov     dx,InitData
        mov     ds,dx

        assume  ds:InitData

        mov     dx,offset bad_ver_msg
        mov     ah,9                    ; cp/m-style write to output
        int     21h

;
; safe exit: what we really want to do here is INT 20H, but when you do this,
; CS must be the segment of the PSP of this program. Knowing that CD 20 is
; embedded at the start of the PSP, the most foolproof way of doing this is
; to jump (using far return) to the start of the PSP
;

        push    es
        xor     ax,ax
        push    ax
        retf                            ; terminate

;
; we are running on a version of DOS >= 2.00, but its not NT, so we still can't
; help. Display the familiar message and exit, but using a less programmer-
; hostile mechanism
;

invalid_version:
        mov     dx,offset bad_ver_msg
        mov     cx,BAD_VER_MSG_LEN
        jmp     short print_error_message_and_exit

;
; if we cannot initialize 32-bit support (because we can't find/load the DLL)
; then put back the hooked interrupt vectors as they were when this TSR started,
; display a message and fail to load the redir TSR
;

initialization_error:
        mov     dx,offset cannot_load_msg
        mov     cx,CANNOT_LOAD_MSG_LEN
        jmp     short print_error_message_and_exit

;
; The DOS version's OK, but this TSR is already loaded
;

already_here:
        mov     dx,offset already_loaded_msg
        mov     cx,ALREADY_LOADED_MSG_LEN

print_error_message_and_exit:
        mov     bx,1                    ; bx = stdout handle
        mov     ah,40h                  ; write to handle
        int     21h                     ; write (cx) bytes @ (ds:dx) to stdout
        mov     ax,4c01h                ; terminate program
        int     21h                     ; au revoir, cruel environment

start   endp

; ***   InstallationCheck
; *
; *     Test to see if this module is already loaded
; *
; *     ENTRY   nothing
; *
; *     EXIT    ZF = 0: loaded
; *
; *     USES    AX
; *
; *     ASSUMES nothing
; *
; ***

InstallationCheck proc
        mov     ax,7a00h
        int     2fh
        or      al,al
        ret
InstallationCheck endp

; ***   InstallVdd
; *
; *     Load VWIPXSPX.DLL into the NTVDM process context
; *
; *     ENTRY   nothing
; *
; *     EXIT    CF = 1: error
; *             CF = 0: VWIPXSPX loaded ok
; *                     AX = VDD handle
; *                     BX = IRQ used by call-back functions (ESR)
; *                     ResidentCode:VddHandle updated
; *                     ResidentCode:IrqValue updated
; *
; *     USES    AX, BX, SI, DI
; *
; *     ASSUMES nothing
; *
; ***

InstallVdd proc
        push    ds
        push    es
        mov     ax,InitData
        mov     ds,ax

        assume  ds:InitData

        mov     es,ax
        mov     si,offset DllName       ; ds:si = library name
        mov     di,offset InitFunc      ; es:di = init function name
        mov     bx,offset DispFunc      ; ds:bx = dispatcher function name

        RegisterModule                  ; returns carry if problem

        mov     si,ResidentCode
        mov     ds,si

        assume  ds:ResidentCode

        mov     VddHandle,ax
        mov     IrqValue,bx
        pop     es

        assume  es:nothing

        pop     ds

        assume  ds:nothing

        ret
InstallVdd endp

; ***   InstallInterruptHandlers
; *
; *     Sets the interrupt handlers for all the ints we use - 2F, 7A
; *
; *     ENTRY   BX = IRQ for call-backs
; *             ES = PSP segment
; *
; *     EXIT    Old2FHandler contains the original interrupt 2F vector
; *             Old7AHandler contains the original interrupt 7A vector
; *             OldIrqHandler contains original IRQ vector
; *
; *     USES    AX, BX, CX, DX
; *
; *     ASSUMES nothing
; *
; ***

InstallInterruptHandlers proc
        push    es                      ; PSP segment - destroyed by INT 21/35h
        push    ds
        mov     dx,ResidentCode
        mov     ds,dx

        assume  ds:ResidentCode

;
; get and set call-back IRQ
;

        mov     ah,35h
        mov     al,bl
        mov     cl,bl                   ; cl = IRQ number
        int     21h
        mov     word ptr OldIrqHandler,bx
        mov     word ptr OldIrqHandler+2,es
        mov     al,cl
        mov     ah,25h
        mov     dx,offset ResidentCode:VwIpxEsrFunction
        int     21h

;
; get and set 2F handler
;

        mov     ax,352Fh
        int     21h
        mov     word ptr Old2FHandler,bx
        mov     word ptr Old2FHandler+2,es
        mov     dx,offset ResidentCode:VwIpxEntryPoint
        mov     ax,252Fh
        int     21h

;
; get and set 7A handler
;

        mov     ax,357Ah
        int     21h
        mov     word ptr Old7AHandler,bx
        mov     word ptr Old7AHandler+2,es
        mov     dx,offset ResidentCode:VwIpx7ADispatcher
        mov     ax,257Ah
        int     21h
        pop     ds                      ; restore segment registers

        assume  ds:nothing

        pop     es

        assume  es:nothing

        ret
InstallInterruptHandlers endp

InitCodeEnd

page

;
; code from here on will be left in memory after initialisation
;

ResidentCodeStart

        assume cs:ResidentCode
        assume ds:nothing
        assume es:nothing
        assume ss:nothing

Old2FHandler    dd      ?
Old7AHandler    dd      ?
OldIrqHandler   dd      ?

IrqValue        dw      ?

VddHandle       dw      ?

; ***   VwIpxEntryPoint
; *
; *     The INT 2Fh handler that recognizes the Netware IPX request code (7A).
; *     Also chains INT 2F/AX=1122
; *
; *     ENTRY   AX = 7A00h
; *
; *     EXIT    AL = 0FFh
; *             ES:DI = address of routine to call when submitting IPX/SPX
; *                     requests
; *
; *     USES
; *
; *     ASSUMES nothing
; *
; ***

VwIpxEntryPoint proc
        cmp     ax,7a00h
        jne     @f
        mov     di,cs
        mov     es,di
        mov     di,offset VwIpxDispatcher
        dec     al
        iret

;
; not 7A00h. Check for 1122h (IFSResetEnvironment). If yes, then this is DOS
; calling the IFS chain to notify that the app is terminating. When we have
; notified the DLL, chain the IFS request
;

@@:     cmp     ax,7affh
        jne     try1122
        mov     di,cs
        mov     es,di
        mov     di,offset VwIpxDispatcher
        or      bx,bx
        jz      @f
        mov     cx,8000h
        mov     si,7
        iret
@@:     mov     cx,14h
        mov     si,200h
        iret

try1122:cmp     ax,1122h
        jne     @f

;
; DOS Calls INT 2F/AX=1122 for every terminating app, including this one. We
; can't differentiate between a TSR and a non-TSR. Let the DLL handle it
;

        push    ax
        push    bx
        push    cx
        mov     ah,51h
        int     21h
        mov     cx,bx                   ; cx = PDB of terminating program/TSR
        mov     bx,-1                   ; bx = dispatch code
        mov     ax,VddHandle            ; ax = VDD handle
        DispatchCall
        pop     cx
        pop     bx
        pop     ax
@@:     jmp     Old2FHandler            ; chain int 2F
VwIpxEntryPoint endp

; ***   VwIpxDispatcher
; *
; *     All DOS IPX/SPX calls are routed here by the netware libraries. Just
; *     BOP on through to the other side
; *
; *     This routine just transfers control to 32-bit world, where all work is
; *     done
; *
; *     ENTRY   BX = netware IPX/SPX dispatch code
; *             others - depends on function
; *
; *     EXIT    depends on function
; *
; *     USES    depends on function
; *
; *     ASSUMES nothing
; *
; ***

VwIpxDispatcher proc far
        pushf                           ; apparently we don't modify flags
        call    DispatchWithFeeling
        popf
        ret
VwIpxDispatcher endp

; ***   VwIpx7ADispatcher
; *
; *     Older Netware apps make the call to IPX/SPX via INT 7A. Same function
; *     as VwIpxDispatcher
; *
; *     This routine just transfers control to 32-bit world, where all work is
; *     done
; *
; *     ENTRY   BX = netware IPX/SPX dispatch code
; *             others - depends on function
; *
; *     EXIT    depends on function
; *
; *     USES    depends on function
; *
; *     ASSUMES nothing
; *
; ***

VwIpx7ADispatcher proc
        call    DispatchWithFeeling
        iret
VwIpx7ADispatcher endp

; ***   DispatchWithFeeling
; *
; *     Performs the dispatch for VrIpxDispatcher and VrIpx7ADispatcher. Checks
; *     requested function for return code in AX: either returns value in AX
; *     or restores AX to value on input
; *
; *     This routine just transfers control to 32-bit world, where all work is
; *     done
; *
; *     ENTRY   BX = netware IPX/SPX dispatch code
; *             others - depends on function
; *
; *     EXIT    depends on function
; *
; *     USES    depends on function
; *
; *     ASSUMES 1. Dispatch codes are in range 0..255 (ie 0 in BH)
; *
; ***

DispatchWithFeeling proc
        push    bp
        push    ax                      ; caller value

;
; some APIs (IPXOpenSocket, IPXScheduleIPXEvent, SPXEstablishConnection, and
; others...) pass a parameter in AX. Since AX is being used for the VDD
; handle, we have to commandeer another register to hold our AX value. BP is
; always a good candidate
;

        mov     bp,ax                   ; grumble, mutter, gnash, gnash
        push    cx                      ; required if IPXOpenSocket
        push    bx                      ; dispatch code
        or      bx,bx                   ; IPXOpenSocket?
        jz      @f                      ; yus ma'am
        cmp     bl,3                    ; IPXSendPacket?
        jz      @f                      ; yus ma'am again
        jmp     short carry_on_dispatching      ; ooo-err missus

;
; IPXOpenSocket et IPXSendPacket: We need an extra piece of info - the PDB of
; the process making this request. This is so we can clean-up at program
; termination
;

@@:     push    bx
        mov     ah,51h                  ; get DOS PDB
        int     21h                     ; this call can be made any time
        mov     cx,bx
        pop     bx

carry_on_dispatching:
        mov     ax,VddHandle
        DispatchCall
        mov     bp,sp

;
; BX and [BP] will be the same value except for SPXInitialize which is the only
; function that returns something in BX
;

        xchg    bx,[bp]                 ; bx = dispatch code, [bp] = returned bx

;
; if this call returns something in AX (or AL) don't pop the AX value we pushed.
; If not a call which returns something in AX then restore the caller's AX. You
; can rest assured some assembler programmer has made use of the fact that some
; calls modify AX and the others leave it alone (presumably...?)
;

        or      bl,bl                   ; 0x00 = IPXOpenSocket
        jz      @f
        cmp     bl,2                    ; 0x02 = IPXGetLocalTarget
        jz      @f
        cmp     bl,4                    ; 0x04 = IPXListenForPacket
        jz      @f
        cmp     bl,6                    ; 0x06 = IPXCancelEvent
        jz      @f
        cmp     bl,8                    ; 0x08 = IPXGetIntervalMarker
        jz      @f
        cmp     bl,10h                  ; 0x10 = SPXInitialize
        jz      spx_init
        cmp     bl,11h                  ; 0x11 = SPXEstablishConnection
        jz      @f
        cmp     bl,15h                  ; 0x15 = SPXGetConnectionStatus
        jz      @f
        cmp     bl,1ah                  ; 0x1A = IPXGetMaxPacketSize
        jz      @f
        pop     cx                      ; original dispatch code
        pop     cx                      ; original cx
        pop     ax                      ; original ax
        pop     bp                      ; original bp
        ret

;
; here if this call returns something in AX/AL
;

@@:     pop     cx                      ; original dispatch code
        pop     cx                      ; original cx
        pop     bp                      ; don't restore AX
        pop     bp
        ret

;
; here if the call was SPXInitialize which returns values in AX, BX, CX, DX
;

spx_init:
        pop     bx                      ; bx = major/minor SPX version #
        pop     bp                      ; caller cx - NOT restored
        pop     bp                      ; caller ax - NOT restored
        pop     bp                      ; caller bp - restored
        ret
DispatchWithFeeling endp

; ***   VwIpxEsrFunction
; *
; *     This routine makes the call to the ESR as defined in the ECB. We must
; *     set up our stack, save the registers (except SS & SP), then call the
; *     ESR.
; *
; *     Control will not be transferred here for an ECB which has a NULL ESR
; *     field
; *
; *     ENTRY   AL = 0 for AES or 0FFh for IPX
; *             ES:SI = ECB address
; *
; *     EXIT    depends on function
; *
; *     USES    depends on function
; *
; *     ASSUMES nothing
; *
; ***

VwIpxEsrFunction proc

;
; Novell documentation states all registers except SS and SP are saved before
; calling ESR and that INTERRUPTS ARE DISABLED
;

        pusha
        push    ds
        push    es
        mov     ax,VddHandle
        mov     bx,-2
        DispatchCall                    ; get ECB
        jc      @f
        call    dword ptr es:[si][4]    ; branch to the ESR
        mov     al,20h
        out     0a0h,al                 ; clear slave pic
        out     20h,al                  ;   "   master "
        pop     es
        pop     ds
        popa
        iret
@@:     pop     es
        pop     ds
        popa
        jmp     OldIrqHandler
VwIpxEsrFunction endp

ResidentCodeEnd

end start
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\vwipxspx\tsr\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\dspch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\activeds.c ===
#include "dspch.h"
#pragma hdrstop

static
HRESULT
WINAPI
ADsGetObject(
    LPCWSTR lpszPathName,
    REFIID riid,
    VOID * * ppObject
    )
{
    if (ppObject)
    {
        *ppObject = NULL;
    }

    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
ADsGetLastError(
    OUT     LPDWORD lpError,
    OUT     LPWSTR  lpErrorBuf,
    IN      DWORD   dwErrorBufLen,
    OUT     LPWSTR  lpNameBuf,
    IN      DWORD   dwNameBufLen
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(activeds)
{
    DLOENTRY(3,ADsGetObject)
    DLOENTRY(13,ADsGetLastError)
};

DEFINE_ORDINAL_MAP(activeds)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\esent.c ===
#include "dspch.h"
#pragma hdrstop

#include <esent98.h>

static
JET_ERR JET_API JetAddColumn(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        const char              *szColumnName,
        const JET_COLUMNDEF     *pcolumndef,
        const void              *pvDefault,
        unsigned long   cbDefault,
        JET_COLUMNID    *pcolumnid )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetAttachDatabase(
        JET_SESID               sesid,
        const char              *szFilename,
        JET_GRBIT               grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetBeginSession(
        JET_INSTANCE    instance,
        JET_SESID               *psesid,
        const char              *szUserName,
        const char              *szPassword )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetBeginTransaction(
        JET_SESID sesid )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetCloseDatabase(
        JET_SESID               sesid,
        JET_DBID                dbid,
        JET_GRBIT               grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetCloseTable(
        JET_SESID sesid, JET_TABLEID tableid )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetCommitTransaction(
        JET_SESID sesid, JET_GRBIT grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetCreateDatabase(
        JET_SESID               sesid,
        const char              *szFilename,
        const char              *szConnect,
        JET_DBID                *pdbid,
        JET_GRBIT               grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetCreateTableColumnIndex(
        JET_SESID               sesid,
        JET_DBID                dbid,
        JET_TABLECREATE *ptablecreate )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetDelete(
        JET_SESID sesid, JET_TABLEID tableid )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetDeleteTable(
        JET_SESID               sesid,
        JET_DBID                dbid,
        const char              *szTableName )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetDetachDatabase(
        JET_SESID               sesid,
        const char              *szFilename )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetEndSession(
        JET_SESID sesid, JET_GRBIT grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetGetDatabaseInfo(
        JET_SESID               sesid,
        JET_DBID                dbid,
        void                    *pvResult,
        unsigned long   cbMax,
        unsigned long   InfoLevel )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetGetTableColumnInfo(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        const char              *szColumnName,
        void                    *pvResult,
        unsigned long   cbMax,
        unsigned long   InfoLevel )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetIndexRecordCount(
        JET_SESID sesid,
        JET_TABLEID tableid,
        unsigned long *pcrec,
        unsigned long crecMax )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetInit(
        JET_INSTANCE *pinstance)
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetMakeKey(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        const void              *pvData,
        unsigned long   cbData,
        JET_GRBIT               grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetMove(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        long                    cRow,
        JET_GRBIT               grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetOpenDatabase(
        JET_SESID               sesid,
        const char              *szFilename,
        const char              *szConnect,
        JET_DBID                *pdbid,
        JET_GRBIT               grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetOpenTable(
        JET_SESID               sesid,
        JET_DBID                dbid,
        const char              *szTableName,
        const void              *pvParameters,
        unsigned long   cbParameters,
        JET_GRBIT               grbit,
        JET_TABLEID             *ptableid )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetPrepareUpdate(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        unsigned long   prep )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetResetSessionContext(
        JET_SESID               sesid )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetRetrieveColumn(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        JET_COLUMNID    columnid,
        void                    *pvData,
        unsigned long   cbData,
        unsigned long   *pcbActual,
        JET_GRBIT               grbit,
        JET_RETINFO             *pretinfo )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetRollback(
        JET_SESID sesid, JET_GRBIT grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetSeek(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        JET_GRBIT               grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetSetColumn(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        JET_COLUMNID    columnid,
        const void              *pvData,
        unsigned long   cbData,
        JET_GRBIT               grbit,
        JET_SETINFO             *psetinfo )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetSetCurrentIndex(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        const char              *szIndexName )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetSetIndexRange(
        JET_SESID sesid,
        JET_TABLEID tableidSrc,
        JET_GRBIT grbit)
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetSetSessionContext(
        JET_SESID               sesid,
        ULONG_PTR               ulContext )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetSetSystemParameter(
        JET_INSTANCE    *pinstance,
        JET_SESID               sesid,
        unsigned long   paramid,
        ULONG_PTR               lParam,
        const char              *sz )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetTerm(
        JET_INSTANCE instance )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetTerm2(
        JET_INSTANCE instance,
        JET_GRBIT grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetUpdate(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        void                    *pvBookmark,
        unsigned long   cbBookmark,
        unsigned long   *pcbActual)
{
    return JET_errInternalError;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(esent)
{
    DLPENTRY(JetAddColumn)
    DLPENTRY(JetAttachDatabase)
    DLPENTRY(JetBeginSession)
    DLPENTRY(JetBeginTransaction)
    DLPENTRY(JetCloseDatabase)
    DLPENTRY(JetCloseTable)
    DLPENTRY(JetCommitTransaction)
    DLPENTRY(JetCreateDatabase)
    DLPENTRY(JetCreateTableColumnIndex)
    DLPENTRY(JetDelete)
    DLPENTRY(JetDeleteTable)
    DLPENTRY(JetDetachDatabase)
    DLPENTRY(JetEndSession)
    DLPENTRY(JetGetDatabaseInfo)
    DLPENTRY(JetGetTableColumnInfo)
    DLPENTRY(JetIndexRecordCount)
    DLPENTRY(JetInit)
    DLPENTRY(JetMakeKey)
    DLPENTRY(JetMove)
    DLPENTRY(JetOpenDatabase)
    DLPENTRY(JetOpenTable)
    DLPENTRY(JetPrepareUpdate)
    DLPENTRY(JetResetSessionContext)
    DLPENTRY(JetRetrieveColumn)
    DLPENTRY(JetRollback)
    DLPENTRY(JetSeek)
    DLPENTRY(JetSetColumn)
    DLPENTRY(JetSetCurrentIndex)
    DLPENTRY(JetSetIndexRange)
    DLPENTRY(JetSetSessionContext)
    DLPENTRY(JetSetSystemParameter)
    DLPENTRY(JetTerm)
    DLPENTRY(JetTerm2)
    DLPENTRY(JetUpdate)
};

DEFINE_PROCNAME_MAP(esent)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\certcli.c ===
#include "dspch.h"
#pragma hdrstop

#define _CERTCLI_
#include <certca.h>

#include <winldap.h>


static
HRESULT
WINAPI
CAAccessCheck(
    IN HCAINFO      hCAInfo,
    IN HANDLE       ClientToken
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CACertTypeAccessCheck(
    IN HCERTTYPE    hCertType,
    IN HANDLE       ClientToken
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CACloseCA(
          IN HCAINFO hCA
          )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CACloseCertType(
                IN HCERTTYPE hCertType
                )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
DWORD
WINAPI
CACountCAs(
           IN  HCAINFO  hCAInfo
           )
{
    return 0;
}

static
DWORD
WINAPI
CACountCertTypes(
    IN  HCERTTYPE  hCertType
    )
{
    return 0;
}

static
HRESULT
WINAPI
CAEnumCertTypesForCA(
    IN  HCAINFO     hCAInfo,
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAEnumCertTypesForCAEx(
    IN  HCAINFO     hCAInfo,
    IN  LPCWSTR     wszScope,
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


static
HRESULT
WINAPI
CAEnumFirstCA(
    IN  LPCWSTR          wszScope,
    IN  DWORD            fFlags,
    OUT HCAINFO *        phCAInfo
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAEnumNextCA(
    IN  HCAINFO          hPrevCA,
    OUT HCAINFO *        phCAInfo
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAEnumNextCertType(
    IN  HCERTTYPE          hPrevCertType,
    OUT HCERTTYPE *        phCertType
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
CAFindByIssuerDN(
    IN  CERT_NAME_BLOB const *  pIssuerDN,
    IN  LPCWSTR                 wszScope,
    IN  DWORD                   fFlags,
    OUT HCAINFO *               phCAInfo
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAFindByName(
    IN  LPCWSTR     wszCAName,
    IN  LPCWSTR     wszScope,
    IN  DWORD       dwFlags,
    OUT HCAINFO *   phCAInfo
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAFindCertTypeByName(
        IN  LPCWSTR     wszCertType,
        IN  HCAINFO     hCAInfo,
        IN  DWORD       dwFlags,
        OUT HCERTTYPE * phCertType
        )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAFreeCAProperty(
    IN  HCAINFO     hCAInfo,
    LPWSTR *        awszPropertyValue
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAFreeCertTypeExtensions(
    IN  HCERTTYPE           hCertType,
    IN  PCERT_EXTENSIONS    pCertExtensions
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAFreeCertTypeProperty(
    IN  HCERTTYPE   hCertType,
    IN  LPWSTR *    awszPropertyValue
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAGetCACertificate(
    IN  HCAINFO     hCAInfo,
    OUT PCCERT_CONTEXT *ppCert
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAGetCAProperty(
    IN  HCAINFO     hCAInfo,
    IN  LPCWSTR     wszPropertyName,
    OUT LPWSTR **   pawszPropertyValue
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


static
HRESULT
WINAPI
CAGetCertTypeExpiration(
    IN  HCERTTYPE           hCertType,
    OUT OPTIONAL FILETIME * pftExpiration,
    OUT OPTIONAL FILETIME * pftOverlap
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAGetCertTypeExtensions(
    IN  HCERTTYPE           hCertType,
    OUT PCERT_EXTENSIONS *  ppCertExtensions
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAGetCertTypeExtensionsEx(
    IN  HCERTTYPE           hCertType,
    IN  DWORD               dwFlags,
    IN  LPVOID              pParam,
    OUT PCERT_EXTENSIONS *  ppCertExtensions
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


static
HRESULT
WINAPI
CAGetCertTypeFlags(
    IN  HCERTTYPE           hCertType,
    OUT DWORD *             pdwFlags
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAGetCertTypeFlagsEx(
    IN  HCERTTYPE           hCertType,
    IN  DWORD               dwOption,
    OUT DWORD *             pdwFlags
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAGetCertTypeKeySpec(
    IN  HCERTTYPE           hCertType,
    OUT DWORD *             pdwKeySpec
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAGetCertTypeProperty(
    IN  HCERTTYPE   hCertType,
    IN  LPCWSTR     wszPropertyName,
    OUT LPWSTR **   pawszPropertyValue
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAGetCertTypePropertyEx(
    IN  HCERTTYPE   hCertType,
    IN  LPCWSTR     wszPropertyName,
    OUT LPVOID      pPropertyValue)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
myRobustLdapBind(
    OUT LDAP ** ppldap,
    IN BOOL fGC
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CertServerSubmitRequest(
    IN DWORD Flags,
    IN BYTE const *pbRequest,
    IN DWORD cbRequest,
    OPTIONAL IN WCHAR const *pwszRequestAttributes,
    IN WCHAR const *pwszServerName,
    IN WCHAR const *pwszAuthority,
    OUT CERTSERVERENROLL **ppcsEnroll) // free via CertServerFreeMemory
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
VOID
WINAPI
CertServerFreeMemory(
    IN VOID *pv)
{
    NOTHING;
}



//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(certcli)
{
	DLPENTRY(CAAccessCheck)
	DLPENTRY(CACertTypeAccessCheck)
	DLPENTRY(CACloseCA)
	DLPENTRY(CACloseCertType)
	DLPENTRY(CACountCAs)
	DLPENTRY(CACountCertTypes)
	DLPENTRY(CAEnumCertTypesForCA)
	DLPENTRY(CAEnumCertTypesForCAEx)
	DLPENTRY(CAEnumFirstCA)
	DLPENTRY(CAEnumNextCA)
	DLPENTRY(CAEnumNextCertType)
	DLPENTRY(CAFindByIssuerDN)
	DLPENTRY(CAFindByName)
	DLPENTRY(CAFindCertTypeByName)
	DLPENTRY(CAFreeCAProperty)
	DLPENTRY(CAFreeCertTypeExtensions)
	DLPENTRY(CAFreeCertTypeProperty)
	DLPENTRY(CAGetCACertificate)
	DLPENTRY(CAGetCAProperty)
	DLPENTRY(CAGetCertTypeExpiration)
	DLPENTRY(CAGetCertTypeExtensions)
	DLPENTRY(CAGetCertTypeExtensionsEx)
	DLPENTRY(CAGetCertTypeFlags)
	DLPENTRY(CAGetCertTypeFlagsEx)
	DLPENTRY(CAGetCertTypeKeySpec)
	DLPENTRY(CAGetCertTypeProperty)
	DLPENTRY(CAGetCertTypePropertyEx)
};


DEFINE_PROCNAME_MAP(certcli)

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(certcli)
{
    DLOENTRY(214,myRobustLdapBind)
    DLOENTRY(219,CertServerSubmitRequest)
    DLOENTRY(221,CertServerFreeMemory)
};

DEFINE_ORDINAL_MAP(certcli)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\dnsapi.c ===
#include "dspch.h"
#pragma hdrstop


#define DNS_STATUS       LONG
#define PIP4_ARRAY       PVOID
#define PDNS_RECORD      PVOID
#define PDNS_DEBUG_INFO  PVOID
#define DNS_CHARSET      DWORD
#define DNS_FREE_TYPE    DWORD
#define DNS_NAME_FORMAT  DWORD
#define DNS_CONFIG_TYPE  DWORD


//
//  SDK public
//

static 
BOOL
WINAPI
DnsFlushResolverCache(
    VOID
    )
{
    return FALSE;
}

static
VOID
WINAPI
DnsFree(
    IN OUT  PVOID           pData,
    IN      DNS_FREE_TYPE   FreeType
    )
{
    return;
}

static
BOOL
WINAPI
DnsNameCompare_A(
    IN      LPSTR       pName1,
    IN      LPSTR       pName2
    )
{
    return FALSE;
}

static
BOOL
WINAPI
DnsNameCompare_UTF8(
    IN      LPSTR       pName1,
    IN      LPSTR       pName2
    )
{
    return FALSE;
}

static
BOOL
WINAPI
DnsNameCompare_W(
    IN      LPWSTR          pName1,
    IN      LPWSTR          pName2
    )
{
    return FALSE;
}

static
DNS_STATUS
WINAPI
DnsQuery_A(
    IN      LPSTR           pszName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PIP4_ARRAY      aipServers            OPTIONAL,
    IN OUT  PDNS_RECORD *   ppQueryResults        OPTIONAL,
    IN OUT  PVOID *         pReserved             OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DNS_STATUS
WINAPI
DnsQuery_UTF8(
    IN      LPSTR           pszName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PIP4_ARRAY      aipServers            OPTIONAL,
    IN OUT  PDNS_RECORD *   ppQueryResults        OPTIONAL,
    IN OUT  PVOID *         pReserved             OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DNS_STATUS
WINAPI
DnsQuery_W(
    IN      LPWSTR          pszName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PIP4_ARRAY      aipServers            OPTIONAL,
    IN OUT  PDNS_RECORD *   ppQueryResults        OPTIONAL,
    IN OUT  PVOID *         pReserved             OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

BOOL
WINAPI
DnsRecordCompare(
    IN      PDNS_RECORD     pRecord1,
    IN      PDNS_RECORD     pRecord2
    )
{
    return  FALSE;
}

BOOL
WINAPI
DnsRecordSetCompare(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2,
    OUT     PDNS_RECORD *   ppDiff1,
    OUT     PDNS_RECORD *   ppDiff2
    )
{
    return  FALSE;
}

PDNS_RECORD
WINAPI
DnsRecordCopyEx(
    IN      PDNS_RECORD     pRecord,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
{
    return  NULL;
}

PDNS_RECORD
WINAPI
DnsRecordSetCopyEx(
    IN      PDNS_RECORD     pRecordSet,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
{
    return  NULL;
}


static
VOID
WINAPI
DnsRecordListFree(
    IN OUT  PDNS_RECORD     pRecordList,
    IN      DNS_FREE_TYPE   FreeType
    )
{
    return;
}

PDNS_RECORD
DnsRecordSetDetach(
    IN OUT  PDNS_RECORD     pRecordList
    )
{
    return  NULL;
}


static
DNS_STATUS
DnsValidateName_A(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DNS_STATUS
DnsValidateName_UTF8(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DNS_STATUS
DnsValidateName_W(
    IN      LPCWSTR         pwszName,
    IN      DNS_NAME_FORMAT Format
    )
{
    return ERROR_PROC_NOT_FOUND;
}


DNS_STATUS
WINAPI
DnsQueryConfig(
    IN      DNS_CONFIG_TYPE     Config,
    IN      DWORD               Flag,
    IN      PWSTR               pwsAdapterName,
    IN      PVOID               pReserved,
    OUT     PVOID               pBuffer,
    IN OUT  PDWORD              pBufferLength
    )
{
    return ERROR_PROC_NOT_FOUND;
}

//
//  Private config
//

PVOID
WINAPI
DnsQueryConfigAllocEx(
    IN      DNS_CONFIG_TYPE     Config,
    IN      PWSTR               pwsAdapterName,
    IN      BOOL                fLocalAlloc
    )
{
    return NULL;
}

VOID
WINAPI
DnsFreeConfigStructure(
    IN OUT  PVOID           pData,
    IN      DNS_CONFIG_TYPE ConfigId
    )
{
    return;
}

DWORD
WINAPI
DnsQueryConfigDword(
    IN      DNS_CONFIG_TYPE     Config,
    IN      PWSTR               pwsAdapterName
    )
{
    return 0;
}

DNS_STATUS
WINAPI
DnsSetConfigDword(
    IN      DNS_CONFIG_TYPE     Config,
    IN      PWSTR               pwsAdapterName,
    IN      DWORD               NewValue
    )
{
    return ERROR_PROC_NOT_FOUND;
}

//
//  Private stuff
//

PVOID
DnsApiAlloc(
    IN      INT             iSize
    )
{
    return  NULL;
}

PVOID
DnsApiRealloc(
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    )
{
    return  NULL;
}

VOID
DnsApiFree(
    IN OUT  PVOID           pMem
    )
{
    return;
}

PDNS_DEBUG_INFO
DnsApiSetDebugGlobals(
    IN OUT  PDNS_DEBUG_INFO pInfo
    )
{
    return  NULL;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are
// CASE SENSITIVE (eg lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(dnsapi)
{
    DLPENTRY(DnsApiAlloc)
    DLPENTRY(DnsApiFree)
    DLPENTRY(DnsApiRealloc)
    DLPENTRY(DnsApiSetDebugGlobals)
    DLPENTRY(DnsFlushResolverCache)
    DLPENTRY(DnsFree)
    DLPENTRY(DnsFreeConfigStructure)
    DLPENTRY(DnsNameCompare_A)
    DLPENTRY(DnsNameCompare_UTF8)
    DLPENTRY(DnsNameCompare_W)
    DLPENTRY(DnsQueryConfig)
    DLPENTRY(DnsQueryConfigAllocEx)
    DLPENTRY(DnsQueryConfigDword)
    DLPENTRY(DnsQuery_A)
    DLPENTRY(DnsQuery_UTF8)
    DLPENTRY(DnsQuery_W)
    DLPENTRY(DnsRecordCompare)
    DLPENTRY(DnsRecordCopyEx)
    DLPENTRY(DnsRecordListFree)
    DLPENTRY(DnsRecordSetCompare)
    DLPENTRY(DnsRecordSetCopyEx)
    DLPENTRY(DnsRecordSetDetach)
    DLPENTRY(DnsSetConfigDword)
    DLPENTRY(DnsValidateName_A)
    DLPENTRY(DnsValidateName_UTF8)
    DLPENTRY(DnsValidateName_W)
};

DEFINE_PROCNAME_MAP(dnsapi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\credui.c ===
#include "dspch.h"
#pragma hdrstop

#define _CREDUI_
#include <wincrui.h>

static
CREDUIAPI
void
WINAPI
CredUIFlushAllCredentials(
    void
    )
{
}

static
CREDUIAPI
DWORD
WINAPI
CredUIParseUserNameW(
    PCWSTR pszUserName,
    PWSTR pszUser,
    ULONG ulUserMaxChars,
    PWSTR pszDomain,
    ULONG ulDomainMaxChars
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
CREDUIAPI
BOOL
WINAPI
CredUIInitControls()
{
    return FALSE;
}

static
CREDUIAPI
DWORD
WINAPI
CredUICmdLinePromptForCredentialsW(
    PCWSTR pszTargetName,
    PCtxtHandle pContext,
    DWORD dwAuthError,
    PWSTR UserName,
    ULONG ulUserMaxChars,
    PWSTR pszPassword,
    ULONG ulPasswordMaxChars,
    PBOOL pfSave,
    DWORD dwFlags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
CREDUIAPI
DWORD
WINAPI
CredUIPromptForCredentialsW(
    PCREDUI_INFOW pUiInfo,
    PCWSTR pszTargetName,
    PCtxtHandle pContext,
    DWORD dwAuthError,
    PWSTR pszUserName,
    ULONG ulUserNameMaxChars,
    PWSTR pszPassword,
    ULONG ulPasswordMaxChars,
    BOOL *save,
    DWORD dwFlags
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(credui)
{
    DLPENTRY(CredUICmdLinePromptForCredentialsW)
    DLPENTRY(CredUIFlushAllCredentials)
    DLPENTRY(CredUIInitControls)
    DLPENTRY(CredUIParseUserNameW)
    DLPENTRY(CredUIPromptForCredentialsW)
};

DEFINE_PROCNAME_MAP(credui)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\authz.c ===
#include "dspch.h"
#pragma hdrstop

#define AUTHZAPI
#define AUTHZ_CLIENT_CONTEXT_HANDLE          PVOID
#define PAUTHZ_CLIENT_CONTEXT_HANDLE         PVOID *
#define AUTHZ_RESOURCE_MANAGER_HANDLE        PVOID
#define PAUTHZ_RESOURCE_MANAGER_HANDLE       PVOID *
#define AUTHZ_CONTEXT_INFORMATION_CLASS      DWORD
#define PFN_AUTHZ_ACCESS_CHECK               PVOID
#define PFN_AUTHZ_COMPUTE_DYNAMIC_GROUPS     PVOID
#define PFN_AUTHZ_FREE_DYNAMIC_GROUPS        PVOID
#define PFN_AUTHZ_DYNAMIC_ACCESS_CHECK       PVOID
#define PAUTHZ_ACCESS_REQUEST                PVOID
#define AUTHZ_AUDIT_EVENT_HANDLE             PVOID
#define PAUTHZ_ACCESS_REPLY                  PVOID
#define PAUTHZ_ACCESS_CHECK_RESULTS_HANDLE   PVOID

static
AUTHZAPI
BOOL
WINAPI
AuthzAccessCheck(
    IN     DWORD                              Flags,
    IN     AUTHZ_CLIENT_CONTEXT_HANDLE        hAuthzClientContext,
    IN     PAUTHZ_ACCESS_REQUEST              pRequest,
    IN     AUTHZ_AUDIT_EVENT_HANDLE           hAuditEvent                      OPTIONAL,
    IN     PSECURITY_DESCRIPTOR               pSecurityDescriptor,
    IN     PSECURITY_DESCRIPTOR               *OptionalSecurityDescriptorArray OPTIONAL,
    IN     DWORD                              OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY                pReply,
    OUT    PAUTHZ_ACCESS_CHECK_RESULTS_HANDLE phAccessCheckResults             OPTIONAL
    )
{
    return FALSE;
}

static
AUTHZAPI
BOOL
WINAPI
AuthzFreeContext(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext
    )
{
    return FALSE;
}

static
AUTHZAPI
BOOL
WINAPI
AuthzFreeResourceManager(
    IN AUTHZ_RESOURCE_MANAGER_HANDLE hAuthzResourceManager
    )
{
    return FALSE;
}

static
AUTHZAPI
BOOL
WINAPI
AuthzGetInformationFromContext(
    IN  AUTHZ_CLIENT_CONTEXT_HANDLE     hAuthzClientContext,
    IN  AUTHZ_CONTEXT_INFORMATION_CLASS InfoClass,
    IN  DWORD                           BufferSize,
    OUT PDWORD                          pSizeRequired,
    OUT PVOID                           Buffer
    )
{
    return FALSE;
}

static
AUTHZAPI
BOOL
WINAPI
AuthzInitializeContextFromSid(
    IN  DWORD                         Flags,
    IN  PSID                          UserSid,
    IN  AUTHZ_RESOURCE_MANAGER_HANDLE hAuthzResourceManager,
    IN  PLARGE_INTEGER                pExpirationTime        OPTIONAL,
    IN  LUID                          Identifier,
    IN  PVOID                         DynamicGroupArgs       OPTIONAL,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE  phAuthzClientContext
    )
{
    return FALSE;
}

static
AUTHZAPI
BOOL
WINAPI
AuthzInitializeResourceManager(
    IN  DWORD                            Flags,
    IN  PFN_AUTHZ_DYNAMIC_ACCESS_CHECK   pfnDynamicAccessCheck   OPTIONAL,
    IN  PFN_AUTHZ_COMPUTE_DYNAMIC_GROUPS pfnComputeDynamicGroups OPTIONAL,
    IN  PFN_AUTHZ_FREE_DYNAMIC_GROUPS    pfnFreeDynamicGroups    OPTIONAL,
    IN  PCWSTR                           szResourceManagerName,
    OUT PAUTHZ_RESOURCE_MANAGER_HANDLE   phAuthzResourceManager
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(authz)
{
    DLPENTRY(AuthzAccessCheck)
    DLPENTRY(AuthzFreeContext)
    DLPENTRY(AuthzFreeResourceManager)
    DLPENTRY(AuthzGetInformationFromContext)
    DLPENTRY(AuthzInitializeContextFromSid)
    DLPENTRY(AuthzInitializeResourceManager)
};

DEFINE_PROCNAME_MAP(authz)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\cryptui.c ===
#include "dspch.h"
#pragma hdrstop

#include <wincrypt.h>
#include <cryptui.h>
#include <lenroll.h>


static
BOOL
WINAPI
CryptUIDlgViewCRLW(
        IN PCCRYPTUI_VIEWCRL_STRUCTW pcvcrl
        )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
CryptUIDlgViewCTLW(
        IN PCCRYPTUI_VIEWCTL_STRUCTW pcvctl
        )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
CryptUIDlgViewCertificateW(
        IN  PCCRYPTUI_VIEWCERTIFICATE_STRUCTW   pCertViewInfo,
        OUT BOOL                                *pfPropertiesChanged  // OPTIONAL
        )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


HRESULT WINAPI LocalEnroll(  DWORD                 dwFlags,         //IN Required
              LPCWSTR               pRequestString,  // Reserved:  must be NULL. 
                      void                  *pReserved,      //IN Optional
                      BOOL                  fKeyService,     //IN Required: Whether the function is called remotely
                      DWORD                 dwPurpose,       //IN Required: Whether it is enrollment or renew
                      BOOL                  fConfirmation,   //IN Required: Set the TRUE if confirmation dialogue is needed
                      HWND                  hwndParent,      //IN Optional: The parent window
                      LPWSTR                pwszConfirmationTitle,   //IN Optional: The title for confirmation dialogue
                      UINT                  idsConfirmTitle, //IN Optional: The resource ID for the title of the confirmation dialogue
                      LPWSTR                pwszCALocation,  //IN Required: The ca machine name
                      LPWSTR                pwszCAName,      //IN Required: The ca name
                      CERT_BLOB             *pCertBlob,      //IN Required: The renewed certifcate
                      CERT_REQUEST_PVK_NEW  *pRenewKey,      //IN Required: The private key on the certificate
                      BOOL                  fNewKey,         //IN Required: Set the TRUE if new private key is needed
                      CERT_REQUEST_PVK_NEW  *pKeyNew,        //IN Required: The private key information
                      LPWSTR                pwszHashAlg,     //IN Optional: The hash algorithm
                      LPWSTR                pwszDesStore,    //IN Optional: The destination store
                      DWORD                 dwStoreFlags,    //IN Optional: The store flags
                      CERT_ENROLL_INFO      *pRequestInfo,   //IN Required: The information about the cert request
                      CERT_BLOB             *pPKCS7Blob,     //OUT Optional: The PKCS7 from the CA
                      CERT_BLOB             *pHashBlob,      //OUT Optioanl: The SHA1 hash of the enrolled/renewed certificate
                      DWORD                 *pdwStatus,      //OUT Optional: The status of the enrollment/renewal
              PCERT_CONTEXT         *ppCertContext   //OUT Optional: The enrolled certificate
                   )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND); 
}
    

HRESULT WINAPI LocalEnrollNoDS(  DWORD                 dwFlags,         //IN Required
              LPCWSTR               pRequestString,  // Reserved:  must be NULL. 
                      void                  *pReserved,      //IN Optional
                      BOOL                  fKeyService,     //IN Required: Whether the function is called remotely
                      DWORD                 dwPurpose,       //IN Required: Whether it is enrollment or renew
                      BOOL                  fConfirmation,   //IN Required: Set the TRUE if confirmation dialogue is needed
                      HWND                  hwndParent,      //IN Optional: The parent window
                      LPWSTR                pwszConfirmationTitle,   //IN Optional: The title for confirmation dialogue
                      UINT                  idsConfirmTitle, //IN Optional: The resource ID for the title of the confirmation dialogue
                      LPWSTR                pwszCALocation,  //IN Required: The ca machine name
                      LPWSTR                pwszCAName,      //IN Required: The ca name
                      CERT_BLOB             *pCertBlob,      //IN Required: The renewed certifcate
                      CERT_REQUEST_PVK_NEW  *pRenewKey,      //IN Required: The private key on the certificate
                      BOOL                  fNewKey,         //IN Required: Set the TRUE if new private key is needed
                      CERT_REQUEST_PVK_NEW  *pKeyNew,        //IN Required: The private key information
                      LPWSTR                pwszHashAlg,     //IN Optional: The hash algorithm
                      LPWSTR                pwszDesStore,    //IN Optional: The destination store
                      DWORD                 dwStoreFlags,    //IN Optional: The store flags
                      CERT_ENROLL_INFO      *pRequestInfo,   //IN Required: The information about the cert request
                      CERT_BLOB             *pPKCS7Blob,     //OUT Optional: The PKCS7 from the CA
                      CERT_BLOB             *pHashBlob,      //OUT Optioanl: The SHA1 hash of the enrolled/renewed certificate
                      DWORD                 *pdwStatus,      //OUT Optional: The status of the enrollment/renewal
              HANDLE                *pResult         //IN OUT Optional: The enrolled certificate
                   )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND); 
}



//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(cryptui)
{
    DLPENTRY(CryptUIDlgViewCRLW)
    DLPENTRY(CryptUIDlgViewCTLW)
    DLPENTRY(CryptUIDlgViewCertificateW)
    DLPENTRY(LocalEnroll)
    DLPENTRY(LocalEnrollNoDS)
};

DEFINE_PROCNAME_MAP(cryptui)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\crypt32.c ===
#include "dspch.h"
#pragma hdrstop

#define _CRYPT32_
#include <wincrypt.h>

static
WINCRYPT32API
BOOL
WINAPI
CertAddCertificateContextToStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCERT_CONTEXT *ppStoreContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CertCloseStore(
    IN HCERTSTORE hCertStore,
    DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
WINCRYPT32API
BOOL
WINAPI
CertCompareCertificateName(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pCertName1,
    IN PCERT_NAME_BLOB pCertName2
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CertControlStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwFlags,
    IN DWORD dwCtrlType,
    IN void const *pvCtrlPara
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CertCreateCertificateContext(
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}


static
WINCRYPT32API
PCCTL_CONTEXT
WINAPI
CertCreateCTLContext(
    DWORD dwMsgAndCertEncodingType,
    const BYTE *pbCtlEncoded,
    DWORD cbCtlEncoded
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
WINCRYPT32API
BOOL
WINAPI
CertDeleteCertificateFromStore(
    IN PCCERT_CONTEXT pCertContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CertDuplicateCertificateContext(
    IN PCCERT_CONTEXT pCertContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
PCCTL_CONTEXT
WINAPI
CertDuplicateCTLContext(
    IN PCCTL_CONTEXT pCtlContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CertEnumCertificatesInStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pPrevCertContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
WINCRYPT32API
BOOL
WINAPI
CertFreeCertificateContext (
    IN PCCERT_CONTEXT pCertContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CertFindCertificateInStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCERT_CONTEXT pPrevCertContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}


static
WINCRYPT32API
PCCTL_CONTEXT
WINAPI
CertFindCTLInStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCTL_CONTEXT pPrevCtlContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
WINCRYPT32API
PCERT_EXTENSION
WINAPI
CertFindExtension(
    IN LPCSTR pszObjId,
    IN DWORD cExtensions,
    IN CERT_EXTENSION rgExtensions[]
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
WINCRYPT32API
PCTL_ENTRY 
WINAPI 
CertFindSubjectInCTL(
    DWORD dwEncodingType, 
    DWORD dwSubjectType, 
    void *pvSubject, 
    PCCTL_CONTEXT pCtlContext, 
    DWORD dwFlags 
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
WINCRYPT32API
VOID
WINAPI
CertFreeCertificateChain (
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    NOTHING;
}

static
WINCRYPT32API
BOOL
WINAPI
CertFreeCTLContext(
    IN PCCTL_CONTEXT pCtlContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CertGetCertificateChain (
    IN OPTIONAL HCERTCHAINENGINE hChainEngine,
    IN PCCERT_CONTEXT pCertContext,
    IN OPTIONAL LPFILETIME pTime,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN PCERT_CHAIN_PARA pChainPara,
    IN DWORD dwFlags,
    IN LPVOID pvReserved,
    OUT PCCERT_CHAIN_CONTEXT* ppChainContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CertGetCertificateContextProperty(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI 
CertGetEnhancedKeyUsage (
    IN     PCCERT_CONTEXT     pCertContext,
    IN     DWORD              dwFlags,
    OUT    PCERT_ENHKEY_USAGE pUsage,
    IN OUT DWORD*             pcbUsage
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CertGetIssuerCertificateFromStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pSubjectContext,
    IN OPTIONAL PCCERT_CONTEXT pPrevIssuerContext,
    IN OUT DWORD *pdwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}


static
WINCRYPT32API
DWORD
WINAPI
CertGetPublicKeyLength(
    DWORD dwCertEncodingType,
    PCERT_PUBLIC_KEY_INFO pPublicKey
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return 0;
}


static
WINCRYPT32API
DWORD
WINAPI
CertNameToStrW(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pName,
    IN DWORD dwStrType,
    OUT OPTIONAL LPWSTR psz,
    IN DWORD csz
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
HCERTSTORE
WINAPI
CertOpenStore(
    IN LPCSTR lpszStoreProvider,
    IN DWORD dwEncodingType,
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwFlags,
    IN const void *pvPara
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
WINCRYPT32API
HCERTSTORE
WINAPI 
CertOpenSystemStoreW(
    HCRYPTPROV  hProv,
    const WCHAR * wcsSubsystemProtocol
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}


static
WINCRYPT32API
BOOL
WINAPI
CertRegisterPhysicalStore(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
DWORD
WINAPI
CertRDNValueToStrW(
    IN DWORD dwValueType,
    IN PCERT_RDN_VALUE_BLOB pValue,
    OUT OPTIONAL LPWSTR psz,
    IN DWORD csz
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return 0;
}

static
WINCRYPT32API
BOOL
WINAPI
CertSetCertificateContextProperty(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CertStrToNameW(
    IN DWORD dwCertEncodingType,
    IN LPCWSTR pszX500,
    IN DWORD dwStrType,
    IN OPTIONAL void *pvReserved,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded,
    OUT OPTIONAL LPCWSTR *ppszError
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CertVerifyCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CertVerifySubjectCertificateContext(
    IN PCCERT_CONTEXT pSubject,
    IN OPTIONAL PCCERT_CONTEXT pIssuer,
    IN OUT DWORD *pdwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptDecodeObject(
    IN DWORD        dwCertEncodingType,
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    IN DWORD        dwFlags,
    OUT void        *pvStructInfo,
    IN OUT DWORD    *pcbStructInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptDecodeObjectEx(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT DWORD *pcbStructInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
WINCRYPT32API
BOOL
WINAPI
CryptDecryptMessage(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN const BYTE *pbEncryptedBlob,
    IN DWORD cbEncryptedBlob,
    OUT OPTIONAL BYTE *pbDecrypted,
    IN OUT OPTIONAL DWORD *pcbDecrypted,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptEncodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptEncodeObjectEx(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
    OUT void *pvEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptEncryptMessage(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    IN const BYTE *pbToBeEncrypted,
    IN DWORD cbToBeEncrypted,
    OUT BYTE *pbEncryptedBlob,
    IN OUT DWORD *pcbEncryptedBlob
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptExportPublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    OUT PCERT_PUBLIC_KEY_INFO pInfo,
    IN OUT DWORD *pcbInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptFormatObject(
    IN DWORD dwCertEncodingType,
    IN DWORD dwFormatType,
    IN DWORD dwFormatStrType,
    IN void  *pFormatStruct,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT void *pbFormat,
    IN OUT DWORD *pcbFormat
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
DWORD
WINAPI
CertGetNameStringW(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwType,
    IN DWORD dwFlags,
    IN void *pvTypePara,
    OUT OPTIONAL LPWSTR pszNameString,
    IN DWORD cchNameString
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return 0;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptHashPublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    IN ALG_ID Algid,
    IN DWORD dwFlags,
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pInfo,
    OUT BYTE *pbComputedHash,
    IN OUT DWORD *pcbComputedHash
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptImportPublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pInfo,
    OUT HCRYPTKEY *phKey
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptImportPublicKeyInfoEx(
    HCRYPTPROV hCryptProv,
    DWORD dwCertEncodingType,
    PCERT_PUBLIC_KEY_INFO pInfo,
    ALG_ID aiKeyAlg,
    DWORD dwFlags,
    void *pvAuxInfo,
    HCRYPTKEY *phKey
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptMsgGetAndVerifySigner(
    HCRYPTMSG hCryptMsg, 
    DWORD cSignerStore,
    HCERTSTORE *rghSignerStore,
    DWORD dwFlags,    
    PCCERT_CONTEXT *ppSigner,
    DWORD *pdwSignerIndex
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptProtectData(
        DATA_BLOB*      pDataIn,
        LPCWSTR         szDataDescr,
        DATA_BLOB*      pOptionalEntropy,
        PVOID           pvReserved,
        CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct,
        DWORD           dwFlags,
        DATA_BLOB*      pDataOut)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptSignAndEncodeCertificate(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    IN PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    IN OPTIONAL const void *pvHashAuxInfo,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptSignMessage(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    IN BOOL fDetachedSignature,
    IN DWORD cToBeSigned,
    IN const BYTE *rgpbToBeSigned[],
    IN DWORD rgcbToBeSigned[],
    OUT BYTE *pbSignedBlob,
    IN OUT DWORD *pcbSignedBlob
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptUnprotectData(
        DATA_BLOB*      pDataIn,             // in encr blob
        LPWSTR*         ppszDataDescr,       // out
        DATA_BLOB*      pOptionalEntropy,
        PVOID           pvReserved,
        CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct,
        DWORD           dwFlags,
        DATA_BLOB*      pDataOut)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
WINCRYPT32API
BOOL
WINAPI
CryptVerifyCertificateSignature(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwCertEncodingType,
    IN const BYTE * pbEncoded,
    IN DWORD        cbEncoded,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
WINCRYPT32API
BOOL
WINAPI
CryptVerifyMessageSignature(
  PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
  DWORD dwSignerIndex,
  const BYTE *pbSignedBlob,
  DWORD cbSignedBlob,
  BYTE *pbDecoded,
  DWORD *pcbDecoded,
  PCCERT_CONTEXT *ppSignerCert
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(crypt32)
{
    DLPENTRY(CertAddCertificateContextToStore)
    DLPENTRY(CertCloseStore)
    DLPENTRY(CertCompareCertificateName)
    DLPENTRY(CertControlStore)
    DLPENTRY(CertCreateCTLContext)
    DLPENTRY(CertCreateCertificateContext)
    DLPENTRY(CertDeleteCertificateFromStore)
    DLPENTRY(CertDuplicateCTLContext)
    DLPENTRY(CertDuplicateCertificateContext)
    DLPENTRY(CertEnumCertificatesInStore)
    DLPENTRY(CertFindCTLInStore)
    DLPENTRY(CertFindCertificateInStore)
    DLPENTRY(CertFindExtension)
    DLPENTRY(CertFindSubjectInCTL)
    DLPENTRY(CertFreeCTLContext)
    DLPENTRY(CertFreeCertificateChain)
    DLPENTRY(CertFreeCertificateContext)
    DLPENTRY(CertGetCertificateChain)
    DLPENTRY(CertGetCertificateContextProperty)
    DLPENTRY(CertGetEnhancedKeyUsage)
    DLPENTRY(CertGetIssuerCertificateFromStore)
    DLPENTRY(CertGetNameStringW)
    DLPENTRY(CertGetPublicKeyLength)
    DLPENTRY(CertNameToStrW)
    DLPENTRY(CertOpenStore)
    DLPENTRY(CertOpenSystemStoreW)
    DLPENTRY(CertRDNValueToStrW)
    DLPENTRY(CertRegisterPhysicalStore)
    DLPENTRY(CertSetCertificateContextProperty)
    DLPENTRY(CertStrToNameW)
    DLPENTRY(CertVerifyCertificateChainPolicy)
    DLPENTRY(CertVerifySubjectCertificateContext)
    DLPENTRY(CryptDecodeObject)
    DLPENTRY(CryptDecodeObjectEx)
    DLPENTRY(CryptDecryptMessage)
    DLPENTRY(CryptEncodeObject)
    DLPENTRY(CryptEncodeObjectEx)
    DLPENTRY(CryptEncryptMessage)
    DLPENTRY(CryptExportPublicKeyInfo)
    DLPENTRY(CryptFormatObject)
    DLPENTRY(CryptHashPublicKeyInfo)
    DLPENTRY(CryptImportPublicKeyInfo)
    DLPENTRY(CryptImportPublicKeyInfoEx)
    DLPENTRY(CryptMsgGetAndVerifySigner)
    DLPENTRY(CryptProtectData)
    DLPENTRY(CryptSignAndEncodeCertificate)
    DLPENTRY(CryptSignMessage)
    DLPENTRY(CryptUnprotectData)
    DLPENTRY(CryptVerifyCertificateSignature)
    DLPENTRY(CryptVerifyMessageSignature)
};

DEFINE_PROCNAME_MAP(crypt32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\kdcsvc.c ===
#include "dspch.h"
#pragma hdrstop

#include <ntsam.h>

static
NTSTATUS
KdcAccountChangeNotification (
    IN PSID DomainSid,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN OPTIONAL PUNICODE_STRING ObjectName,
    IN PLARGE_INTEGER ModifiedCount,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(kdcsvc)
{
    DLPENTRY(KdcAccountChangeNotification)
};

DEFINE_PROCNAME_MAP(kdcsvc)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\keymgr.c ===
#include "dspch.h"
#pragma hdrstop

#define _KEYMGR_
#include <keymgr.h>

static LONG APIENTRY CPlApplet(HWND hwndCPl,UINT uMsg,LPARAM lParam1,LPARAM lParam2)
{
    return 0;
}
static void WINAPI KRShowKeyMgr(HWND hwParent,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    return;
}
static void WINAPI PRShowRestoreWizardW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    return;
}
static void WINAPI PRShowRestoreWizardExW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    return;
}
static void WINAPI PRShowRestoreFromMsginaW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    return;
}
static void WINAPI PRShowSaveWizardW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    return;
}
static void WINAPI PRShowSaveWizardExW(HWND hwParent,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    return;
}
static void WINAPI PRShowSaveFromMsginaW(HWND hwParent,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    return;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(keymgr)
{
    DLPENTRY(CPlApplet)
    DLPENTRY(KRShowKeyMgr)
    DLPENTRY(PRShowRestoreFromMsginaW)
    DLPENTRY(PRShowRestoreWizardExW)
    DLPENTRY(PRShowRestoreWizardW)
    DLPENTRY(PRShowSaveFromMsginaW)
    DLPENTRY(PRShowSaveWizardExW)
    DLPENTRY(PRShowSaveWizardW)
};

DEFINE_PROCNAME_MAP(keymgr)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\mscat32.c ===
#include "dspch.h"
#pragma hdrstop

#include <wincrypt.h>
#include <mscat.h>


static
BOOL
WINAPI
CryptCATAdminAcquireContext (
    OUT HCATADMIN *phCatAdmin,
    IN const GUID *pgSubsystem,
    IN DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
HCATINFO
WINAPI
CryptCATAdminAddCatalog (
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN OPTIONAL WCHAR *pwszSelectBaseName,
    IN DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
BOOL
WINAPI
CryptCATAdminCalcHashFromFileHandle (
    IN HANDLE hFile,
    IN OUT DWORD *pcbHash,
    OUT OPTIONAL BYTE *pbHash,
    IN DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
HCATINFO
WINAPI
CryptCATAdminEnumCatalogFromHash (
    IN HCATADMIN hCatAdmin,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN DWORD dwFlags,
    IN OUT HCATINFO *phPrevCatInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
BOOL
WINAPI
CryptCATAdminReleaseCatalogContext (
    IN HCATADMIN hCatAdmin,
    IN HCATINFO hCatInfo,
    IN DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
CryptCATAdminReleaseContext (
    IN HCATADMIN hCatAdmin,
    IN DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
CryptCATCatalogInfoFromContext (
    IN HCATINFO hCatInfo,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(mscat32)
{
    DLPENTRY(CryptCATAdminAcquireContext)
    DLPENTRY(CryptCATAdminAddCatalog)
    DLPENTRY(CryptCATAdminCalcHashFromFileHandle)
    DLPENTRY(CryptCATAdminEnumCatalogFromHash)
    DLPENTRY(CryptCATAdminReleaseCatalogContext)
    DLPENTRY(CryptCATAdminReleaseContext)
    DLPENTRY(CryptCATCatalogInfoFromContext)
};

DEFINE_PROCNAME_MAP(mscat32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\netapi32.c ===
#include "dspch.h"
#pragma hdrstop

#define _DSGETDCAPI_
#include <dsgetdc.h>
#include <lm.h>
#include <icanon.h>
#include <dsrole.h>
#include <nb30.h>
#include <winsock2.h>

static
DWORD
WINAPI
DsEnumerateDomainTrustsW(
    LPWSTR ServerName,
    ULONG Flags,
    PDS_DOMAIN_TRUSTSW *Domains,
    PULONG DomainCount
    )
{
    *Domains = NULL;
    *DomainCount = 0;
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
DsGetDcNameW(
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
DsGetDcNameWithAccountW(
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR AccountName OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
VOID
WINAPI
DsRoleFreeMemory(
    IN PVOID    Buffer
    )
{
    return;
}

static
DWORD
WINAPI
DsRoleGetPrimaryDomainInformation(
    IN LPCWSTR lpServer OPTIONAL,
    IN DSROLE_PRIMARY_DOMAIN_INFO_LEVEL InfoLevel,
    OUT PBYTE *Buffer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
DsAddressToSiteNamesW(
    IN LPCWSTR ComputerName,
    IN DWORD EntryCount,
    IN PSOCKET_ADDRESS SocketAddresses,
    OUT LPWSTR **SiteNames
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
DsGetDcSiteCoverageW(
    IN LPCWSTR ServerName,
    OUT PULONG EntryCount,
    OUT LPWSTR **SiteNames
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
I_NetNameCanonicalize(
    IN  LPTSTR  ServerName OPTIONAL,
    IN  LPTSTR  Name,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
I_NetNameValidate(
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  Name,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetAlertRaiseEx(
    IN LPCWSTR AlertEventName,
    IN LPVOID  VariableInfo,
    IN DWORD   VariableInfoSize,
    IN LPCWSTR ServiceName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetApiBufferAllocate (
    IN  DWORD ByteCount,
    OUT LPVOID *Buffer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetApiBufferFree (
    IN LPVOID Buffer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetDfsGetInfo(
    IN  LPWSTR  DfsEntryPath,
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  ShareName OPTIONAL,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTSTATUS
NET_API_FUNCTION
NetEnumerateTrustedDomains (
    IN LPWSTR ServerName OPTIONAL,
    OUT LPWSTR *DomainNames
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetGetJoinInformation(
    IN   LPCWSTR                lpServer OPTIONAL,
    OUT  LPWSTR                *lpNameBuffer,
    OUT  PNETSETUP_JOIN_STATUS  BufferType
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetJoinDomain(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpDomain,
    IN  LPCWSTR lpAccountOU, OPTIONAL
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  DWORD   fJoinOptions
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetLocalGroupGetMembers(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR LocalGroupName,
    IN DWORD Level,
    OUT LPBYTE *Buffer,
    IN DWORD PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT PDWORD_PTR ResumeHandle
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
NET_API_STATUS NET_API_FUNCTION
NetMessageBufferSend (
    IN  LPCWSTR servername OPTIONAL,
    IN  LPCWSTR msgname,
    IN  LPCWSTR fromname,
    IN  LPBYTE  buf,
    IN  DWORD   buflen
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetQueryDisplayInformation(
    IN  LPCWSTR ServerName OPTIONAL,
    IN  DWORD   Level,
    IN  DWORD   Index,
    IN  DWORD   EntriesRequested,
    IN  DWORD   PreferredMaximumLength,
    OUT LPDWORD ReturnedEntryCount,
    OUT PVOID   *SortedBuffer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetRenameMachineInDomain(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpNewMachineName OPTIONAL,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  DWORD   fRenameOptions
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetServerSetInfo (
    IN  LPWSTR  servername OPTIONAL,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD ParmError OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetSessionEnum (
    IN      LPTSTR      servername,
    IN      LPTSTR      clientname,
    IN      LPTSTR      username,
    IN      DWORD       level,
    OUT     LPBYTE      *bufptr,
    IN      DWORD       prefmaxlen,
    OUT     LPDWORD     entriesread,
    OUT     LPDWORD     totalentries,
    IN OUT  LPDWORD     resume_handle
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetShareGetInfo(
    IN  LMSTR   servername,
    IN  LMSTR   netname,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetShareSetInfo (
    IN  LMSTR   servername,
    IN  LMSTR   netname,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetUnjoinDomain(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  DWORD   fUnjoinOptions
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetUserAdd(
    IN  LPCWSTR ServerName OPTIONAL,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetUserChangePassword(
    IN LPCWSTR DomainName,
    IN LPCWSTR UserName,
    IN LPCWSTR OldPassword,
    IN LPCWSTR NewPassword
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetUserDel(
    IN  LPCWSTR ServerName OPTIONAL,
    IN  LPCWSTR UserName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetUserGetGroups(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR UserName,
    IN DWORD Level,
    OUT LPBYTE *Buffer,
    IN DWORD PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetUserGetInfo (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     username,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetUserGetLocalGroups(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR UserName,
    IN DWORD Level,
    IN DWORD Flags,
    OUT LPBYTE *Buffer,
    IN DWORD PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetUserModalsGet(
    IN  LPCWSTR ServerName OPTIONAL,
    IN  DWORD   Level,
    OUT LPBYTE  *Buffer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetUserSetInfo(
    IN  LPCWSTR ServerName OPTIONAL,
    IN  LPCWSTR UserName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetValidateName(
    IN  LPCWSTR             lpServer OPTIONAL,
    IN  LPCWSTR             lpName,
    IN  LPCWSTR             lpAccount OPTIONAL,
    IN  LPCWSTR             lpPassword OPTIONAL,
    IN  NETSETUP_NAME_TYPE  NameType
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetWkstaGetInfo(
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetWkstaUserGetInfo (
    IN  LPWSTR reserved,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
UCHAR
APIENTRY
Netbios(
    PNCB pncb
    )
{
    return NRC_SYSTEM;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetpIsRemote(
    IN  LPTSTR  ComputerName OPTIONAL,
    OUT LPDWORD LocalOrRemote,
    OUT LPTSTR  CanonicalizedName OPTIONAL,
    IN  DWORD   Flags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetpUpgradePreNT5JoinInfo( VOID )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetServerGetInfo(
    IN  LMSTR   servername OPTIONAL,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    )
{
    return ERROR_PROC_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(netapi32)
{
    DLPENTRY(DsAddressToSiteNamesW)
    DLPENTRY(DsEnumerateDomainTrustsW)
    DLPENTRY(DsGetDcNameW)
    DLPENTRY(DsGetDcNameWithAccountW)
    DLPENTRY(DsGetDcSiteCoverageW)
    DLPENTRY(DsRoleFreeMemory)
    DLPENTRY(DsRoleGetPrimaryDomainInformation)
    DLPENTRY(I_NetNameCanonicalize)
    DLPENTRY(I_NetNameValidate)
    DLPENTRY(NetAlertRaiseEx)
    DLPENTRY(NetApiBufferAllocate)
    DLPENTRY(NetApiBufferFree)
    DLPENTRY(NetDfsGetInfo)
    DLPENTRY(NetEnumerateTrustedDomains)
    DLPENTRY(NetGetJoinInformation)
    DLPENTRY(NetJoinDomain)
    DLPENTRY(NetLocalGroupGetMembers)
    DLPENTRY(NetMessageBufferSend)
    DLPENTRY(NetQueryDisplayInformation)
    DLPENTRY(NetRenameMachineInDomain)
    DLPENTRY(NetServerGetInfo)
    DLPENTRY(NetServerSetInfo)
    DLPENTRY(NetSessionEnum)
    DLPENTRY(NetShareGetInfo)
    DLPENTRY(NetShareSetInfo)
    DLPENTRY(NetUnjoinDomain)
    DLPENTRY(NetUserAdd)
    DLPENTRY(NetUserChangePassword)
    DLPENTRY(NetUserDel)
    DLPENTRY(NetUserGetGroups)
    DLPENTRY(NetUserGetInfo)
    DLPENTRY(NetUserGetLocalGroups)
    DLPENTRY(NetUserModalsGet)
    DLPENTRY(NetUserSetInfo)
    DLPENTRY(NetValidateName)
    DLPENTRY(NetWkstaGetInfo)
    DLPENTRY(NetWkstaUserGetInfo)
    DLPENTRY(Netbios)
    DLPENTRY(NetpIsRemote)
    DLPENTRY(NetpUpgradePreNT5JoinInfo)
};

DEFINE_PROCNAME_MAP(netapi32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\netrap.c ===
#include "dspch.h"
#pragma hdrstop


#define LPDESC                 LPVOID
#define NET_API_STATUS         DWORD
#define RAP_TRANSMISSION_MODE  DWORD
#define RAP_CONVERSION_MODE    DWORD


static
DWORD
RapArrayLength(
    IN LPDESC Descriptor,
    IN OUT LPDESC * UpdatedDescriptorPtr,
    IN RAP_TRANSMISSION_MODE TransmissionMode
    )
{
    return 0;
}

static
DWORD
RapAsciiToDecimal(
   IN OUT LPDESC *Number
   )
{
    return 0;
}

static
DWORD
RapAuxDataCount(
    IN LPBYTE Buffer,
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    )
{
    return 0Xffffffff;
}

static
DWORD
RapAuxDataCountOffset(
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    )
{
    return 0xffffffff;
}

static
NET_API_STATUS
RapConvertSingleEntry(
    IN LPBYTE InStructure,
    IN LPDESC InStructureDesc,
    IN BOOL MeaninglessInputPointers,
    IN LPBYTE OutBufferStart OPTIONAL,
    OUT LPBYTE OutStructure OPTIONAL,
    IN LPDESC OutStructureDesc,
    IN BOOL SetOffsets,
    IN OUT LPBYTE *StringLocation OPTIONAL,
    IN OUT LPDWORD BytesRequired,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN RAP_CONVERSION_MODE ConversionMode
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
RapConvertSingleEntryEx(
    IN LPBYTE InStructure,
    IN LPDESC InStructureDesc,
    IN BOOL MeaninglessInputPointers,
    IN LPBYTE OutBufferStart OPTIONAL,
    OUT LPBYTE OutStructure OPTIONAL,
    IN LPDESC OutStructureDesc,
    IN BOOL SetOffsets,
    IN OUT LPBYTE *StringLocation OPTIONAL,
    IN OUT LPDWORD BytesRequired,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN RAP_CONVERSION_MODE ConversionMode,
    IN UINT_PTR Bias
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
RapGetFieldSize(
    IN LPDESC TypePointer,
    IN OUT LPDESC * TypePointerAddress,
    IN RAP_TRANSMISSION_MODE TransmissionMode
    )
{
    return 0;
}

static
BOOL
RapIsValidDescriptorSmb(
    IN LPDESC Desc
    )
{
    return FALSE;
}

static
LPDESC
RapParmNumDescriptor(
    IN LPDESC Descriptor,
    IN DWORD ParmNum,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    )
{
    return NULL;
}

static
DWORD
RapStructureAlignment(
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    )
{
    return 0;
}

static
DWORD
RapStructureSize(
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    )
{
    return 0;
}

static
DWORD
RapTotalSize(
    IN LPBYTE InStructure,
    IN LPDESC InStructureDesc,
    IN LPDESC OutStructureDesc,
    IN BOOL MeaninglessInputPointers,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN RAP_CONVERSION_MODE ConversionMode
    )
{
    return 0;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(netrap)
{
    DLPENTRY(RapArrayLength)
    DLPENTRY(RapAsciiToDecimal)
    DLPENTRY(RapAuxDataCount)
    DLPENTRY(RapAuxDataCountOffset)
    DLPENTRY(RapConvertSingleEntry)
    DLPENTRY(RapConvertSingleEntryEx)
    DLPENTRY(RapGetFieldSize)
    DLPENTRY(RapIsValidDescriptorSmb)
    DLPENTRY(RapParmNumDescriptor)
    DLPENTRY(RapStructureAlignment)
    DLPENTRY(RapStructureSize)
    DLPENTRY(RapTotalSize)
};

DEFINE_PROCNAME_MAP(netrap)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\mssign32.c ===
#include "dspch.h"
#pragma hdrstop

#include <wincrypt.h>
#include <signer.h>
#include <mssip.h>
#include <signhlp.h>

static
void WINAPI FreeCryptProvFromCert(BOOL          fAcquired,
                           HCRYPTPROV   hProv,
                           LPWSTR       pwszCapiProvider,
                           DWORD        dwProviderType,
                           LPWSTR       pwszTmpContainer)
{
    NOTHING;
}

static
BOOL WINAPI GetCryptProvFromCert(
    HWND            hwnd,
    PCCERT_CONTEXT  pCert,
    HCRYPTPROV      *phCryptProv,
    DWORD           *pdwKeySpec,
    BOOL            *pfDidCryptAcquire,
    LPWSTR          *ppwszTmpContainer,
    LPWSTR          *ppwszProviderName,
    DWORD           *pdwProviderType
    )
{
    return FALSE;
}


static
void WINAPI PvkFreeCryptProv(IN HCRYPTPROV hProv,
                      IN LPCWSTR pwszCapiProvider,
                      IN DWORD dwProviderType,
                      IN LPWSTR pwszTmpContainer)
{
    NOTHING;
}


static
HRESULT WINAPI PvkGetCryptProv( IN HWND hwnd,
                            IN LPCWSTR pwszCaption,
                            IN LPCWSTR pwszCapiProvider,
                            IN DWORD   dwProviderType,
                            IN LPCWSTR pwszPvkFile,
                            IN LPCWSTR pwszKeyContainerName,
                            IN DWORD   *pdwKeySpec,
                            OUT LPWSTR *ppwszTmpContainer,
                            OUT HCRYPTPROV *phCryptProv)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


static
HRESULT WINAPI
SignerFreeSignerContext(
    IN  SIGNER_CONTEXT          *pSignerContext
)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT WINAPI 
SignerSignEx(
    IN  DWORD                   dwFlags,
    IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,
    IN	SIGNER_CERT				*pSignerCert,
    IN	SIGNER_SIGNATURE_INFO	*pSignatureInfo,
    IN	SIGNER_PROVIDER_INFO	*pProviderInfo,
    IN  LPCWSTR					pwszHttpTimeStamp,
    IN  PCRYPT_ATTRIBUTES		psRequest,
    IN	LPVOID					pSipData,
    OUT SIGNER_CONTEXT          **ppSignerContext
)									
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT WINAPI 
SignerTimeStampEx(
    IN  DWORD                   dwFlags,
    IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,
    IN  LPCWSTR					pwszHttpTimeStamp,
    IN  PCRYPT_ATTRIBUTES		psRequest,
    IN	LPVOID					pSipData,
    OUT SIGNER_CONTEXT          **ppSignerContext
)					
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
SpcGetCertFromKey(IN DWORD dwCertEncodingType,
                  IN HCERTSTORE hStore,
                  IN HCRYPTPROV hProv,
                  IN DWORD hKeySpec,
                  OUT PCCERT_CONTEXT* pReturnCert)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(mssign32)
{
    DLPENTRY(FreeCryptProvFromCert)
    DLPENTRY(GetCryptProvFromCert)
    DLPENTRY(PvkFreeCryptProv)
    DLPENTRY(PvkGetCryptProv)
    DLPENTRY(SignerFreeSignerContext)
    DLPENTRY(SignerSignEx)
    DLPENTRY(SignerTimeStampEx)
    DLPENTRY(SpcGetCertFromKey)
};

DEFINE_PROCNAME_MAP(mssign32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\msgina.c ===
#include "dspch.h"
#pragma hdrstop

#include <unknwn.h>
#include <winwlx.h>
#undef _MSGinaExports_
#define _MSGINA_
#include <MSGinaExports.h>
#include <shlobj.h>
#include <shlobjp.h>    // for SHTDN_NONE


static MSGINAAPI LONG ShellGetUserList (BOOL fRemoveGuest, DWORD *pdwUserCount, void* *pUserList)
{
    return 0;
}

static MSGINAAPI BOOL ShellIsSingleUserNoPassword (WCHAR *pwszUsername, WCHAR *pwszDomain)
{
    return FALSE;
}

static MSGINAAPI BOOL ShellIsFriendlyUIActive (void)
{
    return FALSE;
}

static MSGINAAPI BOOL ShellIsMultipleUsersEnabled (void)
{
    return FALSE;
}

static MSGINAAPI BOOL ShellIsRemoteConnectionsEnabled (void)
{
    return FALSE;
}

static MSGINAAPI BOOL ShellEnableFriendlyUI (BOOL fEnable)
{
    SetLastError(ERROR_OUTOFMEMORY);
    return FALSE;
}

static MSGINAAPI BOOL ShellEnableMultipleUsers (BOOL fEnable)
{
    SetLastError(ERROR_OUTOFMEMORY);
    return FALSE;
}

static MSGINAAPI BOOL ShellEnableRemoteConnections (BOOL fEnable)
{
    SetLastError(ERROR_OUTOFMEMORY);
    return FALSE;
}

static MSGINAAPI DWORD ShellTurnOffDialog (HWND hwndParent)
{
    return SHTDN_NONE;
}

static MSGINAAPI int ShellACPIPowerButtonPressed (void *pWlxContext, UINT uiEventType, BOOL fLocked)
{
    return -1;
}

static MSGINAAPI BOOL ShellIsSuspendAllowed (void)
{
    return FALSE;
}

static MSGINAAPI void ShellStatusHostBegin (UINT uiStartType)
{
}

static MSGINAAPI void ShellStatusHostEnd (UINT uiEndType)
{
}

static MSGINAAPI void ShellStatusHostShuttingDown (void)
{
}

static MSGINAAPI BOOL ShellSwitchWhenInteractiveReady (SWITCHTYPE eSwitchType, void *pWlxContext)
{
    return FALSE;
}

static MSGINAAPI HRESULT ShellDimScreen (IUnknown* *ppIUnknown, HWND* phwndDimmed)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static MSGINAAPI void ShellInstallAccountFilterData (void)
{
}

static MSGINAAPI DWORD ShellSwitchUser (BOOL fWait)
{
    return ERROR_PROC_NOT_FOUND;
}

static MSGINAAPI int ShellIsUserInteractiveLogonAllowed (const WCHAR *pwszUsername)
{
    return -1;
}

static MSGINAAPI void ShellNotifyThemeUserChange (USERLOGTYPE eUserLogType, HANDLE hToken)
{
}

static MSGINAAPI DWORD ShellReturnToWelcome (BOOL fUnlock)
{
    return WLX_SAS_ACTION_NONE;
}

static MSGINAAPI void ShellStatusHostPowerEvent (void)
{
}

static MSGINAAPI DWORD ShellStartCredentialServer (const WCHAR *pwszUsername, const WCHAR *pwszDomain, WCHAR *pwszPassword, DWORD dwTimeout)
{
    return ERROR_PROC_NOT_FOUND;
}

static MSGINAAPI void ShellAcquireLogonMutex (void)
{
}

static MSGINAAPI void ShellReleaseLogonMutex (BOOL fSignalEvent)
{
}

static MSGINAAPI void ShellSignalShutdown (void)
{
}

static MSGINAAPI void ShellStatusHostHide (void)
{
}

static MSGINAAPI void ShellStatusHostShow (void)
{
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(msgina)
{
    DLOENTRY(1,ShellGetUserList)
    DLOENTRY(2,ShellIsFriendlyUIActive)
    DLOENTRY(3,ShellACPIPowerButtonPressed)
    DLOENTRY(4,ShellSwitchUser)
    DLOENTRY(5,ShellIsRemoteConnectionsEnabled)
    DLOENTRY(6,ShellEnableFriendlyUI)
    DLOENTRY(7,ShellEnableMultipleUsers)
    DLOENTRY(8,ShellEnableRemoteConnections)
    DLOENTRY(9,ShellTurnOffDialog)
    DLOENTRY(10,ShellNotifyThemeUserChange)
    DLOENTRY(11,ShellStatusHostBegin)
    DLOENTRY(12,ShellStatusHostEnd)
    DLOENTRY(13,ShellIsSuspendAllowed)  
    DLOENTRY(14,ShellIsSingleUserNoPassword)
    DLOENTRY(15,ShellSwitchWhenInteractiveReady)
    DLOENTRY(16,ShellDimScreen)
    DLOENTRY(17,ShellInstallAccountFilterData)
    DLOENTRY(18,ShellStatusHostShuttingDown)
    DLOENTRY(19,ShellIsUserInteractiveLogonAllowed)
    DLOENTRY(20,ShellIsMultipleUsersEnabled)
    DLOENTRY(21,ShellReturnToWelcome)
    DLOENTRY(22,ShellStatusHostPowerEvent)
    DLOENTRY(23,ShellStartCredentialServer)
    DLOENTRY(24,ShellAcquireLogonMutex)
    DLOENTRY(25,ShellReleaseLogonMutex)
    DLOENTRY(26,ShellSignalShutdown)
    DLOENTRY(27,ShellStatusHostHide)
    DLOENTRY(28,ShellStatusHostShow)
};

DEFINE_ORDINAL_MAP(msgina)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\ntmarta.c ===
#include "dspch.h"
#pragma hdrstop

#include <accctrl.h>

static
DWORD
AccRewriteSetNamedRights(
    IN     LPWSTR               pObjectName,
    IN     SE_OBJECT_TYPE       ObjectType,
    IN     SECURITY_INFORMATION SecurityInfo,
    IN OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN     BOOL                 bSkipInheritanceComputation
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(ntmarta)
{
    DLPENTRY(AccRewriteSetNamedRights)
};

DEFINE_PROCNAME_MAP(ntmarta)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\ntdsa.c ===
#include "dspch.h"
#pragma hdrstop

#include <ntdsa.h>
#include <wxlpc.h>
#include <drs.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <mappings.h>

//
// Notes on stub behavior
//

//
// Whenever possible, STATUS_PROCEDURE_NOT_FOUHD, ERROR_PROC_NOT_FOUND, NULL, 
// or FALSE is returned.
//

//
// Some of the functions below require the caller to look at an OUT 
// parameter to determine whether the results of the function (in addition
// or independent of the return value).  Since these are private functions
// there is no need in shipping code to check for the validity of the OUT 
// parameter (typically a pointer).  These values should always be present
// in RTM versions.
//

//
// Some functions don't return a status and were designed to never fail
// (for example, functions that effectively do a table lookup).  For these
// functions there is no reasonable return value.  However, this is not
// a practical issue since these API's would only be called after the DS
// initialized which means that API would have already been "snapped" in via
// GetProcAddress().
//
// Of course, it is possible to rewrite these routines to return errors,
// however, as above, this will have no practical effect.
//

#define NTDSA_STUB_NO_REASONABLE_DEFAULT 0xFFFFFFFF

//
// Most Dir functions return 0 on success and simply a non zero on failure.
// The error space can be from the DB layer or sometimes from the Jet layer.
// To extract the real error, the caller looks at an OUT parameter.  In 
// these cases we return a standard failure value.
//

#define NTDSA_STUB_GENERAL_FAILURE      (!0)


static
unsigned 
AppendRDN(
    DSNAME *pDNBase,
    DSNAME *pDNNew,
    ULONG ulBufSize,
    WCHAR *pRDNVal,
    ULONG RDNlen,
    ATTRTYP AttId
    )
{
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
ULONG 
DirAddEntry (
    ADDARG        * pAddArg,
    ADDRES       ** ppAddRes
    )
{
    *ppAddRes = NULL;
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
NTSTATUS
DirErrorToNtStatus(
    IN  DWORD    DirError,
    IN  COMMRES *CommonResult
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
DWORD
DirErrorToWinError(
    IN  DWORD    DirError,
    IN  COMMRES *CommonResult
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
ULONG 
DirFindEntry(
    FINDARG    *pFindArg,
    FINDRES    ** ppFindRes
)
{
    *ppFindRes = NULL;
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
DWORD
DirGetDomainHandle(
    DSNAME *pDomainDN
    )
{
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
ULONG
DirModifyDN(
    MODIFYDNARG    * pModifyDNArg,
    MODIFYDNRES   ** ppModifyDNRes
    )
{
    *ppModifyDNRes = NULL;
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
ULONG 
DirModifyEntry (
    MODIFYARG  * pModifyArg,
    MODIFYRES ** ppModifyRes
    )
{
    *ppModifyRes = NULL;
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
ULONG
DirNotifyRegister(
    SEARCHARG *pSearchArg,
    NOTIFYARG *pNotifyArg,
    NOTIFYRES **ppNotifyRes
    )
{
    *ppNotifyRes = NULL;
    return NTDSA_STUB_GENERAL_FAILURE;
}


static
ULONG
DirNotifyUnRegister(
    DWORD hServer,
    NOTIFYRES **pNotifyRes
    )
{
    *pNotifyRes = NULL;
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
ULONG
DirOperationControl(
    OPARG   * pOpArg,
    OPRES  ** ppOpRes
    )
{
    *ppOpRes= NULL;
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
ULONG
DirProtectEntry(
    IN DSNAME *pObj
    )
{
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
ULONG
DirRead (
    READARG FAR   * pReadArg,
    READRES      ** ppReadRes
    )
{
    *ppReadRes = NULL;
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
ULONG
DirRemoveEntry (
    REMOVEARG  * pRemoveArg,
    REMOVERES ** ppRemoveRes
    )
{
    *ppRemoveRes = NULL;
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
ULONG
DirSearch (
    SEARCHARG     * pSearchArg,
    SEARCHRES    ** ppSearchRes
    )
{
    *ppSearchRes = NULL;
    return NTDSA_STUB_GENERAL_FAILURE;
}


static
NTSTATUS
DsChangeBootOptions(
    WX_AUTH_TYPE    BootOption,
    ULONG           Flags,
    PVOID           NewKey,
    ULONG           cbNewKey
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
BOOL
DsCheckConstraint(
        IN ATTRTYP  attID,
        IN ATTRVAL *pAttVal,
        IN BOOL     fVerifyAsRDN
        )
{
    return FALSE;
}

static
WX_AUTH_TYPE
DsGetBootOptions(
    VOID
    )
{
    return WxNone;
}

static
NTSTATUS
DsInitialize(
	ULONG Flags,
	IN  PDS_INSTALL_PARAM   InParams  OPTIONAL,
	OUT PDS_INSTALL_RESULT  OutParams OPTIONAL
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
DsUninitialize(
    BOOL fExternalOnly
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
BOOLEAN
DsaWaitUntilServiceIsRunning(
    CHAR *ServiceName
    )
{
    return FALSE;
}


static
ENTINF *
GCVerifyCacheLookup(
    DSNAME *pDSName
    )
{
    return NULL;
}

static
DWORD
GetConfigParam(
    char * parameter,
    void * value,
    DWORD dwSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
GetConfigParamAllocW(
    IN  PWCHAR  parameter,
    OUT PVOID   *value,
    OUT PDWORD  pdwSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
GetConfigParamW(
    WCHAR * parameter,
    void * value,
    DWORD dwSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTSTATUS
GetConfigurationName(
    DWORD       which,
    DWORD       *pcbName,
    DSNAME      *pName
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
unsigned 
GetRDNInfoExternal(
    const DSNAME *pDN,
    WCHAR *pRDNVal,
    ULONG *pRDNlen,
    ATTRTYP *pRDNtype
    )
{
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
DWORD
ImpersonateAnyClient(
    void
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
VOID 
InitCommarg(
    COMMARG *pCommArg
    )
{
    return;
}

static 
int
NameMatched(
    const DSNAME *pDN1, 
    const DSNAME *pDN2
    )
{
    return !0;
}

static
unsigned 
QuoteRDNValue(
    const WCHAR * pVal,
    unsigned ccVal,
    WCHAR * pQuote,
    unsigned ccQuoteBufMax
    )
{
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
BOOLEAN
SampAddLoopbackTask(
    IN PVOID NotifyInfo
    )
{
    return FALSE;
}

static
BOOL
SampAmIGC()
{
    return FALSE;
}


static
NTSTATUS
SampComputeGroupType(
    ULONG  ObjectClass,
    ULONG  GroupType,
    NT4_GROUP_TYPE *pNT4GroupType,
    NT5_GROUP_TYPE *pNT5GroupType,
    BOOLEAN        *pSecurityEnabled
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}


static
ULONG
SampDeriveMostBasicDsClass(
    ULONG   DerivedClass
    )
{
    return DerivedClass;
}

static
ULONG
SampDsAttrFromSamAttr(
    SAMP_OBJECT_TYPE    ObjectType,
    ULONG               SamAttr
    )
{
    return NTDSA_STUB_NO_REASONABLE_DEFAULT;
}


static
ULONG
SampDsClassFromSamObjectType(
    ULONG SamObjectType
    )
{
    return NTDSA_STUB_NO_REASONABLE_DEFAULT;
}


static
BOOL
SampExistsDsLoopback(
    DSNAME  **ppLoopbackName
    )
{
    return FALSE;
}


static
BOOL
SampExistsDsTransaction()
{
    return FALSE;
}

static
NTSTATUS
SampGCLookupNames(
    IN  ULONG           cNames,
    IN  UNICODE_STRING *rNames,
    OUT ENTINF         **rEntInf
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}



static
NTSTATUS
SampGCLookupSids(
    IN  ULONG         cSid,
    IN  PSID         *rpSid,
    OUT PDS_NAME_RESULTW *Results
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SampGetAccountCounts(
        DSNAME * DomainObjectName,
        BOOLEAN  GetApproximateCount, 
        int    * UserCount,
        int    * GroupCount,
        int    * AliasCount
        )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SampGetClassAttribute(
     IN     ULONG    ClassId,
     IN     ULONG    Attribute,
     OUT    PULONG   attLen,
     OUT    PVOID    pattVal
     )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SampGetDisplayEnumerationIndex (
      IN    DSNAME      *DomainName,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    PRPC_UNICODE_STRING Prefix,
      OUT   PULONG      Index,
      OUT   PRESTART    *RestartToReturn
      )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}


static
ULONG
SampGetDsAttrIdByName(
    UNICODE_STRING AttributeIdentifier
    )
{
    return NTDSA_STUB_NO_REASONABLE_DEFAULT;
}

static
VOID
SampGetEnterpriseSidList(
   IN   PULONG pcSids,
   IN OPTIONAL PSID * rgSids
   )
{
    *pcSids = 0;
    if (rgSids) {
        *rgSids = NULL;
    }
    return;
}


static
NTSTATUS
SampGetGroupsForToken(
    IN  DSNAME * pObjName,
    IN  ULONG    Flags,
    OUT ULONG   *pcSids,
    OUT PSID    **prpSids
   )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
VOID
SampGetLoopbackObjectClassId(
    PULONG  ClassId
    )
{
    *ClassId = NTDSA_STUB_NO_REASONABLE_DEFAULT;
    return;
}

static
NTSTATUS
SampGetMemberships(
    IN  PDSNAME     *rgObjNames,
    IN  ULONG       cObjNames,
    IN  OPTIONAL    DSNAME  *pLimitingDomain,
    IN  REVERSE_MEMBERSHIP_OPERATION_TYPE   OperationType,
    OUT ULONG       *pcDsNames,
    OUT PDSNAME     **prpDsNames,
    OUT PULONG      *Attributes OPTIONAL,
    OUT PULONG      pcSidHistory OPTIONAL,
    OUT PSID        **rgSidHistory OPTIONAL
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SampGetQDIRestart(
    IN PDSNAME  DomainName,
    IN DOMAIN_DISPLAY_INFORMATION DisplayInformation, 
    IN ULONG    LastObjectDNT,
    OUT PRESTART *ppRestart
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SampGetServerRoleFromFSMO(
   DOMAIN_SERVER_ROLE *ServerRole
   )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
BOOLEAN
SampIsSecureLdapConnection(
    VOID
    )
{
    return FALSE;
}

static
BOOL
SampIsWriteLockHeldByDs()
{
    return FALSE;
}

static
NTSTATUS
SampMaybeBeginDsTransaction(
    SAMP_DS_TRANSACTION_CONTROL ReadOrWrite
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SampMaybeEndDsTransaction(
    SAMP_DS_TRANSACTION_CONTROL CommitOrAbort
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SampNetlogonPing(
    IN  ULONG           DomainHandle,
    IN  PUNICODE_STRING AccountName,
    OUT PBOOLEAN        AccountExists,
    OUT PULONG          UserAccountControl
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
ULONG
SampSamAttrFromDsAttr(
    SAMP_OBJECT_TYPE    ObjectType,
    ULONG DsAttr
    )
{
    return NTDSA_STUB_NO_REASONABLE_DEFAULT;
}

static
ULONG
SampSamObjectTypeFromDsClass(
    ULONG DsClass
    )
{
    return NTDSA_STUB_NO_REASONABLE_DEFAULT;
}

static
VOID
SampSetDsa(
   BOOLEAN DsaFlag
   )
{
    return;
}


static
NTSTATUS
SampSetIndexRanges(
    ULONG   IndexTypeToUse,
    ULONG   LowLimitLength1,
    PVOID   LowLimit1,
    ULONG   LowLimitLength2,
    PVOID   LowLimit2,
    ULONG   HighLimitLength1,
    PVOID   HighLimit1,
    ULONG   HighLimitLength2,
    PVOID   HighLimit2,
    BOOL    RootOfSearchIsNcHead
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}


static
VOID
SampSetSam(
    IN BOOLEAN fSAM
    )
{
    return;
}


static
VOID
SampSignalStart(
        VOID
        )
{
    return;
}

static
ULONG
SampVerifySids(
    ULONG           cSid,
    PSID            *rpSid,
    DSNAME         ***prpDSName
    )
{
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
void * 
THAlloc(
    DWORD size
    )
{
    return NULL;
}

static
VOID 
THClearErrors()
{
    return;
}

static
ULONG 
THCreate(
    DWORD x
    )
{
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
ULONG 
THDestroy(
    void
    )
{
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
void 
THFree(
    void *buff
    )
{
    return;
}

static
BOOL  
THQuery(
    void
    )
{
    return FALSE;
}

static
VOID 
THRestore(
    PVOID x
    )
{
    return;
}

static
PVOID 
THSave()
{
    return NULL;
}

static
BOOL 
TrimDSNameBy(
    DSNAME *pDNSrc,
    ULONG cava,
    DSNAME *pDNDst
    )
{
    return FALSE;
}

static
VOID
UnImpersonateAnyClient(
    void
    )
{
    return;
}

static
VOID
UpdateDSPerfStats(
    IN DWORD        dwStat,
    IN DWORD        dwOperation,
    IN DWORD        dwChange
    )
{
    return;
}


static
BOOL 
fNullUuid(
    const UUID *pUuid
    )
{
    return FALSE;
}
//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(ntdsa)
{
    DLPENTRY(AppendRDN)
    DLPENTRY(DirAddEntry)
    DLPENTRY(DirErrorToNtStatus)
    DLPENTRY(DirErrorToWinError)
    DLPENTRY(DirFindEntry)
    DLPENTRY(DirGetDomainHandle)
    DLPENTRY(DirModifyDN)
    DLPENTRY(DirModifyEntry)
    DLPENTRY(DirNotifyRegister)
    DLPENTRY(DirNotifyUnRegister)
    DLPENTRY(DirOperationControl)
    DLPENTRY(DirProtectEntry)
    DLPENTRY(DirRead)
    DLPENTRY(DirRemoveEntry)
    DLPENTRY(DirSearch)
    DLPENTRY(DsChangeBootOptions)
    DLPENTRY(DsCheckConstraint)
    DLPENTRY(DsGetBootOptions)
    DLPENTRY(DsInitialize)
    DLPENTRY(DsUninitialize)
    DLPENTRY(DsaWaitUntilServiceIsRunning)
    DLPENTRY(GCVerifyCacheLookup)
    DLPENTRY(GetConfigParam)
    DLPENTRY(GetConfigParamAllocW)
    DLPENTRY(GetConfigParamW)
    DLPENTRY(GetConfigurationName)
    DLPENTRY(GetRDNInfoExternal)
    DLPENTRY(ImpersonateAnyClient)
    DLPENTRY(InitCommarg)
    DLPENTRY(NameMatched)
    DLPENTRY(QuoteRDNValue)
    DLPENTRY(SampAddLoopbackTask)
    DLPENTRY(SampAmIGC)
    DLPENTRY(SampComputeGroupType)
    DLPENTRY(SampDeriveMostBasicDsClass)
    DLPENTRY(SampDsAttrFromSamAttr)
    DLPENTRY(SampDsClassFromSamObjectType)
    DLPENTRY(SampExistsDsLoopback)
    DLPENTRY(SampExistsDsTransaction)
    DLPENTRY(SampGCLookupNames)
    DLPENTRY(SampGCLookupSids)
    DLPENTRY(SampGetAccountCounts)
    DLPENTRY(SampGetClassAttribute)
    DLPENTRY(SampGetDisplayEnumerationIndex)
    DLPENTRY(SampGetDsAttrIdByName)
    DLPENTRY(SampGetEnterpriseSidList)
    DLPENTRY(SampGetGroupsForToken)
    DLPENTRY(SampGetLoopbackObjectClassId)
    DLPENTRY(SampGetMemberships)
    DLPENTRY(SampGetQDIRestart)
    DLPENTRY(SampGetServerRoleFromFSMO)
    DLPENTRY(SampIsSecureLdapConnection)
    DLPENTRY(SampIsWriteLockHeldByDs)
    DLPENTRY(SampMaybeBeginDsTransaction)
    DLPENTRY(SampMaybeEndDsTransaction)
    DLPENTRY(SampNetlogonPing)
    DLPENTRY(SampSamAttrFromDsAttr)
    DLPENTRY(SampSamObjectTypeFromDsClass)
    DLPENTRY(SampSetDsa)
    DLPENTRY(SampSetIndexRanges)
    DLPENTRY(SampSetSam)
    DLPENTRY(SampSignalStart)
    DLPENTRY(SampVerifySids)
    DLPENTRY(THAlloc)
    DLPENTRY(THClearErrors)
    DLPENTRY(THCreate)
    DLPENTRY(THDestroy)
    DLPENTRY(THFree)
    DLPENTRY(THQuery)
    DLPENTRY(THRestore)
    DLPENTRY(THSave)
    DLPENTRY(TrimDSNameBy)
    DLPENTRY(UnImpersonateAnyClient)
    DLPENTRY(UpdateDSPerfStats)
    DLPENTRY(fNullUuid)
};

DEFINE_PROCNAME_MAP(ntdsa)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\ntlsapi.c ===
#include "dspch.h"
#pragma hdrstop

#include <ntlsapi.h>

static
LS_STATUS_CODE 
LS_API_ENTRY 
NtLicenseRequestW(
    LPWSTR      ProductName,
    LPWSTR      Version,
    LS_HANDLE   FAR *LicenseHandle,
    NT_LS_DATA  *NtData
    )
{
    return  STATUS_PROCEDURE_NOT_FOUND;
}

static
LS_STATUS_CODE 
LS_API_ENTRY 
NtLSFreeHandle(
    LS_HANDLE LicenseHandle
    )
{
    return  STATUS_PROCEDURE_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(ntlsapi)
{
    DLPENTRY(NtLSFreeHandle)
    DLPENTRY(NtLicenseRequestW)
};

DEFINE_PROCNAME_MAP(ntlsapi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\ntdsapi.c ===
#include "dspch.h"
#pragma hdrstop
#define _NTDSAPI_
#include <ntdsapi.h>

static
NTDSAPI
DWORD
WINAPI
DsBindW(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    HANDLE          *phDS
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsBindWithCredW(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    HANDLE          *phDS
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsCrackNamesW(
    HANDLE              hDS,                // in
    DS_NAME_FLAGS       flags,              // in
    DS_NAME_FORMAT      formatOffered,      // in
    DS_NAME_FORMAT      formatDesired,      // in
    DWORD               cNames,             // in
    const LPCWSTR       *rpNames,           // in
    PDS_NAME_RESULTW    *ppResult           // out
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
void
WINAPI
DsFreeNameResultW(
    PDS_NAME_RESULTW      pResult            // in
    )
{
    return;
}

static
NTDSAPI
VOID
WINAPI
DsFreePasswordCredentials(
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity
    )
{
    return;
}

static
NTDSAPI
DWORD
WINAPI
DsGetRdnW(
    IN OUT LPCWCH   *ppDN,
    IN OUT DWORD    *pcDN,
    OUT    LPCWCH   *ppKey,
    OUT    DWORD    *pcKey,
    OUT    LPCWCH   *ppVal,
    OUT    DWORD    *pcVal
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsMakePasswordCredentialsW(
    LPCWSTR User,
    LPCWSTR Domain,
    LPCWSTR Password,
    RPC_AUTH_IDENTITY_HANDLE *pAuthIdentity
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsUnBindW(
    HANDLE          *phDS               // in
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsUnquoteRdnValueW(
    IN     DWORD    cQuotedRdnValueLength,
    IN     LPCWCH   psQuotedRdnValue,
    IN OUT DWORD    *pcUnquotedRdnValueLength,
    OUT    LPWCH    psUnquotedRdnValue
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsWriteAccountSpnW(
    IN HANDLE hDS,
    IN DS_SPN_WRITE_OP Operation,
    IN LPCWSTR pszAccount,
    IN DWORD cSpn,
    IN LPCWSTR *rpszSpn
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(ntdsapi)
{
    DLPENTRY(DsBindW)
    DLPENTRY(DsBindWithCredW)
    DLPENTRY(DsCrackNamesW)
    DLPENTRY(DsFreeNameResultW)
    DLPENTRY(DsFreePasswordCredentials)
    DLPENTRY(DsGetRdnW)
    DLPENTRY(DsMakePasswordCredentialsW)
    DLPENTRY(DsUnBindW)
    DLPENTRY(DsUnquoteRdnValueW)
    DLPENTRY(DsWriteAccountSpnW)
};

DEFINE_PROCNAME_MAP(ntdsapi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\pautoenr.c ===
#include "dspch.h"
#pragma hdrstop

#define _PAUTOENR_

static
HANDLE 
WINAPI
CertAutoEnrollment(IN HWND     hwndParent,
                   IN DWORD    dwStatus)
{
    return NULL;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(pautoenr)
{
    DLPENTRY(CertAutoEnrollment)
};

DEFINE_PROCNAME_MAP(pautoenr)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\samlib.c ===
#include "dspch.h"
#pragma hdrstop

#include <ntsam.h>

static
NTSTATUS
SamAddMemberToAlias(
    IN SAM_HANDLE AliasHandle,
    IN PSID MemberId
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamAddMemberToGroup(
    IN SAM_HANDLE GroupHandle,
    IN ULONG MemberId,
    IN ULONG Attributes
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamCloseHandle(
    IN SAM_HANDLE SamHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamConnect(
    IN PUNICODE_STRING ServerName,
    OUT PSAM_HANDLE ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamCreateAliasInDomain(
    IN SAM_HANDLE DomainHandle,
    IN PUNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT PSAM_HANDLE AliasHandle,
    OUT PULONG RelativeId
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamCreateGroupInDomain(
    IN SAM_HANDLE DomainHandle,
    IN PUNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT PSAM_HANDLE GroupHandle,
    OUT PULONG RelativeId
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamCreateUser2InDomain(
    IN SAM_HANDLE DomainHandle,
    IN PUNICODE_STRING AccountName,
    IN ULONG AccountType,
    IN ACCESS_MASK DesiredAccess,
    OUT PSAM_HANDLE UserHandle,
    OUT PULONG GrantedAccess,
    OUT PULONG RelativeId
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamDeleteAlias(
    IN SAM_HANDLE AliasHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamDeleteGroup(
    IN SAM_HANDLE GroupHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamDeleteUser(
    IN SAM_HANDLE UserHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamEnumerateAliasesInDomain(
    IN SAM_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    IN PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamEnumerateDomainsInSamServer(
    IN SAM_HANDLE ServerHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamEnumerateGroupsInDomain(
    IN SAM_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamEnumerateUsersInDomain(
    IN SAM_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    IN ULONG UserAccountControl,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamFreeMemory(
    IN PVOID Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamGetAliasMembership(
    IN SAM_HANDLE DomainHandle,
    IN ULONG PassedCount,
    IN PSID *Sids,
    OUT PULONG MembershipCount,
    OUT PULONG *Aliases
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamGetCompatibilityMode(
    IN  SAM_HANDLE ObjectHandle,
    OUT ULONG*     Mode
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamGetDisplayEnumerationIndex (
      IN    SAM_HANDLE        DomainHandle,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    PUNICODE_STRING   Prefix,
      OUT   PULONG            Index
      )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamGetGroupsForUser(
    IN SAM_HANDLE UserHandle,
    OUT PGROUP_MEMBERSHIP * Groups,
    OUT PULONG MembershipCount
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamGetMembersInAlias(
    IN SAM_HANDLE AliasHandle,
    OUT PSID **MemberIds,
    OUT PULONG MemberCount
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamGetMembersInGroup(
    IN SAM_HANDLE GroupHandle,
    OUT PULONG * MemberIds,
    OUT PULONG * Attributes,
    OUT PULONG MemberCount
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamLookupDomainInSamServer(
    IN SAM_HANDLE ServerHandle,
    IN PUNICODE_STRING Name,
    OUT PSID * DomainId
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamLookupIdsInDomain(
    IN SAM_HANDLE DomainHandle,
    IN ULONG Count,
    IN PULONG RelativeIds,
    OUT PUNICODE_STRING *Names,
    OUT PSID_NAME_USE *Use
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamLookupNamesInDomain(
    IN SAM_HANDLE DomainHandle,
    IN ULONG Count,
    IN PUNICODE_STRING Names,
    OUT PULONG *RelativeIds,
    OUT PSID_NAME_USE *Use
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamOpenAlias(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG AliasId,
    OUT PSAM_HANDLE AliasHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamOpenDomain(
    IN SAM_HANDLE ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PSID DomainId,
    OUT PSAM_HANDLE DomainHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamOpenGroup(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG GroupId,
    OUT PSAM_HANDLE GroupHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamOpenUser(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG UserId,
    OUT PSAM_HANDLE UserHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamQueryDisplayInformation (
      IN    SAM_HANDLE DomainHandle,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    ULONG      Index,
      IN    ULONG      EntryCount,
      IN    ULONG      PreferredMaximumLength,
      OUT   PULONG     TotalAvailable,
      OUT   PULONG     TotalReturned,
      OUT   PULONG     ReturnedEntryCount,
      OUT   PVOID      *SortedBuffer
      )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamQueryInformationAlias(
    IN SAM_HANDLE AliasHandle,
    IN ALIAS_INFORMATION_CLASS AliasInformationClass,
    OUT PVOID *Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamQueryInformationDomain(
    IN SAM_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    OUT PVOID *Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamQueryInformationGroup(
    IN SAM_HANDLE GroupHandle,
    IN GROUP_INFORMATION_CLASS GroupInformationClass,
    OUT PVOID *Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamQueryInformationUser(
    IN SAM_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    OUT PVOID * Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamQuerySecurityObject(
    IN SAM_HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamRemoveMemberFromAlias(
    IN SAM_HANDLE AliasHandle,
    IN PSID MemberId
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamRemoveMemberFromForeignDomain(
    IN SAM_HANDLE DomainHandle,
    IN PSID MemberId
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamRemoveMemberFromGroup(
    IN SAM_HANDLE GroupHandle,
    IN ULONG MemberId
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamRidToSid(
    IN  SAM_HANDLE ObjectHandle,
    IN  ULONG      Rid,
    OUT PSID*      Sid
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamSetInformationAlias(
    IN SAM_HANDLE AliasHandle,
    IN ALIAS_INFORMATION_CLASS AliasInformationClass,
    IN PVOID Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamSetInformationDomain(
    IN SAM_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    IN PVOID DomainInformation
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamSetInformationGroup(
    IN SAM_HANDLE GroupHandle,
    IN GROUP_INFORMATION_CLASS GroupInformationClass,
    IN PVOID Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamSetInformationUser(
    IN SAM_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN PVOID Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamSetMemberAttributesOfGroup(
    IN SAM_HANDLE GroupHandle,
    IN ULONG MemberId,
    IN ULONG Attributes
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamSetSecurityObject(
    IN SAM_HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(samlib)
{
    DLPENTRY(SamAddMemberToAlias)
    DLPENTRY(SamAddMemberToGroup)
    DLPENTRY(SamCloseHandle)
    DLPENTRY(SamConnect)
    DLPENTRY(SamCreateAliasInDomain)
    DLPENTRY(SamCreateGroupInDomain)
    DLPENTRY(SamCreateUser2InDomain)
    DLPENTRY(SamDeleteAlias)
    DLPENTRY(SamDeleteGroup)
    DLPENTRY(SamDeleteUser)
    DLPENTRY(SamEnumerateAliasesInDomain)
    DLPENTRY(SamEnumerateDomainsInSamServer)
    DLPENTRY(SamEnumerateGroupsInDomain)
    DLPENTRY(SamEnumerateUsersInDomain)
    DLPENTRY(SamFreeMemory)
    DLPENTRY(SamGetAliasMembership)
    DLPENTRY(SamGetCompatibilityMode)
    DLPENTRY(SamGetDisplayEnumerationIndex)
    DLPENTRY(SamGetGroupsForUser)
    DLPENTRY(SamGetMembersInAlias)
    DLPENTRY(SamGetMembersInGroup)
    DLPENTRY(SamLookupDomainInSamServer)
    DLPENTRY(SamLookupIdsInDomain)
    DLPENTRY(SamLookupNamesInDomain)
    DLPENTRY(SamOpenAlias)
    DLPENTRY(SamOpenDomain)
    DLPENTRY(SamOpenGroup)
    DLPENTRY(SamOpenUser)
    DLPENTRY(SamQueryDisplayInformation)
    DLPENTRY(SamQueryInformationAlias)
    DLPENTRY(SamQueryInformationDomain)
    DLPENTRY(SamQueryInformationGroup)
    DLPENTRY(SamQueryInformationUser)
    DLPENTRY(SamQuerySecurityObject)
    DLPENTRY(SamRemoveMemberFromAlias)
    DLPENTRY(SamRemoveMemberFromForeignDomain)
    DLPENTRY(SamRemoveMemberFromGroup)
    DLPENTRY(SamRidToSid)
    DLPENTRY(SamSetInformationAlias)
    DLPENTRY(SamSetInformationDomain)
    DLPENTRY(SamSetInformationGroup)
    DLPENTRY(SamSetInformationUser)
    DLPENTRY(SamSetMemberAttributesOfGroup)
    DLPENTRY(SamSetSecurityObject)
};

DEFINE_PROCNAME_MAP(samlib)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\pstorec.c ===
#include "dspch.h"
#pragma hdrstop

#define _PSTOREC_
#include <wincrypt.h>
#include <pstore.h>

static
HRESULT __stdcall PStoreCreateInstance(
    IPStore __RPC_FAR *__RPC_FAR *ppProvider,
    PST_PROVIDERID __RPC_FAR *pProviderID,
    void __RPC_FAR *pReserved,
    DWORD dwFlags)
{
    return E_FAIL;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(pstorec)
{
    DLPENTRY(PStoreCreateInstance)
};

DEFINE_PROCNAME_MAP(pstorec)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\scecli.c ===
#include "dspch.h"
#pragma hdrstop

#include <secedit.h>
#include <scesetup.h>

static
DWORD
WINAPI
SceSetupMoveSecurityFile(
    IN PWSTR FileToSetSecurity,
    IN PWSTR FileToSaveInDB OPTIONAL,
    IN PWSTR SDText OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
SceSetupUnwindSecurityFile(
    IN PWSTR FileFullName,
    IN PSECURITY_DESCRIPTOR pSDBackup
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
SceSetupUpdateSecurityFile(
     IN PWSTR FileFullName,
     IN UINT nFlag,
     IN PWSTR SDText
     )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
SceSetupUpdateSecurityKey(
     IN HKEY hKeyRoot,
     IN PWSTR KeyPath,
     IN UINT nFlag,
     IN PWSTR SDText
     )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
SceSetupUpdateSecurityService(
     IN PWSTR ServiceName,
     IN DWORD StartType,
     IN PWSTR SDText
     )
{
    return ERROR_PROC_NOT_FOUND;
}

static
SCESTATUS
WINAPI
SceSvcConvertSDToText(
    IN PSECURITY_DESCRIPTOR   pSD,
    IN SECURITY_INFORMATION   siSecurityInfo,
    OUT PWSTR                  *ppwszTextSD,
    OUT PULONG                 pulTextSize
    )
{
    return SCESTATUS_MOD_NOT_FOUND;
}

static
SCESTATUS
WINAPI
SceSvcConvertTextToSD (
    IN  PWSTR                   pwszTextSD,
    OUT PSECURITY_DESCRIPTOR   *ppSD,
    OUT PULONG                  pulSDSize,
    OUT PSECURITY_INFORMATION   psiSeInfo
    )
{
    return SCESTATUS_MOD_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(scecli)
{
    DLPENTRY(SceSetupMoveSecurityFile)
    DLPENTRY(SceSetupUnwindSecurityFile)
    DLPENTRY(SceSetupUpdateSecurityFile)
    DLPENTRY(SceSetupUpdateSecurityKey)
    DLPENTRY(SceSetupUpdateSecurityService)
    DLPENTRY(SceSvcConvertSDToText)
    DLPENTRY(SceSvcConvertTextToSD)
};

DEFINE_PROCNAME_MAP(scecli)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\secur32.c ===
#include "dspch.h"
#pragma hdrstop
#include <sspi.h>

#define SEC_ENTRY                              __stdcall
#define EXTENDED_NAME_FORMAT                   DWORD
#define PLSA_STRING                            PVOID
#define SECURITY_LOGON_TYPE                    DWORD
#define POLICY_NOTIFICATION_INFORMATION_CLASS  DWORD
#define PLSA_OPERATIONAL_MODE                  PULONG


static
BOOLEAN
SEC_ENTRY
GetUserNameExA(
    EXTENDED_NAME_FORMAT  NameFormat,
    LPSTR lpNameBuffer,
    PULONG nSize
    )
{
    return FALSE;
}

static
BOOLEAN
SEC_ENTRY
GetUserNameExW(
    EXTENDED_NAME_FORMAT NameFormat,
    LPWSTR lpNameBuffer,
    PULONG nSize
    )
{
    return FALSE;
}

static
NTSTATUS
NTAPI
LsaCallAuthenticationPackage(
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
NTAPI
LsaConnectUntrusted (
    OUT PHANDLE LsaHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
NTAPI
LsaDeregisterLogonProcess (
    IN HANDLE LsaHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
NTAPI
LsaFreeReturnBuffer (
    IN PVOID Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
NTAPI
LsaLogonUser (
    IN HANDLE LsaHandle,
    IN PLSA_STRING OriginName,
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG AuthenticationPackage,
    IN PVOID AuthenticationInformation,
    IN ULONG AuthenticationInformationLength,
    IN PTOKEN_GROUPS LocalGroups OPTIONAL,
    IN PTOKEN_SOURCE SourceContext,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PLUID LogonId,
    OUT PHANDLE Token,
    OUT PQUOTA_LIMITS Quotas,
    OUT PNTSTATUS SubStatus
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
NTAPI
LsaLookupAuthenticationPackage (
    IN HANDLE LsaHandle,
    IN PLSA_STRING PackageName,
    OUT PULONG AuthenticationPackage
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
NTAPI
LsaRegisterLogonProcess (
    IN PLSA_STRING LogonProcessName,
    OUT PHANDLE LsaHandle,
    OUT PLSA_OPERATIONAL_MODE SecurityMode
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
NTAPI
LsaRegisterPolicyChangeNotification(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
    IN HANDLE  NotificationEventHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
NTAPI
LsaUnregisterPolicyChangeNotification(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
    IN HANDLE  NotificationEventHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS
SEC_ENTRY
QueryContextAttributesW(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS
SEC_ENTRY
SetContextAttributesW(
    PCtxtHandle                 phContext,          // Context to Set
    unsigned long               ulAttribute,        // Attribute to Set
    void SEC_FAR *              pBuffer,            // Buffer for attributes
    unsigned long               cbBuffer            // Size (in bytes) of pBuffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
BOOLEAN
SEC_ENTRY
TranslateNameW(
    LPCWSTR lpAccountName,
    EXTENDED_NAME_FORMAT AccountNameFormat,
    EXTENDED_NAME_FORMAT DesiredNameFormat,
    LPWSTR lpTranslatedName,
    PULONG nSize
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(secur32)
{
    DLPENTRY(GetUserNameExA)
    DLPENTRY(GetUserNameExW)
    DLPENTRY(LsaCallAuthenticationPackage)
    DLPENTRY(LsaConnectUntrusted)
    DLPENTRY(LsaDeregisterLogonProcess)
    DLPENTRY(LsaFreeReturnBuffer)
    DLPENTRY(LsaLogonUser)
    DLPENTRY(LsaLookupAuthenticationPackage)
    DLPENTRY(LsaRegisterLogonProcess)
    DLPENTRY(LsaRegisterPolicyChangeNotification)
    DLPENTRY(LsaUnregisterPolicyChangeNotification)
    DLPENTRY(QueryContextAttributesW)
    DLPENTRY(SetContextAttributesW)
    DLPENTRY(TranslateNameW)
};

DEFINE_PROCNAME_MAP(secur32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\winscard.c ===
#include "dspch.h"
#pragma hdrstop

#define WINSCARDAPI
#include <winscard.h>

static
WINSCARDAPI LONG WINAPI
SCardCancel(
    IN SCARDCONTEXT hContext)
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINSCARDAPI
LONG
WINAPI
SCardEstablishContext(
    IN      DWORD dwScope,
    IN      LPCVOID pvReserved1,
    IN      LPCVOID pvReserved2,
    OUT     LPSCARDCONTEXT phContext)
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINSCARDAPI LONG WINAPI
SCardFreeMemory(
    IN SCARDCONTEXT hContext,
    IN LPCVOID pvMem)
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINSCARDAPI LONG WINAPI
SCardGetCardTypeProviderNameW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szCardName,
    IN DWORD dwProviderId,
    OUT LPWSTR szProvider,
    IN OUT LPDWORD pcchProvider)
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINSCARDAPI LONG WINAPI
SCardGetStatusChangeW(
    IN SCARDCONTEXT hContext,
    IN DWORD dwTimeout,
    IN OUT LPSCARD_READERSTATE_W rgReaderStates,
    IN DWORD cReaders)
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINSCARDAPI LONG WINAPI
SCardListCardsW(
    IN SCARDCONTEXT hContext,
    IN LPCBYTE pbAtr,
    IN LPCGUID rgquidInterfaces,
    IN DWORD cguidInterfaceCount,
    OUT LPWSTR mszCards,
    IN OUT LPDWORD pcchCards)
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
WINAPI
SCardListReadersA(
    IN      SCARDCONTEXT hContext,
    IN      LPCSTR mszGroups,
    OUT     LPSTR mszReaders,
    IN OUT  LPDWORD pcchReaders)
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINSCARDAPI LONG WINAPI
SCardListReadersW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR mszGroups,
    OUT LPWSTR mszReaders,
    IN OUT LPDWORD pcchReaders)
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINSCARDAPI
LONG
WINAPI
SCardReleaseContext(
    IN      SCARDCONTEXT hContext)
{
    return ERROR_PROC_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(winscard)
{
    DLPENTRY(SCardCancel)
    DLPENTRY(SCardEstablishContext)
    DLPENTRY(SCardFreeMemory)
    DLPENTRY(SCardGetCardTypeProviderNameW)
    DLPENTRY(SCardGetStatusChangeW)
    DLPENTRY(SCardListCardsW)
    DLPENTRY(SCardListReadersA)
    DLPENTRY(SCardListReadersW)
    DLPENTRY(SCardReleaseContext)
};

DEFINE_PROCNAME_MAP(winscard)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\userenv.c ===
#include "dspch.h"
#pragma hdrstop

#define _USERENV_
#include <userenv.h>
#include <userenvp.h>


static
BOOL
WINAPI
AddItemW (
    LPCWSTR lpGroupName,
    BOOL    bCommonGroup,
    LPCWSTR lpFileName,
    LPCWSTR lpCommandLine,
    LPCWSTR lpIconPath,
    int     iIconIndex,
    LPCWSTR lpWorkingDirectory,
    WORD    wHotKey,
    int     iShowCmd
    )
{
    return FALSE;
}

static
BOOL
WINAPI
DeleteItemW(
     IN LPCWSTR lpGroupName,
     IN BOOL    bCommonGroup,
     IN LPCWSTR lpFileName,
     IN BOOL    bDeleteGroup)
{
    return FALSE;
}

static
BOOL
WINAPI
CreateEnvironmentBlock(
    OUT LPVOID *lpEnvironment,
    IN HANDLE  hToken,
    IN BOOL    bInherit)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
CreateGroupW(
     IN LPCWSTR lpGroupName,
     IN BOOL    bCommonGroup)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
CreateGroupEx(LPCWSTR lpGroupName, BOOL bCommonGroup,
              LPCWSTR lpResourceModuleName, UINT uResourceID)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
CreateLinkFileW(
     IN INT csidl,
     IN LPCWSTR lpSubDirectory,
     IN LPCWSTR lpFileName,
     IN LPCWSTR lpCommandLine,
     IN LPCWSTR lpIconPath,
     IN INT     iIconIndex,
     IN LPCWSTR lpWorkingDirectory,
     IN WORD    wHotKey,
     IN INT     iShowCmd,
     IN LPCWSTR lpDescription)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
CreateLinkFileEx(INT     csidl,                LPCTSTR lpSubDirectory,
                 LPCTSTR lpFileName,           LPCTSTR lpCommandLine,
                 LPCTSTR lpIconPath,           int iIconIndex,
                 LPCTSTR lpWorkingDirectory,   WORD wHotKey,
                 int     iShowCmd,             LPCTSTR lpDescription,
                 LPCWSTR lpResourceModuleName, UINT uResourceID)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
DeleteGroupW(
     IN LPCWSTR lpGroupName,
     IN BOOL    bCommonGroup)
{
    return FALSE;
}

static
BOOL
WINAPI
ExpandEnvironmentStringsForUserW(
    IN HANDLE hToken,
    IN LPCWSTR lpSrc,
    OUT LPWSTR lpDest,
    IN DWORD dwSize)
{
    return FALSE;
}

static
BOOL
WINAPI
GetDefaultUserProfileDirectoryW(
    IN LPWSTR lpProfileDir,
    IN OUT LPDWORD lpcchSize)
{
    return FALSE;
}

static
BOOL
WINAPI
GetProfileType(
    OUT DWORD *dwFlags)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
InitializeProfiles(
    IN BOOL bGuiModeSetup)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
GetUserProfileDirectoryW(
    IN HANDLE  hToken,
    OUT LPWSTR lpProfileDir,
    IN OUT LPDWORD lpcchSize)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
GetAllUsersProfileDirectoryW(
    OUT LPWSTR lpProfileDir,
    IN OUT LPDWORD lpcchSize)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
GetProfilesDirectoryW(
    OUT LPWSTR lpProfilesDir,
    IN OUT LPDWORD lpcchSize)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
DestroyEnvironmentBlock(
    IN LPVOID  lpEnvironment)
{
    return FALSE;
}

static
USERENVAPI
BOOL 
WINAPI 
LoadUserProfileW 
(HANDLE hToken, 
 LPPROFILEINFOW lpProfileInfoW)
{
    return FALSE; 
}

static
USERENVAPI
BOOL 
WINAPI 
UnloadUserProfile
(HANDLE hToken, 
 HANDLE hProfile)
{
    return FALSE; 
}

static
BOOL 
WINAPI 
RegisterGPNotification(
    IN HANDLE hEvent, 
    IN BOOL bMachine )
{
    return FALSE;
}

static
BOOL 
WINAPI 
UnregisterGPNotification(
    IN HANDLE hEvent)

{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
DeleteLinkFile(INT csidl, LPCTSTR lpSubDirectory,
               LPCTSTR lpFileName, BOOL bDeleteSubDirectory)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
DeleteProfileW (
        IN LPCWSTR lpSidString,
        IN LPCWSTR lpProfilePath,
        IN LPCWSTR lpComputerName)
{
    return FALSE;
}

static
USERENVAPI
DWORD 
WINAPI
GetGroupPolicyNetworkName(
    LPWSTR szNetworkName,
    LPDWORD pdwByteCount
    )
{
    return 0;
}

static
DWORD 
WINAPI 
GetUserAppDataPathW(
    HANDLE hToken, 
    LPWSTR lpFolderPath)
{
    return E_FAIL;
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(userenv)
{
    DLOENTRY(100, InitializeProfiles)
    DLOENTRY(102, CreateGroupW)
    DLOENTRY(104, DeleteGroupW)
    DLOENTRY(106, AddItemW)
    DLOENTRY(108, DeleteItemW)
    DLOENTRY(120, CreateLinkFileW)
    DLOENTRY(122, DeleteLinkFileW)
    DLOENTRY(132, CreateEnvironmentBlock)
    DLOENTRY(136, ExpandEnvironmentStringsForUserW)
    DLOENTRY(137, CreateGroupExW)
    DLOENTRY(139, CreateLinkFileExW)
    DLOENTRY(147, GetGroupPolicyNetworkName)
    DLOENTRY(149, GetUserAppDataPathW)

};

DEFINE_ORDINAL_MAP(userenv)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(userenv)
{
    DLPENTRY(CreateEnvironmentBlock)
    DLPENTRY(DeleteProfileW)
    DLPENTRY(DestroyEnvironmentBlock)
    DLPENTRY(ExpandEnvironmentStringsForUserW)
    DLPENTRY(GetAllUsersProfileDirectoryW)
    DLPENTRY(GetDefaultUserProfileDirectoryW)
    DLPENTRY(GetProfileType)
    DLPENTRY(GetProfilesDirectoryW)
    DLPENTRY(GetUserProfileDirectoryW)
    DLPENTRY(LoadUserProfileW)
    DLPENTRY(RegisterGPNotification)
    DLPENTRY(UnloadUserProfile)
    DLPENTRY(UnregisterGPNotification)
};

DEFINE_PROCNAME_MAP(userenv)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\wldap32.c ===
#include "dspch.h"
#pragma hdrstop

#define _WINLDAP_
#define LDAP_UNICODE    0
#include <winldap.h>

static
WINLDAPAPI
ULONG LDAPAPI
ldap_unbind(
    LDAP *ld
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_unbind_s(
    LDAP *ld
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
LdapMapErrorToWin32(
    ULONG LdapError
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINLDAPAPI
ULONG LDAPAPI
LdapGetLastError(
    VOID
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINLDAPAPI
LDAPMessage *LDAPAPI
ldap_first_entry(
    LDAP *ld,
    LDAPMessage *res
    )
{
    return NULL;
}

static
WINLDAPAPI
LDAPMessage *LDAPAPI
ldap_next_entry(
    LDAP *ld,
    LDAPMessage *entry
    )
{
    return NULL;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_count_entries(
    LDAP *ld,
    LDAPMessage *res
    )
{
    return -1;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_result(
    LDAP            *ld,
    ULONG           msgid,
    ULONG           all,
    struct l_timeval  *timeout,
    LDAPMessage     **res
    )
{
    return -1;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_msgfree(
    LDAPMessage *res
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_bind_s(
    LDAP *ld,
    const PCHAR dn,
    const PCHAR cred,
    ULONG method
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
LDAP * LDAPAPI
cldap_openA(
    PCHAR HostName,
    ULONG PortNumber
    )
{
    return NULL;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_add_sW(
    LDAP *ld,
    PWCHAR dn,
    LDAPModW *attrs[]
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_bind_sW(
    LDAP *ld,
    PWCHAR dn,
    PWCHAR cred,
    ULONG method
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_count_values_len(
    struct berval **vals
    )
{
    return -1;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_value_free_len(
    struct berval **vals
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_compare_sW(
    LDAP *ld,
    const PWCHAR dn,
    const PWCHAR attr,
    PWCHAR value
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_count_valuesW(
    PWCHAR *vals
    )
{
    return -1;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_delete_sW(
    LDAP *ld,
    const PWCHAR dn
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_escape_filter_elementA(
   PCHAR   sourceFilterElement,
   ULONG   sourceLength,
   PCHAR   destFilterElement,
   ULONG   destLength
   )
{
    return LDAP_NO_MEMORY;
}

static
PWCHAR __cdecl
ldap_get_dnW (
    LDAP *ExternalHandle,
    LDAPMessage *LdapMsg
    )
{
    return NULL;
}

static
WINLDAPAPI 
ULONG LDAPAPI 
ldap_get_next_page_s(
    PLDAP           ExternalHandle,
    PLDAPSearch     SearchHandle,
    struct l_timeval  *timeout,
    ULONG           PageSize,
    ULONG          *TotalCount,
    LDAPMessage     **Results
    )
{
    return LDAP_NO_MEMORY;
}


static
WINLDAPAPI
PWCHAR *LDAPAPI
ldap_get_valuesW(
    LDAP            *ld,
    LDAPMessage     *entry,
    const PWCHAR          attr
    )
{
    return NULL;
}

static
WINLDAPAPI
struct berval **LDAPAPI
ldap_get_values_lenA(
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    const PCHAR           attr
    )
{
    return NULL;
}

static
WINLDAPAPI
struct berval **LDAPAPI
ldap_get_values_lenW(
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    const PWCHAR          attr
    )
{
    return NULL;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_modify_ext_sW(
    LDAP *ld,
    const PWCHAR dn,
    LDAPModW *mods[],
    PLDAPControlW   *ServerControls,
    PLDAPControlW   *ClientControls
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_modify_sW(
    LDAP *ld,
    PWCHAR dn,
    LDAPModW *mods[]
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
LDAP * LDAPAPI
ldap_openW(
    const PWCHAR HostName,
    ULONG PortNumber
    )
{
    return NULL;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_searchA(
    LDAP    *ld,
    const PCHAR   base,
    ULONG   scope,
    const PCHAR   filter,
    PCHAR   attrs[],
    ULONG   attrsonly
    )
{
    return -1;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_search_ext_sW(
    LDAP            *ld,
    const PWCHAR    base,
    ULONG           scope,
    const PWCHAR    filter,
    PWCHAR          attrs[],
    ULONG           attrsonly,
    PLDAPControlW   *ServerControls,
    PLDAPControlW   *ClientControls,
    struct l_timeval  *timeout,
    ULONG           SizeLimit,
    LDAPMessage     **res
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_search_sW(
    LDAP            *ld,
    const PWCHAR    base,
    ULONG           scope,
    const PWCHAR    filter,
    PWCHAR          attrs[],
    ULONG           attrsonly,
    LDAPMessage     **res
    )
{
    *res = NULL;
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_value_freeW(
    PWCHAR *vals
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
PCHAR LDAPAPI
ldap_err2stringA(
    ULONG err
    )
{
    return NULL;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_set_optionW(
    LDAP *ld,
    int option,
    const void *invalue
    )
{
    return LDAP_NO_MEMORY;
}

static
VOID  __cdecl
ldap_memfreeW(
    PWCHAR  Block
    )
{
    return;
}

static 
WINLDAPAPI 
ULONG LDAPAPI 
ldap_search_abandon_page(
        PLDAP           ExternalHandle,
        PLDAPSearch     SearchBlock
    )
{
    return LDAP_NO_MEMORY;
}

WINLDAPAPI 
PLDAPSearch LDAPAPI 
ldap_search_init_pageW(
        PLDAP           ExternalHandle,
        const PWCHAR    DistinguishedName,
        ULONG           ScopeOfSearch,
        const PWCHAR    SearchFilter,
        PWCHAR          AttributeList[],
        ULONG           AttributesOnly,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           PageTimeLimit,
        ULONG           TotalSizeLimit,
        PLDAPSortKeyW  *SortKeys
    )
{
    return NULL;
}

static
WINLDAPAPI
LDAP* LDAPAPI
ldap_initW(
    const PWCHAR HostName,
    ULONG PortNumber
    )
{
    return NULL;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//

DEFINE_ORDINAL_ENTRIES(wldap32)
{
    DLOENTRY(13,ldap_unbind)
    DLOENTRY(14,ldap_set_optionW)
    DLOENTRY(16,LdapGetLastError)
    DLOENTRY(18,LdapMapErrorToWin32)
    DLOENTRY(26,ldap_first_entry)
    DLOENTRY(27,ldap_next_entry)
    DLOENTRY(36,ldap_count_entries)
    DLOENTRY(40,ldap_result)
    DLOENTRY(41,ldap_msgfree)
    DLOENTRY(45,ldap_bind_s)
    DLOENTRY(46,ldap_unbind_s)
    DLOENTRY(55,cldap_openA)
    DLOENTRY(69,ldap_add_sW)
    DLOENTRY(73,ldap_bind_sW)
    DLOENTRY(77,ldap_count_values_len)
    DLOENTRY(79,ldap_value_free_len)
    DLOENTRY(87,ldap_compare_sW)
    DLOENTRY(97,ldap_count_valuesW)
    DLOENTRY(113,ldap_delete_sW)
    DLOENTRY(117,ldap_err2stringA)
    DLOENTRY(119,ldap_escape_filter_elementA)
    DLOENTRY(133,ldap_get_dnW)
    DLOENTRY(135,ldap_get_next_page_s)
    DLOENTRY(140,ldap_get_valuesW)
    DLOENTRY(141,ldap_get_values_lenA)
    DLOENTRY(142,ldap_get_values_lenW)
    DLOENTRY(145,ldap_initW)
    DLOENTRY(147,ldap_memfreeW)
    DLOENTRY(155,ldap_modify_ext_sW)
    DLOENTRY(157,ldap_modify_sW)
    DLOENTRY(170,ldap_openW)
    DLOENTRY(189,ldap_searchA)
    DLOENTRY(191,ldap_search_abandon_page)
    DLOENTRY(203,ldap_search_ext_sW)
    DLOENTRY(206,ldap_search_init_pageW)
    DLOENTRY(208,ldap_search_sW)
    DLOENTRY(224,ldap_value_freeW)
};

DEFINE_ORDINAL_MAP(wldap32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\dload\wintrust.c ===
#include "dspch.h"
#pragma hdrstop

#include <wincrypt.h>
#include <mscat.h>


static
LONG
WINAPI
WinVerifyTrust (
    HWND hwnd,
    GUID *pgActionID,
    LPVOID pWVTData
    )
{
    return E_UNEXPECTED;
}

static
BOOL
WINAPI
CryptCATAdminAcquireContext(
    OUT HCATADMIN *phCatAdmin,
    IN const GUID *pgSubsystem,
    IN DWORD dwFlags) 
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
HCATINFO
WINAPI
CryptCATAdminEnumCatalogFromHash(
    IN HCATADMIN hCatAdmin,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN DWORD dwFlags,
    IN OUT HCATINFO *phPrevCatInfo)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
BOOL
WINAPI
CryptCATAdminCalcHashFromFileHandle(
    IN HANDLE hFile,
    IN OUT DWORD *pcbHash,
    OUT OPTIONAL BYTE *pbHash,
    IN DWORD dwFlags)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
HCATINFO
WINAPI
CryptCATAdminAddCatalog(
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN OPTIONAL WCHAR *pwszSelectBaseName,
    IN DWORD dwFlags)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
BOOL
WINAPI
CryptCATCatalogInfoFromContext(
    IN HCATINFO hCatInfo,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
CryptCATAdminReleaseContext(
    IN HCATADMIN hCatAdmin,
    IN DWORD dwFlags)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
CryptCATAdminReleaseCatalogContext(
    IN HCATADMIN hCatAdmin,
    IN HCATINFO hCatInfo,
    IN DWORD dwFlags)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
CryptCATAdminRemoveCatalog(
    IN HCATADMIN hCatAdmin,
    IN LPCWSTR pwszCatalogFile,
    IN DWORD dwFlags)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
CryptCATAdminResolveCatalogPath(
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(wintrust)
{
    DLPENTRY(CryptCATAdminAcquireContext)
    DLPENTRY(CryptCATAdminAddCatalog)
    DLPENTRY(CryptCATAdminCalcHashFromFileHandle)
    DLPENTRY(CryptCATAdminEnumCatalogFromHash)
    DLPENTRY(CryptCATAdminReleaseCatalogContext)
    DLPENTRY(CryptCATAdminReleaseContext)
    DLPENTRY(CryptCATAdminRemoveCatalog)
    DLPENTRY(CryptCATAdminResolveCatalogPath)
    DLPENTRY(CryptCATCatalogInfoFromContext)
    DLPENTRY(WinVerifyTrust)
};

DEFINE_PROCNAME_MAP(wintrust)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\inc\makefile.inc ===
#
# The contents of this file was moved from windows\makefile0
#

!IFNDEF NO_STRICT
STRICT=1
!ENDIF

TARGETSRCS= \
            $(O)\ntsecapi.h  \
            $(O)\subauth.h \
            $(O)\ntsecpkg.h \
            $(O)\aclapi.h \
            $(O)\aclapip.h \
            $(O)\sddl.h \
            $(O)\sddlp.h \
            $(O)\winsafer.h \
            $(O)\winsaferp.h \
            $(O)\wincrypt.h

secinc: $(TARGETSRCS)

clean:
    -del /q /f $(TARGETSRCS) 2>nul


NTSECAPI_DEPENDS=ntlsa.w \
                 ntsam.w \
                 ntmsv1_0.w \
                 kerbcon.w \
                 kerberos.w

NTSECPKG_DEPENDS=ntlsa.w \
                 ntsam.w \
                 secpkg.w

#######################################################################
# subauth.h
#

$(O)\subauth.h :            ntsam.w                           \
                            $(SDK_INC_PATH)\ntstatus.h        \
                            $(DS_INC_PATH)\crypt.h            \
                            $(DS_INC_PATH)\logonmsv.h         \
                            makefile.inc
    type << > $(O)\subauth.h
/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    subauth.h

Abstract:

    This module defines types and macros for Subauthentication Packages.

Revision History:

--*/

#ifndef _NTSUBAUTH_
#define _NTSUBAUTH_

#ifdef __cplusplus
extern "C" {
#endif

#if (!defined(_NTDEF_)) && (!defined(_NTSECAPI_))
typedef LONG NTSTATUS, *PNTSTATUS;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} STRING, *PSTRING;
#endif

#ifndef _NTDEF_

typedef struct _OLD_LARGE_INTEGER {
    ULONG LowPart;
    LONG HighPart;
} OLD_LARGE_INTEGER, *POLD_LARGE_INTEGER;

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

#endif

<<
    hextract -o $(O)\subauth.h -lt ntsubauth -bt begin_ntsubauth end_ntsubauth ntsam.w
    hextract -o $(O)\subauth.h -lt ntsubauth -bt begin_ntsubauth end_ntsubauth $(DS_INC_PATH)\crypt.h
    hextract -o $(O)\subauth.h -lt ntsubauth -bt begin_ntsubauth end_ntsubauth $(DS_INC_PATH)\logonmsv.h
    hextract -o $(O)\subauth.h -lt ntsubauth -bt begin_ntsubauth end_ntsubauth $(SDK_INC_PATH)\ntstatus.h
    type << >> $(O)\subauth.h
#ifdef __cplusplus
}
#endif

#endif /* _NTSUBAUTH_ */

<<

########################################################################
# ntsecapi.h
#

$(O)\ntsecapi.h : $(NTSECAPI_DEPENDS) makefile.inc
    type << > $(O)\ntsecapi.h
/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    ntsecapi.h

Abstract:

    This module defines the Local Security Authority APIs.

Revision History:

--*/

#ifndef _NTSECAPI_
#define _NTSECAPI_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _NTDEF_
typedef LONG NTSTATUS, *PNTSTATUS;
#endif

<<
    hextract -o $(O)\ntsecapi.h -lt ntsecapi -bt begin_ntsecapi end_ntsecapi ntlsa.w
    type << >> $(O)\ntsecapi.h
#ifndef _NTDEF_
typedef LSA_UNICODE_STRING UNICODE_STRING, *PUNICODE_STRING;
typedef LSA_STRING STRING, *PSTRING ;
#endif
<<
    hextract -o $(O)\ntsecapi.h -lt ntsecapi -bt begin_ntsecapi end_ntsecapi ntsam.w
    hextract -o $(O)\ntsecapi.h -lt ntsecapi -bt begin_ntsecapi end_ntsecapi ntmsv1_0.w
    hextract -o $(O)\ntsecapi.h -lt ntsecapi -bt begin_ntsecapi end_ntsecapi kerbcon.w
    hextract -o $(O)\ntsecapi.h -lt ntsecapi -bt begin_ntsecapi end_ntsecapi kerberos.w
    type << >> $(O)\ntsecapi.h

#ifdef __cplusplus
}
#endif

#endif /* _NTSECAPI_ */

<<


########################################################################
# ntsecpkg.h
#
$(O)\ntsecpkg.h : $(NTSECPKG_DEPENDS) makefile.inc
    type << > $(O)\ntsecpkg.h
/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    ntsecpkg.h

Abstract:

    This module defines the structures and APIs for use by a
    authentication or security package.

Revision History:

--*/

#ifndef _NTSECPKG_
#define _NTSECPKG_

#ifdef __cplusplus
extern "C" {
#endif

<<
    hextract -o $(O)\ntsecpkg.h -lt ntsecpkg -bt begin_ntsecpkg end_ntsecpkg ntlsa.w
    hextract -o $(O)\ntsecpkg.h -lt ntsecpkg -bt begin_ntsecpkg end_ntsecpkg ntsam.w
    hextract -o $(O)\ntsecpkg.h -lt ntsecpkg -bt begin_ntsecpkg end_ntsecpkg secpkg.w
    type << >> $(O)\ntsecpkg.h

#ifdef __cplusplus
}
#endif

#endif /* _NTSECPKG_ */

<<


########################################################################
# wincrypt.h
#

$(O)\wincrypt.h : wincrypt.x
    wcshdr < $? > $@


########################################################################
# aclapi.h, aclapip.h, aclapip.x, aclapi.x
#

$(O)\aclapi.x $(O)\aclapip.x: aclapi.w
    hsplit -e -o $(O)\aclapi.x $(O)\aclapip.x aclapi.w

$(O)\aclapi.h : $(O)\aclapi.x
    wcshdr < $? > $@

$(O)\aclapip.h : $(O)\aclapip.x
    wcshdr < $? > $@

$(WINDOWS_INC_PATH)\aclapip.h : $(O)\aclapip.h
    $(PUBLISH_CMD) {$?=$@}

$(SDK_INC_PATH)\aclapi.h : $(O)\aclapi.h
    $(PUBLISH_CMD) {$?=$@}


#
# sddl.h, sddlp.x, sddl.x
#

$(O)\sddl.x $(O)\sddlp.x: sddl.w
    hsplit -e -o $(O)\sddl.x $(O)\sddlp.x sddl.w

$(O)\sddl.h : $(O)\sddl.x
    wcshdr < $? > $@

$(O)\sddlp.h : $(O)\sddlp.x
    wcshdr < $? > $@

########################################################################
# winsafer.h, winsaferp.h, winsaferp.x, winsafer.x
#

$(O)\winsafer.x $(O)\winsaferp.x: winsafer.w
    hsplit -e -o $(O)\winsafer.x $(O)\winsaferp.x winsafer.w

$(O)\winsafer.h : $(O)\winsafer.x
    wcshdr < $? > $@

$(O)\winsaferp.h : $(O)\winsaferp.x
    wcshdr < $? > $@

$(WINDOWS_INC_PATH)\winsaferp.h : $(O)\winsaferp.h
    $(PUBLISH_CMD) {$?=$@}

$(SDK_INC_PATH)\winsafer.h : $(O)\winsafer.h
    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\lsa\makefile.inc ===
MIDL_OPTIMIZATION_NT5=-Oicf -robust -error all -no_format_opt -protocol all

SERVER_FLAGS  = $(MIDL_OPTIMIZATION_NT5) -oldnames -c_ext -ms_ext $(MIDL_FLAGS) -acf $(SERVER_ACF) -client none -header $(O)\$(SERVER_INC_FILE)
NO_STUB_FLAGS = -server none

CPP = -cpp_cmd "$(MIDL_CPP)"

$(DS_INC_PATH)\$(IDL_NAME).idl: $(@F)
    $(PUBLISH_CMD) {$?=$@}

$(DS_INC_PATH)\$(SERVER_ACF): $(@F)
    $(PUBLISH_CMD) {$?=$@}

$(DS_INC_PATH)\$(IMPORT_FILE): $(@F)
    $(PUBLISH_CMD) {$?=$@}

$(DS_INC_PATH)\$(IDL_NAME).h: $(O)\$(@F)
    $(PUBLISH_CMD) {$?=$@}

$(O)\$(IDL_NAME).h: $(IDL_NAME).idl $(SERVER_ACF)
    $(MIDL) $(CPP) $(SERVER_FLAGS) $(NO_STUB_FLAGS) $(MIDL_INCS) $(IDL_NAME).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\ds\sam\idl\makefile.inc ===
MIDL_OPTIMIZATION_NT5=-Oicf -robust -error all -no_format_opt

SERVER_FLAGS  = $(MIDL_OPTIMIZATION_NT5) -oldnames -c_ext -ms_ext $(MIDL_FLAGS) -acf $(SERVER_ACF) -client none -header $(O)\$(SERVER_INC_FILE)
NO_STUB_FLAGS = -server none

CPP = -cpp_cmd "$(MIDL_CPP)"

$(PRIVATE_INC_PATH)\$(IDL_NAME).h: $(O)\$(@F)
    $(PUBLISH_CMD) {$?=$@}

$(O)\$(IDL_NAME).h: $(IDL_NAME).idl $(SERVER_ACF)
    $(MIDL) $(CPP) $(SERVER_FLAGS) $(NO_STUB_FLAGS) $(MIDL_INCS) $(IDL_NAME).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\inc\upssvc.h ===
/*++

Copyright (c) 2000 Microsoft Corporation. All rights reserved.

Module Name:

    upssvc.h

Abstract:

    This file defines the interface to the serial UPS service in 
    Windows 2000.  Please see the UPS documentation in the DDK
    for more information.


--*/

#ifndef _INC_UPS_DRIVER_H_
#define _INC_UPS_DRIVER_H_


//
// values that represent the state of the
// UPS system - these values are used in the
// UPSGetState and UPSWaitForStateChange functions
//
#define UPS_ONLINE 1
#define UPS_ONBATTERY 2
#define UPS_LOWBATTERY 4
#define UPS_NOCOMM 8
#define UPS_CRITICAL 16


//
// possible error codes returned from UPSInit
//
#define UPS_INITUNKNOWNERROR    0
#define UPS_INITOK              1
#define UPS_INITNOSUCHDRIVER    2
#define UPS_INITBADINTERFACE    3
#define UPS_INITREGISTRYERROR   4
#define UPS_INITCOMMOPENERROR   5
#define UPS_INITCOMMSETUPERROR  6


/**
* UPSInit
*
* Description:
*   
*   The UPSInit function must be called before any
*   other function in this file
*
* Parameters:
*   None
*
* Returns:
*   UPS_INITOK: Initalization was successful
*   UPS_INITNOSUCHDRIVER:   The configured driver DLL can't be opened    
*   UPS_INITBADINTERFACE:   The configured driver DLL doesn't support 
*                           the UPS driver interface
*   UPS_INITREGISTRYERROR:  The 'Options' registry value is corrupt
*   UPS_INITCOMMOPENERROR:  The comm port could not be opened
*   UPS_INITCOMMSETUPERROR: The comm port could not be configured
*   UPS_INITUNKNOWNERROR:   Undefined error has occurred
*   
*/
DWORD UPSInit(void);


/**
* UPSStop
*
* Description:
*   After a call to UPSStop, only the UPSInit
*   function is valid.  This call will unload the
*   UPS driver interface and stop monitoring of the
*   UPS system
*
* Parameters:
*   None
*
* Returns:
*   None
*   
*/
void UPSStop(void);


/**
* UPSWaitForStateChange
*
* Description:
*   Blocks until the state of the UPS differs
*   from the value passed in via aCurrentState or 
*   anInterval milliseconds has expired.  If
*   anInterval has a value of INFINITE this 
*   function will never timeout
*
* Parameters:
*   aState: defines the state to wait for a change from,
*           possible values:
*           UPS_ONLINE 
*           UPS_ONBATTERY
*           UPS_LOWBATTERY
*           UPS_NOCOMM
*
*   anInterval: timeout in milliseconds, or INFINITE for
*               no timeout interval
*
* Returns:
*   None
*   
*/
void UPSWaitForStateChange(DWORD aCurrentState, DWORD anInterval);


/**
* UPSGetState
*
* Description:
*   returns the current state of the UPS
*
* Parameters:
*   None
*
* Returns: 
*   possible values:
*           UPS_ONLINE 
*           UPS_ONBATTERY
*           UPS_LOWBATTERY
*           UPS_NOCOMM
*   
*/
DWORD UPSGetState(void);


/**
* UPSCancelWait
*
* Description:
*   interrupts pending calls to UPSWaitForStateChange
*   without regard to timout or state change
*
* Parameters:
*   None
*
* Returns:
*   None
*   
*/
void UPSCancelWait(void);


/**
* UPSTurnOff
*
* Description:
*   Attempts to turn off the outlets on the UPS
*   after the specified delay.  This call must
*   return immediately.  Any work, such as a timer,
*   must be performed on a another thread.
*
* Parameters:
*   aTurnOffDelay: the minimum amount of time to wait before
*                  turning off the outlets on the UPS
*
* Returns:
*   None
*   
*/
void UPSTurnOff(DWORD aTurnOffDelay);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\userenv\makefile.inc ===
#
# The contents of this file was moved from windows\makefile0
#

!IFNDEF NO_STRICT
STRICT=1
!ENDIF

TARGETSRCS0= $(SDK_INC_PATH)\userenv.h

TARGETSRCS1= $(DS_INC_PATH)\userenvp.h

TARGETSRCS2= $(SDK_INC_PATH)\profinfo.h

TARGETSRCS= $(TARGETSRCS0) $(TARGETSRCS1) $(TARGETSRCS2)

wininc: $(TARGETSRCS)

#
# userenvp.h, userenv.h, userenvp.x, userenv.x
#

$(O)\userenv.x $(O)\userenvp.x: userenv.w
    hsplit -e -o $(O)\userenv.x $(O)\userenvp.x userenv.w

$(O)\userenv.h: $(O)\userenv.x
    wcshdr < $? > $@

$(O)\userenvp.h: $(O)\userenvp.x
    wcshdr < $? > $@

$(O)\profinfo.h: profinfo.w
    wcshdr < $? > $@

$(SDK_INC_PATH)\userenv.h: $(O)\userenv.h
    $(PUBLISH_CMD) {$?=$@}

$(DS_INC_PATH)\userenvp.h: $(O)\userenvp.h
    $(PUBLISH_CMD) {$?=$@}

$(SDK_INC_PATH)\profinfo.h: $(O)\profinfo.h
    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\safealloca\alloca.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    alloca.c

Abstract:

    This module implements a safe stack-based allocator with fallback to the heap.

Author:

    Jonathan Schwartz (JSchwart)  16-Mar-2001

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <malloc.h>   // _resetstkoflw()

#include <alloca.h>


//
// Globals used to control SafeAlloca behavior
//

SIZE_T  g_ulMaxStackAllocSize;
SIZE_T  g_ulAdditionalProbeSize;

SAFEALLOC_ALLOC_PROC  g_pfnAllocate;
SAFEALLOC_FREE_PROC   g_pfnFree;


//
// Local function declarations
//

PVOID
SafeAllocaAllocateFromHeap(
    SIZE_T Size
    );

VOID
SafeAllocaFreeToHeap(
    PVOID BaseAddress
    );


//+-------------------------------------------------------------------------
//
//  Function:   SafeAllocaInitialize
//
//  Synopsis:   Initialize globals used to control SafeAlloca behavior
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      Must be called before SafeAlloca is used to allocate space
//
//--------------------------------------------------------------------------

VOID
SafeAllocaInitialize(
    IN  OPTIONAL SIZE_T                ulMaxStackAllocSize,
    IN  OPTIONAL SIZE_T                ulAdditionalProbeSize,
    IN  OPTIONAL SAFEALLOC_ALLOC_PROC  pfnAllocate,
    IN  OPTIONAL SAFEALLOC_FREE_PROC   pfnFree
    )
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    PPEB Peb = NtCurrentPeb();

    //
    // Make sure this is the first and only time the init is being called for this
    // binary (either DLL or EXE since this is a code LIB).  Otherwise, we could
    // end up with the free routine after memory is allocated using a completely
    // unrelated allocator.
    //

    ASSERT(g_pfnAllocate == NULL && g_pfnFree == NULL);

    if (NtCurrentPeb()->BeingDebugged)
    {
        //
        // Usermode debugger is attached to this process, which can cause issues
        // when the first-chance overflow exception on stack probes is caught by
        // the debugger rather than the probe exception handler.  Force all
        // allocations to the heap.
        //

        g_ulMaxStackAllocSize = 0;
    }
    else if (ulMaxStackAllocSize == SAFEALLOCA_USE_DEFAULT)
    {
        //
        // Default is stack size from the image header
        //

        NtHeaders = RtlImageNtHeader(Peb->ImageBaseAddress);

        if (NtHeaders == NULL)
        {
            //
            // This shouldn't happen -- it implies the binary is bad.
            // Set the default to force heap allocations only.
            //

            ASSERT(NtHeaders != NULL);
            g_ulMaxStackAllocSize = 0;
        }
        else
        {
            g_ulMaxStackAllocSize = NtHeaders->OptionalHeader.SizeOfStackCommit;
        }
    }
    else
    {
        g_ulMaxStackAllocSize = ulMaxStackAllocSize;
    }

    if (ulAdditionalProbeSize == SAFEALLOCA_USE_DEFAULT)
    {
        //
        // Default is stack size from the image header
        //

        if (NtHeaders == NULL)
        {
            NtHeaders = RtlImageNtHeader(Peb->ImageBaseAddress);

            if (NtHeaders == NULL)
            {
                //
                // This shouldn't happen -- it implies the binary is bad.
                // Set the default to force heap allocations only.
                //

                ASSERT(NtHeaders != NULL);
                g_ulAdditionalProbeSize = 0xffffffff;
            }
        }

        if (NtHeaders != NULL)
        {
            g_ulAdditionalProbeSize = NtHeaders->OptionalHeader.SizeOfStackCommit;
        }
    }
    else
    {
        g_ulAdditionalProbeSize = ulAdditionalProbeSize;
    }

    if (pfnAllocate == NULL)
    {
        g_pfnAllocate = SafeAllocaAllocateFromHeap;
    }
    else
    {
        g_pfnAllocate = pfnAllocate;
    }

    if (pfnFree == NULL)
    {
        g_pfnFree = SafeAllocaFreeToHeap;
    }
    else
    {
        g_pfnFree = pfnFree;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   SafeAllocaAllocateFromHeap
//
//  Synopsis:   Default fallback heap allocator for SafeAlloca
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:  
//
//--------------------------------------------------------------------------

PVOID
SafeAllocaAllocateFromHeap(
    SIZE_T Size
    )
{
    return RtlAllocateHeap(RtlProcessHeap(), 0, Size);
}


//+-------------------------------------------------------------------------
//
//  Function:   SafeAllocaFreeToHeap
//
//  Synopsis:   Default fallback heap free routine for SafeAlloca
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:  
//
//--------------------------------------------------------------------------

VOID
SafeAllocaFreeToHeap(
    PVOID BaseAddress
    )
{
    RtlFreeHeap(RtlProcessHeap(), 0, BaseAddress);
}


//+-------------------------------------------------------------------------
//
//  Function:   VerifyStackAvailable
//
//  Synopsis:   Routine to probe the stack to ensure the allocation size
//              plus additional probe size is available.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:  
//
//--------------------------------------------------------------------------

BOOL
VerifyStackAvailable(
    SIZE_T Size
    )
{
    BOOL fStackAvailable = TRUE;

    __try
    {
        PVOID p = _alloca(Size);
    }
    __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
                   EXCEPTION_EXECUTE_HANDLER :
                   EXCEPTION_CONTINUE_SEARCH)
    {
        fStackAvailable = FALSE;
        _resetstkoflw();
    }

    return fStackAvailable;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\published\scard\makefile.inc ===
SCHEADERS=$(SDK_INC_PATH)\winscard.h \
          $(SDK_INC_PATH)\winsmcrd.h \
          $(SDK_INC_PATH)\scarderr.h

ALLHEADERS : $(SCHEADERS)

$(SDK_INC_PATH)\winscard.h : $(O)\winscard.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\winscard.h : winscard.x
    wcshdr < $? > $@

$(SDK_INC_PATH)\winsmcrd.h : $(O)\winsmcrd.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\winsmcrd.h : winsmcrd.x
    wcshdr < $? > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\builtin.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_BUILTIN_H_
#define _ASN1C_BUILTIN_H_

extern Type_t *Builtin_Type_Null;
extern Type_t *Builtin_Type_Boolean;
extern Type_t *Builtin_Type_Integer;
extern Type_t *Builtin_Type_PositiveInteger;
extern Type_t *Builtin_Type_ObjectIdentifier;
extern Type_t *Builtin_Type_ObjectDescriptor;
extern Type_t *Builtin_Type_Open;
extern Type_t *Builtin_Type_BitString;
extern Type_t *Builtin_Type_OctetString;
extern Type_t *Builtin_Type_UTF8String;
extern Type_t *Builtin_Type_BMPString;
extern Type_t *Builtin_Type_GeneralString;
extern Type_t *Builtin_Type_GraphicString;
extern Type_t *Builtin_Type_IA5String;
extern Type_t *Builtin_Type_ISO646String;
extern Type_t *Builtin_Type_NumericString;
extern Type_t *Builtin_Type_PrintableString;
extern Type_t *Builtin_Type_TeletexString;
extern Type_t *Builtin_Type_T61String;
extern Type_t *Builtin_Type_UniversalString;
extern Type_t *Builtin_Type_VideotexString;
extern Type_t *Builtin_Type_VisibleString;
extern Type_t *Builtin_Type_CharacterString;
extern Type_t *Builtin_Type_GeneralizedTime;
extern Type_t *Builtin_Type_UTCTime;
extern Type_t *Builtin_Type_Real;
extern Type_t *Builtin_Type_External;
extern Type_t *Builtin_Type_EmbeddedPdv;
extern Value_t *Builtin_Value_Null;
extern Value_t *Builtin_Value_Integer_0;
extern Value_t *Builtin_Value_Integer_1;
extern Value_t *Builtin_Value_Integer_2;
extern Value_t *Builtin_Value_Integer_10;
extern ObjectClass_t *Builtin_ObjectClass_TypeIdentifier;
extern ObjectClass_t *Builtin_ObjectClass_AbstractSyntax;
extern ModuleIdentifier_t *Builtin_Module;
extern ModuleIdentifier_t *Builtin_Character_Module;
extern AssignmentList_t Builtin_Assignments;
extern AssignedObjIdList_t Builtin_ObjIds;

extern void InitBuiltin();

#endif // _ASN1C_BUILTIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\ber.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

void ExamineBERType(AssignmentList_t ass, Type_t *type, char *ideref);
void ExamineBERType_Boolean(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Integer(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Enumerated(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Real(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_BitString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_OctetString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_UTF8String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Null(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_EmbeddedPdv(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_External(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_ObjectIdentifier(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_BMPString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_GeneralString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_GraphicString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_IA5String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_ISO646String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_NumericString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_PrintableString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_TeletexString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_T61String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_UniversalString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_VideotexString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_VisibleString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_UnrestrictedString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_GeneralizedTime(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_UTCTime(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_ObjectDescriptor(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Open(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_SequenceSet(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_SequenceSetOf(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Choice(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_InstanceOf(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Reference(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);

/* examine all types and extract informations needed for BER encoding */
void
ExamineBER(AssignmentList_t ass)
{
    Assignment_t *a;

    /* examine all assignments */
    for (a = ass; a; a = a->Next) {

	/* examine types */
	switch (a->Type) {
	case eAssignment_Type:
	    ExamineBERType(ass, a->U.Type.Type, GetName(a));
	    break;
	}
    }
}

/* extract some type informations needed for BER encoding */
void
ExamineBERType(AssignmentList_t ass, Type_t *type, char *ideref)
{
    BERTypeInfo_t *info;

    info = &type->BERTypeInfo;
    info->pPrivateDirectives = &type->PrivateDirectives;

    /* get tags to en-/decode */
    if (IsReferenceType(type) && IsStructuredType(GetType(ass, type))) {
	info->Tags = type->Tags;
    } else {
	info->Tags = type->AllTags;
    }

    /* get the type to be examined */
    if (IsReferenceType(type) && !IsStructuredType(GetType(ass, type)))
	type = GetType(ass, type);

    /* initialize the BER informations */
    info->Identifier = ideref;
    info->Rules = type->Rules;
    info->Flags = type->Flags;
    info->NOctets = 0;
    info->SubIdentifier = NULL;
    info->SubType = NULL;
    info->Data = eBERSTIData_Null;

    /* BER informations are type specific ... */
    switch (type->Type) {
    case eType_Boolean:
	ExamineBERType_Boolean(ass, type, info);
	break;
    case eType_Integer:
	ExamineBERType_Integer(ass, type, info);
	break;
    case eType_Enumerated:
	ExamineBERType_Enumerated(ass, type, info);
	break;
    case eType_Real:
	ExamineBERType_Real(ass, type, info);
	break;
    case eType_BitString:
	ExamineBERType_BitString(ass, type, info);
	break;
    case eType_OctetString:
	ExamineBERType_OctetString(ass, type, info);
	break;
    case eType_UTF8String:
	ExamineBERType_UTF8String(ass, type, info);
	break;
    case eType_Null:
	ExamineBERType_Null(ass, type, info);
	break;
    case eType_EmbeddedPdv:
	ExamineBERType_EmbeddedPdv(ass, type, info);
	break;
    case eType_External:
	ExamineBERType_External(ass, type, info);
	break;
    case eType_ObjectIdentifier:
	ExamineBERType_ObjectIdentifier(ass, type, info);
	break;
    case eType_BMPString:
	ExamineBERType_BMPString(ass, type, info);
	break;
    case eType_GeneralString:
	ExamineBERType_GeneralString(ass, type, info);
	break;
    case eType_GraphicString:
	ExamineBERType_GraphicString(ass, type, info);
	break;
    case eType_IA5String:
	ExamineBERType_IA5String(ass, type, info);
	break;
    case eType_ISO646String:
	ExamineBERType_ISO646String(ass, type, info);
	break;
    case eType_NumericString:
	ExamineBERType_NumericString(ass, type, info);
	break;
    case eType_PrintableString:
	ExamineBERType_PrintableString(ass, type, info);
	break;
    case eType_TeletexString:
	ExamineBERType_TeletexString(ass, type, info);
	break;
    case eType_T61String:
	ExamineBERType_T61String(ass, type, info);
	break;
    case eType_UniversalString:
	ExamineBERType_UniversalString(ass, type, info);
	break;
    case eType_VideotexString:
	ExamineBERType_VideotexString(ass, type, info);
	break;
    case eType_VisibleString:
	ExamineBERType_VisibleString(ass, type, info);
	break;
    case eType_CharacterString:
	ExamineBERType_UnrestrictedString(ass, type, info);
	break;
    case eType_GeneralizedTime:
	ExamineBERType_GeneralizedTime(ass, type, info);
	break;
    case eType_UTCTime:
	ExamineBERType_UTCTime(ass, type, info);
	break;
    case eType_ObjectDescriptor:
	ExamineBERType_ObjectDescriptor(ass, type, info);
	break;
    case eType_Open:
	ExamineBERType_Open(ass, type, info);
	break;
    case eType_Sequence:
    case eType_Set:
	ExamineBERType_SequenceSet(ass, type, info);
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	ExamineBERType_SequenceSetOf(ass, type, info);
	break;
    case eType_Choice:
	ExamineBERType_Choice(ass, type, info);
	break;
    case eType_InstanceOf:
	ExamineBERType_InstanceOf(ass, type, info);
	break;
    case eType_RestrictedString:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    case eType_Selection:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    case eType_Undefined:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    case eType_Reference:
	ExamineBERType_Reference(ass, type, info);
	break;
    case eType_FieldReference:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    }
}

/*
 * Description of the fields of BERTypeInfo_t:
 *   info.
 *	Identifier	complete name of the type
 *	Rules		encoding directive rules
 *	Flags		encoding flags
 *	NOctets		size of string characters/integer type
 *	Data		data type of value
 *	SubIdentifier	complete name of the subtype
 *	SubType		the subtype itself
 *	Tags		tag list of the type
 *
 * NOTES:
 *	The encoding is mostly controlled by following arguments:
 *	- Data, the type: one of:
 *	  eBERSTIData_Null, eBERSTIData_Boolean,
 *	  eBERSTIData_Integer, eBERSTIData_Unsigned,
 *	  eBERSTIData_Real, eBERSTIData_BitString, eBERSTIData_RZBBitString,
 *	  eBERSTIData_OctetString, eBERSTIData_SequenceOf, eBERSTIData_SetOf,
 *	  eBERSTIData_Sequence, eBERSTIData_Set, eBERSTIData_Choice,
 *	  eBERSTIData_ObjectIdentifier, eBERSTIData_ObjectIdEncoded, eBERSTIData_String,
 *	  eBERSTIData_ZeroString, eBERSTIData_Reference, eBERSTIData_External,
 *	  eBERSTIData_EmbeddedPdv, eBERSTIData_UnrestrictedString
 *
 *	Following arguments contain variable/function names in the generated
 *	code:
 *	- Identifier, the name of the current type
 *	- SubIdentifier, the name of the subtype
 *
 *	Following values require additional arguments:
 *	- Data == eBERSTIData_Reference
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 *	- Data == eBERSTIData_*String
 *	  -> NOctets, the size of the string characters
 *	- Data == eBERSTIData_Integer || Data == eBERSTIData_Unsigned ||
 *	  Data == eBERSTIData_Boolean || Data == eBERSTIData_Choice
 *	  -> NOctets, the size of the integer type
 *	- Data == eBERSTIData_SequenceOf || Data == eBERSTIData_SetOf
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 *	  -> Rule, the encoding directive rules
 */

/*
 * BOOLEAN:
 *
 *	Data == eBERSTIData_Boolean
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_Integer || dat == eBERSTIData_Unsigned ||
 *	  Data == eBERSTIData_Boolean || dat == eBERSTIData_Choice
 *	  -> NOctets, the size of the integer type
 */
void
ExamineBERType_Boolean(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_Boolean;
    info->NOctets = GetOctets(GetBooleanType());
}

/*
 * INTEGER:
 *
 *	Data == eBERSTIData_Integer ||
 *	Data == eBERSTIData_Unsigned
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_Integer || dat == eBERSTIData_Unsigned ||
 *	  Data == eBERSTIData_Boolean || dat == eBERSTIData_Choice
 *	  -> NOctets, the size of the integer type
 */
void
ExamineBERType_Integer(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    int32_t sign;

    /* calculate NOctets and Data depending on the used C-Type */
    info->NOctets = GetOctets(GetIntegerType(ass, type, &sign));
    info->Data = sign > 0 ? eBERSTIData_Unsigned : eBERSTIData_Integer;
}

/*
 * ENUMERATED:
 *
 *	Data == eBERSTIData_Integer ||
 *	Data == eBERSTIData_Unsigned
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_Integer || dat == eBERSTIData_Unsigned ||
 *	  Data == eBERSTIData_Boolean || dat == eBERSTIData_Choice
 *	  -> NOctets, the size of the integer type
 */
void
ExamineBERType_Enumerated(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    int32_t sign;

    /* calculate NOctets and Data depending on the used C-Type */
    info->NOctets = GetOctets(GetEnumeratedType(ass, type, &sign));
    info->Data = sign > 0 ? eBERSTIData_Unsigned : eBERSTIData_Integer;
}

/*
 * REAL:
 *
 *	Data == eBERSTIData_Real
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_Real(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->NOctets = GetOctets(GetRealType(type));
    info->Data = eBERSTIData_Real;
}

/*
 * BIT STRING:
 *
 *	Data == eBERSTIData_BitString ||
 *	Data == eBERSTIData_RZBBitString
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_BitString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    /* set Data to RZBBitString/BitString */
    if (type->U.BitString.NamedNumbers)
	info->Data = eBERSTIData_RZBBitString;
    else
	info->Data = eBERSTIData_BitString;
}

/*
 * OCTET STRING:
 *
 *	Data == eBERSTIData_OctetString
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_OctetString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    /* set Data to OctetString */
    info->Data = eBERSTIData_OctetString;
}

void
ExamineBERType_UTF8String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    /* set Data to UTF8String */
    info->Data = eBERSTIData_UTF8String;
}

/*
 * NULL:
 *
 *	Data == eBERSTIData_Null
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_Null(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_Null;
}

/*
 * EMBEDDED PDV:
 *
 *	Data == eBERSTIData_EmbeddedPdv
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_EmbeddedPdv(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_EmbeddedPdv;
}

/*
 * EXTERNAL:
 *
 *	Data == eBERSTIData_External
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_External(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_External;
}

/*
 * OBJECT IDENTIFIER:
 *
 *	Data == eBERSTIData_ObjectIdEncoded || eBERSTIData_ObjectIdentifier
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_ObjectIdentifier(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = type->PrivateDirectives.fOidPacked ? eBERSTIData_ObjectIdEncoded : eBERSTIData_ObjectIdentifier;
}

/*
 * *String:
 *
 *	Data == eBERSTIData_String ||
 *	Data == eBERSTIData_ZeroString
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_*String
 *	  -> NOctets, the size of the string characters
 */

void
ExamineBERType_BMPString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_GeneralString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_GraphicString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_IA5String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_ISO646String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_NumericString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_PrintableString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_TeletexString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t noctets, zero;

    GetStringType(ass, type, &noctets, &zero); // to make hack directives become effective
    info->Data = eBERSTIData_MultibyteString;
    info->NOctets = 1;
}

void
ExamineBERType_T61String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t noctets, zero;

    GetStringType(ass, type, &noctets, &zero); // to make hack directives become effective
    info->Data = eBERSTIData_MultibyteString;
    info->NOctets = 1;
}

void
ExamineBERType_UniversalString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_VideotexString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t noctets, zero;

    GetStringType(ass, type, &noctets, &zero); // to make hack directives become effective
    info->Data = eBERSTIData_MultibyteString;
    info->NOctets = 1;
}

void
ExamineBERType_VisibleString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

/*
 * CHARACTER STRING:
 *
 *	Data == eBERSTIData_UnrestrictedString
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_EmbeddedPdv ||
 *	  Data == eBERSTIData_UnrestrictedString
 *	  -> Identification, the identification of the type if the type
 *	     is constraint to fixed identification or syntaxes identification
 *	     with single value
 */
void
ExamineBERType_UnrestrictedString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_UnrestrictedString;
}

/*
 * GeneralizedTime:
 *
 *	Data == eBERSTIData_GeneralizedTime
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_GeneralizedTime(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_GeneralizedTime;
}

/*
 * UTCTime:
 *
 *	Data == eBERSTIData_UTCTime
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_UTCTime(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_UTCTime;
}

/*
 * ObjectDescriptor:
 *
 *	Data == eBERSTIData_ZeroString
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_ObjectDescriptor(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->NOctets = 1;
    info->Data = eBERSTIData_ZeroString;
}

/*
 * OpenType:
 *
 *	Data == eBERSTIData_Open
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_Open(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->NOctets = 1;
    info->Data = eBERSTIData_Open;
}

/*
 * SEQUENCE/SET:
 *
 *	Data == eBERSTIData_Sequence ||
 *	Data == eBERSTIData_Set
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_SequenceSet(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    Component_t *comp;
    NamedType_t *namedType;
    char idebuf[256];

    info->Data = (type->Type == eType_Sequence) ?
	eBERSTIData_Sequence : eBERSTIData_Set;

    /* examine types of components */
    for (comp = type->U.SSC.Components; comp; comp = comp->Next) {
	switch (comp->Type) {
	case eComponent_Normal:
	case eComponent_Optional:
	case eComponent_Default:
	    namedType = comp->U.NOD.NamedType;
	    sprintf(idebuf, "%s_%s", info->Identifier, namedType->Identifier);
	    ExamineBERType(ass, namedType->Type, strdup(idebuf));
	    break;
	}
    }
}

/*
 * SEQUENCE OF/SET OF:
 *
 *	Data == eBERSTIData_SequenceOf ||
 *	Data == eBERSTIData_SetOf
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_SequenceOf || dat == eBERSTIData_SetOf
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 *	  -> Rule, the encoding directive rules
 */
void
ExamineBERType_SequenceSetOf(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    char idebuf[256];

    /* set data type and Alignment */
    info->Data = (type->Type == eType_SequenceOf ?
	eBERSTIData_SequenceOf : eBERSTIData_SetOf);

    /* set SubType, SubIdentifier */
    info->SubType = type->U.SS.Type;
    info->SubIdentifier = GetTypeName(ass, info->SubType);

    /* examine subtype */
    sprintf(idebuf, "%s_%s", info->Identifier,
	type->Type == eType_SequenceOf ? "Sequence" : "Set");
    ExamineBERType(ass, type->U.SS.Type, strdup(idebuf));
}

/*
 * CHOICE:
 *
 *	Data == eBERSTIData_Choice
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_Integer || dat == eBERSTIData_Unsigned ||
 *	  Data == eBERSTIData_Boolean || dat == eBERSTIData_Choice
 *	  -> NOctets, the size of the integer type
 */
void
ExamineBERType_Choice(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    Component_t *comp;
    NamedType_t *namedType;
    char idebuf[256];

    info->NOctets = GetOctets(GetChoiceType(type));
    info->Data = eBERSTIData_Choice;

    /* examine types of alternatives */
    for (comp = type->U.SSC.Components; comp; comp = comp->Next) {
	switch (comp->Type) {
	case eComponent_Normal:
	    namedType = comp->U.NOD.NamedType;
	    sprintf(idebuf, "%s_%s", info->Identifier, namedType->Identifier);
	    ExamineBERType(ass, namedType->Type, strdup(idebuf));
	    break;
	}
    }
}

/*
 * INSTANCE OF:
 *
 *	Data == eBERSTIData_Sequence
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_InstanceOf(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    Component_t *comp;
    NamedType_t *namedType;
    char idebuf[256];

    info->Data = eBERSTIData_Sequence;

    /* examine types of components */
    for (comp = type->U.SSC.Components; comp; comp = comp->Next) {
	switch (comp->Type) {
	case eComponent_Normal:
	case eComponent_Optional:
	case eComponent_Default:
	    namedType = comp->U.NOD.NamedType;
	    sprintf(idebuf, "%s_%s", info->Identifier, namedType->Identifier);
	    ExamineBERType(ass, namedType->Type, strdup(idebuf));
	    break;
	}
    }
}

/*
 * Reference:
 *
 *	Data == eBERSTIData_Reference
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_Reference
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 */
void
ExamineBERType_Reference(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    Assignment_t *a;

    info->Data = eBERSTIData_Reference;
    a = GetAssignment(ass, FindAssignment(ass, eAssignment_Type,
	type->U.Reference.Identifier, type->U.Reference.Module));
    info->SubIdentifier = GetName(a);
    info->SubType = a->U.Type.Type;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\char.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"


/* check if a 16 bit character is a space */
int
ASN1is16space(ASN1char16_t c)
{
    return c == ' ' || c == '\t' || c == '\b' || c == '\f' || c == '\r' ||
	c == '\n' || c == '\v';
}

/* get length of a 16 bit string */
// lonchanc: lstrlenW()
int
ASN1str16len(ASN1char16_t *p)
{
    int len;

    for (len = 0; *p; p++)
	len++;
    return len;
}

/* check if a 32 bit character is a space */
int
ASN1is32space(ASN1char32_t c)
{
    return c == ' ' || c == '\t' || c == '\b' || c == '\f' || c == '\r' ||
	c == '\n' || c == '\v';
}

/* get length of a 32 bit string */
int
ASN1str32len(ASN1char32_t *p)
{
    int len;

    for (len = 0; *p; p++)
	len++;
    return len;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\builtin.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

Type_t *Builtin_Type_Null;
Type_t *Builtin_Type_Boolean;
Type_t *Builtin_Type_Integer;
Type_t *Builtin_Type_PositiveInteger;
Type_t *Builtin_Type_ObjectIdentifier;
Type_t *Builtin_Type_ObjectDescriptor;
Type_t *Builtin_Type_Open;
Type_t *Builtin_Type_BitString;
Type_t *Builtin_Type_OctetString;
Type_t *Builtin_Type_UTF8String;
Type_t *Builtin_Type_BMPString;
Type_t *Builtin_Type_GeneralString;
Type_t *Builtin_Type_GraphicString;
Type_t *Builtin_Type_IA5String;
Type_t *Builtin_Type_ISO646String;
Type_t *Builtin_Type_NumericString;
Type_t *Builtin_Type_PrintableString;
Type_t *Builtin_Type_TeletexString;
Type_t *Builtin_Type_T61String;
Type_t *Builtin_Type_UniversalString;
Type_t *Builtin_Type_VideotexString;
Type_t *Builtin_Type_VisibleString;
Type_t *Builtin_Type_CharacterString;
Type_t *Builtin_Type_GeneralizedTime;
Type_t *Builtin_Type_UTCTime;
Type_t *Builtin_Type_Real;
Type_t *Builtin_Type_External;
Type_t *Builtin_Type_EmbeddedPdv;
Value_t *Builtin_Value_Null;
Value_t *Builtin_Value_Integer_0;
Value_t *Builtin_Value_Integer_1;
Value_t *Builtin_Value_Integer_2;
Value_t *Builtin_Value_Integer_10;
ObjectClass_t *Builtin_ObjectClass_AbstractSyntax;
ObjectClass_t *Builtin_ObjectClass_TypeIdentifier;
ModuleIdentifier_t *Builtin_Module;
AssignmentList_t Builtin_Assignments;
AssignedObjIdList_t Builtin_ObjIds;

/* create a type with a given tag */
static Type_t *
NewTaggedType(Type_e type, TagType_e tag, uint32_t val)
{
    Type_t *ty;
    Tag_t *ta;
    Value_t *va;

    ty = NewType(type);
    ty->Tags = ta = NewTag(tag);
    ta->Tag = va = NewValue(NULL, Builtin_Type_Integer);
    intx_setuint32(&va->U.Integer.Value, val);
    return ty;
}

/* create a type with a given permitted alphabet constraint */
/* n is the number of character ranges, the lower and upper characters */
/* of these ranges will follow in the vararg list */
static Type_t *
NewTypeWithPermittedAlphabetConstraint(Type_e type, int n, ...)
{
    va_list args;
    Type_t *ty;
    Value_t *va;
    Constraint_t **cc;
    ElementSetSpec_t *s, **ss;
    char32_t lo, up;
    int i;

    va_start(args, n);

    /* create type with permitted alphabet constraint */
    ty = NewType(type);
    cc = &ty->Constraints;
    *cc = NewConstraint();
    (*cc)->Root = NewElementSetSpec(eElementSetSpec_SubtypeElement);
    (*cc)->Root->U.SubtypeElement.SubtypeElement =
	NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
    cc = &(*cc)->Root->U.SubtypeElement.SubtypeElement->
	U.PermittedAlphabet.Constraints;
    *cc = NewConstraint();
    ss = &(*cc)->Root;

    /* n character ranges will be needed */
    for (i = 0; i < n; i++) {

	/* get the lower and upper character of one range */
	lo = va_arg(args, char32_t);
	up = va_arg(args, char32_t);

	/* create an element set spec for this range */
	s = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	s->U.SubtypeElement.SubtypeElement =
	    NewSubtypeElement(eSubtypeElement_ValueRange);
	s->U.SubtypeElement.SubtypeElement->U.ValueRange.Lower.Flags = 0;
	s->U.SubtypeElement.SubtypeElement->U.ValueRange.Lower.Value = va =
	    NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value =
	    (char32_t *)malloc(sizeof(char32_t));
	*va->U.RestrictedString.Value.value = lo;
	s->U.SubtypeElement.SubtypeElement->U.ValueRange.Upper.Flags = 0;
	s->U.SubtypeElement.SubtypeElement->U.ValueRange.Upper.Value = va =
	    NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value =
	    (char32_t *)malloc(sizeof(char32_t));
	*va->U.RestrictedString.Value.value = up;

	/* setup for next range or last range */
	if (i < n - 1) {
	    *ss = NewElementSetSpec(eElementSetSpec_Union);
	    (*ss)->U.Union.Elements1 = s;
	    ss = &(*ss)->U.Union.Elements2;
	} else {
	    *ss = s;
	}
    }
    return ty;
}

/* initialize internally needed builtin types, values, information object */
/* classes and object identifier components */
void
InitBuiltin()
{
    Type_t *ty;
    Component_t *co1, *co2, *co3, *co4, *co5, *co6;
    Assignment_t *a;
    AssignedObjId_t *oi0, *oi1, *oi2, *oi0_0, *oi0_1, *oi0_2, *oi0_3, *oi0_4,
	*oi1_0, *oi1_2, *oi1_3, **oi;
    String_t *s1, *s2;
    int i;
    FieldSpec_t *fs1, *fs2, *fs3;
    Constraint_t *c;
    SubtypeElement_t *s;
    SyntaxSpec_t *sy1, *sy2, *sy3, *sy4, *sy5, *sy6, *sy7, *sy8;

    /* allocate a builtin module name */
    Builtin_Assignments = NULL;
    Builtin_Module = NewModuleIdentifier();
    Builtin_Module->Identifier = "<Internal>";

    /* allocate basic ASN.1 types */
    Builtin_Type_Null = NewType(eType_Null);
    Builtin_Type_Boolean = NewType(eType_Boolean);
    Builtin_Type_Integer = NewType(eType_Integer);
    Builtin_Type_ObjectIdentifier = NewType(eType_ObjectIdentifier);
    Builtin_Type_Open = NewType(eType_Open);
    Builtin_Type_BitString = NewType(eType_BitString);
    Builtin_Type_OctetString = NewType(eType_OctetString);
    Builtin_Type_UTF8String = NewType(eType_UTF8String);
    Builtin_Type_ObjectDescriptor = NewTypeWithPermittedAlphabetConstraint(
	eType_ObjectDescriptor, 1, 0x00, 0xff);
    Builtin_Type_BMPString = NewTypeWithPermittedAlphabetConstraint(
	eType_BMPString, 1, 0x0000, 0xffff);
    Builtin_Type_GeneralString = NewTypeWithPermittedAlphabetConstraint(
	eType_GeneralString, 1, 0x00, 0xff);
    Builtin_Type_GraphicString = NewTypeWithPermittedAlphabetConstraint(
	eType_GraphicString, 1, 0x00, 0xff);
    Builtin_Type_IA5String = NewTypeWithPermittedAlphabetConstraint(
	eType_IA5String, 1, 0x00, 0x7f);
    Builtin_Type_ISO646String = NewTypeWithPermittedAlphabetConstraint(
	eType_ISO646String, 1, 0x20, 0x7e);
    Builtin_Type_NumericString = NewTypeWithPermittedAlphabetConstraint(
	eType_NumericString, 2, 0x20, 0x20, 0x30, 0x39);
    Builtin_Type_PrintableString = NewTypeWithPermittedAlphabetConstraint(
	eType_PrintableString, 7, 0x20, 0x20, 0x27, 0x29, 0x2b, 0x3a,
	0x3d, 0x3d, 0x3f, 0x3f, 0x41, 0x5a, 0x61, 0x7a);
    Builtin_Type_TeletexString = NewTypeWithPermittedAlphabetConstraint(
	eType_TeletexString, 1, 0x00, 0xff);
    Builtin_Type_T61String = NewTypeWithPermittedAlphabetConstraint(
	eType_T61String, 1, 0x00, 0xff);
    Builtin_Type_UniversalString = NewTypeWithPermittedAlphabetConstraint(
	eType_UniversalString, 1, 0x00000000, 0xffffffff);
    Builtin_Type_VideotexString = NewTypeWithPermittedAlphabetConstraint(
	eType_VideotexString, 1, 0x00, 0xff);
    Builtin_Type_VisibleString = NewTypeWithPermittedAlphabetConstraint(
	eType_VisibleString, 1, 0x20, 0x7e);
    Builtin_Type_GeneralizedTime = NewTypeWithPermittedAlphabetConstraint(
	eType_GeneralizedTime, 1, 0x20, 0x7e);
    Builtin_Type_UTCTime = NewTypeWithPermittedAlphabetConstraint(
	eType_UTCTime, 1, 0x20, 0x7e);

    /* allocate basic ASN.1 values */
    Builtin_Value_Null = NewValue(NULL, Builtin_Type_Null);
    Builtin_Value_Integer_0 = NewValue(NULL, Builtin_Type_Integer);
    intx_setuint32(&Builtin_Value_Integer_0->U.Integer.Value, 0);
    Builtin_Value_Integer_1 = NewValue(NULL, Builtin_Type_Integer);
    intx_setuint32(&Builtin_Value_Integer_1->U.Integer.Value, 1);
    Builtin_Value_Integer_2 = NewValue(NULL, Builtin_Type_Integer);
    intx_setuint32(&Builtin_Value_Integer_2->U.Integer.Value, 2);
    Builtin_Value_Integer_10 = NewValue(NULL, Builtin_Type_Integer);
    intx_setuint32(&Builtin_Value_Integer_10->U.Integer.Value, 10);

    /* allocate a positive integer type */
    Builtin_Type_PositiveInteger = NewType(eType_Integer);
    Builtin_Type_PositiveInteger->Constraints = c = NewConstraint();
    c->Root = NewElementSetSpec(eElementSetSpec_SubtypeElement);
    c->Root->U.SubtypeElement.SubtypeElement = s =
	NewSubtypeElement(eSubtypeElement_ValueRange);
    s->U.ValueRange.Lower.Flags = 0;
    s->U.ValueRange.Lower.Value = Builtin_Value_Integer_0;
    s->U.ValueRange.Upper.Flags = eEndPoint_Max;

#ifndef NO_BUILTIN
    /* REAL */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    co3 = co2->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Integer, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("mantissa", ty);
    ty = NewTaggedType(eType_Integer, eTagType_Implicit, 1);
    ty->Constraints = c = NewConstraint();
    c->Root = NewElementSetSpec(eElementSetSpec_Union);
    c->Root->U.Union.Elements1 =
	NewElementSetSpec(eElementSetSpec_SubtypeElement);
    c->Root->U.Union.Elements1->U.SubtypeElement.SubtypeElement = s =
	NewSubtypeElement(eSubtypeElement_SingleValue);
    s->U.SingleValue.Value = Builtin_Value_Integer_2;
    c->Root->U.Union.Elements2 =
	NewElementSetSpec(eElementSetSpec_SubtypeElement);
    c->Root->U.Union.Elements2->U.SubtypeElement.SubtypeElement = s =
	NewSubtypeElement(eSubtypeElement_SingleValue);
    s->U.SingleValue.Value = Builtin_Value_Integer_10;
    co2->U.Normal.NamedType = NewNamedType("base", ty);
    ty = NewTaggedType(eType_Integer, eTagType_Implicit, 2);
    co3->U.Normal.NamedType = NewNamedType("exponent", ty);
    Builtin_Type_Real = NewType(eType_Real);
    Builtin_Type_Real->U.Real.Components = co1;

    /* EXTERNAL.identification.syntaxes */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("abstract", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 1);
    co2->U.Normal.NamedType = NewNamedType("transfer", ty);
    ty = NewType(eType_Sequence);
    ty->U.Sequence.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "<ASN1external_identification_syntaxes_t>";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EXTERNAL.identification.context-negotiation */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Integer, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("presentation-context-id", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 1);
    co2->U.Normal.NamedType = NewNamedType("transfer-syntax", ty);
    ty = NewType(eType_Sequence);
    ty->U.Sequence.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1external_identification_context_negotiation_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EXTERNAL.identification */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    co3 = co2->Next = NewComponent(eComponent_Normal);
    co4 = co3->Next = NewComponent(eComponent_Normal);
    co5 = co4->Next = NewComponent(eComponent_Normal);
    co6 = co5->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Reference, eTagType_Explicit, 0);
    ty->U.Reference.Identifier = "<ASN1external_identification_syntaxes_t>";
    ty->U.Reference.Module = Builtin_Module;
    co1->U.Normal.NamedType = NewNamedType("<syntaxes>", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Explicit, 1);
    co2->U.Normal.NamedType = NewNamedType("syntax", ty);
    ty = NewTaggedType(eType_Integer, eTagType_Explicit, 2);
    co3->U.Normal.NamedType = NewNamedType("presentation-context-id", ty);
    ty = NewTaggedType(eType_Reference, eTagType_Explicit, 3);
    ty->U.Reference.Identifier =
	"ASN1external_identification_context_negotiation_t";
    ty->U.Reference.Module = Builtin_Module;
    co4->U.Normal.NamedType = NewNamedType("context-negotiation", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Explicit, 4);
    co5->U.Normal.NamedType = NewNamedType("<transfer-syntax>", ty);
    ty = NewTaggedType(eType_Null, eTagType_Explicit, 5);
    co6->U.Normal.NamedType = NewNamedType("<fixed>", ty);
    ty = NewType(eType_Choice);
    ty->U.Choice.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1external_identification_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EXTERNAL.data-value */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Open, eTagType_Explicit, 0);
    co1->U.Normal.NamedType = NewNamedType("notation", ty);
    ty = NewTaggedType(eType_BitString, eTagType_Explicit, 1);
    co2->U.Normal.NamedType = NewNamedType("encoded", ty);
    ty = NewType(eType_Choice);
    ty->U.Choice.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1external_data_value_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EXTERNAL */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Optional);
    co3 = co2->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Reference, eTagType_Implicit, 0);
    ty->U.Reference.Identifier = "ASN1external_identification_t";
    ty->U.Reference.Module = Builtin_Module;
    co1->U.Normal.NamedType = NewNamedType("identification", ty);
    ty = NewTaggedType(eType_ObjectDescriptor, eTagType_Implicit, 1);
    co2->U.Optional.NamedType = NewNamedType("data-value-descriptor", ty);
    ty = NewTaggedType(eType_Reference, eTagType_Implicit, 2);
    ty->U.Reference.Identifier = "ASN1external_data_value_t";
    ty->U.Reference.Module = Builtin_Module;
    co3->U.Normal.NamedType = NewNamedType("data-value", ty);
    Builtin_Type_External = NewType(eType_External);
    Builtin_Type_External->U.External.Components = co1;
    Builtin_Type_External->U.External.Optionals = 1;

    /* EMBEDDED PDV.identification.syntaxes */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("abstract", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 1);
    co2->U.Normal.NamedType = NewNamedType("transfer", ty);
    ty = NewType(eType_Sequence);
    ty->U.Sequence.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1embeddedpdv_identification_syntaxes_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EMBEDDED PDV.identification.context-negotiation */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Integer, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("presentation-context-id", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 1);
    co2->U.Normal.NamedType = NewNamedType("transfer-syntax", ty);
    ty = NewType(eType_Sequence);
    ty->U.Sequence.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1embeddedpdv_identification_context_negotiation_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EMBEDDED PDV.identification */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    co3 = co2->Next = NewComponent(eComponent_Normal);
    co4 = co3->Next = NewComponent(eComponent_Normal);
    co5 = co4->Next = NewComponent(eComponent_Normal);
    co6 = co5->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Reference, eTagType_Explicit, 0);
    ty->U.Reference.Identifier = "ASN1embeddedpdv_identification_syntaxes_t";
    ty->U.Reference.Module = Builtin_Module;
    co1->U.Normal.NamedType = NewNamedType("syntaxes", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Explicit, 1);
    co2->U.Normal.NamedType = NewNamedType("syntax", ty);
    ty = NewTaggedType(eType_Integer, eTagType_Explicit, 2);
    co3->U.Normal.NamedType = NewNamedType("presentation-context-id", ty);
    ty = NewTaggedType(eType_Reference, eTagType_Explicit, 3);
    ty->U.Reference.Identifier =
	"ASN1embeddedpdv_identification_context_negotiation_t";
    ty->U.Reference.Module = Builtin_Module;
    co4->U.Normal.NamedType = NewNamedType("context-negotiation", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Explicit, 4);
    co5->U.Normal.NamedType = NewNamedType("transfer-syntax", ty);
    ty = NewTaggedType(eType_Null, eTagType_Explicit, 5);
    co6->U.Normal.NamedType = NewNamedType("fixed", ty);
    ty = NewType(eType_Choice);
    ty->U.Choice.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1embeddedpdv_identification_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EMBEDDED PDV.data-value */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Open, eTagType_Explicit, 0);
    co1->U.Normal.NamedType = NewNamedType("notation", ty);
    ty = NewTaggedType(eType_BitString, eTagType_Explicit, 1);
    co2->U.Normal.NamedType = NewNamedType("encoded", ty);
    ty = NewType(eType_Choice);
    ty->U.Choice.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1embeddedpdv_data_value_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EMBEDDED PDV */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Reference, eTagType_Implicit, 0);
    ty->U.Reference.Identifier = "ASN1embeddedpdv_identification_t";
    ty->U.Reference.Module = Builtin_Module;
    co1->U.Normal.NamedType = NewNamedType("identification", ty);
    ty = NewTaggedType(eType_Reference, eTagType_Implicit, 2);
    ty->U.Reference.Identifier = "ASN1embeddedpdv_data_value_t";
    ty->U.Reference.Module = Builtin_Module;
    co2->U.Normal.NamedType = NewNamedType("data-value", ty);
    Builtin_Type_EmbeddedPdv = NewType(eType_EmbeddedPdv);
    Builtin_Type_EmbeddedPdv->U.EmbeddedPdv.Components = co1;

    /* CHARACTER STRING.identification.syntaxes */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("abstract", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 1);
    co2->U.Normal.NamedType = NewNamedType("transfer", ty);
    ty = NewType(eType_Sequence);
    ty->U.Sequence.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1characterstring_identification_syntaxes_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* CHARACTER STRING.identification.context-negotiation */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Integer, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("presentation-context-id", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 1);
    co2->U.Normal.NamedType = NewNamedType("transfer-syntax", ty);
    ty = NewType(eType_Sequence);
    ty->U.Sequence.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1characterstring_identification_context_negotiation_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* CHARACTER STRING.identification */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    co3 = co2->Next = NewComponent(eComponent_Normal);
    co4 = co3->Next = NewComponent(eComponent_Normal);
    co5 = co4->Next = NewComponent(eComponent_Normal);
    co6 = co5->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Reference, eTagType_Explicit, 0);
    ty->U.Reference.Identifier = "ASN1characterstring_identification_syntaxes_t";
    ty->U.Reference.Module = Builtin_Module;
    co1->U.Normal.NamedType = NewNamedType("syntaxes", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Explicit, 1);
    co2->U.Normal.NamedType = NewNamedType("syntax", ty);
    ty = NewTaggedType(eType_Integer, eTagType_Explicit, 2);
    co3->U.Normal.NamedType = NewNamedType("presentation-context-id", ty);
    ty = NewTaggedType(eType_Reference, eTagType_Explicit, 3);
    ty->U.Reference.Identifier =
	"ASN1characterstring_identification_context_negotiation_t";
    ty->U.Reference.Module = Builtin_Module;
    co4->U.Normal.NamedType = NewNamedType("context-negotiation", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Explicit, 4);
    co5->U.Normal.NamedType = NewNamedType("transfer-syntax", ty);
    ty = NewTaggedType(eType_Null, eTagType_Explicit, 5);
    co6->U.Normal.NamedType = NewNamedType("fixed", ty);
    ty = NewType(eType_Choice);
    ty->U.Choice.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1characterstring_identification_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* CHARACTER STRING.data-value */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Open, eTagType_Explicit, 0);
    co1->U.Normal.NamedType = NewNamedType("notation", ty);
    ty = NewTaggedType(eType_OctetString, eTagType_Explicit, 1);
    co2->U.Normal.NamedType = NewNamedType("encoded", ty);
    ty = NewType(eType_Choice);
    ty->U.Choice.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1characterstring_data_value_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* CHARACTER STRING */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Reference, eTagType_Implicit, 0);
    ty->U.Reference.Identifier = "ASN1characterstring_identification_t";
    ty->U.Reference.Module = Builtin_Module;
    co1->U.Normal.NamedType = NewNamedType("identification", ty);
    ty = NewTaggedType(eType_Reference, eTagType_Implicit, 2);
    ty->U.Reference.Identifier = "ASN1characterstring_data_value_t";
    ty->U.Reference.Module = Builtin_Module;
    co2->U.Normal.NamedType = NewNamedType("data-value", ty);
    Builtin_Type_CharacterString = NewType(eType_CharacterString);
    Builtin_Type_CharacterString->U.CharacterString.Components = co1;

    /* ABSTRACT-SYNTAX */
    fs1 = NewFieldSpec(eFieldSpec_FixedTypeValue);
    fs2 = fs1->Next = NewFieldSpec(eFieldSpec_Type);
    fs3 = fs2->Next = NewFieldSpec(eFieldSpec_FixedTypeValue);
    fs1->Identifier = "&id";
    fs1->U.FixedTypeValue.Type = Builtin_Type_ObjectIdentifier;
    fs1->U.FixedTypeValue.Unique = 1;
    fs1->U.FixedTypeValue.Optionality = NewOptionality(eOptionality_Normal);
    fs2->Identifier = "&Type";
    fs2->U.Type.Optionality = NewOptionality(eOptionality_Normal);
    fs3->U.FixedTypeValue.Type = ty = NewType(eType_BitString);
    ty->U.BitString.NamedNumbers = NewNamedNumber(eNamedNumber_Normal);
    ty->U.BitString.NamedNumbers->U.Normal.Identifier =
	"handles-invalid-encodings";
    ty->U.BitString.NamedNumbers->U.Normal.Value = Builtin_Value_Integer_0;
    fs3->U.FixedTypeValue.Optionality =
	NewOptionality(eOptionality_Default_Value);
    fs3->U.FixedTypeValue.Optionality->U.Value = NewValue(NULL, ty);
    sy1 = NewSyntaxSpec(eSyntaxSpec_Field);
    sy2 = sy1->Next = NewSyntaxSpec(eSyntaxSpec_Literal);
    sy3 = sy2->Next = NewSyntaxSpec(eSyntaxSpec_Literal);
    sy4 = sy3->Next = NewSyntaxSpec(eSyntaxSpec_Field);
    sy5 = sy4->Next = NewSyntaxSpec(eSyntaxSpec_Optional);
    sy6 = sy5->U.Optional.SyntaxSpec = NewSyntaxSpec(eSyntaxSpec_Literal);
    sy7 = sy6->Next = NewSyntaxSpec(eSyntaxSpec_Literal);
    sy8 = sy7->Next = NewSyntaxSpec(eSyntaxSpec_Field);
    sy1->U.Field.Field = "&Type";
    sy2->U.Literal.Literal = "IDENTIFIED";
    sy3->U.Literal.Literal = "BY";
    sy4->U.Field.Field = "&id";
    sy6->U.Literal.Literal = "HAS";
    sy7->U.Literal.Literal = "PROPERTY";
    sy8->U.Field.Field = "&property";
    Builtin_ObjectClass_AbstractSyntax =
	NewObjectClass(eObjectClass_ObjectClass);
    Builtin_ObjectClass_AbstractSyntax->U.ObjectClass.FieldSpec = fs1;
    Builtin_ObjectClass_AbstractSyntax->U.ObjectClass.SyntaxSpec = sy1;
    
    /* TYPE-IDENTIFIER */
    fs1 = NewFieldSpec(eFieldSpec_FixedTypeValue);
    fs2 = fs1->Next = NewFieldSpec(eFieldSpec_Type);
    fs1->Identifier = "&id";
    fs1->U.FixedTypeValue.Type = Builtin_Type_ObjectIdentifier;
    fs1->U.FixedTypeValue.Unique = 1;
    fs1->U.FixedTypeValue.Optionality = NewOptionality(eOptionality_Normal);
    fs2->Identifier = "&Type";
    fs2->U.Type.Optionality = NewOptionality(eOptionality_Normal);
    sy1 = NewSyntaxSpec(eSyntaxSpec_Field);
    sy2 = sy1->Next = NewSyntaxSpec(eSyntaxSpec_Literal);
    sy3 = sy2->Next = NewSyntaxSpec(eSyntaxSpec_Literal);
    sy4 = sy3->Next = NewSyntaxSpec(eSyntaxSpec_Field);
    sy1->U.Field.Field = "&Type";
    sy2->U.Literal.Literal = "IDENTIFIED";
    sy3->U.Literal.Literal = "BY";
    sy4->U.Field.Field = "&id";
    Builtin_ObjectClass_TypeIdentifier =
	NewObjectClass(eObjectClass_ObjectClass);
    Builtin_ObjectClass_TypeIdentifier->U.ObjectClass.FieldSpec = fs1;
    Builtin_ObjectClass_TypeIdentifier->U.ObjectClass.SyntaxSpec = sy1;
#endif
    
    /* object identifiers components */

#ifndef NO_OBJID
    Builtin_ObjIds = oi0 = NewAssignedObjId();
    oi0->Next = oi1 = NewAssignedObjId();
    oi1->Next = oi2 = NewAssignedObjId();

    /* { itu-t(0) }, { ccitt(0) } */
    oi0->Number = 0;
    oi0->Names = s1 = NewString();
    s1->Next = s2 = NewString();
    s1->String = "itu-t";
    s2->String = "ccitt";

    /* { iso(1) } */
    oi1->Number = 1;
    oi1->Names = s1 = NewString();
    s1->String = "iso";

    /* { joint-iso-itu-t(2) }, { joint-iso-ccitt(2) } */
    oi2->Number = 2;
    oi2->Names = s1 = NewString();
    s1->Next = s2 = NewString();
    s1->String = "joint-iso-itu-t";
    s2->String = "joint-iso-ccitt";

    oi0->Child = oi0_0 = NewAssignedObjId();
    oi0_0->Next = oi0_1 = NewAssignedObjId();
    oi0_1->Next = oi0_2 = NewAssignedObjId();
    oi0_2->Next = oi0_3 = NewAssignedObjId();
    oi0_3->Next = oi0_4 = NewAssignedObjId();

    /* { itu-t recommendation(0) } */
    oi0_0->Number = 0;
    oi0_0->Names = s1 = NewString();
    s1->String = "recommendation";

    /* { itu-t question(1) } */
    oi0_1->Number = 1;
    oi0_1->Names = s1 = NewString();
    s1->String = "question";

    /* { itu-t administration(2) } */
    oi0_2->Number = 2;
    oi0_2->Names = s1 = NewString();
    s1->String = "administration";

    /* { itu-t network-operator(3) } */
    oi0_3->Number = 3;
    oi0_3->Names = s1 = NewString();
    s1->String = "network-operator";

    /* { itu-t identified-organization(4) } */
    oi0_4->Number = 4;
    oi0_4->Names = s1 = NewString();
    s1->String = "identified-organization";

    /* { itu-t recommendation a(1) } .. { itu-t recommendation z(26) } */
    oi = &oi0_0->Child;
    for (i = 'a'; i <= 'z'; i++) {
	*oi = NewAssignedObjId();
	(*oi)->Number = i - 'a' + 1;
	(*oi)->Names = s1 = NewString();
	s1->String = (char *)malloc(2);
	s1->String[0] = (char)i;
	s1->String[1] = 0;
	oi = &(*oi)->Next;
    }

    oi1->Child = oi1_0 = NewAssignedObjId();
    oi1_0->Next = oi1_2 = NewAssignedObjId();
    oi1_2->Next = oi1_3 = NewAssignedObjId();

    /* { iso standard(0) } */
    oi1_0->Number = 0;
    oi1_0->Names = s1 = NewString();
    s1->String = "standard";

    /* { iso member-body(2) } */
    oi1_2->Number = 2;
    oi1_2->Names = s1 = NewString();
    s1->String = "member-body";

    /* { iso identified-organization(3) } */
    oi1_3->Number = 3;
    oi1_3->Names = s1 = NewString();
    s1->String = "identified-organization";
#endif

    /* initialize ASN1-CHARACTER-MODULE */
    InitBuiltinASN1CharacterModule();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\asn1.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

#ifndef HAS_GETOPT
extern int getopt(int argc, char **argv, const char *opts);
extern char *optarg;
extern int optind;
#endif

int pass;

/* if ForceAllTypes is set, asn1c will generate encoding functions for */
/* all types (default: only for sequence/set/choice/sequence of/set of) */
int ForceAllTypes = 0;

/* type to use for unconstrained integers/semiconstrained signed integers */
char *IntegerRestriction = "ASN1int32_t";

/* type to use for semiconstrained unsigned integers */
char *UIntegerRestriction = "ASN1uint32_t";

/* type to use for real */
char *RealRestriction = "double";

/* output language */
Language_e g_eProgramLanguage = eLanguage_C;

/* alignment of encoding */
Alignment_e Alignment = eAlignment_Aligned;

/* encoding to generate code for */
Encoding_e g_eEncodingRule = eEncoding_Packed;

/* subencoding to generate code for */
SubEncoding_e g_eSubEncodingRule = eSubEncoding_Basic;

/* target compiler supports 64 bit integers */
int Has64Bits = 0;

/* zero out allocated buffers for decoded data */
int g_fDecZeroMemory = 1;

/* debug module name */
int g_nDbgModuleName = 0;

/* source file and header file pointers */
FILE *g_finc, *g_fout;

// default tag type in this module
TagType_e g_eDefTagType = eTagType_Unknown;

/* original main module name without postfixed _Module */
char *g_pszOrigModuleName = NULL;
char *g_pszOrigModuleNameLowerCase = NULL;

/* enable long name (prefixed with module name for imported) */
int g_fLongNameForImported = 0;

// extra struct type name postfixed with _s, and its original name is its pointer type.
int g_fExtraStructPtrTypeSS = 0;

// the default structure type for Sequence Of and Set Of
TypeRules_e g_eDefTypeRuleSS_NonSized = eTypeRules_SinglyLinkedList;
TypeRules_e g_eDefTypeRuleSS_Sized = eTypeRules_FixedArray;

// ignore the assertion
int g_fNoAssert = 0;

// object identifier is 16-node array
int g_fOidArray = 0;

// case based optimizer switch
int g_fCaseBasedOptimizer = 1;

// enable in-file directive
int g_fMicrosoftExtensions = 1;

// all platforms: little endian (default) and big endian
int g_fAllEndians = 0;

// directive begin, end, AND
int g_chDirectiveBegin = '#';
int g_chDirectiveEnd = '#';
int g_chDirectiveAND = '&';

// postfix
char *g_pszApiPostfix = "ID";
char *g_pszChoicePostfix = "choice";
char *g_pszOptionPostfix = "option";

// option value
char *g_pszOptionValue = "option_bits";

// invisble file array
int g_cGhostFiles = 0;
GhostFile_t g_aGhostFiles[16];

int _cdecl main(int argc, char **argv)
{
    FILE *finc, *fout;
    char *p;
    int c, chInvalidDir;
    LLSTATE in, out;
    UndefinedSymbol_t *lastundef;
    Assignment_t *a, **aa;
    LLTERM *tokens;
    unsigned ntokens;
    int fSupported;
    char *psz;
    char incfilename[256], outfilename[256], module[256];

    /* parse options */
    // if an option is followed by ':', then it has a parameter.
    while ((c = getopt(argc, argv, "ab:c:d:e:fg:hil:mn:o:p:q:s:t:uv:wy")) != EOF)
    {
        chInvalidDir = 0;
        switch (c)
        {
        case 'a':

            /* enable for all platforms: little endian and big endian */
            g_fAllEndians = 1;
            break;

        case 'b':

            /* maximum number of bits of target machine */
            if (atoi(optarg) == 32) {
                Has64Bits = 0;
                break;
            }
            if (atoi(optarg) == 64) {
                Has64Bits = 1;
                break;
            }
            fprintf(stderr, "Bad number of bits specified.\n");
            MyExit(1);
            /*NOTREACHED*/

        case 'c':

            // Choice postfix
            psz = strdup(optarg);
            if (psz && isalpha(*psz))
            {
                g_pszChoicePostfix = psz;
            }
            break;

        case 'd':

            // sequence of and set of data structure types
            if (! stricmp(optarg, "linked") || ! stricmp(optarg, "slinked"))
            {
                g_eDefTypeRuleSS_NonSized = eTypeRules_SinglyLinkedList;
            }
            else
            if (! stricmp(optarg, "lenptr"))
            {
                g_eDefTypeRuleSS_NonSized = eTypeRules_LengthPointer;
            }
            else
            if (! stricmp(optarg, "dlinked"))
            {
                g_eDefTypeRuleSS_NonSized = eTypeRules_DoublyLinkedList;
            }
            else
            {
                goto usage;
            }
            break;

        case 'e':

            /* encoding to generate code for */
            if (!stricmp(optarg, "packed"))
            {
                g_eEncodingRule = eEncoding_Packed;
            }
            else
            if (!stricmp(optarg, "basic"))
            {
                g_eEncodingRule = eEncoding_Basic;
            }
            else
            if (!stricmp(optarg, "per"))
            {
                g_eEncodingRule = eEncoding_Packed;
                Alignment = eAlignment_Aligned;
            }
            else
            if (!stricmp(optarg, "cer"))
            {
                g_eEncodingRule = eEncoding_Basic;
                g_eSubEncodingRule = eSubEncoding_Canonical;
            }
            else
            if (!stricmp(optarg, "der"))
            {
                g_eEncodingRule = eEncoding_Basic;
                g_eSubEncodingRule = eSubEncoding_Distinguished;
            }
            else
            if (!stricmp(optarg, "ber"))
            {
                g_eEncodingRule = eEncoding_Basic;
                g_eSubEncodingRule = eSubEncoding_Basic;
            }
            else
            {
                fprintf(stderr, "Bad encoding specified.\n");
                fprintf(stderr, "Allowed encodings are:\n");
                fprintf(stderr, "- packed (default)\n");
                fprintf(stderr, "- basic\n");
                MyExit(1);
                /*NOTREACHED*/
            }
            break;

        case 'f':

            /* force generation of encoding/decoding functions for all types */
            ForceAllTypes = 1;
            break;

        case 'g':

            /* ghost asn1 files */
            g_aGhostFiles[g_cGhostFiles].pszFileName = strdup(optarg);
            g_aGhostFiles[g_cGhostFiles++].pszModuleName = NULL;
            break;

        case 'h':

            goto usage;

        case 'i':

            /* ignore assertion */
            g_fNoAssert = 1;
            break;

        case 'l':

            /* set output language */
            if (!stricmp(optarg, "c")) {
                g_eProgramLanguage = eLanguage_C;
                break;
            }
            if (!stricmp(optarg, "c++") || !stricmp(optarg, "cpp")) {
                g_eProgramLanguage = eLanguage_Cpp;
                break;
            }
            goto usage;

        case 'm':

            /* enable Microsoft extension */
            g_fMicrosoftExtensions = 1;
            break;

        case 'n':

            /* debug module name */
            g_nDbgModuleName = 0;
            {
                int len = strlen(optarg);
                if (len > 4)
                    len = 4;
                memcpy(&g_nDbgModuleName, optarg, len);
            }
            break;

        case 'o':

            // Option postfix
            psz = strdup(optarg);
            if (psz && isalpha(*psz))
            {
                g_pszOptionPostfix = psz;
            }
            break;

        case 'p':

            // API postfix
            psz = strdup(optarg);
            if (psz && isalpha(*psz))
            {
                g_pszApiPostfix = psz;
            }
            break;

        case 'q':

            // sequence of and set of data structure types
            if (! stricmp(optarg, "linked") || ! stricmp(optarg, "slinked"))
            {
                g_eDefTypeRuleSS_Sized = eTypeRules_SinglyLinkedList;
            }
            else
            if (! stricmp(optarg, "lenptr"))
            {
                g_eDefTypeRuleSS_Sized = eTypeRules_LengthPointer;
            }
            else
            if (! stricmp(optarg, "array"))
            {
                g_eDefTypeRuleSS_Sized = eTypeRules_FixedArray;
            }
            else
            if (! stricmp(optarg, "pointer"))
            {
                g_eDefTypeRuleSS_Sized = eTypeRules_PointerToElement | eTypeRules_FixedArray;
            }
            else
            if (! stricmp(optarg, "dlinked"))
            {
                g_eDefTypeRuleSS_Sized = eTypeRules_DoublyLinkedList;
            }
            else
            {
                goto usage;
            }
            break;

        case 's':

            /* set subencoding */
            if (!stricmp(optarg, "aligned"))
            {
                Alignment = eAlignment_Aligned;
            }
            else
            if (!stricmp(optarg, "unaligned"))
            {
                Alignment = eAlignment_Unaligned;
            }
            else
            if (!stricmp(optarg, "cer"))
            {
                g_eSubEncodingRule = eSubEncoding_Canonical;
            }
            else
            if (!stricmp(optarg, "der"))
            {
                g_eSubEncodingRule = eSubEncoding_Distinguished;
            }
            else
            if (!stricmp(optarg, "basic"))
            {
                g_eSubEncodingRule = eSubEncoding_Basic;
            }
            else
            {
                fprintf(stderr, "Bad sub-encoding specified.\n");
                fprintf(stderr, "Allowed sub-encodings are:\n");
                fprintf(stderr, "- aligned (default) or unaligned\n");
                fprintf(stderr, "- basic (default), cer or der\n");
                MyExit(1);
                /*NOTREACHED*/
            }
            break;

        case 't':

            /* specify type to use for unconstrained/semiconstrained types */
            p = strchr(optarg, '=');
            if (!p)
                goto usage;
            *p++ = 0;
            if (!stricmp(optarg, "integer")) {
                if (!stricmp(p, "ASN1int32_t")) {
                    IntegerRestriction = "ASN1int32_t";
                    break;
                }
                if (!stricmp(p, "ASN1uint32_t")) {
                    IntegerRestriction = "ASN1uint32_t";
                    break;
                }
                if (!stricmp(p, "ASN1int64_t")) {
                    IntegerRestriction = "ASN1int64_t";
                    break;
                }
                if (!stricmp(p, "ASN1uint64_t")) {
                    IntegerRestriction = "ASN1uint64_t";
                    break;
                }
                if (!stricmp(p, "ASN1intx_t")) {
                    IntegerRestriction = "ASN1intx_t";
                    break;
                }
            }
            if (!stricmp(optarg, "unsigned")) {
                if (!stricmp(p, "ASN1int32_t")) {
                    UIntegerRestriction = "ASN1int32_t";
                    break;
                }
                if (!stricmp(p, "ASN1uint32_t")) {
                    UIntegerRestriction = "ASN1uint32_t";
                    break;
                }
                if (!stricmp(p, "ASN1int64_t")) {
                    UIntegerRestriction = "ASN1int64_t";
                    break;
                }
                if (!stricmp(p, "ASN1uint64_t")) {
                    UIntegerRestriction = "ASN1uint64_t";
                    break;
                }
                if (!stricmp(p, "ASN1intx_t")) {
                    UIntegerRestriction = "ASN1intx_t";
                    break;
                }
            }
            if (!stricmp(optarg, "real")) {
                if (!stricmp(p, "double")) {
                    RealRestriction = "double";
                    break;
                }
                if (!stricmp(p, "ASN1real_t")) {
                    RealRestriction = "ASN1real_t";
                    break;
                }
            }
            goto usage;

        case 'u':

            // no case-based optimizer
            g_fCaseBasedOptimizer = 0;
            break;

        case 'v':

            // Option value
            psz = strdup(optarg);
            if (psz && isalpha(*psz))
            {
                g_pszOptionValue = psz;
            }
            break;

        case 'w':

            // --#OID ARRAY#--
            g_fOidArray = 1;
            break;

        case 'y':

            /* enable long name (prefixed with module name for imported) */
            g_fLongNameForImported = 1;
            break;

        default:

            chInvalidDir = c;

        usage:
            fprintf(stderr,"ASN.1 Compiler V1.0\n");
            fprintf(stderr, "Copyright (C) Microsoft Corporation, U.S.A., 1997-1998. All rights reserved.\n");
            fprintf(stderr, "Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved.\n");
            if (chInvalidDir)
            {
                fprintf(stderr, "Invalid option  -%c\n", chInvalidDir);
            }
            else
            {
                fprintf(stderr, "Usage: %s [options] [imported.asn1 ...] main.asn1\n", argv[0]);
                fprintf(stderr, "Options:\n");
                fprintf(stderr, "-h\t\tthis help\n");
                fprintf(stderr, "-z\t\tzero out allocated buffers for decoded data\n");
                fprintf(stderr, "-x\t\tbridge APIs\n");
                fprintf(stderr, "-a\t\textra type definition for structure\n");
                fprintf(stderr, "-n name\t\tmodule name for debugging purpose\n");
                // fprintf(stderr, "-l language\tgenerate code for <language> (c (default), c++)\n");
                // fprintf(stderr, "-b 64\t\tenable 64 bit support\n");
                fprintf(stderr, "-e encoding\tuse <encoding> as encoding rule\n");
                fprintf(stderr,     "\t\t(possible values: packed (default), basic)\n");
                fprintf(stderr, "-s subencoding\tuse <subencoding> as subencoding rules\n");
                fprintf(stderr,     "\t\t(possible values: aligned (default) or unaligned,\n");
                fprintf(stderr,     "\t\tbasic (default), canonical or distinguished)\n");
                fprintf(stderr, "-t type=rest.\trestrict/unrestrict a unconstrained/semiconstrained type:\n");
                fprintf(stderr,     "\t\tinteger=type\tuse <type> (ASN1[u]int32_t, ASN1[u]int64_t or\n\t\t\t\tASN1intx_t) for unconstrained integers\n\t\t\t\t(default: ASN1int32_t)\n");
                fprintf(stderr,     "\t\tunsigned=type\tuse <type> (ASN1[u]int32_t, ASN1[u]int64_t or\n\t\t\t\tASN1intx_t) for positive semiconstrained\n\t\t\t\tintegers (default: ASN1uint32_t)\n");
                fprintf(stderr,     "\t\treal=type\tuse <type> (double or ASN1real_t) for\n\t\t\t\tunconstrained floating point numbers\n\t\t\t\t(default: double)\n");
            }
            MyExit(1);
        }
    }

    /* check if any modules are given */
    if (argc < optind + 1)
        goto usage;

    /* check for unsupported encoding */
    fSupported = TRUE;
    if (g_eEncodingRule == eEncoding_Packed)
    {
        if (Alignment != eAlignment_Aligned || g_eSubEncodingRule != eSubEncoding_Basic)
        {
            fSupported = FALSE;
        }
    }
    else
    if (g_eEncodingRule == eEncoding_Basic)
    {
        // if (Alignment != eAlignment_Aligned || g_eSubEncodingRule == eSubEncoding_Distinguished)
        if (Alignment != eAlignment_Aligned)
        {
            fSupported = FALSE;
        }
    }
    if (! fSupported)
    {
        fprintf(stderr, "Encoding not implemented (yet)\n");
        MyExit(1);
    }

    /* initialize */
    InitBuiltin();

    /* scan file(s) */
#if defined(LLDEBUG) && LLDEBUG > 0
    pass = 1;
    fprintf(stderr, "Pass 1: Scanning input file\n");
#endif
    readfiles(argv + optind);
    llscanner(&tokens, &ntokens);

    /* setup initial state */
    in.Assignments = Builtin_Assignments;
    in.AssignedObjIds = Builtin_ObjIds;
    in.Undefined = NULL;
    in.BadlyDefined = NULL;
    in.Module = NULL;
    in.MainModule = NULL;
    in.Imported = NULL;
    in.TagDefault = eTagType_Unknown;
    in.ExtensionDefault = eExtensionType_None;
    lastundef = NULL;

    /* parse the modules */
    do {
#if defined(LLDEBUG) && LLDEBUG > 0
        fprintf(stderr, "Pass %d: Parsing                    \n", ++pass);
#endif

        /* parse modules */
        if (!llparser(tokens, ntokens, &in, &out)) {
            llprinterror(stderr);
            MyExit(1);
        }

        /* if undefined symbols remain the same as in previous pass */
        /* than print these undefined symbols and MyExit */
        if (!CmpUndefinedSymbolList(out.Assignments, out.Undefined, lastundef))
            UndefinedError(out.Assignments, out.Undefined, out.BadlyDefined);

        /* setup data for next pass */
        in = out;
        aa = &in.Assignments;
        for (a = Builtin_Assignments; a; a = a->Next) {
            *aa = DupAssignment(a);
            aa = &(*aa)->Next;
        }
        *aa = NewAssignment(eAssignment_NextPass);
        aa = &(*aa)->Next;
        *aa = out.Assignments;
        lastundef = out.Undefined;
        in.Undefined = NULL;
        in.BadlyDefined = NULL;

        /* continue parsing until no undefined symbols left */
    } while (lastundef);

    /* build internal information */
#if defined(LLDEBUG) && LLDEBUG > 0
    fprintf(stderr, "Pass %d: Building internal information                    \n", ++pass);
#endif
    Examination(&out.Assignments, out.MainModule);
    ExaminePER(out.Assignments);
    ExamineBER(out.Assignments);

    // remember who is the local duplicate of imported types
    for (a = out.Assignments; a; a = a->Next)
    {
        a->fImportedLocalDuplicate = IsImportedLocalDuplicate(out.Assignments, out.MainModule, a) ? 1 : 0;
    }

    /* create file names and open files */
#if defined(LLDEBUG) && LLDEBUG > 0
    fprintf(stderr, "Pass %d: Code generation                    \n", ++pass);
#endif

    // create module name
    StripModuleName(module, argv[argc - 1]);

    // create inc file and out file names
    strcpy(incfilename, module);
    strcat(incfilename, ".h");
    strcpy(outfilename, module);
    strcat(outfilename, ".c");
    for (p = module; *p; p++)
        *p = (char)toupper(*p);
    finc = fopen(incfilename, "w");
    if (!finc) {
        perror(incfilename);
        MyExit(1);
    }
    fout = fopen(outfilename, "w");
    if (!fout) {
        perror(outfilename);
        MyExit(1);
    }

    // lonchanc: change the full path name to file name only
    {
        char *psz = strrchr(module, '\\');
        if (psz)
        {
            strcpy(module, psz+1);
        }
    }

    // save the original module names
    g_pszOrigModuleName = strdup(module);
    g_pszOrigModuleNameLowerCase = strdup(module);
    {
        char *psz;
        for (psz = g_pszOrigModuleNameLowerCase; *psz; psz++)
        {
            *psz = (char)tolower(*psz);
        }
    }

    // lonchanc: append "_Module" to module name
    strcat(module, "_Module");

    /* code generation */
    g_finc = finc;
    g_fout = fout;
    GenInc(out.Assignments, finc, module);
    GenPrg(out.Assignments, fout, module, incfilename);

    setoutfile(finc);
    output("\n#ifdef __cplusplus\n");
    outputni("} /* extern \"C\" */\n");
    output("#endif\n\n");
    output("#endif /* _%s_H_ */\n", module);
    setoutfile(fout);

    /* finitialize */
    fclose(finc);
    fclose(fout);
#if defined(LLDEBUG) && LLDEBUG > 0
    fprintf(stderr, "Finished. \n");
#endif
    return 0;
}

/* why is this function not in MS libc? */
#ifndef HAS_GETOPT
char *optarg;
int optind = 1;
static int optpos = 1;

/* get the next option from the command line arguments */
int getopt(int argc, char **argv, const char *options) {
    char *p, *q;

    optarg = NULL;

    /* find start of next option */
    do {
        if (optind >= argc)
            return EOF;
        if (*argv[optind] != '-' && *argv[optind] != '/')
            return EOF;
        p = argv[optind] + optpos++;
        if (!*p) {
            optind++;
            optpos = 1;
        }
    } while (!*p);

    /* find option in option string */
    q = strchr(options, *p);
    if (!q)
        return '?';

    /* set optarg for parameterized option and adjust optind and optpos for next call */
    if (q[1] == ':') {
        if (p[1]) {
            optarg = p + 1;
            optind++;
            optpos = 1;
        } else if (++optind < argc) {
            optarg = argv[optind];
            optind++;
            optpos = 1;
        } else {
            return '?';
        }
    }

    /* return found option */
    return *p;
}
#endif


void StripModuleName(char *pszDst, char *pszSrc)
{
    strcpy(pszDst, pszSrc);
    if (!strcmp(pszDst + strlen(pszDst) - 5, ".asn1"))
        pszDst[strlen(pszDst) - 5] = 0;
    else if (!strcmp(pszDst + strlen(pszDst) - 4, ".asn"))
        pszDst[strlen(pszDst) - 4] = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\chrmodul.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

extern char32_t chrtab[];
ModuleIdentifier_t *Builtin_Character_Module;

void
InitBuiltinASN1CharacterModule()
{
	ModuleIdentifier_t *mid;
	Assignment_t *as;
	Value_t *va;
	Type_t *ty;
	Constraint_t *co;
	ElementSetSpec_t *es, **esp;
	SubtypeElement_t *se;

	Builtin_Character_Module = mid = NewModuleIdentifier();
	mid->Identifier = "ASN1-CHARACTER-MODULE";
	mid->ObjectIdentifier = NewValue(NULL, Builtin_Type_ObjectIdentifier);
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.length = 5;
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.value = (objectnumber_t *)malloc(5 * sizeof(objectnumber_t));
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.value[0] = 2;
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.value[1] = 1;
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.value[2] = 0;
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.value[3] = 0;
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.value[4] = 0;
#ifndef NO_CHRMODULE
	as = NewAssignment(eAssignment_ModuleIdentifier);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "<module>";
	as->Module = mid;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 0;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "nul";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 1;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "soh";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 2;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "stx";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 3;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "etx";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 4;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "eot";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 5;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "enq";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 6;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "ack";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 7;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "bel";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 8;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "bs";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 9;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "ht";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 10;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "lf";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 11;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "vt";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 12;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "ff";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 13;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "cr";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 14;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "so";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 15;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "si";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 16;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "dle";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 17;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "dc1";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 18;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "dc2";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 19;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "dc3";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 20;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "dc4";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 21;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "nak";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 22;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "syn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 23;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "etb";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 24;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "can";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 25;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "em";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 26;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "sub";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 27;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "esc";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 28;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "is4";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 29;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "is3";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 30;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "is2";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 31;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "is1";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 32;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "del";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 33;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "space";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 34;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "exclamationMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 35;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "quotationMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 36;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "numberSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 37;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "dollarSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 38;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "percentSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 39;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "ampersand";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 40;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "apostrophe";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 41;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "leftParenthesis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 42;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "rightParenthesis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 43;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "asterisk";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 44;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "plusSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 45;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "comma";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 46;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "hyphen-minus";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 47;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "fullStop";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 48;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "solidus";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 49;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitZero";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 50;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitOne";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 51;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitTwo";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 52;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitThree";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 53;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitFour";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 54;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitFive";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 55;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitSix";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 56;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitSeven";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 57;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitEight";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 58;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitNine";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 59;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "colon";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 60;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "semicolon";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 61;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "less-thanSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 62;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "equalsSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 63;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "greater-thanSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 64;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "questionMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 65;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "commercialAt";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 66;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterA";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 67;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterB";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 68;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterC";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 69;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterD";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 70;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterE";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 71;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterF";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 72;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterG";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 73;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterH";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 74;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterI";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 75;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterJ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 76;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterK";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 77;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterL";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 78;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterM";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 79;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterN";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 80;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterO";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 81;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterP";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 82;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterQ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 83;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterR";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 84;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterS";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 85;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterT";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 86;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterU";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 87;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterV";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 88;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterW";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 89;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterX";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 90;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterY";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 91;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterZ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 92;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "leftSquareBracket";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 93;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "reverseSolidus";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 94;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "rightSquareBracket";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 95;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "circumflexAccent";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 96;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "lowLine";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 97;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "graveAccent";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 98;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterA";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 99;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterB";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 100;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterC";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 101;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterD";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 102;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterE";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 103;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterF";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 104;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterG";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 105;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterH";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 106;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterI";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 107;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterJ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 108;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterK";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 109;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterL";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 110;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterM";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 111;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterN";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 112;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterO";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 113;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterP";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 114;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterQ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 115;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterR";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 116;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterS";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 117;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterT";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 118;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterU";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 119;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterV";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 120;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterW";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 121;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterX";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 122;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterY";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 123;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterZ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 124;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "leftCurlyBracket";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 125;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "verticalLine";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 126;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "rightCurlyBracket";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 127;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "tilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	ty = NewType(eType_BMPString);
	ty->Constraints = co = NewConstraint();
	co->Root = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
	se->U.PermittedAlphabet.Constraints = co = NewConstraint();
	esp = &co->Root;
	(*esp) = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_ValueRange);
	se->U.ValueRange.Lower.Flags = 0;
	se->U.ValueRange.Lower.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 33;
	se->U.ValueRange.Upper.Flags = 0;
	se->U.ValueRange.Upper.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 127;
	as = NewAssignment(eAssignment_Type);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "BasicLatin";
	as->Module = mid;
	as->U.Type.Type = ty;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 128;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "no-breakSpace";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 129;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "invertedExclamationMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 130;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "centSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 131;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "poundSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 132;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "currencySign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 133;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "yenSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 134;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "brokenBar";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 135;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "sectionSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 136;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "diaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 137;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "copyrightSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 138;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "feminineOrdinalIndicator";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 139;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "left-pointingDoubleAngleQuotationMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 140;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "notSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 141;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "softHyphen";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 142;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "registeredSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 143;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "macron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 144;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "degreeSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 145;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "plus-minusSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 146;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "superscriptTwo";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 147;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "superscriptThree";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 148;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "acuteAccent";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 149;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "microSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 150;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "pilcrowSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 151;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "middleDot";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 152;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "cedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 153;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "superscriptOne";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 154;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "masculineOrdinalIndicator";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 155;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "right-pointingDoubleAngleQuotationMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 156;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "vulgarFractionOneQuarter";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 157;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "vulgarFractionOneHalf";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 158;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "valgarFractionThreeQuarters";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 159;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "invertedQuestionMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 160;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 161;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 162;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 163;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 164;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 165;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithRingAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 166;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAe";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 167;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterCWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 168;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 169;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 170;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 171;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 172;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 173;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 174;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 175;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 176;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEth";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 177;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 178;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 179;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 180;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 181;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 182;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 183;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "multiplicationSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 184;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 185;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 186;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 187;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 188;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 189;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterYWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 190;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterThorn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 191;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterSharpS";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 192;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 193;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 194;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 195;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 196;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 197;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithRingAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 198;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAe";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 199;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterCWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 200;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 201;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 202;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 203;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 204;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 205;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 206;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 207;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 208;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEth";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 209;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 210;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 211;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 212;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 213;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 214;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 215;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "divisionSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 216;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 217;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 218;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 219;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 220;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 221;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterYWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 222;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterThorn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 223;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterYWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	ty = NewType(eType_BMPString);
	ty->Constraints = co = NewConstraint();
	co->Root = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
	se->U.PermittedAlphabet.Constraints = co = NewConstraint();
	esp = &co->Root;
	(*esp) = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_ValueRange);
	se->U.ValueRange.Lower.Flags = 0;
	se->U.ValueRange.Lower.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 128;
	se->U.ValueRange.Upper.Flags = 0;
	se->U.ValueRange.Upper.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 223;
	as = NewAssignment(eAssignment_Type);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "Latin-1Supplement";
	as->Module = mid;
	as->U.Type.Type = ty;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 224;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 225;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 226;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 227;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 228;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 229;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 230;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterCWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 231;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterCWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 232;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterCWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 233;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterCWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 234;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterCWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 235;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterCWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 236;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterCWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 237;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterCWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 238;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 239;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterDWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 240;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 241;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterDWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 242;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 243;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 244;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 245;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 246;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 247;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 248;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 249;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 250;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 251;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 252;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 253;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 254;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 255;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 256;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 257;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 258;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 259;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 260;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterHWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 261;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterHWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 262;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterHWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 263;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterHWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 264;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 265;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 266;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 267;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 268;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 269;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 270;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 271;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 272;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 273;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterDotlessI";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 274;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLigatureIj";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 275;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLigatureIj";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 276;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterJWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 277;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterJWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 278;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterKWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 279;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterKWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 280;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterKra";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 281;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 282;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 283;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 284;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 285;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 286;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 287;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLWithMiddleDot";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 288;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLWithMiddleDot";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 289;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 290;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 291;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 292;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 293;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 294;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 295;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 296;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 297;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNPrecededByApostrophe";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 298;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEng";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 299;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEng";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 300;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 301;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 302;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 303;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 304;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithDoubleAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 305;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithDoubleAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 306;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLigatureOe";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 307;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLigatureOe";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 308;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterRWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 309;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterRWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 310;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterRWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 311;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterRWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 312;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterRWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 313;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterRWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 314;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterSWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 315;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterSWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 316;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterSWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 317;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterSWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 318;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterSWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 319;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterSWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 320;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterSWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 321;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterSWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 322;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterTWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 323;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 324;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterTWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 325;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 326;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterTWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 327;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 328;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 329;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 330;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 331;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 332;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 333;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 334;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithRingAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 335;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithRingAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 336;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDoubleAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 337;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDoubleAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 338;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 339;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 340;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterWWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 341;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterWWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 342;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterYWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 343;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterYWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 344;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterYWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 345;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterZWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 346;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterZWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 347;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterZWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 348;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterZWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 349;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterZWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 350;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterZWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 351;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLongS";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	ty = NewType(eType_BMPString);
	ty->Constraints = co = NewConstraint();
	co->Root = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
	se->U.PermittedAlphabet.Constraints = co = NewConstraint();
	esp = &co->Root;
	(*esp) = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_ValueRange);
	se->U.ValueRange.Lower.Flags = 0;
	se->U.ValueRange.Lower.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 224;
	se->U.ValueRange.Upper.Flags = 0;
	se->U.ValueRange.Upper.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 351;
	as = NewAssignment(eAssignment_Type);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "LatinExtended-a";
	as->Module = mid;
	as->U.Type.Type = ty;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 352;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterBWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 353;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterBWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 354;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterBWithTopbar";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 355;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterBWithTopbar";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 356;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterToneSix";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 357;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterToneSix";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 358;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOpenO";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 359;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterCWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 360;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterCWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 361;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAfricanD";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 362;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 363;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDWithTopbar";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 364;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterDWithTopbar";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 365;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTurnedDelta";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 366;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterReverseE";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 367;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterSchwa";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 368;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOpenE";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 369;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterFWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 370;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterFWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 371;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 372;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGamma";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 373;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterHv";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 374;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIota";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 375;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 376;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterKWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 377;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterKWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 378;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLWithBar";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 379;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLambdaWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 380;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterTurnedM";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 381;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNWithLeftHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 382;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNWithLongRightLeg";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 383;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithMiddleTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 384;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithHorn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 385;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithHorn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 386;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOi";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 387;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOi";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 388;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterPWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 389;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterPWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 390;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterYr";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 391;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterToneTwo";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 392;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterToneTwo";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 393;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEsh";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 394;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterReversedEshLoop";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 395;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTWithPalatalHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 396;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterTWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 397;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 398;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterTWithRetroflexHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 399;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithHorn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 400;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithHorn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 401;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUpsilon";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 402;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterVWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 403;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterYWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 404;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterYWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 405;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterZWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 406;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterZWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 407;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEzh";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 408;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEzhReversed";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 409;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEzhReversed";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 410;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEzhWithTail";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 411;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterTwoWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 412;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterToneFive";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 413;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterToneFive";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 414;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterInvertedGlottalStopWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 415;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterWynn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 416;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterDentalClick";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 417;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterLateralClick";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 418;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterAlveolarClick";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 419;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterRetroflexClick";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 420;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDzWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 421;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDWithSmallLetterZWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 422;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterDzWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 423;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLj";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 424;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLWithSmallLetterJ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 425;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLj";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 426;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNj";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 427;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNWithSmallLetterJ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 428;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNj";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 429;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 430;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 431;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 432;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 433;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 434;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 435;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 436;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 437;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDiaeresisAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 438;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDiaeresisAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 439;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDiaeresisAndAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 440;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDiaeresisAndAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 441;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDiaeresisAndCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 442;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDiaeresisAndCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 443;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDiaeresisAndGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 444;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDiaeresisAndGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 445;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTurnedE";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 446;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithDiaeresisAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 447;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithDiaeresisAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 448;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithDotAboveAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 449;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithDotAboveAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 450;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAeWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 451;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAeWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 452;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 453;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 454;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 455;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 456;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterKWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 457;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterKWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 458;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 459;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 460;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithOgonekAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 461;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithOgonekAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 462;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEzhWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 463;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEzhWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 464;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterJWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 465;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDz";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 466;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDWithSmallLetterZ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 467;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterDz";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 468;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 469;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 470;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithRingAboveAndAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 471;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithRingAboveAndAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 472;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAeWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 473;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAeWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 474;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithStrokeAndAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 475;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithStrokeAndAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 476;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 477;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 478;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 479;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 480;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 481;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 482;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 483;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 484;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 485;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 486;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 487;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 488;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 489;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 490;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 491;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 492;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterRWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 493;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterRWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 494;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterRWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 495;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterRWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 496;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 497;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 498;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 499;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	ty = NewType(eType_BMPString);
	ty->Constraints = co = NewConstraint();
	co->Root = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
	se->U.PermittedAlphabet.Constraints = co = NewConstraint();
	esp = &co->Root;
	*esp = NewElementSetSpec(eElementSetSpec_Union);
	(*esp)->U.Union.Elements1 = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_ValueRange);
	se->U.ValueRange.Lower.Flags = 0;
	se->U.ValueRange.Lower.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 352;
	se->U.ValueRange.Upper.Flags = 0;
	se->U.ValueRange.Upper.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 0;
esp = &(*esp)->U.Union.Elements2;
	(*esp) = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_ValueRange);
	se->U.ValueRange.Lower.Flags = 0;
	se->U.ValueRange.Lower.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 0;
	se->U.ValueRange.Upper.Flags = 0;
	se->U.ValueRange.Upper.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 499;
	as = NewAssignment(eAssignment_Type);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "LatinExtended-b";
	as->Module = mid;
	as->U.Type.Type = ty;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	ty = NewType(eType_BMPString);
	ty->Constraints = co = NewConstraint();
	co->Root = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
	se->U.PermittedAlphabet.Constraints = co = NewConstraint();
	esp = &co->Root;
	(*esp) = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_SingleValue);
	se->U.SingleValue.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 0;
	as = NewAssignment(eAssignment_Type);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "Level3";
	as->Module = mid;
	as->U.Type.Type = ty;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
#endif /* NO_CHRMODULE */
}

char32_t chrtab[] = {
	0, 1, 2, 3, 4, 5, 6, 7,
	8, 9, 10, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 20, 21, 22, 23,
	24, 25, 26, 27, 28, 29, 30, 31,
	127, 32, 33, 34, 35, 36, 37, 38,
	39, 40, 41, 42, 43, 44, 45, 46,
	47, 48, 49, 50, 51, 52, 53, 54,
	55, 56, 57, 58, 59, 60, 61, 62,
	63, 64, 65, 66, 67, 68, 69, 70,
	71, 72, 73, 74, 75, 76, 77, 78,
	79, 80, 81, 82, 83, 84, 85, 86,
	87, 88, 89, 90, 91, 92, 93, 94,
	95, 96, 97, 98, 99, 100, 101, 102,
	103, 104, 105, 106, 107, 108, 109, 110,
	111, 112, 113, 114, 115, 116, 117, 118,
	119, 120, 121, 122, 123, 124, 125, 126,
	160, 161, 162, 163, 164, 165, 166, 167,
	168, 169, 170, 171, 172, 173, 174, 175,
	176, 177, 178, 179, 180, 181, 182, 183,
	184, 185, 186, 187, 188, 189, 190, 191,
	192, 193, 194, 195, 196, 197, 198, 199,
	200, 201, 202, 203, 204, 205, 206, 207,
	208, 209, 210, 211, 212, 213, 214, 215,
	216, 217, 218, 219, 220, 221, 222, 223,
	224, 225, 226, 227, 228, 229, 230, 231,
	232, 233, 234, 235, 236, 237, 238, 239,
	240, 241, 242, 243, 244, 245, 246, 247,
	248, 249, 250, 251, 252, 253, 254, 255,
	256, 257, 258, 259, 260, 261, 262, 263,
	264, 265, 266, 267, 268, 269, 270, 271,
	272, 273, 274, 275, 276, 277, 278, 279,
	280, 281, 282, 283, 284, 285, 286, 287,
	288, 289, 290, 291, 292, 293, 294, 295,
	296, 297, 298, 299, 300, 301, 302, 303,
	304, 305, 306, 307, 308, 309, 310, 311,
	312, 313, 314, 315, 316, 317, 318, 319,
	320, 321, 322, 323, 324, 325, 326, 327,
	328, 329, 330, 331, 332, 333, 334, 335,
	336, 337, 338, 339, 340, 341, 342, 343,
	344, 345, 346, 347, 348, 349, 350, 351,
	352, 353, 354, 355, 356, 357, 358, 359,
	360, 361, 362, 363, 364, 365, 366, 367,
	368, 369, 370, 371, 372, 373, 374, 375,
	376, 377, 378, 379, 380, 381, 382, 383,
	384, 385, 386, 387, 388, 389, 390, 391,
	392, 393, 394, 395, 396, 397, 398, 399,
	400, 401, 402, 403, 404, 405, 406, 407,
	408, 409, 410, 411, 412, 413, 414, 415,
	416, 417, 418, 419, 420, 421, 422, 423,
	424, 425, 426, 427, 428, 429, 430, 431,
	432, 433, 434, 435, 436, 437, 438, 439,
	440, 441, 442, 443, 444, 445, 446, 447,
	448, 449, 450, 451, 452, 453, 454, 455,
	456, 457, 458, 459, 460, 461, 462, 463,
	464, 465, 466, 467, 468, 469, 470, 471,
	472, 473, 474, 475, 476, 477, 478, 479,
	480, 481, 482, 483, 484, 485, 486, 487,
	488, 489, 490, 491, 492, 493, 494, 495,
	496, 497, 498, 499, 500, 501, 506, 507,
	508, 509, 510, 511, 512, 513, 514, 515,
	516, 517, 518, 519, 520, 521, 522, 523,
	524, 525, 526, 527, 528, 529, 530, 531,
	532, 533, 534, 535
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\error.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_ERROR_H_
#define _ASN1C_ERROR_H_

#define E_success				0
#define E_systemerror				1
#define E_COMPONENTS_OF_in_extension		2
#define E_applied_COMPONENTS_OF_to_bad_type	3
#define E_COMPONENTS_OF_extended_type		4
#define E_bad_component_in_selectiontype	5
#define E_selection_of_bad_type			6
#define E_recursive_type_definition		7
#define E_undefined_typereference		8
#define E_unterminated_string			9
#define E_bad_character				10
#define E_duplicate_tag				11
#define E_bad_directive				12
#define E_constraint_too_complex		13

void error(int errornr, LLPOS *pos);

#endif // _ASN1C_ERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\error.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "error.h"

/* MyAbort by an error message */
void
error(int errornr, LLPOS *pos)
{
    char errbuf[256];

    switch (errornr) {
    case E_systemerror:
	strcpy(errbuf, strerror(errno));
	break;
    case E_COMPONENTS_OF_in_extension:
	strcpy(errbuf, "`COMPONENTS OF' may not be used in extensions");
	break;
    case E_applied_COMPONENTS_OF_to_bad_type:
	strcpy(errbuf, "`COMPONENTS OF' must be applied to SEQUENCE/SET/CHOICE type");
	break;
    case E_COMPONENTS_OF_extended_type:
	strcpy(errbuf, "`COMPONENTS OF' can only be applied to unextended types");
	break;
    case E_bad_component_in_selectiontype:
	strcpy(errbuf, "unknown component in selection type");
	break;
    case E_selection_of_bad_type:
	strcpy(errbuf, "selection type can only be applied to SEQUENCE/SET/CHOICE types");
	break;
    case E_recursive_type_definition:
	strcpy(errbuf, "recursive type definition, introduce --<POINTER>-- to break recursion");
	break;
    case E_undefined_typereference:
	strcpy(errbuf, "undefined type reference");
	break;
    case E_unterminated_string:
	strcpy(errbuf, "unterminated string constant");
	break;
    case E_bad_character:
	strcpy(errbuf, "bad character in file");
	break;
    case E_duplicate_tag:
	strcpy(errbuf, "duplicate tag in sequence/set/choice type");
	break;
    case E_bad_directive:
	strcpy(errbuf, "directive does not fit to given type");
	break;
    case E_constraint_too_complex:
	strcpy(errbuf, "constraint is too complex");
	break;
    default:
	sprintf(errbuf, "unknown error 0x%x", errornr);
	break;
    }
    ASSERT(0);
    llerror(stderr, pos, "%s", errbuf);
    /*NOTREACHED*/
}

/* print an error message: */
/* print the file name, the line number, the line and mark the column where */
/* the error occured and terminate unsuccessful */
void
llverror(FILE *f, LLPOS *pos, char *fmt, va_list args)
{
    char *p, *q;
    int i;

    if (pos) {
	p = file;
	for (i = 1; i < pos->line; i++) {
	    p = strchr(p, '\n');
	    if (!p)
		break;
	    p++;
	}
	if (pos && pos->file)
	    fprintf(f, "File %s, line %d:\n", pos->file, pos->line);
	if (p && (q = strchr(p, '\n'))) {
	    if (q[-1] == '\r')
		q--;
	    fprintf(f, "%.*s\n", q - p, p);
	    for (i = 0; i < pos->column - 1; i++)
		putc(p[i] == '\t' ? '\t' : ' ', f);
	    fprintf(f, "^ ");
	}
    }
    vfprintf(f, fmt, args);
    putc('\n', f);
    MyExit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\defs.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "error.h"


/* allocate a new value of type _T, copy *_src and return this duplicate */
#define RETDUP(_T, _src) _T *ret; ret = (_T *)malloc(sizeof(_T)); *ret = *(_src); return ret

/* constructor of Assignment_t */
Assignment_t *
NewAssignment(Assignment_e type)
{
    Assignment_t *ret;

    ret = (Assignment_t *)malloc(sizeof(Assignment_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Assignment_t));
    // ret->Next = NULL;
    // ret->Identifier = NULL;
    // ret->Module = NULL;
    // ret->Flags = 0;
    // ret->fImportedLocalDuplicate = 0;
    // ret->fGhost = 0;
    ret->eDefTagType = eTagType_Unknown;
    ret->Type = type;
    switch (type) {
    case eAssignment_Undefined:
        break;
    case eAssignment_ModuleIdentifier:
        break;
    case eAssignment_Type:
        // ret->U.Type.Type = NULL;
        break;
    case eAssignment_Value:
        // ret->U.Value.Value = NULL;
        break;
    case eAssignment_ObjectClass:
        // ret->U.ObjectClass.ObjectClass = NULL;
        break;
    case eAssignment_Object:
        // ret->U.Object.Object = NULL;
        break;
    case eAssignment_ObjectSet:
        // ret->U.ObjectSet.ObjectSet = NULL;
        break;
    case eAssignment_Reference:
        // ret->U.Reference.Identifier = NULL;
        // ret->U.Reference.Module = NULL;
        break;
    }
    return ret;
}

/* copy constructor of Assignment_t */
Assignment_t *
DupAssignment(Assignment_t *src)
{
    RETDUP(Assignment_t, src);
}

/* find an assignment by name+moduleidentifier in an assignment list */
Assignment_t *
FindAssignment(AssignmentList_t ass, Assignment_e type, char *identifier, ModuleIdentifier_t *module)
{
    Assignment_t *a;
    Assignment_e at;

    for (a = ass; a; a = a->Next) {
        if (a->Type == eAssignment_NextPass)
            continue;
        if (type == eAssignment_Undefined) {
            at = eAssignment_Undefined;
        } else {
            at = GetAssignmentType(ass, a);
        }
        if (at == type &&
            !strcmp(a->Identifier, identifier) &&
            !CmpModuleIdentifier(ass, a->Module, module))
            return a;
    }
    return NULL;
}

/* find an exported assignment by name+moduleidentifier in an assignment list */
Assignment_t *
FindExportedAssignment(AssignmentList_t ass, Assignment_e type, char *identifier, ModuleIdentifier_t *module)
{
    Assignment_t *a;
    Assignment_e at;

    for (a = ass; a; a = a->Next) {
        if (a->Type == eAssignment_NextPass ||
            !(a->Flags & eAssignmentFlags_Exported))
            continue;
        if (type == eAssignment_Undefined) {
            at = eAssignment_Undefined;
        } else {
            at = GetAssignmentType(ass, a);
        }
        if (at == type &&
            !strcmp(a->Identifier, identifier) &&
            !CmpModuleIdentifier(ass, a->Module, module))
            return a;
    }
    return NULL;
}

/* find an assignment by name+moduleidentifier in an assignment list */
/* do not use assignments of previous parsing passes */
Assignment_t *
FindAssignmentInCurrentPass(AssignmentList_t ass, char *identifier, ModuleIdentifier_t *module)
{
    for (; ass; ass = ass->Next) {
        if (ass->Type == eAssignment_NextPass)
            return NULL;
        if (!strcmp(ass->Identifier, identifier) &&
            !CmpModuleIdentifier(ass, ass->Module, module))
            return ass;
    }
    return NULL;
}

/* resolve assignment references */
Assignment_t *
GetAssignment(AssignmentList_t ass, Assignment_t *a)
{
    while (a && a->Type == eAssignment_Reference) {
        a = FindAssignment(ass, eAssignment_Undefined,
            a->U.Reference.Identifier, a->U.Reference.Module);
    }
    return a;
}

/* get type of an assignment */
Assignment_e
GetAssignmentType(AssignmentList_t ass, Assignment_t *a)
{
    a = GetAssignment(ass, a);
    return a ? a->Type : eAssignment_Undefined;
}

/* assign a type */
/* lhs must be an type reference */
/* returns 0 if type is already defined in current parser pass */
int
AssignType(AssignmentList_t *ass, Type_t *lhs, Type_t *rhs)
{
    Assignment_t *a;

    if (lhs->Type != eType_Reference)
        MyAbort();
    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_Type &&
            !strcmp(a->Identifier, lhs->U.Reference.Identifier) &&
            !CmpModuleIdentifier(*ass, a->Module, lhs->U.Reference.Module))
            return 0;
    }
    // propagate the directives from rhs to lhs
    PropagatePrivateDirectives(lhs, &(rhs->PrivateDirectives));
    // create new assignment
    a = NewAssignment(eAssignment_Type);
    a->Identifier = lhs->U.Reference.Identifier;
    a->Module = lhs->U.Reference.Module;
    a->U.Type.Type = rhs;
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* assign a value */
/* lhs must be an value reference */
/* returns 0 if value is already defined in current parser pass */
int
AssignValue(AssignmentList_t *ass, Value_t *lhs, Value_t *rhs)
{
    Assignment_t *a;

    if (lhs->Type)
        MyAbort();
    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_Value &&
            !strcmp(a->Identifier, lhs->U.Reference.Identifier) &&
            !CmpModuleIdentifier(*ass, a->Module, lhs->U.Reference.Module))
            return 0;
    }
    a = NewAssignment(eAssignment_Value);
    a->Identifier = lhs->U.Reference.Identifier;
    a->Module = lhs->U.Reference.Module;
    a->U.Value.Value = rhs;
    ASSERT(rhs);
    if (rhs->Type && rhs->Type->Type == eType_ObjectIdentifier)
    {
        AddDefinedOID(a->Identifier, rhs);
    }
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* assign a object class */
/* lhs must be an object class reference */
/* returns 0 if object class is already defined in current parser pass */
int
AssignObjectClass(AssignmentList_t *ass, ObjectClass_t *lhs, ObjectClass_t *rhs)
{
    Assignment_t *a;

    if (lhs->Type != eObjectClass_Reference)
        MyAbort();
    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_ObjectClass &&
            !strcmp(a->Identifier, lhs->U.Reference.Identifier) &&
            !CmpModuleIdentifier(*ass, a->Module, lhs->U.Reference.Module))
            return 0;
    }
    a = NewAssignment(eAssignment_ObjectClass);
    a->Identifier = lhs->U.Reference.Identifier;
    a->Module = lhs->U.Reference.Module;
    a->U.ObjectClass.ObjectClass = rhs;
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* assign a object */
/* lhs must be an object reference */
/* returns 0 if object is already defined in current parser pass */
int
AssignObject(AssignmentList_t *ass, Object_t *lhs, Object_t *rhs)
{
    Assignment_t *a;

    if (lhs->Type != eObject_Reference)
        MyAbort();
    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_Object &&
            !strcmp(a->Identifier, lhs->U.Reference.Identifier) &&
            !CmpModuleIdentifier(*ass, a->Module, lhs->U.Reference.Module))
            return 0;
    }
    a = NewAssignment(eAssignment_Object);
    a->Identifier = lhs->U.Reference.Identifier;
    a->Module = lhs->U.Reference.Module;
    a->U.Object.Object = rhs;
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* assign a object set */
/* lhs must be an object set reference */
/* returns 0 if type is already defined in current parser pass */
int
AssignObjectSet(AssignmentList_t *ass, ObjectSet_t *lhs, ObjectSet_t *rhs)
{
    Assignment_t *a;

    if (lhs->Type != eObjectSet_Reference)
        MyAbort();
    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_ObjectSet &&
            !strcmp(a->Identifier, lhs->U.Reference.Identifier) &&
            !CmpModuleIdentifier(*ass, a->Module, lhs->U.Reference.Module))
            return 0;
    }
    a = NewAssignment(eAssignment_ObjectSet);
    a->Identifier = lhs->U.Reference.Identifier;
    a->Module = lhs->U.Reference.Module;
    a->U.ObjectSet.ObjectSet = rhs;
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* assign a macro */
/* lhs must be an macro reference */
/* returns 0 if macro is already defined in current parser pass */
int
AssignMacro(AssignmentList_t *ass, Macro_t *lhs, Macro_t *rhs)
{
    Assignment_t *a;

    if (lhs->Type != eMacro_Reference)
        MyAbort();
    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_Macro &&
            !strcmp(a->Identifier, lhs->U.Reference.Identifier) &&
            !CmpModuleIdentifier(*ass, a->Module, lhs->U.Reference.Module))
            return 0;
    }
    a = NewAssignment(eAssignment_Macro);
    a->Identifier = lhs->U.Reference.Identifier;
    a->Module = lhs->U.Reference.Module;
    a->U.Macro.Macro = rhs;
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* define a module identifier */
/* returns 0 if module identifier is already defined in current parser pass */
int
AssignModuleIdentifier(AssignmentList_t *ass, ModuleIdentifier_t *module)
{
    Assignment_t *a;

    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_ModuleIdentifier &&
            !CmpModuleIdentifier(*ass, a->Module, module))
            return 0;
    }
    a = NewAssignment(eAssignment_ModuleIdentifier);
    a->Identifier = "<module>";
    a->Module = module;
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* constructor of UndefinedSymbol_t */
UndefinedSymbol_t *
NewUndefinedSymbol(UndefinedSymbol_e type, Assignment_e reftype)
{
    UndefinedSymbol_t *ret;

    ret = (UndefinedSymbol_t *)malloc(sizeof(UndefinedSymbol_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(UndefinedSymbol_t));
    ret->Type = type;
    ret->U.Symbol.ReferenceType = reftype;
    // ret->U.Symbol.Identifier = NULL;
    // ret->U.Symbol.Module = NULL;
    // ret->Next = NULL;
    return ret;
}

/* constructor of UndefinedSymbol_t */
UndefinedSymbol_t *
NewUndefinedField(UndefinedSymbol_e type, ObjectClass_t *oc, Settings_e reffieldtype)
{
    UndefinedSymbol_t *ret;

    if (oc->Type != eObjectClass_Reference)
        MyAbort();
    ret = (UndefinedSymbol_t *)malloc(sizeof(UndefinedSymbol_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(UndefinedSymbol_t));
    ret->Type = type;
    ret->U.Field.ReferenceFieldType = reffieldtype;
    // ret->U.Field.Identifier = NULL;
    // ret->U.Field.Module = NULL;
    ret->U.Field.ObjectClass = oc;
    // ret->Next = NULL;
    return ret;
}

/* find an undefined symbol by type/name/moduleidentifier in a list of */
/* undefined symbols */
UndefinedSymbol_t *
FindUndefinedSymbol(AssignmentList_t ass, UndefinedSymbolList_t u, Assignment_e type, char *ide, ModuleIdentifier_t *mod)
{
    for (; u; u = u->Next) {
        if (u->Type != eUndefinedSymbol_SymbolNotDefined &&
            u->Type != eUndefinedSymbol_SymbolNotExported)
            continue;
        if ((type == eAssignment_Undefined ||
            u->U.Symbol.ReferenceType == eAssignment_Undefined ||
            u->U.Symbol.ReferenceType == type) &&
            !strcmp(u->U.Symbol.Identifier, ide) &&
            !CmpModuleIdentifier(ass, u->U.Field.Module, mod))
            return u;
    }
    return NULL;
}

/* find an undefined field by type/objectclass/name/moduleidentifier in a */
/* list of undefined symbols */
UndefinedSymbol_t *
FindUndefinedField(AssignmentList_t ass, UndefinedSymbolList_t u, Settings_e fieldtype, ObjectClass_t *oc, char *ide, ModuleIdentifier_t *mod)
{
    for (; u; u = u->Next) {
        if (u->Type != eUndefinedSymbol_FieldNotDefined &&
            u->Type != eUndefinedSymbol_FieldNotExported)
            continue;
        if ((fieldtype == eSetting_Undefined ||
            u->U.Field.ReferenceFieldType == eSetting_Undefined ||
            u->U.Field.ReferenceFieldType == fieldtype) &&
            !strcmp(u->U.Field.Identifier, ide) &&
            GetObjectClass(ass, oc) ==
            GetObjectClass(ass, u->U.Field.ObjectClass) &&
            !CmpModuleIdentifier(ass, u->U.Field.Module, mod))
            return u;
    }
    return NULL;
}

/* constructor of Type_t */
Type_t *
NewType(Type_e type)
{
    Type_t *ret;

    ret = (Type_t *)malloc(sizeof(Type_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Type_t));
    ret->Type = type;
    // ret->Tags = NULL;
    // ret->AllTags = NULL;
    // ret->FirstTags = NULL;
    // ret->Constraints = NULL;
    // ret->Directives = NULL;
    // ret->Flags = 0;
    ret->Rules = eTypeRules_Normal;
    ret->TagDefault = eTagType_Unknown;
    ret->ExtensionDefault = eExtensionType_None;
    ret->PERConstraints.Value.Type = eExtension_Unconstrained;
    // ret->PERConstraints.Value.Root = NULL;
    // ret->PERConstraints.Value.Additional = NULL;
    ret->PERConstraints.Size.Type = eExtension_Unconstrained;
    // ret->PERConstraints.Size.Root = NULL;
    // ret->PERConstraints.Size.Additional = NULL;
    ret->PERConstraints.PermittedAlphabet.Type = eExtension_Unconstrained;
    // ret->PERConstraints.PermittedAlphabet.Root = NULL;
    // ret->PERConstraints.PermittedAlphabet.Additional = NULL;
    // ret->PrivateDirectives = { 0 };
    switch (type) {
    case eType_Boolean:
        break;
    case eType_Integer:
    case eType_Enumerated:
    case eType_BitString:
        // ret->U.IEB.NamedNumbers = NULL;
        break;
    case eType_OctetString:
    case eType_UTF8String:
        break;
    case eType_Null:
        break;
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_Real:
    case eType_EmbeddedPdv:
    case eType_External:
    case eType_CharacterString:
    case eType_InstanceOf:
        // ret->U.SSC.Components = NULL;
        // ret->U.SSC.Optionals = 0;
        // ret->U.SSC.Alternatives = 0;
        // ret->U.SSC.Extensions = 0;
        // ret->U.SSC.Autotag[0] = 0;
        // ret->U.SSC.Autotag[1] = 0;
        break;
    case eType_SequenceOf:
    case eType_SetOf:
        // ret->U.SS.Type = NULL;
        // ret->U.SS.Directives = NULL;
        break;
    case eType_Selection:
        // ret->U.Selection.Identifier = NULL;
        // ret->U.Selection.Type = NULL;
        break;
    case eType_ObjectIdentifier:
        break;
    case eType_BMPString:
        break;
    case eType_GeneralString:
        break;
    case eType_GraphicString:
        break;
    case eType_IA5String:
        break;
    case eType_ISO646String:
        break;
    case eType_NumericString:
        break;
    case eType_PrintableString:
        break;
    case eType_TeletexString:
        break;
    case eType_T61String:
        break;
    case eType_UniversalString:
        break;
    case eType_VideotexString:
        break;
    case eType_VisibleString:
        break;
    case eType_GeneralizedTime:
        break;
    case eType_UTCTime:
        break;
    case eType_ObjectDescriptor:
        break;
    case eType_Undefined:
        break;
    case eType_RestrictedString:
        break;
    case eType_Reference:
        // ret->U.Reference.Identifier = NULL;
        // ret->U.Reference.Module = NULL;
        break;
    case eType_FieldReference:
        // ret->U.FieldReference.ObjectClass = NULL;
        // ret->U.FieldReference.Identifier = NULL;
        break;
    case eType_Macro:
        // ret->U.Macro.Macro = NULL;
        // ret->U.Macro.LocalAssignments = NULL;
        break;
    }
    return ret;
}

/* copy constructor of Type_t */
Type_t *
DupType(Type_t *src)
{
    RETDUP(Type_t, src);
}

/* resolve field reference */
FieldSpec_t *
GetReferencedFieldSpec(AssignmentList_t ass, Type_t *type, ObjectClass_t **objectclass)
{
    FieldSpec_t *fs;
    ObjectClass_t *oc;

    if (type->Type != eType_FieldReference)
        MyAbort();
    oc = type->U.FieldReference.ObjectClass;
    oc = GetObjectClass(ass, oc);
    if (!oc)
        return NULL;
    fs = GetFieldSpec(ass, FindFieldSpec(oc->U.ObjectClass.FieldSpec,
        type->U.FieldReference.Identifier));
    if (!fs)
        return NULL;
    if (fs->Type == eFieldSpec_Object)
        oc = fs->U.Object.ObjectClass;
    else if (fs->Type == eFieldSpec_ObjectSet)
        oc = fs->U.ObjectSet.ObjectClass;
    else
        return NULL;
    if (objectclass)
        *objectclass = oc;
    return GetFieldSpec(ass, fs);
}

/* resolve type reference */
Type_t *
GetReferencedType(AssignmentList_t ass, Type_t *type)
{
    Assignment_t *a;
    FieldSpec_t *fs;

    switch (type->Type) {
    case eType_Reference:
        a = FindAssignment(ass, eAssignment_Type, type->U.Reference.Identifier,
            type->U.Reference.Module);
        a = GetAssignment(ass, a);
        if (!a)
            return NULL;
        return a->U.Type.Type;
    case eType_FieldReference:
        fs = GetReferencedFieldSpec(ass, type, NULL);
        if (!fs)
            return NULL;
        switch (fs->Type) {
        case eFieldSpec_FixedTypeValue:
            return fs->U.FixedTypeValue.Type;
        case eFieldSpec_FixedTypeValueSet:
            return fs->U.FixedTypeValueSet.Type;
        case eFieldSpec_Type:
        case eFieldSpec_VariableTypeValue:
        case eFieldSpec_VariableTypeValueSet:
            return Builtin_Type_Open;
        default:
            return NULL;
        }
        /*NOTREACHED*/
    default:
        MyAbort();
        /*NOTREACHED*/
    }
    return NULL;
}

/* constructor of Component_t */
Component_t *
NewComponent(Components_e type)
{
    Component_t *ret;

    ret = (Component_t *)malloc(sizeof(Component_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Component_t));
    ret->Type = type;
    // ret->Next = NULL;
    switch (type) {
    case eComponent_Normal:
        // ret->U.Normal.NamedType = NULL;
        break;
    case eComponent_Optional:
        // ret->U.Optional.NamedType = NULL;
        break;
    case eComponent_Default:
        // ret->U.Default.NamedType = NULL;
        // ret->U.Default.Value = NULL;
        break;
    case eComponent_ComponentsOf:
        // ret->U.ComponentsOf.Type = NULL;
        break;
    case eComponent_ExtensionMarker:
        /*ret->U.ExtensionMarker.ExceptionSpec = NULL;*/
        break;
    }
    return ret;
}

/* copy constructor of Component_t */
Component_t *
DupComponent(Component_t *src)
{
    RETDUP(Component_t, src);
}

/* find a component by name in a list of components */
Component_t *
FindComponent(AssignmentList_t ass, ComponentList_t components, char *identifier)
{
    Component_t *c;
    NamedType_t *namedType;

    while (components) {
        switch (components->Type) {
        case eComponent_Normal:
        case eComponent_Optional:
        case eComponent_Default:
            namedType = components->U.NOD.NamedType;
            if (namedType && !strcmp(namedType->Identifier, identifier))
                return components;
            break;
        case eComponent_ComponentsOf:
            switch (GetTypeType(ass, components->U.ComponentsOf.Type)) {
            case eType_Sequence:
            case eType_Set:
            case eType_Choice:
            case eType_External:
            case eType_EmbeddedPdv:
            case eType_CharacterString:
            case eType_Real:
            case eType_InstanceOf:
                c = FindComponent(ass,
                    GetType(ass, components->U.ComponentsOf.Type)->
                    U.SSC.Components, identifier);
                if (c)
                    return c;
                break;
            default:
                break;
            }
            break;
        }
        components = components->Next;
    }
    return NULL;
}

/* constructor of NamedType_t */
NamedType_t *
NewNamedType(char *identifier, Type_t *type)
{
    NamedType_t *ret;

    ret = (NamedType_t *)malloc(sizeof(NamedType_t));
    if (! ret)
        return NULL;

    ret->Type = type;
    ret->Identifier = identifier;
    return ret;
}

/* constructor of NamedValue_t */
NamedValue_t *
NewNamedValue(char *identifier, Value_t *value)
{
    NamedValue_t *ret;

    ret = (NamedValue_t *)malloc(sizeof(NamedValue_t));
    if (! ret)
        return NULL;

    ret->Next = NULL;
    ret->Value = value;
    ret->Identifier = identifier;
    return ret;
}

/* copy constructor of NamedValue_t */
NamedValue_t *
DupNamedValue(NamedValue_t *src)
{
    RETDUP(NamedValue_t, src);
}

/* find a named value by name in a list of named values */
NamedValue_t *
FindNamedValue(NamedValueList_t namedValues, char *identifier)
{
    for (; namedValues; namedValues = namedValues->Next) {
        if (!strcmp(namedValues->Identifier, identifier))
            return namedValues;
    }
    return NULL;
}

/* constructor of NamedNumber_t */
NamedNumber_t *
NewNamedNumber(NamedNumbers_e type)
{
    NamedNumber_t *ret;

    ret = (NamedNumber_t *)malloc(sizeof(NamedNumber_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(NamedNumber_t));
    // ret->Next = NULL;
    ret->Type = type;
    switch (type) {
    case eNamedNumber_Normal:
        // ret->U.Normal.Identifier = NULL;
        // ret->U.Normal.Value = NULL;
        break;
    case eNamedNumber_ExtensionMarker:
        /*XXX*/
        break;
    }
    return ret;
}

/* copy constructor of NamedNumber_t */
NamedNumber_t *
DupNamedNumber(NamedNumber_t *src)
{
    RETDUP(NamedNumber_t, src);
}

/* find a named number by name in a list of named numbers */
NamedNumber_t *
FindNamedNumber(NamedNumberList_t namedNumbers, char *identifier)
{
    for (; namedNumbers; namedNumbers = namedNumbers->Next) {
        switch (namedNumbers->Type) {
        case eNamedNumber_Normal:
            if (!strcmp(namedNumbers->U.Normal.Identifier, identifier))
                return namedNumbers;
            break;
        case eNamedNumber_ExtensionMarker:
            break;
        }
    }
    return NULL;
}

/* constructor of Value_t */
Value_t *
NewValue(AssignmentList_t ass, Type_t *type)
{
    Value_t *ret;

    ret = (Value_t *)malloc(sizeof(Value_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Value_t));
    // ret->Next = NULL;
    ret->Type = type;
    if (type) {
        // ret->Flags = 0;
        switch (GetTypeType(ass, type)) {
        case eType_Boolean:
            // ret->U.Boolean.Value = 0;
            break;
        case eType_Integer:
            ret->U.Integer.Value.length = 1;
            ret->U.Integer.Value.value = (octet_t *)malloc(1);
            // ret->U.Integer.Value.value[0] = 0;
            break;
        case eType_Enumerated:
            // ret->U.Enumerated.Value = 0;
            break;
        case eType_Real:
            ret->U.Real.Value.type = eReal_Normal;
            intx_setuint32(&ret->U.Real.Value.mantissa, 0);
            intx_setuint32(&ret->U.Real.Value.exponent, 0);
            ret->U.Real.Value.base = 2;
            break;
        case eType_BitString:
            // ret->U.BitString.Value.length = 0;
            // ret->U.BitString.Value.value = NULL;
            break;
        case eType_OctetString:
        case eType_UTF8String:
            // ret->U.OctetString.Value.length = 0;
            // ret->U.OctetString.Value.value = NULL;
            break;
        case eType_Null:
            break;
        case eType_SequenceOf:
        case eType_SetOf:
            // ret->U.SS.Values = NULL;
            break;
        case eType_Sequence:
        case eType_Set:
        case eType_Choice:
        case eType_EmbeddedPdv:
        case eType_External:
        case eType_CharacterString:
        case eType_InstanceOf:
            // ret->U.SSC.NamedValues = NULL;
            break;
        case eType_Selection:
            break;
        case eType_ObjectIdentifier:
            break;
        case eType_BMPString:
            break;
        case eType_GeneralString:
            break;
        case eType_GraphicString:
            break;
        case eType_IA5String:
            break;
        case eType_ISO646String:
            break;
        case eType_NumericString:
            break;
        case eType_PrintableString:
            break;
        case eType_TeletexString:
            break;
        case eType_T61String:
            break;
        case eType_UniversalString:
            break;
        case eType_VideotexString:
            break;
        case eType_VisibleString:
            break;
        case eType_GeneralizedTime:
            break;
        case eType_UTCTime:
            break;
        case eType_ObjectDescriptor:
            break;
        case eType_Undefined:
            break;
        }
    } else {
        // ret->U.Reference.Identifier = NULL;
        // ret->U.Reference.Module = NULL;
    }
    return ret;
}

/* copy constructor of Value_t */
Value_t *
DupValue(Value_t *src)
{
    RETDUP(Value_t, src);
}

/* constructor of ValueSet_t */
ValueSet_t *
NewValueSet()
{
    ValueSet_t *ret;

    ret = (ValueSet_t *)malloc(sizeof(ValueSet_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ValueSet_t));
    // ret->Elements = NULL;
    return ret;
}

/* copy constructor of ValueSet_t */
ValueSet_t *
DupValueSet(ValueSet_t *src)
{
    RETDUP(ValueSet_t, src);
}

/* constructor of Macro_t */
Macro_t *
NewMacro(Macro_e type)
{
    Macro_t *ret;

    ret = (Macro_t *)malloc(sizeof(Macro_t));
    if (! ret)
        return NULL;

    ret->Type = type;
    return ret;
}

/* copy constructor of Macro_t */
Macro_t *
DupMacro(Macro_t *src)
{
    RETDUP(Macro_t, src);
}

/* constructor of MacroProduction_t */
MacroProduction_t *
NewMacroProduction(MacroProduction_e type)
{
    MacroProduction_t *ret;

    ret = (MacroProduction_t *)malloc(sizeof(MacroProduction_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(MacroProduction_t));
    ret->Type = type;
    switch (type) {
    case eMacroProduction_Alternative:
        // ret->U.Alternative.Production1 = NULL;
        // ret->U.Alternative.Production2 = NULL;
        break;
    case eMacroProduction_Sequence:
        // ret->U.Sequence.Production1 = NULL;
        // ret->U.Sequence.Production2 = NULL;
        break;
    case eMacroProduction_AString:
        // ret->U.AString.String = NULL;
        break;
    case eMacroProduction_ProductionReference:
        // ret->U.ProductionReference.Reference = NULL;
        break;
    case eMacroProduction_String:
    case eMacroProduction_Identifier:
    case eMacroProduction_Number:
    case eMacroProduction_Empty:
        break;
    case eMacroProduction_Type:
        // ret->U.Type.LocalTypeReference = NULL;
        break;
    case eMacroProduction_Value:
        // ret->U.Value.LocalTypeReference = NULL;
        // ret->U.Value.LocalValueReference = NULL;
        // ret->U.Value.Type = NULL;
        break;
    case eMacroProduction_LocalTypeAssignment:
        // ret->U.LocalTypeAssignment.LocalTypeReference = NULL;
        // ret->U.LocalTypeAssignment.Type = NULL;
        break;
    case eMacroProduction_LocalValueAssignment:
        // ret->U.LocalValueAssignment.LocalValueReference = NULL;
        // ret->U.LocalValueAssignment.Value = NULL;
        break;
    }
    return ret;
}

/* copy constructor of MacroProduction_t */
MacroProduction_t *
DupMacroProduction(MacroProduction_t *src)
{
    RETDUP(MacroProduction_t, src);
}

/* constructor of NamedMacroProduction_t */
NamedMacroProduction_t *
NewNamedMacroProduction()
{
    NamedMacroProduction_t *ret;

    ret = (NamedMacroProduction_t *)malloc(sizeof(NamedMacroProduction_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(NamedMacroProduction_t));
    // ret->Next = NULL;
    // ret->Identifier = NULL;
    // ret->Production = NULL;
    return ret;
}

/* copy constructor of NamedMacroProduction */
NamedMacroProduction_t *
DupNamedMacroProduction(NamedMacroProduction_t *src)
{
    RETDUP(NamedMacroProduction_t, src);
}

/* constructor of MacroLocalAssignment_t */
MacroLocalAssignment_t *
NewMacroLocalAssignment(MacroLocalAssignment_e type)
{
    MacroLocalAssignment_t *ret;

    ret = (MacroLocalAssignment_t *)malloc(sizeof(MacroLocalAssignment_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(MacroLocalAssignment_t));
    // ret->Next = NULL;
    ret->Type = type;
    // ret->Identifier = NULL;
    switch (type) {
    case eMacroLocalAssignment_Type:
        // ret->U.Type = NULL;
        break;
    case eMacroLocalAssignment_Value:
        // ret->U.Value = NULL;
        break;
    }
    return ret;
}

/* copy constructor of MacroLocalAssignment_t */
MacroLocalAssignment_t *
DupMacroLocalAssignment(MacroLocalAssignment_t *src)
{
    RETDUP(MacroLocalAssignment_t, src);
}

/* find a macrolocalassignment by name in a list of macrolocalassignments */
MacroLocalAssignment_t *
FindMacroLocalAssignment(MacroLocalAssignmentList_t la, char *ide)
{
    for (; la; la = la->Next) {
        if (!strcmp(la->Identifier, ide))
            break;
    }
    return la;
}

/* constructor of EndPoint_t */
EndPoint_t *
NewEndPoint()
{
    EndPoint_t *ret;

    ret = (EndPoint_t *)malloc(sizeof(EndPoint_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(EndPoint_t));
    // ret->Flags = 0;
    // ret->Value = NULL;
    return ret;
}

/* constructor of Constraint_t */
Constraint_t *
NewConstraint()
{
    Constraint_t *ret;

    ret = (Constraint_t *)malloc(sizeof(Constraint_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Constraint_t));
    ret->Type = eExtension_Unextended;
    // ret->Root = NULL;
    // ret->Additional = NULL;
    return ret;
}

/* copy constructor of Constraint_t */
Constraint_t *DupConstraint(Constraint_t *src)
{
    RETDUP(Constraint_t, src);
}

/* constructor of ElementSetSpec_t */
ElementSetSpec_t *
NewElementSetSpec(ElementSetSpec_e type)
{
    ElementSetSpec_t *ret;

    ret = (ElementSetSpec_t *)malloc(sizeof(ElementSetSpec_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ElementSetSpec_t));
    ret->Type = type;
    switch (type) {
    case eElementSetSpec_AllExcept:
        // ret->U.AllExcept.Elements = NULL;
        break;
    case eElementSetSpec_Union:
        // ret->U.Union.Elements1 = NULL;
        // ret->U.Union.Elements2 = NULL;
        break;
    case eElementSetSpec_Intersection:
        // ret->U.Intersection.Elements1 = NULL;
        // ret->U.Intersection.Elements2 = NULL;
        break;
    case eElementSetSpec_Exclusion:
        // ret->U.Exclusion.Elements1 = NULL;
        // ret->U.Exclusion.Elements2 = NULL;
        break;
    case eElementSetSpec_SubtypeElement:
        // ret->U.SubtypeElement.SubtypeElement = NULL;
        break;
    case eElementSetSpec_ObjectSetElement:
        // ret->U.ObjectSetElement.ObjectSetElement = NULL;
        break;
    default:
        MyAbort();
    }
    return ret;
}

/* constructor of SubtypeElement_t */
SubtypeElement_t *
NewSubtypeElement(SubtypeElement_e type)
{
    SubtypeElement_t *ret;

    ret = (SubtypeElement_t *)malloc(sizeof(SubtypeElement_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(SubtypeElement_t));
    ret->Type = type;
    switch (type) {
    case eSubtypeElement_ValueRange:
        ret->U.ValueRange.Lower.Flags = eEndPoint_Min;
        // ret->U.ValueRange.Lower.Value = NULL;
        ret->U.ValueRange.Upper.Flags = eEndPoint_Max;
        // ret->U.ValueRange.Upper.Value = NULL;
        break;
    case eSubtypeElement_Size:
        // ret->U.Size.Constraints = NULL;
        break;
    case eSubtypeElement_SingleValue:
        // ret->U.SingleValue.Value = NULL;
        break;
    case eSubtypeElement_PermittedAlphabet:
        // ret->U.PermittedAlphabet.Constraints = NULL;
        break;
    case eSubtypeElement_ContainedSubtype:
        // ret->U.ContainedSubtype.Type = NULL;
        break;
    case eSubtypeElement_Type:
        // ret->U.Type.Type = NULL;
        break;
    case eSubtypeElement_SingleType:
        // ret->U.SingleType.Constraints = NULL;
        break;
    case eSubtypeElement_FullSpecification:
        // ret->U.FullSpecification.NamedConstraints = NULL;
        break;
    case eSubtypeElement_PartialSpecification:
        // ret->U.PartialSpecification.NamedConstraints = NULL;
        break;
    case eSubtypeElement_ElementSetSpec:
        // ret->U.ElementSetSpec.ElementSetSpec = NULL;
        break;
    }
    return ret;
}

/* constructor of ObjectSetElement_t */
ObjectSetElement_t *NewObjectSetElement(ObjectSetElement_e type)
{
    ObjectSetElement_t *ret;

    ret = (ObjectSetElement_t *)malloc(sizeof(ObjectSetElement_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ObjectSetElement_t));
    ret->Type = type;
    switch (type) {
    case eObjectSetElement_Object:
        // ret->U.Object.Object = NULL;
        break;
    case eObjectSetElement_ObjectSet:
        // ret->U.ObjectSet.ObjectSet = NULL;
        break;
    case eObjectSetElement_ElementSetSpec:
        // ret->U.ElementSetSpec.ElementSetSpec = NULL;
        break;
    }
    return ret;
}

/* constructor of ValueConstraint_t */
ValueConstraint_t *
NewValueConstraint()
{
    ValueConstraint_t *ret;

    ret = (ValueConstraint_t *)malloc(sizeof(ValueConstraint_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ValueConstraint_t));
    // ret->Next = NULL;
    // ret->Lower.Flags = ret->Upper.Flags = 0;
    // ret->Lower.Value = ret->Upper.Value = NULL;
    return ret;
}

/* constructor of NamedConstraint_t */
NamedConstraint_t *
NewNamedConstraint()
{
    NamedConstraint_t *ret;

    ret = (NamedConstraint_t *)malloc(sizeof(NamedConstraint_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(NamedConstraint_t));
    // ret->Next = NULL;
    // ret->Identifier = NULL;
    // ret->Constraint = NULL;
    ret->Presence = ePresence_Normal;
    return ret;
}

/* constructor of Tag_t */
Tag_t *
NewTag(TagType_e type)
{
    Tag_t *tag;

    tag = (Tag_t *)malloc(sizeof(Tag_t));
    if (! tag)
        return NULL;

    memset(tag, 0, sizeof(Tag_t));
    tag->Type = type;
    tag->Class = eTagClass_Unknown;
    // tag->Tag = NULL;
    // tag->Next = NULL;
    return tag;
}

/* copy constructor of Tag_t */
Tag_t *
DupTag(Tag_t *src)
{
    RETDUP(Tag_t, src);
}

/* constructor of Directive_t */
Directive_t *
NewDirective(Directives_e type)
{
    Directive_t *ret;

    ret = (Directive_t *)malloc(sizeof(Directive_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Directive_t));
    ret->Type = type;
    // ret->Next = NULL;
    return ret;
}

/* copy constructor of Directive_t */
Directive_t *
DupDirective(Directive_t *src)
{
    RETDUP(Directive_t, src);
}

/* constructor of ModuleIdentifier_t */
ModuleIdentifier_t *
NewModuleIdentifier()
{
    ModuleIdentifier_t *ret;

    ret = (ModuleIdentifier_t *)malloc(sizeof(ModuleIdentifier_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ModuleIdentifier_t));
    // ret->Identifier = NULL;
    // ret->ObjectIdentifier = NULL;
    return ret;
}

/* constructor of ObjectClass_t */
ObjectClass_t *
NewObjectClass(ObjectClass_e type)
{
    ObjectClass_t *ret;

    ret = (ObjectClass_t *)malloc(sizeof(ObjectClass_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ObjectClass_t));
    ret->Type = type;
    switch (type) {
    case eObjectClass_ObjectClass:
        // ret->U.ObjectClass.FieldSpec = NULL;
        // ret->U.ObjectClass.SyntaxSpec = NULL;
        break;
    case eObjectClass_Reference:
        // ret->U.Reference.Identifier = NULL;
        // ret->U.Reference.Module = NULL;
        break;
    }

    return ret;
}

/* constructor of Object_t */
Object_t *
NewObject(Object_e type)
{
    Object_t *ret;

    ret = (Object_t *)malloc(sizeof(Object_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Object_t));
    ret->Type = type;
    switch (type) {
    case eObject_Object:
        // ret->U.Object.ObjectClass = NULL;
        // ret->U.Object.Settings = NULL;
        break;
    case eObject_Reference:
        // ret->U.Reference.Identifier = NULL;
        // ret->U.Reference.Module = NULL;
        break;
    }

    return ret;
}

/* constructor of ObjectSet_t */
ObjectSet_t *
NewObjectSet(ObjectSet_e type)
{
    ObjectSet_t *ret;

    ret = (ObjectSet_t *)malloc(sizeof(ObjectSet_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ObjectSet_t));
    ret->Type = type;
    switch (type) {
    case eObjectSet_ObjectSet:
        // ret->U.ObjectSet.ObjectClass = NULL;
        // ret->U.ObjectSet.Elements = NULL;
        break;
    case eObjectSet_Reference:
        // ret->U.Reference.Identifier = NULL;
        // ret->U.Reference.Module = NULL;
        break;
    case eObjectSet_ExtensionMarker:
        // ret->U.ExtensionMarker.ObjectClass = NULL;
        // ret->U.ExtensionMarker.Elements = NULL;
        break;
    }

    return ret;
}

/* constructor of Setting_t */
Setting_t *
NewSetting(Settings_e type)
{
    Setting_t *ret;

    ret = (Setting_t *)malloc(sizeof(Setting_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Setting_t));
    ret->Type = type;
    // ret->Identifier = NULL;
    // ret->Next = NULL;
    switch (type) {
    case eSetting_Type:
        // ret->U.Type.Type = NULL;
        break;
    case eSetting_Value:
        // ret->U.Value.Value = NULL;
        break;
    case eSetting_ValueSet:
        // ret->U.ValueSet.ValueSet = NULL;
        break;
    case eSetting_Object:
        // ret->U.Object.Object = NULL;
        break;
    case eSetting_ObjectSet:
        // ret->U.ObjectSet.ObjectSet = NULL;
        break;
    }

    return ret;
}

/* copy constructor of Setting_t */
Setting_t *
DupSetting(Setting_t *src)
{
    RETDUP(Setting_t, src);
}

/* get the type of a setting */
Settings_e
GetSettingType(Setting_t *se)
{
    return se ? se->Type : eSetting_Undefined;
}

/* find a setting by name in a list of settings */
Setting_t *
FindSetting(SettingList_t se, char *identifier)
{
    for (; se; se = se->Next) {
        if (!strcmp(se->Identifier, identifier))
            return se;
    }
    return NULL;
}

/* constructor of FieldSpec_t */
FieldSpec_t *
NewFieldSpec(FieldSpecs_e type)
{
    FieldSpec_t *ret;

    ret = (FieldSpec_t *)malloc(sizeof(FieldSpec_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(FieldSpec_t));
    ret->Type = type;
    // ret->Identifier = NULL;
    // ret->Next = NULL;
    switch (type) {
    case eFieldSpec_Type:
        // ret->U.Type.Optionality = NULL;
        break;
    case eFieldSpec_FixedTypeValue:
        // ret->U.FixedTypeValue.Type = NULL;
        // ret->U.FixedTypeValue.Unique = 0;
        // ret->U.FixedTypeValue.Optionality = NULL;
        break;
    case eFieldSpec_VariableTypeValue:
        // ret->U.VariableTypeValue.Fields = NULL;
        // ret->U.VariableTypeValue.Optionality = NULL;
        break;
    case eFieldSpec_FixedTypeValueSet:
        // ret->U.FixedTypeValueSet.Type = NULL;
        // ret->U.FixedTypeValueSet.Optionality = NULL;
        break;
    case eFieldSpec_VariableTypeValueSet:
        // ret->U.VariableTypeValueSet.Fields = NULL;
        // ret->U.VariableTypeValueSet.Optionality = NULL;
        break;
    case eFieldSpec_Object:
        // ret->U.Object.ObjectClass = NULL;
        // ret->U.Object.Optionality = NULL;
        break;
    case eFieldSpec_ObjectSet:
        // ret->U.ObjectSet.ObjectClass = NULL;
        // ret->U.ObjectSet.Optionality = NULL;
        break;
    default:
        MyAbort();
    }

    return ret;
}

/* copy constructor of FieldSpec_t */
FieldSpec_t *
DupFieldSpec(FieldSpec_t *src)
{
    RETDUP(FieldSpec_t, src);
}

/* find a fieldspec by name in a list of fieldspecs */
FieldSpec_t *
FindFieldSpec(FieldSpecList_t fs, char *identifier)
{
    if (!identifier)
        return NULL;
    for (; fs; fs = fs->Next) {
        if (!strcmp(fs->Identifier, identifier))
            return fs;
    }
    return NULL;
}

/* constructor of Optionality_t */
Optionality_t *
NewOptionality(Optionality_e type)
{
    Optionality_t *ret;

    ret = (Optionality_t *)malloc(sizeof(Optionality_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Optionality_t));
    ret->Type = type;
    switch (type) {
    case eOptionality_Normal:
        break;
    case eOptionality_Optional:
        break;
    case eOptionality_Default_Type:
        // ret->U.Type = NULL;
        break;
    case eOptionality_Default_Value:
        // ret->U.Value = NULL;
        break;
    case eOptionality_Default_ValueSet:
        // ret->U.ValueSet = NULL;
        break;
    case eOptionality_Default_Object:
        // ret->U.Object = NULL;
        break;
    case eOptionality_Default_ObjectSet:
        // ret->U.ObjectSet = NULL;
        break;
    }

    return ret;
}

/* constructor of String_t */
String_t *
NewString()
{
    String_t *ret;

    ret = (String_t *)malloc(sizeof(String_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(String_t));
    // ret->String = NULL;
    // ret->Next = NULL;
    return ret;
}

/* copy constructor of String_t */
String_t *
DupString(String_t *src)
{
    RETDUP(String_t, src);
}

/* find a string by name in a string list */
String_t *
FindString(StringList_t list, char *string)
{
    for (; list; list = list->Next) {
        if (!strcmp(list->String, string))
            return list;
    }
    return NULL;
}

/* constructor of StringModule_t */
StringModule_t *
NewStringModule()
{
    StringModule_t *ret;

    ret = (StringModule_t *)malloc(sizeof(StringModule_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(StringModule_t));
    // ret->String = NULL;
    // ret->Module = NULL;
    // ret->Next = NULL;
    return ret;
}

/* copy constructor of StringModule_t */
StringModule_t *
DupStringModule(StringModule_t *src)
{
    RETDUP(StringModule_t, src);
}

/* find a stringmodule by name/module in a list of stringmodules */
StringModule_t *
FindStringModule(AssignmentList_t ass, StringModuleList_t list, char *string, ModuleIdentifier_t *module)
{
    for (; list; list = list->Next) {
        if (!strcmp(list->String, string) &&
            !CmpModuleIdentifier(ass, list->Module, module))
            return list;
    }
    return NULL;
}

/* constructor of SyntaxSpec_t */
SyntaxSpec_t *
NewSyntaxSpec(SyntaxSpecs_e type)
{
    SyntaxSpec_t *ret;

    ret = (SyntaxSpec_t *)malloc(sizeof(SyntaxSpec_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(SyntaxSpec_t));
    // ret->Next = NULL;
    ret->Type = type;
    switch (type) {
    case eSyntaxSpec_Literal:
        // ret->U.Literal.Literal = NULL;
        break;
    case eSyntaxSpec_Field:
        // ret->U.Field.Field = NULL;
        break;
    case eSyntaxSpec_Optional:
        // ret->U.Optional.SyntaxSpec = NULL;
        break;
    }
    return ret;
}

/* copy constructor of SyntaxSpec_t */
SyntaxSpec_t *
DupSyntaxSpec(SyntaxSpec_t *src)
{
    RETDUP(SyntaxSpec_t, src);
}

/* check if a type depends on other types which would be declared later */
/* returns 1 if the type depends on a type of the unknown list and */
/* therefore has to be defined later */
/* returns 0 if the type can be defined now */
int
Depends(AssignmentList_t known, AssignmentList_t unknown, Type_t *type, Type_t *parent)
{
    Type_t *reftype;
    int isunknown = 0;

    /* no dependency if no type is referenced */
    if (type->Type != eType_Reference && type->Type != eType_FieldReference)
        return 0;

    /* get the directly referenced type */
    reftype = GetReferencedType(known, type);
    if (!reftype) {
        reftype = GetReferencedType(unknown, type);
        isunknown = 1;
    }
    if (!reftype)
        MyAbort();

    // fix intermediate pdu
    if (IsStructuredType(reftype) || IsSequenceType(reftype) || IsReferenceType(reftype))
    {
        reftype->Flags |= eTypeFlags_MiddlePDU;
    }

    /* no dependency if a structured type is referenced by use of pointer */
    /* because a 'struct XXX_s *' can be used */
    if (IsStructuredType(reftype) && (type->Rules & eTypeRules_IndirectMask))
        return 0;

    /* no dependency if a structured type is referenced in an length-pointer */
    /* type, because a 'struct XXX_s *values' can be used */
    if (IsStructuredType(reftype) && (parent->Rules & eTypeRules_LengthPointer))
        return 0;

    // special case for pointer related components
    if (! isunknown && IsStructuredType(reftype) &&
        (parent->Rules & eTypeRules_LinkedListMask))
        return 0;

    // special case for SequenceOf and SetOf because they are using Pxxx.
    if ((reftype->Type == eType_SequenceOf || reftype->Type == eType_SetOf) &&
        (reftype->Rules & (eTypeRules_LinkedListMask | eTypeRules_PointerToElement)))
       // && (type->Rules & eTypeRules_IndirectMask))
        return 0;

    /* return true if referenced type is unknown up to now */
    return isunknown;
}

/* sort the assignments */
/* obtain an order usable by C type definitions */
void
SortAssignedTypes(AssignmentList_t *a)
{
    Assignment_t *list, *curr, *next, **prev, **last;
    int depends;
    Component_t *components;
    Type_t *type;
    int flag;
    int structured;

    /* list will contain the unordered assignments */
    list = *a;

    /* *a is the ordered list of assignments */
    *a = NULL;

    /* last will be used for appending to the list of ordered assignments */
    last = a;

    /* at first try to dump all non-structured types */
    structured = 0;

    /* we have to move all elements of the unordered assignment list into */
    /* the list of the ordered assignments */
    while (list) {

        /* flag if any assignment has been moved */
        flag = 0;

        /* examine every element in the unordered list */
        for (prev = &list, curr = list; curr; ) {

            /* flag if the current type depends on another type and */
            /* therefore cannot be moved now */
            depends = 0;

            /* only types will need dependencies */
            if (curr->Type == eAssignment_Type) {

                /* examine the current type */
                switch (curr->U.Type.Type->Type) {
                case eType_Sequence:
                case eType_Set:
                case eType_Choice:
                case eType_External:
                case eType_EmbeddedPdv:
                case eType_CharacterString:
                case eType_Real:
                case eType_InstanceOf:
                    
                    /* structured types shall not be moved in the first pass */
                    if (!structured) {
                        depends = 1;
                        break;
                    }

                    /* examine all components of the current type */
                    for (components = curr->U.Type.Type->U.SSC.Components;
                        components && !depends; components = components->Next) {

                        switch (components->Type) {
                        case eComponent_Normal:
                        case eComponent_Optional:
                        case eComponent_Default:
                            
                            /* check if the type of the component depends */
                            /* on an undefined type */
                            type = components->U.NOD.NamedType->Type;
                            depends |= Depends(*a, list, type,
                                curr->U.Type.Type);
                            break;

                        case eComponent_ComponentsOf:

                            /* components of should have been already */
                            /* resolved */
                            MyAbort();
                            /*NOTREACHED*/

                        case eComponent_ExtensionMarker:
                            break;
                        }
                    }
                    break;

                case eType_SequenceOf:
                case eType_SetOf:

                    /* structured types shall not be moved in the first pass */
                    if (!structured) {
                        depends = 1;
                        break;
                    }

                    /* check if the type of the elements depends on an */
                    /* undefined type */
                    type = curr->U.Type.Type->U.SS.Type;
                    depends |= Depends(*a, list, type, curr->U.Type.Type);
                    break;

                case eType_Reference:

                    /* check if the referenced type depends on an */
                    /* undefined type */
                    type = curr->U.Type.Type;
                    depends |= Depends(*a, list, type, curr->U.Type.Type);
                    break;
                }
            }

            /* move assignment into ordered assignment list if there's no */
            /* unresolved dependency */
            if (!depends) {
                next = curr->Next;
                *last = curr;
                curr->Next = NULL;
                last = &curr->Next;
                curr = next;
                *prev = curr;
                flag = 1;
            } else {
                prev = &curr->Next;
                curr = curr->Next;
            }
        }

        /* if no types have been moved, allow examination of structured types */
        /* if already allowed structured types, MyAbort because of cyclic */
        /* type definitions */
        if (!flag) {
            if (!structured) {
                structured = 1;
            } else {
            if (! curr || ! curr->Next)
            {
                        error(E_recursive_type_definition, NULL);
            }
            }
        }
    }
}

// --- The following is added by Microsoft ---

static const char *c_aReservedWords[] =
{
    // special for C language
    "__asm",
    "__based",
    "__cdecl",
    "__declspec",
    "__except",
    "__fastcall",
    "__finally",
    "__inline",
    "__int16",
    "__int32",
    "__int64",
    "__int8",
    "__leave",
    "__multiple_inheritance",
    "__single_inheritance",
    "__stdcall",
    "__try",
    "__uuidof",
    "__virtual_inheritance",
    "auto",
    "bool",
    "break",
    "case",
    "catch",
    "char",
    "class",
    "const",
    "const_cast",
    "continue",
    "default",
    "delete",
    "dllexport",
    "dllimport",
    "do",
    "double",
    "dynamic_cast",
    "else",
    "enum",
    "explicit",
    "extern",
    "false",
    "float",
    "for",
    "friend",
    "goto",
    "if",
    "inline",
    "int",
    "long",
    "main",
    "mutable",
    "naked",
    "namespace",
    "new",
    "operator",
    "private",
    "protected",
    "public",
    "register",
    "reinterpret_cast",
    "return",
    "short",
    "signed",
    "sizeof",
    "static",
    "static_cast",
    "struct",
    "switch",
    "template",
    "this",
    "thread",
    "throw",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "unsigned",
    "using",
    "uuid",
    "virtual",
    "void",
    "volatile",
    "while",
    "wmain",
    "xalloc"
};
int IsReservedWord ( char *psz )
{
    int cWords = sizeof(c_aReservedWords) / sizeof(c_aReservedWords[0]);
    const char **ppszWord;
    for (ppszWord = &c_aReservedWords[0]; cWords--; ppszWord++)
    {
        if (strcmp(psz, *ppszWord) == 0)
            return 1;
    }
    return 0;
}

typedef struct ConflictNameList_s
{
    struct ConflictNameList_s   *next;
    char                        *pszName;
    unsigned int                cInstances;
}   ConflictNameList_t;
static ConflictNameList_t *g_pEnumNameList = NULL;      // ENUMERATED
static ConflictNameList_t *g_pOptNameList = NULL;       // OPTIONAL
static ConflictNameList_t *g_pChoiceNameList = NULL;    // CHOICE

void KeepConflictNames ( ConflictNameList_t **ppListHead, char *pszName )
{
    ConflictNameList_t *p;
    char *psz;
    char szName[256];

    strcpy(&szName[0], pszName);
    for (psz = &szName[0]; *psz; psz++)
    {
        if (*psz == '-')
            *psz = '_';
    }

    for (p = *ppListHead; p; p = p->next)
    {
        if (strcmp(p->pszName, &szName[0]) == 0)
        {
            p->cInstances++;
            return;
        }
    }

    p = (ConflictNameList_t *) malloc(sizeof(ConflictNameList_t));
    if (p)
    {
        memset(p, 0, sizeof(ConflictNameList_t));
        p->next = *ppListHead;
        *ppListHead = p;
        p->cInstances = 1;
        p->pszName = strdup(&szName[0]);
    }
}

void KeepEnumNames ( char *pszEnumName )
{
    KeepConflictNames(&g_pEnumNameList, pszEnumName);
}
void KeepOptNames ( char *pszOptName )
{
    KeepConflictNames(&g_pOptNameList, pszOptName);
}
void KeepChoiceNames ( char *pszChoiceName )
{
    KeepConflictNames(&g_pChoiceNameList, pszChoiceName);
}

unsigned int GetConflictNameInstanceCount ( ConflictNameList_t *pListHead, char *pszName )
{
    ConflictNameList_t *p;
    for (p = pListHead; p; p = p->next)
    {
        if (strcmp(p->pszName, pszName) == 0)
        {
            return p->cInstances;
        }
    }
    return 0;
}

int DoesEnumNameConflict ( char *pszEnumName )
{
    return (GetConflictNameInstanceCount(g_pEnumNameList, pszEnumName) > 2); // counted twice
}
int DoesOptNameConflict ( char *pszOptName )
{
    return (GetConflictNameInstanceCount(g_pOptNameList, pszOptName) > 2); // counted twice
}
int DoesChoiceNameConflict ( char *pszChoiceName )
{
    return (GetConflictNameInstanceCount(g_pChoiceNameList, pszChoiceName) > 2); // counted twice
}


int IsImportedLocalDuplicate(AssignmentList_t ass, ModuleIdentifier_t *pMainModule, Assignment_t *curr)
{
    if (0 == CmpModuleIdentifier(ass, curr->Module, pMainModule))
    {
        Assignment_t *a;
        for (a = ass; a; a = a->Next)
        {
            if (a->Flags & eAssignmentFlags_LongName)
            {
                if (0 == strcmp(a->Identifier, curr->Identifier))
                {
                    if (0 != CmpModuleIdentifier(ass, a->Module, curr->Module))
                    {
                        return 1;
                    }
                }
            }
        }
    }
    return 0;
}



DefinedObjectID_t *g_pDefinedObjectIDs = NULL;

Value_t *GetDefinedOIDValue ( char *pszName )
{
    if (pszName)
    {
        DefinedObjectID_t *p;
        for (p = g_pDefinedObjectIDs; p; p = p->next)
        {
            if (strcmp(pszName, p->pszName) == 0)
            {
                return p->pValue;
            }
        }
    }
    return NULL;
}

void AddDefinedOID ( char *pszName, Value_t *pValue )
{
    // add it only when it does not exist
    if (! GetDefinedOIDValue(pszName))
    {
        DefinedObjectID_t *p;
        p = (DefinedObjectID_t *) malloc(sizeof(DefinedObjectID_t));
        if (p)
        {
            p->next = g_pDefinedObjectIDs;
            p->pszName = pszName;
            p->pValue = pValue;
            g_pDefinedObjectIDs = p;
        }
    }
}


void PropagatePrivateDirectives ( Type_t *pDst, PrivateDirectives_t *pSrc )
{
    if (pSrc && pDst)
    {
        if (! pDst->PrivateDirectives.pszTypeName)
        {
            pDst->PrivateDirectives.pszTypeName = pSrc->pszTypeName;
        }
        if (! pDst->PrivateDirectives.pszFieldName)
        {
            pDst->PrivateDirectives.pszFieldName = pSrc->pszFieldName;
        }
        if (! pDst->PrivateDirectives.pszValueName)
        {
            pDst->PrivateDirectives.pszValueName = pSrc->pszValueName;
        }
        pDst->PrivateDirectives.fPublic |= pSrc->fPublic;
        pDst->PrivateDirectives.fIntx |= pSrc->fIntx;
        pDst->PrivateDirectives.fLenPtr |= pSrc->fLenPtr;
        pDst->PrivateDirectives.fPointer |= pSrc->fPointer;
        pDst->PrivateDirectives.fArray |= pSrc->fArray;
        pDst->PrivateDirectives.fNoCode |= pSrc->fNoCode;
        pDst->PrivateDirectives.fNoMemCopy |= pSrc->fNoMemCopy;
        pDst->PrivateDirectives.fOidPacked |= pSrc->fOidPacked;
        pDst->PrivateDirectives.fOidArray |= pSrc->fOidArray;
        pDst->PrivateDirectives.fSLinked |= pSrc->fSLinked;
        pDst->PrivateDirectives.fDLinked |= pSrc->fDLinked;
    }
}


void PropagateReferenceTypePrivateDirectives ( Type_t *pDst, PrivateDirectives_t *pSrc )
{
    if (pSrc && pDst)
    {
        pDst->PrivateDirectives.fPublic |= pSrc->fPublic;
        pDst->PrivateDirectives.fIntx |= pSrc->fIntx;
        pDst->PrivateDirectives.fLenPtr |= pSrc->fLenPtr;
        pDst->PrivateDirectives.fPointer |= pSrc->fPointer;
        pDst->PrivateDirectives.fArray |= pSrc->fArray;
        pDst->PrivateDirectives.fNoCode |= pSrc->fNoCode;
        pDst->PrivateDirectives.fNoMemCopy |= pSrc->fNoMemCopy;
        pDst->PrivateDirectives.fOidPacked |= pSrc->fOidPacked;
        pDst->PrivateDirectives.fOidArray |= pSrc->fOidArray;
        pDst->PrivateDirectives.fSLinked |= pSrc->fSLinked;
        pDst->PrivateDirectives.fDLinked |= pSrc->fDLinked;
    }
}


char *GetPrivateValueName(PrivateDirectives_t *pPrivateDirectives, char *pszDefValueName)
{
    return pPrivateDirectives->pszValueName ? pPrivateDirectives->pszValueName : pszDefValueName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\defs.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_DEFS_H_
#define _ASN1C_DEFS_H_

typedef struct Assignment_s Assignment_t;
typedef struct UndefinedSymbol_s UndefinedSymbol_t;
typedef struct AssignedObjId_s AssignedObjId_t;
typedef struct AssignedModules_s AssignedModules_t;
typedef struct Type_s Type_t;
typedef struct Tag_s Tag_t;
typedef struct EndPoint_s EndPoint_t;
typedef struct ElementSetSpec_s ElementSetSpec_t;
typedef struct SubtypeElement_s SubtypeElement_t;
typedef struct ObjectSetElement_s ObjectSetElement_t;
typedef struct Constraint_s Constraint_t;
typedef struct NamedConstraint_s NamedConstraint_t;
typedef struct PERConstraint_s PERConstraint_t;
typedef struct PERConstraints_s PERConstraints_t;
typedef struct ValueConstraint_s ValueConstraint_t;
typedef struct NamedNumber_s NamedNumber_t;
typedef struct NamedType_s NamedType_t;
typedef struct NamedValue_s NamedValue_t;
typedef struct Component_s Component_t;
typedef struct Value_s Value_t;
typedef struct ValueSet_s ValueSet_t;
typedef struct Macro_s Macro_t;
typedef struct MacroProduction_s MacroProduction_t;
typedef struct NamedMacroProduction_s NamedMacroProduction_t;
typedef struct MacroLocalAssignment_s MacroLocalAssignment_t;
typedef struct Quadruple_s Quadruple_t;
typedef struct Tuple_s Tuple_t;
typedef struct Directive_s Directive_t;
typedef struct ModuleIdentifier_s ModuleIdentifier_t;
typedef struct NamedObjIdValue_s NamedObjIdValue_t;
typedef struct ObjectClass_s ObjectClass_t;
typedef struct Object_s Object_t;
typedef struct ObjectSet_s ObjectSet_t;
typedef struct Optionality_s Optionality_t;
typedef struct FieldSpec_s FieldSpec_t;
typedef struct SyntaxSpec_s SyntaxSpec_t;
typedef struct Setting_s Setting_t;
typedef struct String_s String_t;
typedef struct StringModule_s StringModule_t;
typedef struct PERSimpleTypeInfo_s PERSimpleTypeInfo_t;
typedef struct PERTypeInfo_s PERTypeInfo_t;
typedef struct BERTypeInfo_s BERTypeInfo_t;
typedef struct Arguments_s Arguments_t;

typedef Assignment_t *AssignmentList_t;
typedef AssignedObjId_t *AssignedObjIdList_t;
typedef Tag_t *TagList_t;
typedef NamedConstraint_t *NamedConstraintList_t;
typedef NamedNumber_t *NamedNumberList_t;
typedef ValueConstraint_t *ValueConstraintList_t;
typedef Component_t *ComponentList_t;
typedef NamedValue_t *NamedValueList_t;
typedef Directive_t *DirectiveList_t;
typedef Setting_t *SettingList_t;
typedef SyntaxSpec_t *SyntaxSpecList_t;
typedef FieldSpec_t *FieldSpecList_t;
typedef UndefinedSymbol_t *UndefinedSymbolList_t;
typedef NamedObjIdValue_t *NamedObjIdValueList_t;
typedef Value_t *ValueList_t;
typedef NamedMacroProduction_t *NamedMacroProductionList_t;
typedef MacroLocalAssignment_t *MacroLocalAssignmentList_t;
typedef String_t *StringList_t;
typedef StringModule_t *StringModuleList_t;

/* --- undefined element --- */

#define UNDEFINED_VALUE 1UL
#define UNDEFINED(_ptr) ((unsigned long)(_ptr) == UNDEFINED_VALUE)
#define DEFINED(_ptr) ((_ptr) && !UNDEFINED(_ptr))

/* --- Tag --- */

typedef enum {
    eTagType_Implicit,
    eTagType_Explicit,
    eTagType_Automatic,
    eTagType_Unknown
} TagType_e;

typedef enum {
    eTagClass_Universal          = 0x00,
    eTagClass_Application        = 0x40,
    eTagClass_Unknown            = 0x80,
    eTagClass_Pr