NCOMPATIBLE_VERSION
//
// MessageText:
//
//  A new version of the SDK is needed to play the requested content.%0
//
#define NS_E_INCOMPATIBLE_VERSION        0xC00D0BC7L

//
// MessageId: NS_S_REBUFFERING
//
// MessageText:
//
//  The requested operation has caused the source to rebuffer.%0
//
#define NS_S_REBUFFERING                 0x000D0BC8L

//
// MessageId: NS_S_DEGRADING_QUALITY
//
// MessageText:
//
//  The requested operation has caused the source to degrade codec quality.%0
//
#define NS_S_DEGRADING_QUALITY           0x000D0BC9L

//
// MessageId: NS_E_OFFLINE_MODE
//
// MessageText:
//
//  The requested URL is not available in offline mode.%0
//
#define NS_E_OFFLINE_MODE                0xC00D0BCAL

//
// MessageId: NS_E_NOT_CONNECTED
//
// MessageText:
//
//  The requested URL cannot be accessed because there is no network connection.%0
//
#define NS_E_NOT_CONNECTED               0xC00D0BCBL

//
// MessageId: NS_E_TOO_MUCH_DATA
//
// MessageText:
//
//  The encoding process was unable to keep up with the amount of supplied data.%0
//
#define NS_E_TOO_MUCH_DATA               0xC00D0BCCL

//
// MessageId: NS_E_UNSUPPORTED_PROPERTY
//
// MessageText:
//
//  The given property is not supported.%0
//
#define NS_E_UNSUPPORTED_PROPERTY        0xC00D0BCDL

//
// MessageId: NS_E_8BIT_WAVE_UNSUPPORTED
//
// MessageText:
//
//  Windows Media Player cannot copy the files to the CD because they are 8-bit. Convert the files to 16-bit, 44-kHz stereo files by using Sound Recorder or another audio-processing program, and then try again.%0
//
#define NS_E_8BIT_WAVE_UNSUPPORTED       0xC00D0BCEL

//
// MessageId: NS_E_NO_MORE_SAMPLES
//
// MessageText:
//
//  There are no more samples in the current range.%0
//
#define NS_E_NO_MORE_SAMPLES             0xC00D0BCFL

//
// MessageId: NS_E_INVALID_SAMPLING_RATE
//
// MessageText:
//
//  The given sampling rate is invalid.%0
//
#define NS_E_INVALID_SAMPLING_RATE       0xC00D0BD0L

//
// MessageId: NS_E_MAX_PACKET_SIZE_TOO_SMALL
//
// MessageText:
//
//  The given maximum packet size is too small to accommodate this profile
//
#define NS_E_MAX_PACKET_SIZE_TOO_SMALL   0xC00D0BD1L

//
// MessageId: NS_E_LATE_PACKET
//
// MessageText:
//
//  The packet arrived too late to be of use
//
#define NS_E_LATE_PACKET                 0xC00D0BD2L

//
// MessageId: NS_E_DUPLICATE_PACKET
//
// MessageText:
//
//  The packet is a duplicate of one received before
//
#define NS_E_DUPLICATE_PACKET            0xC00D0BD3L



/////////////////////////////////////////////////////////////////////////
//
// Windows Media Player Errors
//
// IdRange = 4000 - 4999
//
/////////////////////////////////////////////////////////////////////////

//
// WMP CD Filter Error codes
//
//
// MessageId: NS_E_NO_CD
//
// MessageText:
//
//  There is no CD in the CD-ROM drive. Insert a CD, and try again.%0
//
#define NS_E_NO_CD                       0xC00D0FA0L

//
// MessageId: NS_E_CANT_READ_DIGITAL
//
// MessageText:
//
//  Unable to perform digital reads on this compact disc drive.  Please try analog playback via the Tools Options menu.%0
//
#define NS_E_CANT_READ_DIGITAL           0xC00D0FA1L

//
// MessageId: NS_E_DEVICE_DISCONNECTED
//
// MessageText:
//
//  Windows Media Player no longer detects a connected portable device. Reconnect your portable device, and then try downloading the file again.%0
//
#define NS_E_DEVICE_DISCONNECTED         0xC00D0FA2L

//
// MessageId: NS_E_DEVICE_NOT_SUPPORT_FORMAT
//
// MessageText:
//
//  Your Music Player does not support this song's format.%0
//
#define NS_E_DEVICE_NOT_SUPPORT_FORMAT   0xC00D0FA3L

//
// MessageId: NS_E_SLOW_READ_DIGITAL
//
// MessageText:
//
//  Digital reads on this compact disc drive are too slow.  Please try analog playback via the Tools Options menu.%0
//
#define NS_E_SLOW_READ_DIGITAL           0xC00D0FA4L

//
// MessageId: NS_E_MIXER_INVALID_LINE
//
// MessageText:
//
//  An invalid line error occurred in the mixer.%0
//
#define NS_E_MIXER_INVALID_LINE          0xC00D0FA5L

//
// MessageId: NS_E_MIXER_INVALID_CONTROL
//
// MessageText:
//
//  An invalid control error occurred in the mixer.%0
//
#define NS_E_MIXER_INVALID_CONTROL       0xC00D0FA6L

//
// MessageId: NS_E_MIXER_INVALID_VALUE
//
// MessageText:
//
//  An invalid value error occurred in the mixer.%0
//
#define NS_E_MIXER_INVALID_VALUE         0xC00D0FA7L

//
// MessageId: NS_E_MIXER_UNKNOWN_MMRESULT
//
// MessageText:
//
//  An unrecognized MMRESULT occurred in the mixer.%0
//
#define NS_E_MIXER_UNKNOWN_MMRESULT      0xC00D0FA8L

//
// MessageId: NS_E_USER_STOP
//
// MessageText:
//
//  User has stopped the operation.%0
//
#define NS_E_USER_STOP                   0xC00D0FA9L

//
// MessageId: NS_E_MP3_FORMAT_NOT_FOUND
//
// MessageText:
//
//  Windows Media Player cannot play the file. One or more codecs required to play the file cannot be found.%0
//
#define NS_E_MP3_FORMAT_NOT_FOUND        0xC00D0FAAL

//
// MessageId: NS_E_CD_READ_ERROR_NO_CORRECTION
//
// MessageText:
//
//  Windows Media Player cannot read the CD. It may contain flaws. Turn on error correction and try again.%0
//
#define NS_E_CD_READ_ERROR_NO_CORRECTION 0xC00D0FABL

//
// MessageId: NS_E_CD_READ_ERROR
//
// MessageText:
//
//  Windows Media Player cannot read the CD. Be sure the CD is free of dirt and scratches and the CD-ROM drive is functioning properly.%0
//
#define NS_E_CD_READ_ERROR               0xC00D0FACL

//
// MessageId: NS_E_CD_SLOW_COPY
//
// MessageText:
//
//  To speed up the copy process, do not play CD tracks while copying.%0
//
#define NS_E_CD_SLOW_COPY                0xC00D0FADL

//
// MessageId: NS_E_CD_COPYTO_CD
//
// MessageText:
//
//  Cannot copy directly from a CDROM to a CD drive.%0
//
#define NS_E_CD_COPYTO_CD                0xC00D0FAEL

//
// MessageId: NS_E_MIXER_NODRIVER
//
// MessageText:
//
//  Could not open a sound mixer driver.%0
//
#define NS_E_MIXER_NODRIVER              0xC00D0FAFL

//
// MessageId: NS_E_REDBOOK_ENABLED_WHILE_COPYING
//
// MessageText:
//
//  Windows Media Player has detected that a setting for the CD-ROM drive will cause audio CDs to copy incorrectly; no audio is copied. Change the CD-ROM drive setting in Device Manager, and then try again.%0
//
#define NS_E_REDBOOK_ENABLED_WHILE_COPYING 0xC00D0FB0L

//
// MessageId: NS_E_CD_REFRESH
//
// MessageText:
//
//  Trying to refresh the CD playlist.%0
//
#define NS_E_CD_REFRESH                  0xC00D0FB1L

//
// MessageId: NS_E_CD_DRIVER_PROBLEM
//
// MessageText:
//
//  Windows Media Player must switch to analog  mode  because there is a problem reading the CD-ROM drive in digital mode. Verify that the CD-ROM drive is installed correctly or try to update the drivers for the CD-ROM drive, and then try to use digital mode again.%0
//
#define NS_E_CD_DRIVER_PROBLEM           0xC00D0FB2L

//
// MessageId: NS_E_WONT_DO_DIGITAL
//
// MessageText:
//
//  Windows Media Player must switch to analog mode because there is a problem reading the CD-ROM drive  in digital mode.%0
//
#define NS_E_WONT_DO_DIGITAL             0xC00D0FB3L

//
// WMP IWMPXMLParser Error codes
//
//
// MessageId: NS_E_WMPXML_NOERROR
//
// MessageText:
//
//  A call was made to GetParseError on the XML parser but there was no error to retrieve.%0
//
#define NS_E_WMPXML_NOERROR              0xC00D0FB4L

//
// MessageId: NS_E_WMPXML_ENDOFDATA
//
// MessageText:
//
//  The XML Parser ran out of data while parsing.%0
//
#define NS_E_WMPXML_ENDOFDATA            0xC00D0FB5L

//
// MessageId: NS_E_WMPXML_PARSEERROR
//
// MessageText:
//
//  A generic parse error occurred in the XML parser but no information is available.%0
//
#define NS_E_WMPXML_PARSEERROR           0xC00D0FB6L

//
// MessageId: NS_E_WMPXML_ATTRIBUTENOTFOUND
//
// MessageText:
//
//  A call get GetNamedAttribute or GetNamedAttributeIndex on the XML parser resulted in the index not being found.%0
//
#define NS_E_WMPXML_ATTRIBUTENOTFOUND    0xC00D0FB7L

//
// MessageId: NS_E_WMPXML_PINOTFOUND
//
// MessageText:
//
//  A call was made go GetNamedPI on the XML parser, but the requested Processing Instruction was not found.%0
//
#define NS_E_WMPXML_PINOTFOUND           0xC00D0FB8L

//
// MessageId: NS_E_WMPXML_EMPTYDOC
//
// MessageText:
//
//  Persist was called on the XML parser, but the parser has no data to persist.%0
//
#define NS_E_WMPXML_EMPTYDOC             0xC00D0FB9L

//
// Miscellaneous Media Player Error codes
//
//
// MessageId: NS_E_WMP_WINDOWSAPIFAILURE
//
// MessageText:
//
//  A Windows API call failed but no error information was available.%0
//
#define NS_E_WMP_WINDOWSAPIFAILURE       0xC00D0FC8L

//
// MessageId: NS_E_WMP_RECORDING_NOT_ALLOWED
//
// MessageText:
//
//  Windows Media Player cannot copy the file. Either the license restricts copying, or you must obtain a license to copy the file.%0
//
#define NS_E_WMP_RECORDING_NOT_ALLOWED   0xC00D0FC9L

//
// MessageId: NS_E_DEVICE_NOT_READY
//
// MessageText:
//
//  Windows Media Player no longer detects a connected portable device. Reconnect your portable device, and try again.%0
//
#define NS_E_DEVICE_NOT_READY            0xC00D0FCAL

//
// MessageId: NS_E_DAMAGED_FILE
//
// MessageText:
//
//  Windows Media Player cannot play the file because it is either damaged or corrupt.%0
//
#define NS_E_DAMAGED_FILE                0xC00D0FCBL

//
// MessageId: NS_E_MPDB_GENERIC
//
// MessageText:
//
//  An error occurred when the Player was attempting to access information in your media library. Try closing and then reopening the Player.%0
//
#define NS_E_MPDB_GENERIC                0xC00D0FCCL

//
// MessageId: NS_E_FILE_FAILED_CHECKS
//
// MessageText:
//
//  The file cannot be added to Media Library because it is smaller than the minimum-size requirement. Adjust the size requirements, and then try again.%0
//
#define NS_E_FILE_FAILED_CHECKS          0xC00D0FCDL

//
// MessageId: NS_E_MEDIA_LIBRARY_FAILED
//
// MessageText:
//
//  Windows Media Player could not create Media Library. Check with your system administrator to get the necessary permissions to create Media Library on your computer, and then try installing the Player again.%0
//
#define NS_E_MEDIA_LIBRARY_FAILED        0xC00D0FCEL

//
// MessageId: NS_E_SHARING_VIOLATION
//
// MessageText:
//
//  The file is already in use. Close other programs that may be using the file, or stop playing the file, and try again.%0
//
#define NS_E_SHARING_VIOLATION           0xC00D0FCFL

//
// MessageId: NS_E_NO_ERROR_STRING_FOUND
//
// MessageText:
//
//  Windows Media Player has encountered an unknown error.%0
//
#define NS_E_NO_ERROR_STRING_FOUND       0xC00D0FD0L

//
// Generic Media PlayerUI error codes
//
//
// MessageId: NS_E_WMP_UI_SUBCONTROLSNOTSUPPORTED
//
// MessageText:
//
//  The control (%s) does not support creation of sub-controls, yet (%d) sub-controls have been specified.%0
//
#define NS_E_WMP_UI_SUBCONTROLSNOTSUPPORTED 0xC00D0FDEL

//
// MessageId: NS_E_WMP_UI_VERSIONMISMATCH
//
// MessageText:
//
//  Version mismatch: (%.1f required, %.1f found).%0
//
#define NS_E_WMP_UI_VERSIONMISMATCH      0xC00D0FDFL

//
// MessageId: NS_E_WMP_UI_NOTATHEMEFILE
//
// MessageText:
//
//  The layout manager was given valid XML that wasn't a theme file.%0
//
#define NS_E_WMP_UI_NOTATHEMEFILE        0xC00D0FE0L

//
// MessageId: NS_E_WMP_UI_SUBELEMENTNOTFOUND
//
// MessageText:
//
//  The %s subelement could not be found on the %s object.%0
//
#define NS_E_WMP_UI_SUBELEMENTNOTFOUND   0xC00D0FE1L

//
// MessageId: NS_E_WMP_UI_VERSIONPARSE
//
// MessageText:
//
//  An error occurred parsing the version tag.\nValid version tags are of the form:\n\n\t<?wmp version='1.0'?>.%0
//
#define NS_E_WMP_UI_VERSIONPARSE         0xC00D0FE2L

//
// MessageId: NS_E_WMP_UI_VIEWIDNOTFOUND
//
// MessageText:
//
//  The view specified in for the 'currentViewID' property (%s) was not found in this theme file.%0
//
#define NS_E_WMP_UI_VIEWIDNOTFOUND       0xC00D0FE3L

//
// MessageId: NS_E_WMP_UI_PASSTHROUGH
//
// MessageText:
//
//  This error used internally for hit testing.%0
//
#define NS_E_WMP_UI_PASSTHROUGH          0xC00D0FE4L

//
// MessageId: NS_E_WMP_UI_OBJECTNOTFOUND
//
// MessageText:
//
//  Attributes were specified for the %s object, but the object was not available to send them to.%0
//
#define NS_E_WMP_UI_OBJECTNOTFOUND       0xC00D0FE5L

//
// MessageId: NS_E_WMP_UI_SECONDHANDLER
//
// MessageText:
//
//  The %s event already has a handler, the second handler was ignored.%0
//
#define NS_E_WMP_UI_SECONDHANDLER        0xC00D0FE6L

//
// MessageId: NS_E_WMP_UI_NOSKININZIP
//
// MessageText:
//
//  No .wms file found in skin archive.%0
//
#define NS_E_WMP_UI_NOSKININZIP          0xC00D0FE7L

//
// MessageId: NS_S_WMP_UI_VERSIONMISMATCH
//
// MessageText:
//
//  An upgrade may be needed for the theme manager to correctly show this skin. Skin reports version: %.1f.%0
//
#define NS_S_WMP_UI_VERSIONMISMATCH      0x000D0FE8L

//
// MessageId: NS_S_WMP_EXCEPTION
//
// MessageText:
//
//  An error occurred in one of the UI components.%0
//
#define NS_S_WMP_EXCEPTION               0x000D0FE9L

//
// MessageId: NS_E_WMP_URLDOWNLOADFAILED
//
// MessageText:
//
//  Windows Media Player cannot download the file. Check the path to the server, and then try again. For example, if you specified "mms://" in the file name, and the file was actually located on a path beginning with "http://" the file cannot be downloaded, even though it can be played.%0
//
#define NS_E_WMP_URLDOWNLOADFAILED       0xC00D0FEAL

//
// WMP Regional button control
//
//
// MessageId: NS_E_WMP_RBC_JPGMAPPINGIMAGE
//
// MessageText:
//
//  JPG Images are not recommended for use as a mappingImage.%0
//
#define NS_E_WMP_RBC_JPGMAPPINGIMAGE     0xC00D1004L

//
// MessageId: NS_E_WMP_JPGTRANSPARENCY
//
// MessageText:
//
//  JPG Images are not recommended when using a transparencyColor.%0
//
#define NS_E_WMP_JPGTRANSPARENCY         0xC00D1005L

//
// WMP Slider control
//
//
// MessageId: NS_E_WMP_INVALID_MAX_VAL
//
// MessageText:
//
//  The Max property cannot be less than Min property.%0
//
#define NS_E_WMP_INVALID_MAX_VAL         0xC00D1009L

//
// MessageId: NS_E_WMP_INVALID_MIN_VAL
//
// MessageText:
//
//  The Min property cannot be greater than Max property.%0
//
#define NS_E_WMP_INVALID_MIN_VAL         0xC00D100AL

//
// WMP CustomSlider control
//
//
// MessageId: NS_E_WMP_CS_JPGPOSITIONIMAGE
//
// MessageText:
//
//  JPG Images are not recommended for use as a positionImage.%0
//
#define NS_E_WMP_CS_JPGPOSITIONIMAGE     0xC00D100EL

//
// MessageId: NS_E_WMP_CS_NOTEVENLYDIVISIBLE
//
// MessageText:
//
//  The (%s) image's size is not evenly divisible by the positionImage's size.%0
//
#define NS_E_WMP_CS_NOTEVENLYDIVISIBLE   0xC00D100FL

//
// WMP ZIP Decoder
//
//
// MessageId: NS_E_WMPZIP_NOTAZIPFILE
//
// MessageText:
//
//  The ZIP reader opened a file and its signature didn't match that of ZIP files.%0
//
#define NS_E_WMPZIP_NOTAZIPFILE          0xC00D1018L

//
// MessageId: NS_E_WMPZIP_CORRUPT
//
// MessageText:
//
//  The ZIP reader has detected that the file is corrupt.%0
//
#define NS_E_WMPZIP_CORRUPT              0xC00D1019L

//
// MessageId: NS_E_WMPZIP_FILENOTFOUND
//
// MessageText:
//
//  GetFileStream, SaveToFile, or SaveTemp file was called on the ZIP reader with a filename that was not found in the zip file.%0
//
#define NS_E_WMPZIP_FILENOTFOUND         0xC00D101AL

//
// WMP Image Decoding Error codes
//
//
// MessageId: NS_E_WMP_IMAGE_FILETYPE_UNSUPPORTED
//
// MessageText:
//
//  Image type not supported.%0
//
#define NS_E_WMP_IMAGE_FILETYPE_UNSUPPORTED 0xC00D1022L

//
// MessageId: NS_E_WMP_IMAGE_INVALID_FORMAT
//
// MessageText:
//
//  Image file may be corrupt.%0
//
#define NS_E_WMP_IMAGE_INVALID_FORMAT    0xC00D1023L

//
// MessageId: NS_E_WMP_GIF_UNEXPECTED_ENDOFFILE
//
// MessageText:
//
//  Unexpected end of file. GIF file may be corrupt.%0
//
#define NS_E_WMP_GIF_UNEXPECTED_ENDOFFILE 0xC00D1024L

//
// MessageId: NS_E_WMP_GIF_INVALID_FORMAT
//
// MessageText:
//
//  Invalid GIF file.%0
//
#define NS_E_WMP_GIF_INVALID_FORMAT      0xC00D1025L

//
// MessageId: NS_E_WMP_GIF_BAD_VERSION_NUMBER
//
// MessageText:
//
//  Invalid GIF version. Only 87a or 89a supported.%0
//
#define NS_E_WMP_GIF_BAD_VERSION_NUMBER  0xC00D1026L

//
// MessageId: NS_E_WMP_GIF_NO_IMAGE_IN_FILE
//
// MessageText:
//
//  No images found in GIF file.%0
//
#define NS_E_WMP_GIF_NO_IMAGE_IN_FILE    0xC00D1027L

//
// MessageId: NS_E_WMP_PNG_INVALIDFORMAT
//
// MessageText:
//
//  Invalid PNG image file format.%0
//
#define NS_E_WMP_PNG_INVALIDFORMAT       0xC00D1028L

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_BITDEPTH
//
// MessageText:
//
//  PNG bitdepth not supported.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_BITDEPTH 0xC00D1029L

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_COMPRESSION
//
// MessageText:
//
//  Compression format defined in PNG file not supported,%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_COMPRESSION 0xC00D102AL

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_FILTER
//
// MessageText:
//
//  Filter method defined in PNG file not supported.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_FILTER  0xC00D102BL

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_INTERLACE
//
// MessageText:
//
//  Interlace method defined in PNG file not supported.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_INTERLACE 0xC00D102CL

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_BAD_CRC
//
// MessageText:
//
//  Bad CRC in PNG file.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_BAD_CRC 0xC00D102DL

//
// MessageId: NS_E_WMP_BMP_INVALID_BITMASK
//
// MessageText:
//
//  Invalid bitmask in BMP file.%0
//
#define NS_E_WMP_BMP_INVALID_BITMASK     0xC00D102EL

//
// MessageId: NS_E_WMP_BMP_TOPDOWN_DIB_UNSUPPORTED
//
// MessageText:
//
//  Topdown DIB not supported.%0
//
#define NS_E_WMP_BMP_TOPDOWN_DIB_UNSUPPORTED 0xC00D102FL

//
// MessageId: NS_E_WMP_BMP_BITMAP_NOT_CREATED
//
// MessageText:
//
//  Bitmap could not be created.%0
//
#define NS_E_WMP_BMP_BITMAP_NOT_CREATED  0xC00D1030L

//
// MessageId: NS_E_WMP_BMP_COMPRESSION_UNSUPPORTED
//
// MessageText:
//
//  Compression format defined in BMP not supported.%0
//
#define NS_E_WMP_BMP_COMPRESSION_UNSUPPORTED 0xC00D1031L

//
// MessageId: NS_E_WMP_BMP_INVALID_FORMAT
//
// MessageText:
//
//  Invalid Bitmap format.%0
//
#define NS_E_WMP_BMP_INVALID_FORMAT      0xC00D1032L

//
// MessageId: NS_E_WMP_JPG_JERR_ARITHCODING_NOTIMPL
//
// MessageText:
//
//  JPEG Arithmetic coding not supported.%0
//
#define NS_E_WMP_JPG_JERR_ARITHCODING_NOTIMPL 0xC00D1033L

//
// MessageId: NS_E_WMP_JPG_INVALID_FORMAT
//
// MessageText:
//
//  Invalid JPEG format.%0
//
#define NS_E_WMP_JPG_INVALID_FORMAT      0xC00D1034L

//
// MessageId: NS_E_WMP_JPG_BAD_DCTSIZE
//
// MessageText:
//
//  Invalid JPEG format.%0
//
#define NS_E_WMP_JPG_BAD_DCTSIZE         0xC00D1035L

//
// MessageId: NS_E_WMP_JPG_BAD_VERSION_NUMBER
//
// MessageText:
//
//  Internal version error. Unexpected JPEG library version.%0
//
#define NS_E_WMP_JPG_BAD_VERSION_NUMBER  0xC00D1036L

//
// MessageId: NS_E_WMP_JPG_BAD_PRECISION
//
// MessageText:
//
//  Internal JPEG Library error. Unsupported JPEG data precision.%0
//
#define NS_E_WMP_JPG_BAD_PRECISION       0xC00D1037L

//
// MessageId: NS_E_WMP_JPG_CCIR601_NOTIMPL
//
// MessageText:
//
//  JPEG CCIR601 not supported.%0
//
#define NS_E_WMP_JPG_CCIR601_NOTIMPL     0xC00D1038L

//
// MessageId: NS_E_WMP_JPG_NO_IMAGE_IN_FILE
//
// MessageText:
//
//  No image found in JPEG file.%0
//
#define NS_E_WMP_JPG_NO_IMAGE_IN_FILE    0xC00D1039L

//
// MessageId: NS_E_WMP_JPG_READ_ERROR
//
// MessageText:
//
//  Could not read JPEG file.%0
//
#define NS_E_WMP_JPG_READ_ERROR          0xC00D103AL

//
// MessageId: NS_E_WMP_JPG_FRACT_SAMPLE_NOTIMPL
//
// MessageText:
//
//  JPEG Fractional sampling not supported.%0
//
#define NS_E_WMP_JPG_FRACT_SAMPLE_NOTIMPL 0xC00D103BL

//
// MessageId: NS_E_WMP_JPG_IMAGE_TOO_BIG
//
// MessageText:
//
//  JPEG image too large. Maximum image size supported is 65500 X 65500.%0
//
#define NS_E_WMP_JPG_IMAGE_TOO_BIG       0xC00D103CL

//
// MessageId: NS_E_WMP_JPG_UNEXPECTED_ENDOFFILE
//
// MessageText:
//
//  Unexpected end of file reached in JPEG file.%0
//
#define NS_E_WMP_JPG_UNEXPECTED_ENDOFFILE 0xC00D103DL

//
// MessageId: NS_E_WMP_JPG_SOF_UNSUPPORTED
//
// MessageText:
//
//  Unsupported JPEG SOF marker found.%0
//
#define NS_E_WMP_JPG_SOF_UNSUPPORTED     0xC00D103EL

//
// MessageId: NS_E_WMP_JPG_UNKNOWN_MARKER
//
// MessageText:
//
//  Unknown JPEG marker found.%0
//
#define NS_E_WMP_JPG_UNKNOWN_MARKER      0xC00D103FL

//
// MessageId: NS_S_WMP_LOADED_GIF_IMAGE
//
// MessageText:
//
//  Successfully loaded a GIF file.%0
//
#define NS_S_WMP_LOADED_GIF_IMAGE        0x000D1040L

//
// MessageId: NS_S_WMP_LOADED_PNG_IMAGE
//
// MessageText:
//
//  Successfully loaded a PNG file.%0
//
#define NS_S_WMP_LOADED_PNG_IMAGE        0x000D1041L

//
// MessageId: NS_S_WMP_LOADED_BMP_IMAGE
//
// MessageText:
//
//  Successfully loaded a BMP file.%0
//
#define NS_S_WMP_LOADED_BMP_IMAGE        0x000D1042L

//
// MessageId: NS_S_WMP_LOADED_JPG_IMAGE
//
// MessageText:
//
//  Successfully loaded a JPG file.%0
//
#define NS_S_WMP_LOADED_JPG_IMAGE        0x000D1043L

//
// WMP WM Runtime Error codes
//
//
// MessageId: NS_E_WMG_INVALIDSTATE
//
// MessageText:
//
//  Operation attempted in an invalid graph state.%0
//
#define NS_E_WMG_INVALIDSTATE            0xC00D1054L

//
// MessageId: NS_E_WMG_SINKALREADYEXISTS
//
// MessageText:
//
//  A renderer cannot be inserted in a stream while one already exists.%0
//
#define NS_E_WMG_SINKALREADYEXISTS       0xC00D1055L

//
// MessageId: NS_E_WMG_NOSDKINTERFACE
//
// MessageText:
//
//  A necessary WM SDK interface to complete the operation doesn't exist at this time.%0
//
#define NS_E_WMG_NOSDKINTERFACE          0xC00D1056L

//
// MessageId: NS_E_WMG_NOTALLOUTPUTSRENDERED
//
// MessageText:
//
//  Windows Media Player cannot play the file. The file may be formatted with an unsupported codec, or the Player could not download the codec.%0
//
#define NS_E_WMG_NOTALLOUTPUTSRENDERED   0xC00D1057L

//
// MessageId: NS_E_WMR_UNSUPPORTEDSTREAM
//
// MessageText:
//
//  Windows Media Player cannot play the file. The Player does not support the format you are trying to play.%0
//
#define NS_E_WMR_UNSUPPORTEDSTREAM       0xC00D1059L

//
// MessageId: NS_E_WMR_PINNOTFOUND
//
// MessageText:
//
//  An operation was attempted on a pin that doesn't exist in the DirectShow filter graph.%0
//
#define NS_E_WMR_PINNOTFOUND             0xC00D105AL

//
// MessageId: NS_E_WMR_WAITINGONFORMATSWITCH
//
// MessageText:
//
//  Specified operation cannot be completed while waiting for a media format change from the SDK.%0
//
#define NS_E_WMR_WAITINGONFORMATSWITCH   0xC00D105BL

//
// WMP Playlist Error codes
//
//
// MessageId: NS_E_WMX_UNRECOGNIZED_PLAYLIST_FORMAT
//
// MessageText:
//
//  The format of this file was not recognized as a valid playlist format.%0
//
#define NS_E_WMX_UNRECOGNIZED_PLAYLIST_FORMAT 0xC00D1068L

//
// MessageId: NS_E_ASX_INVALIDFORMAT
//
// MessageText:
//
//  This file was believed to be an ASX playlist, but the format was not recognized.%0
//
#define NS_E_ASX_INVALIDFORMAT           0xC00D1069L

//
// MessageId: NS_E_ASX_INVALIDVERSION
//
// MessageText:
//
//  The version of this playlist is not supported. Click Details to go to the microsoft web site and see if there is a newer version of the player to install.%0
//
#define NS_E_ASX_INVALIDVERSION          0xC00D106AL

//
// MessageId: NS_E_ASX_INVALID_REPEAT_BLOCK
//
// MessageText:
//
//  Format of a REPEAT loop within the current playlist file is invalid.%0
//
#define NS_E_ASX_INVALID_REPEAT_BLOCK    0xC00D106BL

//
// MessageId: NS_E_ASX_NOTHING_TO_WRITE
//
// MessageText:
//
//  Windows Media Player cannot export the playlist because it is empty.%0
//
#define NS_E_ASX_NOTHING_TO_WRITE        0xC00D106CL

//
// MessageId: NS_E_URLLIST_INVALIDFORMAT
//
// MessageText:
//
//  Windows Media Player does not recognize this file as a supported playlist.%0
//
#define NS_E_URLLIST_INVALIDFORMAT       0xC00D106DL

//
// MessageId: NS_E_WMX_ATTRIBUTE_DOES_NOT_EXIST
//
// MessageText:
//
//  The specified attribute does not exist.%0
//
#define NS_E_WMX_ATTRIBUTE_DOES_NOT_EXIST 0xC00D106EL

//
// MessageId: NS_E_WMX_ATTRIBUTE_ALREADY_EXISTS
//
// MessageText:
//
//  The specified attribute already exists.%0
//
#define NS_E_WMX_ATTRIBUTE_ALREADY_EXISTS 0xC00D106FL

//
// MessageId: NS_E_WMX_ATTRIBUTE_UNRETRIEVABLE
//
// MessageText:
//
//  Can not retrieve the specified attribute.%0
//
#define NS_E_WMX_ATTRIBUTE_UNRETRIEVABLE 0xC00D1070L

//
// MessageId: NS_E_WMX_ITEM_DOES_NOT_EXIST
//
// MessageText:
//
//  The specified item does not exist in the current playlist.%0
//
#define NS_E_WMX_ITEM_DOES_NOT_EXIST     0xC00D1071L

//
// MessageId: NS_E_WMX_ITEM_TYPE_ILLEGAL
//
// MessageText:
//
//  Items of the specified type can not be created within the current playlist.%0
//
#define NS_E_WMX_ITEM_TYPE_ILLEGAL       0xC00D1072L

//
// MessageId: NS_E_WMX_ITEM_UNSETTABLE
//
// MessageText:
//
//  The specified item can not be set in the current playlist.%0
//
#define NS_E_WMX_ITEM_UNSETTABLE         0xC00D1073L

//
// WMP Core  Error codes
//
//
// MessageId: NS_E_WMPCORE_NOSOURCEURLSTRING
//
// MessageText:
//
//  Windows Media Player cannot find the file. Be sure the path is typed correctly. If it is, the file may not exist in the specified location, or the computer where the file is stored may be offline.%0
//
#define NS_E_WMPCORE_NOSOURCEURLSTRING   0xC00D107CL

//
// MessageId: NS_E_WMPCORE_COCREATEFAILEDFORGITOBJECT
//
// MessageText:
//
//  Failed to create the Global Interface Table.%0
//
#define NS_E_WMPCORE_COCREATEFAILEDFORGITOBJECT 0xC00D107DL

//
// MessageId: NS_E_WMPCORE_FAILEDTOGETMARSHALLEDEVENTHANDLERINTERFACE
//
// MessageText:
//
//  Failed to get the marshalled graph event handler interface.%0
//
#define NS_E_WMPCORE_FAILEDTOGETMARSHALLEDEVENTHANDLERINTERFACE 0xC00D107EL

//
// MessageId: NS_E_WMPCORE_BUFFERTOOSMALL
//
// MessageText:
//
//  Buffer is too small for copying media type.%0
//
#define NS_E_WMPCORE_BUFFERTOOSMALL      0xC00D107FL

//
// MessageId: NS_E_WMPCORE_UNAVAILABLE
//
// MessageText:
//
//  Current state of the player does not allow the operation.%0
//
#define NS_E_WMPCORE_UNAVAILABLE         0xC00D1080L

//
// MessageId: NS_E_WMPCORE_INVALIDPLAYLISTMODE
//
// MessageText:
//
//  Playlist manager does not understand the current play mode (shuffle, normal etc).%0
//
#define NS_E_WMPCORE_INVALIDPLAYLISTMODE 0xC00D1081L

//
// MessageId: NS_E_WMPCORE_ITEMNOTINPLAYLIST
//
// MessageText:
//
//  The item is not in the playlist.%0
//
#define NS_E_WMPCORE_ITEMNOTINPLAYLIST   0xC00D1086L

//
// MessageId: NS_E_WMPCORE_PLAYLISTEMPTY
//
// MessageText:
//
//  There are no items in this playlist. Add items to the playlist, and try again.%0
//
#define NS_E_WMPCORE_PLAYLISTEMPTY       0xC00D1087L

//
// MessageId: NS_E_WMPCORE_NOBROWSER
//
// MessageText:
//
//  The Web site cannot be accessed. A Web browser is not detected on your computer.%0
//
#define NS_E_WMPCORE_NOBROWSER           0xC00D1088L

//
// MessageId: NS_E_WMPCORE_UNRECOGNIZED_MEDIA_URL
//
// MessageText:
//
//  Windows Media Player cannot find the specified file. Be sure the path is typed correctly. If it is, the file does not exist in the specified location, or the computer where the file is stored is offline.%0
//
#define NS_E_WMPCORE_UNRECOGNIZED_MEDIA_URL 0xC00D1089L

//
// MessageId: NS_E_WMPCORE_GRAPH_NOT_IN_LIST
//
// MessageText:
//
//  Graph with the specified URL was not found in the prerolled graph list.%0
//
#define NS_E_WMPCORE_GRAPH_NOT_IN_LIST   0xC00D108AL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EMPTY_OR_SINGLE_MEDIA
//
// MessageText:
//
//  Operation could not be performed because the playlist does not have more than one item.%0
//
#define NS_E_WMPCORE_PLAYLIST_EMPTY_OR_SINGLE_MEDIA 0xC00D108BL

//
// MessageId: NS_E_WMPCORE_ERRORSINKNOTREGISTERED
//
// MessageText:
//
//  An error sink was never registered for the calling object.%0
//
#define NS_E_WMPCORE_ERRORSINKNOTREGISTERED 0xC00D108CL

//
// MessageId: NS_E_WMPCORE_ERRORMANAGERNOTAVAILABLE
//
// MessageText:
//
//  The error manager is not available to respond to errors.%0
//
#define NS_E_WMPCORE_ERRORMANAGERNOTAVAILABLE 0xC00D108DL

//
// MessageId: NS_E_WMPCORE_WEBHELPFAILED
//
// MessageText:
//
//  Failed launching WebHelp URL.%0
//
#define NS_E_WMPCORE_WEBHELPFAILED       0xC00D108EL

//
// MessageId: NS_E_WMPCORE_MEDIA_ERROR_RESUME_FAILED
//
// MessageText:
//
//  Could not resume playing next item in playlist.%0
//
#define NS_E_WMPCORE_MEDIA_ERROR_RESUME_FAILED 0xC00D108FL

//
// MessageId: NS_E_WMPCORE_NO_REF_IN_ENTRY
//
// MessageText:
//
//  No URL specified in the Ref attribute in playlist file.%0
//
#define NS_E_WMPCORE_NO_REF_IN_ENTRY     0xC00D1090L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_EMPTY
//
// MessageText:
//
//  An empty string for playlist attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_EMPTY 0xC00D1091L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_ILLEGAL
//
// MessageText:
//
//  An invalid playlist attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_ILLEGAL 0xC00D1092L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_EMPTY
//
// MessageText:
//
//  An empty string for a playlist attribute value was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_EMPTY 0xC00D1093L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_ILLEGAL
//
// MessageText:
//
//  An illegal value for a playlist attribute was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_ILLEGAL 0xC00D1094L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_EMPTY
//
// MessageText:
//
//  An empty string for a playlist item attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_EMPTY 0xC00D1095L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_ILLEGAL
//
// MessageText:
//
//  An illegal value for a playlist item attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_ILLEGAL 0xC00D1096L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_VALUE_EMPTY
//
// MessageText:
//
//  An illegal value for a playlist item attribute was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_VALUE_EMPTY 0xC00D1097L

//
// MessageId: NS_E_WMPCORE_LIST_ENTRY_NO_REF
//
// MessageText:
//
//  No entries found in the playlist file.%0
//
#define NS_E_WMPCORE_LIST_ENTRY_NO_REF   0xC00D1098L

//
// MessageId: NS_E_WMPCORE_CODEC_NOT_TRUSTED
//
// MessageText:
//
//  The codec downloaded for this media does not appear to be properly signed. Installation is not possible.%0
//
#define NS_E_WMPCORE_CODEC_NOT_TRUSTED   0xC00D109AL

//
// MessageId: NS_E_WMPCORE_CODEC_NOT_FOUND
//
// MessageText:
//
//  Windows Media Player cannot play the file. One or more codecs required to play the file could not be found.%0
//
#define NS_E_WMPCORE_CODEC_NOT_FOUND     0xC00D109BL

//
// MessageId: NS_E_WMPCORE_CODEC_DOWNLOAD_NOT_ALLOWED
//
// MessageText:
//
//  Some of the codecs required by this media are not installed on your system. Since the option for automatic codec acquisition is disabled, no codecs will be downloaded.%0
//
#define NS_E_WMPCORE_CODEC_DOWNLOAD_NOT_ALLOWED 0xC00D109CL

//
// MessageId: NS_E_WMPCORE_ERROR_DOWNLOADING_PLAYLIST
//
// MessageText:
//
//  Failed to download the playlist file.%0
//
#define NS_E_WMPCORE_ERROR_DOWNLOADING_PLAYLIST 0xC00D109DL

//
// MessageId: NS_E_WMPCORE_FAILED_TO_BUILD_PLAYLIST
//
// MessageText:
//
//  Failed to build the playlist.%0
//
#define NS_E_WMPCORE_FAILED_TO_BUILD_PLAYLIST 0xC00D109EL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NONE
//
// MessageText:
//
//  Playlist has no alternates to switch into.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NONE 0xC00D109FL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_EXHAUSTED
//
// MessageText:
//
//  No more playlist alternates available to switch to.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_EXHAUSTED 0xC00D10A0L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NAME_NOT_FOUND
//
// MessageText:
//
//  Could not find the name of the alternate playlist to switch into.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NAME_NOT_FOUND 0xC00D10A1L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_MORPH_FAILED
//
// MessageText:
//
//  Failed to switch to an alternate for this media.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_MORPH_FAILED 0xC00D10A2L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_INIT_FAILED
//
// MessageText:
//
//  Failed to initialize an alternate for the media.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_INIT_FAILED 0xC00D10A3L

//
// MessageId: NS_E_WMPCORE_MEDIA_ALTERNATE_REF_EMPTY
//
// MessageText:
//
//  No URL specified for the roll over Refs in the playlist file.%0
//
#define NS_E_WMPCORE_MEDIA_ALTERNATE_REF_EMPTY 0xC00D10A4L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_NO_EVENT_NAME
//
// MessageText:
//
//  Encountered a playlist with no name.%0
//
#define NS_E_WMPCORE_PLAYLIST_NO_EVENT_NAME 0xC00D10A5L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EVENT_ATTRIBUTE_ABSENT
//
// MessageText:
//
//  A required attribute in the event block of the playlist was not found.%0
//
#define NS_E_WMPCORE_PLAYLIST_EVENT_ATTRIBUTE_ABSENT 0xC00D10A6L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EVENT_EMPTY
//
// MessageText:
//
//  No items were found in the event block of the playlist.%0
//
#define NS_E_WMPCORE_PLAYLIST_EVENT_EMPTY 0xC00D10A7L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_STACK_EMPTY
//
// MessageText:
//
//  No playlist was found while returning from a nested playlist.%0
//
#define NS_E_WMPCORE_PLAYLIST_STACK_EMPTY 0xC00D10A8L

//
// MessageId: NS_E_WMPCORE_CURRENT_MEDIA_NOT_ACTIVE
//
// MessageText:
//
//  The media item is not active currently.%0
//
#define NS_E_WMPCORE_CURRENT_MEDIA_NOT_ACTIVE 0xC00D10A9L

//
// MessageId: NS_E_WMPCORE_USER_CANCEL
//
// MessageText:
//
//  Open was aborted by user.%0
//
#define NS_E_WMPCORE_USER_CANCEL         0xC00D10ABL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_REPEAT_EMPTY
//
// MessageText:
//
//  No items were found inside the playlist repeat block.%0
//
#define NS_E_WMPCORE_PLAYLIST_REPEAT_EMPTY 0xC00D10ACL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_REPEAT_START_MEDIA_NONE
//
// MessageText:
//
//  Media object corresponding to start of a playlist repeat block was not found.%0
//
#define NS_E_WMPCORE_PLAYLIST_REPEAT_START_MEDIA_NONE 0xC00D10ADL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_REPEAT_END_MEDIA_NONE
//
// MessageText:
//
//  Media object corresponding to the end of a playlist repeat block was not found.%0
//
#define NS_E_WMPCORE_PLAYLIST_REPEAT_END_MEDIA_NONE 0xC00D10AEL

//
// MessageId: NS_E_WMPCORE_INVALID_PLAYLIST_URL
//
// MessageText:
//
//  Playlist URL supplied to the playlist manager is invalid.%0
//
#define NS_E_WMPCORE_INVALID_PLAYLIST_URL 0xC00D10AFL

//
// MessageId: NS_E_WMPCORE_MISMATCHED_RUNTIME
//
// MessageText:
//
//  Player is selecting a runtime that is not valid for this media file type.%0
//
#define NS_E_WMPCORE_MISMATCHED_RUNTIME  0xC00D10B0L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_IMPORT_FAILED_NO_ITEMS
//
// MessageText:
//
//  Windows Media Player cannot import the playlist to Media Library because the playlist is empty.%0
//
#define NS_E_WMPCORE_PLAYLIST_IMPORT_FAILED_NO_ITEMS 0xC00D10B1L

//
// MessageId: NS_E_WMPCORE_VIDEO_TRANSFORM_FILTER_INSERTION
//
// MessageText:
//
//  An error has occurred that could prevent the changing of the video contrast on this media.%0
//
#define NS_E_WMPCORE_VIDEO_TRANSFORM_FILTER_INSERTION 0xC00D10B2L

//
// MessageId: NS_E_WMPCORE_MEDIA_UNAVAILABLE
//
// MessageText:
//
//  Windows Media Player cannot play this file. Connect to the Internet or insert the removable media on which the file is located, and then try to play the file again.%0
//
#define NS_E_WMPCORE_MEDIA_UNAVAILABLE   0xC00D10B3L

//
// MessageId: NS_E_WMPCORE_WMX_ENTRYREF_NO_REF
//
// MessageText:
//
//  The playlist contains an ENTRYREF for which no href was parsed. Check the syntax of playlist file.%0
//
#define NS_E_WMPCORE_WMX_ENTRYREF_NO_REF 0xC00D10B4L

//
// MessageId: NS_E_WMPCORE_NO_PLAYABLE_MEDIA_IN_PLAYLIST
//
// MessageText:
//
//  Windows Media Player cannot play any items in this playlist. For additional information, right-click an item that cannot be played, and then click Error Details.%0
//
#define NS_E_WMPCORE_NO_PLAYABLE_MEDIA_IN_PLAYLIST 0xC00D10B5L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EMPTY_NESTED_PLAYLIST_SKIPPED_ITEMS
//
// MessageText:
//
//  Windows Media Player cannot play some or all of the playlist items.%0
//
#define NS_E_WMPCORE_PLAYLIST_EMPTY_NESTED_PLAYLIST_SKIPPED_ITEMS 0xC00D10B6L

//
// MessageId: NS_E_WMPCORE_BUSY
//
// MessageText:
//
//  Windows Media Player could not handle your request for digital media content in a timely manner. Try again later.%0
//
#define NS_E_WMPCORE_BUSY                0xC00D10B7L

//
// MessageId: NS_E_WMPCORE_MEDIA_CHILD_PLAYLIST_UNAVAILABLE
//
// MessageText:
//
//  There is no child playlist available for this media item at this time.%0
//
#define NS_E_WMPCORE_MEDIA_CHILD_PLAYLIST_UNAVAILABLE 0xC00D10B8L

//
// MessageId: NS_E_WMPCORE_MEDIA_NO_CHILD_PLAYLIST
//
// MessageText:
//
//  There is no child playlist for this media item.%0
//
#define NS_E_WMPCORE_MEDIA_NO_CHILD_PLAYLIST 0xC00D10B9L

//
// MessageId: NS_E_WMPCORE_FILE_NOT_FOUND
//
// MessageText:
//
//  Windows Media Player cannot play one or more files. Right-click the file, and then click Error Details to view information about the error.%0
//
#define NS_E_WMPCORE_FILE_NOT_FOUND      0xC00D10BAL

//
// MessageId: NS_E_WMPCORE_TEMP_FILE_NOT_FOUND
//
// MessageText:
//
//  The temporary file was not found.%0
//
#define NS_E_WMPCORE_TEMP_FILE_NOT_FOUND 0xC00D10BBL

//
// MessageId: NS_E_WMDM_REVOKED
//
// MessageText:
//
//  Windows Media Player cannot transfer media to the portable device without an update.  Please click details to find out how to update your device.%0
//
#define NS_E_WMDM_REVOKED                0xC00D10BCL

//
// MessageId: NS_E_DDRAW_GENERIC
//
// MessageText:
//
//  Windows Media Player cannot play the video stream because of a problem with your video card.%0
//
#define NS_E_DDRAW_GENERIC               0xC00D10BDL

//
// MessageId: NS_E_DISPLAY_MODE_CHANGE_FAILED
//
// MessageText:
//
//  Windows Media Player failed to change the screen mode for fullscreen video playback.%0
//
#define NS_E_DISPLAY_MODE_CHANGE_FAILED  0xC00D10BEL

//
// MessageId: NS_E_PLAYLIST_CONTAINS_ERRORS
//
// MessageText:
//
//  One or more items in the playlist cannot be played. For more details, right-click an item in the playlist, and then click Error Details.%0
//
#define NS_E_PLAYLIST_CONTAINS_ERRORS    0xC00D10BFL

//
// WMP Core  Success codes
//
//
// MessageId: NS_S_WMPCORE_PLAYLISTCLEARABORT
//
// MessageText:
//
//  Failed to clear playlist because it was aborted by user.%0
//
#define NS_S_WMPCORE_PLAYLISTCLEARABORT  0x000D10FEL

//
// MessageId: NS_S_WMPCORE_PLAYLISTREMOVEITEMABORT
//
// MessageText:
//
//  Failed to remove item in the playlist since it was aborted by user.%0
//
#define NS_S_WMPCORE_PLAYLISTREMOVEITEMABORT 0x000D10FFL

//
// MessageId: NS_S_WMPCORE_PLAYLIST_CREATION_PENDING
//
// MessageText:
//
//  Playlist is being generated asynchronously.%0
//
#define NS_S_WMPCORE_PLAYLIST_CREATION_PENDING 0x000D1102L

//
// MessageId: NS_S_WMPCORE_MEDIA_VALIDATION_PENDING
//
// MessageText:
//
//  Validation of the media is pending...%0
//
#define NS_S_WMPCORE_MEDIA_VALIDATION_PENDING 0x000D1103L

//
// MessageId: NS_S_WMPCORE_PLAYLIST_REPEAT_SECONDARY_SEGMENTS_IGNORED
//
// MessageText:
//
//  Encountered more than one Repeat block during ASX processing.%0
//
#define NS_S_WMPCORE_PLAYLIST_REPEAT_SECONDARY_SEGMENTS_IGNORED 0x000D1104L

//
// MessageId: NS_S_WMPCORE_COMMAND_NOT_AVAILABLE
//
// MessageText:
//
//  Current state of WMP disallows calling this method or property.%0
//
#define NS_S_WMPCORE_COMMAND_NOT_AVAILABLE 0x000D1105L

//
// MessageId: NS_S_WMPCORE_PLAYLIST_NAME_AUTO_GENERATED
//
// MessageText:
//
//  Name for the playlist has been auto generated.%0
//
#define NS_S_WMPCORE_PLAYLIST_NAME_AUTO_GENERATED 0x000D1106L

//
// MessageId: NS_S_WMPCORE_PLAYLIST_IMPORT_MISSING_ITEMS
//
// MessageText:
//
//  The imported playlist does not contain all items from the original.%0
//
#define NS_S_WMPCORE_PLAYLIST_IMPORT_MISSING_ITEMS 0x000D1107L

//
// MessageId: NS_S_WMPCORE_PLAYLIST_COLLAPSED_TO_SINGLE_MEDIA
//
// MessageText:
//
//  The M3U playlist has been ignored because it only contains one item.%0
//
#define NS_S_WMPCORE_PLAYLIST_COLLAPSED_TO_SINGLE_MEDIA 0x000D1108L

//
// MessageId: NS_S_WMPCORE_MEDIA_CHILD_PLAYLIST_OPEN_PENDING
//
// MessageText:
//
//  The open for the child playlist associated with this media is pending.%0
//
#define NS_S_WMPCORE_MEDIA_CHILD_PLAYLIST_OPEN_PENDING 0x000D1109L

//
// WMP Internet Manager error codes
//
//
// MessageId: NS_E_WMPIM_USEROFFLINE
//
// MessageText:
//
//  Windows Media Player has detected that you are not connected to the Internet. Connect to the Internet, and then try again.%0
//
#define NS_E_WMPIM_USEROFFLINE           0xC00D1126L

//
// MessageId: NS_E_WMPIM_USERCANCELED
//
// MessageText:
//
//  User cancelled attempt to connect to the Internet.%0
//
#define NS_E_WMPIM_USERCANCELED          0xC00D1127L

//
// MessageId: NS_E_WMPIM_DIALUPFAILED
//
// MessageText:
//
//  Attempt to dial connection to the Internet failed.%0
//
#define NS_E_WMPIM_DIALUPFAILED          0xC00D1128L

//
// MessageId: NS_E_WINSOCK_ERROR_STRING
//
// MessageText:
//
//  Windows Media Player has encountered an error in the Winsock networking layer.%0
//
#define NS_E_WINSOCK_ERROR_STRING        0xC00D1129L

//
// WMP Backup and restore error and success codes
//
//
// MessageId: NS_E_WMPBR_NOLISTENER
//
// MessageText:
//
//  No window is currently listening to Backup and Restore events.%0
//
#define NS_E_WMPBR_NOLISTENER            0xC00D1130L

//
// MessageId: NS_E_WMPBR_BACKUPCANCEL
//
// MessageText:
//
//  Backup of your licenses has been cancelled.  Please try again to ensure license backup.%0
//
#define NS_E_WMPBR_BACKUPCANCEL          0xC00D1131L

//
// MessageId: NS_E_WMPBR_RESTORECANCEL
//
// MessageText:
//
//  The licenses were not restored because the restoration was cancelled.%0
//
#define NS_E_WMPBR_RESTORECANCEL         0xC00D1132L

//
// MessageId: NS_E_WMPBR_ERRORWITHURL
//
// MessageText:
//
//  An error occurred during the backup or restore operation that requires a web page be displayed to the user.%0
//
#define NS_E_WMPBR_ERRORWITHURL          0xC00D1133L

//
// MessageId: NS_E_WMPBR_NAMECOLLISION
//
// MessageText:
//
//  The licenses were not backed up because the backup was cancelled.%0
//
#define NS_E_WMPBR_NAMECOLLISION         0xC00D1134L

//
// MessageId: NS_S_WMPBR_SUCCESS
//
// MessageText:
//
//  Backup or Restore successful!.%0
//
#define NS_S_WMPBR_SUCCESS               0x000D1135L

//
// MessageId: NS_S_WMPBR_PARTIALSUCCESS
//
// MessageText:
//
//  Transfer complete with limitations.%0
//
#define NS_S_WMPBR_PARTIALSUCCESS        0x000D1136L

//
// WMP Effects Success codes
//
//
// MessageId: NS_S_WMPEFFECT_TRANSPARENT
//
// MessageText:
//
//  Request to the effects control to change transparency status to transparent.%0
//
#define NS_S_WMPEFFECT_TRANSPARENT       0x000D1144L

//
// MessageId: NS_S_WMPEFFECT_OPAQUE
//
// MessageText:
//
//  Request to the effects control to change transparency status to opaque.%0
//
#define NS_S_WMPEFFECT_OPAQUE            0x000D1145L

//
// WMP Application Success codes
//
//
// MessageId: NS_S_OPERATION_PENDING
//
// MessageText:
//
//  The requested application pane is performing an operation and will not be relased.%0
//
#define NS_S_OPERATION_PENDING           0x000D114EL

//
// WMP DVD Error Codes
//
//
// MessageId: NS_E_DVD_NO_SUBPICTURE_STREAM
//
// MessageText:
//
//  Windows Media Player cannot display subtitles or highlights in menus. Reinstall the DVD decoder or contact your device manufacturer to obtain an updated decoder, and then try again.%0
//
#define NS_E_DVD_NO_SUBPICTURE_STREAM    0xC00D1162L

//
// MessageId: NS_E_DVD_COPY_PROTECT
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because a problem occurred with digital copyright protection.%0
//
#define NS_E_DVD_COPY_PROTECT            0xC00D1163L

//
// MessageId: NS_E_DVD_AUTHORING_PROBLEM
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because the disc is incompatible with the Player.%0
//
#define NS_E_DVD_AUTHORING_PROBLEM       0xC00D1164L

//
// MessageId: NS_E_DVD_INVALID_DISC_REGION
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because the disc prohibits playback in your region of the world. You must obtain a disc that is intended for your geographic region.%0
//
#define NS_E_DVD_INVALID_DISC_REGION     0xC00D1165L

//
// MessageId: NS_E_DVD_COMPATIBLE_VIDEO_CARD
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because your video card does not support DVD playback.%0
//
#define NS_E_DVD_COMPATIBLE_VIDEO_CARD   0xC00D1166L

//
// MessageId: NS_E_DVD_MACROVISION
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because a problem occurred with analog copyright protection.%0
//
#define NS_E_DVD_MACROVISION             0xC00D1167L

//
// MessageId: NS_E_DVD_SYSTEM_DECODER_REGION
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because the region assigned to your DVD drive does not match the region assigned to your DVD decoder.%0
//
#define NS_E_DVD_SYSTEM_DECODER_REGION   0xC00D1168L

//
// MessageId: NS_E_DVD_DISC_DECODER_REGION
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because the disc prohibits playback in your region of the world. To play the disc by using the Player, you must obtain a disc that is intended for your geographic region.%0
//
#define NS_E_DVD_DISC_DECODER_REGION     0xC00D1169L

//
// MessageId: NS_E_DVD_NO_VIDEO_STREAM
//
// MessageText:
//
//  Windows Media Player is currently unable to play DVD video. Close any open files and quit any other running programs, and then try again.%0
//
#define NS_E_DVD_NO_VIDEO_STREAM         0xC00D116AL

//
// MessageId: NS_E_DVD_NO_AUDIO_STREAM
//
// MessageText:
//
//  Windows Media Player cannot play DVD audio. Verify that your sound card is set up correctly, and then try again.%0
//
#define NS_E_DVD_NO_AUDIO_STREAM         0xC00D116BL

//
// MessageId: NS_E_DVD_GRAPH_BUILDING
//
// MessageText:
//
//  Windows Media Player cannot play DVD video. Close any open files and quit any other running programs, and then try again. If the problem continues, restart your computer.%0
//
#define NS_E_DVD_GRAPH_BUILDING          0xC00D116CL

//
// MessageId: NS_E_DVD_NO_DECODER
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because a compatible DVD decoder is not installed on your computer.%0
//
#define NS_E_DVD_NO_DECODER              0xC00D116DL

//
// MessageId: NS_E_DVD_PARENTAL
//
// MessageText:
//
//  Windows Media Player cannot play this DVD segment because the segment has a parental rating higher than the rating you are authorized to view.%0
//
#define NS_E_DVD_PARENTAL                0xC00D116EL

//
// MessageId: NS_E_DVD_CANNOT_JUMP
//
// MessageText:
//
//  Windows Media Player cannot skip to the requested location in the DVD at this time.%0
//
#define NS_E_DVD_CANNOT_JUMP             0xC00D116FL

//
// MessageId: NS_E_DVD_DEVICE_CONTENTION
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because it is currently in use by another program. Quit the other program that is using the DVD, and then try to play it again.%0
//
#define NS_E_DVD_DEVICE_CONTENTION       0xC00D1170L

//
// MessageId: NS_E_DVD_NO_VIDEO_MEMORY
//
// MessageText:
//
//  Windows Media Player cannot play DVD video. Double-click Display in Control Panel to lower your screen resolution and color quality settings.%0
//
#define NS_E_DVD_NO_VIDEO_MEMORY         0xC00D1171L

//
// WMP PDA Error codes
//
//
// MessageId: NS_E_NO_CD_BURNER
//
// MessageText:
//
//  A CD recorder (burner) was not detected. Connect a CD recorder, and try copying again.%0
//
#define NS_E_NO_CD_BURNER                0xC00D1176L

//
// MessageId: NS_E_DEVICE_IS_NOT_READY
//
// MessageText:
//
//  Windows Media Player does not detect any removable media in your portable device. Insert the media in the device or check the connection between the device and your computer, and then press F5 to refresh.%0
//
#define NS_E_DEVICE_IS_NOT_READY         0xC00D1177L

//
// MessageId: NS_E_PDA_UNSUPPORTED_FORMAT
//
// MessageText:
//
//  Windows Media Player cannot play the specified file. Your portable device does not support the specified format.%0
//
#define NS_E_PDA_UNSUPPORTED_FORMAT      0xC00D1178L

//
// MessageId: NS_E_NO_PDA
//
// MessageText:
//
//  Windows Media Player cannot detect a connected portable device. Connect your portable device, and try again.%0
//
#define NS_E_NO_PDA                      0xC00D1179L

//
// MessageId: NS_E_PDA_UNSPECIFIED_ERROR
//
// MessageText:
//
//  Windows Media Player has encountered an error on the portable device. Click the Details button for more information.%0
//
#define NS_E_PDA_UNSPECIFIED_ERROR       0xC00D117AL

//
// General Remapped Error codes in WMP
//
//
// MessageId: NS_E_WMP_PROTOCOL_PROBLEM
//
// MessageText:
//
//  Windows Media Player could not open the specified URL. Be sure Windows Media Player is configured to use all available protocols, and then try again.%0
//
#define NS_E_WMP_PROTOCOL_PROBLEM        0xC00D1194L

//
// MessageId: NS_E_WMP_NO_DISK_SPACE
//
// MessageText:
//
//  Windows Media Player cannot open the file because there is not enough disk space on your computer. Delete some unneeded files on your hard disk, and then try again.%0
//
#define NS_E_WMP_NO_DISK_SPACE           0xC00D1195L

//
// MessageId: NS_E_WMP_LOGON_FAILURE
//
// MessageText:
//
//  The user name or password is incorrect. Type your user name or password again.%0
//
#define NS_E_WMP_LOGON_FAILURE           0xC00D1196L

//
// MessageId: NS_E_WMP_CANNOT_FIND_FILE
//
// MessageText:
//
//  Windows Media Player cannot find the specified file. Be sure the path is typed correctly. If it is, the file does not exist in the specified location, or the computer where the file is stored is offline.%0
//
#define NS_E_WMP_CANNOT_FIND_FILE        0xC00D1197L

//
// MessageId: NS_E_WMP_SERVER_INACCESSIBLE
//
// MessageText:
//
//  Windows Media Player cannot connect to the server. The server name may be incorrect or the server is busy. Try again later.%0
//
#define NS_E_WMP_SERVER_INACCESSIBLE     0xC00D1198L

//
// MessageId: NS_E_WMP_UNSUPPORTED_FORMAT
//
// MessageText:
//
//  Windows Media Player cannot play the file. The file is either corrupt or the Player does not support the format you are trying to play.%0
//
#define NS_E_WMP_UNSUPPORTED_FORMAT      0xC00D1199L

//
// MessageId: NS_E_WMP_DSHOW_UNSUPPORTED_FORMAT
//
// MessageText:
//
//  Windows Media Player cannot play the file. The file may be formatted with an unsupported codec, or the Internet security setting on your computer is set too high. Lower your browser's security setting, and then try again.%0
//
#define NS_E_WMP_DSHOW_UNSUPPORTED_FORMAT 0xC00D119AL

//
// MessageId: NS_E_WMP_PLAYLIST_EXISTS
//
// MessageText:
//
//  Windows Media Player cannot create the playlist because the name already exists. Type a different playlist name.%0
//
#define NS_E_WMP_PLAYLIST_EXISTS         0xC00D119BL

//
// MessageId: NS_E_WMP_NONMEDIA_FILES
//
// MessageText:
//
//  Windows Media Player could not delete the playlist because it contains non-digital media files. Any digital media files in the playlist were deleted. Use Windows Explorer to delete non-digital media files, and then try deleting the playlist again.%0
//
#define NS_E_WMP_NONMEDIA_FILES          0xC00D119CL

//
// MessageId: NS_E_WMP_INVALID_ASX
//
// MessageText:
//
//  Windows Media Player cannot play the selected playlist.  The format of the playlist is either invalid or is not recognized.%0
//
#define NS_E_WMP_INVALID_ASX             0xC00D119DL

//
// MessageId: NS_E_WMP_ALREADY_IN_USE
//
// MessageText:
//
//  Windows Media Player is already in use. Stop playing any content and close all Player dialog boxes and then try again.%0
//
#define NS_E_WMP_ALREADY_IN_USE          0xC00D119EL

//
// MessageId: NS_E_WMP_IMAPI_FAILURE
//
// MessageText:
//
//  Windows Media Player has encountered an IMAPI error. A better error message will be generated for this in the future.%0
//
#define NS_E_WMP_IMAPI_FAILURE           0xC00D119FL

//
// MessageId: NS_E_WMP_WMDM_FAILURE
//
// MessageText:
//
//  Windows Media Player has encountered a WMDM error. A better error message will be generated for this in the future.%0
//
#define NS_E_WMP_WMDM_FAILURE            0xC00D11A0L

//
// WMP CD Filter Error codes extension
//
//
// MessageId: NS_E_CD_NO_BUFFERS_READ
//
// MessageText:
//
//  Windows Media Player encountered an error when reading the CD-ROM drive in digital mode. You can try to use digital mode again, or you can switch the Player to analog mode.%0
//
#define NS_E_CD_NO_BUFFERS_READ          0xC00D11F8L

//
// MessageId: NS_E_CD_EMPTY_TRACK_QUEUE
//
// MessageText:
//
//  No CD track was specified for playback.%0
//
#define NS_E_CD_EMPTY_TRACK_QUEUE        0xC00D11F9L

//
// MessageId: NS_E_CD_NO_READER
//
// MessageText:
//
//  The CD filter was not able to create the CD reader.%0
//
#define NS_E_CD_NO_READER                0xC00D11FAL



/////////////////////////////////////////////////////////////////////////
//
// Windows Media Server Errors
//
// IdRange = 5000 - 5999
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_REDIRECT
//
// MessageText:
//
//  The client redirected to another server.%0
//
#define NS_E_REDIRECT                    0xC00D1388L

//
// MessageId: NS_E_STALE_PRESENTATION
//
// MessageText:
//
//  The streaming media description is no longer current.%0
//
#define NS_E_STALE_PRESENTATION          0xC00D1389L


 // Namespace Errors

//
// MessageId: NS_E_NAMESPACE_WRONG_PERSIST
//
// MessageText:
//
//  It is not possible to create a persistent namespace node under a transient parent node.%0
//
#define NS_E_NAMESPACE_WRONG_PERSIST     0xC00D138AL

//
// MessageId: NS_E_NAMESPACE_WRONG_TYPE
//
// MessageText:
//
//  It is not possible to store a value in a namespace node that has a different value type.%0
//
#define NS_E_NAMESPACE_WRONG_TYPE        0xC00D138BL

//
// MessageId: NS_E_NAMESPACE_NODE_CONFLICT
//
// MessageText:
//
//  It is not possible to remove the root namespace node.%0
//
#define NS_E_NAMESPACE_NODE_CONFLICT     0xC00D138CL

//
// MessageId: NS_E_NAMESPACE_NODE_NOT_FOUND
//
// MessageText:
//
//  The specified namespace node could not be found.%0
//
#define NS_E_NAMESPACE_NODE_NOT_FOUND    0xC00D138DL

//
// MessageId: NS_E_NAMESPACE_BUFFER_TOO_SMALL
//
// MessageText:
//
//  The buffer supplied to hold namespace node string is too small.%0
//
#define NS_E_NAMESPACE_BUFFER_TOO_SMALL  0xC00D138EL

//
// MessageId: NS_E_NAMESPACE_TOO_MANY_CALLBACKS
//
// MessageText:
//
//  The callback list on a namespace node is at the maximum size.%0
//
#define NS_E_NAMESPACE_TOO_MANY_CALLBACKS 0xC00D138FL

//
// MessageId: NS_E_NAMESPACE_DUPLICATE_CALLBACK
//
// MessageText:
//
//  It is not possible to register an already-registered callback on a namespace node.%0
//
#define NS_E_NAMESPACE_DUPLICATE_CALLBACK 0xC00D1390L

//
// MessageId: NS_E_NAMESPACE_CALLBACK_NOT_FOUND
//
// MessageText:
//
//  Cannot find the callback in the namespace when attempting to remove the callback.%0
//
#define NS_E_NAMESPACE_CALLBACK_NOT_FOUND 0xC00D1391L

//
// MessageId: NS_E_NAMESPACE_NAME_TOO_LONG
//
// MessageText:
//
//  The namespace node name exceeds the allowed maximum length.%0
//
#define NS_E_NAMESPACE_NAME_TOO_LONG     0xC00D1392L

//
// MessageId: NS_E_NAMESPACE_DUPLICATE_NAME
//
// MessageText:
//
//  Cannot create a namespace node that already exists.%0
//
#define NS_E_NAMESPACE_DUPLICATE_NAME    0xC00D1393L

//
// MessageId: NS_E_NAMESPACE_EMPTY_NAME
//
// MessageText:
//
//  The namespace node name cannot be a null string.%0
//
#define NS_E_NAMESPACE_EMPTY_NAME        0xC00D1394L

//
// MessageId: NS_E_NAMESPACE_INDEX_TOO_LARGE
//
// MessageText:
//
//  Finding a child namespace node by index failed because the index exceeded the number of children.%0
//
#define NS_E_NAMESPACE_INDEX_TOO_LARGE   0xC00D1395L

//
// MessageId: NS_E_NAMESPACE_BAD_NAME
//
// MessageText:
//
//  The namespace node name is invalid.%0
//
#define NS_E_NAMESPACE_BAD_NAME          0xC00D1396L

//
// MessageId: NS_E_NAMESPACE_WRONG_SECURITY
//
// MessageText:
//
//  It is not possible to store a value in a namespace node that has a different security type.%0
//
#define NS_E_NAMESPACE_WRONG_SECURITY    0xC00D1397L


 // Cache Errors 5100-5199

//
// MessageId: NS_E_CACHE_ARCHIVE_CONFLICT
//
// MessageText:
//
//  The archive request conflicts with other requests in progress.%0
//
#define NS_E_CACHE_ARCHIVE_CONFLICT      0xC00D13ECL

//
// MessageId: NS_E_CACHE_ORIGIN_SERVER_NOT_FOUND
//
// MessageText:
//
//  The specified origin server cannot be found.%0
//
#define NS_E_CACHE_ORIGIN_SERVER_NOT_FOUND 0xC00D13EDL

//
// MessageId: NS_E_CACHE_ORIGIN_SERVER_TIMEOUT
//
// MessageText:
//
//  The specified origin server is not responding.%0
//
#define NS_E_CACHE_ORIGIN_SERVER_TIMEOUT 0xC00D13EEL

//
// MessageId: NS_E_CACHE_NOT_BROADCAST
//
// MessageText:
//
//  The internal code for HTTP status code 412 Precondition Failed due to not broadcast type.%0
//
#define NS_E_CACHE_NOT_BROADCAST         0xC00D13EFL

//
// MessageId: NS_E_CACHE_CANNOT_BE_CACHED
//
// MessageText:
//
//  The internal code for HTTP status code 403 Forbidden due to not cacheable.%0
//
#define NS_E_CACHE_CANNOT_BE_CACHED      0xC00D13F0L

//
// MessageId: NS_E_CACHE_NOT_MODIFIED
//
// MessageText:
//
//  The internal code for HTTP status code 304 Not Modified.%0
//
#define NS_E_CACHE_NOT_MODIFIED          0xC00D13F1L


// Object Model Errors 5200-5299

//
// MessageId: NS_E_CANNOT_REMOVE_PUBLISHING_POINT
//
// MessageText:
//
//  It is not possible to remove a cache or proxy publishing point.%0
//
#define NS_E_CANNOT_REMOVE_PUBLISHING_POINT 0xC00D1450L

//
// MessageId: NS_E_CANNOT_REMOVE_PLUGIN
//
// MessageText:
//
//  It is not possible to remove the last instance of a type of plug-in.%0
//
#define NS_E_CANNOT_REMOVE_PLUGIN        0xC00D1451L

//
// MessageId: NS_E_WRONG_PUBLISHING_POINT_TYPE
//
// MessageText:
//
//  Cache and proxy publishing points do not support this property or method.%0
//
#define NS_E_WRONG_PUBLISHING_POINT_TYPE 0xC00D1452L

//
// MessageId: NS_E_UNSUPPORTED_LOAD_TYPE
//
// MessageText:
//
//  The plug-in does not support the specified load type.%0
//
#define NS_E_UNSUPPORTED_LOAD_TYPE       0xC00D1453L

//
// MessageId: NS_E_INVALID_PLUGIN_LOAD_TYPE_CONFIGURATION
//
// MessageText:
//
//  The plug-in does not support any load types. The plug-in must support at least one load type.%0
//
#define NS_E_INVALID_PLUGIN_LOAD_TYPE_CONFIGURATION 0xC00D1454L

//
// MessageId: NS_E_INVALID_PUBLISHING_POINT_NAME
//
// MessageText:
//
//  The publishing point name is invalid.%0
//
#define NS_E_INVALID_PUBLISHING_POINT_NAME 0xC00D1455L

//
// MessageId: NS_E_TOO_MANY_MULTICAST_SINKS
//
// MessageText:
//
//  Only one multicast data writer plug-in can be enabled for a publishing point.%0
//
#define NS_E_TOO_MANY_MULTICAST_SINKS    0xC00D1456L

//
// MessageId: NS_E_PUBLISHING_POINT_INVALID_REQUEST_WHILE_STARTED
//
// MessageText:
//
//  The requested operation cannot be completed while the publishing point is started.%0
//
#define NS_E_PUBLISHING_POINT_INVALID_REQUEST_WHILE_STARTED 0xC00D1457L

//
// MessageId: NS_E_MULTICAST_PLUGIN_NOT_ENABLED
//
// MessageText:
//
//  A multicast data writer plug-in must be enabled in order for this operation to be completed.%0
//
#define NS_E_MULTICAST_PLUGIN_NOT_ENABLED 0xC00D1458L

//
// MessageId: NS_E_INVALID_OPERATING_SYSTEM_VERSION
//
// MessageText:
//
//  This feature is not supported on this operating system.%0
//
#define NS_E_INVALID_OPERATING_SYSTEM_VERSION 0xC00D1459L

//
// MessageId: NS_E_PUBLISHING_POINT_REMOVED
//
// MessageText:
//
//  The requested operation cannot be completed because the specified publishing point has been removed.%0
//
#define NS_E_PUBLISHING_POINT_REMOVED    0xC00D145AL

//
// MessageId: NS_E_INVALID_PUSH_PUBLISHING_POINT_START_REQUEST
//
// MessageText:
//
//  Publishing poins configure for push distribution can only be started by an encoder.%0
//
#define NS_E_INVALID_PUSH_PUBLISHING_POINT_START_REQUEST 0xC00D145BL

//
// MessageId: NS_E_UNSUPPORTED_LANGUAGE
//
// MessageText:
//
//  The specified language is not supported.%0
//
#define NS_E_UNSUPPORTED_LANGUAGE        0xC00D145CL


// Playlist Errors 5300-5399

//
// MessageId: NS_E_PLAYLIST_ENTRY_ALREADY_PLAYING
//
// MessageText:
//
//  The playlist entry is already playing.%0
//
#define NS_E_PLAYLIST_ENTRY_ALREADY_PLAYING 0xC00D14B4L

//
// MessageId: NS_E_EMPTY_PLAYLIST
//
// MessageText:
//
//  The playlist or directory you are requesting does not contain content.%0
//
#define NS_E_EMPTY_PLAYLIST              0xC00D14B5L

//
// MessageId: NS_E_PLAYLIST_PARSE_FAILURE
//
// MessageText:
//
//  The server was unable to parse the requested playlist file.%0
//
#define NS_E_PLAYLIST_PARSE_FAILURE      0xC00D14B6L

//
// MessageId: NS_E_PLAYLIST_UNSUPPORTED_ENTRY
//
// MessageText:
//
//  The requested operation is not supported for this type of playlist entry.%0
//
#define NS_E_PLAYLIST_UNSUPPORTED_ENTRY  0xC00D14B7L


// Datapath Errors -- 5400 - 5499

//
// MessageId: NS_E_DATAPATH_NO_SINK
//
// MessageText:
//
//  The data path does not have an associated data writer plug-in.%0
//
#define NS_E_DATAPATH_NO_SINK            0xC00D1518L

//
// MessageId: NS_S_PUBLISHING_POINT_STARTED_WITH_FAILED_SINKS
//
// MessageText:
//
//  The publishing point successfully started, but one or more of the requested data writer plug-ins failed.%0
//
#define NS_S_PUBLISHING_POINT_STARTED_WITH_FAILED_SINKS 0x000D1519L

//
// MessageId: NS_E_INVALID_PUSH_TEMPLATE
//
// MessageText:
//
//  The specified push template is invalid.%0
//
#define NS_E_INVALID_PUSH_TEMPLATE       0xC00D151AL

//
// MessageId: NS_E_INVALID_PUSH_PUBLISHING_POINT
//
// MessageText:
//
//  The specified push publishing point is invalid.%0
//
#define NS_E_INVALID_PUSH_PUBLISHING_POINT 0xC00D151BL

//
// MessageId: NS_E_CRITICAL_ERROR
//
// MessageText:
//
//  The requested operation cannot be performed because the server or publishing point is in a critical error state.%0
//
#define NS_E_CRITICAL_ERROR              0xC00D151CL

//
// MessageId: NS_E_NO_NEW_CONNECTIONS
//
// MessageText:
//
//  The content can not be played because server is not currently accepting connections. Try connecting at a later time.%0
//
#define NS_E_NO_NEW_CONNECTIONS          0xC00D151DL

//
// MessageId: NS_E_WSX_INVALID_VERSION
//
// MessageText:
//
//  The version of this playlist is not supported by the server.%0
//
#define NS_E_WSX_INVALID_VERSION         0xC00D151EL

//
// MessageId: NS_E_HEADER_MISMATCH
//
// MessageText:
//
//  The command does not apply to the current media header user by a server component.%0
//
#define NS_E_HEADER_MISMATCH             0xC00D151FL


// Plugin Errors -- 5500 - 5599

//
// MessageId: NS_E_NO_SCRIPT_ENGINE
//
// MessageText:
//
//  There is no script engine available for this file.%0
//
#define NS_E_NO_SCRIPT_ENGINE            0xC00D157CL

//
// MessageId: NS_E_PLUGIN_ERROR_REPORTED
//
// MessageText:
//
//  The plug-in has reported an error. See the Troubleshooting tab or the NT Application Event Log for details.%0
//
#define NS_E_PLUGIN_ERROR_REPORTED       0xC00D157DL

//
// MessageId: NS_E_SOURCE_PLUGIN_NOT_FOUND
//
// MessageText:
//
//  No enabled data source plug-in is available to access the requested content.%0
//
#define NS_E_SOURCE_PLUGIN_NOT_FOUND     0xC00D157EL

//
// MessageId: NS_E_PLAYLIST_PLUGIN_NOT_FOUND
//
// MessageText:
//
//  No enabled playlist parser plug-in is available to access the requested content.%0
//
#define NS_E_PLAYLIST_PLUGIN_NOT_FOUND   0xC00D157FL

//
// MessageId: NS_E_DATA_SOURCE_ENUMERATION_NOT_SUPPORTED
//
// MessageText:
//
//  The data source plug-in does not support enumeration.%0
//
#define NS_E_DATA_SOURCE_ENUMERATION_NOT_SUPPORTED 0xC00D1580L

//
// MessageId: NS_E_MEDIA_PARSER_INVALID_FORMAT
//
// MessageText:
//
//  The server cannot stream the selected file because it is either damaged or corrupt. Select a different file.%0
//
#define NS_E_MEDIA_PARSER_INVALID_FORMAT 0xC00D1581L

//
// MessageId: NS_E_SCRIPT_DEBUGGER_NOT_INSTALLED
//
// MessageText:
//
//  The plug-in cannot be enabled because a compatible script debugger is not installed on this system.  Install a script debugger, or disable the script debugger option on the general tab of the plug-in's properties page and try again.%0
//
#define NS_E_SCRIPT_DEBUGGER_NOT_INSTALLED 0xC00D1582L



/////////////////////////////////////////////////////////////////////////
//
// Windows Media Tools Errors
//
// IdRange = 7000 - 7999
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_BAD_MARKIN
//
// MessageText:
//
//  The Mark In time should be greater than 0 and less than Mark Out time.%0
//
#define NS_E_BAD_MARKIN                  0xC00D1B58L

//
// MessageId: NS_E_BAD_MARKOUT
//
// MessageText:
//
//  The Mark Out time should be greater than Mark In time and less than file duration.%0
//
#define NS_E_BAD_MARKOUT                 0xC00D1B59L

//
// MessageId: NS_E_NOMATCHING_MEDIASOURCE
//
// MessageText:
//
//  No matching media source is found in source group %1.%0
//
#define NS_E_NOMATCHING_MEDIASOURCE      0xC00D1B5AL

//
// MessageId: NS_E_UNSUPPORTED_SOURCETYPE
//
// MessageText:
//
//  Unsupported source type.%0
//
#define NS_E_UNSUPPORTED_SOURCETYPE      0xC00D1B5BL

//
// MessageId: NS_E_TOO_MANY_AUDIO
//
// MessageText:
//
//  No more than 1 audio input is allowed.%0
//
#define NS_E_TOO_MANY_AUDIO              0xC00D1B5CL

//
// MessageId: NS_E_TOO_MANY_VIDEO
//
// MessageText:
//
//  No more than 2 video inputs are allowed.%0
//
#define NS_E_TOO_MANY_VIDEO              0xC00D1B5DL

//
// MessageId: NS_E_NOMATCHING_ELEMENT
//
// MessageText:
//
//  No matching element is found in the list.%0
//
#define NS_E_NOMATCHING_ELEMENT          0xC00D1B5EL

//
// MessageId: NS_E_MISMATCHED_MEDIACONTENT
//
// MessageText:
//
//  The profile's media content doesn't match the media content defined in the source group.%0
//
#define NS_E_MISMATCHED_MEDIACONTENT     0xC00D1B5FL

//
// MessageId: NS_E_CANNOT_DELETE_ACTIVE_SOURCEGROUP
//
// MessageText:
//
//  Cannot remove an active source group from the source group collection while encoder is currently running.%0
//
#define NS_E_CANNOT_DELETE_ACTIVE_SOURCEGROUP 0xC00D1B60L

//
// MessageId: NS_E_AUDIODEVICE_BUSY
//
// MessageText:
//
//  Cannot open specified audio capture device because it is in use right now.%0
//
#define NS_E_AUDIODEVICE_BUSY            0xC00D1B61L

//
// MessageId: NS_E_AUDIODEVICE_UNEXPECTED
//
// MessageText:
//
//  Cannot open specified audio capture device because unexpected error occurred.%0
//
#define NS_E_AUDIODEVICE_UNEXPECTED      0xC00D1B62L

//
// MessageId: NS_E_AUDIODEVICE_BADFORMAT
//
// MessageText:
//
//  Audio capture device doesn't support specified audio format.%0
//
#define NS_E_AUDIODEVICE_BADFORMAT       0xC00D1B63L

//
// MessageId: NS_E_VIDEODEVICE_BUSY
//
// MessageText:
//
//  Cannot open specified video capture device because it is in use right now.%0
//
#define NS_E_VIDEODEVICE_BUSY            0xC00D1B64L

//
// MessageId: NS_E_VIDEODEVICE_UNEXPECTED
//
// MessageText:
//
//  Cannot open specified video capture device because unexpected error occurred.%0
//
#define NS_E_VIDEODEVICE_UNEXPECTED      0xC00D1B65L

//
// MessageId: NS_E_INVALIDCALL_WHILE_ENCODER_RUNNING
//
// MessageText:
//
//  This operation is not allowed while encoder is running.%0
//
#define NS_E_INVALIDCALL_WHILE_ENCODER_RUNNING 0xC00D1B66L

//
// MessageId: NS_E_NO_PROFILE_IN_SOURCEGROUP
//
// MessageText:
//
//  No profile is set in source group.%0
//
#define NS_E_NO_PROFILE_IN_SOURCEGROUP   0xC00D1B67L

//
// MessageId: NS_E_VIDEODRIVER_UNSTABLE
//
// MessageText:
//
//  The video capture driver returned an unrecoverable error.  It is now in an unstable state.%0
//
#define NS_E_VIDEODRIVER_UNSTABLE        0xC00D1B68L

//
// MessageId: NS_E_VIDCAPSTARTFAILED
//
// MessageText:
//
//  The video input device could not be started.%0
//
#define NS_E_VIDCAPSTARTFAILED           0xC00D1B69L

//
// MessageId: NS_E_VIDSOURCECOMPRESSION
//
// MessageText:
//
//  The video input source does not support the requested output format or color depth.%0
//
#define NS_E_VIDSOURCECOMPRESSION        0xC00D1B6AL

//
// MessageId: NS_E_VIDSOURCESIZE
//
// MessageText:
//
//  The video input source does not support the request capture size.%0
//
#define NS_E_VIDSOURCESIZE               0xC00D1B6BL

//
// MessageId: NS_E_ICMQUERYFORMAT
//
// MessageText:
//
//  Unable to obtain output information from video compressor.%0
//
#define NS_E_ICMQUERYFORMAT              0xC00D1B6CL

//
// MessageId: NS_E_VIDCAPCREATEWINDOW
//
// MessageText:
//
//  Unable to create video capture window.%0
//
#define NS_E_VIDCAPCREATEWINDOW          0xC00D1B6DL

//
// MessageId: NS_E_VIDCAPDRVINUSE
//
// MessageText:
//
//  There already is a running stream active on this video input device.%0
//
#define NS_E_VIDCAPDRVINUSE              0xC00D1B6EL

//
// MessageId: NS_E_NO_MEDIAFORMAT_IN_SOURCE
//
// MessageText:
//
//  No media format is set in source.%0
//
#define NS_E_NO_MEDIAFORMAT_IN_SOURCE    0xC00D1B6FL

//
// MessageId: NS_E_NO_VALID_OUTPUT_STREAM
//
// MessageText:
//
//  Cannot find valid output stream from source.%0
//
#define NS_E_NO_VALID_OUTPUT_STREAM      0xC00D1B70L

//
// MessageId: NS_E_NO_VALID_SOURCE_PLUGIN
//
// MessageText:
//
//  Cannot find valid source plug-in to support specified source.%0
//
#define NS_E_NO_VALID_SOURCE_PLUGIN      0xC00D1B71L

//
// MessageId: NS_E_NO_ACTIVE_SOURCEGROUP
//
// MessageText:
//
//  No source group is currently active.%0
//
#define NS_E_NO_ACTIVE_SOURCEGROUP       0xC00D1B72L

//
// MessageId: NS_E_NO_SCRIPT_STREAM
//
// MessageText:
//
//  No script stream is set in current active source group.%0
//
#define NS_E_NO_SCRIPT_STREAM            0xC00D1B73L

//
// MessageId: NS_E_INVALIDCALL_WHILE_ARCHIVAL_RUNNING
//
// MessageText:
//
//  This operation is not allowed when file archival is started.%0
//
#define NS_E_INVALIDCALL_WHILE_ARCHIVAL_RUNNING 0xC00D1B74L

//
// MessageId: NS_E_INVALIDPACKETSIZE
//
// MessageText:
//
//  The MaxPacketSize value specified is invalid.%0
//
#define NS_E_INVALIDPACKETSIZE           0xC00D1B75L

//
// MessageId: NS_E_PLUGIN_CLSID_INVALID
//
// MessageText:
//
//  The plug-in CLSID specified is invalid.%0
//
#define NS_E_PLUGIN_CLSID_INVALID        0xC00D1B76L

//
// MessageId: NS_E_UNSUPPORTED_ARCHIVETYPE
//
// MessageText:
//
//  This Archive type is not supported.%0
//
#define NS_E_UNSUPPORTED_ARCHIVETYPE     0xC00D1B77L

//
// MessageId: NS_E_UNSUPPORTED_ARCHIVEOPERATION
//
// MessageText:
//
//  This Archive operation is not supported.%0
//
#define NS_E_UNSUPPORTED_ARCHIVEOPERATION 0xC00D1B78L

//
// MessageId: NS_E_ARCHIVE_FILENAME_NOTSET
//
// MessageText:
//
//  The local archive filename was not set.%0
//
#define NS_E_ARCHIVE_FILENAME_NOTSET     0xC00D1B79L

//
// MessageId: NS_E_SOURCEGROUP_NOTPREPARED
//
// MessageText:
//
//  The SourceGroup is not yet prepared.%0
//
#define NS_E_SOURCEGROUP_NOTPREPARED     0xC00D1B7AL

//
// MessageId: NS_E_PROFILE_MISMATCH
//
// MessageText:
//
//  Profiles on the sourcegroups do not match.%0
//
#define NS_E_PROFILE_MISMATCH            0xC00D1B7BL

//
// MessageId: NS_E_INCORRECTCLIPSETTINGS
//
// MessageText:
//
//  The clip settings specified on the source are incorrect.%0
//
#define NS_E_INCORRECTCLIPSETTINGS       0xC00D1B7CL

//
// MessageId: NS_E_NOSTATSAVAILABLE
//
// MessageText:
//
//  No statistics are available at this time.%0
//
#define NS_E_NOSTATSAVAILABLE            0xC00D1B7DL

//
// MessageId: NS_E_NOTARCHIVING
//
// MessageText:
//
//  Encoder is not archiving.%0
//
#define NS_E_NOTARCHIVING                0xC00D1B7EL

//
// MessageId: NS_E_INVALIDCALL_WHILE_ENCODER_STOPPED
//
// MessageText:
//
//  This operation is not allowed while encoder is not running.%0
//
#define NS_E_INVALIDCALL_WHILE_ENCODER_STOPPED 0xC00D1B7FL

//
// MessageId: NS_E_NOSOURCEGROUPS
//
// MessageText:
//
//  This SourceGroupCollection doesnt contain any SourceGroups.%0
//
#define NS_E_NOSOURCEGROUPS              0xC00D1B80L

//
// MessageId: NS_E_INVALIDINPUTFPS
//
// MessageText:
//
//  Because this source group does not have a frame rate of 30 frames per second, you cannot use the inverse telecine feature.%0
//
#define NS_E_INVALIDINPUTFPS             0xC00D1B81L

//
// MessageId: NS_E_NO_DATAVIEW_SUPPORT
//
// MessageText:
//
//  Internal problems are preventing the preview or postview of your content.%0
//
#define NS_E_NO_DATAVIEW_SUPPORT         0xC00D1B82L

//
// MessageId: NS_E_CODEC_UNAVAILABLE
//
// MessageText:
//
//  One or more codecs required to open this media could not be found.%0
//
#define NS_E_CODEC_UNAVAILABLE           0xC00D1B83L

//
// MessageId: NS_E_ARCHIVE_SAME_AS_INPUT
//
// MessageText:
//
//  The output archive file specified is the same as an input source in one of the source groups.%0
//
#define NS_E_ARCHIVE_SAME_AS_INPUT       0xC00D1B84L

//
// MessageId: NS_E_SOURCE_NOTSPECIFIED
//
// MessageText:
//
//  The input source has not been setup completely.%0
//
#define NS_E_SOURCE_NOTSPECIFIED         0xC00D1B85L

//
// MessageId: NS_E_NO_REALTIME_TIMECOMPRESSION
//
// MessageText:
//
//  Cannot apply time compression transform plug-in to a real time broadcast session.%0
//
#define NS_E_NO_REALTIME_TIMECOMPRESSION 0xC00D1B86L

//
// MessageId: NS_E_UNSUPPORTED_ENCODER_DEVICE
//
// MessageText:
//
//  The Encoder was unable to open this device. Please see the system requirements for more information.%0
//
#define NS_E_UNSUPPORTED_ENCODER_DEVICE  0xC00D1B87L

//
// MessageId: NS_E_UNEXPECTED_DISPLAY_SETTINGS
//
// MessageText:
//
//  Encoding cannot start because the display size or color setting has changed since the current session was defined. Restore the previous settings or create a new session.%0
//
#define NS_E_UNEXPECTED_DISPLAY_SETTINGS 0xC00D1B88L

//
// MessageId: NS_E_NO_AUDIODATA
//
// MessageText:
//
//  No audio data has been received for multiple seconds.  Check the audio source and restart the encoder.%0
//
#define NS_E_NO_AUDIODATA                0xC00D1B89L

//
// MessageId: NS_E_INPUTSOURCE_PROBLEM
//
// MessageText:
//
//  One or all of your specified input sources are not working properly. Make sure your input sources are configured correctly.%0
//
#define NS_E_INPUTSOURCE_PROBLEM         0xC00D1B8AL

//
// MessageId: NS_E_WME_VERSION_MISMATCH
//
// MessageText:
//
//  The supplied configuration file is not supported by this version of the encoder.%0
//
#define NS_E_WME_VERSION_MISMATCH        0xC00D1B8BL

//
// MessageId: NS_E_NO_REALTIME_PREPROCESS
//
// MessageText:
//
//  Image pre-process can not be used with realtime encoding.%0
//
#define NS_E_NO_REALTIME_PREPROCESS      0xC00D1B8CL

//
// MessageId: NS_E_NO_REPEAT_PREPROCESS
//
// MessageText:
//
//  Image pre-process can not be used when source is set to loop.%0
//
#define NS_E_NO_REPEAT_PREPROCESS        0xC00D1B8DL

//
// MessageId: NS_E_CANNOT_PAUSE_LIVEBROADCAST
//
// MessageText:
//
//  Pause encoder is forbidden because the encoding session is live broadcast.%0
//
#define NS_E_CANNOT_PAUSE_LIVEBROADCAST  0xC00D1B8EL

//
// MessageId: NS_E_DRM_PROFILE_NOT_SET
//
// MessageText:
//
//  DRM Profile is not set on the current encoding session.%0
//
#define NS_E_DRM_PROFILE_NOT_SET         0xC00D1B8FL

//
// MessageId: NS_E_DUPLICATE_DRMPROFILE
//
// MessageText:
//
//  The profile ID is already used by a DRM Profile in the system.  Please use a different profile ID.%0
//
#define NS_E_DUPLICATE_DRMPROFILE        0xC00D1B90L

//
// MessageId: NS_E_INVALID_DEVICE
//
// MessageText:
//
//  Setting of the selected device doesn't support control for playing back tapes.%0
//
#define NS_E_INVALID_DEVICE              0xC00D1B91L

//
// MessageId: NS_E_SPEECHEDL_ON_NON_MIXEDMODE
//
// MessageText:
//
//  Cannot set speech EDL when speech encoding mode is not set to mixed mode.%0
//
#define NS_E_SPEECHEDL_ON_NON_MIXEDMODE  0xC00D1B92L

//
// MessageId: NS_E_DRM_PASSWORD_TOO_LONG
//
// MessageText:
//
//  The password you specified is too long.  Please specify a password with no more than 8 characters.%0
//
#define NS_E_DRM_PASSWORD_TOO_LONG       0xC00D1B93L

//
// MessageId: NS_E_DEVCONTROL_FAILED_SEEK
//
// MessageText:
//
//  Device Control cannot successfully seek to the specified Mark-In point.%0
//
#define NS_E_DEVCONTROL_FAILED_SEEK      0xC00D1B94L


/////////////////////////////////////////////////////////////////////////
//
// DRM Specific Errors
//
// IdRange = 10000..10999
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_E_DRM_INVALID_APPLICATION
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_INVALID_APPLICATION     0xC00D2711L

//
// MessageId: NS_E_DRM_LICENSE_STORE_ERROR
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_STORE_ERROR     0xC00D2712L

//
// MessageId: NS_E_DRM_SECURE_STORE_ERROR
//
// MessageText:
//
//  Secure storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_SECURE_STORE_ERROR      0xC00D2713L

//
// MessageId: NS_E_DRM_LICENSE_STORE_SAVE_ERROR
//
// MessageText:
//
//  License acquisition did not work. Acquire a new license or contact the content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_STORE_SAVE_ERROR 0xC00D2714L

//
// MessageId: NS_E_DRM_SECURE_STORE_UNLOCK_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_SECURE_STORE_UNLOCK_ERROR 0xC00D2715L

//
// MessageId: NS_E_DRM_INVALID_CONTENT
//
// MessageText:
//
//  The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_INVALID_CONTENT         0xC00D2716L

//
// MessageId: NS_E_DRM_UNABLE_TO_OPEN_LICENSE
//
// MessageText:
//
//  The license is corrupted. Acquire a new license.%0
//
#define NS_E_DRM_UNABLE_TO_OPEN_LICENSE  0xC00D2717L

//
// MessageId: NS_E_DRM_INVALID_LICENSE
//
// MessageText:
//
//  The license is corrupted or invalid. Acquire a new license%0
//
#define NS_E_DRM_INVALID_LICENSE         0xC00D2718L

//
// MessageId: NS_E_DRM_INVALID_MACHINE
//
// MessageText:
//
//  Licenses cannot be copied from one computer to another. Use License Management to transfer licenses, or get a new license for the media file.%0
//
#define NS_E_DRM_INVALID_MACHINE         0xC00D2719L

//
// MessageId: NS_E_DRM_ENUM_LICENSE_FAILED
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_ENUM_LICENSE_FAILED     0xC00D271BL

//
// MessageId: NS_E_DRM_INVALID_LICENSE_REQUEST
//
// MessageText:
//
//  The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_INVALID_LICENSE_REQUEST 0xC00D271CL

//
// MessageId: NS_E_DRM_UNABLE_TO_INITIALIZE
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_UNABLE_TO_INITIALIZE    0xC00D271DL

//
// MessageId: NS_E_DRM_UNABLE_TO_ACQUIRE_LICENSE
//
// MessageText:
//
//  The license could not be acquired. Try again later.%0
//
#define NS_E_DRM_UNABLE_TO_ACQUIRE_LICENSE 0xC00D271EL

//
// MessageId: NS_E_DRM_INVALID_LICENSE_ACQUIRED
//
// MessageText:
//
//  License acquisition did not work. Acquire a new license or contact the content provider for further assistance.%0
//
#define NS_E_DRM_INVALID_LICENSE_ACQUIRED 0xC00D271FL

//
// MessageId: NS_E_DRM_NO_RIGHTS
//
// MessageText:
//
//  The requested operation cannot be performed on this file.%0
//
#define NS_E_DRM_NO_RIGHTS               0xC00D2720L

//
// MessageId: NS_E_DRM_KEY_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_KEY_ERROR               0xC00D2721L

//
// MessageId: NS_E_DRM_ENCRYPT_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_ENCRYPT_ERROR           0xC00D2722L

//
// MessageId: NS_E_DRM_DECRYPT_ERROR
//
// MessageText:
//
//  The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_DECRYPT_ERROR           0xC00D2723L

//
// MessageId: NS_E_DRM_LICENSE_INVALID_XML
//
// MessageText:
//
//  The license is corrupted. Acquire a new license.%0
//
#define NS_E_DRM_LICENSE_INVALID_XML     0xC00D2725L

//
// MessageId: NS_S_DRM_LICENSE_ACQUIRED
//
// MessageText:
//
//  Status message: The license was acquired.%0
//
#define NS_S_DRM_LICENSE_ACQUIRED        0x000D2726L

//
// MessageId: NS_S_DRM_INDIVIDUALIZED
//
// MessageText:
//
//  Status message: The security upgrade has been completed.%0
//
#define NS_S_DRM_INDIVIDUALIZED          0x000D2727L

//
// MessageId: NS_E_DRM_NEEDS_INDIVIDUALIZATION
//
// MessageText:
//
//  A security upgrade is required to perform the operation on this media file.%0
//
#define NS_E_DRM_NEEDS_INDIVIDUALIZATION 0xC00D2728L

//
// MessageId: NS_E_DRM_ACTION_NOT_QUERIED
//
// MessageText:
//
//  The application cannot perform this action. Contact product support for this application.%0
//
#define NS_E_DRM_ACTION_NOT_QUERIED      0xC00D272AL

//
// MessageId: NS_E_DRM_ACQUIRING_LICENSE
//
// MessageText:
//
//  You cannot begin a new license acquisition process until the current one has been completed.%0
//
#define NS_E_DRM_ACQUIRING_LICENSE       0xC00D272BL

//
// MessageId: NS_E_DRM_INDIVIDUALIZING
//
// MessageText:
//
//  You cannot begin a new security upgrade until the current one has been completed.%0
//
#define NS_E_DRM_INDIVIDUALIZING         0xC00D272CL

//
// MessageId: NS_E_DRM_PARAMETERS_MISMATCHED
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_PARAMETERS_MISMATCHED   0xC00D272FL

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_LICENSE_OBJECT
//
// MessageText:
//
//  A license cannot be created for this media file. Reinstall the application.%0
//
#define NS_E_DRM_UNABLE_TO_CREATE_LICENSE_OBJECT 0xC00D2730L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_INDI_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_INDI_OBJECT 0xC00D2731L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_ENCRYPT_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_ENCRYPT_OBJECT 0xC00D2732L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_DECRYPT_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_DECRYPT_OBJECT 0xC00D2733L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_PROPERTIES_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_PROPERTIES_OBJECT 0xC00D2734L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_BACKUP_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_BACKUP_OBJECT 0xC00D2735L

//
// MessageId: NS_E_DRM_INDIVIDUALIZE_ERROR
//
// MessageText:
//
//  The security upgrade failed. Try again later.%0
//
#define NS_E_DRM_INDIVIDUALIZE_ERROR     0xC00D2736L

//
// MessageId: NS_E_DRM_LICENSE_OPEN_ERROR
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_OPEN_ERROR      0xC00D2737L

//
// MessageId: NS_E_DRM_LICENSE_CLOSE_ERROR
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_CLOSE_ERROR     0xC00D2738L

//
// MessageId: NS_E_DRM_GET_LICENSE_ERROR
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_GET_LICENSE_ERROR       0xC00D2739L

//
// MessageId: NS_E_DRM_QUERY_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_QUERY_ERROR             0xC00D273AL

//
// MessageId: NS_E_DRM_REPORT_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_REPORT_ERROR            0xC00D273BL

//
// MessageId: NS_E_DRM_GET_LICENSESTRING_ERROR
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_GET_LICENSESTRING_ERROR 0xC00D273CL

//
// MessageId: NS_E_DRM_GET_CONTENTSTRING_ERROR
//
// MessageText:
//
//  The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_GET_CONTENTSTRING_ERROR 0xC00D273DL

//
// MessageId: NS_E_DRM_MONITOR_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Try again later.%0
//
#define NS_E_DRM_MONITOR_ERROR           0xC00D273EL

//
// MessageId: NS_E_DRM_UNABLE_TO_SET_PARAMETER
//
// MessageText:
//
//  The application has made an invalid call to the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_UNABLE_TO_SET_PARAMETER 0xC00D273FL

//
// MessageId: NS_E_DRM_INVALID_APPDATA
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_INVALID_APPDATA         0xC00D2740L

//
// MessageId: NS_E_DRM_INVALID_APPDATA_VERSION
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0.
//
#define NS_E_DRM_INVALID_APPDATA_VERSION 0xC00D2741L

//
// MessageId: NS_E_DRM_BACKUP_EXISTS
//
// MessageText:
//
//  Licenses are already backed up in this location.%0
//
#define NS_E_DRM_BACKUP_EXISTS           0xC00D2742L

//
// MessageId: NS_E_DRM_BACKUP_CORRUPT
//
// MessageText:
//
//  One or more backed-up licenses are missing or corrupt.%0
//
#define NS_E_DRM_BACKUP_CORRUPT          0xC00D2743L

//
// MessageId: NS_E_DRM_BACKUPRESTORE_BUSY
//
// MessageText:
//
//  You cannot begin a new backup process until the current process has been completed.%0
//
#define NS_E_DRM_BACKUPRESTORE_BUSY      0xC00D2744L

//
// MessageId: NS_S_DRM_MONITOR_CANCELLED
//
// MessageText:
//
//  Status message: License monitoring has been cancelled.%0
//
#define NS_S_DRM_MONITOR_CANCELLED       0x000D2746L

//
// MessageId: NS_S_DRM_ACQUIRE_CANCELLED
//
// MessageText:
//
//  Status message: License acquisition has been cancelled.%0
//
#define NS_S_DRM_ACQUIRE_CANCELLED       0x000D2747L

//
// MessageId: NS_E_DRM_LICENSE_UNUSABLE
//
// MessageText:
//
//  The license is invalid. Contact the content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_UNUSABLE        0xC00D2748L

//
// MessageId: NS_E_DRM_INVALID_PROPERTY
//
// MessageText:
//
//  A required property was not set by the application. Contact product support for this application.%0.
//
#define NS_E_DRM_INVALID_PROPERTY        0xC00D2749L

//
// MessageId: NS_E_DRM_SECURE_STORE_NOT_FOUND
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component of this application. Try to acquire a license again.%0
//
#define NS_E_DRM_SECURE_STORE_NOT_FOUND  0xC00D274AL

//
// MessageId: NS_E_DRM_CACHED_CONTENT_ERROR
//
// MessageText:
//
//  A license cannot be found for this media file. Use License Management to transfer a license for this file from the original computer, or acquire a new license.%0
//
#define NS_E_DRM_CACHED_CONTENT_ERROR    0xC00D274BL

//
// MessageId: NS_E_DRM_INDIVIDUALIZATION_INCOMPLETE
//
// MessageText:
//
//  A problem occurred during the security upgrade. Try again later.%0
//
#define NS_E_DRM_INDIVIDUALIZATION_INCOMPLETE 0xC00D274CL

//
// MessageId: NS_E_DRM_DRIVER_AUTH_FAILURE
//
// MessageText:
//
//  Certified driver components are required to play this media file. Contact Windows Update to see whether updated drivers are available for your hardware.%0
//
#define NS_E_DRM_DRIVER_AUTH_FAILURE     0xC00D274DL

//
// MessageId: NS_E_DRM_NEED_UPGRADE
//
// MessageText:
//
//  A new version of the Digital Rights Management component is required. Contact product support for this application to get the latest version.%0
//
#define NS_E_DRM_NEED_UPGRADE            0xC00D274EL

//
// MessageId: NS_E_DRM_REOPEN_CONTENT
//
// MessageText:
//
//  Status message: Reopen the file.%0
//
#define NS_E_DRM_REOPEN_CONTENT          0xC00D274FL

//
// MessageId: NS_E_DRM_DRIVER_DIGIOUT_FAILURE
//
// MessageText:
//
//  Certain driver functionality is required to play this media file. Contact Windows Update to see whether updated drivers are available for your hardware.%0
//
#define NS_E_DRM_DRIVER_DIGIOUT_FAILURE  0xC00D2750L

//
// MessageId: NS_E_DRM_INVALID_SECURESTORE_PASSWORD
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_INVALID_SECURESTORE_PASSWORD 0xC00D2751L

//
// MessageId: NS_E_DRM_APPCERT_REVOKED
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_APPCERT_REVOKED         0xC00D2752L

//
// MessageId: NS_E_DRM_RESTORE_FRAUD
//
// MessageText:
//
//  You cannot restore your license(s).%0
//
#define NS_E_DRM_RESTORE_FRAUD           0xC00D2753L

//
// MessageId: NS_E_DRM_HARDWARE_INCONSISTENT
//
// MessageText:
//
//  The licenses for your media files are corrupted. Contact Microsoft product support.%0
//
#define NS_E_DRM_HARDWARE_INCONSISTENT   0xC00D2754L

//
// MessageId: NS_E_DRM_SDMI_TRIGGER
//
// MessageText:
//
//  To transfer this media file, you must upgrade the application.%0
//
#define NS_E_DRM_SDMI_TRIGGER            0xC00D2755L

//
// MessageId: NS_E_DRM_SDMI_NOMORECOPIES
//
// MessageText:
//
//  You cannot make any more copies of this media file.%0
//
#define NS_E_DRM_SDMI_NOMORECOPIES       0xC00D2756L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_HEADER_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_HEADER_OBJECT 0xC00D2757L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_KEYS_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_KEYS_OBJECT 0xC00D2758L

;// This error is never shown to user but needed for program logic.
//
// MessageId: NS_E_DRM_LICENSE_NOTACQUIRED
//
// MessageText:
//
//  Unable to obtain license.%0
//
#define NS_E_DRM_LICENSE_NOTACQUIRED     0xC00D2759L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_CODING_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_CODING_OBJECT 0xC00D275AL

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_STATE_DATA_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_STATE_DATA_OBJECT 0xC00D275BL

//
// MessageId: NS_E_DRM_BUFFER_TOO_SMALL
//
// MessageText:
//
//  The buffer supplied is not sufficient.%0.
//
#define NS_E_DRM_BUFFER_TOO_SMALL        0xC00D275CL

//
// MessageId: NS_E_DRM_UNSUPPORTED_PROPERTY
//
// MessageText:
//
//  The property requested is not supported.%0.
//
#define NS_E_DRM_UNSUPPORTED_PROPERTY    0xC00D275DL

//
// MessageId: NS_E_DRM_ERROR_BAD_NET_RESP
//
// MessageText:
//
//  The specified server cannot perform the requested operation.%0.
//
#define NS_E_DRM_ERROR_BAD_NET_RESP      0xC00D275EL

//
// MessageId: NS_E_DRM_STORE_NOTALLSTORED
//
// MessageText:
//
//  Some of the licenses could not be stored.%0.
//
#define NS_E_DRM_STORE_NOTALLSTORED      0xC00D275FL

//
// MessageId: NS_E_DRM_SECURITY_COMPONENT_SIGNATURE_INVALID
//
// MessageText:
//
//  The Digital Rights Management security upgrade component could not be validated. Contact Microsoft product support.%0
//
#define NS_E_DRM_SECURITY_COMPONENT_SIGNATURE_INVALID 0xC00D2760L

//
// MessageId: NS_E_DRM_INVALID_DATA
//
// MessageText:
//
//  Invalid or corrupt data was encountered.%0
//
#define NS_E_DRM_INVALID_DATA            0xC00D2761L

//
// MessageId: NS_E_DRM_UNABLE_TO_CONTACT_SERVER
//
// MessageText:
//
//  Unable to contact the server for the requested operation.%0
//
#define NS_E_DRM_UNABLE_TO_CONTACT_SERVER 0xC00D2762L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_AUTHENTICATION_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_AUTHENTICATION_OBJECT 0xC00D2763L

//
// MessageId: NS_E_DRM_NOT_CONFIGURED
//
// MessageText:
//
//  Not all of the necessary properties for DRM have been set.%0
//
#define NS_E_DRM_NOT_CONFIGURED          0xC00D2764L

;// License Reasons Section
;// Error Codes why a license is not usable. Reserve 10200..10300 for this purpose.
;// 10200..10249 is for license reported reasons. 10250..10300 is for client detected reasons.
//
// MessageId: NS_E_DRM_LICENSE_EXPIRED
//
// MessageText:
//
//  The license for this file has expired and is no longer valid. Contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_EXPIRED         0xC00D27D8L

//
// MessageId: NS_E_DRM_LICENSE_NOTENABLED
//
// MessageText:
//
//  The license for this file is not valid yet, but will be at a future date.%0
//
#define NS_E_DRM_LICENSE_NOTENABLED      0xC00D27D9L

//
// MessageId: NS_E_DRM_LICENSE_APPSECLOW
//
// MessageText:
//
//  The license for this file requires a higher level of security than the player you are currently using has. Try using a different player or download a newer version of your current player.%0
//
#define NS_E_DRM_LICENSE_APPSECLOW       0xC00D27DAL

//
// MessageId: NS_E_DRM_STORE_NEEDINDI
//
// MessageText:
//
//  The license cannot be stored as it requires security upgrade of Digital Rights Management component.%0.
//
#define NS_E_DRM_STORE_NEEDINDI          0xC00D27DBL

//
// MessageId: NS_E_DRM_STORE_NOTALLOWED
//
// MessageText:
//
//  Your machine does not meet the requirements for storing the license.%0.
//
#define NS_E_DRM_STORE_NOTALLOWED        0xC00D27DCL

//
// MessageId: NS_E_DRM_LICENSE_APP_NOTALLOWED
//
// MessageText:
//
//  The license for this file requires an upgraded version of your player or a different player.%0.
//
#define NS_E_DRM_LICENSE_APP_NOTALLOWED  0xC00D27DDL

//
// MessageId: NS_S_DRM_NEEDS_INDIVIDUALIZATION
//
// MessageText:
//
//  A security upgrade is required to perform the operation on this media file.%0
//
#define NS_S_DRM_NEEDS_INDIVIDUALIZATION 0x000D27DEL

//
// MessageId: NS_E_DRM_LICENSE_CERT_EXPIRED
//
// MessageText:
//
//  The license server's certificate expired. Make sure your system clock is set correctly. Contact your content provider for further assistance. %0.
//
#define NS_E_DRM_LICENSE_CERT_EXPIRED    0xC00D27DFL

//
// MessageId: NS_E_DRM_LICENSE_SECLOW
//
// MessageText:
//
//  The license for this file requires a higher level of security than the player you are currently using has. Try using a different player or download a newer version of your current player.%0
//
#define NS_E_DRM_LICENSE_SECLOW          0xC00D27E0L

//
// MessageId: NS_E_DRM_LICENSE_CONTENT_REVOKED
//
// MessageText:
//
//  The content owner for the license you just acquired is no longer supporting their content. Contact the content owner for a newer version of the content.%0
//
#define NS_E_DRM_LICENSE_CONTENT_REVOKED 0xC00D27E1L

//
// MessageId: NS_E_DRM_LICENSE_NOSAP
//
// MessageText:
//
//  The license for this file requires a feature that is not supported in your current player or operating system. You can try with newer version of your current player or contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOSAP           0xC00D280AL

//
// MessageId: NS_E_DRM_LICENSE_NOSVP
//
// MessageText:
//
//  The license for this file requires a feature that is not supported in your current player or operating system. You can try with newer version of your current player or contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOSVP           0xC00D280BL

//
// MessageId: NS_E_DRM_LICENSE_NOWDM
//
// MessageText:
//
//  The license for this file requires Windows Driver Model (WDM) audio drivers. Contact your sound card manufacturer for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOWDM           0xC00D280CL

//
// MessageId: NS_E_DRM_LICENSE_NOTRUSTEDCODEC
//
// MessageText:
//
//  The license for this file requires a higher level of security than the player you are currently using has. Try using a different player or download a newer version of your current player.%0
//
#define NS_E_DRM_LICENSE_NOTRUSTEDCODEC  0xC00D280DL

;// End of License Reasons Section


/////////////////////////////////////////////////////////////////////////
//
// Windows Media Setup Specific Errors
//
// IdRange = 11000..11999
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_S_REBOOT_RECOMMENDED
//
// MessageText:
//
//  The requested operation is successful.  Some cleanup will not be complete until the system is rebooted.%0
//
#define NS_S_REBOOT_RECOMMENDED          0x000D2AF8L

//
// MessageId: NS_S_REBOOT_REQUIRED
//
// MessageText:
//
//  The requested operation is successful.  The system will not function correctly until the system is rebooted.%0
//
#define NS_S_REBOOT_REQUIRED             0x000D2AF9L

//
// MessageId: NS_E_REBOOT_RECOMMENDED
//
// MessageText:
//
//  The requested operation failed.  Some cleanup will not be complete until the system is rebooted.%0
//
#define NS_E_REBOOT_RECOMMENDED          0xC00D2AFAL

//
// MessageId: NS_E_REBOOT_REQUIRED
//
// MessageText:
//
//  The requested operation failed.  The system will not function correctly until the system is rebooted.%0
//
#define NS_E_REBOOT_REQUIRED             0xC00D2AFBL


/////////////////////////////////////////////////////////////////////////
//
// Windows Media Networking Errors
//
// IdRange = 12000..12999
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_E_UNKNOWN_PROTOCOL
//
// MessageText:
//
//  The specified protocol is not supported.%0
//
#define NS_E_UNKNOWN_PROTOCOL            0xC00D2EE0L

//
// MessageId: NS_E_REDIRECT_TO_PROXY
//
// MessageText:
//
//  The client is redirected to a proxy server.%0
//
#define NS_E_REDIRECT_TO_PROXY           0xC00D2EE1L

//
// MessageId: NS_E_INTERNAL_SERVER_ERROR
//
// MessageText:
//
//  The server encountered an unexpected condition which prevented it from fulfilling the request.%0
//
#define NS_E_INTERNAL_SERVER_ERROR       0xC00D2EE2L

//
// MessageId: NS_E_BAD_REQUEST
//
// MessageText:
//
//  The request could not be understood by the server.%0
//
#define NS_E_BAD_REQUEST                 0xC00D2EE3L

//
// MessageId: NS_E_ERROR_FROM_PROXY
//
// MessageText:
//
//  The proxy experienced an error while attempting to contact the media server.%0
//
#define NS_E_ERROR_FROM_PROXY            0xC00D2EE4L

//
// MessageId: NS_E_PROXY_TIMEOUT
//
// MessageText:
//
//  The proxy did not receive a timely response while attempting to contact the media server.%0
//
#define NS_E_PROXY_TIMEOUT               0xC00D2EE5L

//
// MessageId: NS_E_SERVER_UNAVAILABLE
//
// MessageText:
//
//  The server is currently unable to handle the request due to a temporary overloading or maintenance of the server.%0
//
#define NS_E_SERVER_UNAVAILABLE          0xC00D2EE6L

//
// MessageId: NS_E_REFUSED_BY_SERVER
//
// MessageText:
//
//  The server is refusing to fulfill the requested operation.%0
//
#define NS_E_REFUSED_BY_SERVER           0xC00D2EE7L

//
// MessageId: NS_E_INCOMPATIBLE_SERVER
//
// MessageText:
//
//  The server is not a compatible streaming media server.%0
//
#define NS_E_INCOMPATIBLE_SERVER         0xC00D2EE8L

//
// MessageId: NS_E_MULTICAST_DISABLED
//
// MessageText:
//
//  The content cannot be streamed because the Multicast protocol has been disabled.%0
//
#define NS_E_MULTICAST_DISABLED          0xC00D2EE9L

//
// MessageId: NS_E_INVALID_REDIRECT
//
// MessageText:
//
//  The server redirected the player to an invalid location.%0
//
#define NS_E_INVALID_REDIRECT            0xC00D2EEAL

//
// MessageId: NS_E_ALL_PROTOCOLS_DISABLED
//
// MessageText:
//
//  The content cannot be streamed because all protocols have been disabled.%0
//
#define NS_E_ALL_PROTOCOLS_DISABLED      0xC00D2EEBL

//
// MessageId: NS_E_MSBD_NO_LONGER_SUPPORTED
//
// MessageText:
//
//  The MSBD protocol is no longer supported. Please use HTTP to connect to the Windows Media stream.%0
//
#define NS_E_MSBD_NO_LONGER_SUPPORTED    0xC00D2EECL

//
// MessageId: NS_E_PROXY_NOT_FOUND
//
// MessageText:
//
//  The proxy server could not be located. Please check your proxy server configuration.%0
//
#define NS_E_PROXY_NOT_FOUND             0xC00D2EEDL

//
// MessageId: NS_E_CANNOT_CONNECT_TO_PROXY
//
// MessageText:
//
//  Unable to establish a connection to the proxy server. Please check your proxy server configuration.%0
//
#define NS_E_CANNOT_CONNECT_TO_PROXY     0xC00D2EEEL

//
// MessageId: NS_E_SERVER_DNS_TIMEOUT
//
// MessageText:
//
//  Unable to locate the media server. The operation timed out.%0
//
#define NS_E_SERVER_DNS_TIMEOUT          0xC00D2EEFL

//
// MessageId: NS_E_PROXY_DNS_TIMEOUT
//
// MessageText:
//
//  Unable to locate the proxy server. The operation timed out.%0
//
#define NS_E_PROXY_DNS_TIMEOUT           0xC00D2EF0L

//
// MessageId: NS_E_CLOSED_ON_SUSPEND
//
// MessageText:
//
//  Media closed because Windows was shut down.%0
//
#define NS_E_CLOSED_ON_SUSPEND           0xC00D2EF1L

//
// MessageId: NS_E_CANNOT_READ_PLAYLIST_FROM_MEDIASERVER
//
// MessageText:
//
//  Unable to read the contents of a playlist file from a media server.%0
//
#define NS_E_CANNOT_READ_PLAYLIST_FROM_MEDIASERVER 0xC00D2EF2L

//
// MessageId: NS_E_SESSION_NOT_FOUND
//
// MessageText:
//
//  Session not found.%0
//
#define NS_E_SESSION_NOT_FOUND           0xC00D2EF3L

//
// MessageId: NS_E_REQUIRE_STREAMING_CLIENT
//
// MessageText:
//
//  Content requires a streaming media client.%0
//
#define NS_E_REQUIRE_STREAMING_CLIENT    0xC00D2EF4L

//
// MessageId: NS_E_PLAYLIST_ENTRY_HAS_CHANGED
//
// MessageText:
//
//  A command applies to a previous playlist entry.%0
//
#define NS_E_PLAYLIST_ENTRY_HAS_CHANGED  0xC00D2EF5L

//
// MessageId: NS_E_PROXY_ACCESSDENIED
//
// MessageText:
//
//  The proxy server is denying access.  The username and/or password might be incorrect.%0
//
#define NS_E_PROXY_ACCESSDENIED          0xC00D2EF6L

//
// MessageId: NS_E_PROXY_SOURCE_ACCESSDENIED
//
// MessageText:
//
//  The proxy could not provide valid authentication credentials to the media server.%0
//
#define NS_E_PROXY_SOURCE_ACCESSDENIED   0xC00D2EF7L

//
// MessageId: NS_E_NETWORK_SINK_WRITE
//
// MessageText:
//
//  The network sink failed to write data to the network.%0
//
#define NS_E_NETWORK_SINK_WRITE          0xC00D2EF8L

//
// MessageId: NS_E_FIREWALL
//
// MessageText:
//
//  Data packets are not being received from the server. The packets might be blocked by a filtering device, such as a network firewall.%0  
//
#define NS_E_FIREWALL                    0xC00D2EF9L

//
// MessageId: NS_E_MMS_NOT_SUPPORTED
//
// MessageText:
//
//  The MMS protocol is not supported. Please use HTTP or RTSP to connect to the Windows Media stream.%0
//
#define NS_E_MMS_NOT_SUPPORTED           0xC00D2EFAL

//
// MessageId: NS_E_SERVER_ACCESSDENIED
//
// MessageText:
//
//  The Windows Media server is denying access.  The username and/or password might be incorrect.%0
//
#define NS_E_SERVER_ACCESSDENIED         0xC00D2EFBL

//
// MessageId: NS_E_RESOURCE_GONE
//
// MessageText:
//
//  The Publishing Point or file on the Windows Media Server is no longer available.%0
//
#define NS_E_RESOURCE_GONE               0xC00D2EFCL


/////////////////////////////////////////////////////////////////////////
//
// Windows Media Client Media Services
//
// IdRange = 13000..13999 (0x32C8-0x36AF)
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_E_END_OF_PLAYLIST
//
// MessageText:
//
//  The playlist has reached its end.%0
//
#define NS_E_END_OF_PLAYLIST             0xC00D32C8L

//
// MessageId: NS_E_USE_FILE_SOURCE
//
// MessageText:
//
//  Use file source.%0
//
#define NS_E_USE_FILE_SOURCE             0xC00D32C9L


#endif // _NSERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\wmsdk\inc\drmexternals.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for drmexternals.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __drmexternals_h__
#define __drmexternals_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDRMStatusCallback_FWD_DEFINED__
#define __IDRMStatusCallback_FWD_DEFINED__
typedef interface IDRMStatusCallback IDRMStatusCallback;
#endif 	/* __IDRMStatusCallback_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_drmexternals_0000 */
/* [local] */ 

static const WCHAR *g_wszWMDRM_ASFV1                = L"ASFV1";
static const WCHAR *g_wszWMDRM_ASFV2                = L"ASFV2";
static const WCHAR *g_wszWMDRM_RIGHT_PLAYBACK                = L"Play";
static const WCHAR *g_wszWMDRM_RIGHT_COPY_TO_CD              = L"Print.redbook";
static const WCHAR *g_wszWMDRM_RIGHT_COPY_TO_SDMI_DEVICE     = L"Transfer.SDMI";
static const WCHAR *g_wszWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE = L"Transfer.NONSDMI";
static const WCHAR *g_wszWMDRM_RIGHT_BACKUP                  = L"Backup";
static const WCHAR *g_wszWMDRM_ActionAllowed                = L"ActionAllowed.";
static const WCHAR *g_wszWMDRM_LicenseState                 = L"LicenseStateData.";
static const WCHAR *g_wszWMDRM_DRMHeader                    = L"DRMHeader.";
static const WCHAR *g_wszWMDRM_IsDRM                             = L"IsDRM";
static const WCHAR *g_wszWMDRM_IsDRMCached                       = L"IsDRMCached";
static const WCHAR *g_wszWMDRM_ActionAllowed_Playback            = L"ActionAllowed.Play";
static const WCHAR *g_wszWMDRM_ActionAllowed_CopyToCD            = L"ActionAllowed.Print.redbook";
static const WCHAR *g_wszWMDRM_ActionAllowed_CopyToSDMIDevice    = L"ActionAllowed.Transfer.SDMI";
static const WCHAR *g_wszWMDRM_ActionAllowed_CopyToNonSDMIDevice = L"ActionAllowed.Transfer.NONSDMI";
static const WCHAR *g_wszWMDRM_ActionAllowed_Backup              = L"ActionAllowed.Backup";
static const WCHAR *g_wszWMDRM_LicenseState_Playback             = L"LicenseStateData.Play";
static const WCHAR *g_wszWMDRM_LicenseState_CopyToCD             = L"LicenseStateData.Print.redbook";
static const WCHAR *g_wszWMDRM_LicenseState_CopyToSDMIDevice     = L"LicenseStateData.Transfer.SDMI";
static const WCHAR *g_wszWMDRM_LicenseState_CopyToNonSDMIDevice  = L"LicenseStateData.Transfer.NONSDMI";
typedef 
enum DRM_LICENSE_STATE_CATEGORY
    {	WM_DRM_LICENSE_STATE_NORIGHT	= 0,
	WM_DRM_LICENSE_STATE_UNLIM	= WM_DRM_LICENSE_STATE_NORIGHT + 1,
	WM_DRM_LICENSE_STATE_COUNT	= WM_DRM_LICENSE_STATE_UNLIM + 1,
	WM_DRM_LICENSE_STATE_FROM	= WM_DRM_LICENSE_STATE_COUNT + 1,
	WM_DRM_LICENSE_STATE_UNTIL	= WM_DRM_LICENSE_STATE_FROM + 1,
	WM_DRM_LICENSE_STATE_FROM_UNTIL	= WM_DRM_LICENSE_STATE_UNTIL + 1,
	WM_DRM_LICENSE_STATE_COUNT_FROM	= WM_DRM_LICENSE_STATE_FROM_UNTIL + 1,
	WM_DRM_LICENSE_STATE_COUNT_UNTIL	= WM_DRM_LICENSE_STATE_COUNT_FROM + 1,
	WM_DRM_LICENSE_STATE_COUNT_FROM_UNTIL	= WM_DRM_LICENSE_STATE_COUNT_UNTIL + 1,
	WM_DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE	= WM_DRM_LICENSE_STATE_COUNT_FROM_UNTIL + 1
    } 	DRM_LICENSE_STATE_CATEGORY;

typedef struct _DRM_LICENSE_STATE_DATA
    {
    DWORD dwStreamId;
    DRM_LICENSE_STATE_CATEGORY dwCategory;
    DWORD dwNumCounts;
    DWORD dwCount[ 4 ];
    DWORD dwNumDates;
    FILETIME datetime[ 4 ];
    DWORD dwVague;
    } 	DRM_LICENSE_STATE_DATA;

typedef 
enum DRM_HTTP_STATUS
    {	HTTP_NOTINITIATED	= 0,
	HTTP_CONNECTING	= HTTP_NOTINITIATED + 1,
	HTTP_REQUESTING	= HTTP_CONNECTING + 1,
	HTTP_RECEIVING	= HTTP_REQUESTING + 1,
	HTTP_COMPLETED	= HTTP_RECEIVING + 1
    } 	DRM_HTTP_STATUS;

typedef 
enum DRM_INDIVIDUALIZATION_STATUS
    {	INDI_UNDEFINED	= 0,
	INDI_BEGIN	= 0x1,
	INDI_SUCCEED	= 0x2,
	INDI_FAIL	= 0x4,
	INDI_CANCEL	= 0x8,
	INDI_DOWNLOAD	= 0x10,
	INDI_INSTALL	= 0x20
    } 	DRM_INDIVIDUALIZATION_STATUS;

typedef struct _WMIndividualizeStatus
    {
    HRESULT hr;
    DRM_INDIVIDUALIZATION_STATUS enIndiStatus;
    LPSTR pszIndiRespUrl;
    DWORD dwHTTPRequest;
    DRM_HTTP_STATUS enHTTPStatus;
    DWORD dwHTTPReadProgress;
    DWORD dwHTTPReadTotal;
    } 	WM_INDIVIDUALIZE_STATUS;

typedef struct _WMGetLicenseData
    {
    DWORD dwSize;
    HRESULT hr;
    WCHAR *wszURL;
    WCHAR *wszLocalFilename;
    BYTE *pbPostData;
    DWORD dwPostDataSize;
    } 	WM_GET_LICENSE_DATA;

typedef 
enum MSDRM_STATUS
    {	DRM_ERROR	= 0,
	DRM_INFORMATION	= 1,
	DRM_BACKUPRESTORE_BEGIN	= 2,
	DRM_BACKUPRESTORE_END	= 3,
	DRM_BACKUPRESTORE_CONNECTING	= 4,
	DRM_BACKUPRESTORE_DISCONNECTING	= 5,
	DRM_ERROR_WITHURL	= 6,
	DRM_RESTRICTED_LICENSE	= 7,
	DRM_NEEDS_INDIVIDUALIZATION	= 8
    } 	MSDRM_STATUS;

typedef 
enum DRM_ATTR_DATATYPE
    {	DRM_TYPE_DWORD	= 0,
	DRM_TYPE_STRING	= 1,
	DRM_TYPE_BINARY	= 2,
	DRM_TYPE_BOOL	= 3,
	DRM_TYPE_QWORD	= 4,
	DRM_TYPE_WORD	= 5,
	DRM_TYPE_GUID	= 6
    } 	DRM_ATTR_DATATYPE;


#define DRM_BACKUP_OVERWRITE         ((DWORD) 0x00000001)
#define DRM_RESTORE_INDIVIDUALIZE    ((DWORD) 0x00000002)


extern RPC_IF_HANDLE __MIDL_itf_drmexternals_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_drmexternals_0000_v0_0_s_ifspec;

#ifndef __IDRMStatusCallback_INTERFACE_DEFINED__
#define __IDRMStatusCallback_INTERFACE_DEFINED__

/* interface IDRMStatusCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDRMStatusCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08548704-75B1-4982-9B26-FB385DEE741D")
    IDRMStatusCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStatus( 
            /* [in] */ MSDRM_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ DRM_ATTR_DATATYPE dwType,
            /* [in] */ BYTE *pValue,
            /* [in] */ void *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDRMStatusCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDRMStatusCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDRMStatusCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDRMStatusCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStatus )( 
            IDRMStatusCallback * This,
            /* [in] */ MSDRM_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ DRM_ATTR_DATATYPE dwType,
            /* [in] */ BYTE *pValue,
            /* [in] */ void *pvContext);
        
        END_INTERFACE
    } IDRMStatusCallbackVtbl;

    interface IDRMStatusCallback
    {
        CONST_VTBL struct IDRMStatusCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDRMStatusCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDRMStatusCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDRMStatusCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDRMStatusCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDRMStatusCallback_OnStatus_Proxy( 
    IDRMStatusCallback * This,
    /* [in] */ MSDRM_STATUS Status,
    /* [in] */ HRESULT hr,
    /* [in] */ DRM_ATTR_DATATYPE dwType,
    /* [in] */ BYTE *pValue,
    /* [in] */ void *pvContext);


void __RPC_STUB IDRMStatusCallback_OnStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDRMStatusCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_drmexternals_0111 */
/* [local] */ 

#define DRM_ENCRYPT_CONTENT_ASFv1  0x1001
#define DRM_ENCRYPT_CONTENT_ASFv2  0x1002
typedef struct _DRMBUF
    {
    unsigned long len;
    char *buf;
    } 	DRMBUF;

typedef struct _DRMBUF *PDRMBUF;



extern RPC_IF_HANDLE __MIDL_itf_drmexternals_0111_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_drmexternals_0111_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\wmsdk\inc\wmsbuffer.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for wmsbuffer.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsbuffer_h__
#define __wmsbuffer_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __INSSBuffer_FWD_DEFINED__
#define __INSSBuffer_FWD_DEFINED__
typedef interface INSSBuffer INSSBuffer;
#endif 	/* __INSSBuffer_FWD_DEFINED__ */


#ifndef __INSSBuffer2_FWD_DEFINED__
#define __INSSBuffer2_FWD_DEFINED__
typedef interface INSSBuffer2 INSSBuffer2;
#endif 	/* __INSSBuffer2_FWD_DEFINED__ */


#ifndef __INSSBuffer3_FWD_DEFINED__
#define __INSSBuffer3_FWD_DEFINED__
typedef interface INSSBuffer3 INSSBuffer3;
#endif 	/* __INSSBuffer3_FWD_DEFINED__ */


#ifndef __IWMSBufferAllocator_FWD_DEFINED__
#define __IWMSBufferAllocator_FWD_DEFINED__
typedef interface IWMSBufferAllocator IWMSBufferAllocator;
#endif 	/* __IWMSBufferAllocator_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_wmsbuffer_0000 */
/* [local] */ 

//=========================================================================
//
// Microsoft Windows Media Technologies
// Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved.
//
//=========================================================================
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
EXTERN_GUID( IID_INSSBuffer, 0xE1CD3524,0x03D7,0x11d2,0x9E,0xED,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSBuffer, 0xE1CD3524,0x03D7,0x11d2,0x9E,0xED,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSBufferAllocator, 0x61103CA4,0x2033,0x11d2,0x9E,0xF1,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_INSSBuffer2, 0x4f528693, 0x1035, 0x43fe, 0xb4, 0x28, 0x75, 0x75, 0x61, 0xad, 0x3a, 0x68);
EXTERN_GUID( IID_INSSBuffer3, 0xc87ceaaf, 0x75be, 0x4bc4, 0x84, 0xeb, 0xac, 0x27, 0x98, 0x50, 0x76, 0x72);
EXTERN_GUID( WM_SampleExtensionGUID_OutputCleanPoint, 0xf72a3c6f, 0x6eb4, 0x4ebc, 0xb1, 0x92, 0x9, 0xad, 0x97, 0x59, 0xe8, 0x28 );
EXTERN_GUID( WM_SampleExtensionGUID_FileName, 0xe165ec0e, 0x19ed, 0x45d7, 0xb4, 0xa7, 0x25, 0xcb, 0xd1, 0xe2, 0x8e, 0x9b);
#define IWMSBuffer INSSBuffer



extern RPC_IF_HANDLE __MIDL_itf_wmsbuffer_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsbuffer_0000_v0_0_s_ifspec;

#ifndef __INSSBuffer_INTERFACE_DEFINED__
#define __INSSBuffer_INTERFACE_DEFINED__

/* interface INSSBuffer */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_INSSBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1CD3524-03D7-11d2-9EED-006097D2D7CF")
    INSSBuffer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ DWORD *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLength( 
            /* [in] */ DWORD dwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxLength( 
            /* [out] */ DWORD *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [out] */ BYTE **ppdwBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferAndLength( 
            /* [out] */ BYTE **ppdwBuffer,
            /* [out] */ DWORD *pdwLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSSBufferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INSSBuffer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INSSBuffer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INSSBuffer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            INSSBuffer * This,
            /* [out] */ DWORD *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetLength )( 
            INSSBuffer * This,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxLength )( 
            INSSBuffer * This,
            /* [out] */ DWORD *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            INSSBuffer * This,
            /* [out] */ BYTE **ppdwBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferAndLength )( 
            INSSBuffer * This,
            /* [out] */ BYTE **ppdwBuffer,
            /* [out] */ DWORD *pdwLength);
        
        END_INTERFACE
    } INSSBufferVtbl;

    interface INSSBuffer
    {
        CONST_VTBL struct INSSBufferVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSSBuffer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INSSBuffer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INSSBuffer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INSSBuffer_GetLength(This,pdwLength)	\
    (This)->lpVtbl -> GetLength(This,pdwLength)

#define INSSBuffer_SetLength(This,dwLength)	\
    (This)->lpVtbl -> SetLength(This,dwLength)

#define INSSBuffer_GetMaxLength(This,pdwLength)	\
    (This)->lpVtbl -> GetMaxLength(This,pdwLength)

#define INSSBuffer_GetBuffer(This,ppdwBuffer)	\
    (This)->lpVtbl -> GetBuffer(This,ppdwBuffer)

#define INSSBuffer_GetBufferAndLength(This,ppdwBuffer,pdwLength)	\
    (This)->lpVtbl -> GetBufferAndLength(This,ppdwBuffer,pdwLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INSSBuffer_GetLength_Proxy( 
    INSSBuffer * This,
    /* [out] */ DWORD *pdwLength);


void __RPC_STUB INSSBuffer_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_SetLength_Proxy( 
    INSSBuffer * This,
    /* [in] */ DWORD dwLength);


void __RPC_STUB INSSBuffer_SetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_GetMaxLength_Proxy( 
    INSSBuffer * This,
    /* [out] */ DWORD *pdwLength);


void __RPC_STUB INSSBuffer_GetMaxLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_GetBuffer_Proxy( 
    INSSBuffer * This,
    /* [out] */ BYTE **ppdwBuffer);


void __RPC_STUB INSSBuffer_GetBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_GetBufferAndLength_Proxy( 
    INSSBuffer * This,
    /* [out] */ BYTE **ppdwBuffer,
    /* [out] */ DWORD *pdwLength);


void __RPC_STUB INSSBuffer_GetBufferAndLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INSSBuffer_INTERFACE_DEFINED__ */


#ifndef __INSSBuffer2_INTERFACE_DEFINED__
#define __INSSBuffer2_INTERFACE_DEFINED__

/* interface INSSBuffer2 */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_INSSBuffer2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F528693-1035-43fe-B428-757561AD3A68")
    INSSBuffer2 : public INSSBuffer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSampleProperties( 
            /* [in] */ DWORD cbProperties,
            /* [out] */ BYTE *pbProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSampleProperties( 
            /* [in] */ DWORD cbProperties,
            /* [in] */ BYTE *pbProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSSBuffer2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INSSBuffer2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INSSBuffer2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INSSBuffer2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            INSSBuffer2 * This,
            /* [out] */ DWORD *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetLength )( 
            INSSBuffer2 * This,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxLength )( 
            INSSBuffer2 * This,
            /* [out] */ DWORD *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            INSSBuffer2 * This,
            /* [out] */ BYTE **ppdwBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferAndLength )( 
            INSSBuffer2 * This,
            /* [out] */ BYTE **ppdwBuffer,
            /* [out] */ DWORD *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetSampleProperties )( 
            INSSBuffer2 * This,
            /* [in] */ DWORD cbProperties,
            /* [out] */ BYTE *pbProperties);
        
        HRESULT ( STDMETHODCALLTYPE *SetSampleProperties )( 
            INSSBuffer2 * This,
            /* [in] */ DWORD cbProperties,
            /* [in] */ BYTE *pbProperties);
        
        END_INTERFACE
    } INSSBuffer2Vtbl;

    interface INSSBuffer2
    {
        CONST_VTBL struct INSSBuffer2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSSBuffer2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INSSBuffer2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INSSBuffer2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INSSBuffer2_GetLength(This,pdwLength)	\
    (This)->lpVtbl -> GetLength(This,pdwLength)

#define INSSBuffer2_SetLength(This,dwLength)	\
    (This)->lpVtbl -> SetLength(This,dwLength)

#define INSSBuffer2_GetMaxLength(This,pdwLength)	\
    (This)->lpVtbl -> GetMaxLength(This,pdwLength)

#define INSSBuffer2_GetBuffer(This,ppdwBuffer)	\
    (This)->lpVtbl -> GetBuffer(This,ppdwBuffer)

#define INSSBuffer2_GetBufferAndLength(This,ppdwBuffer,pdwLength)	\
    (This)->lpVtbl -> GetBufferAndLength(This,ppdwBuffer,pdwLength)


#define INSSBuffer2_GetSampleProperties(This,cbProperties,pbProperties)	\
    (This)->lpVtbl -> GetSampleProperties(This,cbProperties,pbProperties)

#define INSSBuffer2_SetSampleProperties(This,cbProperties,pbProperties)	\
    (This)->lpVtbl -> SetSampleProperties(This,cbProperties,pbProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INSSBuffer2_GetSampleProperties_Proxy( 
    INSSBuffer2 * This,
    /* [in] */ DWORD cbProperties,
    /* [out] */ BYTE *pbProperties);


void __RPC_STUB INSSBuffer2_GetSampleProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer2_SetSampleProperties_Proxy( 
    INSSBuffer2 * This,
    /* [in] */ DWORD cbProperties,
    /* [in] */ BYTE *pbProperties);


void __RPC_STUB INSSBuffer2_SetSampleProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INSSBuffer2_INTERFACE_DEFINED__ */


#ifndef __INSSBuffer3_INTERFACE_DEFINED__
#define __INSSBuffer3_INTERFACE_DEFINED__

/* interface INSSBuffer3 */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_INSSBuffer3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C87CEAAF-75BE-4bc4-84EB-AC2798507672")
    INSSBuffer3 : public INSSBuffer2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ GUID guidBufferProperty,
            /* [in] */ void *pvBufferProperty,
            /* [in] */ DWORD dwBufferPropertySize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ GUID guidBufferProperty,
            /* [out] */ void *pvBufferProperty,
            /* [out][in] */ DWORD *pdwBufferPropertySize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSSBuffer3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INSSBuffer3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INSSBuffer3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INSSBuffer3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            INSSBuffer3 * This,
            /* [out] */ DWORD *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetLength )( 
            INSSBuffer3 * This,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxLength )( 
            INSSBuffer3 * This,
            /* [out] */ DWORD *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            INSSBuffer3 * This,
            /* [out] */ BYTE **ppdwBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferAndLength )( 
            INSSBuffer3 * This,
            /* [out] */ BYTE **ppdwBuffer,
            /* [out] */ DWORD *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetSampleProperties )( 
            INSSBuffer3 * This,
            /* [in] */ DWORD cbProperties,
            /* [out] */ BYTE *pbProperties);
        
        HRESULT ( STDMETHODCALLTYPE *SetSampleProperties )( 
            INSSBuffer3 * This,
            /* [in] */ DWORD cbProperties,
            /* [in] */ BYTE *pbProperties);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            INSSBuffer3 * This,
            /* [in] */ GUID guidBufferProperty,
            /* [in] */ void *pvBufferProperty,
            /* [in] */ DWORD dwBufferPropertySize);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            INSSBuffer3 * This,
            /* [in] */ GUID guidBufferProperty,
            /* [out] */ void *pvBufferProperty,
            /* [out][in] */ DWORD *pdwBufferPropertySize);
        
        END_INTERFACE
    } INSSBuffer3Vtbl;

    interface INSSBuffer3
    {
        CONST_VTBL struct INSSBuffer3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSSBuffer3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INSSBuffer3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INSSBuffer3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INSSBuffer3_GetLength(This,pdwLength)	\
    (This)->lpVtbl -> GetLength(This,pdwLength)

#define INSSBuffer3_SetLength(This,dwLength)	\
    (This)->lpVtbl -> SetLength(This,dwLength)

#define INSSBuffer3_GetMaxLength(This,pdwLength)	\
    (This)->lpVtbl -> GetMaxLength(This,pdwLength)

#define INSSBuffer3_GetBuffer(This,ppdwBuffer)	\
    (This)->lpVtbl -> GetBuffer(This,ppdwBuffer)

#define INSSBuffer3_GetBufferAndLength(This,ppdwBuffer,pdwLength)	\
    (This)->lpVtbl -> GetBufferAndLength(This,ppdwBuffer,pdwLength)


#define INSSBuffer3_GetSampleProperties(This,cbProperties,pbProperties)	\
    (This)->lpVtbl -> GetSampleProperties(This,cbProperties,pbProperties)

#define INSSBuffer3_SetSampleProperties(This,cbProperties,pbProperties)	\
    (This)->lpVtbl -> SetSampleProperties(This,cbProperties,pbProperties)


#define INSSBuffer3_SetProperty(This,guidBufferProperty,pvBufferProperty,dwBufferPropertySize)	\
    (This)->lpVtbl -> SetProperty(This,guidBufferProperty,pvBufferProperty,dwBufferPropertySize)

#define INSSBuffer3_GetProperty(This,guidBufferProperty,pvBufferProperty,pdwBufferPropertySize)	\
    (This)->lpVtbl -> GetProperty(This,guidBufferProperty,pvBufferProperty,pdwBufferPropertySize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INSSBuffer3_SetProperty_Proxy( 
    INSSBuffer3 * This,
    /* [in] */ GUID guidBufferProperty,
    /* [in] */ void *pvBufferProperty,
    /* [in] */ DWORD dwBufferPropertySize);


void __RPC_STUB INSSBuffer3_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer3_GetProperty_Proxy( 
    INSSBuffer3 * This,
    /* [in] */ GUID guidBufferProperty,
    /* [out] */ void *pvBufferProperty,
    /* [out][in] */ DWORD *pdwBufferPropertySize);


void __RPC_STUB INSSBuffer3_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INSSBuffer3_INTERFACE_DEFINED__ */


#ifndef __IWMSBufferAllocator_INTERFACE_DEFINED__
#define __IWMSBufferAllocator_INTERFACE_DEFINED__

/* interface IWMSBufferAllocator */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_IWMSBufferAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("61103CA4-2033-11d2-9EF1-006097D2D7CF")
    IWMSBufferAllocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocateBuffer( 
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer **ppBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocatePageSizeBuffer( 
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer **ppBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSBufferAllocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSBufferAllocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSBufferAllocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSBufferAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateBuffer )( 
            IWMSBufferAllocator * This,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer **ppBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *AllocatePageSizeBuffer )( 
            IWMSBufferAllocator * This,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer **ppBuffer);
        
        END_INTERFACE
    } IWMSBufferAllocatorVtbl;

    interface IWMSBufferAllocator
    {
        CONST_VTBL struct IWMSBufferAllocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSBufferAllocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSBufferAllocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSBufferAllocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSBufferAllocator_AllocateBuffer(This,dwMaxBufferSize,ppBuffer)	\
    (This)->lpVtbl -> AllocateBuffer(This,dwMaxBufferSize,ppBuffer)

#define IWMSBufferAllocator_AllocatePageSizeBuffer(This,dwMaxBufferSize,ppBuffer)	\
    (This)->lpVtbl -> AllocatePageSizeBuffer(This,dwMaxBufferSize,ppBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMSBufferAllocator_AllocateBuffer_Proxy( 
    IWMSBufferAllocator * This,
    /* [in] */ DWORD dwMaxBufferSize,
    /* [out] */ INSSBuffer **ppBuffer);


void __RPC_STUB IWMSBufferAllocator_AllocateBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSBufferAllocator_AllocatePageSizeBuffer_Proxy( 
    IWMSBufferAllocator * This,
    /* [in] */ DWORD dwMaxBufferSize,
    /* [out] */ INSSBuffer **ppBuffer);


void __RPC_STUB IWMSBufferAllocator_AllocatePageSizeBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSBufferAllocator_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\wmsdk\inc\wmsdkidl.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for wmsdkidl.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsdkidl_h__
#define __wmsdkidl_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMMediaProps_FWD_DEFINED__
#define __IWMMediaProps_FWD_DEFINED__
typedef interface IWMMediaProps IWMMediaProps;
#endif 	/* __IWMMediaProps_FWD_DEFINED__ */


#ifndef __IWMVideoMediaProps_FWD_DEFINED__
#define __IWMVideoMediaProps_FWD_DEFINED__
typedef interface IWMVideoMediaProps IWMVideoMediaProps;
#endif 	/* __IWMVideoMediaProps_FWD_DEFINED__ */


#ifndef __IWMWriter_FWD_DEFINED__
#define __IWMWriter_FWD_DEFINED__
typedef interface IWMWriter IWMWriter;
#endif 	/* __IWMWriter_FWD_DEFINED__ */


#ifndef __IWMInputMediaProps_FWD_DEFINED__
#define __IWMInputMediaProps_FWD_DEFINED__
typedef interface IWMInputMediaProps IWMInputMediaProps;
#endif 	/* __IWMInputMediaProps_FWD_DEFINED__ */


#ifndef __IWMPropertyVault_FWD_DEFINED__
#define __IWMPropertyVault_FWD_DEFINED__
typedef interface IWMPropertyVault IWMPropertyVault;
#endif 	/* __IWMPropertyVault_FWD_DEFINED__ */


#ifndef __IWMIStreamProps_FWD_DEFINED__
#define __IWMIStreamProps_FWD_DEFINED__
typedef interface IWMIStreamProps IWMIStreamProps;
#endif 	/* __IWMIStreamProps_FWD_DEFINED__ */


#ifndef __IWMReader_FWD_DEFINED__
#define __IWMReader_FWD_DEFINED__
typedef interface IWMReader IWMReader;
#endif 	/* __IWMReader_FWD_DEFINED__ */


#ifndef __IWMSyncReader_FWD_DEFINED__
#define __IWMSyncReader_FWD_DEFINED__
typedef interface IWMSyncReader IWMSyncReader;
#endif 	/* __IWMSyncReader_FWD_DEFINED__ */


#ifndef __IWMOutputMediaProps_FWD_DEFINED__
#define __IWMOutputMediaProps_FWD_DEFINED__
typedef interface IWMOutputMediaProps IWMOutputMediaProps;
#endif 	/* __IWMOutputMediaProps_FWD_DEFINED__ */


#ifndef __IWMStatusCallback_FWD_DEFINED__
#define __IWMStatusCallback_FWD_DEFINED__
typedef interface IWMStatusCallback IWMStatusCallback;
#endif 	/* __IWMStatusCallback_FWD_DEFINED__ */


#ifndef __IWMReaderCallback_FWD_DEFINED__
#define __IWMReaderCallback_FWD_DEFINED__
typedef interface IWMReaderCallback IWMReaderCallback;
#endif 	/* __IWMReaderCallback_FWD_DEFINED__ */


#ifndef __IWMCredentialCallback_FWD_DEFINED__
#define __IWMCredentialCallback_FWD_DEFINED__
typedef interface IWMCredentialCallback IWMCredentialCallback;
#endif 	/* __IWMCredentialCallback_FWD_DEFINED__ */


#ifndef __IWMMetadataEditor_FWD_DEFINED__
#define __IWMMetadataEditor_FWD_DEFINED__
typedef interface IWMMetadataEditor IWMMetadataEditor;
#endif 	/* __IWMMetadataEditor_FWD_DEFINED__ */


#ifndef __IWMMetadataEditor2_FWD_DEFINED__
#define __IWMMetadataEditor2_FWD_DEFINED__
typedef interface IWMMetadataEditor2 IWMMetadataEditor2;
#endif 	/* __IWMMetadataEditor2_FWD_DEFINED__ */


#ifndef __IWMHeaderInfo_FWD_DEFINED__
#define __IWMHeaderInfo_FWD_DEFINED__
typedef interface IWMHeaderInfo IWMHeaderInfo;
#endif 	/* __IWMHeaderInfo_FWD_DEFINED__ */


#ifndef __IWMHeaderInfo2_FWD_DEFINED__
#define __IWMHeaderInfo2_FWD_DEFINED__
typedef interface IWMHeaderInfo2 IWMHeaderInfo2;
#endif 	/* __IWMHeaderInfo2_FWD_DEFINED__ */


#ifndef __IWMProfileManager_FWD_DEFINED__
#define __IWMProfileManager_FWD_DEFINED__
typedef interface IWMProfileManager IWMProfileManager;
#endif 	/* __IWMProfileManager_FWD_DEFINED__ */


#ifndef __IWMProfileManager2_FWD_DEFINED__
#define __IWMProfileManager2_FWD_DEFINED__
typedef interface IWMProfileManager2 IWMProfileManager2;
#endif 	/* __IWMProfileManager2_FWD_DEFINED__ */


#ifndef __IWMProfile_FWD_DEFINED__
#define __IWMProfile_FWD_DEFINED__
typedef interface IWMProfile IWMProfile;
#endif 	/* __IWMProfile_FWD_DEFINED__ */


#ifndef __IWMProfile2_FWD_DEFINED__
#define __IWMProfile2_FWD_DEFINED__
typedef interface IWMProfile2 IWMProfile2;
#endif 	/* __IWMProfile2_FWD_DEFINED__ */


#ifndef __IWMProfile3_FWD_DEFINED__
#define __IWMProfile3_FWD_DEFINED__
typedef interface IWMProfile3 IWMProfile3;
#endif 	/* __IWMProfile3_FWD_DEFINED__ */


#ifndef __IWMStreamConfig_FWD_DEFINED__
#define __IWMStreamConfig_FWD_DEFINED__
typedef interface IWMStreamConfig IWMStreamConfig;
#endif 	/* __IWMStreamConfig_FWD_DEFINED__ */


#ifndef __IWMStreamConfig2_FWD_DEFINED__
#define __IWMStreamConfig2_FWD_DEFINED__
typedef interface IWMStreamConfig2 IWMStreamConfig2;
#endif 	/* __IWMStreamConfig2_FWD_DEFINED__ */


#ifndef __IWMPacketSize_FWD_DEFINED__
#define __IWMPacketSize_FWD_DEFINED__
typedef interface IWMPacketSize IWMPacketSize;
#endif 	/* __IWMPacketSize_FWD_DEFINED__ */


#ifndef __IWMPacketSize2_FWD_DEFINED__
#define __IWMPacketSize2_FWD_DEFINED__
typedef interface IWMPacketSize2 IWMPacketSize2;
#endif 	/* __IWMPacketSize2_FWD_DEFINED__ */


#ifndef __IWMStreamList_FWD_DEFINED__
#define __IWMStreamList_FWD_DEFINED__
typedef interface IWMStreamList IWMStreamList;
#endif 	/* __IWMStreamList_FWD_DEFINED__ */


#ifndef __IWMMutualExclusion_FWD_DEFINED__
#define __IWMMutualExclusion_FWD_DEFINED__
typedef interface IWMMutualExclusion IWMMutualExclusion;
#endif 	/* __IWMMutualExclusion_FWD_DEFINED__ */


#ifndef __IWMMutualExclusion2_FWD_DEFINED__
#define __IWMMutualExclusion2_FWD_DEFINED__
typedef interface IWMMutualExclusion2 IWMMutualExclusion2;
#endif 	/* __IWMMutualExclusion2_FWD_DEFINED__ */


#ifndef __IWMBandwidthSharing_FWD_DEFINED__
#define __IWMBandwidthSharing_FWD_DEFINED__
typedef interface IWMBandwidthSharing IWMBandwidthSharing;
#endif 	/* __IWMBandwidthSharing_FWD_DEFINED__ */


#ifndef __IWMStreamPrioritization_FWD_DEFINED__
#define __IWMStreamPrioritization_FWD_DEFINED__
typedef interface IWMStreamPrioritization IWMStreamPrioritization;
#endif 	/* __IWMStreamPrioritization_FWD_DEFINED__ */


#ifndef __IWMWriterAdvanced_FWD_DEFINED__
#define __IWMWriterAdvanced_FWD_DEFINED__
typedef interface IWMWriterAdvanced IWMWriterAdvanced;
#endif 	/* __IWMWriterAdvanced_FWD_DEFINED__ */


#ifndef __IWMWriterAdvanced2_FWD_DEFINED__
#define __IWMWriterAdvanced2_FWD_DEFINED__
typedef interface IWMWriterAdvanced2 IWMWriterAdvanced2;
#endif 	/* __IWMWriterAdvanced2_FWD_DEFINED__ */


#ifndef __IWMWriterAdvanced3_FWD_DEFINED__
#define __IWMWriterAdvanced3_FWD_DEFINED__
typedef interface IWMWriterAdvanced3 IWMWriterAdvanced3;
#endif 	/* __IWMWriterAdvanced3_FWD_DEFINED__ */


#ifndef __IWMWriterPreprocess_FWD_DEFINED__
#define __IWMWriterPreprocess_FWD_DEFINED__
typedef interface IWMWriterPreprocess IWMWriterPreprocess;
#endif 	/* __IWMWriterPreprocess_FWD_DEFINED__ */


#ifndef __IWMWriterPostViewCallback_FWD_DEFINED__
#define __IWMWriterPostViewCallback_FWD_DEFINED__
typedef interface IWMWriterPostViewCallback IWMWriterPostViewCallback;
#endif 	/* __IWMWriterPostViewCallback_FWD_DEFINED__ */


#ifndef __IWMWriterPostView_FWD_DEFINED__
#define __IWMWriterPostView_FWD_DEFINED__
typedef interface IWMWriterPostView IWMWriterPostView;
#endif 	/* __IWMWriterPostView_FWD_DEFINED__ */


#ifndef __IWMWriterSink_FWD_DEFINED__
#define __IWMWriterSink_FWD_DEFINED__
typedef interface IWMWriterSink IWMWriterSink;
#endif 	/* __IWMWriterSink_FWD_DEFINED__ */


#ifndef __IWMRegisterCallback_FWD_DEFINED__
#define __IWMRegisterCallback_FWD_DEFINED__
typedef interface IWMRegisterCallback IWMRegisterCallback;
#endif 	/* __IWMRegisterCallback_FWD_DEFINED__ */


#ifndef __IWMWriterFileSink_FWD_DEFINED__
#define __IWMWriterFileSink_FWD_DEFINED__
typedef interface IWMWriterFileSink IWMWriterFileSink;
#endif 	/* __IWMWriterFileSink_FWD_DEFINED__ */


#ifndef __IWMWriterFileSink2_FWD_DEFINED__
#define __IWMWriterFileSink2_FWD_DEFINED__
typedef interface IWMWriterFileSink2 IWMWriterFileSink2;
#endif 	/* __IWMWriterFileSink2_FWD_DEFINED__ */


#ifndef __IWMWriterFileSinkDataUnit_FWD_DEFINED__
#define __IWMWriterFileSinkDataUnit_FWD_DEFINED__
typedef interface IWMWriterFileSinkDataUnit IWMWriterFileSinkDataUnit;
#endif 	/* __IWMWriterFileSinkDataUnit_FWD_DEFINED__ */


#ifndef __IWMWriterFileSink3_FWD_DEFINED__
#define __IWMWriterFileSink3_FWD_DEFINED__
typedef interface IWMWriterFileSink3 IWMWriterFileSink3;
#endif 	/* __IWMWriterFileSink3_FWD_DEFINED__ */


#ifndef __IWMWriterNetworkSink_FWD_DEFINED__
#define __IWMWriterNetworkSink_FWD_DEFINED__
typedef interface IWMWriterNetworkSink IWMWriterNetworkSink;
#endif 	/* __IWMWriterNetworkSink_FWD_DEFINED__ */


#ifndef __IWMClientConnections_FWD_DEFINED__
#define __IWMClientConnections_FWD_DEFINED__
typedef interface IWMClientConnections IWMClientConnections;
#endif 	/* __IWMClientConnections_FWD_DEFINED__ */


#ifndef __IWMReaderAdvanced_FWD_DEFINED__
#define __IWMReaderAdvanced_FWD_DEFINED__
typedef interface IWMReaderAdvanced IWMReaderAdvanced;
#endif 	/* __IWMReaderAdvanced_FWD_DEFINED__ */


#ifndef __IWMReaderAdvanced2_FWD_DEFINED__
#define __IWMReaderAdvanced2_FWD_DEFINED__
typedef interface IWMReaderAdvanced2 IWMReaderAdvanced2;
#endif 	/* __IWMReaderAdvanced2_FWD_DEFINED__ */


#ifndef __IWMReaderAdvanced3_FWD_DEFINED__
#define __IWMReaderAdvanced3_FWD_DEFINED__
typedef interface IWMReaderAdvanced3 IWMReaderAdvanced3;
#endif 	/* __IWMReaderAdvanced3_FWD_DEFINED__ */


#ifndef __IWMReaderAllocatorEx_FWD_DEFINED__
#define __IWMReaderAllocatorEx_FWD_DEFINED__
typedef interface IWMReaderAllocatorEx IWMReaderAllocatorEx;
#endif 	/* __IWMReaderAllocatorEx_FWD_DEFINED__ */


#ifndef __IWMReaderTypeNegotiation_FWD_DEFINED__
#define __IWMReaderTypeNegotiation_FWD_DEFINED__
typedef interface IWMReaderTypeNegotiation IWMReaderTypeNegotiation;
#endif 	/* __IWMReaderTypeNegotiation_FWD_DEFINED__ */


#ifndef __IWMReaderCallbackAdvanced_FWD_DEFINED__
#define __IWMReaderCallbackAdvanced_FWD_DEFINED__
typedef interface IWMReaderCallbackAdvanced IWMReaderCallbackAdvanced;
#endif 	/* __IWMReaderCallbackAdvanced_FWD_DEFINED__ */


#ifndef __IWMDRMReader_FWD_DEFINED__
#define __IWMDRMReader_FWD_DEFINED__
typedef interface IWMDRMReader IWMDRMReader;
#endif 	/* __IWMDRMReader_FWD_DEFINED__ */


#ifndef __IWMReaderNetworkConfig_FWD_DEFINED__
#define __IWMReaderNetworkConfig_FWD_DEFINED__
typedef interface IWMReaderNetworkConfig IWMReaderNetworkConfig;
#endif 	/* __IWMReaderNetworkConfig_FWD_DEFINED__ */


#ifndef __IWMReaderStreamClock_FWD_DEFINED__
#define __IWMReaderStreamClock_FWD_DEFINED__
typedef interface IWMReaderStreamClock IWMReaderStreamClock;
#endif 	/* __IWMReaderStreamClock_FWD_DEFINED__ */


#ifndef __IWMIndexer_FWD_DEFINED__
#define __IWMIndexer_FWD_DEFINED__
typedef interface IWMIndexer IWMIndexer;
#endif 	/* __IWMIndexer_FWD_DEFINED__ */


#ifndef __IWMIndexer2_FWD_DEFINED__
#define __IWMIndexer2_FWD_DEFINED__
typedef interface IWMIndexer2 IWMIndexer2;
#endif 	/* __IWMIndexer2_FWD_DEFINED__ */


#ifndef __IWMLicenseBackup_FWD_DEFINED__
#define __IWMLicenseBackup_FWD_DEFINED__
typedef interface IWMLicenseBackup IWMLicenseBackup;
#endif 	/* __IWMLicenseBackup_FWD_DEFINED__ */


#ifndef __IWMLicenseRestore_FWD_DEFINED__
#define __IWMLicenseRestore_FWD_DEFINED__
typedef interface IWMLicenseRestore IWMLicenseRestore;
#endif 	/* __IWMLicenseRestore_FWD_DEFINED__ */


#ifndef __IWMBackupRestoreProps_FWD_DEFINED__
#define __IWMBackupRestoreProps_FWD_DEFINED__
typedef interface IWMBackupRestoreProps IWMBackupRestoreProps;
#endif 	/* __IWMBackupRestoreProps_FWD_DEFINED__ */


#ifndef __IWMCodecInfo_FWD_DEFINED__
#define __IWMCodecInfo_FWD_DEFINED__
typedef interface IWMCodecInfo IWMCodecInfo;
#endif 	/* __IWMCodecInfo_FWD_DEFINED__ */


#ifndef __IWMCodecInfo2_FWD_DEFINED__
#define __IWMCodecInfo2_FWD_DEFINED__
typedef interface IWMCodecInfo2 IWMCodecInfo2;
#endif 	/* __IWMCodecInfo2_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "wmsbuffer.h"
#include "drmexternals.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_wmsdkidl_0000 */
/* [local] */ 

//=========================================================================
//
// Microsoft Windows Media Technologies
// Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved.
//
//=========================================================================
typedef unsigned __int64 QWORD;







































////////////////////////////////////////////////////////////////
//
// These are the special case attributes that give information 
// about the Windows Media file.
//
static const DWORD g_dwWMSpecialAttributes = 20;
static const WCHAR g_wszWMDuration[] =L"Duration";
static const WCHAR g_wszWMBitrate[] =L"Bitrate";
static const WCHAR g_wszWMSeekable[] =L"Seekable";
static const WCHAR g_wszWMStridable[] =L"Stridable";
static const WCHAR g_wszWMBroadcast[] =L"Broadcast";
static const WCHAR g_wszWMProtected[] =L"Is_Protected";
static const WCHAR g_wszWMTrusted[] =L"Is_Trusted";
static const WCHAR g_wszWMSignature_Name[] =L"Signature_Name";
static const WCHAR g_wszWMHasAudio[] =L"HasAudio";
static const WCHAR g_wszWMHasImage[] =L"HasImage";
static const WCHAR g_wszWMHasScript[] =L"HasScript";
static const WCHAR g_wszWMHasVideo[] =L"HasVideo";
static const WCHAR g_wszWMCurrentBitrate[] =L"CurrentBitrate";
static const WCHAR g_wszWMOptimalBitrate[] =L"OptimalBitrate";
static const WCHAR g_wszWMHasAttachedImages[] =L"HasAttachedImages";
static const WCHAR g_wszWMSkipBackward[] =L"Can_Skip_Backward";
static const WCHAR g_wszWMSkipForward[] =L"Can_Skip_Forward";
static const WCHAR g_wszWMNumberOfFrames[] =L"NumberOfFrames";
static const WCHAR g_wszWMFileSize[] =L"FileSize";
static const WCHAR g_wszWMHasArbitraryDataStream[] =L"HasArbitraryDataStream";
static const WCHAR g_wszWMHasFileTransferStream[] =L"HasFileTransferStream";

////////////////////////////////////////////////////////////////
//
// The content description object supports 5 basic attributes.
//
static const DWORD g_dwWMContentAttributes = 5;
static const WCHAR g_wszWMTitle[] =L"Title";
static const WCHAR g_wszWMAuthor[] =L"Author";
static const WCHAR g_wszWMDescription[] =L"Description";
static const WCHAR g_wszWMRating[] =L"Rating";
static const WCHAR g_wszWMCopyright[] =L"Copyright";

////////////////////////////////////////////////////////////////
//
// These attributes are used to configure DRM using IWMDRMWriter::SetDRMAttribute.
//
static const WCHAR *g_wszWMUse_DRM = L"Use_DRM";
static const WCHAR *g_wszWMDRM_Flags = L"DRM_Flags";
static const WCHAR *g_wszWMDRM_Level = L"DRM_Level";

////////////////////////////////////////////////////////////////
//
// These are the additional attributes defined in the WM attribute
// namespace that give information about the content.
//
static const WCHAR g_wszWMAlbumTitle[] =L"WM/AlbumTitle";
static const WCHAR g_wszWMTrack[] =L"WM/Track";
static const WCHAR g_wszWMPromotionURL[] =L"WM/PromotionURL";
static const WCHAR g_wszWMAlbumCoverURL[] =L"WM/AlbumCoverURL";
static const WCHAR g_wszWMGenre[] =L"WM/Genre";
static const WCHAR g_wszWMYear[] =L"WM/Year";
static const WCHAR g_wszWMGenreID[] =L"WM/GenreID";
static const WCHAR g_wszWMMCDI[] =L"WM/MCDI";
static const WCHAR g_wszWMComposer[] =L"WM/Composer";
static const WCHAR g_wszWMLyrics[] =L"WM/Lyrics";
static const WCHAR g_wszWMTrackNumber[] =L"WM/TrackNumber";
static const WCHAR g_wszWMToolName[] =L"WM/ToolName";
static const WCHAR g_wszWMToolVersion[] =L"WM/ToolVersion";
static const WCHAR g_wszWMIsVBR[] =L"IsVBR";
static const WCHAR g_wszWMAlbumArtist[] =L"WM/AlbumArtist";

////////////////////////////////////////////////////////////////
//
// These optional attributes may be used to give information 
// about the branding of the content.
//
static const WCHAR g_wszWMBannerImageType[] =L"BannerImageType";
static const WCHAR g_wszWMBannerImageData[] =L"BannerImageData";
static const WCHAR g_wszWMBannerImageURL[] =L"BannerImageURL";
static const WCHAR g_wszWMCopyrightURL[] =L"CopyrightURL";
////////////////////////////////////////////////////////////////
//
// Optional attributes, used to give information 
// about video stream properties.
//
static const WCHAR g_wszWMAspectRatioX[] =L"AspectRatioX";
static const WCHAR g_wszWMAspectRatioY[] =L"AspectRatioY";
////////////////////////////////////////////////////////////////
//
// The NSC file supports the following attributes.
//
static const DWORD g_dwWMNSCAttributes = 5;
static const WCHAR g_wszWMNSCName[] =L"NSC_Name";
static const WCHAR g_wszWMNSCAddress[] =L"NSC_Address";
static const WCHAR g_wszWMNSCPhone[] =L"NSC_Phone";
static const WCHAR g_wszWMNSCEmail[] =L"NSC_Email";
static const WCHAR g_wszWMNSCDescription[] =L"NSC_Description";

////////////////////////////////////////////////////////////////
//
// These are setting names for use in Get/SetOutputSetting
//
static const WCHAR g_wszEarlyDataDelivery[] =L"EarlyDataDelivery";
static const WCHAR g_wszJustInTimeDecode[] =L"JustInTimeDecode";
static const WCHAR g_wszSingleOutputBuffer[] =L"SingleOutputBuffer";
static const WCHAR g_wszSoftwareScaling[] =L"SoftwareScaling";
static const WCHAR g_wszDeliverOnReceive[] =L"DeliverOnReceive";
static const WCHAR g_wszScrambledAudio[] =L"ScrambledAudio";
static const WCHAR g_wszDedicatedDeliveryThread[] =L"DedicatedDeliveryThread";

////////////////////////////////////////////////////////////////
//
// These are setting names for use in Get/SetInputSetting
//
static const WCHAR g_wszDeinterlaceMode[] =L"DeinterlaceMode";
static const WCHAR g_wszInitialPatternForInverseTelecine[] =L"InitialPatternForInverseTelecine";
static const WCHAR g_wszJPEGCompressionQuality[] =L"JPEGCompressionQuality";

////////////////////////////////////////////////////////////////
//
// All known IWMPropertyVault property names
//
static const WCHAR g_wszOriginalSourceFormatTag[] =L"_SOURCEFORMATTAG";
static const WCHAR g_wszEDL[] =L"_EDL";

////////////////////////////////////////////////////////////////
//
// All known IWMIStreamProps property names
//
static const WCHAR g_wszReloadIndexOnSeek[] =L"ReloadIndexOnSeek";
static const WCHAR g_wszStreamNumIndexObjects[] =L"StreamNumIndexObjects";
static const WCHAR g_wszFailSeekOnError[] =L"FailSeekOnError";
static const WCHAR g_wszPermitSeeksBeyondEndOfStream[] =L"PermitSeeksBeyondEndOfStream";
static const WCHAR g_wszUsePacketAtSeekPoint[] =L"UsePacketAtSeekPoint";
static const WCHAR g_wszSourceBufferTime[] =L"SourceBufferTime";
static const WCHAR g_wszSourceMaxBytesAtOnce[] =L"SourceMaxBytesAtOnce";

////////////////////////////////////////////////////////////////
//
// VBR encoding settings
//
static const WCHAR g_wszVBREnabled[] =L"_VBRENABLED";
static const WCHAR g_wszVBRQuality[] =L"_VBRQUALITY";
static const WCHAR g_wszVBRBitrateMax[] =L"_RMAX";
static const WCHAR g_wszVBRBufferWindowMax[] =L"_BMAX";

////////////////////////////////////////////////////////////////
//
// VBR Video settings
//
static const WCHAR *g_wszVBRPeak = L"VBR Peak";
static const WCHAR *g_wszBufferAverage = L"Buffer Average";

////////////////////////////////////////////////////////////////
//
// Flags that can be passed into the Start method of IWMReader
//
#define WM_START_CURRENTPOSITION     ( ( QWORD )-1 )

#define WM_BACKUP_OVERWRITE    ((DWORD) 0x00000001)
#define WM_RESTORE_INDIVIDUALIZE    ((DWORD) 0x00000002)
#define WAVE_FORMAT_DRM            0x0009

enum __MIDL___MIDL_itf_wmsdkidl_0000_0001
    {	WM_SF_CLEANPOINT	= 0x1,
	WM_SF_DISCONTINUITY	= 0x2,
	WM_SF_DATALOSS	= 0x4
    } ;

enum __MIDL___MIDL_itf_wmsdkidl_0000_0002
    {	WM_SFEX_NOTASYNCPOINT	= 0x2,
	WM_SFEX_DATALOSS	= 0x4
    } ;
typedef 
enum WMT_STATUS
    {	WMT_ERROR	= 0,
	WMT_OPENED	= 1,
	WMT_BUFFERING_START	= 2,
	WMT_BUFFERING_STOP	= 3,
	WMT_EOF	= 4,
	WMT_END_OF_FILE	= 4,
	WMT_END_OF_SEGMENT	= 5,
	WMT_END_OF_STREAMING	= 6,
	WMT_LOCATING	= 7,
	WMT_CONNECTING	= 8,
	WMT_NO_RIGHTS	= 9,
	WMT_MISSING_CODEC	= 10,
	WMT_STARTED	= 11,
	WMT_STOPPED	= 12,
	WMT_CLOSED	= 13,
	WMT_STRIDING	= 14,
	WMT_TIMER	= 15,
	WMT_INDEX_PROGRESS	= 16,
	WMT_SAVEAS_START	= 17,
	WMT_SAVEAS_STOP	= 18,
	WMT_NEW_SOURCEFLAGS	= 19,
	WMT_NEW_METADATA	= 20,
	WMT_BACKUPRESTORE_BEGIN	= 21,
	WMT_SOURCE_SWITCH	= 22,
	WMT_ACQUIRE_LICENSE	= 23,
	WMT_INDIVIDUALIZE	= 24,
	WMT_NEEDS_INDIVIDUALIZATION	= 25,
	WMT_NO_RIGHTS_EX	= 26,
	WMT_BACKUPRESTORE_END	= 27,
	WMT_BACKUPRESTORE_CONNECTING	= 28,
	WMT_BACKUPRESTORE_DISCONNECTING	= 29,
	WMT_ERROR_WITHURL	= 30,
	WMT_RESTRICTED_LICENSE	= 31,
	WMT_CLIENT_CONNECT	= 32,
	WMT_CLIENT_DISCONNECT	= 33,
	WMT_NATIVE_OUTPUT_PROPS_CHANGED	= 34,
	WMT_RECONNECT_START	= 35,
	WMT_RECONNECT_END	= 36,
	WMT_CLIENT_CONNECT_EX	= 37,
	WMT_CLIENT_DISCONNECT_EX	= 38,
	WMT_SET_FEC_SPAN	= 39
    } 	WMT_STATUS;

typedef 
enum WMT_RIGHTS
    {	WMT_RIGHT_PLAYBACK	= 0x1,
	WMT_RIGHT_COPY_TO_NON_SDMI_DEVICE	= 0x2,
	WMT_RIGHT_COPY_TO_CD	= 0x8,
	WMT_RIGHT_COPY_TO_SDMI_DEVICE	= 0x10,
	WMT_RIGHT_ONE_TIME	= 0x20,
	WMT_RIGHT_SDMI_TRIGGER	= 0x10000,
	WMT_RIGHT_SDMI_NOMORECOPIES	= 0x20000
    } 	WMT_RIGHTS;

typedef 
enum WMT_STREAM_SELECTION
    {	WMT_OFF	= 0,
	WMT_CLEANPOINT_ONLY	= 1,
	WMT_ON	= 2
    } 	WMT_STREAM_SELECTION;

typedef 
enum WMT_ATTR_DATATYPE
    {	WMT_TYPE_DWORD	= 0,
	WMT_TYPE_STRING	= 1,
	WMT_TYPE_BINARY	= 2,
	WMT_TYPE_BOOL	= 3,
	WMT_TYPE_QWORD	= 4,
	WMT_TYPE_WORD	= 5,
	WMT_TYPE_GUID	= 6
    } 	WMT_ATTR_DATATYPE;

typedef 
enum WMT_ATTR_IMAGETYPE
    {	WMT_IMAGETYPE_BITMAP	= 1,
	WMT_IMAGETYPE_JPEG	= 2,
	WMT_IMAGETYPE_GIF	= 3
    } 	WMT_ATTR_IMAGETYPE;

typedef 
enum WMT_VERSION
    {	WMT_VER_4_0	= 0x40000,
	WMT_VER_7_0	= 0x70000,
	WMT_VER_8_0	= 0x80000
    } 	WMT_VERSION;

typedef 
enum tagWMT_STORAGE_FORMAT
    {	WMT_Storage_Format_MP3	= 0,
	WMT_Storage_Format_V1	= WMT_Storage_Format_MP3 + 1
    } 	WMT_STORAGE_FORMAT;

typedef 
enum tagWMT_TRANSPORT_TYPE
    {	WMT_Transport_Type_Unreliable	= 0,
	WMT_Transport_Type_Reliable	= WMT_Transport_Type_Unreliable + 1
    } 	WMT_TRANSPORT_TYPE;

typedef 
enum WMT_NET_PROTOCOL
    {	WMT_PROTOCOL_HTTP	= 0
    } 	WMT_NET_PROTOCOL;

typedef 
enum WMT_PLAY_MODE
    {	WMT_PLAY_MODE_AUTOSELECT	= 0,
	WMT_PLAY_MODE_LOCAL	= 1,
	WMT_PLAY_MODE_DOWNLOAD	= 2,
	WMT_PLAY_MODE_STREAMING	= 3
    } 	WMT_PLAY_MODE;

typedef 
enum WMT_PROXY_SETTINGS
    {	WMT_PROXY_SETTING_NONE	= 0,
	WMT_PROXY_SETTING_MANUAL	= 1,
	WMT_PROXY_SETTING_AUTO	= 2,
	WMT_PROXY_SETTING_BROWSER	= 3
    } 	WMT_PROXY_SETTINGS;

typedef 
enum WMT_CODEC_INFO_TYPE
    {	WMT_CODECINFO_AUDIO	= 0,
	WMT_CODECINFO_VIDEO	= 1,
	WMT_CODECINFO_UNKNOWN	= 0xffffffff
    } 	WMT_CODEC_INFO_TYPE;


enum __MIDL___MIDL_itf_wmsdkidl_0000_0003
    {	WM_DM_NOTINTERLACED	= 0,
	WM_DM_DEINTERLACE_NORMAL	= 1,
	WM_DM_DEINTERLACE_HALFSIZE	= 2,
	WM_DM_DEINTERLACE_HALFSIZEDOUBLERATE	= 3,
	WM_DM_DEINTERLACE_INVERSETELECINE	= 4,
	WM_DM_DEINTERLACE_VERTICALHALFSIZEDOUBLERATE	= 5
    } ;

enum __MIDL___MIDL_itf_wmsdkidl_0000_0004
    {	WM_DM_IT_DISABLE_COHERENT_MODE	= 0,
	WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_AA_TOP	= 1,
	WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_BB_TOP	= 2,
	WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_BC_TOP	= 3,
	WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_CD_TOP	= 4,
	WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_DD_TOP	= 5,
	WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_AA_BOTTOM	= 6,
	WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_BB_BOTTOM	= 7,
	WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_BC_BOTTOM	= 8,
	WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_CD_BOTTOM	= 9,
	WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_DD_BOTTOM	= 10
    } ;
typedef 
enum tagWMT_OFFSET_FORMAT
    {	WMT_OFFSET_FORMAT_100NS	= 0,
	WMT_OFFSET_FORMAT_FRAME_NUMBERS	= WMT_OFFSET_FORMAT_100NS + 1,
	WMT_OFFSET_FORMAT_PLAYLIST_OFFSET	= WMT_OFFSET_FORMAT_FRAME_NUMBERS + 1
    } 	WMT_OFFSET_FORMAT;

typedef 
enum tagWMT_INDEXER_TYPE
    {	WMT_IT_PRESENTATION_TIME	= 0,
	WMT_IT_FRAME_NUMBERS	= WMT_IT_PRESENTATION_TIME + 1
    } 	WMT_INDEXER_TYPE;

typedef 
enum tagWMT_INDEX_TYPE
    {	WMT_IT_NEAREST_DATA_UNIT	= 1,
	WMT_IT_NEAREST_OBJECT	= WMT_IT_NEAREST_DATA_UNIT + 1,
	WMT_IT_NEAREST_CLEAN_POINT	= WMT_IT_NEAREST_OBJECT + 1
    } 	WMT_INDEX_TYPE;

typedef 
enum tagWMT_FILESINK_MODE
    {	WMT_FM_SINGLE_BUFFERS	= 0x1,
	WMT_FM_FILESINK_DATA_UNITS	= 0x2,
	WMT_FM_FILESINK_UNBUFFERED	= 0x4
    } 	WMT_FILESINK_MODE;

typedef struct _WMStreamPrioritizationRecord
    {
    WORD wStreamNumber;
    BOOL fMandatory;
    } 	WM_STREAM_PRIORITY_RECORD;

typedef struct _WMWriterStatistics
    {
    QWORD qwSampleCount;
    QWORD qwByteCount;
    QWORD qwDroppedSampleCount;
    QWORD qwDroppedByteCount;
    DWORD dwCurrentBitrate;
    DWORD dwAverageBitrate;
    DWORD dwExpectedBitrate;
    DWORD dwCurrentSampleRate;
    DWORD dwAverageSampleRate;
    DWORD dwExpectedSampleRate;
    } 	WM_WRITER_STATISTICS;

typedef struct _WMWriterStatisticsEx
    {
    DWORD dwBitratePlusOverhead;
    DWORD dwCurrentSampleDropRateInQueue;
    DWORD dwCurrentSampleDropRateInCodec;
    DWORD dwCurrentSampleDropRateInMultiplexer;
    DWORD dwTotalSampleDropsInQueue;
    DWORD dwTotalSampleDropsInCodec;
    DWORD dwTotalSampleDropsInMultiplexer;
    } 	WM_WRITER_STATISTICS_EX;

typedef struct _WMReaderStatistics
    {
    DWORD cbSize;
    DWORD dwBandwidth;
    DWORD cPacketsReceived;
    DWORD cPacketsRecovered;
    DWORD cPacketsLost;
    WORD wQuality;
    } 	WM_READER_STATISTICS;

typedef struct _WMReaderClientInfo
    {
    DWORD cbSize;
    WCHAR *wszLang;
    WCHAR *wszBrowserUserAgent;
    WCHAR *wszBrowserWebPage;
    QWORD qwReserved;
    LPARAM *pReserved;
    WCHAR *wszHostExe;
    QWORD qwHostVersion;
    } 	WM_READER_CLIENTINFO;

typedef struct _WMClientProperties
    {
    DWORD dwIPAddress;
    DWORD dwPort;
    } 	WM_CLIENT_PROPERTIES;

typedef struct _WMClientPropertiesEx
    {
    DWORD cbSize;
    LPCWSTR pwszIPAddress;
    LPCWSTR pwszPort;
    LPCWSTR pwszDNSName;
    } 	WM_CLIENT_PROPERTIES_EX;

typedef struct _WMPortNumberRange
    {
    WORD wPortBegin;
    WORD wPortEnd;
    } 	WM_PORT_NUMBER_RANGE;

typedef struct _WMT_BUFFER_SEGMENT
    {
    INSSBuffer *pBuffer;
    DWORD cbOffset;
    DWORD cbLength;
    } 	WMT_BUFFER_SEGMENT;

typedef struct _WMT_PAYLOAD_FRAGMENT
    {
    DWORD dwPayloadIndex;
    WMT_BUFFER_SEGMENT segmentData;
    } 	WMT_PAYLOAD_FRAGMENT;

typedef struct _WMT_FILESINK_DATA_UNIT
    {
    WMT_BUFFER_SEGMENT packetHeaderBuffer;
    DWORD cPayloads;
    WMT_BUFFER_SEGMENT *pPayloadHeaderBuffers;
    DWORD cPayloadDataFragments;
    WMT_PAYLOAD_FRAGMENT *pPayloadDataFragments;
    } 	WMT_FILESINK_DATA_UNIT;

typedef struct _WM_LICENSE_STATE_DATA
    {
    DWORD dwSize;
    DWORD dwNumStates;
    DRM_LICENSE_STATE_DATA stateData[ 1 ];
    } 	WM_LICENSE_STATE_DATA;

typedef struct _WMMediaType
    {
    GUID majortype;
    GUID subtype;
    BOOL bFixedSizeSamples;
    BOOL bTemporalCompression;
    ULONG lSampleSize;
    GUID formattype;
    IUnknown *pUnk;
    ULONG cbFormat;
    /* [size_is] */ BYTE *pbFormat;
    } 	WM_MEDIA_TYPE;

typedef struct tagWMVIDEOINFOHEADER
{
    //
    // The bit we really want to use.
    //
    RECT rcSource;

    //
    // Where the video should go.
    //
    RECT rcTarget;

    //
    // Approximate bit data rate.
    //
    DWORD dwBitRate;

    //
    // Bit error rate for this stream.
    //
    DWORD dwBitErrorRate;

    //
    // Average time per frame (100ns units).
    //
    LONGLONG AvgTimePerFrame;

    BITMAPINFOHEADER bmiHeader;
} WMVIDEOINFOHEADER;
typedef struct tagWMVIDEOINFOHEADER2
{
    //
    // The bit we really want to use.
    //
    RECT rcSource;

    //
    // Where the video should go.
    //
    RECT rcTarget;

    //
    // Approximate bit data rate.
    //
    DWORD dwBitRate;

    //
    // Bit error rate for this stream.
    //
    DWORD dwBitErrorRate;

    //
    // Average time per frame (100ns units).
    //
    LONGLONG AvgTimePerFrame;

    //
    // Use AMINTERLACE_* defines. Reject connection if undefined bits are not 0.
    //
    DWORD dwInterlaceFlags;

    //
    // use AMCOPYPROTECT_* defines. Reject connection if undefined bits are not 0.
    //
    DWORD dwCopyProtectFlags;

    //
    // X dimension of picture aspect ratio, e.g. 16 for 16x9 display.
    //
    DWORD dwPictAspectRatioX;

    //
    // Y dimension of picture aspect ratio, e.g.  9 for 16x9 display.
    //
    DWORD dwPictAspectRatioY;

    //
    // Must be 0; reject connection otherwise.
    //
    DWORD dwReserved1;

    //
    // Must be 0; reject connection otherwise.
    //
    DWORD dwReserved2;

    BITMAPINFOHEADER bmiHeader;
} WMVIDEOINFOHEADER2;
typedef struct tagWMMPEG2VIDEOINFO
{
    //
    // Video info header2.
    //
    WMVIDEOINFOHEADER2 hdr;

    //
    // Not used for DVD.
    //
    DWORD dwStartTimeCode;

    //
    // Is 0 for DVD (no sequence header).
    //
    DWORD cbSequenceHeader;

    //
    // Use enum MPEG2Profile.
    //
    DWORD dwProfile;

    //
    // Use enum MPEG2Level.
    //
    DWORD dwLevel;

    //
    // Use AMMPEG2_* defines.  Reject connection if undefined bits are not 0.
    //
    DWORD dwFlags;

    //
    // Sequence header.
    //
    DWORD dwSequenceHeader[1];

} WMMPEG2VIDEOINFO;
typedef struct tagWMSCRIPTFORMAT
{
    GUID    scriptType; 
} WMSCRIPTFORMAT;
// 00000000-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_Base 
EXTERN_GUID(WMMEDIASUBTYPE_Base, 
0x00000000, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 73646976-0000-0010-8000-00AA00389B71  'vids' == WMMEDIATYPE_Video 
EXTERN_GUID(WMMEDIATYPE_Video, 
0x73646976, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1 
EXTERN_GUID(WMMEDIASUBTYPE_RGB1, 
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb79-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB4 
EXTERN_GUID(WMMEDIASUBTYPE_RGB4, 
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB8 
EXTERN_GUID(WMMEDIASUBTYPE_RGB8, 
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB565 
EXTERN_GUID(WMMEDIASUBTYPE_RGB565, 
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB555 
EXTERN_GUID(WMMEDIASUBTYPE_RGB555, 
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB24 
EXTERN_GUID(WMMEDIASUBTYPE_RGB24, 
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB32 
EXTERN_GUID(WMMEDIASUBTYPE_RGB32, 
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// 30323449-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_I420 
EXTERN_GUID(WMMEDIASUBTYPE_I420, 
0x30323449, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 56555949-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_IYUV 
EXTERN_GUID(WMMEDIASUBTYPE_IYUV, 
0x56555949, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 31313259-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_YV12 
EXTERN_GUID(WMMEDIASUBTYPE_YV12, 
0x32315659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 32595559-0000-0010-8000-00AA00389B71  'YUY2' == MEDIASUBTYPE_YUY2 
EXTERN_GUID(WMMEDIASUBTYPE_YUY2, 
0x32595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 59565955-0000-0010-8000-00AA00389B71  'UYVY' ==  MEDIASUBTYPE_UYVY 
EXTERN_GUID(WMMEDIASUBTYPE_UYVY, 
0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 55595659-0000-0010-8000-00AA00389B71  'YVYU' == MEDIASUBTYPE_YVYU 
EXTERN_GUID(WMMEDIASUBTYPE_YVYU, 
0x55595659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 39555659-0000-0010-8000-00AA00389B71  'YVU9' == MEDIASUBTYPE_YVU9 
EXTERN_GUID(WMMEDIASUBTYPE_YVU9, 
0x39555659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 3334504D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MP43 
EXTERN_GUID(WMMEDIASUBTYPE_MP43, 
0x3334504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 5334504D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MP4S 
EXTERN_GUID(WMMEDIASUBTYPE_MP4S, 
0x5334504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 31564D57-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMV1 
EXTERN_GUID(WMMEDIASUBTYPE_WMV1, 
0x31564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 32564D57-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMV2 
EXTERN_GUID(WMMEDIASUBTYPE_WMV2, 
0x32564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 3153534D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MSS1 
EXTERN_GUID(WMMEDIASUBTYPE_MSS1, 
0x3153534D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// e06d8026-db46-11cf-b4d1-00805f6cbbea            WMMEDIASUBTYPE_MPEG2_VIDEO 
EXTERN_GUID(WMMEDIASUBTYPE_MPEG2_VIDEO, 
0xe06d8026, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea); 
// 73647561-0000-0010-8000-00AA00389B71  'auds' == WMMEDIATYPE_Audio 
EXTERN_GUID(WMMEDIATYPE_Audio, 
0x73647561, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 00000001-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_PCM 
EXTERN_GUID(WMMEDIASUBTYPE_PCM, 
0x00000001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000009-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_DRM 
EXTERN_GUID(WMMEDIASUBTYPE_DRM, 
0x00000009, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000161-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV8 
EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV8, 
0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000161-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV7 
EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV7, 
0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000161-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV2 
EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV2, 
0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000130-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_ACELPnet 
EXTERN_GUID(WMMEDIASUBTYPE_ACELPnet, 
0x00000130, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 73636d64-0000-0010-8000-00AA00389B71  'scmd' == WMMEDIATYPE_Script 
EXTERN_GUID(WMMEDIATYPE_Script, 
0x73636d64, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 34A50FD8-8AA5-4386-81FE-A0EFE0488E31  'imag' == WMMEDIATYPE_Image 
EXTERN_GUID(WMMEDIATYPE_Image, 
0x34a50fd8, 0x8aa5, 0x4386, 0x81, 0xfe, 0xa0, 0xef, 0xe0, 0x48, 0x8e, 0x31); 
// D9E47579-930E-4427-ADFC-AD80F290E470  'fxfr' == WMMEDIATYPE_FileTransfer 
EXTERN_GUID(WMMEDIATYPE_FileTransfer, 
0xd9e47579, 0x930e, 0x4427, 0xad, 0xfc, 0xad, 0x80, 0xf2, 0x90, 0xe4, 0x70); 
// 9BBA1EA7-5AB2-4829-BA57-0940209BCF3E      'text' == WMMEDIATYPE_Text 
EXTERN_GUID(WMMEDIATYPE_Text, 
0x9bba1ea7, 0x5ab2, 0x4829, 0xba, 0x57, 0x9, 0x40, 0x20, 0x9b, 0xcf, 0x3e); 
// 05589f80-c356-11ce-bf01-00aa0055595a        WMFORMAT_VideoInfo 
EXTERN_GUID(WMFORMAT_VideoInfo, 
0x05589f80, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a); 
// e06d80e3-db46-11cf-b4d1-00805f6cbbea        WMFORMAT_MPEG2Video 
EXTERN_GUID(WMFORMAT_MPEG2Video, 
0xe06d80e3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea); 
// 05589f81-c356-11ce-bf01-00aa0055595a        WMFORMAT_WaveFormatEx 
EXTERN_GUID(WMFORMAT_WaveFormatEx, 
0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a); 
// 5C8510F2-DEBE-4ca7-BBA5-F07A104F8DFF        WMFORMAT_Script 
EXTERN_GUID(WMFORMAT_Script, 
0x5c8510f2, 0xdebe, 0x4ca7, 0xbb, 0xa5, 0xf0, 0x7a, 0x10, 0x4f, 0x8d, 0xff); 
// 82f38a70-c29f-11d1-97ad-00a0c95ea850        WMSCRIPTTYPE_TwoStrings 
EXTERN_GUID( WMSCRIPTTYPE_TwoStrings, 
0x82f38a70,0xc29f,0x11d1,0x97,0xad,0x00,0xa0,0xc9,0x5e,0xa8,0x50); 
EXTERN_GUID( IID_IWMMediaProps,         0x96406bce,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMVideoMediaProps,    0x96406bcf,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriter,             0x96406bd4,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMInputMediaProps,    0x96406bd5,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReader,             0x96406bd6,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMSyncReader,         0x9397f121,0x7705,0x4dc9,0xb0,0x49,0x98,0xb6,0x98,0x18,0x84,0x14 );
EXTERN_GUID( IID_IWMOutputMediaProps,   0x96406bd7,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMStatusCallback,     0x6d7cdc70,0x9888,0x11d3,0x8e,0xdc,0x00,0xc0,0x4f,0x61,0x09,0xcf );
EXTERN_GUID( IID_IWMReaderCallback,     0x96406bd8,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMCredentialCallback, 0x342e0eb7,0xe651,0x450c,0x97,0x5b,0x2a,0xce,0x2c,0x90,0xc4,0x8e );
EXTERN_GUID( IID_IWMMetadataEditor,     0x96406bd9,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMMetadataEditor2,    0x203cffe3,0x2e18,0x4fdf,0xb5,0x9d,0x6e,0x71,0x53,0x05,0x34,0xcf );
EXTERN_GUID( IID_IWMHeaderInfo,         0x96406bda,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMHeaderInfo2,        0x15cf9781,0x454e,0x482e,0xb3,0x93,0x85,0xfa,0xe4,0x87,0xa8,0x10 );
EXTERN_GUID( IID_IWMProfileManager,     0xd16679f2,0x6ca0,0x472d,0x8d,0x31,0x2f,0x5d,0x55,0xae,0xe1,0x55 );
EXTERN_GUID( IID_IWMProfileManager2,    0x7a924e51,0x73c1,0x494d,0x80,0x19,0x23,0xd3,0x7e,0xd9,0xb8,0x9a );
EXTERN_GUID( IID_IWMProfile,            0x96406bdb,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMProfile2,           0x07e72d33,0xd94e,0x4be7,0x88,0x43,0x60,0xae,0x5f,0xf7,0xe5,0xf5 );
EXTERN_GUID( IID_IWMProfile3,           0x00ef96cc,0xa461,0x4546,0x8b,0xcd,0xc9,0xa2,0x8f,0x0e,0x06,0xf5 );
EXTERN_GUID( IID_IWMStreamConfig,       0x96406bdc,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMStreamConfig2,      0x7688d8cb,0xfc0d,0x43bd,0x94,0x59,0x5a,0x8d,0xec,0x20,0x0c,0xfa );
EXTERN_GUID( IID_IWMStreamList,         0x96406bdd,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMMutualExclusion,    0x96406bde,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMMutualExclusion2,   0x302b57d,0x89d1,0x4ba2,0x85,0xc9,0x16,0x6f,0x2c,0x53,0xeb,0x91 );
EXTERN_GUID( IID_IWMBandwidthSharing,   0xad694af1,0xf8d9,0x42f8,0xbc,0x47,0x70,0x31,0x1b,0x0c,0x4f,0x9e );
EXTERN_GUID( IID_IWMStreamPrioritization, 0x8c1c6090,0xf9a8,0x4748,0x8e,0xc3,0xdd,0x11,0x08,0xba,0x1e,0x77 );
EXTERN_GUID( IID_IWMWriterAdvanced,     0x96406be3,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterAdvanced2,    0x962dc1ec,0xc046,0x4db8,0x9c,0xc7,0x26,0xce,0xae,0x50,0x08,0x17 );
EXTERN_GUID( IID_IWMWriterAdvanced3,    0x2cd6492d,0x7c37,0x4e76,0x9d,0x3b,0x59,0x26,0x11,0x83,0xa2,0x2e );
EXTERN_GUID( IID_IWMWriterPreprocess,   0xfc54a285,0x38c4,0x45b5,0xaa,0x23,0x85,0xb9,0xf7,0xcb,0x42,0x4b );
EXTERN_GUID( IID_IWMWriterSink,         0x96406be4,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterFileSink,     0x96406be5,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterFileSink2,    0x14282ba7,0x4aef,0x4205,0x8c,0xe5,0xc2,0x29,0x03,0x5a,0x05,0xbc );
EXTERN_GUID( IID_IWMWriterFileSinkDataUnit, 0x633392f0,0xbe5c,0x486b,0xa0,0x9c,0x10,0x66,0x9c,0x7a,0x6c,0x27);
EXTERN_GUID( IID_IWMWriterFileSink3,    0x3fea4feb,0x2945,0x47a7,0xa1,0xdd,0xc5,0x3a,0x8f,0xc4,0xc4,0x5c );
EXTERN_GUID( IID_IWMWriterNetworkSink,  0x96406be7,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMClientConnections,  0x73c66010,0xa299,0x41df,0xb1,0xf0,0xcc,0xf0,0x3b,0x09,0xc1,0xc6 );
EXTERN_GUID( IID_IWMReaderAdvanced,     0x96406bea,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReaderAdvanced2,    0xae14a945,0xb90c,0x4d0d,0x91,0x27,0x80,0xd6,0x65,0xf7,0xd7,0x3e );
EXTERN_GUID( IID_IWMReaderAdvanced3,    0x5dc0674b,0xf04b,0x4a4e,0x9f,0x2a,0xb1,0xaf,0xde,0x2c,0x81,0x00 );
EXTERN_GUID( IID_IWMDRMReader,          0xd2827540,0x3ee7,0x432c,0xb1,0x4c,0xdc,0x17,0xf0,0x85,0xd3,0xb3 );
EXTERN_GUID( IID_IWMReaderCallbackAdvanced, 0x96406beb,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReaderNetworkConfig,0x96406bec,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReaderStreamClock,  0x96406bed,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMIndexer,            0x6d7cdc71,0x9888,0x11d3,0x8e,0xdc,0x00,0xc0,0x4f,0x61,0x09,0xcf );
EXTERN_GUID( IID_IWMIndexer2,           0xb70f1e42,0x6255,0x4df0,0xa6,0xb9,0x02,0xb2,0x12,0xd9,0xe2,0xbb );
EXTERN_GUID( IID_IWMReaderAllocatorEx,  0x9f762fa7,0xa22e,0x428d,0x93,0xc9,0xac,0x82,0xf3,0xaa,0xfe,0x5a );
EXTERN_GUID( IID_IWMReaderTypeNegotiation, 0xfdbe5592,0x81a1,0x41ea,0x93,0xbd,0x73,0x5c,0xad,0x1a,0xdc,0x5 );
EXTERN_GUID( IID_IWMLicenseBackup,      0x05E5AC9F,0x3FB6,0x4508,0xBB,0x43,0xA4,0x06,0x7B,0xA1,0xEB,0xE8);
EXTERN_GUID( IID_IWMLicenseRestore,     0xC70B6334,0xa22e,0x4efb,0xA2,0x45,0x15,0xE6,0x5A,0x00,0x4A,0x13);
EXTERN_GUID( IID_IWMBackupRestoreProps, 0x3C8E0DA6,0x996F,0x4ff3,0xA1,0xAF,0x48,0x38,0xF9,0x37,0x7e,0x2e);
EXTERN_GUID( IID_IWMPacketSize,         0xcdfb97ab,0x188f,0x40b3,0xb6,0x43,0x5b,0x79,0x03,0x97,0x5c,0x59);
EXTERN_GUID( IID_IWMPacketSize2,        0x8bfc2b9e,0xb646,0x4233,0xa8,0x77,0x1c,0x6a,0x7,0x96,0x69,0xdc);
EXTERN_GUID( IID_IWMRegisterCallback,   0xcf4b1f99,0x4de2,0x4e49,0xa3,0x63,0x25,0x27,0x40,0xd9,0x9b,0xc1);
EXTERN_GUID( IID_IWMWriterPostView,     0x81e20ce4,0x75ef,0x491a,0x80,0x04,0xfc,0x53,0xc4,0x5b,0xdc,0x3e);
EXTERN_GUID( IID_IWMWriterPostViewCallback, 0xd9d6549d,0xa193,0x4f24,0xb3,0x08,0x03,0x12,0x3d,0x9b,0x7f,0x8d);
EXTERN_GUID( IID_IWMCodecInfo,          0xa970f41e,0x34de,0x4a98,0xb3,0xba,0xe4,0xb3,0xca,0x75,0x28,0xf0);
EXTERN_GUID( IID_IWMCodecInfo2,         0xaa65e273,0xb686,0x4056,0x91,0xec,0xdd,0x76,0x8d,0x4d,0xf7,0x10);
EXTERN_GUID( IID_IWMPropertyVault,      0x72995A79,0x5090,0x42a4,0x9C,0x8C,0xD9,0xD0,0xB6,0xD3,0x4B,0xE5 );
EXTERN_GUID( IID_IWMIStreamProps,       0x6816dad3,0x2b4b,0x4c8e,0x81,0x49,0x87,0x4c,0x34,0x83,0xa7,0x53 );
EXTERN_GUID( CLSID_WMMUTEX_Language, 0xD6E22A00,0x35DA,0x11D1,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE );
EXTERN_GUID( CLSID_WMMUTEX_Bitrate, 0xD6E22A01,0x35DA,0x11D1,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE );
EXTERN_GUID( CLSID_WMMUTEX_Presentation, 0xD6E22A02,0x35DA,0x11D1,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE );
EXTERN_GUID( CLSID_WMMUTEX_Unknown, 0xD6E22A03,0x35DA,0x11D1,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE );
EXTERN_GUID( CLSID_WMBandwidthSharing_Exclusive, 0xaf6060aa,0x5197,0x11d2,0xb6,0xaf,0x00,0xc0,0x4f,0xd9,0x08,0xe9 );
EXTERN_GUID( CLSID_WMBandwidthSharing_Partial, 0xaf6060ab,0x5197,0x11d2,0xb6,0xaf,0x00,0xc0,0x4f,0xd9,0x08,0xe9 );
#define WM_MAX_VIDEO_STREAMS            0x07f
#define WM_MAX_STREAMS                  0x07f
HRESULT STDMETHODCALLTYPE WMIsContentProtected( const WCHAR *pwszFileName, BOOL *pfIsProtected );
HRESULT STDMETHODCALLTYPE WMCreateCertificate( IUnknown** pUnkCert );
HRESULT STDMETHODCALLTYPE WMCreateWriter( IUnknown* pUnkCert, IWMWriter **ppWriter );
HRESULT STDMETHODCALLTYPE WMCreateReader( IUnknown* pUnkCert, DWORD dwRights, IWMReader **ppReader );
HRESULT STDMETHODCALLTYPE WMCreateSyncReader( IUnknown* pUnkCert, DWORD dwRights, IWMSyncReader **ppSyncReader );
HRESULT STDMETHODCALLTYPE WMCreateEditor( IWMMetadataEditor **ppEditor );
HRESULT STDMETHODCALLTYPE WMCreateIndexer( IWMIndexer **ppIndexer );
HRESULT STDMETHODCALLTYPE WMCreateBackupRestorer( IUnknown *pCallback, IWMLicenseBackup **ppBackup );
HRESULT STDMETHODCALLTYPE WMCreateProfileManager( IWMProfileManager **ppProfileManager );
HRESULT STDMETHODCALLTYPE WMCreateWriterFileSink( IWMWriterFileSink **ppSink );
HRESULT STDMETHODCALLTYPE WMCreateWriterNetworkSink( IWMWriterNetworkSink **ppSink );


extern RPC_IF_HANDLE __MIDL_itf_wmsdkidl_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsdkidl_0000_v0_0_s_ifspec;

#ifndef __IWMMediaProps_INTERFACE_DEFINED__
#define __IWMMediaProps_INTERFACE_DEFINED__

/* interface IWMMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BCE-2B2B-11d3-B36B-00C04F6108FF")
    IWMMediaProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID *pguidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaType( 
            /* [out] */ WM_MEDIA_TYPE *pType,
            /* [out][in] */ DWORD *pcbType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaType( 
            /* [in] */ WM_MEDIA_TYPE *pType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMMediaProps * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMMediaProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMMediaProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IWMMediaProps * This,
            /* [out] */ GUID *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IWMMediaProps * This,
            /* [out] */ WM_MEDIA_TYPE *pType,
            /* [out][in] */ DWORD *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IWMMediaProps * This,
            /* [in] */ WM_MEDIA_TYPE *pType);
        
        END_INTERFACE
    } IWMMediaPropsVtbl;

    interface IWMMediaProps
    {
        CONST_VTBL struct IWMMediaPropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMediaProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMMediaProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMMediaProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMMediaProps_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMMediaProps_GetMediaType(This,pType,pcbType)	\
    (This)->lpVtbl -> GetMediaType(This,pType,pcbType)

#define IWMMediaProps_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMMediaProps_GetType_Proxy( 
    IWMMediaProps * This,
    /* [out] */ GUID *pguidType);


void __RPC_STUB IWMMediaProps_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMediaProps_GetMediaType_Proxy( 
    IWMMediaProps * This,
    /* [out] */ WM_MEDIA_TYPE *pType,
    /* [out][in] */ DWORD *pcbType);


void __RPC_STUB IWMMediaProps_GetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMediaProps_SetMediaType_Proxy( 
    IWMMediaProps * This,
    /* [in] */ WM_MEDIA_TYPE *pType);


void __RPC_STUB IWMMediaProps_SetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMVideoMediaProps_INTERFACE_DEFINED__
#define __IWMVideoMediaProps_INTERFACE_DEFINED__

/* interface IWMVideoMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMVideoMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BCF-2B2B-11d3-B36B-00C04F6108FF")
    IWMVideoMediaProps : public IWMMediaProps
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMaxKeyFrameSpacing( 
            /* [out] */ LONGLONG *pllTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxKeyFrameSpacing( 
            /* [in] */ LONGLONG llTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQuality( 
            /* [out] */ DWORD *pdwQuality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetQuality( 
            /* [in] */ DWORD dwQuality) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMVideoMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMVideoMediaProps * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMVideoMediaProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMVideoMediaProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IWMVideoMediaProps * This,
            /* [out] */ GUID *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IWMVideoMediaProps * This,
            /* [out] */ WM_MEDIA_TYPE *pType,
            /* [out][in] */ DWORD *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IWMVideoMediaProps * This,
            /* [in] */ WM_MEDIA_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxKeyFrameSpacing )( 
            IWMVideoMediaProps * This,
            /* [out] */ LONGLONG *pllTime);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxKeyFrameSpacing )( 
            IWMVideoMediaProps * This,
            /* [in] */ LONGLONG llTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetQuality )( 
            IWMVideoMediaProps * This,
            /* [out] */ DWORD *pdwQuality);
        
        HRESULT ( STDMETHODCALLTYPE *SetQuality )( 
            IWMVideoMediaProps * This,
            /* [in] */ DWORD dwQuality);
        
        END_INTERFACE
    } IWMVideoMediaPropsVtbl;

    interface IWMVideoMediaProps
    {
        CONST_VTBL struct IWMVideoMediaPropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMVideoMediaProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMVideoMediaProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMVideoMediaProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMVideoMediaProps_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMVideoMediaProps_GetMediaType(This,pType,pcbType)	\
    (This)->lpVtbl -> GetMediaType(This,pType,pcbType)

#define IWMVideoMediaProps_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)


#define IWMVideoMediaProps_GetMaxKeyFrameSpacing(This,pllTime)	\
    (This)->lpVtbl -> GetMaxKeyFrameSpacing(This,pllTime)

#define IWMVideoMediaProps_SetMaxKeyFrameSpacing(This,llTime)	\
    (This)->lpVtbl -> SetMaxKeyFrameSpacing(This,llTime)

#define IWMVideoMediaProps_GetQuality(This,pdwQuality)	\
    (This)->lpVtbl -> GetQuality(This,pdwQuality)

#define IWMVideoMediaProps_SetQuality(This,dwQuality)	\
    (This)->lpVtbl -> SetQuality(This,dwQuality)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMVideoMediaProps_GetMaxKeyFrameSpacing_Proxy( 
    IWMVideoMediaProps * This,
    /* [out] */ LONGLONG *pllTime);


void __RPC_STUB IWMVideoMediaProps_GetMaxKeyFrameSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMVideoMediaProps_SetMaxKeyFrameSpacing_Proxy( 
    IWMVideoMediaProps * This,
    /* [in] */ LONGLONG llTime);


void __RPC_STUB IWMVideoMediaProps_SetMaxKeyFrameSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMVideoMediaProps_GetQuality_Proxy( 
    IWMVideoMediaProps * This,
    /* [out] */ DWORD *pdwQuality);


void __RPC_STUB IWMVideoMediaProps_GetQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMVideoMediaProps_SetQuality_Proxy( 
    IWMVideoMediaProps * This,
    /* [in] */ DWORD dwQuality);


void __RPC_STUB IWMVideoMediaProps_SetQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMVideoMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMWriter_INTERFACE_DEFINED__
#define __IWMWriter_INTERFACE_DEFINED__

/* interface IWMWriter */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD4-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProfileByID( 
            /* [in] */ REFGUID guidProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProfile( 
            /* [in] */ IWMProfile *pProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputFilename( 
            /* [in] */ const WCHAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputCount( 
            /* [out] */ DWORD *pcInputs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputProps( 
            /* [in] */ DWORD dwInputNum,
            /* [out] */ IWMInputMediaProps **ppInput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputProps( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ IWMInputMediaProps *pInput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputFormatCount( 
            /* [in] */ DWORD dwInputNumber,
            /* [out] */ DWORD *pcFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputFormat( 
            /* [in] */ DWORD dwInputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMInputMediaProps **pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginWriting( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndWriting( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateSample( 
            /* [in] */ DWORD dwSampleSize,
            /* [out] */ INSSBuffer **ppSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteSample( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProfileByID )( 
            IWMWriter * This,
            /* [in] */ REFGUID guidProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SetProfile )( 
            IWMWriter * This,
            /* [in] */ IWMProfile *pProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputFilename )( 
            IWMWriter * This,
            /* [in] */ const WCHAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputCount )( 
            IWMWriter * This,
            /* [out] */ DWORD *pcInputs);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputProps )( 
            IWMWriter * This,
            /* [in] */ DWORD dwInputNum,
            /* [out] */ IWMInputMediaProps **ppInput);
        
        HRESULT ( STDMETHODCALLTYPE *SetInputProps )( 
            IWMWriter * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ IWMInputMediaProps *pInput);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputFormatCount )( 
            IWMWriter * This,
            /* [in] */ DWORD dwInputNumber,
            /* [out] */ DWORD *pcFormats);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputFormat )( 
            IWMWriter * This,
            /* [in] */ DWORD dwInputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMInputMediaProps **pProps);
        
        HRESULT ( STDMETHODCALLTYPE *BeginWriting )( 
            IWMWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *EndWriting )( 
            IWMWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateSample )( 
            IWMWriter * This,
            /* [in] */ DWORD dwSampleSize,
            /* [out] */ INSSBuffer **ppSample);
        
        HRESULT ( STDMETHODCALLTYPE *WriteSample )( 
            IWMWriter * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample);
        
        HRESULT ( STDMETHODCALLTYPE *Flush )( 
            IWMWriter * This);
        
        END_INTERFACE
    } IWMWriterVtbl;

    interface IWMWriter
    {
        CONST_VTBL struct IWMWriterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriter_SetProfileByID(This,guidProfile)	\
    (This)->lpVtbl -> SetProfileByID(This,guidProfile)

#define IWMWriter_SetProfile(This,pProfile)	\
    (This)->lpVtbl -> SetProfile(This,pProfile)

#define IWMWriter_SetOutputFilename(This,pwszFilename)	\
    (This)->lpVtbl -> SetOutputFilename(This,pwszFilename)

#define IWMWriter_GetInputCount(This,pcInputs)	\
    (This)->lpVtbl -> GetInputCount(This,pcInputs)

#define IWMWriter_GetInputProps(This,dwInputNum,ppInput)	\
    (This)->lpVtbl -> GetInputProps(This,dwInputNum,ppInput)

#define IWMWriter_SetInputProps(This,dwInputNum,pInput)	\
    (This)->lpVtbl -> SetInputProps(This,dwInputNum,pInput)

#define IWMWriter_GetInputFormatCount(This,dwInputNumber,pcFormats)	\
    (This)->lpVtbl -> GetInputFormatCount(This,dwInputNumber,pcFormats)

#define IWMWriter_GetInputFormat(This,dwInputNumber,dwFormatNumber,pProps)	\
    (This)->lpVtbl -> GetInputFormat(This,dwInputNumber,dwFormatNumber,pProps)

#define IWMWriter_BeginWriting(This)	\
    (This)->lpVtbl -> BeginWriting(This)

#define IWMWriter_EndWriting(This)	\
    (This)->lpVtbl -> EndWriting(This)

#define IWMWriter_AllocateSample(This,dwSampleSize,ppSample)	\
    (This)->lpVtbl -> AllocateSample(This,dwSampleSize,ppSample)

#define IWMWriter_WriteSample(This,dwInputNum,cnsSampleTime,dwFlags,pSample)	\
    (This)->lpVtbl -> WriteSample(This,dwInputNum,cnsSampleTime,dwFlags,pSample)

#define IWMWriter_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriter_SetProfileByID_Proxy( 
    IWMWriter * This,
    /* [in] */ REFGUID guidProfile);


void __RPC_STUB IWMWriter_SetProfileByID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_SetProfile_Proxy( 
    IWMWriter * This,
    /* [in] */ IWMProfile *pProfile);


void __RPC_STUB IWMWriter_SetProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_SetOutputFilename_Proxy( 
    IWMWriter * This,
    /* [in] */ const WCHAR *pwszFilename);


void __RPC_STUB IWMWriter_SetOutputFilename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_GetInputCount_Proxy( 
    IWMWriter * This,
    /* [out] */ DWORD *pcInputs);


void __RPC_STUB IWMWriter_GetInputCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_GetInputProps_Proxy( 
    IWMWriter * This,
    /* [in] */ DWORD dwInputNum,
    /* [out] */ IWMInputMediaProps **ppInput);


void __RPC_STUB IWMWriter_GetInputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_SetInputProps_Proxy( 
    IWMWriter * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ IWMInputMediaProps *pInput);


void __RPC_STUB IWMWriter_SetInputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_GetInputFormatCount_Proxy( 
    IWMWriter * This,
    /* [in] */ DWORD dwInputNumber,
    /* [out] */ DWORD *pcFormats);


void __RPC_STUB IWMWriter_GetInputFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_GetInputFormat_Proxy( 
    IWMWriter * This,
    /* [in] */ DWORD dwInputNumber,
    /* [in] */ DWORD dwFormatNumber,
    /* [out] */ IWMInputMediaProps **pProps);


void __RPC_STUB IWMWriter_GetInputFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_BeginWriting_Proxy( 
    IWMWriter * This);


void __RPC_STUB IWMWriter_BeginWriting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_EndWriting_Proxy( 
    IWMWriter * This);


void __RPC_STUB IWMWriter_EndWriting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_AllocateSample_Proxy( 
    IWMWriter * This,
    /* [in] */ DWORD dwSampleSize,
    /* [out] */ INSSBuffer **ppSample);


void __RPC_STUB IWMWriter_AllocateSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_WriteSample_Proxy( 
    IWMWriter * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer *pSample);


void __RPC_STUB IWMWriter_WriteSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_Flush_Proxy( 
    IWMWriter * This);


void __RPC_STUB IWMWriter_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriter_INTERFACE_DEFINED__ */


#ifndef __IWMInputMediaProps_INTERFACE_DEFINED__
#define __IWMInputMediaProps_INTERFACE_DEFINED__

/* interface IWMInputMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMInputMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD5-2B2B-11d3-B36B-00C04F6108FF")
    IWMInputMediaProps : public IWMMediaProps
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConnectionName( 
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupName( 
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMInputMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMInputMediaProps * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMInputMediaProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMInputMediaProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IWMInputMediaProps * This,
            /* [out] */ GUID *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IWMInputMediaProps * This,
            /* [out] */ WM_MEDIA_TYPE *pType,
            /* [out][in] */ DWORD *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IWMInputMediaProps * This,
            /* [in] */ WM_MEDIA_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionName )( 
            IWMInputMediaProps * This,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupName )( 
            IWMInputMediaProps * This,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchName);
        
        END_INTERFACE
    } IWMInputMediaPropsVtbl;

    interface IWMInputMediaProps
    {
        CONST_VTBL struct IWMInputMediaPropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMInputMediaProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMInputMediaProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMInputMediaProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMInputMediaProps_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMInputMediaProps_GetMediaType(This,pType,pcbType)	\
    (This)->lpVtbl -> GetMediaType(This,pType,pcbType)

#define IWMInputMediaProps_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)


#define IWMInputMediaProps_GetConnectionName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetConnectionName(This,pwszName,pcchName)

#define IWMInputMediaProps_GetGroupName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetGroupName(This,pwszName,pcchName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMInputMediaProps_GetConnectionName_Proxy( 
    IWMInputMediaProps * This,
    /* [out] */ WCHAR *pwszName,
    /* [out][in] */ WORD *pcchName);


void __RPC_STUB IWMInputMediaProps_GetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMInputMediaProps_GetGroupName_Proxy( 
    IWMInputMediaProps * This,
    /* [out] */ WCHAR *pwszName,
    /* [out][in] */ WORD *pcchName);


void __RPC_STUB IWMInputMediaProps_GetGroupName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMInputMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMPropertyVault_INTERFACE_DEFINED__
#define __IWMPropertyVault_INTERFACE_DEFINED__

/* interface IWMPropertyVault */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPropertyVault;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("72995A79-5090-42a4-9C8C-D9D0B6D34BE5")
    IWMPropertyVault : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyCount( 
            /* [in] */ DWORD *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyByName( 
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE pType,
            /* [in] */ BYTE *pValue,
            /* [in] */ DWORD dwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pszName,
            /* [out][in] */ DWORD *pdwNameLen,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyPropertiesFrom( 
            /* [in] */ IWMPropertyVault *pIWMPropertyVault) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPropertyVaultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPropertyVault * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPropertyVault * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPropertyVault * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyCount )( 
            IWMPropertyVault * This,
            /* [in] */ DWORD *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyByName )( 
            IWMPropertyVault * This,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IWMPropertyVault * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE pType,
            /* [in] */ BYTE *pValue,
            /* [in] */ DWORD dwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyByIndex )( 
            IWMPropertyVault * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pszName,
            /* [out][in] */ DWORD *pdwNameLen,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPropertiesFrom )( 
            IWMPropertyVault * This,
            /* [in] */ IWMPropertyVault *pIWMPropertyVault);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IWMPropertyVault * This);
        
        END_INTERFACE
    } IWMPropertyVaultVtbl;

    interface IWMPropertyVault
    {
        CONST_VTBL struct IWMPropertyVaultVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPropertyVault_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPropertyVault_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPropertyVault_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPropertyVault_GetPropertyCount(This,pdwCount)	\
    (This)->lpVtbl -> GetPropertyCount(This,pdwCount)

#define IWMPropertyVault_GetPropertyByName(This,pszName,pType,pValue,pdwSize)	\
    (This)->lpVtbl -> GetPropertyByName(This,pszName,pType,pValue,pdwSize)

#define IWMPropertyVault_SetProperty(This,pszName,pType,pValue,dwSize)	\
    (This)->lpVtbl -> SetProperty(This,pszName,pType,pValue,dwSize)

#define IWMPropertyVault_GetPropertyByIndex(This,dwIndex,pszName,pdwNameLen,pType,pValue,pdwSize)	\
    (This)->lpVtbl -> GetPropertyByIndex(This,dwIndex,pszName,pdwNameLen,pType,pValue,pdwSize)

#define IWMPropertyVault_CopyPropertiesFrom(This,pIWMPropertyVault)	\
    (This)->lpVtbl -> CopyPropertiesFrom(This,pIWMPropertyVault)

#define IWMPropertyVault_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPropertyVault_GetPropertyCount_Proxy( 
    IWMPropertyVault * This,
    /* [in] */ DWORD *pdwCount);


void __RPC_STUB IWMPropertyVault_GetPropertyCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPropertyVault_GetPropertyByName_Proxy( 
    IWMPropertyVault * This,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE *pType,
    /* [out] */ BYTE *pValue,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IWMPropertyVault_GetPropertyByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPropertyVault_SetProperty_Proxy( 
    IWMPropertyVault * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE pType,
    /* [in] */ BYTE *pValue,
    /* [in] */ DWORD dwSize);


void __RPC_STUB IWMPropertyVault_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPropertyVault_GetPropertyByIndex_Proxy( 
    IWMPropertyVault * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ LPWSTR pszName,
    /* [out][in] */ DWORD *pdwNameLen,
    /* [out] */ WMT_ATTR_DATATYPE *pType,
    /* [out] */ BYTE *pValue,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IWMPropertyVault_GetPropertyByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPropertyVault_CopyPropertiesFrom_Proxy( 
    IWMPropertyVault * This,
    /* [in] */ IWMPropertyVault *pIWMPropertyVault);


void __RPC_STUB IWMPropertyVault_CopyPropertiesFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPropertyVault_Clear_Proxy( 
    IWMPropertyVault * This);


void __RPC_STUB IWMPropertyVault_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPropertyVault_INTERFACE_DEFINED__ */


#ifndef __IWMIStreamProps_INTERFACE_DEFINED__
#define __IWMIStreamProps_INTERFACE_DEFINED__

/* interface IWMIStreamProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMIStreamProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6816dad3-2b4b-4c8e-8149-874c3483a753")
    IWMIStreamProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMIStreamPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMIStreamProps * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMIStreamProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMIStreamProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IWMIStreamProps * This,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ DWORD *pdwSize);
        
        END_INTERFACE
    } IWMIStreamPropsVtbl;

    interface IWMIStreamProps
    {
        CONST_VTBL struct IWMIStreamPropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMIStreamProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMIStreamProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMIStreamProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMIStreamProps_GetProperty(This,pszName,pType,pValue,pdwSize)	\
    (This)->lpVtbl -> GetProperty(This,pszName,pType,pValue,pdwSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMIStreamProps_GetProperty_Proxy( 
    IWMIStreamProps * This,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE *pType,
    /* [out] */ BYTE *pValue,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IWMIStreamProps_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMIStreamProps_INTERFACE_DEFINED__ */


#ifndef __IWMReader_INTERFACE_DEFINED__
#define __IWMReader_INTERFACE_DEFINED__

/* interface IWMReader */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD6-2B2B-11d3-B36B-00C04F6108FF")
    IWMReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const WCHAR *pwszURL,
            /* [in] */ IWMReaderCallback *pCallback,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputCount( 
            /* [out] */ DWORD *pcOutputs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ IWMOutputMediaProps **ppOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps *pOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputFormatCount( 
            /* [in] */ DWORD dwOutputNumber,
            /* [out] */ DWORD *pcFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputFormat( 
            /* [in] */ DWORD dwOutputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMOutputMediaProps **ppProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IWMReader * This,
            /* [in] */ const WCHAR *pwszURL,
            /* [in] */ IWMReaderCallback *pCallback,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IWMReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputCount )( 
            IWMReader * This,
            /* [out] */ DWORD *pcOutputs);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputProps )( 
            IWMReader * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ IWMOutputMediaProps **ppOutput);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputProps )( 
            IWMReader * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps *pOutput);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputFormatCount )( 
            IWMReader * This,
            /* [in] */ DWORD dwOutputNumber,
            /* [out] */ DWORD *pcFormats);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputFormat )( 
            IWMReader * This,
            /* [in] */ DWORD dwOutputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMOutputMediaProps **ppProps);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IWMReader * This,
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IWMReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IWMReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IWMReader * This);
        
        END_INTERFACE
    } IWMReaderVtbl;

    interface IWMReader
    {
        CONST_VTBL struct IWMReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReader_Open(This,pwszURL,pCallback,pvContext)	\
    (This)->lpVtbl -> Open(This,pwszURL,pCallback,pvContext)

#define IWMReader_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMReader_GetOutputCount(This,pcOutputs)	\
    (This)->lpVtbl -> GetOutputCount(This,pcOutputs)

#define IWMReader_GetOutputProps(This,dwOutputNum,ppOutput)	\
    (This)->lpVtbl -> GetOutputProps(This,dwOutputNum,ppOutput)

#define IWMReader_SetOutputProps(This,dwOutputNum,pOutput)	\
    (This)->lpVtbl -> SetOutputProps(This,dwOutputNum,pOutput)

#define IWMReader_GetOutputFormatCount(This,dwOutputNumber,pcFormats)	\
    (This)->lpVtbl -> GetOutputFormatCount(This,dwOutputNumber,pcFormats)

#define IWMReader_GetOutputFormat(This,dwOutputNumber,dwFormatNumber,ppProps)	\
    (This)->lpVtbl -> GetOutputFormat(This,dwOutputNumber,dwFormatNumber,ppProps)

#define IWMReader_Start(This,cnsStart,cnsDuration,fRate,pvContext)	\
    (This)->lpVtbl -> Start(This,cnsStart,cnsDuration,fRate,pvContext)

#define IWMReader_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IWMReader_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IWMReader_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReader_Open_Proxy( 
    IWMReader * This,
    /* [in] */ const WCHAR *pwszURL,
    /* [in] */ IWMReaderCallback *pCallback,
    /* [in] */ void *pvContext);


void __RPC_STUB IWMReader_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Close_Proxy( 
    IWMReader * This);


void __RPC_STUB IWMReader_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_GetOutputCount_Proxy( 
    IWMReader * This,
    /* [out] */ DWORD *pcOutputs);


void __RPC_STUB IWMReader_GetOutputCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_GetOutputProps_Proxy( 
    IWMReader * This,
    /* [in] */ DWORD dwOutputNum,
    /* [out] */ IWMOutputMediaProps **ppOutput);


void __RPC_STUB IWMReader_GetOutputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_SetOutputProps_Proxy( 
    IWMReader * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ IWMOutputMediaProps *pOutput);


void __RPC_STUB IWMReader_SetOutputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_GetOutputFormatCount_Proxy( 
    IWMReader * This,
    /* [in] */ DWORD dwOutputNumber,
    /* [out] */ DWORD *pcFormats);


void __RPC_STUB IWMReader_GetOutputFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_GetOutputFormat_Proxy( 
    IWMReader * This,
    /* [in] */ DWORD dwOutputNumber,
    /* [in] */ DWORD dwFormatNumber,
    /* [out] */ IWMOutputMediaProps **ppProps);


void __RPC_STUB IWMReader_GetOutputFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Start_Proxy( 
    IWMReader * This,
    /* [in] */ QWORD cnsStart,
    /* [in] */ QWORD cnsDuration,
    /* [in] */ float fRate,
    /* [in] */ void *pvContext);


void __RPC_STUB IWMReader_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Stop_Proxy( 
    IWMReader * This);


void __RPC_STUB IWMReader_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Pause_Proxy( 
    IWMReader * This);


void __RPC_STUB IWMReader_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Resume_Proxy( 
    IWMReader * This);


void __RPC_STUB IWMReader_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReader_INTERFACE_DEFINED__ */


#ifndef __IWMSyncReader_INTERFACE_DEFINED__
#define __IWMSyncReader_INTERFACE_DEFINED__

/* interface IWMSyncReader */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMSyncReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9397F121-7705-4dc9-B049-98B698188414")
    IWMSyncReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const WCHAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRange( 
            /* [in] */ QWORD cnsStartTime,
            /* [in] */ LONGLONG cnsDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRangeByFrame( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD qwFrameNumber,
            /* [in] */ LONGLONG cFramesToRead) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextSample( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ INSSBuffer **ppSample,
            /* [out] */ QWORD *pcnsSampleTime,
            /* [out] */ QWORD *pcnsDuration,
            /* [out] */ DWORD *pdwFlags,
            /* [out] */ DWORD *pdwOutputNum,
            /* [out] */ WORD *pwStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamsSelected( 
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION *pSelections) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamSelected( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION *pSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReadStreamSamples( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fCompressed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReadStreamSamples( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL *pfCompressed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputSetting( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputSetting( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputCount( 
            /* [out] */ DWORD *pcOutputs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ IWMOutputMediaProps **ppOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps *pOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputFormatCount( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ DWORD *pcFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputFormat( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD dwFormatNum,
            /* [out] */ IWMOutputMediaProps **ppProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputNumberForStream( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ DWORD *pdwOutputNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamNumberForOutput( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ WORD *pwStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxOutputSampleSize( 
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD *pcbMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxStreamSampleSize( 
            /* [in] */ WORD wStream,
            /* [out] */ DWORD *pcbMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenStream( 
            /* [in] */ IStream *pStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSyncReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSyncReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSyncReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSyncReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IWMSyncReader * This,
            /* [in] */ const WCHAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IWMSyncReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRange )( 
            IWMSyncReader * This,
            /* [in] */ QWORD cnsStartTime,
            /* [in] */ LONGLONG cnsDuration);
        
        HRESULT ( STDMETHODCALLTYPE *SetRangeByFrame )( 
            IWMSyncReader * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD qwFrameNumber,
            /* [in] */ LONGLONG cFramesToRead);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextSample )( 
            IWMSyncReader * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ INSSBuffer **ppSample,
            /* [out] */ QWORD *pcnsSampleTime,
            /* [out] */ QWORD *pcnsDuration,
            /* [out] */ DWORD *pdwFlags,
            /* [out] */ DWORD *pdwOutputNum,
            /* [out] */ WORD *pwStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamsSelected )( 
            IWMSyncReader * This,
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION *pSelections);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamSelected )( 
            IWMSyncReader * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE *SetReadStreamSamples )( 
            IWMSyncReader * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fCompressed);
        
        HRESULT ( STDMETHODCALLTYPE *GetReadStreamSamples )( 
            IWMSyncReader * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL *pfCompressed);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputSetting )( 
            IWMSyncReader * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputSetting )( 
            IWMSyncReader * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputCount )( 
            IWMSyncReader * This,
            /* [out] */ DWORD *pcOutputs);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputProps )( 
            IWMSyncReader * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ IWMOutputMediaProps **ppOutput);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputProps )( 
            IWMSyncReader * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps *pOutput);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputFormatCount )( 
            IWMSyncReader * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ DWORD *pcFormats);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputFormat )( 
            IWMSyncReader * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD dwFormatNum,
            /* [out] */ IWMOutputMediaProps **ppProps);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputNumberForStream )( 
            IWMSyncReader * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ DWORD *pdwOutputNum);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamNumberForOutput )( 
            IWMSyncReader * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ WORD *pwStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxOutputSampleSize )( 
            IWMSyncReader * This,
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxStreamSampleSize )( 
            IWMSyncReader * This,
            /* [in] */ WORD wStream,
            /* [out] */ DWORD *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE *OpenStream )( 
            IWMSyncReader * This,
            /* [in] */ IStream *pStream);
        
        END_INTERFACE
    } IWMSyncReaderVtbl;

    interface IWMSyncReader
    {
        CONST_VTBL struct IWMSyncReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSyncReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSyncReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSyncReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSyncReader_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)

#define IWMSyncReader_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMSyncReader_SetRange(This,cnsStartTime,cnsDuration)	\
    (This)->lpVtbl -> SetRange(This,cnsStartTime,cnsDuration)

#define IWMSyncReader_SetRangeByFrame(This,wStreamNum,qwFrameNumber,cFramesToRead)	\
    (This)->lpVtbl -> SetRangeByFrame(This,wStreamNum,qwFrameNumber,cFramesToRead)

#define IWMSyncReader_GetNextSample(This,wStreamNum,ppSample,pcnsSampleTime,pcnsDuration,pdwFlags,pdwOutputNum,pwStreamNum)	\
    (This)->lpVtbl -> GetNextSample(This,wStreamNum,ppSample,pcnsSampleTime,pcnsDuration,pdwFlags,pdwOutputNum,pwStreamNum)

#define IWMSyncReader_SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)	\
    (This)->lpVtbl -> SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)

#define IWMSyncReader_GetStreamSelected(This,wStreamNum,pSelection)	\
    (This)->lpVtbl -> GetStreamSelected(This,wStreamNum,pSelection)

#define IWMSyncReader_SetReadStreamSamples(This,wStreamNum,fCompressed)	\
    (This)->lpVtbl -> SetReadStreamSamples(This,wStreamNum,fCompressed)

#define IWMSyncReader_GetReadStreamSamples(This,wStreamNum,pfCompressed)	\
    (This)->lpVtbl -> GetReadStreamSamples(This,wStreamNum,pfCompressed)

#define IWMSyncReader_GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)

#define IWMSyncReader_SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)

#define IWMSyncReader_GetOutputCount(This,pcOutputs)	\
    (This)->lpVtbl -> GetOutputCount(This,pcOutputs)

#define IWMSyncReader_GetOutputProps(This,dwOutputNum,ppOutput)	\
    (This)->lpVtbl -> GetOutputProps(This,dwOutputNum,ppOutput)

#define IWMSyncReader_SetOutputProps(This,dwOutputNum,pOutput)	\
    (This)->lpVtbl -> SetOutputProps(This,dwOutputNum,pOutput)

#define IWMSyncReader_GetOutputFormatCount(This,dwOutputNum,pcFormats)	\
    (This)->lpVtbl -> GetOutputFormatCount(This,dwOutputNum,pcFormats)

#define IWMSyncReader_GetOutputFormat(This,dwOutputNum,dwFormatNum,ppProps)	\
    (This)->lpVtbl -> GetOutputFormat(This,dwOutputNum,dwFormatNum,ppProps)

#define IWMSyncReader_GetOutputNumberForStream(This,wStreamNum,pdwOutputNum)	\
    (This)->lpVtbl -> GetOutputNumberForStream(This,wStreamNum,pdwOutputNum)

#define IWMSyncReader_GetStreamNumberForOutput(This,dwOutputNum,pwStreamNum)	\
    (This)->lpVtbl -> GetStreamNumberForOutput(This,dwOutputNum,pwStreamNum)

#define IWMSyncReader_GetMaxOutputSampleSize(This,dwOutput,pcbMax)	\
    (This)->lpVtbl -> GetMaxOutputSampleSize(This,dwOutput,pcbMax)

#define IWMSyncReader_GetMaxStreamSampleSize(This,wStream,pcbMax)	\
    (This)->lpVtbl -> GetMaxStreamSampleSize(This,wStream,pcbMax)

#define IWMSyncReader_OpenStream(This,pStream)	\
    (This)->lpVtbl -> OpenStream(This,pStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMSyncReader_Open_Proxy( 
    IWMSyncReader * This,
    /* [in] */ const WCHAR *pwszFilename);


void __RPC_STUB IWMSyncReader_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_Close_Proxy( 
    IWMSyncReader * This);


void __RPC_STUB IWMSyncReader_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_SetRange_Proxy( 
    IWMSyncReader * This,
    /* [in] */ QWORD cnsStartTime,
    /* [in] */ LONGLONG cnsDuration);


void __RPC_STUB IWMSyncReader_SetRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_SetRangeByFrame_Proxy( 
    IWMSyncReader * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ QWORD qwFrameNumber,
    /* [in] */ LONGLONG cFramesToRead);


void __RPC_STUB IWMSyncReader_SetRangeByFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_GetNextSample_Proxy( 
    IWMSyncReader * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ INSSBuffer **ppSample,
    /* [out] */ QWORD *pcnsSampleTime,
    /* [out] */ QWORD *pcnsDuration,
    /* [out] */ DWORD *pdwFlags,
    /* [out] */ DWORD *pdwOutputNum,
    /* [out] */ WORD *pwStreamNum);


void __RPC_STUB IWMSyncReader_GetNextSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_SetStreamsSelected_Proxy( 
    IWMSyncReader * This,
    /* [in] */ WORD cStreamCount,
    /* [in] */ WORD *pwStreamNumbers,
    /* [in] */ WMT_STREAM_SELECTION *pSelections);


void __RPC_STUB IWMSyncReader_SetStreamsSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_GetStreamSelected_Proxy( 
    IWMSyncReader * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ WMT_STREAM_SELECTION *pSelection);


void __RPC_STUB IWMSyncReader_GetStreamSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_SetReadStreamSamples_Proxy( 
    IWMSyncReader * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ BOOL fCompressed);


void __RPC_STUB IWMSyncReader_SetReadStreamSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_GetReadStreamSamples_Proxy( 
    IWMSyncReader * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ BOOL *pfCompressed);


void __RPC_STUB IWMSyncReader_GetReadStreamSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_GetOutputSetting_Proxy( 
    IWMSyncReader * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE *pType,
    /* [out] */ BYTE *pValue,
    /* [out][in] */ WORD *pcbLength);


void __RPC_STUB IWMSyncReader_GetOutputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_SetOutputSetting_Proxy( 
    IWMSyncReader * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMSyncReader_SetOutputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_GetOutputCount_Proxy( 
    IWMSyncReader * This,
    /* [out] */ DWORD *pcOutputs);


void __RPC_STUB IWMSyncReader_GetOutputCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_GetOutputProps_Proxy( 
    IWMSyncReader * This,
    /* [in] */ DWORD dwOutputNum,
    /* [out] */ IWMOutputMediaProps **ppOutput);


void __RPC_STUB IWMSyncReader_GetOutputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_SetOutputProps_Proxy( 
    IWMSyncReader * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ IWMOutputMediaProps *pOutput);


void __RPC_STUB IWMSyncReader_SetOutputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_GetOutputFormatCount_Proxy( 
    IWMSyncReader * This,
    /* [in] */ DWORD dwOutputNum,
    /* [out] */ DWORD *pcFormats);


void __RPC_STUB IWMSyncReader_GetOutputFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_GetOutputFormat_Proxy( 
    IWMSyncReader * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ DWORD dwFormatNum,
    /* [out] */ IWMOutputMediaProps **ppProps);


void __RPC_STUB IWMSyncReader_GetOutputFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_GetOutputNumberForStream_Proxy( 
    IWMSyncReader * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ DWORD *pdwOutputNum);


void __RPC_STUB IWMSyncReader_GetOutputNumberForStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_GetStreamNumberForOutput_Proxy( 
    IWMSyncReader * This,
    /* [in] */ DWORD dwOutputNum,
    /* [out] */ WORD *pwStreamNum);


void __RPC_STUB IWMSyncReader_GetStreamNumberForOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_GetMaxOutputSampleSize_Proxy( 
    IWMSyncReader * This,
    /* [in] */ DWORD dwOutput,
    /* [out] */ DWORD *pcbMax);


void __RPC_STUB IWMSyncReader_GetMaxOutputSampleSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_GetMaxStreamSampleSize_Proxy( 
    IWMSyncReader * This,
    /* [in] */ WORD wStream,
    /* [out] */ DWORD *pcbMax);


void __RPC_STUB IWMSyncReader_GetMaxStreamSampleSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_OpenStream_Proxy( 
    IWMSyncReader * This,
    /* [in] */ IStream *pStream);


void __RPC_STUB IWMSyncReader_OpenStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSyncReader_INTERFACE_DEFINED__ */


#ifndef __IWMOutputMediaProps_INTERFACE_DEFINED__
#define __IWMOutputMediaProps_INTERFACE_DEFINED__

/* interface IWMOutputMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMOutputMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD7-2B2B-11d3-B36B-00C04F6108FF")
    IWMOutputMediaProps : public IWMMediaProps
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamGroupName( 
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionName( 
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMOutputMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMOutputMediaProps * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMOutputMediaProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMOutputMediaProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IWMOutputMediaProps * This,
            /* [out] */ GUID *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IWMOutputMediaProps * This,
            /* [out] */ WM_MEDIA_TYPE *pType,
            /* [out][in] */ DWORD *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IWMOutputMediaProps * This,
            /* [in] */ WM_MEDIA_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamGroupName )( 
            IWMOutputMediaProps * This,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionName )( 
            IWMOutputMediaProps * This,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchName);
        
        END_INTERFACE
    } IWMOutputMediaPropsVtbl;

    interface IWMOutputMediaProps
    {
        CONST_VTBL struct IWMOutputMediaPropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMOutputMediaProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMOutputMediaProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMOutputMediaProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMOutputMediaProps_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMOutputMediaProps_GetMediaType(This,pType,pcbType)	\
    (This)->lpVtbl -> GetMediaType(This,pType,pcbType)

#define IWMOutputMediaProps_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)


#define IWMOutputMediaProps_GetStreamGroupName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetStreamGroupName(This,pwszName,pcchName)

#define IWMOutputMediaProps_GetConnectionName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetConnectionName(This,pwszName,pcchName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMOutputMediaProps_GetStreamGroupName_Proxy( 
    IWMOutputMediaProps * This,
    /* [out] */ WCHAR *pwszName,
    /* [out][in] */ WORD *pcchName);


void __RPC_STUB IWMOutputMediaProps_GetStreamGroupName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMOutputMediaProps_GetConnectionName_Proxy( 
    IWMOutputMediaProps * This,
    /* [out] */ WCHAR *pwszName,
    /* [out][in] */ WORD *pcchName);


void __RPC_STUB IWMOutputMediaProps_GetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMOutputMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMStatusCallback_INTERFACE_DEFINED__
#define __IWMStatusCallback_INTERFACE_DEFINED__

/* interface IWMStatusCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStatusCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d7cdc70-9888-11d3-8edc-00c04f6109cf")
    IWMStatusCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStatus( 
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE *pValue,
            /* [in] */ void *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStatusCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMStatusCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMStatusCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMStatusCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStatus )( 
            IWMStatusCallback * This,
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE *pValue,
            /* [in] */ void *pvContext);
        
        END_INTERFACE
    } IWMStatusCallbackVtbl;

    interface IWMStatusCallback
    {
        CONST_VTBL struct IWMStatusCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStatusCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMStatusCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMStatusCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMStatusCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMStatusCallback_OnStatus_Proxy( 
    IWMStatusCallback * This,
    /* [in] */ WMT_STATUS Status,
    /* [in] */ HRESULT hr,
    /* [in] */ WMT_ATTR_DATATYPE dwType,
    /* [in] */ BYTE *pValue,
    /* [in] */ void *pvContext);


void __RPC_STUB IWMStatusCallback_OnStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMStatusCallback_INTERFACE_DEFINED__ */


#ifndef __IWMReaderCallback_INTERFACE_DEFINED__
#define __IWMReaderCallback_INTERFACE_DEFINED__

/* interface IWMReaderCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD8-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderCallback : public IWMStatusCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSample( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample,
            /* [in] */ void *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMReaderCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMReaderCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMReaderCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStatus )( 
            IWMReaderCallback * This,
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE *pValue,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *OnSample )( 
            IWMReaderCallback * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample,
            /* [in] */ void *pvContext);
        
        END_INTERFACE
    } IWMReaderCallbackVtbl;

    interface IWMReaderCallback
    {
        CONST_VTBL struct IWMReaderCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext)


#define IWMReaderCallback_OnSample(This,dwOutputNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)	\
    (This)->lpVtbl -> OnSample(This,dwOutputNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderCallback_OnSample_Proxy( 
    IWMReaderCallback * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer *pSample,
    /* [in] */ void *pvContext);


void __RPC_STUB IWMReaderCallback_OnSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderCallback_INTERFACE_DEFINED__ */


#ifndef __IWMCredentialCallback_INTERFACE_DEFINED__
#define __IWMCredentialCallback_INTERFACE_DEFINED__

/* interface IWMCredentialCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCredentialCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("342e0eb7-e651-450c-975b-2ace2c90c48e")
    IWMCredentialCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AcquireCredentials( 
            /* [in] */ WCHAR *pwszRealm,
            /* [in] */ WCHAR *pwszSite,
            /* [size_is][out][in] */ WCHAR *pwszUser,
            /* [in] */ DWORD cchUser,
            /* [size_is][out][in] */ WCHAR *pwszPassword,
            /* [in] */ DWORD cchPassword,
            /* [in] */ HRESULT hrStatus,
            /* [out][in] */ DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCredentialCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMCredentialCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMCredentialCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMCredentialCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *AcquireCredentials )( 
            IWMCredentialCallback * This,
            /* [in] */ WCHAR *pwszRealm,
            /* [in] */ WCHAR *pwszSite,
            /* [size_is][out][in] */ WCHAR *pwszUser,
            /* [in] */ DWORD cchUser,
            /* [size_is][out][in] */ WCHAR *pwszPassword,
            /* [in] */ DWORD cchPassword,
            /* [in] */ HRESULT hrStatus,
            /* [out][in] */ DWORD *pdwFlags);
        
        END_INTERFACE
    } IWMCredentialCallbackVtbl;

    interface IWMCredentialCallback
    {
        CONST_VTBL struct IWMCredentialCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCredentialCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMCredentialCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMCredentialCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMCredentialCallback_AcquireCredentials(This,pwszRealm,pwszSite,pwszUser,cchUser,pwszPassword,cchPassword,hrStatus,pdwFlags)	\
    (This)->lpVtbl -> AcquireCredentials(This,pwszRealm,pwszSite,pwszUser,cchUser,pwszPassword,cchPassword,hrStatus,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMCredentialCallback_AcquireCredentials_Proxy( 
    IWMCredentialCallback * This,
    /* [in] */ WCHAR *pwszRealm,
    /* [in] */ WCHAR *pwszSite,
    /* [size_is][out][in] */ WCHAR *pwszUser,
    /* [in] */ DWORD cchUser,
    /* [size_is][out][in] */ WCHAR *pwszPassword,
    /* [in] */ DWORD cchPassword,
    /* [in] */ HRESULT hrStatus,
    /* [out][in] */ DWORD *pdwFlags);


void __RPC_STUB IWMCredentialCallback_AcquireCredentials_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMCredentialCallback_INTERFACE_DEFINED__ */


#ifndef __IWMMetadataEditor_INTERFACE_DEFINED__
#define __IWMMetadataEditor_INTERFACE_DEFINED__

/* interface IWMMetadataEditor */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMetadataEditor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD9-2B2B-11d3-B36B-00C04F6108FF")
    IWMMetadataEditor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const WCHAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMetadataEditorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMMetadataEditor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMMetadataEditor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMMetadataEditor * This);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IWMMetadataEditor * This,
            /* [in] */ const WCHAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IWMMetadataEditor * This);
        
        HRESULT ( STDMETHODCALLTYPE *Flush )( 
            IWMMetadataEditor * This);
        
        END_INTERFACE
    } IWMMetadataEditorVtbl;

    interface IWMMetadataEditor
    {
        CONST_VTBL struct IWMMetadataEditorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMetadataEditor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMMetadataEditor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMMetadataEditor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMMetadataEditor_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)

#define IWMMetadataEditor_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMMetadataEditor_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMMetadataEditor_Open_Proxy( 
    IWMMetadataEditor * This,
    /* [in] */ const WCHAR *pwszFilename);


void __RPC_STUB IWMMetadataEditor_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMetadataEditor_Close_Proxy( 
    IWMMetadataEditor * This);


void __RPC_STUB IWMMetadataEditor_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMetadataEditor_Flush_Proxy( 
    IWMMetadataEditor * This);


void __RPC_STUB IWMMetadataEditor_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMMetadataEditor_INTERFACE_DEFINED__ */


#ifndef __IWMMetadataEditor2_INTERFACE_DEFINED__
#define __IWMMetadataEditor2_INTERFACE_DEFINED__

/* interface IWMMetadataEditor2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMetadataEditor2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("203CFFE3-2E18-4fdf-B59D-6E71530534CF")
    IWMMetadataEditor2 : public IWMMetadataEditor
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenEx( 
            /* [in] */ const WCHAR *pwszFilename,
            /* [in] */ DWORD dwDesiredAccess,
            /* [in] */ DWORD dwShareMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMetadataEditor2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMMetadataEditor2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMMetadataEditor2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMMetadataEditor2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IWMMetadataEditor2 * This,
            /* [in] */ const WCHAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IWMMetadataEditor2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Flush )( 
            IWMMetadataEditor2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenEx )( 
            IWMMetadataEditor2 * This,
            /* [in] */ const WCHAR *pwszFilename,
            /* [in] */ DWORD dwDesiredAccess,
            /* [in] */ DWORD dwShareMode);
        
        END_INTERFACE
    } IWMMetadataEditor2Vtbl;

    interface IWMMetadataEditor2
    {
        CONST_VTBL struct IWMMetadataEditor2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMetadataEditor2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMMetadataEditor2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMMetadataEditor2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMMetadataEditor2_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)

#define IWMMetadataEditor2_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMMetadataEditor2_Flush(This)	\
    (This)->lpVtbl -> Flush(This)


#define IWMMetadataEditor2_OpenEx(This,pwszFilename,dwDesiredAccess,dwShareMode)	\
    (This)->lpVtbl -> OpenEx(This,pwszFilename,dwDesiredAccess,dwShareMode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMMetadataEditor2_OpenEx_Proxy( 
    IWMMetadataEditor2 * This,
    /* [in] */ const WCHAR *pwszFilename,
    /* [in] */ DWORD dwDesiredAccess,
    /* [in] */ DWORD dwShareMode);


void __RPC_STUB IWMMetadataEditor2_OpenEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMMetadataEditor2_INTERFACE_DEFINED__ */


#ifndef __IWMHeaderInfo_INTERFACE_DEFINED__
#define __IWMHeaderInfo_INTERFACE_DEFINED__

/* interface IWMHeaderInfo */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMHeaderInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDA-2B2B-11d3-B36B-00C04F6108FF")
    IWMHeaderInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAttributeCount( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD *pcAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeByIndex( 
            /* [in] */ WORD wIndex,
            /* [out][in] */ WORD *pwStreamNum,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeByName( 
            /* [out][in] */ WORD *pwStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAttribute( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMarkerCount( 
            /* [out] */ WORD *pcMarkers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMarker( 
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR *pwszMarkerName,
            /* [out][in] */ WORD *pcchMarkerNameLen,
            /* [out] */ QWORD *pcnsMarkerTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMarker( 
            /* [in] */ WCHAR *pwszMarkerName,
            /* [in] */ QWORD cnsMarkerTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveMarker( 
            /* [in] */ WORD wIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptCount( 
            /* [out] */ WORD *pcScripts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScript( 
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR *pwszType,
            /* [out][in] */ WORD *pcchTypeLen,
            /* [out] */ WCHAR *pwszCommand,
            /* [out][in] */ WORD *pcchCommandLen,
            /* [out] */ QWORD *pcnsScriptTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddScript( 
            /* [in] */ WCHAR *pwszType,
            /* [in] */ WCHAR *pwszCommand,
            /* [in] */ QWORD cnsScriptTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveScript( 
            /* [in] */ WORD wIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMHeaderInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMHeaderInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMHeaderInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMHeaderInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeCount )( 
            IWMHeaderInfo * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD *pcAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeByIndex )( 
            IWMHeaderInfo * This,
            /* [in] */ WORD wIndex,
            /* [out][in] */ WORD *pwStreamNum,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeByName )( 
            IWMHeaderInfo * This,
            /* [out][in] */ WORD *pwStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetAttribute )( 
            IWMHeaderInfo * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetMarkerCount )( 
            IWMHeaderInfo * This,
            /* [out] */ WORD *pcMarkers);
        
        HRESULT ( STDMETHODCALLTYPE *GetMarker )( 
            IWMHeaderInfo * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR *pwszMarkerName,
            /* [out][in] */ WORD *pcchMarkerNameLen,
            /* [out] */ QWORD *pcnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE *AddMarker )( 
            IWMHeaderInfo * This,
            /* [in] */ WCHAR *pwszMarkerName,
            /* [in] */ QWORD cnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveMarker )( 
            IWMHeaderInfo * This,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptCount )( 
            IWMHeaderInfo * This,
            /* [out] */ WORD *pcScripts);
        
        HRESULT ( STDMETHODCALLTYPE *GetScript )( 
            IWMHeaderInfo * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR *pwszType,
            /* [out][in] */ WORD *pcchTypeLen,
            /* [out] */ WCHAR *pwszCommand,
            /* [out][in] */ WORD *pcchCommandLen,
            /* [out] */ QWORD *pcnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE *AddScript )( 
            IWMHeaderInfo * This,
            /* [in] */ WCHAR *pwszType,
            /* [in] */ WCHAR *pwszCommand,
            /* [in] */ QWORD cnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveScript )( 
            IWMHeaderInfo * This,
            /* [in] */ WORD wIndex);
        
        END_INTERFACE
    } IWMHeaderInfoVtbl;

    interface IWMHeaderInfo
    {
        CONST_VTBL struct IWMHeaderInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMHeaderInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMHeaderInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMHeaderInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMHeaderInfo_GetAttributeCount(This,wStreamNum,pcAttributes)	\
    (This)->lpVtbl -> GetAttributeCount(This,wStreamNum,pcAttributes)

#define IWMHeaderInfo_GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)

#define IWMHeaderInfo_GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)

#define IWMHeaderInfo_SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)

#define IWMHeaderInfo_GetMarkerCount(This,pcMarkers)	\
    (This)->lpVtbl -> GetMarkerCount(This,pcMarkers)

#define IWMHeaderInfo_GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)	\
    (This)->lpVtbl -> GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)

#define IWMHeaderInfo_AddMarker(This,pwszMarkerName,cnsMarkerTime)	\
    (This)->lpVtbl -> AddMarker(This,pwszMarkerName,cnsMarkerTime)

#define IWMHeaderInfo_RemoveMarker(This,wIndex)	\
    (This)->lpVtbl -> RemoveMarker(This,wIndex)

#define IWMHeaderInfo_GetScriptCount(This,pcScripts)	\
    (This)->lpVtbl -> GetScriptCount(This,pcScripts)

#define IWMHeaderInfo_GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)	\
    (This)->lpVtbl -> GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)

#define IWMHeaderInfo_AddScript(This,pwszType,pwszCommand,cnsScriptTime)	\
    (This)->lpVtbl -> AddScript(This,pwszType,pwszCommand,cnsScriptTime)

#define IWMHeaderInfo_RemoveScript(This,wIndex)	\
    (This)->lpVtbl -> RemoveScript(This,wIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetAttributeCount_Proxy( 
    IWMHeaderInfo * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ WORD *pcAttributes);


void __RPC_STUB IWMHeaderInfo_GetAttributeCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetAttributeByIndex_Proxy( 
    IWMHeaderInfo * This,
    /* [in] */ WORD wIndex,
    /* [out][in] */ WORD *pwStreamNum,
    /* [out] */ WCHAR *pwszName,
    /* [out][in] */ WORD *pcchNameLen,
    /* [out] */ WMT_ATTR_DATATYPE *pType,
    /* [out] */ BYTE *pValue,
    /* [out][in] */ WORD *pcbLength);


void __RPC_STUB IWMHeaderInfo_GetAttributeByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetAttributeByName_Proxy( 
    IWMHeaderInfo * This,
    /* [out][in] */ WORD *pwStreamNum,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE *pType,
    /* [out] */ BYTE *pValue,
    /* [out][in] */ WORD *pcbLength);


void __RPC_STUB IWMHeaderInfo_GetAttributeByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_SetAttribute_Proxy( 
    IWMHeaderInfo * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMHeaderInfo_SetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetMarkerCount_Proxy( 
    IWMHeaderInfo * This,
    /* [out] */ WORD *pcMarkers);


void __RPC_STUB IWMHeaderInfo_GetMarkerCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetMarker_Proxy( 
    IWMHeaderInfo * This,
    /* [in] */ WORD wIndex,
    /* [out] */ WCHAR *pwszMarkerName,
    /* [out][in] */ WORD *pcchMarkerNameLen,
    /* [out] */ QWORD *pcnsMarkerTime);


void __RPC_STUB IWMHeaderInfo_GetMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_AddMarker_Proxy( 
    IWMHeaderInfo * This,
    /* [in] */ WCHAR *pwszMarkerName,
    /* [in] */ QWORD cnsMarkerTime);


void __RPC_STUB IWMHeaderInfo_AddMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_RemoveMarker_Proxy( 
    IWMHeaderInfo * This,
    /* [in] */ WORD wIndex);


void __RPC_STUB IWMHeaderInfo_RemoveMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetScriptCount_Proxy( 
    IWMHeaderInfo * This,
    /* [out] */ WORD *pcScripts);


void __RPC_STUB IWMHeaderInfo_GetScriptCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetScript_Proxy( 
    IWMHeaderInfo * This,
    /* [in] */ WORD wIndex,
    /* [out] */ WCHAR *pwszType,
    /* [out][in] */ WORD *pcchTypeLen,
    /* [out] */ WCHAR *pwszCommand,
    /* [out][in] */ WORD *pcchCommandLen,
    /* [out] */ QWORD *pcnsScriptTime);


void __RPC_STUB IWMHeaderInfo_GetScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_AddScript_Proxy( 
    IWMHeaderInfo * This,
    /* [in] */ WCHAR *pwszType,
    /* [in] */ WCHAR *pwszCommand,
    /* [in] */ QWORD cnsScriptTime);


void __RPC_STUB IWMHeaderInfo_AddScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_RemoveScript_Proxy( 
    IWMHeaderInfo * This,
    /* [in] */ WORD wIndex);


void __RPC_STUB IWMHeaderInfo_RemoveScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMHeaderInfo_INTERFACE_DEFINED__ */


#ifndef __IWMHeaderInfo2_INTERFACE_DEFINED__
#define __IWMHeaderInfo2_INTERFACE_DEFINED__

/* interface IWMHeaderInfo2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMHeaderInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("15CF9781-454E-482e-B393-85FAE487A810")
    IWMHeaderInfo2 : public IWMHeaderInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodecInfoCount( 
            /* [out] */ DWORD *pcCodecInfos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecInfo( 
            /* [in] */ DWORD wIndex,
            /* [out][in] */ WORD *pcchName,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchDescription,
            /* [out] */ WCHAR *pwszDescription,
            /* [out] */ WMT_CODEC_INFO_TYPE *pCodecType,
            /* [out][in] */ WORD *pcbCodecInfo,
            /* [out] */ BYTE *pbCodecInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMHeaderInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMHeaderInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMHeaderInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMHeaderInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeCount )( 
            IWMHeaderInfo2 * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD *pcAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeByIndex )( 
            IWMHeaderInfo2 * This,
            /* [in] */ WORD wIndex,
            /* [out][in] */ WORD *pwStreamNum,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeByName )( 
            IWMHeaderInfo2 * This,
            /* [out][in] */ WORD *pwStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetAttribute )( 
            IWMHeaderInfo2 * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetMarkerCount )( 
            IWMHeaderInfo2 * This,
            /* [out] */ WORD *pcMarkers);
        
        HRESULT ( STDMETHODCALLTYPE *GetMarker )( 
            IWMHeaderInfo2 * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR *pwszMarkerName,
            /* [out][in] */ WORD *pcchMarkerNameLen,
            /* [out] */ QWORD *pcnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE *AddMarker )( 
            IWMHeaderInfo2 * This,
            /* [in] */ WCHAR *pwszMarkerName,
            /* [in] */ QWORD cnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveMarker )( 
            IWMHeaderInfo2 * This,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptCount )( 
            IWMHeaderInfo2 * This,
            /* [out] */ WORD *pcScripts);
        
        HRESULT ( STDMETHODCALLTYPE *GetScript )( 
            IWMHeaderInfo2 * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR *pwszType,
            /* [out][in] */ WORD *pcchTypeLen,
            /* [out] */ WCHAR *pwszCommand,
            /* [out][in] */ WORD *pcchCommandLen,
            /* [out] */ QWORD *pcnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE *AddScript )( 
            IWMHeaderInfo2 * This,
            /* [in] */ WCHAR *pwszType,
            /* [in] */ WCHAR *pwszCommand,
            /* [in] */ QWORD cnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveScript )( 
            IWMHeaderInfo2 * This,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecInfoCount )( 
            IWMHeaderInfo2 * This,
            /* [out] */ DWORD *pcCodecInfos);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecInfo )( 
            IWMHeaderInfo2 * This,
            /* [in] */ DWORD wIndex,
            /* [out][in] */ WORD *pcchName,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchDescription,
            /* [out] */ WCHAR *pwszDescription,
            /* [out] */ WMT_CODEC_INFO_TYPE *pCodecType,
            /* [out][in] */ WORD *pcbCodecInfo,
            /* [out] */ BYTE *pbCodecInfo);
        
        END_INTERFACE
    } IWMHeaderInfo2Vtbl;

    interface IWMHeaderInfo2
    {
        CONST_VTBL struct IWMHeaderInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMHeaderInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMHeaderInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMHeaderInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMHeaderInfo2_GetAttributeCount(This,wStreamNum,pcAttributes)	\
    (This)->lpVtbl -> GetAttributeCount(This,wStreamNum,pcAttributes)

#define IWMHeaderInfo2_GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)

#define IWMHeaderInfo2_GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)

#define IWMHeaderInfo2_SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)

#define IWMHeaderInfo2_GetMarkerCount(This,pcMarkers)	\
    (This)->lpVtbl -> GetMarkerCount(This,pcMarkers)

#define IWMHeaderInfo2_GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)	\
    (This)->lpVtbl -> GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)

#define IWMHeaderInfo2_AddMarker(This,pwszMarkerName,cnsMarkerTime)	\
    (This)->lpVtbl -> AddMarker(This,pwszMarkerName,cnsMarkerTime)

#define IWMHeaderInfo2_RemoveMarker(This,wIndex)	\
    (This)->lpVtbl -> RemoveMarker(This,wIndex)

#define IWMHeaderInfo2_GetScriptCount(This,pcScripts)	\
    (This)->lpVtbl -> GetScriptCount(This,pcScripts)

#define IWMHeaderInfo2_GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)	\
    (This)->lpVtbl -> GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)

#define IWMHeaderInfo2_AddScript(This,pwszType,pwszCommand,cnsScriptTime)	\
    (This)->lpVtbl -> AddScript(This,pwszType,pwszCommand,cnsScriptTime)

#define IWMHeaderInfo2_RemoveScript(This,wIndex)	\
    (This)->lpVtbl -> RemoveScript(This,wIndex)


#define IWMHeaderInfo2_GetCodecInfoCount(This,pcCodecInfos)	\
    (This)->lpVtbl -> GetCodecInfoCount(This,pcCodecInfos)

#define IWMHeaderInfo2_GetCodecInfo(This,wIndex,pcchName,pwszName,pcchDescription,pwszDescription,pCodecType,pcbCodecInfo,pbCodecInfo)	\
    (This)->lpVtbl -> GetCodecInfo(This,wIndex,pcchName,pwszName,pcchDescription,pwszDescription,pCodecType,pcbCodecInfo,pbCodecInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMHeaderInfo2_GetCodecInfoCount_Proxy( 
    IWMHeaderInfo2 * This,
    /* [out] */ DWORD *pcCodecInfos);


void __RPC_STUB IWMHeaderInfo2_GetCodecInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo2_GetCodecInfo_Proxy( 
    IWMHeaderInfo2 * This,
    /* [in] */ DWORD wIndex,
    /* [out][in] */ WORD *pcchName,
    /* [out] */ WCHAR *pwszName,
    /* [out][in] */ WORD *pcchDescription,
    /* [out] */ WCHAR *pwszDescription,
    /* [out] */ WMT_CODEC_INFO_TYPE *pCodecType,
    /* [out][in] */ WORD *pcbCodecInfo,
    /* [out] */ BYTE *pbCodecInfo);


void __RPC_STUB IWMHeaderInfo2_GetCodecInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMHeaderInfo2_INTERFACE_DEFINED__ */


#ifndef __IWMProfileManager_INTERFACE_DEFINED__
#define __IWMProfileManager_INTERFACE_DEFINED__

/* interface IWMProfileManager */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfileManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d16679f2-6ca0-472d-8d31-2f5d55aee155")
    IWMProfileManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateEmptyProfile( 
            /* [in] */ WMT_VERSION dwVersion,
            /* [out] */ IWMProfile **ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadProfileByID( 
            /* [in] */ REFGUID guidProfile,
            /* [out] */ IWMProfile **ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadProfileByData( 
            /* [in] */ const WCHAR *pwszProfile,
            /* [out] */ IWMProfile **ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveProfile( 
            /* [in] */ IWMProfile *pIWMProfile,
            /* [in] */ WCHAR *pwszProfile,
            /* [out][in] */ DWORD *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSystemProfileCount( 
            /* [out] */ DWORD *pcProfiles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadSystemProfile( 
            /* [in] */ DWORD dwProfileIndex,
            /* [out] */ IWMProfile **ppProfile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfileManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMProfileManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMProfileManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMProfileManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateEmptyProfile )( 
            IWMProfileManager * This,
            /* [in] */ WMT_VERSION dwVersion,
            /* [out] */ IWMProfile **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *LoadProfileByID )( 
            IWMProfileManager * This,
            /* [in] */ REFGUID guidProfile,
            /* [out] */ IWMProfile **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *LoadProfileByData )( 
            IWMProfileManager * This,
            /* [in] */ const WCHAR *pwszProfile,
            /* [out] */ IWMProfile **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SaveProfile )( 
            IWMProfileManager * This,
            /* [in] */ IWMProfile *pIWMProfile,
            /* [in] */ WCHAR *pwszProfile,
            /* [out][in] */ DWORD *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetSystemProfileCount )( 
            IWMProfileManager * This,
            /* [out] */ DWORD *pcProfiles);
        
        HRESULT ( STDMETHODCALLTYPE *LoadSystemProfile )( 
            IWMProfileManager * This,
            /* [in] */ DWORD dwProfileIndex,
            /* [out] */ IWMProfile **ppProfile);
        
        END_INTERFACE
    } IWMProfileManagerVtbl;

    interface IWMProfileManager
    {
        CONST_VTBL struct IWMProfileManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfileManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfileManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfileManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfileManager_CreateEmptyProfile(This,dwVersion,ppProfile)	\
    (This)->lpVtbl -> CreateEmptyProfile(This,dwVersion,ppProfile)

#define IWMProfileManager_LoadProfileByID(This,guidProfile,ppProfile)	\
    (This)->lpVtbl -> LoadProfileByID(This,guidProfile,ppProfile)

#define IWMProfileManager_LoadProfileByData(This,pwszProfile,ppProfile)	\
    (This)->lpVtbl -> LoadProfileByData(This,pwszProfile,ppProfile)

#define IWMProfileManager_SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)	\
    (This)->lpVtbl -> SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)

#define IWMProfileManager_GetSystemProfileCount(This,pcProfiles)	\
    (This)->lpVtbl -> GetSystemProfileCount(This,pcProfiles)

#define IWMProfileManager_LoadSystemProfile(This,dwProfileIndex,ppProfile)	\
    (This)->lpVtbl -> LoadSystemProfile(This,dwProfileIndex,ppProfile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfileManager_CreateEmptyProfile_Proxy( 
    IWMProfileManager * This,
    /* [in] */ WMT_VERSION dwVersion,
    /* [out] */ IWMProfile **ppProfile);


void __RPC_STUB IWMProfileManager_CreateEmptyProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_LoadProfileByID_Proxy( 
    IWMProfileManager * This,
    /* [in] */ REFGUID guidProfile,
    /* [out] */ IWMProfile **ppProfile);


void __RPC_STUB IWMProfileManager_LoadProfileByID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_LoadProfileByData_Proxy( 
    IWMProfileManager * This,
    /* [in] */ const WCHAR *pwszProfile,
    /* [out] */ IWMProfile **ppProfile);


void __RPC_STUB IWMProfileManager_LoadProfileByData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_SaveProfile_Proxy( 
    IWMProfileManager * This,
    /* [in] */ IWMProfile *pIWMProfile,
    /* [in] */ WCHAR *pwszProfile,
    /* [out][in] */ DWORD *pdwLength);


void __RPC_STUB IWMProfileManager_SaveProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_GetSystemProfileCount_Proxy( 
    IWMProfileManager * This,
    /* [out] */ DWORD *pcProfiles);


void __RPC_STUB IWMProfileManager_GetSystemProfileCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_LoadSystemProfile_Proxy( 
    IWMProfileManager * This,
    /* [in] */ DWORD dwProfileIndex,
    /* [out] */ IWMProfile **ppProfile);


void __RPC_STUB IWMProfileManager_LoadSystemProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfileManager_INTERFACE_DEFINED__ */


#ifndef __IWMProfileManager2_INTERFACE_DEFINED__
#define __IWMProfileManager2_INTERFACE_DEFINED__

/* interface IWMProfileManager2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfileManager2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7A924E51-73C1-494d-8019-23D37ED9B89A")
    IWMProfileManager2 : public IWMProfileManager
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSystemProfileVersion( 
            WMT_VERSION *pdwVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSystemProfileVersion( 
            WMT_VERSION dwVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfileManager2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMProfileManager2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMProfileManager2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMProfileManager2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateEmptyProfile )( 
            IWMProfileManager2 * This,
            /* [in] */ WMT_VERSION dwVersion,
            /* [out] */ IWMProfile **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *LoadProfileByID )( 
            IWMProfileManager2 * This,
            /* [in] */ REFGUID guidProfile,
            /* [out] */ IWMProfile **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *LoadProfileByData )( 
            IWMProfileManager2 * This,
            /* [in] */ const WCHAR *pwszProfile,
            /* [out] */ IWMProfile **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SaveProfile )( 
            IWMProfileManager2 * This,
            /* [in] */ IWMProfile *pIWMProfile,
            /* [in] */ WCHAR *pwszProfile,
            /* [out][in] */ DWORD *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetSystemProfileCount )( 
            IWMProfileManager2 * This,
            /* [out] */ DWORD *pcProfiles);
        
        HRESULT ( STDMETHODCALLTYPE *LoadSystemProfile )( 
            IWMProfileManager2 * This,
            /* [in] */ DWORD dwProfileIndex,
            /* [out] */ IWMProfile **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GetSystemProfileVersion )( 
            IWMProfileManager2 * This,
            WMT_VERSION *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE *SetSystemProfileVersion )( 
            IWMProfileManager2 * This,
            WMT_VERSION dwVersion);
        
        END_INTERFACE
    } IWMProfileManager2Vtbl;

    interface IWMProfileManager2
    {
        CONST_VTBL struct IWMProfileManager2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfileManager2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfileManager2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfileManager2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfileManager2_CreateEmptyProfile(This,dwVersion,ppProfile)	\
    (This)->lpVtbl -> CreateEmptyProfile(This,dwVersion,ppProfile)

#define IWMProfileManager2_LoadProfileByID(This,guidProfile,ppProfile)	\
    (This)->lpVtbl -> LoadProfileByID(This,guidProfile,ppProfile)

#define IWMProfileManager2_LoadProfileByData(This,pwszProfile,ppProfile)	\
    (This)->lpVtbl -> LoadProfileByData(This,pwszProfile,ppProfile)

#define IWMProfileManager2_SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)	\
    (This)->lpVtbl -> SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)

#define IWMProfileManager2_GetSystemProfileCount(This,pcProfiles)	\
    (This)->lpVtbl -> GetSystemProfileCount(This,pcProfiles)

#define IWMProfileManager2_LoadSystemProfile(This,dwProfileIndex,ppProfile)	\
    (This)->lpVtbl -> LoadSystemProfile(This,dwProfileIndex,ppProfile)


#define IWMProfileManager2_GetSystemProfileVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetSystemProfileVersion(This,pdwVersion)

#define IWMProfileManager2_SetSystemProfileVersion(This,dwVersion)	\
    (This)->lpVtbl -> SetSystemProfileVersion(This,dwVersion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfileManager2_GetSystemProfileVersion_Proxy( 
    IWMProfileManager2 * This,
    WMT_VERSION *pdwVersion);


void __RPC_STUB IWMProfileManager2_GetSystemProfileVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager2_SetSystemProfileVersion_Proxy( 
    IWMProfileManager2 * This,
    WMT_VERSION dwVersion);


void __RPC_STUB IWMProfileManager2_SetSystemProfileVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfileManager2_INTERFACE_DEFINED__ */


#ifndef __IWMProfile_INTERFACE_DEFINED__
#define __IWMProfile_INTERFACE_DEFINED__

/* interface IWMProfile */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDB-2B2B-11d3-B36B-00C04F6108FF")
    IWMProfile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ WMT_VERSION *pdwVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ DWORD *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ const WCHAR *pwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [out] */ WCHAR *pwszDescription,
            /* [out][in] */ DWORD *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescription( 
            /* [in] */ const WCHAR *pwszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamCount( 
            /* [out] */ DWORD *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ IWMStreamConfig **ppConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamByNumber( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ IWMStreamConfig **ppConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStream( 
            /* [in] */ IWMStreamConfig *pConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStreamByNumber( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStream( 
            /* [in] */ IWMStreamConfig *pConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReconfigStream( 
            /* [in] */ IWMStreamConfig *pConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewStream( 
            /* [in] */ REFGUID guidStreamType,
            /* [out] */ IWMStreamConfig **ppConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMutualExclusionCount( 
            /* [out] */ DWORD *pcME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMutualExclusion( 
            /* [in] */ DWORD dwMEIndex,
            /* [out] */ IWMMutualExclusion **ppME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveMutualExclusion( 
            /* [in] */ IWMMutualExclusion *pME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMutualExclusion( 
            /* [in] */ IWMMutualExclusion *pME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewMutualExclusion( 
            /* [out] */ IWMMutualExclusion **ppME) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMProfile * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMProfile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMProfile * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            IWMProfile * This,
            /* [out] */ WMT_VERSION *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IWMProfile * This,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ DWORD *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            IWMProfile * This,
            /* [in] */ const WCHAR *pwszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            IWMProfile * This,
            /* [out] */ WCHAR *pwszDescription,
            /* [out][in] */ DWORD *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescription )( 
            IWMProfile * This,
            /* [in] */ const WCHAR *pwszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamCount )( 
            IWMProfile * This,
            /* [out] */ DWORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            IWMProfile * This,
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ IWMStreamConfig **ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamByNumber )( 
            IWMProfile * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ IWMStreamConfig **ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStream )( 
            IWMProfile * This,
            /* [in] */ IWMStreamConfig *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStreamByNumber )( 
            IWMProfile * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *AddStream )( 
            IWMProfile * This,
            /* [in] */ IWMStreamConfig *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE *ReconfigStream )( 
            IWMProfile * This,
            /* [in] */ IWMStreamConfig *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNewStream )( 
            IWMProfile * This,
            /* [in] */ REFGUID guidStreamType,
            /* [out] */ IWMStreamConfig **ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE *GetMutualExclusionCount )( 
            IWMProfile * This,
            /* [out] */ DWORD *pcME);
        
        HRESULT ( STDMETHODCALLTYPE *GetMutualExclusion )( 
            IWMProfile * This,
            /* [in] */ DWORD dwMEIndex,
            /* [out] */ IWMMutualExclusion **ppME);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveMutualExclusion )( 
            IWMProfile * This,
            /* [in] */ IWMMutualExclusion *pME);
        
        HRESULT ( STDMETHODCALLTYPE *AddMutualExclusion )( 
            IWMProfile * This,
            /* [in] */ IWMMutualExclusion *pME);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNewMutualExclusion )( 
            IWMProfile * This,
            /* [out] */ IWMMutualExclusion **ppME);
        
        END_INTERFACE
    } IWMProfileVtbl;

    interface IWMProfile
    {
        CONST_VTBL struct IWMProfileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfile_GetVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersion)

#define IWMProfile_GetName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetName(This,pwszName,pcchName)

#define IWMProfile_SetName(This,pwszName)	\
    (This)->lpVtbl -> SetName(This,pwszName)

#define IWMProfile_GetDescription(This,pwszDescription,pcchName)	\
    (This)->lpVtbl -> GetDescription(This,pwszDescription,pcchName)

#define IWMProfile_SetDescription(This,pwszDescription)	\
    (This)->lpVtbl -> SetDescription(This,pwszDescription)

#define IWMProfile_GetStreamCount(This,pcStreams)	\
    (This)->lpVtbl -> GetStreamCount(This,pcStreams)

#define IWMProfile_GetStream(This,dwStreamIndex,ppConfig)	\
    (This)->lpVtbl -> GetStream(This,dwStreamIndex,ppConfig)

#define IWMProfile_GetStreamByNumber(This,wStreamNum,ppConfig)	\
    (This)->lpVtbl -> GetStreamByNumber(This,wStreamNum,ppConfig)

#define IWMProfile_RemoveStream(This,pConfig)	\
    (This)->lpVtbl -> RemoveStream(This,pConfig)

#define IWMProfile_RemoveStreamByNumber(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStreamByNumber(This,wStreamNum)

#define IWMProfile_AddStream(This,pConfig)	\
    (This)->lpVtbl -> AddStream(This,pConfig)

#define IWMProfile_ReconfigStream(This,pConfig)	\
    (This)->lpVtbl -> ReconfigStream(This,pConfig)

#define IWMProfile_CreateNewStream(This,guidStreamType,ppConfig)	\
    (This)->lpVtbl -> CreateNewStream(This,guidStreamType,ppConfig)

#define IWMProfile_GetMutualExclusionCount(This,pcME)	\
    (This)->lpVtbl -> GetMutualExclusionCount(This,pcME)

#define IWMProfile_GetMutualExclusion(This,dwMEIndex,ppME)	\
    (This)->lpVtbl -> GetMutualExclusion(This,dwMEIndex,ppME)

#define IWMProfile_RemoveMutualExclusion(This,pME)	\
    (This)->lpVtbl -> RemoveMutualExclusion(This,pME)

#define IWMProfile_AddMutualExclusion(This,pME)	\
    (This)->lpVtbl -> AddMutualExclusion(This,pME)

#define IWMProfile_CreateNewMutualExclusion(This,ppME)	\
    (This)->lpVtbl -> CreateNewMutualExclusion(This,ppME)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfile_GetVersion_Proxy( 
    IWMProfile * This,
    /* [out] */ WMT_VERSION *pdwVersion);


void __RPC_STUB IWMProfile_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetName_Proxy( 
    IWMProfile * This,
    /* [out] */ WCHAR *pwszName,
    /* [out][in] */ DWORD *pcchName);


void __RPC_STUB IWMProfile_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_SetName_Proxy( 
    IWMProfile * This,
    /* [in] */ const WCHAR *pwszName);


void __RPC_STUB IWMProfile_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetDescription_Proxy( 
    IWMProfile * This,
    /* [out] */ WCHAR *pwszDescription,
    /* [out][in] */ DWORD *pcchName);


void __RPC_STUB IWMProfile_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_SetDescription_Proxy( 
    IWMProfile * This,
    /* [in] */ const WCHAR *pwszDescription);


void __RPC_STUB IWMProfile_SetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetStreamCount_Proxy( 
    IWMProfile * This,
    /* [out] */ DWORD *pcStreams);


void __RPC_STUB IWMProfile_GetStreamCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetStream_Proxy( 
    IWMProfile * This,
    /* [in] */ DWORD dwStreamIndex,
    /* [out] */ IWMStreamConfig **ppConfig);


void __RPC_STUB IWMProfile_GetStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetStreamByNumber_Proxy( 
    IWMProfile * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ IWMStreamConfig **ppConfig);


void __RPC_STUB IWMProfile_GetStreamByNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_RemoveStream_Proxy( 
    IWMProfile * This,
    /* [in] */ IWMStreamConfig *pConfig);


void __RPC_STUB IWMProfile_RemoveStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_RemoveStreamByNumber_Proxy( 
    IWMProfile * This,
    /* [in] */ WORD wStreamNum);


void __RPC_STUB IWMProfile_RemoveStreamByNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_AddStream_Proxy( 
    IWMProfile * This,
    /* [in] */ IWMStreamConfig *pConfig);


void __RPC_STUB IWMProfile_AddStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_ReconfigStream_Proxy( 
    IWMProfile * This,
    /* [in] */ IWMStreamConfig *pConfig);


void __RPC_STUB IWMProfile_ReconfigStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_CreateNewStream_Proxy( 
    IWMProfile * This,
    /* [in] */ REFGUID guidStreamType,
    /* [out] */ IWMStreamConfig **ppConfig);


void __RPC_STUB IWMProfile_CreateNewStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetMutualExclusionCount_Proxy( 
    IWMProfile * This,
    /* [out] */ DWORD *pcME);


void __RPC_STUB IWMProfile_GetMutualExclusionCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetMutualExclusion_Proxy( 
    IWMProfile * This,
    /* [in] */ DWORD dwMEIndex,
    /* [out] */ IWMMutualExclusion **ppME);


void __RPC_STUB IWMProfile_GetMutualExclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_RemoveMutualExclusion_Proxy( 
    IWMProfile * This,
    /* [in] */ IWMMutualExclusion *pME);


void __RPC_STUB IWMProfile_RemoveMutualExclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_AddMutualExclusion_Proxy( 
    IWMProfile * This,
    /* [in] */ IWMMutualExclusion *pME);


void __RPC_STUB IWMProfile_AddMutualExclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_CreateNewMutualExclusion_Proxy( 
    IWMProfile * This,
    /* [out] */ IWMMutualExclusion **ppME);


void __RPC_STUB IWMProfile_CreateNewMutualExclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfile_INTERFACE_DEFINED__ */


#ifndef __IWMProfile2_INTERFACE_DEFINED__
#define __IWMProfile2_INTERFACE_DEFINED__

/* interface IWMProfile2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfile2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("07E72D33-D94E-4be7-8843-60AE5FF7E5F5")
    IWMProfile2 : public IWMProfile
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProfileID( 
            /* [out] */ GUID *pguidID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfile2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMProfile2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMProfile2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMProfile2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            IWMProfile2 * This,
            /* [out] */ WMT_VERSION *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IWMProfile2 * This,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ DWORD *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            IWMProfile2 * This,
            /* [in] */ const WCHAR *pwszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            IWMProfile2 * This,
            /* [out] */ WCHAR *pwszDescription,
            /* [out][in] */ DWORD *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescription )( 
            IWMProfile2 * This,
            /* [in] */ const WCHAR *pwszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamCount )( 
            IWMProfile2 * This,
            /* [out] */ DWORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            IWMProfile2 * This,
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ IWMStreamConfig **ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamByNumber )( 
            IWMProfile2 * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ IWMStreamConfig **ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStream )( 
            IWMProfile2 * This,
            /* [in] */ IWMStreamConfig *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStreamByNumber )( 
            IWMProfile2 * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *AddStream )( 
            IWMProfile2 * This,
            /* [in] */ IWMStreamConfig *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE *ReconfigStream )( 
            IWMProfile2 * This,
            /* [in] */ IWMStreamConfig *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNewStream )( 
            IWMProfile2 * This,
            /* [in] */ REFGUID guidStreamType,
            /* [out] */ IWMStreamConfig **ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE *GetMutualExclusionCount )( 
            IWMProfile2 * This,
            /* [out] */ DWORD *pcME);
        
        HRESULT ( STDMETHODCALLTYPE *GetMutualExclusion )( 
            IWMProfile2 * This,
            /* [in] */ DWORD dwMEIndex,
            /* [out] */ IWMMutualExclusion **ppME);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveMutualExclusion )( 
            IWMProfile2 * This,
            /* [in] */ IWMMutualExclusion *pME);
        
        HRESULT ( STDMETHODCALLTYPE *AddMutualExclusion )( 
            IWMProfile2 * This,
            /* [in] */ IWMMutualExclusion *pME);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNewMutualExclusion )( 
            IWMProfile2 * This,
            /* [out] */ IWMMutualExclusion **ppME);
        
        HRESULT ( STDMETHODCALLTYPE *GetProfileID )( 
            IWMProfile2 * This,
            /* [out] */ GUID *pguidID);
        
        END_INTERFACE
    } IWMProfile2Vtbl;

    interface IWMProfile2
    {
        CONST_VTBL struct IWMProfile2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfile2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfile2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfile2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfile2_GetVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersion)

#define IWMProfile2_GetName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetName(This,pwszName,pcchName)

#define IWMProfile2_SetName(This,pwszName)	\
    (This)->lpVtbl -> SetName(This,pwszName)

#define IWMProfile2_GetDescription(This,pwszDescription,pcchName)	\
    (This)->lpVtbl -> GetDescription(This,pwszDescription,pcchName)

#define IWMProfile2_SetDescription(This,pwszDescription)	\
    (This)->lpVtbl -> SetDescription(This,pwszDescription)

#define IWMProfile2_GetStreamCount(This,pcStreams)	\
    (This)->lpVtbl -> GetStreamCount(This,pcStreams)

#define IWMProfile2_GetStream(This,dwStreamIndex,ppConfig)	\
    (This)->lpVtbl -> GetStream(This,dwStreamIndex,ppConfig)

#define IWMProfile2_GetStreamByNumber(This,wStreamNum,ppConfig)	\
    (This)->lpVtbl -> GetStreamByNumber(This,wStreamNum,ppConfig)

#define IWMProfile2_RemoveStream(This,pConfig)	\
    (This)->lpVtbl -> RemoveStream(This,pConfig)

#define IWMProfile2_RemoveStreamByNumber(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStreamByNumber(This,wStreamNum)

#define IWMProfile2_AddStream(This,pConfig)	\
    (This)->lpVtbl -> AddStream(This,pConfig)

#define IWMProfile2_ReconfigStream(This,pConfig)	\
    (This)->lpVtbl -> ReconfigStream(This,pConfig)

#define IWMProfile2_CreateNewStream(This,guidStreamType,ppConfig)	\
    (This)->lpVtbl -> CreateNewStream(This,guidStreamType,ppConfig)

#define IWMProfile2_GetMutualExclusionCount(This,pcME)	\
    (This)->lpVtbl -> GetMutualExclusionCount(This,pcME)

#define IWMProfile2_GetMutualExclusion(This,dwMEIndex,ppME)	\
    (This)->lpVtbl -> GetMutualExclusion(This,dwMEIndex,ppME)

#define IWMProfile2_RemoveMutualExclusion(This,pME)	\
    (This)->lpVtbl -> RemoveMutualExclusion(This,pME)

#define IWMProfile2_AddMutualExclusion(This,pME)	\
    (This)->lpVtbl -> AddMutualExclusion(This,pME)

#define IWMProfile2_CreateNewMutualExclusion(This,ppME)	\
    (This)->lpVtbl -> CreateNewMutualExclusion(This,ppME)


#define IWMProfile2_GetProfileID(This,pguidID)	\
    (This)->lpVtbl -> GetProfileID(This,pguidID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfile2_GetProfileID_Proxy( 
    IWMProfile2 * This,
    /* [out] */ GUID *pguidID);


void __RPC_STUB IWMProfile2_GetProfileID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfile2_INTERFACE_DEFINED__ */


#ifndef __IWMProfile3_INTERFACE_DEFINED__
#define __IWMProfile3_INTERFACE_DEFINED__

/* interface IWMProfile3 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfile3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00EF96CC-A461-4546-8BCD-C9A28F0E06F5")
    IWMProfile3 : public IWMProfile2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStorageFormat( 
            /* [out] */ WMT_STORAGE_FORMAT *pnStorageFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStorageFormat( 
            /* [in] */ WMT_STORAGE_FORMAT nStorageFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBandwidthSharingCount( 
            /* [out] */ DWORD *pcBS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBandwidthSharing( 
            /* [in] */ DWORD dwBSIndex,
            /* [out] */ IWMBandwidthSharing **ppBS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveBandwidthSharing( 
            /* [in] */ IWMBandwidthSharing *pBS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddBandwidthSharing( 
            /* [in] */ IWMBandwidthSharing *pBS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewBandwidthSharing( 
            /* [out] */ IWMBandwidthSharing **ppBS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamPrioritization( 
            /* [out] */ IWMStreamPrioritization **ppSP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamPrioritization( 
            /* [in] */ IWMStreamPrioritization *pSP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStreamPrioritization( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewStreamPrioritization( 
            /* [out] */ IWMStreamPrioritization **ppSP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExpectedPacketCount( 
            /* [in] */ QWORD msDuration,
            /* [out] */ QWORD *pcPackets) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfile3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMProfile3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMProfile3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMProfile3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            IWMProfile3 * This,
            /* [out] */ WMT_VERSION *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IWMProfile3 * This,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ DWORD *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            IWMProfile3 * This,
            /* [in] */ const WCHAR *pwszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            IWMProfile3 * This,
            /* [out] */ WCHAR *pwszDescription,
            /* [out][in] */ DWORD *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescription )( 
            IWMProfile3 * This,
            /* [in] */ const WCHAR *pwszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamCount )( 
            IWMProfile3 * This,
            /* [out] */ DWORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            IWMProfile3 * This,
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ IWMStreamConfig **ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamByNumber )( 
            IWMProfile3 * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ IWMStreamConfig **ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStream )( 
            IWMProfile3 * This,
            /* [in] */ IWMStreamConfig *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStreamByNumber )( 
            IWMProfile3 * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *AddStream )( 
            IWMProfile3 * This,
            /* [in] */ IWMStreamConfig *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE *ReconfigStream )( 
            IWMProfile3 * This,
            /* [in] */ IWMStreamConfig *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNewStream )( 
            IWMProfile3 * This,
            /* [in] */ REFGUID guidStreamType,
            /* [out] */ IWMStreamConfig **ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE *GetMutualExclusionCount )( 
            IWMProfile3 * This,
            /* [out] */ DWORD *pcME);
        
        HRESULT ( STDMETHODCALLTYPE *GetMutualExclusion )( 
            IWMProfile3 * This,
            /* [in] */ DWORD dwMEIndex,
            /* [out] */ IWMMutualExclusion **ppME);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveMutualExclusion )( 
            IWMProfile3 * This,
            /* [in] */ IWMMutualExclusion *pME);
        
        HRESULT ( STDMETHODCALLTYPE *AddMutualExclusion )( 
            IWMProfile3 * This,
            /* [in] */ IWMMutualExclusion *pME);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNewMutualExclusion )( 
            IWMProfile3 * This,
            /* [out] */ IWMMutualExclusion **ppME);
        
        HRESULT ( STDMETHODCALLTYPE *GetProfileID )( 
            IWMProfile3 * This,
            /* [out] */ GUID *pguidID);
        
        HRESULT ( STDMETHODCALLTYPE *GetStorageFormat )( 
            IWMProfile3 * This,
            /* [out] */ WMT_STORAGE_FORMAT *pnStorageFormat);
        
        HRESULT ( STDMETHODCALLTYPE *SetStorageFormat )( 
            IWMProfile3 * This,
            /* [in] */ WMT_STORAGE_FORMAT nStorageFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetBandwidthSharingCount )( 
            IWMProfile3 * This,
            /* [out] */ DWORD *pcBS);
        
        HRESULT ( STDMETHODCALLTYPE *GetBandwidthSharing )( 
            IWMProfile3 * This,
            /* [in] */ DWORD dwBSIndex,
            /* [out] */ IWMBandwidthSharing **ppBS);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveBandwidthSharing )( 
            IWMProfile3 * This,
            /* [in] */ IWMBandwidthSharing *pBS);
        
        HRESULT ( STDMETHODCALLTYPE *AddBandwidthSharing )( 
            IWMProfile3 * This,
            /* [in] */ IWMBandwidthSharing *pBS);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNewBandwidthSharing )( 
            IWMProfile3 * This,
            /* [out] */ IWMBandwidthSharing **ppBS);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamPrioritization )( 
            IWMProfile3 * This,
            /* [out] */ IWMStreamPrioritization **ppSP);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamPrioritization )( 
            IWMProfile3 * This,
            /* [in] */ IWMStreamPrioritization *pSP);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStreamPrioritization )( 
            IWMProfile3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNewStreamPrioritization )( 
            IWMProfile3 * This,
            /* [out] */ IWMStreamPrioritization **ppSP);
        
        HRESULT ( STDMETHODCALLTYPE *GetExpectedPacketCount )( 
            IWMProfile3 * This,
            /* [in] */ QWORD msDuration,
            /* [out] */ QWORD *pcPackets);
        
        END_INTERFACE
    } IWMProfile3Vtbl;

    interface IWMProfile3
    {
        CONST_VTBL struct IWMProfile3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfile3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfile3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfile3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfile3_GetVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersion)

#define IWMProfile3_GetName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetName(This,pwszName,pcchName)

#define IWMProfile3_SetName(This,pwszName)	\
    (This)->lpVtbl -> SetName(This,pwszName)

#define IWMProfile3_GetDescription(This,pwszDescription,pcchName)	\
    (This)->lpVtbl -> GetDescription(This,pwszDescription,pcchName)

#define IWMProfile3_SetDescription(This,pwszDescription)	\
    (This)->lpVtbl -> SetDescription(This,pwszDescription)

#define IWMProfile3_GetStreamCount(This,pcStreams)	\
    (This)->lpVtbl -> GetStreamCount(This,pcStreams)

#define IWMProfile3_GetStream(This,dwStreamIndex,ppConfig)	\
    (This)->lpVtbl -> GetStream(This,dwStreamIndex,ppConfig)

#define IWMProfile3_GetStreamByNumber(This,wStreamNum,ppConfig)	\
    (This)->lpVtbl -> GetStreamByNumber(This,wStreamNum,ppConfig)

#define IWMProfile3_RemoveStream(This,pConfig)	\
    (This)->lpVtbl -> RemoveStream(This,pConfig)

#define IWMProfile3_RemoveStreamByNumber(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStreamByNumber(This,wStreamNum)

#define IWMProfile3_AddStream(This,pConfig)	\
    (This)->lpVtbl -> AddStream(This,pConfig)

#define IWMProfile3_ReconfigStream(This,pConfig)	\
    (This)->lpVtbl -> ReconfigStream(This,pConfig)

#define IWMProfile3_CreateNewStream(This,guidStreamType,ppConfig)	\
    (This)->lpVtbl -> CreateNewStream(This,guidStreamType,ppConfig)

#define IWMProfile3_GetMutualExclusionCount(This,pcME)	\
    (This)->lpVtbl -> GetMutualExclusionCount(This,pcME)

#define IWMProfile3_GetMutualExclusion(This,dwMEIndex,ppME)	\
    (This)->lpVtbl -> GetMutualExclusion(This,dwMEIndex,ppME)

#define IWMProfile3_RemoveMutualExclusion(This,pME)	\
    (This)->lpVtbl -> RemoveMutualExclusion(This,pME)

#define IWMProfile3_AddMutualExclusion(This,pME)	\
    (This)->lpVtbl -> AddMutualExclusion(This,pME)

#define IWMProfile3_CreateNewMutualExclusion(This,ppME)	\
    (This)->lpVtbl -> CreateNewMutualExclusion(This,ppME)


#define IWMProfile3_GetProfileID(This,pguidID)	\
    (This)->lpVtbl -> GetProfileID(This,pguidID)


#define IWMProfile3_GetStorageFormat(This,pnStorageFormat)	\
    (This)->lpVtbl -> GetStorageFormat(This,pnStorageFormat)

#define IWMProfile3_SetStorageFormat(This,nStorageFormat)	\
    (This)->lpVtbl -> SetStorageFormat(This,nStorageFormat)

#define IWMProfile3_GetBandwidthSharingCount(This,pcBS)	\
    (This)->lpVtbl -> GetBandwidthSharingCount(This,pcBS)

#define IWMProfile3_GetBandwidthSharing(This,dwBSIndex,ppBS)	\
    (This)->lpVtbl -> GetBandwidthSharing(This,dwBSIndex,ppBS)

#define IWMProfile3_RemoveBandwidthSharing(This,pBS)	\
    (This)->lpVtbl -> RemoveBandwidthSharing(This,pBS)

#define IWMProfile3_AddBandwidthSharing(This,pBS)	\
    (This)->lpVtbl -> AddBandwidthSharing(This,pBS)

#define IWMProfile3_CreateNewBandwidthSharing(This,ppBS)	\
    (This)->lpVtbl -> CreateNewBandwidthSharing(This,ppBS)

#define IWMProfile3_GetStreamPrioritization(This,ppSP)	\
    (This)->lpVtbl -> GetStreamPrioritization(This,ppSP)

#define IWMProfile3_SetStreamPrioritization(This,pSP)	\
    (This)->lpVtbl -> SetStreamPrioritization(This,pSP)

#define IWMProfile3_RemoveStreamPrioritization(This)	\
    (This)->lpVtbl -> RemoveStreamPrioritization(This)

#define IWMProfile3_CreateNewStreamPrioritization(This,ppSP)	\
    (This)->lpVtbl -> CreateNewStreamPrioritization(This,ppSP)

#define IWMProfile3_GetExpectedPacketCount(This,msDuration,pcPackets)	\
    (This)->lpVtbl -> GetExpectedPacketCount(This,msDuration,pcPackets)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfile3_GetStorageFormat_Proxy( 
    IWMProfile3 * This,
    /* [out] */ WMT_STORAGE_FORMAT *pnStorageFormat);


void __RPC_STUB IWMProfile3_GetStorageFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_SetStorageFormat_Proxy( 
    IWMProfile3 * This,
    /* [in] */ WMT_STORAGE_FORMAT nStorageFormat);


void __RPC_STUB IWMProfile3_SetStorageFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_GetBandwidthSharingCount_Proxy( 
    IWMProfile3 * This,
    /* [out] */ DWORD *pcBS);


void __RPC_STUB IWMProfile3_GetBandwidthSharingCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_GetBandwidthSharing_Proxy( 
    IWMProfile3 * This,
    /* [in] */ DWORD dwBSIndex,
    /* [out] */ IWMBandwidthSharing **ppBS);


void __RPC_STUB IWMProfile3_GetBandwidthSharing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_RemoveBandwidthSharing_Proxy( 
    IWMProfile3 * This,
    /* [in] */ IWMBandwidthSharing *pBS);


void __RPC_STUB IWMProfile3_RemoveBandwidthSharing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_AddBandwidthSharing_Proxy( 
    IWMProfile3 * This,
    /* [in] */ IWMBandwidthSharing *pBS);


void __RPC_STUB IWMProfile3_AddBandwidthSharing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_CreateNewBandwidthSharing_Proxy( 
    IWMProfile3 * This,
    /* [out] */ IWMBandwidthSharing **ppBS);


void __RPC_STUB IWMProfile3_CreateNewBandwidthSharing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_GetStreamPrioritization_Proxy( 
    IWMProfile3 * This,
    /* [out] */ IWMStreamPrioritization **ppSP);


void __RPC_STUB IWMProfile3_GetStreamPrioritization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_SetStreamPrioritization_Proxy( 
    IWMProfile3 * This,
    /* [in] */ IWMStreamPrioritization *pSP);


void __RPC_STUB IWMProfile3_SetStreamPrioritization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_RemoveStreamPrioritization_Proxy( 
    IWMProfile3 * This);


void __RPC_STUB IWMProfile3_RemoveStreamPrioritization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_CreateNewStreamPrioritization_Proxy( 
    IWMProfile3 * This,
    /* [out] */ IWMStreamPrioritization **ppSP);


void __RPC_STUB IWMProfile3_CreateNewStreamPrioritization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_GetExpectedPacketCount_Proxy( 
    IWMProfile3 * This,
    /* [in] */ QWORD msDuration,
    /* [out] */ QWORD *pcPackets);


void __RPC_STUB IWMProfile3_GetExpectedPacketCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfile3_INTERFACE_DEFINED__ */


#ifndef __IWMStreamConfig_INTERFACE_DEFINED__
#define __IWMStreamConfig_INTERFACE_DEFINED__

/* interface IWMStreamConfig */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStreamConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDC-2B2B-11d3-B36B-00C04F6108FF")
    IWMStreamConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamType( 
            /* [out] */ GUID *pguidStreamType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamNumber( 
            /* [out] */ WORD *pwStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamNumber( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamName( 
            /* [out] */ WCHAR *pwszStreamName,
            /* [out][in] */ WORD *pcchStreamName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamName( 
            /* [in] */ WCHAR *pwszStreamName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionName( 
            /* [out] */ WCHAR *pwszInputName,
            /* [out][in] */ WORD *pcchInputName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConnectionName( 
            /* [in] */ WCHAR *pwszInputName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBitrate( 
            /* [out] */ DWORD *pdwBitrate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBitrate( 
            /* [in] */ DWORD pdwBitrate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferWindow( 
            /* [out] */ DWORD *pmsBufferWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferWindow( 
            /* [in] */ DWORD msBufferWindow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStreamConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMStreamConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMStreamConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMStreamConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamType )( 
            IWMStreamConfig * This,
            /* [out] */ GUID *pguidStreamType);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamNumber )( 
            IWMStreamConfig * This,
            /* [out] */ WORD *pwStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamNumber )( 
            IWMStreamConfig * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamName )( 
            IWMStreamConfig * This,
            /* [out] */ WCHAR *pwszStreamName,
            /* [out][in] */ WORD *pcchStreamName);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamName )( 
            IWMStreamConfig * This,
            /* [in] */ WCHAR *pwszStreamName);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionName )( 
            IWMStreamConfig * This,
            /* [out] */ WCHAR *pwszInputName,
            /* [out][in] */ WORD *pcchInputName);
        
        HRESULT ( STDMETHODCALLTYPE *SetConnectionName )( 
            IWMStreamConfig * This,
            /* [in] */ WCHAR *pwszInputName);
        
        HRESULT ( STDMETHODCALLTYPE *GetBitrate )( 
            IWMStreamConfig * This,
            /* [out] */ DWORD *pdwBitrate);
        
        HRESULT ( STDMETHODCALLTYPE *SetBitrate )( 
            IWMStreamConfig * This,
            /* [in] */ DWORD pdwBitrate);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferWindow )( 
            IWMStreamConfig * This,
            /* [out] */ DWORD *pmsBufferWindow);
        
        HRESULT ( STDMETHODCALLTYPE *SetBufferWindow )( 
            IWMStreamConfig * This,
            /* [in] */ DWORD msBufferWindow);
        
        END_INTERFACE
    } IWMStreamConfigVtbl;

    interface IWMStreamConfig
    {
        CONST_VTBL struct IWMStreamConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStreamConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMStreamConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMStreamConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMStreamConfig_GetStreamType(This,pguidStreamType)	\
    (This)->lpVtbl -> GetStreamType(This,pguidStreamType)

#define IWMStreamConfig_GetStreamNumber(This,pwStreamNum)	\
    (This)->lpVtbl -> GetStreamNumber(This,pwStreamNum)

#define IWMStreamConfig_SetStreamNumber(This,wStreamNum)	\
    (This)->lpVtbl -> SetStreamNumber(This,wStreamNum)

#define IWMStreamConfig_GetStreamName(This,pwszStreamName,pcchStreamName)	\
    (This)->lpVtbl -> GetStreamName(This,pwszStreamName,pcchStreamName)

#define IWMStreamConfig_SetStreamName(This,pwszStreamName)	\
    (This)->lpVtbl -> SetStreamName(This,pwszStreamName)

#define IWMStreamConfig_GetConnectionName(This,pwszInputName,pcchInputName)	\
    (This)->lpVtbl -> GetConnectionName(This,pwszInputName,pcchInputName)

#define IWMStreamConfig_SetConnectionName(This,pwszInputName)	\
    (This)->lpVtbl -> SetConnectionName(This,pwszInputName)

#define IWMStreamConfig_GetBitrate(This,pdwBitrate)	\
    (This)->lpVtbl -> GetBitrate(This,pdwBitrate)

#define IWMStreamConfig_SetBitrate(This,pdwBitrate)	\
    (This)->lpVtbl -> SetBitrate(This,pdwBitrate)

#define IWMStreamConfig_GetBufferWindow(This,pmsBufferWindow)	\
    (This)->lpVtbl -> GetBufferWindow(This,pmsBufferWindow)

#define IWMStreamConfig_SetBufferWindow(This,msBufferWindow)	\
    (This)->lpVtbl -> SetBufferWindow(This,msBufferWindow)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetStreamType_Proxy( 
    IWMStreamConfig * This,
    /* [out] */ GUID *pguidStreamType);


void __RPC_STUB IWMStreamConfig_GetStreamType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetStreamNumber_Proxy( 
    IWMStreamConfig * This,
    /* [out] */ WORD *pwStreamNum);


void __RPC_STUB IWMStreamConfig_GetStreamNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetStreamNumber_Proxy( 
    IWMStreamConfig * This,
    /* [in] */ WORD wStreamNum);


void __RPC_STUB IWMStreamConfig_SetStreamNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetStreamName_Proxy( 
    IWMStreamConfig * This,
    /* [out] */ WCHAR *pwszStreamName,
    /* [out][in] */ WORD *pcchStreamName);


void __RPC_STUB IWMStreamConfig_GetStreamName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetStreamName_Proxy( 
    IWMStreamConfig * This,
    /* [in] */ WCHAR *pwszStreamName);


void __RPC_STUB IWMStreamConfig_SetStreamName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetConnectionName_Proxy( 
    IWMStreamConfig * This,
    /* [out] */ WCHAR *pwszInputName,
    /* [out][in] */ WORD *pcchInputName);


void __RPC_STUB IWMStreamConfig_GetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetConnectionName_Proxy( 
    IWMStreamConfig * This,
    /* [in] */ WCHAR *pwszInputName);


void __RPC_STUB IWMStreamConfig_SetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetBitrate_Proxy( 
    IWMStreamConfig * This,
    /* [out] */ DWORD *pdwBitrate);


void __RPC_STUB IWMStreamConfig_GetBitrate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetBitrate_Proxy( 
    IWMStreamConfig * This,
    /* [in] */ DWORD pdwBitrate);


void __RPC_STUB IWMStreamConfig_SetBitrate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetBufferWindow_Proxy( 
    IWMStreamConfig * This,
    /* [out] */ DWORD *pmsBufferWindow);


void __RPC_STUB IWMStreamConfig_GetBufferWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetBufferWindow_Proxy( 
    IWMStreamConfig * This,
    /* [in] */ DWORD msBufferWindow);


void __RPC_STUB IWMStreamConfig_SetBufferWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMStreamConfig_INTERFACE_DEFINED__ */


#ifndef __IWMStreamConfig2_INTERFACE_DEFINED__
#define __IWMStreamConfig2_INTERFACE_DEFINED__

/* interface IWMStreamConfig2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStreamConfig2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7688D8CB-FC0D-43BD-9459-5A8DEC200CFA")
    IWMStreamConfig2 : public IWMStreamConfig
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTransportType( 
            /* [out] */ WMT_TRANSPORT_TYPE *pnTransportType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransportType( 
            /* [in] */ WMT_TRANSPORT_TYPE nTransportType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddDataUnitExtension( 
            /* [in] */ GUID guidExtensionSystemID,
            /* [in] */ WORD cbExtensionDataSize,
            /* [in] */ BYTE *pbExtensionSystemInfo,
            /* [in] */ DWORD cbExtensionSystemInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataUnitExtensionCount( 
            /* [out] */ WORD *pcDataUnitExtensions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataUnitExtension( 
            /* [in] */ WORD wDataUnitExtensionNumber,
            /* [out] */ GUID *pguidExtensionSystemID,
            /* [out] */ WORD *pcbExtensionDataSize,
            /* [out] */ BYTE *pbExtensionSystemInfo,
            /* [out] */ DWORD *pcbExtensionSystemInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllDataUnitExtensions( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStreamConfig2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMStreamConfig2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMStreamConfig2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMStreamConfig2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamType )( 
            IWMStreamConfig2 * This,
            /* [out] */ GUID *pguidStreamType);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamNumber )( 
            IWMStreamConfig2 * This,
            /* [out] */ WORD *pwStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamNumber )( 
            IWMStreamConfig2 * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamName )( 
            IWMStreamConfig2 * This,
            /* [out] */ WCHAR *pwszStreamName,
            /* [out][in] */ WORD *pcchStreamName);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamName )( 
            IWMStreamConfig2 * This,
            /* [in] */ WCHAR *pwszStreamName);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionName )( 
            IWMStreamConfig2 * This,
            /* [out] */ WCHAR *pwszInputName,
            /* [out][in] */ WORD *pcchInputName);
        
        HRESULT ( STDMETHODCALLTYPE *SetConnectionName )( 
            IWMStreamConfig2 * This,
            /* [in] */ WCHAR *pwszInputName);
        
        HRESULT ( STDMETHODCALLTYPE *GetBitrate )( 
            IWMStreamConfig2 * This,
            /* [out] */ DWORD *pdwBitrate);
        
        HRESULT ( STDMETHODCALLTYPE *SetBitrate )( 
            IWMStreamConfig2 * This,
            /* [in] */ DWORD pdwBitrate);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferWindow )( 
            IWMStreamConfig2 * This,
            /* [out] */ DWORD *pmsBufferWindow);
        
        HRESULT ( STDMETHODCALLTYPE *SetBufferWindow )( 
            IWMStreamConfig2 * This,
            /* [in] */ DWORD msBufferWindow);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportType )( 
            IWMStreamConfig2 * This,
            /* [out] */ WMT_TRANSPORT_TYPE *pnTransportType);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransportType )( 
            IWMStreamConfig2 * This,
            /* [in] */ WMT_TRANSPORT_TYPE nTransportType);
        
        HRESULT ( STDMETHODCALLTYPE *AddDataUnitExtension )( 
            IWMStreamConfig2 * This,
            /* [in] */ GUID guidExtensionSystemID,
            /* [in] */ WORD cbExtensionDataSize,
            /* [in] */ BYTE *pbExtensionSystemInfo,
            /* [in] */ DWORD cbExtensionSystemInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataUnitExtensionCount )( 
            IWMStreamConfig2 * This,
            /* [out] */ WORD *pcDataUnitExtensions);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataUnitExtension )( 
            IWMStreamConfig2 * This,
            /* [in] */ WORD wDataUnitExtensionNumber,
            /* [out] */ GUID *pguidExtensionSystemID,
            /* [out] */ WORD *pcbExtensionDataSize,
            /* [out] */ BYTE *pbExtensionSystemInfo,
            /* [out] */ DWORD *pcbExtensionSystemInfo);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAllDataUnitExtensions )( 
            IWMStreamConfig2 * This);
        
        END_INTERFACE
    } IWMStreamConfig2Vtbl;

    interface IWMStreamConfig2
    {
        CONST_VTBL struct IWMStreamConfig2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStreamConfig2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMStreamConfig2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMStreamConfig2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMStreamConfig2_GetStreamType(This,pguidStreamType)	\
    (This)->lpVtbl -> GetStreamType(This,pguidStreamType)

#define IWMStreamConfig2_GetStreamNumber(This,pwStreamNum)	\
    (This)->lpVtbl -> GetStreamNumber(This,pwStreamNum)

#define IWMStreamConfig2_SetStreamNumber(This,wStreamNum)	\
    (This)->lpVtbl -> SetStreamNumber(This,wStreamNum)

#define IWMStreamConfig2_GetStreamName(This,pwszStreamName,pcchStreamName)	\
    (This)->lpVtbl -> GetStreamName(This,pwszStreamName,pcchStreamName)

#define IWMStreamConfig2_SetStreamName(This,pwszStreamName)	\
    (This)->lpVtbl -> SetStreamName(This,pwszStreamName)

#define IWMStreamConfig2_GetConnectionName(This,pwszInputName,pcchInputName)	\
    (This)->lpVtbl -> GetConnectionName(This,pwszInputName,pcchInputName)

#define IWMStreamConfig2_SetConnectionName(This,pwszInputName)	\
    (This)->lpVtbl -> SetConnectionName(This,pwszInputName)

#define IWMStreamConfig2_GetBitrate(This,pdwBitrate)	\
    (This)->lpVtbl -> GetBitrate(This,pdwBitrate)

#define IWMStreamConfig2_SetBitrate(This,pdwBitrate)	\
    (This)->lpVtbl -> SetBitrate(This,pdwBitrate)

#define IWMStreamConfig2_GetBufferWindow(This,pmsBufferWindow)	\
    (This)->lpVtbl -> GetBufferWindow(This,pmsBufferWindow)

#define IWMStreamConfig2_SetBufferWindow(This,msBufferWindow)	\
    (This)->lpVtbl -> SetBufferWindow(This,msBufferWindow)


#define IWMStreamConfig2_GetTransportType(This,pnTransportType)	\
    (This)->lpVtbl -> GetTransportType(This,pnTransportType)

#define IWMStreamConfig2_SetTransportType(This,nTransportType)	\
    (This)->lpVtbl -> SetTransportType(This,nTransportType)

#define IWMStreamConfig2_AddDataUnitExtension(This,guidExtensionSystemID,cbExtensionDataSize,pbExtensionSystemInfo,cbExtensionSystemInfo)	\
    (This)->lpVtbl -> AddDataUnitExtension(This,guidExtensionSystemID,cbExtensionDataSize,pbExtensionSystemInfo,cbExtensionSystemInfo)

#define IWMStreamConfig2_GetDataUnitExtensionCount(This,pcDataUnitExtensions)	\
    (This)->lpVtbl -> GetDataUnitExtensionCount(This,pcDataUnitExtensions)

#define IWMStreamConfig2_GetDataUnitExtension(This,wDataUnitExtensionNumber,pguidExtensionSystemID,pcbExtensionDataSize,pbExtensionSystemInfo,pcbExtensionSystemInfo)	\
    (This)->lpVtbl -> GetDataUnitExtension(This,wDataUnitExtensionNumber,pguidExtensionSystemID,pcbExtensionDataSize,pbExtensionSystemInfo,pcbExtensionSystemInfo)

#define IWMStreamConfig2_RemoveAllDataUnitExtensions(This)	\
    (This)->lpVtbl -> RemoveAllDataUnitExtensions(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMStreamConfig2_GetTransportType_Proxy( 
    IWMStreamConfig2 * This,
    /* [out] */ WMT_TRANSPORT_TYPE *pnTransportType);


void __RPC_STUB IWMStreamConfig2_GetTransportType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig2_SetTransportType_Proxy( 
    IWMStreamConfig2 * This,
    /* [in] */ WMT_TRANSPORT_TYPE nTransportType);


void __RPC_STUB IWMStreamConfig2_SetTransportType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig2_AddDataUnitExtension_Proxy( 
    IWMStreamConfig2 * This,
    /* [in] */ GUID guidExtensionSystemID,
    /* [in] */ WORD cbExtensionDataSize,
    /* [in] */ BYTE *pbExtensionSystemInfo,
    /* [in] */ DWORD cbExtensionSystemInfo);


void __RPC_STUB IWMStreamConfig2_AddDataUnitExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig2_GetDataUnitExtensionCount_Proxy( 
    IWMStreamConfig2 * This,
    /* [out] */ WORD *pcDataUnitExtensions);


void __RPC_STUB IWMStreamConfig2_GetDataUnitExtensionCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig2_GetDataUnitExtension_Proxy( 
    IWMStreamConfig2 * This,
    /* [in] */ WORD wDataUnitExtensionNumber,
    /* [out] */ GUID *pguidExtensionSystemID,
    /* [out] */ WORD *pcbExtensionDataSize,
    /* [out] */ BYTE *pbExtensionSystemInfo,
    /* [out] */ DWORD *pcbExtensionSystemInfo);


void __RPC_STUB IWMStreamConfig2_GetDataUnitExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig2_RemoveAllDataUnitExtensions_Proxy( 
    IWMStreamConfig2 * This);


void __RPC_STUB IWMStreamConfig2_RemoveAllDataUnitExtensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMStreamConfig2_INTERFACE_DEFINED__ */


#ifndef __IWMPacketSize_INTERFACE_DEFINED__
#define __IWMPacketSize_INTERFACE_DEFINED__

/* interface IWMPacketSize */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPacketSize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CDFB97AB-188F-40b3-B643-5B7903975C59")
    IWMPacketSize : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMaxPacketSize( 
            /* [out] */ DWORD *pdwMaxPacketSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxPacketSize( 
            /* [in] */ DWORD dwMaxPacketSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPacketSizeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPacketSize * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPacketSize * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPacketSize * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxPacketSize )( 
            IWMPacketSize * This,
            /* [out] */ DWORD *pdwMaxPacketSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxPacketSize )( 
            IWMPacketSize * This,
            /* [in] */ DWORD dwMaxPacketSize);
        
        END_INTERFACE
    } IWMPacketSizeVtbl;

    interface IWMPacketSize
    {
        CONST_VTBL struct IWMPacketSizeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPacketSize_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPacketSize_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPacketSize_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPacketSize_GetMaxPacketSize(This,pdwMaxPacketSize)	\
    (This)->lpVtbl -> GetMaxPacketSize(This,pdwMaxPacketSize)

#define IWMPacketSize_SetMaxPacketSize(This,dwMaxPacketSize)	\
    (This)->lpVtbl -> SetMaxPacketSize(This,dwMaxPacketSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPacketSize_GetMaxPacketSize_Proxy( 
    IWMPacketSize * This,
    /* [out] */ DWORD *pdwMaxPacketSize);


void __RPC_STUB IWMPacketSize_GetMaxPacketSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPacketSize_SetMaxPacketSize_Proxy( 
    IWMPacketSize * This,
    /* [in] */ DWORD dwMaxPacketSize);


void __RPC_STUB IWMPacketSize_SetMaxPacketSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPacketSize_INTERFACE_DEFINED__ */


#ifndef __IWMPacketSize2_INTERFACE_DEFINED__
#define __IWMPacketSize2_INTERFACE_DEFINED__

/* interface IWMPacketSize2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPacketSize2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8BFC2B9E-B646-4233-A877-1C6A079669DC")
    IWMPacketSize2 : public IWMPacketSize
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMinPacketSize( 
            /* [out] */ DWORD *pdwMinPacketSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMinPacketSize( 
            /* [in] */ DWORD dwMinPacketSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPacketSize2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPacketSize2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPacketSize2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPacketSize2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxPacketSize )( 
            IWMPacketSize2 * This,
            /* [out] */ DWORD *pdwMaxPacketSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxPacketSize )( 
            IWMPacketSize2 * This,
            /* [in] */ DWORD dwMaxPacketSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetMinPacketSize )( 
            IWMPacketSize2 * This,
            /* [out] */ DWORD *pdwMinPacketSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetMinPacketSize )( 
            IWMPacketSize2 * This,
            /* [in] */ DWORD dwMinPacketSize);
        
        END_INTERFACE
    } IWMPacketSize2Vtbl;

    interface IWMPacketSize2
    {
        CONST_VTBL struct IWMPacketSize2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPacketSize2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPacketSize2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPacketSize2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPacketSize2_GetMaxPacketSize(This,pdwMaxPacketSize)	\
    (This)->lpVtbl -> GetMaxPacketSize(This,pdwMaxPacketSize)

#define IWMPacketSize2_SetMaxPacketSize(This,dwMaxPacketSize)	\
    (This)->lpVtbl -> SetMaxPacketSize(This,dwMaxPacketSize)


#define IWMPacketSize2_GetMinPacketSize(This,pdwMinPacketSize)	\
    (This)->lpVtbl -> GetMinPacketSize(This,pdwMinPacketSize)

#define IWMPacketSize2_SetMinPacketSize(This,dwMinPacketSize)	\
    (This)->lpVtbl -> SetMinPacketSize(This,dwMinPacketSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPacketSize2_GetMinPacketSize_Proxy( 
    IWMPacketSize2 * This,
    /* [out] */ DWORD *pdwMinPacketSize);


void __RPC_STUB IWMPacketSize2_GetMinPacketSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPacketSize2_SetMinPacketSize_Proxy( 
    IWMPacketSize2 * This,
    /* [in] */ DWORD dwMinPacketSize);


void __RPC_STUB IWMPacketSize2_SetMinPacketSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPacketSize2_INTERFACE_DEFINED__ */


#ifndef __IWMStreamList_INTERFACE_DEFINED__
#define __IWMStreamList_INTERFACE_DEFINED__

/* interface IWMStreamList */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStreamList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDD-2B2B-11d3-B36B-00C04F6108FF")
    IWMStreamList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreams( 
            /* [out] */ WORD *pwStreamNumArray,
            /* [out][in] */ WORD *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStream( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStream( 
            /* [in] */ WORD wStreamNum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStreamListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMStreamList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMStreamList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMStreamList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreams )( 
            IWMStreamList * This,
            /* [out] */ WORD *pwStreamNumArray,
            /* [out][in] */ WORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *AddStream )( 
            IWMStreamList * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStream )( 
            IWMStreamList * This,
            /* [in] */ WORD wStreamNum);
        
        END_INTERFACE
    } IWMStreamListVtbl;

    interface IWMStreamList
    {
        CONST_VTBL struct IWMStreamListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStreamList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMStreamList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMStreamList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMStreamList_GetStreams(This,pwStreamNumArray,pcStreams)	\
    (This)->lpVtbl -> GetStreams(This,pwStreamNumArray,pcStreams)

#define IWMStreamList_AddStream(This,wStreamNum)	\
    (This)->lpVtbl -> AddStream(This,wStreamNum)

#define IWMStreamList_RemoveStream(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStream(This,wStreamNum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMStreamList_GetStreams_Proxy( 
    IWMStreamList * This,
    /* [out] */ WORD *pwStreamNumArray,
    /* [out][in] */ WORD *pcStreams);


void __RPC_STUB IWMStreamList_GetStreams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamList_AddStream_Proxy( 
    IWMStreamList * This,
    /* [in] */ WORD wStreamNum);


void __RPC_STUB IWMStreamList_AddStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamList_RemoveStream_Proxy( 
    IWMStreamList * This,
    /* [in] */ WORD wStreamNum);


void __RPC_STUB IWMStreamList_RemoveStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMStreamList_INTERFACE_DEFINED__ */


#ifndef __IWMMutualExclusion_INTERFACE_DEFINED__
#define __IWMMutualExclusion_INTERFACE_DEFINED__

/* interface IWMMutualExclusion */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMutualExclusion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDE-2B2B-11d3-B36B-00C04F6108FF")
    IWMMutualExclusion : public IWMStreamList
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID *pguidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetType( 
            /* [in] */ REFGUID guidType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMutualExclusionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMMutualExclusion * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMMutualExclusion * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMMutualExclusion * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreams )( 
            IWMMutualExclusion * This,
            /* [out] */ WORD *pwStreamNumArray,
            /* [out][in] */ WORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *AddStream )( 
            IWMMutualExclusion * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStream )( 
            IWMMutualExclusion * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IWMMutualExclusion * This,
            /* [out] */ GUID *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE *SetType )( 
            IWMMutualExclusion * This,
            /* [in] */ REFGUID guidType);
        
        END_INTERFACE
    } IWMMutualExclusionVtbl;

    interface IWMMutualExclusion
    {
        CONST_VTBL struct IWMMutualExclusionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMutualExclusion_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMMutualExclusion_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMMutualExclusion_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMMutualExclusion_GetStreams(This,pwStreamNumArray,pcStreams)	\
    (This)->lpVtbl -> GetStreams(This,pwStreamNumArray,pcStreams)

#define IWMMutualExclusion_AddStream(This,wStreamNum)	\
    (This)->lpVtbl -> AddStream(This,wStreamNum)

#define IWMMutualExclusion_RemoveStream(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStream(This,wStreamNum)


#define IWMMutualExclusion_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMMutualExclusion_SetType(This,guidType)	\
    (This)->lpVtbl -> SetType(This,guidType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMMutualExclusion_GetType_Proxy( 
    IWMMutualExclusion * This,
    /* [out] */ GUID *pguidType);


void __RPC_STUB IWMMutualExclusion_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion_SetType_Proxy( 
    IWMMutualExclusion * This,
    /* [in] */ REFGUID guidType);


void __RPC_STUB IWMMutualExclusion_SetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMMutualExclusion_INTERFACE_DEFINED__ */


#ifndef __IWMMutualExclusion2_INTERFACE_DEFINED__
#define __IWMMutualExclusion2_INTERFACE_DEFINED__

/* interface IWMMutualExclusion2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMutualExclusion2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0302B57D-89D1-4ba2-85C9-166F2C53EB91")
    IWMMutualExclusion2 : public IWMMutualExclusion
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ WCHAR *pwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCount( 
            /* [out] */ WORD *pwRecordCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRecord( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveRecord( 
            /* [in] */ WORD wRecordNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordName( 
            /* [in] */ WORD wRecordNumber,
            /* [out] */ WCHAR *pwszRecordName,
            /* [out][in] */ WORD *pcchRecordName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRecordName( 
            /* [in] */ WORD wRecordNumber,
            /* [in] */ WCHAR *pwszRecordName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamsForRecord( 
            /* [in] */ WORD wRecordNumber,
            /* [out] */ WORD *pwStreamNumArray,
            /* [out][in] */ WORD *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStreamForRecord( 
            /* [in] */ WORD wRecordNumber,
            /* [in] */ WORD wStreamNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStreamForRecord( 
            /* [in] */ WORD wRecordNumber,
            /* [in] */ WORD wStreamNumber) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMutualExclusion2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMMutualExclusion2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMMutualExclusion2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMMutualExclusion2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreams )( 
            IWMMutualExclusion2 * This,
            /* [out] */ WORD *pwStreamNumArray,
            /* [out][in] */ WORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *AddStream )( 
            IWMMutualExclusion2 * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStream )( 
            IWMMutualExclusion2 * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IWMMutualExclusion2 * This,
            /* [out] */ GUID *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE *SetType )( 
            IWMMutualExclusion2 * This,
            /* [in] */ REFGUID guidType);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IWMMutualExclusion2 * This,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            IWMMutualExclusion2 * This,
            /* [in] */ WCHAR *pwszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCount )( 
            IWMMutualExclusion2 * This,
            /* [out] */ WORD *pwRecordCount);
        
        HRESULT ( STDMETHODCALLTYPE *AddRecord )( 
            IWMMutualExclusion2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveRecord )( 
            IWMMutualExclusion2 * This,
            /* [in] */ WORD wRecordNumber);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordName )( 
            IWMMutualExclusion2 * This,
            /* [in] */ WORD wRecordNumber,
            /* [out] */ WCHAR *pwszRecordName,
            /* [out][in] */ WORD *pcchRecordName);
        
        HRESULT ( STDMETHODCALLTYPE *SetRecordName )( 
            IWMMutualExclusion2 * This,
            /* [in] */ WORD wRecordNumber,
            /* [in] */ WCHAR *pwszRecordName);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamsForRecord )( 
            IWMMutualExclusion2 * This,
            /* [in] */ WORD wRecordNumber,
            /* [out] */ WORD *pwStreamNumArray,
            /* [out][in] */ WORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *AddStreamForRecord )( 
            IWMMutualExclusion2 * This,
            /* [in] */ WORD wRecordNumber,
            /* [in] */ WORD wStreamNumber);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStreamForRecord )( 
            IWMMutualExclusion2 * This,
            /* [in] */ WORD wRecordNumber,
            /* [in] */ WORD wStreamNumber);
        
        END_INTERFACE
    } IWMMutualExclusion2Vtbl;

    interface IWMMutualExclusion2
    {
        CONST_VTBL struct IWMMutualExclusion2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMutualExclusion2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMMutualExclusion2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMMutualExclusion2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMMutualExclusion2_GetStreams(This,pwStreamNumArray,pcStreams)	\
    (This)->lpVtbl -> GetStreams(This,pwStreamNumArray,pcStreams)

#define IWMMutualExclusion2_AddStream(This,wStreamNum)	\
    (This)->lpVtbl -> AddStream(This,wStreamNum)

#define IWMMutualExclusion2_RemoveStream(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStream(This,wStreamNum)


#define IWMMutualExclusion2_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMMutualExclusion2_SetType(This,guidType)	\
    (This)->lpVtbl -> SetType(This,guidType)


#define IWMMutualExclusion2_GetName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetName(This,pwszName,pcchName)

#define IWMMutualExclusion2_SetName(This,pwszName)	\
    (This)->lpVtbl -> SetName(This,pwszName)

#define IWMMutualExclusion2_GetRecordCount(This,pwRecordCount)	\
    (This)->lpVtbl -> GetRecordCount(This,pwRecordCount)

#define IWMMutualExclusion2_AddRecord(This)	\
    (This)->lpVtbl -> AddRecord(This)

#define IWMMutualExclusion2_RemoveRecord(This,wRecordNumber)	\
    (This)->lpVtbl -> RemoveRecord(This,wRecordNumber)

#define IWMMutualExclusion2_GetRecordName(This,wRecordNumber,pwszRecordName,pcchRecordName)	\
    (This)->lpVtbl -> GetRecordName(This,wRecordNumber,pwszRecordName,pcchRecordName)

#define IWMMutualExclusion2_SetRecordName(This,wRecordNumber,pwszRecordName)	\
    (This)->lpVtbl -> SetRecordName(This,wRecordNumber,pwszRecordName)

#define IWMMutualExclusion2_GetStreamsForRecord(This,wRecordNumber,pwStreamNumArray,pcStreams)	\
    (This)->lpVtbl -> GetStreamsForRecord(This,wRecordNumber,pwStreamNumArray,pcStreams)

#define IWMMutualExclusion2_AddStreamForRecord(This,wRecordNumber,wStreamNumber)	\
    (This)->lpVtbl -> AddStreamForRecord(This,wRecordNumber,wStreamNumber)

#define IWMMutualExclusion2_RemoveStreamForRecord(This,wRecordNumber,wStreamNumber)	\
    (This)->lpVtbl -> RemoveStreamForRecord(This,wRecordNumber,wStreamNumber)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMMutualExclusion2_GetName_Proxy( 
    IWMMutualExclusion2 * This,
    /* [out] */ WCHAR *pwszName,
    /* [out][in] */ WORD *pcchName);


void __RPC_STUB IWMMutualExclusion2_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion2_SetName_Proxy( 
    IWMMutualExclusion2 * This,
    /* [in] */ WCHAR *pwszName);


void __RPC_STUB IWMMutualExclusion2_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion2_GetRecordCount_Proxy( 
    IWMMutualExclusion2 * This,
    /* [out] */ WORD *pwRecordCount);


void __RPC_STUB IWMMutualExclusion2_GetRecordCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion2_AddRecord_Proxy( 
    IWMMutualExclusion2 * This);


void __RPC_STUB IWMMutualExclusion2_AddRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion2_RemoveRecord_Proxy( 
    IWMMutualExclusion2 * This,
    /* [in] */ WORD wRecordNumber);


void __RPC_STUB IWMMutualExclusion2_RemoveRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion2_GetRecordName_Proxy( 
    IWMMutualExclusion2 * This,
    /* [in] */ WORD wRecordNumber,
    /* [out] */ WCHAR *pwszRecordName,
    /* [out][in] */ WORD *pcchRecordName);


void __RPC_STUB IWMMutualExclusion2_GetRecordName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion2_SetRecordName_Proxy( 
    IWMMutualExclusion2 * This,
    /* [in] */ WORD wRecordNumber,
    /* [in] */ WCHAR *pwszRecordName);


void __RPC_STUB IWMMutualExclusion2_SetRecordName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion2_GetStreamsForRecord_Proxy( 
    IWMMutualExclusion2 * This,
    /* [in] */ WORD wRecordNumber,
    /* [out] */ WORD *pwStreamNumArray,
    /* [out][in] */ WORD *pcStreams);


void __RPC_STUB IWMMutualExclusion2_GetStreamsForRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion2_AddStreamForRecord_Proxy( 
    IWMMutualExclusion2 * This,
    /* [in] */ WORD wRecordNumber,
    /* [in] */ WORD wStreamNumber);


void __RPC_STUB IWMMutualExclusion2_AddStreamForRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion2_RemoveStreamForRecord_Proxy( 
    IWMMutualExclusion2 * This,
    /* [in] */ WORD wRecordNumber,
    /* [in] */ WORD wStreamNumber);


void __RPC_STUB IWMMutualExclusion2_RemoveStreamForRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMMutualExclusion2_INTERFACE_DEFINED__ */


#ifndef __IWMBandwidthSharing_INTERFACE_DEFINED__
#define __IWMBandwidthSharing_INTERFACE_DEFINED__

/* interface IWMBandwidthSharing */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMBandwidthSharing;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AD694AF1-F8D9-42F8-BC47-70311B0C4F9E")
    IWMBandwidthSharing : public IWMStreamList
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID *pguidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetType( 
            /* [in] */ REFGUID guidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBandwidth( 
            /* [out] */ DWORD *pdwBitrate,
            /* [out] */ DWORD *pmsBufferWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBandwidth( 
            /* [in] */ DWORD dwBitrate,
            /* [in] */ DWORD msBufferWindow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMBandwidthSharingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMBandwidthSharing * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMBandwidthSharing * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMBandwidthSharing * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreams )( 
            IWMBandwidthSharing * This,
            /* [out] */ WORD *pwStreamNumArray,
            /* [out][in] */ WORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *AddStream )( 
            IWMBandwidthSharing * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStream )( 
            IWMBandwidthSharing * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IWMBandwidthSharing * This,
            /* [out] */ GUID *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE *SetType )( 
            IWMBandwidthSharing * This,
            /* [in] */ REFGUID guidType);
        
        HRESULT ( STDMETHODCALLTYPE *GetBandwidth )( 
            IWMBandwidthSharing * This,
            /* [out] */ DWORD *pdwBitrate,
            /* [out] */ DWORD *pmsBufferWindow);
        
        HRESULT ( STDMETHODCALLTYPE *SetBandwidth )( 
            IWMBandwidthSharing * This,
            /* [in] */ DWORD dwBitrate,
            /* [in] */ DWORD msBufferWindow);
        
        END_INTERFACE
    } IWMBandwidthSharingVtbl;

    interface IWMBandwidthSharing
    {
        CONST_VTBL struct IWMBandwidthSharingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMBandwidthSharing_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMBandwidthSharing_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMBandwidthSharing_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMBandwidthSharing_GetStreams(This,pwStreamNumArray,pcStreams)	\
    (This)->lpVtbl -> GetStreams(This,pwStreamNumArray,pcStreams)

#define IWMBandwidthSharing_AddStream(This,wStreamNum)	\
    (This)->lpVtbl -> AddStream(This,wStreamNum)

#define IWMBandwidthSharing_RemoveStream(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStream(This,wStreamNum)


#define IWMBandwidthSharing_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMBandwidthSharing_SetType(This,guidType)	\
    (This)->lpVtbl -> SetType(This,guidType)

#define IWMBandwidthSharing_GetBandwidth(This,pdwBitrate,pmsBufferWindow)	\
    (This)->lpVtbl -> GetBandwidth(This,pdwBitrate,pmsBufferWindow)

#define IWMBandwidthSharing_SetBandwidth(This,dwBitrate,msBufferWindow)	\
    (This)->lpVtbl -> SetBandwidth(This,dwBitrate,msBufferWindow)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMBandwidthSharing_GetType_Proxy( 
    IWMBandwidthSharing * This,
    /* [out] */ GUID *pguidType);


void __RPC_STUB IWMBandwidthSharing_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBandwidthSharing_SetType_Proxy( 
    IWMBandwidthSharing * This,
    /* [in] */ REFGUID guidType);


void __RPC_STUB IWMBandwidthSharing_SetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBandwidthSharing_GetBandwidth_Proxy( 
    IWMBandwidthSharing * This,
    /* [out] */ DWORD *pdwBitrate,
    /* [out] */ DWORD *pmsBufferWindow);


void __RPC_STUB IWMBandwidthSharing_GetBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBandwidthSharing_SetBandwidth_Proxy( 
    IWMBandwidthSharing * This,
    /* [in] */ DWORD dwBitrate,
    /* [in] */ DWORD msBufferWindow);


void __RPC_STUB IWMBandwidthSharing_SetBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMBandwidthSharing_INTERFACE_DEFINED__ */


#ifndef __IWMStreamPrioritization_INTERFACE_DEFINED__
#define __IWMStreamPrioritization_INTERFACE_DEFINED__

/* interface IWMStreamPrioritization */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStreamPrioritization;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8C1C6090-F9A8-4748-8EC3-DD1108BA1E77")
    IWMStreamPrioritization : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPriorityRecords( 
            /* [out] */ WM_STREAM_PRIORITY_RECORD *pRecordArray,
            /* [out] */ WORD *pcRecords) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPriorityRecords( 
            /* [in] */ WM_STREAM_PRIORITY_RECORD *pRecordArray,
            /* [in] */ WORD cRecords) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStreamPrioritizationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMStreamPrioritization * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMStreamPrioritization * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMStreamPrioritization * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPriorityRecords )( 
            IWMStreamPrioritization * This,
            /* [out] */ WM_STREAM_PRIORITY_RECORD *pRecordArray,
            /* [out] */ WORD *pcRecords);
        
        HRESULT ( STDMETHODCALLTYPE *SetPriorityRecords )( 
            IWMStreamPrioritization * This,
            /* [in] */ WM_STREAM_PRIORITY_RECORD *pRecordArray,
            /* [in] */ WORD cRecords);
        
        END_INTERFACE
    } IWMStreamPrioritizationVtbl;

    interface IWMStreamPrioritization
    {
        CONST_VTBL struct IWMStreamPrioritizationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStreamPrioritization_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMStreamPrioritization_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMStreamPrioritization_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMStreamPrioritization_GetPriorityRecords(This,pRecordArray,pcRecords)	\
    (This)->lpVtbl -> GetPriorityRecords(This,pRecordArray,pcRecords)

#define IWMStreamPrioritization_SetPriorityRecords(This,pRecordArray,cRecords)	\
    (This)->lpVtbl -> SetPriorityRecords(This,pRecordArray,cRecords)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMStreamPrioritization_GetPriorityRecords_Proxy( 
    IWMStreamPrioritization * This,
    /* [out] */ WM_STREAM_PRIORITY_RECORD *pRecordArray,
    /* [out] */ WORD *pcRecords);


void __RPC_STUB IWMStreamPrioritization_GetPriorityRecords_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamPrioritization_SetPriorityRecords_Proxy( 
    IWMStreamPrioritization * This,
    /* [in] */ WM_STREAM_PRIORITY_RECORD *pRecordArray,
    /* [in] */ WORD cRecords);


void __RPC_STUB IWMStreamPrioritization_SetPriorityRecords_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMStreamPrioritization_INTERFACE_DEFINED__ */


#ifndef __IWMWriterAdvanced_INTERFACE_DEFINED__
#define __IWMWriterAdvanced_INTERFACE_DEFINED__

/* interface IWMWriterAdvanced */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE3-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSinkCount( 
            /* [out] */ DWORD *pcSinks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSink( 
            /* [in] */ DWORD dwSinkNum,
            /* [out] */ IWMWriterSink **ppSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSink( 
            /* [in] */ IWMWriterSink *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveSink( 
            /* [in] */ IWMWriterSink *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteStreamSample( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD msSampleSendTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLiveSource( 
            BOOL fIsLiveSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRealTime( 
            /* [out] */ BOOL *pfRealTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWriterTime( 
            /* [out] */ QWORD *pcnsCurrentTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS *pStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSyncTolerance( 
            /* [in] */ DWORD msWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSyncTolerance( 
            /* [out] */ DWORD *pmsWindow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterAdvanced * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterAdvanced * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterAdvanced * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSinkCount )( 
            IWMWriterAdvanced * This,
            /* [out] */ DWORD *pcSinks);
        
        HRESULT ( STDMETHODCALLTYPE *GetSink )( 
            IWMWriterAdvanced * This,
            /* [in] */ DWORD dwSinkNum,
            /* [out] */ IWMWriterSink **ppSink);
        
        HRESULT ( STDMETHODCALLTYPE *AddSink )( 
            IWMWriterAdvanced * This,
            /* [in] */ IWMWriterSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveSink )( 
            IWMWriterAdvanced * This,
            /* [in] */ IWMWriterSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *WriteStreamSample )( 
            IWMWriterAdvanced * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD msSampleSendTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample);
        
        HRESULT ( STDMETHODCALLTYPE *SetLiveSource )( 
            IWMWriterAdvanced * This,
            BOOL fIsLiveSource);
        
        HRESULT ( STDMETHODCALLTYPE *IsRealTime )( 
            IWMWriterAdvanced * This,
            /* [out] */ BOOL *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetWriterTime )( 
            IWMWriterAdvanced * This,
            /* [out] */ QWORD *pcnsCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatistics )( 
            IWMWriterAdvanced * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS *pStats);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncTolerance )( 
            IWMWriterAdvanced * This,
            /* [in] */ DWORD msWindow);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncTolerance )( 
            IWMWriterAdvanced * This,
            /* [out] */ DWORD *pmsWindow);
        
        END_INTERFACE
    } IWMWriterAdvancedVtbl;

    interface IWMWriterAdvanced
    {
        CONST_VTBL struct IWMWriterAdvancedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterAdvanced_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterAdvanced_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterAdvanced_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterAdvanced_GetSinkCount(This,pcSinks)	\
    (This)->lpVtbl -> GetSinkCount(This,pcSinks)

#define IWMWriterAdvanced_GetSink(This,dwSinkNum,ppSink)	\
    (This)->lpVtbl -> GetSink(This,dwSinkNum,ppSink)

#define IWMWriterAdvanced_AddSink(This,pSink)	\
    (This)->lpVtbl -> AddSink(This,pSink)

#define IWMWriterAdvanced_RemoveSink(This,pSink)	\
    (This)->lpVtbl -> RemoveSink(This,pSink)

#define IWMWriterAdvanced_WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)	\
    (This)->lpVtbl -> WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)

#define IWMWriterAdvanced_SetLiveSource(This,fIsLiveSource)	\
    (This)->lpVtbl -> SetLiveSource(This,fIsLiveSource)

#define IWMWriterAdvanced_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterAdvanced_GetWriterTime(This,pcnsCurrentTime)	\
    (This)->lpVtbl -> GetWriterTime(This,pcnsCurrentTime)

#define IWMWriterAdvanced_GetStatistics(This,wStreamNum,pStats)	\
    (This)->lpVtbl -> GetStatistics(This,wStreamNum,pStats)

#define IWMWriterAdvanced_SetSyncTolerance(This,msWindow)	\
    (This)->lpVtbl -> SetSyncTolerance(This,msWindow)

#define IWMWriterAdvanced_GetSyncTolerance(This,pmsWindow)	\
    (This)->lpVtbl -> GetSyncTolerance(This,pmsWindow)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetSinkCount_Proxy( 
    IWMWriterAdvanced * This,
    /* [out] */ DWORD *pcSinks);


void __RPC_STUB IWMWriterAdvanced_GetSinkCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetSink_Proxy( 
    IWMWriterAdvanced * This,
    /* [in] */ DWORD dwSinkNum,
    /* [out] */ IWMWriterSink **ppSink);


void __RPC_STUB IWMWriterAdvanced_GetSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_AddSink_Proxy( 
    IWMWriterAdvanced * This,
    /* [in] */ IWMWriterSink *pSink);


void __RPC_STUB IWMWriterAdvanced_AddSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_RemoveSink_Proxy( 
    IWMWriterAdvanced * This,
    /* [in] */ IWMWriterSink *pSink);


void __RPC_STUB IWMWriterAdvanced_RemoveSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_WriteStreamSample_Proxy( 
    IWMWriterAdvanced * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ DWORD msSampleSendTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer *pSample);


void __RPC_STUB IWMWriterAdvanced_WriteStreamSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_SetLiveSource_Proxy( 
    IWMWriterAdvanced * This,
    BOOL fIsLiveSource);


void __RPC_STUB IWMWriterAdvanced_SetLiveSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_IsRealTime_Proxy( 
    IWMWriterAdvanced * This,
    /* [out] */ BOOL *pfRealTime);


void __RPC_STUB IWMWriterAdvanced_IsRealTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetWriterTime_Proxy( 
    IWMWriterAdvanced * This,
    /* [out] */ QWORD *pcnsCurrentTime);


void __RPC_STUB IWMWriterAdvanced_GetWriterTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetStatistics_Proxy( 
    IWMWriterAdvanced * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ WM_WRITER_STATISTICS *pStats);


void __RPC_STUB IWMWriterAdvanced_GetStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_SetSyncTolerance_Proxy( 
    IWMWriterAdvanced * This,
    /* [in] */ DWORD msWindow);


void __RPC_STUB IWMWriterAdvanced_SetSyncTolerance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetSyncTolerance_Proxy( 
    IWMWriterAdvanced * This,
    /* [out] */ DWORD *pmsWindow);


void __RPC_STUB IWMWriterAdvanced_GetSyncTolerance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterAdvanced_INTERFACE_DEFINED__ */


#ifndef __IWMWriterAdvanced2_INTERFACE_DEFINED__
#define __IWMWriterAdvanced2_INTERFACE_DEFINED__

/* interface IWMWriterAdvanced2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterAdvanced2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("962dc1ec-c046-4db8-9cc7-26ceae500817")
    IWMWriterAdvanced2 : public IWMWriterAdvanced
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInputSetting( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputSetting( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterAdvanced2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterAdvanced2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterAdvanced2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterAdvanced2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSinkCount )( 
            IWMWriterAdvanced2 * This,
            /* [out] */ DWORD *pcSinks);
        
        HRESULT ( STDMETHODCALLTYPE *GetSink )( 
            IWMWriterAdvanced2 * This,
            /* [in] */ DWORD dwSinkNum,
            /* [out] */ IWMWriterSink **ppSink);
        
        HRESULT ( STDMETHODCALLTYPE *AddSink )( 
            IWMWriterAdvanced2 * This,
            /* [in] */ IWMWriterSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveSink )( 
            IWMWriterAdvanced2 * This,
            /* [in] */ IWMWriterSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *WriteStreamSample )( 
            IWMWriterAdvanced2 * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD msSampleSendTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample);
        
        HRESULT ( STDMETHODCALLTYPE *SetLiveSource )( 
            IWMWriterAdvanced2 * This,
            BOOL fIsLiveSource);
        
        HRESULT ( STDMETHODCALLTYPE *IsRealTime )( 
            IWMWriterAdvanced2 * This,
            /* [out] */ BOOL *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetWriterTime )( 
            IWMWriterAdvanced2 * This,
            /* [out] */ QWORD *pcnsCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatistics )( 
            IWMWriterAdvanced2 * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS *pStats);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncTolerance )( 
            IWMWriterAdvanced2 * This,
            /* [in] */ DWORD msWindow);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncTolerance )( 
            IWMWriterAdvanced2 * This,
            /* [out] */ DWORD *pmsWindow);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputSetting )( 
            IWMWriterAdvanced2 * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetInputSetting )( 
            IWMWriterAdvanced2 * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength);
        
        END_INTERFACE
    } IWMWriterAdvanced2Vtbl;

    interface IWMWriterAdvanced2
    {
        CONST_VTBL struct IWMWriterAdvanced2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterAdvanced2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterAdvanced2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterAdvanced2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterAdvanced2_GetSinkCount(This,pcSinks)	\
    (This)->lpVtbl -> GetSinkCount(This,pcSinks)

#define IWMWriterAdvanced2_GetSink(This,dwSinkNum,ppSink)	\
    (This)->lpVtbl -> GetSink(This,dwSinkNum,ppSink)

#define IWMWriterAdvanced2_AddSink(This,pSink)	\
    (This)->lpVtbl -> AddSink(This,pSink)

#define IWMWriterAdvanced2_RemoveSink(This,pSink)	\
    (This)->lpVtbl -> RemoveSink(This,pSink)

#define IWMWriterAdvanced2_WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)	\
    (This)->lpVtbl -> WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)

#define IWMWriterAdvanced2_SetLiveSource(This,fIsLiveSource)	\
    (This)->lpVtbl -> SetLiveSource(This,fIsLiveSource)

#define IWMWriterAdvanced2_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterAdvanced2_GetWriterTime(This,pcnsCurrentTime)	\
    (This)->lpVtbl -> GetWriterTime(This,pcnsCurrentTime)

#define IWMWriterAdvanced2_GetStatistics(This,wStreamNum,pStats)	\
    (This)->lpVtbl -> GetStatistics(This,wStreamNum,pStats)

#define IWMWriterAdvanced2_SetSyncTolerance(This,msWindow)	\
    (This)->lpVtbl -> SetSyncTolerance(This,msWindow)

#define IWMWriterAdvanced2_GetSyncTolerance(This,pmsWindow)	\
    (This)->lpVtbl -> GetSyncTolerance(This,pmsWindow)


#define IWMWriterAdvanced2_GetInputSetting(This,dwInputNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetInputSetting(This,dwInputNum,pszName,pType,pValue,pcbLength)

#define IWMWriterAdvanced2_SetInputSetting(This,dwInputNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetInputSetting(This,dwInputNum,pszName,Type,pValue,cbLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterAdvanced2_GetInputSetting_Proxy( 
    IWMWriterAdvanced2 * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE *pType,
    /* [out] */ BYTE *pValue,
    /* [out][in] */ WORD *pcbLength);


void __RPC_STUB IWMWriterAdvanced2_GetInputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced2_SetInputSetting_Proxy( 
    IWMWriterAdvanced2 * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMWriterAdvanced2_SetInputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterAdvanced2_INTERFACE_DEFINED__ */


#ifndef __IWMWriterAdvanced3_INTERFACE_DEFINED__
#define __IWMWriterAdvanced3_INTERFACE_DEFINED__

/* interface IWMWriterAdvanced3 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterAdvanced3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2cd6492d-7c37-4e76-9d3b-59261183a22e")
    IWMWriterAdvanced3 : public IWMWriterAdvanced2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStatisticsEx( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS_EX *pStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNonBlocking( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterAdvanced3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterAdvanced3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterAdvanced3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterAdvanced3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSinkCount )( 
            IWMWriterAdvanced3 * This,
            /* [out] */ DWORD *pcSinks);
        
        HRESULT ( STDMETHODCALLTYPE *GetSink )( 
            IWMWriterAdvanced3 * This,
            /* [in] */ DWORD dwSinkNum,
            /* [out] */ IWMWriterSink **ppSink);
        
        HRESULT ( STDMETHODCALLTYPE *AddSink )( 
            IWMWriterAdvanced3 * This,
            /* [in] */ IWMWriterSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveSink )( 
            IWMWriterAdvanced3 * This,
            /* [in] */ IWMWriterSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *WriteStreamSample )( 
            IWMWriterAdvanced3 * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD msSampleSendTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample);
        
        HRESULT ( STDMETHODCALLTYPE *SetLiveSource )( 
            IWMWriterAdvanced3 * This,
            BOOL fIsLiveSource);
        
        HRESULT ( STDMETHODCALLTYPE *IsRealTime )( 
            IWMWriterAdvanced3 * This,
            /* [out] */ BOOL *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetWriterTime )( 
            IWMWriterAdvanced3 * This,
            /* [out] */ QWORD *pcnsCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatistics )( 
            IWMWriterAdvanced3 * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS *pStats);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncTolerance )( 
            IWMWriterAdvanced3 * This,
            /* [in] */ DWORD msWindow);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncTolerance )( 
            IWMWriterAdvanced3 * This,
            /* [out] */ DWORD *pmsWindow);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputSetting )( 
            IWMWriterAdvanced3 * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetInputSetting )( 
            IWMWriterAdvanced3 * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatisticsEx )( 
            IWMWriterAdvanced3 * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS_EX *pStats);
        
        HRESULT ( STDMETHODCALLTYPE *SetNonBlocking )( 
            IWMWriterAdvanced3 * This);
        
        END_INTERFACE
    } IWMWriterAdvanced3Vtbl;

    interface IWMWriterAdvanced3
    {
        CONST_VTBL struct IWMWriterAdvanced3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterAdvanced3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterAdvanced3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterAdvanced3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterAdvanced3_GetSinkCount(This,pcSinks)	\
    (This)->lpVtbl -> GetSinkCount(This,pcSinks)

#define IWMWriterAdvanced3_GetSink(This,dwSinkNum,ppSink)	\
    (This)->lpVtbl -> GetSink(This,dwSinkNum,ppSink)

#define IWMWriterAdvanced3_AddSink(This,pSink)	\
    (This)->lpVtbl -> AddSink(This,pSink)

#define IWMWriterAdvanced3_RemoveSink(This,pSink)	\
    (This)->lpVtbl -> RemoveSink(This,pSink)

#define IWMWriterAdvanced3_WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)	\
    (This)->lpVtbl -> WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)

#define IWMWriterAdvanced3_SetLiveSource(This,fIsLiveSource)	\
    (This)->lpVtbl -> SetLiveSource(This,fIsLiveSource)

#define IWMWriterAdvanced3_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterAdvanced3_GetWriterTime(This,pcnsCurrentTime)	\
    (This)->lpVtbl -> GetWriterTime(This,pcnsCurrentTime)

#define IWMWriterAdvanced3_GetStatistics(This,wStreamNum,pStats)	\
    (This)->lpVtbl -> GetStatistics(This,wStreamNum,pStats)

#define IWMWriterAdvanced3_SetSyncTolerance(This,msWindow)	\
    (This)->lpVtbl -> SetSyncTolerance(This,msWindow)

#define IWMWriterAdvanced3_GetSyncTolerance(This,pmsWindow)	\
    (This)->lpVtbl -> GetSyncTolerance(This,pmsWindow)


#define IWMWriterAdvanced3_GetInputSetting(This,dwInputNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetInputSetting(This,dwInputNum,pszName,pType,pValue,pcbLength)

#define IWMWriterAdvanced3_SetInputSetting(This,dwInputNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetInputSetting(This,dwInputNum,pszName,Type,pValue,cbLength)


#define IWMWriterAdvanced3_GetStatisticsEx(This,wStreamNum,pStats)	\
    (This)->lpVtbl -> GetStatisticsEx(This,wStreamNum,pStats)

#define IWMWriterAdvanced3_SetNonBlocking(This)	\
    (This)->lpVtbl -> SetNonBlocking(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterAdvanced3_GetStatisticsEx_Proxy( 
    IWMWriterAdvanced3 * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ WM_WRITER_STATISTICS_EX *pStats);


void __RPC_STUB IWMWriterAdvanced3_GetStatisticsEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced3_SetNonBlocking_Proxy( 
    IWMWriterAdvanced3 * This);


void __RPC_STUB IWMWriterAdvanced3_SetNonBlocking_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterAdvanced3_INTERFACE_DEFINED__ */


#ifndef __IWMWriterPreprocess_INTERFACE_DEFINED__
#define __IWMWriterPreprocess_INTERFACE_DEFINED__

/* interface IWMWriterPreprocess */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterPreprocess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fc54a285-38c4-45b5-aa23-85b9f7cb424b")
    IWMWriterPreprocess : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMaxPreprocessingPasses( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ DWORD dwFlags,
            /* [out] */ DWORD *pdwMaxNumPasses) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNumPreprocessingPasses( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwNumPasses) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginPreprocessingPass( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PreprocessSample( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndPreprocessingPass( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterPreprocessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterPreprocess * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterPreprocess * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterPreprocess * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxPreprocessingPasses )( 
            IWMWriterPreprocess * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ DWORD dwFlags,
            /* [out] */ DWORD *pdwMaxNumPasses);
        
        HRESULT ( STDMETHODCALLTYPE *SetNumPreprocessingPasses )( 
            IWMWriterPreprocess * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwNumPasses);
        
        HRESULT ( STDMETHODCALLTYPE *BeginPreprocessingPass )( 
            IWMWriterPreprocess * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *PreprocessSample )( 
            IWMWriterPreprocess * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample);
        
        HRESULT ( STDMETHODCALLTYPE *EndPreprocessingPass )( 
            IWMWriterPreprocess * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IWMWriterPreprocessVtbl;

    interface IWMWriterPreprocess
    {
        CONST_VTBL struct IWMWriterPreprocessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterPreprocess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterPreprocess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterPreprocess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterPreprocess_GetMaxPreprocessingPasses(This,dwInputNum,dwFlags,pdwMaxNumPasses)	\
    (This)->lpVtbl -> GetMaxPreprocessingPasses(This,dwInputNum,dwFlags,pdwMaxNumPasses)

#define IWMWriterPreprocess_SetNumPreprocessingPasses(This,dwInputNum,dwFlags,dwNumPasses)	\
    (This)->lpVtbl -> SetNumPreprocessingPasses(This,dwInputNum,dwFlags,dwNumPasses)

#define IWMWriterPreprocess_BeginPreprocessingPass(This,dwInputNum,dwFlags)	\
    (This)->lpVtbl -> BeginPreprocessingPass(This,dwInputNum,dwFlags)

#define IWMWriterPreprocess_PreprocessSample(This,dwInputNum,cnsSampleTime,dwFlags,pSample)	\
    (This)->lpVtbl -> PreprocessSample(This,dwInputNum,cnsSampleTime,dwFlags,pSample)

#define IWMWriterPreprocess_EndPreprocessingPass(This,dwInputNum,dwFlags)	\
    (This)->lpVtbl -> EndPreprocessingPass(This,dwInputNum,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterPreprocess_GetMaxPreprocessingPasses_Proxy( 
    IWMWriterPreprocess * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ DWORD dwFlags,
    /* [out] */ DWORD *pdwMaxNumPasses);


void __RPC_STUB IWMWriterPreprocess_GetMaxPreprocessingPasses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPreprocess_SetNumPreprocessingPasses_Proxy( 
    IWMWriterPreprocess * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwNumPasses);


void __RPC_STUB IWMWriterPreprocess_SetNumPreprocessingPasses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPreprocess_BeginPreprocessingPass_Proxy( 
    IWMWriterPreprocess * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IWMWriterPreprocess_BeginPreprocessingPass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPreprocess_PreprocessSample_Proxy( 
    IWMWriterPreprocess * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer *pSample);


void __RPC_STUB IWMWriterPreprocess_PreprocessSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPreprocess_EndPreprocessingPass_Proxy( 
    IWMWriterPreprocess * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IWMWriterPreprocess_EndPreprocessingPass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterPreprocess_INTERFACE_DEFINED__ */


#ifndef __IWMWriterPostViewCallback_INTERFACE_DEFINED__
#define __IWMWriterPostViewCallback_INTERFACE_DEFINED__

/* interface IWMWriterPostViewCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterPostViewCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D9D6549D-A193-4f24-B308-03123D9B7F8D")
    IWMWriterPostViewCallback : public IWMStatusCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnPostViewSample( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForPostView( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [in] */ void *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterPostViewCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterPostViewCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterPostViewCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterPostViewCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStatus )( 
            IWMWriterPostViewCallback * This,
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE *pValue,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *OnPostViewSample )( 
            IWMWriterPostViewCallback * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateForPostView )( 
            IWMWriterPostViewCallback * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [in] */ void *pvContext);
        
        END_INTERFACE
    } IWMWriterPostViewCallbackVtbl;

    interface IWMWriterPostViewCallback
    {
        CONST_VTBL struct IWMWriterPostViewCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterPostViewCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterPostViewCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterPostViewCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterPostViewCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext)


#define IWMWriterPostViewCallback_OnPostViewSample(This,wStreamNumber,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)	\
    (This)->lpVtbl -> OnPostViewSample(This,wStreamNumber,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)

#define IWMWriterPostViewCallback_AllocateForPostView(This,wStreamNum,cbBuffer,ppBuffer,pvContext)	\
    (This)->lpVtbl -> AllocateForPostView(This,wStreamNum,cbBuffer,ppBuffer,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterPostViewCallback_OnPostViewSample_Proxy( 
    IWMWriterPostViewCallback * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer *pSample,
    /* [in] */ void *pvContext);


void __RPC_STUB IWMWriterPostViewCallback_OnPostViewSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostViewCallback_AllocateForPostView_Proxy( 
    IWMWriterPostViewCallback * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer **ppBuffer,
    /* [in] */ void *pvContext);


void __RPC_STUB IWMWriterPostViewCallback_AllocateForPostView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterPostViewCallback_INTERFACE_DEFINED__ */


#ifndef __IWMWriterPostView_INTERFACE_DEFINED__
#define __IWMWriterPostView_INTERFACE_DEFINED__

/* interface IWMWriterPostView */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterPostView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("81E20CE4-75EF-491a-8004-FC53C45BDC3E")
    IWMWriterPostView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPostViewCallback( 
            IWMWriterPostViewCallback *pCallback,
            void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReceivePostViewSamples( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceivePostViewSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReceivePostViewSamples( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL *pfReceivePostViewSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPostViewProps( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IWMMediaProps **ppOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPostViewProps( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ IWMMediaProps *pOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPostViewFormatCount( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ DWORD *pcFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPostViewFormat( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMMediaProps **ppProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllocateForPostView( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ BOOL fAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocateForPostView( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ BOOL *pfAllocate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterPostViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterPostView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterPostView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterPostView * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPostViewCallback )( 
            IWMWriterPostView * This,
            IWMWriterPostViewCallback *pCallback,
            void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetReceivePostViewSamples )( 
            IWMWriterPostView * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceivePostViewSamples);
        
        HRESULT ( STDMETHODCALLTYPE *GetReceivePostViewSamples )( 
            IWMWriterPostView * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL *pfReceivePostViewSamples);
        
        HRESULT ( STDMETHODCALLTYPE *GetPostViewProps )( 
            IWMWriterPostView * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IWMMediaProps **ppOutput);
        
        HRESULT ( STDMETHODCALLTYPE *SetPostViewProps )( 
            IWMWriterPostView * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ IWMMediaProps *pOutput);
        
        HRESULT ( STDMETHODCALLTYPE *GetPostViewFormatCount )( 
            IWMWriterPostView * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ DWORD *pcFormats);
        
        HRESULT ( STDMETHODCALLTYPE *GetPostViewFormat )( 
            IWMWriterPostView * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMMediaProps **ppProps);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllocateForPostView )( 
            IWMWriterPostView * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocateForPostView )( 
            IWMWriterPostView * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ BOOL *pfAllocate);
        
        END_INTERFACE
    } IWMWriterPostViewVtbl;

    interface IWMWriterPostView
    {
        CONST_VTBL struct IWMWriterPostViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterPostView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterPostView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterPostView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterPostView_SetPostViewCallback(This,pCallback,pvContext)	\
    (This)->lpVtbl -> SetPostViewCallback(This,pCallback,pvContext)

#define IWMWriterPostView_SetReceivePostViewSamples(This,wStreamNum,fReceivePostViewSamples)	\
    (This)->lpVtbl -> SetReceivePostViewSamples(This,wStreamNum,fReceivePostViewSamples)

#define IWMWriterPostView_GetReceivePostViewSamples(This,wStreamNum,pfReceivePostViewSamples)	\
    (This)->lpVtbl -> GetReceivePostViewSamples(This,wStreamNum,pfReceivePostViewSamples)

#define IWMWriterPostView_GetPostViewProps(This,wStreamNumber,ppOutput)	\
    (This)->lpVtbl -> GetPostViewProps(This,wStreamNumber,ppOutput)

#define IWMWriterPostView_SetPostViewProps(This,wStreamNumber,pOutput)	\
    (This)->lpVtbl -> SetPostViewProps(This,wStreamNumber,pOutput)

#define IWMWriterPostView_GetPostViewFormatCount(This,wStreamNumber,pcFormats)	\
    (This)->lpVtbl -> GetPostViewFormatCount(This,wStreamNumber,pcFormats)

#define IWMWriterPostView_GetPostViewFormat(This,wStreamNumber,dwFormatNumber,ppProps)	\
    (This)->lpVtbl -> GetPostViewFormat(This,wStreamNumber,dwFormatNumber,ppProps)

#define IWMWriterPostView_SetAllocateForPostView(This,wStreamNumber,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForPostView(This,wStreamNumber,fAllocate)

#define IWMWriterPostView_GetAllocateForPostView(This,wStreamNumber,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForPostView(This,wStreamNumber,pfAllocate)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterPostView_SetPostViewCallback_Proxy( 
    IWMWriterPostView * This,
    IWMWriterPostViewCallback *pCallback,
    void *pvContext);


void __RPC_STUB IWMWriterPostView_SetPostViewCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_SetReceivePostViewSamples_Proxy( 
    IWMWriterPostView * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ BOOL fReceivePostViewSamples);


void __RPC_STUB IWMWriterPostView_SetReceivePostViewSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetReceivePostViewSamples_Proxy( 
    IWMWriterPostView * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ BOOL *pfReceivePostViewSamples);


void __RPC_STUB IWMWriterPostView_GetReceivePostViewSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetPostViewProps_Proxy( 
    IWMWriterPostView * This,
    /* [in] */ WORD wStreamNumber,
    /* [out] */ IWMMediaProps **ppOutput);


void __RPC_STUB IWMWriterPostView_GetPostViewProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_SetPostViewProps_Proxy( 
    IWMWriterPostView * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ IWMMediaProps *pOutput);


void __RPC_STUB IWMWriterPostView_SetPostViewProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetPostViewFormatCount_Proxy( 
    IWMWriterPostView * This,
    /* [in] */ WORD wStreamNumber,
    /* [out] */ DWORD *pcFormats);


void __RPC_STUB IWMWriterPostView_GetPostViewFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetPostViewFormat_Proxy( 
    IWMWriterPostView * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ DWORD dwFormatNumber,
    /* [out] */ IWMMediaProps **ppProps);


void __RPC_STUB IWMWriterPostView_GetPostViewFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_SetAllocateForPostView_Proxy( 
    IWMWriterPostView * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ BOOL fAllocate);


void __RPC_STUB IWMWriterPostView_SetAllocateForPostView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetAllocateForPostView_Proxy( 
    IWMWriterPostView * This,
    /* [in] */ WORD wStreamNumber,
    /* [out] */ BOOL *pfAllocate);


void __RPC_STUB IWMWriterPostView_GetAllocateForPostView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterPostView_INTERFACE_DEFINED__ */


#ifndef __IWMWriterSink_INTERFACE_DEFINED__
#define __IWMWriterSink_INTERFACE_DEFINED__

/* interface IWMWriterSink */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE4-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnHeader( 
            /* [in] */ INSSBuffer *pHeader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRealTime( 
            /* [out] */ BOOL *pfRealTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateDataUnit( 
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer **ppDataUnit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDataUnit( 
            /* [in] */ INSSBuffer *pDataUnit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndWriting( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnHeader )( 
            IWMWriterSink * This,
            /* [in] */ INSSBuffer *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE *IsRealTime )( 
            IWMWriterSink * This,
            /* [out] */ BOOL *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateDataUnit )( 
            IWMWriterSink * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer **ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *OnDataUnit )( 
            IWMWriterSink * This,
            /* [in] */ INSSBuffer *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndWriting )( 
            IWMWriterSink * This);
        
        END_INTERFACE
    } IWMWriterSinkVtbl;

    interface IWMWriterSink
    {
        CONST_VTBL struct IWMWriterSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterSink_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterSink_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterSink_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterSink_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterSink_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterSink_OnHeader_Proxy( 
    IWMWriterSink * This,
    /* [in] */ INSSBuffer *pHeader);


void __RPC_STUB IWMWriterSink_OnHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterSink_IsRealTime_Proxy( 
    IWMWriterSink * This,
    /* [out] */ BOOL *pfRealTime);


void __RPC_STUB IWMWriterSink_IsRealTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterSink_AllocateDataUnit_Proxy( 
    IWMWriterSink * This,
    /* [in] */ DWORD cbDataUnit,
    /* [out] */ INSSBuffer **ppDataUnit);


void __RPC_STUB IWMWriterSink_AllocateDataUnit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterSink_OnDataUnit_Proxy( 
    IWMWriterSink * This,
    /* [in] */ INSSBuffer *pDataUnit);


void __RPC_STUB IWMWriterSink_OnDataUnit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterSink_OnEndWriting_Proxy( 
    IWMWriterSink * This);


void __RPC_STUB IWMWriterSink_OnEndWriting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterSink_INTERFACE_DEFINED__ */


#ifndef __IWMRegisterCallback_INTERFACE_DEFINED__
#define __IWMRegisterCallback_INTERFACE_DEFINED__

/* interface IWMRegisterCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMRegisterCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CF4B1F99-4DE2-4e49-A363-252740D99BC1")
    IWMRegisterCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ IWMStatusCallback *pCallback,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ IWMStatusCallback *pCallback,
            /* [in] */ void *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRegisterCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRegisterCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRegisterCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRegisterCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            IWMRegisterCallback * This,
            /* [in] */ IWMStatusCallback *pCallback,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IWMRegisterCallback * This,
            /* [in] */ IWMStatusCallback *pCallback,
            /* [in] */ void *pvContext);
        
        END_INTERFACE
    } IWMRegisterCallbackVtbl;

    interface IWMRegisterCallback
    {
        CONST_VTBL struct IWMRegisterCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRegisterCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRegisterCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRegisterCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRegisterCallback_Advise(This,pCallback,pvContext)	\
    (This)->lpVtbl -> Advise(This,pCallback,pvContext)

#define IWMRegisterCallback_Unadvise(This,pCallback,pvContext)	\
    (This)->lpVtbl -> Unadvise(This,pCallback,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMRegisterCallback_Advise_Proxy( 
    IWMRegisterCallback * This,
    /* [in] */ IWMStatusCallback *pCallback,
    /* [in] */ void *pvContext);


void __RPC_STUB IWMRegisterCallback_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMRegisterCallback_Unadvise_Proxy( 
    IWMRegisterCallback * This,
    /* [in] */ IWMStatusCallback *pCallback,
    /* [in] */ void *pvContext);


void __RPC_STUB IWMRegisterCallback_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRegisterCallback_INTERFACE_DEFINED__ */


#ifndef __IWMWriterFileSink_INTERFACE_DEFINED__
#define __IWMWriterFileSink_INTERFACE_DEFINED__

/* interface IWMWriterFileSink */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterFileSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE5-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterFileSink : public IWMWriterSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const WCHAR *pwszFilename) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterFileSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterFileSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterFileSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterFileSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnHeader )( 
            IWMWriterFileSink * This,
            /* [in] */ INSSBuffer *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE *IsRealTime )( 
            IWMWriterFileSink * This,
            /* [out] */ BOOL *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateDataUnit )( 
            IWMWriterFileSink * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer **ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *OnDataUnit )( 
            IWMWriterFileSink * This,
            /* [in] */ INSSBuffer *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndWriting )( 
            IWMWriterFileSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IWMWriterFileSink * This,
            /* [in] */ const WCHAR *pwszFilename);
        
        END_INTERFACE
    } IWMWriterFileSinkVtbl;

    interface IWMWriterFileSink
    {
        CONST_VTBL struct IWMWriterFileSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterFileSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterFileSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterFileSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterFileSink_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterFileSink_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterFileSink_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterFileSink_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterFileSink_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)


#define IWMWriterFileSink_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterFileSink_Open_Proxy( 
    IWMWriterFileSink * This,
    /* [in] */ const WCHAR *pwszFilename);


void __RPC_STUB IWMWriterFileSink_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterFileSink_INTERFACE_DEFINED__ */


#ifndef __IWMWriterFileSink2_INTERFACE_DEFINED__
#define __IWMWriterFileSink2_INTERFACE_DEFINED__

/* interface IWMWriterFileSink2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterFileSink2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14282BA7-4AEF-4205-8CE5-C229035A05BC")
    IWMWriterFileSink2 : public IWMWriterFileSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ QWORD cnsStartTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ QWORD cnsStopTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsStopped( 
            /* [out] */ BOOL *pfStopped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileDuration( 
            /* [out] */ QWORD *pcnsDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileSize( 
            /* [out] */ QWORD *pcbFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsClosed( 
            /* [out] */ BOOL *pfClosed) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterFileSink2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterFileSink2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterFileSink2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterFileSink2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnHeader )( 
            IWMWriterFileSink2 * This,
            /* [in] */ INSSBuffer *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE *IsRealTime )( 
            IWMWriterFileSink2 * This,
            /* [out] */ BOOL *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateDataUnit )( 
            IWMWriterFileSink2 * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer **ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *OnDataUnit )( 
            IWMWriterFileSink2 * This,
            /* [in] */ INSSBuffer *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndWriting )( 
            IWMWriterFileSink2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IWMWriterFileSink2 * This,
            /* [in] */ const WCHAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IWMWriterFileSink2 * This,
            /* [in] */ QWORD cnsStartTime);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IWMWriterFileSink2 * This,
            /* [in] */ QWORD cnsStopTime);
        
        HRESULT ( STDMETHODCALLTYPE *IsStopped )( 
            IWMWriterFileSink2 * This,
            /* [out] */ BOOL *pfStopped);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileDuration )( 
            IWMWriterFileSink2 * This,
            /* [out] */ QWORD *pcnsDuration);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileSize )( 
            IWMWriterFileSink2 * This,
            /* [out] */ QWORD *pcbFile);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IWMWriterFileSink2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsClosed )( 
            IWMWriterFileSink2 * This,
            /* [out] */ BOOL *pfClosed);
        
        END_INTERFACE
    } IWMWriterFileSink2Vtbl;

    interface IWMWriterFileSink2
    {
        CONST_VTBL struct IWMWriterFileSink2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterFileSink2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterFileSink2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterFileSink2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterFileSink2_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterFileSink2_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterFileSink2_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterFileSink2_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterFileSink2_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)


#define IWMWriterFileSink2_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)


#define IWMWriterFileSink2_Start(This,cnsStartTime)	\
    (This)->lpVtbl -> Start(This,cnsStartTime)

#define IWMWriterFileSink2_Stop(This,cnsStopTime)	\
    (This)->lpVtbl -> Stop(This,cnsStopTime)

#define IWMWriterFileSink2_IsStopped(This,pfStopped)	\
    (This)->lpVtbl -> IsStopped(This,pfStopped)

#define IWMWriterFileSink2_GetFileDuration(This,pcnsDuration)	\
    (This)->lpVtbl -> GetFileDuration(This,pcnsDuration)

#define IWMWriterFileSink2_GetFileSize(This,pcbFile)	\
    (This)->lpVtbl -> GetFileSize(This,pcbFile)

#define IWMWriterFileSink2_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMWriterFileSink2_IsClosed(This,pfClosed)	\
    (This)->lpVtbl -> IsClosed(This,pfClosed)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_Start_Proxy( 
    IWMWriterFileSink2 * This,
    /* [in] */ QWORD cnsStartTime);


void __RPC_STUB IWMWriterFileSink2_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_Stop_Proxy( 
    IWMWriterFileSink2 * This,
    /* [in] */ QWORD cnsStopTime);


void __RPC_STUB IWMWriterFileSink2_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_IsStopped_Proxy( 
    IWMWriterFileSink2 * This,
    /* [out] */ BOOL *pfStopped);


void __RPC_STUB IWMWriterFileSink2_IsStopped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_GetFileDuration_Proxy( 
    IWMWriterFileSink2 * This,
    /* [out] */ QWORD *pcnsDuration);


void __RPC_STUB IWMWriterFileSink2_GetFileDuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_GetFileSize_Proxy( 
    IWMWriterFileSink2 * This,
    /* [out] */ QWORD *pcbFile);


void __RPC_STUB IWMWriterFileSink2_GetFileSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_Close_Proxy( 
    IWMWriterFileSink2 * This);


void __RPC_STUB IWMWriterFileSink2_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_IsClosed_Proxy( 
    IWMWriterFileSink2 * This,
    /* [out] */ BOOL *pfClosed);


void __RPC_STUB IWMWriterFileSink2_IsClosed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterFileSink2_INTERFACE_DEFINED__ */


#ifndef __IWMWriterFileSinkDataUnit_INTERFACE_DEFINED__
#define __IWMWriterFileSinkDataUnit_INTERFACE_DEFINED__

/* interface IWMWriterFileSinkDataUnit */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterFileSinkDataUnit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("633392F0-BE5C-486B-A09C-10669C7A6C27")
    IWMWriterFileSinkDataUnit : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPacketHeader( 
            /* [out] */ BYTE **ppbPacketHeader,
            /* [out] */ DWORD *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPayloadCount( 
            /* [out] */ DWORD *pcPayloads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPayloadHeader( 
            /* [in] */ DWORD dwPayloadNumber,
            /* [out] */ BYTE **ppbPayloadHeader,
            /* [out] */ DWORD *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPayloadData( 
            /* [in] */ DWORD dwPayloadNumber,
            /* [out] */ BYTE **ppbPayloadHeader,
            /* [out] */ DWORD *pcbPayloadHeader) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterFileSinkDataUnitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterFileSinkDataUnit * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterFileSinkDataUnit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterFileSinkDataUnit * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPacketHeader )( 
            IWMWriterFileSinkDataUnit * This,
            /* [out] */ BYTE **ppbPacketHeader,
            /* [out] */ DWORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetPayloadCount )( 
            IWMWriterFileSinkDataUnit * This,
            /* [out] */ DWORD *pcPayloads);
        
        HRESULT ( STDMETHODCALLTYPE *GetPayloadHeader )( 
            IWMWriterFileSinkDataUnit * This,
            /* [in] */ DWORD dwPayloadNumber,
            /* [out] */ BYTE **ppbPayloadHeader,
            /* [out] */ DWORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetPayloadData )( 
            IWMWriterFileSinkDataUnit * This,
            /* [in] */ DWORD dwPayloadNumber,
            /* [out] */ BYTE **ppbPayloadHeader,
            /* [out] */ DWORD *pcbPayloadHeader);
        
        END_INTERFACE
    } IWMWriterFileSinkDataUnitVtbl;

    interface IWMWriterFileSinkDataUnit
    {
        CONST_VTBL struct IWMWriterFileSinkDataUnitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterFileSinkDataUnit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterFileSinkDataUnit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterFileSinkDataUnit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterFileSinkDataUnit_GetPacketHeader(This,ppbPacketHeader,pcbLength)	\
    (This)->lpVtbl -> GetPacketHeader(This,ppbPacketHeader,pcbLength)

#define IWMWriterFileSinkDataUnit_GetPayloadCount(This,pcPayloads)	\
    (This)->lpVtbl -> GetPayloadCount(This,pcPayloads)

#define IWMWriterFileSinkDataUnit_GetPayloadHeader(This,dwPayloadNumber,ppbPayloadHeader,pcbLength)	\
    (This)->lpVtbl -> GetPayloadHeader(This,dwPayloadNumber,ppbPayloadHeader,pcbLength)

#define IWMWriterFileSinkDataUnit_GetPayloadData(This,dwPayloadNumber,ppbPayloadHeader,pcbPayloadHeader)	\
    (This)->lpVtbl -> GetPayloadData(This,dwPayloadNumber,ppbPayloadHeader,pcbPayloadHeader)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterFileSinkDataUnit_GetPacketHeader_Proxy( 
    IWMWriterFileSinkDataUnit * This,
    /* [out] */ BYTE **ppbPacketHeader,
    /* [out] */ DWORD *pcbLength);


void __RPC_STUB IWMWriterFileSinkDataUnit_GetPacketHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSinkDataUnit_GetPayloadCount_Proxy( 
    IWMWriterFileSinkDataUnit * This,
    /* [out] */ DWORD *pcPayloads);


void __RPC_STUB IWMWriterFileSinkDataUnit_GetPayloadCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSinkDataUnit_GetPayloadHeader_Proxy( 
    IWMWriterFileSinkDataUnit * This,
    /* [in] */ DWORD dwPayloadNumber,
    /* [out] */ BYTE **ppbPayloadHeader,
    /* [out] */ DWORD *pcbLength);


void __RPC_STUB IWMWriterFileSinkDataUnit_GetPayloadHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSinkDataUnit_GetPayloadData_Proxy( 
    IWMWriterFileSinkDataUnit * This,
    /* [in] */ DWORD dwPayloadNumber,
    /* [out] */ BYTE **ppbPayloadHeader,
    /* [out] */ DWORD *pcbPayloadHeader);


void __RPC_STUB IWMWriterFileSinkDataUnit_GetPayloadData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterFileSinkDataUnit_INTERFACE_DEFINED__ */


#ifndef __IWMWriterFileSink3_INTERFACE_DEFINED__
#define __IWMWriterFileSink3_INTERFACE_DEFINED__

/* interface IWMWriterFileSink3 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterFileSink3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3FEA4FEB-2945-47A7-A1DD-C53A8FC4C45C")
    IWMWriterFileSink3 : public IWMWriterFileSink2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAutoIndexing( 
            /* [in] */ BOOL fDoAutoIndexing) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAutoIndexing( 
            /* [out] */ BOOL *pfAutoIndexing) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetControlStream( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ BOOL fShouldControlStartAndStop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMode( 
            /* [out] */ DWORD *pdwFileSinkMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDataUnitEx( 
            /* [in] */ WMT_FILESINK_DATA_UNIT *pFileSinkDataUnit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUnbufferedIO( 
            /* [in] */ BOOL fUnbufferedIO,
            /* [in] */ BOOL fRestrictMemUsage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUnbufferedIO( 
            /* [out] */ BOOL *pfUnbufferedIO) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompleteOperations( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterFileSink3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterFileSink3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterFileSink3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterFileSink3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnHeader )( 
            IWMWriterFileSink3 * This,
            /* [in] */ INSSBuffer *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE *IsRealTime )( 
            IWMWriterFileSink3 * This,
            /* [out] */ BOOL *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateDataUnit )( 
            IWMWriterFileSink3 * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer **ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *OnDataUnit )( 
            IWMWriterFileSink3 * This,
            /* [in] */ INSSBuffer *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndWriting )( 
            IWMWriterFileSink3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IWMWriterFileSink3 * This,
            /* [in] */ const WCHAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IWMWriterFileSink3 * This,
            /* [in] */ QWORD cnsStartTime);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IWMWriterFileSink3 * This,
            /* [in] */ QWORD cnsStopTime);
        
        HRESULT ( STDMETHODCALLTYPE *IsStopped )( 
            IWMWriterFileSink3 * This,
            /* [out] */ BOOL *pfStopped);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileDuration )( 
            IWMWriterFileSink3 * This,
            /* [out] */ QWORD *pcnsDuration);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileSize )( 
            IWMWriterFileSink3 * This,
            /* [out] */ QWORD *pcbFile);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IWMWriterFileSink3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsClosed )( 
            IWMWriterFileSink3 * This,
            /* [out] */ BOOL *pfClosed);
        
        HRESULT ( STDMETHODCALLTYPE *SetAutoIndexing )( 
            IWMWriterFileSink3 * This,
            /* [in] */ BOOL fDoAutoIndexing);
        
        HRESULT ( STDMETHODCALLTYPE *GetAutoIndexing )( 
            IWMWriterFileSink3 * This,
            /* [out] */ BOOL *pfAutoIndexing);
        
        HRESULT ( STDMETHODCALLTYPE *SetControlStream )( 
            IWMWriterFileSink3 * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ BOOL fShouldControlStartAndStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetMode )( 
            IWMWriterFileSink3 * This,
            /* [out] */ DWORD *pdwFileSinkMode);
        
        HRESULT ( STDMETHODCALLTYPE *OnDataUnitEx )( 
            IWMWriterFileSink3 * This,
            /* [in] */ WMT_FILESINK_DATA_UNIT *pFileSinkDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnbufferedIO )( 
            IWMWriterFileSink3 * This,
            /* [in] */ BOOL fUnbufferedIO,
            /* [in] */ BOOL fRestrictMemUsage);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnbufferedIO )( 
            IWMWriterFileSink3 * This,
            /* [out] */ BOOL *pfUnbufferedIO);
        
        HRESULT ( STDMETHODCALLTYPE *CompleteOperations )( 
            IWMWriterFileSink3 * This);
        
        END_INTERFACE
    } IWMWriterFileSink3Vtbl;

    interface IWMWriterFileSink3
    {
        CONST_VTBL struct IWMWriterFileSink3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterFileSink3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterFileSink3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterFileSink3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterFileSink3_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterFileSink3_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterFileSink3_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterFileSink3_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterFileSink3_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)


#define IWMWriterFileSink3_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)


#define IWMWriterFileSink3_Start(This,cnsStartTime)	\
    (This)->lpVtbl -> Start(This,cnsStartTime)

#define IWMWriterFileSink3_Stop(This,cnsStopTime)	\
    (This)->lpVtbl -> Stop(This,cnsStopTime)

#define IWMWriterFileSink3_IsStopped(This,pfStopped)	\
    (This)->lpVtbl -> IsStopped(This,pfStopped)

#define IWMWriterFileSink3_GetFileDuration(This,pcnsDuration)	\
    (This)->lpVtbl -> GetFileDuration(This,pcnsDuration)

#define IWMWriterFileSink3_GetFileSize(This,pcbFile)	\
    (This)->lpVtbl -> GetFileSize(This,pcbFile)

#define IWMWriterFileSink3_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMWriterFileSink3_IsClosed(This,pfClosed)	\
    (This)->lpVtbl -> IsClosed(This,pfClosed)


#define IWMWriterFileSink3_SetAutoIndexing(This,fDoAutoIndexing)	\
    (This)->lpVtbl -> SetAutoIndexing(This,fDoAutoIndexing)

#define IWMWriterFileSink3_GetAutoIndexing(This,pfAutoIndexing)	\
    (This)->lpVtbl -> GetAutoIndexing(This,pfAutoIndexing)

#define IWMWriterFileSink3_SetControlStream(This,wStreamNumber,fShouldControlStartAndStop)	\
    (This)->lpVtbl -> SetControlStream(This,wStreamNumber,fShouldControlStartAndStop)

#define IWMWriterFileSink3_GetMode(This,pdwFileSinkMode)	\
    (This)->lpVtbl -> GetMode(This,pdwFileSinkMode)

#define IWMWriterFileSink3_OnDataUnitEx(This,pFileSinkDataUnit)	\
    (This)->lpVtbl -> OnDataUnitEx(This,pFileSinkDataUnit)

#define IWMWriterFileSink3_SetUnbufferedIO(This,fUnbufferedIO,fRestrictMemUsage)	\
    (This)->lpVtbl -> SetUnbufferedIO(This,fUnbufferedIO,fRestrictMemUsage)

#define IWMWriterFileSink3_GetUnbufferedIO(This,pfUnbufferedIO)	\
    (This)->lpVtbl -> GetUnbufferedIO(This,pfUnbufferedIO)

#define IWMWriterFileSink3_CompleteOperations(This)	\
    (This)->lpVtbl -> CompleteOperations(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterFileSink3_SetAutoIndexing_Proxy( 
    IWMWriterFileSink3 * This,
    /* [in] */ BOOL fDoAutoIndexing);


void __RPC_STUB IWMWriterFileSink3_SetAutoIndexing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink3_GetAutoIndexing_Proxy( 
    IWMWriterFileSink3 * This,
    /* [out] */ BOOL *pfAutoIndexing);


void __RPC_STUB IWMWriterFileSink3_GetAutoIndexing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink3_SetControlStream_Proxy( 
    IWMWriterFileSink3 * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ BOOL fShouldControlStartAndStop);


void __RPC_STUB IWMWriterFileSink3_SetControlStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink3_GetMode_Proxy( 
    IWMWriterFileSink3 * This,
    /* [out] */ DWORD *pdwFileSinkMode);


void __RPC_STUB IWMWriterFileSink3_GetMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink3_OnDataUnitEx_Proxy( 
    IWMWriterFileSink3 * This,
    /* [in] */ WMT_FILESINK_DATA_UNIT *pFileSinkDataUnit);


void __RPC_STUB IWMWriterFileSink3_OnDataUnitEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink3_SetUnbufferedIO_Proxy( 
    IWMWriterFileSink3 * This,
    /* [in] */ BOOL fUnbufferedIO,
    /* [in] */ BOOL fRestrictMemUsage);


void __RPC_STUB IWMWriterFileSink3_SetUnbufferedIO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink3_GetUnbufferedIO_Proxy( 
    IWMWriterFileSink3 * This,
    /* [out] */ BOOL *pfUnbufferedIO);


void __RPC_STUB IWMWriterFileSink3_GetUnbufferedIO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink3_CompleteOperations_Proxy( 
    IWMWriterFileSink3 * This);


void __RPC_STUB IWMWriterFileSink3_CompleteOperations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterFileSink3_INTERFACE_DEFINED__ */


#ifndef __IWMWriterNetworkSink_INTERFACE_DEFINED__
#define __IWMWriterNetworkSink_INTERFACE_DEFINED__

/* interface IWMWriterNetworkSink */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterNetworkSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE7-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterNetworkSink : public IWMWriterSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMaximumClients( 
            /* [in] */ DWORD dwMaxClients) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaximumClients( 
            /* [out] */ DWORD *pdwMaxClients) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNetworkProtocol( 
            /* [in] */ WMT_NET_PROTOCOL protocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNetworkProtocol( 
            /* [out] */ WMT_NET_PROTOCOL *pProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostURL( 
            /* [out] */ WCHAR *pwszURL,
            /* [out][in] */ DWORD *pcchURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [out][in] */ DWORD *pdwPortNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterNetworkSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterNetworkSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterNetworkSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterNetworkSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnHeader )( 
            IWMWriterNetworkSink * This,
            /* [in] */ INSSBuffer *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE *IsRealTime )( 
            IWMWriterNetworkSink * This,
            /* [out] */ BOOL *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateDataUnit )( 
            IWMWriterNetworkSink * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer **ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *OnDataUnit )( 
            IWMWriterNetworkSink * This,
            /* [in] */ INSSBuffer *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndWriting )( 
            IWMWriterNetworkSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaximumClients )( 
            IWMWriterNetworkSink * This,
            /* [in] */ DWORD dwMaxClients);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaximumClients )( 
            IWMWriterNetworkSink * This,
            /* [out] */ DWORD *pdwMaxClients);
        
        HRESULT ( STDMETHODCALLTYPE *SetNetworkProtocol )( 
            IWMWriterNetworkSink * This,
            /* [in] */ WMT_NET_PROTOCOL protocol);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetworkProtocol )( 
            IWMWriterNetworkSink * This,
            /* [out] */ WMT_NET_PROTOCOL *pProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *GetHostURL )( 
            IWMWriterNetworkSink * This,
            /* [out] */ WCHAR *pwszURL,
            /* [out][in] */ DWORD *pcchURL);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IWMWriterNetworkSink * This,
            /* [out][in] */ DWORD *pdwPortNum);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IWMWriterNetworkSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IWMWriterNetworkSink * This);
        
        END_INTERFACE
    } IWMWriterNetworkSinkVtbl;

    interface IWMWriterNetworkSink
    {
        CONST_VTBL struct IWMWriterNetworkSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterNetworkSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterNetworkSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterNetworkSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterNetworkSink_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterNetworkSink_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterNetworkSink_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterNetworkSink_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterNetworkSink_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)


#define IWMWriterNetworkSink_SetMaximumClients(This,dwMaxClients)	\
    (This)->lpVtbl -> SetMaximumClients(This,dwMaxClients)

#define IWMWriterNetworkSink_GetMaximumClients(This,pdwMaxClients)	\
    (This)->lpVtbl -> GetMaximumClients(This,pdwMaxClients)

#define IWMWriterNetworkSink_SetNetworkProtocol(This,protocol)	\
    (This)->lpVtbl -> SetNetworkProtocol(This,protocol)

#define IWMWriterNetworkSink_GetNetworkProtocol(This,pProtocol)	\
    (This)->lpVtbl -> GetNetworkProtocol(This,pProtocol)

#define IWMWriterNetworkSink_GetHostURL(This,pwszURL,pcchURL)	\
    (This)->lpVtbl -> GetHostURL(This,pwszURL,pcchURL)

#define IWMWriterNetworkSink_Open(This,pdwPortNum)	\
    (This)->lpVtbl -> Open(This,pdwPortNum)

#define IWMWriterNetworkSink_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IWMWriterNetworkSink_Close(This)	\
    (This)->lpVtbl -> Close(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_SetMaximumClients_Proxy( 
    IWMWriterNetworkSink * This,
    /* [in] */ DWORD dwMaxClients);


void __RPC_STUB IWMWriterNetworkSink_SetMaximumClients_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_GetMaximumClients_Proxy( 
    IWMWriterNetworkSink * This,
    /* [out] */ DWORD *pdwMaxClients);


void __RPC_STUB IWMWriterNetworkSink_GetMaximumClients_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_SetNetworkProtocol_Proxy( 
    IWMWriterNetworkSink * This,
    /* [in] */ WMT_NET_PROTOCOL protocol);


void __RPC_STUB IWMWriterNetworkSink_SetNetworkProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_GetNetworkProtocol_Proxy( 
    IWMWriterNetworkSink * This,
    /* [out] */ WMT_NET_PROTOCOL *pProtocol);


void __RPC_STUB IWMWriterNetworkSink_GetNetworkProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_GetHostURL_Proxy( 
    IWMWriterNetworkSink * This,
    /* [out] */ WCHAR *pwszURL,
    /* [out][in] */ DWORD *pcchURL);


void __RPC_STUB IWMWriterNetworkSink_GetHostURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_Open_Proxy( 
    IWMWriterNetworkSink * This,
    /* [out][in] */ DWORD *pdwPortNum);


void __RPC_STUB IWMWriterNetworkSink_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_Disconnect_Proxy( 
    IWMWriterNetworkSink * This);


void __RPC_STUB IWMWriterNetworkSink_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_Close_Proxy( 
    IWMWriterNetworkSink * This);


void __RPC_STUB IWMWriterNetworkSink_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterNetworkSink_INTERFACE_DEFINED__ */


#ifndef __IWMClientConnections_INTERFACE_DEFINED__
#define __IWMClientConnections_INTERFACE_DEFINED__

/* interface IWMClientConnections */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMClientConnections;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73C66010-A299-41df-B1F0-CCF03B09C1C6")
    IWMClientConnections : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClientCount( 
            /* [out] */ DWORD *pcClients) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClientProperties( 
            /* [in] */ DWORD dwClientNum,
            /* [out] */ WM_CLIENT_PROPERTIES *pClientProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMClientConnectionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMClientConnections * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMClientConnections * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMClientConnections * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClientCount )( 
            IWMClientConnections * This,
            /* [out] */ DWORD *pcClients);
        
        HRESULT ( STDMETHODCALLTYPE *GetClientProperties )( 
            IWMClientConnections * This,
            /* [in] */ DWORD dwClientNum,
            /* [out] */ WM_CLIENT_PROPERTIES *pClientProperties);
        
        END_INTERFACE
    } IWMClientConnectionsVtbl;

    interface IWMClientConnections
    {
        CONST_VTBL struct IWMClientConnectionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMClientConnections_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMClientConnections_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMClientConnections_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMClientConnections_GetClientCount(This,pcClients)	\
    (This)->lpVtbl -> GetClientCount(This,pcClients)

#define IWMClientConnections_GetClientProperties(This,dwClientNum,pClientProperties)	\
    (This)->lpVtbl -> GetClientProperties(This,dwClientNum,pClientProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMClientConnections_GetClientCount_Proxy( 
    IWMClientConnections * This,
    /* [out] */ DWORD *pcClients);


void __RPC_STUB IWMClientConnections_GetClientCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMClientConnections_GetClientProperties_Proxy( 
    IWMClientConnections * This,
    /* [in] */ DWORD dwClientNum,
    /* [out] */ WM_CLIENT_PROPERTIES *pClientProperties);


void __RPC_STUB IWMClientConnections_GetClientProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMClientConnections_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAdvanced_INTERFACE_DEFINED__
#define __IWMReaderAdvanced_INTERFACE_DEFINED__

/* interface IWMReaderAdvanced */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BEA-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetUserProvidedClock( 
            /* [in] */ BOOL fUserClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserProvidedClock( 
            /* [out] */ BOOL *pfUserClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeliverTime( 
            /* [in] */ QWORD cnsTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetManualStreamSelection( 
            /* [in] */ BOOL fSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManualStreamSelection( 
            /* [out] */ BOOL *pfSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamsSelected( 
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION *pSelections) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamSelected( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION *pSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReceiveSelectionCallbacks( 
            /* [in] */ BOOL fGetCallbacks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReceiveSelectionCallbacks( 
            /* [in] */ BOOL *pfGetCallbacks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReceiveStreamSamples( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReceiveStreamSamples( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL *pfReceiveStreamSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllocateForOutput( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocateForOutput( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL *pfAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllocateForStream( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocateForStream( 
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL *pfAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [in] */ WM_READER_STATISTICS *pStatistics) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClientInfo( 
            /* [in] */ WM_READER_CLIENTINFO *pClientInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxOutputSampleSize( 
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD *pcbMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxStreamSampleSize( 
            /* [in] */ WORD wStream,
            /* [out] */ DWORD *pcbMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyLateDelivery( 
            QWORD cnsLateness) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMReaderAdvanced * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMReaderAdvanced * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMReaderAdvanced * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUserProvidedClock )( 
            IWMReaderAdvanced * This,
            /* [in] */ BOOL fUserClock);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserProvidedClock )( 
            IWMReaderAdvanced * This,
            /* [out] */ BOOL *pfUserClock);
        
        HRESULT ( STDMETHODCALLTYPE *DeliverTime )( 
            IWMReaderAdvanced * This,
            /* [in] */ QWORD cnsTime);
        
        HRESULT ( STDMETHODCALLTYPE *SetManualStreamSelection )( 
            IWMReaderAdvanced * This,
            /* [in] */ BOOL fSelection);
        
        HRESULT ( STDMETHODCALLTYPE *GetManualStreamSelection )( 
            IWMReaderAdvanced * This,
            /* [out] */ BOOL *pfSelection);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamsSelected )( 
            IWMReaderAdvanced * This,
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION *pSelections);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamSelected )( 
            IWMReaderAdvanced * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE *SetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced * This,
            /* [in] */ BOOL fGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE *GetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced * This,
            /* [in] */ BOOL *pfGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE *SetReceiveStreamSamples )( 
            IWMReaderAdvanced * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE *GetReceiveStreamSamples )( 
            IWMReaderAdvanced * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL *pfReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllocateForOutput )( 
            IWMReaderAdvanced * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocateForOutput )( 
            IWMReaderAdvanced * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllocateForStream )( 
            IWMReaderAdvanced * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocateForStream )( 
            IWMReaderAdvanced * This,
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatistics )( 
            IWMReaderAdvanced * This,
            /* [in] */ WM_READER_STATISTICS *pStatistics);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientInfo )( 
            IWMReaderAdvanced * This,
            /* [in] */ WM_READER_CLIENTINFO *pClientInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxOutputSampleSize )( 
            IWMReaderAdvanced * This,
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxStreamSampleSize )( 
            IWMReaderAdvanced * This,
            /* [in] */ WORD wStream,
            /* [out] */ DWORD *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyLateDelivery )( 
            IWMReaderAdvanced * This,
            QWORD cnsLateness);
        
        END_INTERFACE
    } IWMReaderAdvancedVtbl;

    interface IWMReaderAdvanced
    {
        CONST_VTBL struct IWMReaderAdvancedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAdvanced_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAdvanced_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAdvanced_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAdvanced_SetUserProvidedClock(This,fUserClock)	\
    (This)->lpVtbl -> SetUserProvidedClock(This,fUserClock)

#define IWMReaderAdvanced_GetUserProvidedClock(This,pfUserClock)	\
    (This)->lpVtbl -> GetUserProvidedClock(This,pfUserClock)

#define IWMReaderAdvanced_DeliverTime(This,cnsTime)	\
    (This)->lpVtbl -> DeliverTime(This,cnsTime)

#define IWMReaderAdvanced_SetManualStreamSelection(This,fSelection)	\
    (This)->lpVtbl -> SetManualStreamSelection(This,fSelection)

#define IWMReaderAdvanced_GetManualStreamSelection(This,pfSelection)	\
    (This)->lpVtbl -> GetManualStreamSelection(This,pfSelection)

#define IWMReaderAdvanced_SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)	\
    (This)->lpVtbl -> SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)

#define IWMReaderAdvanced_GetStreamSelected(This,wStreamNum,pSelection)	\
    (This)->lpVtbl -> GetStreamSelected(This,wStreamNum,pSelection)

#define IWMReaderAdvanced_SetReceiveSelectionCallbacks(This,fGetCallbacks)	\
    (This)->lpVtbl -> SetReceiveSelectionCallbacks(This,fGetCallbacks)

#define IWMReaderAdvanced_GetReceiveSelectionCallbacks(This,pfGetCallbacks)	\
    (This)->lpVtbl -> GetReceiveSelectionCallbacks(This,pfGetCallbacks)

#define IWMReaderAdvanced_SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)	\
    (This)->lpVtbl -> SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)

#define IWMReaderAdvanced_GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)	\
    (This)->lpVtbl -> GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)

#define IWMReaderAdvanced_SetAllocateForOutput(This,dwOutputNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForOutput(This,dwOutputNum,fAllocate)

#define IWMReaderAdvanced_GetAllocateForOutput(This,dwOutputNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForOutput(This,dwOutputNum,pfAllocate)

#define IWMReaderAdvanced_SetAllocateForStream(This,wStreamNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForStream(This,wStreamNum,fAllocate)

#define IWMReaderAdvanced_GetAllocateForStream(This,dwSreamNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForStream(This,dwSreamNum,pfAllocate)

#define IWMReaderAdvanced_GetStatistics(This,pStatistics)	\
    (This)->lpVtbl -> GetStatistics(This,pStatistics)

#define IWMReaderAdvanced_SetClientInfo(This,pClientInfo)	\
    (This)->lpVtbl -> SetClientInfo(This,pClientInfo)

#define IWMReaderAdvanced_GetMaxOutputSampleSize(This,dwOutput,pcbMax)	\
    (This)->lpVtbl -> GetMaxOutputSampleSize(This,dwOutput,pcbMax)

#define IWMReaderAdvanced_GetMaxStreamSampleSize(This,wStream,pcbMax)	\
    (This)->lpVtbl -> GetMaxStreamSampleSize(This,wStream,pcbMax)

#define IWMReaderAdvanced_NotifyLateDelivery(This,cnsLateness)	\
    (This)->lpVtbl -> NotifyLateDelivery(This,cnsLateness)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetUserProvidedClock_Proxy( 
    IWMReaderAdvanced * This,
    /* [in] */ BOOL fUserClock);


void __RPC_STUB IWMReaderAdvanced_SetUserProvidedClock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetUserProvidedClock_Proxy( 
    IWMReaderAdvanced * This,
    /* [out] */ BOOL *pfUserClock);


void __RPC_STUB IWMReaderAdvanced_GetUserProvidedClock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_DeliverTime_Proxy( 
    IWMReaderAdvanced * This,
    /* [in] */ QWORD cnsTime);


void __RPC_STUB IWMReaderAdvanced_DeliverTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetManualStreamSelection_Proxy( 
    IWMReaderAdvanced * This,
    /* [in] */ BOOL fSelection);


void __RPC_STUB IWMReaderAdvanced_SetManualStreamSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetManualStreamSelection_Proxy( 
    IWMReaderAdvanced * This,
    /* [out] */ BOOL *pfSelection);


void __RPC_STUB IWMReaderAdvanced_GetManualStreamSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetStreamsSelected_Proxy( 
    IWMReaderAdvanced * This,
    /* [in] */ WORD cStreamCount,
    /* [in] */ WORD *pwStreamNumbers,
    /* [in] */ WMT_STREAM_SELECTION *pSelections);


void __RPC_STUB IWMReaderAdvanced_SetStreamsSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetStreamSelected_Proxy( 
    IWMReaderAdvanced * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ WMT_STREAM_SELECTION *pSelection);


void __RPC_STUB IWMReaderAdvanced_GetStreamSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetReceiveSelectionCallbacks_Proxy( 
    IWMReaderAdvanced * This,
    /* [in] */ BOOL fGetCallbacks);


void __RPC_STUB IWMReaderAdvanced_SetReceiveSelectionCallbacks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetReceiveSelectionCallbacks_Proxy( 
    IWMReaderAdvanced * This,
    /* [in] */ BOOL *pfGetCallbacks);


void __RPC_STUB IWMReaderAdvanced_GetReceiveSelectionCallbacks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetReceiveStreamSamples_Proxy( 
    IWMReaderAdvanced * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ BOOL fReceiveStreamSamples);


void __RPC_STUB IWMReaderAdvanced_SetReceiveStreamSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetReceiveStreamSamples_Proxy( 
    IWMReaderAdvanced * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ BOOL *pfReceiveStreamSamples);


void __RPC_STUB IWMReaderAdvanced_GetReceiveStreamSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetAllocateForOutput_Proxy( 
    IWMReaderAdvanced * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ BOOL fAllocate);


void __RPC_STUB IWMReaderAdvanced_SetAllocateForOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetAllocateForOutput_Proxy( 
    IWMReaderAdvanced * This,
    /* [in] */ DWORD dwOutputNum,
    /* [out] */ BOOL *pfAllocate);


void __RPC_STUB IWMReaderAdvanced_GetAllocateForOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetAllocateForStream_Proxy( 
    IWMReaderAdvanced * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ BOOL fAllocate);


void __RPC_STUB IWMReaderAdvanced_SetAllocateForStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetAllocateForStream_Proxy( 
    IWMReaderAdvanced * This,
    /* [in] */ WORD dwSreamNum,
    /* [out] */ BOOL *pfAllocate);


void __RPC_STUB IWMReaderAdvanced_GetAllocateForStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetStatistics_Proxy( 
    IWMReaderAdvanced * This,
    /* [in] */ WM_READER_STATISTICS *pStatistics);


void __RPC_STUB IWMReaderAdvanced_GetStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetClientInfo_Proxy( 
    IWMReaderAdvanced * This,
    /* [in] */ WM_READER_CLIENTINFO *pClientInfo);


void __RPC_STUB IWMReaderAdvanced_SetClientInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetMaxOutputSampleSize_Proxy( 
    IWMReaderAdvanced * This,
    /* [in] */ DWORD dwOutput,
    /* [out] */ DWORD *pcbMax);


void __RPC_STUB IWMReaderAdvanced_GetMaxOutputSampleSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetMaxStreamSampleSize_Proxy( 
    IWMReaderAdvanced * This,
    /* [in] */ WORD wStream,
    /* [out] */ DWORD *pcbMax);


void __RPC_STUB IWMReaderAdvanced_GetMaxStreamSampleSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_NotifyLateDelivery_Proxy( 
    IWMReaderAdvanced * This,
    QWORD cnsLateness);


void __RPC_STUB IWMReaderAdvanced_NotifyLateDelivery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAdvanced_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAdvanced2_INTERFACE_DEFINED__
#define __IWMReaderAdvanced2_INTERFACE_DEFINED__

/* interface IWMReaderAdvanced2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAdvanced2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ae14a945-b90c-4d0d-9127-80d665f7d73e")
    IWMReaderAdvanced2 : public IWMReaderAdvanced
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPlayMode( 
            /* [in] */ WMT_PLAY_MODE Mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlayMode( 
            /* [out] */ WMT_PLAY_MODE *pMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferProgress( 
            /* [out] */ DWORD *pdwPercent,
            /* [out] */ QWORD *pcnsBuffering) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDownloadProgress( 
            /* [out] */ DWORD *pdwPercent,
            /* [out] */ QWORD *pqwBytesDownloaded,
            /* [out] */ QWORD *pcnsDownload) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSaveAsProgress( 
            /* [out] */ DWORD *pdwPercent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveFileAs( 
            /* [in] */ const WCHAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProtocolName( 
            /* [out] */ WCHAR *pwszProtocol,
            /* [out][in] */ DWORD *pcchProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartAtMarker( 
            /* [in] */ WORD wMarkerIndex,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputSetting( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputSetting( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Preroll( 
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLogClientID( 
            /* [in] */ BOOL fLogClientID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogClientID( 
            /* [out] */ BOOL *pfLogClientID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopBuffering( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenStream( 
            /* [in] */ IStream *pStream,
            /* [in] */ IWMReaderCallback *pCallback,
            /* [in] */ void *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAdvanced2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMReaderAdvanced2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMReaderAdvanced2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUserProvidedClock )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ BOOL fUserClock);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserProvidedClock )( 
            IWMReaderAdvanced2 * This,
            /* [out] */ BOOL *pfUserClock);
        
        HRESULT ( STDMETHODCALLTYPE *DeliverTime )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ QWORD cnsTime);
        
        HRESULT ( STDMETHODCALLTYPE *SetManualStreamSelection )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ BOOL fSelection);
        
        HRESULT ( STDMETHODCALLTYPE *GetManualStreamSelection )( 
            IWMReaderAdvanced2 * This,
            /* [out] */ BOOL *pfSelection);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamsSelected )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION *pSelections);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamSelected )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE *SetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ BOOL fGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE *GetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ BOOL *pfGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE *SetReceiveStreamSamples )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE *GetReceiveStreamSamples )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL *pfReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllocateForOutput )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocateForOutput )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllocateForStream )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocateForStream )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatistics )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WM_READER_STATISTICS *pStatistics);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientInfo )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WM_READER_CLIENTINFO *pClientInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxOutputSampleSize )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxStreamSampleSize )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WORD wStream,
            /* [out] */ DWORD *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyLateDelivery )( 
            IWMReaderAdvanced2 * This,
            QWORD cnsLateness);
        
        HRESULT ( STDMETHODCALLTYPE *SetPlayMode )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WMT_PLAY_MODE Mode);
        
        HRESULT ( STDMETHODCALLTYPE *GetPlayMode )( 
            IWMReaderAdvanced2 * This,
            /* [out] */ WMT_PLAY_MODE *pMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferProgress )( 
            IWMReaderAdvanced2 * This,
            /* [out] */ DWORD *pdwPercent,
            /* [out] */ QWORD *pcnsBuffering);
        
        HRESULT ( STDMETHODCALLTYPE *GetDownloadProgress )( 
            IWMReaderAdvanced2 * This,
            /* [out] */ DWORD *pdwPercent,
            /* [out] */ QWORD *pqwBytesDownloaded,
            /* [out] */ QWORD *pcnsDownload);
        
        HRESULT ( STDMETHODCALLTYPE *GetSaveAsProgress )( 
            IWMReaderAdvanced2 * This,
            /* [out] */ DWORD *pdwPercent);
        
        HRESULT ( STDMETHODCALLTYPE *SaveFileAs )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ const WCHAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE *GetProtocolName )( 
            IWMReaderAdvanced2 * This,
            /* [out] */ WCHAR *pwszProtocol,
            /* [out][in] */ DWORD *pcchProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *StartAtMarker )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WORD wMarkerIndex,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputSetting )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputSetting )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE *Preroll )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate);
        
        HRESULT ( STDMETHODCALLTYPE *SetLogClientID )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ BOOL fLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE *GetLogClientID )( 
            IWMReaderAdvanced2 * This,
            /* [out] */ BOOL *pfLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE *StopBuffering )( 
            IWMReaderAdvanced2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenStream )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ IStream *pStream,
            /* [in] */ IWMReaderCallback *pCallback,
            /* [in] */ void *pvContext);
        
        END_INTERFACE
    } IWMReaderAdvanced2Vtbl;

    interface IWMReaderAdvanced2
    {
        CONST_VTBL struct IWMReaderAdvanced2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAdvanced2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAdvanced2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAdvanced2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAdvanced2_SetUserProvidedClock(This,fUserClock)	\
    (This)->lpVtbl -> SetUserProvidedClock(This,fUserClock)

#define IWMReaderAdvanced2_GetUserProvidedClock(This,pfUserClock)	\
    (This)->lpVtbl -> GetUserProvidedClock(This,pfUserClock)

#define IWMReaderAdvanced2_DeliverTime(This,cnsTime)	\
    (This)->lpVtbl -> DeliverTime(This,cnsTime)

#define IWMReaderAdvanced2_SetManualStreamSelection(This,fSelection)	\
    (This)->lpVtbl -> SetManualStreamSelection(This,fSelection)

#define IWMReaderAdvanced2_GetManualStreamSelection(This,pfSelection)	\
    (This)->lpVtbl -> GetManualStreamSelection(This,pfSelection)

#define IWMReaderAdvanced2_SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)	\
    (This)->lpVtbl -> SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)

#define IWMReaderAdvanced2_GetStreamSelected(This,wStreamNum,pSelection)	\
    (This)->lpVtbl -> GetStreamSelected(This,wStreamNum,pSelection)

#define IWMReaderAdvanced2_SetReceiveSelectionCallbacks(This,fGetCallbacks)	\
    (This)->lpVtbl -> SetReceiveSelectionCallbacks(This,fGetCallbacks)

#define IWMReaderAdvanced2_GetReceiveSelectionCallbacks(This,pfGetCallbacks)	\
    (This)->lpVtbl -> GetReceiveSelectionCallbacks(This,pfGetCallbacks)

#define IWMReaderAdvanced2_SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)	\
    (This)->lpVtbl -> SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)

#define IWMReaderAdvanced2_GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)	\
    (This)->lpVtbl -> GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)

#define IWMReaderAdvanced2_SetAllocateForOutput(This,dwOutputNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForOutput(This,dwOutputNum,fAllocate)

#define IWMReaderAdvanced2_GetAllocateForOutput(This,dwOutputNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForOutput(This,dwOutputNum,pfAllocate)

#define IWMReaderAdvanced2_SetAllocateForStream(This,wStreamNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForStream(This,wStreamNum,fAllocate)

#define IWMReaderAdvanced2_GetAllocateForStream(This,dwSreamNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForStream(This,dwSreamNum,pfAllocate)

#define IWMReaderAdvanced2_GetStatistics(This,pStatistics)	\
    (This)->lpVtbl -> GetStatistics(This,pStatistics)

#define IWMReaderAdvanced2_SetClientInfo(This,pClientInfo)	\
    (This)->lpVtbl -> SetClientInfo(This,pClientInfo)

#define IWMReaderAdvanced2_GetMaxOutputSampleSize(This,dwOutput,pcbMax)	\
    (This)->lpVtbl -> GetMaxOutputSampleSize(This,dwOutput,pcbMax)

#define IWMReaderAdvanced2_GetMaxStreamSampleSize(This,wStream,pcbMax)	\
    (This)->lpVtbl -> GetMaxStreamSampleSize(This,wStream,pcbMax)

#define IWMReaderAdvanced2_NotifyLateDelivery(This,cnsLateness)	\
    (This)->lpVtbl -> NotifyLateDelivery(This,cnsLateness)


#define IWMReaderAdvanced2_SetPlayMode(This,Mode)	\
    (This)->lpVtbl -> SetPlayMode(This,Mode)

#define IWMReaderAdvanced2_GetPlayMode(This,pMode)	\
    (This)->lpVtbl -> GetPlayMode(This,pMode)

#define IWMReaderAdvanced2_GetBufferProgress(This,pdwPercent,pcnsBuffering)	\
    (This)->lpVtbl -> GetBufferProgress(This,pdwPercent,pcnsBuffering)

#define IWMReaderAdvanced2_GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)	\
    (This)->lpVtbl -> GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)

#define IWMReaderAdvanced2_GetSaveAsProgress(This,pdwPercent)	\
    (This)->lpVtbl -> GetSaveAsProgress(This,pdwPercent)

#define IWMReaderAdvanced2_SaveFileAs(This,pwszFilename)	\
    (This)->lpVtbl -> SaveFileAs(This,pwszFilename)

#define IWMReaderAdvanced2_GetProtocolName(This,pwszProtocol,pcchProtocol)	\
    (This)->lpVtbl -> GetProtocolName(This,pwszProtocol,pcchProtocol)

#define IWMReaderAdvanced2_StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)	\
    (This)->lpVtbl -> StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)

#define IWMReaderAdvanced2_GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)

#define IWMReaderAdvanced2_SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)

#define IWMReaderAdvanced2_Preroll(This,cnsStart,cnsDuration,fRate)	\
    (This)->lpVtbl -> Preroll(This,cnsStart,cnsDuration,fRate)

#define IWMReaderAdvanced2_SetLogClientID(This,fLogClientID)	\
    (This)->lpVtbl -> SetLogClientID(This,fLogClientID)

#define IWMReaderAdvanced2_GetLogClientID(This,pfLogClientID)	\
    (This)->lpVtbl -> GetLogClientID(This,pfLogClientID)

#define IWMReaderAdvanced2_StopBuffering(This)	\
    (This)->lpVtbl -> StopBuffering(This)

#define IWMReaderAdvanced2_OpenStream(This,pStream,pCallback,pvContext)	\
    (This)->lpVtbl -> OpenStream(This,pStream,pCallback,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SetPlayMode_Proxy( 
    IWMReaderAdvanced2 * This,
    /* [in] */ WMT_PLAY_MODE Mode);


void __RPC_STUB IWMReaderAdvanced2_SetPlayMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetPlayMode_Proxy( 
    IWMReaderAdvanced2 * This,
    /* [out] */ WMT_PLAY_MODE *pMode);


void __RPC_STUB IWMReaderAdvanced2_GetPlayMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetBufferProgress_Proxy( 
    IWMReaderAdvanced2 * This,
    /* [out] */ DWORD *pdwPercent,
    /* [out] */ QWORD *pcnsBuffering);


void __RPC_STUB IWMReaderAdvanced2_GetBufferProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetDownloadProgress_Proxy( 
    IWMReaderAdvanced2 * This,
    /* [out] */ DWORD *pdwPercent,
    /* [out] */ QWORD *pqwBytesDownloaded,
    /* [out] */ QWORD *pcnsDownload);


void __RPC_STUB IWMReaderAdvanced2_GetDownloadProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetSaveAsProgress_Proxy( 
    IWMReaderAdvanced2 * This,
    /* [out] */ DWORD *pdwPercent);


void __RPC_STUB IWMReaderAdvanced2_GetSaveAsProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SaveFileAs_Proxy( 
    IWMReaderAdvanced2 * This,
    /* [in] */ const WCHAR *pwszFilename);


void __RPC_STUB IWMReaderAdvanced2_SaveFileAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetProtocolName_Proxy( 
    IWMReaderAdvanced2 * This,
    /* [out] */ WCHAR *pwszProtocol,
    /* [out][in] */ DWORD *pcchProtocol);


void __RPC_STUB IWMReaderAdvanced2_GetProtocolName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_StartAtMarker_Proxy( 
    IWMReaderAdvanced2 * This,
    /* [in] */ WORD wMarkerIndex,
    /* [in] */ QWORD cnsDuration,
    /* [in] */ float fRate,
    /* [in] */ void *pvContext);


void __RPC_STUB IWMReaderAdvanced2_StartAtMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetOutputSetting_Proxy( 
    IWMReaderAdvanced2 * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE *pType,
    /* [out] */ BYTE *pValue,
    /* [out][in] */ WORD *pcbLength);


void __RPC_STUB IWMReaderAdvanced2_GetOutputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SetOutputSetting_Proxy( 
    IWMReaderAdvanced2 * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMReaderAdvanced2_SetOutputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_Preroll_Proxy( 
    IWMReaderAdvanced2 * This,
    /* [in] */ QWORD cnsStart,
    /* [in] */ QWORD cnsDuration,
    /* [in] */ float fRate);


void __RPC_STUB IWMReaderAdvanced2_Preroll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SetLogClientID_Proxy( 
    IWMReaderAdvanced2 * This,
    /* [in] */ BOOL fLogClientID);


void __RPC_STUB IWMReaderAdvanced2_SetLogClientID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetLogClientID_Proxy( 
    IWMReaderAdvanced2 * This,
    /* [out] */ BOOL *pfLogClientID);


void __RPC_STUB IWMReaderAdvanced2_GetLogClientID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_StopBuffering_Proxy( 
    IWMReaderAdvanced2 * This);


void __RPC_STUB IWMReaderAdvanced2_StopBuffering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_OpenStream_Proxy( 
    IWMReaderAdvanced2 * This,
    /* [in] */ IStream *pStream,
    /* [in] */ IWMReaderCallback *pCallback,
    /* [in] */ void *pvContext);


void __RPC_STUB IWMReaderAdvanced2_OpenStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAdvanced2_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAdvanced3_INTERFACE_DEFINED__
#define __IWMReaderAdvanced3_INTERFACE_DEFINED__

/* interface IWMReaderAdvanced3 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAdvanced3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5DC0674B-F04B-4a4e-9F2A-B1AFDE2C8100")
    IWMReaderAdvanced3 : public IWMReaderAdvanced2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StopNetStreaming( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartAtPosition( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ void *pvOffsetStart,
            /* [in] */ void *pvDuration,
            /* [in] */ WMT_OFFSET_FORMAT dwOffsetFormat,
            /* [in] */ float fRate,
            /* [in] */ void *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAdvanced3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMReaderAdvanced3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMReaderAdvanced3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUserProvidedClock )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ BOOL fUserClock);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserProvidedClock )( 
            IWMReaderAdvanced3 * This,
            /* [out] */ BOOL *pfUserClock);
        
        HRESULT ( STDMETHODCALLTYPE *DeliverTime )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ QWORD cnsTime);
        
        HRESULT ( STDMETHODCALLTYPE *SetManualStreamSelection )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ BOOL fSelection);
        
        HRESULT ( STDMETHODCALLTYPE *GetManualStreamSelection )( 
            IWMReaderAdvanced3 * This,
            /* [out] */ BOOL *pfSelection);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamsSelected )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION *pSelections);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamSelected )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE *SetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ BOOL fGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE *GetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ BOOL *pfGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE *SetReceiveStreamSamples )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE *GetReceiveStreamSamples )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL *pfReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllocateForOutput )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocateForOutput )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllocateForStream )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocateForStream )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatistics )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ WM_READER_STATISTICS *pStatistics);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientInfo )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ WM_READER_CLIENTINFO *pClientInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxOutputSampleSize )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxStreamSampleSize )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ WORD wStream,
            /* [out] */ DWORD *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyLateDelivery )( 
            IWMReaderAdvanced3 * This,
            QWORD cnsLateness);
        
        HRESULT ( STDMETHODCALLTYPE *SetPlayMode )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ WMT_PLAY_MODE Mode);
        
        HRESULT ( STDMETHODCALLTYPE *GetPlayMode )( 
            IWMReaderAdvanced3 * This,
            /* [out] */ WMT_PLAY_MODE *pMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferProgress )( 
            IWMReaderAdvanced3 * This,
            /* [out] */ DWORD *pdwPercent,
            /* [out] */ QWORD *pcnsBuffering);
        
        HRESULT ( STDMETHODCALLTYPE *GetDownloadProgress )( 
            IWMReaderAdvanced3 * This,
            /* [out] */ DWORD *pdwPercent,
            /* [out] */ QWORD *pqwBytesDownloaded,
            /* [out] */ QWORD *pcnsDownload);
        
        HRESULT ( STDMETHODCALLTYPE *GetSaveAsProgress )( 
            IWMReaderAdvanced3 * This,
            /* [out] */ DWORD *pdwPercent);
        
        HRESULT ( STDMETHODCALLTYPE *SaveFileAs )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ const WCHAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE *GetProtocolName )( 
            IWMReaderAdvanced3 * This,
            /* [out] */ WCHAR *pwszProtocol,
            /* [out][in] */ DWORD *pcchProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *StartAtMarker )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ WORD wMarkerIndex,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputSetting )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputSetting )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE *Preroll )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate);
        
        HRESULT ( STDMETHODCALLTYPE *SetLogClientID )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ BOOL fLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE *GetLogClientID )( 
            IWMReaderAdvanced3 * This,
            /* [out] */ BOOL *pfLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE *StopBuffering )( 
            IWMReaderAdvanced3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenStream )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ IStream *pStream,
            /* [in] */ IWMReaderCallback *pCallback,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *StopNetStreaming )( 
            IWMReaderAdvanced3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartAtPosition )( 
            IWMReaderAdvanced3 * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ void *pvOffsetStart,
            /* [in] */ void *pvDuration,
            /* [in] */ WMT_OFFSET_FORMAT dwOffsetFormat,
            /* [in] */ float fRate,
            /* [in] */ void *pvContext);
        
        END_INTERFACE
    } IWMReaderAdvanced3Vtbl;

    interface IWMReaderAdvanced3
    {
        CONST_VTBL struct IWMReaderAdvanced3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAdvanced3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAdvanced3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAdvanced3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAdvanced3_SetUserProvidedClock(This,fUserClock)	\
    (This)->lpVtbl -> SetUserProvidedClock(This,fUserClock)

#define IWMReaderAdvanced3_GetUserProvidedClock(This,pfUserClock)	\
    (This)->lpVtbl -> GetUserProvidedClock(This,pfUserClock)

#define IWMReaderAdvanced3_DeliverTime(This,cnsTime)	\
    (This)->lpVtbl -> DeliverTime(This,cnsTime)

#define IWMReaderAdvanced3_SetManualStreamSelection(This,fSelection)	\
    (This)->lpVtbl -> SetManualStreamSelection(This,fSelection)

#define IWMReaderAdvanced3_GetManualStreamSelection(This,pfSelection)	\
    (This)->lpVtbl -> GetManualStreamSelection(This,pfSelection)

#define IWMReaderAdvanced3_SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)	\
    (This)->lpVtbl -> SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)

#define IWMReaderAdvanced3_GetStreamSelected(This,wStreamNum,pSelection)	\
    (This)->lpVtbl -> GetStreamSelected(This,wStreamNum,pSelection)

#define IWMReaderAdvanced3_SetReceiveSelectionCallbacks(This,fGetCallbacks)	\
    (This)->lpVtbl -> SetReceiveSelectionCallbacks(This,fGetCallbacks)

#define IWMReaderAdvanced3_GetReceiveSelectionCallbacks(This,pfGetCallbacks)	\
    (This)->lpVtbl -> GetReceiveSelectionCallbacks(This,pfGetCallbacks)

#define IWMReaderAdvanced3_SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)	\
    (This)->lpVtbl -> SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)

#define IWMReaderAdvanced3_GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)	\
    (This)->lpVtbl -> GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)

#define IWMReaderAdvanced3_SetAllocateForOutput(This,dwOutputNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForOutput(This,dwOutputNum,fAllocate)

#define IWMReaderAdvanced3_GetAllocateForOutput(This,dwOutputNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForOutput(This,dwOutputNum,pfAllocate)

#define IWMReaderAdvanced3_SetAllocateForStream(This,wStreamNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForStream(This,wStreamNum,fAllocate)

#define IWMReaderAdvanced3_GetAllocateForStream(This,dwSreamNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForStream(This,dwSreamNum,pfAllocate)

#define IWMReaderAdvanced3_GetStatistics(This,pStatistics)	\
    (This)->lpVtbl -> GetStatistics(This,pStatistics)

#define IWMReaderAdvanced3_SetClientInfo(This,pClientInfo)	\
    (This)->lpVtbl -> SetClientInfo(This,pClientInfo)

#define IWMReaderAdvanced3_GetMaxOutputSampleSize(This,dwOutput,pcbMax)	\
    (This)->lpVtbl -> GetMaxOutputSampleSize(This,dwOutput,pcbMax)

#define IWMReaderAdvanced3_GetMaxStreamSampleSize(This,wStream,pcbMax)	\
    (This)->lpVtbl -> GetMaxStreamSampleSize(This,wStream,pcbMax)

#define IWMReaderAdvanced3_NotifyLateDelivery(This,cnsLateness)	\
    (This)->lpVtbl -> NotifyLateDelivery(This,cnsLateness)


#define IWMReaderAdvanced3_SetPlayMode(This,Mode)	\
    (This)->lpVtbl -> SetPlayMode(This,Mode)

#define IWMReaderAdvanced3_GetPlayMode(This,pMode)	\
    (This)->lpVtbl -> GetPlayMode(This,pMode)

#define IWMReaderAdvanced3_GetBufferProgress(This,pdwPercent,pcnsBuffering)	\
    (This)->lpVtbl -> GetBufferProgress(This,pdwPercent,pcnsBuffering)

#define IWMReaderAdvanced3_GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)	\
    (This)->lpVtbl -> GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)

#define IWMReaderAdvanced3_GetSaveAsProgress(This,pdwPercent)	\
    (This)->lpVtbl -> GetSaveAsProgress(This,pdwPercent)

#define IWMReaderAdvanced3_SaveFileAs(This,pwszFilename)	\
    (This)->lpVtbl -> SaveFileAs(This,pwszFilename)

#define IWMReaderAdvanced3_GetProtocolName(This,pwszProtocol,pcchProtocol)	\
    (This)->lpVtbl -> GetProtocolName(This,pwszProtocol,pcchProtocol)

#define IWMReaderAdvanced3_StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)	\
    (This)->lpVtbl -> StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)

#define IWMReaderAdvanced3_GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)

#define IWMReaderAdvanced3_SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)

#define IWMReaderAdvanced3_Preroll(This,cnsStart,cnsDuration,fRate)	\
    (This)->lpVtbl -> Preroll(This,cnsStart,cnsDuration,fRate)

#define IWMReaderAdvanced3_SetLogClientID(This,fLogClientID)	\
    (This)->lpVtbl -> SetLogClientID(This,fLogClientID)

#define IWMReaderAdvanced3_GetLogClientID(This,pfLogClientID)	\
    (This)->lpVtbl -> GetLogClientID(This,pfLogClientID)

#define IWMReaderAdvanced3_StopBuffering(This)	\
    (This)->lpVtbl -> StopBuffering(This)

#define IWMReaderAdvanced3_OpenStream(This,pStream,pCallback,pvContext)	\
    (This)->lpVtbl -> OpenStream(This,pStream,pCallback,pvContext)


#define IWMReaderAdvanced3_StopNetStreaming(This)	\
    (This)->lpVtbl -> StopNetStreaming(This)

#define IWMReaderAdvanced3_StartAtPosition(This,wStreamNum,pvOffsetStart,pvDuration,dwOffsetFormat,fRate,pvContext)	\
    (This)->lpVtbl -> StartAtPosition(This,wStreamNum,pvOffsetStart,pvDuration,dwOffsetFormat,fRate,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAdvanced3_StopNetStreaming_Proxy( 
    IWMReaderAdvanced3 * This);


void __RPC_STUB IWMReaderAdvanced3_StopNetStreaming_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced3_StartAtPosition_Proxy( 
    IWMReaderAdvanced3 * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ void *pvOffsetStart,
    /* [in] */ void *pvDuration,
    /* [in] */ WMT_OFFSET_FORMAT dwOffsetFormat,
    /* [in] */ float fRate,
    /* [in] */ void *pvContext);


void __RPC_STUB IWMReaderAdvanced3_StartAtPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAdvanced3_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAllocatorEx_INTERFACE_DEFINED__
#define __IWMReaderAllocatorEx_INTERFACE_DEFINED__

/* interface IWMReaderAllocatorEx */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAllocatorEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9F762FA7-A22E-428d-93C9-AC82F3AAFE5A")
    IWMReaderAllocatorEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocateForStreamEx( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForOutputEx( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAllocatorExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMReaderAllocatorEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMReaderAllocatorEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMReaderAllocatorEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateForStreamEx )( 
            IWMReaderAllocatorEx * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateForOutputEx )( 
            IWMReaderAllocatorEx * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void *pvContext);
        
        END_INTERFACE
    } IWMReaderAllocatorExVtbl;

    interface IWMReaderAllocatorEx
    {
        CONST_VTBL struct IWMReaderAllocatorExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAllocatorEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAllocatorEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAllocatorEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAllocatorEx_AllocateForStreamEx(This,wStreamNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)	\
    (This)->lpVtbl -> AllocateForStreamEx(This,wStreamNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)

#define IWMReaderAllocatorEx_AllocateForOutputEx(This,dwOutputNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)	\
    (This)->lpVtbl -> AllocateForOutputEx(This,dwOutputNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAllocatorEx_AllocateForStreamEx_Proxy( 
    IWMReaderAllocatorEx * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer **ppBuffer,
    /* [in] */ DWORD dwFlags,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ void *pvContext);


void __RPC_STUB IWMReaderAllocatorEx_AllocateForStreamEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAllocatorEx_AllocateForOutputEx_Proxy( 
    IWMReaderAllocatorEx * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer **ppBuffer,
    /* [in] */ DWORD dwFlags,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ void *pvContext);


void __RPC_STUB IWMReaderAllocatorEx_AllocateForOutputEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAllocatorEx_INTERFACE_DEFINED__ */


#ifndef __IWMReaderTypeNegotiation_INTERFACE_DEFINED__
#define __IWMReaderTypeNegotiation_INTERFACE_DEFINED__

/* interface IWMReaderTypeNegotiation */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderTypeNegotiation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FDBE5592-81A1-41ea-93BD-735CAD1ADC05")
    IWMReaderTypeNegotiation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TryOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps *pOutput) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderTypeNegotiationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMReaderTypeNegotiation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMReaderTypeNegotiation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMReaderTypeNegotiation * This);
        
        HRESULT ( STDMETHODCALLTYPE *TryOutputProps )( 
            IWMReaderTypeNegotiation * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps *pOutput);
        
        END_INTERFACE
    } IWMReaderTypeNegotiationVtbl;

    interface IWMReaderTypeNegotiation
    {
        CONST_VTBL struct IWMReaderTypeNegotiationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderTypeNegotiation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderTypeNegotiation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderTypeNegotiation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderTypeNegotiation_TryOutputProps(This,dwOutputNum,pOutput)	\
    (This)->lpVtbl -> TryOutputProps(This,dwOutputNum,pOutput)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderTypeNegotiation_TryOutputProps_Proxy( 
    IWMReaderTypeNegotiation * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ IWMOutputMediaProps *pOutput);


void __RPC_STUB IWMReaderTypeNegotiation_TryOutputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderTypeNegotiation_INTERFACE_DEFINED__ */


#ifndef __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__
#define __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__

/* interface IWMReaderCallbackAdvanced */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderCallbackAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BEB-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderCallbackAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStreamSample( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTime( 
            /* [in] */ QWORD cnsCurrentTime,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStreamSelection( 
            /* [in] */ WORD wStreamCount,
            /* [in] */ WORD *pStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION *pSelections,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnOutputPropsChanged( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ WM_MEDIA_TYPE *pMediaType,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForStream( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForOutput( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [in] */ void *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderCallbackAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMReaderCallbackAdvanced * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMReaderCallbackAdvanced * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMReaderCallbackAdvanced * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStreamSample )( 
            IWMReaderCallbackAdvanced * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *OnTime )( 
            IWMReaderCallbackAdvanced * This,
            /* [in] */ QWORD cnsCurrentTime,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *OnStreamSelection )( 
            IWMReaderCallbackAdvanced * This,
            /* [in] */ WORD wStreamCount,
            /* [in] */ WORD *pStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION *pSelections,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *OnOutputPropsChanged )( 
            IWMReaderCallbackAdvanced * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ WM_MEDIA_TYPE *pMediaType,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateForStream )( 
            IWMReaderCallbackAdvanced * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateForOutput )( 
            IWMReaderCallbackAdvanced * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [in] */ void *pvContext);
        
        END_INTERFACE
    } IWMReaderCallbackAdvancedVtbl;

    interface IWMReaderCallbackAdvanced
    {
        CONST_VTBL struct IWMReaderCallbackAdvancedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderCallbackAdvanced_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderCallbackAdvanced_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderCallbackAdvanced_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderCallbackAdvanced_OnStreamSample(This,wStreamNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)	\
    (This)->lpVtbl -> OnStreamSample(This,wStreamNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)

#define IWMReaderCallbackAdvanced_OnTime(This,cnsCurrentTime,pvContext)	\
    (This)->lpVtbl -> OnTime(This,cnsCurrentTime,pvContext)

#define IWMReaderCallbackAdvanced_OnStreamSelection(This,wStreamCount,pStreamNumbers,pSelections,pvContext)	\
    (This)->lpVtbl -> OnStreamSelection(This,wStreamCount,pStreamNumbers,pSelections,pvContext)

#define IWMReaderCallbackAdvanced_OnOutputPropsChanged(This,dwOutputNum,pMediaType,pvContext)	\
    (This)->lpVtbl -> OnOutputPropsChanged(This,dwOutputNum,pMediaType,pvContext)

#define IWMReaderCallbackAdvanced_AllocateForStream(This,wStreamNum,cbBuffer,ppBuffer,pvContext)	\
    (This)->lpVtbl -> AllocateForStream(This,wStreamNum,cbBuffer,ppBuffer,pvContext)

#define IWMReaderCallbackAdvanced_AllocateForOutput(This,dwOutputNum,cbBuffer,ppBuffer,pvContext)	\
    (This)->lpVtbl -> AllocateForOutput(This,dwOutputNum,cbBuffer,ppBuffer,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnStreamSample_Proxy( 
    IWMReaderCallbackAdvanced * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer *pSample,
    /* [in] */ void *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnStreamSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnTime_Proxy( 
    IWMReaderCallbackAdvanced * This,
    /* [in] */ QWORD cnsCurrentTime,
    /* [in] */ void *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnStreamSelection_Proxy( 
    IWMReaderCallbackAdvanced * This,
    /* [in] */ WORD wStreamCount,
    /* [in] */ WORD *pStreamNumbers,
    /* [in] */ WMT_STREAM_SELECTION *pSelections,
    /* [in] */ void *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnStreamSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnOutputPropsChanged_Proxy( 
    IWMReaderCallbackAdvanced * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ WM_MEDIA_TYPE *pMediaType,
    /* [in] */ void *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnOutputPropsChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_AllocateForStream_Proxy( 
    IWMReaderCallbackAdvanced * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer **ppBuffer,
    /* [in] */ void *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_AllocateForStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_AllocateForOutput_Proxy( 
    IWMReaderCallbackAdvanced * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer **ppBuffer,
    /* [in] */ void *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_AllocateForOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__ */


#ifndef __IWMDRMReader_INTERFACE_DEFINED__
#define __IWMDRMReader_INTERFACE_DEFINED__

/* interface IWMDRMReader */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMDRMReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D2827540-3EE7-432c-B14C-DC17F085D3B3")
    IWMDRMReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AcquireLicense( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Individualize( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelIndividualization( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MonitorLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelMonitorLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDRMProperty( 
            /* [in] */ LPCWSTR pwstrName,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDRMProperty( 
            /* [in] */ LPCWSTR pwstrName,
            /* [out] */ WMT_ATTR_DATATYPE *pdwType,
            /* [out] */ BYTE *pValue,
            /* [out] */ WORD *pcbLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDRMReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMDRMReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMDRMReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMDRMReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *AcquireLicense )( 
            IWMDRMReader * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CancelLicenseAcquisition )( 
            IWMDRMReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *Individualize )( 
            IWMDRMReader * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CancelIndividualization )( 
            IWMDRMReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *MonitorLicenseAcquisition )( 
            IWMDRMReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *CancelMonitorLicenseAcquisition )( 
            IWMDRMReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDRMProperty )( 
            IWMDRMReader * This,
            /* [in] */ LPCWSTR pwstrName,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetDRMProperty )( 
            IWMDRMReader * This,
            /* [in] */ LPCWSTR pwstrName,
            /* [out] */ WMT_ATTR_DATATYPE *pdwType,
            /* [out] */ BYTE *pValue,
            /* [out] */ WORD *pcbLength);
        
        END_INTERFACE
    } IWMDRMReaderVtbl;

    interface IWMDRMReader
    {
        CONST_VTBL struct IWMDRMReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDRMReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDRMReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDRMReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDRMReader_AcquireLicense(This,dwFlags)	\
    (This)->lpVtbl -> AcquireLicense(This,dwFlags)

#define IWMDRMReader_CancelLicenseAcquisition(This)	\
    (This)->lpVtbl -> CancelLicenseAcquisition(This)

#define IWMDRMReader_Individualize(This,dwFlags)	\
    (This)->lpVtbl -> Individualize(This,dwFlags)

#define IWMDRMReader_CancelIndividualization(This)	\
    (This)->lpVtbl -> CancelIndividualization(This)

#define IWMDRMReader_MonitorLicenseAcquisition(This)	\
    (This)->lpVtbl -> MonitorLicenseAcquisition(This)

#define IWMDRMReader_CancelMonitorLicenseAcquisition(This)	\
    (This)->lpVtbl -> CancelMonitorLicenseAcquisition(This)

#define IWMDRMReader_SetDRMProperty(This,pwstrName,dwType,pValue,cbLength)	\
    (This)->lpVtbl -> SetDRMProperty(This,pwstrName,dwType,pValue,cbLength)

#define IWMDRMReader_GetDRMProperty(This,pwstrName,pdwType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetDRMProperty(This,pwstrName,pdwType,pValue,pcbLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDRMReader_AcquireLicense_Proxy( 
    IWMDRMReader * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IWMDRMReader_AcquireLicense_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_CancelLicenseAcquisition_Proxy( 
    IWMDRMReader * This);


void __RPC_STUB IWMDRMReader_CancelLicenseAcquisition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_Individualize_Proxy( 
    IWMDRMReader * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IWMDRMReader_Individualize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_CancelIndividualization_Proxy( 
    IWMDRMReader * This);


void __RPC_STUB IWMDRMReader_CancelIndividualization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_MonitorLicenseAcquisition_Proxy( 
    IWMDRMReader * This);


void __RPC_STUB IWMDRMReader_MonitorLicenseAcquisition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_CancelMonitorLicenseAcquisition_Proxy( 
    IWMDRMReader * This);


void __RPC_STUB IWMDRMReader_CancelMonitorLicenseAcquisition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_SetDRMProperty_Proxy( 
    IWMDRMReader * This,
    /* [in] */ LPCWSTR pwstrName,
    /* [in] */ WMT_ATTR_DATATYPE dwType,
    /* [in] */ const BYTE *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMDRMReader_SetDRMProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_GetDRMProperty_Proxy( 
    IWMDRMReader * This,
    /* [in] */ LPCWSTR pwstrName,
    /* [out] */ WMT_ATTR_DATATYPE *pdwType,
    /* [out] */ BYTE *pValue,
    /* [out] */ WORD *pcbLength);


void __RPC_STUB IWMDRMReader_GetDRMProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDRMReader_INTERFACE_DEFINED__ */


#ifndef __IWMReaderNetworkConfig_INTERFACE_DEFINED__
#define __IWMReaderNetworkConfig_INTERFACE_DEFINED__

/* interface IWMReaderNetworkConfig */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderNetworkConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BEC-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderNetworkConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBufferingTime( 
            /* [out] */ QWORD *pcnsBufferingTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferingTime( 
            /* [in] */ QWORD cnsBufferingTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUDPPortRanges( 
            /* [out] */ WM_PORT_NUMBER_RANGE *pRangeArray,
            /* [out][in] */ DWORD *pcRanges) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUDPPortRanges( 
            /* [in] */ WM_PORT_NUMBER_RANGE *pRangeArray,
            /* [in] */ DWORD cRanges) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxySettings( 
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS *pProxySetting) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxySettings( 
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS ProxySetting) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyHostName( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR *pwszHostName,
            /* [out][in] */ DWORD *pcchHostName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyHostName( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszHostName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyPort( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ DWORD *pdwPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyPort( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ DWORD dwPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyExceptionList( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR *pwszExceptionList,
            /* [out][in] */ DWORD *pcchExceptionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyExceptionList( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszExceptionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyBypassForLocal( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ BOOL *pfBypassForLocal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyBypassForLocal( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ BOOL fBypassForLocal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetForceRerunAutoProxyDetection( 
            /* [out] */ BOOL *pfForceRerunDetection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetForceRerunAutoProxyDetection( 
            /* [in] */ BOOL fForceRerunDetection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableMulticast( 
            /* [out] */ BOOL *pfEnableMulticast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableMulticast( 
            /* [in] */ BOOL fEnableMulticast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableHTTP( 
            /* [out] */ BOOL *pfEnableHTTP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableHTTP( 
            /* [in] */ BOOL fEnableHTTP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableUDP( 
            /* [out] */ BOOL *pfEnableUDP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableUDP( 
            /* [in] */ BOOL fEnableUDP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableTCP( 
            /* [out] */ BOOL *pfEnableTCP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableTCP( 
            /* [in] */ BOOL fEnableTCP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetProtocolRollover( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionBandwidth( 
            /* [out] */ DWORD *pdwConnectionBandwidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConnectionBandwidth( 
            /* [in] */ DWORD dwConnectionBandwidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumProtocolsSupported( 
            /* [out] */ DWORD *pcProtocols) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedProtocolName( 
            /* [in] */ DWORD dwProtocolNum,
            /* [out] */ WCHAR *pwszProtocolName,
            /* [out][in] */ DWORD *pcchProtocolName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddLoggingUrl( 
            /* [in] */ LPCWSTR pwszUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLoggingUrl( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pwszUrl,
            /* [out][in] */ DWORD *pcchUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLoggingUrlCount( 
            /* [out] */ DWORD *pdwUrlCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetLoggingUrlList( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderNetworkConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMReaderNetworkConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMReaderNetworkConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferingTime )( 
            IWMReaderNetworkConfig * This,
            /* [out] */ QWORD *pcnsBufferingTime);
        
        HRESULT ( STDMETHODCALLTYPE *SetBufferingTime )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ QWORD cnsBufferingTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetUDPPortRanges )( 
            IWMReaderNetworkConfig * This,
            /* [out] */ WM_PORT_NUMBER_RANGE *pRangeArray,
            /* [out][in] */ DWORD *pcRanges);
        
        HRESULT ( STDMETHODCALLTYPE *SetUDPPortRanges )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ WM_PORT_NUMBER_RANGE *pRangeArray,
            /* [in] */ DWORD cRanges);
        
        HRESULT ( STDMETHODCALLTYPE *GetProxySettings )( 
            IWMReaderNetworkConfig * This,
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS *pProxySetting);
        
        HRESULT ( STDMETHODCALLTYPE *SetProxySettings )( 
            IWMReaderNetworkConfig * This,
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS ProxySetting);
        
        HRESULT ( STDMETHODCALLTYPE *GetProxyHostName )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR *pwszHostName,
            /* [out][in] */ DWORD *pcchHostName);
        
        HRESULT ( STDMETHODCALLTYPE *SetProxyHostName )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszHostName);
        
        HRESULT ( STDMETHODCALLTYPE *GetProxyPort )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ DWORD *pdwPort);
        
        HRESULT ( STDMETHODCALLTYPE *SetProxyPort )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ DWORD dwPort);
        
        HRESULT ( STDMETHODCALLTYPE *GetProxyExceptionList )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR *pwszExceptionList,
            /* [out][in] */ DWORD *pcchExceptionList);
        
        HRESULT ( STDMETHODCALLTYPE *SetProxyExceptionList )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszExceptionList);
        
        HRESULT ( STDMETHODCALLTYPE *GetProxyBypassForLocal )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ BOOL *pfBypassForLocal);
        
        HRESULT ( STDMETHODCALLTYPE *SetProxyBypassForLocal )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ BOOL fBypassForLocal);
        
        HRESULT ( STDMETHODCALLTYPE *GetForceRerunAutoProxyDetection )( 
            IWMReaderNetworkConfig * This,
            /* [out] */ BOOL *pfForceRerunDetection);
        
        HRESULT ( STDMETHODCALLTYPE *SetForceRerunAutoProxyDetection )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ BOOL fForceRerunDetection);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnableMulticast )( 
            IWMReaderNetworkConfig * This,
            /* [out] */ BOOL *pfEnableMulticast);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnableMulticast )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ BOOL fEnableMulticast);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnableHTTP )( 
            IWMReaderNetworkConfig * This,
            /* [out] */ BOOL *pfEnableHTTP);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnableHTTP )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ BOOL fEnableHTTP);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnableUDP )( 
            IWMReaderNetworkConfig * This,
            /* [out] */ BOOL *pfEnableUDP);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnableUDP )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ BOOL fEnableUDP);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnableTCP )( 
            IWMReaderNetworkConfig * This,
            /* [out] */ BOOL *pfEnableTCP);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnableTCP )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ BOOL fEnableTCP);
        
        HRESULT ( STDMETHODCALLTYPE *ResetProtocolRollover )( 
            IWMReaderNetworkConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionBandwidth )( 
            IWMReaderNetworkConfig * This,
            /* [out] */ DWORD *pdwConnectionBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE *SetConnectionBandwidth )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ DWORD dwConnectionBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumProtocolsSupported )( 
            IWMReaderNetworkConfig * This,
            /* [out] */ DWORD *pcProtocols);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedProtocolName )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ DWORD dwProtocolNum,
            /* [out] */ WCHAR *pwszProtocolName,
            /* [out][in] */ DWORD *pcchProtocolName);
        
        HRESULT ( STDMETHODCALLTYPE *AddLoggingUrl )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ LPCWSTR pwszUrl);
        
        HRESULT ( STDMETHODCALLTYPE *GetLoggingUrl )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pwszUrl,
            /* [out][in] */ DWORD *pcchUrl);
        
        HRESULT ( STDMETHODCALLTYPE *GetLoggingUrlCount )( 
            IWMReaderNetworkConfig * This,
            /* [out] */ DWORD *pdwUrlCount);
        
        HRESULT ( STDMETHODCALLTYPE *ResetLoggingUrlList )( 
            IWMReaderNetworkConfig * This);
        
        END_INTERFACE
    } IWMReaderNetworkConfigVtbl;

    interface IWMReaderNetworkConfig
    {
        CONST_VTBL struct IWMReaderNetworkConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderNetworkConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderNetworkConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderNetworkConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderNetworkConfig_GetBufferingTime(This,pcnsBufferingTime)	\
    (This)->lpVtbl -> GetBufferingTime(This,pcnsBufferingTime)

#define IWMReaderNetworkConfig_SetBufferingTime(This,cnsBufferingTime)	\
    (This)->lpVtbl -> SetBufferingTime(This,cnsBufferingTime)

#define IWMReaderNetworkConfig_GetUDPPortRanges(This,pRangeArray,pcRanges)	\
    (This)->lpVtbl -> GetUDPPortRanges(This,pRangeArray,pcRanges)

#define IWMReaderNetworkConfig_SetUDPPortRanges(This,pRangeArray,cRanges)	\
    (This)->lpVtbl -> SetUDPPortRanges(This,pRangeArray,cRanges)

#define IWMReaderNetworkConfig_GetProxySettings(This,pwszProtocol,pProxySetting)	\
    (This)->lpVtbl -> GetProxySettings(This,pwszProtocol,pProxySetting)

#define IWMReaderNetworkConfig_SetProxySettings(This,pwszProtocol,ProxySetting)	\
    (This)->lpVtbl -> SetProxySettings(This,pwszProtocol,ProxySetting)

#define IWMReaderNetworkConfig_GetProxyHostName(This,pwszProtocol,pwszHostName,pcchHostName)	\
    (This)->lpVtbl -> GetProxyHostName(This,pwszProtocol,pwszHostName,pcchHostName)

#define IWMReaderNetworkConfig_SetProxyHostName(This,pwszProtocol,pwszHostName)	\
    (This)->lpVtbl -> SetProxyHostName(This,pwszProtocol,pwszHostName)

#define IWMReaderNetworkConfig_GetProxyPort(This,pwszProtocol,pdwPort)	\
    (This)->lpVtbl -> GetProxyPort(This,pwszProtocol,pdwPort)

#define IWMReaderNetworkConfig_SetProxyPort(This,pwszProtocol,dwPort)	\
    (This)->lpVtbl -> SetProxyPort(This,pwszProtocol,dwPort)

#define IWMReaderNetworkConfig_GetProxyExceptionList(This,pwszProtocol,pwszExceptionList,pcchExceptionList)	\
    (This)->lpVtbl -> GetProxyExceptionList(This,pwszProtocol,pwszExceptionList,pcchExceptionList)

#define IWMReaderNetworkConfig_SetProxyExceptionList(This,pwszProtocol,pwszExceptionList)	\
    (This)->lpVtbl -> SetProxyExceptionList(This,pwszProtocol,pwszExceptionList)

#define IWMReaderNetworkConfig_GetProxyBypassForLocal(This,pwszProtocol,pfBypassForLocal)	\
    (This)->lpVtbl -> GetProxyBypassForLocal(This,pwszProtocol,pfBypassForLocal)

#define IWMReaderNetworkConfig_SetProxyBypassForLocal(This,pwszProtocol,fBypassForLocal)	\
    (This)->lpVtbl -> SetProxyBypassForLocal(This,pwszProtocol,fBypassForLocal)

#define IWMReaderNetworkConfig_GetForceRerunAutoProxyDetection(This,pfForceRerunDetection)	\
    (This)->lpVtbl -> GetForceRerunAutoProxyDetection(This,pfForceRerunDetection)

#define IWMReaderNetworkConfig_SetForceRerunAutoProxyDetection(This,fForceRerunDetection)	\
    (This)->lpVtbl -> SetForceRerunAutoProxyDetection(This,fForceRerunDetection)

#define IWMReaderNetworkConfig_GetEnableMulticast(This,pfEnableMulticast)	\
    (This)->lpVtbl -> GetEnableMulticast(This,pfEnableMulticast)

#define IWMReaderNetworkConfig_SetEnableMulticast(This,fEnableMulticast)	\
    (This)->lpVtbl -> SetEnableMulticast(This,fEnableMulticast)

#define IWMReaderNetworkConfig_GetEnableHTTP(This,pfEnableHTTP)	\
    (This)->lpVtbl -> GetEnableHTTP(This,pfEnableHTTP)

#define IWMReaderNetworkConfig_SetEnableHTTP(This,fEnableHTTP)	\
    (This)->lpVtbl -> SetEnableHTTP(This,fEnableHTTP)

#define IWMReaderNetworkConfig_GetEnableUDP(This,pfEnableUDP)	\
    (This)->lpVtbl -> GetEnableUDP(This,pfEnableUDP)

#define IWMReaderNetworkConfig_SetEnableUDP(This,fEnableUDP)	\
    (This)->lpVtbl -> SetEnableUDP(This,fEnableUDP)

#define IWMReaderNetworkConfig_GetEnableTCP(This,pfEnableTCP)	\
    (This)->lpVtbl -> GetEnableTCP(This,pfEnableTCP)

#define IWMReaderNetworkConfig_SetEnableTCP(This,fEnableTCP)	\
    (This)->lpVtbl -> SetEnableTCP(This,fEnableTCP)

#define IWMReaderNetworkConfig_ResetProtocolRollover(This)	\
    (This)->lpVtbl -> ResetProtocolRollover(This)

#define IWMReaderNetworkConfig_GetConnectionBandwidth(This,pdwConnectionBandwidth)	\
    (This)->lpVtbl -> GetConnectionBandwidth(This,pdwConnectionBandwidth)

#define IWMReaderNetworkConfig_SetConnectionBandwidth(This,dwConnectionBandwidth)	\
    (This)->lpVtbl -> SetConnectionBandwidth(This,dwConnectionBandwidth)

#define IWMReaderNetworkConfig_GetNumProtocolsSupported(This,pcProtocols)	\
    (This)->lpVtbl -> GetNumProtocolsSupported(This,pcProtocols)

#define IWMReaderNetworkConfig_GetSupportedProtocolName(This,dwProtocolNum,pwszProtocolName,pcchProtocolName)	\
    (This)->lpVtbl -> GetSupportedProtocolName(This,dwProtocolNum,pwszProtocolName,pcchProtocolName)

#define IWMReaderNetworkConfig_AddLoggingUrl(This,pwszUrl)	\
    (This)->lpVtbl -> AddLoggingUrl(This,pwszUrl)

#define IWMReaderNetworkConfig_GetLoggingUrl(This,dwIndex,pwszUrl,pcchUrl)	\
    (This)->lpVtbl -> GetLoggingUrl(This,dwIndex,pwszUrl,pcchUrl)

#define IWMReaderNetworkConfig_GetLoggingUrlCount(This,pdwUrlCount)	\
    (This)->lpVtbl -> GetLoggingUrlCount(This,pdwUrlCount)

#define IWMReaderNetworkConfig_ResetLoggingUrlList(This)	\
    (This)->lpVtbl -> ResetLoggingUrlList(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetBufferingTime_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [out] */ QWORD *pcnsBufferingTime);


void __RPC_STUB IWMReaderNetworkConfig_GetBufferingTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetBufferingTime_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [in] */ QWORD cnsBufferingTime);


void __RPC_STUB IWMReaderNetworkConfig_SetBufferingTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetUDPPortRanges_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [out] */ WM_PORT_NUMBER_RANGE *pRangeArray,
    /* [out][in] */ DWORD *pcRanges);


void __RPC_STUB IWMReaderNetworkConfig_GetUDPPortRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetUDPPortRanges_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [in] */ WM_PORT_NUMBER_RANGE *pRangeArray,
    /* [in] */ DWORD cRanges);


void __RPC_STUB IWMReaderNetworkConfig_SetUDPPortRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxySettings_Proxy( 
    IWMReaderNetworkConfig * This,
    LPCWSTR pwszProtocol,
    WMT_PROXY_SETTINGS *pProxySetting);


void __RPC_STUB IWMReaderNetworkConfig_GetProxySettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxySettings_Proxy( 
    IWMReaderNetworkConfig * This,
    LPCWSTR pwszProtocol,
    WMT_PROXY_SETTINGS ProxySetting);


void __RPC_STUB IWMReaderNetworkConfig_SetProxySettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyHostName_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ WCHAR *pwszHostName,
    /* [out][in] */ DWORD *pcchHostName);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyHostName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyHostName_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ LPCWSTR pwszHostName);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyHostName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyPort_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ DWORD *pdwPort);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyPort_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ DWORD dwPort);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyExceptionList_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ WCHAR *pwszExceptionList,
    /* [out][in] */ DWORD *pcchExceptionList);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyExceptionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyExceptionList_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ LPCWSTR pwszExceptionList);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyExceptionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyBypassForLocal_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ BOOL *pfBypassForLocal);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyBypassForLocal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyBypassForLocal_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ BOOL fBypassForLocal);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyBypassForLocal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetForceRerunAutoProxyDetection_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [out] */ BOOL *pfForceRerunDetection);


void __RPC_STUB IWMReaderNetworkConfig_GetForceRerunAutoProxyDetection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetForceRerunAutoProxyDetection_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [in] */ BOOL fForceRerunDetection);


void __RPC_STUB IWMReaderNetworkConfig_SetForceRerunAutoProxyDetection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableMulticast_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [out] */ BOOL *pfEnableMulticast);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableMulticast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableMulticast_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [in] */ BOOL fEnableMulticast);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableMulticast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableHTTP_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [out] */ BOOL *pfEnableHTTP);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableHTTP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableHTTP_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [in] */ BOOL fEnableHTTP);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableHTTP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableUDP_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [out] */ BOOL *pfEnableUDP);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableUDP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableUDP_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [in] */ BOOL fEnableUDP);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableUDP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableTCP_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [out] */ BOOL *pfEnableTCP);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableTCP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableTCP_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [in] */ BOOL fEnableTCP);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableTCP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_ResetProtocolRollover_Proxy( 
    IWMReaderNetworkConfig * This);


void __RPC_STUB IWMReaderNetworkConfig_ResetProtocolRollover_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetConnectionBandwidth_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [out] */ DWORD *pdwConnectionBandwidth);


void __RPC_STUB IWMReaderNetworkConfig_GetConnectionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetConnectionBandwidth_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [in] */ DWORD dwConnectionBandwidth);


void __RPC_STUB IWMReaderNetworkConfig_SetConnectionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetNumProtocolsSupported_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [out] */ DWORD *pcProtocols);


void __RPC_STUB IWMReaderNetworkConfig_GetNumProtocolsSupported_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetSupportedProtocolName_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [in] */ DWORD dwProtocolNum,
    /* [out] */ WCHAR *pwszProtocolName,
    /* [out][in] */ DWORD *pcchProtocolName);


void __RPC_STUB IWMReaderNetworkConfig_GetSupportedProtocolName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_AddLoggingUrl_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [in] */ LPCWSTR pwszUrl);


void __RPC_STUB IWMReaderNetworkConfig_AddLoggingUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetLoggingUrl_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ LPWSTR pwszUrl,
    /* [out][in] */ DWORD *pcchUrl);


void __RPC_STUB IWMReaderNetworkConfig_GetLoggingUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetLoggingUrlCount_Proxy( 
    IWMReaderNetworkConfig * This,
    /* [out] */ DWORD *pdwUrlCount);


void __RPC_STUB IWMReaderNetworkConfig_GetLoggingUrlCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_ResetLoggingUrlList_Proxy( 
    IWMReaderNetworkConfig * This);


void __RPC_STUB IWMReaderNetworkConfig_ResetLoggingUrlList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderNetworkConfig_INTERFACE_DEFINED__ */


#ifndef __IWMReaderStreamClock_INTERFACE_DEFINED__
#define __IWMReaderStreamClock_INTERFACE_DEFINED__

/* interface IWMReaderStreamClock */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderStreamClock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BED-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderStreamClock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [in] */ QWORD *pcnsNow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimer( 
            /* [in] */ QWORD cnsWhen,
            /* [in] */ void *pvParam,
            /* [out] */ DWORD *pdwTimerId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KillTimer( 
            /* [in] */ DWORD dwTimerId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderStreamClockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMReaderStreamClock * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMReaderStreamClock * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMReaderStreamClock * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IWMReaderStreamClock * This,
            /* [in] */ QWORD *pcnsNow);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimer )( 
            IWMReaderStreamClock * This,
            /* [in] */ QWORD cnsWhen,
            /* [in] */ void *pvParam,
            /* [out] */ DWORD *pdwTimerId);
        
        HRESULT ( STDMETHODCALLTYPE *KillTimer )( 
            IWMReaderStreamClock * This,
            /* [in] */ DWORD dwTimerId);
        
        END_INTERFACE
    } IWMReaderStreamClockVtbl;

    interface IWMReaderStreamClock
    {
        CONST_VTBL struct IWMReaderStreamClockVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderStreamClock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderStreamClock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderStreamClock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderStreamClock_GetTime(This,pcnsNow)	\
    (This)->lpVtbl -> GetTime(This,pcnsNow)

#define IWMReaderStreamClock_SetTimer(This,cnsWhen,pvParam,pdwTimerId)	\
    (This)->lpVtbl -> SetTimer(This,cnsWhen,pvParam,pdwTimerId)

#define IWMReaderStreamClock_KillTimer(This,dwTimerId)	\
    (This)->lpVtbl -> KillTimer(This,dwTimerId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderStreamClock_GetTime_Proxy( 
    IWMReaderStreamClock * This,
    /* [in] */ QWORD *pcnsNow);


void __RPC_STUB IWMReaderStreamClock_GetTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderStreamClock_SetTimer_Proxy( 
    IWMReaderStreamClock * This,
    /* [in] */ QWORD cnsWhen,
    /* [in] */ void *pvParam,
    /* [out] */ DWORD *pdwTimerId);


void __RPC_STUB IWMReaderStreamClock_SetTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderStreamClock_KillTimer_Proxy( 
    IWMReaderStreamClock * This,
    /* [in] */ DWORD dwTimerId);


void __RPC_STUB IWMReaderStreamClock_KillTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderStreamClock_INTERFACE_DEFINED__ */


#ifndef __IWMIndexer_INTERFACE_DEFINED__
#define __IWMIndexer_INTERFACE_DEFINED__

/* interface IWMIndexer */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMIndexer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d7cdc71-9888-11d3-8edc-00c04f6109cf")
    IWMIndexer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartIndexing( 
            /* [in] */ const WCHAR *pwszURL,
            /* [in] */ IWMStatusCallback *pCallback,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMIndexerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMIndexer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMIndexer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMIndexer * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartIndexing )( 
            IWMIndexer * This,
            /* [in] */ const WCHAR *pwszURL,
            /* [in] */ IWMStatusCallback *pCallback,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IWMIndexer * This);
        
        END_INTERFACE
    } IWMIndexerVtbl;

    interface IWMIndexer
    {
        CONST_VTBL struct IWMIndexerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMIndexer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMIndexer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMIndexer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMIndexer_StartIndexing(This,pwszURL,pCallback,pvContext)	\
    (This)->lpVtbl -> StartIndexing(This,pwszURL,pCallback,pvContext)

#define IWMIndexer_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMIndexer_StartIndexing_Proxy( 
    IWMIndexer * This,
    /* [in] */ const WCHAR *pwszURL,
    /* [in] */ IWMStatusCallback *pCallback,
    /* [in] */ void *pvContext);


void __RPC_STUB IWMIndexer_StartIndexing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMIndexer_Cancel_Proxy( 
    IWMIndexer * This);


void __RPC_STUB IWMIndexer_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMIndexer_INTERFACE_DEFINED__ */


#ifndef __IWMIndexer2_INTERFACE_DEFINED__
#define __IWMIndexer2_INTERFACE_DEFINED__

/* interface IWMIndexer2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMIndexer2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B70F1E42-6255-4df0-A6B9-02B212D9E2BB")
    IWMIndexer2 : public IWMIndexer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ WMT_INDEXER_TYPE nIndexerType,
            /* [in] */ void *pvInterval,
            /* [in] */ void *pvIndexType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMIndexer2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMIndexer2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMIndexer2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMIndexer2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartIndexing )( 
            IWMIndexer2 * This,
            /* [in] */ const WCHAR *pwszURL,
            /* [in] */ IWMStatusCallback *pCallback,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IWMIndexer2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            IWMIndexer2 * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ WMT_INDEXER_TYPE nIndexerType,
            /* [in] */ void *pvInterval,
            /* [in] */ void *pvIndexType);
        
        END_INTERFACE
    } IWMIndexer2Vtbl;

    interface IWMIndexer2
    {
        CONST_VTBL struct IWMIndexer2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMIndexer2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMIndexer2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMIndexer2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMIndexer2_StartIndexing(This,pwszURL,pCallback,pvContext)	\
    (This)->lpVtbl -> StartIndexing(This,pwszURL,pCallback,pvContext)

#define IWMIndexer2_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)


#define IWMIndexer2_Configure(This,wStreamNum,nIndexerType,pvInterval,pvIndexType)	\
    (This)->lpVtbl -> Configure(This,wStreamNum,nIndexerType,pvInterval,pvIndexType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMIndexer2_Configure_Proxy( 
    IWMIndexer2 * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ WMT_INDEXER_TYPE nIndexerType,
    /* [in] */ void *pvInterval,
    /* [in] */ void *pvIndexType);


void __RPC_STUB IWMIndexer2_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMIndexer2_INTERFACE_DEFINED__ */


#ifndef __IWMLicenseBackup_INTERFACE_DEFINED__
#define __IWMLicenseBackup_INTERFACE_DEFINED__

/* interface IWMLicenseBackup */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMLicenseBackup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05E5AC9F-3FB6-4508-BB43-A4067BA1EBE8")
    IWMLicenseBackup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BackupLicenses( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseBackup( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMLicenseBackupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMLicenseBackup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMLicenseBackup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMLicenseBackup * This);
        
        HRESULT ( STDMETHODCALLTYPE *BackupLicenses )( 
            IWMLicenseBackup * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *CancelLicenseBackup )( 
            IWMLicenseBackup * This);
        
        END_INTERFACE
    } IWMLicenseBackupVtbl;

    interface IWMLicenseBackup
    {
        CONST_VTBL struct IWMLicenseBackupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMLicenseBackup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMLicenseBackup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMLicenseBackup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMLicenseBackup_BackupLicenses(This,dwFlags,pCallback)	\
    (This)->lpVtbl -> BackupLicenses(This,dwFlags,pCallback)

#define IWMLicenseBackup_CancelLicenseBackup(This)	\
    (This)->lpVtbl -> CancelLicenseBackup(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMLicenseBackup_BackupLicenses_Proxy( 
    IWMLicenseBackup * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IWMStatusCallback *pCallback);


void __RPC_STUB IWMLicenseBackup_BackupLicenses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMLicenseBackup_CancelLicenseBackup_Proxy( 
    IWMLicenseBackup * This);


void __RPC_STUB IWMLicenseBackup_CancelLicenseBackup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMLicenseBackup_INTERFACE_DEFINED__ */


#ifndef __IWMLicenseRestore_INTERFACE_DEFINED__
#define __IWMLicenseRestore_INTERFACE_DEFINED__

/* interface IWMLicenseRestore */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMLicenseRestore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C70B6334-0544-4efb-A245-15E65A004A13")
    IWMLicenseRestore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RestoreLicenses( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseRestore( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMLicenseRestoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMLicenseRestore * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMLicenseRestore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMLicenseRestore * This);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreLicenses )( 
            IWMLicenseRestore * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *CancelLicenseRestore )( 
            IWMLicenseRestore * This);
        
        END_INTERFACE
    } IWMLicenseRestoreVtbl;

    interface IWMLicenseRestore
    {
        CONST_VTBL struct IWMLicenseRestoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMLicenseRestore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMLicenseRestore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMLicenseRestore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMLicenseRestore_RestoreLicenses(This,dwFlags,pCallback)	\
    (This)->lpVtbl -> RestoreLicenses(This,dwFlags,pCallback)

#define IWMLicenseRestore_CancelLicenseRestore(This)	\
    (This)->lpVtbl -> CancelLicenseRestore(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMLicenseRestore_RestoreLicenses_Proxy( 
    IWMLicenseRestore * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IWMStatusCallback *pCallback);


void __RPC_STUB IWMLicenseRestore_RestoreLicenses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMLicenseRestore_CancelLicenseRestore_Proxy( 
    IWMLicenseRestore * This);


void __RPC_STUB IWMLicenseRestore_CancelLicenseRestore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMLicenseRestore_INTERFACE_DEFINED__ */


#ifndef __IWMBackupRestoreProps_INTERFACE_DEFINED__
#define __IWMBackupRestoreProps_INTERFACE_DEFINED__

/* interface IWMBackupRestoreProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMBackupRestoreProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3C8E0DA6-996F-4ff3-A1AF-4838F9377E2E")
    IWMBackupRestoreProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropCount( 
            /* [out] */ WORD *pcProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropByIndex( 
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropByName( 
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProp( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProp( 
            /* [in] */ LPCWSTR pcwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllProps( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMBackupRestorePropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMBackupRestoreProps * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMBackupRestoreProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMBackupRestoreProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropCount )( 
            IWMBackupRestoreProps * This,
            /* [out] */ WORD *pcProps);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropByIndex )( 
            IWMBackupRestoreProps * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropByName )( 
            IWMBackupRestoreProps * This,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetProp )( 
            IWMBackupRestoreProps * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveProp )( 
            IWMBackupRestoreProps * This,
            /* [in] */ LPCWSTR pcwszName);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAllProps )( 
            IWMBackupRestoreProps * This);
        
        END_INTERFACE
    } IWMBackupRestorePropsVtbl;

    interface IWMBackupRestoreProps
    {
        CONST_VTBL struct IWMBackupRestorePropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMBackupRestoreProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMBackupRestoreProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMBackupRestoreProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMBackupRestoreProps_GetPropCount(This,pcProps)	\
    (This)->lpVtbl -> GetPropCount(This,pcProps)

#define IWMBackupRestoreProps_GetPropByIndex(This,wIndex,pwszName,pcchNameLen,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetPropByIndex(This,wIndex,pwszName,pcchNameLen,pType,pValue,pcbLength)

#define IWMBackupRestoreProps_GetPropByName(This,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetPropByName(This,pszName,pType,pValue,pcbLength)

#define IWMBackupRestoreProps_SetProp(This,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetProp(This,pszName,Type,pValue,cbLength)

#define IWMBackupRestoreProps_RemoveProp(This,pcwszName)	\
    (This)->lpVtbl -> RemoveProp(This,pcwszName)

#define IWMBackupRestoreProps_RemoveAllProps(This)	\
    (This)->lpVtbl -> RemoveAllProps(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_GetPropCount_Proxy( 
    IWMBackupRestoreProps * This,
    /* [out] */ WORD *pcProps);


void __RPC_STUB IWMBackupRestoreProps_GetPropCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_GetPropByIndex_Proxy( 
    IWMBackupRestoreProps * This,
    /* [in] */ WORD wIndex,
    /* [out] */ WCHAR *pwszName,
    /* [out][in] */ WORD *pcchNameLen,
    /* [out] */ WMT_ATTR_DATATYPE *pType,
    /* [out] */ BYTE *pValue,
    /* [out][in] */ WORD *pcbLength);


void __RPC_STUB IWMBackupRestoreProps_GetPropByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_GetPropByName_Proxy( 
    IWMBackupRestoreProps * This,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE *pType,
    /* [out] */ BYTE *pValue,
    /* [out][in] */ WORD *pcbLength);


void __RPC_STUB IWMBackupRestoreProps_GetPropByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_SetProp_Proxy( 
    IWMBackupRestoreProps * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMBackupRestoreProps_SetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_RemoveProp_Proxy( 
    IWMBackupRestoreProps * This,
    /* [in] */ LPCWSTR pcwszName);


void __RPC_STUB IWMBackupRestoreProps_RemoveProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_RemoveAllProps_Proxy( 
    IWMBackupRestoreProps * This);


void __RPC_STUB IWMBackupRestoreProps_RemoveAllProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMBackupRestoreProps_INTERFACE_DEFINED__ */


#ifndef __IWMCodecInfo_INTERFACE_DEFINED__
#define __IWMCodecInfo_INTERFACE_DEFINED__

/* interface IWMCodecInfo */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCodecInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A970F41E-34DE-4a98-B3BA-E4B3CA7528F0")
    IWMCodecInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodecInfoCount( 
            /* [in] */ REFGUID guidType,
            /* [out] */ DWORD *pcCodecs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecFormatCount( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ DWORD *pcFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecFormat( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig **ppIStreamConfig) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCodecInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMCodecInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMCodecInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMCodecInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecInfoCount )( 
            IWMCodecInfo * This,
            /* [in] */ REFGUID guidType,
            /* [out] */ DWORD *pcCodecs);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecFormatCount )( 
            IWMCodecInfo * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ DWORD *pcFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecFormat )( 
            IWMCodecInfo * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig **ppIStreamConfig);
        
        END_INTERFACE
    } IWMCodecInfoVtbl;

    interface IWMCodecInfo
    {
        CONST_VTBL struct IWMCodecInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCodecInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMCodecInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMCodecInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMCodecInfo_GetCodecInfoCount(This,guidType,pcCodecs)	\
    (This)->lpVtbl -> GetCodecInfoCount(This,guidType,pcCodecs)

#define IWMCodecInfo_GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)	\
    (This)->lpVtbl -> GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)

#define IWMCodecInfo_GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)	\
    (This)->lpVtbl -> GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMCodecInfo_GetCodecInfoCount_Proxy( 
    IWMCodecInfo * This,
    /* [in] */ REFGUID guidType,
    /* [out] */ DWORD *pcCodecs);


void __RPC_STUB IWMCodecInfo_GetCodecInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMCodecInfo_GetCodecFormatCount_Proxy( 
    IWMCodecInfo * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [out] */ DWORD *pcFormat);


void __RPC_STUB IWMCodecInfo_GetCodecFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMCodecInfo_GetCodecFormat_Proxy( 
    IWMCodecInfo * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [in] */ DWORD dwFormatIndex,
    /* [out] */ IWMStreamConfig **ppIStreamConfig);


void __RPC_STUB IWMCodecInfo_GetCodecFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMCodecInfo_INTERFACE_DEFINED__ */


#ifndef __IWMCodecInfo2_INTERFACE_DEFINED__
#define __IWMCodecInfo2_INTERFACE_DEFINED__

/* interface IWMCodecInfo2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCodecInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA65E273-B686-4056-91EC-DD768D4DF710")
    IWMCodecInfo2 : public IWMCodecInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodecName( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ WCHAR *wszName,
            /* [out] */ DWORD *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecFormatDesc( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig **ppIStreamConfig,
            /* [out] */ WCHAR *wszDesc,
            /* [out][in] */ DWORD *pcchDesc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCodecInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMCodecInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMCodecInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMCodecInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecInfoCount )( 
            IWMCodecInfo2 * This,
            /* [in] */ REFGUID guidType,
            /* [out] */ DWORD *pcCodecs);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecFormatCount )( 
            IWMCodecInfo2 * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ DWORD *pcFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecFormat )( 
            IWMCodecInfo2 * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig **ppIStreamConfig);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecName )( 
            IWMCodecInfo2 * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ WCHAR *wszName,
            /* [out] */ DWORD *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecFormatDesc )( 
            IWMCodecInfo2 * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig **ppIStreamConfig,
            /* [out] */ WCHAR *wszDesc,
            /* [out][in] */ DWORD *pcchDesc);
        
        END_INTERFACE
    } IWMCodecInfo2Vtbl;

    interface IWMCodecInfo2
    {
        CONST_VTBL struct IWMCodecInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCodecInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMCodecInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMCodecInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMCodecInfo2_GetCodecInfoCount(This,guidType,pcCodecs)	\
    (This)->lpVtbl -> GetCodecInfoCount(This,guidType,pcCodecs)

#define IWMCodecInfo2_GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)	\
    (This)->lpVtbl -> GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)

#define IWMCodecInfo2_GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)	\
    (This)->lpVtbl -> GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)


#define IWMCodecInfo2_GetCodecName(This,guidType,dwCodecIndex,wszName,pcchName)	\
    (This)->lpVtbl -> GetCodecName(This,guidType,dwCodecIndex,wszName,pcchName)

#define IWMCodecInfo2_GetCodecFormatDesc(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig,wszDesc,pcchDesc)	\
    (This)->lpVtbl -> GetCodecFormatDesc(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig,wszDesc,pcchDesc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMCodecInfo2_GetCodecName_Proxy( 
    IWMCodecInfo2 * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [out] */ WCHAR *wszName,
    /* [out] */ DWORD *pcchName);


void __RPC_STUB IWMCodecInfo2_GetCodecName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMCodecInfo2_GetCodecFormatDesc_Proxy( 
    IWMCodecInfo2 * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [in] */ DWORD dwFormatIndex,
    /* [out] */ IWMStreamConfig **ppIStreamConfig,
    /* [out] */ WCHAR *wszDesc,
    /* [out][in] */ DWORD *pcchDesc);


void __RPC_STUB IWMCodecInfo2_GetCodecFormatDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMCodecInfo2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\wmsdk\inc\wmsdk.h ===
#pragma once
//============================================================================
//
//  Microsoft Windows Media Technology
//  Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved.
//
//  File:        wmsdk.h
//
//  Description: WMSDK global include file
//
//============================================================================

//
// Hi!  If you're thinking of modifying this file, consider the following:
// This is our INTERNAL version of the file.  That's why you see wmsdkidl2.h
// here.  If you're looking for the one that we ship in our Format SDK setup 
// package, look for a wmsdk.h in the SDK\samples directory. 
//

#include "wmsdkidl.h"

#include "wmsdkidl2.h"

#include "asferr.h"
#include "nserror.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\wmsdk\zeusette\sdk\writer\sink\dvrsink\dvrsharedmem.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       DVRSharedMem.h
//
//  Classes:    CDVRSSharedMemory
//
//  Contents:   Definition of the CDVRSharedMemory struct.
//
//--------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __DVRSHAREDMEM_H_
#define __DVRSHAREDMEM_H_

#if !defined(MAXQWORD)
#define MAXQWORD (~(0I64))
#endif

const LPCWSTR kwszSharedMutexPrefix = L"Global\\_MS_TSDVRASF_MUTEX_";
const DWORD MAX_MUTEX_NAME_LEN = 26 + 10 + 1 + 3; // 26 is the length of "Global\\_MS_TSDVRASF_MUTEX_", 10 is #digits in MAXDWORD, 1 for NULL, 3 as a safety net
const LPCWSTR kwszSharedEventPrefix = L"Global\\_MS_TSDVRASF_EVENT_";
const DWORD MAX_EVENT_NAME_LEN = 26 + 10 + 1 + 3; // 26 is the length of "Global\\_MS_TSDVRASF_EVENT_", 10 is #digits in MAXDWORD, 1 for NULL, 3 as a safety net

#include "accctrl.h"
#include "aclapi.h"


// Following are free'd (unless NULL) and set to NULL
void FreeSecurityDescriptors(IN OUT PACL&  rpACL,
                             IN OUT PSECURITY_DESCRIPTOR& rpSD
                            );

// ppSid[0] is assumed to be that of CREATOR_OWNER and is set/granted/denied 
// (depending on what ownerAccessMode is) ownerAccessPermissions. The other
// otherAccessMode and otherAccessPermissions are used with the other SIDs
// in ppSids.
// We assume that object handle cannot be inherited.
DWORD CreateACL(IN  DWORD dwNumSids, 
                IN  PSID* ppSids,
                IN  ACCESS_MODE ownerAccessMode, 
                IN  DWORD ownerAccessPermissions,
                IN  ACCESS_MODE otherAccessMode, 
                IN  DWORD otherAccessPermissions,
                OUT PACL&  rpACL,
                OUT PSECURITY_DESCRIPTOR& rpSD
               );



// The size of this is 280 bytes currently. This is followed by
// the index header (i.e. an empty index) which takes 24 + 32 = 56
// bytes (CASFLonghandObject is 24 bytes and CASFIndexObject members
// occupy another 16 + 8 + 4 + 4 = 32 bytes). Total: 280+56 = 336 bytes.
// That leaves 3760 bytes on 1 page for the index entries. Each
// index entry takes 6 bytes, so we can fit 626 or slightly more
// than 10 minutes of index entries (at 1 per second) or 5 minutes 
// (at 1 per half-second) on the first memory page (on x86). (Subsequent
// pages do not have the shared data structure and the index header 
// and can hold 4096/6 = 682 index entries with 4 bytes left over.)

struct CDVRSharedMemory
{
    GUID        guidWriterId ;            //  unique per writer

    QWORD       msLastPresentationTime;   // NOTE: This is in milli sec, not 100s of nano seconds
    QWORD       qwCurrentFileSize;        // excludes index; header + data objects only

    // Members for the index. Byte offsets are from the start of the
    // ASF file

    // qwIndexHeaderOffset specifies where the index header is.
    // This is fixed at 0xFFFFFFFF00000000, which allows 4 GB for the
    // index size and the rest for the header and the data object
    QWORD       qwIndexHeaderOffset;

    // qwTotalFileSize is the size of the file if the ASF header + data
    // section actually grew to 0xFFFFFFFF00000000 bytes. It is updated when
    // an index entry is added. It is not updated if an index is not
    // created on the fly.
    QWORD       qwTotalFileSize;

    // These values are set to qwTotalFileSize initially and updated
    // when an index entry is created. If an index is not generated
    // on the fly, they are not updated.
    // Byte offsets in live fails that are >= qwOffsetOfFirstIndexInSharedMemory
    // and < qwOffsetOfLastIndexInSharedMemory are in shared memory.
    // Note that qwOffsetOfLastIndexInSharedMemory is redundant since it
    // it is the same as qwTotalFileSize.
    QWORD       qwOffsetOfFirstIndexInSharedMemory;
    QWORD       qwOffsetOfLastIndexInSharedMemory;

    // Readers. 
    enum {MAX_READERS = 8};

    struct CReaderInfo {
        // The offset the reader is waiting for, MAXQWORD if none
        QWORD   qwReaderOffset;
        DWORD   dwEventSuffix; // Used to name the event used for reader synchronization
        enum {
            DVR_READER_REQUEST_NONE = 0,
            DVR_READER_REQUEST_DONE = 1,
            DVR_READER_REQUEST_READ = 2
        } dwMsg;
    } Readers[MAX_READERS];

    DWORD      dwMutexSuffix; // Used to name the mutex used for this shared section
                              // 0 if this field has not been initialized. Also, this is
                              // reset to 0 when the writer terminates.

    // "Pointers" into the shared memory section. These are all set to 0
    // if we are not generating an index on the fly. These pointer values
    // are really offsets from the start of the shared memory section.
    // Note: if we hit an error while generating an index entry, we stop
    // indexing and will not write out the index to permanent files when the
    // index is closed, but the index that we have generated so far may be
    // used.
    DWORD       pIndexHeader;
    DWORD       pIndexStart;
    DWORD       pFirstIndex;
    DWORD       pIndexEnd;      // ALL bytes >= pIndexEnd in the shared section are UNUSED

    // Other stuff
    DWORD       dwWriterPid;    // Process id of writer

    // Following can be collapsed to 1 DWORD if required
    DWORD       dwBeingWritten;         // File is being written
    DWORD       dwIsTemporary;          // File is a temporary file
    DWORD       dwLastOwnedByWriter;    // Writer last owned hMutex
    DWORD       dwWriterAbandonedMutex; // Writer died while it owned hMutex

    // The following array is sorted with highest offset first and lowest
    // offset at the end. We use DWORDs (rather than QWORDS) since all the
    // bytes to be fudged are in the ASF header. (WORD will probably suffice)

    enum {MAX_FUDGE = 4};

    struct {
        DWORD   dwStartOffset;// offset (from start of file) of first byte that should be changed
        DWORD   dwEndOffset;  // offset (from start of file) of last byte that should be changed
        DWORD   pFudgeBytes;  // Index in pFudgeBytes that contains the first fudge byte.
                              // First unused one points to next free byte. (Next free
                              // byte can also be computed from start/end offset fields
                              // of the elements that are in use.)
    } FudgeOffsets[MAX_FUDGE];

    // 3 QWORDs (data header size, play duration, send duration) and a DWORD (header's flags)
    BYTE        pFudgeBytes[3*sizeof(QWORD)+sizeof(DWORD)];

    // Note that the pointer to the shared memory block, say p,
    // is cast to a CDVRSharedMemory*, pShared. The index header starts at
    // pShared[1]:
    //
    // LPVOID p;            -- the shared memory block;
    // CDVRSharedMemory* pShared = (CDVRSharedMemory*) p;
    // Index starts at pShared[1] or pShared + sizeof(CDVRSharedMemory)
    //
    // So the start of the index is QWORD aligned (since CDVRSharedMemory is
    // QWORD aligned)

}; // CDVRSharedMemory

#endif // __DVRSHAREDMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\wmsdk\inc\wmsdkidl2.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for wmsdkidl2.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsdkidl2_h__
#define __wmsdkidl2_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMDRMWriter_FWD_DEFINED__
#define __IWMDRMWriter_FWD_DEFINED__
typedef interface IWMDRMWriter IWMDRMWriter;
#endif 	/* __IWMDRMWriter_FWD_DEFINED__ */


#ifndef __IWMWriterPushSink_FWD_DEFINED__
#define __IWMWriterPushSink_FWD_DEFINED__
typedef interface IWMWriterPushSink IWMWriterPushSink;
#endif 	/* __IWMWriterPushSink_FWD_DEFINED__ */


#ifndef __IWMReaderNetworkConfig2_FWD_DEFINED__
#define __IWMReaderNetworkConfig2_FWD_DEFINED__
typedef interface IWMReaderNetworkConfig2 IWMReaderNetworkConfig2;
#endif 	/* __IWMReaderNetworkConfig2_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "wmsdkidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_wmsdkidl2_0000 */
/* [local] */ 



////////////////////////////////////////////////////////////////
//
// These are setting names for use in Get/SetOutputSetting
//
static const WCHAR *g_wszEnableDiscreetOutput = L"EnableDiscreetOutput";

////////////////////////////////////////////////////////////////
//
// These are Speech codec attribute names and values
//
static const WCHAR *g_wszMusicSpeechClassMode = L"MusicSpeechClassMode";
static const WCHAR *g_wszMusicClassMode = L"MusicClassMode";
static const WCHAR *g_wszSpeechClassMode = L"SpeechClassMode";
static const WCHAR *g_wszMixedClassMode = L"MixedClassMode";

////////////////////////////////////////////////////////////////
//
// The Speech code supports the following format property.
//
static const WCHAR *g_wszSpeechCaps = L"SpeechFormatCap";

////////////////////////////////////////////////////////////////
//
// Multi-channel WMA properties
//
static const WCHAR *g_wszSurroundMix = L"SurroundMix";
static const WCHAR *g_wszCenterMix = L"CenterMix";
static const WCHAR *g_wszLFEMix = L"LFEMix";
static const WCHAR *g_wszPeakValue = L"PeakValue";
static const WCHAR *g_wszAverageLevel = L"AverageLevel";
static const WCHAR *g_wszFoldDownData = L"FoldDown%dTo%dChannels";

////////////////////////////////////////////////////////////////
//
// Frame interpolation on video decode
//
static const WCHAR g_wszEnableFrameInterpolation[] =L"EnableFrameInterpolation";
////////////////////////////////////////////////////////////////
//
// These attributes are used to configure DRM using IWMDRMWriter::SetDRMAttribute.
//
static const WCHAR *g_wszWMUse_Advanced_DRM = L"Use_Advanced_DRM";
static const WCHAR *g_wszWMDRM_KeySeed = L"DRM_KeySeed";
static const WCHAR *g_wszWMDRM_KeyID = L"DRM_KeyID";
static const WCHAR *g_wszWMDRM_ContentID = L"DRM_ContentID";
static const WCHAR *g_wszWMDRM_IndividualizedVersion = L"DRM_IndividualizedVersion";
static const WCHAR *g_wszWMDRM_LicenseAcqURL = L"DRM_LicenseAcqURL";
static const WCHAR *g_wszWMDRM_V1LicenseAcqURL = L"DRM_V1LicenseAcqURL";
static const WCHAR *g_wszWMDRM_HeaderSignPrivKey = L"DRM_HeaderSignPrivKey";

////////////////////////////////////////////////////////////////
//
// These are the additional attributes defined in the WM attribute
// namespace that give information about the content.
//
static const WCHAR g_wszWMContentID[] =L"WM/ContentID";

//
//  Version 9 of profiles have been removed from Zeus for the time being, however
//    we want the next efforts to be able to continue to use them.
//
#define WMT_VER_9_0     ((WMT_VERSION)0x00090000)

typedef 
enum tagWMT_MUSICSPEECH_CLASS_MODE
    {	WMT_MS_CLASS_MUSIC	= 0,
	WMT_MS_CLASS_SPEECH	= 1,
	WMT_MS_CLASS_MIXED	= 2
    } 	WMT_MUSICSPEECH_CLASS_MODE;

// 00000162-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV9 
EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV9, 
0x00000162, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 3253534D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MSS2 
EXTERN_GUID(WMMEDIASUBTYPE_MSS2, 
0x3253534D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 0000000A-0000-0010-8000-00AA00389B71        WMMEDIASUBTYPE_WMSP1 
EXTERN_GUID( WMMEDIASUBTYPE_WMSP1, 
0x0000000A,0x0000,0x0010,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71); 
// 33564D57-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMV3 
EXTERN_GUID(WMMEDIASUBTYPE_WMV3, 
0x32564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
EXTERN_GUID( IID_IWMDRMWriter,      0xd6ea5dd0,0x12a0,0x43f4,0x90,0xab,0xa3,0xfd,0x45,0x1e,0x6a,0x07 );
EXTERN_GUID( IID_IWMWriterPushSink,     0xdc10e6a5,0x072c,0x467d,0xbf,0x57,0x63,0x30,0xa9,0xdd,0xe1,0x2a );
EXTERN_GUID( IID_IWMReaderNetworkConfig2,0xd979a853,0x042b,0x4050,0x83,0x87,0xc9,0x39,0xdb,0x22,0x01,0x3f );
HRESULT STDMETHODCALLTYPE WMCreateWriterPushSink( IWMWriterPushSink **ppSink );


extern RPC_IF_HANDLE __MIDL_itf_wmsdkidl2_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsdkidl2_0000_v0_0_s_ifspec;

#ifndef __IWMDRMWriter_INTERFACE_DEFINED__
#define __IWMDRMWriter_INTERFACE_DEFINED__

/* interface IWMDRMWriter */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMDRMWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d6ea5dd0-12a0-43f4-90ab-a3fd451e6a07")
    IWMDRMWriter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GenerateKeySeed( 
            /* [out] */ WCHAR *pwszKeySeed,
            /* [out][in] */ DWORD *pcwchLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateKeyID( 
            /* [out] */ WCHAR *pwszKeyID,
            /* [out][in] */ DWORD *pcwchLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateSigningKeyPair( 
            /* [out] */ WCHAR *pwszPrivKey,
            /* [out][in] */ DWORD *pcwchPrivKeyLength,
            /* [out] */ WCHAR *pwszPubKey,
            /* [out][in] */ DWORD *pcwchPubKeyLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDRMAttribute( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDRMWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMDRMWriter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMDRMWriter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMDRMWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateKeySeed )( 
            IWMDRMWriter * This,
            /* [out] */ WCHAR *pwszKeySeed,
            /* [out][in] */ DWORD *pcwchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateKeyID )( 
            IWMDRMWriter * This,
            /* [out] */ WCHAR *pwszKeyID,
            /* [out][in] */ DWORD *pcwchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateSigningKeyPair )( 
            IWMDRMWriter * This,
            /* [out] */ WCHAR *pwszPrivKey,
            /* [out][in] */ DWORD *pcwchPrivKeyLength,
            /* [out] */ WCHAR *pwszPubKey,
            /* [out][in] */ DWORD *pcwchPubKeyLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetDRMAttribute )( 
            IWMDRMWriter * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength);
        
        END_INTERFACE
    } IWMDRMWriterVtbl;

    interface IWMDRMWriter
    {
        CONST_VTBL struct IWMDRMWriterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDRMWriter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDRMWriter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDRMWriter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDRMWriter_GenerateKeySeed(This,pwszKeySeed,pcwchLength)	\
    (This)->lpVtbl -> GenerateKeySeed(This,pwszKeySeed,pcwchLength)

#define IWMDRMWriter_GenerateKeyID(This,pwszKeyID,pcwchLength)	\
    (This)->lpVtbl -> GenerateKeyID(This,pwszKeyID,pcwchLength)

#define IWMDRMWriter_GenerateSigningKeyPair(This,pwszPrivKey,pcwchPrivKeyLength,pwszPubKey,pcwchPubKeyLength)	\
    (This)->lpVtbl -> GenerateSigningKeyPair(This,pwszPrivKey,pcwchPrivKeyLength,pwszPubKey,pcwchPubKeyLength)

#define IWMDRMWriter_SetDRMAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetDRMAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDRMWriter_GenerateKeySeed_Proxy( 
    IWMDRMWriter * This,
    /* [out] */ WCHAR *pwszKeySeed,
    /* [out][in] */ DWORD *pcwchLength);


void __RPC_STUB IWMDRMWriter_GenerateKeySeed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMWriter_GenerateKeyID_Proxy( 
    IWMDRMWriter * This,
    /* [out] */ WCHAR *pwszKeyID,
    /* [out][in] */ DWORD *pcwchLength);


void __RPC_STUB IWMDRMWriter_GenerateKeyID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMWriter_GenerateSigningKeyPair_Proxy( 
    IWMDRMWriter * This,
    /* [out] */ WCHAR *pwszPrivKey,
    /* [out][in] */ DWORD *pcwchPrivKeyLength,
    /* [out] */ WCHAR *pwszPubKey,
    /* [out][in] */ DWORD *pcwchPubKeyLength);


void __RPC_STUB IWMDRMWriter_GenerateSigningKeyPair_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMWriter_SetDRMAttribute_Proxy( 
    IWMDRMWriter * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMDRMWriter_SetDRMAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDRMWriter_INTERFACE_DEFINED__ */


#ifndef __IWMWriterPushSink_INTERFACE_DEFINED__
#define __IWMWriterPushSink_INTERFACE_DEFINED__

/* interface IWMWriterPushSink */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterPushSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dc10e6a5-072c-467d-bf57-6330a9dde12a")
    IWMWriterPushSink : public IWMWriterSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ LPCWSTR pwszTemplateURL,
            /* [in] */ BOOL fAutoDestroy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndSession( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterPushSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterPushSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterPushSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterPushSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnHeader )( 
            IWMWriterPushSink * This,
            /* [in] */ INSSBuffer *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE *IsRealTime )( 
            IWMWriterPushSink * This,
            /* [out] */ BOOL *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateDataUnit )( 
            IWMWriterPushSink * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer **ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *OnDataUnit )( 
            IWMWriterPushSink * This,
            /* [in] */ INSSBuffer *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndWriting )( 
            IWMWriterPushSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IWMWriterPushSink * This,
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ LPCWSTR pwszTemplateURL,
            /* [in] */ BOOL fAutoDestroy);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IWMWriterPushSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *EndSession )( 
            IWMWriterPushSink * This);
        
        END_INTERFACE
    } IWMWriterPushSinkVtbl;

    interface IWMWriterPushSink
    {
        CONST_VTBL struct IWMWriterPushSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterPushSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterPushSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterPushSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterPushSink_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterPushSink_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterPushSink_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterPushSink_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterPushSink_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)


#define IWMWriterPushSink_Connect(This,pwszURL,pwszTemplateURL,fAutoDestroy)	\
    (This)->lpVtbl -> Connect(This,pwszURL,pwszTemplateURL,fAutoDestroy)

#define IWMWriterPushSink_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IWMWriterPushSink_EndSession(This)	\
    (This)->lpVtbl -> EndSession(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterPushSink_Connect_Proxy( 
    IWMWriterPushSink * This,
    /* [in] */ LPCWSTR pwszURL,
    /* [in] */ LPCWSTR pwszTemplateURL,
    /* [in] */ BOOL fAutoDestroy);


void __RPC_STUB IWMWriterPushSink_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPushSink_Disconnect_Proxy( 
    IWMWriterPushSink * This);


void __RPC_STUB IWMWriterPushSink_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPushSink_EndSession_Proxy( 
    IWMWriterPushSink * This);


void __RPC_STUB IWMWriterPushSink_EndSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterPushSink_INTERFACE_DEFINED__ */


#ifndef __IWMReaderNetworkConfig2_INTERFACE_DEFINED__
#define __IWMReaderNetworkConfig2_INTERFACE_DEFINED__

/* interface IWMReaderNetworkConfig2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderNetworkConfig2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d979a853-042b-4050-8387-c939db22013f")
    IWMReaderNetworkConfig2 : public IWMReaderNetworkConfig
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEnableContentCaching( 
            /* [out] */ BOOL *pfEnableContentCaching) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableContentCaching( 
            /* [in] */ BOOL fEnableContentCaching) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableOpportunisticStreaming( 
            /* [out] */ BOOL *pfEnableOppStreaming) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableOpportunisticStreaming( 
            /* [in] */ BOOL fEnableOppStreaming) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAcceleratedStreamingDuration( 
            /* [out] */ QWORD *pcnsAccelDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAcceleratedStreamingDuration( 
            /* [in] */ QWORD cnsAccelDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAutoReconnectLimit( 
            /* [out] */ DWORD *pdwAutoReconnectLimit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAutoReconnectLimit( 
            /* [in] */ DWORD dwAutoReconnectLimit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableResends( 
            /* [out] */ BOOL *pfEnableResends) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableResends( 
            /* [in] */ BOOL fEnableResends) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableThinning( 
            /* [out] */ BOOL *pfEnableThinning) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableThinning( 
            /* [in] */ BOOL fEnableThinning) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFECSpan( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ DWORD *pdwFECSpan,
            /* [out] */ DWORD *pdwFECPacketsPerSpan) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFECSpan( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD dwFECSpan,
            /* [in] */ DWORD dwFECPacketsPerSpan) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxNetPacketSize( 
            /* [out] */ DWORD *pdwMaxNetPacketSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderNetworkConfig2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMReaderNetworkConfig2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMReaderNetworkConfig2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferingTime )( 
            IWMReaderNetworkConfig2 * This,
            /* [out] */ QWORD *pcnsBufferingTime);
        
        HRESULT ( STDMETHODCALLTYPE *SetBufferingTime )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ QWORD cnsBufferingTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetUDPPortRanges )( 
            IWMReaderNetworkConfig2 * This,
            /* [out] */ WM_PORT_NUMBER_RANGE *pRangeArray,
            /* [out][in] */ DWORD *pcRanges);
        
        HRESULT ( STDMETHODCALLTYPE *SetUDPPortRanges )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ WM_PORT_NUMBER_RANGE *pRangeArray,
            /* [in] */ DWORD cRanges);
        
        HRESULT ( STDMETHODCALLTYPE *GetProxySettings )( 
            IWMReaderNetworkConfig2 * This,
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS *pProxySetting);
        
        HRESULT ( STDMETHODCALLTYPE *SetProxySettings )( 
            IWMReaderNetworkConfig2 * This,
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS ProxySetting);
        
        HRESULT ( STDMETHODCALLTYPE *GetProxyHostName )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR *pwszHostName,
            /* [out][in] */ DWORD *pcchHostName);
        
        HRESULT ( STDMETHODCALLTYPE *SetProxyHostName )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszHostName);
        
        HRESULT ( STDMETHODCALLTYPE *GetProxyPort )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ DWORD *pdwPort);
        
        HRESULT ( STDMETHODCALLTYPE *SetProxyPort )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ DWORD dwPort);
        
        HRESULT ( STDMETHODCALLTYPE *GetProxyExceptionList )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR *pwszExceptionList,
            /* [out][in] */ DWORD *pcchExceptionList);
        
        HRESULT ( STDMETHODCALLTYPE *SetProxyExceptionList )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszExceptionList);
        
        HRESULT ( STDMETHODCALLTYPE *GetProxyBypassForLocal )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ BOOL *pfBypassForLocal);
        
        HRESULT ( STDMETHODCALLTYPE *SetProxyBypassForLocal )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ BOOL fBypassForLocal);
        
        HRESULT ( STDMETHODCALLTYPE *GetForceRerunAutoProxyDetection )( 
            IWMReaderNetworkConfig2 * This,
            /* [out] */ BOOL *pfForceRerunDetection);
        
        HRESULT ( STDMETHODCALLTYPE *SetForceRerunAutoProxyDetection )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ BOOL fForceRerunDetection);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnableMulticast )( 
            IWMReaderNetworkConfig2 * This,
            /* [out] */ BOOL *pfEnableMulticast);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnableMulticast )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ BOOL fEnableMulticast);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnableHTTP )( 
            IWMReaderNetworkConfig2 * This,
            /* [out] */ BOOL *pfEnableHTTP);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnableHTTP )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ BOOL fEnableHTTP);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnableUDP )( 
            IWMReaderNetworkConfig2 * This,
            /* [out] */ BOOL *pfEnableUDP);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnableUDP )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ BOOL fEnableUDP);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnableTCP )( 
            IWMReaderNetworkConfig2 * This,
            /* [out] */ BOOL *pfEnableTCP);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnableTCP )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ BOOL fEnableTCP);
        
        HRESULT ( STDMETHODCALLTYPE *ResetProtocolRollover )( 
            IWMReaderNetworkConfig2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionBandwidth )( 
            IWMReaderNetworkConfig2 * This,
            /* [out] */ DWORD *pdwConnectionBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE *SetConnectionBandwidth )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ DWORD dwConnectionBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumProtocolsSupported )( 
            IWMReaderNetworkConfig2 * This,
            /* [out] */ DWORD *pcProtocols);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedProtocolName )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ DWORD dwProtocolNum,
            /* [out] */ WCHAR *pwszProtocolName,
            /* [out][in] */ DWORD *pcchProtocolName);
        
        HRESULT ( STDMETHODCALLTYPE *AddLoggingUrl )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ LPCWSTR pwszUrl);
        
        HRESULT ( STDMETHODCALLTYPE *GetLoggingUrl )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pwszUrl,
            /* [out][in] */ DWORD *pcchUrl);
        
        HRESULT ( STDMETHODCALLTYPE *GetLoggingUrlCount )( 
            IWMReaderNetworkConfig2 * This,
            /* [out] */ DWORD *pdwUrlCount);
        
        HRESULT ( STDMETHODCALLTYPE *ResetLoggingUrlList )( 
            IWMReaderNetworkConfig2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnableContentCaching )( 
            IWMReaderNetworkConfig2 * This,
            /* [out] */ BOOL *pfEnableContentCaching);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnableContentCaching )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ BOOL fEnableContentCaching);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnableOpportunisticStreaming )( 
            IWMReaderNetworkConfig2 * This,
            /* [out] */ BOOL *pfEnableOppStreaming);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnableOpportunisticStreaming )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ BOOL fEnableOppStreaming);
        
        HRESULT ( STDMETHODCALLTYPE *GetAcceleratedStreamingDuration )( 
            IWMReaderNetworkConfig2 * This,
            /* [out] */ QWORD *pcnsAccelDuration);
        
        HRESULT ( STDMETHODCALLTYPE *SetAcceleratedStreamingDuration )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ QWORD cnsAccelDuration);
        
        HRESULT ( STDMETHODCALLTYPE *GetAutoReconnectLimit )( 
            IWMReaderNetworkConfig2 * This,
            /* [out] */ DWORD *pdwAutoReconnectLimit);
        
        HRESULT ( STDMETHODCALLTYPE *SetAutoReconnectLimit )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ DWORD dwAutoReconnectLimit);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnableResends )( 
            IWMReaderNetworkConfig2 * This,
            /* [out] */ BOOL *pfEnableResends);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnableResends )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ BOOL fEnableResends);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnableThinning )( 
            IWMReaderNetworkConfig2 * This,
            /* [out] */ BOOL *pfEnableThinning);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnableThinning )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ BOOL fEnableThinning);
        
        HRESULT ( STDMETHODCALLTYPE *GetFECSpan )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ DWORD *pdwFECSpan,
            /* [out] */ DWORD *pdwFECPacketsPerSpan);
        
        HRESULT ( STDMETHODCALLTYPE *SetFECSpan )( 
            IWMReaderNetworkConfig2 * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD dwFECSpan,
            /* [in] */ DWORD dwFECPacketsPerSpan);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxNetPacketSize )( 
            IWMReaderNetworkConfig2 * This,
            /* [out] */ DWORD *pdwMaxNetPacketSize);
        
        END_INTERFACE
    } IWMReaderNetworkConfig2Vtbl;

    interface IWMReaderNetworkConfig2
    {
        CONST_VTBL struct IWMReaderNetworkConfig2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderNetworkConfig2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderNetworkConfig2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderNetworkConfig2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderNetworkConfig2_GetBufferingTime(This,pcnsBufferingTime)	\
    (This)->lpVtbl -> GetBufferingTime(This,pcnsBufferingTime)

#define IWMReaderNetworkConfig2_SetBufferingTime(This,cnsBufferingTime)	\
    (This)->lpVtbl -> SetBufferingTime(This,cnsBufferingTime)

#define IWMReaderNetworkConfig2_GetUDPPortRanges(This,pRangeArray,pcRanges)	\
    (This)->lpVtbl -> GetUDPPortRanges(This,pRangeArray,pcRanges)

#define IWMReaderNetworkConfig2_SetUDPPortRanges(This,pRangeArray,cRanges)	\
    (This)->lpVtbl -> SetUDPPortRanges(This,pRangeArray,cRanges)

#define IWMReaderNetworkConfig2_GetProxySettings(This,pwszProtocol,pProxySetting)	\
    (This)->lpVtbl -> GetProxySettings(This,pwszProtocol,pProxySetting)

#define IWMReaderNetworkConfig2_SetProxySettings(This,pwszProtocol,ProxySetting)	\
    (This)->lpVtbl -> SetProxySettings(This,pwszProtocol,ProxySetting)

#define IWMReaderNetworkConfig2_GetProxyHostName(This,pwszProtocol,pwszHostName,pcchHostName)	\
    (This)->lpVtbl -> GetProxyHostName(This,pwszProtocol,pwszHostName,pcchHostName)

#define IWMReaderNetworkConfig2_SetProxyHostName(This,pwszProtocol,pwszHostName)	\
    (This)->lpVtbl -> SetProxyHostName(This,pwszProtocol,pwszHostName)

#define IWMReaderNetworkConfig2_GetProxyPort(This,pwszProtocol,pdwPort)	\
    (This)->lpVtbl -> GetProxyPort(This,pwszProtocol,pdwPort)

#define IWMReaderNetworkConfig2_SetProxyPort(This,pwszProtocol,dwPort)	\
    (This)->lpVtbl -> SetProxyPort(This,pwszProtocol,dwPort)

#define IWMReaderNetworkConfig2_GetProxyExceptionList(This,pwszProtocol,pwszExceptionList,pcchExceptionList)	\
    (This)->lpVtbl -> GetProxyExceptionList(This,pwszProtocol,pwszExceptionList,pcchExceptionList)

#define IWMReaderNetworkConfig2_SetProxyExceptionList(This,pwszProtocol,pwszExceptionList)	\
    (This)->lpVtbl -> SetProxyExceptionList(This,pwszProtocol,pwszExceptionList)

#define IWMReaderNetworkConfig2_GetProxyBypassForLocal(This,pwszProtocol,pfBypassForLocal)	\
    (This)->lpVtbl -> GetProxyBypassForLocal(This,pwszProtocol,pfBypassForLocal)

#define IWMReaderNetworkConfig2_SetProxyBypassForLocal(This,pwszProtocol,fBypassForLocal)	\
    (This)->lpVtbl -> SetProxyBypassForLocal(This,pwszProtocol,fBypassForLocal)

#define IWMReaderNetworkConfig2_GetForceRerunAutoProxyDetection(This,pfForceRerunDetection)	\
    (This)->lpVtbl -> GetForceRerunAutoProxyDetection(This,pfForceRerunDetection)

#define IWMReaderNetworkConfig2_SetForceRerunAutoProxyDetection(This,fForceRerunDetection)	\
    (This)->lpVtbl -> SetForceRerunAutoProxyDetection(This,fForceRerunDetection)

#define IWMReaderNetworkConfig2_GetEnableMulticast(This,pfEnableMulticast)	\
    (This)->lpVtbl -> GetEnableMulticast(This,pfEnableMulticast)

#define IWMReaderNetworkConfig2_SetEnableMulticast(This,fEnableMulticast)	\
    (This)->lpVtbl -> SetEnableMulticast(This,fEnableMulticast)

#define IWMReaderNetworkConfig2_GetEnableHTTP(This,pfEnableHTTP)	\
    (This)->lpVtbl -> GetEnableHTTP(This,pfEnableHTTP)

#define IWMReaderNetworkConfig2_SetEnableHTTP(This,fEnableHTTP)	\
    (This)->lpVtbl -> SetEnableHTTP(This,fEnableHTTP)

#define IWMReaderNetworkConfig2_GetEnableUDP(This,pfEnableUDP)	\
    (This)->lpVtbl -> GetEnableUDP(This,pfEnableUDP)

#define IWMReaderNetworkConfig2_SetEnableUDP(This,fEnableUDP)	\
    (This)->lpVtbl -> SetEnableUDP(This,fEnableUDP)

#define IWMReaderNetworkConfig2_GetEnableTCP(This,pfEnableTCP)	\
    (This)->lpVtbl -> GetEnableTCP(This,pfEnableTCP)

#define IWMReaderNetworkConfig2_SetEnableTCP(This,fEnableTCP)	\
    (This)->lpVtbl -> SetEnableTCP(This,fEnableTCP)

#define IWMReaderNetworkConfig2_ResetProtocolRollover(This)	\
    (This)->lpVtbl -> ResetProtocolRollover(This)

#define IWMReaderNetworkConfig2_GetConnectionBandwidth(This,pdwConnectionBandwidth)	\
    (This)->lpVtbl -> GetConnectionBandwidth(This,pdwConnectionBandwidth)

#define IWMReaderNetworkConfig2_SetConnectionBandwidth(This,dwConnectionBandwidth)	\
    (This)->lpVtbl -> SetConnectionBandwidth(This,dwConnectionBandwidth)

#define IWMReaderNetworkConfig2_GetNumProtocolsSupported(This,pcProtocols)	\
    (This)->lpVtbl -> GetNumProtocolsSupported(This,pcProtocols)

#define IWMReaderNetworkConfig2_GetSupportedProtocolName(This,dwProtocolNum,pwszProtocolName,pcchProtocolName)	\
    (This)->lpVtbl -> GetSupportedProtocolName(This,dwProtocolNum,pwszProtocolName,pcchProtocolName)

#define IWMReaderNetworkConfig2_AddLoggingUrl(This,pwszUrl)	\
    (This)->lpVtbl -> AddLoggingUrl(This,pwszUrl)

#define IWMReaderNetworkConfig2_GetLoggingUrl(This,dwIndex,pwszUrl,pcchUrl)	\
    (This)->lpVtbl -> GetLoggingUrl(This,dwIndex,pwszUrl,pcchUrl)

#define IWMReaderNetworkConfig2_GetLoggingUrlCount(This,pdwUrlCount)	\
    (This)->lpVtbl -> GetLoggingUrlCount(This,pdwUrlCount)

#define IWMReaderNetworkConfig2_ResetLoggingUrlList(This)	\
    (This)->lpVtbl -> ResetLoggingUrlList(This)


#define IWMReaderNetworkConfig2_GetEnableContentCaching(This,pfEnableContentCaching)	\
    (This)->lpVtbl -> GetEnableContentCaching(This,pfEnableContentCaching)

#define IWMReaderNetworkConfig2_SetEnableContentCaching(This,fEnableContentCaching)	\
    (This)->lpVtbl -> SetEnableContentCaching(This,fEnableContentCaching)

#define IWMReaderNetworkConfig2_GetEnableOpportunisticStreaming(This,pfEnableOppStreaming)	\
    (This)->lpVtbl -> GetEnableOpportunisticStreaming(This,pfEnableOppStreaming)

#define IWMReaderNetworkConfig2_SetEnableOpportunisticStreaming(This,fEnableOppStreaming)	\
    (This)->lpVtbl -> SetEnableOpportunisticStreaming(This,fEnableOppStreaming)

#define IWMReaderNetworkConfig2_GetAcceleratedStreamingDuration(This,pcnsAccelDuration)	\
    (This)->lpVtbl -> GetAcceleratedStreamingDuration(This,pcnsAccelDuration)

#define IWMReaderNetworkConfig2_SetAcceleratedStreamingDuration(This,cnsAccelDuration)	\
    (This)->lpVtbl -> SetAcceleratedStreamingDuration(This,cnsAccelDuration)

#define IWMReaderNetworkConfig2_GetAutoReconnectLimit(This,pdwAutoReconnectLimit)	\
    (This)->lpVtbl -> GetAutoReconnectLimit(This,pdwAutoReconnectLimit)

#define IWMReaderNetworkConfig2_SetAutoReconnectLimit(This,dwAutoReconnectLimit)	\
    (This)->lpVtbl -> SetAutoReconnectLimit(This,dwAutoReconnectLimit)

#define IWMReaderNetworkConfig2_GetEnableResends(This,pfEnableResends)	\
    (This)->lpVtbl -> GetEnableResends(This,pfEnableResends)

#define IWMReaderNetworkConfig2_SetEnableResends(This,fEnableResends)	\
    (This)->lpVtbl -> SetEnableResends(This,fEnableResends)

#define IWMReaderNetworkConfig2_GetEnableThinning(This,pfEnableThinning)	\
    (This)->lpVtbl -> GetEnableThinning(This,pfEnableThinning)

#define IWMReaderNetworkConfig2_SetEnableThinning(This,fEnableThinning)	\
    (This)->lpVtbl -> SetEnableThinning(This,fEnableThinning)

#define IWMReaderNetworkConfig2_GetFECSpan(This,wStreamNum,pdwFECSpan,pdwFECPacketsPerSpan)	\
    (This)->lpVtbl -> GetFECSpan(This,wStreamNum,pdwFECSpan,pdwFECPacketsPerSpan)

#define IWMReaderNetworkConfig2_SetFECSpan(This,wStreamNum,dwFECSpan,dwFECPacketsPerSpan)	\
    (This)->lpVtbl -> SetFECSpan(This,wStreamNum,dwFECSpan,dwFECPacketsPerSpan)

#define IWMReaderNetworkConfig2_GetMaxNetPacketSize(This,pdwMaxNetPacketSize)	\
    (This)->lpVtbl -> GetMaxNetPacketSize(This,pdwMaxNetPacketSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_GetEnableContentCaching_Proxy( 
    IWMReaderNetworkConfig2 * This,
    /* [out] */ BOOL *pfEnableContentCaching);


void __RPC_STUB IWMReaderNetworkConfig2_GetEnableContentCaching_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_SetEnableContentCaching_Proxy( 
    IWMReaderNetworkConfig2 * This,
    /* [in] */ BOOL fEnableContentCaching);


void __RPC_STUB IWMReaderNetworkConfig2_SetEnableContentCaching_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_GetEnableOpportunisticStreaming_Proxy( 
    IWMReaderNetworkConfig2 * This,
    /* [out] */ BOOL *pfEnableOppStreaming);


void __RPC_STUB IWMReaderNetworkConfig2_GetEnableOpportunisticStreaming_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_SetEnableOpportunisticStreaming_Proxy( 
    IWMReaderNetworkConfig2 * This,
    /* [in] */ BOOL fEnableOppStreaming);


void __RPC_STUB IWMReaderNetworkConfig2_SetEnableOpportunisticStreaming_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_GetAcceleratedStreamingDuration_Proxy( 
    IWMReaderNetworkConfig2 * This,
    /* [out] */ QWORD *pcnsAccelDuration);


void __RPC_STUB IWMReaderNetworkConfig2_GetAcceleratedStreamingDuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_SetAcceleratedStreamingDuration_Proxy( 
    IWMReaderNetworkConfig2 * This,
    /* [in] */ QWORD cnsAccelDuration);


void __RPC_STUB IWMReaderNetworkConfig2_SetAcceleratedStreamingDuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_GetAutoReconnectLimit_Proxy( 
    IWMReaderNetworkConfig2 * This,
    /* [out] */ DWORD *pdwAutoReconnectLimit);


void __RPC_STUB IWMReaderNetworkConfig2_GetAutoReconnectLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_SetAutoReconnectLimit_Proxy( 
    IWMReaderNetworkConfig2 * This,
    /* [in] */ DWORD dwAutoReconnectLimit);


void __RPC_STUB IWMReaderNetworkConfig2_SetAutoReconnectLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_GetEnableResends_Proxy( 
    IWMReaderNetworkConfig2 * This,
    /* [out] */ BOOL *pfEnableResends);


void __RPC_STUB IWMReaderNetworkConfig2_GetEnableResends_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_SetEnableResends_Proxy( 
    IWMReaderNetworkConfig2 * This,
    /* [in] */ BOOL fEnableResends);


void __RPC_STUB IWMReaderNetworkConfig2_SetEnableResends_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_GetEnableThinning_Proxy( 
    IWMReaderNetworkConfig2 * This,
    /* [out] */ BOOL *pfEnableThinning);


void __RPC_STUB IWMReaderNetworkConfig2_GetEnableThinning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_SetEnableThinning_Proxy( 
    IWMReaderNetworkConfig2 * This,
    /* [in] */ BOOL fEnableThinning);


void __RPC_STUB IWMReaderNetworkConfig2_SetEnableThinning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_GetFECSpan_Proxy( 
    IWMReaderNetworkConfig2 * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ DWORD *pdwFECSpan,
    /* [out] */ DWORD *pdwFECPacketsPerSpan);


void __RPC_STUB IWMReaderNetworkConfig2_GetFECSpan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_SetFECSpan_Proxy( 
    IWMReaderNetworkConfig2 * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ DWORD dwFECSpan,
    /* [in] */ DWORD dwFECPacketsPerSpan);


void __RPC_STUB IWMReaderNetworkConfig2_SetFECSpan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_GetMaxNetPacketSize_Proxy( 
    IWMReaderNetworkConfig2 * This,
    /* [out] */ DWORD *pdwMaxNetPacketSize);


void __RPC_STUB IWMReaderNetworkConfig2_GetMaxNetPacketSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderNetworkConfig2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\wmsdk\zeusette\sdk\writer\sink\dvrsource\dvrsource.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       DVRSource.cpp
//
//  Classes:    CDVRSource
//
//  Contents:   Implementation of the CDVRSource class
//
//--------------------------------------------------------------------------

#include "stdinc.h"
#include "DVRSource.h"
#include "wmsdkbuffer.h"
#include "debughlp.h"
#include "nserror.h"
#include "asfx.h"
#include "nsalign.h"
#include "wmreghelp.h"
#include "wraparound.h"
#include "malloc.h"

#include "findleak.h"
DECLARE_THIS_FILE;

// Defined in dvrsink.cpp
DWORD GetRegDWORD(HKEY hKey, IN LPCWSTR pwszValueName, IN DWORD dwDefaultValue);

#if defined(DVR_UNOFFICIAL_BUILD)

static const WCHAR* kwszRegUsePacketAtSeekPointValue = L"UsePacketAtSeekPoint";
const DWORD kdwRegUsePacketAtSeekPointDefault = 1;

#endif // if defined(DVR_UNOFFICIAL_BUILD)

static const WCHAR* kwszRegMaxBytesAtOnceValue = L"MaxBytesAtOnce";
const DWORD kdwRegMaxBytesAtOnceDefault = 51200;

static const WCHAR* kwszRegReadAheadBufferTimeValue = L"SeekReadAheadBufferTime";
const DWORD kdwRegReadAheadBufferTimeDefault = 5;  // in msec; 0 is not good


HRESULT STDMETHODCALLTYPE DVRCreateDVRFileSource(HKEY hDvrKey,
                                                 HKEY hDvrIoKey,
                                                 DWORD dwNumSids,
                                                 PSID* ppSids,
                                                 IDVRFileSource**       ppDVRFileSource,
                                                 IDVRSourceAdviseSink*  pDVRSourceAdviseSink  /* OPTIONAL */
                                                )
{
    HRESULT hr;

    if (!ppDVRFileSource)
    {
        return E_POINTER;
    }

    *ppDVRFileSource = NULL;

    CDVRSource* p = new CDVRSource(hDvrKey, hDvrIoKey, dwNumSids, ppSids, &hr, pDVRSourceAdviseSink);

    if (p == NULL)
    {
        assert(p);
        return E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        hr = p->QueryInterface(IID_IDVRFileSource, (void**) ppDVRFileSource);
        if (FAILED(hr))
        {
            assert(0);
        }
    }

    if (FAILED(hr))
    {
        delete p;
    }

    return hr;

} // DVRCreateDVRFileSource

////////////////////////////////////////////////////////////////////////////
CDVRSource::CDVRSource(HKEY hDvrKey,
                       HKEY hDvrIoKey,
                       DWORD dwNumSids,
                       PSID* ppSids,
                       HRESULT *phr,
                       IDVRSourceAdviseSink*  pDVRSourceAdviseSink  /* OPTIONAL */ )
    : m_pShared(NULL)
    , m_hDvrKey(hDvrKey)
    , m_hDvrIoKey(hDvrIoKey)
    , m_dwNumSids(dwNumSids)
    , m_ppSids(ppSids)
    , m_hFile(NULL)
    , m_hFileMapping(NULL)
    , m_hTempIndexFile(NULL)
    , m_qwCurrentPosition(0)
    , m_qwMaxHeaderAndDataSize(0)
    , m_hMutex(NULL)
    , m_hWriterNotification(NULL)
    , m_hCancel(NULL)
    , m_bFileIsLive(0)
    , m_dwState(DVR_SOURCE_CLOSED)
    , m_nRefCount(0)
    , m_pwszFilename(NULL)
    , m_dwReadersArrayIndex(CDVRSharedMemory::MAX_READERS)
    , m_qwFileSize(0)
    , m_qwIndexFileOffset(0)
    , m_hWriterProcess(NULL)
    , m_pDVRSourceAdviseSink(pDVRSourceAdviseSink) // Should not be addref'd or released; will cause a circular dependency
    , m_pIDVRAsyncReader(NULL)
{
    HRESULT hr;

    ::InitializeCriticalSection(&m_cs);

    __try
    {
        hr = S_OK;
    }
    __finally
    {
        if (phr)
        {
            *phr = hr;
        }
    }

} // CDVRSource::CDVRSource


////////////////////////////////////////////////////////////////////////////
CDVRSource::~CDVRSource()
{
    if (m_pIDVRAsyncReader) {
        m_pIDVRAsyncReader -> Release () ;
    }
    ::DeleteCriticalSection(&m_cs);

} // CDVRSource::~CDVRSource

////////////////////////////////////////////////////////////////////////////
void CDVRSource::AssertIsClosed()
{
    assert(m_pwszFilename == NULL);
    assert(m_pShared == NULL);
    assert(m_hFile == NULL);
    assert(m_hFileMapping == NULL);
    assert(m_hTempIndexFile == NULL);
    assert(m_qwCurrentPosition == 0);
    assert(m_qwMaxHeaderAndDataSize == 0);
    assert(m_hMutex == NULL);
    assert(m_hWriterNotification == NULL);
    assert(m_hWriterProcess == NULL);
    assert(m_bFileIsLive == 0);
    assert(m_dwReadersArrayIndex == CDVRSharedMemory::MAX_READERS);
    assert(m_dwState == DVR_SOURCE_CLOSED);
    assert(m_qwFileSize == 0);
    assert(m_qwIndexFileOffset == 0);
    assert(m_hCancel == NULL);

} // CDVRSource::AssertIsClosed

////////////////////////////////////////////////////////////////////////////
HRESULT CDVRSource::LockSharedMemory(BOOL& bReleaseSharedMutex)
{
    HRESULT hr;

    bReleaseSharedMutex = 0;
    if (!m_hMutex)
    {
        return S_OK;
    }

    assert(m_pShared);

    // We ignore dwTimeOut here. We don't expect a long
    // wait
    DWORD dwRet = ::WaitForSingleObject(m_hMutex, INFINITE);
    if (dwRet == WAIT_ABANDONED && m_pShared->dwLastOwnedByWriter)
    {
        // Trouble, writer died while holding the mutex.
        // We can't guarantee consistency of the shared data
        // section. Just bail out.
        hr = E_FAIL;
        m_pShared->dwWriterAbandonedMutex = 1;
        m_pShared->dwLastOwnedByWriter = 0;
        bReleaseSharedMutex = 1;
        assert(0);
    }
    else if (dwRet == WAIT_FAILED)
    {
        DWORD dwLastError = ::GetLastError();
        hr = HRESULT_FROM_WIN32(dwLastError);
        assert(0);
    }
    else if (m_pShared->dwWriterAbandonedMutex == 1)
    {
        // Writer died while holding the mutex.
        // We can't guarantee consistency of the shared data
        // section. Just bail out.
        hr = E_FAIL;
        m_pShared->dwLastOwnedByWriter = 0;
        bReleaseSharedMutex = 1;
    }
    else
    {
        m_pShared->dwLastOwnedByWriter = 0;
        bReleaseSharedMutex = 1;
        hr = S_OK;
    }

    return hr;

} // CDVRSource::LockSharedMemory

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSource::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;

    //
    // Validate input parameter
    //
    assert(ppv);

    if (!ppv)
    {
        hr = E_POINTER;
    }
    else if (IsEqualGUID(IID_IStream, riid))
    {
        *ppv = (IStream*) this;
        ((IUnknown *) *ppv)->AddRef();

        hr = S_OK;
    }
    else if (IsEqualGUID(IID_IWMIStreamProps, riid))
    {
        *ppv = (IWMIStreamProps*) this;
        ((IUnknown *) *ppv)->AddRef();

        hr = S_OK;
    }
    else if (IsEqualGUID(IID_IDVRFileSource, riid))
    {
        *ppv = (IDVRFileSource*) this;
        ((IUnknown *) *ppv)->AddRef();

        hr = S_OK;
    }
    else if (IsEqualGUID(IID_IDVRFileSource2, riid))
    {
        *ppv = (IDVRFileSource2*) this;
        ((IUnknown *) *ppv)->AddRef();

        hr = S_OK;
    }
    else if (IsEqualGUID(IID_IUnknown, riid))
    {
        *ppv = (IUnknown*) (IDVRFileSource*) this;
        ((IUnknown *) *ppv)->AddRef();

        hr = S_OK;
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppv = NULL;
    }

    return hr;

} // CDVRSource::QueryInterface

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CDVRSource::AddRef()
{
    LONG nNewRef = ::InterlockedIncrement((PLONG) &m_nRefCount);

    assert(nNewRef > 0);

    return nNewRef <= 0? 0 : (ULONG) nNewRef;

} // CDVRSource::AddRef


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CDVRSource::Release()
{
    LONG nNewRef = ::InterlockedDecrement((PLONG) &m_nRefCount);

    assert(nNewRef >= 0);

    if (nNewRef == 0)
    {
        delete this;
    }

    return nNewRef <= 0? 0 : (ULONG) nNewRef;

} // CDVRSource::Release

//  sets an async IO reader; callee should ref the interface
STDMETHODIMP
CDVRSource::SetAsyncIOReader (
    IN  IDVRAsyncReader *   pIDVRAsyncReader
    )
{
    HRESULT         hr ;

    ::EnterCriticalSection(&m_cs); // time waiting to get in not subtracted from dwTimeOut

    if (!m_pIDVRAsyncReader) {
        m_pIDVRAsyncReader = pIDVRAsyncReader ;
        m_pIDVRAsyncReader -> AddRef () ;

        hr = S_OK ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    ::LeaveCriticalSection(&m_cs);

    return hr ;
}

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSource::Open(LPCWSTR   pwszFileName,
                              HANDLE    hCancel,
                              DWORD     dwTimeOut /* in milliseconds */ )
{
    HRESULT hrRet;

    if (!pwszFileName)
    {
        return E_INVALIDARG;
    }

    ::EnterCriticalSection(&m_cs); // time waiting to get in not subtracted from dwTimeOut

    __try
    {

        HRESULT                     hr;
        BY_HANDLE_FILE_INFORMATION  sFileInf;
        DWORD                       dwLastError;
        WCHAR                       wszMapping[50];
        WCHAR                       *pwszFilePart;
        DWORD                       nLen;
        WCHAR                       *pwszDirectory;
        WCHAR                       wTempChar;
        // DWORD                       dwRet;

        if (m_dwState == DVR_SOURCE_OPENED)
        {
            hr = Close();
            if (FAILED(hr))
            {
                // Will not happen: Close should never fail
                assert(0);
                hrRet = hr;
                __leave;
            }
        }

        AssertIsClosed();

        if (hCancel)
        {
            if (0 == ::DuplicateHandle(::GetCurrentProcess(), hCancel,
                                       ::GetCurrentProcess(), &m_hCancel,
                                       0,       // desired access - ignored
                                       FALSE,   // bInherit
                                       DUPLICATE_SAME_ACCESS))
            {
                dwLastError = ::GetLastError();
                assert(0);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }
        }
        else
        {
            m_hCancel = ::CreateEventW(NULL,        // security attr
                                       TRUE,        // manual reset
                                       FALSE,       // not signaled
                                       NULL         // name
                                      );

            if (m_hCancel == NULL)
            {
                dwLastError = ::GetLastError();
                assert(0);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }
        }

        // Save the fully qualified name of the file

        nLen = ::GetFullPathNameW(pwszFileName, 0, &wTempChar, NULL);
        if (nLen == 0)
        {
            dwLastError = ::GetLastError();
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }
        nLen++;  // for NULL terminator

        m_pwszFilename = new WCHAR[nLen];
        if (m_pwszFilename == NULL)
        {
            assert(0);
            hrRet = E_OUTOFMEMORY;
            __leave;
        }

        pwszDirectory = (PWCHAR) _alloca(sizeof(WCHAR) * nLen);
        if (!pwszDirectory)
        {
            hrRet = E_OUTOFMEMORY;
            __leave;
        }

        nLen = ::GetFullPathNameW(pwszFileName, nLen, pwszDirectory, &pwszFilePart);
        if (nLen == 0)
        {
            dwLastError = ::GetLastError();
            assert(0);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }
        assert(pwszFilePart);
        wcscpy(m_pwszFilename, pwszDirectory);
        *pwszFilePart = L'\0';

        // Open the file

        do
        {
            m_hFile = ::CreateFileW(m_pwszFilename,
                                    GENERIC_READ,
                                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,          // security attributes
                                    OPEN_EXISTING,
                                    FILE_FLAG_SEQUENTIAL_SCAN,
                                    NULL           // template file
                                   );

            if (m_hFile == INVALID_HANDLE_VALUE)
            {
                m_hFile = NULL;
                dwLastError = ::GetLastError();

                if (dwTimeOut == 0 || dwLastError != ERROR_FILE_NOT_FOUND)
                {
                    hrRet = HRESULT_FROM_WIN32(dwLastError);
                    __leave;
                }

                // Caller should not supply a huge timeout if it does not
                // know if the file exists or not.

                if (dwTimeOut < 100)
                {
                    dwTimeOut = 0;
                }
                else if (dwTimeOut != INFINITE)
                {
                    dwTimeOut -= 100;
                }

                // Use m_hCancel only for GetNextSample
                // dwRet = ::WaitForSingleObject(m_hCancel, 100);
                // if (dwRet == WAIT_OBJECT_0)
                // {
                //     dwLastError = ERROR_FILE_NOT_FOUND;
                //     hrRet = HRESULT_FROM_WIN32(dwLastError);
                //     __leave;
                // }
                // else if (dwRet != WAIT_TIMEOUT)
                // {
                //     dwLastError = ::GetLastError();
                //     hrRet = HRESULT_FROM_WIN32(dwLastError);
                //     __leave;
                // }
                Sleep(100);
            }
        }
        while (m_hFile == NULL);

        // The first write to the file writes the entire header, so if
        // the file is not empty, the entire header has been written
        // and we are ready to read the file. (Of course, if we have been
        // told to open a non-ASF file, some subsequent call will fail.)
        //
        // As currently structured, the DVR IO layer opens the file and
        // writes the header. (It could write the header - call BeginWriting
        // and then open the file, but it does not do that.) By the time
        // the header has been written, the memory map would have beem set
        // up. So we don't wait on any other call after this one.

        while (1)
        {
            if (::GetFileInformationByHandle(m_hFile, &sFileInf) == 0)
            {
                dwLastError = ::GetLastError();
                assert(0);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }
            if (sFileInf.nFileSizeHigh > 0 || sFileInf.nFileSizeLow > 0)
            {
                // Good to go - the file has some content in it
                break;
            }

            if (dwTimeOut == 0)
            {
                hrRet = NS_E_INVALID_DATA;
                __leave;
            }

            // Caller should not supply a huge timeout if it does not
            // know if the file is live or not

            if (dwTimeOut < 100)
            {
                dwTimeOut = 0;
            }
            else if (dwTimeOut != INFINITE)
            {
                dwTimeOut -= 100;
            }

            // Use m_hCancel only for GetNextSample
            // dwRet = ::WaitForSingleObject(m_hCancel, 100);
            // if (dwRet == WAIT_OBJECT_0)
            // {
            //     dwLastError = ERROR_FILE_NOT_FOUND;
            //     hrRet = HRESULT_FROM_WIN32(dwLastError);
            //     __leave;
            // }
            // else if (dwRet != WAIT_TIMEOUT)
            // {
            //     dwLastError = ::GetLastError();
            //     hrRet = HRESULT_FROM_WIN32(dwLastError);
            //     __leave;
            // }
            Sleep(100);
        }

        if (::GetFileInformationByHandle(m_hFile, &sFileInf) == 0)
        {
            dwLastError = ::GetLastError();
            assert(0);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        wsprintf(wszMapping, L"Global\\MSDVRMM_%u_%u_%u",
                 sFileInf.dwVolumeSerialNumber ,
                 sFileInf.nFileIndexHigh,
                 sFileInf.nFileIndexLow);

        m_hFileMapping = ::OpenFileMappingW (
                                FILE_MAP_READ | FILE_MAP_WRITE,
                                FALSE,           // bInheritHandle
                                wszMapping
                                ) ;

        dwLastError = ::GetLastError () ;
        if (!m_hFileMapping &&
            dwLastError != ERROR_FILE_NOT_FOUND) {

            hrRet = HRESULT_FROM_WIN32 (dwLastError) ;
            __leave ;
        }

        // Mapping name is used for temp files such as the index file
        // Remove Global\\ prefix from the mapping name.
        wsprintf(wszMapping, L"MSDVRMM_%u_%u_%u",
                 sFileInf.dwVolumeSerialNumber ,
                 sFileInf.nFileIndexHigh,
                 sFileInf.nFileIndexLow);


        //  at this point, either the file has content and/or we have a mapping;
        //  if we have a mapping, the file is live; else we have a > 0 sized
        //  file and no mapping ==> file is not live; if we don't have a memory
        //  map, we've confirmed that it is because the file does not exist, not
        //  some other error

        if (!m_hFileMapping)
        {
            //  non-live file case

            m_bFileIsLive = 0;
            m_qwMaxHeaderAndDataSize = 0;
            m_qwFileSize = (QWORD) sFileInf.nFileSizeLow + (((QWORD) sFileInf.nFileSizeHigh) << 32);

            if (m_pIDVRAsyncReader) {
                hr = m_pIDVRAsyncReader -> OpenFile (
                        NULL,                           //  no writer ID to use; file is not live
                        m_pwszFilename,
                        FILE_SHARE_DELETE | FILE_SHARE_READ,
                        OPEN_EXISTING
                        ) ;
                if (FAILED (hr)) {
                    hrRet = hr;
                    __leave ;
                }
            }
        }
        else
        {
            m_bFileIsLive = 1;
            m_qwFileSize = MAXQWORD;

            // Map the view
            m_pShared = (CDVRSharedMemory*) MapViewOfFile(m_hFileMapping,
                                                          FILE_MAP_READ | FILE_MAP_WRITE,
                                                          0, 0, // file offset for start of map, high and low
                                                          0     // Entire file
                                                         );
            if (m_pShared == NULL)
            {
                dwLastError = ::GetLastError();
                assert(0);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }

            // Get the writer's mutex handle and dup it.
            // The writer writes this with Interlocked functions. The
            // protocol is to lock the mutex and verify if writer is
            // still writing, once we have our own handle,
            // If it is done writing, the mutex is closed. If it is still
            // writinf, we create a writer notification event and dup it
            // into the writer's process.
            //
            // Finally, if the ASF file is being indexed, we open the
            // temp index file if necessary. We have to do this regardless
            // of whether the writer finished writing or not.

            HRESULT hrInnerTry;
            BOOL    bFileIsGrowing = 0;
            BOOL    bReleaseSharedMutex = 0;

            __try
            {
                // In this try section, we open the writer's mutex. The
                // shared memory section contains the dwMutexSuffix member,
                // which is suffixed to a constant string to derive the mutex name.
                // The writer writes this member with Interlocked functions. The
                // protocol is to lock the mutex and verify if writer is
                // still writing, once we have our own handle,
                // If the writer has terminated, the mutex is closed. 
                // If the writer is still writing, we create
                // a writer notification event and let the writer
                // know the event name by setting the dwEventSuffix member 
                // corresponding to this reader in the shared memory section.

                // hrInnerTry is set before leaving the try section

                DWORD  dwWriterMutexSuffix = m_pShared->dwMutexSuffix;

                if (dwWriterMutexSuffix == 0)
                {
                    // File is not growing any more

                    // Following assertion must be true because we set this
                    // member to 0 before we set hMutex to NUll in CDVRSharedMemory
                    // Since dwBeingWritten is 0, we don't have to test
                    // dwWriterAbandonedMutex - the writer has successfully finished
                    // and we don't care if it abandoned the mutex after that.
                    assert(m_pShared->dwBeingWritten == 0);
                    hrInnerTry = S_OK;
                    __leave;
                }

                WCHAR wszMutex[MAX_MUTEX_NAME_LEN];
                wcscpy(wszMutex, kwszSharedMutexPrefix);
                wsprintf(wszMutex, L"%s%u", kwszSharedMutexPrefix, dwWriterMutexSuffix);
                m_hMutex = ::OpenMutexW(SYNCHRONIZE, FALSE /* Inheritable */, wszMutex);

                if (m_hMutex == NULL)
                {
                    dwLastError = ::GetLastError();
                    hr = HRESULT_FROM_WIN32(dwLastError);
                    hrInnerTry = hr;
                    __leave;
                }

                hr = LockSharedMemory(bReleaseSharedMutex);

                if (FAILED(hr))
                {
                    hrInnerTry = hr;
                    __leave;
                }

                // One last check: Has writer stopped writing?
                // This test is not redundant. We don't want to
                // dup m_hWriterNotification into the writer if it
                // has stopped writing because the writer will never
                // close it. Also we want to be able to handle the
                // case when we fail to open the temp index file;
                // see the next __try
                if (m_pShared->dwMutexSuffix == 0)
                {
                    // File is not growing any more
                    assert(m_pShared->dwBeingWritten == 0);
                    hrInnerTry = S_OK;
                    __leave;
                }

                bFileIsGrowing = 1;

                // We try to open the writer process for synchronize
                // access. When this reader pends reads, we wait on the 
                // writer process handle (among other things). If the writer
                // process dies, the read returns. If we can't open the 
                // writer process, that's ok.
                assert(m_hWriterProcess == NULL);
                m_hWriterProcess = ::OpenProcess(SYNCHRONIZE,
                                                 FALSE,   // inherit handle
                                                 m_pShared->dwWriterPid);

                if (m_hWriterProcess == NULL)
                {
                    dwLastError = ::GetLastError(); // For debugging only
                }

                // Find a free spot in the Readers array, create the
                // writer notification event and set the dwEventSuffix member  
                // in shared memory.
                for (int i = 0; i < CDVRSharedMemory::MAX_READERS; i++)
                {
                    if (m_pShared->Readers[i].dwEventSuffix == 0)
                    {
                        DWORD                dwEventSuffix;
                        HANDLE               hEvent;
                        PACL                 pACL;
                        PSECURITY_DESCRIPTOR pSD;
                        DWORD                dwAclCreationStatus;
                        SECURITY_ATTRIBUTES  sa;

                        if (m_dwNumSids > 0)
                        {
                            // It suffices to give EVENT_MODIFY_STATE access to only the writer's 
                            // user context. We know the writer's pid, and there may be a
                            // way of getting its SID from that.
                            dwAclCreationStatus = ::CreateACL(m_dwNumSids, m_ppSids,
                                                              SET_ACCESS, EVENT_ALL_ACCESS,
                                                              SET_ACCESS, EVENT_MODIFY_STATE,
                                                              pACL,
                                                              pSD
                                                             );

                            if (dwAclCreationStatus != ERROR_SUCCESS)
                            {
                                hrInnerTry = HRESULT_FROM_WIN32(dwAclCreationStatus);
                                __leave;
                            }

                            sa.nLength = sizeof (SECURITY_ATTRIBUTES);
                            sa.lpSecurityDescriptor = pSD;
                            sa.bInheritHandle = FALSE;
                        }

                        WCHAR  wszEvent[MAX_EVENT_NAME_LEN];
                        
                        wcscpy(wszEvent, kwszSharedEventPrefix);
                        nLen = wcslen(kwszSharedEventPrefix);

                        for (dwEventSuffix = 1; dwEventSuffix != 0; dwEventSuffix++)
                        {
                            wsprintf(wszEvent + nLen, L"%u", dwEventSuffix);
                            
                            hEvent = ::CreateEventW(m_dwNumSids > 0 ? &sa : NULL,
                                                    FALSE,          // event is auto reset
                                                    FALSE,          // not signaled
                                                    wszEvent        // name
                                                );
                            dwLastError = ::GetLastError();

                            if (hEvent == NULL) 
                            {
                                // It's ok to fail for any reason. Ideally, we should 
                                // trap reasons that stem from insufficient resources and 
                                // bail out. Note that failure can be because this event
                                // is owned by someone else (we don't have access) or this
                                // name is being used by someone else as a semaphore, etc.
                                // In that case, we do want to ignore this error.
                            }
                            else if (dwLastError == ERROR_ALREADY_EXISTS)
                            {
                                // We want a new one, not something else that has 
                                // been created by someone else.
                                ::CloseHandle(hEvent);
                                hEvent = NULL;
                            }
                            else
                            {
                                break;
                            }
                        }
                        if (m_dwNumSids > 0)
                        {
                            ::FreeSecurityDescriptors(pACL, pSD);
                        }
                        if (hEvent == NULL) 
                        {
                            assert(0);
                            hrInnerTry = E_FAIL;
                            __leave;
                        }

                        m_hWriterNotification = hEvent;
                        
                        m_pShared->Readers[i].dwEventSuffix = dwEventSuffix;
                        m_dwReadersArrayIndex = i;
                        m_pShared->Readers[i].dwMsg = CDVRSharedMemory::CReaderInfo::DVR_READER_REQUEST_NONE;
                        break;
                    }
                } // for
                if (i == CDVRSharedMemory::MAX_READERS)
                {
                    // No space in the CDVRSharedMemory::Readers array
                    assert(0);
                    hrInnerTry = HRESULT_FROM_WIN32(ERROR_NO_SYSTEM_RESOURCES);
                    __leave;
                }

                //  file is live, so we open it with the writer GUID
                if (m_pIDVRAsyncReader) {
                    hr = m_pIDVRAsyncReader -> OpenFile (
                            & m_pShared -> guidWriterId,
                            m_pwszFilename,
                            FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                            OPEN_EXISTING
                            ) ;
                    if (FAILED (hr)) {
                        hrInnerTry = hr ;
                        __leave ;
                    }
                }

                // All done
                hrInnerTry = S_OK;
            }
            __finally
            {
            }

            // At the end of the next try we could end up
            // unmapping the view

            BOOL bUnmap = 0;

            __try
            {
                // In this try section we open the ASF index file if it is
                // being indexed and the ASF file is not temporary. We have to
                // do this regardless of whether the writer finished writing or not.

                if (FAILED(hrInnerTry))
                {
                    __leave;
                }
                // If the ASF file is not a temporary file and it is being indexed
                // open the temp index file (which holds the part of the index that has
                // been flushed out of the shared memory section)
                if (!m_pShared->dwIsTemporary && m_pShared->pIndexHeader != NULL)
                {
                    WCHAR                       *pwszIndexFile;

                    nLen = wcslen(pwszDirectory) + wcslen(wszMapping) + 4 + 1;
                    pwszIndexFile = (PWCHAR) _alloca(sizeof(WCHAR) * nLen);
                    if (!pwszIndexFile)
                    {
                        hrInnerTry = E_OUTOFMEMORY;
                        __leave;
                    }
                    wsprintf(pwszIndexFile, L"%ls%ls.tmp", pwszDirectory, wszMapping);

                    m_hTempIndexFile = ::CreateFileW(pwszIndexFile,
                                                     GENERIC_READ | DELETE,
                                                     FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                     NULL,          // security attributes
                                                     OPEN_EXISTING,
                                                     FILE_FLAG_RANDOM_ACCESS,
                                                     NULL           // template file
                                                    );
                    if (m_hTempIndexFile == INVALID_HANDLE_VALUE)
                    {
                        dwLastError = ::GetLastError();

                        if (dwLastError != ERROR_FILE_NOT_FOUND &&
                            dwLastError != ERROR_DELETE_PENDING)
                        {
                            hrInnerTry = HRESULT_FROM_WIN32(dwLastError);
                            m_hTempIndexFile = NULL;
                            __leave;
                        }
                        if (bFileIsGrowing)
                        {
                            // This should not happen. The writer should
                            // still have an open handle to the file and
                            // should allow us to open it
                            assert(0);
                            hrInnerTry = HRESULT_FROM_WIN32(dwLastError);
                            assert(FAILED(hrInnerTry));
                            m_hTempIndexFile = NULL;
                            __leave;
                        }

                        // This is not necessarily an error. The file was opened
                        // as delete_on_close. The last handle on the file could
                        // have been closed and the file could have been deleted.
                        // Typically, the memory mapping would also have been closed
                        // by the other client,but we may have succeeded in opening
                        // the memory map before the client closed it. We now just have
                        // to pretend that we have a complete ASF file on disk. (Note
                        // that we have checked that bFileIsGrowing == FALSE, so the
                        // writer would in fact have completed flushing the index to disk.)


                        // We created this only if bFileIsGrowing is set to 1, so
                        // this assert should not fail. Assert is here just to note
                        // that this does not have to be closed
                        assert(m_hWriterNotification == NULL);
                        assert(m_dwReadersArrayIndex == CDVRSharedMemory::MAX_READERS);

                        bUnmap = 1;
                        hrInnerTry = S_OK;
                        m_hTempIndexFile = NULL;
                        __leave;
                    }
                }
                // If the file is being indexed, ...
                if (m_pShared->pIndexHeader != NULL)
                {
                    m_qwMaxHeaderAndDataSize = m_pShared->qwIndexHeaderOffset;
                }
            }
            __finally
            {
                if (bReleaseSharedMutex)
                {
                    ::ReleaseMutex(m_hMutex);
                }

                if (SUCCEEDED(hrInnerTry))
                {
                    if (!bFileIsGrowing && m_hMutex)
                    {
                        ::CloseHandle(m_hMutex);
                        m_hMutex = NULL;
                    }
                    if (bUnmap)
                    {
                        m_bFileIsLive = 0;
                        m_qwMaxHeaderAndDataSize = 0;
                        m_qwFileSize = (QWORD) sFileInf.nFileSizeLow + (((QWORD) sFileInf.nFileSizeHigh) << 32);
                        UnmapViewOfFile(m_pShared);
                        m_pShared = NULL;
                        ::CloseHandle(m_hFileMapping);
                        m_hFileMapping = NULL;
                    }
                }
                hrRet = hrInnerTry;
            }
            if (FAILED(hrRet))
            {
                __leave;
            }
        }

        // Redundant: we've asserted this above
        m_qwCurrentPosition = 0;

        m_dwState = DVR_SOURCE_OPENED;

        hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            Close();
        }
        ::LeaveCriticalSection(&m_cs);
    }

    return hrRet;


} // CDVRSource::Open

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSource::Close()
{
    ::EnterCriticalSection(&m_cs); // time waiting to get in not subtracted from dwTimeOut

    __try
    {
        if (m_pwszFilename)
        {
            delete [] m_pwszFilename;
            m_pwszFilename = NULL;
        }

        if (m_pIDVRAsyncReader) {
            m_pIDVRAsyncReader -> CloseFile () ;
        }

        if (m_pShared)
        {
            BOOL    bReleaseSharedMutex = 0;
            HRESULT hr = LockSharedMemory(bReleaseSharedMutex);

            if (bReleaseSharedMutex)
            {
                // Do this regardless of whether LockSharedMemory
                // returns success or not. That function obtains
                // the mutex but returns failure if the writer
                // had abandoned the mutex. We don't have to
                // clean up in that case, but we may as well.

                assert(m_dwReadersArrayIndex !=CDVRSharedMemory::MAX_READERS);
                m_pShared->Readers[m_dwReadersArrayIndex].dwMsg = CDVRSharedMemory::CReaderInfo::DVR_READER_REQUEST_DONE;
                ::ReleaseMutex(m_hMutex);
            }

            UnmapViewOfFile(m_pShared);
            m_pShared = NULL;
        }
        if (m_hFileMapping)
        {
            ::CloseHandle(m_hFileMapping);
            m_hFileMapping = NULL;
        }
        if (m_hFile)
        {
            ::CloseHandle(m_hFile);
            m_hFile = NULL;
        }
        if (m_hTempIndexFile)
        {
            ::CloseHandle(m_hTempIndexFile);
            m_hTempIndexFile = NULL;
        }
        m_qwCurrentPosition = 0;
        m_qwMaxHeaderAndDataSize = 0;
        if (m_hMutex)
        {
            ::CloseHandle(m_hMutex);
            m_hMutex = NULL;
        }
        if (m_hWriterNotification)
        {
            ::CloseHandle(m_hWriterNotification);
            m_hWriterNotification = NULL;
        }
        if (m_hWriterProcess)
        {
            ::CloseHandle(m_hWriterProcess);
            m_hWriterProcess = NULL;
        }
        if (m_hCancel)
        {
            ::CloseHandle(m_hCancel);
            m_hCancel = NULL;
        }
        m_bFileIsLive = 0;
        m_qwFileSize = 0;
        m_qwIndexFileOffset = 0;

        m_dwReadersArrayIndex = CDVRSharedMemory::MAX_READERS;
        m_dwState = DVR_SOURCE_CLOSED;
    }
    __finally
    {
        AssertIsClosed();
        ::LeaveCriticalSection(&m_cs);
    }

    return S_OK;

}  // CDVRSource::Close

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSource::IsFileLive(BOOL* pbLiveFile, BOOL* pbShared)
{
    HRESULT hrRet;

    if (!pbLiveFile || !pbShared)
    {
        return E_POINTER;
    }

    BOOL bReleaseSharedMutex = 0;

    ::EnterCriticalSection(&m_cs); // time waiting to get in not subtracted from dwTimeOut

    __try
    {
        if (m_dwState == DVR_SOURCE_CLOSED)
        {
            hrRet = E_UNEXPECTED;
            __leave;
        }
        if (!m_bFileIsLive)
        {
            *pbLiveFile = 0;
            *pbShared = 0;
            hrRet = S_OK;
            __leave;
        }

         // We are reading bytes out of the shared memory section.
         // Specifically, we still fudge bytes
         *pbShared = 1;

        HRESULT hr = LockSharedMemory(bReleaseSharedMutex);

        if (FAILED(hr))
        {
            *pbLiveFile = 1;
            hrRet = hr;
            __leave;
        }

        assert(m_pShared);

        if (!m_pShared->dwBeingWritten)
        {
            *pbLiveFile = 0;
            hrRet = S_OK;
            __leave;
        }

        // assert(m_hWriterProcess);

        if (m_hWriterProcess)
        {
            DWORD  dwRet;
    
            dwRet = ::WaitForSingleObject(m_hWriterProcess, 0);
            if (dwRet == WAIT_FAILED)
            {
                DWORD dwLastError = ::GetLastError();
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                assert(0);
                *pbLiveFile = 1;
                __leave;
            }
            if (dwRet == WAIT_OBJECT_0)
            {
                // Writer dead, but has left m_pShared->dwBeingWritten = 1

                *pbLiveFile = 0;
                hrRet = S_OK;
                __leave;
            }
            assert(dwRet == WAIT_TIMEOUT);
        }

        *pbLiveFile = 1;
        hrRet = S_OK;
    }
    __finally
    {
        if (bReleaseSharedMutex)
        {
            ::ReleaseMutex(m_hMutex);
        }
        ::LeaveCriticalSection(&m_cs);
    }

    return hrRet;

} // CDVRSource::IsFileLive

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSource::GetFileSize(QWORD* pqwFileSize)
{
    HRESULT hrRet;

    if (!pqwFileSize)
    {
        return E_POINTER;
    }

    ::EnterCriticalSection(&m_cs); // time waiting to get in not subtracted from dwTimeOut

    BOOL bReleaseSharedMutex = 0;

    __try
    {
        HRESULT hr;

        if (!m_bFileIsLive)
        {
            hrRet = E_UNEXPECTED;
            __leave;
        }

        // m_bFileIsLive implies this
        assert(m_dwState == DVR_SOURCE_OPENED);

        hr = LockSharedMemory(bReleaseSharedMutex);

        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        assert(m_pShared);

        *pqwFileSize = m_pShared->qwCurrentFileSize;

        hrRet = S_OK;
    }
    __finally
    {
        if (bReleaseSharedMutex)
        {
            ::ReleaseMutex(m_hMutex);
        }
        ::LeaveCriticalSection(&m_cs);
    }

    return hrRet;

} // CDVRSource::GetFileSize

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSource::GetLastTimeStamp(QWORD* pcnsLastTimeStamp)
{
    HRESULT hrRet;

    if (!pcnsLastTimeStamp)
    {
        return E_POINTER;
    }

    ::EnterCriticalSection(&m_cs); // time waiting to get in not subtracted from dwTimeOut

    BOOL bReleaseSharedMutex = 0;

    __try
    {
        HRESULT hr;

        if (!m_bFileIsLive)
        {
            hrRet = E_UNEXPECTED;
            __leave;
        }

        // m_bFileIsLive implies this
        assert(m_dwState == DVR_SOURCE_OPENED);

        hr = LockSharedMemory(bReleaseSharedMutex);

        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        assert(m_pShared);

        *pcnsLastTimeStamp = m_pShared->msLastPresentationTime * 10000;

        hrRet = S_OK;
    }
    __finally
    {
        if (bReleaseSharedMutex)
        {
            ::ReleaseMutex(m_hMutex);
        }
        ::LeaveCriticalSection(&m_cs);
    }

    return hrRet;

} // CDVRSource::GetLastTimeStamp

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSource::Cancel()
{
    // This operation does not lock m_cs. m_hCancel is
    // available till the object is destroyed, so as long
    // as the calling thread has a valid refcount on this
    // object, this operation is ok

    assert(m_hCancel);

    if (::SetEvent(m_hCancel) == 0)
    {
        DWORD dwLastError = ::GetLastError();

        assert(0);

        return HRESULT_FROM_WIN32(dwLastError);
    }

    return S_OK;

} // CDVRSource::Cancel

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSource::ResetCancel()
{
    // This operation does not lock m_cs. m_hCancel is
    // available till the object is destroyed, so as long
    // as the calling thread has a valid refcount on this
    // object, this operation is ok

    assert(m_hCancel);

    if (::ResetEvent(m_hCancel) == 0)
    {
        DWORD dwLastError = ::GetLastError();

        assert(0);

        return HRESULT_FROM_WIN32(dwLastError);
    }

    return S_OK;

} // CDVRSource::ResetCancel

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSource::Stat(STATSTG *pStatStg, DWORD grfStatFlag)
{
    HRESULT hrRet;

    if (!pStatStg)
    {
        return E_POINTER;
    }
    if (grfStatFlag != STATFLAG_DEFAULT && grfStatFlag != STATFLAG_NONAME)
    {
        // This may be an addition after our times
        return E_INVALIDARG;
    }

    ::EnterCriticalSection(&m_cs); // time waiting to get in not subtracted from dwTimeOut

    __try
    {
        DWORD dwLastError;

        pStatStg->pwcsName = NULL;
        if (m_dwState != DVR_SOURCE_OPENED)
        {
            hrRet = E_UNEXPECTED;
            __leave;
        }

        if (grfStatFlag != STATFLAG_NONAME)
        {
            assert(m_pwszFilename);
            pStatStg->pwcsName = (WCHAR*) ::CoTaskMemAlloc(sizeof(WCHAR) * (wcslen(m_pwszFilename) + 1));
            if (pStatStg->pwcsName == NULL)
            {
                assert(0);
                hrRet = E_OUTOFMEMORY;
                __leave;
            }
        }

        assert(m_hFile);

        BY_HANDLE_FILE_INFORMATION sFileInf;

        if (::GetFileInformationByHandle(m_hFile, &sFileInf) == 0)
        {
            dwLastError = ::GetLastError();
            assert(0);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        pStatStg->type = STGTY_STREAM;
        if (m_bFileIsLive)
        {
            // We have to make the ASF file source believe that
            // this file has been fully written to disk and it is
            // as large as it can get.

            assert(m_pShared);
            pStatStg->cbSize.QuadPart = MAXQWORD;
        }
        else
        {
            pStatStg->cbSize.LowPart =  sFileInf.nFileSizeLow;
            pStatStg->cbSize.HighPart = sFileInf.nFileSizeHigh;
        }
        if (m_qwFileSize != pStatStg->cbSize.QuadPart)
        {
            // The file has changed size after we opened it.
            // This assert is benign *provided* an external app
            // changed the file size. (Note that the file is opened
            // with FILE_SHARE_WRITE.) Otherwise, we've goofed; we should
            // have treated the file as being live when we opened it
            // (and we expect that the current size of the file,
            // StatStg->cbSize.QuadPart, is > than the size when
            // we opened the file, m_qwFileSize).

            // @@@@ Consider: adding a flag to the shared section to
            // ask all readers and the writer to stop processing this
            // file since we hit an irrecoverable error. Or at least
            // get this reader to fail all other calls to this file.
            assert(0);
            hrRet = E_FAIL;
            __leave;
        }
        pStatStg->mtime = sFileInf.ftLastWriteTime;
        pStatStg->ctime = sFileInf.ftCreationTime;
        pStatStg->atime = sFileInf.ftLastAccessTime;

        // Note that the file is opened with FILE_SHARE_WRITE,
        // but the storage (and file) cannot be subsequently opened
        // for write.because the writer does not specify
        // FILE_SHARE_WRITE when it opens the file.
        //
        // STGM_DIRECT (no transactioning supported) is the default
        pStatStg->grfMode = STGM_READ | STGM_SHARE_DENY_WRITE | STGM_DIRECT;
        pStatStg->grfLocksSupported = 0;
        pStatStg->clsid = CLSID_NULL;
        pStatStg->grfStateBits = 0;
        pStatStg->reserved = 0;

        hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet) && pStatStg->pwcsName)
        {
            ::CoTaskMemFree(pStatStg->pwcsName);
            pStatStg->pwcsName = NULL;
        }
        ::LeaveCriticalSection(&m_cs);
    }

    return hrRet;

} // CDVRSource::Stat

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSource::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    HRESULT         hrRet;
    QWORD           qwSeekPosition; // relative to the start of the file

    ::EnterCriticalSection(&m_cs); // time waiting to get in not subtracted from dwTimeOut

    __try
    {
        DWORD   dwLastError;

        if (m_dwState != DVR_SOURCE_OPENED)
        {
            hrRet = E_UNEXPECTED;
            __leave;
        }

        assert(m_hFile);

        // Compute the seek offset relative to start of the file
        switch (dwOrigin)
        {
            case STREAM_SEEK_SET:
                // Note that in this case, dlibMove should be treated as unsigned
                // as per MSDN, see IStream::Seek
                qwSeekPosition = (QWORD) dlibMove.QuadPart;
                break;

            case STREAM_SEEK_CUR:
                if (dlibMove.QuadPart >= 0)
                {
                    qwSeekPosition = m_qwCurrentPosition + (ULONGLONG) dlibMove.QuadPart;
                    if (qwSeekPosition < m_qwCurrentPosition)
                    {
                        // We'll be seeking to beyond 2^64 - 1  No can do,
                        hrRet = E_INVALIDARG;
                        __leave;
                    }
                }
                else if (dlibMove.QuadPart < 0)
                {
                    qwSeekPosition = m_qwCurrentPosition + (ULONGLONG) dlibMove.QuadPart;
                    if (qwSeekPosition >= m_qwCurrentPosition)
                    {
                        // We'll be seeking to < 0. This is not allowed as per
                        // MSDN, see IStream::Seek
                        hrRet = E_INVALIDARG;
                        __leave;
                    }
                }
                break;

            case STREAM_SEEK_END:
                if (dlibMove.QuadPart >= 0)
                {
                    qwSeekPosition = m_qwFileSize + (ULONGLONG) dlibMove.QuadPart;
                    if (qwSeekPosition < m_qwFileSize)
                    {
                        // We'll be seeking to beyond 2^64 - 1  No can do,
                        hrRet = E_INVALIDARG;
                        __leave;
                    }

                    // If the file was live, m_qwFileSize should be MAXQWORD
                    // and the test above should have succeeded
                    assert(!m_bFileIsLive);
                }
                else if (dlibMove.QuadPart < 0)
                {
                    qwSeekPosition = m_qwFileSize + (ULONGLONG) dlibMove.QuadPart;
                    if (qwSeekPosition >= m_qwFileSize)
                    {
                        // We'll be seeking to < 0. This is not allowed as per
                        // MSDN, see IStream::Seek
                        hrRet = E_INVALIDARG;

                        // If the file is live, m_qwFileSize should be MAXQWORD
                        // and qwSeekPosition should be >= 0 and < m_qwFileSize
                        assert(!m_bFileIsLive);
                        __leave;
                    }
                }
                break;

            default:
                hrRet = E_INVALIDARG;
                __leave;
        }

        if (qwSeekPosition == m_qwCurrentPosition)
        {
            // We don't force the seek again.
            // This assumes that (a) all the writer code is good and once
            // we have been able to seek to a location, we'll be able to do
            // so again - this should be the case since the writer only appends
            // to the file and never shrinks it, and
            // (b) No external app has opened the file and messed with it. This is
            // possible if the writer has closed its file handle since the readers
            // open the file with FILE_WRITE_SHARE.

            if (plibNewPosition)
            {
                plibNewPosition->QuadPart = m_qwCurrentPosition;
            }
            hrRet = S_OK;
            __leave;
        }

        // Note that if the file is live, a seek to m_qwMaxHeaderAndDataSize
        // (which is = MAXQWORD - MAXDWORD) is viewed as a seek to
        // the start of the index portion rather than as a seek to the
        // end of the data section of the file (i.e., m_hFile pointer is
        // not moved to m_qwMaxHeaderAndDataSize)
        if (!m_bFileIsLive || qwSeekPosition < m_qwMaxHeaderAndDataSize)
        {
            LARGE_INTEGER   llSeekPosition;

            // An optimization for live files is to not make this call if the
            // file pointer of m_hFile is already at this location, i.e., we
            // could have seeked to the index portion of the file and then back
            // to where we were in the data portion of the file. We don't expect
            // much of a gain by filtering this case out. (If we do add another
            // member to track the file position of m_hFile, we could as well
            // make this seek lazy as well, i.e., seek only before the read if
            // needed.)

            if (qwSeekPosition > MAXLONGLONG)
            {
                // This caller can't be serious, but here we are

                // SetFilePointerEx does not support unsigned offsets. We have
                // to seek more than once. Note that if we knew the size of the file
                // (and the size of the file was > MAXLONGLONG), we could get
                // away with one seek relative to the end of the file. But
                // finding out the file size would require calling
                // ::GetFileInformationByHandle and locking the mutex to ensure
                // that the file size does not grow while we write. (We could
                // use CDVRSharedMemory::qwTotalFileSize instead of calling
                // ::GetFileInformationByHandle, but that would assume correctness
                // of the DVR sink code)
                llSeekPosition.QuadPart = MAXLONGLONG;
            }
            else
            {
                llSeekPosition.QuadPart = (LONGLONG) qwSeekPosition;
            }

            hrRet = SeekToLocked (
                        & llSeekPosition,
                        FILE_BEGIN,
                        (LARGE_INTEGER *) plibNewPosition
                        ) ;
            if (FAILED (hrRet)) {
                __leave ;
            }

            if (qwSeekPosition > MAXLONGLONG)
            {
                QWORD qwRest = qwSeekPosition - MAXLONGLONG;
                if (qwRest > MAXLONGLONG)
                {
                    // Note that 2 seeks are enough for for live files
                    // since m_qwMaxHeaderAndDataSize < MAXQWORD

                    assert(!m_bFileIsLive);

                    assert(llSeekPosition.QuadPart == MAXLONGLONG);

                    hrRet = SeekToLocked (
                                & llSeekPosition,
                                FILE_CURRENT,
                                (LARGE_INTEGER *) plibNewPosition
                                ) ;
                    if (FAILED (hrRet)) {
                        __leave ;
                    }

                    qwRest -= MAXLONGLONG;
                }
                llSeekPosition.QuadPart = (LONGLONG) qwRest;

                hrRet = SeekToLocked (
                            & llSeekPosition,
                            FILE_CURRENT,
                            (LARGE_INTEGER *) plibNewPosition
                            ) ;
                if (FAILED (hrRet)) {
                    __leave ;
                }
            }
            hrRet = S_OK;
            __leave;
        }

        // Seeking to the index portion of a live file

        assert(m_bFileIsLive && qwSeekPosition >= m_qwMaxHeaderAndDataSize);

        // Seeks to this part of the file are lazy. They have to be if
        // we have a temp index file since the seeked to location could
        // be in shared memory when this function is called, but could
        // have been flushed to the temp index file when reading.

        // Note also that we allow seeks beyond the last idnex offset.
        // This is in the spirit of seeks (seeks beyond the EOF are ok).
        // It also saves us from having to grab the mutex. The ASF
        // file source (as currently implemented), will not attempt to
        // seek beyond the last index in the file.

        if (plibNewPosition)
        {
            plibNewPosition->QuadPart = qwSeekPosition;
        }
        hrRet = S_OK;
    }
    __finally
    {
        if (SUCCEEDED(hrRet))
        {
            assert(!plibNewPosition || plibNewPosition->QuadPart == qwSeekPosition);
            m_qwCurrentPosition = qwSeekPosition;
        }
        ::LeaveCriticalSection(&m_cs);
    }

    return hrRet;

} // CDVRSource::Seek

HRESULT
CDVRSource::ReadBytesLocked (
    IN  LPVOID  pBuffer,
    IN  DWORD   dwRead,
    OUT DWORD * pdwRead
    )
{
    HRESULT hr ;
    BOOL    r ;
    DWORD   dwErr ;

    if (m_pIDVRAsyncReader) {

        hr = m_pIDVRAsyncReader -> ReadBytes (
                & dwRead,
                (BYTE *) pBuffer
                ) ;

        if (SUCCEEDED (hr)) {
            (* pdwRead) = dwRead ;
        }
        else {
            (* pdwRead) = 0 ;
        }
    }
    else {
        assert (m_hFile != INVALID_HANDLE_VALUE) ;

        r = ::ReadFile (
                m_hFile,
                pBuffer,
                dwRead,
                pdwRead,
                NULL
                ) ;

        if (r) {
            hr = S_OK ;
        }
        else {
            dwErr = ::GetLastError () ;
            hr = HRESULT_FROM_WIN32 (dwErr) ;
        }
    }

    return hr ;
}

HRESULT
CDVRSource::SeekToLocked (
    IN  LARGE_INTEGER * pliOffsetSeekTo,
    IN  DWORD           dwMoveMethod,       //  FILE_BEGIN, FILE_CURRENT, FILE_END
    OUT LARGE_INTEGER * pliOffsetActual
    )
{
    HRESULT hr ;
    BOOL    r ;
    DWORD   dwErr ;

    if (m_pIDVRAsyncReader) {
        hr = m_pIDVRAsyncReader -> Seek (
                pliOffsetSeekTo,
                dwMoveMethod,
                pliOffsetActual
                ) ;
    }
    else {
        assert (m_hFile) ;
        r = ::SetFilePointerEx (
                    m_hFile,
                    (* pliOffsetSeekTo),
                    pliOffsetActual,
                    dwMoveMethod
                    ) ;
        if (r) {
            hr = S_OK ;
        }
        else {
            dwErr = ::GetLastError () ;
            hr = HRESULT_FROM_WIN32 (dwErr) ;
        }
    }

    return hr ;
}

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSource::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    // We probe here because some of the reads are satisfied by us
    // without calling ReadFile
    if (!pv || ::IsBadWritePtr(pv, cb))
    {
        return E_POINTER;
    }

    BOOL            bReleaseSharedMutex = 0;
    HRESULT         hrRet;
    DWORD           dwRead = 0;

    ::EnterCriticalSection(&m_cs); // time waiting to get in not subtracted from dwTimeOut

    __try
    {
        DWORD           dwLastError;
        QWORD           qwLast; // relative to the start of the file
        HRESULT         hr;


        if (m_dwState != DVR_SOURCE_OPENED)
        {
            hrRet = E_UNEXPECTED;
            __leave;
        }

        assert(m_hFile);

        if (!m_bFileIsLive)
        {
            // File is complete; just read from the file.
            // m_qwCurrentPosition is unused although we update it.

            hrRet = ReadBytesLocked (
                        pv,
                        cb,
                        & dwRead
                        ) ;

            if (FAILED (hrRet))
            {
                assert(0);
                __leave;
            }

            //  leave anyway; but successfully
            __leave;
        }

        assert(m_pShared);

        qwLast = m_qwCurrentPosition + cb;

        if (m_qwCurrentPosition < m_qwMaxHeaderAndDataSize)
        {
            // Reading from the header or the data sections of the ASF file

            DWORD       dwNumToRead = cb;
            QWORD       qwLastInFile = qwLast;
            BOOL        bWait = 0;
            BOOL        bFileFullyWritten = 0;
            QWORD       qwMaxFileSize;

            if (qwLast > m_qwMaxHeaderAndDataSize)
            {
                assert(!"Attempting to read bytes from both the data and index objects. Unsupported.");

                dwNumToRead -= (DWORD) (qwLast - m_qwMaxHeaderAndDataSize);
                qwLastInFile = m_qwMaxHeaderAndDataSize;

                // We will read at most dwNumToRead bytes
            }

            // Grab the shared memory lock and, if needed, ask the writer
            // to signal us when it can satisfy our read request.
            hr = LockSharedMemory(bReleaseSharedMutex);

            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }

            if (m_pShared->qwCurrentFileSize < qwLastInFile)
            {
                if (m_pShared->dwBeingWritten)
                {
                    bWait = 1;
                    assert(m_dwReadersArrayIndex !=CDVRSharedMemory::MAX_READERS);
                    ::ResetEvent(m_hWriterNotification);
                    m_pShared->Readers[m_dwReadersArrayIndex].qwReaderOffset = qwLastInFile;
                    m_pShared->Readers[m_dwReadersArrayIndex].dwMsg = CDVRSharedMemory::CReaderInfo::DVR_READER_REQUEST_READ;
                }
                else
                {
                    // m_pShared->qwCurrentFileSize is as large as the header + data section
                    // of the ASF file will grow to. Note that this member does not include
                    // the number of bytes in the index section of the file, not even after
                    // the index has been appended to the file.
                    qwMaxFileSize = m_pShared->qwCurrentFileSize;
                    bFileFullyWritten = 1;
                }
            }

            if (bWait && m_pDVRSourceAdviseSink)
            {
                // Do this before giving up the mutex since we know that the
                // callback is going to call GetLastTimeStamp, which locks the
                // mutex
                m_pDVRSourceAdviseSink->ReadIsGoingToPend();
            }

            if (bReleaseSharedMutex)
            {
                ::ReleaseMutex(m_hMutex);
                bReleaseSharedMutex = 0;
            }

            if (bWait)
            {
                // If >1 object signalled at same time, WFMO returns the smallest index
                HANDLE hWait[3] = {m_hCancel, m_hWriterNotification, m_hWriterProcess};
                DWORD  dwRet;
                DWORD  dwNumWaitObjects = sizeof(hWait)/sizeof(HANDLE) - (m_hWriterProcess? 0 : 1);

                dwRet = ::WaitForMultipleObjects(dwNumWaitObjects, hWait, FALSE /* wait for any */, INFINITE);
                if (dwRet == WAIT_FAILED)
                {
                    dwLastError = ::GetLastError();
                    hrRet = HRESULT_FROM_WIN32(dwLastError);
                    assert(0);
                    __leave;
                }
                if (dwRet == WAIT_OBJECT_0)
                {
                    // Cancelled. We don't cancel the request to the writer.
                    // Note that we reset m_hWriterNotification before making
                    // a new request to the writer.

                    // Assert that leaving here doesn't mess up what we have
                    // in the __finally section.
                    assert(dwRead == 0);

                    hrRet = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    __leave;
                }

                BOOL bDead = (dwRet == WAIT_OBJECT_0 + 2);

                if (bDead)
                {
                    assert(m_hWriterProcess);
                }

                // Determine whether the writer wrote the bytes we wanted or whether it
                // has finished writing the data section or whether it died

                hr = LockSharedMemory(bReleaseSharedMutex);

                if (FAILED(hr))
                {
                    // This covers the case where the writer died while owning the mutex
                    hrRet = hr;
                    __leave;
                }
                if (!m_pShared->dwBeingWritten || bDead)
                {
                    // m_pShared->qwCurrentFileSize is as large as the header + data section
                    // of the ASF file will grow to. Note that this member does not include
                    // the number of bytes in the index section of the file, not even after
                    // the index has been appended to the file.
                    qwMaxFileSize = m_pShared->qwCurrentFileSize;
                    bFileFullyWritten = 1;

                    // Note that if bDead != 0, we do not change m_pShared->dwBeingWritten to 0.
                    // Leave it as is - in case we need to do special stuff for clean up,
                    // other clients can detect that the writer did not finish writing,
                }
                else
                {
                    assert(m_pShared->qwCurrentFileSize >= qwLastInFile);
                }

                if (bReleaseSharedMutex)
                {
                    ::ReleaseMutex(m_hMutex);
                    bReleaseSharedMutex = 0;
                }

            } // if (bWait)

            if (bFileFullyWritten)
            {
                if (m_qwCurrentPosition >= qwMaxFileSize)
                {
                    // We have been positioned beyond the data section of the file (but
                    // before the index section which begins at m_qwMaxHeaderAndDataSize.)
                    // So return EOF.
                    dwNumToRead = 0;
                }
                else if (qwLastInFile > qwMaxFileSize)
                {
                    // Adjust dwNumToRead so that we do not read beyond the data section
                    // in the file.

                    dwNumToRead -= (DWORD) (qwLastInFile - qwMaxFileSize);
                    qwLastInFile = qwMaxFileSize;
                }
            }

            if (dwNumToRead == 0)
            {
                // Short circuit the read. Effectively, this returns EOF.
                dwRead = 0;
            }
            else {
                hrRet = ReadBytesLocked (
                            pv,
                            dwNumToRead,
                            & dwRead
                            ) ;

                if (FAILED (hrRet)) {
                    // If dwRead == 0, ReadFile is signalling EOF. That's not good;
                    // we should have skipped the call to ReadFile if we thought we
                    // were at EOF. Note that this is not an innocuous error. If the
                    // writer appends the index to the file, ReadFile would signal EOF
                    // only after reading the index bytes and the code above should
                    // be making sure that we don't even try to read the index section
                    // at all
                    assert (dwRead == 0) ;
                }
            }

            if (dwRead == 0)
            {
                // We are at the end of the file.
                hrRet = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
                __leave;
            }

            // If we read bytes that we are supposed to fudge, replace them

            for (DWORD i = 0 ; i < CDVRSharedMemory::MAX_FUDGE; i++)
            {
                if (m_qwCurrentPosition > (QWORD) m_pShared->FudgeOffsets[i].dwEndOffset)
                {
                    // All done
                    break;
                }
                if (m_qwCurrentPosition + dwRead <= (QWORD) m_pShared->FudgeOffsets[i].dwStartOffset)
                {
                    continue;
                }

                QWORD qwStart       = m_pShared->FudgeOffsets[i].dwStartOffset;
                QWORD qwEnd         = m_pShared->FudgeOffsets[i].dwEndOffset; // last byte that should be changed
                DWORD dwSrcStart    = m_pShared->FudgeOffsets[i].pFudgeBytes;

                if (m_qwCurrentPosition > m_pShared->FudgeOffsets[i].dwStartOffset)
                {
                    qwStart = m_qwCurrentPosition;
                    dwSrcStart += (DWORD) (m_qwCurrentPosition - m_pShared->FudgeOffsets[i].dwStartOffset);
                }
                if (m_qwCurrentPosition + dwRead <= qwEnd)
                {
                    qwEnd = m_qwCurrentPosition + dwRead - 1;
                }
                ::CopyMemory((BYTE*) pv + qwStart - m_qwCurrentPosition,
                             &m_pShared->pFudgeBytes[dwSrcStart],
                             (DWORD) (qwEnd - qwStart + 1));
            }

            hrRet = S_OK;
            __leave;

        } // if (m_qwCurrentPosition < m_qwMaxHeaderAndDataSize)

        // Seeking to the index portion of a live file

        assert(m_bFileIsLive && m_qwCurrentPosition >= m_qwMaxHeaderAndDataSize);
        assert(m_qwFileSize == MAXQWORD);
        assert(dwRead == 0);

        // Seeks to this part of the file are lazy. They have to be if
        // we have a temp index file since the seeked to location could
        // be in shared memory when this function is called, but could
        // have been flushed to the temp index file when reading.

        // Note also that we allow seeks beyond the last idnex offset.
        // This is in the spirit of seeks (seeks beyond the EOF are ok).
        // It also saves us from having to grab the mutex. The ASF
        // file source (as currently implemented), will not attempt to
        // seek beyond the last index in the file.

        DWORD   dwNumToRead = cb;
        QWORD   qwIndexHeaderEnd;

        if (qwLast < m_qwCurrentPosition)
        {
            // Caller asked us to read beyond file offset of 2^64.
            dwNumToRead = (DWORD) (m_qwFileSize - m_qwCurrentPosition);
            qwLast = m_qwFileSize;
            if (dwNumToRead == 0)
            {
                // Ok to return EOF here (i.e. return dwRead = 0) because we
                // have told the caller that the file size is MAXQWORD
                hrRet = S_OK;
                __leave;
            }
        }

        hr = LockSharedMemory(bReleaseSharedMutex);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        if (m_qwCurrentPosition >= m_pShared->qwOffsetOfLastIndexInSharedMemory)
        {
            // We have read all of the index that there is to read. (The test
            // above will work even in the case we are not generating an index on the fly)
            // We will return 0 bytes (i.e., EOF) here. For the way the ASF file source
            // (see CASFv2FileSource::SearchForASFv1Indexes() in SDK\reader2\source\ASFv2FileSrc.cpp)
            // is CURRENTLY structured, this will work in the case they are trying to
            // look for the next index object. When they get back 0 bytes, they assume there
            // are no more index objects (even though we told them the file size is
            // MAXQWORD).  [Note: They will not hit this when scanning for
            // index objects - as long as we support only 1 index object - since
            // they now use IWMIStreamProps to determine the number of index objects.
            // However, if we support > 1 index object, they will hit this.
            // But they should not - see the comment in GetProperties().
            //
            // If they hit this while reading an index entry (see the function
            // CASFv2FileSource::CalculateReadOffsetASFv1 in the same file),
            // they flag the index as invalid and bail out. This is ok with us;
            // before reading the index entry, they read the index header and
            // determine the number of index entries; so they should not be trying
            // to read one that has not been written yet.

            // If their code changes, we may have to return a special status code. @@@@

            hrRet = S_OK;
            __leave;
        }

        if (qwLast > m_pShared->qwOffsetOfLastIndexInSharedMemory)
        {
            // Reduce the number of bytes to read appropriately
            dwNumToRead = (DWORD) (m_pShared->qwOffsetOfLastIndexInSharedMemory - m_qwCurrentPosition);
            qwLast = m_pShared->qwOffsetOfLastIndexInSharedMemory;
        }

        assert(m_pShared->pIndexHeader);
        assert(m_pShared->pIndexStart);
        assert(m_pShared->pIndexEnd);
        assert(m_pShared->pFirstIndex);

        qwIndexHeaderEnd = m_qwMaxHeaderAndDataSize +
                                 (m_pShared->pIndexStart - m_pShared->pIndexHeader);

        if (qwIndexHeaderEnd == m_pShared->qwOffsetOfFirstIndexInSharedMemory)
        {
            // The index's circular buffer has not wrapped around yet.
            // This has been special cased because we expect it to
            // happen frequently - for all temp ASF files in the ring buffer.

            assert(m_pShared->pFirstIndex == m_pShared->pIndexStart);

            BYTE* pHeader = (BYTE*) m_pShared + m_pShared->pIndexHeader;

            assert(pHeader + (m_qwCurrentPosition - m_qwMaxHeaderAndDataSize) + dwNumToRead <=
                   (BYTE*) m_pShared + m_pShared->pIndexEnd);

            // We expect dwRead to be 0, but just in case
            ::CopyMemory((BYTE*) pv + dwRead, pHeader + (m_qwCurrentPosition - m_qwMaxHeaderAndDataSize), dwNumToRead);
            dwRead += dwNumToRead;
            hrRet = S_OK;
            __leave;
        }
        assert(!m_pShared->dwIsTemporary);
        assert(m_hTempIndexFile);

        LPVOID pvAfterHeader = pv;
        LPVOID pvEnd = (BYTE*) pv + dwNumToRead; // for asserts only

        // Read the index header out of shared memory
        if (m_qwCurrentPosition < qwIndexHeaderEnd)
        {
            DWORD dwReadNow = dwNumToRead;

            if (dwReadNow > qwIndexHeaderEnd - m_qwCurrentPosition)
            {
                dwReadNow = (DWORD) (qwIndexHeaderEnd - m_qwCurrentPosition);
            }

            BYTE* pHeader = (BYTE*) m_pShared + m_pShared->pIndexHeader;

            // We expect dwRead to be 0, but just in case
            ::CopyMemory((BYTE*) pv + dwRead, pHeader + (m_qwCurrentPosition - m_qwMaxHeaderAndDataSize), dwReadNow);
            dwRead += dwReadNow;
            assert(dwRead <= dwNumToRead);
            if (dwRead == dwNumToRead)
            {
                hrRet = S_OK;
                __leave;
            }
            pvAfterHeader = (LPVOID) ((BYTE*)pvAfterHeader + dwRead);
        }

        // Now read from the index's circular buffer. That way, we
        // can release the shared mutex and then seek and read any
        // remaining bytes from the temp index file
        if (m_qwCurrentPosition + dwNumToRead > m_pShared->qwOffsetOfFirstIndexInSharedMemory)
        {
            DWORD dwReadNow;
            QWORD qwOffset;  // Byte we start reading relative to m_pShared->qwOffsetOfFirstIndexInSharedMemory

            if (m_qwCurrentPosition >= m_pShared->qwOffsetOfFirstIndexInSharedMemory)
            {
                dwReadNow = dwNumToRead - dwRead;
                qwOffset = m_qwCurrentPosition - m_pShared->qwOffsetOfFirstIndexInSharedMemory;
            }
            else
            {
                dwReadNow = (DWORD) (m_qwCurrentPosition + dwNumToRead - m_pShared->qwOffsetOfFirstIndexInSharedMemory) - dwRead;
                qwOffset = 0;
            }

            LPVOID pvStart = (BYTE*) pv + dwNumToRead - dwReadNow;
            DWORD dwReadThisPass = dwReadNow;
            BYTE* pvSource; // Pointer into shared memory to the byte we start copying from

            pvEnd = pvStart; // for asserts only

            if (m_pShared->pFirstIndex + qwOffset >= m_pShared->pIndexEnd)
            {
                pvSource = (BYTE*) m_pShared + m_pShared->pIndexStart + qwOffset -
                           (m_pShared->pIndexEnd - m_pShared->pFirstIndex);

                // dwReadThisPass == dwReadNow; only 1 copy in this case
                assert(pvSource + dwReadThisPass <= (BYTE*) m_pShared + m_pShared->pFirstIndex);
            }
            else
            {
                pvSource = (BYTE*) m_pShared + m_pShared->pFirstIndex + qwOffset;
                if (m_pShared->pFirstIndex + qwOffset + dwReadThisPass > m_pShared->pIndexEnd)
                {
                    // Requires 2 calls to ::CopyMemory
                    dwReadThisPass = (DWORD) (m_pShared->pIndexEnd - (m_pShared->pFirstIndex + qwOffset));
                }
            }

            ::CopyMemory(pvStart, pvSource, dwReadThisPass);

            if (dwReadThisPass != dwReadNow)
            {
                assert(dwReadNow > dwReadThisPass);

                pvSource = (BYTE*) m_pShared + m_pShared->pIndexStart;
                DWORD dwReadPass2 = dwReadNow - dwReadThisPass;
                assert(pvSource + dwReadPass2 <= (BYTE*) m_pShared + m_pShared->pFirstIndex);

                ::CopyMemory((BYTE*) pvStart + dwReadThisPass, pvSource, dwReadNow - dwReadThisPass);
            }

            dwRead += dwReadNow;
            if (dwRead == dwNumToRead)
            {
                hrRet = S_OK;
                __leave;
            }
        }

        if (bReleaseSharedMutex)
        {
            ::ReleaseMutex(m_hMutex);
            bReleaseSharedMutex = 0;
        }

        // Got to read from the temp index file. Note that we do not have to hold
        // the shared memory lock when reading from this file because the file
        // is always growing. The only caveat is that we always seek relative to
        // the start of the file.

        // Since this is the last read and the other reads have nto failed
        dwNumToRead -= dwRead;

        assert((BYTE*) pvAfterHeader + dwNumToRead == pvEnd);

        // Seek to the correct position in the temp index file.
        QWORD qwSeekPosition = m_qwCurrentPosition - m_qwMaxHeaderAndDataSize;

        // Following assert justifies a single call to SeekFilePointerEx;
        // if we were seeking to a position > MAXLONGLONG, we would need
        // 2 or 3 calls. It suffices to have MAXLONGLONG (instead of MAXDWORD)
        // in the assert, but we know that there is a max of 4GB for the index
        assert(qwSeekPosition <= MAXDWORD);

        LARGE_INTEGER   llSeekPosition;
        llSeekPosition.QuadPart = (LONGLONG) qwSeekPosition;

        if (0 == ::SetFilePointerEx(m_hTempIndexFile, llSeekPosition, FILE_BEGIN, NULL))
        {
            dwLastError = ::GetLastError();
            assert(0);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        DWORD dwReadFromIndexFile;

        if (0 == ::ReadFile(m_hTempIndexFile, pvAfterHeader, dwNumToRead, &dwReadFromIndexFile, NULL))
        {
            dwLastError = ::GetLastError();
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            assert(0);
            __leave;
        }
        if (dwReadFromIndexFile < dwNumToRead)
        {
            // This is plainly an internal error. We should not redirect
            // reads to the temp index file unless it had the bytes we needed.

            assert(0);
            hrRet = E_FAIL;
            __leave;
        }

        dwRead += dwReadFromIndexFile;

        hrRet = S_OK;
    }
    __finally
    {
        if (SUCCEEDED(hrRet) ||
            hrRet == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF))
        {
            assert(dwRead <= cb);
            m_qwCurrentPosition += dwRead;
            if (pcbRead)
            {
                *pcbRead = dwRead;
            }
        }
        else
        {
            // Don't know if doing this is right or not per
            // IStream::Read spec
            if (pcbRead)
            {
                *pcbRead = 0;
            }
        }
        if (bReleaseSharedMutex)
        {
            ::ReleaseMutex(m_hMutex);
        }
        ::LeaveCriticalSection(&m_cs);
    }

    return hrRet;

} // CDVRSource::Read

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSource::Write(void const *pv, ULONG cb, ULONG *pcbWritten)
{
    return E_UNEXPECTED;
} // CDVRSource::Write

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSource::SetSize(ULARGE_INTEGER libNewSize)
{
    return E_UNEXPECTED;
} // CDVRSource::SetSize

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSource::CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    return E_NOTIMPL;
} // CDVRSource::CopyTo

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSource::Commit(DWORD grfCommitFlags)
{
    return E_UNEXPECTED;
} // CDVRSource::Commit

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSource::Revert()
{
    return E_UNEXPECTED;
} // CDVRSource::Revert

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSource::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
} // CDVRSource::LockRegion

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSource::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
} // CDVRSource::UnlockRegion

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSource::Clone(IStream **ppstm)
{
    return E_NOTIMPL;
} // CDVRSource::Clone

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSource::GetProperty(LPCWSTR pszName,           // in
                                     WMT_ATTR_DATATYPE *pType,  // out
                                     BYTE *pValue,              // out
                                     DWORD *pdwSize             // in out
                                    )
{
    if (!pdwSize || !pValue || !pType)
    {
        return E_POINTER;
    }
    if (pszName == g_wszReloadIndexOnSeek ||
        wcscmp(pszName, g_wszReloadIndexOnSeek) == 0)
    {
        if (*pdwSize < sizeof(BOOL))
        {
            return E_INVALIDARG;
        }
        // Return 0 for non-live files so that the index is not
        // rescanned on every seek
        *((BOOL *) pValue) = m_bFileIsLive? 1 : 0;
        *pType = WMT_TYPE_BOOL;
        *pdwSize = sizeof(BOOL);
        return S_OK;
    }

    if (pszName == g_wszStreamNumIndexObjects ||
        wcscmp(pszName, g_wszStreamNumIndexObjects) == 0)
    {
        // Note: CASFv2FileSource::SearchForASFv1Indexes() in
        // sdk\reader2\sources\ASFv2FileSrc.cpp has a bug if
        // we support >1 index. They use the index size to determine
        // the # of index entries (ok) and to advance the file pointer
        // where they expect the next index header. We won't have the
        // next index header there.

        if (*pdwSize < sizeof(DWORD))
        {
            return E_INVALIDARG;
        }
        *((DWORD *) pValue) = 1;
        *pType = WMT_TYPE_DWORD;
        *pdwSize = sizeof(DWORD);
        return S_OK;
    }

    if (pszName == g_wszSourceBufferTime ||
        wcscmp(pszName, g_wszSourceBufferTime) == 0)
    {
        if (*pdwSize < sizeof(DWORD))
        {
            return E_INVALIDARG;
        }
        DWORD dwReadAhead = GetRegDWORD(m_hDvrIoKey,
                                        kwszRegReadAheadBufferTimeValue,
                                        kdwRegReadAheadBufferTimeDefault);

        *((DWORD *) pValue) = dwReadAhead > 2? dwReadAhead: 2;

        *pType = WMT_TYPE_DWORD;
        *pdwSize = sizeof(DWORD);
        return S_OK;
    }

    if (pszName == g_wszSourceMaxBytesAtOnce ||
        wcscmp(pszName, g_wszSourceMaxBytesAtOnce) == 0)
    {
        if (*pdwSize < sizeof(DWORD))
        {
            return E_INVALIDARG;
        }
        *((DWORD *) pValue) = GetRegDWORD(m_hDvrIoKey,
                                          kwszRegMaxBytesAtOnceValue,
                                          kdwRegMaxBytesAtOnceDefault);
        *pType = WMT_TYPE_DWORD;
        *pdwSize = sizeof(DWORD);
        return S_OK;
    }

    if (pszName == g_wszFailSeekOnError ||
        wcscmp(pszName, g_wszFailSeekOnError) == 0)
    {
        if (*pdwSize < sizeof(BOOL))
        {
            return E_INVALIDARG;
        }
        *((BOOL *) pValue) = 1;
        *pType = WMT_TYPE_BOOL;
        *pdwSize = sizeof(BOOL);
        return S_OK;
    }

    if (pszName == g_wszPermitSeeksBeyondEndOfStream ||
        wcscmp(pszName, g_wszPermitSeeksBeyondEndOfStream) == 0)
    {
        if (*pdwSize < sizeof(BOOL))
        {
            return E_INVALIDARG;
        }
        *((BOOL *) pValue) = 1;
        *pType = WMT_TYPE_BOOL;
        *pdwSize = sizeof(BOOL);
        return S_OK;
    }

    if (pszName == g_wszUsePacketAtSeekPoint ||
        wcscmp(pszName, g_wszUsePacketAtSeekPoint) == 0)
    {
        if (*pdwSize < sizeof(BOOL))
        {
            return E_INVALIDARG;
        }

#if defined(DVR_UNOFFICIAL_BUILD)

        *((BOOL *) pValue) = GetRegDWORD(m_hDvrIoKey,
                                         kwszRegUsePacketAtSeekPointValue,
                                         kdwRegUsePacketAtSeekPointDefault)? 1 : 0;
#else

        *((BOOL *) pValue) = 1;

#endif // if defined(DVR_UNOFFICIAL_BUILD)

        *pType = WMT_TYPE_BOOL;
        *pdwSize = sizeof(BOOL);
        return S_OK;
    }

    return E_FAIL;
} // CDVRSource::GetProperty
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\wmsdk\zeusette\sdk\writer\sink\dvrsink\dvrsink.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       DVRSink.cpp
//
//  Classes:    CDVRSink
//
//  Contents:   Implementation of the CDVRSink class
//
//--------------------------------------------------------------------------

#include "stdinc.h"
#include "DVRSink.h"
#include "wmsdkbuffer.h"
#include "debughlp.h"
#include "nserror.h"
#include "asfx.h"
#include "nsalign.h"
#include "wmreghelp.h"
#include "wraparound.h"
#include "malloc.h"

#include "findleak.h"
DECLARE_THIS_FILE;


void FreeSecurityDescriptors(IN OUT PACL&  rpACL,
                             IN OUT PSECURITY_DESCRIPTOR& rpSD
                            )
{
    if (rpACL)
    {
        LocalFree(rpACL);
        rpACL = NULL;
    }
    if (rpSD)
    {
        LocalFree(rpSD);
        rpSD = NULL;
    }
} // FreeSecurityDescriptors

// ppSid[0] is assumed to be that of CREATOR_OWNER and is set/granted/denied 
// (depending on what ownerAccessMode is) ownerAccessPermissions. The other
// otherAccessMode and otherAccessPermissions are used with the other SIDs
// in ppSids.
// We assume that object handle cannot be inherited.
DWORD CreateACL(IN  DWORD dwNumSids, 
                IN  PSID* ppSids,
                IN  ACCESS_MODE ownerAccessMode, 
                IN  DWORD ownerAccessPermissions,
                IN  ACCESS_MODE otherAccessMode, 
                IN  DWORD otherAccessPermissions,
                OUT PACL&  rpACL,
                OUT PSECURITY_DESCRIPTOR& rpSD
               )
{
    if (dwNumSids == 0 || !ppSids)
    {
        return ERROR_INVALID_PARAMETER;
    }

    EXPLICIT_ACCESS* ea = NULL;

    DWORD dwLastError;

    rpACL = NULL;
    rpSD = NULL;

    __try
    {
        ea = new EXPLICIT_ACCESS[dwNumSids];        
        
        if (ea == NULL)
        {
            dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }


        // Initialize an EXPLICIT_ACCESS structure for ACEs.

        ZeroMemory(ea, dwNumSids * sizeof(EXPLICIT_ACCESS));

        ea[0].grfAccessPermissions = ownerAccessPermissions;
        ea[0].grfAccessMode = ownerAccessMode;
        ea[0].grfInheritance= NO_INHERITANCE;
        ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
        ea[0].Trustee.ptstrName  = (LPTSTR) ppSids[0];

        for (DWORD i = 1; i < dwNumSids; i++)
        {
            ea[i].grfAccessPermissions = otherAccessPermissions;
            ea[i].grfAccessMode = otherAccessMode;
            ea[i].grfInheritance= NO_INHERITANCE;
            ea[i].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ea[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
            ea[i].Trustee.ptstrName  = (LPTSTR) ppSids[i];
        }

        // Create a new ACL that contains the new ACEs.

        DWORD dwRet = ::SetEntriesInAcl(dwNumSids, ea, NULL, &rpACL);
        if (ERROR_SUCCESS != dwRet)
        {
            dwLastError = dwRet;
            __leave;
        }

        // Initialize a security descriptor.  

        rpSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, 
                                                 SECURITY_DESCRIPTOR_MIN_LENGTH); 
        if (rpSD == NULL)
        {
            dwLastError = GetLastError();
            __leave;
        }

        if (!::InitializeSecurityDescriptor(rpSD, SECURITY_DESCRIPTOR_REVISION))
        {
            dwLastError = GetLastError();
            __leave;
        }

        // Add the ACL to the security descriptor. 

        if (!::SetSecurityDescriptorDacl(rpSD, 
                                         TRUE,     // fDaclPresent flag   
                                         rpACL, 
                                         FALSE))   // not a default DACL 
        {
            dwLastError = GetLastError();
            __leave;
        }
        dwLastError = ERROR_SUCCESS;
    }
    __finally
    {
        delete [] ea;
        if (dwLastError != ERROR_SUCCESS)
        {
            ::FreeSecurityDescriptors(rpACL, rpSD);
        }
    }

    return dwLastError;

} // CreateACL

HRESULT STDMETHODCALLTYPE DVRCreateDVRFileSink(HKEY hDvrKey,
                                               HKEY hDvrIoKey,
                                               DWORD dwNumSids,
                                               PSID* ppSids,
                                               IDVRFileSink** ppDVRFileSink)
{
    HRESULT hr;

    if (!ppDVRFileSink)
    {
        return E_POINTER;
    }

    *ppDVRFileSink = NULL;

    CDVRSink* p = new CDVRSink(hDvrKey, hDvrIoKey, dwNumSids, ppSids, &hr, NULL);

    if (p == NULL)
    {
        assert(p);
        return E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        hr = p->QueryInterface(IID_IDVRFileSink, (void**) ppDVRFileSink);
        if (FAILED(hr))
        {
            assert(0);
        }
        else
        {
            // File sink constructs the object with a ref count of 1
            p->Release();
        }
    }

    if (FAILED(hr))
    {
        // delete p;
        // File sink constructs the object with a ref count of 1
        p->Release();
        *ppDVRFileSink = NULL;
    }

    return hr;

} // DVRCreateDVRFileSink

////////////////////////////////////////////////////////////////////////////

#if defined(DVR_UNOFFICIAL_BUILD)

static const WCHAR* kwszRegCopyBuffersInASFMuxValue = L"CopyBuffersInASFMux";
const DWORD kdwRegCopyBuffersInASFMuxDefault = 0;

static const WCHAR* kwszRegTruncateExistingFilesValue = L"TruncateExistingFiles";
const DWORD kdwRegTruncateExistingFilesDefault = 1;

static const WCHAR* kwszRegFileExtendThresholdValue = L"FileExtendThreshold";
const DWORD kdwRegFileExtendThresholdDefault = 0;  // 0 turns it off.
                                                   // Tried it with 16 * 4096, perf degrades because
                                                   // bytes have to be read back before a write when
                                                   // the file is extended.
#endif // if defined(DVR_UNOFFICIAL_BUILD)

DWORD GetRegDWORD(HKEY hKey, IN LPCWSTR pwszValueName, IN DWORD dwDefaultValue)
{
    if (!pwszValueName)
    {
        return dwDefaultValue;
    }

    DWORD dwRet = dwDefaultValue;
    DWORD dwRegRet;

    __try
    {
        DWORD dwType;
        DWORD dwSize;
        DWORD dwValue;

        dwSize = sizeof(DWORD);

        dwRegRet = ::RegQueryValueExW(
                        hKey,
                        pwszValueName,       // value's name
                        0,                   // reserved
                        &dwType,             // type
                        (LPBYTE) &dwValue,   // data
                        &dwSize              // size in bytes
                       );
        if (dwRegRet != ERROR_SUCCESS && dwRegRet != ERROR_FILE_NOT_FOUND)
        {
            __leave;
        }
        if (dwRegRet == ERROR_FILE_NOT_FOUND)
        {
            dwRegRet = ::RegSetValueExW(hKey,
                                        pwszValueName,      // value name
                                        NULL,               // reserved
                                        REG_DWORD,          // type of value
                                        (LPBYTE) &dwRet,    // Value
                                        sizeof(DWORD)       // sizeof dwVal
                                       );
            if (dwRegRet != ERROR_SUCCESS)
            {
                assert(dwRegRet == ERROR_SUCCESS);
            }
            __leave;
        }
        if (dwType != REG_DWORD)
        {
            assert(dwType == REG_DWORD);
            __leave;
        }

        dwRet = dwValue;
        __leave;
    }
    __finally
    {
    }

    return dwRet;

} // GetRegDWORD

#if defined(DVR_UNOFFICIAL_BUILD)

////////////////////////////////////////////////////////////////////////////
DWORD AcquirePrivilege(LPCWSTR           pwszPrivilege,             // IN
                       HANDLE*           phToken,                   // OPTIONAL, used if supplied, else
                                                                    // token is opened. Handle should be closed if
                                                                    // function returns ERROR_SUCCESS
                       PTOKEN_PRIVILEGES *ppPreviousPrivilege,      // OPTIONAL. If function returns ERROR_SUCCESS,
                                                                    // restore these privileges and delete *ppPreviousPrivilege
                                                                    // If function fails, old privileges are restored
                                                                    // before returning and *ppPreviousPrivilege is set to NULL
                       DWORD*            pdwPreviousPrivilegeSize)
{
    if (!phToken)
    {
        return ERROR_INVALID_PARAMETER;
    }

    TOKEN_PRIVILEGES tp;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD            cbPrevious = sizeof(tpPrevious);
    LUID             luid;
    HANDLE           hToken;
    DWORD            dwLastError;
    BOOL             bRestore = 0;

    __try
    {
        if (*phToken != NULL)
        {
            hToken = *phToken;
        }
        else
        {
            if (!::OpenThreadToken(GetCurrentThread(),
                                   TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                   FALSE,
                                   &hToken))
            {
                dwLastError = ::GetLastError(); // For debugging only

                if (!::OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
                {
                    dwLastError = ::GetLastError();
                    __leave;
                }
            }

        }
        if (!::LookupPrivilegeValueW(NULL, pwszPrivilege, &luid))
        {
            dwLastError = ::GetLastError();
	    __leave;
        }

        tp.PrivilegeCount = 1;
        tp.Privileges[0].Luid = luid;
        tp.Privileges[0].Attributes = 0;

        if (!::AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp), &tpPrevious, &cbPrevious) ||
            (dwLastError = ::GetLastError()) != ERROR_SUCCESS)
        {
            __leave;
        }

        tp.PrivilegeCount = 1;
        tp.Privileges[0].Luid = luid;
        if (tpPrevious.PrivilegeCount == 0 ||
            tpPrevious.Privileges[0].Luid.LowPart != luid.LowPart ||
            tpPrevious.Privileges[0].Luid.HighPart != luid.HighPart)
        {
            tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
            tpPrevious.PrivilegeCount = 1;
            tpPrevious.Privileges[0].Luid = luid;
            tpPrevious.Privileges[0].Attributes  = 0;
            bRestore = 1;
        }
        else
        {
            tp.Privileges[0].Attributes = tpPrevious.Privileges[0].Attributes | SE_PRIVILEGE_ENABLED;
            if (tp.Privileges[0].Attributes != tpPrevious.Privileges[0].Attributes)
            {
                bRestore = 1;
            }
        }

        if (!::AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp), NULL, NULL) ||
            (dwLastError = ::GetLastError()) != ERROR_SUCCESS)
        {
            __leave;
        }

        dwLastError = ERROR_SUCCESS;
    }
    __finally
    {
        if (ppPreviousPrivilege)
        {
            *ppPreviousPrivilege = NULL;
        }
        if (pdwPreviousPrivilegeSize)
        {
            *pdwPreviousPrivilegeSize = 0;
        }
        if (bRestore)
        {
            if (dwLastError != ERROR_SUCCESS)
            {
                DWORD dwLastErr;

                if (!::AdjustTokenPrivileges(hToken, FALSE, &tpPrevious, sizeof(tpPrevious), NULL, NULL) ||
                    (dwLastErr = ::GetLastError()) != ERROR_SUCCESS)
                {
                    // We've messed up; we are leaving the privilege attributes at 0
                    assert(!"AcquirePrivilege(): leaving privilege attributes at 0");
                }
            }
            else
            {
                if (ppPreviousPrivilege)
                {
                    *ppPreviousPrivilege = (PTOKEN_PRIVILEGES) new TOKEN_PRIVILEGES;
                    if (*ppPreviousPrivilege != NULL)
                    {
                        **ppPreviousPrivilege = tpPrevious;
                        *pdwPreviousPrivilegeSize = sizeof(TOKEN_PRIVILEGES);
                    }
                    else
                    {
                        assert(!"new() failed");
                    }
                }
                else
                {
                    // Privileges should be restored if bRestore is non-zero.
                    assert(bRestore == 0);
                }
            }
        }
        if (*phToken == NULL)
        {
            if (dwLastError == ERROR_SUCCESS)
            {
                *phToken = hToken;
            }
            else if (hToken)
            {
                ::CloseHandle(hToken);
            }
        }
    }

    return dwLastError;

} // AcquirePrivilege

////////////////////////////////////////////////////////////////////////////
DWORD RestorePrivileges(HANDLE            hToken,
                        DWORD             cbPrivilege,
                        PTOKEN_PRIVILEGES pPrivilege)
{
    DWORD dwLastError = ERROR_SUCCESS;

    __try
    {
        if (!pPrivilege)
        {
            assert(cbPrivilege == 0);
            __leave;
        }
        else
        {
            assert(cbPrivilege != 0);
        }
        if (!::AdjustTokenPrivileges(hToken, FALSE, pPrivilege, cbPrivilege, NULL, NULL) ||
            (dwLastError = ::GetLastError()) != ERROR_SUCCESS)
        {
            // We've messed up; we are leaving the privilege attributes at 0
            assert(!"RestorePrivileges(): leaving privilege attributes at 0");
        }
    }
    __finally
    {
        if (hToken)
        {
            ::CloseHandle(hToken);
        }
        delete pPrivilege;
    }

    return dwLastError;

} // RestorePrivileges

#endif // if defined(DVR_UNOFFICIAL_BUILD)

////////////////////////////////////////////////////////////////////////////
// Static member initialization
const WORD CDVRSink::INVALID_KEY_SPAN = 0xFFFF;

////////////////////////////////////////////////////////////////////////////
CDVRSink::CDVRSink(HKEY hDvrKey,
                   HKEY hDvrIoKey,
                   DWORD dwNumSids,
                   PSID* ppSids,
                   HRESULT *phr,
                   CTPtrArray<WRITER_SINK_CALLBACK> *pCallbacks)
    : CWMFileSinkV1(phr, pCallbacks)
    , m_hDvrKey(hDvrKey)
    , m_hDvrIoKey(hDvrIoKey)
    , m_dwNumSids(dwNumSids)
    , m_ppSids(ppSids)
    , m_pShared(NULL)
    , m_hMutex(NULL)
    , m_hMemoryMappedFile(NULL)
    , m_hFileMapping(NULL)
    , m_hTempIndexFile(NULL)
    , m_dwNumPages(1)               // default number of pages is 1
    , m_dwIndexStreamId(MAXDWORD)
    , m_cnsIndexGranularity(0)
    , m_bTemporary(0)
    , m_dwOpened(DVR_SINK_CLOSED)
    , m_bUnmapView(0)
    , m_bIndexing(0)
    , m_Index(phr)
    , m_bOpenedOnce(0)
    , m_cnsLastIndexedTime(0)
    , m_qwLastKeyTime(0)
    , m_dwLastKey(~0)   // Could as well be 0, not used till it is initialized in PacketContainsKeyStart
    , m_dwLastKeyStart(0)
    , m_dwCurrentObjectID(0)
    , m_dwNumPackets(0)
    , m_bInsideKeyFrame(FALSE)
    , m_wLastKeySpan(INVALID_KEY_SPAN)
    , m_pIDVRAsyncWriter (NULL)

#if defined(DVR_UNOFFICIAL_BUILD)

    , m_dwCopyBuffersInASFMux(kdwRegCopyBuffersInASFMuxDefault)
    , m_cbEOF(0)
    , m_cbFileExtendThreshold(kdwRegFileExtendThresholdDefault)

#endif // if defined(DVR_UNOFFICIAL_BUILD)

{
    // Initialize even if FAILED(*phr) (i.e., base class failed intiialization)

    // Override base class' indexing
    m_fAutoIndex = FALSE;

    ::ZeroMemory(&m_mmsID, sizeof(m_mmsID));
    ::ZeroMemory (& m_guidWriterId, sizeof m_guidWriterId) ;
    ::ZeroMemory(&m_hReaderEvent, sizeof(m_hReaderEvent));
    ::ZeroMemory(&m_bReaderEventOpenFailed, sizeof(m_bReaderEventOpenFailed));

    if (m_bTemporary)
    {
        m_dwFileAttributes = FILE_ATTRIBUTE_HIDDEN |
                             FILE_ATTRIBUTE_SYSTEM  |
                             FILE_ATTRIBUTE_NOT_CONTENT_INDEXED |
                             FILE_FLAG_WRITE_THROUGH |
                             0; // We now delete files manually, so don't use: FILE_FLAG_DELETE_ON_CLOSE;

        // Leave this share flag even though DELETE_ON_CLOSE is not used.
        // This allows the writer to delete temp files that haven fallen
        // out of the ring buffer even though a reader has it open.
        // Subsequent attempts to open the file (after it has been deleted
        // even if the open specifies FILE_SHARE_DELETE) will fail; we're
        // also going to be sharing this file for writing between the writer
        // and the baseclasses
        m_dwFileShareFlags |= FILE_SHARE_DELETE |
                               FILE_SHARE_WRITE |
                               FILE_SHARE_READ ;
    }
    else
    {
        //m_dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
        m_dwFileAttributes = FILE_FLAG_WRITE_THROUGH ;

        //  turn off
        m_dwFileShareFlags &= ~FILE_SHARE_DELETE;

        //  turn on
        m_dwFileShareFlags |= (FILE_SHARE_WRITE | FILE_SHARE_READ) ;
    }

#if defined(DVR_UNOFFICIAL_BUILD)

    if (GetRegDWORD(m_hDvrIoKey, kwszRegTruncateExistingFilesValue, kdwRegTruncateExistingFilesDefault))
    {
        m_dwFileCreationDisposition = CREATE_ALWAYS;

        m_cbFileExtendThreshold = GetRegDWORD(m_hDvrIoKey, kwszRegFileExtendThresholdValue, kdwRegFileExtendThresholdDefault);
    }
    else
    {
        // Open preallocated files if they exist

        // Perf is poor presumably because the existing data in the
        // file has to be read in before it is written out. This
        // setting may be helpful if (a) we write entire pages at a
        // time (using buffered i/o) or (b) use unbuffered i/o.
        // [(a) may not be helped because the NTFS cache manager
        // may still pre-read data, particularly, if the file has
        // also been opened for writing. For (b), SetFileValidData
        // could be used to improve perf without preallocating the file.]

        m_dwFileCreationDisposition = OPEN_ALWAYS;
    }

#else

    // This is the setting in the parent class, but just to be safe
    m_dwFileCreationDisposition = CREATE_ALWAYS;

#endif // if defined(DVR_UNOFFICIAL_BUILD)

    SYSTEM_INFO s;

    GetSystemInfo(&s);

    m_dwPageSize = s.dwPageSize;

    DWORD   dwMaxIndexEntries;
    while (FAILED(GetMaxIndexEntries(m_dwNumPages, &dwMaxIndexEntries)))
    {
        assert(dwMaxIndexEntries > 0);
        m_dwNumPages++;
        if (m_dwNumPages > 10)
        {
            assert(0);
            if (phr && SUCCEEDED(*phr))
            {
                *phr = E_FAIL;
            }
            return;
        }
    }

} // CDVRSink::CDVRSink


////////////////////////////////////////////////////////////////////////////
CDVRSink::~CDVRSink()
{
    if (m_pIDVRAsyncWriter) {
        m_pIDVRAsyncWriter -> Release () ;
    }

} // CDVRSink::~CDVRSink


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSink::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;

    //
    // Validate input parameter
    //
    assert(ppv);

    if (!ppv)
    {
        hr = E_POINTER;
    }
    else if (IsEqualGUID(IID_IDVRFileSink, riid))
    {
        *ppv = (IDVRFileSink*) this;
        ((IUnknown *) *ppv)->AddRef();

        hr = S_OK;
    }
    else if (IsEqualGUID (IID_IDVRFileSink2, riid))
    {
        *ppv = (IDVRFileSink2*) this;
        ((IUnknown *) *ppv)->AddRef();

        hr = S_OK;
    }
    else
    {
        hr = CWMFileSinkV1::QueryInterface(riid, ppv);
    }

    return hr;

} // CDVRSink::QueryInterface

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CDVRSink::AddRef()
{

    return CWMFileSinkV1::AddRef();

} // CDVRSink::AddRef


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CDVRSink::Release()
{

    return CWMFileSinkV1::Release();

} // CDVRSink::Release

//  sets an async IO writer; callee should ref the interface
STDMETHODIMP
CDVRSink::SetAsyncIOWriter (
    IN  IDVRAsyncWriter *   pIDVRAsyncWriter
    )
{
    HRESULT         hr ;
    AutoLock<Mutex> lock(m_GenericMutex);

    if (!m_pIDVRAsyncWriter) {
        m_pIDVRAsyncWriter = pIDVRAsyncWriter ;
        m_pIDVRAsyncWriter -> AddRef () ;

        hr = S_OK ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSink::MarkFileTemporary(BOOL bTemporary)
{
    AutoLock<Mutex> lock(m_GenericMutex);

    if (m_dwOpened != DVR_SINK_CLOSED)
    {
        return E_UNEXPECTED;
    }

    m_bTemporary = bTemporary;

    if (m_bTemporary)
    {
        m_dwFileAttributes = FILE_ATTRIBUTE_HIDDEN |
                             FILE_ATTRIBUTE_SYSTEM  |
                             FILE_ATTRIBUTE_NOT_CONTENT_INDEXED |
                             FILE_FLAG_WRITE_THROUGH |
                             0; // We now delete files manually, so don't use: FILE_FLAG_DELETE_ON_CLOSE;

        // Leave this share flag even though DELETE_ON_CLOSE is not used.
        // This allows the writer to delete temp files that haven fallen
        // out of the ring buffer even though a reader has it open.
        // Subsequent attempts to open the file (after it has been deleted
        // even if the open specifies FILE_SHARE_DELETE) will fail; we're
        // also going to be sharing this file for writing between the writer
        // and the base classes
        m_dwFileShareFlags |= FILE_SHARE_DELETE |
                               FILE_SHARE_WRITE |
                               FILE_SHARE_READ ;
    }
    else
    {
        //m_dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
        m_dwFileAttributes = FILE_FLAG_WRITE_THROUGH ;

        //  turn off
        m_dwFileShareFlags &= ~FILE_SHARE_DELETE;

        //  turn on
        m_dwFileShareFlags |= (FILE_SHARE_WRITE | FILE_SHARE_READ) ;
    }

#if defined(DVR_UNOFFICIAL_BUILD)

    m_dwCopyBuffersInASFMux = GetRegDWORD(m_hDvrIoKey,
                                          kwszRegCopyBuffersInASFMuxValue,
                                          kdwRegCopyBuffersInASFMuxDefault);

    if (GetRegDWORD(m_hDvrIoKey, kwszRegTruncateExistingFilesValue, kdwRegTruncateExistingFilesDefault))
    {
        m_dwFileCreationDisposition = CREATE_ALWAYS;

        m_cbFileExtendThreshold = GetRegDWORD(m_hDvrIoKey,
                                              kwszRegFileExtendThresholdValue,
                                              kdwRegFileExtendThresholdDefault);
    }
    else
    {
        // Open preallocated files if they exist

        // Perf is poor presumably because the existing data in the
        // file has to be read in before it is written out. This
        // setting may be helpful if (a) we write entire pages at a
        // time (using buffered i/o) or (b) use unbuffered i/o.
        // [(a) may not be helped because the NTFS cache manager
        // may still pre-read data, particularly, if the file has
        // also been opened for writing. For (b), SetFileValidData
        // could be used to improve perf without preallocating the file.]

        m_dwFileCreationDisposition =  OPEN_ALWAYS;
    }

#endif // if defined(DVR_UNOFFICIAL_BUILD)

    return S_OK;

} // CDVRSink::MarkFileTemporary

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSink::SetIndexStreamId(DWORD  dwIndexStreamId,
                                        DWORD  msIndexGranularity)
{
    AutoLock<Mutex> lock(m_GenericMutex);

    if (m_bOpenedOnce)
    {
        return E_UNEXPECTED;
    }
    if (dwIndexStreamId != MAXDWORD && msIndexGranularity == 0)
    {
        return E_INVALIDARG;
    }

    m_dwIndexStreamId = dwIndexStreamId;
    m_cnsIndexGranularity = (QWORD) msIndexGranularity * 10000;

    return S_OK;

} // CDVRSink::SetIndexStreamId

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSink::GetIndexStreamId(DWORD*  pdwIndexStreamId)
{
    if (!pdwIndexStreamId)
    {
        assert(0);
        return E_POINTER;
    }

    AutoLock<Mutex> lock(m_GenericMutex);

    *pdwIndexStreamId = m_dwIndexStreamId;

    return S_OK;

} // CDVRSink::GetIndexStreamId

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSink::SetNumSharedDataPages(DWORD dwNumPages)
{
    AutoLock<Mutex> lock(m_GenericMutex);

    if (m_dwOpened != DVR_SINK_CLOSED)
    {
        return E_UNEXPECTED;
    }

    // Validate the argument

    DWORD   dwMaxIndexEntries;
    HRESULT hr = GetMaxIndexEntries(dwNumPages, &dwMaxIndexEntries);

    if (FAILED(hr))
    {
        return hr;
    }
    assert(dwMaxIndexEntries > 0);

    m_dwNumPages = dwNumPages;

    return S_OK;

} // CDVRSink::SetNumSharedDataPages

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSink::GetMaxIndexEntries(DWORD  dwNumPages, DWORD* pdwNumIndexEntries)
{
    if (pdwNumIndexEntries == NULL)
    {
        assert(0);
        return E_POINTER;
    }

    // No need to lock, we use only m_dwPageSize, which is set
    // in constructor and never changed after that
    // AutoLock<Mutex> lock(m_GenericMutex);

    DWORD           dwIndexSpace = m_Index.EmptyIndexSpace(); // Space for an empty index
    QWORD           qwNumBytes = dwNumPages * m_dwPageSize;

    if (qwNumBytes > MAXDWORD)
    {
        *pdwNumIndexEntries = 0;
        return E_INVALIDARG;
    }

    if (qwNumBytes <  dwIndexSpace + sizeof(CDVRSharedMemory) + m_Index.IndexEntrySize())
    {
        *pdwNumIndexEntries = 0;
        return E_INVALIDARG;
    }
    qwNumBytes -= (dwIndexSpace + sizeof(CDVRSharedMemory));
    *pdwNumIndexEntries = ((DWORD) qwNumBytes) / m_Index.IndexEntrySize();

    return S_OK;

} // CDVRSink::GetMaxIndexEntries

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSink::GetNumPages(DWORD  dwNumIndexEntries, DWORD* pdwNumPages)
{
    if (pdwNumPages == NULL)
    {
        assert(0);
        return E_POINTER;
    }

    // No need to lock, we use only m_dwPageSize, which is set
    // in constructor and never changed after that
    // AutoLock<Mutex> lock(m_GenericMutex);

    DWORD           dwIndexSpace = m_Index.EmptyIndexSpace(); // Space for an empty index
    DWORD           dwNumBytes;

    dwNumBytes =  dwIndexSpace + sizeof(CDVRSharedMemory);
    dwNumBytes += (dwNumIndexEntries * m_Index.IndexEntrySize());
    *pdwNumPages = (dwNumBytes / m_dwPageSize) + (dwNumBytes % m_dwPageSize? 1 : 0);

    return S_OK;

} // CDVRSink::GetNumPages

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSink::GetMappingHandles(HANDLE* phDataFile,
                                         HANDLE* phMemoryMappedFile,
                                         HANDLE* phFileMapping,
                                         LPVOID* phMappedView,
                                         HANDLE* phTempIndexFile)
{
    if (phDataFile)
    {
        *phDataFile = NULL;
    }
    if (phMemoryMappedFile)
    {
        *phMemoryMappedFile = NULL;
    }
    if (phFileMapping)
    {
        *phFileMapping = NULL;
    }
    if (phMappedView)
    {
        *phMappedView = NULL;
    }
    if (phTempIndexFile)
    {
        *phTempIndexFile = NULL;
    }

    m_GenericMutex.Lock();

    if (m_dwOpened != DVR_SINK_OPENED)
    {
        m_GenericMutex.Unlock();
        return E_UNEXPECTED;
    }
    if (!m_bIndexing)
    {
        // Our client is not likely to be not indexing.
        // However, there is no reason to not dup the
        // handles. The reader can still share the
        // file size and sync with the writer, etc.

        // return S_FALSE;
    }

    HRESULT     hr;
    DWORD       dwLastError;

    __try
    {
        assert(m_hRecordFile);
        if (phDataFile)
        {
            if (0 == ::DuplicateHandle(::GetCurrentProcess(), m_hRecordFile,
                                       ::GetCurrentProcess(), phDataFile,
                                       0,       // desired access - ignored
                                       FALSE,   // bInherit
                                       DUPLICATE_SAME_ACCESS))
            {
                dwLastError = ::GetLastError();
                hr = HRESULT_FROM_WIN32(dwLastError);
                assert(0);
                __leave;
            }
        }

        assert(m_hMemoryMappedFile);
        if (phMemoryMappedFile)
        {
            if (0 == ::DuplicateHandle(::GetCurrentProcess(), m_hMemoryMappedFile,
                                       ::GetCurrentProcess(), phMemoryMappedFile,
                                       0,       // desired access - ignored
                                       FALSE,   // bInherit
                                       DUPLICATE_SAME_ACCESS))
            {
                dwLastError = ::GetLastError();
                hr = HRESULT_FROM_WIN32(dwLastError);
                assert(0);
                __leave;
            }
        }

        assert(m_hFileMapping);
        if (phFileMapping)
        {
            if (0 == ::DuplicateHandle(::GetCurrentProcess(), m_hFileMapping,
                                       ::GetCurrentProcess(), phFileMapping,
                                       0,       // desired access - ignored
                                       FALSE,   // bInherit
                                       DUPLICATE_SAME_ACCESS))
            {
                dwLastError = ::GetLastError();
                hr = HRESULT_FROM_WIN32(dwLastError);
                assert(0);
                __leave;
            }
        }

        assert(m_pShared);
        if (phMappedView)
        {
            *phMappedView = (LPVOID) m_pShared;
        }

        if (phTempIndexFile && m_hTempIndexFile)
        {
            if (0 == ::DuplicateHandle(::GetCurrentProcess(), m_hTempIndexFile,
                                       ::GetCurrentProcess(), phTempIndexFile,
                                       0,       // desired access - ignored
                                       FALSE,   // bInherit
                                       DUPLICATE_SAME_ACCESS))
            {
                dwLastError = ::GetLastError();
                hr = HRESULT_FROM_WIN32(dwLastError);
                assert(0);
                __leave;
            }
        }
        else if (phTempIndexFile)
        {
            *phTempIndexFile = NULL;
        }

        hr = S_OK;
    }
    __finally
    {
        if (FAILED(hr))
        {
            if (phDataFile)
            {
                ::CloseHandle(*phDataFile);
                *phDataFile = NULL;
            }
            if (phMemoryMappedFile)
            {
                ::CloseHandle(*phMemoryMappedFile);
                *phMemoryMappedFile = NULL;
            }
            if (phFileMapping)
            {
                ::CloseHandle(*phFileMapping);
                *phFileMapping = NULL;
            }
            if (phMappedView)
            {
                *phMappedView = NULL;
            }
            if (phTempIndexFile)
            {
                ::CloseHandle(*phTempIndexFile);
                *phTempIndexFile = NULL;
            }
        }
        else
        {
            if (phMappedView)
            {
                m_bUnmapView = 0;
            }
        }
        m_GenericMutex.Unlock();
    }

    return hr;

} // CDVRSink::GetMappingHandles

////////////////////////////////////////////////////////////////////////////
HRESULT CDVRSink::OpenEvent(IN DWORD i /* dwReaderIndex */)
{
    HRESULT hrRet = S_OK;

    WCHAR wszEvent[MAX_EVENT_NAME_LEN];

    assert(m_pShared->Readers[i].dwEventSuffix);
    assert(m_hReaderEvent[i] == NULL);
    assert(m_bReaderEventOpenFailed[i] == 0);

    wsprintf(wszEvent, L"%s%u", kwszSharedEventPrefix, m_pShared->Readers[i].dwEventSuffix);

    m_hReaderEvent[i] = ::OpenEventW(EVENT_MODIFY_STATE, FALSE /* inheritable */, wszEvent);
    if (m_hReaderEvent[i] == NULL)
    {
        // The open can fail because the reader terminated. 
        DWORD dwLastError = ::GetLastError();
        m_bReaderEventOpenFailed[i] = 1;
        hrRet = HRESULT_FROM_WIN32(dwLastError);
    }

    return hrRet;

} // CDVRSink::OpenEvent


////////////////////////////////////////////////////////////////////////////
HRESULT CDVRSink::InitSharedMemory(CDVRSharedMemory* p,
                                   HANDLE&           hMutex // OUT
                                  )
{
    // This does not access any members of CDVRSink and could be
    // made a static member function

    HRESULT hrRet;

    __try
    {
        DWORD i;
        DWORD nLen;

        ::ZeroMemory(p, sizeof(*p));
        hMutex = NULL;

        WCHAR wszMutex[MAX_MUTEX_NAME_LEN];
        wcscpy(wszMutex, kwszSharedMutexPrefix);
        nLen = wcslen(kwszSharedMutexPrefix);

        PACL                 pACL = NULL;
        PSECURITY_DESCRIPTOR pSD = NULL;
        DWORD                dwAclCreationStatus;
        SECURITY_ATTRIBUTES  sa;

        if (m_dwNumSids > 0)
        {
            dwAclCreationStatus = ::CreateACL(m_dwNumSids, m_ppSids,
                                              SET_ACCESS, MUTEX_ALL_ACCESS,
                                              SET_ACCESS, SYNCHRONIZE,
                                              pACL,
                                              pSD
                                             );

            if (dwAclCreationStatus != ERROR_SUCCESS)
            {
                hrRet = HRESULT_FROM_WIN32(dwAclCreationStatus);
                __leave;
            }

            sa.nLength = sizeof (SECURITY_ATTRIBUTES);
            sa.lpSecurityDescriptor = pSD;
            sa.bInheritHandle = FALSE;
        }

        for (i = 1; i != 0; i++)
        {
            wsprintf(wszMutex + nLen, L"%u", i);

            HANDLE h = ::CreateMutexW(m_dwNumSids > 0 ? &sa : NULL, TRUE /* Initially owned */, wszMutex);

            DWORD dwLastError = ::GetLastError();

            if (h == NULL || dwLastError == ERROR_ALREADY_EXISTS)
            {
                if (h)
                {
                    ::CloseHandle(h);
                }
                else
                {
                    // It's ok if we failed for any other reason - just go on.
                }
            }
            else
            {
                // Done
                p->dwMutexSuffix = i;
                hMutex = h;
                break;
            }
        }
        if (m_dwNumSids > 0)
        {
            ::FreeSecurityDescriptors(pACL, pSD);
        }

        if (i == 0)
        {
            // Failed to find a suitable value for dwMutexSuffix?!
            assert(0);
            hrRet = E_FAIL;
            __leave;
        }

        p->dwLastOwnedByWriter = 1;
        p->dwWriterPid = ::GetCurrentProcessId();

        p->guidWriterId = m_guidWriterId ;

        // Note: everything after this is not required to be set
        // before the view is mapped because the reader will always
        // acquire the mutex before accessing any other member
        // of the shared data section.

        p->dwBeingWritten = 1;
        p->dwIsTemporary = m_bTemporary;

        p->qwIndexHeaderOffset = MAXQWORD - MAXDWORD;
        p->qwTotalFileSize = p->qwIndexHeaderOffset;
        p->qwOffsetOfFirstIndexInSharedMemory = p->qwIndexHeaderOffset;
        p->qwOffsetOfLastIndexInSharedMemory = p->qwIndexHeaderOffset;

        for (int i = 0; i < CDVRSharedMemory::MAX_READERS; i++)
        {
            p->Readers[i].dwMsg = CDVRSharedMemory::CReaderInfo::DVR_READER_REQUEST_NONE;
        }

        // Calling function will set these correctly after the view is
        // mapped. These are currently NULL since we ZeroMemory'd the
        // struct
        // p->pIndexHeader
        // p->pIndexStart
        // p->pFirstIndex
        // p->pIndexEnd

        hrRet = S_OK;
    }
    __finally
    {
        // Calling function will release this mutex. This ensures that
        // readers will not access this memory/write to the Readers[] array
        // till this function and its caller complete without error. This
        // simplifies clean up of the shared memory if there is an error.

    }

    return hrRet;

} // CDVRSink::InitSharedMemory

////////////////////////////////////////////////////////////////////////////
HRESULT CDVRSink::InternalOpen(const WCHAR *pwszFilename)
{
    HRESULT              hrRet;
    CDVRSharedMemory     SharedMemory;
    PTOKEN_PRIVILEGES    pPreviousPrivilege = NULL;
    m_GenericMutex.Lock();

    __try
    {
        HRESULT                     hr;
        BY_HANDLE_FILE_INFORMATION  sFileInf;
        DWORD                       dwLastError;
        WCHAR                       wszMapping[50];
        WCHAR*                      pwszMappingName;
        WCHAR                       *pwszFilePart;
        DWORD                       nLen;
        WCHAR                       *pwszDirectory;
        WCHAR                       *pwszMapFile;
        WCHAR                       *pwszIndexFile = NULL;
        WCHAR                       wTempChar;


#if defined(DVR_UNOFFICIAL_BUILD)

        DWORD                dwPreviousPrivilegeSize = 0;
        HANDLE               hToken = NULL;

        if (m_dwFileCreationDisposition == CREATE_ALWAYS)
        {
            // Ignore any errors. This allows SetFileValidData
            // to be called to extend the file. This should help
            // unbuffered i/o; however, it'does not help buffered writes
            // because data has to be read in before being written.
            // (has been tested)

            AcquirePrivilege(SE_MANAGE_VOLUME_NAME,
                             &hToken,
                             &pPreviousPrivilege,
                             &dwPreviousPrivilegeSize);
        }

#endif // if defined(DVR_UNOFFICIAL_BUILD)


        // Note: The previously opened file may not have been
        // closed at this point. The base class's InternalOpen
        // closes it. (Do not try to create the index file and
        // memory mapping here - see the note below.)

        hrRet = CWMFileSinkV1::InternalOpen(pwszFilename);

#if defined(DVR_UNOFFICIAL_BUILD)

        if (hToken)
        {
            // Call to AcquirePrivilege succeeded
            RestorePrivileges(hToken, dwPreviousPrivilegeSize, pPreviousPrivilege);
            hToken = NULL;
            pPreviousPrivilege = NULL;
        }
        else
        {
            // Don't try to extend the valid data size
            m_cbFileExtendThreshold = 0;
        }

        assert(m_cbEOF == 0);

#endif // if defined(DVR_UNOFFICIAL_BUILD)


        if (FAILED(hrRet))
        {
            __leave;
        }

        assert(m_dwOpened == DVR_SINK_CLOSED);
        assert(m_pShared == NULL);
        assert(m_hMutex == NULL);
#if DBG
        // Assert both arrays have the same number of elements
        assert(sizeof(m_hReaderEvent)/sizeof(m_hReaderEvent[0]) == 
               sizeof(m_bReaderEventOpenFailed)/sizeof(m_bReaderEventOpenFailed[0]));

        // Assert all elements are NULL/zero.
        for (DWORD eventIndex = 0; 
             eventIndex < sizeof(m_hReaderEvent)/sizeof(m_hReaderEvent[0]);
             eventIndex++)
        {
            assert(m_hReaderEvent[eventIndex] == NULL);
            assert(m_bReaderEventOpenFailed[eventIndex] == 0);
        }
#endif
        assert(!m_bUnmapView);

        m_dwOpened = DVR_SINK_BEING_OPENED;
        assert(m_hRecordFile !=  NULL &&
               m_hRecordFile != INVALID_HANDLE_VALUE);
        assert(!m_bIndexing);


        // Note: We have an unaddressed synchronization issue here.
        // The reader can open the ASF file and try to open the file
        // mapping after the writer creates the ASF file but before
        // it creates the mapping. The reader will then believe that
        // the ASF file is complete since there is no index file.

        // There is a similar sync issue at the DVR IO layer: the
        // writer can add a file to the ring buffer and queues the
        // Open and BeginWriting calls; the reader finds the file in
        // the ring buffer and attempts to open it and doesn't find it.

        // We will not hit these sync issues except possibly for
        // the first file that is created when writing starts because
        // the reader uses the ring buffer time extent to determine if
        // a file exists and the writer does not update the extent
        // until a sample has been written (which means that the file
        // has been opened by then).

        // We will let the client of the DVR IO layer to resolve the
        // sync issue for the first file. (The IDVRStreamSource::Open
        // has a time out argument that the DVR IO layer can use.)

        // To address this sync issue purely within this class,
        // the memory mapping should be
        // created before the ASF file is created.
        // We would have to restructure the CFileSinkv1 class'
        // InternalOpen to call into us after calling Close and before
        // it calls CreateFile to create the ASF file. However, this
        // still won't fix the sync issue at the DVR IO layer (reader
        // may try to open the ASF file before the writer creates it)
        // We would also have to use a different naming scheme for the
        // memory map.

        // Currently, IDVRStreamSource::Open waits until the file has a
        // few bytes before trying to open the memory mapping. Since the
        // DVR IO layer always creates the file first and then writes the
        // header, waiting until the file has a few bytes ensures that the
        // memory mapping would have been created.


        // Generate the name of the mapping object and the temp index file(s)

        if (::GetFileInformationByHandle(m_hRecordFile, &sFileInf) == 0)
        {
            dwLastError = ::GetLastError();
            assert(0);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        wsprintf(wszMapping, L"Global\\MSDVRMM_%u_%u_%u",
                 sFileInf.dwVolumeSerialNumber ,
                 sFileInf.nFileIndexHigh,
                 sFileInf.nFileIndexLow);
        pwszMappingName = wszMapping + wcslen(L"Global\\");

        nLen = ::GetFullPathNameW(m_pwszFilename, 0, &wTempChar, NULL);
        if (nLen == 0)
        {
            dwLastError = ::GetLastError();
            assert(0);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }
        nLen++;  // for NULL terminator

        pwszDirectory = (PWCHAR) _alloca(sizeof(WCHAR) * nLen);
        if (!pwszDirectory)
        {
            hrRet = E_OUTOFMEMORY;
            __leave;
        }

        nLen = ::GetFullPathNameW(m_pwszFilename, nLen, pwszDirectory, &pwszFilePart);
        if (nLen == 0)
        {
            dwLastError = ::GetLastError();
            assert(0);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }
        assert(pwszFilePart);
        *pwszFilePart = L'\0';

        nLen = wcslen(pwszDirectory) + wcslen(pwszMappingName) + 1;
        pwszMapFile = (PWCHAR) _alloca(sizeof(WCHAR) * nLen);
        if (!pwszMapFile)
        {
            hrRet = E_OUTOFMEMORY;
            __leave;
        }
        wsprintf(pwszMapFile, L"%ls%ls", pwszDirectory, pwszMappingName);

        // We alloc pwszIndexFile anyway - don't do this in an
        // if clause which tests if we are permanent indexing
        // because the alloca's memory goes out of scope when
        // the if terminates

        nLen += 4;
        pwszIndexFile = (PWCHAR) _alloca(sizeof(WCHAR) * nLen);
        if (!pwszIndexFile)
        {
            hrRet = E_OUTOFMEMORY;
            __leave;
        }

        if (!m_bTemporary && m_dwIndexStreamId != MAXDWORD)
        {
            wsprintf(pwszIndexFile, L"%ls%ls.tmp", pwszDirectory, pwszMappingName);
        }
        else
        {
            *pwszIndexFile = L'\0';
        }

        //  if we're going to use the async writer, allocate the memory it will
        //    use to be part of this
        if (m_pIDVRAsyncWriter) {
            hr = m_pIDVRAsyncWriter -> GetWriterId (& m_guidWriterId) ;
            if (FAILED (hr)) {
                //  we don't expect this call to fail
                assert (0) ;
                hrRet = hr;
                __leave ;
            }
        }

        // Initialize the shared memory structure
        m_pShared = &SharedMemory;   // Kludge to let us clean up in InternalClose() if this function fails
        hr = InitSharedMemory(m_pShared, m_hMutex);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        // Open the memory mapped index file and write the shared data to it
        // This is done before creating the memory mapped section so that the
        // memory mapped section has the correct values when it is created.
        // TODO @@@@: Set acls appropriately
        HANDLE hMMFile = ::CreateFileW(pwszMapFile,
                                       GENERIC_WRITE,
                                       0,             // No share flags
                                       NULL,          // security attributes
                                       CREATE_NEW,
                                       FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_TEMPORARY |
                                       FILE_FLAG_SEQUENTIAL_SCAN,
                                       NULL           // template file
                                      );
        if (hMMFile == INVALID_HANDLE_VALUE)
        {
            dwLastError = ::GetLastError();
            assert(0);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        DWORD dwWritten;
        if (::WriteFile(hMMFile, &SharedMemory, sizeof(SharedMemory), &dwWritten, NULL) == 0 ||
            dwWritten != sizeof(SharedMemory))
        {
            dwLastError = ::GetLastError();
            assert(0);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            ::CloseHandle(hMMFile);
            __leave;
        }

        ::CloseHandle(hMMFile);
        hMMFile = NULL;

        // Open the real handle
        m_hMemoryMappedFile = ::CreateFileW(pwszMapFile,
                                            GENERIC_READ | GENERIC_WRITE | DELETE,
                                            FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                                            NULL,          // security attributes
                                            OPEN_EXISTING,
                                            FILE_FLAG_RANDOM_ACCESS | FILE_FLAG_DELETE_ON_CLOSE,
                                            NULL           // template file
                                           );
        if (m_hMemoryMappedFile == INVALID_HANDLE_VALUE)
        {
            // Note: Some prankster may have opened the file with the wrong share flags
            // or could have deleted it, so failure to open here may not be our error.
            // That is unlikely to happen; if it does open m_hMemoryMappedFile with hMMFile
            // kept open and close hMMFile later.

            // This should not happen if our reader opened the file.

            dwLastError = ::GetLastError();
            assert(0);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            m_hMemoryMappedFile = NULL;
            __leave;
        }

        // Create the memory mapping. This will grow the disk file to
        // the size specified as arguments to the call.
        PACL                 pACL = NULL;
        PSECURITY_DESCRIPTOR pSD = NULL;
        DWORD                dwAclCreationStatus;
        SECURITY_ATTRIBUTES  sa;


        if (m_dwNumSids > 0)
        {
            // The size of this memory map is never changed, so we turn off SECTION_EXTEND_SIZE
            dwAclCreationStatus = ::CreateACL(m_dwNumSids, m_ppSids,
                                              SET_ACCESS, SECTION_ALL_ACCESS & ~(SECTION_EXTEND_SIZE|SECTION_MAP_EXECUTE),
                                              SET_ACCESS, SECTION_QUERY|SECTION_MAP_WRITE|SECTION_MAP_READ,
                                              pACL,
                                              pSD
                                             );

            if (dwAclCreationStatus != ERROR_SUCCESS)
            {
                hrRet = HRESULT_FROM_WIN32(dwAclCreationStatus);
                __leave;
            }

            sa.nLength = sizeof (SECURITY_ATTRIBUTES);
            sa.lpSecurityDescriptor = pSD;
            sa.bInheritHandle = FALSE;
        }

        m_hFileMapping = ::CreateFileMappingW(m_hMemoryMappedFile,
                                              m_dwNumSids > 0 ? &sa : NULL,
                                              PAGE_READWRITE,
                                              0,        /// high order size
                                              m_dwNumPages * m_dwPageSize,
                                              wszMapping);
        dwLastError = ::GetLastError();
        if (m_dwNumSids > 0)
        {
            ::FreeSecurityDescriptors(pACL, pSD);
        }
        if (m_hFileMapping == NULL || dwLastError == ERROR_ALREADY_EXISTS)
        {
            // Note that we fail if ERROR_ALREADY_EXISTS. Readers call
            // OpenFileMapping, so someone else is using this mapping name.

            assert(0);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        // Map the view
        m_pShared = (CDVRSharedMemory*) MapViewOfFile(m_hFileMapping,
                                                      FILE_MAP_ALL_ACCESS,
                                                      0, 0, // file offset for start of map, high and low
                                                      m_dwNumPages * m_dwPageSize);
        if (m_pShared == NULL)
        {
            m_pShared = &SharedMemory; // Kludge to let us clean it up in InternalClose
            dwLastError = ::GetLastError();
            assert(0);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }
        m_bUnmapView = 1;

        //  setup our writer's buffering if required
        if (m_pIDVRAsyncWriter) {
            hr = m_pIDVRAsyncWriter -> SetWriterActive (
                    pwszFilename,               //  filename
                    m_dwFileShareFlags,         //  sharing flags
                    OPEN_ALWAYS                 //  creation flags
                    ) ;

            if (FAILED (hr)) {
                assert (0) ;
                hrRet = hr;
                __leave ;
            }
        }

        if (m_dwIndexStreamId == MAXDWORD)
        {
            // Not indexing
            m_pShared->pIndexHeader = m_pShared->pIndexStart = m_pShared->pIndexEnd = m_pShared->pFirstIndex = 0;
            assert(m_hTempIndexFile == NULL);
            m_bIndexing = 0;
        }
        else
        {
            // Set the byte pointers
            m_pShared->pIndexHeader = sizeof(CDVRSharedMemory);
            m_pShared->pIndexStart = m_pShared->pIndexHeader + m_Index.EmptyIndexSpace();
            m_pShared->pFirstIndex = m_pShared->pIndexStart;

            DWORD dwNumIndexEntries;

            hr = GetMaxIndexEntries(m_dwNumPages, &dwNumIndexEntries);
            if (FAILED(hr))
            {
                // This most likely happened because the caller ignored the error
                // result returned by the constructor. This value of m_dwNumPages
                // could not have been set by calling SetNumSharedDataPages
                assert(0);
                hrRet = E_UNEXPECTED;
                __leave;
            }
            assert(dwNumIndexEntries > 0);

            // Bytes pointed to at and after pIndexEnd should not be used.
            m_pShared->pIndexEnd = m_pShared->pIndexStart + dwNumIndexEntries * m_Index.IndexEntrySize();

            // Initialize the index header. Note that m_Index is (should be) empty at
            // this point.
            assert(m_Index.Space() == m_Index.EmptyIndexSpace());


            hr = m_Index.SetTimeDelta(m_cnsIndexGranularity);

            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }

            CTransferContext TransferContext;

            // @@@@ Following values are used in sdk\indexer\ocx\engine.cpp which constructs the
            // ASF v1 index in a post processing step. Also see CDVRSink::OnHeader() below.
            //
            // Note: Although the index header is written here, the reader should not access it
            // until the header has been written. OnHeader could change the byte ordering of
            // the WORDs and DWORDs in the index header. The reader should ask the writer to notify
            // it when for an additional N bytes until it can construct the header fully; this is
            // the only way the reader knows that the writer has written the header.

            TransferContext.hostArch = TransferContext.streamArch = LITTLE_ENDIAN;
            TransferContext.hostAlign = TransferContext.streamAlign = 1;

            CASFArchive ar((BYTE*) m_pShared + m_pShared->pIndexHeader, m_pShared->pIndexStart, TransferContext);

            hr = m_Index.Persist(ar);
            if (FAILED(hr))
            {
                assert(0);
                hrRet = hr;
                __leave;
            }

            // Create the temporary on-disk index file if the ASF file is not temporary
            if (!m_bTemporary)
            {
                // TODO @@@@: Set acls appropriately
                m_hTempIndexFile = ::CreateFileW(pwszIndexFile,
                                                 GENERIC_READ | GENERIC_WRITE | DELETE,
                                                 FILE_SHARE_DELETE | FILE_SHARE_READ,
                                                 NULL,          // security attributes
                                                 CREATE_NEW,
                                                 FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_TEMPORARY |
                                                 FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_DELETE_ON_CLOSE,
                                                 NULL           // template file
                                                );
                if (m_hTempIndexFile == INVALID_HANDLE_VALUE)
                {
                    dwLastError = ::GetLastError();
                    assert(0);
                    hrRet = HRESULT_FROM_WIN32(dwLastError);
                    m_hTempIndexFile = NULL;
                    __leave;
                }

                // We don't access the index header from this file, but we write it out so that
                // we don't have to adjust offsets when we read this file.

                DWORD   cbWritten;
                BOOL    bResult;

                bResult = ::WriteFile(m_hTempIndexFile,
                                      (BYTE*) m_pShared + m_pShared->pIndexHeader,
                                      m_pShared->pIndexStart - m_pShared->pIndexHeader,
                                      &cbWritten,
                                      NULL);

                if (!bResult || cbWritten != m_pShared->pIndexStart - m_pShared->pIndexHeader)
                {
                    dwLastError = ::GetLastError();
                    assert(0);
                    hrRet = HRESULT_FROM_WIN32(dwLastError);
                    __leave;
                }
            }
            else
            {
                assert(m_hTempIndexFile == NULL);
            }

            m_pShared->qwOffsetOfFirstIndexInSharedMemory += m_Index.EmptyIndexSpace();
            m_pShared->qwOffsetOfLastIndexInSharedMemory += m_Index.EmptyIndexSpace();

            hr = m_Index.SetIndexParams((BYTE*) m_pShared + m_pShared->pIndexHeader,
                                        (BYTE*) m_pShared + m_pShared->pIndexStart,
                                        (BYTE*) m_pShared + m_pShared->pIndexEnd,
                                        &m_pShared->pFirstIndex,
                                        m_pShared->pFirstIndex,
                                        &m_pShared->qwOffsetOfFirstIndexInSharedMemory,
                                        &m_pShared->qwOffsetOfLastIndexInSharedMemory,
                                        &m_pShared->qwTotalFileSize,
                                        m_hTempIndexFile);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }

            // We do this here because we could have got the header before
            // the caller opens the file. (That will happen if he closes the
            // first file and then opens another one without calling EndWriting.)
            //
            // We should do this even if m_mmsID is the NULL guid because even
            // though m_pShared has been ZeroMemory'd, CASFIndexObject's constructor
            // does not initialize its m_mmsID member. This call will set it. [On second
            // thought, CASFINdexObject::m_mmsID is not used at all by us. Anyway ...)

            hr = m_Index.SetMmsID(m_mmsID);
            if (FAILED(hr))
            {
                assert(0);
                hrRet = hr;
                __leave;
            }
            m_bIndexing = 1;
        }
    }
    __finally
    {
        if (SUCCEEDED(hrRet))
        {
            m_dwOpened = DVR_SINK_OPENED;
            m_bOpenedOnce = 1;
            assert(m_pShared);
            assert(m_pShared != &SharedMemory);

            assert(m_hMutex);
            if (::ReleaseMutex(m_hMutex) == 0)
            {
                // We don't own the mutex?!
                DWORD dwLastError = ::GetLastError(); // for debugging only
                assert(0);
            }
        }
        else
        {
            if (m_dwOpened == DVR_SINK_BEING_OPENED)
            {
                // This means that the parent class' InternalOpen
                // succeeded. We have to clean up and clean up
                // the parent class.

                // Note that Close() will write the header to the file just
                // opened if the header has been received. (This will happen if
                // a file was open and this file is being opened without calling
                // EndWriting() or if the client called BeginWriting and then
                // called the sink's Open() method.)

                // The parent class's Close does some other clean up,
                // notably sending notifications. The client should be
                // prepared to receive these notifications although the
                // file has not been opened. (Note that the parent class
                // never has to send out Close notifications if the file
                // open failed because the only failure point is early on
                // and there is no clean up to do - specifically, there is
                // no need to call Close. So this sink adds a new twist for
                // the caller if it processes notifications).

                Close();

                assert(m_dwOpened == DVR_SINK_CLOSED);
            }
            else
            {
                // The parent class' InternalOpen failed. If the sink
                // was open and Open was called (client did not call
                // Close or EndWriting), the parent class calls Close().
                // before opening the new file. Close() could have failed.
                // Or Close() could have succeeded and one of the subsequent
                // steps in opening the file could have failed.

                // The following asserts should hold even if the sink was
                // open when this function was called and the failure
                // occurred when the parent class called Close() to
                // close it. (Close calls InternalClose, so our
                // InternalClose must successfully clean up even if
                // it fails.)

                assert(m_dwOpened == DVR_SINK_CLOSED);
                assert(m_pShared == NULL);

                // If one of the steps in opening the file failed (i.e.,
                // there was no need to call Close or the call to Close
                // succeeded), the parent class should have cleaned up.
                // We don't have anything to do.
            }
        }
        m_GenericMutex.Unlock();
    }

    return hrRet;

} // CDVRSink::InternalOpen

////////////////////////////////////////////////////////////////////////////
HRESULT CDVRSink::InternalClose()
{
    HRESULT hrRet = S_OK;
    HANDLE hMutex = NULL;
    ULONGLONG   ullTotalBytes ;

    m_GenericMutex.Lock();

    __try
    {
        DWORD       dwLastError;

        if (m_dwOpened == DVR_SINK_CLOSED)
        {
            // We have cleaned up - just call the base class
            assert(m_pShared == NULL);
        }
        else if (m_dwOpened == DVR_SINK_BEING_OPENED && m_pShared)
        {
            // Note that m_pShared could be NULL if m_dwOpened == DVR_SINK_BEING_OPENED
            // In that case, we have no clean up.

            // In this case, note that:
            //  - m_pShared may not have been fully initialized.
            //  - it may have been initialized by calling InitSharedMemory
            //    but some step after that may have failed

            // We already own this mutex if it is not NULL
            hMutex = m_hMutex;

#if DBG
            if (hMutex)
            {
                assert(m_pShared->dwLastOwnedByWriter == 1);
                assert(m_pShared->dwWriterAbandonedMutex == 0);
                DWORD dwWait = ::WaitForSingleObject(hMutex, 0);
                if (dwWait == WAIT_TIMEOUT || dwWait == WAIT_FAILED)
                {
                    assert(0);
                }
                else
                {
                    ::ReleaseMutex(hMutex); // We just got it
                }
            }
            for (int i = 0; i < CDVRSharedMemory::MAX_READERS; i++)
            {
                assert(m_pShared->Readers[i].dwMsg == CDVRSharedMemory::CReaderInfo::DVR_READER_REQUEST_NONE);
                assert(m_pShared->Readers[i].dwEventSuffix == 0);
                assert(m_hReaderEvent[i] == NULL);     
                assert(m_bReaderEventOpenFailed[i] == 0);
            }
#endif
        }
        else if (m_dwOpened == DVR_SINK_OPENED)
        {
            assert(m_pShared);

            // Ignore the returned value because readers are expected
            // to only read the shared section (except for the Readers array).
            // If they abandon the mutex, that's ok

            ::WaitForSingleObject(m_hMutex, INFINITE);
            m_pShared->dwLastOwnedByWriter = 1;
            assert(m_pShared->dwWriterAbandonedMutex == 0);
            hMutex = m_hMutex;

            //  flush out our async writer and set the file size
            if (m_pIDVRAsyncWriter) {

                FlushToDiskLocked () ;

                //  inactivate the writer
                m_pIDVRAsyncWriter -> SetWriterInactive () ;

                //  writer no longer is using this
                ::ZeroMemory (& m_pShared -> guidWriterId, sizeof m_pShared -> guidWriterId) ;

                //  finished with the pointer
                m_pIDVRAsyncWriter -> Release () ;
                m_pIDVRAsyncWriter = NULL ;
            }

            // Flag any waiting reader to move on - the file has been closed.
            // Note that the waiting reader will grab the mutex next, so
            // as long as we hold the mutex, we can update the fields in any
            // order
            for (int i = 0; i < CDVRSharedMemory::MAX_READERS; i++)
            {
                if (m_pShared->Readers[i].dwMsg == CDVRSharedMemory::CReaderInfo::DVR_READER_REQUEST_READ)
                {
                    assert(m_pShared->Readers[i].dwEventSuffix);
                    if (!m_hReaderEvent[i] && !m_bReaderEventOpenFailed[i])
                    {
                        // Ignore the result, The reader won't be signaled
                        // This is bad but there's little we can do.
                        OpenEvent(i);
                    }
                    if (m_hReaderEvent[i])
                    {
                        ::SetEvent(m_hReaderEvent[i]);
                    }
                }

                if (m_pShared->Readers[i].dwEventSuffix)
                {
                    if (m_hReaderEvent[i])
                    {
                        ::CloseHandle(m_hReaderEvent[i]);
                        m_hReaderEvent[i] = NULL;
                    }
                    m_bReaderEventOpenFailed[i] = 0;
                    m_pShared->Readers[i].dwEventSuffix = 0;
                    m_pShared->Readers[i].dwMsg = CDVRSharedMemory::CReaderInfo::DVR_READER_REQUEST_NONE;
                }
                else
                {
                    assert(m_pShared->Readers[i].dwMsg == CDVRSharedMemory::CReaderInfo::DVR_READER_REQUEST_NONE);
                }
            }

            // We hold the mutex through the index copy (if this is not a temp
            // ASF file) and hold up readers for that period, but this solves
            // the problem of new readers who try to open the file now - they
            // will have an ASF file with an entire index.

            if (m_bIndexing && (!m_bTemporary || m_bUnmapView))
            {
                __try
                {
                    DWORD   cbWritten;
                    BOOL    bResult;

                    // Copy index to the end of the ASF file

                    // @@@@ Note: This ASSUMES that the format of the
                    // index entries in memory and on disk are identical.
                    // This is OK for X86; verify for other architectures.
                    // Typically, the index is written out using a CASFArchive
                    // object which swaps bytes if one of the host and streaming
                    // architectures is little-endian and the otehr big-endian
                    // (see CASFIndexObject::Persist and CASFArchive methods. However,
                    // the caller sets the endian-ness of both the host and the
                    // streaming machines and the endian value in the ASF file
                    // does not seem to get used (at least in sdk\indexer\ocx\engine.cpp).
                    // See the note in CDVRSink::OnHeader()

                    assert(m_hRecordFile != INVALID_HANDLE_VALUE && m_hRecordFile != NULL);
                    assert(m_cbIndexSize == 0); // Maintained in parent class - CWMFileSinkv1

                    LARGE_INTEGER lSeekPosition;

                    lSeekPosition.QuadPart = 0;
                    if (::SetFilePointerEx(m_hRecordFile,
                                           lSeekPosition,
                                           NULL,
                                           FILE_END) == INVALID_SET_FILE_POINTER)
                    {
                        dwLastError = ::GetLastError();
                        assert(0);
                        hrRet = HRESULT_FROM_WIN32(dwLastError);
                        __leave;
                    }

                    bResult = ::WriteFile(m_hRecordFile,
                                          (BYTE*) m_pShared + m_pShared->pIndexHeader,
                                          m_pShared->pIndexStart - m_pShared->pIndexHeader,
                                          &cbWritten,
                                          NULL);

                    if (!bResult || cbWritten != m_pShared->pIndexStart - m_pShared->pIndexHeader)
                    {
                        dwLastError = ::GetLastError(); // for debugging
                        assert(0);
                        m_wfse = WRITER_FILESINK_ERROR_SEV_ONINDEX;
                        hrRet = NS_E_FILE_WRITE;
                        __leave;
                    }

                    m_cbCurrentFileSize += cbWritten;
                    m_cbIndexSize += cbWritten;

                    if (m_hTempIndexFile)
                    {
                        if (::SetFilePointer(m_hTempIndexFile,
                                             m_Index.EmptyIndexSpace(),
                                             NULL,
                                             FILE_BEGIN) == INVALID_SET_FILE_POINTER)
                        {
                            dwLastError = ::GetLastError();
                            assert(0);
                            hrRet = HRESULT_FROM_WIN32(dwLastError);
                            __leave;
                        }

                        BYTE buf[1024];
                        DWORD dwRead;
                        DWORD nRet;

                        nRet = ::ReadFile(m_hTempIndexFile, buf, sizeof(buf), &dwRead, NULL);

                        while(nRet && dwRead > 0)
                        {
                            bResult = ::WriteFile(m_hRecordFile,
                                                  buf,
                                                  dwRead,
                                                  &cbWritten,
                                                  NULL);

                            if (!bResult || cbWritten != dwRead)
                            {
                                dwLastError = ::GetLastError(); // for debugging
                                assert(0);
                                m_wfse = WRITER_FILESINK_ERROR_SEV_ONINDEX;
                                hrRet = NS_E_FILE_WRITE;
                                __leave;
                            }

                            m_cbCurrentFileSize += cbWritten;
                            m_cbIndexSize += cbWritten;
                            nRet = ::ReadFile(m_hTempIndexFile, buf, sizeof(buf), &dwRead, NULL);
                        }
                        if (nRet == 0)
                        {
                            dwLastError = ::GetLastError();
                            assert(0);
                            hrRet = HRESULT_FROM_WIN32(dwLastError);
                            __leave;
                        }
                    }

                    DWORD dwNumToWrite = m_Index.GetNumIndexEntryBytesNotFlushed();

                    if (dwNumToWrite > 0)
                    {
                        bResult = ::WriteFile(m_hRecordFile,
                                              (BYTE*) m_pShared + m_pShared->pIndexStart,
                                              dwNumToWrite,
                                              &cbWritten,
                                              NULL);

                        if (!bResult || cbWritten != dwNumToWrite)
                        {
                            dwLastError = ::GetLastError(); // for debugging
                            assert(0);
                            m_wfse = WRITER_FILESINK_ERROR_SEV_ONINDEX;
                            hrRet = NS_E_FILE_WRITE;
                            __leave;
                        }
                        m_cbCurrentFileSize += cbWritten;
                        m_cbIndexSize += cbWritten;
                    }

                    // Finally, to let the parent class' UpdateHeader()
                    // set SEEKABLE flag in the ASF header:
                    m_fSimpleIndexObjectWritten = m_bIndexing;

                    // Don't need to do this since SetupIndex calls CreateIndexer
                    // m_StreamNumberToIndex[m_dwIndexStreamId] = (CWMPerStreamIndex *) 1; // Kludge!!
                }
                __finally
                {
                }
            } // if (m_bIndexing && (!m_bTemporary || m_bUnmapView))
        } // if (m_dwOpened == DVR_SINK_OPENED)

        if (m_pShared)
        {
            // Reset the fields

            // The following two members are used by the reader - when starting up - without waiting for
            // the mutex. Reader can't wait for the mutex before dup'ing the handle of the mutex into
            // the reader's process. If the CDVRSharedMemory::dwMutexSuffix == 0, it accesses dwBeingWritten
            // (and subsequently all other members of CDVRSharedMemory) to verify it is 0.
            ::InterlockedExchange((LPLONG) &m_pShared->dwBeingWritten, 0);
            ::InterlockedExchange((LPLONG) &m_pShared->dwMutexSuffix, 0);

            if (m_bUnmapView)
            {
                UnmapViewOfFile(m_pShared);
            }
            m_pShared = NULL;
            m_hMutex = NULL;
        }
        if (m_hFileMapping)
        {
            ::CloseHandle(m_hFileMapping);
            m_hFileMapping = NULL;
        }
        if (m_hMemoryMappedFile)
        {
            ::CloseHandle(m_hMemoryMappedFile);
            m_hMemoryMappedFile = NULL;
        }
        if (m_hTempIndexFile)
        {
            ::CloseHandle(m_hTempIndexFile);
            m_hTempIndexFile = NULL;
        }

        m_dwNumPages = 1;
        DWORD   dwMaxIndexEntries;
        while (FAILED(GetMaxIndexEntries(m_dwNumPages, &dwMaxIndexEntries)))
        {
            assert(dwMaxIndexEntries > 0);
            m_dwNumPages++;
            if (m_dwNumPages > 10)
            {
                // This didn't happen in the constructor; it should
                // not happen here
                assert(0);
                hrRet = E_FAIL;
                break;
            }
        }
        m_dwOpened = DVR_SINK_CLOSED;
        m_bUnmapView = 0;
        m_bIndexing = 0;
        m_bTemporary = 0;
        m_Index.SetIndexParams();

#if defined(DVR_UNOFFICIAL_BUILD)
        m_cbEOF = 0;
#endif // if defined(DVR_UNOFFICIAL_BUILD)

        HRESULT hr = CWMFileSinkV1::InternalClose();

        if (SUCCEEDED(hrRet))
        {
            hrRet = hr;
        }
    }
    __finally
    {
        if (hMutex)
        {
            ::ReleaseMutex(hMutex);
            ::CloseHandle(hMutex);
        }
        m_GenericMutex.Unlock();
    }

    return hrRet;

} // CDVRSink::InternalClose()

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSink::OnHeader(INSSBuffer *pHeader)
{
    AutoLock<Mutex> lock( m_GenericMutex );
    HRESULT hr;
    BOOL    fHeaderNotWrittenBefore ;

    assert(m_pShared);

    ::WaitForSingleObject(m_hMutex, INFINITE);
    m_pShared->dwLastOwnedByWriter = 1;
    assert(m_pShared->dwWriterAbandonedMutex == 0);

    while (1) // __try
    {
        // Note that the parent class sends out notifications on
        // failure. We don't have to split this method into an Internal
        // one (that does the work without sending notifications)
        // because our additions here do not fail.

        //  do this so we know if we should flush (headers are always flushed
        //  to disk);
        fHeaderNotWrittenBefore = !m_fHeaderWritten ;
        hr = CWMFileSinkV1::OnHeader(pHeader);

        if (SUCCEEDED(hr))
        {
            assert(m_pASFHeader);

            if (fHeaderNotWrittenBefore &&
                m_fHeaderWritten) {

                //  baseclass wrote header, so we flush what we have
                FlushToDiskLocked () ;
            }

#if DBG
            // For now all this should be done only in debug mode
            // till we can handle it right. @@@@@
            CASFHeaderObject* pASFHeaderObject = m_pASFHeader->GetHeaderObject();

            BYTE streamArch;
            BYTE streamAlign;

            pASFHeaderObject->GetArchitecture(streamArch);
            pASFHeaderObject->GetAlignment(streamAlign);

            if (streamArch != LITTLE_ENDIAN || streamAlign != 1)
            {
                assert(0);

                // @@@@ We have to change the index header we wrote to
                // *((BYTE*) m_pShared + m_pShared->pIndexHeader). We also have to change
                // CDVRIndexObject to not merely copy DWORDs and WORDs
                // into m_pShared's index, but byte swap them first.
                // Either that, or we can't just write the bytes from
                // m_pShared's index into a file; we have to byte swap first.
            }
#endif

            CASFPropertiesObject *pProps = m_pASFHeader->GetPropertiesObject();

            if (pProps)
            {
                HRESULT hrTmp = pProps->GetMmsID(m_mmsID);

                if (FAILED(hrTmp))
                {
                    // Currently does not fail
                    assert(0);
                }
                else if (m_bIndexing)
                {

                    // Update the mmsID in the index GUID
                    assert(m_pShared);

                    hrTmp = m_Index.SetMmsID(m_mmsID);

                    if (FAILED(hrTmp))
                    {
                        // Currently SetMmsID does not fail
                        assert(0);
                    }

                    // We do not use the index header that is saved to m_hTempIndexFile.
                    // If we did, update it there as well. @@@@@
                }
            }

            CDVRASFMMStream* pDVRHeader = (CDVRASFMMStream*) m_pASFHeader;

            assert(pDVRHeader->GetPropertiesOffset() < MAXDWORD &&
                   pDVRHeader->GetDataOffset() < MAXDWORD);

            // Now initialize the fudge bytes;
            DWORD i = 0;
            DWORD dwCurrentFudgeIndex = 0; // index into m_pShared->pFudgeBytes

            // First the data object.

            CDVRASFDataObject DVRDataObject;

            DVRDataObject.FudgeBytes(m_pShared, i, dwCurrentFudgeIndex, pDVRHeader->GetDataOffset(),
                                     MAXQWORD - MAXDWORD - m_cbHeader);

            // Next the properties object

            CDVRASFPropertiesObject DVRPropertiesObject(*pProps);

            DVRPropertiesObject.FudgeBytes(m_pShared,
                                           i,
                                           dwCurrentFudgeIndex,
                                           pDVRHeader->GetPropertiesOffset(),
                                           m_bIndexing);

            // We want to hold just the right number of fudge elements to
            // save shared memory space
            assert(i == CDVRSharedMemory::MAX_FUDGE);

            // We let sizeof(CDVRSharedMemory::pFudgeBytes) extend up to the next QWORD aligned address
            // because CDVRSharedMemory is QWORD aligned anyway.
            assert(dwCurrentFudgeIndex <= sizeof(m_pShared->pFudgeBytes));
            assert(((dwCurrentFudgeIndex + sizeof(QWORD)) & (~(sizeof(QWORD) - 1))) >=
                   sizeof(m_pShared->pFudgeBytes)
                  );

            // The offsets are sorted in decreasing order. We just assert this.

            for (i--; i != 0; i--)
            {
                assert(m_pShared->FudgeOffsets[i].dwEndOffset < m_pShared->FudgeOffsets[i-1].dwEndOffset);
                assert(m_pShared->FudgeOffsets[i].dwStartOffset < m_pShared->FudgeOffsets[i-1].dwStartOffset);
                assert(m_pShared->FudgeOffsets[i].dwStartOffset < m_pShared->FudgeOffsets[i-1].dwEndOffset);
            }

        }
        break;
    }

    // __finally
    // {
    m_pShared->qwCurrentFileSize = m_cbCurrentFileSize;
    ::ReleaseMutex(m_hMutex);
    // }


    return hr;

} // CDVRSink::OnHeader


////////////////////////////////////////////////////////////////////////////
HRESULT CDVRSink::SetupIndex()
{
    // We really don't have to do anything in this fn. But we create an indexer
    // so that we don't have to kludge InternalClose to set the SEEKABLE
    // flag

    // Note that we could call the base class to do this, but if we did that
    // then we'll have to remove the index param objects from the header.

    CASFPropertiesObject *pProps = m_pASFHeader->GetPropertiesObject();
    if ( !pProps )
    {
        return( E_FAIL );
    }

    DWORD cbMinPacketSize = 0;
    DWORD cbMaxPacketSize = 0;
    pProps->GetMinPacketSize( cbMinPacketSize );
    pProps->GetMaxPacketSize( cbMaxPacketSize );
    assert( cbMinPacketSize == cbMaxPacketSize &&
            "The simple (ASF v1) index requires fixed-size packets!" );

    if (!m_fHeaderReceived && m_dwIndexStreamId != MAXDWORD)
    {
        HRESULT hr;
        LISTPOS pos = NULL;
        CASFLonghandObject *pObject = NULL;

        hr = m_pASFHeader->GetFirstObjectPosition(pos);

        if (FAILED(hr))
        {
            return hr;
        }

        pObject = NULL;
        while (pos &&
               SUCCEEDED(m_pASFHeader->GetNextObject( &pObject, pos)))
        {
            GUID guidObject;
            hr = pObject->GetObjectID(guidObject);
            if (FAILED(hr))
            {
                pObject->Release();
                return hr;
            }

            if (CLSID_CAsfStreamPropertiesObjectV1 == guidObject)
            {
                //
                // Another stream, is it video?
                //
                CASFStreamPropertiesObject *pSPO =
                    (CASFStreamPropertiesObject *) pObject;

                GUID guidStreamType = GUID_NULL;
                pSPO->GetStreamType(guidStreamType);

                if (guidStreamType == CLSID_AsfXStreamTypeIcmVideo)
                {
                    // Is it the stream we've been asked to index?

                    WORD wStreamNumber = 0;

                    hr = pSPO->GetStreamNumber(wStreamNumber);
                    if (FAILED(hr))
                    {
                        pObject->Release();
                        return hr;
                    }
                    if (wStreamNumber != m_dwIndexStreamId)
                    {
                        // Trouble. There is a video stream whose
                        // stream number is smaller than the one
                        // we've been asked to index. The reader will
                        // interpret the index to be the one for the
                        // first video stream. May as well bail out.

                        assert(!"Stream to be indexed is not the first video stream");
                        pObject->Release();
                        return E_FAIL;
                    }

                    //
                    // Create an indexer - as noted above, this is not
                    // really used except for the side-effect of setting
                    // m_StreamNumberToIndex[m_dwIndexStreamId] which is
                    // used to set the SEEKABLE flag
                    hr = CreateIndexer(pSPO, cbMinPacketSize);
                    if (FAILED(hr))
                    {
                        pObject->Release();
                        return hr;
                    }

                    // For now, since we index at most 1 stream
                    pObject->Release();
                    break;
                }
            }
            pObject->Release();
        }
    }

    return S_OK;

} // CDVRSink::SetupIndex()

////////////////////////////////////////////////////////////////////////////
HRESULT CDVRSink::GenerateIndexEntries( PACKET_PARSE_INFO_EX& parseInfoEx,
                                        CPayloadMapEntryEx *payloadMap )
{
    assert(!m_fStopped && ShouldWriteData());
    assert(m_pShared);
    assert(m_hMutex);

    HRESULT hrIndex = S_OK;

    __try
    {
        // Ignore the returned value because readers are expected
        // to only read the shared section (except for the Readers array).
        // If they abandon the mutex, that's ok

        ::WaitForSingleObject(m_hMutex, INFINITE);
        m_pShared->dwLastOwnedByWriter = 1;
        assert(m_pShared->dwWriterAbandonedMutex == 0);

        m_pShared->qwCurrentFileSize = m_cbCurrentFileSize;

        if (m_cbCurrentFileSize > m_pShared->qwIndexHeaderOffset)
        {
            // We have exceeded our bounds and are encroaching into the
            // index's space. We continue writing here; however, live
            // readers will NOT be able to access the data beyond
            // m_pShared->qwIndexHeaderOffset because they'll interpret it
            // as an offset for the index. Also, the DVR IStream Source makes
            // the ASF file source (the reader) believe that the size of the
            // data unit is m_pShared->qwIndexHeaderOffset less the size of the
            // ASF header.
            // Once the file has been completely written (index copied over).
            // the file will be readable, provided that the data + index size is <= 2^64.

            // Assert here, but continue. In practice, we'll never hit
            // a file size so big.

            // This assert will be hit on every subsequent write, we can finesse
            // this if this actually becomes an issue.
            assert(!"File data size overflow. Live readers will be confused. Ignoring ...");
        }

        m_pShared->msLastPresentationTime = m_msLargestPresTimeWritten -  m_qwPreroll;

        // Notify readers whose read requests have been satisfied.
        // Note that the waiting reader will grab the mutex next, so
        // as long as we hold the mutex, we can update the fields in any
        // order
        for (int i = 0; i < CDVRSharedMemory::MAX_READERS; i++)
        {
            if (m_pShared->Readers[i].dwMsg == CDVRSharedMemory::CReaderInfo::DVR_READER_REQUEST_READ &&
                m_pShared->Readers[i].qwReaderOffset <= m_cbCurrentFileSize)
            {
                assert(m_pShared->Readers[i].dwEventSuffix);
                if (!m_hReaderEvent[i] && !m_bReaderEventOpenFailed[i])
                {
                    // Ignore the result, The reader won't be signaled
                    // This is bad but there's little we can do.
                    OpenEvent(i);
                }
                if (m_hReaderEvent[i])
                {
                    ::SetEvent(m_hReaderEvent[i]);
                }
                m_pShared->Readers[i].dwMsg = CDVRSharedMemory::CReaderInfo::DVR_READER_REQUEST_NONE;
            }
            else if (m_pShared->Readers[i].dwMsg == CDVRSharedMemory::CReaderInfo::DVR_READER_REQUEST_DONE)
            {
                // @@@@ Consider: Put a writer event in CDVRSharedMemory and have
                // the reader signal it when it is done and have a thread pool thread
                // monitor this event and do the following. Don't really need this
                // as we have ample reader slots.
                if (m_hReaderEvent[i])
                {
                    ::CloseHandle(m_hReaderEvent[i]);
                    m_hReaderEvent[i] = NULL;
                }
                m_bReaderEventOpenFailed[i] = 0;
                m_pShared->Readers[i].dwEventSuffix = 0;
                m_pShared->Readers[i].dwMsg = CDVRSharedMemory::CReaderInfo::DVR_READER_REQUEST_NONE;
            }
        }

        if (!m_bIndexing)
        {
            __leave;
        }

        assert(m_dwIndexStreamId != MAXDWORD);
        assert(m_cnsIndexGranularity != 0);

        // Generate index entries
        // Adapted from CASFChopper::ScanInputPackets in sdk\indexer\ocx\index.cpp

        m_dwNumPackets++;

        if (m_bInsideKeyFrame)
        {
            DWORD dwObjectID;

            // drop this assertion if it is violated. It looks like it should be true
            assert(m_dwLastKey == m_dwCurrentObjectID);

            //
            // Check and see if this packet contains the END of
            // a previous key frame
            //
            if (PacketContainsKeyEnd(&parseInfoEx, payloadMap, m_dwLastKey, m_dwIndexStreamId, m_qwLastKeyTime, dwObjectID) ||
                dwObjectID != m_dwCurrentObjectID)
            {
                m_bInsideKeyFrame = FALSE;

                WORD wTempSpan;

                wTempSpan = (WORD) (m_dwNumPackets - m_dwLastKeyStart);

                //
                // Have to special case the first key frame as all
                // of the indices before the first key frame point to
                // the future. The rest point to the past.
                //
                if (INVALID_KEY_SPAN == m_wLastKeySpan)
                {
                    for (; m_cnsLastIndexedTime <= m_qwLastKeyTime; m_cnsLastIndexedTime += m_cnsIndexGranularity)
                    {
                        hrIndex = m_Index.SetNextIndex(m_dwLastKeyStart, wTempSpan);
                        if (FAILED(hrIndex))
                        {
                            assert(0);
                            __leave;
                        }
                    }
                }
                m_wLastKeySpan = wTempSpan;
            }
        }

        if (!m_bInsideKeyFrame)
        {
            while (1)
            {
                //
                // Find all of the key frame starts and ends in this packet.
                //
                QWORD qwPreviousKeyTime = m_qwLastKeyTime;

                if (!PacketContainsKeyStart(&parseInfoEx, payloadMap, m_dwIndexStreamId, m_dwLastKey, m_qwLastKeyTime, m_dwCurrentObjectID))
                {
                    break;;
                }

                m_bInsideKeyFrame = TRUE;

                //
                // Make sure we wait until we find the second key frame
                // before filling in the indices. This allows us to figure out
                // the packet span of the first key frame before filling
                // in the entry.
                //
                if (m_wLastKeySpan != INVALID_KEY_SPAN)
                {
                    for (; m_cnsLastIndexedTime >= qwPreviousKeyTime && m_cnsLastIndexedTime < m_qwLastKeyTime;
                         m_cnsLastIndexedTime += m_cnsIndexGranularity)
                    {
                        hrIndex = m_Index.SetNextIndex(m_dwLastKeyStart, m_wLastKeySpan);
                        if (FAILED(hrIndex))
                        {
                            assert(0);
                            __leave;
                        }
                    }
                }

                //
                // Subtract one because we don't count the current packet
                //
                m_dwLastKeyStart = m_dwNumPackets - 1;

                // drop this assertion if it is violated. It looks like it should be true
                assert(m_dwLastKey == m_dwCurrentObjectID);

                DWORD   dwObjectID;

                if (!PacketContainsKeyEnd(&parseInfoEx, payloadMap, m_dwLastKey, m_dwIndexStreamId, m_qwLastKeyTime, dwObjectID) &&
                     dwObjectID == m_dwCurrentObjectID)
                {
                    break;
                }

                m_bInsideKeyFrame = FALSE;

                // drop this assertion if it is violated. It looks like it should be true
                assert(m_dwLastKey == m_dwCurrentObjectID);
                //
                // Have to special case the first key frame as all
                // of the indices before the first key frame point to
                // the future. The rest point to the past.
                //
                if (INVALID_KEY_SPAN == m_wLastKeySpan)
                {
                    for (; m_cnsLastIndexedTime <= m_qwLastKeyTime; m_cnsLastIndexedTime += m_cnsIndexGranularity)
                    {
                        hrIndex = m_Index.SetNextIndex(m_dwLastKeyStart, 1);
                        if (FAILED(hrIndex))
                        {
                            assert(0);
                            __leave;
                        }
                    }
                }
                m_wLastKeySpan = 1;
            }
        }
    }
    __finally
    {
        if (FAILED(hrIndex))
        {
            // Stop indexing, but do not return an error. The reader can access
            // the index that we have generated so far.

            if (m_hTempIndexFile)
            {
                ::CloseHandle(m_hTempIndexFile);
                m_hTempIndexFile = NULL;
            }

            // This turns off indexing for all subsequent files that
            // are opened till EndWriting is called.
            m_dwIndexStreamId = MAXDWORD;

            // This turns off indexing for the file that is opened
            m_bIndexing = 0;
        }

        ::ReleaseMutex(m_hMutex);
    }

#if defined(DVR_UNOFFICIAL_BUILD)

    DWORD dwLastError;
    LARGE_INTEGER nMoveBy;

    nMoveBy.QuadPart = 0;

    __try
    {
        if (m_dwFileCreationDisposition != CREATE_ALWAYS ||
            m_cbFileExtendThreshold == 0)
        {
            __leave;
        }
        if (m_cbEOF < m_cbFileExtendThreshold)
        {
            while (m_cbEOF <= m_cbCurrentFileSize)
            {
                m_cbEOF += m_cbFileExtendThreshold;
            }
            nMoveBy.QuadPart = m_cbEOF - m_cbCurrentFileSize;
        }
        else if (m_cbCurrentFileSize >= m_cbEOF - m_cbFileExtendThreshold/2)
        {
            m_cbEOF += m_cbFileExtendThreshold;
            nMoveBy.QuadPart = m_cbEOF - m_cbCurrentFileSize;
        }

        if (nMoveBy.QuadPart > 0)
        {
            if (!::SetFilePointerEx(m_hRecordFile, nMoveBy, NULL, FILE_CURRENT))
            {
                nMoveBy.QuadPart = 0;
                dwLastError = ::GetLastError(); // for debugging only
                __leave;
            }
            nMoveBy.QuadPart = -nMoveBy.QuadPart;
            if (!::SetEndOfFile(m_hRecordFile))
            {
                dwLastError = ::GetLastError(); // for debugging only
                __leave;
            }
            if (!::SetFileValidData(m_hRecordFile, m_cbEOF)) // @@@@@ SetFileValidData accepts only a LONGLONG, not a ULONGLONG
            {
                dwLastError = ::GetLastError(); // for debugging only

                // Don't try to extend the valid data size any more
                m_cbFileExtendThreshold = 0;
                __leave;
            }
        }
    }
    __finally
    {
        if (nMoveBy.QuadPart != 0)
        {
            if (!::SetFilePointerEx(m_hRecordFile, nMoveBy, NULL, FILE_CURRENT))
            {
                // All messed up

                dwLastError = ::GetLastError(); // for debugging only
                assert(0);
            }
        }
    }

#endif // if defined(DVR_UNOFFICIAL_BUILD)


    return S_OK;

} // CDVRSink::GenerateIndexEntries


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSink::OnEndWriting()
{
    // Parent class does not lock. But it calls InternalClose, which does
    // and the parent class' OnEndWriting doesn't do a lot more than that
    // (e.g., no notifications, etc). So it's unlikely that they don't lock
    // because of potential deadlocks. So it should be safe to lock here.

    AutoLock<Mutex> lock( m_GenericMutex );

    HRESULT hr = CWMFileSinkV1::OnEndWriting();

    m_dwIndexStreamId = MAXDWORD;
    ::ZeroMemory(&m_mmsID, sizeof(m_mmsID));
    m_bOpenedOnce = 0;
    m_cnsLastIndexedTime = 0;
    m_qwLastKeyTime = 0;
    m_dwLastKey = ~0; // Could as well be 0, not used till it is initialized in PacketContainsKeyStart
    m_dwLastKeyStart = 0;
    m_dwCurrentObjectID = 0;
    m_dwNumPackets = 0;
    m_bInsideKeyFrame = FALSE;
    m_wLastKeySpan = INVALID_KEY_SPAN;


    return hr;

} // CDVRSink::OnEndWriting


////////////////////////////////////////////////////////////////////////////

// Stop and Start are not supported. The file sink squishes out the
// time period between Stop and Start. We want to support seek times
// relative to the original time line, not the squished one. If we
// support Start and Stop, a layer above this will have to adjust
// Seek times to account for the time duration for which we are stopped.
// Moreover, we'd have to save the squished time duration and the Stop
// times to the file so that we can do the same thing when the file is
// played back. (If we don't readers that read the ring buffer would see
// the original time line, and those that read the file would see the
// sqished time line.)
//
// Note that the DVR I/O layer does this specially for the time duration
// that is squished out at the start of the file by the file sink. The file
// sink forces the presentation time of the first sample to be 0 and when
// the sample is read out of the SDK, its presentation time is returned as 0.
// It does that only for "live viewing" (reader reading out of the ring buffer)
// rather than for file playbacks. For file playbacks, this onl yhas the effect
// of offsetting the time line (the origin is changed and the total playback
// time is reduced). Other than that initial segment, the original time line
// and the file playback time line have a one-to-one correspondence.

STDMETHODIMP CDVRSink::Start(QWORD cnsTime)
{
    return E_NOTIMPL;
} // CDVRSink::Start


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSink::Stop(QWORD cnsTime)
{
    return E_NOTIMPL;
} // CDVRSink::Stop


/////////////////////////////////////////////////////////////////////////////
// Adapted from CASFChopper::PacketContainsKeyStart in sdk\indexer\ocx\index.cpp
BOOL CDVRSink::PacketContainsKeyStart(const PACKET_PARSE_INFO_EX* pParseInfoEx,   // IN
                                      const CPayloadMapEntryEx*   pPayloadMap,    // IN
                                      DWORD                       dwStreamId,     // IN
                                      DWORD&                      rdwKey,         // OUT
                                      QWORD&                      rqwKeyTime,     // IN, OUT
                                      DWORD&                      rdwObjectID     // OUT changed even if start
                                                                                  // of key frame not found
                                     )
{
    QWORD   qwPreviousTime = rqwKeyTime;

    //
    // We want to loop through the payloads and look for the one that is the
    // beginning of a key frame (any key frame)
    //
    for (DWORD dwPayload = 0; dwPayload < pParseInfoEx->cPayloads; dwPayload++)
    {
        CPayloadMapEntryEx* pPayload = (CPayloadMapEntryEx*) &pPayloadMap[dwPayload];

        //
        // Check stream id
        //
        DWORD dwPayloadStreamId = (DWORD) pPayload->StreamId();

        rdwObjectID = (DWORD) pPayload->ObjectId();

        if (dwStreamId != dwPayloadStreamId)
        {
            continue;
        }

        //
        // See if it's a key frame
        //
        BOOL fKey = pPayload->IsKeyFrame();

        if (!fKey)
        {
            continue;
        }

        //
        // It's the start of a key frame if the offset == 0
        //
        DWORD dwOffset = pPayload->ObjectOffset();

        if (dwOffset != 0)
        {
            continue;
        }

        //
        // Save the object id
        //
        rdwKey = rdwObjectID;

        //
        // Get the presentation time
        //
        QWORD qwTempTime = pPayload->ObjectPres() * ((QWORD) 10000);

        if (qwTempTime > qwPreviousTime)
        {
            rqwKeyTime = qwTempTime;
            return TRUE;
        }
    }

    return 0;

} // CDVRSink::PacketContainsKeyStart

/////////////////////////////////////////////////////////////////////////////
// Adapted from CASFChopper::PacketContainsKeyEnd in sdk\indexer\ocx\index.cpp
BOOL CDVRSink::PacketContainsKeyEnd(const PACKET_PARSE_INFO_EX* pParseInfoEx,     // IN
                                    const CPayloadMapEntryEx*   pPayloadMap,      // IN
                                    DWORD                       dwKey,            // IN
                                    DWORD                       dwStreamId,       // IN
                                    QWORD                       qwKeyTime,        // IN
                                    DWORD&                      rdwObjectID       // OUT
                                   )
{
    //
    // We want to loop through the payloads and look for the one that completes
    // this key frame. ( objectID == dwKey )
    //
    for (DWORD dwPayload = 0; dwPayload < pParseInfoEx->cPayloads; dwPayload++)
    {
        CPayloadMapEntryEx* pPayload = (CPayloadMapEntryEx*) &pPayloadMap[dwPayload];

        //
        // Check stream id
        //
        DWORD dwPayloadStreamId = (DWORD) pPayload->StreamId();

        if (dwStreamId != dwPayloadStreamId)
        {
            continue;
        }


        //
        // Check if this is the object we're looking for
        //
        rdwObjectID = (DWORD) pPayload->ObjectId();

        if (rdwObjectID != dwKey)
        {
            continue;
        }

        //
        // Make sure it's a key frame
        //
        BOOL fKey = pPayload->IsKeyFrame();

        if (!fKey)
        {
            continue;
        }

        //
        // Get the replication data
        //
        DWORD cbData = (DWORD) pPayload->RepDataSize();

        //
        // Make sure this is part of the key frame
        // we're looking for by getting the
        // presentation time.
        //
        QWORD qwTempTime = pPayload->ObjectPres() * ((QWORD) 10000);;

        if (qwTempTime == qwKeyTime)
        {
            //
            // It is the end of the key frame if:
            // offset + payload size == total object size OR
            // if the payload is compressed
            //

            //
            // Check for compressed payload. If so, this is the
            // end of the key frame
            //
            if (1 == cbData)
            {
                return TRUE;
            }

            // Simple payload

            DWORD dwOffset = pPayload->ObjectOffset();

            cbData = pPayload->PayloadSize();

            DWORD cbObjectSize = pPayload->ObjectSize();

            if (dwOffset + cbData == cbObjectSize)
            {
                return TRUE;
            }
        }
    }

    return FALSE;

} // CDVRSink::PacketContainsKeyEnd

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSink::GetMode(DWORD *pdwFileSinkMode)
{
    if (NULL == pdwFileSinkMode)
    {
        return E_POINTER;
    }

#if defined(DVR_UNOFFICIAL_BUILD)

    if (m_dwCopyBuffersInASFMux)
    {
        *pdwFileSinkMode = WMT_FM_SINGLE_BUFFERS;
    }
    else
    {
#endif // if defined(DVR_UNOFFICIAL_BUILD)

        *pdwFileSinkMode = WMT_FM_FILESINK_DATA_UNITS;

#if defined(DVR_UNOFFICIAL_BUILD)
    }
#endif // if defined(DVR_UNOFFICIAL_BUILD)

    return S_OK;

} // CDVRSink::GetMode

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSink::SetAutoIndexing(BOOL fDoAutoIndexing)
{
    return E_NOTIMPL;

} // CDVRSink::SetAutoIndexing

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDVRSink::GetAutoIndexing(BOOL *pfAutoIndexing)
{
    if (!pfAutoIndexing)
    {
        return E_INVALIDARG;
    }

    *pfAutoIndexing = m_dwIndexStreamId == MAXDWORD? 0 : 1;

    return S_OK;

} // CDVRSink::GetAutoIndexing

////////////////////////////////////////////////////////////////////////////
void
CDVRSink::FlushToDiskLocked (
    )
{
    ULONGLONG   ullTotalBytes ;

    AutoLock<Mutex> lock( m_GenericMutex );

    if (m_pIDVRAsyncWriter) {
        //  flush all the content we have to disk
        m_pIDVRAsyncWriter -> FlushToDisk () ;
    }
}

////////////////////////////////////////////////////////////////////////////
HRESULT
CDVRSink::Write (
    IN   BYTE *  pbBuffer,
    IN   DWORD   dwBufferLength,
    OUT  DWORD * pdwBytesWritten
    )
{
    HRESULT hr ;

    if (m_pIDVRAsyncWriter) {

        //  assume success
        (* pdwBytesWritten) = dwBufferLength ;

        hr = m_pIDVRAsyncWriter -> AppendBytes (
                & pbBuffer,
                & dwBufferLength
                ) ;

        if (FAILED (hr)) {
            (* pdwBytesWritten) = 0 ;
            hr = NS_E_FILE_WRITE;
        }
        else {
            //  should have been consumed completely
            assert (dwBufferLength == 0) ;
        }
    }
    else {
        hr = CWMFileSinkV1::Write (pbBuffer, dwBufferLength, pdwBytesWritten) ;
    }

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\wmsdk\zeusette\sdk\writer\sink\dvrsink\dvrsink.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       DVRSink.h
//
//  Classes:    CDVRSink, CDVRIndexObject
//
//  Contents:   Definition of the CDVRSink and CDVRIndexObject classes
//              Inline implementation of all CDVRIndexObject methods
//
//--------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __DVRSINK_H_
#define __DVRSINK_H_

#include "wmsdk.h"
#include "wmsstd.h"
#include "writerstate.h"
#include "asfmmstr.h"
#include "debughlp.h"
#include "sync.h"
#include "Basefilter.h"
#include "tordlist.h"
#include "wmsdkbuffer.h"
#include "FileSinkV1.h"
#include "asfobj.h"
#include "asfmmstr.h"
#include "asfguids.h"
#include "DVRFileSink.h"
#include "DVRSharedmem.h"

/////////////////////////////////////////////////////

class CDVRASFMMStream : public CASFMMStream
{
    QWORD   m_qwProperties; // Offset of properties object from start of file (start of header)
    QWORD   m_qwData;       // Offset of data header from start of file (start of header)

public:

    CDVRASFMMStream(BYTE hostArch = LITTLE_ENDIAN,
                    BYTE streamArch = LITTLE_ENDIAN,
                    BOOL fStrict = TRUE)
    : CASFMMStream(hostArch, streamArch, fStrict)
    , m_qwProperties(MAXQWORD)
    , m_qwData(MAXQWORD)
    {
    } // CDVRASFMMStream

    virtual ~CDVRASFMMStream() {};

    static CASFMMStream* __stdcall CreateInstance(BYTE hostArch = LITTLE_ENDIAN,
                                                  BYTE streamArch = LITTLE_ENDIAN,
                                                  BOOL fStrict = TRUE)
    {
        return new CDVRASFMMStream(hostArch, streamArch, fStrict);
    } // CreateInstance

    virtual HRESULT CreateHeaderObject(CASFLonghandObject **ppObject, CASFArchive& ar)
    {
        HRESULT hr = CASFMMStream::CreateHeaderObject(ppObject, ar);

        if (SUCCEEDED(hr))
        {
            GUID                        objectID;
            QWORD                       cbObject;

            // This code assumes that ar.Base() is the start of the header,
            // which it is (currently); see CASFMMStream::LoadHeader() in
            // core\asflib\asfmmstr.cpp. @@@@

            (*ppObject)->GetObjectID(objectID);
            if (objectID == CLSID_CAsfPropertiesObjectV0 ||
                objectID == CLSID_CAsfPropertiesObjectV1 ||
                objectID == CLSID_CAsfPropertiesObjectV2)
            {
               hr = (*ppObject)->GetSize(cbObject);
               if (FAILED(hr))
               {
                   assert(0);
                   delete (*ppObject);
                   return hr;
               }
               m_qwProperties = ar.Position() - ar.Base() - cbObject;
               assert(m_qwProperties <= MAXDWORD); // We assume this in the fudge offsets in CDVRSharedMemory
            }

            // The data header object is not considered a header object
            // although it is supplied to OnHeader as part of the ASF header.
            // CASFMMStream::LoadHeader (in core\asflib\asfmmstr.cpp) which
            // calls this function assumes that the data object is right
            // after all the header objects. The following code does the
            // same - update m_qwData each time and the last update
            // should set it to the right value.
            //
            // WAS:
            // else if (objectID == CLSID_CAsfDataObjectV0)
            // {
            //    hr = (*ppObject)->GetSize(cbObject);
            //    if (FAILED(hr))
            //    {
            //        assert(0);
            //        delete (*ppObject);
            //        return hr;
            //    }
            //    m_qwData = ar.Position() - ar.Base() - cbObject;
            //    assert(m_qwData <= MAXDWORD); // We assume this in the fudge offsets in CDVRSharedMemory
            // }

            m_qwData = ar.Position() - ar.Base();
            assert(m_qwData <= MAXDWORD); // We assume this in the fudge offsets in CDVRSharedMemory
        }

        return hr;
    } // CreateHeaderObject

    DWORD GetPropertiesOffset() { return (DWORD) m_qwProperties; };
    DWORD GetDataOffset() { return (DWORD) m_qwData; };

}; // class CDVRASFMMStream

/////////////////////////////////////////////////////

class CDVRASFDataObject : public CASFDataObject
{
public:
    void FudgeBytes(CDVRSharedMemory* pShared,
                    DWORD& i,                   // IN OUT, index into pShared->FudgeOffsets
                    DWORD& dwCurrentFudgeIndex, // IN OUT, index into pShared->pFudgeBytes
                    DWORD  dwDataOffset,
                    QWORD  qwSize
                   )
    {
        // Add this object's size
        qwSize += Space();

        assert(i < sizeof(pShared->FudgeOffsets)/sizeof(pShared->FudgeOffsets[0]));

        // Following assumes that CASFLonghandObject stores a GUID before the size field @@@@
        pShared->FudgeOffsets[i].dwStartOffset = dwDataOffset +
                                                 sizeof(m_objectID.Data1) + sizeof(m_objectID.Data2) +
                                                 sizeof(m_objectID.Data3) + sizeof(m_objectID.Data4);
        pShared->FudgeOffsets[i].dwEndOffset = pShared->FudgeOffsets[i].dwStartOffset + sizeof(QWORD) - 1;
        pShared->FudgeOffsets[i].pFudgeBytes = dwCurrentFudgeIndex;

        assert(dwCurrentFudgeIndex + pShared->FudgeOffsets[i].dwEndOffset -
               pShared->FudgeOffsets[i].dwStartOffset + 1 <= sizeof(pShared->pFudgeBytes));

        // @@@@ Unresolved endian issue here. Assumes byte order in memory and the file are the same.
        ::CopyMemory(&pShared->pFudgeBytes[dwCurrentFudgeIndex], (BYTE*) &qwSize, sizeof(QWORD));
        dwCurrentFudgeIndex += sizeof(QWORD);
        i++;
    }

}; // class CDVRASFDataObject

/////////////////////////////////////////////////////

class CDVRASFPropertiesObject : public CASFPropertiesObject
{
public:
    CDVRASFPropertiesObject(const CASFPropertiesObject& rp)
        : CASFPropertiesObject(rp)
    {
    }
    void FudgeBytes(CDVRSharedMemory* pShared,
                    DWORD& i,                   // IN OUT, index into pShared->FudgeOffsets
                    DWORD& dwCurrentFudgeIndex, // IN OUT, index into pShared->pFudgeBytes
                    DWORD  dwPropertiesOffset,
                    BOOL   bIndexing
                   )
    {
        DWORD dwOffset;

        dwOffset = dwPropertiesOffset + CASFLonghandObject::Space();

        if (m_version < 2)
        {
            dwOffset += sizeof(m_clockType.Data1) + sizeof(m_clockType.Data2) +
                        sizeof(m_clockType.Data3) + sizeof(m_clockType.Data4);
        }
        dwOffset += sizeof(m_mmsID.Data1) + sizeof(m_mmsID.Data2) +
                    sizeof(m_mmsID.Data3) + sizeof(m_mmsID.Data4);
        dwOffset += sizeof(m_totalSize) + sizeof(m_createTime) + sizeof(m_cInterleavedPackets) + sizeof(m_playDuration);
        if (m_version != 0)
        {
            dwOffset += sizeof(m_sendDuration);
        }
        dwOffset += sizeof(m_preroll);

        DWORD dwFlags = m_flags;

        dwFlags &= ~CASFPropertiesObject::LIVE;
        dwFlags &= ~CASFPropertiesObject::BROADCAST;
        if (bIndexing)
        {
            dwFlags |= CASFPropertiesObject::SEEKABLE;
        }
        else
        {
            dwFlags &= ~CASFPropertiesObject::SEEKABLE;
        }

        assert(i < sizeof(pShared->FudgeOffsets)/sizeof(pShared->FudgeOffsets[0]));

        pShared->FudgeOffsets[i].dwStartOffset = dwOffset;
        pShared->FudgeOffsets[i].dwEndOffset = pShared->FudgeOffsets[i].dwStartOffset + sizeof(DWORD) - 1;
        pShared->FudgeOffsets[i].pFudgeBytes = dwCurrentFudgeIndex;

        assert(dwCurrentFudgeIndex + pShared->FudgeOffsets[i].dwEndOffset -
               pShared->FudgeOffsets[i].dwStartOffset + 1 <= sizeof(pShared->pFudgeBytes));

        // @@@@ Unresolved endian issue here. Assumes byte order in memory and the file are the same.
        ::CopyMemory(&pShared->pFudgeBytes[dwCurrentFudgeIndex], (BYTE*) &dwFlags, sizeof(DWORD));
        dwCurrentFudgeIndex += sizeof(DWORD);
        i++;

        dwOffset -= sizeof(m_preroll);
        if (m_version != 0)
        {
            QWORD qwSend = MAXQWORD;  // Send duration. Readers asserts if this is 0.

            dwOffset -= sizeof(m_sendDuration);
            assert(i < sizeof(pShared->FudgeOffsets)/sizeof(pShared->FudgeOffsets[0]));

            pShared->FudgeOffsets[i].dwStartOffset = dwOffset;
            pShared->FudgeOffsets[i].dwEndOffset = pShared->FudgeOffsets[i].dwStartOffset + sizeof(QWORD) - 1;
            pShared->FudgeOffsets[i].pFudgeBytes = dwCurrentFudgeIndex;

            assert(dwCurrentFudgeIndex + pShared->FudgeOffsets[i].dwEndOffset -
                   pShared->FudgeOffsets[i].dwStartOffset + 1 <= sizeof(pShared->pFudgeBytes));

            // @@@@ Unresolved endian issue here. Assumes byte order in memory and the file are the same.
            ::CopyMemory(&pShared->pFudgeBytes[dwCurrentFudgeIndex], (BYTE*) &qwSend, sizeof(QWORD));
            dwCurrentFudgeIndex += sizeof(QWORD);
            i++;
        }

        QWORD qwPlay = MAXQWORD; // @@@@ ##### Fix this

        dwOffset -= sizeof(m_playDuration);
        assert(i < sizeof(pShared->FudgeOffsets)/sizeof(pShared->FudgeOffsets[0]));

        pShared->FudgeOffsets[i].dwStartOffset = dwOffset;
        pShared->FudgeOffsets[i].dwEndOffset = pShared->FudgeOffsets[i].dwStartOffset + sizeof(QWORD) - 1;
        pShared->FudgeOffsets[i].pFudgeBytes = dwCurrentFudgeIndex;

        assert(dwCurrentFudgeIndex + pShared->FudgeOffsets[i].dwEndOffset -
               pShared->FudgeOffsets[i].dwStartOffset + 1 <= sizeof(pShared->pFudgeBytes));

        // @@@@ Unresolved endian issue here. Assumes byte order in memory and the file are the same.
        ::CopyMemory(&pShared->pFudgeBytes[dwCurrentFudgeIndex], (BYTE*) &qwPlay, sizeof(QWORD));
        dwCurrentFudgeIndex += sizeof(QWORD);
        i++;

    }

}; // class CDVRASFPropertiesObject

/////////////////////////////////////////////////////

class CDVRIndexObject : public CASFIndexObject
{
protected:
    DWORD   m_dwEmptyIndexSpace;
    DWORD   m_dwNext;               // Next array index to write to
    BOOL    m_bWrapped;             // Have we wrapped around
    DWORD*  m_ppFirstIndex;         // Pointer to CDVRSharedMemory::pFirstIndex
    DWORD   m_ppFirstIndexBase;     // Value of m_ppFirstIndex when it points to the first index entry
    HANDLE  m_hIndexFile;           // For permanent ASF files, the temporary disk file that contains the index
                                    // that is not in shared memory
    DWORD   m_cFlushed ;            // flush count to an index file; occurs every time we wrap our indexing entries
    QWORD*  m_pqwFirstIndexOffset;  // Pointer to CDVRSharedMemory::qwOffsetOfFirstIndexInSharedMemory
    QWORD*  m_pqwLastIndexOffset;   // Pointer to CDVRSharedMemory::qwOffsetOfLastIndexInSharedMemory
    QWORD*  m_pqwTotalFileSize;     // Pointer to CDVRSharedMemory::qwTotalFileSize
    QWORD*  m_pqwIndexSize;         // Pointer to the size field of the index in CDVRSharedMemory

    // Pointers into the index header that is shared memory that contains the
    // max packet value
    DWORD*  m_pdwMaxPackets;
    DWORD*  m_pdwNumEntries;
    BYTE*   m_pGUID;


protected:

    // ============= Methods we override (and that are public in the base class)

    // overrides a public method in CASFIndexObject
    // Call SetIndexParams instead of calling this method directly
    HRESULT SetEntryCount(DWORD cEntries)
    {
        m_cIndexEntries = cEntries;

        // m_rgEntries is never allocated; it is managed by us
        // So don't call the parent class
        return S_OK;
    }

    // overrides a public method in CASFIndexObject
    // This method should not be used, use SetNextIndex instead
    HRESULT SetIndexEntry(DWORD iEntry, DWORD packet, WORD cPackets)
    {
        return E_NOTIMPL;
    }

public:

    // ============= New Methods (not in base class)

    CDVRIndexObject(HRESULT *phr) : CASFIndexObject()
        , m_dwNext(0)
        , m_bWrapped(0)
        , m_ppFirstIndex(NULL)
        , m_ppFirstIndexBase(0)
        , m_hIndexFile(NULL)
        , m_pqwFirstIndexOffset(NULL)
        , m_pqwLastIndexOffset(NULL)
        , m_pqwTotalFileSize(NULL)
        , m_pqwIndexSize(NULL)
        , m_pdwMaxPackets(NULL)
        , m_pdwNumEntries(NULL)
        , m_pGUID(NULL)
        , m_cFlushed(0)
    {
        m_dwEmptyIndexSpace = Space();
    } // CDVRIndexObject

    virtual ~CDVRIndexObject()
    {
        // Don't want ~CASFIndexObject to delete m_rgEntries
        m_rgEntries = NULL;
    } // ~CDVRIndexObject


    HRESULT SetIndexParams(BYTE*  pIndexHeader = NULL,
                           BYTE*  pIndexArrayStart = NULL,
                           BYTE*  pIndexArrayEnd = NULL,
                           DWORD* ppFirstIndex = NULL,
                           DWORD  ppFirstIndexBase = 0,
                           QWORD* pqwFirstIndexOffset = NULL,
                           QWORD* pqwLastIndexOffset = NULL,
                           QWORD* pqwTotalFileSize = NULL,
                           HANDLE hTempIndexFile = NULL)
    {
        HRESULT hrRet = S_OK;

        if (pIndexHeader)
        {
            assert(pIndexArrayStart);
            assert(pIndexArrayEnd);
            assert(pIndexArrayEnd > pIndexArrayStart);
            assert(ppFirstIndex);
            assert(ppFirstIndexBase);
            assert(pqwFirstIndexOffset);
            assert(pqwLastIndexOffset);
            assert(pqwTotalFileSize);
        }
        else
        {
            assert(pIndexArrayStart == NULL);
            assert(pIndexArrayEnd == NULL);
            assert(ppFirstIndex == NULL);
            assert(ppFirstIndexBase == 0);
            assert(pqwFirstIndexOffset == NULL);
            assert(pqwLastIndexOffset == NULL);
            assert(pqwTotalFileSize == NULL);
            assert(hTempIndexFile == NULL);
        }
        m_rgEntries = (CASFIndexObject::IndexEntry*) pIndexArrayStart;
        SetEntryCount((pIndexArrayEnd - pIndexArrayStart)/IndexEntrySize());

        // Note that the m_qwSize field in CASFLonghandObject is never set and
        // should not be used. CASFIndexObject calls SetSize() to set it only
        // in CASFIndexObject::Persist(). So even the methods of CASFIndexObject
        // do not update it or use it.
        // SetSize(Space()); -- this will set it but we don't update it in SetNextIndex

        assert(Space() == m_dwEmptyIndexSpace + (DWORD) (pIndexArrayEnd - pIndexArrayStart));


        m_ppFirstIndex = ppFirstIndex;
        m_ppFirstIndexBase = ppFirstIndexBase;
        m_pqwFirstIndexOffset = pqwFirstIndexOffset;
        m_pqwLastIndexOffset = pqwLastIndexOffset;
        m_pqwTotalFileSize = pqwTotalFileSize;
        m_hIndexFile = hTempIndexFile;
        if (pIndexHeader)
        {
            // m_objectID is a protected member of CASFLonghandObject
            m_pqwIndexSize = (QWORD*) (
                                    (BYTE*) pIndexHeader +
                                    // Note: Should not use sizeof GUID here, though the results will be
                                    // the same. This is because our index header held in memory has a
                                    // packing of 1, see comment in SetNextIndex.
                                     sizeof(m_objectID.Data1) + sizeof(m_objectID.Data2) + sizeof(m_objectID.Data3) +
                                     sizeof(m_objectID.Data4));

            // See CASFIndexObject::Persist and CASFArchive::StoreGUID
            m_pGUID = (BYTE*) pIndexHeader + CASFLonghandObject::Space();
            m_pdwMaxPackets = (DWORD*) ((BYTE*) pIndexHeader + CASFLonghandObject::Space() +
                                        // Note: Should not use sizeof GUID here, though the results will be
                                        // the same. This is because our index header held in memory has a
                                        // packing of 1, see comment in SetNextIndex.
                                        sizeof(m_mmsID.Data1) + sizeof(m_mmsID.Data2) + sizeof(m_mmsID.Data3) +
                                        sizeof(m_mmsID.Data4) +
                                        sizeof(m_timeDelta));

            // Following is because m_cIndexEntries is persisted right after m_cMaxPackets
            // See CASFIndexObject::Persist
            m_pdwNumEntries = m_pdwMaxPackets + 1;

            // Assert alignment. See note in SetNextEntry on alignment
            assert(((UINT_PTR) m_pqwIndexSize & 7) == 0);
            assert(((UINT_PTR) m_pGUID & 3) == 0);
            assert(((UINT_PTR) m_pdwMaxPackets & 3) == 0);
            assert(((UINT_PTR) m_pdwNumEntries & 3) == 0);

            *m_pqwIndexSize = m_dwEmptyIndexSpace;
        }
        else
        {
            m_pqwIndexSize = NULL;
            m_pdwMaxPackets = NULL;
            m_pdwNumEntries = NULL;
            m_pGUID = NULL;
        }

        m_dwNext = 0;
        m_bWrapped = 0;

        return hrRet;

    } // SetIndexParams

    HRESULT SetNextIndex(DWORD packet, WORD cPackets)
    {
        // Caller must hold the mutex of the shared memory section
        // (CDVRSharedMemory::hMutex) before calling this method.

        HRESULT hr;

        assert(m_rgEntries);

        if (*m_pqwTotalFileSize + IndexEntrySize() <= *m_pqwTotalFileSize)
        {
            // The total file size would exceed 64 bits. We stop generating
            // the index.
            assert(!"Index size has overflowed");
            return E_FAIL;
        }

        // Note that the following updates CASFIndexObject::m_cMaxPackets
        hr = CASFIndexObject::SetIndexEntry(m_dwNext, packet, cPackets);

        if (FAILED(hr))
        {
            // This means that we wrote to an index that is >=
            // m_cIndexEntries. This should not happen

            assert(0);
            return hr;
        }

        // The following is ok for X86, see note below. File format
        // may differ from memory format for non-x86. We should save
        // the variable in the file format, not in the memory format.
        //
        // In addition to the endian issue noted below, there is the
        // issue of alignment. The index header is stored starting
        // at CDVRSharedMemory::pIndexHeader in the same format as it
        // would have if it were written to a file, specifically, it's
        // packing is 1 byte. By design, CDVRSharedMemory::pIndexHeader
        // is QWORD aligned (because CDVRSharedMemory is QWORD aligned
        // and pIndexHeader is m_pShared + sizeof(CDVRSharedMemory).
        // The archived members of CASFLonghandObject are a GUID (16 bytes)
        // and a QWORD; the archived members of CASFIndexObject are listed
        // in SetIndexParams in the order they are archived (see the
        // statement that computes the offset of m_pdwMaxPackets there).
        // Hence *m_pdwMaxPackets and 8m_pdwNumEntries are DWORD aligned.
        //
        assert(m_pdwMaxPackets);
        *m_pdwMaxPackets = m_cMaxPackets;
        assert(m_pdwNumEntries);
        (*m_pdwNumEntries)++;

        m_dwNext++;
        assert(m_pqwLastIndexOffset);
        *m_pqwLastIndexOffset += IndexEntrySize();
        assert(m_pqwTotalFileSize);
        *m_pqwTotalFileSize += IndexEntrySize();
        *m_pqwIndexSize += IndexEntrySize();

        BOOL bAlreadyWrapped = m_bWrapped;

        if (m_dwNext == m_cIndexEntries)
        {
            m_bWrapped = 1;
            if (m_hIndexFile)
            {
                // Flush to the temporary index file

                // @@@@ Note: This ASSUMES that the format of the
                // index entries in memory and on disk are identical.
                // This is OK for X86; verify for other architectures.
                // Typically, the index is written out using a CASFArchive
                // object which swaps bytes if one of the host and streaming
                // architectures is little-endian and the other big-endian
                // (see CASFIndexObject::Persist and CASFArchive methods. However,
                // the caller sets the endian-ness of both the host and the
                // streaming machines and the endian value in the ASF file
                // does not seem to get used (at least in sdk\indexer\ocx\engine.cpp).
                // See the note in CDVRSink::OnHeader()

                DWORD   cbWritten;
                DWORD   cbWrite = m_cIndexEntries * IndexEntrySize();
                BOOL    bResult;

                bResult = ::WriteFile(m_hIndexFile,
                                      (BYTE*) m_rgEntries,
                                      cbWrite,
                                      &cbWritten,
                                      NULL);

                if (!bResult || cbWritten != cbWrite)
                {
                    HRESULT dwLastError = ::GetLastError();
                    assert(0);
                    hr = HRESULT_FROM_WIN32(dwLastError);

                    // Don't write any more
                    m_hIndexFile = NULL;

                    // Update the other state variables; do not return from here
                    // This class will still support updates of and accesses from
                    // the circular ring buffer in memory.
                }

                //  one more flush
                m_cFlushed++ ;

            }
            m_dwNext = 0;
        }
        if (m_bWrapped)
        {
            assert(m_ppFirstIndex);
            if (m_dwNext == 0)
            {
                *m_ppFirstIndex = m_ppFirstIndexBase;
            }
            else
            {
                *m_ppFirstIndex += IndexEntrySize();
            }
            assert(m_pqwFirstIndexOffset);
            if (bAlreadyWrapped)
            {
                *m_pqwFirstIndexOffset += IndexEntrySize();
            }
        }
        return hr;
    } // SetNextIndex

    DWORD IndexEntrySize()
    {
        // IndexEntry is a protected member, so we need a public function
        // that returns its size.
        return sizeof(CASFIndexObject::IndexEntry);
    } // IndexEntrySize

    DWORD EmptyIndexSpace()
    {
        return m_dwEmptyIndexSpace;
    } // EmptyIndexSpace

    DWORD GetNumIndexEntryBytesNotFlushed()
    {
        DWORD   cEntriesNotFlushed ;

        if (m_cFlushed) {
            //  assume we are flushed each time we wrap
            cEntriesNotFlushed = m_dwNext ;
        }
        else {
            //  we've never been flushed; make sure that we're ok here

            if (!m_bWrapped) {
                //  never wrapped; m_dwNext is the correct count of index
                //    entries
                cEntriesNotFlushed = m_dwNext ;
            }
            else {
                //  not flushed and wrapped; we'd better not have made some more
                //    indexing entries (overwriting the good ones that existed
                //    before); the correct count is the max entries
                assert (m_dwNext == 0) ;
                cEntriesNotFlushed = m_cIndexEntries ;
            }
        }

        return cEntriesNotFlushed * IndexEntrySize () ;
    }



    // ============= Methods we override (and that are still public)

    HRESULT SetMmsID(const GUID& id)
    {
        HRESULT hr = CASFIndexObject::SetMmsID(id);

        if (FAILED(hr))
        {
            // Currently CASFIndexObject::SetMmsID does not fail
            return hr;
        }

        // Update the id in the shared memory section
        assert(m_pGUID);

        // Adapted from CASFArchive::StoreGUID. Note that what we write
        // to *m_pGUID must be packed with a packing of 1. (There is no
        // unused space between members of the GUID struct and there are
        // no endian issues for x86, so we could just do an assignment)
        //
        // @@@@ Change if not x86 for endian issues and alignment issues,
        // see comments in SetNextIndex

        DWORD* p = (DWORD*) m_pGUID;
        *p = m_mmsID.Data1;

        WORD* q = (WORD*) (m_pGUID + sizeof(DWORD));
        *q = m_mmsID.Data2;
        q++;
        *q = m_mmsID.Data3;

        BYTE* r = m_pGUID + sizeof(DWORD) + 2*sizeof(WORD);
        for (int i = 0; i < 8; i++)
        {
            *r++ = m_mmsID.Data4[i];
        }

        return S_OK;
    } // SetMmsID

}; // CDVRIndexObject

/////////////////////////////////////////////////////

class CDVRSink :
        public CWMFileSinkV1,
        public IDVRFileSink2
{
public:

    CDVRSink(HKEY hDvrKey,
             HKEY hDvrIoKey,
             DWORD dwNumSids,
             PSID* ppSids,
             HRESULT *phr,
             CTPtrArray<WRITER_SINK_CALLBACK> *pCallbacks);

    virtual ~CDVRSink();

    //
    // IUnknown methods
    //
    STDMETHOD( QueryInterface )( REFIID riid, void **ppvObject );
    STDMETHOD_( ULONG, AddRef )();
    STDMETHOD_( ULONG, Release )();

    //
    // IDVRFileSink methods
    //
    STDMETHOD( MarkFileTemporary )(BOOL bTemporary);
    STDMETHOD( SetIndexStreamId )(DWORD  dwIndexStreamId,
                                  DWORD  msIndexGranularity);
    STDMETHOD( GetIndexStreamId )(DWORD*  pdwIndexStreamId);
    STDMETHOD( SetNumSharedDataPages )(DWORD dwNumPages);
    STDMETHOD( GetMaxIndexEntries )(DWORD  dwNumPages, DWORD* pdwNumIndexEntries);
    STDMETHOD( GetNumPages )(DWORD  dwNumIndexEntries, DWORD* pdwNumPages);
    STDMETHOD( GetMappingHandles )(HANDLE* phDataFile,
                                   HANDLE* phMemoryMappedFile,
                                   HANDLE* phFileMapping,
                                   LPVOID* phMappedView,
                                   HANDLE* phTempIndexFile);

    //
    //  IDVRFileSink2 methods
    //

    STDMETHOD ( SetAsyncIOWriter ) (
        IN  IDVRAsyncWriter *   pIDVRAsyncWriter
        ) ;

    //
    // IWMWriterFileSink2 methods
    //
    // STDMETHOD( Open )( const WCHAR *pwszFilename );
    // STDMETHOD( Close )();
    // STDMETHOD( IsClosed )( BOOL *pfClosed );

    // Start and Stop are unsupported.
    STDMETHOD( Start )(QWORD cnsTime);
    STDMETHOD( Stop )(QWORD cnsTime);

    // STDMETHOD( IsStopped )( BOOL *pfStopped );
    // STDMETHOD( GetFileDuration )( QWORD* pcnsDuration );
    // STDMETHOD( GetFileSize )( QWORD* pcbFile );

    //
    // IWMWriterFileSink3 methods
    //
    STDMETHOD( SetAutoIndexing )( BOOL fDoAutoIndexing );
    STDMETHOD( GetAutoIndexing )( BOOL *pfAutoIndexing );
    STDMETHOD( GetMode )(DWORD *pdwFileSinkModes);
    // STDMETHOD( OnDataUnitEx )( WMT_FILESINK_DATA_UNIT *pFileSinkDataUnit );

    //
    // IWMWriterSink methods
    //
    STDMETHOD( OnHeader )(INSSBuffer *pHeader);
    // STDMETHOD( IsRealTime )( BOOL *pfRealTime );
    // STDMETHOD( AllocateDataUnit )( DWORD cbDataUnit, INSSBuffer **ppDataUnit );
    // STDMETHOD( OnDataUnit )(INSSBuffer *pDataUnit);
    STDMETHOD( OnEndWriting )();

    //
    // IWMRegisterCallback
    //
    // STDMETHOD( Advise )(    IWMStatusCallback* pCallback, void* pvContext );
    // STDMETHOD( Unadvise )(  IWMStatusCallback* pCallback, void* pvContext );


protected:

    void
    FlushToDiskLocked (
        ) ;

    virtual
    HRESULT
    Write (
        IN   BYTE *  pbBuffer,
        IN   DWORD   dwBufferLength,
        OUT  DWORD * pdwBytesWritten
        ) ;

    virtual HRESULT     InternalOpen(const WCHAR *pwszFilename);
    virtual HRESULT     InternalClose();
    virtual HRESULT     SetupIndex();

    virtual HRESULT     GenerateIndexEntries( PACKET_PARSE_INFO_EX& parseInfoEx,
                                              CPayloadMapEntryEx *payloadMap );

    virtual CASFMMStream* CreateMMStream(BYTE hostArch = LITTLE_ENDIAN,
                                         BYTE streamArch = LITTLE_ENDIAN,
                                         BOOL fStrict = TRUE)
    {
        return CDVRASFMMStream::CreateInstance(hostArch, streamArch, fStrict);
    }

    // Helper methods added in this class (not in the base class)
    virtual HRESULT     OpenEvent(DWORD i /* reader index */);
    virtual HRESULT     InitSharedMemory(CDVRSharedMemory* p, HANDLE& hMutex);

    virtual BOOL        PacketContainsKeyStart(const PACKET_PARSE_INFO_EX* pParseInfoEx,   // IN
                                               const CPayloadMapEntryEx*   pPayloadMap,    // IN
                                               DWORD                       dwStreamId,     // IN
                                               DWORD&                      rdwKey,         // OUT
                                               QWORD&                      rqwKeyTime,     // IN, OUT
                                               DWORD&                      rdwObjectID     // OUT changed even if start
                                                                                           // of key frame not found
                                              );

    virtual BOOL        PacketContainsKeyEnd(const PACKET_PARSE_INFO_EX* pParseInfoEx,     // IN
                                             const CPayloadMapEntryEx*   pPayloadMap,      // IN
                                             DWORD                       dwKey,            // IN
                                             DWORD                       dwStreamId,       // IN
                                             QWORD                       qwKeyTime,        // IN
                                             DWORD&                      rdwObjectID       // OUT
                                            );

protected:

    //
    // Data members
    //
    CDVRSharedMemory*   m_pShared;
    HANDLE              m_hMemoryMappedFile;
    HANDLE              m_hFileMapping;
    HANDLE              m_hTempIndexFile; // NULL if file is temporary

    GUID                m_guidWriterId ;    //  unique per writer

    // Registry key handles are opened and closed by the creator of the sink
    HKEY                m_hDvrKey;
    HKEY                m_hDvrIoKey;

    DWORD               m_dwPageSize;
    DWORD               m_dwNumPages;
    DWORD               m_dwIndexStreamId;
    QWORD               m_cnsIndexGranularity; // Unused if m_dwIndexStreamId == MAXDWORD
    BOOL                m_bTemporary;
    enum {
        DVR_SINK_CLOSED,
        DVR_SINK_OPENED,
        DVR_SINK_BEING_OPENED
    }                   m_dwOpened;
    BOOL                m_bUnmapView;
    BOOL                m_bOpenedOnce;
    BOOL                m_bIndexing;

    CDVRIndexObject     m_Index;

    IDVRAsyncWriter *   m_pIDVRAsyncWriter ;

    GUID                m_mmsID;

    // State for generating index on the fly
    static const WORD INVALID_KEY_SPAN; // = 0xFFFF

    QWORD               m_cnsLastIndexedTime;   // in 100s of nanoseconds
    QWORD               m_qwLastKeyTime;        // Presentation time of sample that was the last key frame
    HANDLE              m_hMutex;               // For the shared memory
    HANDLE              m_hReaderEvent[CDVRSharedMemory::MAX_READERS]; 
    BOOL                m_bReaderEventOpenFailed[CDVRSharedMemory::MAX_READERS];
    DWORD               m_dwLastKey;            // Object id of payload containing the last key frame
    DWORD               m_dwLastKeyStart;       // Packet number containing the last key frame start
    DWORD               m_dwCurrentObjectID;    // Same as m_dwLastKey
    DWORD               m_dwNumPackets;         // Number of packets recd so far
                                                // For reader synchronization
    BOOL                m_bInsideKeyFrame;      // Are we inside a key frame, i.e., last key frame spans packets

    DWORD               m_dwNumSids;
    WORD                m_wLastKeySpan;         // Number of packets spanned by last key frame
    PSID*               m_ppSids;

#if defined(DVR_UNOFFICIAL_BUILD)

    QWORD               m_cbEOF;
    DWORD               m_cbFileExtendThreshold;
    DWORD               m_dwCopyBuffersInASFMux;

#endif // if defined(DVR_UNOFFICIAL_BUILD)

}; // CDVRSink

#endif // __DVRSINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\wmsdk\zeusette\sdk\writer\sink\filesinkv1\filesinkv1.cpp ===
#include "stdinc.h"
#include "FileSinkV1.h"
#include "wmsdkbuffer.h"
//#include "debughlp.h"
#include "nserror.h"
#include "asfx.h"
#include "nsalign.h"
#include "wmreghelp.h"
#include "wraparound.h"
#include "wmpriv.h"

#include "findleak.h"
DECLARE_THIS_FILE;

// Index once per second
#define INDEX_TIME_DELTA 10000000

////////////////////////////////////////////////////////////////////////////
CWMFileSinkV1::CWMFileSinkV1( HRESULT *phr, CTPtrArray<WRITER_SINK_CALLBACK> *pCallbacks ) :
    m_hRecordFile( INVALID_HANDLE_VALUE ),
    m_dwFileAttributes( FILE_ATTRIBUTE_NORMAL ),
    m_dwFileShareFlags( FILE_SHARE_READ ),
    m_dwFileCreationDisposition ( CREATE_ALWAYS ),
    m_cRef( 1 ),
    m_fHeaderReceived( FALSE ),
    m_fHeaderWritten( FALSE ),
    m_fStopped( FALSE ),
    m_cbHeaderReceived( 0 ),
    m_cbHeader( 0 ),
    m_pbHeader( NULL ),
    m_pwszFilename( NULL ),
    m_pASFHeader( NULL ),
    m_cDataUnitsWritten( 0 ),
    m_cbCurrentFileSize( 0 ),
    m_msLastTimeStampSeen( 0 ),
    m_cLastTimeStampSeenWraps( 0 ),
    m_msLastTimeStampWritten( 0 ),
    m_msPresTimeAdjust( ( QWORD )-1 ),
    m_msTimeStampStopped( 0 ),
    m_pbPaddingBuffer( NULL ),
    m_wfse ( WRITER_FILESINK_ERROR_SEV_NOERROR ),
    m_cbIndexSize( 0 ),
    m_fSimpleIndexObjectWritten( FALSE ),
    m_fNewIndexObjectWritten( FALSE ),
    m_msLargestPresTimeWritten ( 0 ) ,
    m_cIndexers( 0 ),
    m_qwNextNewBlockPacket( 0 ),
    m_fAutoIndex( TRUE ),
    m_cnsDuration( 0 ),
    m_cControlStreams( 0 ),
    m_fUnbufferedIO( FALSE ),
    m_fRestrictMemUsage( FALSE ),
    m_pUnbufferedWriter( NULL )
{
    *phr = m_CommandMutex.Init();
    if( FAILED( *phr ) )
    {
        assert( !"Unexpected error" );
        return;
    }

    *phr = m_CallbackMutex.Init();
    if( FAILED( *phr ) )
    {
        assert( !"Unexpected error" );
        return;
    }

    *phr = m_GenericMutex.Init();
    if( FAILED( *phr ) )
    {
        assert( !"Unexpected error" );
        return;
    }

    m_fWriterFilesLookLive = FALSE;

#if DBG

    HRESULT reghr = LoadRegDword( CU_GENERAL, TEXT("WriterFilesLookLive") , (DWORD*)&m_fWriterFilesLookLive );

    if( FAILED( reghr ) )
    {
        m_fWriterFilesLookLive = FALSE;
    }
#endif

    m_Commands.Initialize( 16 );

    ZeroMemory( m_StreamInfo, sizeof( m_StreamInfo ) );

    ZeroMemory( m_StreamNumberToIndex, sizeof( m_StreamNumberToIndex ) );
    ZeroMemory( m_StreamIndex, sizeof( m_StreamIndex ) );

    ZeroMemory( &m_payloadMap, sizeof( m_payloadMap ) );
    ZeroMemory( &m_parseInfoEx, sizeof( m_parseInfoEx ) );

    m_pAllocator = NULL;

    if( pCallbacks )
    {
        m_fCallbackOnOpen = FALSE;
        for( DWORD i = 0; i < (*pCallbacks).GetSize(); i++ )
        {
            WRITER_SINK_CALLBACK*   pCallbackStructBase = (*pCallbacks)[i];
            WRITER_SINK_CALLBACK*   pCallbackStruct = new WRITER_SINK_CALLBACK;

            if( pCallbackStructBase && pCallbackStruct )
            {
                pCallbackStruct->pCallback = pCallbackStructBase->pCallback;
                pCallbackStruct->pCallback->AddRef();
                pCallbackStruct->pvContext = pCallbackStructBase->pvContext;

                m_Callbacks.Add( pCallbackStruct, NULL );
            }
        }
    }
    else
    {
        m_fCallbackOnOpen = TRUE;
    }

    m_cControlStreams = 0;
    for ( WORD i = 0; i < MAX_STREAMS; i++ )
    {
        m_StreamInfo[i].fIsControlStream = FALSE;
    }
}


////////////////////////////////////////////////////////////////////////////
CWMFileSinkV1::~CWMFileSinkV1()
{
    // Moved to Release(), calling virtual methods in
    // destructor is not a good idea
    // Close();

    SAFE_DELETE( m_pbHeader );
    SAFE_DELETE( m_pwszFilename );
    SAFE_RELEASE( m_pASFHeader );

    while( m_Commands.GetCount() )
    {
        QWORD                   msTime;
        WRITER_SINK_COMMAND*    pCommand;

        m_Commands.RemoveEntry( 0, msTime, pCommand );
        delete pCommand;
    }

    for( DWORD i = 0; i < m_Callbacks.GetSize(); i++ )
    {
        m_Callbacks[i]->pCallback->Release();
        delete m_Callbacks[i];
    }
    m_Callbacks.RemoveAll();

    for ( i = 0; i < m_cIndexers; i++ )
    {
        SAFE_DELETE( m_StreamIndex[i] );
    }

    SAFE_RELEASE( m_pAllocator );

    SAFE_ARRAYDELETE( m_pbPaddingBuffer );

    SAFE_DELETE( m_pUnbufferedWriter );
}


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::QueryInterface( REFIID riid, void **ppvObject )
{
    HRESULT hr = S_OK;

    if( NULL == ppvObject )
    {
        return( E_INVALIDARG );
    }

    *ppvObject = NULL;

    if( IsEqualGUID( IID_IUnknown, riid ) || IsEqualGUID( IID_IWMWriterFileSink, riid ) )
    {
        *ppvObject = ( IWMWriterFileSink* ) this;
    }
    else if( IsEqualGUID( IID_IWMWriterSink, riid ) )
    {
        *ppvObject = ( IWMWriterSink * ) this;
    }
    else if( IsEqualGUID( IID_IWMWriterFileSink2, riid ) )
    {
        *ppvObject = ( IWMWriterFileSink2 * ) this;
    }
    else if( IsEqualGUID( IID_IWMWriterFileSink3, riid ) )
    {
        *ppvObject = ( IWMWriterFileSink3 * ) this;
    }
    else if( IsEqualGUID( IID_IWMRegisterCallback, riid ) )
    {
        *ppvObject = ( IWMRegisterCallback * ) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if( S_OK == hr )
    {
        ( ( IUnknown * ) *ppvObject )->AddRef();
    }

    return( hr );
}


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CWMFileSinkV1::AddRef()
{
    return( InterlockedIncrement( &m_cRef ) );
}


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CWMFileSinkV1::Release()
{
    ULONG   ret = InterlockedDecrement( &m_cRef );

    if( 0 == ret )
    {
        Close();
        delete this;
        return( 0 );
    }

    return( ret );
}

////////////////////////////////////////////////////////////////////////////
HRESULT CWMFileSinkV1::Write( BYTE *pbBuffer, DWORD dwBufferLength, DWORD *pdwBytesWritten )
{
    HRESULT hr = E_UNEXPECTED;

    *pdwBytesWritten = 0;

    if( m_fUnbufferedIO && m_pUnbufferedWriter )
    {
        hr = m_pUnbufferedWriter->SequentialWrite(pbBuffer, dwBufferLength);
        if( SUCCEEDED( hr ) )
        {
            *pdwBytesWritten = dwBufferLength;
        }
    }
    else if( INVALID_HANDLE_VALUE != m_hRecordFile )
    {
        BOOL fResult = WriteFile( m_hRecordFile, pbBuffer, dwBufferLength, pdwBytesWritten, NULL );

        if( !fResult || ( *pdwBytesWritten ) != dwBufferLength )
        {
            hr = NS_E_FILE_WRITE;
        }
        else
        {
            hr = S_OK;
        }
    }

    return hr ;
}

////////////////////////////////////////////////////////////////////////////
HRESULT CWMFileSinkV1::InternalOpen( const WCHAR *pwszFilename )
{
    HRESULT hr = S_OK;

    AutoLock<Mutex> lock( m_GenericMutex );

    if( NULL == pwszFilename )
    {
        return( E_INVALIDARG );
    }

    //
    // If we've been asked to use the unbuffered writer,
    // try to configure it.  If we're already open, force
    // ourselves closed first.
    //

    if ( m_fUnbufferedIO )
    {
        if ( m_pUnbufferedWriter )
        {
            hr = Close();
            if( FAILED( hr ) )
            {
                return( hr );
            }
        }

        assert( NULL == m_pUnbufferedWriter );

        m_pUnbufferedWriter = new CUnbufferedWriter;
        if ( m_pUnbufferedWriter )
        {
            hr = m_pUnbufferedWriter->OpenFile( pwszFilename, m_fRestrictMemUsage );
            if ( FAILED( hr ))
            {
                SAFE_DELETE( m_pUnbufferedWriter );
            }
        }

        //
        // If for any reason we failed to configure the unbuffered
        // writer, use the normal buffered code path from here on out.
        //

        if ( !m_pUnbufferedWriter )
        {
            m_fUnbufferedIO = FALSE;
        }
    }

    if ( !m_fUnbufferedIO )
    {
        if( INVALID_HANDLE_VALUE != m_hRecordFile )
        {
            hr = Close();
            if( FAILED( hr ) )
            {
                return( hr );
            }
        }

        do
        {
            m_hRecordFile = CreateFile( pwszFilename,
                                        GENERIC_WRITE,
                                        m_dwFileShareFlags,
                                        NULL,
                                        m_dwFileCreationDisposition,
                                        m_dwFileAttributes,
                                        NULL );
            if( INVALID_HANDLE_VALUE == m_hRecordFile )
            {
                hr = NS_E_FILE_OPEN_FAILED;
                break;
            }
        }
        while( FALSE );
    }

    //
    // Init our state.
    //

    if( pwszFilename != m_pwszFilename )
    {
        SAFE_DELETE( m_pwszFilename );
        m_pwszFilename = new WCHAR[ wcslen( pwszFilename ) + 1 ];
        if( NULL == m_pwszFilename )
        {
            return( E_OUTOFMEMORY );
        }
        wcscpy( m_pwszFilename, pwszFilename );
    }

    m_wfse = WRITER_FILESINK_ERROR_SEV_NOERROR;
    m_fHeaderWritten = FALSE;

    m_cDataUnitsWritten = 0;
    m_cbIndexSize = 0;
    m_cbCurrentFileSize = 0;

    m_msLastTimeStampWritten = 0;
    m_msLargestPresTimeWritten = 0;

    m_cnsDuration = 0;

    if( !m_fStopped )
    {
        m_msPresTimeAdjust = ( QWORD )-1;
    }
    else
    {
        m_msPresTimeAdjust   = m_msLastTimeStampSeen;
        m_msSendTimeAdjust   = m_msLastTimeStampSeen;
        m_msTimeStampStopped = m_msLastTimeStampSeen;
    }

    for( WORD i = 0; i < MAX_STREAMS; i++ )
    {
        m_StreamInfo[i].msLastPresTimeSeen = 0;
        m_StreamInfo[i].cLastPresTimeSeenWraps = 0;
        m_StreamInfo[i].msLargestPresTimeSeen = 0;
        m_StreamInfo[i].msLargestPresTimeWritten = 0;
        m_StreamInfo[i].msLastDurationWritten = 0;
        m_StreamInfo[i].bLastObjectID = 0;
        m_StreamInfo[i].bObjectIDAdjust = 0;
    }

    //
    // If there are any indexers (i.e., if we were previously
    // writing to some other file), then start them over.
    //

    for ( i = 0; i < m_cIndexers; i++ )
    {
        m_StreamIndex[i]->Reset();
    }

    m_fSimpleIndexObjectWritten = FALSE;
    m_fNewIndexObjectWritten = FALSE;

    return( hr );
}

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::Open( const WCHAR *pwszFilename )
{
    HRESULT hr;

    hr = InternalOpen( pwszFilename );

    if( m_fCallbackOnOpen )
    {
        AutoLock<Mutex> lock( m_CallbackMutex );

        if( m_Callbacks.GetSize() > 0 )
        {
            //
            // notify the world
            //
            DWORD   dwNothing = 0;

            for( DWORD i = 0; i < m_Callbacks.GetSize(); i++ )
            {
                m_Callbacks[i]->pCallback->OnStatus(    WMT_OPENED,
                                                        hr,
                                                        WMT_TYPE_DWORD,
                                                        (BYTE*)&dwNothing,
                                                        m_Callbacks[i]->pvContext );
            }
        }
    }
    else
    {
        m_fCallbackOnOpen = TRUE;
    }

    return( hr );
}


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::OnHeader( INSSBuffer *pHeader )
{
    AutoLock<Mutex> lock( m_GenericMutex );

    HRESULT hr = S_OK;
    BOOL fOpen = FALSE;

    //
    // Open the file if necessary.  We might need to open
    // the file first if that hasn't already happened.
    //

    if( m_fUnbufferedIO )
    {
        if ( !m_pUnbufferedWriter && m_pwszFilename )
        {
            fOpen = TRUE;
        }
    }
    else
    {
        if ( INVALID_HANDLE_VALUE == m_hRecordFile && m_pwszFilename )
        {
           fOpen = TRUE;
        }
    }

    if ( fOpen )
    {
       hr = Open( m_pwszFilename );
       if( FAILED( hr ) )
       {
           return( hr );
       }
    }

    //
    // Write the header.
    //

    if( NULL == pHeader )
    {
        return( E_INVALIDARG );
    }

    do
    {
        LPBYTE  pbBuffer = NULL;
        DWORD   cbBuffer = 0;

        hr = pHeader->GetBufferAndLength( &pbBuffer, &cbBuffer );
        if( FAILED( hr ) )
        {
            assert( !"Unexpected error" );
            hr = E_UNEXPECTED;
            break;
        }

        if( m_fHeaderReceived )
        {
            if( cbBuffer != m_cbHeaderReceived )
            {
                hr = ASF_E_HEADERSIZE;
                break;
            }

            SAFE_DELETE( m_pbHeader );
            SAFE_RELEASE( m_pASFHeader );
        }

        m_cbHeaderReceived = cbBuffer;

        //
        // Parse the header as it is now
        //
        m_pASFHeader = CreateMMStream();
        if( NULL == m_pASFHeader )
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        hr = m_pASFHeader->LoadHeader( pbBuffer, cbBuffer );
        if( FAILED( hr ) )
        {
            hr = ASF_E_INVALIDHEADER;
            break;
        }

        //
        // Grab information about the bitrate and frame rate so we can accurately
        // track the duration of the file
        //
        CASFExtendedStreamPropertiesObject* pExtendedStreamProps;

        pExtendedStreamProps = m_pASFHeader->GetExtendedStreamPropertiesObject();

        if( pExtendedStreamProps )
        {
            for( WORD i = 0; i < MAX_STREAMS; i++ )
            {
                CASFExtendedStreamPropertiesObject::EXTENDED_PROPERTIES extendProps;

                hr = pExtendedStreamProps->GetExtendedProperties( i, &extendProps );
                if( SUCCEEDED( hr ) )
                {
                    m_StreamInfo[i].dwBitrate = extendProps.dwBitrate;
                }
            }

            DWORD   cStreams = m_pASFHeader->GetStreamCount();
            DWORD   dwStreamNumber = 1;

            hr = S_OK;

            while( cStreams && SUCCEEDED( hr ) )
            {
                CASFStreamPropertiesObject* pStreamProps = NULL;

                hr = m_pASFHeader->GetStreamPropertiesObject( dwStreamNumber, &pStreamProps );
                if( SUCCEEDED( hr ) )
                {
                    cStreams--;

                    GUID    guidStreamType;

                    hr = pStreamProps->GetStreamType( guidStreamType );
                    if( SUCCEEDED( hr ) )
                    {
                        if( guidStreamType == CLSID_AsfXStreamTypeAcmAudio )
                        {
                            BYTE* pbData;
                            DWORD cbData;

                            pStreamProps->GetTypeSpecificData( pbData, cbData );

                            WAVEFORMATEX*   pWFX = (WAVEFORMATEX*)pbData;

                            m_StreamInfo[dwStreamNumber].msDurationPerObject = 0;

                            //
                            // For WMAVBR, we pretend we write 128kbps
                            //
                            if ( IsVBRWMA( pWFX->nAvgBytesPerSec ) )
                            {
                                m_StreamInfo[dwStreamNumber].dwBitrate = 128016;
                            }
                            else
                            {
                                m_StreamInfo[dwStreamNumber].dwBitrate = pWFX->nAvgBytesPerSec * 8;
                            }
                        }
                        else if( guidStreamType == CLSID_AsfXStreamTypeIcmVideo )
                        {
                            if( m_StreamInfo[dwStreamNumber].dwBitrate > 150000 )
                            {
                                m_StreamInfo[dwStreamNumber].msDurationPerObject = 33;
                            }
                            else
                            {
                                m_StreamInfo[dwStreamNumber].msDurationPerObject = 66;
                            }
                        }
                        else
                        {
                            m_StreamInfo[dwStreamNumber].msDurationPerObject = 1;
                        }
                    }
                }
                dwStreamNumber++;
            }
        }

        //
        // Get preroll
        //
        m_qwPreroll = 0;

        CASFPropertiesObject *pProps = m_pASFHeader->GetPropertiesObject();

        if( pProps )
        {
            pProps->GetPreroll( m_qwPreroll );
        }

        //
        // Set up index objects
        //
        hr = SetupIndex();
        if ( FAILED( hr ) )
        {
            break;
        }

        //
        // Done with any updates to the header object.
        // Note that the header object might have changed
        //
        DWORD cbHeader = m_pASFHeader->HeaderSpace();
        if( m_fHeaderReceived && cbHeader != m_cbHeader )
        {
            hr = ASF_E_HEADERSIZE;
            break;
        }

        SAFE_DELETE( m_pbHeader );

        m_pbHeader = new BYTE[ cbHeader ];
        if ( !m_pbHeader )
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        m_cbHeader = cbHeader;

        hr = m_pASFHeader->StoreHeader( m_pbHeader, m_cbHeader );
        if ( FAILED( hr ) )
        {
            hr = E_UNEXPECTED;
            break;
        }

        //
        // Write out the header if we haven't already done so.
        //

        m_fHeaderReceived = TRUE;

        if ( !m_fHeaderWritten )
        {
            DWORD   cbWritten = 0;
            hr = Write( m_pbHeader, m_cbHeader, &cbWritten );

            if ( FAILED( hr ) )
            {
                m_wfse = WRITER_FILESINK_ERROR_SEV_ONHEADER;
                hr = NS_E_FILE_WRITE;
                break;
            }

            m_cbCurrentFileSize += cbWritten;
            m_fHeaderWritten = TRUE;
        }

    }
    while( FALSE );

    //
    // notify the callback
    //
    if( FAILED( hr ) && ( m_Callbacks.GetSize() > 0 ) )
    {
        AutoLock<Mutex> lock( m_CallbackMutex );

        //
        // notify the world
        //
        DWORD   dwNothing = 0;

        for( DWORD i = 0; i < m_Callbacks.GetSize(); i++ )
        {
            m_Callbacks[i]->pCallback->OnStatus(    WMT_ERROR,
                                                    hr,
                                                    WMT_TYPE_DWORD,
                                                    (BYTE*)&(dwNothing),
                                                    m_Callbacks[i]->pvContext );
        }

        //
        // reset hr to S_OK, since we have already told the user about the error
        // via the callback
        //
        hr = S_OK;
    }

    //
    // Create a buffer pool for packet-sized objects
    //
    SAFE_RELEASE( m_pAllocator );

    //
    // Get packet size and create allocator
    //
    CASFPropertiesObject *pProps = m_pASFHeader->GetPropertiesObject();

    DWORD cbPacket = 0;
    if( pProps )
    {

        pProps->GetMaxPacketSize( cbPacket );

        if( cbPacket )
        {
            CWMSDKBufferPool::CreateInstance( cbPacket, 4, 1, &m_pAllocator );
        }
    }

    //
    // Create a zeroed-out buffer from which we will write padding
    //
    SAFE_ARRAYDELETE( m_pbPaddingBuffer );
    m_pbPaddingBuffer = new BYTE[ cbPacket ];
    if ( !m_pbPaddingBuffer )
    {
        return( E_OUTOFMEMORY );
    }
    ZeroMemory( m_pbPaddingBuffer, cbPacket );

    return( hr );
}


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::IsRealTime( BOOL *pfRealTime )
{
    if( NULL == pfRealTime )
    {
        return( E_INVALIDARG );
    }

    *pfRealTime = FALSE;

    return( S_OK );
}


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::AllocateDataUnit( DWORD cbDataUnit, INSSBuffer **ppDataUnit )
{
    if( ( 0 == cbDataUnit ) ||
        ( NULL == ppDataUnit ) )
    {
        return( E_INVALIDARG );
    }

    HRESULT hr = S_OK;

    if( m_pAllocator )
    {
        hr = m_pAllocator->AllocateBuffer( cbDataUnit, ppDataUnit );
    }
    else
    {
        hr = CWMSDKBuffer::Create( cbDataUnit, ppDataUnit );
    }

    return( hr );
}


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::OnDataUnit( INSSBuffer *pDataUnit )
{
    if( NULL == pDataUnit )
    {
        return( E_INVALIDARG );
    }

    AutoLock<Mutex> lock( m_GenericMutex );

    //
    // Make sure we're configured properly.
    //

    if ( m_fUnbufferedIO )
    {
        if ( !m_pUnbufferedWriter )
        {
           return( NS_E_NOT_CONFIGURED );
        }
    }
    else
    {
        if( INVALID_HANDLE_VALUE == m_hRecordFile )
        {
            return( NS_E_NOT_CONFIGURED );
        }
    }

    HRESULT hr = S_OK;

    do
    {
        DWORD   cbBuffer;
        BYTE*   pbBuffer;

        hr = pDataUnit->GetBufferAndLength( &pbBuffer, &cbBuffer );
        if( FAILED( hr ) )
        {
            assert( !"Unexpected error" );
            hr = E_UNEXPECTED;
            break;
        }

        PACKET_PARSE_INFO_EX    parseInfoEx;
        CPayloadMapEntryEx      payloadMap[ CPayloadMapEntry::MAX_PACKET_PAYLOADS ];

        ZeroMemory( &payloadMap, sizeof( payloadMap ) );
        ZeroMemory( &parseInfoEx, sizeof( parseInfoEx ) );

        hr = GetTimeStamp( pbBuffer, cbBuffer, &parseInfoEx, payloadMap );
        if( FAILED( hr ) )
        {
            break;
        }

        //
        // Use the parse info to pull apart the buffer into a packet header
        // and the various payload headers
        //
        BYTE *pbPacketHeader = pbBuffer;
        BYTE *pbPayloadHeaders[ CPayloadMapEntry::MAX_PACKET_PAYLOADS ];
        for ( DWORD i = 0; i < parseInfoEx.cPayloads; i++ )
        {
            pbPayloadHeaders[i] = pbBuffer + payloadMap[i].cbPacketOffset;
        }

        //
        // Handle the stuff we just parsed
        //
        hr = ProcessParsedDataUnit( pbPacketHeader, pbPayloadHeaders, parseInfoEx.cPayloads,
            &parseInfoEx, payloadMap );
        if ( FAILED( hr ) )
        {
            break;
        }

        if( !m_fStopped && ShouldWriteData() )
        {
            DWORD   cbWritten = 0;
            hr = Write( pbBuffer, cbBuffer, &cbWritten );

            if( FAILED( hr ) )
            {
                m_wfse = WRITER_FILESINK_ERROR_SEV_ONDATA;
                hr = NS_E_FILE_WRITE;
                break;
            }

            m_cbCurrentFileSize += cbWritten;
            m_cDataUnitsWritten++;
            m_msLastTimeStampWritten = m_msLastTimeStampSeen - m_msSendTimeAdjust;

            // Note that GenerateIndexEntries is called after writing data to the
            // file so that anyone concurrently looking up the index will be able
            // to successfully seek to the index entry. Also, we call this function
            // only if we actually write to the file.
            hr = GenerateIndexEntries( parseInfoEx, payloadMap );
            if ( FAILED( hr ) )
            {
                break;
            }
        }
    }
    while( FALSE );

    //
    // notify the callback if necessary
    //
    if ( FAILED( hr ) )
    {
        NotifyCallbacksOnError( hr );

        //
        // reset hr to S_OK, since we have already told the user about the error
        // via the callback
        //
        hr = S_OK;
    }


    return( hr );
}


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::OnEndWriting()
{

	HRESULT hr = S_OK;

    //
    //  stores duration which allows GetFileDuration() to return proper value
    //  if it is called after EndWriting
    //
    hr = GetFileDuration( &m_cnsDuration );

    hr = InternalClose();

    SAFE_DELETE( m_pbHeader );
    SAFE_RELEASE( m_pASFHeader );

    while( m_Commands.GetCount() )
    {
        QWORD                   msTime;
        WRITER_SINK_COMMAND*    pCommand;

        m_Commands.RemoveEntry( 0, msTime, pCommand );
        delete pCommand;
    }


    m_fHeaderReceived = FALSE;
    m_fHeaderWritten = FALSE;
    m_cbHeaderReceived = 0;
    m_cbHeader = 0;
    m_cbIndexSize = 0;

    m_msLastTimeStampSeen = 0;
    m_msLastTimeStampWritten = 0;
    m_msPresTimeAdjust = ( QWORD )-1;
    m_msTimeStampStopped = 0;
    ZeroMemory( m_StreamInfo, sizeof( m_StreamInfo ) );
    m_msLargestPresTimeWritten = 0;

    m_wfse = WRITER_FILESINK_ERROR_SEV_NOERROR;

    return( hr );
}

////////////////////////////////////////////////////////////////////////////
HRESULT CWMFileSinkV1::SetupIndex()
{
    HRESULT hr = S_OK;

    //
    // These indices assume fixed packet size!
    //
    CASFPropertiesObject *pProps = m_pASFHeader->GetPropertiesObject();
    if ( !pProps )
    {
        return( E_FAIL );
    }

    DWORD cbMinPacketSize = 0;
    DWORD cbMaxPacketSize = 0;
    pProps->GetMinPacketSize( cbMinPacketSize );
    pProps->GetMaxPacketSize( cbMaxPacketSize );
    assert( cbMinPacketSize == cbMaxPacketSize && "On-the-fly indexing assumes fixed-size packets!" );

    do
    {
        //
        // Set up the per-stream indexers if this hasn't already been done
        //
        if ( !m_fHeaderReceived )
        {
            //
            // Here we assume that every stream is going to need
            // an indexer
            //
            LISTPOS pos = NULL;
            hr = m_pASFHeader->GetFirstObjectPosition( pos );
            if ( FAILED( hr ) )
            {
                break;
            }

            CASFLonghandObject *pObject = NULL;
            while( pos && SUCCEEDED( m_pASFHeader->GetNextObject( &pObject, pos ) ) )
            {
                GUID guidObject;
                hr = pObject->GetObjectID( guidObject );
                if ( FAILED( hr ) )
                {
                    break;
                }

                CASFStreamPropertiesObject *pSPO = NULL;

                //
                // Every stream is represented exactly once by an SPO,
                // whether by a standalone (backwards-compatible) SPO or
                // one hidden inside an extended SPO (though not every extended
                // SPO hides an SPO)
                //
                if ( CLSID_CAsfStreamPropertiesObjectV1 == guidObject )
                {
                    pSPO = (CASFStreamPropertiesObject *) pObject;
                }
                else if ( CLSID_CAsfStreamPropertiesObjectEx == guidObject )
                {
                    CASFStreamPropertiesObjectEx *pSPOEx =
                        (CASFStreamPropertiesObjectEx *) pObject;
                    pSPOEx->GetStreamPropertiesObject( &pSPO );
                }

                if ( pSPO )
                {
                    //
                    // Great, create an indexer
                    //
                    hr = CreateIndexer( pSPO, cbMinPacketSize );
                    if ( FAILED( hr ) )
                    {
                        break;
                    }
                }

                pObject->Release();

            }
            if ( FAILED( hr ) )
            {
                break;
            }

        }

        if ( m_cIndexers > 0  )
        {
            //
            // Whether or not we're setting up, we need to add an index parameters
            // object to the header if there's an advanced index object
            //
            CASFIndexParametersObject indexParams;
            indexParams.SetTimeDelta( INDEX_TIME_DELTA / 10000 );
            indexParams.SetSpecifierCount( m_cIndexers );
            for ( WORD i = 0; i < m_cIndexers; i++ )
            {
                indexParams.SetSpecifier( i, m_StreamIndex[i]->GetStreamNumber(), NEAREST_CLEAN_POINT );
            }

            CASFLonghandObject *pObjectToAdd = NULL;
            CASFIndexParametersPlaceholderObject placeholderObject;
            if ( CanIndexWithSimpleIndexObjectOnly() || !m_fAutoIndex )
            {
                //
                // If we'll be using just the old index object,
                // then we don't want an index params object here,
                // so we'll just add a padding object of
                // the same size.
                //
                // Note that the last call to this function will
                // get it right.  For instance, if we have VBR audio,
                // we won't know about it until when we get the header
                // at the end.
                //
                // If for some reason we already have one, then don't
                // bother adding another one.
                //
                LISTPOS pos = NULL;
                hr = m_pASFHeader->GetFirstObjectPosition( pos );
                if ( FAILED( hr ) )
                {
                    break;
                }

                CASFLonghandObject *pObject = NULL;
                BOOL fPlaceholderExists = FALSE;
                while( !fPlaceholderExists && pos && SUCCEEDED( m_pASFHeader->GetNextObject( &pObject, pos ) ) )
                {
                    GUID guidObject;
                    hr = pObject->GetObjectID( guidObject );
                    if ( FAILED( hr ) )
                    {
                        break;
                    }

                    if ( CLSID_CAsfIndexParametersPlaceholderObject == guidObject )
                    {
                        fPlaceholderExists = TRUE;
                    }

                    SAFE_RELEASE( pObject );
                }
                if ( FAILED( hr ) )
                {
                    break;
                }

                if ( !fPlaceholderExists )
                {
                    //
                    // There isn't one, so we need to add it
                    //
                    DWORD dwPlaceholderObjectSize = indexParams.Space();

                    placeholderObject.SetSize( dwPlaceholderObjectSize );

                    pObjectToAdd = &placeholderObject;
                }
            }
            else
            {
                //
                // Add the index parameters object
                //
                pObjectToAdd = &indexParams;
            }

            if ( NULL != pObjectToAdd )
            {
                hr = m_pASFHeader->AddHeaderObject( *pObjectToAdd );
                if ( FAILED( hr ) )
                {
                    break;
                }
            }
        }

    }   while( FALSE );

    return( hr );

}

////////////////////////////////////////////////////////////////////////////
HRESULT CWMFileSinkV1::CreateIndexer(   CASFStreamPropertiesObject *pSPO,
                                        DWORD dwPacketSize )
{
    if ( !pSPO )
    {
        return( E_POINTER );
    }

    WORD wStreamNumber = 0;

    HRESULT hr = S_OK;

    do
    {
        hr = pSPO->GetStreamNumber( wStreamNumber );
        if ( FAILED( hr ) )
        {
            break;
        }

        GUID guidStreamType = GUID_NULL;
        pSPO->GetStreamType( guidStreamType );

        m_StreamIndex[m_cIndexers] =
            new CWMPerStreamIndex(  wStreamNumber,
                                    guidStreamType,
                                    INDEX_TIME_DELTA,
                                    m_qwPreroll,
                                    dwPacketSize );
        if ( !m_StreamIndex[m_cIndexers] )
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // Point to it in the lookup table
        //
        m_StreamNumberToIndex[ wStreamNumber ] = m_StreamIndex[ m_cIndexers ];

        m_cIndexers++;

    }   while( FALSE );

    return( hr );
}

////////////////////////////////////////////////////////////////////////////
HRESULT CWMFileSinkV1::UpdateHeader()
{
    HRESULT hr = S_OK;

    if( !m_fHeaderReceived )
    {
        assert( !"Unexpected error" );
        return( E_UNEXPECTED );
    }

    do
    {
        //
        // Update properties with number of packets & stream size & new flags
        //
        CASFPropertiesObject *pProps = m_pASFHeader->GetPropertiesObject();


        //
        // We might need these values if we decide to go with the play duration
        // that's already in the header.  This would be in the case where the
        // mux set something that we determine is better than what we could set
        // for ourselves (because the mux knows more about sample durations).
        // In this case, we'd have to adjust the play duration back as we have
        // adjusted the presentation times.  But we want to keep this number
        // as it was, should we ever have to use it again (otherwise we'd keep
        // subtracting numbers off it).
        // This is a big ugly bad HACK (beckyw, 8/16/01)
        //
        BOOL fAdjustedPlayDuration = FALSE;
        QWORD msPlayDurationBeforeAdjustment = 0;
        QWORD cOriginalHeaderPackets = 0;

        if( ! pProps )
        {
            assert( !"Unexpected error" );
            hr = E_UNEXPECTED;
            break;
        }
        else
        {
            hr = pProps->SetTotalSize( m_cbCurrentFileSize );
            if( FAILED( hr ) )
            {
                assert( !"Unexpected error" );
                hr = E_UNEXPECTED;
                break;
            }

            //
            // Keep track of whether this header accurately reflects
            // what has been written into this file by finding out
            // if its idea about the number of data units written
            // matches ours.  Only if they're the same will
            // we borrow the play duration number below.
            //
            hr = pProps->GetPacketCount( cOriginalHeaderPackets );
            if ( FAILED( hr ) )
            {
                assert( !"Unexpected error" );
                hr = E_UNEXPECTED;
                break;
            }

            BOOL fPlayDurationIsValid = (cOriginalHeaderPackets == m_cDataUnitsWritten);

            //
            // OK, now clobber the data unit count with the appropriate
            // number
            //
            hr = pProps->SetPacketCount( m_cDataUnitsWritten );
            if( FAILED( hr ) )
            {
                assert( !"Unexpected error" );
                hr = E_UNEXPECTED;
                break;
            }

            if( !m_fWriterFilesLookLive )
            {
                DWORD dwFlags;

                hr = pProps->GetFlags( dwFlags );
                if( FAILED( hr ) )
                {
                    assert( !"Unexpected error" );
                    hr = E_UNEXPECTED;
                    break;
                }

                dwFlags &= ~CASFPropertiesObject::LIVE;
                dwFlags &= ~CASFPropertiesObject::BROADCAST;

                //
                // The following determines whether the file
                // is seekable from a backwards-compatibility
                // point of view
                //
                BOOL    fNonSeekableStreamPresent = FALSE;
                DWORD   cStreams = m_pASFHeader->GetStreamCount();
                DWORD   dwStreamNumber = 1;
                BOOL    rgfSeekableV1[ MAX_STREAMS ];
                ZeroMemory( rgfSeekableV1, MAX_STREAMS * sizeof( BOOL ) );

                while( cStreams && !fNonSeekableStreamPresent )
                {
                    CASFStreamPropertiesObject* pStreamProps = NULL;

                    hr = m_pASFHeader->GetStreamPropertiesObject( dwStreamNumber, &pStreamProps );
                    if( SUCCEEDED( hr ) )
                    {
                        cStreams--;

                        WORD wStreamNumber = 0;
                        pStreamProps->GetStreamNumber( wStreamNumber );

                        //
                        // If the stream is not seekable from a V1 point of view,
                        // then the whole file won't be seekable from a V1 point
                        // of view
                        //
                        rgfSeekableV1[ wStreamNumber ] = IsV1Seekable( pStreamProps );
                        if ( !rgfSeekableV1[ wStreamNumber ] )
                        {
                            fNonSeekableStreamPresent = TRUE;
                        }
                    }
                    dwStreamNumber++;
                }

                //
                // Now go through looking for extended SPOs.
                // Set the seekable flag as appropriate
                //
                LISTPOS pos = NULL;
                hr = m_pASFHeader->GetFirstObjectPosition( pos );
                if ( FAILED( hr ) )
                {
                    break;
                }

                CASFLonghandObject *pObject = NULL;
                while( pos && SUCCEEDED( m_pASFHeader->GetNextObject( &pObject, pos ) ) )
                {
                    GUID guidObject;
                    hr = pObject->GetObjectID( guidObject );
                    if ( FAILED( hr ) )
                    {
                        break;
                    }

                    if ( CLSID_CAsfStreamPropertiesObjectEx == guidObject )
                    {
                        CASFStreamPropertiesObjectEx *pSPOEx =
                            (CASFStreamPropertiesObjectEx *) pObject;

                        WORD wStreamNumber = 0;
                        pSPOEx->GetStreamNumber( wStreamNumber );

                        //
                        // Seekable iff it's seekable with a V1 index OR if
                        // it's seekable with a new index.
                        //
                        pSPOEx->SetSeekable( rgfSeekableV1[ wStreamNumber ] ||
                            (m_StreamNumberToIndex[ wStreamNumber ] && m_fNewIndexObjectWritten) );
                    }

                    pObject->Release();
                }



                if( !fNonSeekableStreamPresent )
                {
                    //
                    // this file is seekable
                    //
                    dwFlags |= CASFPropertiesObject::SEEKABLE;
                }
                else
                {
                    //
                    // This file is not seekable
                    //
                    dwFlags &= ~CASFPropertiesObject::SEEKABLE;
                }

                //
                // Set the flags
                //
                hr = pProps->SetFlags( dwFlags );
                if( FAILED( hr ) )
                {
                    assert( !"Unexpected error" );
                    hr = E_UNEXPECTED;
                    break;
                }

                if( ( QWORD )-1 != m_msPresTimeAdjust )
                {
                    //
                    // The send duration is the last send timestamp plus a guess
                    // at the send duration
                    //
                    DWORD cbMinPacketSize = 0;
                    hr = pProps->GetMinPacketSize( cbMinPacketSize );
                    if ( FAILED( hr ) )
                    {
                        assert( !"Unexpected error" );
                        hr = E_UNEXPECTED;
                        break;
                    }

                    DWORD dwMaxBitrate = 0;
                    hr = pProps->GetMaxBitRate( dwMaxBitrate );
                    if ( FAILED( hr ) )
                    {
                        assert( !"Unexpected error" );
                        hr = E_UNEXPECTED;
                        break;
                    }

                    QWORD msAvgDuration = (8 * cbMinPacketSize * 1000) / dwMaxBitrate;

                    hr = pProps->SetSendDuration( (m_msLastTimeStampWritten + msAvgDuration) * 10000 );
                    if( FAILED( hr ) )
                    {
                        assert( !"Unexpected error" );
                        hr = E_UNEXPECTED;
                        break;
                    }
                }
                else
                {
                    hr = pProps->SetSendDuration( 0 );
                    if( FAILED( hr ) )
                    {
                        assert( !"Unexpected error" );
                        hr = E_UNEXPECTED;
                        break;
                    }
                }

                //
                // Set play duration to largest pres time + duration
                //
                QWORD   cnsHeaderPlayDuration = 0;
                QWORD   msHeaderPlayDuration = 0;
                if( ( QWORD )-1 != m_msPresTimeAdjust )
                {
                    //
                    // If duration is set - mux already provided more accurate value,
                    // do not overwrite it, so long as we can use it...
                    //
                    pProps->GetPlayDuration( cnsHeaderPlayDuration );
                    msHeaderPlayDuration = cnsHeaderPlayDuration / 10000;

                    if ( 0 == msHeaderPlayDuration || !fPlayDurationIsValid )
                    {
                        QWORD   msLargestTime = 0;

                        for( DWORD i = 0; i < MAX_STREAMS; i++ )
                        {
                            if( m_StreamInfo[i].msLargestPresTimeWritten +
                                m_StreamInfo[i].msLastDurationWritten >
                                msLargestTime )
                            {
                                msLargestTime = m_StreamInfo[i].msLargestPresTimeWritten +
                                                m_StreamInfo[i].msLastDurationWritten;
                            }
                        }


                        hr = pProps->SetPlayDuration( msLargestTime * 10000 );
                        if( FAILED( hr ) )
                        {
                            assert( !"Unexpected error" );
                            hr = E_UNEXPECTED;
                            break;
                        }
                    }
                    else
                    {
                        //
                        // If we monkeyed with prestimes, let's also monkey with
                        // the duration that we're getting from the mux (which,
                        // of course, is an unadjusted prestime)
                        //
                        fAdjustedPlayDuration = TRUE;
                        msPlayDurationBeforeAdjustment = msHeaderPlayDuration;

                        NSASSERT( m_msPresTimeAdjust <= msHeaderPlayDuration );
                        msHeaderPlayDuration -= m_msPresTimeAdjust;

                        hr = pProps->SetPlayDuration( msHeaderPlayDuration * 10000 );
                        if ( FAILED( hr ) )
                        {
                            assert( !"Unexpected error" );
                            hr = E_UNEXPECTED;
                            break;
                        }
                    }
                }
                else
                {
                    hr = pProps->SetPlayDuration( 0 );
                    if( FAILED( hr ) )
                    {
                        assert( !"Unexpected error" );
                        hr = E_UNEXPECTED;
                        break;
                    }
                }
            }
        }

        //
        // Update data object with packet count & object size
        //
        if( S_OK == hr )
        {
            CASFDataObject *pData = m_pASFHeader->GetDataObject();

            if( !pData )
            {
                hr = ASF_E_INVALIDHEADER;
                break;
            }

            hr = pData->SetPacketCount( m_cDataUnitsWritten );
            if( FAILED( hr ) )
            {
                assert( !"Unexpected error" );
                hr = E_UNEXPECTED;
                break;
            }

            // 50 is size of data object header
            hr = pData->SetSize( m_cbCurrentFileSize - ( (QWORD) m_cbHeader - 50 ) - m_cbIndexSize );
            if( FAILED( hr ) )
            {
                assert( !"Unexpected error" );
                hr = E_UNEXPECTED;
                break;
            }
        }

        //
        // Store the updated header back to the buffer
        //
        hr = m_pASFHeader->StoreHeader( m_pbHeader, m_cbHeader );
        if( FAILED( hr ) )
        {
            assert( !"Unexpected error" );
            hr = E_UNEXPECTED;
            break;
        }

        //
        // See the BUC above.  If need be, we set the props's play duration back
        // to what it was before we adjusted it, and the packet count corresponding
        // to what's in the props object should be set back.
        //
        if ( fAdjustedPlayDuration )
        {
            pProps->SetPlayDuration( msPlayDurationBeforeAdjustment );
        }
        else
        {
            //
            // Otherwise, that means that the packet count that WAS in the header
            // didn't correspond to the play duration, so we calculated it ourselves.
            // Next time we try to write this header, we should make sure that
            // we calculate it by hand again.
            //
            pProps->SetPacketCount( (QWORD) -1 );
        }
    }
    while( FALSE );

    return( hr );
}


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::Advise( IWMStatusCallback* pCallback, void* pvContext )
{
    if( NULL == pCallback )
    {
        return( E_INVALIDARG );
    }

    WRITER_SINK_CALLBACK*   pCallbackStruct = new WRITER_SINK_CALLBACK;

    pCallbackStruct->pCallback = pCallback;
    pCallback->AddRef();

    pCallbackStruct->pvContext = pvContext;

    m_Callbacks.Add( pCallbackStruct, NULL );

    return( S_OK );
}


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::Unadvise( IWMStatusCallback* pCallback, void* pvContext )
{
    for( DWORD i = 0; i < m_Callbacks.GetSize(); i++ )
    {
        WRITER_SINK_CALLBACK*   pCallbackStruct = m_Callbacks[i];

        if( pCallbackStruct->pCallback == pCallback &&
            pCallbackStruct->pvContext == pvContext )
        {
            m_Callbacks.RemoveAt( i );

            pCallbackStruct->pCallback->Release();
            delete pCallbackStruct;
        }
    }

    return( S_OK );
}


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::Start( QWORD cnsTime )
{
    AutoLock<Mutex> lock( m_GenericMutex );

    if( cnsTime / 10000 < m_msTimeStampStopped )
    {
        return( NS_E_INVALID_REQUEST );
    }

    if( cnsTime / 10000 <= m_msLastTimeStampSeen )
    {
        return( DoStart( m_msLastTimeStampSeen ) );
    }

    WRITER_SINK_COMMAND*    pCommand = new WRITER_SINK_COMMAND;

    if( NULL == pCommand )
    {
        return( E_OUTOFMEMORY );
    }

    pCommand->time = cnsTime / 10000;   // convert to milliseconds
    pCommand->action = WRITER_SINK_START;

    m_Commands.AddEntry( pCommand->time, pCommand );

    return( S_OK );
}


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::Stop( QWORD cnsTime )
{
    AutoLock<Mutex> lock( m_GenericMutex );

    if( cnsTime / 10000 <= m_msLastTimeStampSeen )
    {
        return( DoStop( cnsTime / 10000 ) );
    }

    WRITER_SINK_COMMAND*    pCommand = new WRITER_SINK_COMMAND;

    if( NULL == pCommand )
    {
        return( E_OUTOFMEMORY );
    }

    pCommand->time = cnsTime / 10000;   // convert to milliseconds
    pCommand->action = WRITER_SINK_STOP;

    m_Commands.AddEntry( pCommand->time, pCommand );

    return( S_OK );
}


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::IsStopped( BOOL* pfStopped )
{
    AutoLock<Mutex> lock( m_GenericMutex );

    if( NULL == pfStopped )
    {
        return( E_INVALIDARG );
    }

    *pfStopped = m_fStopped;

    return( S_OK );
}


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::IsClosed( BOOL* pfClosed )
{
    AutoLock<Mutex> lock( m_GenericMutex );

    if( NULL == pfClosed )
    {
        return( E_INVALIDARG );
    }

    *pfClosed = ( m_pwszFilename ) ? FALSE : TRUE;

    return( S_OK );
}


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::GetFileDuration( QWORD* pcnsDuration )
{
    if( NULL == pcnsDuration )
    {
        return( E_INVALIDARG );
    }

    if( ( QWORD )-1 != m_msPresTimeAdjust && m_cDataUnitsWritten > 0 )
    {
        QWORD   msLargestTime = 0;

        for( DWORD i = 0; i < MAX_STREAMS; i++ )
        {
            if( m_StreamInfo[i].msLargestPresTimeWritten +
                m_StreamInfo[i].msLastDurationWritten >
                msLargestTime )
            {
                msLargestTime = m_StreamInfo[i].msLargestPresTimeWritten +
                                m_StreamInfo[i].msLastDurationWritten;
            }
        }

        NSASSERT( m_qwPreroll <= msLargestTime );
        *pcnsDuration = ( msLargestTime - m_qwPreroll ) * 10000;
    }
    else
    {
        *pcnsDuration = m_cnsDuration;
    }

    return( S_OK );
}


////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::GetFileSize( QWORD* pcbFile )
{
    if( NULL == pcbFile )
    {
        return( E_INVALIDARG );
    }

    *pcbFile = m_cbCurrentFileSize;

    return( S_OK );
}

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::SetAutoIndexing(    BOOL fDoAutoIndexing )
{
    //
    // Whether we're autoindexing or not needs to be decided before
    // we get the header for the first time
    //
    if ( m_fHeaderWritten )
    {
        return( NS_E_INVALID_REQUEST );
    }

    m_fAutoIndex = fDoAutoIndexing;
    return( S_OK );
}

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::GetAutoIndexing(    BOOL *pfAutoIndexing )
{
    if ( !pfAutoIndexing )
    {
        return( E_INVALIDARG );
    }

    *pfAutoIndexing = m_fAutoIndex;
    return( S_OK );
}

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::SetControlStream(   WORD wStreamNumber,
                                                BOOL fShouldControlStartAndStop )
{
    if ( wStreamNumber >= MAX_STREAMS )
    {
        return( E_INVALIDARG );
    }

    BOOL fWasControlStream = m_StreamInfo[ wStreamNumber ].fIsControlStream;

    m_StreamInfo[ wStreamNumber ].fIsControlStream = fShouldControlStartAndStop;

    if ( fShouldControlStartAndStop && !fWasControlStream )
    {
        m_cControlStreams++;
    }
    else if ( !fShouldControlStartAndStop && fWasControlStream )
    {
        m_cControlStreams--;
    }

    return( S_OK );

}

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::SetUnbufferedIO(
    BOOL fUnbufferedIO,
    BOOL fRestrictMemUsage
)
{
    if ( m_fHeaderWritten )
    {
        return( NS_E_INVALID_REQUEST );
    }

    m_fUnbufferedIO = fUnbufferedIO;
    m_fRestrictMemUsage = fRestrictMemUsage;

    return( S_OK );
};

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::GetUnbufferedIO(
    BOOL *fUnbufferedIO
)
{
    if ( fUnbufferedIO )
    {
        *fUnbufferedIO = m_fUnbufferedIO;
        return( S_OK );
    }

    return( E_POINTER );
};

////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CWMFileSinkV1::CompleteOperations()
{
    if ( m_fUnbufferedIO )
    {
        NSASSERT( m_pUnbufferedWriter );
        m_pUnbufferedWriter->CompleteOperations();
    }

    return( S_OK );
}

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::GetMode( DWORD *pdwFileSinkMode )
{
    if ( NULL == pdwFileSinkMode )
    {
        return( E_INVALIDARG );
    }

    //
    // This implementation can handle both packets in continguous buffers
    // and the FILESINK_DATA_UNIT type of input
    //
    *pdwFileSinkMode = WMT_FM_SINGLE_BUFFERS | WMT_FM_FILESINK_DATA_UNITS;

    if ( m_fUnbufferedIO )
    {
        *pdwFileSinkMode |= WMT_FM_FILESINK_UNBUFFERED;
    }

    return( S_OK );
}

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::OnDataUnitEx(   WMT_FILESINK_DATA_UNIT *pFileSinkDataUnit )
{
    if ( NULL == pFileSinkDataUnit )
    {
        return( E_INVALIDARG );
    }

    AutoLock<Mutex> lock( m_GenericMutex );

    //
    // Check to see if we're configured properly.
    //

    if ( m_fUnbufferedIO )
    {
        if ( !m_pUnbufferedWriter )
        {
           return( NS_E_NOT_CONFIGURED );
        }
    }
    else
    {
       if( INVALID_HANDLE_VALUE == m_hRecordFile )
       {
           return( NS_E_NOT_CONFIGURED );
       }
    }

    HRESULT hr = S_OK;

    do
    {
        for ( DWORD i = 0; i < pFileSinkDataUnit->cPayloads; i++ )
        {
            BYTE *pbHeader = NULL;
            DWORD cbLength = 0;
            hr = pFileSinkDataUnit->pPayloadHeaderBuffers[i].pBuffer->GetBufferAndLength( &pbHeader, &cbLength );
            if ( FAILED( hr ) )
            {
                break;
            }

            m_pbPayloadHeaders[i] = pbHeader
                + pFileSinkDataUnit->pPayloadHeaderBuffers[i].cbOffset;
            m_cbPayloadHeaders[i] = pFileSinkDataUnit->pPayloadHeaderBuffers[i].cbLength;
        }
        if ( FAILED( hr ) )
        {
            break;
        }


        BYTE *pbPacketHeader = NULL;
        DWORD cbPacketHeader = 0;
        hr = pFileSinkDataUnit->packetHeaderBuffer.pBuffer->GetBufferAndLength( &pbPacketHeader, &cbPacketHeader );
        if ( FAILED( hr ) )
        {
            break;
        }

        //
        // Take the buffer offset into account for the packet header
        //
        pbPacketHeader += pFileSinkDataUnit->packetHeaderBuffer.cbOffset;
        cbPacketHeader = pFileSinkDataUnit->packetHeaderBuffer.cbLength;

        hr = GetTimeStamp(  pbPacketHeader,
                            m_pbPayloadHeaders,
                            pFileSinkDataUnit->cPayloads,
                            &m_parseInfoEx,
                            m_payloadMap );
        if ( FAILED( hr ) )
        {
            break;
        }

        hr = ProcessParsedDataUnit( pbPacketHeader,
                                    m_pbPayloadHeaders,
                                    pFileSinkDataUnit->cPayloads,
                                    &m_parseInfoEx,
                                    m_payloadMap );
        if ( FAILED( hr ) )
        {
            break;
        }

        //
        // Write out all of the buffers in sequence
        //
        if( !m_fStopped && ShouldWriteData() )
        {
            DWORD   cbTotalWritten = 0;
            DWORD   cbWritten = 0;
            BOOL    fResult = TRUE;

            //
            // First the packet header
            //
            hr = Write( pbPacketHeader, cbPacketHeader, &cbTotalWritten );

            if( FAILED( hr ) )
            {
                m_wfse = WRITER_FILESINK_ERROR_SEV_ONDATA;
                hr = NS_E_FILE_WRITE;
                break;
            }

            //
            // Now the payloads
            //
            DWORD cbCurrentPayloadFragment = 0;

            for ( DWORD i = 0; i < pFileSinkDataUnit->cPayloads; i++ )
            {
                //
                // Write the payload header
                //
                hr = Write( m_pbPayloadHeaders[i], m_cbPayloadHeaders[i], &cbWritten );

                if( FAILED( hr ) )
                {
                    break;
                }

                cbTotalWritten += cbWritten;

                //
                // Write the payload data from all fragments for this payload
                //
                while ( fResult
                    && SUCCEEDED( hr )
                    && cbCurrentPayloadFragment < pFileSinkDataUnit->cPayloadDataFragments
                    &&  pFileSinkDataUnit->pPayloadDataFragments[cbCurrentPayloadFragment].dwPayloadIndex == i )
                {
                    WMT_PAYLOAD_FRAGMENT *pFragment = &(pFileSinkDataUnit->pPayloadDataFragments[ cbCurrentPayloadFragment ]);

                    BYTE *pbData = NULL;
                    DWORD cbData = 0;

                    hr = pFragment->segmentData.pBuffer->GetBufferAndLength( &pbData, &cbData );
                    if ( FAILED( hr ) )
                    {
                        fResult = FALSE;
                        break;
                    }

                    hr = Write( pbData + pFragment->segmentData.cbOffset, pFragment->segmentData.cbLength, &cbWritten );

                    if( FAILED( hr ) )
                    {
                        break;
                    }

                    cbTotalWritten += cbWritten;
                    cbCurrentPayloadFragment++;
                }
            }

            if ( !fResult || FAILED( hr ) )
            {
                m_wfse = WRITER_FILESINK_ERROR_SEV_ONDATA;
                hr = NS_E_FILE_WRITE;
                break;
            }

            //
            // Write whatever padding is necessary
            //
            DWORD cbTotalPacket = 0;
            CASFPropertiesObject *pProps = m_pASFHeader->GetPropertiesObject();
            if( pProps )
            {
                pProps->GetMaxPacketSize( cbTotalPacket );
            }

            NSASSERT( cbTotalWritten <= cbTotalPacket );
            DWORD cbPadding = cbTotalPacket - cbTotalWritten;
            if ( cbPadding )
            {
                hr = Write( m_pbPaddingBuffer, cbPadding, &cbWritten );

                if( FAILED( hr ) )
                {
                    m_wfse = WRITER_FILESINK_ERROR_SEV_ONDATA;
                    hr = NS_E_FILE_WRITE;
                    break;
                }

                cbTotalWritten += cbWritten;
            }


            m_cbCurrentFileSize += cbTotalWritten;
            m_cDataUnitsWritten++;
            m_msLastTimeStampWritten = m_msLastTimeStampSeen - m_msSendTimeAdjust;

            // Note that GenerateIndexEntries is called after writing data to the
            // file so that anyone concurrently looking up the index will be able
            // to successfully seek to the index entry. Also, we call this function
            // only if we actually write to the file.
            hr = GenerateIndexEntries( m_parseInfoEx, m_payloadMap );
            if ( FAILED( hr ) )
            {
                break;
            }
        }



    }   while( FALSE );

    //
    // notify the callback if necessary
    //
    if ( FAILED( hr ) )
    {
        NotifyCallbacksOnError( hr );

        //
        // reset hr to S_OK, since we have already told the user about the error
        // via the callback
        //
        hr = S_OK;
    }


    return( hr );
}

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMFileSinkV1::Close()
{
    HRESULT hr = S_OK;

    {
        AutoLock<Mutex> lock( m_GenericMutex );

        hr = InternalClose();
        SAFE_DELETE( m_pwszFilename );
    }

    if( SUCCEEDED( hr ) )
    {
        if( m_Callbacks.GetSize() > 0 )
        {
            AutoLock<Mutex> lock( m_CallbackMutex );

            //
            // notify the world
            //
            DWORD   dwNothing = 0;

            for( DWORD i = 0; i < m_Callbacks.GetSize(); i++ )
            {
                m_Callbacks[i]->pCallback->OnStatus(    WMT_CLOSED,
                                                        hr,
                                                        WMT_TYPE_DWORD,
                                                        (BYTE*)&dwNothing,
                                                        m_Callbacks[i]->pvContext );
            }
        }
    }

    return( hr );
}

////////////////////////////////////////////////////////////////////////////
HRESULT CWMFileSinkV1::GenerateIndexEntries(    PACKET_PARSE_INFO_EX& parseInfoEx,
                                                CPayloadMapEntryEx *payloadMap )
{
    if ( !m_fAutoIndex )
    {
        // Don't deal with index entries
        return( S_OK );
    }

    HRESULT hr = S_OK;
    NSASSERT( m_cDataUnitsWritten > 0 );

    do
    {
        //
        // Time to start a new block everywhere?
        //
        QWORD qwPacket = m_cDataUnitsWritten - 1;
        if ( qwPacket >= m_qwNextNewBlockPacket )
        {
            //
            // Yes.
            //
            QWORD qwMinNextNewBlockPacket = 0xffffffff;
            for ( WORD i = 0; i < m_cIndexers; i++ )
            {
                QWORD qwNextNewBlockPacket = 0xffffffff;
                QWORD cnsNewBlockStart = 10000 * m_msLastTimeStampWritten;  // Guaranteed to precede
                                                                            // all pres times to come
                hr = m_StreamIndex[i]->StartNewBlock( cnsNewBlockStart, &qwNextNewBlockPacket );
                if ( FAILED( hr ) )
                {
                    break;
                }

                if ( qwNextNewBlockPacket < qwMinNextNewBlockPacket )
                {
                    qwMinNextNewBlockPacket = qwNextNewBlockPacket;
                }
            }

            m_qwNextNewBlockPacket = qwMinNextNewBlockPacket;

            if ( FAILED( hr ) )
            {
                break;
            }
        }

        //
        // For each payload, if it belongs to an indexable stream,
        // feed that info to the per-stream index object
        //
        for ( DWORD i = 0; i < parseInfoEx.cPayloads; i++ )
        {
            CPayloadMapEntryEx *pPayloadMapEntry = &(payloadMap[i]);
            BYTE bStreamNumber = pPayloadMapEntry->StreamId();
            CWMPerStreamIndex *pIndexer = m_StreamNumberToIndex[ bStreamNumber ];

            if ( pIndexer )
            {
                // This payload wants to be indexed
                hr = pIndexer->OnNewPayload( pPayloadMapEntry, m_cDataUnitsWritten - 1 );
                if ( FAILED( hr ) )
                {
                    break;
                }

            }
        }
        if ( FAILED( hr ) )
        {
            break;
        }

    }   while( FALSE );

    return( hr );
}

////////////////////////////////////////////////////////////////////////////
HRESULT CWMFileSinkV1::WriteOutIndexObjects()
{
    if ( !m_fAutoIndex || 0 == m_cIndexers )
    {
        //
        // There's no occasion for index-writing
        //
        return( S_OK );
    }

    if ( m_cbIndexSize > 0 )
    {
        //
        // Don't be here
        //
        return( E_UNEXPECTED );
    }

    HRESULT hr = S_OK;
    BYTE *pbIndexObject = NULL;
    BYTE *pbDegenerateSimpleIndex = NULL;
    HANDLE hIndexHandle = INVALID_HANDLE_VALUE;

    //
    // Finish up the indexing.
    //

    for ( WORD i = 0; i < m_cIndexers; i++ )
    {
        hr = m_StreamIndex[i]->FinishIndexing( 10000 * m_msLargestPresTimeWritten );
        if ( FAILED( hr ) )
        {
            return( hr );
        }
    }

    //
    // Get the handle that we need to write the indexes to.
    //

    if ( m_fUnbufferedIO )
    {
        hIndexHandle = m_pUnbufferedWriter->GetIndexWriteHandle();
    }
    else
    {
        hIndexHandle = m_hRecordFile;
    }

    //
    // Now write the indexes.
    //

    do
    {
        BOOL fOnlySimpleIndexObjectNeeded = CanIndexWithSimpleIndexObjectOnly();
        if ( fOnlySimpleIndexObjectNeeded )
        {
            //
            // Simple index object: Each indexer should dump a simple index
            // object in turn
            //
            //
            // The indexers were purposefully put in the order that the
            // corresponding streamprops objects appear in the header,
            // because legacy readers expect that.
            //
            for ( i = 0; i < m_cIndexers; i++ )
            {
                DWORD cbWritten = 0;
                hr = m_StreamIndex[i]->DumpSimpleIndexObjectToFile(
                    hIndexHandle, m_pASFHeader, &cbWritten );
                if ( FAILED( hr ) )
                {
                    break;
                }

                m_cbIndexSize += cbWritten;

                //
                // We've written a simple index object now
                //
                if ( cbWritten > 0 )
                {
                    m_fSimpleIndexObjectWritten = TRUE;
                }
            }
            if ( FAILED( hr ) )
            {
                break;
            }
        }
        else if ( m_cIndexers > 0 )
        {
            //
            // Advanced index object: We create the index object, and each indexer
            // fills it in
            //
            CASFIndexObjectEx indexEx;

            hr = indexEx.SetTimeDelta( INDEX_TIME_DELTA / 10000 );
            if ( FAILED( hr ) )
            {
                break;
            }

            hr = indexEx.SetSpecifierCount( m_cIndexers );
            if ( FAILED( hr ) )
            {
                break;
            }
            for ( i = 0; i < m_cIndexers; i++ )
            {
                hr = indexEx.SetSpecifier( i, m_StreamIndex[i]->GetStreamNumber(), NEAREST_CLEAN_POINT );
                if ( FAILED( hr ) )
                {
                    break;
                }
            }
            if ( FAILED( hr ) )
            {
                break;
            }

            //
            // The indexers should all have the same block count and entries
            // per block, so it's OK to ask the first one
            //
            NSASSERT( m_StreamIndex[0] );
            DWORD cBlocks = 0;
            m_StreamIndex[0]->GetBlockCount( &cBlocks );
            if ( !cBlocks )
            {
                hr = E_UNEXPECTED;
                break;
            }

            indexEx.SetBlockCount( cBlocks );

            for ( DWORD j = 0; j < cBlocks; j++ )
            {
                DWORD cEntries = 0;
                hr = m_StreamIndex[0]->GetEntryCountForBlock( j, &cEntries );
                if ( FAILED( hr ) )
                {
                    break;
                }

                hr = indexEx.SetBlock( j, cEntries );
                if ( FAILED( hr ) )
                {
                    break;
                }
            }
            if ( FAILED( hr ) )
            {
                break;
            }

            //
            // Now ask each stream to fill in the blocks with its values
            //
            for ( i = 0; i < m_cIndexers; i++ )
            {
                hr = m_StreamIndex[i]->FillInIndexEntries( i, &indexEx );
                if ( FAILED( hr ) )
                {
                    break;
                }
            }
            if ( FAILED( hr ) )
            {
                break;
            }

            //
            // The index object is now complete.  Write it to the file
            //

            //
            // Write the index object to a buffer
            //
            DWORD cbIndexObject = indexEx.Space();
            pbIndexObject = new BYTE[ cbIndexObject ];
            if ( !pbIndexObject )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            CASFArchive ar( pbIndexObject, cbIndexObject, m_pASFHeader->GetContext() );
            hr = indexEx.Persist( ar );

            //
            // Write the serialized index object to the file
            //
            DWORD cbWritten = 0;
            BOOL fResult = ::WriteFile( hIndexHandle, pbIndexObject, cbIndexObject, &cbWritten, NULL );
            if ( !fResult || cbWritten < cbIndexObject )
            {
                hr = E_FAIL;
                break;
            }

            m_cbIndexSize = cbWritten;

            m_fNewIndexObjectWritten = TRUE;



            //
            // The following is for compatibility with the Cyprus player.
            // There needs to be a simple index object following the advanced
            // index object, so we'll put a degenerate one here regardless
            //

            //
            // First see if there are any backwards-compatible video streams
            // to index legitimately
            //

            LISTPOS pos = NULL;
            hr = m_pASFHeader->GetFirstObjectPosition( pos );
            if ( FAILED( hr ) )
            {
                break;
            }

            CASFLonghandObject *pObject = NULL;
            while( pos && SUCCEEDED( m_pASFHeader->GetNextObject( &pObject, pos ) ) )
            {
                GUID guidObject;
                hr = pObject->GetObjectID( guidObject );
                if ( FAILED( hr ) )
                {
                    break;
                }

                //
                // Each freestanding SPO is backwards-compatible
                //
                if ( CLSID_CAsfStreamPropertiesObjectV1 == guidObject )
                {

                    CASFStreamPropertiesObject *pStreamProps =
                        (CASFStreamPropertiesObject *) pObject;

                    GUID    guidStreamType;

                    hr = pStreamProps->GetStreamType( guidStreamType );
                    if ( FAILED( hr ) )
                    {
                        break;
                    }

                    if( guidStreamType == CLSID_AsfXStreamTypeIcmVideo )
                    {
                        //
                        // This is video: Dump out a simple index object
                        //
                        WORD wStreamNumber = 0;
                        pStreamProps->GetStreamNumber( wStreamNumber );

                        CWMPerStreamIndex *pIndexer = m_StreamNumberToIndex[ wStreamNumber ];
                        if ( pIndexer )
                        {
                            DWORD cbWritten = 0;
                            if ( SUCCEEDED( pIndexer->DumpSimpleIndexObjectToFile(
                                hIndexHandle, m_pASFHeader, &cbWritten ) ) )
                            {
                                m_fSimpleIndexObjectWritten = TRUE;

                                m_cbIndexSize += cbWritten;
                            }
                        }
                    }
                }
            }


            if ( !m_fSimpleIndexObjectWritten )
            {
                //
                // Oh well, just write a degenerate one
                //

                CASFIndexObject indexObj;

                GUID guidMMSID = GUID_NULL;
                CASFPropertiesObject *pProps = m_pASFHeader->GetPropertiesObject();
                if (pProps)
                {
                    hr = pProps->GetMmsID(guidMMSID);
                    if ( FAILED( hr ) )
                    {
                        break;
                    }
                }

                indexObj.SetMmsID( guidMMSID );
                indexObj.SetTimeDelta( 0 );
                indexObj.SetEntryCount( 0 );

                DWORD cbDegenerateSimpleIndex = indexObj.Space();
                pbDegenerateSimpleIndex = new BYTE[ cbDegenerateSimpleIndex ];
                if ( !pbDegenerateSimpleIndex )
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }

                CASFArchive arDegenerate( pbDegenerateSimpleIndex, cbDegenerateSimpleIndex, m_pASFHeader->GetContext() );
                hr = indexObj.Persist( arDegenerate );

                //
                // Write the serialized index object to the file
                //
                fResult = ::WriteFile( hIndexHandle, pbDegenerateSimpleIndex, cbDegenerateSimpleIndex, &cbWritten, NULL );
                if ( !fResult || cbWritten < cbDegenerateSimpleIndex )
                {
                    hr = E_FAIL;
                    break;
                }

                m_cbIndexSize += cbWritten;

                //
                // We do NOT set m_fSimpleIndexObjectWritten because that would
                // cause the seekable attribute to be set in the header, and this
                // object is bogus.
                //
            }

        }

        //
        // All done.  The file size has grown by the index size
        //
        m_cbCurrentFileSize += m_cbIndexSize;

    }   while( FALSE );

    SAFE_ARRAYDELETE( pbIndexObject );
    SAFE_ARRAYDELETE( pbDegenerateSimpleIndex );

    return( hr );
}

////////////////////////////////////////////////////////////////////////////
HRESULT CWMFileSinkV1::InternalClose()
{
    HRESULT hr = S_OK;

    AutoLock<Mutex> lock( m_GenericMutex );

    do
    {
        //
        // Double check that this request makes sense.
        //

        if( NULL == m_pwszFilename )
        {
            return( NS_E_INVALID_REQUEST );
        }

        if ( m_fUnbufferedIO )
        {
            if ( !m_pUnbufferedWriter )
            {
                return( S_FALSE );
            }
            else
            {
                //
                // You must call EndWriting on the unbuffered writer before you
                // can rewriter the header or add indexes!  EndWriting causes all
                // the data to be flushed out to the disk and re-opens the file
                // for standard writing.
                //

                m_pUnbufferedWriter->EndWriting( m_pwszFilename );
            }
        }
        else
        {
            if( INVALID_HANDLE_VALUE == m_hRecordFile )
            {
                return( S_FALSE );
            }

        }

        //
        // If the writing of the index objects fail, then they won't be written.
        // We should continue to update the header and the data object size anyways.
        //

        WriteOutIndexObjects();

        //
        // Before closing the file, write the updated header.
        //

        if( m_fHeaderReceived )
        {
            hr = UpdateHeader();
            if( FAILED( hr ) )
            {
                break;
            }

            DWORD   cbWritten;

            if ( m_fUnbufferedIO )
            {
                hr = m_pUnbufferedWriter->RewriteHeader( m_pbHeader, m_cbHeader );
                if ( FAILED( hr ) )
                {
                    cbWritten = 0;
                }
                else
                {
                    cbWritten = m_cbHeader;
                }
            }
            else
            {
                if( 0xFFFFFFFF == SetFilePointer( m_hRecordFile, 0, NULL, FILE_BEGIN ) )
                {
                    assert( !"Unexpected error" );
                    hr = E_UNEXPECTED;
                    break;
                }

                BOOL    fResult;
                fResult = WriteFile( m_hRecordFile, m_pbHeader, m_cbHeader, &cbWritten, NULL );
            }

            if( cbWritten != m_cbHeader )
            {
                m_wfse = WRITER_FILESINK_ERROR_SEV_ONHEADER;
                hr = NS_E_FILE_WRITE;
                break;
            }
        }

        //
        // This indicates that we haven't started writing to the "current" file yet.
        //

        m_fHeaderWritten = FALSE;
    }
    while( FALSE );

    if ( m_fUnbufferedIO )
    {
        m_pUnbufferedWriter->CloseFile();
        SAFE_DELETE( m_pUnbufferedWriter );
    }
    else
    {
        SAFE_CLOSEFILEHANDLE( m_hRecordFile );
    }

    return( hr );
}


////////////////////////////////////////////////////////////////////////////
HRESULT CWMFileSinkV1::ProcessCommands( PACKET_PARSE_INFO_EX* parseInfoEx, CPayloadMapEntryEx* payloadMap )
{
    HRESULT                 hr = S_OK;
    WRITER_SINK_COMMAND*    pCommand = NULL;
    QWORD                   msCommandTime = 0;

    //
    // Get the first command from the queue
    //
    {
        AutoLock<Mutex> lock( m_CommandMutex );

        if( m_Commands.GetCount() )
        {
            m_Commands.GetEntry( 0, msCommandTime, pCommand );
        }
    }

    while( pCommand && CommandShouldExecuteNow( msCommandTime, parseInfoEx, payloadMap ) )
    {
        QWORD               time = pCommand->time;
        WRITER_SINK_ACTION  action = pCommand->action;

        //
        // Remove the command from the queue
        //
        {
            AutoLock<Mutex> lock( m_CommandMutex );

            delete pCommand;
            m_Commands.RemoveEntry( 0, msCommandTime, pCommand );
        }

        switch( action )
        {
        case WRITER_SINK_START:

            hr = DoStart( m_msLastTimeStampSeen );
            break;

        case WRITER_SINK_STOP:

            hr = DoStop( time );
            break;
        };

        //
        // Get the next command from the queue
        //
        {
            AutoLock<Mutex> lock( m_CommandMutex );

            if( m_Commands.GetCount() )
            {
                m_Commands.GetEntry( 0, msCommandTime, pCommand );
            }
            else
            {
                pCommand = NULL;
            }
        }

    };  // ... while( commands to process )

    return( hr );
}

////////////////////////////////////////////////////////////////////////////
BOOL CWMFileSinkV1::CommandShouldExecuteNow(    QWORD msCommandTime,
                                                PACKET_PARSE_INFO_EX *parseInfoEx,
                                                CPayloadMapEntryEx *payloadMap )
{
    if ( m_cControlStreams > 0 )
    {
        //
        // Do the following for each payload in the packet:
        // If the stream to which this payload belongs is a control stream,
        // we're ready to execute the command if it's later than the
        // payload's prestime.
        //
        QWORD msCommandTimePlusPreroll = msCommandTime + m_qwPreroll;
        for ( DWORD i = 0; i < parseInfoEx->cPayloads; i++ )
        {
            WORD wStreamNumber = payloadMap[i].StreamId();
            if ( wStreamNumber < MAX_STREAMS )
            {
                if ( m_StreamInfo[wStreamNumber].fIsControlStream )
                {
                    BOOL fReadyToRoll = (msCommandTimePlusPreroll <= payloadMap[i].msObjectPres);
                    if ( fReadyToRoll )
                    {
                        return( TRUE );
                    }
                }
            }
        }

        //
        // OK, fine, just go according to sendtime.  This covers the
        // case when all control streams are out to lunch,
        // since we know that now nothing can have a sendtime
        // earlier than parseInfoEx->dwSCR
        //
    }

    //
    // Do this the old-school way, just compare
    // command times against send times.
    //
    BOOL fCommandEarlierThanSCR = (msCommandTime <= parseInfoEx->dwSCR);
    return( fCommandEarlierThanSCR );
}

////////////////////////////////////////////////////////////////////////////
HRESULT CWMFileSinkV1::DoStart( QWORD msTime )
{
    //
    // change state
    //
    if( m_fStopped )
    {
        for( DWORD i = 0; i < MAX_STREAMS; i++ )
        {
            m_StreamInfo[i].fDiscontinuity = TRUE;
        }

        //
        // dongwei 06/13/00: First, it doesn't make sense to increment them
        // when they're not initialized (this could happen when start is
        // called before first sample is received). Second, we never want
        // TimeAdjust > msTime (LastTimeSeen). An anlysis shows that this
        // CAN'T happen as long as initial_TimeAdjust <= first_stop time,
        // in another word, it should be safe to ignore the start/stop if
        // this does happen.
        //
        if( ( ( QWORD )-1 != m_msPresTimeAdjust ) &&
            ( m_msSendTimeAdjust <= m_msTimeStampStopped ) )
        {
            m_msPresTimeAdjust += msTime - m_msTimeStampStopped;
            m_msSendTimeAdjust += msTime - m_msTimeStampStopped;
        }

        m_fStopped = FALSE;

        AutoLock<Mutex> lock( m_CallbackMutex );

        for( i = 0; i < m_Callbacks.GetSize(); i++ )
        {
            m_Callbacks[i]->pCallback->OnStatus(    WMT_STARTED,
                                                    S_OK,
                                                    WMT_TYPE_QWORD,
                                                    (BYTE*)&(msTime),
                                                    m_Callbacks[i]->pvContext );
        }
    }

    return( S_OK );
}


////////////////////////////////////////////////////////////////////////////
HRESULT CWMFileSinkV1::DoStop( QWORD msTime )
{
    //
    // change state
    //
    if( !m_fStopped )
    {
        m_msTimeStampStopped = msTime;
        m_fStopped = TRUE;

        AutoLock<Mutex> lock( m_CallbackMutex );

        for( DWORD i = 0; i < m_Callbacks.GetSize(); i++ )
        {
            m_Callbacks[i]->pCallback->OnStatus(    WMT_STOPPED,
                                                    S_OK,
                                                    WMT_TYPE_QWORD,
                                                    (BYTE*)&(msTime),
                                                    m_Callbacks[i]->pvContext );
        }
    }

    return( S_OK );
}

////////////////////////////////////////////////////////////////////////////
HRESULT CWMFileSinkV1::ProcessParsedDataUnit(   BYTE *pbPacketHeader,
                                                BYTE **ppbPayloadHeaders,
                                                DWORD cPayloads,
                                                PACKET_PARSE_INFO_EX *pParseInfoEx,
                                                CPayloadMapEntryEx *payloadMap )
{
    HRESULT hr = S_OK;

    do
    {
        if( ( pParseInfoEx->dwSCR < (DWORD)m_msLastTimeStampSeen ) &&
            ( WRAPDW_GreaterThan( pParseInfoEx->dwSCR, (DWORD)m_msLastTimeStampSeen ) ) )
        {
            m_cLastTimeStampSeenWraps++;
        }

        m_msLastTimeStampSeen = (QWORD)pParseInfoEx->dwSCR + 0x100000000 * (QWORD)m_cLastTimeStampSeenWraps;

        if( ( QWORD )-1 == m_msPresTimeAdjust )
        {
            if( !m_fWriterFilesLookLive )
            {
                //
                // This is the first data unit we've received.  We need to adjust all timestamps
                // we receive as if this data unit was actually time zero.
                //
                m_msPresTimeAdjust = m_msLastTimeStampSeen;
                m_msSendTimeAdjust = m_msLastTimeStampSeen;
            }
            else
            {
                m_msPresTimeAdjust = 0;
                m_msSendTimeAdjust = 0;
            }
        }

        hr = ProcessCommands( pParseInfoEx, payloadMap );
        if( FAILED( hr ) )
        {
            break;
        }

#if 0
        //
        // Let's get some NSTRACE action on key frames
        //
        BOOL fWillWritePacket = !m_fStopped && ShouldWriteData();
        for ( WORD i = 0; i < pParseInfoEx->cPayloads; i++ )
        {
            CPayloadMapEntryEx *pPayloadMapEntry = &(payloadMap[i]);
            if ( pPayloadMapEntry->IsKeyFrame() )
            {
                if ( fWillWritePacket )
                {
                }
                else
                {
                }
            }
        }

#endif

        hr = AdjustTimeStamps(  pbPacketHeader,
                                ppbPayloadHeaders,
                                cPayloads,
                                pParseInfoEx,
                                payloadMap );
        if( FAILED( hr ) )
        {
            break;
        }

        if( !m_fStopped && ShouldWriteData() )
        {
            if( !m_fHeaderWritten )
            {
                //
                // This isn't a valid request unless we can write a header.
                //

                hr = NS_E_INVALID_REQUEST;

                if( m_fHeaderReceived )
                {
                    DWORD   cbWritten = 0;

                    assert( m_pbHeader );

                    hr = Write (m_pbHeader, m_cbHeader, & cbWritten) ;
                    if (SUCCEEDED (hr)) {
                        m_cbCurrentFileSize += cbWritten;
                        m_fHeaderWritten = TRUE;
                    }
                }
            }
        }
    }   while( FALSE );

    return( hr );
}

////////////////////////////////////////////////////////////////////////////
HRESULT CWMFileSinkV1::GetTimeStamp( BYTE* pbData, DWORD cbData, PACKET_PARSE_INFO_EX* pParseInfoEx, CPayloadMapEntryEx* payloadMap )
{
    HRESULT hr;

    //
    //  Parse the packet for header and payload info
    //
    hr = CBasePacketFilter::ParsePacketAndPayloads(
                                pbData,
                                cbData,
                                pParseInfoEx,
                                CPayloadMapEntry::MAX_PACKET_PAYLOADS,
                                payloadMap );
    if( FAILED( hr ) )
    {
        NSASSERT( !"Failed to parse packet" );
        return( hr );
    }

    return( S_OK );
}

////////////////////////////////////////////////////////////////////////////
HRESULT CWMFileSinkV1::GetTimeStamp(    BYTE *pPacketHeader,
                                        BYTE **ppbPayloadHeaders,
                                        DWORD cPayloads,
                                        PACKET_PARSE_INFO_EX *pParseInfoEx,
                                        CPayloadMapEntryEx *payloadMap )
{
    HRESULT hr;

    // BUGBUG: What about variable-size packets?
    DWORD cbPacket = 0;
    CASFPropertiesObject *pProps = m_pASFHeader->GetPropertiesObject();
    if( pProps )
    {
        pProps->GetMaxPacketSize( cbPacket );
    }

    //
    //  Parse the packet for header and payload info
    //
    hr = CBasePacketFilter::ParsePacketAndPayloads( pPacketHeader,
                                                    ppbPayloadHeaders,
                                                    cPayloads,
                                                    cbPacket,
                                                    pParseInfoEx,
                                                    CPayloadMapEntry::MAX_PACKET_PAYLOADS,
                                                    payloadMap );
    if( FAILED( hr ) )
    {
        NSASSERT( !"Failed to parse packet" );
        return( hr );
    }

    return( S_OK );
}

////////////////////////////////////////////////////////////////////////////
#define OFFSET_TO_REP_DATA      6
HRESULT CWMFileSinkV1::AdjustTimeStamps(    BYTE *pbPacketHeader,
                                            BYTE **ppbPayloadHeaders,
                                            DWORD cPayloads,
                                            PACKET_PARSE_INFO_EX *pParseInfoEx,
                                            CPayloadMapEntryEx *payloadMap )
{
    //
    // Check if we're about to adjust a timestamp to be earlier than a previous timestamp.  If so, fix our adjust amount.
    // Also, check if we need to adjust our objectid adjust amount
    //
    DWORD   rgLastPresTimeSeen[MAX_STREAMS];

    for( DWORD i = 0; i < MAX_STREAMS; i++ )
    {
        rgLastPresTimeSeen[i] = m_StreamInfo[ i ].msLastPresTimeSeen;
    }

    if( 0 != m_msPresTimeAdjust )
    {
        for( DWORD dwPayload = 0; dwPayload < pParseInfoEx->cPayloads; dwPayload++ )
        {
            BYTE    bStreamID = payloadMap[dwPayload].StreamId();

            NSASSERT( bStreamID < MAX_STREAMS );

            DWORD   dwWraps = m_StreamInfo[ bStreamID ].cLastPresTimeSeenWraps;

            //
            // Keep track of this object's presentation time and if it has wrapped around,
            // but don't update the "wrapped" variables since we process all these packets
            // a second time a little bit lower.
            //
            if( ( payloadMap[ dwPayload ].msObjectPres < rgLastPresTimeSeen[bStreamID] ) &&
                ( WRAPDW_GreaterThan( payloadMap[ dwPayload ].msObjectPres, rgLastPresTimeSeen[bStreamID] ) ) )
            {
                dwWraps++;
            }
            rgLastPresTimeSeen[bStreamID] = payloadMap[ dwPayload ].msObjectPres;

            QWORD msWrappedPresTime = (QWORD)payloadMap[ dwPayload ].msObjectPres +
                                        0x100000000 * (QWORD)dwWraps;

            //
            // Make sure that when we adjust the presentation time, we don't adjust it to be less than any
            // previous presentation times we've written
            //
            if( msWrappedPresTime - m_msPresTimeAdjust < m_StreamInfo[bStreamID].msLargestPresTimeWritten &&
                msWrappedPresTime >= m_StreamInfo[bStreamID].msLargestPresTimeWritten )
            {
                m_msPresTimeAdjust = msWrappedPresTime - m_StreamInfo[ bStreamID ].msLargestPresTimeWritten;

                if( m_msPresTimeAdjust )
                {
                    m_msPresTimeAdjust--;         // subtract off 1 ms if we can
                }
            }

            //
            // Also make sure we don't make any pres times less than the preroll value
            //
            if( ( msWrappedPresTime - m_msPresTimeAdjust < m_qwPreroll ) && ( 0 != m_qwPreroll ) && ! m_fStopped )
            {
                m_msPresTimeAdjust = msWrappedPresTime - m_qwPreroll;
            }

            //
            // Adjust the object IDs so that discontinuities look like discontinuities.
            //
            if( m_StreamInfo[ bStreamID ].fDiscontinuity )
            {
                m_StreamInfo[ bStreamID ].bObjectIDAdjust = m_StreamInfo[ bStreamID ].bLastObjectID + 64 - payloadMap[ dwPayload ].ObjectId();
                if( 0 == m_StreamInfo[ bStreamID ].bObjectIDAdjust )
                {
                    m_StreamInfo[ bStreamID ].bObjectIDAdjust = 64;
                }
                m_StreamInfo[ bStreamID ].fDiscontinuity = FALSE;
            }

            //
            // keep track of the largest pres time we've seen
            //
            if( msWrappedPresTime > m_StreamInfo[ bStreamID ].msLargestPresTimeSeen )
            {
                m_StreamInfo[ bStreamID ].msLargestPresTimeSeen = msWrappedPresTime;
            }
        }
    }

    if( m_fStopped )
    {
        return( S_OK );
    }

    //
    // Update SCR (send time)
    //
    if( 0 != m_msSendTimeAdjust )
    {
        //
        // Adjust the presentation times
        //
        NSAssert( m_msSendTimeAdjust <= m_msLastTimeStampSeen );

        DWORD dwNewSCR = (DWORD)( m_msLastTimeStampSeen - m_msSendTimeAdjust );

        SetUnalignedDword( &pbPacketHeader[ pParseInfoEx->bPadLenType + pParseInfoEx->cbPadLenOffset ],
                            dwNewSCR );
    }

    //
    // Update payload pres times
    //
    for( DWORD dwPayload = 0; dwPayload < pParseInfoEx->cPayloads; dwPayload++ )
    {
        BYTE    bStreamID = payloadMap[dwPayload].StreamId();

        NSASSERT( bStreamID < MAX_STREAMS );

        BYTE    *pbPayloadHeader = ppbPayloadHeaders[ dwPayload ];
        DWORD   cbPresTimeOffset = 1;
        DWORD   cbRepData = payloadMap[ dwPayload ].cbRepData;

        //
        // Keep track of this object's presentation time and if it has wrapped around
        //
        if( ( payloadMap[ dwPayload ].msObjectPres < m_StreamInfo[ bStreamID ].msLastPresTimeSeen ) &&
            ( WRAPDW_GreaterThan( payloadMap[ dwPayload ].msObjectPres, m_StreamInfo[ bStreamID ].msLastPresTimeSeen ) ) )
        {
            m_StreamInfo[ bStreamID ].cLastPresTimeSeenWraps++;
        }

        m_StreamInfo[ bStreamID ].msLastPresTimeSeen = payloadMap[ dwPayload ].msObjectPres;

        //
        // keep track of the largest pres time we've written
        //
        QWORD msWrappedPresTime = (QWORD)payloadMap[ dwPayload ].msObjectPres +
                                    0x100000000 * (QWORD)m_StreamInfo[ bStreamID ].cLastPresTimeSeenWraps;

        if( msWrappedPresTime - m_msPresTimeAdjust > m_StreamInfo[ bStreamID ].msLargestPresTimeWritten )
        {
            m_StreamInfo[ bStreamID ].msLargestPresTimeWritten = msWrappedPresTime - m_msPresTimeAdjust;

            if (m_StreamInfo[ bStreamID ].msLargestPresTimeWritten > m_msLargestPresTimeWritten)
            {
                m_msLargestPresTimeWritten = m_StreamInfo[ bStreamID ].msLargestPresTimeWritten;
            }
        }

        //
        // keep track of the last duration we've seen.
        //
        if( m_StreamInfo[ bStreamID ].msDurationPerObject )
        {
            if( 1 == cbRepData )    // compressed payload
            {
                //
                // Compressed Payload: the layout is: total_length (WORD)->
                //   1st payload length (BYTE)->data->2nd length->2nd data
                //   total_length includes data AND lengthes of data
                //
                // cbPresTimeOffset + OFFSET_TO_REP_DATA + 1 offsets the data
                // to where total_length is. Then + sizeof(WORD) brings it to
                // length of first payload.
                //
                // SLEROUX 5/2/00: Note that if this compressed payload is
                // the only payload in the packet, then the payload length
                // is NOT explicitly stored and therefore the total_length(WORD)
                // field is not present.
                //
                // CORYWEST 2/9/01: These type specifications are only
                // accurate for the compressed payloads case.
                //
                WORD    cbPayloadLengthField = pParseInfoEx->fMultiPayloads ? sizeof( WORD ) : 0;
                WORD    cbTotal = (WORD)payloadMap[dwPayload].PayloadSize();
                WORD    cbCurr = pbPayloadHeader[cbPresTimeOffset+OFFSET_TO_REP_DATA + cbPayloadLengthField + 1];
                for( WORD cP = 1; cbCurr + cP < cbTotal; cP++ )
                {
                    cbCurr += pbPayloadHeader[cbPresTimeOffset + OFFSET_TO_REP_DATA
                        + cbPayloadLengthField + 1 + cbCurr + cP];
                }

                NSASSERT( cbCurr + cP == cbTotal );
                m_StreamInfo[bStreamID].msLastDurationWritten =
                    m_StreamInfo[bStreamID].msDurationPerObject * cP;
            }
            else
            {
                m_StreamInfo[ bStreamID ].msLastDurationWritten = m_StreamInfo[ bStreamID ].msDurationPerObject;
            }
        }
        else if( m_StreamInfo[ bStreamID ].dwBitrate )
        {
            if( 1 == cbRepData )    // compressed payload
            {
                //
                // Compressed Payload: pretty much the same thing, we still
                // want to know the number of payloads, since total size
                // includes the extra byte for each payload.
                //
                WORD    cbPayloadLengthField = pParseInfoEx->fMultiPayloads ?
                            sizeof( WORD ) : 0;
                WORD    cbTotal = (WORD)payloadMap[dwPayload].PayloadSize();
                WORD    cbCurr = pbPayloadHeader[cbPresTimeOffset + OFFSET_TO_REP_DATA
                            + cbPayloadLengthField + 1];
                for( WORD cP = 1; cbCurr + cP < cbTotal; cP++ )
                {
                    cbCurr += pbPayloadHeader[cbPresTimeOffset + OFFSET_TO_REP_DATA
                        + cbPayloadLengthField + 1 + cbCurr + cP];
                }

                NSASSERT( cbCurr + cP == cbTotal );
                m_StreamInfo[bStreamID].msLastDurationWritten =
                    cbCurr * 1000 * 8 / m_StreamInfo[ bStreamID ].dwBitrate;
            }
            else
            {
                m_StreamInfo[ bStreamID ].msLastDurationWritten = payloadMap[ dwPayload ].ObjectSize() * 1000 * 8 / m_StreamInfo[ bStreamID ].dwBitrate;
            }
        }

        //
        // If there's nothing to adjust, continue here
        //
        if( 0 == m_msPresTimeAdjust && 0 == m_StreamInfo[ bStreamID ].bObjectIDAdjust )
        {
            continue;
        }

        //
        // Adjust the object id
        //
        pbPayloadHeader[ 1 ] = payloadMap[ dwPayload ].ObjectId() + m_StreamInfo[ bStreamID ].bObjectIDAdjust;
        m_StreamInfo[ bStreamID ].bLastObjectID = pbPayloadHeader[ 1 ];

        // The DVR sink uses this field during index generation.
        payloadMap[ dwPayload ].bObjectId = pbPayloadHeader[ 1 ];

        //
        // Adjust the presentation time
        //
        NSAssert( m_msPresTimeAdjust <= msWrappedPresTime );
        payloadMap[ dwPayload ].msObjectPres = (DWORD)( msWrappedPresTime - m_msPresTimeAdjust );

        if( 1 == cbRepData )
        {
            //
            // This is a compressed payload - the offset contains the PT
            //
            SetUnalignedDword( &pbPayloadHeader[ cbPresTimeOffset + 1 ],
                   ( DWORD ) payloadMap[ dwPayload ].msObjectPres );
        }
        else if( 8 <= cbRepData )
        {
            //
            // This payload's replicated data contains at least the object size
            // and PT.  Skip over the one byte replicated data len.
            //
            SetUnalignedDword(
                &pbPayloadHeader[ cbPresTimeOffset + OFFSET_TO_REP_DATA + pParseInfoEx->bOffsetBytes ],
                ( DWORD ) payloadMap[ dwPayload ].msObjectPres );
        }
        else
        {
            NSASSERT( !"Bad replicated data length in ASFv1 payload!" );
        }
    }

    return( S_OK );
}

///////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMFileSinkV1::NotifyCallbacksOnError(  HRESULT hrError )
{
    //
    // notify the callback
    //
    if( FAILED( hrError ) && ( m_Callbacks.GetSize() > 0 ) )
    {
        AutoLock<Mutex> lock( m_CallbackMutex );

        //
        // notify the world
        //
        DWORD   dwNothing = 0;

        for( DWORD i = 0; i < m_Callbacks.GetSize(); i++ )
        {
            m_Callbacks[i]->pCallback->OnStatus(    WMT_ERROR,
                                                    hrError,
                                                    WMT_TYPE_DWORD,
                                                    (BYTE*)&(dwNothing),
                                                    m_Callbacks[i]->pvContext );
        }

    }

    return( S_OK );
}

///////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWMFileSinkV1::CanIndexWithSimpleIndexObjectOnly()
{
    BOOL fCanIndexWithSimpleIndexObjectOnly = TRUE;
    HRESULT hr = S_OK;

    //
    // The following conditions would cause a file to
    // require the new index object in order to be
    // seekable:
    //      * Hidden streams
    //      * VBR audio, even if it's not hidden
    //

    do
    {
        LISTPOS pos = NULL;
        hr = m_pASFHeader->GetFirstObjectPosition( pos );
        if ( FAILED( hr ) )
        {
            break;
        }

        CASFLonghandObject *pObject = NULL;
        while( pos && SUCCEEDED( m_pASFHeader->GetNextObject( &pObject, pos ) ) )
        {
            GUID guidObject;
            hr = pObject->GetObjectID( guidObject );
            if ( FAILED( hr ) )
            {
                break;
            }

            if ( CLSID_CAsfStreamPropertiesObjectEx == guidObject )
            {
                CASFStreamPropertiesObjectEx *pSPOEx =
                    (CASFStreamPropertiesObjectEx *) pObject;

                CASFStreamPropertiesObject *pHiddenSPO = NULL;
                pSPOEx->GetStreamPropertiesObject( &pHiddenSPO );

                if ( pHiddenSPO )
                {
                    //
                    // This one is hidden
                    //
                    fCanIndexWithSimpleIndexObjectOnly = FALSE;
                }
            }
            else if ( CLSID_CAsfStreamPropertiesObjectV1 == guidObject )
            {
                //
                // A non-hidden stream.
                // If it's audio we'll need to check for VBR
                //
                CASFStreamPropertiesObject *pSPO =
                    (CASFStreamPropertiesObject *) pObject;

                GUID guidStreamType = GUID_NULL;
                pSPO->GetStreamType( guidStreamType );

                if ( CLSID_AsfXStreamTypeAcmAudio == guidStreamType )
                {
                    if ( IsVBR( pSPO ) )
                    {
                        fCanIndexWithSimpleIndexObjectOnly = FALSE;
                    }
                }

            }

            pObject->Release();

        }
    }   while( FALSE );

    if ( FAILED( hr ) )
    {
        fCanIndexWithSimpleIndexObjectOnly = FALSE;
    }

    return( fCanIndexWithSimpleIndexObjectOnly );

}

///////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWMFileSinkV1::IsV1Seekable(   CASFStreamPropertiesObject *pStreamProps )
{
    if ( !pStreamProps )
    {
        return( FALSE );
    }

    WORD wStreamNumber = 0;
    pStreamProps->GetStreamNumber( wStreamNumber );

    BOOL fV1Seekable = TRUE;  // benefit of the doubt

    GUID    guidStreamType;

    HRESULT hr = S_OK;

    do
    {
        hr = pStreamProps->GetStreamType( guidStreamType );
        if( SUCCEEDED( hr ) )
        {
            if( guidStreamType != CLSID_AsfXStreamTypeAcmAudio &&
                guidStreamType != CLSID_AsfXStreamTypeScriptCommand )
            {
                //
                // Video stream: Seekable only if we have
                // an indexer for it
                //
                if ( !m_StreamNumberToIndex[ wStreamNumber ] || !m_fSimpleIndexObjectWritten )
                {
                    //
                    // Video stream with no index!
                    //
                    fV1Seekable = FALSE;
                }
            }
        }
        else
        {
            fV1Seekable = FALSE;
        }

    }   while( FALSE );

    if ( FAILED( hr ) )
    {
        fV1Seekable = FALSE;
    }

    return( fV1Seekable );

}

///////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWMFileSinkV1::IsVBR(   CASFStreamPropertiesObject *pStreamProps )
{
    if ( !pStreamProps )
    {
        return( FALSE );
    }

    BOOL fVBR = FALSE;
    CASFLonghandObject *pObject = NULL;
    HRESULT hr = S_OK;

    //
    // Now we're going to look for VBR info on this stream.
    // If we can find any, then it's not V1-seekable
    //
    do
    {
        WORD wStreamNumber = 0;
        hr = pStreamProps->GetStreamNumber( wStreamNumber );
        if ( FAILED( hr ) )
        {
            break;
        }

        LISTPOS pos = NULL;
        hr = m_pASFHeader->GetFirstObjectPosition( pos );
        if ( FAILED( hr ) )
        {
            break;
        }

        BOOL fSPOExFound = FALSE;
        CASFStreamPropertiesObjectEx *pSPOEx = NULL;
        while( !fSPOExFound && pos && SUCCEEDED( m_pASFHeader->GetNextObject( &pObject, pos ) )  )
        {
            GUID guidObject;
            hr = pObject->GetObjectID( guidObject );
            if ( FAILED( hr ) )
            {
                break;
            }

            if ( CLSID_CAsfStreamPropertiesObjectEx == guidObject )
            {
                pSPOEx = (CASFStreamPropertiesObjectEx *) pObject;

                WORD wExStreamNumber = 0;
                pSPOEx->GetStreamNumber( wExStreamNumber );

                if ( wExStreamNumber == wStreamNumber )
                {
                    fSPOExFound = TRUE;
                }
            }

            if ( !fSPOExFound )
            {
                SAFE_RELEASE( pObject );
            }
            // otherwise it'll get released further down
        }

        if ( fSPOExFound )
        {
            //
            // We found it, now check the VBR data
            //
            fVBR = IsVBR( pSPOEx );
        }

        //
        // Otherwise we know it isn't VBR
        //

    }   while( FALSE );

    if ( FAILED( hr ) )
    {
        fVBR = FALSE;
    }

    SAFE_RELEASE( pObject );

    return( fVBR );
}

///////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWMFileSinkV1::IsVBR(   CASFStreamPropertiesObjectEx *pStreamPropsEx )
{
    if ( !pStreamPropsEx )
    {
        return( FALSE );
    }

    BOOL fVBR = FALSE;

    //
    // We found it, now check the VBR data
    //
    DWORD dwAvgBitrate = 0;
    DWORD dwMaxBitrate = 0;
    pStreamPropsEx->GetAvgDataBitrate( dwAvgBitrate );
    pStreamPropsEx->GetMaxDataBitrate( dwMaxBitrate );
    if ( dwAvgBitrate != dwMaxBitrate )
    {
        fVBR = TRUE;
    }

    return( fVBR );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\wmsdk\zeusette\sdk\writer\sink\dvrsource\dvrsource.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       DVRSource.h
//
//  Classes:    CDVRSource
//
//  Contents:   Definition of the CDVRSource class
//
//--------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __DVRSOURCE_H_
#define __DVRSOURCE_H_

#include "wmsdk.h"
#include "wmsstd.h"
#include "writerstate.h"
#include "asfmmstr.h"
#include "debughlp.h"
#include "sync.h"
#include "Basefilter.h"
#include "tordlist.h"
#include "wmsdkbuffer.h"
#include "asfobj.h"
#include "DVRFileSource.h"
#include "DVRSharedmem.h"

class CDVRSource :
        public IStream,
        public IDVRFileSource2,
        public IWMIStreamProps
{
public:

    CDVRSource(HKEY hDvrKey,
               HKEY hDvrIoKey,
               DWORD dwNumSids,
               PSID* ppSids,
               HRESULT *phr,
               IDVRSourceAdviseSink*  pDVRSourceAdviseSink /* OPTIONAL */ );

    virtual ~CDVRSource();

    //
    // IUnknown methods
    //
    STDMETHOD( QueryInterface )( REFIID riid, void **ppvObject );
    STDMETHOD_( ULONG, AddRef )();
    STDMETHOD_( ULONG, Release )();

    //
    // IDVRFileSource methods
    //
    STDMETHOD( Open )(LPCWSTR pwszFileName,
                      HANDLE  hEvent,   // OPTIONAL
                      DWORD   dwTimeOut /* in milliseconds */ );
    STDMETHOD( Close )();
    STDMETHOD( IsFileLive )(BOOL* pbLiveFile, BOOL* pbShared);
    STDMETHOD( GetFileSize )(QWORD* pqwFileSize);
    STDMETHOD( GetLastTimeStamp )(QWORD* pcnsLastTimeStamp);
    STDMETHOD( Cancel )();
    STDMETHOD( ResetCancel )();

    STDMETHODIMP
    SetAsyncIOReader (
        IN  IDVRAsyncReader *   pIDVRAsyncReader
        ) ;

    //
    // IStream methods: We implement only Stat, Read and Seek!!
    //
    STDMETHOD( Read )(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD( Write )(void const *pv, ULONG cb, ULONG *pcbWritten);
    STDMETHOD( Seek )(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHOD( SetSize )(ULARGE_INTEGER libNewSize);
    STDMETHOD( CopyTo )(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHOD( Commit )(DWORD grfCommitFlags);
    STDMETHOD( Revert )();
    STDMETHOD( LockRegion )(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD( UnlockRegion )(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD( Stat )(STATSTG *pStatStg, DWORD grfStatFlag);
    STDMETHOD( Clone )(IStream **ppstm);

    // IWMIStreamProps methods
    STDMETHOD( GetProperty )(LPCWSTR pszName,           // in
                             WMT_ATTR_DATATYPE *pType,  // out
                             BYTE *pValue,              // out
                             DWORD *pdwSize             // in out
                            );

protected:

    virtual void        AssertIsClosed();
    virtual HRESULT     LockSharedMemory(BOOL& bReleaseSharedMutex);

    HRESULT
    ReadBytesLocked (
        IN  LPVOID  pBuffer,
        IN  DWORD   dwRead,
        OUT DWORD * pdwRead
        ) ;

    HRESULT
    SeekToLocked (
        IN  LARGE_INTEGER * pliOffsetSeekTo,
        IN  DWORD           dwMoveMethod,       //  FILE_BEGIN, FILE_CURRENT, FILE_END
        OUT LARGE_INTEGER * pliOffsetActual
        ) ;

protected:

    //
    // Data members
    //
    // Current position in the combined file, set as a result of a
    // a call to Seek or a previous Read
    QWORD               m_qwCurrentPosition;

    // Initialized from CDVRSharedMemory::qwIndexHeaderOffset and
    // never changed after that. Always 0 if the file is not live.
    QWORD               m_qwMaxHeaderAndDataSize;

    // Set to MAXQWORD if the file is live, else to the file's
    // real size. It is set when the file is opened and is not
    // changed after that.
    QWORD               m_qwFileSize;

    // Current position for the file pointer m_hTempIndexFile. Always
    // 0 if there is no temp index file. We need this because seeks
    // to the index portion of the file are lazy; when we read from the
    // temp index file, we may have to seek first.
    QWORD               m_qwIndexFileOffset;

    LPWSTR              m_pwszFilename;
    CDVRSharedMemory*   m_pShared;
    IDVRSourceAdviseSink*  m_pDVRSourceAdviseSink;
    HANDLE              m_hFile;
    HANDLE              m_hFileMapping;
    HANDLE              m_hTempIndexFile; // NULL if file is temporary

    HANDLE              m_hMutex;               // For the shared section
    HANDLE              m_hWriterNotification;  // manual reset event
    HANDLE              m_hCancel;              // manual reset event
    HANDLE              m_hWriterProcess;       // Writer process handle

    IDVRAsyncReader *   m_pIDVRAsyncReader ;

    // Registry key handles are opened and closed by the creator of the sink
    HKEY                m_hDvrKey;
    HKEY                m_hDvrIoKey;

    // Index into CDVRSharedMemory::Readers[] that is used by this reader
    DWORD               m_dwReadersArrayIndex;

    ULONG               m_nRefCount;

    // Note that this flag is not the same as CDVRSharedMemory::dwBeingWritten
    // The file is considered live as long as a memory mapping object is
    // found. The file may have been closed by the writer, but the memory
    // mapping may still be available because the file is still in the ring
    // buffer.
    BOOL                m_bFileIsLive;

    enum {
        DVR_SOURCE_CLOSED,
        DVR_SOURCE_OPENED
    }                   m_dwState;

    DWORD               m_dwNumSids;
    CRITICAL_SECTION    m_cs;                   // For this class
    PSID*               m_ppSids;

}; // CDVRSource

#endif // __DVRSOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\sbe\wmsdk\zeusette\sdk\writer\sink\filesinkv1\filesinkv1.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       WMFileSinkv1.h
//
//  Classes:    CWMFileSinkV1
//
//  Contents:   Definition of the CWMFileSinkV1 class.
//
//  History:    7-26-99     sleroux Initial version.
//
//--------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __FILESINKV1_H_
#define __FILESINKV1_H_

#include "wmsdk.h"
#include "wmsstd.h"
#include "writerstate.h"
#include "asfmmstr.h"
#include "debughlp.h"
#include "sync.h"
#include "Basefilter.h"
#include "tordlist.h"
#include "wmsdkbuffer.h"
#include "indexonthefly.h"
#include "unbuffered.h"

//
// Callbacks
//
struct WRITER_SINK_CALLBACK
{
    IWMStatusCallback*  pCallback;
    void*               pvContext;
};

////////////////////////////////////////////////////////////////////////////
class CWMFileSinkV1 :
        public IWMWriterFileSink3,
        public IWMRegisterCallback
{
public:

    CWMFileSinkV1::CWMFileSinkV1( HRESULT *phr, CTPtrArray<WRITER_SINK_CALLBACK> *pCallbacks );
    virtual CWMFileSinkV1::~CWMFileSinkV1();

    //
    // IUnknown methods
    //
    STDMETHOD( QueryInterface )( REFIID riid, void **ppvObject );

    STDMETHOD_( ULONG, AddRef )();
    STDMETHOD_( ULONG, Release )();

    //
    // IWMWriterFileSink2 methods
    //
    STDMETHOD( Open )( const WCHAR *pwszFilename );
    STDMETHOD( Close )();
    STDMETHOD( IsClosed )( BOOL *pfClosed );

    STDMETHOD( Start )( QWORD cnsTime );
    STDMETHOD( Stop )(  QWORD cnsTime );
    STDMETHOD( IsStopped )( BOOL *pfStopped );

    STDMETHOD( GetFileDuration )( QWORD* pcnsDuration );
    STDMETHOD( GetFileSize )( QWORD* pcbFile );

    //
    // IWMWriterFileSink3 methods
    //
    STDMETHOD( SetAutoIndexing )( BOOL fDoAutoIndexing );
    STDMETHOD( GetAutoIndexing )( BOOL *pfAutoIndexing );
    STDMETHOD( SetControlStream )(  WORD wStreamNumber,
                                    BOOL fShouldControlStartAndStop );
    STDMETHOD( GetMode )( DWORD *pdwFileSinkModes );
    STDMETHOD( OnDataUnitEx )( WMT_FILESINK_DATA_UNIT *pFileSinkDataUnit );

    //
    // OK!  Listen up, because this is important!
    //
    // If we're using the sink in unbuffered mode, then we MUST provide
    // the sink with an opportunity to complete i/o operations on the
    // thread that issued those writes!
    //
    // Writes are potentially issued as a result of the following calls:
    //
    //     OnHeader
    //     OnDataUnit
    //     OnDataUnitEx
    //
    // If you call these functions from different threads, or fail to
    // call CompleteOperations from the thread that called these functions
    // before trying to close the sink, you will probably deadlock.
    //
    // Using the unbuffered sink optimization is not for the faint of
    // heart, though the benefit it provides in certain scenarios is
    // worth the effort involved!
    //

    STDMETHOD( SetUnbufferedIO )( BOOL fUnbufferedIO, BOOL fRestrictMemUsage );
    STDMETHOD( GetUnbufferedIO )( BOOL *fUnbufferedIO );
    STDMETHOD( CompleteOperations )( );

    //
    // IWMWriterSink methods
    //
    STDMETHOD( OnHeader )( INSSBuffer *pHeader );
    STDMETHOD( IsRealTime )( BOOL *pfRealTime );
    STDMETHOD( AllocateDataUnit )( DWORD cbDataUnit, INSSBuffer **ppDataUnit );
    STDMETHOD( OnDataUnit )( INSSBuffer *pDataUnit );
    STDMETHOD( OnEndWriting ) ();

    //
    // IWMRegisterCallback
    //
    STDMETHOD( Advise )(    IWMStatusCallback* pCallback, void* pvContext );
    STDMETHOD( Unadvise )(  IWMStatusCallback* pCallback, void* pvContext );


protected:

    HRESULT     UpdateHeader();

    virtual HRESULT     SetupIndex();

    virtual HRESULT     Write(  BYTE *pbBuffer,
                                DWORD dwBufferLength,
                                DWORD *pdwBytesWritten );

    HRESULT     CreateIndexer(  CASFStreamPropertiesObject *pSPO,
                                DWORD dwPacketSize );

    HRESULT     ProcessParsedDataUnit(  BYTE *pbPacketHeader,
                                        BYTE **ppbPayloadHeaders,
                                        DWORD cPayloads,
                                        PACKET_PARSE_INFO_EX *parseInfoEx,
                                        CPayloadMapEntryEx *payloadMap );

    HRESULT     GetTimeStamp( BYTE* pbData, DWORD cbData, PACKET_PARSE_INFO_EX* parseInfoEx, CPayloadMapEntryEx* payloadMap );
    HRESULT     GetTimeStamp(       BYTE *pbPacketHeader,
                                    BYTE **ppbPayloadHeaders,
                                    DWORD cPayloads,
                                    PACKET_PARSE_INFO_EX* parseInfoEx,
                                    CPayloadMapEntryEx* payloadMap );

    HRESULT     AdjustTimeStamps(   BYTE*   pbPacketHeader,
                                    BYTE**  ppbPayloadHeaders,
                                    DWORD   cPayloads,
                                    PACKET_PARSE_INFO_EX* parseInfoEx,
                                    CPayloadMapEntryEx* payloadMap );

    HRESULT     NotifyCallbacksOnError( HRESULT hrError );

    virtual HRESULT     InternalOpen( const WCHAR *pwszFilename );
    virtual HRESULT     InternalClose();
    virtual HRESULT     GenerateIndexEntries( PACKET_PARSE_INFO_EX& parseInfoEx,
                                              CPayloadMapEntryEx *payloadMap );
    virtual HRESULT     WriteOutIndexObjects();
    virtual CASFMMStream* CreateMMStream(BYTE hostArch = LITTLE_ENDIAN,
                                         BYTE streamArch = LITTLE_ENDIAN,
                                         BOOL fStrict = TRUE)
    {
        return CASFMMStream::CreateInstance(hostArch, streamArch, fStrict);
    }

    virtual HRESULT     ProcessCommands( PACKET_PARSE_INFO_EX* parseInfoEx, CPayloadMapEntryEx* payloadMap );
    virtual BOOL        CommandShouldExecuteNow(    QWORD msCommandTime,
                                                    PACKET_PARSE_INFO_EX *parseInfoEx,
                                                    CPayloadMapEntryEx *payloadMap );
    virtual HRESULT     DoStart( QWORD msTime );
    virtual HRESULT     DoStop( QWORD msTime );

    BOOL        ShouldWriteData( VOID )
    {
        return( WRITER_FILESINK_ERROR_SEV_NOERROR == m_wfse );
    }

    virtual BOOL        CanIndexWithSimpleIndexObjectOnly();
    virtual BOOL        IsV1Seekable(   CASFStreamPropertiesObject *pStreamProps );
    virtual BOOL        IsVBR(  CASFStreamPropertiesObject *pStreamProps );
    virtual BOOL        IsVBR(  CASFStreamPropertiesObjectEx *pStreamPropsEx );

protected:

    //
    // State info
    //
    LONG            m_cRef;
    BOOL            m_fHeaderReceived;
    BOOL            m_fHeaderWritten;
    BOOL            m_fStopped;
    BOOL            m_fWriterFilesLookLive;
    BOOL            m_fUnbufferedIO;
    BOOL            m_fRestrictMemUsage;

    Mutex           m_GenericMutex;
    Mutex           m_CommandMutex;
    Mutex           m_CallbackMutex;

    //
    // Destination info
    //
    HANDLE          m_hRecordFile;
    WCHAR*          m_pwszFilename;
    DWORD           m_dwFileAttributes;
    DWORD           m_dwFileShareFlags;
    DWORD           m_dwFileCreationDisposition;

    //
    // Header info
    //
    DWORD           m_cbHeaderReceived;
    DWORD           m_cbHeader;
    BYTE*           m_pbHeader;
    CASFMMStream*   m_pASFHeader;
    QWORD           m_qwPreroll;

    //
    // Stats info
    //
    QWORD           m_cDataUnitsWritten;
    QWORD           m_cbCurrentFileSize;
    QWORD           m_msLastTimeStampSeen;
    DWORD           m_cLastTimeStampSeenWraps;
    QWORD           m_msLastTimeStampWritten;
    QWORD           m_msPresTimeAdjust;
    QWORD           m_msSendTimeAdjust;
    QWORD           m_msTimeStampStopped;
    QWORD           m_cbIndexSize;
    BOOL            m_fSimpleIndexObjectWritten;
    BOOL            m_fNewIndexObjectWritten;


    //
    // stores duration calculated at OnEndWriting
    //
    QWORD           m_cnsDuration;

    //
    // per-stream info
    //
    struct STREAM_INFO
    {
        DWORD   msLastPresTimeSeen;
        DWORD   cLastPresTimeSeenWraps;
        QWORD   msLargestPresTimeSeen;
        QWORD   msLargestPresTimeWritten;
        DWORD   msLastDurationWritten;
        BYTE    bLastObjectID;
        BYTE    bObjectIDAdjust;
        BOOL    fDiscontinuity;
        DWORD   dwBitrate;
        DWORD   msDurationPerObject;
        BOOL    fIsControlStream;
    };

    #define MAX_STREAMS 64

    STREAM_INFO m_StreamInfo[MAX_STREAMS];

    //
    // Data unit info
    //
    PACKET_PARSE_INFO_EX    m_parseInfoEx;
    CPayloadMapEntryEx      m_payloadMap[ CPayloadMapEntry::MAX_PACKET_PAYLOADS ];

    BYTE *m_pbPayloadHeaders[ CPayloadMapEntry::MAX_PACKET_PAYLOADS ];
    DWORD m_cbPayloadHeaders[ CPayloadMapEntry::MAX_PACKET_PAYLOADS ];

    QWORD       m_msLargestPresTimeWritten; // used by the DVR sink

    //
    // index info
    //
    CWMPerStreamIndex *m_StreamNumberToIndex[ MAX_STREAMS ]; // lookup table
    CWMPerStreamIndex *m_StreamIndex[ MAX_STREAMS ];
    WORD m_cIndexers;
    QWORD m_qwNextNewBlockPacket;
    BOOL m_fAutoIndex;


    //
    // pending commands
    //
    enum WRITER_SINK_ACTION
    {
        WRITER_SINK_START = 1,
        WRITER_SINK_STOP = 2
    };

    struct WRITER_SINK_COMMAND
    {
        WRITER_SINK_ACTION  action;
        QWORD               time;
    };

    CTOrderedList<QWORD, WRITER_SINK_COMMAND*> m_Commands;

    WORD                    m_cControlStreams;

    //
    // Callbacks
    //
    CTPtrArray<WRITER_SINK_CALLBACK>   m_Callbacks;
    BOOL                               m_fCallbackOnOpen;

    //
    // A buffer pool for requested buffers
    //
    CWMSDKBufferPool*       m_pAllocator;

    //
    // A zeroed buffer from which we can write padding bytes
    // in the fast file write case
    //
    BYTE*                   m_pbPaddingBuffer;

    //
    // File Sink Write Error Severity
    //
    enum WRITER_FILESINK_ERROR_SEV
    {
        WRITER_FILESINK_ERROR_SEV_NOERROR = 0,
        WRITER_FILESINK_ERROR_SEV_ONHEADER = 1,
        WRITER_FILESINK_ERROR_SEV_ONDATA = 2,
        WRITER_FILESINK_ERROR_SEV_ONINDEX = 3
    };

    WRITER_FILESINK_ERROR_SEV m_wfse;

    //
    // The unbuffered writer, if we're using it.
    //
    CUnbufferedWriter *m_pUnbufferedWriter;
};

#endif // __FILESINKV1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\audilyzer\audilyzer.cpp ===
#include <streams.h>
#include <initguid.h> 
#include <uuids.h>
#include <ks.h>
#include <ksmedia.h>
#include <dvdmedia.h>
#include <audilyzer.h>
#include <stdio.h>
#include <assert.h>
#include <tchar.h>
///
///   AM stuff
///

#define XFORMAUDIO

// {EE001998-B7CB-11d2-A4F7-00C04F79A597}
DEFINE_GUID(CLSID_AudilyzerFilter, 0xEE001998, 0xB7CB, 0x11D2, 0xA4, 0xF7, 0x00, 0xC0, 0x4F, 0x79, 0xA5, 0x97);

static AMOVIESETUP_MEDIATYPE sudInputTypes[] = {
    {
        &MEDIATYPE_Audio,
        &MEDIASUBTYPE_PCM
    },
	{
		&MEDIATYPE_MPEG2_PES,
		&MEDIASUBTYPE_DVD_LPCM_AUDIO
	},
	{
		&MEDIATYPE_MPEG2_PES,
		&MEDIASUBTYPE_MPEG2_AUDIO
	},
	{
		&MEDIATYPE_Audio,
		&MEDIASUBTYPE_MPEG2_AUDIO
	},
	{
		&MEDIATYPE_Audio,
		&MEDIASUBTYPE_DVD_LPCM_AUDIO
	}
};

// Note that PES output types must be listed last to support
// CAudioOutputPin::GetMediaType()

static AMOVIESETUP_MEDIATYPE sudOutputTypes[] =
{
	{
		&MEDIATYPE_Audio,
		&MEDIASUBTYPE_DVD_LPCM_AUDIO
	},
    {
        &MEDIATYPE_Audio,
        &MEDIASUBTYPE_PCM
    },
	{
		&MEDIATYPE_Audio,
		&MEDIASUBTYPE_MPEG2_AUDIO
	},
	{
		&MEDIATYPE_MPEG2_PES,
		&MEDIASUBTYPE_MPEG2_AUDIO
	},
	{
		&MEDIATYPE_MPEG2_PES,
		&MEDIASUBTYPE_DVD_LPCM_AUDIO
	}
};

static AMOVIESETUP_MEDIATYPE sudDebugTypes[] =
{
	{
		&MEDIATYPE_Text,
		&GUID_NULL
	}
};

static AMOVIESETUP_PIN RegistrationPinInfo[] =
{
    { // input
        L"PES audio input",
        FALSE, // bRendered
        FALSE, // bOutput
        FALSE, // bZero
        FALSE, // bMany
        &CLSID_NULL, // clsConnectsToFilter
        NULL, // ConnectsToPin
        NUMELMS(sudInputTypes), // nMediaTypes
        sudInputTypes
    },
    { // output
        L"audio output",
        FALSE, // bRendered
        TRUE, // bOutput
        FALSE, // bZero
        FALSE, // bMany
        NULL, // clsConnectsToFilter
        NULL, // ConnectsToPin
        NUMELMS(sudOutputTypes), // nMediaTypes
        sudOutputTypes // lpMediaType
    },
#ifdef DEBUG
    { // output
        L"debug output",
        FALSE, // bRendered
        TRUE, // bOutput
        FALSE, // bZero
        FALSE, // bMany
        NULL, // clsConnectsToFilter
        NULL, // ConnectsToPin
        NUMELMS(sudDebugTypes), // nMediaTypes
        sudDebugTypes // lpMediaType
    }
#endif // DEBUG
};

AMOVIESETUP_FILTER RegistrationInfo =
{
    &CLSID_AudilyzerFilter,
    L"PES Audio Analyzer",
    MERIT_UNLIKELY, // merit
    NUMELMS(RegistrationPinInfo), // nPins
    RegistrationPinInfo
};

CFactoryTemplate g_Templates[] =
{
    {
        L"PES Audio Analyzer g_Templates name",
        &CLSID_AudilyzerFilter,
        CAudilyzerFilter::CreateInstance,
        NULL,
        &RegistrationInfo
    }
};

int g_cTemplates = NUMELMS(g_Templates);

STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}

CUnknown * CALLBACK
CAudilyzerFilter::CreateInstance( LPUNKNOWN UnkOuter, HRESULT* hr )
{
    CUnknown *Unknown;

    *hr = S_OK;
    Unknown = new CAudilyzerFilter( UnkOuter, hr );
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
}

#define SWAP( x )	((((x) & 0xFF) << 8) | (((x) & 0xFF00) >> 8))

CAudilyzerFilter::CAudilyzerFilter( LPUNKNOWN UnkOuter, HRESULT* hr ) :
	CBaseFilter(
        TEXT("PES Audio Analyzer CBaseFilter"),
        UnkOuter,
		&m_csFilter,
        CLSID_AudilyzerFilter,
		hr
    ),
	m_bPESAvailable( FALSE ),
	m_pDebug( NULL ),
	m_pInput( NULL ),
	m_pOutput( NULL ),
	m_ulMaxBPS( 0 ),
	m_ulMinBPS( 0 ),
	m_bOutputPES( FALSE ),
	m_pMediaSample( NULL ),
	m_pts( 0 ),
	m_state( CLEAN ),
	m_bytesOutstanding( 0 ),
	m_pCurrentHeader( NULL ),
	m_bTransform( FALSE )
{
    m_pInput = new CAudioInputPin( TEXT("PES Audio Analyzer PES Audio Input Pin"),
								   this, &m_csFilter, hr, L"[PES] audio in" );
    m_pOutput = new CAudioOutputPin( TEXT("PES Audio Analyzer Audio Output Pin"),
									 this, &m_csFilter, hr, L"[PES] audio out" );
#ifdef DEBUG
	m_pDebug = new CDebugOutputPin( TEXT("PES Audio Analyzer Debug Output Pin" ),
									this, &m_csFilter, hr, L"debug out" );
#endif // DEBUG

	memset( (void *) &m_staticHeader, 0, sizeof( PES_HEADER ) );
	m_staticHeader.packet_start_code_prefix[2] = 0x01;
	memset( (void *) m_startCode, 0, sizeof( m_startCode ) );
	m_startCode[2] = 0x01;
	LONG i;

	for ( i = 0; i < 0x10000; i++ )
	{
		m_xformTable[i] = SWAP( i );
	}
}

CAudilyzerFilter::~CAudilyzerFilter()
{
	if (NULL != m_pInput)
		delete m_pInput;
	if (NULL != m_pOutput)
		delete m_pOutput;
	if (NULL != m_pDebug)
		delete m_pDebug;

	if (NULL != m_pMediaSample)
	{
		m_pMediaSample->Release();
		m_pMediaSample = NULL;
	}
}

int CAudilyzerFilter::GetPinCount(void)
{
	if (NULL == m_pDebug)
		return m_pInput->IsConnected() ? 2 : 1;
	else
		return m_pInput->IsConnected() ? 3 : 2;
}

class CBasePin* CAudilyzerFilter::GetPin(int nPin)
{
    switch (nPin) {
        case 0:
			return m_pInput;

		case 1: 
			if (NULL == m_pDebug)
				return m_pInput->IsConnected() ? m_pOutput : NULL;
			else
				return m_pDebug;

        case 2: 
			if (NULL != m_pDebug)
				return m_pInput->IsConnected() ? m_pOutput : NULL;
			return NULL;

        default: return NULL;
    };
}

HRESULT CAudilyzerFilter::DecideBufferSize( IMemAllocator *pAllocator, ALLOCATOR_PROPERTIES *pprop )
{
	if (m_pInput->IsConnected())
	{
		/*
		** We'll use the settings provided from the upstream filter...
		*/
		IMemAllocator	*pUpStreamAllocator = NULL;
		m_pInput->GetAllocator( &pUpStreamAllocator );
		ALLOCATOR_PROPERTIES	propsUpstream;
		pUpStreamAllocator->GetProperties( &propsUpstream );
		pUpStreamAllocator->Release();

		pprop->cbBuffer = propsUpstream.cbBuffer;
		pprop->cBuffers = propsUpstream.cBuffers;

		ALLOCATOR_PROPERTIES	propsActual;
		HRESULT	hr = pAllocator->SetProperties(pprop, &propsActual);
		if (SUCCEEDED(hr))
		{
			if ((propsActual.cbBuffer == 0) || (propsActual.cBuffers == 0))
				return E_FAIL;
			else
				return NOERROR;
		}
		else              
			return hr;
	}

	return E_FAIL;

}

HRESULT CAudilyzerFilter::SetMediaType(PIN_DIRECTION direction, const CMediaType *pmt)
{
	switch (direction)
	{
	case PINDIR_INPUT:
#if 0
		m_bPESAvailable = TRUE;
#else
		m_bPESAvailable = (MEDIATYPE_MPEG2_PES == pmt->majortype);
#endif // 0

		if ((FORMAT_WaveFormatEx == pmt->formattype) && 
			(NULL != (WAVEFORMATEX *) (pmt->pbFormat)))
			m_wfx = * (WAVEFORMATEX *) (pmt->pbFormat);

		m_ulMaxBPS = m_wfx.nAvgBytesPerSec * 8;
		m_ulMinBPS = m_ulMaxBPS;

#ifdef XFORMAUDIO
#if 1
		m_inputFormat = LPCM;
#else
		m_inputFormat = (MEDIASUBTYPE_DVD_LPCM_AUDIO == pmt->subtype) ? LPCM : PCM;
#endif // 1
#endif // XFORMAUDIO
		break;

	case PINDIR_OUTPUT:
#ifdef XFORMAUDIO
		m_outputFormat = (MEDIASUBTYPE_DVD_LPCM_AUDIO == pmt->subtype) ? LPCM : PCM;
		m_bTransform = (m_inputFormat != m_outputFormat);
#endif // XFORMAUDIO
		m_bOutputPES = (MEDIATYPE_MPEG2_PES == pmt->majortype);
		break;

	default:
		break;
	}

	return NOERROR;
}

/* Stream Processing **********************************************************/

BOOL CAudilyzerFilter::Process( BYTE *pBuffer, LONG bufferSize, BYTE streamID )
{
	BYTE	*pGuard = pBuffer + bufferSize;
	BYTE	*pScan = pBuffer;

	if (m_bPESAvailable)
	{
		LONG	hdrSize = sizeof( PES_HEADER );
		LONG	skipped = 0L;

		while (pScan < pGuard)
		{
			switch (m_state)
			{
			case CLEAN:
				{
					if (0 == *pScan)
					{
						// Found a single 0x00
						if (0 < skipped)
						{
							Consume( pScan - skipped, skipped );
							skipped = 0;
						} // 0 < skipped
						pScan++;
						m_state = ONEOH;
					} // 0 == *pScan
					else
					{
						// Emit current *pScan
						pScan++;
						skipped++;
						// m_state = CLEAN;
					} // 0 != *pScan
				} // CLEAN
				break;

			case ONEOH:
				{
					if (0 == *pScan)
					{
						// Now we've found 0x00 0x00
						pScan++;
						m_state = TWOOHS;
					} // 0 == *pScan
					else
					{
						// Emit an 0x00 and *pScan before returning to CLEAN state
						Consume( m_startCode, 1 );
						Consume( pScan++, 1 );
						m_state = CLEAN;
					} // 0 != *pScan
				} // ONEOH
				break;

			case TWOOHS:
				{
					switch (*pScan)
					{
					case 1:
						{
							// Now we've found 0x00 0x00 0x01
							pScan++;
							m_state = OHOHONE;
						} // case 1
						break;

					case 0:
						{
							// Emit an 0x00 before continuing
							Consume( pScan++, 1 );
							m_state = TWOOHS;
						} // case 0
						break;

					default:
						{
							// Emit 0x00, 0x00 and *pScan before returning to CLEAN state
							Consume( m_startCode, 2 );
							Consume( pScan++, 1 );
							m_state = CLEAN;
						} // default
						break;
					} // switch (*pScan)
				} // TWOOHS
				break;

			case OHOHONE:
				{
					switch (*pScan)
					{
					case 0xB3: // Sequence Header
						{
							// Send current media sample, if not empty
							// Start new media sample, setting its SyncPoint flag
							// emit 4 bytes consumed while identifying the header
							// return to CLEAN state
	/*
							((CPESVideoConsumer *) pConsumer)->Flush();
	*/
							SetSyncPoint();
							Consume( m_startCode, 3 );
							Consume( pScan++, 1 );

							m_state = CLEAN;
						} // case 0xB3
						break;

					default:
						{
							if (streamID == *pScan)
							{
								// Now we've found 0x00 0x00 0x01 followed by streamID
								m_staticHeader.stream_id = *pScan++;
								m_bytesOutstanding = sizeof( PES_HEADER ) - 4;
								m_state = PESHEADER;
							} // streamID == *pScan
							else
							{
								// Emit 0x00, 0x00, 0x01 and the current *pScan before continuing
								Consume( m_startCode, 3 );
								Consume( pScan++, 1 );
								m_state = CLEAN;
							} // streamID != *pScan
						} // default
						break;
					} // switch (*pScan)
				} // OHOHONE
				break;

			case PESHEADER:
				{
					ULONG	bytesToCopy = m_bytesOutstanding;
					if ((ULONG) (pGuard - pScan) < bytesToCopy)
						bytesToCopy = (ULONG) (pGuard - pScan);
					BYTE	*pDst = (BYTE *) &m_staticHeader.PES_packet_length;
					pDst += (sizeof( PES_HEADER ) - 4) - m_bytesOutstanding;
					memcpy( (void *) pDst, pScan, bytesToCopy );
					pScan += bytesToCopy;
					m_bytesOutstanding -= bytesToCopy;
					if (0 == m_bytesOutstanding)
					{
	// HACK, HACK, HACK
	m_staticHeader.PES_header_data[0] = 15;
						m_bytesOutstanding = m_staticHeader.PES_header_data[0];
						if (NULL != m_pCurrentHeader)
						{
							delete m_pCurrentHeader;
							m_pCurrentHeader = NULL;
						} // NULL != m_pCurrentHeader
						m_pCurrentHeader = new CPESHeader( m_staticHeader );
						m_state = EXTENSION;
					} // 0 == m_headerBytesOutstanding
				} // HEADER
				break;

			case EXTENSION:
				{
					ULONG	bytesToCopy = m_bytesOutstanding;
					if ((ULONG) (pGuard - pScan) < bytesToCopy)
						bytesToCopy = (ULONG) (pGuard - pScan);
					BYTE	*pDst = m_pCurrentHeader->Extension();
					pDst += m_pCurrentHeader->ExtensionSize() - m_bytesOutstanding;
					memcpy( (void *) pDst, pScan, bytesToCopy );
					pScan += bytesToCopy;
					m_bytesOutstanding -= bytesToCopy;
					if (0 == m_bytesOutstanding)
					{
						// Found header
						if (m_pCurrentHeader->ptsPresent())
						{
							Flush();
							SetPTS( m_pCurrentHeader->PTS() );
							if (m_bOutputPES)
							{
	//							pConsumer->Consume( (BYTE *) &m_staticHeader, sizeof( m_staticHeader ), pDebug );
								Consume( (BYTE *) (PES_HEADER *) m_pCurrentHeader, sizeof( PES_HEADER ) );
								if (0 < m_pCurrentHeader->ExtensionSize())
									Consume( m_pCurrentHeader->Extension(), m_pCurrentHeader->ExtensionSize() );
							} // m_bPassPESHeader
							if (m_pDebug)
								m_pDebug->Output( "PTS %I64d\n", (__int64) m_pCurrentHeader->PTS() );
						} // m_pCurrentHeader->ptsPresent()

						if (0 < m_pCurrentHeader->PacketLength())
						{
							m_bytesOutstanding  = m_pCurrentHeader->PacketLength();
							m_bytesOutstanding -= sizeof( PES_HEADER ) - 6;
							m_bytesOutstanding -= m_pCurrentHeader->ExtensionSize();
							m_state = PAYLOAD;
						}
						else
							m_state = CLEAN;
					} // 0 == m_extensionBytesOutstanding
				} // EXTENSION
				break;

			case PAYLOAD:
				{
					ULONG	bytesToCopy = m_bytesOutstanding;
					if ((ULONG) (pGuard - pScan) < bytesToCopy)
						bytesToCopy = (ULONG) (pGuard - pScan);
					if (!m_bTransform)
						Consume( pScan, bytesToCopy );
					else
						Transform( pScan, bytesToCopy );
					pScan += bytesToCopy;
					m_bytesOutstanding -= bytesToCopy;
					if (0 == m_bytesOutstanding)
						m_state = CLEAN;
				} // PAYLOAD
				break;

			default:
				assert( (CLEAN <= m_state) && (m_state <= EXTENSION) );
				break;
			} // switch (m_state)
		} // while (pScan < pGuard)

		if (0 < skipped)
		{
			Consume( pScan - skipped, skipped );
			skipped = 0;
		} // 0 < skipped

//		Flush();

	} // if (m_bPESAvailable)
	else
	{
		Consume( pBuffer, bufferSize );
		Flush();
	}

	return TRUE;
}

HRESULT CAudilyzerFilter::Consume(BYTE *pBytes, LONG lCount )
{
	if (NULL == m_pMediaSample)
		NewBuffer();

	while ((NULL != m_pMediaSample) && (0 < lCount))
	{
		BYTE	*pBuffer = NULL;
		m_pMediaSample->GetPointer( &pBuffer );
		LONG	lSize  = m_pMediaSample->GetSize();
		LONG	lActual = m_pMediaSample->GetActualDataLength();

		LONG	lAvailable = lSize - lActual;
		LONG	lToWrite = lCount > lAvailable ? lAvailable : lCount;

		memcpy( pBuffer + lActual, pBytes, lToWrite );
		lCount -= lToWrite;
		lActual += lToWrite;
		lAvailable = lSize - lActual;
		m_pMediaSample->SetActualDataLength( lActual );

		if (0 == lAvailable)
		{
			HRESULT hr = m_pOutput->Deliver( m_pMediaSample );
			if (m_pDebug)
				m_pDebug->Output( "Delivered media sample\n" );
			NewBuffer();
		} // 0 == lAvailable
	} // while ((NULL != m_pMediaSample) && (0 < lCount))

	return 0 == lCount ? S_OK : E_FAIL;
}


HRESULT CAudilyzerFilter::Flush()
{
	HRESULT	hr = E_FAIL;

	if (NULL != m_pMediaSample)
	{
		LONG	lActual = m_pMediaSample->GetActualDataLength();
		if (0 < lActual)
		{
/*
			{
				REFERENCE_TIME	time, dummy;
				m_pMediaSample->GetTime( &time, &dummy );
				TCHAR	msg[128];
				_stprintf( msg, _T("Audio media sample- PTS= %I64d\n"), (__int64) time );
				DbgLog((LOG_TIMING|LOG_TRACE,3,msg));
			}
*/
			HRESULT	hr = m_pOutput->Deliver( m_pMediaSample );
			NewBuffer();
		}
		else
			hr = S_OK;
	}

	return hr;
}

HRESULT CAudilyzerFilter::SetSyncPoint()
{
	if (NULL != m_pMediaSample)
		return m_pMediaSample->SetSyncPoint( TRUE );

	return E_FAIL;
}

HRESULT CAudilyzerFilter::SetPTS(ULONGLONG pts)
{
	HRESULT	hr = S_OK;

	m_pts = pts;
//	DbgLog((LOG_TRACE, 0, _T("audio PTS: %ld\n"), pts ));

	if (NULL != m_pMediaSample)
	{
		REFERENCE_TIME	refTime = (REFERENCE_TIME) m_pts;
		// m_pts is in 90kHz clock ticks
		// refTime is in 100ns clock ticks
		// time in seconds (tis) = m_pts / 90,000
		// refTime = tis * 10^7
		// refTime = (m_pts / 90,000) * 10,000,000
		// refTime = (m_pts / 9) * 1,000 = m_pts * 1000 / 9;
		refTime *= 1000;
		refTime /= 9;
		hr = m_pMediaSample->SetTime( &refTime, NULL );
	}

	return hr;
}

HRESULT CAudilyzerFilter::NewBuffer()
{
	if (NULL != m_pMediaSample)
	{
		m_pMediaSample->Release();
		m_pMediaSample = NULL;
	}

	if (NULL != m_pOutput)
	{
		REFERENCE_TIME	refTime = (REFERENCE_TIME) m_pts;
		// m_pts is in 90kHz clock ticks
		// refTime is in 100ns clock ticks
		// time in seconds (tis) = m_pts / 90,000
		// refTime = tis * 10^7
		// refTime = (m_pts / 90,000) * 10,000,000
		// refTime = (m_pts / 9) * 1,000 = m_pts * 1000 / 9;
		refTime *= 1000;
		refTime /= 9;
		HRESULT	hr = m_pOutput->GetDeliveryBuffer( &m_pMediaSample, &refTime, NULL, 0 );
		if (SUCCEEDED(hr))
			m_pMediaSample->SetActualDataLength( 0L );
		else
			OutputDebugString( "GetDeliveryBuffer() failed\n" );
		return hr;
	}
	else
		OutputDebugString( "NULL == m_pOutputPin\n" );

	return E_FAIL;
}

CAudioInputPin::CAudioInputPin( TCHAR *pObjectName, CAudilyzerFilter *pFilter,
							    CCritSec *pLock, HRESULT *phr, LPCWSTR pPinName ) :
	CBaseInputPin( pObjectName, (CBaseFilter *) pFilter, pLock, phr, pPinName ),
	m_pAudFilter( pFilter )
{
	
}

CAudioOutputPin::CAudioOutputPin( TCHAR *pObjectName, CAudilyzerFilter *pFilter,
								  CCritSec *pLock, HRESULT *phr, LPCWSTR pPinName ) :
	CBaseOutputPin( pObjectName, (CBaseFilter *) pFilter, pLock, phr, pPinName ),
	m_pAudFilter( pFilter )
{

}

HRESULT CAudioInputPin::CheckMediaType(const CMediaType *pmt)
{
	int	iPosition;

	for (iPosition = 0; iPosition < NUMELMS(sudInputTypes); iPosition++)
		if ((*(pmt->Type()) == *(sudInputTypes[iPosition].clsMajorType)) &&
			(*(pmt->Subtype()) == *(sudInputTypes[iPosition].clsMinorType))) {

			return S_OK;
		} // if (type and subtype match)

	return S_FALSE;
}

HRESULT CAudioOutputPin::CheckMediaType(const CMediaType *pmt)
{
	int	iPosition;

//	int	maxType = m_bPESAvailable ? 5 : 3;

	for (iPosition = 0; iPosition < NUMELMS(sudOutputTypes); iPosition++)
//	for (iPosition = 0; iPosition < maxType; iPosition++)
		if ((*(pmt->Type()) == *(sudOutputTypes[iPosition].clsMajorType)) &&
			(m_pAudFilter->m_bPESAvailable || (MEDIATYPE_MPEG2_PES != *(sudOutputTypes[iPosition].clsMajorType))) &&
			(*(pmt->Subtype()) == *(sudOutputTypes[iPosition].clsMinorType))) {

			return S_OK;
		} // if (type and subtype match)

	return S_FALSE;
}

STDMETHODIMP CAudioInputPin::Receive(IMediaSample *pSample)
{
	return m_pAudFilter->Process( pSample );
}

HRESULT CAudilyzerFilter::Process(IMediaSample *pSample)
{
	BYTE	*pBuffer = NULL;
	pSample->GetPointer( &pBuffer );
	LONG	lSize = pSample->GetActualDataLength();

	if (NULL != m_pDebug)
	{
		__int64	msTime, mTime, dummy;
		pSample->GetTime( &msTime, &dummy );
		pSample->GetMediaTime( &mTime, &dummy );
		m_pDebug->Output( "Media Sample: time- %I64d media time- %I64d payload- %d\n", msTime, mTime, lSize );
	}

/*
	if (NULL == m_pMediaSample)
		NewBuffer();
	if ((FALSE == m_bPESAvailable) && (NULL != m_pMediaSample))
	{
		__int64 timeStart, timeEnd;
		if (SUCCEEDED(pSample->GetTime( &timeStart, &timeEnd )))
			m_pMediaSample->SetTime( &timeStart, &timeEnd );
		if (SUCCEEDED(pSample->GetMediaTime( &timeStart, &timeEnd )))
			m_pMediaSample->SetMediaTime( &timeStart, &timeEnd );
	}
*/
	if (!m_bPESAvailable)
		return m_pOutput->Deliver( pSample );
	else
		return Process( pBuffer, lSize, 0xBD ) ? S_OK : E_FAIL;
}

HRESULT CAudioOutputPin::DecideBufferSize(IMemAllocator *pAlloc, ALLOCATOR_PROPERTIES *pProps)
{
	return m_pAudFilter->DecideBufferSize( pAlloc, pProps );
}

HRESULT CAudioOutputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
//	int	maxType = m_bPESAvailable ? 5 : 3;

	if ((iPosition < NUMELMS(sudOutputTypes)) &&
		(m_pAudFilter->m_bPESAvailable || (MEDIATYPE_MPEG2_PES != *(sudOutputTypes[iPosition].clsMajorType)))) {
//	if (iPosition < maxType) {
		pMediaType->InitMediaType();
		pMediaType->SetType( sudOutputTypes[iPosition].clsMajorType );
		pMediaType->SetSubtype( sudOutputTypes[iPosition].clsMinorType );

		pMediaType->SetFormatType( &FORMAT_WaveFormatEx );
		pMediaType->SetFormat( (BYTE *) &m_pAudFilter->m_wfx, sizeof( WAVEFORMATEX ) );

		return S_OK;
	}

	return VFW_S_NO_MORE_ITEMS;
}

HRESULT CDebugOutputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
	if (iPosition < NUMELMS(sudDebugTypes)) {
		pMediaType->InitMediaType();
		pMediaType->SetType(sudDebugTypes[iPosition].clsMajorType);
		pMediaType->SetSubtype(sudDebugTypes[iPosition].clsMinorType);

		return S_OK;
	}

	return VFW_S_NO_MORE_ITEMS;
}

HRESULT CDebugOutputPin::DecideBufferSize(IMemAllocator *pAlloc, ALLOCATOR_PROPERTIES *pProps)
{
	pProps->cbAlign  = 1;
	pProps->cbBuffer = 1024;
	pProps->cbPrefix = 0;
	pProps->cBuffers = 2;

	ALLOCATOR_PROPERTIES	propsActual;
	HRESULT	hr = pAlloc->SetProperties( pProps, &propsActual );
	if (SUCCEEDED( hr ))
	{
		if ((0 == propsActual.cbBuffer) || (0 == propsActual.cBuffers))
			hr = E_FAIL;
		else
			hr = NOERROR;
	}

	return hr;
}

HRESULT CDebugOutputPin::CheckMediaType(const CMediaType *pmt)
{
	int	iPosition;

	for (iPosition = 0; iPosition < NUMELMS(sudDebugTypes); iPosition++)
		if ((*(pmt->Type()) == *(sudDebugTypes[iPosition].clsMajorType)) &&
			(*(pmt->Subtype()) == *(sudDebugTypes[iPosition].clsMinorType))) {

			return S_OK;
		} // if (type and subtype match)

	return S_FALSE;
}

CDebugOutputPin::CDebugOutputPin( TCHAR *pObjectName, CAudilyzerFilter *pFilter,
								  CCritSec *pLock, HRESULT *phr,
								  LPCWSTR pPinName) :
	CBaseOutputPin( pObjectName, (CBaseFilter *) pFilter, pLock, phr, pPinName ),
	m_pAudFilter( pFilter ),
	m_pMediaSample( NULL )
{

}

HRESULT CDebugOutputPin::Output( char *format, ...)
{
	if (NULL == m_pMediaSample)
	{
		if (FAILED( GetDeliveryBuffer( &m_pMediaSample, NULL, NULL, 0 ) ))
			return E_FAIL;
		m_pMediaSample->SetActualDataLength( 0L );
	}

	char msg[256], *ptr = (char *) msg;
	va_list	argptr;
	va_start( argptr, format );
	_vsnprintf( msg, 256, format, argptr );
	va_end( argptr );

	long	count = strlen( msg );
	while (0 < count)
	{
		LONG	lSize = m_pMediaSample->GetSize();
		LONG	lActual = m_pMediaSample->GetActualDataLength();
		LONG	lAvailable = lSize - lActual;
		LONG	toWrite = count <= lAvailable ? count : lAvailable;
		BYTE	*pBuffer;
		
		m_pMediaSample->GetPointer( &pBuffer );
		pBuffer += lActual;
		memcpy( pBuffer, ptr, toWrite );
		pBuffer += toWrite;
		ptr += toWrite;
		count -= toWrite;
		lActual += toWrite;
		m_pMediaSample->SetActualDataLength( lActual );
		lAvailable -= toWrite;

		if (0 == lAvailable)
		{
			Deliver( m_pMediaSample );
			m_pMediaSample->Release();
			m_pMediaSample = NULL;

			if (FAILED( GetDeliveryBuffer( &m_pMediaSample, NULL, NULL, 0 ) ))
				break;
			m_pMediaSample->SetActualDataLength( 0L );
		} // 0 == lAvailable
	} // 0 < count

	return 0 == count ? S_OK : E_FAIL;
}

STDMETHODIMP
CAudioOutputPin::GetBitRates( ULONG *plMinBPS, ULONG *plMaxBPS )
{
	*plMinBPS = m_pAudFilter->m_ulMinBPS;
	*plMaxBPS = m_pAudFilter->m_ulMaxBPS;

	return S_OK;
}

STDMETHODIMP
CAudioOutputPin::HasSyncPoints( BOOL *pbHasSyncPoints, REFERENCE_TIME *pFrequency )
{
	*pbHasSyncPoints = FALSE;
	*pFrequency = 333333; // 1/30 second in 100ns units

	return S_OK;
}

HRESULT CAudioInputPin::CompleteConnect(IPin *pPin)
{
	HRESULT	hr = CBaseInputPin::CompleteConnect( pPin );

	if (SUCCEEDED( hr ))
	{
		hr = m_pAudFilter->SetMediaType( PINDIR_INPUT, &m_mt );
	}

	return hr;
}

HRESULT CAudioOutputPin::CompleteConnect(IPin *pPin)
{
	HRESULT	hr = CBaseOutputPin::CompleteConnect( pPin );

	if (SUCCEEDED( hr ))
	{
		hr = m_pAudFilter->SetMediaType( PINDIR_OUTPUT, &m_mt );
	}

	return hr;
}

HRESULT CAudilyzerFilter::Transform(BYTE *pBytes, LONG lCount )
{
	if (NULL == m_pMediaSample)
		NewBuffer();

	while ((NULL != m_pMediaSample) && (0 < lCount))
	{
		BYTE	*pBuffer = NULL;
		m_pMediaSample->GetPointer( &pBuffer );
		LONG	lSize  = m_pMediaSample->GetSize();
		LONG	lActual = m_pMediaSample->GetActualDataLength();

		LONG	lAvailable = lSize - lActual;
		LONG	lToWrite = lCount > lAvailable ? lAvailable : lCount;

//		memcpy( pBuffer + lActual, pBytes, lToWrite );
		{
			LONG	i;
			USHORT	*pSource = (USHORT *) pBytes;
			USHORT	*pDest   = (USHORT *) (pBuffer + lActual);
			LONG	count = lToWrite / 2;

			for ( i = 0; i < count; i++ )
				*pDest++ = m_xformTable[*pSource++];
		}

		lCount -= lToWrite;
		lActual += lToWrite;
		lAvailable = lSize - lActual;
		m_pMediaSample->SetActualDataLength( lActual );

		if (0 == lAvailable)
		{
			HRESULT hr = m_pOutput->Deliver( m_pMediaSample );
			if (m_pDebug)
				m_pDebug->Output( "Delivered media sample\n" );
			NewBuffer();
		} // 0 == lAvailable
	} // while ((NULL != m_pMediaSample) && (0 < lCount))

	return 0 == lCount ? S_OK : E_FAIL;
}

HRESULT CAudioInputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
	if (iPosition < NUMELMS(sudInputTypes)) {
		pMediaType->InitMediaType();
		pMediaType->SetType(sudInputTypes[iPosition].clsMajorType);
		pMediaType->SetSubtype(sudInputTypes[iPosition].clsMinorType);

		return S_OK;
	}

	return VFW_S_NO_MORE_ITEMS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\audilyzer\audilyzer.h ===
#include "pesinfo.h"
#include "timeshift.h"
#include "pesheader.h"

class CAudilyzerFilter;

class CAudioInputPin : public CBaseInputPin
{
public:
	HRESULT GetMediaType( int iPosition, CMediaType *pMediaType );
	HRESULT CompleteConnect( IPin *pPin );
	STDMETHODIMP Receive( IMediaSample *pSample );
	HRESULT CheckMediaType( const CMediaType *pmt );
	CAudilyzerFilter * m_pAudFilter;
	CAudioInputPin( TCHAR *pObjectName, CAudilyzerFilter *pFilter,
					CCritSec *pLock, HRESULT *phr, LPCWSTR pPinName );
};

class CAudioOutputPin : public CBaseOutputPin, public IAnalyzerOutputPin
{
public:
	HRESULT CompleteConnect( IPin *pPin );
	HRESULT GetMediaType( int iPosition, CMediaType *pMediaType );
	HRESULT DecideBufferSize( IMemAllocator *pAlloc, ALLOCATOR_PROPERTIES *pProps );
	HRESULT CheckMediaType( const CMediaType *pmt );
	CAudilyzerFilter * m_pAudFilter;
	CAudioOutputPin( TCHAR *pObjectName, CAudilyzerFilter *pFilter,
					 CCritSec *pLock, HRESULT *phr, LPCWSTR pPinName);

	// IAnalyzerOutputPin
	DECLARE_IUNKNOWN
	STDMETHODIMP	GetBitRates( ULONG *lMinBitsPerSecond, ULONG *lMaxBitsPerSecond );
	STDMETHODIMP	HasSyncPoints( BOOL *pbHasSyncPoints, REFERENCE_TIME *pFrequency );
};

class CDebugObject
{
public:
	virtual HRESULT	Output( char *format, ... ) = NULL;
};

class CDebugOutputPin : public CBaseOutputPin, public CDebugObject
{
public:
	IMediaSample * m_pMediaSample;
	HRESULT Output( char *format, ... );
	CAudilyzerFilter * m_pAudFilter;
	CDebugOutputPin( TCHAR *pObjectName, CAudilyzerFilter *pFilter, CCritSec *pLock, HRESULT *phr, LPCWSTR pPinName );
	HRESULT CheckMediaType( const CMediaType *pmt );
	HRESULT DecideBufferSize( IMemAllocator *pAlloc, ALLOCATOR_PROPERTIES *pProps );
	HRESULT GetMediaType( int iPosition, CMediaType *pMediaType );
};

class CAudilyzerFilter : public CBaseFilter
{
public:
	BYTE m_startCode[4];
	enum STATES {
		CLEAN,
		ONEOH,
		TWOOHS,
		OHOHONE,
		PESHEADER,
		EXTENSION,
		PAYLOAD
	} m_state;
	BOOL m_bTransform;
	ULONG m_bytesOutstanding;
	CPESHeader *m_pCurrentHeader;
	PES_HEADER m_staticHeader;
	BOOL Process( BYTE *pBuffer, LONG lSize, BYTE streamID );

	USHORT m_xformTable[65536];
	HRESULT Transform( BYTE *pBytes, LONG lCount );
	ULONGLONG m_pts;
	IMediaSample * m_pMediaSample;
	HRESULT SetPTS( ULONGLONG pts );
	HRESULT SetSyncPoint( void );
	HRESULT Flush( void );
	HRESULT Consume( BYTE *pBytes, LONG lCount );
	HRESULT NewBuffer( void );

	enum AUDIOFORMAT {
		PCM,
		LPCM
	};
	AUDIOFORMAT m_outputFormat;
	AUDIOFORMAT m_inputFormat;
	BOOL m_bOutputPES;
	BOOL m_bPESAvailable;
	ULONG m_ulMaxBPS;
	ULONG m_ulMinBPS;
	CCritSec m_csFilter;
	HRESULT Process( IMediaSample *pSample );
	static CUnknown * CALLBACK	CreateInstance( LPUNKNOWN, HRESULT * );

	CAudilyzerFilter( LPUNKNOWN, HRESULT * );
	~CAudilyzerFilter( void );

	HRESULT	DecideBufferSize( IMemAllocator *pAllocator, ALLOCATOR_PROPERTIES *pprop );
	class CBasePin *	GetPin( int n );
	int					GetPinCount( void );

	HRESULT	SetMediaType( PIN_DIRECTION direction, const CMediaType *pmt );

	WAVEFORMATEX m_wfx;

	CAudioInputPin *	m_pInput;
	CAudioOutputPin *	m_pOutput;
	CDebugOutputPin * m_pDebug;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\audilyzer\pesheader.cpp ===
// PESHeader.cpp: implementation of the CPESHeader class.
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include "PESHeader.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPESHeader::CPESHeader( PES_HEADER &header ) :
	m_pExtension( NULL )
{
	memcpy( (void *) (PES_HEADER *) this, (void *) &header, sizeof( PES_HEADER ) );
	m_pExtension = new BYTE [ PES_header_data[0] ];
//	m_pHeader = (PES_HEADER *) new BYTE [sizeof( PES_HEADER ) + header.PES_header_data[0]];
//	memcpy( (void *) m_pHeader, (void *) &header, sizeof( PES_HEADER ) );
}

CPESHeader::~CPESHeader()
{
//	if (m_pHeader)
//		delete [] (BYTE *) m_pHeader;
	if (m_pExtension)
		delete [] m_pExtension;
}

/*
BYTE * CPESHeader::Extension()
{
	return (BYTE *) m_pHeader->PES_header_data + 1;
}

ULONG CPESHeader::ExtensionSize()
{
	return (ULONG) m_pHeader->PES_header_data[0];
}

ULONG CPESHeader::StreamID()
{
	return (ULONG) m_pHeader->stream_id;
}

ULONG CPESHeader::PacketLength()
{
	ULONG	packetLength = (m_pHeader->PES_packet_length & 0xFF00) >> 8;
	packetLength |= (m_pHeader->PES_packet_length & 0xFF) << 8;
	
	return packetLength;
}

ULONGLONG CPESHeader::PTS()
{
	ULONGLONG	pts = 0;

	if (ptsPresent())
	{
		pts   = (m_pHeader->PES_header_data[1] & 0x0E) >> 1;
		pts <<= 8;
		pts  |= m_pHeader->PES_header_data[2];
		pts <<= 7;
		pts  |= (m_pHeader->PES_header_data[3] & 0xFE) >> 1;
		pts <<= 8;
		pts  |= m_pHeader->PES_header_data[4];
		pts <<= 7;
		pts  |= (m_pHeader->PES_header_data[5] & 0xFE) >> 1;
	}

	return pts;
}

ULONGLONG CPESHeader::DTS()
{
	ULONGLONG	dts = 0;

	if (dtsPresent())
	{
		dts   = (m_pHeader->PES_header_data[6] & 0x0E) >> 1;
		dts <<= 8;
		dts  |= m_pHeader->PES_header_data[7];
		dts <<= 7;
		dts  |= (m_pHeader->PES_header_data[8] & 0xFE) >> 1;
		dts <<= 8;
		dts  |= m_pHeader->PES_header_data[9];
		dts <<= 7;
		dts  |= (m_pHeader->PES_header_data[10] & 0xFE) >> 1;
	}

	return dts;
}
*/

ULONG CPESHeader::PacketLength()
{
	ULONG	packetLength = (PES_packet_length & 0xFF00) >> 8;
	packetLength |= (PES_packet_length & 0xFF) << 8;
	
	return packetLength;
}

ULONGLONG CPESHeader::PTS()
{
	ULONGLONG	pts = 0;

	if (ptsPresent())
	{
		pts   = (m_pExtension[0] & 0x0E) >> 1;
		pts <<= 8;
		pts  |= m_pExtension[1];
		pts <<= 7;
		pts  |= (m_pExtension[2] & 0xFE) >> 1;
		pts <<= 8;
		pts  |= m_pExtension[3];
		pts <<= 7;
		pts  |= (m_pExtension[4] & 0xFE) >> 1;
	}

	return pts;
}

ULONGLONG CPESHeader::DTS()
{
	ULONGLONG	dts = 0;

	if (dtsPresent())
	{
		dts   = (m_pExtension[5] & 0x0E) >> 1;
		dts <<= 8;
		dts  |= m_pExtension[6];
		dts <<= 7;
		dts  |= (m_pExtension[7] & 0xFE) >> 1;
		dts <<= 8;
		dts  |= m_pExtension[8];
		dts <<= 7;
		dts  |= (m_pExtension[9] & 0xFE) >> 1;
	}

	return dts;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\audilyzer\streamproc.cpp ===
// PESHeaderLocator.cpp: implementation of the CPESVideoProcessor class.
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include "StreamProcess.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\audilyzer\pesheader.h ===
// PESHeader.h: interface for the CPESHeader class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PESHEADER_H__5952398A_C11E_11D2_A4F9_00C04F79A597__INCLUDED_)
#define AFX_PESHEADER_H__5952398A_C11E_11D2_A4F9_00C04F79A597__INCLUDED_

#include "pesinfo.h"

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CPESHeader : public PES_HEADER
{
public:
	ULONGLONG DTS( void );
	ULONGLONG PTS( void );
//	inline BOOL dtsPresent( void ) { return (BOOL) (3 == (m_pHeader->PTS_DTS_flags & 0x03)); };
//	inline BOOL ptsPresent( void ) { return (BOOL) (0 != (m_pHeader->PTS_DTS_flags & 0x02)); };
	inline BOOL dtsPresent( void ) { return (BOOL) (3 == (PTS_DTS_flags & 0x03)); };
	inline BOOL ptsPresent( void ) { return (BOOL) (0 != (PTS_DTS_flags & 0x02)); };
	ULONG PacketLength( void );
	inline ULONG StreamID( void ) { return stream_id; };
	inline ULONG ExtensionSize( void ) { return PES_header_data[0]; };
	inline BYTE * Extension( void ) { return m_pExtension; };
	CPESHeader( PES_HEADER &header );
	virtual ~CPESHeader();
protected:
	BYTE * m_pExtension;
};

#endif // !defined(AFX_PESHEADER_H__5952398A_C11E_11D2_A4F9_00C04F79A597__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\delay\common.h ===
#ifndef __COMMON_H__
#define __COMMON_H__

#define MAX_SUBSTREAMS  8
#define MAX_STREAMERS   4

#define INVALID_OFFSET  0xffffffffffffffff
#define INVALID_PTS     0xffffffffffffffff

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\audilyzer\pesinfo.h ===
/*******************************************************************************
**
**     pesinfo.h - Structure of PES header.
**
**     1.0     10-FEB-1998     C.Lorton     Created.
**
*******************************************************************************/

#ifndef _PESINFO_H_
#define _PESINFO_H_

/*
typedef struct {
	BYTE	packet_start_code_prefix[3];
	BYTE	stream_id;
	USHORT	PES_packet_length;
	USHORT	one_oh : 2;
	USHORT	PES_scrambling_control : 2;
	USHORT	PES_priority : 1;
	USHORT	data_alignment_indicator : 1;
	USHORT	copyright : 1;
	USHORT	original_or_copy : 1;
	USHORT	PTS_DTS_flags : 2;
	USHORT	ESCR_flag : 1;
	USHORT	ES_rate_flag : 1;
	USHORT	DSM_trick_mode_flag : 1;
	USHORT	additional_copy_info_flag : 1;
	USHORT	PES_CRC_flag : 1;
	USHORT	PES_extension_flag : 1;
	BYTE	PES_header_data[1];
} PES_HEADER;
*/

#pragma pack( 1 )

typedef struct {
	BYTE	packet_start_code_prefix[3];
	BYTE	stream_id;
	USHORT	PES_packet_length;

	// The following six fields are reversed due to little endian/big endian differences
	UCHAR	original_or_copy : 1;
	UCHAR	copyright : 1;
	UCHAR	data_alignment_indicator : 1;
	UCHAR	PES_priority : 1;
	UCHAR	PES_scrambling_control : 2;
	UCHAR	one_oh : 2;

	// The following seven fields are reversed due to little endian/big endian differences
	UCHAR	PES_extension_flag : 1;
	UCHAR	PES_CRC_flag : 1;
	UCHAR	additional_copy_info_flag : 1;
	UCHAR	DSM_trick_mode_flag : 1;
	UCHAR	ES_rate_flag : 1;
	UCHAR	ESCR_flag : 1;
	UCHAR	PTS_DTS_flags : 2;

	BYTE	PES_header_data[1];
} PES_HEADER;

#pragma pack( )

#endif // _PESINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\audilyzer\streamproc.h ===
// PESHeaderLocator.h: interface for the CPESVideoProcessor class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PESHEADERLOCATOR_H__B302990C_C065_11D2_A4F9_00C04F79A597__INCLUDED_)
#define AFX_PESHEADERLOCATOR_H__B302990C_C065_11D2_A4F9_00C04F79A597__INCLUDED_

#include "pesinfo.h"	// Added by ClassView
#include "PESHeader.h"	// Added by ClassView
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CDebugObject
{
public:
	virtual HRESULT	Output( char *format, ... ) = NULL;
};

class CStreamConsumer
{
public:
	virtual HRESULT Consume( BYTE *pBytes, LONG lCount, CDebugObject *pDebug = NULL ) = NULL;
	CStreamConsumer( void ) {}
	~CStreamConsumer( void ) {}
};

class CStreamProcessor
{
public:
	virtual BOOL Process( BYTE *pBuffer, LONG lCount, BYTE streamID, CStreamConsumer *pConsumer, CDebugObject *pDebug = NULL ) = NULL;
	CStreamProcessor( void ) {};
	~CStreamProcessor( void ) {};
};

#endif // !defined(AFX_PESHEADERLOCATOR_H__B302990C_C065_11D2_A4F9_00C04F79A597__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\delay\indexer.cpp ===
#include <streams.h>
#include "delay.h"
#include "indexer.h"

//////////////////////////////////////////////////////////////////
//
//	class CCircBufWindowTracker implementation.
//
//  This classs will keep track of the tail of the official timeshift
//  window which is the intersection of what is available in the
//  circular file and the indices.
//
//////////////////////////////////////////////////////////////////
CCircBufWindowTracker::CCircBufWindowTracker(CDelayFilter *pDelayFilter)
{
    m_pDelayFilter = pDelayFilter;

    //Initialize the information array
    for (int i = 0; i < MAX_SUBSTREAMS; i++)
    {
        m_SubstreamInfoArray[i].m_bInUse = FALSE;
        m_SubstreamInfoArray[i].ullHeadOffset = INVALID_OFFSET;
        m_SubstreamInfoArray[i].ullTailOffset = INVALID_OFFSET;
    }
}

CCircBufWindowTracker::~CCircBufWindowTracker()
{
}

void CCircBufWindowTracker::RegisterTracking(ULONG ulSubstreamId)
{
    if (ulSubstreamId >= MAX_SUBSTREAMS)
    {
        ASSERT(!"CCircBufWindowTracker : Invalid Substream Id");
        return;
    }

    if (m_SubstreamInfoArray[ulSubstreamId].m_bInUse)
    {
        ASSERT(!"CCircBufWindowTracker : substream info already in use");
        return;
    }

    // mark the usage flag
    m_SubstreamInfoArray[ulSubstreamId].m_bInUse = TRUE;
}

void CCircBufWindowTracker::UnregisterTracking(ULONG ulSubstreamId)
{
    if (ulSubstreamId >= MAX_SUBSTREAMS)
    {
        ASSERT(!"CCircBufWindowTracker : Invalid Substream Id");
        return;
    }

    if (!m_SubstreamInfoArray[ulSubstreamId].m_bInUse)
    {
        ASSERT(!"CCircBufWindowTracker : substream info is not used");
        return;
    }

    // mark the usage flag
    m_SubstreamInfoArray[ulSubstreamId].m_bInUse = FALSE;
}

void CCircBufWindowTracker::SetWindowOffsets(ULONG ulSubstreamId, ULONGLONG ullHeadOffset, ULONGLONG ullTailOffset, BOOL bWriterNotification)
{
    CAutoLock l(&m_cs);

    // Check if this is a notification from the writer
    if (bWriterNotification)
    {
        m_WriterInfo.ullHeadOffset = ullHeadOffset;
        m_WriterInfo.ullTailOffset = ullTailOffset;
    }
    else
    {
        // Validate the substream id.
        if (ulSubstreamId >= MAX_SUBSTREAMS)
        {
            ASSERT(!"CCircBufWindowTracker : Invalid Substream Id");
            return;
        }

        // Sanity check
        // We occasionally hit this during shutdown, I'm not sure the assert is valid.
        // ASSERT(m_SubstreamInfoArray[ulSubstreamId].m_bInUse);

        // Update the information for the substream.
        m_SubstreamInfoArray[ulSubstreamId].ullHeadOffset = ullHeadOffset;
        m_SubstreamInfoArray[ulSubstreamId].ullTailOffset = ullTailOffset;
    }

    ULONGLONG ullHead, ullTail;
    CalculateIntersection(&ullHead, &ullTail);
    m_pDelayFilter->NotifyWindowOffsets(ullHead, ullTail);
}

void CCircBufWindowTracker::CalculateIntersection(ULONGLONG *pHead, ULONGLONG *pTail)
{
    // TODO : Caluculate the intersection window of the writer's head/tail with the 
    // head/tail of all the substream indexes. Currently this returns the head/tail
    // of the writer for cancel scan purposes.
    *pHead = m_WriterInfo.ullHeadOffset;
    *pTail = m_WriterInfo.ullTailOffset;
}


//////////////////////////////////////////////////////////////////
//
//	CIndexMapper implementation.
//
//  The CIndexMapper objects are used by the indexer to maintain
//	a list of substream id and their respective index objects.
//
//////////////////////////////////////////////////////////////////
CIndexMapper::CIndexMapper()
{
	m_ulSubstreamId = 0xffffffff;
	m_pSubstreamIndex = NULL;
}
//////////////////////////////////////////////////////////////////
//
//	CSubstreamIndex implementation.
//
//  The CSubstreamIndex class implements the indices for a substream.
//	The indices are maintained in an allocated array of CIndexEntry
//	objects. The index array is implemented in a circular fashion. So
//  there is a possibility that the index entries for a substream are
//  not in sync with the data in the cirsular buffer.
//
//////////////////////////////////////////////////////////////////
CSubstreamIndex::CSubstreamIndex(ULONG ulSubstreamId, ULONG ulNumEntries, CCircBufWindowTracker *pTracker, HRESULT *phr)
{
	// Initialize all member variables.
	m_pIndexArray = NULL;
	m_ullMinFileOffset = INVALID_OFFSET;
	m_ullMaxFileOffset = INVALID_OFFSET;
	m_ulHead = 0;
	m_ulTail = 0;
    m_ulSubstreamId = ulSubstreamId;

    // Head/Tail tracker to notify any changes in the
    // min/max offsets
    m_pTracker = pTracker;
	// Register with the tracker object
	m_pTracker->RegisterTracking(ulSubstreamId);

	m_ulNumEntries = ulNumEntries;

	*phr = AllocateIndexArray(m_ulNumEntries);
}

CSubstreamIndex::~CSubstreamIndex()
{
	// unregister with the tracker object.
	m_pTracker->UnregisterTracking(m_ulSubstreamId);

	// Clean up the index array that was allocated.
	if (m_pIndexArray)
	{
		delete [] m_pIndexArray;
	}
}

BOOL CSubstreamIndex::IsEmpty()
{
	if (m_ulHead == 0 &&
		m_ulTail == 0 &&
		m_pIndexArray[0].m_ullFileOffset == INVALID_OFFSET &&
		m_pIndexArray[0].m_llPresTime == INVALID_PTS)
		return TRUE;
	else
		return FALSE;

}

//////////////////////////////////////////////////////////////////
//
//	AllocateIndexArray - allocates the index array for the substream
//  duh!!
//
//	Parameters:
//		ulNumEntries - The max number of index entries to be maintained
//						for this substream
//
//	Returns :
//		NOERROR if successful and E_OUTOFMEMORY if the index array
//		allocation fails.
//////////////////////////////////////////////////////////////////
HRESULT CSubstreamIndex::AllocateIndexArray(ULONG ulNumEntries)
{
	// Allocate the index array. The size of the index array is
	// specified by ulNumEntries.
	m_pIndexArray = new CIndexEntry[ulNumEntries];

	if (m_pIndexArray == NULL)
	{
      DbgLog((LOG_ERROR,1,"Could Not Allocate Index Array"));
      return E_OUTOFMEMORY;
	}
	return InvalidateAllEntries();
}

//////////////////////////////////////////////////////////////////
//
//	InvalidateAllEntries
//	
//	Invalidates all index entries for this substream. This would 
//	be used if the index entries are being generated periodically 
//  without any sync points. Once we receive a sync point on a 
//	stream, then we discard all the existing index entries and then 
//	start indexing sync points only.
//
//	Parameters:
//
//	Returns :
//		NOERROR if successful
//////////////////////////////////////////////////////////////////
HRESULT CSubstreamIndex::InvalidateAllEntries()
{
	// Lock the critical section for this substream
	CAutoLock l(&m_csIndex);

	for (ULONG i = 0; i < m_ulNumEntries; i++)
	{
		m_pIndexArray[i].m_ullFileOffset = INVALID_OFFSET;
		m_pIndexArray[i].m_llPresTime = INVALID_PTS;
	}
	m_ullMinFileOffset = INVALID_OFFSET;
	m_ullMaxFileOffset = INVALID_OFFSET;
	m_ulHead = 0;
	m_ulTail = 0;
	return NOERROR;
}

void CSubstreamIndex::InvalidateEntry(CIndexEntry *pEntry)
{
	pEntry->m_ullFileOffset = INVALID_OFFSET;
	pEntry->m_llPresTime = INVALID_PTS;
}

void CSubstreamIndex::UpdateMinMaxOffsets()
{
    if (IsEmpty())
    {
	    m_ullMinFileOffset = INVALID_OFFSET;
	    m_ullMaxFileOffset = INVALID_OFFSET;
        return;
    }
	m_ullMinFileOffset = m_pIndexArray[m_ulHead].m_ullFileOffset;
	m_ullMaxFileOffset = m_pIndexArray[m_ulTail].m_ullFileOffset;

    // Check if a tracker is initialized and send notifications.
    if (m_pTracker)
    {
        m_pTracker->SetWindowOffsets(m_ulSubstreamId, m_ullMinFileOffset, m_ullMaxFileOffset);
    }
}

void CSubstreamIndex::GetMinMaxOffsets(ULONGLONG *pHead, ULONGLONG *pTail)
{
    *pHead = m_ullMinFileOffset;
    *pTail = m_ullMaxFileOffset;
}

//////////////////////////////////////////////////////////////////
//
//	AddIndexEntry
//
//	Adds a new index entry to the substream index array and adjusts
//  the head/tail pointers and the min/max offsets accordingly.
//
//	Parameters:
//		ullFileOffset - file offset for the new index entry
//		llPresTime - presentation time for the new index entry
//
//	Returns :
//		NOERROR if successful
//////////////////////////////////////////////////////////////////
HRESULT CSubstreamIndex::AddIndexEntry(ULONGLONG ullFileOffset, REFERENCE_TIME llPresTime)
{
	// Lock the critical section for this substream
	CAutoLock l(&m_csIndex);

	// We always add the new entry at the tail of the circular index array. We also
	// need to check if the head needs to be bumped up in the case we are
	// overwriting the entry at the head of the circular array.
	if (IsEmpty())
	{
		// This is the first entry.
		m_pIndexArray[0].m_ullFileOffset = ullFileOffset;
		m_pIndexArray[0].m_llPresTime = llPresTime;
        UpdateMinMaxOffsets();
		return NOERROR;

	}

	// Compute the next entry to write into.
	ULONG ulNext = (m_ulTail + 1) % m_ulNumEntries;
	// Check if we need to bump the head.
	if (ulNext == m_ulHead)
	{
		m_ulHead = (m_ulHead + 1) % m_ulNumEntries;
	}
	// Update the index entry
	m_pIndexArray[ulNext].m_ullFileOffset = ullFileOffset;
	m_pIndexArray[ulNext].m_llPresTime = llPresTime;
	// Update the tail.
	m_ulTail = ulNext;

    // Update the min/max offsets.
    UpdateMinMaxOffsets();


//#ifdef _DEBUG
	// Sanity Check
//#endif

	return NOERROR;
}

//////////////////////////////////////////////////////////////////
//
//	InvalidateEntries
//
//  Given the end file offset of the block being oversritten, the 
//  index entries that might be pointing to invalid file offsets 
//  will be invalidated and the head and tail pointers will be 
//  adjusted.
//
//	Parameters:
//		ullOverwriteBlockEndOffset - End file offsets of the block in the
//						   circular file which is being overwritten.
//
//	Returns :
//		NOERROR if successful
//////////////////////////////////////////////////////////////////
HRESULT CSubstreamIndex::InvalidateEntries(ULONGLONG ullOverwriteBlockEndOffset)
{
	// Lock the critical section for this substream
	CAutoLock l(&m_csIndex);

	// First check if there are any entries
	if (IsEmpty())
	{
		// We do not have any index entries.
		return NOERROR;
	}

	BOOL fDone = FALSE;
	ULONG ulHead = m_ulHead;
	while (!fDone)
	{
		ULONGLONG offset = m_pIndexArray[ulHead].GetOffset();

        // Check if we are done
		if (ulHead == m_ulTail)
		{
		    if (offset <= ullOverwriteBlockEndOffset)
            {
                // last entry being invalidated.
			    // Invalidate the entry
			    InvalidateEntry(&m_pIndexArray[ulHead]);
                m_ulHead = 0;
                m_ulTail = 0;
            }
            break;
		}

        if (offset <= ullOverwriteBlockEndOffset)
		{
			// Invalidate the entry
			InvalidateEntry(&m_pIndexArray[ulHead]);
			// Move the head.
			ulHead = (ulHead + 1) % m_ulNumEntries;
            m_ulHead = ulHead;
		}
		else
		{
			fDone = TRUE;
		}

	}

    // Update the min/max offsets
    UpdateMinMaxOffsets();

	return NOERROR;
}

//////////////////////////////////////////////////////////////////
//
//	GetOffsets
//
//	For a given presentation time, this returns the 2 closest offsets
//  and their presentation times. The first offset and presentation time
//	(ullOffsetLT_EQ & llPtsLT_EQ) is the closest index entry with
//  presentation time less than or equal to llPresTime. The second offset
//  and presentation time (ullOffsetGT & llPtsGT) is the closest
//  index entry with a presentation time greater than llPresTime.
//
//  Note : If llPresTime1 == llPresTime, then ullFileOffset2 & llPresTime2
//	will be set to INVALID_OFFSET & INVALID_PTS respectively. If there are
//  no entries in this substream index, it returns NOERROR with the offsets
//  set to INVALID_OFFSET & the presentation times set to INVALID_PTS.
//
//	Parameters:
//		llPresTime - The specified presentation time for which file offsets
//					 are retrieved.
//      ullOffsetLT_EQ
//		llPtsLT_EQ - File offset & Presentation time of the closest index entry
//					 with presentation time <= llPresTime. Values will be set
//					 to INVALID_OFFSET & INVALID_PTS if no index entries are
//					 available.
//      ullOffsetGT
//		llPtsGT - File offset & Presentation time of the closest index entry
//					  with presentation time > llPresTime. These will be set to
//					  INVALID_OFFSET & INVALID_PTS respectively if llPresTime1
//					  is equal to llPresTime or no index entries are available.
//
//	Returns :
//		NOERROR if successful
//////////////////////////////////////////////////////////////////
HRESULT CSubstreamIndex::GetOffsets(REFERENCE_TIME llPresTime, 
									ULONGLONG &ullOffsetLT_EQ,
									REFERENCE_TIME &llPtsLT_EQ,
									ULONGLONG &ullOffsetGT,
									REFERENCE_TIME &llPtsGT)
{
	// Lock the critical section for this substream
	CAutoLock l(&m_csIndex);

	// First check if there are any entries
	if (IsEmpty())
	{
		// Set invalid return values.
		ullOffsetLT_EQ = ullOffsetGT = INVALID_OFFSET;
		llPtsLT_EQ = llPtsGT = INVALID_PTS;
		// We do not have any index entries.
		return NOERROR;
	}

	BOOL fDone = FALSE;
	ULONG ulCur = m_ulHead;
	ULONGLONG ullLTEQOffset = INVALID_OFFSET, ullGTOffset = INVALID_OFFSET;
	REFERENCE_TIME llLTEQTime = INVALID_PTS, llGTTime = INVALID_PTS;
	while (!fDone)
	{
		if (ulCur == m_ulTail)
		{
			fDone = TRUE;
		}

		ULONGLONG ullOffset = m_pIndexArray[ulCur].GetOffset();
		REFERENCE_TIME llTime = m_pIndexArray[ulCur].GetPTS();
		if (llTime < llPresTime)
		{
			if ((ullLTEQOffset == INVALID_OFFSET && llLTEQTime == INVALID_PTS) ||
				(llTime > llLTEQTime))
			{
				ullLTEQOffset = ullOffset;
				llLTEQTime = llTime;
			}
		}
		else if (llTime == llPresTime)
		{
			ullOffsetLT_EQ = ullOffset;
			llPtsLT_EQ = llTime;
			ullOffsetGT = INVALID_OFFSET;
			llPtsGT = INVALID_PTS;
			return NOERROR;
		}
		else
		{
			if ((ullGTOffset == INVALID_OFFSET && llGTTime == INVALID_PTS) ||
			    (llTime < llGTTime))
			{
				ullGTOffset = ullOffset;
				llGTTime = llTime;
				// Assuming that the list is sorted, we can stop here.
				fDone = TRUE;
			}

		}
		ulCur = (ulCur + 1) % m_ulNumEntries;
	}
	return NOERROR;
}

HRESULT CSubstreamIndex::FindNextSyncPoint( int nStreamer,
                                            ULONGLONG ullOffset,
                                            ULONGLONG *pSyncPtOffset)
{
	// Lock the critical section for this substream
	CAutoLock l(&m_csIndex);

    *pSyncPtOffset = INVALID_OFFSET;

	// First check if there are any entries
	if (IsEmpty())
	{
		// We do not have any index entries.
		return E_FAIL;
	}

	ULONG ulHead = m_ulHead;
	
#ifdef OPTIMIZED_SEARCH
   // Optimization: m_ulStreamerPos[nStreamer] may contain the index
   // position we found the last time we were called from this streamer.
   // We know that is the case if the file offset at that position is
   // equal to ullOffset.  So in that situation we can avoid looping and
   // jump straight to the entry we found last time.
   
   // check if this is a valid streamer ID
   if ((nStreamer >= 0) || (nStreamer < MAX_STREAMERS)) { // valid streamer ?
      // Yes, check if the value in there falls within our index range
      ULONG ulPrevPos = m_ulStreamerPos[nStreamer];
      if (((m_ulHead <= m_ulTail) && (ulPrevPos >= m_ulHead) && (ulPrevPos <= m_ulTail)) ||
          ((m_ulHead > m_ulTail) && ((ulPrevPos >= m_ulHead) || (ulPrevPos <= m_ulTail))))
      { // Yes, ulPrevPos appears to be a valid index entry position
   
         // Is the value in that entry the value we are looking for ?
         if (m_pIndexArray[ulPrevPos].GetOffset() == ullOffset) {
            // Yes, we can start the search there
            ulHead = ulPrevPos;
         }
      }
   }
#endif // OPTIMIZED_SEARCH
   
   ULONGLONG offset;

   while (1)
	{
		offset = m_pIndexArray[ulHead].GetOffset();

        // Check if we are done
		if (ulHead == m_ulTail)
         break; // because we've hit the end

      if (offset > ullOffset)
         break; // because we just found what we were looking for
   	
      // Move the head.
		ulHead = (ulHead + 1) % m_ulNumEntries;
	}

   // So did we quit because we found something or because we hit the end ?
   
   if (offset > ullOffset) { // good, we found something
#ifdef OPTIMIZED_SEARCH
      m_ulStreamerPos[nStreamer] = ulHead; // remember what we found for future use
#endif
      *pSyncPtOffset = offset;
      return NOERROR;
   }
   else // no, we hit the end without finding anything
      return E_FAIL;
}


#ifdef DEBUG

void CSubstreamIndex::Dump()
{
    DbgLog((LOG_TRACE,1,"Head = %d   Tail = %d",m_ulHead, m_ulTail));
    for (ULONG i = 0; i < m_ulNumEntries; i++)
    {
        DbgLog((LOG_TRACE,3,TEXT("IndexEntry[%d] : Offset = %s   PresTime = %s"), 
                  i, 
                  (LPCTSTR) CDisp(m_pIndexArray[i].m_ullFileOffset, CDISP_DEC), 
                  (LPCTSTR) CDisp(m_pIndexArray[i].m_llPresTime, CDISP_DEC)));

        if (	m_pIndexArray[i].m_ullFileOffset == INVALID_OFFSET &&
			    m_pIndexArray[i].m_llPresTime == INVALID_PTS )
			    break;
    }
}

#endif


//////////////////////////////////////////////////////////////////
//
//	CIndexer implementation.
//
//////////////////////////////////////////////////////////////////
CIndexer::CIndexer()
{
    m_pTracker = NULL;
}

CIndexer::~CIndexer()
{
    //Lets clean up all the index arrays.
	for (int i = 0; i < MAX_SUBSTREAMS; i++)
	{
		// Check if there is a valid CIndexMapper object
		if (m_IndexMap[i].m_ulSubstreamId == 0xffffffff)
			continue;

        // Now we have an substream index.
		delete m_IndexMap[i].m_pSubstreamIndex;
		m_IndexMap[i].m_pSubstreamIndex = NULL;
		m_IndexMap[i].m_ulSubstreamId = 0xffffffff;
	}
}

//
//	GetSubstreamIndex - Steps through the array of CIndexMapper objects
//  and retrieves the CSubstreamIndex for a given substream. Returns E_FAIL
//  if the substream index is not found.
//
HRESULT CIndexer::GetSubstreamIndex(ULONG ulSubstreamId, CSubstreamIndex **ppSubstreamIndex)
{
	for (int i = 0; i < MAX_SUBSTREAMS; i++)
	{
		// Check if there is a valid CIndexMapper object
		if (m_IndexMap[i].m_ulSubstreamId == 0xffffffff)
			continue;

		if (m_IndexMap[i].m_ulSubstreamId == ulSubstreamId)
		{
			*ppSubstreamIndex = m_IndexMap[i].m_pSubstreamIndex;
			return S_OK;
		}
	}
	return E_FAIL;
}

HRESULT CIndexer::AddSubstreamIndex(ULONG SubstreamId, ULONG ulNumEntries)
{
    DbgLog((LOG_TRACE,2,"CIndexer::AddSubstreamIndex - Id : %d  Numentries : %d",SubstreamId, ulNumEntries));
	// Check if the substream index already exists as well as find
	// the first unused map entry that can be used.
	ULONG ulUnusedIndex;
	BOOL fFound = FALSE;
	
	for (ULONG i = 0; i < MAX_SUBSTREAMS; i++)
	{
		if (!fFound && m_IndexMap[i].m_ulSubstreamId == 0xffffffff)
		{
			ulUnusedIndex = i;
			fFound = TRUE;
		}

		if (m_IndexMap[i].m_ulSubstreamId == SubstreamId)
		{
			DbgLog((LOG_ERROR,1,"Index For Substream Already Exists"));
			return E_FAIL;
		}
	}

	// this would be real wierd !!! but check anyways.
	if (!fFound)
	{
		DbgLog((LOG_ERROR,1,"No Unused Index Map Entry Found"));
		return E_FAIL;
	}

	// Create a new CSubstreamIndex object and update the index map entry
	HRESULT hr;
	CSubstreamIndex *pIndex = new CSubstreamIndex(SubstreamId, ulNumEntries, m_pTracker, &hr);
	
	if (FAILED(hr))
	{
		DbgLog((LOG_ERROR,1,"Failed To Create CSubstreamIndex Object"));
		return hr;
	}

	// Update the index map entry
	m_IndexMap[ulUnusedIndex].m_ulSubstreamId = SubstreamId;
	m_IndexMap[ulUnusedIndex].m_pSubstreamIndex = pIndex;
	return NOERROR;
}

HRESULT CIndexer::DeleteSubstreamIndex(ULONG SubstreamId)
{
    DbgLog((LOG_TRACE,2,"CIndexer::DeleteSubstreamIndex - Id : %d",SubstreamId));
	for (ULONG i = 0; i < MAX_SUBSTREAMS; i++)
	{
		if (m_IndexMap[i].m_ulSubstreamId == SubstreamId)
		{
#ifdef DEBUG
            DumpIndex(i);
#endif
            delete m_IndexMap[i].m_pSubstreamIndex;
			m_IndexMap[i].m_pSubstreamIndex = NULL;
			m_IndexMap[i].m_ulSubstreamId = 0xffffffff;
			return NO_ERROR;
		}
	}
	return E_FAIL;
}

HRESULT CIndexer::PurgeSubstreamIndex(ULONG SubstreamId)
{
    DbgLog((LOG_TRACE,1,"CIndexer::PurgeSubstreamIndex - Id : %d",SubstreamId));
    CSubstreamIndex *pIndex;
	HRESULT hr = NOERROR;

	if (FAILED(hr = GetSubstreamIndex(SubstreamId, &pIndex)))
	{
		DbgLog((LOG_ERROR,1,"Substream Index Does Not Exist"));
		return hr;
	}

	return pIndex->InvalidateAllEntries();
}

HRESULT CIndexer::InvalidateIndexEntries(ULONG ulSubstreamId, 
                                         ULONGLONG ullOverwriteBlockEndOffset, 
                                         BOOL fInvalidateAllSubstreams)
{
    // Check if we need to invalidate anything.
    if (ullOverwriteBlockEndOffset == 0 || ullOverwriteBlockEndOffset == INVALID_OFFSET)
    {
        return NOERROR;
    }

	DbgLog((LOG_TRACE,4,TEXT("CIndexer::InvalidateIndexEntries - Id : %d  Offset : %s  AllStreams : %s"),
                        ulSubstreamId,
                        (LPCTSTR) CDisp(ullOverwriteBlockEndOffset, CDISP_DEC),
                        fInvalidateAllSubstreams ? "TRUE" : "FALSE"));
    HRESULT hr = NOERROR;
	for (ULONG i = 0; i < MAX_SUBSTREAMS; i++)
	{
		if (m_IndexMap[i].m_ulSubstreamId != 0xffffffff)
		{
			// Check if we need to invalidate all substreams.
            if (fInvalidateAllSubstreams || m_IndexMap[i].m_ulSubstreamId == ulSubstreamId)
            {
			    if(FAILED(hr = m_IndexMap[i].m_pSubstreamIndex->InvalidateEntries(ullOverwriteBlockEndOffset)))
			    {
				    DbgLog((LOG_ERROR,1,"Failed To Invalidate Substream Index Entries"));
				    return hr;
			    }
            }
		}
	}
	return hr;
}

HRESULT CIndexer::AddIndexEntry(	ULONG ulSubstreamId, 
									ULONGLONG ullNewFileOffset,
									REFERENCE_TIME llPresTime)
{
	DbgLog((LOG_TRACE,3,TEXT("CIndexer::AddIndexEntry - Id : %d  Offset : %s  PTS : %s"),
                        ulSubstreamId,
                        (LPCTSTR) CDisp(ullNewFileOffset, CDISP_DEC),
                        (LPCTSTR) CDisp(llPresTime, CDISP_DEC)));
                        
	// First lets invalidate the index entries on all streams for the
	// file offsets that is being overwritten
	HRESULT hr = NOERROR;
	for (ULONG i = 0; i < MAX_SUBSTREAMS; i++)
	{
		// Check if this is the substream index to which we want to add an entry
		if (m_IndexMap[i].m_ulSubstreamId != 0xffffffff && m_IndexMap[i].m_ulSubstreamId == ulSubstreamId)
		{
    		// Add the index entry
			if (FAILED(hr = m_IndexMap[i].m_pSubstreamIndex->AddIndexEntry(ullNewFileOffset, llPresTime)))
			{
				DbgLog((LOG_ERROR,1,"Failed To Add Index Entry"));
				return hr;
			}
		}
	}

	return hr;
}

/*
HRESULT CIndexer::InvalidateIndexEntries(ULONGLONG ullFileStartOffset,
										 ULONGLONG ullFileEndOffset)
{
	HRESULT hr = NOERROR;
	for (ULONG i = 0; i < MAX_SUBSTREAMS; i++)
	{
		if (m_IndexMap[i].m_ulSubstreamId != 0xffffffff)
		{
			if(FAILED(hr = m_IndexMap[i].m_pSubstreamIndex->InvalidateEntries(ullFileStartOffset, ullFileEndOffset)))
			{
				DbgLog((LOG_ERROR,1,"Failed To Invalidate Substream Index Entries"));
				return hr;
			}
		}
	}
	return hr;
}

HRESULT CIndexer::ChannelStreamGetOffset(REFERENCE_TIME llPresTime,
										 ULONGLONG &ullFileOffset)
{
	ULONGLONG ullMinOffset = INVALID_OFFSET;
	HRESULT hr = NOERROR;
	for (ULONG i = 0; i < MAX_SUBSTREAMS; i++)
	{
		if (m_IndexMap[i].m_ulSubstreamId != 0xffffffff)
		{
			ULONGLONG ullOffset;
			if (FAILED(hr = m_IndexMap[i].m_pSubstreamIndex->GetOffset(llPresTime, &ullOffset)))
			{
				DbgLog((LOG_ERROR,1,"Error Retrieving Substream Offset"));
				return hr;
			}

			// Check if this is less than ullMinOffset.
			if (ullMinOffset == INVALID_OFFSET || ullOffset < ullMinOffset)
				ullMinOffset = ullOffset;
		}
	}
	ullFileOffset = ullMinOffset;
	return NOERROR;
}
*/

//////////////////////////////////////////////////////////////////
//
//	GetOffsets
//
//	For a given subatream & presentation time, this returns the 2 closest offsets
//  and their presentation times. The first offset and presentation time
//	(ullOffsetLT_EQ & llPtsLT_EQ) is the closest index entry with
//  presentation time less than or equal to llPresTime. The second offset
//  and presentation time (ullOffsetGT & llPtsGT) is the closest
//  index entry with a presentation time greater than llPresTime.
//
//  Note : If llPresTime1 == llPresTime, then ullFileOffset2 & llPresTime2
//	will be set to INVALID_OFFSET & INVALID_PTS respectively. If there are
//  no entries in this substream index, it returns NOERROR with the offsets
//  set to INVALID_OFFSET & the presentation times set to INVALID_PTS.
//
//	Parameters:
//		llPresTime - The specified presentation time for which file offsets
//					 are retrieved.
//      ullOffsetLT_EQ
//		llPtsLT_EQ - File offset & Presentation time of the closest index entry
//					 with presentation time <= llPresTime. Values will be set
//					 to INVALID_OFFSET & INVALID_PTS if no index entries are
//					 available.
//      ullOffsetGT
//		llPtsGT - File offset & Presentation time of the closest index entry
//					  with presentation time > llPresTime. These will be set to
//					  INVALID_OFFSET & INVALID_PTS respectively if llPresTime1
//					  is equal to llPresTime or no index entries are available.
//
//	Returns :
//		NOERROR if successful
//////////////////////////////////////////////////////////////////
HRESULT CIndexer::ChannelSubstreamGetOffsets(ULONG ulSubstreamId,
											 REFERENCE_TIME llPresTime,
											 ULONGLONG &ullOffsetLT_EQ,
											 REFERENCE_TIME &llPtsLT_EQ,
											 ULONGLONG &ullOffsetGT,
											 REFERENCE_TIME &llPtsGT)
{
	CSubstreamIndex *pIndex;
	HRESULT hr = NOERROR;
	// Find the substream index object for ulSubstreamId
	if (FAILED(hr = GetSubstreamIndex(ulSubstreamId, &pIndex)))
	{
		DbgLog((LOG_ERROR,1,"Index For Substream Does Not Exist"));
		return E_INVALIDARG;
	}

	// Just a sanity check
	ASSERT(pIndex);

	if (FAILED(hr = pIndex->GetOffsets(	llPresTime, 
										ullOffsetLT_EQ,
										llPtsLT_EQ,
										ullOffsetGT,
										llPtsGT)))
	{
		DbgLog((LOG_ERROR,1,"Error Retrieving Substream Offsets"));
		return hr;
	}
	return NOERROR;
}

HRESULT CIndexer::FindNextSyncPoint(    int nStreamer,
                                        ULONG ulSubstreamId,
                                        ULONGLONG ullOffset,
                                        ULONGLONG *pSyncPtOffset)
{
    CSubstreamIndex *pIndex;
    HRESULT hr = NOERROR;

    // Find the substream index object for ulSubstreamId
	if (FAILED(hr = GetSubstreamIndex(ulSubstreamId, &pIndex)))
	{
		DbgLog((LOG_ERROR,1,"Index For Substream Does Not Exist"));
		return E_INVALIDARG;
	}

    // Just a sanity check
	ASSERT(pIndex);
	if (FAILED(hr = pIndex->FindNextSyncPoint(nStreamer, ullOffset, pSyncPtOffset)))
	{
		DbgLog((LOG_ERROR,1,"Error: CSubstreamIndex::FindNextSyncPoint"));
		return hr;
	}
	return NOERROR;
}


#ifdef DEBUG
void CIndexer::DumpIndex(ULONG ulID)
{
    DbgLog((LOG_TRACE,3,"**** START INDEX DUMP ******"));

    for (int i = 0; i < MAX_SUBSTREAMS; i++)
	{
		// Check if there is a valid CIndexMapper object
		if (m_IndexMap[i].m_ulSubstreamId == 0xffffffff)
			continue;

		if (m_IndexMap[i].m_ulSubstreamId == ulID)
        {
            DbgLog((LOG_TRACE,3,"*** Index Entries for Substream[%d]", i));
		    m_IndexMap[i].m_pSubstreamIndex->Dump();
        }
	}
    DbgLog((LOG_TRACE,3,"**** END INDEX DUMP ******"));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\delay\delay.cpp ===
#include <streams.h>
#include <initguid.h>
#include <uuids.h>
//#include <ks.h>
//#include <ksmedia.h>
#include <commctrl.h>
#include <stdio.h>
#include "dvdmedia.h"
#include "delay.h"
#include "resource.h"
///
///   AM stuff
///

DEFINE_GUID(CLSID_DelayFilter,0xd53b9ef6, 0xb264, 0x11d2, 0x9a, 0x95, 0x00, 0xc0, 0x4f, 0x79, 0x9b, 0xb9);
DEFINE_GUID(CLSID_DelayFilterProperties,0xea46b1e0, 0xf126, 0x11d2, 0x88, 0x73, 0x00, 0x90, 0x27, 0x41, 0xfc, 0x26);
DEFINE_GUID(CLSID_FirstStreamerProperties,0x88e8b760, 0xf126, 0x11d2, 0x88, 0x73, 0x00, 0x90, 0x27, 0x41, 0xfc, 0x26);
DEFINE_GUID(CLSID_SecondStreamerProperties,0x88e8b761, 0xf126, 0x11d2, 0x88, 0x73, 0x00, 0x90, 0x27, 0x41, 0xfc, 0x26);

static AMOVIESETUP_PIN RegistrationPinInfo[] =
{
    { // input
        L"Delay input",
        FALSE, // bRendered
        FALSE, // bOutput
        FALSE, // bZero
        FALSE, // bMany
        &CLSID_NULL, // clsConnectsToFilter
        NULL, // ConnectsToPin
        0, //NUMELMS(sudInputTypes),
        NULL //sudInputTypes
    }
};

AMOVIESETUP_FILTER RegistrationInfo =
{
    &CLSID_DelayFilter,
    L"Delay Filter",
    0x00600000, // merit
    NUMELMS(RegistrationPinInfo), // nPins
    RegistrationPinInfo
};

CFactoryTemplate g_Templates[] =
{
    {
        L"Delay filter g_Templates name",
        &CLSID_DelayFilter,
        CDelayFilter::CreateInstance,
        NULL,
        &RegistrationInfo
    },
    {
       L"Delay filter properties",
       &CLSID_DelayFilterProperties,
       CDelayFilterProperties::CreateInstance
    },
    {
       L"Main streamer properties",
       &CLSID_FirstStreamerProperties,
       CreateFirstStreamerPropPage
    },
    {
       L"Archive streamer properties",
       &CLSID_SecondStreamerProperties,
       CreateSecondStreamerPropPage
    }

};

int g_cTemplates = NUMELMS(g_Templates);

STDAPI DllRegisterServer()
{
    DbgLog((LOG_TRACE,5,"DllRegisterServer"));
    return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
    DbgLog((LOG_TRACE,5,"DllUnregisterServer"));
    return AMovieDllRegisterServer2( FALSE );
}

CStreamer::CStreamer(CDelayFilter *pFilter, int nStreamerPos)
{
   DbgLog((LOG_TRACE,2,"streamer constructor"));
   m_pFilter = pFilter;
   m_nStreamerPos = nStreamerPos;
   m_State = Uninitialized;
}


// IChannelStreamPinEnum methods
HRESULT CStreamer::ChannelStreamGetPinCount(int *nCount) {
   *nCount = m_pFilter->m_nSubstreams;
   return NOERROR;
}

HRESULT CStreamer::ChannelStreamGetPin(int n, IPin **ppPin) {
   if ((n < 0) || (n > m_pFilter->m_nSubstreams))
      return E_INVALIDARG;
   CDelayOutputPin *pPin = m_pFilter->m_pOutputPins[m_nStreamerPos][m_pFilter->GetNthSubstreamPos(n)];
   if (pPin == NULL)
      return E_FAIL;
   return pPin->QueryInterface(IID_IPin, (void**)ppPin);
}

HRESULT CStreamer::ChannelStreamGetID(int *nID) {
   *nID = m_nStreamerPos;
   return NOERROR;
}

HRESULT CStreamer::QueryInterface(REFIID riid, void ** ppv) {
   if (riid == IID_IChannelStreamPinEnum) {
      return GetInterface((IChannelStreamPinEnum *) this, ppv);
   } else if (riid == IID_IDelayStreamer) {
      return GetInterface((IDelayStreamer *) this, ppv);
   } else if (riid == IID_IDelayStreamerInternal) {
      return GetInterface((IDelayStreamerInternal *) this, ppv);
   } else if (riid == IID_IUnknown) {
      return GetInterface((IUnknown *) (IDelayStreamer*) this, ppv);
   }
   else
      return E_NOINTERFACE;
}

ULONG CStreamer::AddRef() {
   return m_pFilter->AddRef();
}

ULONG CStreamer::Release() {
   return m_pFilter->Release();
}

HRESULT CStreamer::GetMarker(GUID *pMarkerGUID,
          REFERENCE_TIME *pMarkerPresentationTime,
          ULONG *pIndex) {
   // ?
   return E_NOTIMPL;
}

// IDelayStreamer methods

HRESULT CStreamer::IsConnected() {
   return m_pFilter->IsStreamerConnected(m_nStreamerPos) && (m_State != Uninitialized);
}

//
// Filter property page code
//
CUnknown * WINAPI CDelayFilterProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CDelayFilterProperties(lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}

CDelayFilterProperties::CDelayFilterProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CBasePropertyPage(NAME("Filter Properties"), lpunk,
        IDD_DELAYFILTERPROP,IDS_DELAYFILTERPROPNAME)
    , m_pFilter(NULL)
{
    ASSERT(phr);
    m_ullFileSize = 0;
    m_ulWindowSize = 0;
    strcpy(m_szFileName, "uninitialized");
    InitCommonControls();
}

HRESULT CDelayFilterProperties::OnConnect(IUnknown *pUnknown) {
   ASSERT(!m_pFilter);
   HRESULT hr = pUnknown->QueryInterface(IID_IDelayFilter, (void**) &m_pFilter);
   if (FAILED(hr)) {
      m_pFilter = NULL;
      return hr;
   }
   if (!m_pFilter)
      return E_FAIL;

   IDelayFilterInternal *pFilter;
   if (FAILED(hr = m_pFilter->QueryInterface(IID_IDelayFilterInternal, (void**) &pFilter))) {
      m_pFilter->Release();
      m_pFilter = NULL;
      return hr;
   }
   if (!pFilter) {
      m_pFilter->Release();
      m_pFilter = NULL;
      return hr;
   }

   if (FAILED(hr = pFilter->GetDelayWindowParams(m_szFileName, &m_ullFileSize, &m_ulWindowSize))) {
      m_pFilter->Release();
      m_pFilter = NULL;
      pFilter->Release();
      return hr;
   }
   pFilter->Release();
   return NOERROR;
}

HRESULT CDelayFilterProperties::OnDisconnect() {
   if (!m_pFilter)
      return E_UNEXPECTED;
   m_pFilter->Release();
   m_pFilter = NULL;
   return NOERROR;
}

HRESULT CDelayFilterProperties::OnActivate(void)
{
   UpdateFields();
   return NOERROR;
}

void CDelayFilterProperties::UpdateFields() {
   TCHAR szTemp[80];
   SetDlgItemText(m_hwnd, IDC_FILENAMETEXT, m_szFileName);
   TCHAR szSize[32];
   sprintf(szSize, "%I64u", m_ullFileSize);
   SetDlgItemText(m_hwnd, IDC_FILESIZETEXT, szSize);
   TCHAR szWindow[16];
   sprintf(szWindow, "%u", m_ulWindowSize);
   SetDlgItemText(m_hwnd, IDC_WINDOWSIZETEXT, szWindow);
}

HRESULT CDelayFilterProperties::OnDeactivate(void)
{
   return NOERROR;
}


HRESULT CDelayFilterProperties::OnApplyChanges(void)
{
	if ((!m_pFilter) || (FAILED(m_pFilter->SetDelayWindowParams(m_szFileName, m_ullFileSize, m_ulWindowSize))))
		MessageBox(m_hwnd, "SetDelayWindowParams() failed - changes were not applied", "filter problems", MB_OK);
    return NOERROR;
}

BOOL CDelayFilterProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam)
{
    switch (uMsg) {

    case WM_COMMAND:

        if (HIWORD(wParam) == EN_KILLFOCUS) {
           TCHAR szTemp[80];
           ULONG ulWindowSize;
           ULONGLONG ullFileSize;
           switch (LOWORD(wParam)) {
   
           case IDC_FILENAMETEXT:
              GetDlgItemText(m_hwnd, IDC_FILENAMETEXT, m_szFileName, 80);
              break;
           case IDC_FILESIZETEXT:
              GetDlgItemText(m_hwnd, IDC_FILESIZETEXT, szTemp, 80);
              if (sscanf(szTemp, "%I64u", &ullFileSize) != 1) {
                 MessageBox(m_hwnd, "Bad file size - changes were not applied", "bad user input", MB_OK);
                 UpdateFields();
              }
              else
                 m_ullFileSize = ullFileSize;
              break;
           case IDC_WINDOWSIZETEXT:
              GetDlgItemText(m_hwnd, IDC_WINDOWSIZETEXT, szTemp, 80);
              if (sscanf(szTemp, "%u", &ulWindowSize) != 1) {
                 MessageBox(m_hwnd, "Bad window size - changes were not applied", "bad user input", MB_OK);
                 UpdateFields();
              }
              else
                 m_ulWindowSize = ulWindowSize;
              break;
           default:
               break;
           }
           m_bDirty = TRUE;
           if (m_pPageSite)
               m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
        }
        return TRUE;

    case WM_DESTROY:
        return TRUE;

    default:
        return FALSE;

    }
    return TRUE;
}
// End filter property page code

//
// Streamer property page code
//
CUnknown * WINAPI CreateFirstStreamerPropPage(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CDelayStreamerProperties(lpunk, phr, 0);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}

CUnknown * WINAPI CreateSecondStreamerPropPage(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CDelayStreamerProperties(lpunk, phr, 1);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}

CDelayStreamerProperties::CDelayStreamerProperties(LPUNKNOWN lpunk, HRESULT *phr, int nStreamer)
    : CBasePropertyPage(NAME("Streamer Properties"), lpunk,
        IDD_DELAYSTREAMERPROP,IDS_DELAYSTREAMERPROPNAME)
    , m_pStreamer(NULL),
      m_nStreamer(nStreamer)
{
    ASSERT(phr);

    InitCommonControls();
}

HRESULT CDelayStreamerProperties::OnConnect(IUnknown *pUnknown) {
   IDelayFilter *pFilter;
   ASSERT(!m_pStreamer);
   
   HRESULT hr = pUnknown->QueryInterface(IID_IDelayFilter, (void**) &pFilter);
   if (FAILED(hr))
      return hr;
   if (!pFilter)
      return E_FAIL;
   
   int nStreamers;
   IDelayStreamer *pStreamer;
   if ((SUCCEEDED(pFilter->GetStreamerCount(&nStreamers))) && (m_nStreamer < nStreamers))
      hr = pFilter->GetStreamer(m_nStreamer, &pStreamer);
   else
	  hr = E_FAIL;
   pFilter->Release();
   
   if (FAILED(hr))
      return hr;

   if (!pStreamer)
      return E_FAIL;

   hr = pStreamer->QueryInterface(IID_IDelayStreamerInternal, (void**) &m_pStreamer);
   pStreamer->Release();

   if (FAILED(hr)) {
      m_pStreamer = NULL;
      return hr;
   }
    
   if (!m_pStreamer)
      return E_FAIL;

   if (!m_pStreamer->IsConnected()) {
      m_pStreamer->Release();
      m_pStreamer = NULL;
      return VFW_E_NOT_CONNECTED;
   }

   if (FAILED(hr = m_pStreamer->GetState((int*)(&m_State), &m_dRate))) {
      m_pStreamer->Release();
      m_pStreamer = NULL;
      return hr;
   }

   return NOERROR;
}

HRESULT CDelayStreamerProperties::OnDisconnect() {
   if (!m_pStreamer)
      return E_UNEXPECTED;
   m_pStreamer->Release();
   m_pStreamer = NULL;
   return NOERROR;
}

HRESULT CDelayStreamerProperties::OnActivate(void)
{
   UpdateFields();
   return NOERROR;
}

void CDelayStreamerProperties::UpdateFields() {
   TCHAR szTemp[80];
   sprintf(szTemp,"%lf", m_dRate);
   SetDlgItemText(m_hwnd, IDC_RATE, szTemp);
   switch(m_State) {
   case Stopped:
      CheckRadioButton(m_hwnd, IDC_STOPPED, IDC_ARCHIVING, IDC_STOPPED);
      break;
   case Streaming:
      CheckRadioButton(m_hwnd, IDC_STOPPED, IDC_ARCHIVING, IDC_STREAMING);
      break;
   case Paused:
      CheckRadioButton(m_hwnd, IDC_STOPPED, IDC_ARCHIVING, IDC_PAUSED);
      break;
   case Archiving:
      CheckRadioButton(m_hwnd, IDC_STOPPED, IDC_ARCHIVING, IDC_ARCHIVING);
      break;
   }
}

HRESULT CDelayStreamerProperties::OnDeactivate(void)
{
   return NOERROR;
}


HRESULT CDelayStreamerProperties::OnApplyChanges(void)
{
/*
	if ((!m_pStreamer) || (FAILED(m_pStreamer->SetState(m_State, m_dRate))))
		MessageBox(m_hwnd, "SetState() failed - changes were not applied", "streamer problems", MB_OK);
*/
       return NOERROR;
}

BOOL CDelayStreamerProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam)
{
   STREAMER_STATE RequestedState;
   switch (uMsg) {

   case WM_COMMAND:
      switch (LOWORD(wParam)) {
      case IDC_RATE:
         if (HIWORD(wParam) == EN_KILLFOCUS) {
            TCHAR szTemp[80];
            double dRate;
            GetDlgItemText(m_hwnd, IDC_RATE, szTemp, 80);
            if (sscanf(szTemp, "%lf", &dRate) != 1)
               MessageBox(m_hwnd, "Bad rate value - changes were not applied", "bad user input", MB_OK);
            else {
               m_dRate = dRate;
               m_pStreamer->SetState(m_State, m_dRate, (int*)(&m_State), &m_dRate);
            }
            UpdateFields();
         }
         break;
      case IDC_STOPPED:
      case IDC_STREAMING:
      case IDC_PAUSED:
      case IDC_ARCHIVING:
         switch (LOWORD(wParam)) {
         case IDC_STOPPED:
            RequestedState = Stopped; break;
         case IDC_STREAMING:
            RequestedState = Streaming; break;
         case IDC_PAUSED:
            RequestedState = Paused; break;
         case IDC_ARCHIVING:
            RequestedState = Archiving; break;
         }
         m_pStreamer->SetState(RequestedState, m_dRate, (int*)(&m_State), &m_dRate);
         UpdateFields();
/*
         if (RequestedState != m_State)
            MessageBox(NULL,"requested state transition is not valid", "", MB_OK);
*/
         break;
      }

   case WM_DESTROY:
       return TRUE;

   default:
       return FALSE;

   }
   return TRUE;
}
// End streamer property page code


CUnknown*
CALLBACK
CDelayFilter::CreateInstance(
    LPUNKNOWN UnkOuter,
    HRESULT* hr
    )
{
    CUnknown *Unknown;

    DbgLog((LOG_TRACE,5,"CreateInstance"));
    
    *hr = S_OK;
    Unknown = new CDelayFilter(UnkOuter, hr);
    if (!Unknown){
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
}

#define REG_KEY_PATH "Software\\Microsoft\\TimeshiftingDelayFilter"
#define FILENAME_VALUE_NAME "FilePath"
#define FILESIZE_VALUE_NAME "FileSize"
#define WINDOWSIZE_VALUE_NAME "WindowSize"
#define BUFFERWRITES_VALUE_NAME "BufferWrites"
#define WRITEBUFFERSIZE_VALUE_NAME "WriteBufferSize"
#define BLOCKWRITER_VALUE_NAME "BlockWriter"
#define USEOUTPUTQUEUES_VALUE_NAME "UseOutputQueues"

void CheckRegValue(HKEY hKey,
                   char *pName,
                   DWORD dwAcceptedTypes,
                   DWORD dwExpectedSize,
                   BYTE *pbDest) {
   BYTE pbData[1024]; // big enough ?
   DWORD dwSize = 1024;
   DWORD dwType;
   if (RegQueryValueEx(hKey,
                       pName,
                       NULL,
                       &dwType,
                       pbData,
                       &dwSize) == ERROR_SUCCESS) {
      if ((dwType & dwAcceptedTypes) && ((dwSize == dwExpectedSize) || (dwExpectedSize == 0)))
         memcpy(pbDest, pbData, dwSize);
   }
}

void CDelayFilter::ReadRegistry() {
   HKEY hKey;

   if (RegOpenKey(HKEY_LOCAL_MACHINE,
                   REG_KEY_PATH,
                   &hKey) != ERROR_SUCCESS)
      return; // no key

   CheckRegValue(hKey, FILENAME_VALUE_NAME,        REG_SZ,     0, (BYTE*)m_szFileName);
   CheckRegValue(hKey, FILESIZE_VALUE_NAME,        REG_BINARY, 8, (BYTE*)&m_ullFileSize);
   CheckRegValue(hKey, WINDOWSIZE_VALUE_NAME,      REG_DWORD,  4, (BYTE*)&m_ulDelayWindow);
   CheckRegValue(hKey, BUFFERWRITES_VALUE_NAME,    REG_BINARY, 1, (BYTE*)&m_bBufferWrites);
   CheckRegValue(hKey, WRITEBUFFERSIZE_VALUE_NAME, REG_DWORD,  4, (BYTE*)&m_ulWriteBufferSize);
   CheckRegValue(hKey, BLOCKWRITER_VALUE_NAME,     REG_BINARY, 1, (BYTE*)&m_bBlockWriter);
   CheckRegValue(hKey, USEOUTPUTQUEUES_VALUE_NAME, REG_BINARY, 1, (BYTE*)&m_bUseOutputQueues);

   RegCloseKey(hKey);
}

void CDelayFilter::WriteRegistry() {
   HKEY hKey;
   if (RegCreateKey(HKEY_LOCAL_MACHINE,
                    REG_KEY_PATH,
                    &hKey) != ERROR_SUCCESS)
      return;

   RegSetValueEx(hKey,FILENAME_VALUE_NAME,       NULL,REG_SZ,    (BYTE*)m_szFileName,   strlen(m_szFileName) + 1);
   RegSetValueEx(hKey,FILESIZE_VALUE_NAME,       NULL,REG_BINARY,(BYTE*)&m_ullFileSize, 8);
   RegSetValueEx(hKey,WINDOWSIZE_VALUE_NAME,     NULL,REG_DWORD, (BYTE*)&m_ulDelayWindow,4);
   RegSetValueEx(hKey,BUFFERWRITES_VALUE_NAME,   NULL,REG_BINARY,(BYTE*)&m_bBufferWrites, 1);
   RegSetValueEx(hKey,WRITEBUFFERSIZE_VALUE_NAME,NULL,REG_DWORD, (BYTE*)&m_ulWriteBufferSize, 4);
   RegSetValueEx(hKey,BLOCKWRITER_VALUE_NAME,    NULL,REG_BINARY,(BYTE*)&m_bBlockWriter, 1);
   RegSetValueEx(hKey,USEOUTPUTQUEUES_VALUE_NAME,NULL,REG_BINARY,(BYTE*)&m_bUseOutputQueues, 1);
   RegCloseKey(hKey);
}

#pragma warning(disable:4355)
CDelayFilter::CDelayFilter(
    LPUNKNOWN UnkOuter,
    HRESULT* phr
)
:
    CBaseFilter(
        TEXT("Delay Filter CBaseFilter constructor name"),
        UnkOuter,
        &m_csFilter,
        CLSID_DelayFilter
    )
{
    DbgLog((LOG_TRACE,2,"filter constructor entered"));
    *phr = NOERROR;
    char szFileName[1024] = "d:\\shift";
    ULONGLONG ullFileSize = 0x80000000; // 2GB
    ULONG ulWindowSize = 7200; // 2 hours

    // Create the circular buffer window tracker
    m_pTracker = new CCircBufWindowTracker(this);
    // give the CCircBufWindowTracker pointer to the indexer
    m_Indexer.InitTracker(m_pTracker);
    
    m_ulDelayWindow = 0;
    m_ullFileSize = 0;

    m_nSubstreams = 0;
    m_nStreamers = 0;
    int i,j;
    for (i = 0; i < MAX_STREAMERS; i++) {
       m_pStreamers[i] = NULL;
       for (j = 0; j < MAX_SUBSTREAMS; j++)
          m_pOutputPins[i][j] = NULL;
    }
    for (i = 0; i < MAX_SUBSTREAMS; i++)
       m_pInputPins[i] = NULL;

    *phr = AddSubstream();
    if (FAILED(*phr))
       goto filterconstructorfail;

    *phr = AddStreamer();
    if (FAILED(*phr))
       goto filterconstructorfail;

    // Initialize various operation parameters
    m_ulDelayWindow = 7200;
    m_ullFileSize = 1024 * 1024 * 256;
    strcpy (m_szFileName,"c:\\shift");
    m_bBufferWrites = FALSE;
    m_ulWriteBufferSize = 4 * 1024 * 1024;
    m_bUseOutputQueues = TRUE;
    
    // Check the registry for overriding values
    ReadRegistry();

    DbgLog((LOG_TRACE,2,"filter constructor success"));
    return;

filterconstructorfail:
    if (m_pStreamers[0]) delete m_pStreamers[0];
    if (m_pInputPins[0]) delete m_pInputPins[0];
    if (m_pOutputPins[0][0]) delete m_pOutputPins[0][0];
    DbgLog((LOG_ERROR,1,"filter constructor failed"));
    return;
}

CDelayFilter::~CDelayFilter()
{
    DbgLog((LOG_TRACE,2,"filter destructor"));

    WriteRegistry();

    // Clean up the circular buffer window tracker
    if (m_pTracker)
        delete m_pTracker;

    int nSubstreamPos, nStreamerPos;

    // delete the output pins and streamers
    for (nStreamerPos = 0; nStreamerPos < MAX_STREAMERS; nStreamerPos++) {
       if (m_pStreamers[nStreamerPos]) { // does the streamer exist ?
          // delete the output pins
          for (nSubstreamPos = 0; nSubstreamPos < MAX_SUBSTREAMS; nSubstreamPos++) {
             if (m_pInputPins[nSubstreamPos]) { // does the substream exist ?
                if (m_pOutputPins[nStreamerPos][nSubstreamPos] == NULL) {
                   DbgLog((LOG_ERROR,1,"missing output pin object"));
                   ASSERT(!"missing output pin object");
                }
                else {
                   delete m_pOutputPins[nStreamerPos][nSubstreamPos];
                   m_pOutputPins[nStreamerPos][nSubstreamPos] = NULL;
                }
             }
          }
          // delete the streamer
          delete m_pStreamers[nStreamerPos];
          m_pStreamers[nStreamerPos] = NULL;
       }
    }

    // delete the input pins
    for (nSubstreamPos = 0; nSubstreamPos < MAX_SUBSTREAMS; nSubstreamPos++) {
       if (m_pInputPins[nSubstreamPos]) {
          delete m_pInputPins[nSubstreamPos];
          m_pInputPins[nSubstreamPos] = NULL;
       }
    }

    m_nSubstreams = 0;
    m_nStreamers = 0;
}

HRESULT CDelayFilter::AddSubstream(void) {
   HRESULT hr;

   // find a substream slot
   int nSubstreamPos = 0, nStreamerPos;
   do {
      if (m_pInputPins[nSubstreamPos] == 0)
         break;
      nSubstreamPos++;
      if (nSubstreamPos >= MAX_SUBSTREAMS) {
         DbgLog((LOG_ERROR,1,"out of substream slots"));
         return E_OUTOFMEMORY; // for lack of a better error code
      }
   } while (1);
   ASSERT((nSubstreamPos < MAX_SUBSTREAMS) && (m_pInputPins[nSubstreamPos] == NULL));

   if (m_pInputPins[nSubstreamPos] != NULL) {
      DbgLog((LOG_ERROR,1,"substream / input pin slot inconsistency"));
      ASSERT("substream / input pin slot inconsistency");
      return E_FAIL;
   }
   
   for (nStreamerPos = 0; nStreamerPos < MAX_STREAMERS; nStreamerPos++) {
      if (m_pOutputPins[nStreamerPos][nSubstreamPos] != NULL) {
         DbgLog((LOG_ERROR,1,"substream / output pin slot inconsistency"));
         ASSERT(!"substream / output pin slot inconsistency");
         return E_FAIL;
      }
   }

   // create the extra input pin
   m_pInputPins[nSubstreamPos] = CDelayInputPin::CreatePin(TEXT("delay filter input pin"),
                                                        this,
                                                        &hr,
                                                        L"",
                                                        nSubstreamPos);
   if (m_pInputPins[nSubstreamPos] == NULL) {
      DbgLog((LOG_ERROR,1,"could not create an input pin"));
      hr = E_OUTOFMEMORY;
      goto addsubstreamfail;
   }
   if (FAILED(hr)) {
      DbgLog((LOG_ERROR,1,"an input pin failed to initialize"));
      goto addsubstreamfail;
   }

   // create the extra output pins
   for (nStreamerPos = 0; nStreamerPos < MAX_STREAMERS; nStreamerPos++) {
      if (m_pStreamers[nStreamerPos]) { // does the streamer exist ?
         m_pOutputPins[nStreamerPos][nSubstreamPos]
                                = CDelayOutputPin::CreatePin(TEXT("delay filter output pin"),
                                                             this,
                                                             &hr,
                                                             L"",
                                                             nStreamerPos,nSubstreamPos);
         if (m_pOutputPins[nStreamerPos][nSubstreamPos] == NULL) {
            DbgLog((LOG_ERROR,1,"could not create an output pin"));
            hr = E_OUTOFMEMORY;
            goto addsubstreamfail;
         }
         if (FAILED(hr)) {
            DbgLog((LOG_ERROR,1,"an output pin failed to initialize"));
            goto addsubstreamfail;
         }
      }
   }

   m_nSubstreams++;
   return NOERROR;

addsubstreamfail:
   if (m_pInputPins[nSubstreamPos]) {
      delete m_pInputPins[nSubstreamPos];                     
      m_pInputPins[nSubstreamPos] = NULL;
   }
   for (nStreamerPos = 0 ; nStreamerPos < MAX_STREAMERS; nStreamerPos++) {
      if (m_pOutputPins[nStreamerPos][nSubstreamPos] != NULL) {
         if (m_pStreamers[nStreamerPos] == NULL) {
            DbgLog((LOG_ERROR,1,"stray output pin"));
            ASSERT(!"stray output pin");
         }
         else {
            delete m_pOutputPins[nStreamerPos][nSubstreamPos];
            m_pOutputPins[nStreamerPos][nSubstreamPos] = NULL;
         }
      }
   }
   return hr;
}

HRESULT CDelayFilter::AddStreamer(void) {
   HRESULT hr;

   // find a streamer slot
   int nStreamerPos = 0, nSubstreamPos;
   do {
      if (m_pStreamers[nStreamerPos] == 0)
         break;
      nStreamerPos++;
      if (nStreamerPos >= MAX_STREAMERS) {
         DbgLog((LOG_ERROR,1,"out of streamer slots"));
         return E_OUTOFMEMORY; // for lack of a better error code
      }
   } while (1);
   ASSERT((nStreamerPos < MAX_STREAMERS) && (m_pStreamers[nStreamerPos] == NULL));

   for (nSubstreamPos = 0; nSubstreamPos < MAX_SUBSTREAMS; nSubstreamPos++) {
      if (m_pOutputPins[nStreamerPos][nSubstreamPos] != NULL) {
         DbgLog((LOG_ERROR,1,"streamer / output pin slot inconsistency"));
         ASSERT(!"streamer / output pin slot inconsistency");
         return E_FAIL;
      }
   }

   // create the streamer object
   m_pStreamers[nStreamerPos] = new CStreamer(this, nStreamerPos);
   if (m_pStreamers[nStreamerPos] == NULL) {
      DbgLog((LOG_ERROR,1,"could not create a streaner object"));
      hr = E_OUTOFMEMORY;
      goto addstreamerfail;
   }

   // create the extra output pins
   for (nSubstreamPos = 0; nSubstreamPos < MAX_SUBSTREAMS; nSubstreamPos++) {
      if (m_pInputPins[nSubstreamPos]) { // does the substream exist ?
         m_pOutputPins[nStreamerPos][nSubstreamPos]
                                = CDelayOutputPin::CreatePin(TEXT("delay filter output pin"),
                                                             this,
                                                             &hr,
                                                             L"",
                                                             nStreamerPos,nSubstreamPos);
         if (m_pOutputPins[nStreamerPos][nSubstreamPos] == NULL) {
            DbgLog((LOG_ERROR,1,"could not create an output pin"));
            hr = E_OUTOFMEMORY;
            goto addstreamerfail;
         }
         if (FAILED(hr)) {
            DbgLog((LOG_ERROR,1,"an output pin failed to initialize"));
            goto addstreamerfail;
         }
      }
   }
   m_nStreamers++;
   return NOERROR;

addstreamerfail:
   if (m_pStreamers[nStreamerPos]) {
      delete m_pStreamers[nStreamerPos];
      m_pStreamers[nStreamerPos] = NULL;
   }
   for (nSubstreamPos = 0 ; nSubstreamPos < MAX_SUBSTREAMS; nSubstreamPos++) {
      if (m_pOutputPins[nStreamerPos][nSubstreamPos] != NULL) {
         if (m_pInputPins[nSubstreamPos] == NULL) {
            DbgLog((LOG_ERROR,1,"stray output pin"));
            ASSERT(!"stray output pin");
         }
         else {
            delete m_pOutputPins[nStreamerPos][nSubstreamPos];
            m_pOutputPins[nStreamerPos][nSubstreamPos] = NULL;
         }
      }
   }
   return hr;
}

HRESULT CDelayFilter::RemoveSubstream(int nSubstreamPos) {
   return E_NOTIMPL;
}

HRESULT CDelayFilter::RemoveStreamer(int nStreamerPos) {
   return E_NOTIMPL;
}

int CDelayFilter::GetPinCount(void)
{
    DbgLog((LOG_TRACE,5,"GetPinCount"));
    return m_nSubstreams * (m_nStreamers + 1);
}

//
// The following two functions are used to find the index of the nth
// streamer/substream.  This is needed because the nth entry may not
// be in the nth position of the array if something was deleted.
//
int CDelayFilter::GetNthSubstreamPos(int nSubstream) {
   int nPos = 0, nCount = -1;
   do {
      if (m_pInputPins[nPos] != NULL)
         nCount++;
      if (nCount == nSubstream)
         return nPos;

      nPos++;
      if (nPos >= MAX_SUBSTREAMS) {
         DbgLog((LOG_ERROR,1,"bad substream id"));
         ASSERT(!"bad substream id");
         return 0x8000000; // so that we crash some place easy to debug
      }
   } while (1);
   ASSERT(FALSE); // we never get out here
   return 0;
}

int CDelayFilter::GetNthStreamerPos(int nStreamer) {
   int nPos = 0, nCount = -1;
   do {
      if (m_pStreamers[nPos] != NULL)
         nCount++;
      if (nCount == nStreamer)
         return nPos;

      nPos++;
      if (nPos >= MAX_STREAMERS) {
         DbgLog((LOG_ERROR,1,"bad streamer id"));
         ASSERT(!"bad streamer id");
         return 0x8000000; // so that we crash some place easy to debug
      }
   } while (1);
   ASSERT(FALSE); // we never get out here
   return 0;
}

class CBasePin* CDelayFilter::GetPin(int nPin)
{
    DbgLog((LOG_TRACE,5,"GetPin(%d)",nPin));
    // Pin ordering: the first m_nSubstreams are input pins;
    // then come the m_nSubstreams pins for the first streamer,
    // m_nSubstreams pins for the second streamer, and so on

    if (nPin < m_nSubstreams) // input pin
       return m_pInputPins[GetNthSubstreamPos(nPin)];
    else if (nPin < m_nSubstreams * (m_nStreamers + 1)) { // output pin
       int nStreamer = (nPin - m_nSubstreams) / m_nSubstreams;
       int nSubstream = (nPin - m_nSubstreams) % m_nSubstreams;
       ASSERT(nStreamer < m_nStreamers);
       ASSERT(nSubstream < m_nSubstreams);
       CDelayOutputPin *pPin = m_pOutputPins[GetNthStreamerPos(nStreamer)]
                                            [GetNthSubstreamPos(nSubstream)];
       if (pPin == NULL) {
          DbgLog((LOG_ERROR,1,"pin id mixup"));
          ASSERT(!"pin id mixup");
       }
       return pPin;
    }
    else {
       DbgLog((LOG_ERROR,1,"GetPin(): bad pin id"));
       return NULL;
    }
}

BOOL CDelayFilter::AreAllInputPinsConnected() {
   for (int nSubstreamPos = 0; nSubstreamPos < MAX_SUBSTREAMS; nSubstreamPos++)
      if (m_pInputPins[nSubstreamPos] && (!(m_pInputPins[nSubstreamPos]->IsConnected())))
            return FALSE;
   return TRUE;
}

BOOL CDelayFilter::IsStreamerConnected(int nStreamerPos) {
   for (int nSubstreamPos = 0; nSubstreamPos < MAX_SUBSTREAMS; nSubstreamPos++)
      if (m_pInputPins[nSubstreamPos] && (m_pOutputPins[nStreamerPos][nSubstreamPos]->IsConnected()))
            return TRUE;
   return FALSE;
}

BOOL CDelayFilter::AreAllStreamersConnected() {
   for (int nStreamerPos = 0; nStreamerPos < MAX_STREAMERS; nStreamerPos++) {
      if (m_pStreamers[nStreamerPos] && (!IsStreamerConnected(nStreamerPos)))
         return FALSE;
   }
   return TRUE; // all streamers were at least partially connected
}

HRESULT CDelayFilter::Pause(void)
{
    CAutoLock l(m_pLock);
    HRESULT hr;

    if (m_State == State_Stopped) {
       m_ullLastVideoSyncPoint = 0;
       
       if (FAILED(hr = m_IO.Init(this,
                                 m_ullFileSize,
                                 m_szFileName,
                                 m_bBlockWriter,
                                 m_bBufferWrites,
                                 m_ulWriteBufferSize))) {
          DbgLog((LOG_ERROR,1,"the IO layer failed to initialize"));
          return hr;
       }

       for (int nStreamerPos = 0; nStreamerPos < MAX_STREAMERS; nStreamerPos++)
          if (m_pStreamers[nStreamerPos] && (IsStreamerConnected(nStreamerPos)))
             if (FAILED(hr = m_pStreamers[nStreamerPos]->Init(&m_IO))) {
                DbgLog((LOG_ERROR,1,"a streamer failed to initialize"));
                return hr;
             }

       for (int nSubstreamPos = 0; nSubstreamPos < MAX_SUBSTREAMS; nSubstreamPos++) {
          if (m_pInputPins[nSubstreamPos] && m_pInputPins[nSubstreamPos]->IsConnected()) {
             if (FAILED(hr = m_Indexer.AddSubstreamIndex(nSubstreamPos,
                                                         (ULONG)(llMulDiv(m_ulDelayWindow,
                                                                          10000000,
                                                                          m_pInputPins[nSubstreamPos]->m_rtIndexGranularity,
                                                                          0))))) {
                DbgLog((LOG_ERROR,1,"failed to create substream index"));
                // clean up
                for (int j = 0; j < nSubstreamPos; j++)
                   if (m_pInputPins[j] && m_pInputPins[j]->IsConnected())
                      m_Indexer.DeleteSubstreamIndex(j);
                return hr;
             }
          }
       }
    }
    if (FAILED(hr = CBaseFilter::Pause())) {
       DbgLog((LOG_ERROR,1,"CBaseFilter::Pause() failed"));
       for (int nSubstreamPos = 0; nSubstreamPos < MAX_SUBSTREAMS; nSubstreamPos++)
          if (m_pInputPins[nSubstreamPos] && m_pInputPins[nSubstreamPos]->IsConnected())
             m_Indexer.DeleteSubstreamIndex(nSubstreamPos);
       return hr;
    }
    return NOERROR;
}

HRESULT CDelayFilter::Stop(void)
{
    CAutoLock l(m_pLock);
    DbgLog((LOG_TRACE,2,"Stop"));
    HRESULT hr;

    m_IO.Abort(); // force all readers to exit/unblock

    for (int nStreamerPos = 0; nStreamerPos < MAX_STREAMERS; nStreamerPos++)
       if (m_pStreamers[nStreamerPos] && IsStreamerConnected(nStreamerPos))
          m_pStreamers[nStreamerPos]->Shutdown();

    for (int nSubstreamPos = 0; nSubstreamPos < MAX_SUBSTREAMS; nSubstreamPos++)
       if (m_pInputPins[nSubstreamPos] && m_pInputPins[nSubstreamPos]->IsConnected())
          m_Indexer.DeleteSubstreamIndex(nSubstreamPos);

    m_IO.Shutdown();

    return CBaseFilter::Stop();
}

HRESULT CDelayFilter::GetMediaType(int nSubstreamPos, AM_MEDIA_TYPE *pmt) {
   return m_pInputPins[nSubstreamPos]->ConnectionMediaType(pmt);
}

CDelayInputPin *CDelayInputPin::CreatePin(TCHAR *pObjectName,
                                          CBaseFilter *pFilter,
                                          HRESULT *phr,
                                          LPCWSTR pName, // unused
                                          int nSubstream) {
    WCHAR wcName[8] = L"in";
    // append the substream index to the name of the pin
    if ((nSubstream < 10000) && (nSubstream >= 0))
       wsprintfW(wcName + wcslen(wcName), L"%d", nSubstream);
    return new CDelayInputPin(pObjectName,
                              pFilter,
                              phr,
                              wcName,
                              nSubstream);
}


HRESULT CDelayFilter::NonDelegatingQueryInterface(REFIID riid, void ** ppv) {
   if (riid == IID_IDelayFilter) {
       return GetInterface((IDelayFilter *) this, ppv);
   }
   else if (riid == IID_IDelayFilterInternal) {
       return GetInterface((IDelayFilterInternal *) this, ppv);
   } else if (riid == IID_ISpecifyPropertyPages) {
       return GetInterface((ISpecifyPropertyPages *) this, ppv);
   } else {
       return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
   }
}

STDMETHODIMP CDelayFilter::GetPages(CAUUID * pPages) {

    CAutoLock l(m_pLock);

    pPages->cElems = 3;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID) * pPages->cElems);
    
    if (pPages->pElems == NULL)
        return E_OUTOFMEMORY;
     
    pPages->pElems[0] = CLSID_DelayFilterProperties;
    pPages->pElems[1] = CLSID_FirstStreamerProperties;
    pPages->pElems[2] = CLSID_SecondStreamerProperties;

#if 0
    for (int i = 0; i < m_nStreamers; i++) {
       REFGUID rguid = CLSID_DelayStreamerProperties;
       rguid.data1 += i; // not a perfectly legal trick
       pPages->pElems[pPages->cElems++] = rguid;
    }
#endif

    return NOERROR;

}

// IDelayFilter methods
HRESULT CDelayFilter::SetDelayWindowParams(LPCSTR pszFilePath,
                                           ULONGLONG ullSize,
                                           ULONG ulSeconds) {
   m_ulDelayWindow = ulSeconds;
   m_ullFileSize = ullSize;
   strcpy (m_szFileName, pszFilePath);
   return NOERROR;
}

STDMETHODIMP CDelayFilter::GetDelayWindowParams(LPSTR pszFilePath,
                                  ULONGLONG *pullSize,
                                  ULONG *pulSeconds) {
   *pulSeconds = m_ulDelayWindow;
   *pullSize = m_ullFileSize;
   strcpy(pszFilePath, m_szFileName);
   return NOERROR;
}

HRESULT CDelayFilter::GetStreamerCount(int *nCount) {
   if ((m_nStreamers < 0) || (m_nStreamers >= MAX_STREAMERS))
      return E_FAIL;
   *nCount = m_nStreamers;
   return NOERROR;
}

HRESULT CDelayFilter::GetStreamer(int nStreamer, IDelayStreamer **ppStreamer) {
   CStreamer *pStreamer;
   pStreamer = m_pStreamers[GetNthStreamerPos(nStreamer)];
   if (pStreamer == NULL)
      return E_INVALIDARG;
   return pStreamer->QueryInterface(IID_IDelayStreamer, (void**)ppStreamer);
}

void CDelayFilter::NotifyWindowOffsets(ULONGLONG ullHeadOffset, ULONGLONG ullTailOffset)
{
    // Send the notifications to the streamer
    for (int i = 0; i < MAX_STREAMERS; i++)
    {
       if (m_pStreamers[i])
       {
          DbgLog((LOG_TRACE,3,TEXT("CStreamer[%d].TailTrackerNotify() : Head = %s   Tail = %s"), 
                  i, 
                  (LPCTSTR) CDisp(ullHeadOffset, CDISP_DEC), 
                  (LPCTSTR) CDisp(ullTailOffset, CDISP_DEC)));
          m_pStreamers[i]->TailTrackerNotify(ullHeadOffset,ullTailOffset);
      }
    }
}


CDelayInputPin::CDelayInputPin(
    TCHAR *pObjectName,
    CBaseFilter *pFilter,
    HRESULT *phr,
    LPCWSTR pName,
    int nSubstreamPos
) :
CBaseInputPin (
   pObjectName,
   pFilter,
   &m_csLock,
   phr,
   pName
)
{
    DbgLog((LOG_TRACE,2,"input pin constructor"));
    m_nSubstreamPos = nSubstreamPos;
}

CDelayInputPin::~CDelayInputPin()
{
    DbgLog((LOG_TRACE,2,"input pin destructor"));
}

HRESULT CDelayInputPin::CheckMediaType(const CMediaType *pmt) 
{
   DbgLog((LOG_TRACE,2,"input CheckMediaType"));
   return NOERROR;
}

HRESULT CDelayInputPin::GetMediaType(
    int iPosition,
    CMediaType *pMediaType
)
{
    return VFW_S_NO_MORE_ITEMS;
}

HRESULT CDelayInputPin::Active()
{
    DbgLog((LOG_TRACE,5,"input Active"));
    HRESULT hr;
    CAutoLock l(m_pLock);

    m_rtLastIndexEntry = 0x8000000000000000; // negative infinity
    m_ulSamplesReceived = 0;
    m_ulIndexEntriesGenerated = 0;
    m_ulSyncPointsSeen = 0;

    hr = CBaseInputPin::Active();
    if (FAILED(hr))
        return hr;
    return NOERROR;
}

HRESULT CDelayInputPin::Inactive()
{
    DbgLog((LOG_TRACE,5,"input Inactive"));
    HRESULT hr;
    hr = CBaseInputPin::Inactive();
    if (FAILED(hr))
        return hr;
    return NOERROR;
}

HRESULT CDelayInputPin::CompleteConnect(IPin *pReceivePin) {
   DbgLog((LOG_TRACE,5,"input CompleteConnect"));
   HRESULT hr;
   IAnalyzerOutputPin *pAnalyzer;

   // Initialize everything to default values in case the analyzer won't talk to us
   m_bNeedSyncPoint = FALSE;
   m_bSyncPointFlagIsOfficial = FALSE;
   m_rtSyncPointGranularity = -1;
   m_rtIndexGranularity = 5000000; // 0.5 sec.  bugbug - how do we make this configurable ?
   m_ulMaxBitsPerSecond = 0x7FFFFFFF;
   m_ulMinBitsPerSecond = 0;

   // Query the analyzer for various information
   if (SUCCEEDED(pReceivePin->QueryInterface(IID_IAnalyzerOutputPin, (void**)(&pAnalyzer)))) {
      if (SUCCEEDED(pAnalyzer->HasSyncPoints(&m_bNeedSyncPoint, &m_rtSyncPointGranularity)))
         m_bSyncPointFlagIsOfficial = TRUE;
      else {
         m_bNeedSyncPoint = FALSE;
         m_rtSyncPointGranularity = -1;
      }

      if (FAILED(pAnalyzer->GetBitRates(&m_ulMinBitsPerSecond, &m_ulMaxBitsPerSecond))) {
         m_ulMinBitsPerSecond = 0;
         m_ulMaxBitsPerSecond = 0x7FFFFFFF;
      }

      pAnalyzer->Release();
   }

   hr = CBaseInputPin::CompleteConnect(pReceivePin);
   if (FAILED(hr)) {
      DbgLog((LOG_ERROR,1,"CBaseInputPin::CompleteConnect() failed"));
      return hr;
   }
   
   DbgLog((LOG_TRACE,2,"input CompleteConnect() OK"));
   if (Filter()->AreAllInputPinsConnected())
      Filter()->AddSubstream();
   return NOERROR;
}

HRESULT CDelayInputPin::BreakConnect() {
    CAutoLock l(m_pLock);
    DbgLog((LOG_TRACE,5,"input BreakConnect"));

    return CBaseInputPin::BreakConnect();
}

HRESULT CDelayInputPin::EndOfStream(void)
{
    CAutoLock l(&(Filter()->m_csFilter));
    DbgLog((LOG_TRACE,2,"input EndOfStream"));
    HRESULT hr;
    hr = CheckStreaming();
    if (FAILED(hr))
        return hr;

    return NOERROR;
}

STDMETHODIMP CDelayInputPin::GetAllocatorRequirements(
    ALLOCATOR_PROPERTIES *pProps
)
{
    DbgLog((LOG_TRACE,5,"GetAllocatorRequirements"));
    pProps->cBuffers = 1; // let others override
    pProps->cbBuffer = 0; // no requirements
    pProps->cbAlign = 1; // no requirements
    pProps->cbPrefix = 0; // no prefix
    return NOERROR;
}

HRESULT CDelayInputPin::NotifyAllocator(IMemAllocator *pAllocator,
                                                        BOOL bReadOnly) {
   DbgLog((LOG_TRACE,5,"NotifyAllocator"));
   HRESULT hr;
   ALLOCATOR_PROPERTIES props, actual;
   
   hr = CBaseInputPin::NotifyAllocator(pAllocator, bReadOnly);
   if (FAILED(hr))
       return hr;
   hr = pAllocator->GetProperties(&props);
   if (FAILED(hr))
      return VFW_E_NO_ALLOCATOR;
   
   hr = pAllocator->SetProperties(&props, &actual);
   if (FAILED(hr))
      return VFW_E_NO_ALLOCATOR;

   DbgLog((LOG_TRACE,2,"substream %d input pin: %d %d-byte buffers",m_nSubstreamPos,actual.cBuffers,actual.cbBuffer));
   
   return NOERROR;
}

HRESULT CDelayInputPin::Receive(IMediaSample * pSample)
{
    HRESULT hr; // no function should be without one
    BYTE *pData;
    ULONG ulRecordSize, ulPayloadSize, ulTrailerSize, ulPrefixSize, ulHeaderSize;
    REFERENCE_TIME rtStart, rtStop;
    BOOL bSyncPoint;
    ULONGLONG ullOffset; // the logical buffer offset that the data got written to
    ULONGLONG ullHead, ullTail;
    BYTE Header[64];
    BYTE Trailer[64];
    //CAutoLock l(&(Filter()->m_csFilter)); // mainly for serializing writes

    hr = CheckStreaming();
    if (FAILED(hr))
        return hr;

    ulPayloadSize = pSample->GetActualDataLength();
    if (FAILED(hr = pSample->GetPointer(&pData)))
        return hr;
    if (FAILED(hr = pSample->GetTime(&rtStart, &rtStop)))
       return hr;
    bSyncPoint = (pSample->IsSyncPoint() == S_OK);

    m_ulSamplesReceived++;
    
    //
    // The following 20-30 lines are our "muxer"
    //

    ulTrailerSize = 4;
    // Build the header.
    // Right now the prefix consists of
    //    8 byte REFERENCE_TIME
    //    4 bytes of flags, where bit 0 is syncpoint
    //    8 byte file offset to the previous video sync point frame
    //
    ulPrefixSize = 20; 
    ulHeaderSize = 20 + ulPrefixSize;
    ASSERT(ulHeaderSize <= 64);
    ulRecordSize = ulPayloadSize + ulHeaderSize + ulTrailerSize;
    *((ULONG*)(Header +  0)) = ulRecordSize;
    *((ULONG*)(Header +  4)) = m_nSubstreamPos; // stream ID
    *((ULONG*)(Header +  8)) = ulHeaderSize; // payload offset
    *((ULONG*)(Header + 12)) = ulPayloadSize;
    *((ULONG*)(Header + 16)) = ulPrefixSize; // prefix size;
    *((REFERENCE_TIME*)(Header + 20)) = rtStart;
    *((ULONG*)(Header + 28)) = 0;
    if (bSyncPoint)
       *((ULONG*)(Header + 28)) |= 1;
    *((ULONGLONG*)(Header + 32)) = Filter()->m_ullLastVideoSyncPoint;
    DbgLog((LOG_TRACE,6,"w %08X%08X", DWORD(Filter()->m_ullLastVideoSyncPoint >> 32), DWORD(Filter()->m_ullLastVideoSyncPoint)));

    // Build the trailer - just the size for now
    *((ULONG*)(Trailer + 0)) = ulRecordSize;
    
    // send the record
    Filter()->m_csWriter.Lock(); // keep the three writes together
    Filter()->m_IO.Write(Header, ulHeaderSize, &ullOffset, NULL, NULL);
    Filter()->m_IO.Write(pData, ulPayloadSize, NULL, NULL, NULL);
    Filter()->m_IO.Write(Trailer, ulTrailerSize, NULL, &ullHead, &ullTail);
    Filter()->m_csWriter.Unlock();
    
    DbgLog((LOG_TRACE,4,"substream %d muxed %d-byte sample at 0x%08X, timestamp 0x%08X%08X", m_nSubstreamPos, ulPayloadSize, DWORD(ullOffset), DWORD(rtStart >> 32), DWORD(rtStart)));

    Filter()->m_pTracker->SetWindowOffsets(-1, ullHead, ullTail, TRUE);
 
    // Invalidate index entries for anything we have overwritten
    Filter()->m_Indexer.InvalidateIndexEntries(-1, ullHead, TRUE);

    //
    // indexing logic
    //
    if (bSyncPoint) {
       m_ulSyncPointsSeen++;
       if (m_nSubstreamPos == 0) // bugbug - this is a BAD way to identify the video stream
          Filter()->m_ullLastVideoSyncPoint = ullOffset;
    }
    if ((m_bSyncPointFlagIsOfficial == FALSE) && (m_bNeedSyncPoint == FALSE) && bSyncPoint) {
       // We thought there were no sync points, but now we know that there are.
	    // Throw away any index entries we have generated, since we were generating
	    // them because we thought there were no sync points.
       Filter()->m_Indexer.PurgeSubstreamIndex(m_nSubstreamPos);
	    m_bNeedSyncPoint = TRUE; // now we do know
       DbgLog((LOG_TRACE,1,"found out that substream %d has sync points after %d samples and %d index entries", m_nSubstreamPos, m_ulSamplesReceived, m_ulIndexEntriesGenerated));
       m_ulIndexEntriesGenerated = 0;
    }
    if ((m_bNeedSyncPoint == FALSE) || bSyncPoint) {
       // consider generating an index entry for this sample
       DbgLog((LOG_TRACE,5,"sample eligible for index entry"));
       if (rtStart >= m_rtLastIndexEntry + m_rtIndexGranularity) { // generate an index entry
          m_ulIndexEntriesGenerated++;
          DbgLog((LOG_TRACE,3,"substream %d: index entry %d at sample %d, syncpoint %d", m_nSubstreamPos, m_ulIndexEntriesGenerated, m_ulSamplesReceived, m_ulSyncPointsSeen));
          Filter()->m_Indexer.AddIndexEntry(m_nSubstreamPos, ullOffset, rtStart);
          m_rtLastIndexEntry = rtStart;
       }
    }

    return NOERROR;
} /* InputPin::Receive() */


CDelayOutputPin *CDelayOutputPin::CreatePin(TCHAR *pObjectName,
                                           CBaseFilter *pFilter,
                                           HRESULT *phr,
                                           LPCWSTR pName, // unused
                                           int nStreamerPos, int nSubstreamPos) {
   WCHAR wcName[32] = L"";
   wsprintfW(wcName + wcslen(wcName), L"out%d-in%d", nStreamerPos, nSubstreamPos);
   return new CDelayOutputPin(pObjectName,
                              pFilter,
                              phr,
                              wcName,
                              nStreamerPos,nSubstreamPos);
}



CDelayOutputPin::CDelayOutputPin(TCHAR *pObjectName,
                                 CBaseFilter *pFilter,
                                 HRESULT *phr,
                                 LPCWSTR pName,
                                 int nStreamerPos, int nSubstreamPos) :
CBaseOutputPin (pObjectName,
                pFilter,
                &m_csLock,
                phr,
                pName)
{
    DbgLog((LOG_TRACE,2,"outpin pin constructor"));
    m_nStreamerPos = nStreamerPos;
    m_nSubstreamPos = nSubstreamPos;
    m_pOutputQueue = NULL;
    m_pKsPropSet = NULL;
    m_pDownstreamFilter = NULL;
}

CDelayOutputPin::~CDelayOutputPin()
{
    DbgLog((LOG_TRACE,2,"outpin pin destructor"));
    if (m_pOutputQueue) {
       DbgLog((LOG_TRACE,1,"the output queue was not freed by disconnect"));
       delete m_pOutputQueue;
    }
    if (m_pKsPropSet) {
       DbgLog((LOG_TRACE,1,"m_pKsPropSet was not freed by disconnect"));
       m_pKsPropSet->Release();
    }
    if (m_pDownstreamFilter) {
       DbgLog((LOG_TRACE,1,"downstream filter was not freed by disconnect"));
       m_pDownstreamFilter->Release();
    }
}


HRESULT CDelayOutputPin::CompleteConnect(IPin *pReceivePin)
{
    HRESULT hr;
    DbgLog((LOG_TRACE,5,"Output CompleteConnect"));
    hr = CBaseOutputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr))
        return hr;

    DbgLog((LOG_TRACE,2,"Output CompleteConnect OK"));
    if (Filter()->AreAllStreamersConnected())
       Filter()->AddStreamer();

    // see if they support DVD style rate stuff
    if (FAILED(hr = pReceivePin->QueryInterface(IID_IKsPropertySet, (void**)&m_pKsPropSet))) {
       DbgLog((LOG_ERROR,1,"streamer %d substream %d: downstream pin does not support IKsPropertySet", m_nStreamerPos, m_nSubstreamPos));
       m_pKsPropSet = NULL;
    }
    else {
       DWORD cbReturned;
       if (FAILED(hr = m_pKsPropSet->Get(AM_KSPROPSETID_TSRateChange,
                                         AM_RATE_MaxFullDataRate,
                                         NULL,
                                         0,
                                         (BYTE *)&m_lMaxFullDataRate, 
                                         sizeof(m_lMaxFullDataRate), 
                                         &cbReturned))) {
          DbgLog((LOG_TRACE,2,"streamer %d substream %d: decoder won't admit its limitations", m_nStreamerPos, m_nSubstreamPos));
          m_lMaxFullDataRate = 10000; // assume 1x
       } else {
          if (m_lMaxFullDataRate < 10000)
             DbgLog((LOG_TRACE,1,"decoder returned a weird MaxFullDataRate = %d",m_lMaxFullDataRate));
          else
             DbgLog((LOG_TRACE,2,"streamer %d substream %d: decoder is rate capable, maximum rate is %d", m_nStreamerPos, m_nSubstreamPos, m_lMaxFullDataRate));
       }
   
       DWORD dwTypeSupport;
       if ((FAILED(hr = m_pKsPropSet->QuerySupported(AM_KSPROPSETID_TSRateChange,
                                                    AM_RATE_SimpleRateChange,
                                                    &dwTypeSupport))) || 
           (!(dwTypeSupport & KSPROPERTY_SUPPORT_GET))) {
          if ((FAILED(hr = m_pKsPropSet->QuerySupported(AM_KSPROPSETID_TSRateChange,
                                                       AM_RATE_ExactRateChange,
                                                       &dwTypeSupport))) || 
              (!(dwTypeSupport & KSPROPERTY_SUPPORT_GET))) {
             DbgLog((LOG_ERROR,1,"streamer %d substream %d: downstream pin does not support either AM_RATE_SimpleRateChange or AM_RATE_ExactRateChange", m_nStreamerPos, m_nSubstreamPos));
             m_pKsPropSet->Release();
             m_pKsPropSet = NULL;
          }
          else {
             DbgLog((LOG_TRACE,2,"streamer %d substream %d: downstream pin supports KS_AM_ExactRateChange, but not AM_RATE_SimpleRateChange", m_nStreamerPos, m_nSubstreamPos));
             m_bUseExactRateChange = TRUE;
          }
       }
       else {
          m_bUseExactRateChange = FALSE;
       }
    }
    
    // Now get the downstream filter's interface so that we can pause/unpause it
    PIN_INFO PinInfo;
    if ((FAILED(hr = pReceivePin->QueryPinInfo(&PinInfo))) || (PinInfo.pFilter == NULL)) {
       DbgLog((LOG_ERROR,1,"streamer %d substream %d: downstream pin's QueryPinInfo() is not working", m_nStreamerPos, m_nSubstreamPos));
       m_pDownstreamFilter = NULL;
    }
    else
       m_pDownstreamFilter = PinInfo.pFilter;

    if (Filter()->m_bUseOutputQueues) {
       //
       // Query allocator properties
       //
       if (!m_pAllocator) { // ???
          hr = VFW_E_NO_ALLOCATOR;
          goto outputcompleteconnectfail;
       }
   
       int cBuffers;
       ALLOCATOR_PROPERTIES props;
       if (FAILED(hr = m_pAllocator->GetProperties(&props))) { // strange but not fatal
          DbgLog((LOG_TRACE,1,"GetProperties() failed on output allocator"));
          cBuffers = 64; // reasonable default ?
       }
       else
          cBuffers = props.cBuffers;
   
       //
       // Create an output queue
       //
   
       if (m_pOutputQueue)
          DbgLog((LOG_TRACE,1,"CompleteConnect: why is m_pOutputQueue not NULL ?"));
   
       m_pOutputQueue = new COutputQueue(pReceivePin,
                                         &hr,
                                         TRUE, // bAuto based on ReceiveCanBlock
                                         TRUE, // create thread (auto)
                                         1, // batch size - no batching
                                         FALSE, // batch exact
                                         cBuffers,
                                         THREAD_PRIORITY_NORMAL);
       if (!m_pOutputQueue) {
          hr = E_OUTOFMEMORY;
          goto outputcompleteconnectfail;
       }
       if (FAILED(hr))
          goto outputcompleteconnectfail;
    }

    return NOERROR;

outputcompleteconnectfail:
    if (m_pKsPropSet) {
       m_pKsPropSet->Release();
       m_pKsPropSet = NULL;
    }
    if (m_pDownstreamFilter) {
       m_pDownstreamFilter->Release();
       m_pDownstreamFilter = NULL;
    }
    if (m_pOutputQueue) {
       delete m_pOutputQueue;
       m_pOutputQueue = NULL;
    }
    return hr;
}

HRESULT CDelayOutputPin::DeliverAndReleaseSample(IMediaSample *pSample) {
   if (Filter()->m_bUseOutputQueues)
      return m_pOutputQueue->Receive(pSample);
   else {
      HRESULT hr = CBaseOutputPin::Deliver(pSample);
      pSample->Release();
      return hr;
   }
}

HRESULT CDelayOutputPin::Disconnect(void) {
   DbgLog((LOG_TRACE,2,"OutputPin Disconnect"));
   if (m_pKsPropSet) {
      m_pKsPropSet->Release();
      m_pKsPropSet = NULL;
   }
   if (m_pDownstreamFilter) {
      m_pDownstreamFilter->Release();
      m_pDownstreamFilter = NULL;
   }
   if (m_pOutputQueue) {
      delete m_pOutputQueue;
      m_pOutputQueue = NULL;
   }
   return CBaseOutputPin::Disconnect();
}

HRESULT CDelayOutputPin::BreakConnect(void)
{
    DbgLog((LOG_TRACE,5,"Output BreakConnect"));
    return CBaseOutputPin::BreakConnect();
}

HRESULT CDelayOutputPin::Active(void)
{
    DbgLog((LOG_TRACE,5,"Output Active"));
    HRESULT hr;

    hr = CBaseOutputPin::Active();
    if (FAILED(hr))
        return hr;

    return NOERROR;
}

HRESULT CDelayOutputPin::Inactive(void)
{
    DbgLog((LOG_TRACE,5,"Output Inactive"));
    HRESULT hr;
    CAutoLock l(m_pLock);
    hr = CBaseOutputPin::Inactive();
    if (FAILED(hr))
        return hr;
    return NOERROR;
}

HRESULT CDelayOutputPin::CheckMediaType(const CMediaType *pmt) 
{
    AM_MEDIA_TYPE mt;
    if (SUCCEEDED(Filter()->GetMediaType(m_nSubstreamPos, &mt)))
       if ((mt.majortype == *(pmt->Type())) &&
           (mt.subtype   == *(pmt->Subtype())) /* &&
           ((pmt->bFixedSizeSamples) || (m_nSubstreamPos == 1))*/) {
          DbgLog((LOG_TRACE,2,"Output CheckMediaType OK"));
          return NOERROR;
       }
    DbgLog((LOG_ERROR,1,"Output CheckMediaType not OK"));
    return E_FAIL;
}

HRESULT CDelayOutputPin::DecideBufferSize(
    IMemAllocator *pAlloc,
    ALLOCATOR_PROPERTIES *ppropInputRequest
)
{
    DbgLog((LOG_TRACE,2,"DecideBufferSize() for streamer %d substream %d:", m_nStreamerPos, m_nSubstreamPos));
    DbgLog((LOG_TRACE,2,"\tother pin proposed %d %d-byte buffers", ppropInputRequest->cBuffers, ppropInputRequest->cbBuffer));
    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr;
     
    if (ppropInputRequest->cbBuffer == 0)
       ppropInputRequest->cbBuffer = 65536;
    if (ppropInputRequest->cBuffers == 0)
       ppropInputRequest->cBuffers = 1;

    // find out the buffer size from the input allocator
    IMemAllocator* pInputAllocator = NULL;
    ALLOCATOR_PROPERTIES propInputPinAllocatorProps;

    if ((m_nSubstreamPos < 0) ||
        (m_nSubstreamPos >= MAX_STREAMERS) ||
        (!(Filter()))||
        (!(Filter()->m_pInputPins[m_nSubstreamPos]))) {
       DbgLog((LOG_ERROR,1,"DecideBufferSize(): missing substream input pin"));
       return E_FAIL;
    } 
    if ((FAILED(Filter()->m_pInputPins[m_nSubstreamPos]->GetAllocator(&pInputAllocator))) ||
        (!pInputAllocator)) {
       DbgLog((LOG_ERROR,1,"DecideBufferSize(): substream input pin has no allocator"));
       return E_FAIL;
    }
    hr = pInputAllocator->GetProperties(&propInputPinAllocatorProps);
    pInputAllocator->Release();
    if ((FAILED(hr)) ||
        (propInputPinAllocatorProps.cbBuffer == 0)) {
       DbgLog((LOG_ERROR,1,"DecideBufferSize(): input allocator is not cooperating"));
       return E_FAIL;
    }

    // use what we got from the input pin for buffer size and 24 for sample count
    ppropInputRequest->cbBuffer = propInputPinAllocatorProps.cbBuffer;
    ppropInputRequest->cBuffers = 24; // maybe a little large
    DbgLog((LOG_TRACE,2,"\trequesting %d %d-byte buffers", ppropInputRequest->cBuffers, ppropInputRequest->cbBuffer));

    hr = pAlloc->SetProperties(ppropInputRequest, &Actual);
    if (SUCCEEDED(hr))
    {
        if ((Actual.cbBuffer == 0) || (Actual.cBuffers == 0))
            return E_FAIL;
        else {
           DbgLog((LOG_TRACE,2,"\tagreed on %d %d-byte buffers", Actual.cBuffers, Actual.cbBuffer));
           return NOERROR;
        }
    }
    else              
        return hr;
}


HRESULT CDelayOutputPin::GetMediaType(
    int iPosition,
    CMediaType *pMediaType
)
{
   if (iPosition == 0)
      if (SUCCEEDED(Filter()->GetMediaType(m_nSubstreamPos, pMediaType)))
         return NOERROR;
   return VFW_S_NO_MORE_ITEMS;
}

HRESULT CDelayOutputPin::NonDelegatingQueryInterface(REFIID riid, void ** ppv) {
   if (riid == IID_IChannelStreamPinEnum) {
       return GetInterface((IChannelStreamPinEnum *) this, ppv);
   } else {
       return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
   }
}

// IChannelStreamPinEnum methods
HRESULT CDelayOutputPin::ChannelStreamGetPinCount(int *nCount) {
   *nCount = Filter()->m_nSubstreams;
   return NOERROR;
}

HRESULT CDelayOutputPin::ChannelStreamGetPin(int n, IPin **ppPin) {
   if (Filter()->m_pStreamers[m_nStreamerPos] == NULL)
      return E_FAIL;
   else
      return Filter()->m_pStreamers[m_nStreamerPos]->ChannelStreamGetPin(n, ppPin);
}

HRESULT CDelayOutputPin::ChannelStreamGetID(int *nID) {
   *nID = m_nStreamerPos;
   return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\delay\delay.h ===
#ifndef __DELAY_H__
#define __DELAY_H__

#include "common.h"
#include "io.h"
#include "indexer.h"
#include "timeshift.h"
#include "internal.h"

//
// Terminology:
//
// A streamer is a set of output pins that all go to the same destination.
// The output pins in a streamer all operate at the same rate, get paused and
// stoped at the same time, etc.  There will probably be a single thread for
// each streamer that reads data from the disk, demuxes it, and sends it down
// to the next filter or puts it in an output queue.
//
// A substream is a data stream of one media type, e.g., audio, video, VBI, etc.
// There is a substream for each connected input pin, and that substream logically
// consists of the input pin itself as well as one output pin within each streamer
// that corresponding to that input pin.  I.e., a substream consists of one input
// pin and nStreamers output pins.
//
// There are two kinds of streamers: timeshifting streamers and archiving streamers.
// It is not yet clear whether or not we will have code specific to each kind, but
// timeshifting streamers will probably have to be treated a little differently for
// a couple of reasons.  First, the timeshifting streamer talks to a renderer or
// decoder filter, whereas an archiver streamer tals to ASF stream writers.  Second,
// we my eventually try to somehow give timeshifting streamers higher priority for
// disk IO, since they will be driving realtime decoders.  We may run into other
// differences later.  We may still be able to have the same code execute for both
// kinds of streamers, however.
//
// We will collect substream specific info in the input pin objects and streamer
// specific info in CStreamer objects.  CStreamer objects will expose the IDelayStreamer
// interface to let the app control each streamer individually.
//
// Pin naming scheme: input pins are names "in#", where # (0 <= n < nSubstreams) is the
// index of the substream that the input pin belongs to.  E.g., the first substream's
// input pin is names "in0".  Output pins are names "out#-in#", where the first # is
// the index of the streamer that the output pin is a part of, and the second # is the
// substream index.  E.g., if there were three substreams, the second streamer's pins
// would be named "out1-in0", "out1-in1", and "out1-in2".
//
// Pin enumeration: there is one input pin for each substream for a total of
// nSubstreams input pins.  There are nStreamers * nSubstreams output pins.  So there
// are a total of (nStreamers + 1) * nSubstreams pins.  The way GetPin(n) maps n to pins
// is as follows: the first nSubstreams pins are input pins, the rest are output pins.
// Among the output pins, those that belong to the same streamer are near each other.
// So if we had three substreams and two streamers, the pin enumeration order would be
// "in0", "in1", "in2", "out0-in0", "out0-in1", "out0-in2", "out1-in0", "out1-in1",
// and finally "out1-in2."
//
// All streamer/substream creation/deletion and corresponding pin creation/deletion is
// done by the filter object.  Pointers to all input pins are kept in an arrays.
// Pointers to the streamers are kept in another array.  Pointers to the output pins
// are kept in a two dimensional array whose one direction is parallel to the streamer
// array, and the other is parallel to the input pin array.  Bugbug - phrase this in a
// more comprehensible manner.
//

#define STREAMID_PADDING 0xFFFFFFFE

typedef enum {
   Streaming,
   Stopped,
   Paused,
   Archiving,
   Uninitialized
} STREAMER_STATE;

class CDelayFilter;

class CStreamer : public IDelayStreamer, public IChannelStreamPinEnum, public IDelayStreamerInternal {
public:
   CStreamer(CDelayFilter *pFilter, int nStreamerPos);
   
   // IUnknown stuff
   STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
   STDMETHODIMP_(ULONG) AddRef();
   STDMETHODIMP_(ULONG) Release();
   
   // IDelayStreamer methods
   STDMETHODIMP Pause();
   STDMETHODIMP Play();
   STDMETHODIMP Stop();
   STDMETHODIMP SetRate(double dRate);
   STDMETHODIMP Seek(SEEK_POSITION SeekPos, REFERENCE_TIME llTime);
   STDMETHODIMP GetPositions(REFERENCE_TIME *pStartTime,
                             REFERENCE_TIME *pEndTime,
                             REFERENCE_TIME *pCurrentTime);
   STDMETHODIMP StartArchive(REFERENCE_TIME llArchiveStartTime,
                             REFERENCE_TIME llArchiveEndTime);
   STDMETHODIMP GetMarker(GUID *pMarkerGUID,
                          REFERENCE_TIME *pMarkerPresentationTime,
                          ULONG *pIndex);

   // IDelayStreamerInternal methods
   STDMETHODIMP IsConnected();
   STDMETHODIMP GetState(int *pState, double *pdRate);
   STDMETHODIMP SetState(int State, double dRate, int *pNewStatem, double *pdNewRate);

   // IChannelStreamPinEnum methods
   STDMETHODIMP ChannelStreamGetPinCount(int *nCount);
   STDMETHODIMP ChannelStreamGetPin(int n, IPin **ppPin);
   STDMETHODIMP ChannelStreamGetID(int *nID);

private:
   CDelayFilter *m_pFilter;
   int m_nStreamerPos;

   //
   // streamer worker thread stuff - should this be a separate class ?
   //
public:   
   HRESULT Init(CDelayIOLayer *pIO); // create streaming thread, etc.
   HRESULT Shutdown(); // kill the streaming thread, etc.
   void TailTrackerNotify(ULONGLONG ullHead, ULONGLONG ullTail);

private:
   HANDLE m_hThread;
   HANDLE m_hEvent;
   BOOL m_bDone; // signal thread to exit
   static DWORD WINAPI InitialThreadProc(void*);
   virtual DWORD ThreadProc();
   void StreamingStep(void);
   HRESULT ReadAndDeliverBlock(ULONGLONG ullFilePos, ULONG *ulBlockSize, ULONGLONG *pBackPointer);
   DWORD AllowedOperations();
   void NotifyState();
   HRESULT ComputeNewFileOffset(REFERENCE_TIME rtSeekPos, ULONGLONG *ullNewFileOffset);
   HRESULT SetRateInternal(double dRate);
   CDelayFilter* Filter() {return m_pFilter;}
   HRESULT CStreamer::CheckKsPropSetSupport();
   HRESULT CheckDownstreamFilters();
   HRESULT CStreamer::PauseInternal();
   HRESULT CStreamer::PlayInternal();
   void Flush(void);

   CDelayIOLayer *m_pIO;
   CCritSec m_csStreamerState; // Used to protect state variables.  Thou shalt not block inside this.
   STREAMER_STATE m_State;
   REFERENCE_TIME m_rtDelay;
   double m_dSpeed, m_dNewSpeed;
   ULONGLONG m_ullFilePos;
   BOOL m_bSeekPending;
   SEEK_POSITION m_SeekType;
   REFERENCE_TIME m_rtSeekPos;
   REFERENCE_TIME m_rtMostRecentSampleSent;
   REFERENCE_TIME m_rtDropAllSamplesBefore;
   BOOL m_bDiscontinuityFlags[MAX_SUBSTREAMS];
   BOOL m_bError[MAX_SUBSTREAMS];
   ULONGLONG m_ullFileTail;
   ULONGLONG m_ullFileHead;
};

//
// Output pin class
//
class CDelayOutputPin :
   public CBaseOutputPin,
   public IChannelStreamPinEnum
{
public:
   HRESULT CheckMediaType(const CMediaType *pmt);
   static CDelayOutputPin *CreatePin(TCHAR *pObjectName,
                                     CBaseFilter *pFilter,
                                     HRESULT *phr,
                                     LPCWSTR pName,
                                     int nStreamerPos, int nSubstreamPos);
   CDelayOutputPin(TCHAR *pObjectName,
                        CBaseFilter *pFilter,
                        HRESULT *phr,
                        LPCWSTR pName,
                        int nStreamerPos, int nSubstreamPos);
   ~CDelayOutputPin();
   HRESULT DecideBufferSize(IMemAllocator *pAlloc,
                            ALLOCATOR_PROPERTIES *ppropInputRequest);
   HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
   CDelayFilter* Filter(void) {return (CDelayFilter*)m_pFilter;};
   HRESULT Active(void);
   HRESULT Inactive(void);
   HRESULT CompleteConnect(IPin*);
   HRESULT BreakConnect(void);
   STDMETHODIMP Disconnect(void);
   STDMETHODIMP DeliverAndReleaseSample(IMediaSample *pSample);
   
   // IChannelStreamPinEnum methods
   STDMETHODIMP ChannelStreamGetPinCount(int *nCount);
   STDMETHODIMP ChannelStreamGetPin(int n, IPin **ppPin);
   STDMETHODIMP ChannelStreamGetID(int *nID);

   // interface stuff
   DECLARE_IUNKNOWN;
   STDMETHODIMP NonDelegatingQueryInterface( REFIID riid, void ** ppv );
   
   IKsPropertySet* m_pKsPropSet;
   LONG m_lMaxFullDataRate;
   BOOL m_bUseExactRateChange;

   IBaseFilter* m_pDownstreamFilter;

private:
   int m_nSubstreamPos;
   int m_nStreamerPos;
   CCritSec m_csLock;
   COutputQueue* m_pOutputQueue;
};

//
// Archiving pin class - do we need one ?
//
// class CDelayArchivingPin; 


//
// Input pin class
//
class CDelayInputPin :
   public CBaseInputPin
{
public:
   HRESULT CheckMediaType(const CMediaType *pmt);
   HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
   static CDelayInputPin *CreatePin(TCHAR *pObjectName,
                                    CBaseFilter *pFilter,
                                    HRESULT *phr,
                                    LPCWSTR pName,
                                    int nSubstreamPos);
   CDelayInputPin(TCHAR *pObjectName,
                  CBaseFilter *pFilter,
                  HRESULT *phr,
                  LPCWSTR pName,
                  int nSubstreamPos);
   ~CDelayInputPin();
   STDMETHODIMP Receive(IMediaSample *pSample);
   STDMETHODIMP ReceiveCanBlock() {return /*S_FALSE*/S_OK;};
   HRESULT Active(void);
   HRESULT Inactive(void);
   HRESULT CompleteConnect(IPin*);
   HRESULT BreakConnect(void);
   STDMETHODIMP EndOfStream(void);
   STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps);
   STDMETHODIMP NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly);
   // base implementation works for us STDMETHODIMP Disconnect();
   //STDMETHODIMP GetAllocator(IMemAllocator *ppAllocator);
   CDelayFilter* Filter(void) {return (CDelayFilter*)m_pFilter;};
   
   // interface stuff
   //DECLARE_IUNKNOWN;
   //STDMETHODIMP NonDelegatingQueryInterface( REFIID riid, void ** ppv );

   REFERENCE_TIME m_rtIndexGranularity;

   // debug
   ULONG m_ulIndexEntriesGenerated;
   ULONG m_ulSamplesReceived;
   ULONG m_ulSyncPointsSeen;
private:   
   int m_nSubstreamPos;
   CCritSec m_csLock;

   // various info we get from the analyzer
   REFERENCE_TIME m_rtLastIndexEntry;
   REFERENCE_TIME m_rtSyncPointGranularity;
   BOOL m_bNeedSyncPoint; // is the concept of sync points defined for this stream ?
   BOOL m_bSyncPointFlagIsOfficial; // did we get the above value from the analyzer ?
   ULONG m_ulMaxBitsPerSecond;
   ULONG m_ulMinBitsPerSecond;
};

//
// Filter class   
//
class CDelayFilter :
   public CBaseFilter,
   public IDelayFilter,
   public ISpecifyPropertyPages,
   public IDelayFilterInternal
{
public:
   static CUnknown* CALLBACK CreateInstance(LPUNKNOWN, HRESULT*);
   CDelayFilter(LPUNKNOWN, HRESULT*);
   ~CDelayFilter();
   int GetPinCount(void);
   class CBasePin* GetPin(int);
   STDMETHODIMP Pause(void); // hook transitions from stop to pause
   STDMETHODIMP Stop(void); // hook transitions to stop
   CCritSec m_csFilter; // main filter cs
   
   int GetNthSubstreamPos(int nSubstream);
   int GetNthStreamerPos(int nStreamer);
   HRESULT AddSubstream();
   HRESULT AddStreamer();
   HRESULT RemoveSubstream(int nSubstreamPos);
   HRESULT RemoveStreamer(int nStreamerPos);
   BOOL AreAllInputPinsConnected();
   BOOL AreAllStreamersConnected();
   BOOL IsStreamerConnected(int nStreamerPos);

   int m_nSubstreams;
   int m_nStreamers;
   CStreamer *m_pStreamers[MAX_STREAMERS];
   CDelayOutputPin *m_pOutputPins[MAX_STREAMERS][MAX_SUBSTREAMS];
   CDelayInputPin *m_pInputPins[MAX_SUBSTREAMS];

   // Registry/property page configuration parameters
   ULONG m_ulDelayWindow; // in seconds
   ULONGLONG m_ullFileSize;
   char m_szFileName[1024];
   BYTE m_bBufferWrites;
   BOOL m_ulWriteBufferSize;
   BYTE m_bBlockWriter;
   BYTE m_bUseOutputQueues;

   void ReadRegistry();
   void WriteRegistry();

   ULONGLONG m_ullLastVideoSyncPoint;

   CCritSec m_csWriter; // keep wrtes from interleaving randomly
   CDelayIOLayer m_IO;
   CIndexer m_Indexer;
   CCircBufWindowTracker *m_pTracker;

   HRESULT GetMediaType(int nSubstreamPos, AM_MEDIA_TYPE *pmt);
   void NotifyWindowOffsets(ULONGLONG ullHeadOffset, ULONGLONG ullTailOffset);
   void NotifyTail(ULONGLONG ullTail);

   // interface stuff
   DECLARE_IUNKNOWN;
   STDMETHODIMP NonDelegatingQueryInterface( REFIID riid, void ** ppv );

   // IDelayFilter methods
	STDMETHODIMP SetDelayWindowParams(LPCSTR pszFilePath,
                                     ULONGLONG ullSize,
                                     ULONG ulSeconds);
   STDMETHODIMP GetStreamerCount(int *nCount);
   STDMETHODIMP GetStreamer(int n, IDelayStreamer **ppStreamer);
   
   // return our property pages
   STDMETHODIMP GetPages(CAUUID * pPages);

   // IDelayFilterInternal
   STDMETHODIMP GetDelayWindowParams(LPSTR pszFilePath,
                                     ULONGLONG *pullSize,
                                     ULONG *pulSeconds);
};

class CDelayFilterProperties : public CBasePropertyPage {
public:
   CDelayFilterProperties(LPUNKNOWN lpUnk, HRESULT *phr);
   static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

   HRESULT OnConnect(IUnknown *pUnknown);
   HRESULT OnDisconnect();
   HRESULT OnActivate();
   HRESULT OnDeactivate();
   HRESULT OnApplyChanges();
   BOOL OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
private:
   void UpdateFields();
   IDelayFilter *m_pFilter;
   ULONGLONG m_ullFileSize;
   ULONG m_ulWindowSize;
   TCHAR m_szFileName[80];
};

class CDelayStreamerProperties : public CBasePropertyPage {
public:
   CDelayStreamerProperties(LPUNKNOWN lpUnk, HRESULT *phr, int nStreamer);

   HRESULT OnConnect(IUnknown *pUnknown);
   HRESULT OnDisconnect();
   HRESULT OnActivate();
   HRESULT OnDeactivate();
   HRESULT OnApplyChanges();
   BOOL OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);

private:   
   void UpdateFields();
   IDelayStreamerInternal *m_pStreamer;
   int m_nStreamer;
   double m_dRate;
   STREAMER_STATE m_State;
   
};

CUnknown * WINAPI CreateFirstStreamerPropPage(LPUNKNOWN lpunk, HRESULT *phr);
CUnknown * WINAPI CreateSecondStreamerPropPage(LPUNKNOWN lpunk, HRESULT *phr);


#endif // __DELAY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\delay\indexer.h ===
#ifndef __INDEXER_H_
#define __INDEXER_H_

#include "common.h"

#define OPTIMIZED_SEARCH

//
//	Stuff for index management
//

// forward declarations.
class CSubstreamIndex;
class CIndexer;
class CIndexMapper;
class CCircBufWindowTracker;
class CDelayFilter;

//////////////////////////////////////////////////////////////////
//
//	class CCircBufWindowTracker definition.
//
//  This classs will keep track of the tail of the official timeshift
//  window which is the intersection of what is available in the
//  circular file and the indices.
//
//  This object takes a pointer to the delay filter and calls
//  NotifyBufferWindow() on the delay filter which can then
//  propogate it down to the streamers. By doing this, the object
//  does not need to keep track of streamers which the delay filter
//  does anyways.
//
//////////////////////////////////////////////////////////////////
typedef struct _tagHeadTailInfo
{
    BOOL m_bInUse;
    ULONGLONG ullHeadOffset;
    ULONGLONG ullTailOffset;
} HeadTailInfo;

class CCircBufWindowTracker
{
public:
    CCircBufWindowTracker(CDelayFilter *pDelayFilter);
    ~CCircBufWindowTracker();

    // Notification of a new head/tail either from the
    // circular buffer or the indexer. This also calls
    // the NotifyBufferWindow() on the delay filter after
    // it updates the head and tail of the buffer window.
    // bWriterNotifcation indicates that the notification is
    // from the writer and the substreamid is ignored in this case.
    void SetWindowOffsets(ULONG ulSubstreamId, ULONGLONG ullHeadOffset, ULONGLONG ullTailOffset, BOOL bWriterNotification = FALSE);
    void RegisterTracking(ULONG ulSubstreamId);
    void UnregisterTracking(ULONG ulSubstreamId);

protected:
    CDelayFilter *m_pDelayFilter;
    // We maintain a HeadTailInfo array for the max number
    // of substreams. The substreamid will be the index into
    // this array for head/tail info for a particular substream.
    HeadTailInfo m_SubstreamInfoArray[MAX_SUBSTREAMS];
    // Writer head/tail info is maintained separately.
    HeadTailInfo m_WriterInfo;
    CCritSec  m_cs;
private:
    void CalculateIntersection(ULONGLONG *ullHead, ULONGLONG *ullTail);
};



//////////////////////////////////////////////////////////////////
//
//	class CIndexMapper definition.
//
//  The indexer object will have an array of CIndexMapper objects
//  using which it can get to the stream index object for any given
//  stream.
//
//////////////////////////////////////////////////////////////////
class CIndexMapper
{
public:
	CIndexMapper();
	~ CIndexMapper() {;}

public:
	ULONG m_ulSubstreamId;
	CSubstreamIndex *m_pSubstreamIndex;
};

class CIndexEntry
{
public:
	CIndexEntry() {m_ullFileOffset=INVALID_OFFSET; m_llPresTime=INVALID_PTS;}
	~CIndexEntry() {;}
	ULONGLONG m_ullFileOffset;
	REFERENCE_TIME m_llPresTime;
	ULONGLONG GetOffset() { return m_ullFileOffset ;}
	REFERENCE_TIME GetPTS() { return m_llPresTime ;}
};

class CSubstreamIndex
{
// Methods
public:
	CSubstreamIndex(ULONG ulSubsreamId, ULONG ulNumEntries, CCircBufWindowTracker *pTracker, HRESULT *phr);
	~CSubstreamIndex();

	HRESULT AddIndexEntry(ULONGLONG ullFileOffset, REFERENCE_TIME llPresTime);
	HRESULT InvalidateEntries(ULONGLONG ullOverwriteBlockEndOffset);
	HRESULT GetOffsets(	REFERENCE_TIME llPresTime, 
						ULONGLONG &ullOffsetLT_EQ,
						REFERENCE_TIME &llPtsLT_EQ,
						ULONGLONG &ullOffsetGT,
						REFERENCE_TIME &llPtsGT);
	HRESULT InvalidateAllEntries();
    void GetMinMaxOffsets(ULONGLONG *pHead, ULONGLONG *pTail);

    HRESULT FindNextSyncPoint(int nStreamer,
                              ULONGLONG ullOffset,
                              ULONGLONG *pSyncPtOffset);

#ifdef DEBUG
    void Dump();
#endif

protected:
private:
	HRESULT		AllocateIndexArray(ULONG ulNumEntries);
	void		InvalidateEntry(CIndexEntry *pEntry);
    void        UpdateMinMaxOffsets();
	BOOL		IsEmpty();

// Attributes
public:
protected:
    ULONG           m_ulSubstreamId;
	CIndexEntry *	m_pIndexArray;
	ULONGLONG		m_ullMinFileOffset;
	ULONGLONG		m_ullMaxFileOffset;
	ULONG			m_ulHead;
	ULONG			m_ulTail;
	ULONG			m_ulNumEntries;
	// we will lock the critsec for all updates and reads to make
	// sure that data is not read while being updated.
	CCritSec		m_csIndex;
    CCircBufWindowTracker *m_pTracker;

private:
#ifdef OPTIMIZED_SEARCH
   // see FindNextSyncPoint()
   ULONG m_ulStreamerPos[MAX_STREAMERS];
#endif
};

class CIndexer
{
// Methods
public:
	CIndexer();
	~CIndexer();

    void InitTracker(CCircBufWindowTracker *pTracker) {m_pTracker = pTracker;}

	// Add a new substream index
	HRESULT AddSubstreamIndex(ULONG SubstreamId, ULONG ulNumEntries);
	// Delete the specified substream index
	HRESULT DeleteSubstreamIndex(ULONG SubstreamId);
	// Purge all existing entries for a substream
	HRESULT PurgeSubstreamIndex(ULONG SubstreamId);

    // Invalidate index entries for the block being overwritten.
    HRESULT InvalidateIndexEntries( ULONG ulSubstreamId, 
                                    ULONGLONG ullOverwriteBlockEndOffset, 
                                    BOOL fInvalidateAllSubstreams = FALSE);

	// Add a new index entry for a substream.
	HRESULT AddIndexEntry(	ULONG ulSubstreamId,
							ULONGLONG ullNewFileOffset,
							REFERENCE_TIME llPresTime);
	

/*
	// Given a presentation time in REFERENCE_TIME units, get the
	// lowest offset of all sub streams to start reading data for
	// a given presentation time.
	HRESULT ChannelStreamGetOffset(	REFERENCE_TIME llPresTime,
									ULONGLONG &ullFileOffset);
*/

	// Get the sub stream file offsets window closest to a given presentation time
	// ullFileOffset1 & llPresTime1 are the file offset and PTS of the closest index 
	// entry whose PTS is less than or equal to llPresTime. ullFileOffset2 & llPresTime2 
	// are the file offset and presentation time for the closest index entry whose PTS is greater
	// than llPresTime. If llPresTime == llPresTime1, then ullFileOffset2 & llPresTime2 will
	// be set to 0xffffffffffffffff
	HRESULT ChannelSubstreamGetOffsets(	ULONG ulSubstreamId,
										REFERENCE_TIME llPresTime,
										ULONGLONG &ullOffsetLT_EQ,
										REFERENCE_TIME &llPtsLT_EQ,
										ULONGLONG &ullOffsetGT,
										REFERENCE_TIME &llPtsGT);

    HRESULT FindNextSyncPoint(  int nStreamer,
                                ULONG ulSubstreamId,
                                ULONGLONG ullOffset,
                                ULONGLONG *pSyncPtOffset);
                                

#ifdef DEBUG
    void DumpIndex(ULONG ulID);
#endif

protected:

/*
	HRESULT InvalidateIndexEntries(ULONGLONG ullFileStartOffset, ULONGLONG ullFileEndOffset);
*/

	HRESULT GetSubstreamIndex(ULONG ulSubstreamId, CSubstreamIndex **ppSubstreamIndex);

private:


//Attributes
public:
protected:
	CIndexMapper m_IndexMap[MAX_SUBSTREAMS];
	ULONG m_ulNumStreams;
    CCircBufWindowTracker *m_pTracker;

private:
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\delay\resource.h ===
#define IDD_DELAYFILTERPROP 101
#define IDD_DELAYSTREAMERPROP 102

#define IDS_DELAYFILTERPROPNAME 201
#define IDS_DELAYSTREAMERPROPNAME 202

#define IDC_FILENAMETEXT 301
#define IDC_FILESIZETEXT 302
#define IDC_RATE         303
#define IDC_STATE        304
#define IDC_STOPPED      305
#define IDC_STREAMING    306
#define IDC_PAUSED       307
#define IDC_ARCHIVING    308
#define IDC_WINDOWSIZETEXT 309

#define IDC_STR_FILENAME 401
#define IDC_STR_FILESIZE 402
#define IDC_STR_RATE     403
#define IDC_STR_WINDOWSIZE 404
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\delay\io.cpp ===
//
// Delay filter's "IO layer" - named so for historical reasons.  Since the
// the reader/writer synchronization stuff has been rolled into this, it
// should really be called the "IO/synchronization layer" or something like
// that.
//

#include <windows.h>
#include <streams.h>
#include "indexer.h"
#include "io.h"

//
// IO layer sublayers (upside down to look more like a runtime stack):
//
//                        Writer side stack          Reader side stack
//                        -----------------          -------------------
//                        // runtime/filesystem IO stuff
//                        WriteFile()                ReadFile()
//  circularity layer     // converts always-increasing offset to physical offset
//                        UnbufferedWrite()          UnbufferedRead()
//  buffering layer       // batches up writes       // reads from write buffer or from disk
//                        BufferedWrite()            BufferedRead()
//  sync/blocking layer   // unblocks reader         // blocks reader
//                        Write()                    Read()
//                        // The rest of the delay filter
//
//
// The synchronization stuff is described reasonably well in our patent disclosure
// docs (see the "delay\doc\" subdirectory, especially the Visio flowcharts.
//
// All layers except the circularity layer work with logical (non-wraparound)
// file offsets, i.e., offsets that just keep increasing even as the real file
// offset wraps around.  The cirrularity layer (implemented by UnbufferedRead
// and UnbufferedWrite) simply translates logical delay filter offsets into real
// file offsets that the file system will understand.
//
// Note that for better or worse, writer buffering is currently done above the
// circularity layer and thus operates on logical file offsets.
//
// See io.h and the rest of this file for additional comments.
//

BOOL MyCloseHandle(HANDLE *hHandle) {
   BOOL bRet = 0;
   if ((!*hHandle) || (*hHandle == INVALID_HANDLE_VALUE))
      DbgLog((LOG_ERROR,1,"attempt to close an invalid handle"));
   else if (!(bRet = CloseHandle(*hHandle)))
      DbgLog((LOG_ERROR,1,"CloseHandle() failed"));
   *hHandle = NULL;
   return bRet;
}

CDelayIOLayer::CDelayIOLayer() {
   m_pbWriterBuffer = NULL;
   m_bDone = TRUE;
   m_hWriterFileHandle = INVALID_HANDLE_VALUE;
   m_hAbortEvent = NULL;
   m_hWriterUnblockEvent = NULL;
   for (int i = 0; i < MAX_STREAMERS; i++)
      m_Readers[i].m_bInUse = FALSE;
}

CDelayIOLayer::~CDelayIOLayer() {
   if (m_hWriterUnblockEvent)
      MyCloseHandle(&m_hWriterUnblockEvent);
   if (m_hAbortEvent)
      MyCloseHandle(&m_hAbortEvent);
   if (m_hWriterFileHandle != INVALID_HANDLE_VALUE)
      MyCloseHandle(&m_hWriterFileHandle);
   for (int i = 0; i < MAX_STREAMERS; i++)
      if (m_Readers[i].m_bInUse) {
         MyCloseHandle(&m_Readers[i].m_hReaderFileHandle);
         MyCloseHandle(&m_Readers[i].m_hReaderUnblockEvent);
      }
}

//
// A reader calls this to register with us, so that we can allocate and event
// and a file handle for it.  As described in io.h, it is assumed that readers
// will pass us unique reader IDs (we use the words reader and streamer to
// describe the same thing, which is the CStreamer object defined in delay.h).
//
HRESULT CDelayIOLayer::ReaderConnect(int nStreamer) {
   if ((nStreamer < 0) || (nStreamer >= MAX_STREAMERS)) {
      DbgLog((LOG_ERROR,1,"bug: somebody is passing in a bad streamer id"));
      return E_INVALIDARG;
   }
   
   CAutoLock l(&m_csIO);

   if (m_bDone) {
      DbgLog((LOG_ERROR,1,"ReaderConnet() before IO layer has been initialized"));
      return E_FAIL;
   }

   if ((nStreamer >= MAX_STREAMERS) || (nStreamer < 0))
      return E_INVALIDARG;
   if (m_Readers[nStreamer].m_bInUse) {
      DbgLog((LOG_ERROR,1,"reader is already connected"));
      return VFW_E_ALREADY_CONNECTED;
   }

   m_Readers[nStreamer].m_ullReaderBlockedOn = ULLINFINITY;
   m_Readers[nStreamer].m_hReaderFileHandle = INVALID_HANDLE_VALUE;
   m_Readers[nStreamer].m_hReaderUnblockEvent = NULL;
   if (m_bBlockWriter)
      m_Readers[nStreamer].m_ullCurrentReadStart = ULLINFINITY;

/* This did not work because handles obtained this way cannot be used concurrently.
   if ((!DuplicateHandle(GetCurrentProcess(),
                         m_hWriterFileHandle,
                         GetCurrentProcess(),
                         &(m_Readers[nStreamer].m_hReaderFileHandle),
                         GENERIC_READ,
                         FALSE, // cannot inherit
                         0)) ||
       (m_Readers[nStreamer].m_hReaderFileHandle == NULL)) {
      m_Readers[nStreamer].m_hReaderFileHandle = NULL;
      DbgLog((LOG_ERROR,1,"failed to create a reader file handle"));
      goto readerconnectfail;
   }
*/
   if ((m_Readers[nStreamer].m_hReaderFileHandle = CreateFile(
          m_szFileName,
          GENERIC_READ,
          FILE_SHARE_READ | FILE_SHARE_WRITE,
          NULL,
          OPEN_EXISTING,
          FILE_FLAG_SEQUENTIAL_SCAN,
          NULL)) == INVALID_HANDLE_VALUE) {
      DbgLog((LOG_ERROR,1,"failed to open the file for reading (%08X)",GetLastError()));
      goto readerconnectfail;
   }
   if ((m_Readers[nStreamer].m_hReaderUnblockEvent = CreateEvent(NULL,FALSE,FALSE,NULL)) == NULL) {
      DbgLog((LOG_ERROR,1,"failed to create a reader unblock event"));
      goto readerconnectfail;
   }

   m_Readers[nStreamer].m_bInUse = TRUE;
   return NOERROR;

readerconnectfail:
   if (m_Readers[nStreamer].m_hReaderFileHandle != INVALID_HANDLE_VALUE)
      MyCloseHandle(&m_Readers[nStreamer].m_hReaderFileHandle);
   if (m_Readers[nStreamer].m_hReaderUnblockEvent)
      MyCloseHandle(&m_Readers[nStreamer].m_hReaderUnblockEvent);
   return E_OUTOFMEMORY;
}

//
// Readers should call this when done streaming, but I think we survive even if they don't.
//
HRESULT CDelayIOLayer::ReaderDisconnect(int nStreamer) {
   if ((nStreamer < 0) || (nStreamer >= MAX_STREAMERS)) {
      DbgLog((LOG_ERROR,1,"bug: somebody is passing in a bad streamer id"));
      return E_INVALIDARG;
   }
   
   CAutoLock l(&m_csIO);
   // This check is invalid because ReaderDisconnect() is normally called
   // in the process of stopping.
   //if (m_bDone)
   //   return E_FAIL;
   if (!m_Readers[nStreamer].m_bInUse)
      return VFW_E_NOT_CONNECTED;
   MyCloseHandle(&m_Readers[nStreamer].m_hReaderFileHandle);
   MyCloseHandle(&m_Readers[nStreamer].m_hReaderUnblockEvent);
   m_Readers[nStreamer].m_bInUse = FALSE;
   return NOERROR;
}

//
// The delay filter calls this every time it transitions from stopped to streaming.
// We use this to create a file, allocate memory and create various handles.
//
// The counterpart of this is Shutdown.
//
HRESULT CDelayIOLayer::Init(CBaseFilter *pFilter,
                            ULONGLONG ullFileSize,
                            const char *szFileName,
                            BOOL bBlockWriter,
                            BOOL bBufferWrites,
                            ULONG ulWriterBufferSize) {
   if (!m_bDone)
      DbgLog((LOG_TRACE,1,"IO layer initialized more than once (bad)"));

   m_pFilter = pFilter;
   
   m_ullTempFileSize = ullFileSize;
   strcpy(m_szFileName, szFileName);
   m_bBlockWriter  = bBlockWriter;
   m_bBufferWrites = bBufferWrites;
   m_ulWriterBufferSize = ulWriterBufferSize;

   LONG lHigh;
   
   for (int i = 0; i < MAX_STREAMERS; i++)
      m_Readers[i].m_bInUse = FALSE;

   m_bDone = FALSE;
   m_hAbortEvent = NULL;
   m_hWriterFileHandle = INVALID_HANDLE_VALUE;
   m_ullWriterBlockedOn = 0;
   m_hWriterUnblockEvent = NULL;

   // is writer blocking enabled ?
   if (m_bBlockWriter) {
      // Yes, create an event to block on
      if (!m_hWriterUnblockEvent) {
         m_hWriterUnblockEvent = CreateEvent(NULL, TRUE, FALSE, NULL); // manual reset
         if (!m_hWriterUnblockEvent) {
            DbgLog((LOG_ERROR,1,"Init(): failed to create the writer unblock event"));
            goto initfail;
         }
      }
      else {
         DbgLog((LOG_TRACE,1,"writer unblock event already exists"));
      }
   }
   
   if (!m_hAbortEvent) {
      m_hAbortEvent = CreateEvent(NULL, TRUE, FALSE, NULL); // manual reset
      if (!m_hAbortEvent) {
         DbgLog((LOG_ERROR,1,"Init(): failed to create the abort event"));
         goto initfail;
      }
   }
   else {
      DbgLog((LOG_TRACE,1,"abort event already exists"));
   }

   // is write caching enabled ?
   if (m_bBufferWrites) {
      // Yes, allocate some memory
      m_ullStartOfDirtyData = 0;
      m_ullNewDataTail = 0;
      if (!m_pbWriterBuffer) {
         if ((m_pbWriterBuffer = (BYTE*)(VirtualAlloc(NULL,
                                              m_ulWriterBufferSize,
                                              MEM_COMMIT | MEM_RESERVE,
                                              PAGE_READWRITE))) == NULL) {
            DbgLog((LOG_ERROR,1,"Init(): failed to allocate the writer buffer"));
            goto initfail;
         }
      }
      else
         DbgLog((LOG_TRACE,1,"writer buffer has already been allocated"));
   }

   if (m_hWriterFileHandle != INVALID_HANDLE_VALUE) {
      DbgLog((LOG_ERROR,1,"writer file handle already exists"));
      goto initfail; // this is an error becayse they may have specified a new name/size
   }
   if ((m_hWriterFileHandle = CreateFile(m_szFileName,
                             GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL, // no security
                             OPEN_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL | (m_bBufferWrites ? FILE_FLAG_NO_BUFFERING | FILE_FLAG_WRITE_THROUGH : FILE_FLAG_SEQUENTIAL_SCAN),
                             NULL // no template
      )) == INVALID_HANDLE_VALUE) {
      DbgLog((LOG_ERROR,1,"Init(): could not open the file"));
      goto initfail;
   }

   //
   // We used to seek to the end and call SetEndOfFile() to preallocate the disk space,
   // but had to stop doing that because NT writes zeros to the whole file when using
   // FAT, which is of course very time consuming.
   //
   lHigh = LONG(m_ullTempFileSize >> 32);
   if (
       (SetFilePointer(m_hWriterFileHandle,
                       LONG(m_ullTempFileSize & 0x00000000FFFFFFFF),
                       &lHigh,
                       FILE_BEGIN) != DWORD(m_ullTempFileSize & 0x00000000FFFFFFFF)) ||
       (lHigh != LONG(m_ullTempFileSize >> 32)) ||
       //(!SetEndOfFile(m_hWriterFileHandle)) ||
       (SetFilePointer(m_hWriterFileHandle,
                       0,
                       NULL,
                       FILE_BEGIN) != 0)
      ) {
      DbgLog((LOG_ERROR,1,"Init(): SetFilePointer() or SetEndOfFile() failed!"));
      goto initfail;
   }

   if (!ResetEvent(m_hAbortEvent))
      DbgLog((LOG_ERROR,1,"failed to reset the abort event"));
   
   m_ullDataTail = 0;
   m_ullDataHead = 0;

#ifdef REPORT_RDWRPOS
   m_ullLastReaderPos = 0;
   m_ullLastWriterPos = 0;
#endif
   
   m_ulWrites = 0;
   m_ulRealWrites = 0;
   m_ulReads = 0;
   m_ulRealReads = 0;
   
   return NOERROR;

initfail:
   if (m_hWriterUnblockEvent)
      MyCloseHandle(&m_hWriterUnblockEvent);
   if (m_hAbortEvent)
      MyCloseHandle(&m_hAbortEvent);
   if (m_hWriterFileHandle != INVALID_HANDLE_VALUE)
      MyCloseHandle(&m_hWriterFileHandle);
   if (m_pbWriterBuffer) {
      VirtualFree(m_pbWriterBuffer, 0, MEM_FREE);
      m_pbWriterBuffer = NULL;
   }
   return E_OUTOFMEMORY;
}

//
// Called by the delay filter on Stop before calling shutdown, so that we can abort
// any ohtstanding or blocked read requests.
//
HRESULT CDelayIOLayer::Abort() {
   if (m_bDone) {
      DbgLog((LOG_ERROR,1,"Abort() called either more than once or before Init()"));
      return E_FAIL;
   }
   
   m_bDone = TRUE;
  
   if (SetEvent(m_hAbortEvent))
      return NOERROR;
   else {
      DbgLog((LOG_ERROR,1,"failed to set the abort event"));
      return E_FAIL;
   }
}

//
// Undo whatever we did in Init()
//
HRESULT CDelayIOLayer::Shutdown() {
   CAutoLock l(&m_csIO);
   if (!m_bDone)
      DbgLog((LOG_TRACE,1,"Abort() was never called"));

   int nReaders = 0;
   for (int i = 0; i < MAX_STREAMERS; i++)
      if (m_Readers[i].m_bInUse) {
         nReaders++;
         MyCloseHandle(&m_Readers[i].m_hReaderUnblockEvent);
         MyCloseHandle(&m_Readers[i].m_hReaderFileHandle);
         m_Readers[i].m_bInUse = FALSE;
      }
   if (nReaders)
      DbgLog((LOG_TRACE,1,"%d readers did not disconnect before shutdown", nReaders));

   MyCloseHandle(&m_hWriterFileHandle);
   m_hWriterFileHandle = INVALID_HANDLE_VALUE;

   if (m_pbWriterBuffer) {
      VirtualFree(m_pbWriterBuffer, 0, MEM_RELEASE);
      m_pbWriterBuffer = NULL;
   }

   return NOERROR;
}

CAutoReleaseWriter::CAutoReleaseWriter(int nStreamer,
                                       HANDLE hWriterUnblockEvent,
                                       volatile ULONGLONG *pullWriterBlockedOn,
                                       PerReaderStruct *Readers,
                                       CCritSec *pcsIO,
                                       BOOL bBlockWriter) {
   m_bBlockWriter = bBlockWriter;
   if (m_bBlockWriter) {
      m_nStreamer = nStreamer;
      m_hWriterUnblockEvent = hWriterUnblockEvent;
      m_pullWriterBlockedOn = pullWriterBlockedOn;
      m_Readers = Readers;
      m_pcsIO = pcsIO;
   }
}

//
// This is just some code we want always executed on exit from CDelayIoLayer::Read().
//
CAutoReleaseWriter::~CAutoReleaseWriter() {
   if (m_bBlockWriter) { // none of this applies if writer blocking is not enabled.
      CAutoLock l(m_pcsIO);
      ULONGLONG ullWriterBlockedOn = *m_pullWriterBlockedOn; // ok to cache this now that we have the critical section
      // if the writer is blocked trying to write data beyond the point we are
      // reading from, then we know we are blocking the writer.  However, the
      // writer may also be blocked on other readers, so we must check that nobody
      // else is reading from where the writer wants to write to before we can
      // unblock the writer.  I.e., imagine he following situation: reader A starts
      // reading at 1000, then reader B starts reading at 1000, and then the writer
      // decides to write at 1200 and gets blocked.  When reader A is done, it
      // erroneously unblocks the writer even though reader B is still reading.  By
      // performing this additional check we prevent such erronous unblocking.
      if (ullWriterBlockedOn > m_Readers[m_nStreamer].m_ullCurrentReadStart) { // if we are blocking the writer
         int i;
         for (i = 0; i < MAX_STREAMERS; i++)
            if ((i != m_nStreamer) &&
                m_Readers[i].m_bInUse &&
                (m_Readers[i].m_ullCurrentReadStart < ullWriterBlockedOn))
               break; // found another reader who is also blocking the writer
         if (i == MAX_STREAMERS) { // did not find any other blockers - unblock
            if (!SetEvent(m_hWriterUnblockEvent))
               DbgLog((LOG_ERROR,1,"failed to set the writer unblock event"));
         }
         else { // somebody else is still blocking the writer, cannot unblock it yet
            DbgLog((LOG_TRACE,1,"multiple readers are blocking the writer"));
         }
      }
      m_Readers[m_nStreamer].m_ullCurrentReadStart = ULLINFINITY;
   }
}

// Send a graph event, marshalling the LONGLONG into the two LONG event parameters
void CDelayIOLayer::ReportPos(ULONGLONG ullPos, ULONGLONG *pullLast, long lEvent) {
   if ((ullPos / REPORT_GRANULARITY) != ((*pullLast) / REPORT_GRANULARITY))
      m_pFilter->NotifyEvent(lEvent, (long)((ullPos / 1024) >> 32),(long)(ullPos / 1024));
   *pullLast = ullPos;
}

//
// Reader side synchronization/blocking code.
//
HRESULT CDelayIOLayer::Read(int nStreamer, ULONGLONG ullPosition, BYTE *pBuffer, ULONG ulSize) {
   if ((nStreamer < 0) || (nStreamer >= MAX_STREAMERS)) {
      DbgLog((LOG_ERROR,1,"bug: somebody is passing in a bad streamer id"));
      return E_INVALIDARG;
   }
   
   { // lock scope
      // Our use of CAutoLock means we must be careful if we happen to
      // return with the lock already unlocked, because we could
      // accidentally get unlocked twice in that case !
      CAutoLock l(&m_csIO);
   
      if (!m_Readers[nStreamer].m_bInUse)
         return VFW_E_NOT_CONNECTED;
   
      if (m_bDone)
         return VFW_E_WRONG_STATE;
   
      //
      // Are we trying to read something that has not been written yet ?
      //
      if (ullPosition + ulSize > m_ullDataTail) {
         //
         // Yes, need to block.
         //
         m_Readers[nStreamer].m_ullReaderBlockedOn = ullPosition + ulSize;

         if (!ResetEvent(m_Readers[nStreamer].m_hReaderUnblockEvent))
            DbgLog((LOG_ERROR,1,"failed to reset a reader unblock event"));

         m_csIO.Unlock(); // to let somebody unblock us
         // CAUTION: from here to the next lock(), if we return we must
         // re-lock the CS before returning.  This is because we have
         // already unlocked it, but the auto lock will try to unlock
         // it again on return.

         HANDLE Handles[2] = {m_Readers[nStreamer].m_hReaderUnblockEvent, m_hAbortEvent};
         DWORD dwWaitResult = WaitForMultipleObjects(2,Handles,FALSE,INFINITE);

         m_csIO.Lock(); // now autolock can work normally
         // resetting of this variable is better done in the writer
         //m_Readers[nStreamer].m_ullReaderBlockedOn = ULLINFINITY;

         if (dwWaitResult == WAIT_OBJECT_0 + 1) // aborted
           return VFW_E_WRONG_STATE;
         if (dwWaitResult != WAIT_OBJECT_0) {
           DbgLog((LOG_ERROR,1,"strange return value from WaitForMultipleObjects()"));
           return E_FAIL;
         }
      }
   
      //
      // Sanity check: we just got unblocked, presumably because the data
      // we were waiting for has finally arrived.  Make sure it is really there.
      //
      if (ullPosition + ulSize > m_ullDataTail) { // still not enough data
         DbgLog((LOG_ERROR,1,"reader blocking mechanism appears to be broken"));
         return E_FAIL;
      }
   
      //
      // Check that the data we are about to read has not been overwritten
      // by something newer. 
      //
      // If writer blocking is disabled, we perform this check again
      // after the read to make sure it did not get overwritten *during*
      // the read.  In that case, this first check is not strictly
      // necessary, but it is useful anyway because why do a read
      // that we know is useless ?
      //
      if (ullPosition < m_ullDataHead)
         return E_PASTWINDOWBOUNDARY;
   
      // Indicate where we are reading from, so that if the writer
      // tries to write to the same place it will block itself (this
      // only applies if writer blocking is enabled).
      if (m_bBlockWriter)
         m_Readers[nStreamer].m_ullCurrentReadStart = ullPosition;
   } // lock scope

   // When this variable goes out of scope, CAutoReleaseWriter will
   // (1) reset the variable to infinity to indicate that this reader
   // is no longer reading, and (2) unblock the writer if it is
   // blocked and ready to be unblocked.
   CAutoReleaseWriter a(nStreamer,
                        m_hWriterUnblockEvent,
                        &m_ullWriterBlockedOn,
                        m_Readers,
                        &m_csIO,
                        m_bBlockWriter);

   #ifdef REPORT_RDWRPOS
   ReportPos(ullPosition, &m_ullLastAbsRdPos, EC_ABSRDPOS);
   #endif

   #ifdef REPORT_RDWRPOS
   ReportPos(ullPosition % m_ullTempFileSize, &m_ullLastReaderPos, EC_READERPOS);
   #endif
   
   //
   // Do the read, bypassing the buffering layer if writer bufferind is disabled.
   //
   HRESULT hr;
   if (m_bBufferWrites)
      hr = BufferedRead(pBuffer, ulSize, ullPosition, nStreamer);
   else
      hr = UnbufferedRead(pBuffer, ulSize, ullPosition, nStreamer);
   if (FAILED(hr))
      return hr;

   // Check that the data did not get overwritten while we were reading -
   // could happen if we don't block the writer
   if (!m_bBlockWriter) {
      CAutoLock l(&m_csIO);
      if (ullPosition < m_ullDataHead) {
         DbgLog((LOG_TRACE,1,"data got overwritten while we were reading it"));
         return E_PASTWINDOWBOUNDARY;
      }
   } // !m_bBlockWriter

   return NOERROR;
}

//
// BufferedRead():
//
// Check if the read falls within the cache window trailing the writer, and if so get the
// data out of there.  Otherwise call UnbufferedRead to perform a filesystem read.
//
// This function treats the underlying file as non-circular, the circularity abstraction
// is implemented by lower layers.  I.e., this function treats all file offsets as always
// increasing (aka linear aka logical...).
//
// Our cache is a circular buffer aligned on its own size relative to non-circular file
// offsets.  E.g.., if the size of our cache were 16MB, then the first byte of the cache
// would initially map to the first byte of the file, then 16MB into the file, 32MB into
// the file, 48MB into the file, and so on.
//
// Since this function treats the file as linear (file offsets don't wrap around), cache
// wraparounds happen independently of circular file wraparounds.  They will be synchronized
// if the size of our circular file happens to be an integer multiple of the cache size, but
// no effort is made to enforce such synchronization.
//
HRESULT CDelayIOLayer::BufferedRead(BYTE *pBuffer, ULONG ulSize, ULONGLONG ullPosition, int nStreamer) {
   ULONGLONG ullCacheStart;
   m_ulReads++;
   m_csIO.Lock();
   ullCacheStart = (m_ullNewDataTail > m_ulWriterBufferSize) ? m_ullNewDataTail - m_ulWriterBufferSize : 0;
   m_csIO.Unlock();
   if (ullPosition >= ullCacheStart) { // cache hit ?
      // Yes, try to get the data from the cache
      if (ullPosition / m_ulWriterBufferSize != (ullPosition + ulSize) / m_ulWriterBufferSize) {
         // Tache wraparound, need to split the memcpy.
         memcpy(pBuffer + 0,
                m_pbWriterBuffer + ullPosition % m_ulWriterBufferSize,
                m_ulWriterBufferSize - ULONG(ullPosition % m_ulWriterBufferSize));
         memcpy(pBuffer + m_ulWriterBufferSize - ullPosition % m_ulWriterBufferSize,
                m_pbWriterBuffer + 0,
                ULONG((ullPosition + ulSize) % m_ulWriterBufferSize));
      }
      else // no wraparound, a single memcpy is fine
         memcpy(pBuffer, m_pbWriterBuffer + ullPosition % m_ulWriterBufferSize, ulSize);

      // now that we've got the data, see if some of it was invalidated while we were copying
      m_csIO.Lock();
      ullCacheStart = (m_ullNewDataTail > m_ulWriterBufferSize) ? m_ullNewDataTail - m_ulWriterBufferSize : 0;
      m_csIO.Unlock();
      if (ullPosition >= ullCacheStart) // still valid ?
         return NOERROR;
      // else fall through and perform a filesystem read after all
   }
   m_ulRealReads++;
   return UnbufferedRead(pBuffer, ulSize, ullPosition, nStreamer);
}

//
// Translate logical (aka always increasing aka linear) file offset into a physical
// (aka wrap-around aka circular) offset and perform the read.  If the requested portion
// wraps around, two reads are required.
//
// Unbuffered just means that we don't do our own buffering, the file system still may.
// In fact, unlike in UnbufferedWrite(), here we _rely_ on filesystem buffering, becase
// we don't always try to batch up our reads or align them on any boundary.  We assume
// that the reader file handle was created with buffering enabled.
//
HRESULT CDelayIOLayer::UnbufferedRead(BYTE *pBuffer, ULONG ulSize, ULONGLONG ullPosition, int nStreamer) {
   ullPosition %= m_ullTempFileSize;
   LONG lHigh = LONG(ullPosition >> 32);
   ULONG ulBytesRead;
   if ((SetFilePointer(m_Readers[nStreamer].m_hReaderFileHandle,
                      LONG(ullPosition & 0x00000000FFFFFFFF),
                      &lHigh,
                      FILE_BEGIN) != DWORD(ullPosition & 0x00000000FFFFFFFF)) ||
       (lHigh != LONG(ullPosition >> 32))) {
      DbgLog((LOG_ERROR,1,"Read(): SetFilePointer() failed!"));
      return E_UNEXPECTED;
   }
   if (ullPosition + ulSize > m_ullTempFileSize) {
      //
      // Requested data wraps around the end, need to do 2 reads
      //
      if ((ReadFile(m_Readers[nStreamer].m_hReaderFileHandle,
                   pBuffer,
                   DWORD(m_ullTempFileSize - ullPosition),
                   &ulBytesRead,
                   NULL
                  ) == 0) || (ulBytesRead != ULONG(m_ullTempFileSize - ullPosition))) {
         DbgLog((LOG_ERROR,1,"ReadFile() part 1 failed !"));
         return E_UNEXPECTED;
      }
      if (SetFilePointer(m_Readers[nStreamer].m_hReaderFileHandle,
                         0,
                         NULL,
                         FILE_BEGIN) != 0) {
         DbgLog((LOG_ERROR,1,"SetFilePointer() in the middle of a split read failed!"));
         return E_UNEXPECTED;
      }
      if ((ReadFile(m_Readers[nStreamer].m_hReaderFileHandle,
                   pBuffer + m_ullTempFileSize - ullPosition,
                   DWORD(ULONGLONG(ulSize) + ullPosition - m_ullTempFileSize),
                   &ulBytesRead,
                   NULL
                  ) == 0) || (ulBytesRead != ULONG(ULONGLONG(ulSize) + ullPosition - m_ullTempFileSize))) {
         DbgLog((LOG_ERROR,1,"ReadFile() part 2 failed !"));
         return E_UNEXPECTED;
      }
   }
   else {
      //
      // One read
      //
      if ((ReadFile(m_Readers[nStreamer].m_hReaderFileHandle,
                   pBuffer,
                   ulSize,
                   &ulBytesRead,
                   NULL
                  ) == 0) || (ulBytesRead != ulSize)) {
         DbgLog((LOG_ERROR,1,"ReadFile() failed !"));
         return E_UNEXPECTED;
      }
   }
   return NOERROR;
}

//
// Implements the writer side of reader/writer synchronization and calls lower layers
// to read the data, possibly from our own cache.  Reader/writer synchronization in
// this function means unblocking blocked readers after the write, and optionally
// blocking the writer (this thread) if the write is to a region currently being read
// from.
//
// The write position is implicit (all data is written sequentially, so we always write
// to the location indicated by m_ullDataTail).
//
HRESULT CDelayIOLayer::Write(BYTE *pBuffer, ULONG ulSize, ULONGLONG *pullOffset, ULONGLONG *pullHead, ULONGLONG *pullTail) {
   CAutoLock l(&m_csSerializeWrites);
   { // lock scope
      // We use auto lock to prevent problems with forgetting to unlock
      // before an unexpected return.  This means we must be careful if
      // we happen to return with the lock already unlocked.
      CAutoLock l(&m_csIO);
   
      if (m_bDone)
         return VFW_E_WRONG_STATE;
   
      // Report back the location that the data was be written to
      if (pullOffset)
         *pullOffset = m_ullDataTail;

      // Bump the data tail before we even start writing.  This is to prevent
      // readers from reading the data we are about to write (unless they are
      // already reading it).  If we did not do this here, two bad things could
      // happen.  First, while the writer is blocked here additional readers
      // could start reading the data we are about to write, thus unnecessarily
      // delaying the writer.  Worse yet, if the writer did not invalidate the
      // section to be written until after being unblocked, we could have another
      // race with a reader after being unblocked, in which case we would have to
      // block again and again.  So instead we fail all readers who want to read
      // from where we are about to write, even if we have to block before we can
      // really start writing.
      if (m_ullDataTail + ulSize > m_ullTempFileSize) // has 1st wrap around occurred ?
         m_ullDataHead = m_ullDataTail + ulSize - m_ullTempFileSize; // else leave at 0

      // Report back the new head value
      if (pullHead)
         *pullHead = m_ullDataHead;
   
      //
      // Is writer blocking enabled ?
      //
      if (m_bBlockWriter) {
         //
         // Y., check if any reader is reading from where we are about to write,
         // and if so block ourselves until that's done.
         //
         int i;
         for (i = 0; i < MAX_STREAMERS; i++)
            if (m_Readers[i].m_bInUse && (m_Readers[i].m_ullCurrentReadStart < m_ullDataHead))
               break; // found a reader who is reading from where we want to write
         if (i != MAX_STREAMERS) {
            //
            // found a reader, need to block
            //
            DbgLog((LOG_TRACE,1,"blocking the writer - we were supposed to avoid this"));
            m_ullWriterBlockedOn = m_ullDataHead; // indicate we are blocked
            if (!ResetEvent(m_hWriterUnblockEvent))
               DbgLog((LOG_ERROR,1,"failed to reset the writer unblock event"));
            m_csIO.Unlock(); // to let somebody unblock us
            HANDLE Handles[2] = {m_hWriterUnblockEvent, m_hAbortEvent};
            DWORD dwWaitResult = WaitForMultipleObjects(2,Handles,FALSE,INFINITE);
            m_csIO.Lock(); // now autolock can work normally
            m_ullWriterBlockedOn = 0; // no longer blocked
            if (dwWaitResult == WAIT_OBJECT_0 + 1) // aborted
              return VFW_E_WRONG_STATE;
            if (dwWaitResult != WAIT_OBJECT_0) {
              DbgLog((LOG_ERROR,1,"strange return value from WaitForMultipleObjects()"));
              return E_FAIL;
            }
         }
      
         //
         // sanity check: look for a blocking reader again
         //
         for (i = 0; i < MAX_STREAMERS; i++)
            if (m_Readers[i].m_bInUse && (m_Readers[i].m_ullCurrentReadStart < m_ullDataHead))
               break; // found a reader who is reading from where we want to write
         if (i != MAX_STREAMERS) { // section still busy
            DbgLog((LOG_ERROR,1,"writer blocking mechanism appears to be broken"));
            return E_FAIL;
         }
      } // writer blocking
      
      if (m_bBufferWrites) // invalidate the ulSize bytes following m_ullDataTail
         m_ullNewDataTail = m_ullDataTail + ulSize;
   } // lock scope


   #ifdef REPORT_RDWRPOS
   ReportPos(m_ullDataHead, &m_ullLastAbsHeadPos, EC_ABSHEADPOS);
   ReportPos(m_ullDataTail, &m_ullLastAbsWrPos, EC_ABSWRPOS);
   #endif

   #ifdef REPORT_RDWRPOS
   ReportPos(m_ullDataTail % m_ullTempFileSize, &m_ullLastWriterPos, EC_WRITERPOS);
   #endif

   //
   // Do the write, bypassing the buffering layer if writer buffering is not enabled
   //
   HRESULT hr;
   if (m_bBufferWrites)
      hr = BufferedWrite(pBuffer, ulSize);
   else
      hr = UnbufferedWrite(pBuffer, ulSize, m_ullDataTail);
   if (FAILED(hr))
      return hr;

   //
   // advance the window tail and unblock any readers who are blocked on us
   //
   m_csIO.Lock();
   for (int i = 0; i < MAX_STREAMERS; i++)
      if (m_Readers[i].m_bInUse)
         if (m_Readers[i].m_ullReaderBlockedOn <= m_ullDataTail + ulSize) {
            if (m_Readers[i].m_ullReaderBlockedOn <= m_ullDataTail) // how on earth did this happen ?
               DbgLog((LOG_TRACE,1,"reader should have been unblocked by the previous write"));
            if (!SetEvent(m_Readers[i].m_hReaderUnblockEvent))
               DbgLog((LOG_ERROR,1,"failed to set the reader unblock event"));
            m_Readers[i].m_ullReaderBlockedOn = ULLINFINITY;
         }
   m_ullDataTail += ulSize;
   m_csIO.Unlock();

   // report back the tail position
   if (pullTail)
      *pullTail = m_ullDataTail;

   #ifdef REPORT_RDWRPOS
   ReportPos(m_ullDataTail, &m_ullLastAbsTailPos, EC_ABSTAILPOS);
   #endif

   return NOERROR;
}

//
// Store the data in our own writer cache and flush a portion of the cache
// if it is time to do so.
//
// The write position is implicit (m_ullDataTail).
//
// See BufferedRead() for comments on cache circularity vs file circularity.
//
HRESULT CDelayIOLayer::BufferedWrite(BYTE *pBuffer, ULONG ulSize) {
   //
   // convert the always-increasing linear file offset into a circular buffer offset
   //
   ULONG ulBufferOffset = ULONG(m_ullDataTail % m_ulWriterBufferSize);
   if (ulBufferOffset + ulSize > m_ulWriterBufferSize) {
      // wraparound, need 2 copies
      memcpy(m_pbWriterBuffer + ulBufferOffset,
             pBuffer + 0,
             m_ulWriterBufferSize - ulBufferOffset);
      memcpy(m_pbWriterBuffer + 0,
             pBuffer + (m_ulWriterBufferSize - ulBufferOffset),
             ulBufferOffset + ulSize - m_ulWriterBufferSize);
   }
   else {
      // 1 copy
      memcpy(m_pbWriterBuffer + ulBufferOffset, pBuffer, ulSize);
   }

   m_ulWrites++;

   //
   // how full is the buffer ?
   //
   if (m_ullNewDataTail - m_ullStartOfDirtyData > m_ulWriterBufferSize * FLUSH_THRESHOLD_NUMERATOR / FLUSH_THRESHOLD_DENOMINATOR) {
      //
      // full enough - flush
      //
      m_ulRealWrites++;

      DbgLog((LOG_TRACE,2,"Writes/flushes: %u/%u; cached/real reads: %u/%u", m_ulWrites, m_ulRealWrites, m_ulReads, m_ulRealReads));

      //
      // compute flush region in terms of always-increasing file offsets
      //
      ASSERT(m_ullStartOfDirtyData % UNBUFFERED_IO_GRANULARITY == 0);
      ULONGLONG ullFlushEnd = (m_ullNewDataTail / UNBUFFERED_IO_GRANULARITY) * UNBUFFERED_IO_GRANULARITY;

      HRESULT hr;
      
      //
      // write out the data in the flush region
      //
      if (m_ullStartOfDirtyData / m_ulWriterBufferSize != ullFlushEnd / m_ulWriterBufferSize) {
         // wraparound - need 2 writes
         if (FAILED(hr = UnbufferedWrite(m_pbWriterBuffer + (m_ullStartOfDirtyData % m_ulWriterBufferSize),
                                         m_ulWriterBufferSize - ULONG(m_ullStartOfDirtyData % m_ulWriterBufferSize),
                                         m_ullStartOfDirtyData))) {
            DbgLog((LOG_ERROR,1,"first unbuffered write failed"));
            return hr;
         }
         if (FAILED(hr = UnbufferedWrite(m_pbWriterBuffer + 0,
                                         ULONG(ullFlushEnd % m_ulWriterBufferSize),
                                         (ullFlushEnd / m_ulWriterBufferSize) * m_ulWriterBufferSize))) {
            DbgLog((LOG_ERROR,1,"second unbuffered write failed"));
            return hr;
         }
      }
      else { // just 1 write
         if (FAILED(hr = UnbufferedWrite(m_pbWriterBuffer + (m_ullStartOfDirtyData % m_ulWriterBufferSize),
                                         ULONG(ullFlushEnd - m_ullStartOfDirtyData),
                                         m_ullStartOfDirtyData))) {
            DbgLog((LOG_ERROR,1,"single unbuffered write failed"));
            return hr;
         }
      }
      m_ullStartOfDirtyData = ullFlushEnd;
   }
   return NOERROR;
}

//
// Converts the always-increasing ullPosition offset to a real (circular) one and performs
// the write.  "Unbuffered" means that we don't buffer anything ourselves, the underlying
// layers may still perform buffering.
//
HRESULT CDelayIOLayer::UnbufferedWrite(BYTE *pBuffer, ULONG ulSize, ULONGLONG ullPosition) {
   ullPosition %= m_ullTempFileSize;

   LONG lHigh = LONG(ullPosition >> 32);
   ULONG ulBytesWritten;
   if ((SetFilePointer(m_hWriterFileHandle,
                      LONG(ullPosition & 0x00000000FFFFFFFF),
                      &lHigh,
                      FILE_BEGIN) != DWORD(ullPosition & 0x00000000FFFFFFFF)) ||
       (lHigh != LONG(ullPosition >> 32))) {
      DbgLog((LOG_ERROR,1,"Write(): SetFilePointer() failed!"));
      return E_UNEXPECTED;
   }
   if (ullPosition + ulSize > m_ullTempFileSize) { // wraparound - need 2 writes
      if ((WriteFile(m_hWriterFileHandle,
                   pBuffer,
                   DWORD(m_ullTempFileSize - ullPosition),
                   &ulBytesWritten,
                   NULL
                  ) == 0) || (ulBytesWritten != ULONG(m_ullTempFileSize - ullPosition))) {
         DbgLog((LOG_ERROR,1,"WriteFile() part 1 failed !"));
         return E_UNEXPECTED;
      }
      if (SetFilePointer(m_hWriterFileHandle,
                         0,
                         NULL,
                         FILE_BEGIN) != 0) {
         DbgLog((LOG_ERROR,1,"SetFilePointer() in the middle of a split write failed!"));
         return E_UNEXPECTED;
      }
      if ((WriteFile(m_hWriterFileHandle,
                   pBuffer + m_ullTempFileSize - ullPosition,
                   ULONG(ULONGLONG(ulSize) + ullPosition - m_ullTempFileSize),
                   &ulBytesWritten,
                   NULL
                  ) == 0) || (ulBytesWritten != (ULONGLONG)ulSize + ullPosition - m_ullTempFileSize)) {
         DbgLog((LOG_ERROR,1,"WriteFile() part 2 failed !"));
         return E_UNEXPECTED;
      }
   }
   else { // 1 write
      if ((WriteFile(m_hWriterFileHandle,
                   pBuffer,
                   ulSize,
                   &ulBytesWritten,
                   NULL
                  ) == 0) || (ulBytesWritten != ulSize)) {
         DbgLog((LOG_ERROR,1,"WriteFile() failed !"));
         return E_UNEXPECTED;
      }
   }
   return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\delay\io.h ===
//
// Definitions for io.cpp, which is the component of the delay
// filter that handles file IO and reader/writer synchronization.
//
#ifndef __IO_H__
#define __IO_H__

//
// If REPORT_REWRPOS is defined, the delay filter periodically sends
// EC_XXXX events defined in tsevcod.h to the filter graph manager.
// Any component with access to the graph manager can hook these
// events to be updated of the reader's and writer's position in bytes.
//
// BUGBUG: although the delay filter itself supports multiple readers,
// this mechanism only works for one (there is just one set of reader
// position event codes.
//
#define REPORT_RDWRPOS
#ifdef REPORT_RDWRPOS
#include "tsevcod.h"
#define REPORT_GRANULARITY 262144 // how often graph notifications are sent, in bytes
#endif // REPORT_RDWRPOS

#include "common.h" // need to pull in the MAX_STREAMERS #define

//
// When writer buffering code calls ReadFile/WriteFile, we align our
// requests on this many bytes.  This was done in preparation for using
// unbuffered ReadFile/WriteFile.  However, we can't start using
// unbuffered ReadFile/WriteFile until we have complete reader side
// buffering implemented.  At the moment the only reader side buffering
// we do is that if the reader is close enough behind the writer to hit
// the writer's buffer, we will read from that bufffer.  Otherwise the
// reader issues a straight ReadFile().  We would need to implement some
// per-reader buffer before using unbuffered IO.
//
#define UNBUFFERED_IO_GRANULARITY 262144

// The fraction of the writer buffer that has to be dirty before we will flush/
// I.e., when these are defined to be 3 and 4, we flush as soon as the buffer is
// over 75% full.
#define FLUSH_THRESHOLD_NUMERATOR   3
#define FLUSH_THRESHOLD_DENOMINATOR 4

// A special error that the IO layer will sometime return to the reader.
// This means the read failed because the requested data is too old and
// has already been overwritten with newer data.
#define E_PASTWINDOWBOUNDARY 0xA5A5A5A5

// This should really be 0xF... instead of 0x7..., but we make it 0x7...
// just in case some variable somewhere is accidentally treated as signed.
//
// Used to initialize various file position variables.
#define ULLINFINITY 0x7FFFFFFFFFFFFFFF

//
// PerReaderStruct - the IO layer maintains one of these for each connected
// reader.  This is used to keep track of the reader's position while there
// is an outstanding read request, as well as the per-reader synchronization
// event.
//
// We also have a separate file handle for each reader.  This is somewhat dumb,
// but it is necessary because Win9x does not allow specifying read/write
// position in a ReadFile/WriteFile request.  To work on Win9x with a single
// handle, we would have to use it in a mutually exclusive way, which
// unnecessarily reduces efficiency when using the OS's file cache.
//
typedef struct {
   BOOL m_bInUse;
   HANDLE m_hReaderUnblockEvent;
   volatile ULONGLONG m_ullReaderBlockedOn;
   HANDLE m_hReaderFileHandle; // need a per reader handle for concurrent reads because there is no overlapped struct in Win98
   volatile ULONGLONG m_ullCurrentReadStart; // prevent the writer from corrupting what we are reading
} PerReaderStruct;

//
// IO layer object - there is only one of these per instance of the delay filter.
//
class CDelayIOLayer {
public:
   CDelayIOLayer();
   ~CDelayIOLayer();
   HRESULT Init(CBaseFilter *pFilter, // need this so we can send graph events
                ULONGLONG ullFileSize, // size of circular file to use
                const char *szFileName,
                BOOL bBlockWriter, // Should we block the writer if the area it is
                                   // trying to write to is currently being read from ?
                                   // If this is FALSE, the writer proceeds normally,
                                   // but later the reader code detects this condition
                                   // and fails the read with E_PASTWINDOWBOUNDARY.
                BOOL bBufferWrites, // Should the writer temporarily store everything in
                                    // a circular memory buffer and periodically flush
                                    // that to disk ?  If FALSE, we forward all Write
                                    // requests down to the OS on a one-for-one basis.
                ULONG ulWriterBufferSize); // ignored if above is FALSE
   HRESULT Abort(); // Kick out all readers so that we can shutdown in Shutdown()
   HRESULT Shutdown(); // Release all handles and any memory we allocated
   HRESULT ReaderConnect(int nStreamer); // Readers call this to register.  The delay filter
                                         // assigns a uniques streamer ID to each reader, and
                                         // the reader passes that in here.  This way the IO
                                         // layer does not have to worry about allocating
                                         // reader IDs.
   HRESULT ReaderDisconnect(int nStreamer);

   //
   // The following are read/write functions for the different sublayers of the IO layer
   // 

   // Reader/writer synchronization and blocking layer - called by the rest of the filter
   HRESULT Read(int nStreamer, ULONGLONG ullPosition, BYTE *pBuffer, ULONG ulSize);
   HRESULT Write(BYTE *pBuffer, ULONG ulSize, ULONGLONG *pullOffset, ULONGLONG *pullHead, ULONGLONG *pullTail);
private:
   // Buffering layer (optional caching) - called by Read() and Write()
   HRESULT BufferedRead(BYTE *pBuffer, ULONG ulSize, ULONGLONG ullPosition, int nStreamer);
   HRESULT BufferedWrite(BYTE *pBuffer, ULONG ulSize);

   // File circularity abstration layer - called by either of the above layers
   HRESULT UnbufferedRead(BYTE *pBuffer, ULONG ulSize, ULONGLONG ullPosition, int nStreamer);
   HRESULT UnbufferedWrite(BYTE *pBuffer, ULONG ulSize, ULONGLONG ullPosition);

   // Simple wrapper for sending an event to the filter graph
   void ReportPos(ULONGLONG ullPos, ULONGLONG *pullLast, long lEvent);

   volatile BOOL m_bDone; // set wither when we are uninitialized or when streaming has stopped
   HANDLE m_hWriterFileHandle; // writer's file handle (there can only be one writer)
   HANDLE m_hAbortEvent;       // set to signal any blocked readers to exit when aborting
   HANDLE m_hWriterUnblockEvent; // used to unblock the writer if it is waiting for a reader

   //
   // The following three variables are logical (non-wraparound) offsets into the file.
   //
   volatile ULONGLONG m_ullWriterBlockedOn; // end of the region the writer is waiting on

   // CAUTION: different parts of the delay filter use the terms Head/Tail differently
   // when it comes to positions in the circular file (!).  My apologies.  In the IO layer,
   // head is the oldest and tail is the most recent (which is in some sense backwards).
   // I think some other parts use tail to mean the oldest and head the most recent.
   volatile ULONGLONG m_ullDataHead; // beginning of the oldest available block of data
   volatile ULONGLONG m_ullDataTail; // end of most recent block of data

   ULONGLONG m_ullTempFileSize; // size of the disk file
   CCritSec m_csIO;
   CCritSec m_csSerializeWrites; // redundant - the delay filter must take care of this anyway
   PerReaderStruct m_Readers[MAX_STREAMERS];
   BOOL m_bBlockWriter; // see Init()
   TCHAR m_szFileName[1024]; // stored for subsequent CreateFile()s done on behalf of readers
   CBaseFilter *m_pFilter; // used only for sending graph notifications
   BOOL m_bBufferWrites; // see Init()
   BYTE* m_pbWriterBuffer; // see Init()
   ULONG m_ulWriterBufferSize; // see Init()

   // These variables are used by the writer buffering layer.
   // They are logical (non-wraparound) offsets into the file.
   volatile ULONGLONG m_ullStartOfDirtyData;
   volatile ULONGLONG m_ullNewDataTail;

#ifdef REPORT_RDWRPOS
   // Used to remember the last reported value, so that we can wait
   // sufficiently long before sending another event to the graph.
   ULONGLONG m_ullLastReaderPos;
   ULONGLONG m_ullLastWriterPos;
   ULONGLONG m_ullLastAbsRdPos;
   ULONGLONG m_ullLastAbsWrPos;
   ULONGLONG m_ullLastAbsHeadPos;
   ULONGLONG m_ullLastAbsTailPos;
#endif

   // debug statistics
   ULONG m_ulWrites;
   ULONG m_ulRealWrites;
   ULONG m_ulReads;
   ULONG m_ulRealReads;
};

//
// Helper class to automatically clean up some stuff on return from Read()
// Essentially just a way to automatically execute the code in this classe's
// destructor when CDelayIOLayer::Read() returns.
//
class CAutoReleaseWriter {
public:
    CAutoReleaseWriter(int nStreamer,
                        HANDLE hEvent,
                        volatile ULONGLONG *pullWriterBlockedOn,
                        PerReaderStruct *pReaders,
                        CCritSec *pcsIO,
                        BOOL bBlockWriter);
    ~CAutoReleaseWriter();
private:
   int m_nStreamer;
   HANDLE m_hWriterUnblockEvent;
   volatile ULONGLONG *m_pullWriterBlockedOn;
   PerReaderStruct *m_Readers;
   CCritSec *m_pcsIO;
   BOOL m_bBlockWriter;
};

#endif // __IO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\delay\reader.cpp ===
#include <streams.h>
#include <initguid.h>
#include <uuids.h>
#include <dvdmedia.h> // rate change stuff
#include "tsevcod.h"
#include "timeshift.h"
#include "delay.h"   

// force-unpase a reader if this close to the tail
#define UNPAUSE_PROXIMITY 0x200000 // 2MB

DWORD CStreamer::AllowedOperations(void) {
   switch (m_State) {
   case Streaming: {
      DWORD dwRet = AOB_PLAY | AOB_PAUSE | AOB_STOP | AOB_FF | AOB_RW | AOB_BACK | AOB_CATCHUP | AOB_SEEK | AOB_GETPOS;
      // disallow play if already playing
      if (m_dNewSpeed == 1.0)
         dwRet &= ~AOB_PLAY;
      if (m_dNewSpeed > 1.0)
         dwRet &= ~AOB_FF;
      if (m_dNewSpeed < -1.0)
         dwRet &= ~AOB_RW;
      return dwRet;
   }
   case Stopped: return AOB_PLAY | AOB_ARCHIVE; // could also allow RW, PAUSE, BACK, and SEEK if we wanted to
   case Paused: return AOB_PLAY | AOB_STOP | AOB_GETPOS; // could also allow FF, RW, BACK, CATCHUP, SEEK, GETPOS
   case Archiving: return AOB_STOP; // the only operation allowed while archiving
   default: return 0;
   }
}

//#define DUMP_TO_FILE
#undef DUMP_TO_FILE

#ifdef DUMP_TO_FILE
HANDLE g_hVideoFileHandle = INVALID_HANDLE_VALUE;
HANDLE g_hAudioFileHandle = INVALID_HANDLE_VALUE;
ULONG g_ulAudioBytesDelivered = 0;
ULONG g_ulVideoBytesDelivered = 0;
ULONG g_ulAudioBytesRead = 0;
ULONG g_ulVideoBytesRead = 0;
#endif

HRESULT CStreamer::Init(CDelayIOLayer *pIO) {
   HRESULT hr;
   m_pIO = pIO;

   if (FAILED(hr = m_pIO->ReaderConnect(m_nStreamerPos))) {
      DbgLog((LOG_ERROR,1,"streamer %d failed to connect to IO", m_nStreamerPos));
      return hr;
   }

   m_State = Stopped;
   m_dSpeed = 1.0;
   m_dNewSpeed = 0.0;
   m_bDone = FALSE;

   m_ullFileTail = 0;
   m_ullFileHead = 0;
   
   DWORD dwThreadId;

   m_hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
   if (m_hEvent == NULL) {
      DbgLog((LOG_ERROR,1,"streamer %d failed to create an event", m_nStreamerPos));
      return E_FAIL;
   }

   m_hThread = CreateThread(NULL,4096,InitialThreadProc,this,0,&dwThreadId);
   if (m_hThread == NULL) {
      DbgLog((LOG_ERROR,1,"streamer %d failed to create a thread", m_nStreamerPos));
      CloseHandle(m_hEvent);
      return E_FAIL;
   }

   // Create();

#ifdef DUMP_TO_FILE
   g_hAudioFileHandle = CreateFile("e:\\timeshift\\aud.dmp",
                                   GENERIC_WRITE,
                                   0, // no sharing
                                   NULL, // security
                                   CREATE_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);
   g_hVideoFileHandle = CreateFile("e:\\timeshift\\vid.dmp",
                                   GENERIC_WRITE,
                                   0, // no sharing
                                   NULL, // security
                                   CREATE_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);
   if ((g_hAudioFileHandle == INVALID_HANDLE_VALUE) || (g_hVideoFileHandle == INVALID_HANDLE_VALUE))
      DbgLog((LOG_TRACE,1,"could not open one of the dump files"));
   g_ulAudioBytesDelivered = 0;
   g_ulVideoBytesDelivered = 0;
   g_ulAudioBytesRead = 0;
   g_ulVideoBytesRead = 0;
#endif // DUMP_TO_FILE
   
   return NOERROR;
}

HRESULT CStreamer::Shutdown() {
   if (m_State == Uninitialized)
      return E_FAIL;

   m_bDone = TRUE;
   SetEvent(m_hEvent);
   WaitForSingleObject(m_hThread, INFINITE);
   CloseHandle(m_hEvent);
   CloseHandle(m_hThread);
   //Close(); // CAMThread::Close() - wait for the thread to exit
   m_pIO->ReaderDisconnect(m_nStreamerPos);
   
#ifdef DUMP_TO_FILE
   if (g_hAudioFileHandle != INVALID_HANDLE_VALUE) {
      CloseHandle(g_hAudioFileHandle);
      g_hAudioFileHandle = INVALID_HANDLE_VALUE;
   }
   if (g_hVideoFileHandle != INVALID_HANDLE_VALUE) {
      CloseHandle(g_hVideoFileHandle);
      g_hVideoFileHandle = INVALID_HANDLE_VALUE;
   }
   DbgLog((LOG_TRACE,2,"video: %u bytes read, %u bytes delivered", g_ulVideoBytesRead, g_ulVideoBytesDelivered));
   DbgLog((LOG_TRACE,2,"audio: %u bytes read, %u bytes delivered", g_ulAudioBytesRead, g_ulAudioBytesDelivered));
#endif // DUMP_TO_FILE

   return NOERROR;
}

void CStreamer::TailTrackerNotify(ULONGLONG ullHead, ULONGLONG ullTail) {
   m_csStreamerState.Lock();
   m_ullFileHead = ullHead;
   m_ullFileTail = ullTail;
   m_csStreamerState.Unlock();
   
   // If the tail is "too close" behind our current position and we are paused, unpause.
   if ((m_State == Paused) && (m_ullFileHead + UNPAUSE_PROXIMITY >= m_ullFilePos)) {
      DbgLog((LOG_TRACE,2,"streamer %d: forced unpause due to tail tracker notification", m_nStreamerPos));
      Play();
   }
}

DWORD CStreamer::InitialThreadProc(void *p) {
   return ((CStreamer*)p)->ThreadProc();
}

DWORD CStreamer::ThreadProc() {
   do {
      if ((m_State == Streaming) || (m_State == Archiving))
         StreamingStep();
      else
         WaitForSingleObject(m_hEvent, INFINITE);
   } while (!m_bDone);
   return 0;
}

/*
DWORD CStreamer::ThreadProc() {
   DWORD dwRequest;
   do {
      // possible race - doesn't matter (right ?)
      if ((m_State == Streaming) || (m_State == Archiving)) {
         if (CheckRequest(&dwRequest))
            goto process_request;
         else {
            StreamingStep();
            continue;
         }
      }
      else
         dwRequest = GetRequest();

   process_request:
      switch (dwRequest) {
      case WTC_EXIT:
         Reply(NOERROR);
         return 0;
      case WTC_STARTSTREAMING:
         Reply(NOERROR);
         
         m_csStreamerState.Lock();
         m_State = Streaming;
         NotifyState();
         m_csStreamerState.Unlock();
         
         break;
      default:
         Reply(E_INVALIDARG);
      }
   } while (1);

   return 0;
}
*/

#define INITIAL_READ 512

HRESULT CStreamer::ReadAndDeliverBlock(ULONGLONG ullFilePos, ULONG *ulretBlockSize, ULONGLONG *pullretBackPointer) {
   HRESULT hr;
   ULONG ulBlockSize;
   ULONG ulStreamId;
   ULONG ulDataSize;
   ULONG ulDataOffset;
   ULONG ulBytesLeft;
   ULONG ulCurrentOffset;
   ULONG ulDataLeft;
   ULONG ulSampleSize;
   ULONG ulThisSample;
   ULONG ulCopySize;
   ULONG ulSampleCount;
   ULONG ulPrefixSize;
   BYTE *pData;
   BYTE pHeader[512];
   CDelayOutputPin *pOutputPin;
   IMediaSample *pSample;
   BOOL bSyncPoint;
   REFERENCE_TIME rtStart, rtStop;
   DWORD dwFlags;
   ULONGLONG ullBackPointer;
   
   if (FAILED(hr = m_pIO->Read(m_nStreamerPos, ullFilePos, pHeader, INITIAL_READ))) {
      DbgLog((LOG_ERROR,1,"streamer %d: initial read failed at 0x%08X%08X", m_nStreamerPos, DWORD(ullFilePos >> 32), DWORD(ullFilePos)));
      return hr;
   }

   *ulretBlockSize = *((ULONG*)(pHeader + 0));
   
   //
   // The following 20 or so lines are our "demux"
   //
   ulBlockSize  = *((ULONG*)(pHeader + 0));
   ulStreamId   = *((ULONG*)(pHeader + 4));
   ulDataOffset = *((ULONG*)(pHeader + 8));
   ulDataSize   = *((ULONG*)(pHeader + 12));
   ulPrefixSize = *((ULONG*)(pHeader + 16));

   DbgLog((LOG_TRACE,5,"streamer %d: reading %d-byte block at 0x%08X (%d bytes payload)", m_nStreamerPos, ulBlockSize, DWORD(ullFilePos), ulDataSize));

   if (ulPrefixSize < 20) { // this version of the demux requires at least a 20-byte prefix
      DbgLog((LOG_ERROR,1,"streamer %d: prefix too small", m_nStreamerPos));
      return E_FAIL;
   }
   if (ulPrefixSize != 20)
      DbgLog((LOG_TRACE,1,"streamer %d: suspicios prefix size (%u)", m_nStreamerPos, ulPrefixSize));
   
   rtStop = rtStart = *((REFERENCE_TIME*)(pHeader + 20));
   if (rtStart < m_rtDropAllSamplesBefore) {
      DbgLog((LOG_TRACE,2,"streamer %d: skipping block for substream %d after seek", m_nStreamerPos, ulStreamId));
      return S_FALSE;
   }

   dwFlags = *((DWORD*)(pHeader + 28));
   if (dwFlags & 0xFFFFFFFE)
      DbgLog((LOG_TRACE,1,"streamer %d: suspicious flags (0x%08X)", m_nStreamerPos,dwFlags));
   bSyncPoint = dwFlags & 1;

   ullBackPointer = *((ULONGLONG*)(pHeader + 32));
   DbgLog((LOG_TRACE,6,"r %08X%08X", DWORD(ullBackPointer >> 32), DWORD(ullBackPointer)));
   if (ullBackPointer > 0x7FFFFFFFFFFFFFFF)
      DbgLog((LOG_TRACE,1,"streamer %d: suspicious back pointer (0x%08X%08X)", m_nStreamerPos, DWORD(ullBackPointer >> 32), DWORD(ullBackPointer)));
   if (pullretBackPointer) // not everybody cares, this is only used for rewinding
      *pullretBackPointer = ullBackPointer;

   if (ulBlockSize > 0x100000) {
      DbgLog((LOG_TRACE,1,"streamer %d: suspiciously large block", m_nStreamerPos));
   }

   //
   // In some cases we skip the block without trying to deliver it
   //

   // special padding stream ?
   if (ulStreamId == STREAMID_PADDING)
      return S_FALSE;

   // skip all non-video and non-syncpoint video blocks during ff/rw
   if ((m_dSpeed != 1.0) && ((ulStreamId != 0) || (!bSyncPoint))) // bugbug - assumes stream 0 is video
      return S_FALSE;

   // previous delivery error ?
   if (m_bError[ulStreamId])
      return S_FALSE;

   if (ulStreamId >= MAX_SUBSTREAMS) {
      DbgLog((LOG_ERROR,1,"streamer %d: bad stream id (%u)", m_nStreamerPos, ulStreamId));
      return E_FAIL;
   }
   if (m_pFilter->m_pInputPins[ulStreamId] == NULL) {
      DbgLog((LOG_ERROR,1,"streamer %d: missing substream (%u)", m_nStreamerPos, ulStreamId));
      return E_FAIL;
   }
   if ((pOutputPin = m_pFilter->m_pOutputPins[m_nStreamerPos][ulStreamId]) == NULL) {
      DbgLog((LOG_ERROR,1,"streamer %d: missing output pin", m_nStreamerPos));
      return E_FAIL;
   }
   if (ulDataOffset + ulDataSize > ulBlockSize) {
      DbgLog((LOG_ERROR,1,"streamer %d: bad data offset or size", m_nStreamerPos));
      return E_FAIL;
   }

#ifdef DUMP_TO_FILE
   if (ulStreamId == 0)
      g_ulVideoBytesRead += ulDataSize;
   if (ulStreamId == 1)
      g_ulAudioBytesRead += ulDataSize;
#endif

   ulCurrentOffset = ulDataOffset;
   ulSampleCount = 0;
   // Fill up and deliver media samples until we've delivered the whole block
   do {
      ulDataLeft = ulDataOffset + ulDataSize - ulCurrentOffset;
      if (!ulDataLeft)
         break;

      if (FAILED(hr = pOutputPin->GetDeliveryBuffer(&pSample, NULL, NULL, 0))) {
         DbgLog((LOG_ERROR,1,"streamer %d: GetDeliveryBuffer() failed", m_nStreamerPos));
         m_bError[ulStreamId] = TRUE;
         return S_FALSE;
      }
      if (FAILED(hr = pSample->GetPointer(&pData))) {
         DbgLog((LOG_ERROR,1,"streamer %d: GetPointer() failed", m_nStreamerPos));
         pSample->Release();
         m_bError[ulStreamId] = TRUE;
         return S_FALSE;
      }

      ulSampleSize = pSample->GetSize();
      ulThisSample = (ulDataLeft > ulSampleSize) ? ulSampleSize : ulDataLeft;
      ulCopySize = 0;

      // Does this sample begin within the data we've already read ?
      if (ulCurrentOffset < INITIAL_READ) { // Yes, reuse what we've already read
         ulCopySize = (ulThisSample > INITIAL_READ - ulCurrentOffset) ?
                            INITIAL_READ - ulCurrentOffset : ulThisSample;

         memcpy(pData, pHeader + ulCurrentOffset, ulCopySize);
      }
      
      // Is this sample completely contained within the data we've already read ?
      if (ulCopySize < ulThisSample) { // No, need to also read some data from disk
         if (FAILED(hr = m_pIO->Read(m_nStreamerPos,
                                     m_ullFilePos + ulCurrentOffset + ulCopySize,
                                     pData + ulCopySize,
                                     ulThisSample - ulCopySize))) {
            DbgLog((LOG_ERROR,1,"streamer %d: %u-byte read failed at 0x%08X%08X", m_nStreamerPos, ulThisSample - ulCopySize, DWORD((m_ullFilePos + ulCurrentOffset + ulCopySize) >> 32), DWORD(m_ullFilePos + ulCurrentOffset + ulCopySize)));
            pSample->Release();
            return hr;
         }
      }
         
      ulCurrentOffset += ulThisSample;

      ASSERT(ulThisSample <= ulSampleSize);
      if (FAILED(hr = pSample->SetActualDataLength(ulThisSample))) {
         DbgLog((LOG_ERROR,1,"streamer %d: SetActualDataLength() failed", m_nStreamerPos));
         pSample->Release();
         m_bError[ulStreamId] = TRUE;
         return S_FALSE;
      }
      // set sync point flag only if this this the first sample from the block
      if (FAILED(hr = pSample->SetSyncPoint((bSyncPoint && !ulSampleCount) ? TRUE : FALSE))) {
         DbgLog((LOG_ERROR,1,"streamer %d: SetSyncPoint() failed", m_nStreamerPos));
         pSample->Release();
         m_bError[ulStreamId] = TRUE;
         return S_FALSE;
      }
      if (FAILED(hr = pSample->SetTime(&rtStart, &rtStop))) {
         DbgLog((LOG_ERROR,1,"streamer %d: SetTime() failed", m_nStreamerPos));
         pSample->Release();
         m_bError[ulStreamId] = TRUE;
         return S_FALSE;
      }
      if (FAILED(hr = pSample->SetDiscontinuity(m_bDiscontinuityFlags[ulStreamId]))) {
         DbgLog((LOG_ERROR,1,"streamer %d: SetDiscontinuity() failed", m_nStreamerPos));
         pSample->Release();
         m_bError[ulStreamId] = TRUE;
         return S_FALSE;
      }
      if (FAILED(hr = pOutputPin->DeliverAndReleaseSample(pSample))) {
         DbgLog((LOG_ERROR,1,"streamer %d: sample delivery failed", m_nStreamerPos));
         m_bError[ulStreamId] = TRUE;
         return S_FALSE;
      }
      
      // eat up any discontinuity we just processed
      if (m_bDiscontinuityFlags[ulStreamId])
         DbgLog((LOG_TRACE,2,"streamer %d: discontinuity on sample for substream %d", m_nStreamerPos, ulStreamId));
      m_bDiscontinuityFlags[ulStreamId] = FALSE;

      ulSampleCount++;

#ifdef DUMP_TO_FILE
      if ((ulStreamId == 0) && (g_hVideoFileHandle != INVALID_HANDLE_VALUE)) {
         ULONG ulBytesWritten;
         if ((!WriteFile(g_hVideoFileHandle,
                         pData,
                         ulThisSample,
                         &ulBytesWritten,
                         NULL)) || (ulBytesWritten != ulThisSample))
            DbgLog((LOG_TRACE,1,"video write failed"));
         g_ulVideoBytesDelivered += ulThisSample;
      }
      if ((ulStreamId == 1) && (g_hAudioFileHandle != INVALID_HANDLE_VALUE)) {
         ULONG ulBytesWritten;
         if ((!WriteFile(g_hAudioFileHandle,
                         pData,
                         ulThisSample,
                         &ulBytesWritten,
                         NULL)) || (ulBytesWritten != ulThisSample))
            DbgLog((LOG_TRACE,1,"audio write failed"));
         g_ulAudioBytesDelivered += ulThisSample;
      }
#endif // DUMP_TO_FILE
   } while (1);

   // At this point we should have successfully delivered all of the block
#ifdef DUMP_TO_FILE
   ASSERT(g_ulAudioBytesRead == g_ulAudioBytesDelivered);
   ASSERT(g_ulVideoBytesRead == g_ulVideoBytesDelivered);
#endif
   
   if (ulSampleCount > 1) {
      DbgLog((LOG_TRACE,1,"streamer %d: block was %d bytes long and took %d media samples to deliver", m_nStreamerPos, ulDataSize, ulSampleCount));
   }
   DbgLog((LOG_TRACE,4,"streamer %d: delivered %d-byte block (0x%08X%08X) for substream %d",m_nStreamerPos,ulDataSize,DWORD(rtStart >> 32),DWORD(rtStart),ulStreamId));

   return NOERROR;
}

HRESULT CStreamer::ComputeNewFileOffset(REFERENCE_TIME rtSeekPos, ULONGLONG *ullNewFileOffset) {
   return E_NOTIMPL;
}

void CStreamer::Flush(void) {
   for (int i = 0; i < MAX_SUBSTREAMS; i++) {
      CDelayOutputPin *pOutputPin = Filter()->m_pOutputPins[m_nStreamerPos][i];
      if (pOutputPin && pOutputPin->IsConnected()) {
         HRESULT hr = 0;
         m_bDiscontinuityFlags[i] = TRUE;
         DbgLog((LOG_TRACE,2,"Calling BeginFlush() on substream %d", i));
         hr = pOutputPin->DeliverBeginFlush();
         DbgLog((LOG_TRACE,2,"Returned from BeginFlush() with 0x%08X, now calling EndFlush()", hr));
         hr = pOutputPin->DeliverEndFlush();
         DbgLog((LOG_TRACE,2,"EndFlush() for substream %d returned with 0x%08X",i,hr));
      }
   }
}

void CStreamer::StreamingStep(void) {
   HRESULT hr;
   
   double dNewSpeed;
   BOOL bSeekPending;
   REFERENCE_TIME rtSeekPos;
   SEEK_POSITION SeekType;
   ULONGLONG ullFileHead, ullFileTail;

   // get a consistent set of state variables
   m_csStreamerState.Lock();
   dNewSpeed = m_dNewSpeed;
   bSeekPending = m_bSeekPending;
   m_bSeekPending = FALSE; // consume
   rtSeekPos = m_rtSeekPos;
   SeekType = m_SeekType;
   ullFileTail = m_ullFileTail; // in case we need it - we may not
   ullFileHead = m_ullFileHead;
   m_csStreamerState.Unlock();

   // process any pending seek
   if (bSeekPending) {
      if (SeekType == SEEK_TO_TIME) {
         ULONGLONG ullNewFileOffset;
         if (FAILED(hr = ComputeNewFileOffset(rtSeekPos, &ullNewFileOffset))) {
            DbgLog((LOG_ERROR,1,"streamer %d: seek failed, hr = 0x%08X", m_nStreamerPos, hr));
         }
         else {
            m_ullFilePos = ullNewFileOffset;
            m_rtDropAllSamplesBefore = rtSeekPos;
            Flush();
         }
      }
      else if (SeekType == SEEK_TO_CURRENT) {
         m_ullFilePos = ullFileTail;
         Flush();
      }
      else if (SeekType == SEEK_TO_BEGIN) {
         m_ullFilePos = ullFileHead;
         Flush();
      }
      else {
         DbgLog((LOG_ERROR,1,"streamer %d: invalid seek type", m_nStreamerPos));
      }
   }

   // process any rate change
   if (m_dSpeed != dNewSpeed) {
      Flush();
      if ((dNewSpeed < 0.0) && (m_dSpeed > 0.0)) { // from forward to reverse
      }
      else if ((dNewSpeed > 0.0) && (m_dSpeed < 0.0)) { // reverse to forward
         // Sleep(1500);
      }
      if (FAILED(hr = SetRateInternal(dNewSpeed))) {
         DbgLog((LOG_ERROR,1,"streamer %d: SetRate failed", m_nStreamerPos));
         
         // notify the app
         m_csStreamerState.Lock();
         m_dNewSpeed = m_dSpeed;
         NotifyState();
         m_csStreamerState.Unlock();
      }
      else { // SetRate succeeded
         if ((dNewSpeed < 0.0) && (m_dSpeed > 0.0)) { // from forward to reverse
            //Flush();
         }
         else if ((dNewSpeed > 0.0) && (m_dSpeed < 0.0)) { // reverse to forward
            //Flush();
         }
         m_dSpeed = dNewSpeed;
      }
   }
   
   // now deliver a block of data
   ULONG ulBlockSize;
   ULONGLONG ullBackPointer;
   if (FAILED(hr = ReadAndDeliverBlock(m_ullFilePos, &ulBlockSize, &ullBackPointer))) {
      if (hr == E_PASTWINDOWBOUNDARY) {
         DbgLog((LOG_TRACE,2,"streamer %d: past window boundary", m_nStreamerPos));
         if (m_dSpeed < 0.0) {
            DbgLog((LOG_TRACE,2,"streamer %d: canceling rewind due to E_PASTWINDOFBOUNDARY", m_nStreamerPos));
            SetRate(1.0);
         }
         
         // seek forward a bit
         HRESULT hr;
         ULONGLONG ullNewPos;
         // bugbug - stream 0 won't always be video...
         hr = m_pFilter->m_Indexer.FindNextSyncPoint(m_nStreamerPos, 0, m_ullFilePos, &ullNewPos);
         
         if (SUCCEEDED(hr) && (ullNewPos < m_ullFileTail))
            m_ullFilePos = ullNewPos;
         else {
            DbgLog((LOG_ERROR,1,"streamer %d: failed to get back into the window, will probably die now", m_nStreamerPos));
         }
            
      }
      else {
         DbgLog((LOG_ERROR,1,"streamer %d: failed to read and deliver the block", m_nStreamerPos));
         
         m_csStreamerState.Lock();
         m_State = Stopped;
         NotifyState();
         m_csStreamerState.Unlock();
      }
   }
   else { // succeeded
      if (m_dSpeed > 0.0) {
         
         // if fast forwarding, go straight to the next video index point
         if (m_dSpeed > 1.0) {
            ULONGLONG ullNewPos;
            HRESULT hr;
            // bugbug - stream 0 won't always be video...
            hr = m_pFilter->m_Indexer.FindNextSyncPoint(m_nStreamerPos, 0, m_ullFilePos, &ullNewPos);
            
            if (SUCCEEDED(hr) && (ullNewPos < m_ullFileTail))
               m_ullFilePos = ullNewPos;
            else
               m_ullFilePos += ulBlockSize;
         }
         else
            m_ullFilePos += ulBlockSize;

         if ((m_dSpeed > 1.0) && (m_ullFilePos > m_ullFileTail)) { // reached the front - slow down
            m_csStreamerState.Lock();
            m_dNewSpeed = 1.0;
            NotifyState();
            m_csStreamerState.Unlock();
         }
      }
      else if (m_dSpeed < 0.0) { // jump back to previous video I frame
         m_ullFilePos = ullBackPointer;
         if (m_ullFilePos <= m_ullFileHead) { // too close to beginning - switch to forward
            DbgLog((LOG_TRACE,2,"streamer %d: canceling rewind due to head approaching", m_nStreamerPos));
            SetRate(1.0);
         }
      }
      else // m_dSpeed == 0
         ASSERT(FALSE);
   }
}

HRESULT CStreamer::CheckKsPropSetSupport() {
   HRESULT hr;
   int i;
   for (i = 0; i < MAX_SUBSTREAMS; i++) // check if everybody supports setrate
      if (Filter()->m_pOutputPins[m_nStreamerPos][i] && Filter()->m_pOutputPins[m_nStreamerPos][i]->IsConnected())
         if (!Filter()->m_pOutputPins[m_nStreamerPos][i]->m_pKsPropSet)
            return E_FAIL;
   return NOERROR;
}

HRESULT CStreamer::SetRateInternal(double dRate) {
   HRESULT hr;
   int i;
   if (FAILED(hr = CheckKsPropSetSupport())) {
      DbgLog((LOG_ERROR,1,"streamer %d: not all downstream pins support rate changes", m_nStreamerPos));
      return hr;
   }
   for (i = 0; i < MAX_SUBSTREAMS; i++) { // now call setrate on every output pin
      if (Filter()->m_pOutputPins[m_nStreamerPos][i] && Filter()->m_pOutputPins[m_nStreamerPos][i]->IsConnected()) {
         if (Filter()->m_pOutputPins[m_nStreamerPos][i]->m_bUseExactRateChange) {
            DbgLog((LOG_TRACE,2,"need to implement KS_AM_ExactRateChange support right"));
            AM_ExactRateChange Rate;
            Rate.OutputZeroTime = 0; // bugbug - can we get away with this even with ExactRateChange ?
            Rate.Rate = (long)(10000.0 / dRate);
            if (FAILED(hr = Filter()->m_pOutputPins[m_nStreamerPos][i]->m_pKsPropSet->Set(
                    AM_KSPROPSETID_TSRateChange,
                    AM_RATE_ExactRateChange,
                    NULL,
                    0,
                    (BYTE *)&Rate, 
                    sizeof(Rate)))) {
               DbgLog((LOG_ERROR,1,"ExactRateChange failed, substreams may get inconsistent rates"));
               return hr;
            }
         }
         else {
            AM_SimpleRateChange Rate;
            Rate.StartTime = 0; // bugbug - I understand everybody ignores this, but is it safe ?
            Rate.Rate = (long)(10000.0 / dRate);
            if (FAILED(hr = Filter()->m_pOutputPins[m_nStreamerPos][i]->m_pKsPropSet->Set(
                    AM_KSPROPSETID_TSRateChange,
                    AM_RATE_SimpleRateChange,
                    NULL,
                    0,
                    (BYTE *)&Rate, 
                    sizeof(Rate)))) {
               DbgLog((LOG_ERROR,1,"SimpleRateChange failed, substreams may get inconsistent rates"));
               return hr;
            }
         }
      }
   }
   DbgLog((LOG_TRACE,2,"streamer %d changed rate to %d", m_nStreamerPos, (long)(10000.0 * dRate)));
   return NOERROR;
}

HRESULT CStreamer::CheckDownstreamFilters() {
   int i;
   for (i = 0; i < MAX_SUBSTREAMS; i++)
      if (Filter()->m_pOutputPins[m_nStreamerPos][i] && Filter()->m_pOutputPins[m_nStreamerPos][i]->IsConnected())
         if (!Filter()->m_pOutputPins[m_nStreamerPos][i]->m_pDownstreamFilter)
            return E_FAIL;
   return NOERROR;
}

HRESULT CStreamer::PauseInternal() {
   HRESULT hr;
   if (FAILED(hr = CheckDownstreamFilters())) {
      DbgLog((LOG_ERROR,1,"streamer %d: cannot pause because some downstream pin would not tell us about its filter", m_nStreamerPos));
      return hr;
   }
   for (int i = 0; i < MAX_SUBSTREAMS; i++)
      if (Filter()->m_pOutputPins[m_nStreamerPos][i] && Filter()->m_pOutputPins[m_nStreamerPos][i]->IsConnected())
         if (FAILED(hr = Filter()->m_pOutputPins[m_nStreamerPos][i]->m_pDownstreamFilter->Pause())) {
            DbgLog((LOG_ERROR,1,"streamer %d: Pause() failed on some downstream pin", m_nStreamerPos));
            return hr;
         }
   return NOERROR;
}

HRESULT CStreamer::PlayInternal() {
   HRESULT hr;
   if (FAILED(hr = CheckDownstreamFilters())) {
      DbgLog((LOG_ERROR,1,"streamer %d: cannot play because some downstream pin would not tell us about its filter", m_nStreamerPos));
      return hr;
   }
   for (int i = 0; i < MAX_SUBSTREAMS; i++)
      if (Filter()->m_pOutputPins[m_nStreamerPos][i] && Filter()->m_pOutputPins[m_nStreamerPos][i]->IsConnected())
         if (FAILED(hr = Filter()->m_pOutputPins[m_nStreamerPos][i]->m_pDownstreamFilter->Run(0))) {
            DbgLog((LOG_ERROR,1,"streamer %d: Play() failed on some downstream pin", m_nStreamerPos));
            return hr;
         }
   return NOERROR;
}

HRESULT CStreamer::Play() {
   CAutoLock l(&m_csStreamerState);
   if (AOB_PLAY & AllowedOperations()) {
      HRESULT hr;
      if (m_State == Stopped)
         m_ullFilePos = m_ullFileTail;
      m_bSeekPending = FALSE;
      m_dNewSpeed = 1.0;
      m_rtDropAllSamplesBefore = 0x8000000000000000; // minus infinity
      if (m_State != Paused) {
         for (int i = 0; i < MAX_SUBSTREAMS; i++) {
            m_bDiscontinuityFlags[i] = TRUE;
            m_bError[i] = FALSE;
         }
      }
      if (SUCCEEDED(hr = PlayInternal())) {
         /* if (m_State == Paused)
            Sleep(1000); */
         m_State = Streaming;
         SetEvent(m_hEvent);
         NotifyState();
         return NOERROR;
      }
      else
         return hr;
   }
   else
      return VFW_E_WRONG_STATE;
}

HRESULT CStreamer::Pause() {
   CAutoLock l(&m_csStreamerState);
   if (AOB_PAUSE & AllowedOperations()) {
      if (SUCCEEDED(PauseInternal())) { // bugbug - this could block
         m_State = Paused;
         NotifyState();
      }
      return NOERROR;
   }
   else
      return VFW_E_WRONG_STATE;
}

HRESULT CStreamer::Stop() {
   CAutoLock l(&m_csStreamerState);
   if (AOB_STOP & AllowedOperations()) {
      m_State = Stopped;
      NotifyState();
      return NOERROR;
   }
   else
      return VFW_E_WRONG_STATE;
}

// CDelayStreamerInternal methods
HRESULT CStreamer::GetState(int *pState, double *pdRate) {
   CAutoLock l(&m_csStreamerState);
   *pState = m_State;
   *pdRate = m_dNewSpeed;
   return NOERROR;
}

HRESULT CStreamer::SetState(int State, double dRate, int *pNewState, double *pdNewRate) {
   CAutoLock l(&m_csStreamerState);
   HRESULT hr;
   m_dNewSpeed = dRate;
   *pdNewRate = dRate;
   switch (State) {
   case Stopped: Stop(); break;
   case Streaming: Play(); break;
   case Paused: Pause(); break;
   case Archiving: break;
   default: break;
   }
   *pNewState = m_State;
   return NOERROR;
}

HRESULT CStreamer::SetRate(double dRate) {
   CAutoLock l(&m_csStreamerState);
   if (dRate > 1.0) {
      if (AOB_FF & AllowedOperations()) {
         m_dNewSpeed = dRate;
         NotifyState();
         return NOERROR;
      }
      else
         return VFW_E_WRONG_STATE;
   }
   else if (dRate < -1.0) {
      if (AOB_RW & AllowedOperations()) {
         m_dNewSpeed = dRate;
         NotifyState();
         return NOERROR;
      }
      else
         return VFW_E_WRONG_STATE;
   }
   else if (dRate == 0.0) {
      if (AOB_PAUSE & AllowedOperations())
         return Pause();
      else
         return VFW_E_WRONG_STATE;
   }
   else if (dRate == 1.0) {
      if (AOB_PLAY & AllowedOperations()) {
         m_dNewSpeed = dRate;
         NotifyState();
         return NOERROR;
      }
      else
         return VFW_E_WRONG_STATE;
   }
   else { // no AOB checking
      m_dNewSpeed = dRate;
      NotifyState();
      return NOERROR;
   }
}

HRESULT CStreamer::Seek(SEEK_POSITION SeekType, REFERENCE_TIME rtTime) {
   CAutoLock l(&m_csStreamerState);

   m_SeekType = SeekType;
   if (SeekType == SEEK_TO_BEGIN) {
      if (AOB_BACK & AllowedOperations()) {
         m_bSeekPending = TRUE;
         NotifyState();
         return NOERROR;
      }
      else
         return VFW_E_WRONG_STATE;
   }
   else if (SeekType == SEEK_TO_TIME) {
      if (AOB_SEEK & AllowedOperations()) {
         m_bSeekPending = TRUE;
         m_rtSeekPos = rtTime;
         NotifyState();
         return NOERROR;
      }
      else
         return VFW_E_WRONG_STATE;
   }
   else if (SeekType == SEEK_TO_CURRENT) {
      if (AOB_CATCHUP & AllowedOperations()) {
         m_rtDelay = 0; // this doesn't actually do anything yet
         m_bSeekPending = TRUE;
         NotifyState();
         return NOERROR;
      }
      else
         return VFW_E_WRONG_STATE;
   }
   else
      return E_INVALIDARG;
}

void CStreamer::NotifyState() {
   // compute a new "permitted operations" bitmask and notify the graph
   DWORD dwAOB = AllowedOperations();
#ifdef DEBUG
   char *p;
   switch (m_State) {
   case Streaming: p = "Streaming"; break;
   case Stopped:   p = "Stopped";   break;
   case Paused:    p = "Paused";    break;
   case Archiving: p = "Archiving"; break;
   default:        p = "Unknown";
   }
   DbgLog((LOG_TRACE,2,"streamer %d STATE: %s, rate = %d", m_nStreamerPos, p, int(m_dNewSpeed * 10000.0)));
#endif
   Filter()->NotifyEvent(EC_AOB_UPDATE, dwAOB, 0);
}

HRESULT CStreamer::GetPositions(REFERENCE_TIME *pStartTime,
             REFERENCE_TIME *pEndTime,
             REFERENCE_TIME *pCurrentTime) {
   CAutoLock l(&m_csStreamerState);
   // Todo: examine our variables to find out the requested information
   return E_NOTIMPL;
}

HRESULT CStreamer::StartArchive(REFERENCE_TIME llArchiveStartTime,
             REFERENCE_TIME llArchiveEndTime) {
   //
   // Seek, set stop, then call play
   //
   return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\markers\makefile.inc ===
..\inc\markers.idl : markers.idl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\idl\makefile.inc ===
..\inc\timeshift.idl : timeshift.idl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\delay\tsevcod.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// The allowed bit mask definition of the user operations that are
// permitted/prohibited by the timeshift engine. This is sent as the
// lParam1 parameter of EC_AOB_UPDATE event.
//
#define AOB_PLAY    0x00000001
#define AOB_PAUSE   0x00000002
#define AOB_STOP    0x00000004
#define AOB_FF      0x00000008
#define AOB_RW      0x00000010
#define AOB_BACK    0x00000020
#define AOB_CATCHUP 0x00000040
#define AOB_SEEK    0x00000080
#define AOB_GETPOS  0x00000100
#define AOB_ARCHIVE 0x00000200
#define AOB_MARKER  0x00000400

//
// list of standard Timeshift event codes and the expected params
// 

#define EC_TSBASE							0x0800

//
// Timeshift event codes
// ======================
//

#define EC_AOB_UPDATE                           (EC_TSBASE + 0x01)
#define EC_WRITERPOS                            (EC_TSBASE + 0x02)
#define EC_READERPOS                            (EC_TSBASE + 0x03)
#define EC_ABSRDPOS                             (EC_TSBASE + 0x04)
#define EC_ABSWRPOS                             (EC_TSBASE + 0x05)
#define EC_ABSHEADPOS                           (EC_TSBASE + 0x06)
#define EC_ABSTAILPOS                           (EC_TSBASE + 0x07)

//
// Parameters : (lParam1, void)
//
// Signalled whenever the state of the timeshift engine change. This event
// specifies which operations are valid.
//
// lParam1 - Bit Mask of allowed user operations.
//           The allowed bit masks are defined in this file
//           as AOB_<operation>
//
// lParam2 - void.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\markers\enumcat.cpp ===
// EnumCategories.cpp: implementation of the CEnumCategories class.

/*******************************************************************************
**
**     EnumCategories.cpp - Implementation of CEnumCategories
**
**     1.0     07-APR-1999     C.Lorton     Created.
**
*******************************************************************************/

#include "tsmarkers.h"

CEnumCategories::CEnumCategories( CCategoryList *pList ) :
	m_cRef( 1 ),
	m_pList( pList ),
	m_index( 0 )
{
	m_pList->Reference();
}

CEnumCategories::CEnumCategories( CCategoryList *pList, ULONG index ) :
	m_cRef( 1 ),
	m_pList( pList ),
	m_index( 0 )
{
	m_pList->Reference();
}

CEnumCategories::~CEnumCategories()
{
	m_pList->Dereference();
}

STDMETHODIMP
CEnumCategories::QueryInterface( REFIID rid, LPVOID *pVoid )
{
	if ((IID_IUnknown == rid) || (IID_IEnumCategories == rid))
	{
		IEnumCategories::AddRef();
		*pVoid = (LPVOID) (IEnumCategories *) this;
		return S_OK;
	}

	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CEnumCategories::AddRef( void )
{
	return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CEnumCategories::Release( void )
{
	ULONG	refCount = --m_cRef;

	if (0 == m_cRef)
		delete this;

	return refCount;
}

HRESULT
CEnumCategories::Clone( IEnumCategories **ppEnum )
{
	*ppEnum = NULL;

	CEnumCategories *	pEnum = new CEnumCategories( m_pList, m_index );
	if (NULL == pEnum)
		return E_OUTOFMEMORY;

	*ppEnum = pEnum;

	return S_OK;
}

HRESULT
CEnumCategories::Next( ULONG count, CATEGORYINFO **pInfo, ULONG *pDelivered )
{
	if (IsBadWritePtr( pInfo, count * sizeof( CATEGORYINFO * ) ) ||
		IsBadWritePtr( pDelivered, sizeof( ULONG * )))
		return E_POINTER;

	*pDelivered = 0;

	while (count--)
	{
		HRESULT hr;
		CATEGORYINFO * pCategory;
		if (SUCCEEDED(hr = m_pList->GetCategory( m_index++, &pCategory )))
		{
			if (NULL != (*pInfo++ = CreateCategoryInfo( pCategory )))
			{
				(*pDelivered)++;
			}
			else
			{
				return E_OUTOFMEMORY;
			}
		}
		else
			return S_FALSE;
	}

	return S_OK;
}

HRESULT
CEnumCategories::Reset( void )
{
	m_index = 0;
	return S_OK;
}

HRESULT
CEnumCategories::Skip( ULONG count )
{
	while (count--)
	{
		HRESULT hr;
		CATEGORYINFO * pCategory;
		if (FAILED(hr = m_pList->GetCategory( m_index++, &pCategory )))
			return S_FALSE; // If not enough markers remain
	}

	return S_OK; // If succeeded
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\markers\enummark.cpp ===
// EnumMarkers.cpp: implementation of the CEnumMarkers class.

/*******************************************************************************
**
**     EnumMarkers.cpp - Implementation of CEnumMarkers
**
**     1.0     07-APR-1999     C.Lorton     Created.
**
*******************************************************************************/

#include "tsmarkers.h"

CEnumMarkers::CEnumMarkers( CMarkerList *pList, REFIID category ) :
	m_category( category ),
	m_cRef( 1 ),
	m_pList( pList ),
	m_index( 0 )
{
	m_pList->Reference();
}

CEnumMarkers::CEnumMarkers( CMarkerList *pList, REFIID category, ULONG index ) :
	m_category( category ),
	m_cRef( 1 ),
	m_pList( pList ),
	m_index( index )
{
	m_pList->Reference();
}

CEnumMarkers::~CEnumMarkers()
{
	m_pList->Dereference();
}

STDMETHODIMP
CEnumMarkers::QueryInterface( REFIID rid, LPVOID *pVoid )
{
	if ((IID_IUnknown == rid) || (IID_IEnumMarkers == rid))
	{
		IEnumMarkers::AddRef();
		*pVoid = (LPVOID) (IEnumMarkers *) this;
		return S_OK;
	}

	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CEnumMarkers::AddRef( void )
{
	return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CEnumMarkers::Release( void )
{
	ULONG	refCount = --m_cRef;

	if (0 == m_cRef)
		delete this;

	return refCount;
}

HRESULT
CEnumMarkers::Clone( IEnumMarkers **ppEnum )
{
	*ppEnum = NULL;

	CEnumMarkers *	pEnum = new CEnumMarkers( m_pList, m_category, m_index );

	if (NULL == pEnum)
		return E_OUTOFMEMORY;

	*ppEnum = pEnum;
	return S_OK;
}

HRESULT
CEnumMarkers::Next( ULONG count, MARKERINFO **pInfo, ULONG *pDelivered )
{
	if (IsBadWritePtr( pInfo, count * sizeof( MARKERINFO * ) ) ||
		IsBadWritePtr( pDelivered, sizeof( ULONG * )))
		return E_POINTER;

	*pDelivered = 0;

	while (count--)
	{
		HRESULT hr;
		MARKERINFO * pMarker;
		if (SUCCEEDED(hr = m_pList->GetMarker( m_category, m_index++, &pMarker )))
		{
			if (NULL != (*pInfo++ = CreateMarkerInfo( pMarker )))
			{
				(*pDelivered)++;
			}
			else
			{
				return E_OUTOFMEMORY;
			}
		}
		else
			return S_FALSE;
	}

	return S_OK;
}

HRESULT
CEnumMarkers::Reset( void )
{
	m_index = 0;
	return S_OK;
}

HRESULT
CEnumMarkers::Skip( ULONG count )
{
	while (count--)
	{
		HRESULT hr;
		MARKERINFO * pMarker;
		if (FAILED(hr = m_pList->GetMarker( m_category, m_index++, &pMarker )))
			return S_FALSE;
	}

	return S_OK; // If succeeded
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\markers\markercoll.cpp ===
// MarkerCollection.cpp: implementation of the CMarkerCollection class.

/*******************************************************************************
**
**     MarkerCollection.cpp - Implementation of CMarkerCollection
**
**     1.0     07-APR-1999     C.Lorton     Created.
**
*******************************************************************************/

#include "tsmarkers.h"

CMarkerCollection::CMarkerCollection() :
	m_cRef( 1 )
{
}

CMarkerCollection::~CMarkerCollection()
{
	ULONG i;
	for ( i = 0; i < m_catList.Size(); i++ )
	{
		HRESULT hr;
		CATEGORYHDR * pHeader;
		if (SUCCEEDED(hr = m_catList.Retrieve( i, &pHeader )))
		{
			ULONG j;
			for ( j = 0; j < pHeader->pMarkList->Size(); j++ )
			{
				MARKERINFO ** ppMarker;
				if (SUCCEEDED(hr = pHeader->pMarkList->Retrieve( j, &ppMarker )))
					DeleteMarkerInfo( *ppMarker );
			}
			DeleteCategoryInfo( pHeader->pCat );
		}
	}
}

STDMETHODIMP
CMarkerCollection::QueryInterface( REFIID rid, LPVOID *pVoid )
{
	if ((IID_IUnknown == rid) || (IID_IMarkerCollection == rid))
	{
		IMarkerCollection::AddRef();
		*pVoid = (LPVOID) (IMarkerCollection *) this;
		return S_OK;
	}

	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CMarkerCollection::AddRef( void )
{
	return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CMarkerCollection::Release( void )
{
	ULONG	refCount = --m_cRef;

	if (0 == m_cRef)
		delete this;

	return refCount;
}

HRESULT
CMarkerCollection::EnumCategories( IEnumCategories **ppEnum )
{
	*ppEnum = NULL;

	if (IsBadWritePtr( ppEnum, sizeof( IEnumCategories * ) ))
		return E_POINTER;

	CEnumCategories *	pEnum = new CEnumCategories( this );
	if (NULL == pEnum)
		return E_OUTOFMEMORY;

	HRESULT	hr = pEnum->QueryInterface( IID_IEnumCategories, (void **) ppEnum );
	if (FAILED(hr))
		delete pEnum;

	return hr;
}

HRESULT
CMarkerCollection::EnumMarkers( REFIID categoryId, IEnumMarkers **ppEnum )
{
	*ppEnum = NULL;

	if (IsBadWritePtr( ppEnum, sizeof( IEnumMarkers * ) ))
		return E_POINTER;

	CEnumMarkers *	pEnum = new CEnumMarkers( this, categoryId );
	if (NULL == pEnum)
		return E_OUTOFMEMORY;

	HRESULT hr = pEnum->QueryInterface( IID_IEnumMarkers, (void **) ppEnum );
	if (FAILED(hr))
		delete pEnum;

	return hr;
}

HRESULT
CMarkerCollection::GetCategory( ULONG index, CATEGORYINFO **ppCategory )
{
	if (IsBadWritePtr( ppCategory, sizeof( CATEGORYINFO * ) ))
		return E_POINTER;

	*ppCategory = NULL;

	HRESULT hr;
	CATEGORYHDR * pHeader;
	if (FAILED( hr = m_catList.Retrieve( index, &pHeader )))
		return hr;

	*ppCategory = CreateCategoryInfo( pHeader->pCat );
	if (NULL == *ppCategory)
		return E_OUTOFMEMORY;

	return S_OK;
}

HRESULT
CMarkerCollection::GetMarker( REFIID category, ULONG index, MARKERINFO **ppMarker )
{
	if (IsBadWritePtr( ppMarker, sizeof( MARKERINFO * ) ))
		return E_POINTER;

	*ppMarker = NULL;

	ULONG i;
	for ( i = 0; i < m_catList.Size(); i++ )
	{
		HRESULT hr;
		CATEGORYHDR * pHeader;
		if (FAILED(hr = m_catList.Retrieve( i, &pHeader )))
			return hr;

		if (pHeader->pCat->categoryId == category)
		{
			MARKERINFO ** ppInfo;
			if (FAILED(hr = pHeader->pMarkList->Retrieve( index, &ppInfo )))
				return hr;

			*ppMarker = CreateMarkerInfo( *ppInfo );
			if (NULL == *ppMarker)
				return E_OUTOFMEMORY;

			return S_OK;
		}
	}

	return E_INVALIDARG;
}

HRESULT CMarkerCollection::AddCategory(CATEGORYINFO *pCategory)
{
	if (IsBadReadPtr( pCategory, sizeof( CATEGORYINFO ) ))
		return E_POINTER;

	ULONG	i;
	for ( i = 0; i < m_catList.Size(); i++ )
	{
		HRESULT	hr;
		CATEGORYHDR *pHeader;
		if (FAILED(hr = m_catList.Retrieve( i, &pHeader )))
			return hr;
		if (pHeader->pCat->categoryId == pCategory->categoryId)
			return E_INVALIDARG;
	}

	CATEGORYHDR	header;
	header.pCat = CreateCategoryInfo( pCategory );
	header.pMarkList = new MARKERLIST;

	return m_catList.Append( header );
}

HRESULT CMarkerCollection::AddMarker(MARKERINFO *pMarker)
{
	if (IsBadReadPtr( pMarker, sizeof( MARKERINFO ) ))
		return E_POINTER;

	ULONG i;
	for ( i = 0; i < m_catList.Size(); i++ )
	{
		HRESULT hr;
		CATEGORYHDR *pHeader;
		if (FAILED(hr = m_catList.Retrieve( i, &pHeader )))
			return hr;
		if (pHeader->pCat->categoryId == pMarker->categoryId)
		{
			MARKERINFO *pInfo = CreateMarkerInfo( pMarker );
			if (NULL == pInfo)
				return E_OUTOFMEMORY;

			return pHeader->pMarkList->Append( pInfo );
		}
	}

	return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\markers\markersink.cpp ===
// MarkerSink.cpp: implementation of the CMarkerSink class.

/*******************************************************************************
**
**     MarkerSink.cpp - Implementation of CMarkerSink
**
**     1.0     07-APR-1999     C.Lorton     Created.
**
*******************************************************************************/

#include "tsmarkers.h"

CMarkerSink::CMarkerSink() :
	m_cookie( 0 ),
	m_cRef( 1 ),
	m_pSource( NULL )
{
}

CMarkerSink::~CMarkerSink()
{
}

STDMETHODIMP
CMarkerSink::QueryInterface( REFIID rid, LPVOID *pVoid )
{
	if ((IID_IUnknown == rid) || (IID_IMarkerSink == rid))
	{
		IMarkerSink::AddRef();
		*pVoid = (LPVOID) (IMarkerSink *) this;
		return S_OK;
	}

	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CMarkerSink::AddRef( void )
{
	return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CMarkerSink::Release( void )
{
	ULONG	refCount = --m_cRef;

	if (0 == m_cRef)
		delete this;

	return refCount;
}

HRESULT
CMarkerSink::Disconnect( IMarkerSource *pSource )
{
	if (pSource == m_pSource)
	{
		m_pSource->Unadvise( m_cookie );
		m_pSource->Release();
		m_pSource == NULL;
		return S_OK;
	}

	return E_INVALIDARG;
}

HRESULT
CMarkerSink::NewMarker( MARKERINFO *pMarker )
{
	return E_NOTIMPL;
}

HRESULT
CMarkerSink::StartMarker( MARKERINFO *pMarker )
{
	return E_NOTIMPL;
}

HRESULT
CMarkerSink::EndMarker( MARKERINFO *pMarker )
{
	return E_NOTIMPL;
}

HRESULT CMarkerSink::Connect(IMarkerSource *pSource)
{
	HRESULT	hr = E_UNEXPECTED;

	if (NULL == m_pSource)
	{
		m_pSource == pSource;
		m_pSource->AddRef();
		hr = m_pSource->Advise( (IMarkerSink *) this, &m_cookie );
		if (FAILED(hr))
		{
			m_pSource->Release();
			m_pSource = NULL;
		}
	}
	else
		hr = E_FAIL;

	return hr;
}

HRESULT CMarkerSink::Disconnect()
{
	return Disconnect( m_pSource );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\videlyzer\pesinfo.h ===
/*******************************************************************************
**
**     pesinfo.h - Structure of PES header.
**
**     1.0     10-FEB-1998     C.Lorton     Created.
**
*******************************************************************************/

#ifndef _PESINFO_H_
#define _PESINFO_H_

/*
typedef struct {
	BYTE	packet_start_code_prefix[3];
	BYTE	stream_id;
	USHORT	PES_packet_length;
	USHORT	one_oh : 2;
	USHORT	PES_scrambling_control : 2;
	USHORT	PES_priority : 1;
	USHORT	data_alignment_indicator : 1;
	USHORT	copyright : 1;
	USHORT	original_or_copy : 1;
	USHORT	PTS_DTS_flags : 2;
	USHORT	ESCR_flag : 1;
	USHORT	ES_rate_flag : 1;
	USHORT	DSM_trick_mode_flag : 1;
	USHORT	additional_copy_info_flag : 1;
	USHORT	PES_CRC_flag : 1;
	USHORT	PES_extension_flag : 1;
	BYTE	PES_header_data[1];
} PES_HEADER;
*/

#pragma pack( 1 )

typedef struct {
	BYTE	packet_start_code_prefix[3];
	BYTE	stream_id;
	USHORT	PES_packet_length;

	// The following six fields are reversed due to little endian/big endian differences
	UCHAR	original_or_copy : 1;
	UCHAR	copyright : 1;
	UCHAR	data_alignment_indicator : 1;
	UCHAR	PES_priority : 1;
	UCHAR	PES_scrambling_control : 2;
	UCHAR	one_oh : 2;

	// The following seven fields are reversed due to little endian/big endian differences
	UCHAR	PES_extension_flag : 1;
	UCHAR	PES_CRC_flag : 1;
	UCHAR	additional_copy_info_flag : 1;
	UCHAR	DSM_trick_mode_flag : 1;
	UCHAR	ES_rate_flag : 1;
	UCHAR	ESCR_flag : 1;
	UCHAR	PTS_DTS_flags : 2;

	BYTE	PES_header_data[1];
} PES_HEADER;

#pragma pack( )

#endif // _PESINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\markers\tsmarkers.h ===
/******************************************************************************
**
**     tsmarkers.h - Declaration of timeshifting marker classes
**
**     1.0     07-APR-1999     C.Lorton     Created.
**
******************************************************************************/

#ifndef _TSMARKERS_H_
#define _TSMARKERS_H_

#include <markers.h>

class CMarkerSource;
class CEnumCategories;
class CMarkerSink;
class CMarkerCollection;
class CEnumMarkers;

template < class T, ULONG ulBlockSize = 32 > class CObjectList
{
public:
	HRESULT Append( T &data );
	HRESULT Retrieve( ULONG index, T **ppData );
	ULONG Size( void ) { return m_cEntries; }
	CObjectList( void );
	~CObjectList( void );

protected:
	ULONG m_cEntriesAvailable;
	ULONG m_cEntries;
	ULONG m_cBlocks;
	T** m_pBlocks;
};

class CCategoryList
{
public:
	virtual HRESULT GetCategory( ULONG index, CATEGORYINFO **ppCategory ) = 0;
	virtual ULONG Reference( void ) = 0;
	virtual ULONG Dereference( void ) = 0;
};

class CMarkerList
{
public:
	virtual HRESULT GetMarker( REFIID category, ULONG index, MARKERINFO **ppMarker ) = 0;
	virtual ULONG Reference( void ) = 0;
	virtual ULONG Dereference( void ) = 0;
};

class CMarkerSource : public IMarkerSource, public CCategoryList
{
	typedef struct {
		ULONG			ulcookie;
		IMarkerSink *	pSink;
	} ADVISEE;

public:
	// Implementation

	HRESULT NewMarker( GUID &category, LPWSTR description, ULONGLONG time, ULONG stream, MARKERINFO **ppMarker );
	HRESULT StartMarker( GUID &category, LPWSTR description, ULONGLONG timeStart, ULONG stream, MARKERINFO **ppMarker );
	HRESULT EndMarker( MARKERINFO *pMarker, ULONGLONG timeEnd );
	UINT32 m_nextCookie;

	// CCategoryList
	HRESULT	GetCategory( ULONG index, CATEGORYINFO **ppCategory );
	ULONG	Reference( void ) { return AddRef(); }
	ULONG	Dereference( void ) { return Release(); }

	// IMarkerSource
	// Retrieve category enumerator
	STDMETHODIMP EnumCategories( IEnumCategories **ppEnum );
	// Be advised of marker sink requesting markers
	STDMETHODIMP Advise( IMarkerSink *pSink, ULONG *pulCookie );
	// Remove marker sink from list of active sinks
	STDMETHODIMP Unadvise( ULONG ulCookie );

	// IUnknown
	// Return requested interface, if supported
	STDMETHODIMP QueryInterface( REFIID rid, LPVOID *pVoid );
	// Increment reference count
	STDMETHODIMP_(ULONG) AddRef( void );
	// Decrement reference count
	STDMETHODIMP_(ULONG) Release( void );
	// Current reference count
	ULONG	m_cRef;

	CMarkerSource();
	virtual ~CMarkerSource();
};

class CEnumCategories : public IEnumCategories
{
public:
	// Implementation

	ULONG m_index;
	CCategoryList * m_pList;

	// IEnumCategories
	// Generate a duplicate enumerator
	STDMETHODIMP Clone( IEnumCategories **ppEnum );
	// Get next count category descriptors
	STDMETHODIMP Next( ULONG count, CATEGORYINFO **pInfo, ULONG *pDelivered );
	// Reset enumerator
	STDMETHODIMP Reset( void );
	// Skip next count category descriptors
	STDMETHODIMP Skip( ULONG count );

	// IUnknown
	// Return requested interface, if supported
	STDMETHODIMP QueryInterface( REFIID rid, LPVOID *pVoid );
	// Increment reference count
	STDMETHODIMP_(ULONG) AddRef( void );
	// Decrement reference count
	STDMETHODIMP_(ULONG) Release( void );
	// Current reference count
	ULONG	m_cRef;

	CEnumCategories( CCategoryList *pList );
	virtual ~CEnumCategories();
protected:
	CEnumCategories( CCategoryList *pList, ULONG index );
};

class CMarkerSink : public IMarkerSink
{
public:
	// Implementation

	HRESULT Disconnect( void );
	HRESULT Connect( IMarkerSource *pSource );
	ULONG m_cookie;
	IMarkerSource * m_pSource;

	// IMarkerSink
	// Receive disconnect request from marker source
	STDMETHODIMP Disconnect( IMarkerSource *pSource );
	// Receive notification of new point event marker
	STDMETHODIMP NewMarker( MARKERINFO *pMarker ) = 0;
	// Receive notification of start of new event marker
	STDMETHODIMP StartMarker( MARKERINFO *pMarker ) = 0;
	// Receive notification of end of new event marker
	STDMETHODIMP EndMarker( MARKERINFO *pMarker ) = 0;

	// IUnknown
	// Return requested interface, if supported
	STDMETHODIMP QueryInterface( REFIID rid, LPVOID *pVoid );
	// Increment reference count
	STDMETHODIMP_(ULONG) AddRef( void );
	// Decrement reference count
	STDMETHODIMP_(ULONG) Release( void );
	// Current reference count
	ULONG	m_cRef;

	CMarkerSink();
	virtual ~CMarkerSink();
};



class CMarkerCollection : public IMarkerCollection, public CCategoryList, public CMarkerList
{
public:
	// Implementation

	typedef CObjectList< MARKERINFO * > MARKERLIST;
	typedef struct {
		CATEGORYINFO * pCat;
		MARKERLIST * pMarkList;
	} CATEGORYHDR;
	typedef CObjectList< CATEGORYHDR > CATEGORYLIST;

	CATEGORYLIST	m_catList;

	HRESULT AddCategory( CATEGORYINFO *pCategory );
	HRESULT AddMarker( MARKERINFO *pMarker );

	// IMarkerCOllection
	// Retrieve category enumerator
	STDMETHODIMP EnumCategories( IEnumCategories **ppEnum );
	// Retrieve marker enumerator
	STDMETHODIMP EnumMarkers( REFIID categoryId, IEnumMarkers **ppEnum );

	// CCategoryList
	HRESULT GetCategory( ULONG index, CATEGORYINFO **ppCategory );
	ULONG	Reference( void ) { return AddRef(); }
	ULONG	Dereference( void ) { return Release(); }

	// CMarkerList
	HRESULT GetMarker( REFIID category, ULONG index, MARKERINFO **ppMarker );
//	ULONG	CMarkerList::Reference( void ) { return AddRef(); }
//	ULONG	CMarkerList::Dereference( void ) { return Release(); }

	// IUnknown
	// Return requested interface, if supported
	STDMETHODIMP QueryInterface( REFIID rid, LPVOID *pVoid );
	// Increment reference count
	STDMETHODIMP_(ULONG) AddRef( void );
	// Decrement reference count
	STDMETHODIMP_(ULONG) Release( void );
	// Current reference count
	ULONG	m_cRef;

	CMarkerCollection();
	virtual ~CMarkerCollection();
};

class CEnumMarkers : public IEnumMarkers
{
public:
	// Implementation

	ULONG m_index;
	CMarkerList *m_pList;
	GUID m_category;

	// IEnumMarkers
	// Generate a duplicate enumerator
	STDMETHODIMP Clone( IEnumMarkers **ppEnum );
	// Get next count marker descriptors
	STDMETHODIMP Next( ULONG count, MARKERINFO **pInfo, ULONG *pDelivered );
	// Reset enumerator
	STDMETHODIMP Reset( void );
	// Skip next count marker descriptors
	STDMETHODIMP Skip( ULONG count );

	// IUnknown
	// Return requested interface, if supported
	STDMETHODIMP QueryInterface( REFIID rid, LPVOID *pVoid );
	// Increment reference count
	STDMETHODIMP_(ULONG) AddRef( void );
	// Decrement reference count
	STDMETHODIMP_(ULONG) Release( void );
	// Current reference count
	ULONG	m_cRef;

	CEnumMarkers( CMarkerList *pList, REFIID category );
	virtual ~CEnumMarkers();

protected:
	CEnumMarkers( CMarkerList *pList, REFIID category, ULONG index );
};

// Allocates a CATEGORYINFO structure and space for the name string
CATEGORYINFO * CreateCategoryInfo( REFIID category, LPWSTR name, REFIID parent, ULONGLONG frequency );
CATEGORYINFO * CreateCategoryInfo( CATEGORYINFO *pSource );
// Frees the name string and the CATEGORYINFO structure
void DeleteCategoryInfo( CATEGORYINFO *pCategory );
// Frees the name string in the target (if non-NULL), allocates new space and copies the source
void CopyCategoryInfo( CATEGORYINFO *pTarget, const CATEGORYINFO *pSource );
// Frees the name string
void FreeCategoryInfo( CATEGORYINFO &category );

// Allocates a MARKERINFO structure and space for the description string
MARKERINFO * CreateMarkerInfo( REFIID category, LPWSTR description, ULONGLONG start, ULONGLONG end, ULONG stream );
MARKERINFO * CreateMarkerInfo( MARKERINFO *pSource );
// Frees the description string and the MARKERINFO structure
void DeleteMarkerInfo( MARKERINFO *pMarker );
// Frees ther description string in the target (if non-NULL), allocates new space and copies the source
void CopyMarkerInfo( MARKERINFO *pTarget, const MARKERINFO *pSource );
// Frees the description string
void FreeMarkerInfo( MARKERINFO &marker );

#endif // _TSMARKERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\markers\markutil.cpp ===
/*******************************************************************************
**
**     MarkerUtils.cpp - Implementation of marker utility functions.
**
**     1.0     08-APR-1999     C.Lorton     Created.
**
*******************************************************************************/

#include "tsmarkers.h"

template < class T, ULONG BLOCKSIZE >
CObjectList< T, BLOCKSIZE >::CObjectList( void ) :
	m_cEntriesAvailable( 0 ),
	m_cEntries( 0 ),
	m_cBlocks( 0 ),
	m_pBlocks( NULL )
{
	m_pBlocks = new T* [++m_cBlocks];
	if (NULL != m_pBlocks)
	{
		m_pBlocks[m_cBlocks-1] = new T [BLOCKSIZE];
		if (NULL != m_pBlocks[m_cBlocks-1])
		{
			m_cEntriesAvailable = BLOCKSIZE;
		}
		else
		{
			delete m_pBlocks;
			m_pBlocks = NULL;
		}
	}
}

template < class T, ULONG BLOCKSIZE >
CObjectList< T, BLOCKSIZE >::~CObjectList( void )
{
	if (NULL != m_pBlocks)
	{
		while (0 < m_cBlocks)
		{
			delete [] m_pBlocks[--m_cBlocks];
		}
		delete [] m_pBlocks;
		m_pBlocks = NULL;
	}
}

template < class T, ULONG BLOCKSIZE >
HRESULT
CObjectList< T, BLOCKSIZE >::Append( T &data )
{
	if (NULL == m_pBlocks)
		return E_OUTOFMEMORY;

	if (0 == m_cEntriesAvailable)
	{
		T** pTemp = new T* [m_cBlocks + 1];
		if (NULL == pTemp)
			return E_OUTOFMEMORY;
		ULONG	i;
		for ( i = 0; i < m_cBlocks; i++ )
			pTemp[i] = m_pBlocks[i];
		pTemp[m_cBlocks] = new T [BLOCKSIZE];
		if (NULL == pTemp[m_cBlocks])
		{
			delete [] pTemp;
			return E_OUTOFMEMORY;
		}
		delete [] m_pBlocks;
		m_pBlocks = pTemp;
		m_cEntriesAvailable = BLOCKSIZE;
	}

	if (0 == m_cEntriesAvailable)
		return E_OUTOFMEMORY;

	ULONG	i = m_cEntries / BLOCKSIZE;
	ULONG	j = m_cEntries % BLOCKSIZE;

	m_pBlocks[i][j] = data;
	m_cEntries++;

	return S_OK;
}

template < class T, ULONG BLOCKSIZE >
HRESULT
CObjectList< T, BLOCKSIZE >::Retrieve( ULONG index, T **ppData )
{
	if (IsBadWritePtr( ppData, sizeof( T * ) ))
		return E_POINTER;

	if (index >= m_cEntries)
		return E_INVALIDARG;

	ULONG	i = index / BLOCKSIZE;
	ULONG	j = index % BLOCKSIZE;

	*ppData = m_pBlocks[i] + j;
	return S_OK;
}

// Allocates a CATEGORYINFO structure and space for the name string
CATEGORYINFO *
CreateCategoryInfo( REFIID category, LPWSTR name, REFIID parent, ULONGLONG frequency )
{
	CATEGORYINFO * pInfo = (CATEGORYINFO *) CoTaskMemAlloc( sizeof( CATEGORYINFO ) );
	if (NULL != pInfo)
	{
		pInfo->ulSize = sizeof( CATEGORYINFO * );
		pInfo->categoryId = category;

		if (NULL != name)
		{
			pInfo->categoryName = (LPWSTR) CoTaskMemAlloc( wcslen( name ) * sizeof( wchar_t ) );
			if (NULL != pInfo->categoryName)
				wcscpy( pInfo->categoryName, name );
		}
		else
			pInfo->categoryName = NULL;

		pInfo->parentCategoryId = parent;
		pInfo->estFrequency = frequency;
	}

	return pInfo;
}

CATEGORYINFO *
CreateCategory( CATEGORYINFO *pSource )
{
	CATEGORYINFO * pInfo = (CATEGORYINFO *) CoTaskMemAlloc( sizeof( CATEGORYINFO ) );
	if (NULL != pInfo)
	{
		pInfo->ulSize = sizeof( CATEGORYINFO * );
		pInfo->categoryId = pSource->categoryId;

		if (NULL != pSource->categoryName)
		{
			pInfo->categoryName = (LPWSTR) CoTaskMemAlloc( wcslen( pSource->categoryName ) * sizeof( wchar_t ) );
			if (NULL != pInfo->categoryName)
				wcscpy( pInfo->categoryName, pSource->categoryName );
		}
		else
			pInfo->categoryName = NULL;

		pInfo->parentCategoryId = pSource->parentCategoryId;
		pInfo->estFrequency = pSource->estFrequency;
	}

	return pInfo;
}

// Frees the name string and the CATEGORYINFO structure
void
DeleteCategoryInfo( CATEGORYINFO *pCategory )
{
	if (NULL != pCategory)
	{
		if (NULL != pCategory->categoryName)
			CoTaskMemFree( pCategory->categoryName );
		CoTaskMemFree( pCategory );
	}
}

// Frees the name string in the target (if non-NULL), allocates new space and copies the source
void
CopyCategoryInfo( CATEGORYINFO *pTarget, const CATEGORYINFO *pSource )
{
	if (NULL != pTarget)
	{
		if (NULL != pTarget->categoryName)
			CoTaskMemFree( pTarget->categoryName );
		memcpy( pTarget, pSource, sizeof( CATEGORYINFO ) );
		pTarget->categoryName = (LPWSTR) CoTaskMemAlloc( wcslen( pSource->categoryName ) * sizeof( wchar_t ) );
		if (NULL != pTarget->categoryName)
			wcscpy( pTarget->categoryName, pSource->categoryName );
	}
}

// Frees the name string
void
FreeCategoryInfo( CATEGORYINFO &category )
{
	if (NULL != category.categoryName)
	{
		CoTaskMemFree( category.categoryName );
		category.categoryName = NULL;
	}
}


// Allocates a MARKERINFO structure and space for the description string
MARKERINFO *
CreateMarkerInfo( REFIID category, LPWSTR description, ULONGLONG start, ULONGLONG end, ULONG stream )
{
	MARKERINFO * pInfo = (MARKERINFO *) CoTaskMemAlloc( sizeof( MARKERINFO ) );
	if (NULL != pInfo)
	{
		pInfo->ulSize = sizeof( MARKERINFO * );
		pInfo->categoryId = category;

		if (NULL != description)
		{
			pInfo->descriptionString = (LPWSTR) CoTaskMemAlloc( wcslen( description ) * sizeof( wchar_t ) );
			if (NULL != pInfo->descriptionString)
				wcscpy( pInfo->descriptionString, description );
		}
		else
			pInfo->descriptionString = NULL;

		pInfo->timeStart = start;
		pInfo->timeEnd   = end;
		pInfo->streamId = stream;
	}

	return pInfo;
}

MARKERINFO *
CreateMarkerInfo( MARKERINFO *pSource )
{
	MARKERINFO * pInfo = (MARKERINFO *) CoTaskMemAlloc( sizeof( MARKERINFO ) );
	if (NULL != pInfo)
	{
		pInfo->ulSize = sizeof( MARKERINFO * );
		pInfo->categoryId = pSource->categoryId;

		if (NULL != pSource->descriptionString)
		{
			pInfo->descriptionString = (LPWSTR) CoTaskMemAlloc( wcslen( pSource->descriptionString ) * sizeof( wchar_t ) );
			if (NULL != pInfo->descriptionString)
				wcscpy( pInfo->descriptionString, pSource->descriptionString );
		}
		else
			pInfo->descriptionString = NULL;

		pInfo->timeStart = pSource->timeStart;
		pInfo->timeEnd   = pSource->timeEnd;
		pInfo->streamId = pSource->streamId;
	}

	return pInfo;
}

// Frees the description string and the MARKERINFO structure
void
DeleteMarkerInfo( MARKERINFO *pMarker )
{
	if (NULL != pMarker)
	{
		if (NULL != pMarker->descriptionString)
			CoTaskMemFree( pMarker->descriptionString );
		CoTaskMemFree( pMarker );
	}
}

// Frees ther description string in the target (if non-NULL), allocates new space and copies the source
void
CopyMarkerInfo( MARKERINFO *pTarget, const MARKERINFO *pSource )
{
	if (NULL != pTarget)
	{
		if (NULL != pTarget->descriptionString)
			CoTaskMemFree( pTarget->descriptionString );
		memcpy( pTarget, pSource, sizeof( MARKERINFO ) );
		pTarget->descriptionString = (LPWSTR) CoTaskMemAlloc( wcslen( pSource->descriptionString ) * sizeof( wchar_t ) );
		if (NULL != pTarget->descriptionString)
			wcscpy( pTarget->descriptionString, pSource->descriptionString );
	}
}

// Frees the description string
void
FreeMarkerInfo( MARKERINFO &marker )
{
	if (NULL != marker.descriptionString)
	{
		CoTaskMemFree( marker.descriptionString );
		marker.descriptionString = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\videlyzer\debugpin.cpp ===
/*******************************************************************************
**
**     DebugPin.cpp - Implementation of CDebugPin
**
**     1.0     26-MAR-1999     C.Lorton     Created out of Videlyzer.cpp
**
*******************************************************************************/

#include <streams.h>
#include <stdio.h>
#include <tchar.h>
#include "DebugPin.h"

AMOVIESETUP_MEDIATYPE sudDebugTypes[] =
{
	{
		&MEDIATYPE_Text,
		&GUID_NULL
	}
};

UINT32 numDebugTypes = NUMELMS( sudDebugTypes );

CDebugOutputPin::CDebugOutputPin( TCHAR *pObjectName, CBaseFilter *pFilter,
								  CCritSec *pLock, HRESULT *phr,
								  LPCWSTR pPinName) :
	CBaseOutputPin( pObjectName, pFilter, pLock, phr, pPinName ),
	m_pMediaSample( NULL )
{
} // CDebugOutputPin::CDebugOutputPin

HRESULT
CDebugOutputPin::CheckMediaType(const CMediaType *pmt)
{
	int	iPosition;

	for (iPosition = 0; iPosition < NUMELMS(sudDebugTypes); iPosition++)
		if ((*(pmt->Type()) == *(sudDebugTypes[iPosition].clsMajorType)) &&
			(*(pmt->Subtype()) == *(sudDebugTypes[iPosition].clsMinorType))) {

			return S_OK;
		} // if (type and subtype match)

	return S_FALSE;
} // CDebugOutputPin::CheckMediaType

HRESULT
CDebugOutputPin::DecideBufferSize(IMemAllocator *pAlloc, ALLOCATOR_PROPERTIES *pProps)
{
	pProps->cbAlign  = 1;
	pProps->cbBuffer = 1024;
	pProps->cbPrefix = 0;
	pProps->cBuffers = 2;

	ALLOCATOR_PROPERTIES	propsActual;
	HRESULT	hr = pAlloc->SetProperties( pProps, &propsActual );
	if (SUCCEEDED( hr ))
	{
		if ((0 == propsActual.cbBuffer) || (0 == propsActual.cBuffers))
			hr = E_FAIL;
		else
			hr = NOERROR;
	}

	return hr;
} // CDebugOutputPin::DecideBufferSize

HRESULT
CDebugOutputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
	if (iPosition < NUMELMS(sudDebugTypes)) {
		pMediaType->InitMediaType();
		pMediaType->SetType(sudDebugTypes[iPosition].clsMajorType);
		pMediaType->SetSubtype(sudDebugTypes[iPosition].clsMinorType);

		return S_OK;
	}

	return VFW_S_NO_MORE_ITEMS;
} // CDebugOutputPin::GetMediaType

HRESULT
CDebugOutputPin::Output( char *format, ...)
{
	if (NULL == m_pMediaSample)
	{
		if (FAILED( GetDeliveryBuffer( &m_pMediaSample, NULL, NULL, 0 ) ))
			return E_FAIL;
		m_pMediaSample->SetActualDataLength( 0L );
	}

	char msg[256], *ptr = (char *) msg;
	va_list	argptr;
	va_start( argptr, format );
	_vsnprintf( msg, 256, format, argptr );
	va_end( argptr );

	long	count = strlen( msg );
	while (0 < count)
	{
		LONG	lSize = m_pMediaSample->GetSize();
		LONG	lActual = m_pMediaSample->GetActualDataLength();
		LONG	lAvailable = lSize - lActual;
		LONG	toWrite = count <= lAvailable ? count : lAvailable;
		BYTE	*pBuffer;
		
		m_pMediaSample->GetPointer( &pBuffer );
		pBuffer += lActual;
		memcpy( pBuffer, ptr, toWrite );
		pBuffer += toWrite;
		ptr += toWrite;
		count -= toWrite;
		lActual += toWrite;
		m_pMediaSample->SetActualDataLength( lActual );
		lAvailable -= toWrite;

		if (0 == lAvailable)
		{
			Deliver( m_pMediaSample );
			m_pMediaSample->Release();
			m_pMediaSample = NULL;

			if (FAILED( GetDeliveryBuffer( &m_pMediaSample, NULL, NULL, 0 ) ))
				break;
			m_pMediaSample->SetActualDataLength( 0L );
		} // 0 == lAvailable
	} // 0 < count

	return 0 == count ? S_OK : E_FAIL;
} // CDebugOutputPin::Output
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\videlyzer\debugpin.h ===
/*******************************************************************************
**
**     DebugPin.h - Declaration of CDebugPin
**
**     1.0     26-MAR-1999     C.Lorton     Created out of Videlyzer.h
**
*******************************************************************************/

#ifndef _DEBUGPIN_H_
#define _DEBUGPIN_H_

class CVidelyzerFilter;

class CDebugObject
{
public:
	virtual HRESULT	Output( char *format, ... ) = NULL;
};

class CDebugOutputPin : public CBaseOutputPin, public CDebugObject
{
public:
	IMediaSample * m_pMediaSample;
	HRESULT Output( char *format, ... );
	CDebugOutputPin( TCHAR *pObjectName, CBaseFilter *pFilter, CCritSec *pLock, HRESULT *phr, LPCWSTR pPinName );
	HRESULT CheckMediaType( const CMediaType *pmt );
	HRESULT DecideBufferSize( IMemAllocator *pAlloc, ALLOCATOR_PROPERTIES *pProps );
	HRESULT GetMediaType( int iPosition, CMediaType *pMediaType );
};

#endif // _DEBUGPIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\markers\markersrc.cpp ===
// MarkerSource.cpp: implementation of the CMarkerSource class.

/*******************************************************************************
**
**     MarkerSource.cpp - Implementation of CMarkerSource
**
**     1.0     07-APR-1999     C.Lorton     Created.
**
*******************************************************************************/

#include "tsmarkers.h"

CMarkerSource::CMarkerSource() :
	m_cRef( 1 )
{
}

CMarkerSource::~CMarkerSource()
{
}

STDMETHODIMP
CMarkerSource::QueryInterface( REFIID rid, LPVOID *pVoid )
{
	if ((IID_IUnknown == rid) || (IID_IMarkerSource == rid))
	{
		IMarkerSource::AddRef();
		*pVoid = (LPVOID) (IMarkerSource *) this;
		return S_OK;
	}

	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CMarkerSource::AddRef( void )
{
	return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CMarkerSource::Release( void )
{
	ULONG	refCount = --m_cRef;

	if (0 == m_cRef)
		delete this;

	return refCount;
}

HRESULT
CMarkerSource::EnumCategories( IEnumCategories **ppEnum )
{
	if (IsBadWritePtr( ppEnum, sizeof( IEnumCategories * ) ))
		return E_POINTER;

	*ppEnum = NULL;

	CEnumCategories *	pEnum = new CEnumCategories( this );
	if (NULL == pEnum)
		return E_OUTOFMEMORY;

	*ppEnum = (IEnumCategories *) pEnum;

	return S_OK;
}

HRESULT
CMarkerSource::Advise( IMarkerSink *pSink, ULONG *pulCookie )
{
	if (IsBadWritePtr( pulCookie, sizeof( ULONG ) ))
		return E_POINTER;

	// Store pointer here

	*pulCookie = m_nextCookie++;

	return S_OK;
}
	
HRESULT
CMarkerSource::Unadvise(ULONG ulCookie)
{
	// Search current connections using ulCookie
	if (ulCookie < m_nextCookie)
		return S_OK;
	else
		return E_FAIL;
}

HRESULT CMarkerSource::EndMarker(MARKERINFO *pMarker, ULONGLONG timeEnd)
{
	if (IsBadReadPtr( pMarker, sizeof( MARKERINFO ) ) ||
		IsBadWritePtr( pMarker, sizeof( MARKERINFO ) ))
		return E_POINTER;

	pMarker->timeEnd = timeEnd;

	// For each advisee, call IMarkerSink->EndMarker( pMarker )

	return S_OK;
}

HRESULT CMarkerSource::StartMarker(GUID &category, LPWSTR description, ULONGLONG timeStart, ULONG stream, MARKERINFO **ppMarker)
{
	MARKERINFO *	pMarker = new MARKERINFO;
	if (NULL == pMarker)
		return E_OUTOFMEMORY;

	pMarker->ulSize = sizeof( MARKERINFO );
	pMarker->categoryId = category;
	if (NULL != description)
	{
		pMarker->descriptionString = (LPWSTR) CoTaskMemAlloc( wcslen( description ) * sizeof( wchar_t ) );
		wcscpy( pMarker->descriptionString, description );
	}
	else
		pMarker->descriptionString = NULL;
	pMarker->timeStart = timeStart;
	pMarker->timeEnd   = -1;
	pMarker->streamId = stream;
	pMarker->pNextMarker = NULL;
	pMarker->pPrevMarker = NULL;

	// For each advisee, call IMarkerSink->StartMarker( pMarker )

	if ((NULL != ppMarker) && (!IsBadWritePtr( ppMarker, sizeof( MARKERINFO * ) )))
		*ppMarker = pMarker;
	else
	{
		if (NULL != pMarker->descriptionString)
			CoTaskMemFree( pMarker->descriptionString );
		delete pMarker;
	}

	return S_OK;
}

HRESULT CMarkerSource::NewMarker(GUID &category, LPWSTR description, ULONGLONG time, ULONG stream, MARKERINFO **ppMarker)
{
	MARKERINFO *	pMarker = new MARKERINFO;
	if (NULL == pMarker)
		return E_OUTOFMEMORY;

	pMarker->ulSize = sizeof( MARKERINFO );
	pMarker->categoryId = category;
	if (NULL != description)
	{
		pMarker->descriptionString = (LPWSTR) CoTaskMemAlloc( wcslen( description ) * sizeof( wchar_t ) );
		if (NULL != pMarker->descriptionString)
			wcscpy( pMarker->descriptionString, description );
	}
	else
		pMarker->descriptionString = NULL;
	pMarker->timeStart = time;
	pMarker->timeEnd   = 0;
	pMarker->streamId = stream;
	pMarker->pNextMarker = NULL;
	pMarker->pPrevMarker = NULL;

	// For each advisee, call IMarkerSink->NewMarker( pMarker )

	if ((NULL != ppMarker) && (!IsBadWritePtr( ppMarker, sizeof( MARKERINFO * ) )))
		*ppMarker = pMarker;
	else
	{
		if (NULL != pMarker->descriptionString)
			CoTaskMemFree( pMarker->descriptionString );
		delete pMarker;
	}

	return S_OK;
}

HRESULT
CMarkerSource::GetCategory( ULONG index, CATEGORYINFO **ppCategory )
{
	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\videlyzer\streamproc.cpp ===
// PESHeaderLocator.cpp: implementation of the CPESVideoProcessor class.
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include "StreamProcess.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\videlyzer\streamproc.h ===
// PESHeaderLocator.h: interface for the CPESVideoProcessor class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PESHEADERLOCATOR_H__B302990C_C065_11D2_A4F9_00C04F79A597__INCLUDED_)
#define AFX_PESHEADERLOCATOR_H__B302990C_C065_11D2_A4F9_00C04F79A597__INCLUDED_

#include "pesinfo.h"	// Added by ClassView
#include "PESHeader.h"	// Added by ClassView
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CDebugObject
{
public:
	virtual HRESULT	Output( char *format, ... ) = NULL;
};

class CStreamConsumer
{
public:
	virtual HRESULT Consume( BYTE *pBytes, LONG lCount, CDebugObject *pDebug = NULL ) = NULL;
	CStreamConsumer( void ) {}
	~CStreamConsumer( void ) {}
};

class CStreamProcessor
{
public:
	virtual BOOL Process( BYTE *pBuffer, LONG lCount, BYTE streamID, CStreamConsumer *pConsumer, CDebugObject *pDebug = NULL ) = NULL;
	CStreamProcessor( void ) {};
	~CStreamProcessor( void ) {};
};

#endif // !defined(AFX_PESHEADERLOCATOR_H__B302990C_C065_11D2_A4F9_00C04F79A597__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\videlyzer\pesheader.cpp ===
// PESHeader.cpp: implementation of the CPESHeader class.
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include "PESHeader.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPESHeader::CPESHeader( PES_HEADER &header ) :
	m_pHeader( NULL )
{
	m_pHeader = (PES_HEADER *) new BYTE [sizeof( PES_HEADER ) + header.PES_header_data[0]];
	memcpy( (void *) m_pHeader, (void *) &header, sizeof( PES_HEADER ) );
}

CPESHeader::~CPESHeader()
{
	if (m_pHeader)
		delete [] (BYTE *) m_pHeader;
}

BYTE * CPESHeader::Extension()
{
	return (BYTE *) m_pHeader->PES_header_data + 1;
}

ULONG CPESHeader::ExtensionSize()
{
	return (ULONG) m_pHeader->PES_header_data[0];
}

ULONG CPESHeader::StreamID()
{
	return (ULONG) m_pHeader->stream_id;
}

ULONG CPESHeader::PacketLength()
{
	ULONG	packetLength = (m_pHeader->PES_packet_length & 0xFF00) >> 8;
	packetLength |= (m_pHeader->PES_packet_length & 0xFF) << 8;
	
	return packetLength;
}

ULONGLONG CPESHeader::PTS()
{
	ULONGLONG	pts = 0;

	if (ptsPresent())
	{
		pts   = (m_pHeader->PES_header_data[1] & 0x0E) >> 1;
		pts <<= 8;
		pts  |= m_pHeader->PES_header_data[2];
		pts <<= 7;
		pts  |= (m_pHeader->PES_header_data[3] & 0xFE) >> 1;
		pts <<= 8;
		pts  |= m_pHeader->PES_header_data[4];
		pts <<= 7;
		pts  |= (m_pHeader->PES_header_data[5] & 0xFE) >> 1;
	}

	return pts;
}

ULONGLONG CPESHeader::DTS()
{
	ULONGLONG	dts = 0;

	if (dtsPresent())
	{
		dts   = (m_pHeader->PES_header_data[6] & 0x0E) >> 1;
		dts <<= 8;
		dts  |= m_pHeader->PES_header_data[7];
		dts <<= 7;
		dts  |= (m_pHeader->PES_header_data[8] & 0xFE) >> 1;
		dts <<= 8;
		dts  |= m_pHeader->PES_header_data[9];
		dts <<= 7;
		dts  |= (m_pHeader->PES_header_data[10] & 0xFE) >> 1;
	}

	return dts;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\videlyzer\pesheader.h ===
// PESHeader.h: interface for the CPESHeader class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PESHEADER_H__5952398A_C11E_11D2_A4F9_00C04F79A597__INCLUDED_)
#define AFX_PESHEADER_H__5952398A_C11E_11D2_A4F9_00C04F79A597__INCLUDED_

#include "pesinfo.h"

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CPESHeader  
{
public:
	ULONGLONG DTS( void );
	ULONGLONG PTS( void );
	inline BOOL dtsPresent( void ) { return (BOOL) (3 == (m_pHeader->PTS_DTS_flags & 0x03)); };
	inline BOOL ptsPresent( void ) { return (BOOL) (0 != (m_pHeader->PTS_DTS_flags & 0x02)); };
	ULONG PacketLength( void );
	ULONG StreamID( void );
	ULONG ExtensionSize( void );
	BYTE * Extension( void );
	PES_HEADER * m_pHeader;
	CPESHeader( PES_HEADER &header );
	virtual ~CPESHeader();

};

#endif // !defined(AFX_PESHEADER_H__5952398A_C11E_11D2_A4F9_00C04F79A597__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\videlyzer\videlyzer.h ===
#include "pesinfo.h"
#include "timeshift.h"
#include "pesheader.h"
#include "VideoInputPin.h"
#include "VideoOutputPin.h"
#include "DebugPin.h"

class CVidelyzerFilter : public CBaseFilter
{
protected:
	BYTE m_startCode[4];
	enum STATES {
		CLEAN,
		ONEOH,
		TWOOHS,
		OHOHONE,
		PESHEADER,
		EXTENSION,
		SEQHEADER,
	} m_state;
	HRESULT NewBuffer( void );

public:
	CMediaType m_mediaType;
	BOOL m_bOutputPES;
	ULONGLONG m_pts;
	HRESULT Consume( BYTE *pBytes, LONG lCount );
	IMediaSample * m_pMediaSample;
	HRESULT SetPTS( ULONGLONG pts );
	HRESULT SetSyncPoint( void );
	HRESULT Flush( void );

	CPESHeader *m_pCurrentHeader;
	PES_HEADER m_staticHeader;
	ULONG m_bytesOutstanding;
	BOOL Process( BYTE *pBuffer, LONG lCount, BYTE streamID );

	BOOL m_bPESAvailable;
	ULONG m_ulMaxBPS;
	ULONG m_ulMinBPS;
	CCritSec m_csFilter;
	HRESULT Process( IMediaSample *pSample );
	static CUnknown * CALLBACK	CreateInstance( LPUNKNOWN, HRESULT * );

	CVidelyzerFilter( LPUNKNOWN, HRESULT * );
	~CVidelyzerFilter( void );

	HRESULT	DecideBufferSize( IMemAllocator *pAllocator, ALLOCATOR_PROPERTIES *pprop );
	class CBasePin *	GetPin( int n );
	int					GetPinCount( void );

	HRESULT	SetMediaType( PIN_DIRECTION direction, const CMediaType *pmt );

	VIDEOINFOHEADER	m_vih;

	CVideoInputPin m_inputPin;
	CVideoOutputPin m_outputPin;
	CDebugOutputPin m_debugPin;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\analysis\dvranalysisutil\dvranalysisutil.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrutil.cpp

    Abstract:

        This module the ts/dvr-wide utility code; compiles into a .LIB

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#include "dvrall.h"
#include "dvranalysis.h"
#include "dvranalysisutil.h"

HRESULT
CopyDVRAnalysisDescriptor (
    IN  LONG                    lCount,
    IN  DVR_ANALYSIS_DESC_INT * pDVRAnalysisDescIntMaster,
    OUT DVR_ANALYSIS_DESC **    ppDVRAnalysisDescCopy
    )
{
    HRESULT hr ;
    LONG    i ;

    ASSERT (lCount > 0) ;
    ASSERT (pDVRAnalysisDescIntMaster) ;
    ASSERT (ppDVRAnalysisDescCopy) ;

    hr = S_OK ;

    (* ppDVRAnalysisDescCopy) = reinterpret_cast <DVR_ANALYSIS_DESC *> (CoTaskMemAlloc (lCount * sizeof DVR_ANALYSIS_DESC)) ;

    if (* ppDVRAnalysisDescCopy) {
        for (i = 0; i < lCount; i++) {

            //  analysis GUID
            (* ppDVRAnalysisDescCopy) [i].guidAnalysis = (* pDVRAnalysisDescIntMaster [i].pguidAnalysis) ;

            //  descriptive string
            ASSERT (pDVRAnalysisDescIntMaster [i].pszDescription) ;
            (* ppDVRAnalysisDescCopy) [i].pszDescription = reinterpret_cast <LPWSTR> (
                CoTaskMemAlloc ((wcslen (pDVRAnalysisDescIntMaster [i].pszDescription) + 1) * sizeof WCHAR)
                ) ;
            if ((* ppDVRAnalysisDescCopy) [i].pszDescription) {
                wcscpy (
                    (* ppDVRAnalysisDescCopy) [i].pszDescription,
                    pDVRAnalysisDescIntMaster [i].pszDescription
                    ) ;
            }
            else {
                FreeDVRAnalysisDescriptor (
                    i,
                    (* ppDVRAnalysisDescCopy)
                    ) ;

                hr = E_OUTOFMEMORY ;

                break ;
            }
        }
    }
    else {
        hr = E_OUTOFMEMORY ;
    }

    return hr ;
}

void
FreeDVRAnalysisDescriptor (
    IN  LONG                    lCount,
    IN  DVR_ANALYSIS_DESC *     pDVRAnalysisDesc
    )
{
    LONG    i ;

    for (i = 0; i < lCount; i++) {
        CoTaskMemFree (pDVRAnalysisDesc [i].pszDescription) ;
    }

    CoTaskMemFree (pDVRAnalysisDesc) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\videlyzer\vidoutpin.cpp ===
/*******************************************************************************
**
**     VideoOutputPin.cpp - Implementation of CVideoOutputPin
**
**     1.0     26-MAR-1999     C.Lorton     Created out of Videlyzer.cpp
**
*******************************************************************************/

#include <streams.h>
#include <dvdmedia.h>
#include "VideoOutputPin.h"
#include "Videlyzer.h"

// Note, all MEDIATYPE_MPEG2_PES major format types must come at the end
// of the list.  This is to support CVideoOutputPin::GetMediaType().

AMOVIESETUP_MEDIATYPE sudOutputTypes[] =
{
    {
        &MEDIATYPE_Video,
        &MEDIASUBTYPE_MPEG2_VIDEO
    },
	{
		&MEDIATYPE_MPEG2_PES,
		&MEDIASUBTYPE_MPEG2_VIDEO
	}
};

UINT32 numOutputTypes = NUMELMS( sudOutputTypes );

CVideoOutputPin::CVideoOutputPin( TCHAR *pObjectName, CVidelyzerFilter *pFilter,
								  CCritSec *pLock, HRESULT *phr, LPCWSTR pPinName ) :
	CBaseOutputPin( pObjectName, (CBaseFilter *) pFilter, pLock, phr, pPinName ),
	m_pVidFilter( pFilter )
{
} // CVideoOutputPin::CVideoOutputPin

HRESULT
CVideoOutputPin::CheckMediaType(const CMediaType *pmt)
{
	UINT32	iPosition;

	for ( iPosition = 0; iPosition < numOutputTypes; iPosition++ )

		/* Check that we have a valid major type (in general)
		** Check that either PES is available or the requested major type is not PES
		** Check that we have a valid sub type
		** Check that our formats match in type
		** Check that our formats match in content
		*/

		if ((pmt->majortype == *sudOutputTypes[iPosition].clsMajorType) &&
			(m_pVidFilter->m_bPESAvailable || (MEDIATYPE_MPEG2_PES != pmt->majortype)) &&
			(pmt->subtype == *sudOutputTypes[iPosition].clsMinorType) &&
			(pmt->formattype == m_pVidFilter->m_mediaType.formattype)) // &&
//				(pmt->cbFormat == m_pVidFilter->m_mediaType.cbFormat) &&
//				(0 == memcmp( pmt->pbFormat, m_pVidFilter->m_mediaType.pbFormat, pmt->cbFormat )))
		{
			return S_OK;
		} // if (type and subtype match)

	return S_FALSE;
} // CVideoOutputPin::CheckMediaType

HRESULT
CVideoOutputPin::CompleteConnection(IPin *pPin)
{
	HRESULT	hr = CBaseOutputPin::CompleteConnect( pPin );

	if (SUCCEEDED( hr ))
	{
		hr = m_pVidFilter->SetMediaType( PINDIR_OUTPUT, &m_mt );
	}

	return hr;
} // CVideoOutputPin::CompleteConnection

HRESULT
CVideoOutputPin::DecideBufferSize(IMemAllocator *pAlloc, ALLOCATOR_PROPERTIES *pProps)
{
	return m_pVidFilter->DecideBufferSize( pAlloc, pProps );
} // CVideoOutputPin::DecideBufferSize

STDMETHODIMP
CVideoOutputPin::GetBitRates( ULONG *plMinBPS, ULONG *plMaxBPS )
{
	*plMinBPS = m_pVidFilter->m_ulMinBPS;
	*plMaxBPS = m_pVidFilter->m_ulMaxBPS;

	return S_OK;
} // CVideoOutputPin::GetBitRates

HRESULT
CVideoOutputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
	HRESULT	hr = VFW_S_NO_MORE_ITEMS;

	switch (iPosition)
	{
	case 0:
		// This gets the format contents into the mediatype
		*pMediaType = m_pVidFilter->m_mediaType;
		pMediaType->SetType( &MEDIATYPE_Video );
		hr = S_OK;
		break;

	case 1:
		if (m_pVidFilter->m_bPESAvailable)
		{
			// This gets the format contents into the mediatype
			*pMediaType = m_pVidFilter->m_mediaType;
			pMediaType->SetType( &MEDIATYPE_MPEG2_PES );
			hr = S_OK;
		} // if (m_pVidFilter->m_bPESAvailable)
		break;

	default:
		break;
	}

/***
	if (0 == iPosition)
	{
		pMediaType->InitMediaType();
		AM_MEDIA_TYPE	mt;
		if (SUCCEEDED( hr = m_pVidFilter->m_inputPin.ConnectionMediaType( &mt ) ))
		{
			*pMediaType = mt;
			FreeMediaType( mt );
			pMediaType->SetType( &MEDIATYPE_Video );
			hr = S_OK;
		}
	}
	else if (m_pVidFilter->m_bPESAvailable)
	{
		pMediaType->InitMediaType();
		AM_MEDIA_TYPE	mt;
		if (SUCCEEDED( hr = m_pVidFilter->m_inputPin.ConnectionMediaType( &mt ) ))
		{
			*pMediaType = mt;
			FreeMediaType( mt );
			pMediaType->SetType( &MEDIATYPE_MPEG2_PES );
			hr = S_OK;
		}
	}
***/

	return hr;
} // CVideoOutputPin::GetMediaType

STDMETHODIMP
CVideoOutputPin::HasSyncPoints( BOOL *pbHasSyncPoints, REFERENCE_TIME *pFrequency )
{
	*pbHasSyncPoints = TRUE;
	*pFrequency = 5000000; // 0.5 seconds in 100ns units

	return S_OK;
} // CVideoOutputPin::HasSyncPoints
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\analysis\dvranalysisutil\dvranalysisutil.h ===
#ifndef __dvranalysisutil_h
#define __dvranalysisutil_h

struct DVR_ANALYSIS_DESC_INT {
    const GUID *    pguidAnalysis ;
    LPWSTR          pszDescription ;
} ;

HRESULT
CopyDVRAnalysisDescriptor (
    IN  LONG                    lCount,
    IN  DVR_ANALYSIS_DESC_INT * pDVRAnalysisDescMaster,
    OUT DVR_ANALYSIS_DESC **    ppDVRAnalysisDescCopy
    ) ;

void
FreeDVRAnalysisDescriptor (
    IN  LONG                    lCount,
    IN  DVR_ANALYSIS_DESC *     pDVRAnalysisDesc
    ) ;

#endif  //  __dvranalysisutil_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\videlyzer\videoinpin.h ===
/*******************************************************************************
**
**     VideoInputPin.h - Declaration of CVideoInputPin
**
**     1.0     26-MAR-1999     C.Lorton     Created out of Videlyzer.h
**
*******************************************************************************/

#ifndef _VIDEOINPUTPIN_H_
#define _VIDEOINPUTPIN_H_

class CVidelyzerFilter;

class CVideoInputPin : public CBaseInputPin
{
public:
	HRESULT GetMediaType( int iPosition, CMediaType *pMediaType );
	HRESULT CompleteConnect( IPin *pPin );
	STDMETHODIMP Receive( IMediaSample *pSample );
	HRESULT CheckMediaType( const CMediaType *pmt );
	CVidelyzerFilter * m_pVidFilter;
	CVideoInputPin( TCHAR *pObjectName, CVidelyzerFilter *pFilter,
					CCritSec *pLock, HRESULT *phr, LPCWSTR pPinName );
};

#endif // _VIDEOINPUTPIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\analysis\filtercf\dvranalysisfiltercf.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvranalysisfiltercf.cpp

    Abstract:

        This module contains

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        19-Feb-2001     created

--*/

#include "dvrall.h"

#include "dvranalysis.h"
#include "dvranalysisfiltercf.h"

STDMETHODIMP
CDVRAnalysisFilterCF::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    if (riid == IID_IDVRAnalysisFilterHostFactory) {

        return GetInterface (
                    (IDVRAnalysisFilterHostFactory *) this,
                    ppv
                    ) ;
    }

    return CUnknown::NonDelegatingQueryInterface (riid, ppv) ;
}

HRESULT
CDVRAnalysisFilterCF::InstantiateFilterHost (
    IN  IUnknown *  punkAnalysisLogic,
    IN  LPCWSTR     pszLogicName,
    OUT IUnknown ** ppunkAnalysisHostFilter
    )
{
    return E_NOTIMPL ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\videlyzer\videoinpin.cpp ===
/*******************************************************************************
**
**     VideoInputPin.cpp - Implementation of CVideoInputPin
**
**     1.0     26-MAR-1999     C.Lorton     Created out of Videlyzer.cpp
**
*******************************************************************************/

#include <streams.h>
#include <dvdmedia.h>
#include "VideoInputPin.h"
#include "Videlyzer.h"

AMOVIESETUP_MEDIATYPE sudInputTypes[] =
{
	{
		&MEDIATYPE_MPEG2_PES,
		&MEDIASUBTYPE_MPEG2_VIDEO
	},
    {
        &MEDIATYPE_Video,
        &MEDIASUBTYPE_MPEG2_VIDEO
    }
};

UINT32 numInputTypes = NUMELMS( sudInputTypes );

CVideoInputPin::CVideoInputPin( TCHAR *pObjectName, CVidelyzerFilter *pFilter,
							    CCritSec *pLock, HRESULT *phr, LPCWSTR pPinName ) :
	CBaseInputPin( pObjectName, (CBaseFilter *) pFilter, pLock, phr, pPinName ),
	m_pVidFilter( pFilter )
{
} // CVideoInputPin::CVideoInputPin

HRESULT
CVideoInputPin::CheckMediaType(const CMediaType *pmt)
{
	int	iPosition;

	for (iPosition = 0; iPosition < NUMELMS(sudInputTypes); iPosition++)
		if ((*(pmt->Type()) == *(sudInputTypes[iPosition].clsMajorType)) &&
			(*(pmt->Subtype()) == *(sudInputTypes[iPosition].clsMinorType))) {

			return S_OK;
		} // if (type and subtype match)

	return S_FALSE;
} // CVideoInputPin::CheckMediaType

HRESULT
CVideoInputPin::CompleteConnect(IPin *pPin)
{
	HRESULT	hr = CBaseInputPin::CompleteConnect( pPin );

	if (SUCCEEDED( hr ))
	{
		hr = m_pVidFilter->SetMediaType( PINDIR_INPUT, &m_mt );
	}

	return hr;
} // CVideoInputPin::CompleteConnect

HRESULT
CVideoInputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
	if (iPosition < NUMELMS(sudInputTypes)) {
		pMediaType->InitMediaType();
		pMediaType->SetType(sudInputTypes[iPosition].clsMajorType);
		pMediaType->SetSubtype(sudInputTypes[iPosition].clsMinorType);

		return S_OK;
	}

	return VFW_S_NO_MORE_ITEMS;
} // CVideoInputPin::GetMediaType

STDMETHODIMP
CVideoInputPin::Receive(IMediaSample *pSample)
{
	return m_pVidFilter->Process( pSample );
} // CVideoInputPin::Receive
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\analysis\filtercf\dvranalysisfiltercf.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        DVRAnalysisFilterCF.h

    Abstract:

        This module contains the COM server that instantiates an analysis
         filter host i.e. a generic filter that hosts the analysis logic
         component.  Analysis logic component instantiates this filter in
         its class factory.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        19-Feb-2001     created

--*/

#ifndef __analysis__dvranalysisfiltercf_h
#define __analysis__dvranalysisfiltercf_h

class CDVRAnalysisFilterCF :
    public CUnknown,
    public IDVRAnalysisFilterHostFactory
{
    public :

        CDVRAnalysisFilterCF (
            IN  IUnknown *  punkControlling,
            OUT HRESULT *   phr
            ) : CUnknown    (TEXT ("CDVRAnalysisFilterCF"),
                             punkControlling
                             )
        {
            (* phr) = S_OK ;
        }

        ~CDVRAnalysisFilterCF (
            ) {}

        DECLARE_IUNKNOWN ;
        DECLARE_IDVRANALYSISFILTERHOSTFACTORY () ;

        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  pIUnknown,
            IN  HRESULT *   phr
            )
        {
            CDVRAnalysisFilterCF *  pIDVRHost ;

            pIDVRHost = new CDVRAnalysisFilterCF (
                            pIUnknown,
                            phr
                            ) ;
            if (FAILED (* phr) ||
                !pIDVRHost) {
                (* phr) = (FAILED (* phr) ? (* phr) : E_OUTOFMEMORY) ;
                DELETE_RESET (pIDVRHost) ;
            }

            return pIDVRHost ;
        }
} ;

#endif  //  #define __analysis__dvranalysisfiltercf_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\videlyzer\videooutpin.h ===
/*******************************************************************************
**
**     VideoOutputPin.h - Declaration of CVideoOutputPin
**
**     1.0     26-MAR-1999     C.Lorton     Created out of Videlyzer.h
**
*******************************************************************************/

#ifndef _VIDEOOUTPUTPIN_H_
#define _VIDEOOUTPUTPIN_H_

#include <timeshift.h>

class CVidelyzerFilter;

class CVideoOutputPin : public CBaseOutputPin, public IAnalyzerOutputPin
{
public:
	HRESULT CompleteConnection( IPin *pPin );
	HRESULT GetMediaType( int iPosition, CMediaType *pMediaType );
	HRESULT DecideBufferSize( IMemAllocator *pAlloc, ALLOCATOR_PROPERTIES *pProps );
	HRESULT CheckMediaType( const CMediaType *pmt );
	CVidelyzerFilter * m_pVidFilter;
	CVideoOutputPin( TCHAR *pObjectName, CVidelyzerFilter *pFilter,
					 CCritSec *pLock, HRESULT *phr, LPCWSTR pPinName);

	// IAnalyzerOutputPin
	DECLARE_IUNKNOWN
	STDMETHODIMP	GetBitRates( ULONG *lMinBitsPerSecond, ULONG *lMaxBitsPerSecond );
	STDMETHODIMP	HasSyncPoints( BOOL *pbHasSyncPoints, REFERENCE_TIME *pFrequency );
};

#endif // _VIDEOOUTPUTPIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\timeshift\videlyzer\videlyzer.cpp ===
#include <streams.h>
#include <initguid.h> 
#include <dvdmedia.h>
#include "videlyzer.h"
#include <stdio.h>
#include <tchar.h>

// {ABC24608-B7C8-11d2-A4F7-00C04F79A597}
DEFINE_GUID(CLSID_VidelyzerFilter,0xabc24608, 0xb7c8, 0x11d2, 0xa4, 0xf7, 0x00, 0xc0, 0x4f, 0x79, 0xa5, 0x97);

extern AMOVIESETUP_MEDIATYPE sudInputTypes[];
extern UINT32 numInputTypes;

extern AMOVIESETUP_MEDIATYPE sudOutputTypes[];
extern UINT32 numOutputTypes;

extern AMOVIESETUP_MEDIATYPE sudDebugTypes[];
extern UINT32 numDebugTypes;

static AMOVIESETUP_PIN RegistrationPinInfo[] =
{
    { // input
        L"PES video input",
        FALSE, // bRendered
        FALSE, // bOutput
        FALSE, // bZero
        FALSE, // bMany
        &CLSID_NULL, // clsConnectsToFilter
        NULL, // ConnectsToPin
        numInputTypes, // nMediaTypes
        sudInputTypes
    },
    { // output
        L"video output",
        FALSE, // bRendered
        TRUE, // bOutput
        FALSE, // bZero
        FALSE, // bMany
        NULL, // clsConnectsToFilter
        NULL, // ConnectsToPin
        numOutputTypes, // nMediaTypes
        sudOutputTypes // lpMediaType
    },
#ifdef DEBUG
    { // output
        L"debug output",
        FALSE, // bRendered
        TRUE, // bOutput
        FALSE, // bZero
        FALSE, // bMany
        NULL, // clsConnectsToFilter
        NULL, // ConnectsToPin
        numDebugTypes, // nMediaTypes
        sudDebugTypes // lpMediaType
    }
#endif // DEBUG
};

AMOVIESETUP_FILTER RegistrationInfo =
{
    &CLSID_VidelyzerFilter,
    L"PES Video Analyzer",
    MERIT_UNLIKELY, // merit
    NUMELMS(RegistrationPinInfo), // nPins
    RegistrationPinInfo
};

CFactoryTemplate g_Templates[] =
{
    {
        L"PES Video Analyzer",
        &CLSID_VidelyzerFilter,
        CVidelyzerFilter::CreateInstance,
        NULL,
        &RegistrationInfo
    }
};

int g_cTemplates = NUMELMS(g_Templates);

STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}

/* CVidelyzerFilter ***********************************************************/

CUnknown * CALLBACK
CVidelyzerFilter::CreateInstance( LPUNKNOWN UnkOuter, HRESULT* hr )
{
    CUnknown *Unknown;

    *hr = S_OK;
    Unknown = new CVidelyzerFilter( UnkOuter, hr );
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} // CVidelyzerFilter::CreateInstance

#pragma warning(disable:4355)

CVidelyzerFilter::CVidelyzerFilter( LPUNKNOWN UnkOuter, HRESULT* hr ) :
	CBaseFilter(
        TEXT("PES Video Analyzer CBaseFilter"),
        UnkOuter,
		&m_csFilter,
        CLSID_VidelyzerFilter,
		hr
    ),
	m_bPESAvailable( FALSE ),
	m_inputPin( TEXT("PES Video Analyzer PES Video Input Pin"),
				this, &m_csFilter, hr, L"[PES] video in" ),
	m_outputPin( TEXT("PES Video Analyzer Video Output Pin"),
				 this, &m_csFilter, hr, L"[PES] video out" ),
	m_debugPin( TEXT("PES Video Analyzer Debug Output Pin" ),
				this, &m_csFilter, hr, L"debug out" ),
	m_ulMaxBPS( 0 ),
	m_ulMinBPS( 0 ),
	m_state( CLEAN ),
	m_bytesOutstanding( 0 ),
	m_pCurrentHeader( NULL ),
	m_pMediaSample( NULL ),
	m_pts( 0 )
{
	memset( (void *) &m_staticHeader, 0, sizeof( PES_HEADER ) );
	m_staticHeader.packet_start_code_prefix[2] = 0x01;
	memset( (void *) m_startCode, 0, sizeof( m_startCode ) );
	m_startCode[2] = 0x01;
} // CVidelyzerFilter::CVidelyzerFilter

CVidelyzerFilter::~CVidelyzerFilter()
{
	if (NULL != m_pMediaSample)
	{
		m_pMediaSample->Release();
		m_pMediaSample = NULL;
	}
} // CVidelyzerFilter::~CVidelyzerFilter

HRESULT
CVidelyzerFilter::Consume(BYTE *pBytes, LONG lCount )
{
	if (NULL == m_pMediaSample)
		NewBuffer();

	while ((NULL != m_pMediaSample) && (0 < lCount))
	{
		BYTE	*pBuffer = NULL;
		m_pMediaSample->GetPointer( &pBuffer );
		LONG	lSize  = m_pMediaSample->GetSize();
		LONG	lActual = m_pMediaSample->GetActualDataLength();

		LONG	lAvailable = lSize - lActual;
		LONG	lToWrite = lCount > lAvailable ? lAvailable : lCount;

		memcpy( pBuffer + lActual, pBytes, lToWrite );

		lCount -= lToWrite;
		lActual += lToWrite;
		lAvailable = lSize - lActual;
		m_pMediaSample->SetActualDataLength( lActual );

		if (0 == lAvailable)
		{
/*
			{
				REFERENCE_TIME	time = -1, dummy;
				m_pMediaSample->GetTime( &time, &dummy );
				TCHAR	msg[128];
				_stprintf( msg, _T("Video media sample- PTS= %I64d\n"), (__int64) time );
				DbgLog((LOG_TRACE, 4, msg));
			}
*/
			m_outputPin.Deliver( m_pMediaSample );
//			DbgLog((LOG_TRACE|LOG_ERROR, 3, _T("Delivered media sample early.\n")));
#ifdef DEBUG
			m_debugPin.Output( "Delivered media sample\n" );
#endif // DEBUG
			NewBuffer();
		} // 0 == lAvailable
	} // while ((NULL != m_pMediaSample) && (0 < lCount))

	return 0 == lCount ? S_OK : E_FAIL;
} // CVidelyzerFilter::Consume

HRESULT
CVidelyzerFilter::DecideBufferSize( IMemAllocator *pAllocator, ALLOCATOR_PROPERTIES *pprop )
{
	if (m_inputPin.IsConnected())
	{
		/*
		** We'll use the settings provided from the upstream filter...
		*/
		IMemAllocator	*pUpStreamAllocator = NULL;
		m_inputPin.GetAllocator( &pUpStreamAllocator );
		ALLOCATOR_PROPERTIES	propsUpstream;
		pUpStreamAllocator->GetProperties( &propsUpstream );
		pUpStreamAllocator->Release();

//		pprop->cbBuffer = propsUpstream.cbBuffer;
		pprop->cbBuffer = 0x00030000;
		pprop->cBuffers = propsUpstream.cBuffers;

		ALLOCATOR_PROPERTIES	propsActual;
		HRESULT	hr = pAllocator->SetProperties(pprop, &propsActual);
		if (SUCCEEDED(hr))
		{
			if ((propsActual.cbBuffer == 0) || (propsActual.cBuffers == 0))
				return E_FAIL;
			else
				return NOERROR;
		}
		else              
			return hr;
	}

	return E_FAIL;
} // CVidelyzerFilter::DecideBufferSize

HRESULT
CVidelyzerFilter::Flush()
{
	HRESULT	hr = E_FAIL;

	if (NULL != m_pMediaSample)
	{
		LONG	lActual = m_pMediaSample->GetActualDataLength();
		if (0 < lActual)
		{
/*
			{
				REFERENCE_TIME	time = -1, dummy;
				m_pMediaSample->GetTime( &time, &dummy );
				TCHAR	msg[128];
				_stprintf( msg, _T("Video media sample- PTS= %I64d\n"), (__int64) time );
				DbgLog((LOG_TRACE, 4, msg));
			}
*/
			HRESULT	hr = m_outputPin.Deliver( m_pMediaSample );
			NewBuffer();
		}
		else
			hr = S_OK;
	}

	return hr;
} // CVidelyzerFilter::Flush

class CBasePin *
CVidelyzerFilter::GetPin(int nPin)
{
    switch (nPin)
	{
        case 0: return &m_inputPin;

		case 1: 
#ifndef DEBUG
			// No debug pin, are we connected?
			return m_inputPin.IsConnected() ? &m_outputPin : NULL;
#else
			// Return debug pin
			return &m_debugPin;
#endif // DEBUG

        case 2: // Should only be here when we have a debug pin
#ifdef DEBUG
			return m_inputPin.IsConnected() ? &m_outputPin : NULL;
#else
			// No debug pin, pin index 2 is invalid
			return NULL;
#endif // DEBUG

        default: return NULL;
    }
} // CVidelyzerFilter::GetPin

int
CVidelyzerFilter::GetPinCount(void)
{
#ifndef DEBUG
	return m_inputPin.IsConnected() ? 2 : 1;
#else
	return m_inputPin.IsConnected() ? 3 : 2;
#endif // DEBUG
} // CVidelyzerFilter::GetPinCount

HRESULT
CVidelyzerFilter::NewBuffer()
{
	if (NULL != m_pMediaSample)
	{
		m_pMediaSample->Release();
		m_pMediaSample = NULL;
	}

	HRESULT	hr = m_outputPin.GetDeliveryBuffer( &m_pMediaSample, NULL, NULL, 0 );
	if (SUCCEEDED(hr))
	{
		REFERENCE_TIME	refTime = (REFERENCE_TIME) m_pts;
		// m_pts is in 90kHz clock ticks
		// refTime is in 100ns clock ticks
		// time in seconds (tis) = m_pts / 90,000
		// refTime = tis * 10^7
		// refTime = (m_pts / 90,000) * 10,000,000
		// refTime = (m_pts / 9) * 1,000 = m_pts * 1000 / 9;
		refTime *= 1000;
		refTime /= 9;
		m_pMediaSample->SetTime( &refTime, NULL );
		m_pMediaSample->SetActualDataLength( 0L );
	}
	return hr;
} // CVidelyzerFilter::NewBuffer

BOOL
CVidelyzerFilter::Process( BYTE *pBuffer, LONG bufferSize, BYTE streamID )
{
	BYTE	*pGuard = pBuffer + bufferSize;
	BYTE	*pScan = pBuffer;

	LONG	hdrSize = sizeof( PES_HEADER );
	LONG	skipped = 0L;

	while (pScan < pGuard)
	{
		switch (m_state)
		{
		case CLEAN:
			{
				if (0 == *pScan)
				{
					// Found a single 0x00
					if (0 < skipped)
					{
						Consume( pScan - skipped, skipped );
						skipped = 0;
					} // 0 < skipped
					pScan++;
					m_state = ONEOH;
				} // 0 == *pScan
				else
				{
					// Emit current *pScan
					pScan++;
					skipped++;
					// m_state = CLEAN;
				} // 0 != *pScan
			} // CLEAN
			break;

		case ONEOH:
			{
				if (0 == *pScan)
				{
					// Now we've found 0x00 0x00
					pScan++;
					m_state = TWOOHS;
				} // 0 == *pScan
				else
				{
					// Emit an 0x00 and *pScan before returning to CLEAN state
					Consume( m_startCode, 1 );
					Consume( pScan++, 1 );
					m_state = CLEAN;
				} // 0 != *pScan
			} // ONEOH
			break;

		case TWOOHS:
			{
				switch (*pScan)
				{
				case 1:
					{
						// Now we've found 0x00 0x00 0x01
						pScan++;
						m_state = OHOHONE;
					} // case 1
					break;

				case 0:
					{
						// Emit an 0x00 before continuing
						Consume( pScan++, 1 );
						m_state = TWOOHS;
					} // case 0
					break;

				default:
					{
						// Emit 0x00, 0x00 and *pScan before returning to CLEAN state
						Consume( m_startCode, 2 );
						Consume( pScan++, 1 );
						m_state = CLEAN;
					} // default
					break;
				} // switch (*pScan)
			} // TWOOHS
			break;

		case OHOHONE:
			{
				switch (*pScan)
				{
				case 0xB3: // Sequence Header
					{
						// Send current media sample, if not empty
						// Start new media sample, setting its SyncPoint flag
						// emit 4 bytes consumed while identifying the header
						// return to CLEAN state
/*
						((CPESVideoConsumer *) pConsumer)->Flush();
*/
						SetSyncPoint();
						Consume( m_startCode, 3 );
						Consume( pScan++, 1 );

						m_state = CLEAN;
					} // case 0xB3
					break;

				default:
					{
						if (streamID == *pScan)
						{
							// Now we've found 0x00 0x00 0x01 followed by streamID
							m_staticHeader.stream_id = *pScan++;
							m_bytesOutstanding = sizeof( PES_HEADER ) - 4;
							m_state = PESHEADER;
						} // streamID == *pScan
						else
						{
							// Emit 0x00, 0x00, 0x01 and the current *pScan before continuing
							Consume( m_startCode, 3 );
							Consume( pScan++, 1 );
							m_state = CLEAN;
						} // streamID != *pScan
					} // default
					break;
				} // switch (*pScan)
			} // OHOHONE
			break;

		case PESHEADER:
			{
				ULONG	bytesToCopy = m_bytesOutstanding;
				if ((ULONG) (pGuard - pScan) < bytesToCopy)
					bytesToCopy = (ULONG) (pGuard - pScan);
				BYTE	*pDst = (BYTE *) &m_staticHeader.PES_packet_length;
				pDst += (sizeof( PES_HEADER ) - 4) - m_bytesOutstanding;
				memcpy( (void *) pDst, pScan, bytesToCopy );
				pScan += bytesToCopy;
				m_bytesOutstanding -= bytesToCopy;
				if (0 == m_bytesOutstanding)
				{
					m_bytesOutstanding = m_staticHeader.PES_header_data[0];
					if (NULL != m_pCurrentHeader)
					{
						delete m_pCurrentHeader;
						m_pCurrentHeader = NULL;
					}
					m_pCurrentHeader = new CPESHeader( m_staticHeader );
					m_state = EXTENSION;
				} // 0 == m_bytesOutstanding
			} // HEADER
			break;

		case EXTENSION:
			{
				ULONG	bytesToCopy = m_bytesOutstanding;
				if ((ULONG) (pGuard - pScan) < bytesToCopy)
					bytesToCopy = (ULONG) (pGuard - pScan);
				BYTE	*pDst = m_pCurrentHeader->Extension();
				pDst += m_pCurrentHeader->ExtensionSize() - m_bytesOutstanding;
				memcpy( (void *) pDst, pScan, bytesToCopy );
				pScan += bytesToCopy;
				m_bytesOutstanding -= bytesToCopy;
				if (0 == m_bytesOutstanding)
				{
					// Found header
					if (m_pCurrentHeader->ptsPresent())
					{
						Flush();
						SetPTS( m_pCurrentHeader->PTS() );
						{
							TCHAR	msg[128];
							_stprintf( msg, "PTS %I64d\n", m_pCurrentHeader->PTS() );
//							DbgLog((LOG_TRACE, 0, msg ));
#ifdef DEBUG
							m_debugPin.Output( msg );
#endif // DEBUG
						}
					} // m_pCurrentHeader->ptsPresent()
/*
#ifdef DEBUG
					if (m_pCurrentHeader->dtsPresent())
					{
						TCHAR	msg[128];
						_stprintf( msg, "DTS %I64d\n", m_pCurrentHeader->DTS() );
						DbgLog((LOG_TRACE, 0, msg ));
					}
#endif // DEBUG
*/
					if (m_bOutputPES)
					{
						Consume( (BYTE *) (PES_HEADER *) m_pCurrentHeader, sizeof( PES_HEADER ) );
						Consume( (BYTE *) m_pCurrentHeader->Extension(), m_pCurrentHeader->ExtensionSize() );
					} // m_bOutputPES
					m_state = CLEAN;
				} // 0 == m_bytesOutstanding
			} // EXTENSION
			break;

		case SEQHEADER:
			// drop through

		default:
			ASSERT( (CLEAN <= m_state) && (m_state <= EXTENSION) );
			break;
		} // switch (m_state)
	} // while (pScan < pGuard)

	if (0 < skipped)
	{
		Consume( pScan - skipped, skipped );
		skipped = 0;
	} // 0 < skipped

//	Flush();

	return TRUE;
} // CVidelyzerFilter::Process

HRESULT
CVidelyzerFilter::Process(IMediaSample *pSample)
{
	BYTE	*pBuffer = NULL;
	pSample->GetPointer( &pBuffer );
	LONG	lSize = pSample->GetActualDataLength();
#ifdef DEBUG
	{
		__int64	msTime, mTime, dummy;
		pSample->GetTime( &msTime, &dummy );
		pSample->GetMediaTime( &mTime, &dummy );
		m_debugPin.Output( "Media Sample: time- %I64d media time- %I64d payload- %d\n", msTime, mTime, lSize );
	}
#endif // DEBUG
	return Process( pBuffer, lSize, 0xE0 ) ? S_OK : E_FAIL;
} // CVidelyzerFilter::Process

HRESULT
CVidelyzerFilter::SetMediaType(PIN_DIRECTION direction, const CMediaType *pmt)
{
	switch (direction)
	{
	case PINDIR_INPUT:
//		m_bPESAvailable = (MEDIATYPE_MPEG2_PES == pmt->majortype);
		m_bPESAvailable = TRUE;

		m_mediaType = *pmt;
		m_mediaType.SetFormatType( &FORMAT_MPEG2Video );

		if ((FORMAT_VideoInfo == pmt->formattype) && 
			(NULL != (VIDEOINFOHEADER *) (pmt->pbFormat)))
		{
			MPEG2VIDEOINFO	mpegInfo;

			mpegInfo.cbSequenceHeader    = 0;
			mpegInfo.dwFlags             = 0;
			mpegInfo.dwLevel             = AM_MPEG2Level_Low;
			mpegInfo.dwProfile           = AM_MPEG2Profile_Simple;
			mpegInfo.dwSequenceHeader[0] = 0;
			mpegInfo.dwStartTimeCode     = 0;
			VIDEOINFOHEADER	* pVIH = (VIDEOINFOHEADER *) pmt->pbFormat;
			mpegInfo.hdr.AvgTimePerFrame    = pVIH->AvgTimePerFrame;
			mpegInfo.hdr.bmiHeader          = pVIH->bmiHeader;
			mpegInfo.hdr.dwBitErrorRate     = pVIH->dwBitErrorRate;
			mpegInfo.hdr.dwBitRate          = pVIH->dwBitRate;
			mpegInfo.hdr.dwCopyProtectFlags = 0;
			mpegInfo.hdr.dwInterlaceFlags   = 0;
			mpegInfo.hdr.dwPictAspectRatioX = 16; //4; //16;
			mpegInfo.hdr.dwPictAspectRatioY = 9; //3; //9;
			mpegInfo.hdr.dwReserved1        = 0;
			mpegInfo.hdr.dwReserved2        = 0;
			mpegInfo.hdr.rcSource	          = pVIH->rcSource;
			mpegInfo.hdr.rcTarget           = pVIH->rcTarget;

			m_mediaType.SetFormat( (BYTE *) &mpegInfo, sizeof( mpegInfo ) );
		}
		else if (FORMAT_VideoInfo2 == pmt->formattype)
		{
			MPEG2VIDEOINFO	mpegInfo;

			mpegInfo.cbSequenceHeader    = 0;
			mpegInfo.dwFlags             = 0;
			mpegInfo.dwLevel             = AM_MPEG2Level_Low;
			mpegInfo.dwProfile           = AM_MPEG2Profile_Simple;
			mpegInfo.dwSequenceHeader[0] = 0;
			mpegInfo.dwStartTimeCode     = 0;
			memcpy( (void *) &mpegInfo.hdr, pmt->pbFormat, sizeof( VIDEOINFOHEADER2 ) );

			m_mediaType.SetFormat( (BYTE *) &mpegInfo, sizeof( mpegInfo ) );
		}
		else if (FORMAT_MPEG2Video == pmt->formattype)
		{
			m_mediaType.SetFormat( pmt->pbFormat, pmt->cbFormat );
		}

		m_ulMaxBPS = ((MPEG2VIDEOINFO *) m_mediaType.pbFormat)->hdr.dwBitRate;
		m_ulMinBPS = m_ulMaxBPS;
		break;

	case PINDIR_OUTPUT:
		m_bOutputPES = (MEDIATYPE_MPEG2_PES == pmt->majortype);
		break;

	default:
		break;
	}

	return NOERROR;
} // CVidelyzerFilter::SetMediaType

HRESULT
CVidelyzerFilter::SetPTS(ULONGLONG pts)
{
	HRESULT	hr = S_OK;

	m_pts = pts;

	if (NULL != m_pMediaSample)
	{
		REFERENCE_TIME	refTime = (REFERENCE_TIME) m_pts;
		// m_pts is in 90kHz clock ticks
		// refTime is in 100ns clock ticks
		// time in seconds (tis) = m_pts / 90,000
		// refTime = tis * 10^7
		// refTime = (m_pts / 90,000) * 10,000,000
		// refTime = (m_pts / 9) * 1,000 = m_pts * 1000 / 9;
		refTime *= 1000;
		refTime /= 9;
		hr = m_pMediaSample->SetTime( &refTime, NULL );
	}

	return hr;
} // CVidelyzerFilter::SetPTS

HRESULT
CVidelyzerFilter::SetSyncPoint()
{
	if (NULL != m_pMediaSample)
		return m_pMediaSample->SetSyncPoint( TRUE );

	return E_FAIL;
} // CVidelyzerFilter::SetSyncPoint
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\analysis\dvranalysis\dvranalysishost.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        DVRAnalysisHost.h

    Abstract:

        This module contains the DVRAnalysis filter declarations

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        19-Feb-2001     created

--*/

#ifndef __tsdvr__dvranalysishost_h
#define __tsdvr__dvranalysishost_h

class CDVRAnalysisBuffer :
    public IDVRAnalysisBufferPriv
{
    struct ANALYSIS_RESULT {
        LONG    lOffset ;
        GUID    guidAttribute ;
    } ;

    IMediaSample *                      m_pIMediaSample ;
    LONG                                m_lMediaSampleBufferLength ;
    BYTE *                              m_pbMediaSampleBuffer ;
    CRITICAL_SECTION                    m_crt ;
    LONG                                m_lRef ;
    CDVRAnalysisBufferPool *            m_pOwningDVRPool ;
    CTSortedList <ANALYSIS_RESULT *>    m_AnalysisResultList ;
    TStructPool <ANALYSIS_RESULT, 3>    m_AnalysisResultPool ;
    LONG                                m_lLastIndexAttribute ;

    void Lock_ ()       { EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()     { LeaveCriticalSection (& m_crt) ; }

    HRESULT
    FixupList_ (
        ) ;

    public :

        CDVRAnalysisBuffer (
            CDVRAnalysisBufferPool *    pOwningDVRPool
            ) ;

        virtual
        ~CDVRAnalysisBuffer (
            ) ;

        STDMETHODIMP_ (ULONG) AddRef () ;
        STDMETHODIMP_ (ULONG) Release () ;
        STDMETHODIMP QueryInterface (REFIID, void **) ;

        DECLARE_IDVRANALYSISBUFFERPRIV () ;

        void
        SetMediaSample (
            IN  IMediaSample *  pIMS
            ) ;

        void
        Reset (
            ) ;
} ;

class CDVRAnalysisBufferPool
{
    TCProducerConsumer <CDVRAnalysisBuffer *>   m_DVRBufferPool ;

    public :

        CDVRAnalysisBufferPool (
            ) ;

        ~CDVRAnalysisBufferPool (
            ) ;

        CDVRAnalysisBuffer *
        Get (
            ) ;

        void
        Recycle (
            IN  CDVRAnalysisBuffer *
            ) ;
} ;

class CDVRAnalysisInput :
    public CBaseInputPin
{
    CDVRAnalysis *  m_pHostAnalysisFilter ;

    void FilterLock_ ()         { m_pLock -> Lock () ;      }
    void FilterUnlock_ ()       { m_pLock -> Unlock () ;    }

    public :

        CDVRAnalysisInput (
            IN  TCHAR *         pszPinName,
            IN  CDVRAnalysis *  pAnalysisFilter,
            IN  CCritSec *      pFilterLock,
            OUT HRESULT *       phr
            ) ;

        //  --------------------------------------------------------------------
        //  CBasePin methods

        HRESULT
        CheckMediaType (
            IN  const CMediaType *
            ) ;

        HRESULT
        CompleteConnect (
            IN  IPin *  pIPin
            ) ;

        HRESULT
        BreakConnect (
            ) ;

        //  --------------------------------------------------------------------
        //  CBaseInputPin methods

        STDMETHODIMP
        Receive (
            IN  IMediaSample * pIMediaSample
            ) ;

        //  --------------------------------------------------------------------
        //  class methods

        HRESULT
        SetAllocatorProperties (
            IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
            ) ;

        HRESULT
        GetRefdConnectionAllocator (
            OUT IMemAllocator **    ppAlloc
            ) ;
} ;

class CDVRAnalysisOutput :
    public CBaseOutputPin
{
    CDVRAnalysis *  m_pHostAnalysisFilter ;

    void FilterLock_ ()         { m_pLock -> Lock () ;      }
    void FilterUnlock_ ()       { m_pLock -> Unlock () ;    }

    public :

        CDVRAnalysisOutput (
            IN  TCHAR *         pszPinName,
            IN  CDVRAnalysis *  pAnalysisFilter,
            IN  CCritSec *      pFilterLock,
            OUT HRESULT *       phr
            ) ;

        HRESULT
        SendSample (
            IN  IMediaSample *  pIMS
            ) ;

        //  --------------------------------------------------------------------
        //  CBasePin methods

        HRESULT
        DecideBufferSize (
            IN  IMemAllocator *         pAlloc,
            IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
            ) ;

        HRESULT
        GetMediaType (
            IN  int             iPosition,
            OUT CMediaType *    pmt
            ) ;

        HRESULT
        CheckMediaType (
            IN  const CMediaType *
            ) ;

        HRESULT
        CompleteConnect (
            IN  IPin *  pIPin
            ) ;

        HRESULT
        BreakConnect (
            ) ;

        HRESULT
        DecideAllocator (
            IN  IMemInputPin *      pPin,
            IN  IMemAllocator **    ppAlloc
            ) ;
} ;

class CDVRAnalysis :
    public CBaseFilter,             //  dshow base class
    public IDVRPostAnalysisSend
{
    CDVRAnalysisInput *     m_pInputPin ;
    CDVRAnalysisOutput *    m_pOutputPin ;
    IDVRAnalysisLogicProp * m_pIDVRAnalysisProp ;
    IDVRAnalyze *           m_pIDVRAnalyze ;
    CDVRAnalysisBufferPool  m_DVRBuffers ;
    CMediaSampleWrapperPool m_MSWrappers ;
    CDVRAnalysisFlags *     m_pAnalysisTagger ;

    void Lock_ ()           { m_pLock -> Lock () ;      }
    void Unlock_ ()         { m_pLock -> Unlock () ;    }

    HRESULT
    ConfirmBufferPoolStocked_ (
        ) ;

    BOOL
    CompareConnectionMediaType_ (
        IN  const AM_MEDIA_TYPE *   pmt,
        IN  CBasePin *              pPin
        ) ;

    BOOL
    CheckInputMediaType_ (
        IN  const AM_MEDIA_TYPE *   pmt
        ) ;

    BOOL
    CheckOutputMediaType_ (
        IN  const AM_MEDIA_TYPE *   pmt
        ) ;

    HRESULT
    SetWrapperProperties_ (
        IN  CMediaSampleWrapper *   pMSWrapper,
        IN  IMediaSample *          pIMSCore,
        IN  LONG                    lCoreBufferOffset,
        IN  CDVRAnalysisFlags *     pAnalysisFlags
        ) ;

    HRESULT
    WrapAndSend_ (
        IN  IMediaSample *      pIMSCore,
        IN  LONG                lBufferOffset,
        IN  BYTE *              pbBuffer,
        IN  LONG                lBufferLength,
        IN  CDVRAnalysisFlags * pAnalysisFlags
        ) ;

    HRESULT
    TransferProperties_ (
        IN  CMediaSampleWrapper *   pMSWrapper,
        IN  IMediaSample *          pIMediaSampleFrom
        ) ;

    public :

        CDVRAnalysis (
            IN  TCHAR *     pszFilterName,
            IN  IUnknown *  punkControlling,
            IN  IUnknown *  punkAnalysisLogic,
            IN  REFCLSID    rCLSID,
            OUT HRESULT *   phr
            ) ;

        ~CDVRAnalysis (
            ) ;

        DECLARE_IUNKNOWN ;
        DECLARE_IDVRPOSTANALYSISSEND () ;

        //  ====================================================================
        //  pure virtual methods in base class

        int
        GetPinCount (
            ) ;

        CBasePin *
        GetPin (
            IN  int
            ) ;

        STDMETHODIMP
        Pause (
            ) ;

        //  ====================================================================
        //  class methods

        BOOL
        CheckAnalysisMediaType (
            IN  PIN_DIRECTION,          //  caller
            IN  const CMediaType *
            ) ;

        HRESULT
        Process (
            IN  IMediaSample *
            ) ;

        HRESULT
        OnCompleteConnect (
            IN  PIN_DIRECTION           //  caller
            ) ;

        HRESULT
        OnBreakConnect (
            IN  PIN_DIRECTION           //  caller
            ) ;

        HRESULT
        UpdateAllocatorProperties (
            IN  ALLOCATOR_PROPERTIES *
            ) ;

        HRESULT
        OnOutputGetMediaType (
            OUT CMediaType *    pmt
            ) ;

        HRESULT
        GetRefdInputAllocator (
            OUT IMemAllocator **
            ) ;
} ;

#endif  //  __tsdvr__dvranalysishost_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\analysis\dvranalysis\dvranalysishost.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvranalysishost.cpp

    Abstract:

        This module contains the dvranalysishost filter code.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        19-Feb-2001     created

--*/

#include "dvrall.h"

#include "dvranalysis.h"            //  analysis CLSID & CF interface
#include "dvranalysisutil.h"
#include "dvranalysishost.h"

//  disable so we can use 'this' in the initializer list
#pragma warning (disable:4355)

//  ============================================================================

HRESULT
CreateDVRAnalysisHostFilter (
    IN  IUnknown *  punkOuter,
    IN  IUnknown *  punkAnalysisLogic,
    IN  REFCLSID    rCLSID,
    OUT CUnknown ** punkAnalysisFilterHost
    )
{
    HRESULT                 hr ;
    LPWSTR                  pszFilterName ;
    IDVRAnalysisLogicProp * pILogicProp ;
    CDVRAnalysis *          pAnalysisFilter ;

    ASSERT (punkAnalysisLogic) ;
    ASSERT (punkAnalysisFilterHost) ;

    (* punkAnalysisFilterHost) = NULL ;

    hr = punkAnalysisLogic -> QueryInterface (
                                IID_IDVRAnalysisLogicProp,
                                (void **) & pILogicProp
                                ) ;
    if (SUCCEEDED (hr)) {
        hr = pILogicProp -> GetDisplayName (& pszFilterName) ;
        if (SUCCEEDED (hr)) {

#ifdef UNICODE
            pAnalysisFilter = new CDVRAnalysis (
                                    pszFilterName,
                                    punkOuter,
                                    punkAnalysisLogic,
                                    rCLSID,
                                    & hr
                                    ) ;
#else
            //  BUGBUG: unicode only .. for now at least
            pAnalysisFilter = NULL ;
#endif

            if (pAnalysisFilter &&
                SUCCEEDED (hr)) {

                (* punkAnalysisFilterHost) = pAnalysisFilter ;
            }
            else {
                hr = (pAnalysisFilter ? hr : E_OUTOFMEMORY) ;
                delete pAnalysisFilter ;
            }

            CoTaskMemFree (pszFilterName) ;
        }

        pILogicProp -> Release () ;
    }

    return hr ;
}

//  ============================================================================

CDVRAnalysisBuffer::CDVRAnalysisBuffer (
    CDVRAnalysisBufferPool *    pOwningDVRPool
    ) : m_pIMediaSample         (NULL),
        m_pOwningDVRPool        (pOwningDVRPool),
        m_lRef                  (0),
        m_lLastIndexAttribute   (UNDEFINED)
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRAnalysisBuffer")) ;

    ASSERT (pOwningDVRPool) ;

    InitializeCriticalSection (& m_crt) ;
}

CDVRAnalysisBuffer::~CDVRAnalysisBuffer (
    )
{
    TRACE_DESTRUCTOR (TEXT ("CDVRAnalysisBuffer")) ;

    DeleteCriticalSection (& m_crt) ;

    RELEASE_AND_CLEAR (m_pIMediaSample) ;
}

STDMETHODIMP_ (ULONG)
CDVRAnalysisBuffer::AddRef (
    )
{
    O_TRACE_ENTER_0 (TEXT ("CDVRAnalysisBuffer::AddRef ()")) ;

    return InterlockedIncrement (& m_lRef) ;
}

STDMETHODIMP_ (ULONG)
CDVRAnalysisBuffer::Release (
    )
{
    LONG    lRef ;

    O_TRACE_ENTER_0 (TEXT ("CDVRAnalysisBuffer::Release ()")) ;

    lRef = InterlockedDecrement (& m_lRef) ;

    if (lRef == 0) {
        Reset () ;
        m_pOwningDVRPool -> Recycle (this) ;
        return 0 ;
    }

    return m_lRef ;
}

STDMETHODIMP
CDVRAnalysisBuffer::QueryInterface (
    IN  REFIID  riid,
    IN  void ** ppv
    )
{
    O_TRACE_ENTER_0 (TEXT ("CDVRAnalysisBuffer::QueryInterface ()")) ;

    if (!ppv) {
        return E_POINTER ;
    }

    if (riid == IID_IUnknown) {
        (* ppv) = static_cast <IUnknown *> (this) ;
    }
    else if (riid == IID_IDVRAnalysisBuffer) {
        (* ppv) = static_cast <IDVRAnalysisBuffer *> (this) ;
    }
    else if (riid == IID_IDVRAnalysisBufferPriv) {
        (* ppv) = static_cast <IDVRAnalysisBufferPriv *> (this) ;
    }
    else {
        return E_NOINTERFACE ;
    }

    reinterpret_cast <IUnknown *> (* ppv) -> AddRef () ;

    return S_OK ;
}

HRESULT
CDVRAnalysisBuffer::GetBuffer (
    OUT BYTE ** ppbBuffer
    )
{
    HRESULT hr ;

    if (!ppbBuffer) {
        return E_POINTER ;
    }

    Lock_ () ;

    if (m_pIMediaSample) {
        (* ppbBuffer) = m_pbMediaSampleBuffer ;
        hr = S_OK ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    Unlock_ () ;

    return hr ;
}

HRESULT
CDVRAnalysisBuffer::GetBufferLength (
    IN  LONG *  plBufferLen
    )
{
    HRESULT hr ;

    if (!plBufferLen) {
        return E_POINTER ;
    }

    Lock_ () ;

    if (m_pIMediaSample) {
        (* plBufferLen) = m_lMediaSampleBufferLength ;
        hr = S_OK ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    Unlock_ () ;

    return hr ;
}

HRESULT
CDVRAnalysisBuffer::Mark (
    IN  LONG            lBufferOffset,
    IN  const GUID *    pguidAttribute
    )
{
    ANALYSIS_RESULT *   pAnalysisResult ;
    HRESULT             hr ;
    DWORD               dw ;

    if (lBufferOffset >= m_lMediaSampleBufferLength ||
        !pguidAttribute) {

        return E_INVALIDARG ;
    }

    Lock_ () ;

    pAnalysisResult = m_AnalysisResultPool.Get () ;
    if (pAnalysisResult) {
        pAnalysisResult -> lOffset          = lBufferOffset ;
        pAnalysisResult -> guidAttribute    = (* pguidAttribute) ;

        dw = m_AnalysisResultList.Insert (
                pAnalysisResult,
                pAnalysisResult -> lOffset
                ) ;
        if (dw == NOERROR) {
            hr = S_OK ;
        }
        else {
            m_AnalysisResultPool.Recycle (pAnalysisResult) ;
            hr = HRESULT_FROM_WIN32 (dw) ;
        }
    }
    else {
        hr = E_OUTOFMEMORY ;
    }

    Unlock_ () ;

    return hr ;
}

HRESULT
CDVRAnalysisBuffer::GetAttribute (
    IN  LONG    lIndex,
    OUT LONG *  plBufferOffset,
    OUT GUID *  pguidAttribute
    )
{
    ANALYSIS_RESULT *   pAnalysisResult ;
    DWORD               dw ;
    LONG                i ;
    HRESULT             hr ;

    //  we're the caller so these better be valid
    ASSERT (plBufferOffset) ;
    ASSERT (pguidAttribute) ;

    Lock_ () ;

    //  position
    if (m_lLastIndexAttribute != UNDEFINED &&
        m_lLastIndexAttribute < lIndex) {

        for (i = 0, dw = NOERROR;
             dw == NOERROR && i < lIndex - m_lLastIndexAttribute;
             i++) {
            dw = m_AnalysisResultList.Advance () ;
        }
    }
    else {
        dw = m_AnalysisResultList.SetPointer (lIndex) ;
    }

    //  and retrieve
    if (dw == NOERROR) {
        m_lLastIndexAttribute = lIndex ;

        dw = m_AnalysisResultList.GetCur (& pAnalysisResult) ;
        if (dw == NOERROR) {
            (* plBufferOffset) = pAnalysisResult -> lOffset ;
            (* pguidAttribute) = pAnalysisResult -> guidAttribute ;

            ASSERT (m_pIMediaSample) ;
            ASSERT (pAnalysisResult -> lOffset < m_lMediaSampleBufferLength) ;
        }
    }

    Unlock_ () ;

    hr = HRESULT_FROM_WIN32 (dw) ;
    return hr ;
}

void
CDVRAnalysisBuffer::SetMediaSample (
    IN  IMediaSample *  pIMS
    )
{
    Lock_ () ;

    Reset () ;

    if (pIMS) {
        m_pIMediaSample = pIMS ;
        m_pIMediaSample -> AddRef () ;

        m_lMediaSampleBufferLength = m_pIMediaSample -> GetActualDataLength () ;
        m_pIMediaSample -> GetPointer (& m_pbMediaSampleBuffer) ;
    }

    Unlock_ () ;

    return ;
}

HRESULT
CDVRAnalysisBuffer::IsDiscontinuity (
    OUT BOOL *  pfDiscontinuity
    )
{
    HRESULT hr ;

    if (!pfDiscontinuity) {
        return E_POINTER ;
    }

    Lock_ () ;

    if (m_pIMediaSample) {
        (* pfDiscontinuity) = (m_pIMediaSample -> IsDiscontinuity () == S_OK ? TRUE : FALSE) ;
        hr = S_OK ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    Unlock_ () ;

    return hr ;
}

void
CDVRAnalysisBuffer::Reset (
    )
{
    ANALYSIS_RESULT *   pAnalysisResult ;
    DWORD               dw ;

    Lock_ () ;

    dw = m_AnalysisResultList.SetPointer (0) ;
    while (dw == NOERROR) {
        dw = m_AnalysisResultList.GetCur (& pAnalysisResult) ;
        if (dw == NOERROR) {
            m_AnalysisResultPool.Recycle (pAnalysisResult) ;

            dw = m_AnalysisResultList.PopCur () ;
        }
    }

    m_lLastIndexAttribute = UNDEFINED ;

    RELEASE_AND_CLEAR (m_pIMediaSample) ;

    m_pbMediaSampleBuffer       = NULL ;
    m_lMediaSampleBufferLength  = 0 ;

    Unlock_ () ;
}

STDMETHODIMP
CDVRAnalysisBuffer::GetWrappedMediaSample (
    OUT IMediaSample ** ppIMS
    )
{
    HRESULT hr ;

    ASSERT (ppIMS) ;

    Lock_ () ;

    if (m_pIMediaSample) {
        (* ppIMS) = m_pIMediaSample ;
        (* ppIMS) -> AddRef () ;

        hr = S_OK ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    Unlock_ () ;

    return hr ;
}

//  ============================================================================

CDVRAnalysisBufferPool::CDVRAnalysisBufferPool (
    )
{
}

CDVRAnalysisBufferPool::~CDVRAnalysisBufferPool (
    )
{
    CDVRAnalysisBuffer *    pDVRBuffer ;
    DWORD                   dw ;

    for (;;) {
        dw = m_DVRBufferPool.TryPop (& pDVRBuffer) ;
        if (dw == NOERROR) {
            ASSERT (pDVRBuffer) ;
            delete pDVRBuffer ;
        }
        else {
            break ;
        }
    }
}

CDVRAnalysisBuffer *
CDVRAnalysisBufferPool::Get (
    )
{
    CDVRAnalysisBuffer *    pDVRBuffer ;
    DWORD                   dw ;

    dw = m_DVRBufferPool.TryPop (& pDVRBuffer) ;
    if (dw == NOERROR) {
        ASSERT (pDVRBuffer) ;
        pDVRBuffer -> AddRef () ;
    }
    else {
        pDVRBuffer = new CDVRAnalysisBuffer (this) ;
        if (pDVRBuffer) {
            pDVRBuffer -> AddRef () ;
        }
    }

    return pDVRBuffer ;
}

void
CDVRAnalysisBufferPool::Recycle (
    IN  CDVRAnalysisBuffer *    pDVRBuffer
    )
{
    DWORD   dw ;

    dw = m_DVRBufferPool.Push (pDVRBuffer) ;
    if (dw != NOERROR) {
        delete pDVRBuffer ;
    }
}

//  ============================================================================

CDVRAnalysisInput::CDVRAnalysisInput (
    IN  TCHAR *         pszPinName,
    IN  CDVRAnalysis *  pAnalysisFilter,
    IN  CCritSec *      pFilterLock,
    OUT HRESULT *       phr
    ) : CBaseInputPin       (NAME ("CDVRAnalysisInput"),
                             pAnalysisFilter,
                             pFilterLock,
                             phr,
                             pszPinName
                             ),
    m_pHostAnalysisFilter   (pAnalysisFilter)
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRAnalysisInput")) ;
}

HRESULT
CDVRAnalysisInput::CheckMediaType (
    IN  const CMediaType *  pmt
    )
{
    BOOL    f ;

    FilterLock_ () ;

    f = m_pHostAnalysisFilter -> CheckAnalysisMediaType (m_dir, pmt) ;

    FilterUnlock_ () ;

    return (f ? S_OK : S_FALSE) ;
}

HRESULT
CDVRAnalysisInput::CompleteConnect (
    IN  IPin *  pIPin
    )
{
    HRESULT hr ;

    hr = CBaseInputPin::CompleteConnect (pIPin) ;
    if (SUCCEEDED (hr)) {
        hr = m_pHostAnalysisFilter -> OnCompleteConnect (m_dir) ;
    }

    return hr ;
}

HRESULT
CDVRAnalysisInput::BreakConnect (
    )
{
    HRESULT hr ;

    hr = CBaseInputPin::BreakConnect () ;
    if (SUCCEEDED (hr)) {
        hr = m_pHostAnalysisFilter -> OnBreakConnect (m_dir) ;
    }

    return hr ;
}

HRESULT
CDVRAnalysisInput::SetAllocatorProperties (
    IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
    )
{
    HRESULT hr ;

    if (IsConnected ()) {
        ASSERT (m_pAllocator) ;
        hr = m_pAllocator -> GetProperties (ppropInputRequest) ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

STDMETHODIMP
CDVRAnalysisInput::Receive (
    IN  IMediaSample * pIMediaSample
    )
{
    HRESULT hr ;

    hr = CBaseInputPin::Receive (pIMediaSample) ;
    if (SUCCEEDED (hr)) {
        hr = m_pHostAnalysisFilter -> Process (pIMediaSample) ;
    }

    return hr ;
}

HRESULT
CDVRAnalysisInput::GetRefdConnectionAllocator (
    OUT IMemAllocator **    ppAlloc
    )
{
    HRESULT hr ;

    if (m_pAllocator) {
        (* ppAlloc) = m_pAllocator ;
        (* ppAlloc) -> AddRef () ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

//  ============================================================================

CDVRAnalysisOutput::CDVRAnalysisOutput (
    IN  TCHAR *         pszPinName,
    IN  CDVRAnalysis *  pAnalysisFilter,
    IN  CCritSec *      pFilterLock,
    OUT HRESULT *       phr
    ) : CBaseOutputPin      (NAME ("CDVRAnalysisOutput"),
                             pAnalysisFilter,
                             pFilterLock,
                             phr,
                             pszPinName
                             ),
    m_pHostAnalysisFilter   (pAnalysisFilter)
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRAnalysisOutput")) ;
}

HRESULT
CDVRAnalysisOutput::DecideBufferSize (
    IN  IMemAllocator *         pAlloc,
    IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
    )
{
    HRESULT hr ;

    hr = m_pHostAnalysisFilter -> UpdateAllocatorProperties (
            ppropInputRequest
            ) ;

    return hr ;
}

HRESULT
CDVRAnalysisOutput::GetMediaType (
    IN  int             iPosition,
    OUT CMediaType *    pmt
    )
{
    HRESULT hr ;

    FilterLock_ () ;

    hr = m_pHostAnalysisFilter -> OnOutputGetMediaType (pmt) ;

    FilterUnlock_ () ;

    return hr ;
}

HRESULT
CDVRAnalysisOutput::CheckMediaType (
    IN  const CMediaType *  pmt
    )
{
    BOOL    f ;

    FilterLock_ () ;

    f = m_pHostAnalysisFilter -> CheckAnalysisMediaType (m_dir, pmt) ;

    FilterUnlock_ () ;

    return (f ? S_OK : S_FALSE) ;
}

HRESULT
CDVRAnalysisOutput::CompleteConnect (
    IN  IPin *  pIPin
    )
{
    HRESULT hr ;

    hr = CBaseOutputPin::CompleteConnect (pIPin) ;
    if (SUCCEEDED (hr)) {
        hr = m_pHostAnalysisFilter -> OnCompleteConnect (m_dir) ;
    }

    return hr ;
}

HRESULT
CDVRAnalysisOutput::BreakConnect (
    )
{
    HRESULT hr ;

    hr = CBaseOutputPin::BreakConnect () ;
    if (SUCCEEDED (hr)) {
        hr = m_pHostAnalysisFilter -> OnBreakConnect (m_dir) ;
    }

    return hr ;
}

HRESULT
CDVRAnalysisOutput::DecideAllocator (
    IN  IMemInputPin *      pPin,
    IN  IMemAllocator **    ppAlloc
    )
{
    HRESULT hr ;

    hr = m_pHostAnalysisFilter -> GetRefdInputAllocator (ppAlloc) ;
    if (SUCCEEDED (hr)) {
        //  input pin must be connected i.e. have an allocator; preserve
        //   all properties and pass them through to the output
        hr = pPin -> NotifyAllocator ((* ppAlloc), FALSE) ;
    }

    return hr ;
}

HRESULT
CDVRAnalysisOutput::SendSample (
    IN  IMediaSample *  pIMS
    )
{
    HRESULT hr ;

    ASSERT (pIMS) ;

#if 0
    REFERENCE_TIME  rtStart ;
    REFERENCE_TIME  rtStop ;
    LONGLONG        llStart ;
    LONGLONG        llStop ;

    TRACE_2 (TEXT ("-------- %08xh %d"), pIMS, pIMS -> GetActualDataLength ()) ;

    hr = pIMS -> GetTime (& rtStart, & rtStop) ;
    if (SUCCEEDED (hr)) {
        TRACE_2 (TEXT ("start/stop %I64016x %I64016x"), rtStart, rtStop) ;
    }
    else {
        TRACE_0 (TEXT ("start/stop ")) ;
    }

    hr = pIMS -> GetMediaTime (& llStart, & llStop) ;
    if (SUCCEEDED (hr)) {
    }
    else {
    }
#endif

    hr = Deliver (pIMS) ;

    return hr ;
}

//  ============================================================================

CDVRAnalysis::CDVRAnalysis (
    IN  TCHAR *     pszFilterName,
    IN  IUnknown *  punkControlling,
    IN  IUnknown *  punkAnalysisLogic,
    IN  REFCLSID    rCLSID,
    OUT HRESULT *   phr
    ) : CBaseFilter             (pszFilterName,
                                 punkControlling,
                                 new CCritSec,
                                 rCLSID
                                ),
        m_pInputPin             (NULL),
        m_pOutputPin            (NULL),
        m_pIDVRAnalysisProp     (NULL),
        m_pIDVRAnalyze          (NULL),
        m_pAnalysisTagger       (NULL)
{
    DVR_ANALYSIS_DESC * pAnalysisDesc ;
    LONG                lAnalysisDescCount ;
    LONG                i ;

    TRACE_CONSTRUCTOR (TEXT ("CDVRAnalysis")) ;

    if (!m_pLock) {
        (* phr) = E_OUTOFMEMORY ;
        goto cleanup ;
    }

    m_pInputPin = new CDVRAnalysisInput (
                        TEXT ("in"),
                        this,
                        m_pLock,
                        phr
                        ) ;
    if (!m_pInputPin ||
        FAILED (* phr)) {

        (* phr) = (m_pInputPin ? (* phr) : E_OUTOFMEMORY) ;
        goto cleanup ;
    }

    m_pOutputPin = new CDVRAnalysisOutput (
                        TEXT ("out"),
                        this,
                        m_pLock,
                        phr
                        ) ;
    if (!m_pOutputPin ||
        FAILED (* phr)) {

        (* phr) = (m_pOutputPin ? (* phr) : E_OUTOFMEMORY) ;
        goto cleanup ;
    }

    (* phr) = punkAnalysisLogic -> QueryInterface (
                    IID_IDVRAnalysisLogicProp,
                    (void **) & m_pIDVRAnalysisProp
                    ) ;
    if (FAILED (* phr)) { goto cleanup ; }

    (* phr) = m_pIDVRAnalysisProp -> EnumAnalysis (
                & lAnalysisDescCount,
                & pAnalysisDesc
                ) ;
    if (SUCCEEDED (* phr)) {
        for (i = 0; i < lAnalysisDescCount && m_pAnalysisTagger == NULL; i++) {
            m_pAnalysisTagger = GetAnalysisTagger (pAnalysisDesc [i].guidAnalysis) ;
        }

        FreeDVRAnalysisDescriptor (lAnalysisDescCount, pAnalysisDesc) ;
    }

    if (m_pAnalysisTagger == NULL) { (* phr) = E_FAIL ; goto cleanup ; }


    (* phr) = m_pIDVRAnalysisProp -> SetPostAnalysisSend (this) ;
    if (FAILED (* phr)) { goto cleanup ; }

    (* phr) = punkAnalysisLogic -> QueryInterface (
                    IID_IDVRAnalyze,
                    (void **) & m_pIDVRAnalyze
                    ) ;
    if (FAILED (* phr)) { goto cleanup ; }

    //  success
    ASSERT (SUCCEEDED (* phr)) ;
    ASSERT (m_pInputPin) ;
    ASSERT (m_pOutputPin) ;
    ASSERT (m_pIDVRAnalysisProp) ;
    ASSERT (m_pIDVRAnalyze) ;

    cleanup :

    return ;
}

CDVRAnalysis::~CDVRAnalysis (
    )
{
    RELEASE_AND_CLEAR (m_pIDVRAnalysisProp) ;
    RELEASE_AND_CLEAR (m_pIDVRAnalyze) ;

    RecycleAnalysisTagger (m_pAnalysisTagger) ;

    delete m_pInputPin ;
    delete m_pOutputPin ;
}

int
CDVRAnalysis::GetPinCount (
    )
{
    int i ;

    Lock_ () ;

    //  don't show the output pin if the input pin is not connected
    i = (m_pInputPin -> IsConnected () ? 2 : 1) ;

    Unlock_ () ;

    return i ;
}

CBasePin *
CDVRAnalysis::GetPin (
    IN  int iIndex
    )
{
    CBasePin *  pPin ;

    Lock_ () ;

    if (iIndex == 0) {
        pPin = m_pInputPin ;
    }
    else if (iIndex == 1) {
        pPin = (m_pInputPin -> IsConnected () ? m_pOutputPin : NULL) ;
    }
    else {
        pPin = NULL ;
    }

    Unlock_ () ;

    return pPin ;
}

BOOL
CDVRAnalysis::CompareConnectionMediaType_ (
    IN  const AM_MEDIA_TYPE *   pmt,
    IN  CBasePin *              pPin
    )
{
    BOOL        f ;
    HRESULT     hr ;
    CMediaType  cmtConnection ;
    CMediaType  cmtCompare ;

    ASSERT (pPin -> IsConnected ()) ;

    hr = pPin -> ConnectionMediaType (& cmtConnection) ;
    if (SUCCEEDED (hr)) {
        cmtCompare = (* pmt) ;
        f = (cmtConnection == cmtCompare ? TRUE : FALSE) ;
    }
    else {
        f = FALSE ;
    }

    return f ;
}

BOOL
CDVRAnalysis::CheckInputMediaType_ (
    IN  const AM_MEDIA_TYPE *   pmt
    )
{
    BOOL    f ;
    HRESULT hr ;

    if (!m_pOutputPin -> IsConnected ()) {
        hr = m_pIDVRAnalysisProp -> CheckMediaType (pmt, & f) ;
        if (FAILED (hr)) {
            f = FALSE ;
        }
    }
    else {
        f = CompareConnectionMediaType_ (pmt, m_pOutputPin) ;
    }

    return f ;
}

BOOL
CDVRAnalysis::CheckOutputMediaType_ (
    IN  const AM_MEDIA_TYPE *   pmt
    )
{
    BOOL    f ;
    HRESULT hr ;

    Lock_ () ;

    if (m_pInputPin -> IsConnected ()) {
        f = CompareConnectionMediaType_ (pmt, m_pInputPin) ;
    }
    else {
        f = FALSE ;
    }

    Unlock_ () ;

    return f ;
}

BOOL
CDVRAnalysis::CheckAnalysisMediaType (
    IN  PIN_DIRECTION       PinDir,
    IN  const CMediaType *  pmt
    )
{
    BOOL    f ;

    //  both pins must have identical media types, so we check with the pin that
    //   is not calling; if it's connected, we measure against the connection's
    //   media type

    if (PinDir == PINDIR_INPUT) {
        f = CheckInputMediaType_ (pmt) ;
    }
    else {
        ASSERT (PinDir == PINDIR_OUTPUT) ;
        f = CheckOutputMediaType_ (pmt) ;
    }

    return f ;
}

STDMETHODIMP
CDVRAnalysis::Pause (
    )
{
    HRESULT                 hr ;
    ALLOCATOR_PROPERTIES    AllocProp ;

    O_TRACE_ENTER_0 (TEXT("CDVRAnalysis::Pause ()")) ;

    Lock_ () ;

    if (m_State == State_Stopped) {
        hr = CBaseFilter::Pause () ;
        if (SUCCEEDED (hr)) {
            hr = m_pInputPin -> SetAllocatorProperties (& AllocProp) ;
            if (SUCCEEDED (hr)) {
                m_MSWrappers.SetMaxAllocate (AllocProp.cBuffers) ;
            }
            else {
                //  don't fail if the input is not connected
                hr = (m_pInputPin -> IsConnected () ? hr : S_OK) ;
            }
        }
    } else {
        m_State = State_Paused ;

        hr = S_OK ;
    }

    Unlock_ () ;

    return hr ;
}

HRESULT
CDVRAnalysis::Process (
    IN  IMediaSample *  pIMediaSample
    )
{
    CDVRAnalysisBuffer *    pDVRBuffer ;
    HRESULT                 hr ;

    pDVRBuffer = m_DVRBuffers.Get () ;
    if (pDVRBuffer) {
        //  DVRBuffer is ref'd by m_DVRBuffers before return

        pDVRBuffer -> SetMediaSample (
            pIMediaSample
            ) ;

        hr = m_pIDVRAnalyze -> Analyze (
                pDVRBuffer,
                pIMediaSample -> IsDiscontinuity () == S_OK ? TRUE : FALSE
                ) ;

        pDVRBuffer -> Release () ;
    }

    return hr ;
}

HRESULT
CDVRAnalysis::TransferProperties_ (
    IN  CMediaSampleWrapper *   pMSWrapper,
    IN  IMediaSample *          pIMediaSampleFrom
    )
{
    HRESULT                 hr ;
    REFERENCE_TIME          rtPTSStart ;
    REFERENCE_TIME          rtPTSStop ;
    LONGLONG                llMTStart ;
    LONGLONG                llMTStop ;
    AM_SAMPLE2_PROPERTIES   SampleProperties ;
    IMediaSample2 *         pIMediaSample2From ;

    pIMediaSample2From  = NULL ;

    hr = pIMediaSampleFrom -> QueryInterface (IID_IMediaSample2, (void **) & pIMediaSample2From) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  ====================================================================
    //  presentation time
    hr = pIMediaSampleFrom -> GetTime (& rtPTSStart, & rtPTSStop) ;
    if (SUCCEEDED (hr)) {
        //  start & stop
        hr = pMSWrapper -> SetTime (& rtPTSStart, & rtPTSStop) ;
    }
    else if (FAILED (hr) &&
             hr == VFW_S_NO_STOP_TIME) {

        //  start only
        hr = pMSWrapper -> SetTime (& rtPTSStart, NULL) ;
    }
    else if (FAILED (hr) &&
             hr == VFW_E_SAMPLE_TIME_NOT_SET) {

        //  neither - not a failure
        hr = S_OK ;
    }

    if (FAILED (hr)) { goto cleanup ; }

    //  ====================================================================
    //  media time
    hr = pIMediaSampleFrom -> GetMediaTime (& llMTStart, & llMTStop) ;
    if (SUCCEEDED (hr)) {
        hr = pMSWrapper -> SetMediaTime (& llMTStart, & llMTStop) ;
    }
    else if (FAILED (hr) &&
             hr == VFW_E_MEDIA_TIME_NOT_SET) {

        hr = S_OK ;
    }

    //  ====================================================================
    //  flags
    pMSWrapper -> SetDiscontinuity  (pIMediaSampleFrom -> IsDiscontinuity () == S_OK ? TRUE : FALSE) ;
    pMSWrapper -> SetSyncPoint      (pIMediaSampleFrom -> IsSyncPoint ()     == S_OK ? TRUE : FALSE) ;
    pMSWrapper -> SetPreroll        (pIMediaSampleFrom -> IsPreroll ()       == S_OK ? TRUE : FALSE) ;

    //  set .dwTypeSpecificFlags
    //
    hr = pIMediaSample2From -> GetProperties (sizeof SampleProperties, (BYTE *) & SampleProperties) ;
    if (FAILED (hr)) { goto cleanup ; }

    pMSWrapper -> SetTypeSpecificFlags (SampleProperties.dwTypeSpecificFlags) ;

    cleanup :

    RELEASE_AND_CLEAR (pIMediaSample2From) ;

    return hr ;
}

HRESULT
CDVRAnalysis::SetWrapperProperties_ (
    IN  CMediaSampleWrapper *   pMSWrapper,
    IN  IMediaSample *          pIMSCore,
    IN  LONG                    lCoreBufferOffset,
    IN  CDVRAnalysisFlags *     pAnalysisFlags
    )
{
    HRESULT hr ;

    if (lCoreBufferOffset == 0) {
        hr = TransferProperties_ (pMSWrapper, pIMSCore) ;
        if (SUCCEEDED (hr)) {
            hr = pAnalysisFlags -> Tag (pMSWrapper, FALSE) ;
        }
    }
    else {
        hr = pAnalysisFlags -> Tag (pMSWrapper, TRUE) ;
    }

    return hr ;
}

HRESULT
CDVRAnalysis::WrapAndSend_ (
    IN  IMediaSample *      pIMSCore,
    IN  LONG                lBufferOffset,
    IN  BYTE *              pbBuffer,
    IN  LONG                lBufferLength,
    IN  CDVRAnalysisFlags * pAnalysisFlags
    )
{
    CMediaSampleWrapper *   pMSWrapper ;
    HRESULT                 hr ;

    pMSWrapper = m_MSWrappers.Get () ;
    if (pMSWrapper) {
        hr = pMSWrapper -> Init (
                pIMSCore,
                pbBuffer,
                lBufferLength
                ) ;
        if (SUCCEEDED (hr)) {
            hr = SetWrapperProperties_ (
                    pMSWrapper,
                    pIMSCore,
                    lBufferOffset,
                    pAnalysisFlags
                    ) ;

            if (SUCCEEDED (hr)) {
                hr = m_pOutputPin -> SendSample (pMSWrapper) ;
                pMSWrapper -> Release () ;
            }
        }
    }

    return hr ;
}

HRESULT
CDVRAnalysis::CompleteAnalysis (
    IN  IDVRAnalysisBuffer *    pIOwningAnalysisBuffer
    )
{
    IDVRAnalysisBufferPriv *    pDVRBufferPriv ;
    IMediaSample *              pICoreMediaSample ;
    HRESULT                     hr ;
    LONG                        lIndex ;
    LONG                        lBufferOffset ;
    LONG                        lLastBufferOffset ;
    GUID                        guidAttribute ;
    BYTE *                      pbCoreBuffer ;
    LONG                        lCoreBufferLength ;

    ASSERT (m_pAnalysisTagger) ;

    hr = pIOwningAnalysisBuffer -> QueryInterface (
            IID_IDVRAnalysisBufferPriv,
            (void **) & pDVRBufferPriv
            ) ;
    if (SUCCEEDED (hr)) {
        hr = pDVRBufferPriv -> GetWrappedMediaSample (& pICoreMediaSample) ;
        if (SUCCEEDED (hr)) {

            ASSERT (pDVRBufferPriv) ;

            //  initialize
            lLastBufferOffset   = 0 ;                                           //  start at offset 0
            lCoreBufferLength   = pICoreMediaSample -> GetActualDataLength () ; //  get the length
            pICoreMediaSample -> GetPointer (& pbCoreBuffer) ;                  //  and core pointer

            m_pAnalysisTagger -> Reset () ;

            //
            for (lIndex = 0; SUCCEEDED (hr); lIndex++) {

                hr = pDVRBufferPriv -> GetAttribute (
                        lIndex,
                        & lBufferOffset,
                        & guidAttribute
                        ) ;

                if (SUCCEEDED (hr)) {
                    if (lBufferOffset > lLastBufferOffset) {
                        hr = WrapAndSend_ (
                                pICoreMediaSample,
                                lLastBufferOffset,
                                pbCoreBuffer + lLastBufferOffset,
                                lBufferOffset - lLastBufferOffset,
                                m_pAnalysisTagger
                                ) ;
                        if (SUCCEEDED (hr)) {
                            //  initialize for the next - no flags
                            m_pAnalysisTagger -> Reset () ;
                            m_pAnalysisTagger -> Mark (guidAttribute) ;
                            lLastBufferOffset = lBufferOffset ;
                        }
                    }
                    else {
                        //  pile on the attributes for the next we'll send
                        ASSERT (lBufferOffset == lLastBufferOffset) ;
                        m_pAnalysisTagger -> Mark (guidAttribute) ;
                    }
                }
            }

            hr = WrapAndSend_ (
                    pICoreMediaSample,
                    lLastBufferOffset,
                    pbCoreBuffer + lLastBufferOffset,
                    lCoreBufferLength - lLastBufferOffset,
                    m_pAnalysisTagger
                    ) ;

            pICoreMediaSample -> Release () ;
        }

        //  successful QI's
        pDVRBufferPriv -> Release () ;
    }

    return hr ;
}

HRESULT
CDVRAnalysis::OnCompleteConnect (
    IN  PIN_DIRECTION   PinDir
    )
{
    Lock_ () ;

    if (PinDir == PINDIR_INPUT) {
        //  time to display the output pin
        IncrementPinVersion () ;
    }

    Unlock_ () ;

    return S_OK ;
}

HRESULT
CDVRAnalysis::OnBreakConnect (
    IN  PIN_DIRECTION   PinDir
    )
{
    HRESULT hr ;

    Lock_ () ;

    if (PinDir == PINDIR_INPUT) {
        if (m_pOutputPin -> IsConnected ()) {
            m_pOutputPin -> GetConnected () -> Disconnect () ;
            m_pOutputPin -> Disconnect () ;

            IncrementPinVersion () ;
        }
    }

    Unlock_ () ;

    return S_OK ;
}

HRESULT
CDVRAnalysis::UpdateAllocatorProperties (
    IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
    )
{
    HRESULT hr ;

    if (m_pInputPin -> IsConnected ()) {
        hr = m_pInputPin -> SetAllocatorProperties (ppropInputRequest) ;
    }
    else {
        hr = S_OK ;
    }

    return hr ;
}

HRESULT
CDVRAnalysis::OnOutputGetMediaType (
    OUT CMediaType *    pmt
    )
{
    HRESULT hr ;

    ASSERT (pmt) ;

    if (m_pInputPin -> IsConnected ()) {
        hr = m_pInputPin -> ConnectionMediaType (pmt) ;
    }
    else {
        //  BUGBUG
        //  does this prevent the output from connecting when the input is not
        //   connected ?  yes
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRAnalysis::GetRefdInputAllocator (
    OUT IMemAllocator **    ppAlloc
    )
{
    HRESULT hr ;

    Lock_ () ;
    hr = m_pInputPin -> GetRefdConnectionAllocator (ppAlloc) ;
    Unlock_ () ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\dvrplay\dvrplay.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        DVRPlay.h

    Abstract:

        This module contains the DVRPlay declarations.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef __dvrplay__dvrplay_h
#define __dvrplay__dvrplay_h

extern AMOVIESETUP_FILTER   g_sudDVRPlay ;

class CDVRPlay :
    public CBaseFilter,
    public ISpecifyPropertyPages,
    public IAMFilterMiscFlags,
    public IFileSourceFilter
{
    CDVRSourcePinManager *  m_pOutputPins ;
    CDVRPolicy *            m_pPolicy ;
    CDVRRecordingReader *   m_pReader ;
    WCHAR *                 m_pszFilename ;
    CDVRDShowSeekingCore    m_SeekingCore ;
    CDVRClock *             m_pDVRClock ;

    void LockFilter_ ()         { m_pLock -> Lock () ; }
    void UnlockFilter_ ()       { m_pLock -> Unlock () ; }

    HRESULT
    LoadASFFile_ (
        ) ;

    HRESULT
    UnloadASFFile_ (
        ) ;

    public :

        CDVRPlay (
            IN  IUnknown *  punkControlling,
            IN  REFCLSID    rclsid,
            OUT HRESULT *   phr
            ) ;

        ~CDVRPlay (
            ) ;

        DECLARE_IUNKNOWN ;

        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
             ) ;

        STDMETHODIMP
        JoinFilterGraph (
            IN  IFilterGraph *  pGraph,
            IN  LPCWSTR         pName
            ) ;

        STDMETHODIMP
        Pause (
            ) ;

        STDMETHODIMP
        Stop (
            ) ;

        STDMETHODIMP
        Run (
            IN  REFERENCE_TIME  rtStart
            ) ;

        //  ====================================================================
        //  pure virtual methods in base class

        int
        GetPinCount (
            ) ;

        CBasePin *
        GetPin (
            IN  int
            ) ;

        //  ====================================================================
        //  IFileSourceFilter

        STDMETHODIMP
        Load (
            IN  LPCOLESTR               pszFilename,
            IN  const AM_MEDIA_TYPE *   pmt
            ) ;

        STDMETHODIMP
        GetCurFile (
            OUT LPOLESTR *      ppszFilename,
            OUT AM_MEDIA_TYPE * pmt
            ) ;

        //  ====================================================================
        //  IAMFilterMiscFlags method

        STDMETHODIMP_(ULONG)
        GetMiscFlags (
            )
        {
            //  we must implement this interface and return this value if we
            //  want to be selected as graph clock
            return AM_FILTER_MISC_FLAGS_IS_SOURCE ;
        }

        //  ====================================================================
        //  ISpecifyPropertyPages

        STDMETHODIMP
        GetPages (
            CAUUID * pPages
            ) ;

        //  ====================================================================
        //  class-factory method

        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  punkControlling,
            IN  HRESULT *   phr
            ) ;
} ;

#endif  //  __dvrplay__dvrplay_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dll\tsdvr.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        tsdvr.cpp

    Abstract:

        This module contains ts/dvr registration data and entry points

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <tchar.h>
#include <limits.h>

//  dshow
#include <streams.h>
#include <dvdmedia.h>       //  MPEG2VIDEOINFO

//  WMSDK
#include <wmsdk.h>

#include "dvrdef.h"
#include "dvrfor.h"
#include "dvrtrace.h"
#include "dvrmacros.h"
#include "dvrioidl.h"

//  link in CLSIDs
#include <initguid.h>
#include "dvrds.h"
#include "dvrdspriv.h"
#include "dvrutil.h"
#include "dvrpolicy.h"
#include "dvranalysis.h"
#include "dvrioidl.h"
#include "dvrstats.h"
#include "MultiGraphHost.h"

//  I-frame analysis COM server
#include "dvriframe.h"

//  analysis filter class factory
#include "dvranalysisfiltercf.h"

//  required for all filters
#include "dvrprof.h"
#include "dvrdsseek.h"
#include "dvrpins.h"

//  DVRStreamSink filter
#include "DVRStreamSink.h"

//  DVRStreamSource filter
#include "DVRStreamSource.h"

//  DVRPlay filter
#include "DVRPlay.h"

//  all stats info
#include "dvrstats.h"

//  registration templates
CFactoryTemplate
g_Templates[] = {
    //  ========================================================================
    //  analysis: I-frame
    //  code in ..\analysis\iframe
    {   L"I-Frame Analysis",                        //  display name
        & CLSID_DVRMpeg2VideoFrameAnalysis,         //  CLSID
        CMpeg2VideoFrame::CreateInstance,           //  CF CreateInstance method
        NULL,
        & g_sudMpeg2VideoFrame                      //  not dshow related
    },

    //  ========================================================================
    //  filter: DVRStreamSink
    //  code in ..\filters\DVRStreamSink
    {   L"DVRStreamSink",                           //  display name
        & CLSID_DVRStreamSink,                      //  CLSID
        CDVRStreamSink::CreateInstance,             //  CF CreateInstance method
        NULL,
        & g_sudDVRStreamSink
    },

    //  ========================================================================
    //  filter: DVRStreamSource
    //  code in ..\filters\DVRStreamSource
    {   L"DVRStreamSource",                         //  display name
        & CLSID_DVRStreamSource,                    //  CLSID
        CDVRStreamSource::CreateInstance,           //  CF CreateInstance method
        NULL,
        & g_sudDVRStreamSource
    },

    //  ========================================================================
    //  filter: DVRStreamSource
    //  code in ..\filters\DVRPlay
    {   L"DVRPlay",                                 //  display name
        & CLSID_DVRPlay,                            //  CLSID
        CDVRPlay::CreateInstance,                   //  CF CreateInstance method
        NULL,
        & g_sudDVRPlay
    },

    //  ========================================================================
    //  stats: receiver side
    //  code in ..\util\dvrstats.cpp
    {   L"DVR Stats - receiver side",               //  display name
        & CLSID_DVRReceiverSideStats,               //  CLSID
        CDVRReceiveStatsReader::CreateInstance,     //  CF CreateInstance method
        NULL,
        NULL
    },

    //  ========================================================================
    //  stats: send side
    //  code in ..\util\dvrstats.cpp
    {   L"DVR Stats - sender side",                 //  display name
        & CLSID_DVRSenderSideStats,                 //  CLSID
        CDVRSendStatsReader::CreateInstance,        //  CF CreateInstance method
        NULL,
        NULL
    },

/*
    //  ========================================================================
    //  filter: DVRStreamThrough
    //  code in ..\filters\DVRStreamThrough
    {   L"DVRStreamThrough",                        //  display name
        & CLSID_DVRStreamThrough,                   //  CLSID
        CDVRStreamThrough::CreateInstance,          //  CF CreateInstance method
        NULL,
        & g_sudDVRStreamThrough
    },
*/
    //  ========================================================================
    //  stats: mpeg-2 video stream analysis
    //  code in ..\util\dvrstats.cpp
    {   L"DVR Stats - Mpeg2 Video Stream Analysis",     //  display name
        & CLSID_DVRMpeg2VideoStreamAnalysisStats,       //  CLSID
        CMpeg2VideoStreamStatsReader::CreateInstance,   //  CF CreateInstance method
        NULL,
        NULL
    },

    //  ========================================================================
    //  analysis logic filter host's class factory
    //  code in ..\analysis\filtercf
    {   L"DVR Analysis Filter Class Factory",       //  display name
        & CLSID_DVRAnalysisFilterFactory,           //  CLSID
        CDVRAnalysisFilterCF::CreateInstance,       //  CF CreateInstance method
        NULL,
        NULL
    },
} ;

int g_cTemplates = NUMELMS(g_Templates);

//
// DllRegisterSever
//
// Handle the registration of this filter
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2 (TRUE);
}

//
// DllUnregsiterServer
//
STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2 (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\analysis\mp2frame\dvriframe.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvriframe.h

    Abstract:

        This module contains the mpeg-2 I-Frame detection code; part of
            the analysis framework

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef __analysis__dvriframe_h
#define __analysis__dvriframe_h

extern AMOVIESETUP_FILTER g_sudMpeg2VideoFrame ;

class CMpeg2VideoFrame :
    public CUnknown,
    public IDVRAnalyze,
    public IDVRAnalysisLogicProp
{
    //  ========================================================================
    //
    //  GOP detection:
    //      1. start code prefix "00 00 01"
    //      2. followed by start code "B8"
    //          --> 4 bytes total
    //
    //  I-frame detection:
    //      1. start code prefix "00 00 01"
    //      2. followed by start code "00"
    //      3. followed by 1 byte (don't care):     temporal_reference
    //      4. followed by (bits) "xx00 1xxxx":     mask is 0x38, value is 0x08
    //          --> 6 bytes total
    //
    //  ========================================================================

    enum {
        //  H.262 6.2.2.6
        //  [group_start_code] : 32
        MIN_GOP_HEADER_BUFFER_REQ   = 4,

        //  H.262 6.2.3
        //  [picture_start_code, picture_coding_type] : 45
        MIN_I_FRAME_BUFFER_REQ      = 6,
    } ;

    enum {
        //  H.262 6.2.2.6
        //  [group_start_code, next_start_code()]
        MIN_GOP_HEADER_LENGTH       = 8,

        //  H.262 6.2.3
        //  [picture_start_code, next_start_code()]
        MIN_PICTURE_HEADER_LENGTH   = 8,
    } ;

    enum {
        //  H.262 6.3.8
        //  group_start_code
        GOP_HEADER_START_CODE       = 0xB8,

        //  H.262 6.3.9
        //  picture_start_code
        PICTURE_HEADER_START_CODE   = 0x00,
    } ;

    enum LAST_MARKED {
        LAST_MARKED_GOP_HEADER      = 1,
        LAST_MARKED_I_FRAME         = 2,
        LAST_MARKED_RESTART         = 3,
    } ;

    enum PICTURE_CODING_TYPE {
        I_FRAME = 1,
        B_FRAME = 2,
        P_FRAME = 3,
        OTHER   = 4
    } ;

    //  H.262, table 6-12
    enum {
        INTRA_CODED_VALUE                       = 0x01,
        PREDICTIVE_CODED_VALUE                  = 0x02,
        BIDIRECTIONALLY_PREDICTIVE_CODED_VALUE  = 0x03,
    } ;

    IDVRPostAnalysisSend *                      m_pIDVRPostAnalysisSend ;
    CRITICAL_SECTION                            m_crt ;
    TSizedDataCache <MIN_I_FRAME_BUFFER_REQ>    m_Cache ;
    CTDynQueue <IDVRAnalysisBuffer *>           m_BufferQueue ;
    LAST_MARKED                                 m_LastMarked ;
    CMpeg2VideoStreamStatsWriter                m_Mpeg2VideoStreamStats ;
    CDVRPolicy *                                m_pPolicy ;

    void Lock_ ()       { EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()     { LeaveCriticalSection (& m_crt) ; }

    HRESULT
    CompleteQueuedBuffers_ (
        ) ;

    HRESULT
    Process_ (
        IN  IDVRAnalysisBuffer *,
        OUT BOOL *
        ) ;

    HRESULT
    Complete_ (
        IN  IDVRAnalysisBuffer *
        ) ;

    HRESULT
    QueueBuffer_ (
        IN  IDVRAnalysisBuffer *
        ) ;

    HRESULT
    Restart_ (
        ) ;

    PICTURE_CODING_TYPE
    PictureCodingType_ (
        IN  BYTE *
        ) ;

    public :

        CMpeg2VideoFrame (
            IN  IUnknown *  punkControlling,
            OUT HRESULT *   phr
            ) : CUnknown        (TEXT (DVR_MPEG2_FRAME_ANALYSIS),
                                 punkControlling
                                 ),
                m_LastMarked    (LAST_MARKED_RESTART),
                m_pPolicy       (NULL),
                m_BufferQueue   (MIN_I_FRAME_BUFFER_REQ)
        {
            LONG    l ;
            DWORD   dwDisposition ;
            DWORD   dw ;

            (* phr) = S_OK ;

            InitializeCriticalSection (& m_crt) ;

            m_pPolicy = new CDVRPolicy (REG_DVR_ANALYSIS_LOGIC_MPEG2_VIDEO, phr) ;
            if (!m_pPolicy ||
                FAILED (* phr)) {

                (* phr) = (m_pPolicy ? (* phr) : E_OUTOFMEMORY) ;
                RELEASE_AND_CLEAR (m_pPolicy) ;
                goto cleanup ;
            }

            m_Mpeg2VideoStreamStats.Initialize (m_pPolicy -> Settings () -> StatsEnabled ()) ;

            cleanup :

            return ;
        }

        ~CMpeg2VideoFrame (
            )
        {
            RELEASE_AND_CLEAR (m_pPolicy) ;
            DeleteCriticalSection (& m_crt) ;
        }

        DECLARE_IUNKNOWN ;
        DECLARE_IDVRANALYZE () ;
        DECLARE_IDVRANALYSISLOGICPROP () ;

        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  pIUnknown,
            IN  HRESULT *   phr
            ) ;
} ;

#endif  //  __analysis__dvriframe_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\analysis\mp2frame\dvriframe.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvriframe.cpp

    Abstract:

        This module contains the mpeg-2 I-Frame detection code; part of the
            analysis framework

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#include "dvrall.h"
#include "dvranalysis.h"
#include "dvrstats.h"
#include "dvranalysisutil.h"
#include "dvriframe.h"

static
DVR_ANALYSIS_DESC_INT
g_Mpeg2VideoFrameAnalysis [] = {
    {
        //  ====================================================================
        //  GOP header, if there is one (first frame is guaranteed to be
        //   an I-frame: H.262, 6.1.1.7 "I-pictures and group of pictures
        //   header", last paragraph)
        //
        //  -or-
        //
        //  I-frame if there is no GOP header
        & DVRAnalysis_Mpeg2GOP,
        L"Mpeg2 Group Of Pictures (GOP)"
    },
    {
        //  ====================================================================
        //  P-frame
        & DVRAnalysis_Mpeg2_PFrame,
        L"Mpeg2 video P Frame"
    },
    {
        //  ====================================================================
        //  B-frame
        & DVRAnalysis_Mpeg2_BFrame,
        L"Mpeg2 video B Frame"
    },
} ;

static
LONG
g_Mpeg2VideoFrameAnalysisEnum = sizeof g_Mpeg2VideoFrameAnalysis / sizeof DVR_ANALYSIS_DESC_INT ;

//  ============================================================================

AMOVIESETUP_FILTER
g_sudMpeg2VideoFrame = {
    & CLSID_DVRMpeg2VideoFrameAnalysis,
    TEXT (DVR_MPEG2_FRAME_ANALYSIS),
    MERIT_DO_NOT_USE,
    0,                                          //  no pins advertized
    NULL                                        //  no pins details
} ;

CUnknown *
WINAPI
CMpeg2VideoFrame::CreateInstance (
    IN  IUnknown *  punkOuter,
    IN  HRESULT *   phr
    )
{
    CMpeg2VideoFrame *  pIFrame ;
    CUnknown *          punkFilterHost ;
    IUnknown *          punkThis ;

    pIFrame = new CMpeg2VideoFrame (
                    NULL,               //  don't aggregate this one
                    phr
                    ) ;

    if (FAILED (* phr) ||
        !pIFrame) {

        (* phr) = (FAILED (* phr) ? (* phr) : E_OUTOFMEMORY) ;
        delete pIFrame ;
        return NULL ;
    }

    //  refcount: pIFrame now has a ref of 0

    (* phr) = pIFrame -> QueryInterface (IID_IUnknown, (void **) & punkThis) ;
    ASSERT (SUCCEEDED (* phr)) ;
    ASSERT (punkThis) ;

    //  refcount: pIFrame now has a ref of 1

    (* phr) = CreateDVRAnalysisHostFilter (
                punkOuter,
                punkThis,
                CLSID_DVRMpeg2VideoFrameAnalysis,
                & punkFilterHost
                ) ;

    //  release our ref to the object
    punkThis -> Release () ;

    return punkFilterHost ;
}

STDMETHODIMP
CMpeg2VideoFrame::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    if (riid == IID_IDVRAnalysisLogicProp) {

        return GetInterface (
                    (IDVRAnalysisLogicProp *) this,
                    ppv
                    ) ;
    }

    else if (riid == IID_IDVRAnalyze) {

        return GetInterface (
                    (IDVRAnalyze *) this,
                    ppv
                    ) ;
    }

    return CUnknown::NonDelegatingQueryInterface (riid, ppv) ;
}

HRESULT
CMpeg2VideoFrame::CompleteQueuedBuffers_ (
    )
{
    IDVRAnalysisBuffer *    pIDVRAnalysisBuffer ;
    HRESULT                 hr ;

    hr = S_OK ;

    while (m_BufferQueue.Length () > 0 &&
           SUCCEEDED (hr)) {

        pIDVRAnalysisBuffer = NULL ;
        m_BufferQueue.Pop (& pIDVRAnalysisBuffer) ;
        ASSERT (pIDVRAnalysisBuffer) ;

        //  keep the queue's ref until we've completed it
        hr = m_pIDVRPostAnalysisSend -> CompleteAnalysis (pIDVRAnalysisBuffer) ;
        pIDVRAnalysisBuffer -> Release () ;
    }

    return hr ;
}

CMpeg2VideoFrame::PICTURE_CODING_TYPE
CMpeg2VideoFrame::PictureCodingType_ (
    IN  BYTE *  pbBuffer
    )
{
    PICTURE_CODING_TYPE CodingType ;

    ASSERT (IsStartCodePrefix (pbBuffer)) ;
    ASSERT (StartCode (pbBuffer) == PICTURE_HEADER_START_CODE) ;

    switch ((pbBuffer [5] >> 3) & 0x07) {
        case INTRA_CODED_VALUE :
            CodingType = I_FRAME ;
            m_Mpeg2VideoStreamStats.I_Frame () ;
            break ;

        case PREDICTIVE_CODED_VALUE :
            CodingType = P_FRAME ;
            m_Mpeg2VideoStreamStats.P_Frame () ;
            break ;

        case BIDIRECTIONALLY_PREDICTIVE_CODED_VALUE :
            CodingType = B_FRAME ;
            m_Mpeg2VideoStreamStats.B_Frame () ;
            break ;

        default :
            CodingType = OTHER ;
            break ;
    } ;

    return CodingType ;
}

HRESULT
CMpeg2VideoFrame::Process_ (
    IN  IDVRAnalysisBuffer *    pIDVRAnalysisBuffer,
    OUT BOOL *                  pfAnalysisComplete
    )
{
    BOOL                r ;
    BYTE *              pbCur ;
    LONG                lAdvance ;
    LONG                lBufferLen ;
    LONG                lBufferLeft ;
    LONG                lBufferOffset ;
    BYTE                bStartCode ;
    HRESULT             hr ;
    PICTURE_CODING_TYPE PictureCodingType ;

    ASSERT (m_pIDVRPostAnalysisSend) ;

    hr = pIDVRAnalysisBuffer -> GetBufferLength (& lBufferLen) ;
    if (SUCCEEDED (hr)) {
        lBufferLeft = lBufferLen ;
        hr = pIDVRAnalysisBuffer -> GetBuffer (& pbCur) ;

        //  ====================================================================
        //  BUGBUG: ignore the case where a GOP header or I-frame picture
        //   header spans across DVR Buffers

        while (lBufferLeft > START_CODE_LENGTH &&
               SUCCEEDED (hr)) {

            r = SeekToPrefix (
                    & pbCur,
                    & lBufferLeft
                    ) ;

            if (r &&
                lBufferLeft >= START_CODE_LENGTH) {

                if (StartCode (pbCur) == GOP_HEADER_START_CODE) {
                    //  ========================================================
                    //  GOP header code; mark it
                    lBufferOffset = lBufferLen - lBufferLeft ;
                    hr = pIDVRAnalysisBuffer -> Mark (
                            lBufferOffset,
                            & DVRAnalysis_Mpeg2GOP
                            ) ;

                    if (SUCCEEDED (hr)) {
                        m_LastMarked = LAST_MARKED_GOP_HEADER ;
                    }

                    lAdvance = Min <LONG> (lBufferLeft, MIN_GOP_HEADER_LENGTH) ;

                    m_Mpeg2VideoStreamStats.GOPHeader () ;

                }
                else if (StartCode (pbCur) == PICTURE_HEADER_START_CODE) {
                    if (lBufferLeft >= MIN_I_FRAME_BUFFER_REQ) {

                        PictureCodingType = PictureCodingType_ (pbCur) ;

                        switch (PictureCodingType) {

                            //  I-frame
                            case I_FRAME :
                                //  ============================================
                                //  only mark it if it was *not* immediately
                                //   preceded by a marked GOP header; we prefer to
                                //   mark a GOP header, but if there is none, or if
                                //   we get consecutive I-frames, we'll mark those
                                if (m_LastMarked != LAST_MARKED_GOP_HEADER) {

                                    lBufferOffset = lBufferLen - lBufferLeft ;

                                    hr = pIDVRAnalysisBuffer -> Mark (
                                            lBufferOffset,
                                            & DVRAnalysis_Mpeg2GOP
                                            ) ;
                                }

                                if (SUCCEEDED (hr)) {
                                    m_LastMarked = LAST_MARKED_I_FRAME ;
                                }

                                break ;

                            //  handle none of the others for now; could add
                            //   later though to get frame boundaries for
                            //   all
                            case P_FRAME :
                            case B_FRAME :
                            case OTHER :
                                break ;
                        } ;
                    }
                    else {
                        //  BUGBUG: ignore spanning case for now
                    }

                    lAdvance = Min <LONG> (lBufferLeft, MIN_PICTURE_HEADER_LENGTH) ;
                }
                else {
                    lAdvance = Min <LONG> (lBufferLeft, START_CODE_PREFIX_LENGTH) ;
                }

                pbCur       += lAdvance ;
                lBufferLeft -= lAdvance ;
            }
        }
    }

    //  BUGBUG: we're ignoring the spanning case for now
    (* pfAnalysisComplete) = TRUE ;

    return hr ;
}

HRESULT
CMpeg2VideoFrame::Complete_ (
    IN  IDVRAnalysisBuffer *    pIDVRAnalysisBuffer
    )
{
    HRESULT hr ;

    ASSERT (m_pIDVRPostAnalysisSend) ;

    CompleteQueuedBuffers_ () ;
    hr = m_pIDVRPostAnalysisSend -> CompleteAnalysis (pIDVRAnalysisBuffer) ;

    return hr ;
}

HRESULT
CMpeg2VideoFrame::QueueBuffer_ (
    IN  IDVRAnalysisBuffer *    pIDVRAnalysisBuffer
    )
{
    DWORD   dw ;
    HRESULT hr ;

    dw = m_BufferQueue.Push (pIDVRAnalysisBuffer) ;
    if (dw == NOERROR) {
        //  queue's ref
        pIDVRAnalysisBuffer -> AddRef () ;
    }

    hr = HRESULT_FROM_WIN32 (dw) ;

    return hr ;
}

HRESULT
CMpeg2VideoFrame::Restart_ (
    )
{
    //  reset everything
    //  send any queued buffers we may have
    CompleteQueuedBuffers_ () ;

    m_LastMarked = LAST_MARKED_RESTART ;

    return S_OK ;
}

STDMETHODIMP
CMpeg2VideoFrame::Analyze (
    IN  IDVRAnalysisBuffer *    pIDVRAnalysisBuffer,
    IN  BOOL                    fDiscontinuity
    )
{
    HRESULT hr ;
    BOOL    fAnalysisComplete ;

    if (m_pIDVRPostAnalysisSend) {

        if (fDiscontinuity) {
            Restart_ () ;
        }

        hr = Process_ (
                pIDVRAnalysisBuffer,
                & fAnalysisComplete
                ) ;
        if (SUCCEEDED (hr)) {
            if (fAnalysisComplete) {
                hr = Complete_ (pIDVRAnalysisBuffer) ;
            }
            else {
                hr = QueueBuffer_ (pIDVRAnalysisBuffer) ;
                if (FAILED (hr)) {
                    //  failed to queue; complete what's queued + this one
                    hr = Complete_ (pIDVRAnalysisBuffer) ;
                }
            }
        }
        else {
            //  failed while processing this one; send it through anyways
            hr = Complete_ (pIDVRAnalysisBuffer) ;
        }
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

STDMETHODIMP
CMpeg2VideoFrame::GetDisplayName (
    IN  LPWSTR *    ppszFilterName
    )
{
    int     iLen ;
    HRESULT hr ;

    if (!ppszFilterName) {
        return E_POINTER ;
    }

    iLen = wcslen (DVR_MPEG2_FRAME_ANALYSIS_W) ;

    (* ppszFilterName) = reinterpret_cast <LPWSTR> (CoTaskMemAlloc ((iLen + 1) * sizeof WCHAR)) ;
    if (* ppszFilterName) {
        wcscpy ((* ppszFilterName), DVR_MPEG2_FRAME_ANALYSIS_W) ;
        (* ppszFilterName) [iLen] = L'\0' ;

        hr = S_OK ;
    }
    else {
        hr = E_OUTOFMEMORY ;
    }

    return hr ;
}

HRESULT
CMpeg2VideoFrame::CheckMediaType (
    IN  const AM_MEDIA_TYPE *   pMediaType,
    OUT BOOL *                  pfAccept
    )
{
    if (!pMediaType ||
        !pfAccept) {

        return E_POINTER ;
    }

    (* pfAccept) = (pMediaType -> majortype == MEDIATYPE_Video &&
                    pMediaType -> subtype   == MEDIASUBTYPE_MPEG2_VIDEO ? TRUE : FALSE) ;

    return S_OK ;
}

HRESULT
CMpeg2VideoFrame::SetPostAnalysisSend (
    IN  IDVRPostAnalysisSend *  pIDVRPostAnalysisSend
    )
{
    Lock_ () ;

    //  weak ref !!
    m_pIDVRPostAnalysisSend = pIDVRPostAnalysisSend ;

    Unlock_ () ;

    return S_OK ;
}

HRESULT
CMpeg2VideoFrame::EnumAnalysis (
    OUT LONG *                  plCount,
    OUT DVR_ANALYSIS_DESC **    ppDVRAnalysisDesc    //  callee allocates; caller deallocates
    )
{
    HRESULT hr ;

    if (!plCount ||
        !ppDVRAnalysisDesc) {

        return E_POINTER ;
    }

    (* plCount) = g_Mpeg2VideoFrameAnalysisEnum ;
    hr = CopyDVRAnalysisDescriptor (
            (* plCount),
            g_Mpeg2VideoFrameAnalysis,
            ppDVRAnalysisDesc
            ) ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\dvrstreamsink\dvrstreamsink.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        DVRStreamSink.h

    Abstract:

        This module contains the DVRStreamSink filter declarations.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef __DVRStreamSink__DVRStreamSink_h
#define __DVRStreamSink__DVRStreamSink_h

extern AMOVIESETUP_FILTER   g_sudDVRStreamSink ;

class CDVRStreamSink :
    public CBaseFilter,             //  dshow base classes
    public ISpecifyPropertyPages,
    public IDVRStreamSink
{
    CDVRSinkPinManager *    m_pInputPins ;
    CDVRWriteManager *      m_pWriteManager ;
    CDVRPolicy *            m_pPolicy ;
    CDVRWriter *            m_pDVRWriter ;
    CCritSec                m_RecvLock ;

    //  if both: RECV lock first

    void FilterLock_ ()     { m_pLock -> Lock () ;      }
    void FilterUnlock_ ()   { m_pLock -> Unlock () ;    }

    void RecvLock_ ()       { m_RecvLock.Lock () ; }
    void RecvUnlock_ ()     { m_RecvLock.Unlock () ; }

    HRESULT
    SetWriterActive_ (
        ) ;

    HRESULT
    SetWriterInactive_ (
        ) ;

    CDVRWriter *
    GetWriter_ (
        IN  IWMProfile *    pIWMProfile
        ) ;

    public :

        CDVRStreamSink (
            IN  IUnknown *  punkControlling,
            IN  REFCLSID    rclsid,
            OUT HRESULT *   phr
            ) ;

        ~CDVRStreamSink (
            ) ;

        DECLARE_IUNKNOWN ;

        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        //  ====================================================================
        //  IDVRStreamSink methods

        STDMETHODIMP
        CreateRecorder (
            IN  LPCWSTR     pszFilename,
            IN  DWORD       dwReserved,
            OUT IUnknown ** ppRecordingIUnknown
            ) ;

        STDMETHODIMP
        LockProfile (
            ) ;

        STDMETHODIMP
        IsProfileLocked (
            ) ;

        //  ====================================================================
        //  pure virtual methods in base class

        int
        GetPinCount (
            ) ;

        CBasePin *
        GetPin (
            IN  int
            ) ;

        STDMETHODIMP
        Pause (
            ) ;

        STDMETHODIMP
        Stop (
            ) ;

        STDMETHODIMP
        Run (
            IN  REFERENCE_TIME  rtStart
            ) ;

        //  ====================================================================
        //  ISpecifyPropertyPages
        STDMETHODIMP
        GetPages (
            CAUUID * pPages
            ) ;

        //  ====================================================================
        //  class-factory method

        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  punkControlling,
            IN  HRESULT *   phr
            ) ;
} ;

#endif  //  __DVRStreamSink__DVRStreamSink_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\dvrplay\dvrplay.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        DVRPlay.cpp

    Abstract:

        This module contains the DVRPlay code.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#include "dvrall.h"

#include "dvrclock.h"           //  IReferenceClock
#include "dvrprof.h"            //  WM Profiles
#include "dvrdsseek.h"
#include "dvrpins.h"            //  pins & pin collections
#include "DVRPlay.h"            //  filter declarations
#include "dvrdsread.h"          //  reader

#pragma warning (disable:4355)

AMOVIESETUP_FILTER
g_sudDVRPlay = {
    & CLSID_DVRPlay,
    TEXT (DVR_PLAY_FILTER_NAME),
    MERIT_DO_NOT_USE,
    0,                                          //  no pins advertized
    NULL                                        //  no pins details
} ;

//  ============================================================================

CDVRPlay::CDVRPlay (
    IN  IUnknown *  punkControlling,
    IN  REFCLSID    rclsid,
    OUT HRESULT *   phr
    ) : CBaseFilter     (TEXT (DVR_PLAY_FILTER_NAME),
                         punkControlling,
                         new CCritSec,
                         rclsid
                         ),
        m_pOutputPins   (NULL),
        m_pPolicy       (NULL),
        m_pReader       (NULL),
        m_pszFilename   (NULL),
        m_SeekingCore   (m_pLock,
                         this
                         ),
        m_pDVRClock     (NULL)          //  don't set this until we know if we're live or not
{
    DWORD   dwDisposition ;
    DWORD   dw ;
    LONG    l ;

    TRACE_CONSTRUCTOR (TEXT ("CDVRPlay")) ;

    //  settings object
    m_pPolicy = new CDVRPolicy (REG_DVR_PLAY_ROOT, phr) ;

    if (!m_pLock ||
        !m_pPolicy ||
        FAILED (* phr)) {

        (* phr) = E_FAIL ;

        goto cleanup ;
    }

    m_pOutputPins = new CDVRSourcePinManager (
                            m_pPolicy,
                            this,
                            m_pLock,
                            & m_SeekingCore
                            ) ;
    if (!m_pOutputPins) {
        (* phr) = E_OUTOFMEMORY ;
        goto cleanup ;
    }

    //  set the source pin manager
    m_SeekingCore.SetDVRSourcePinManager (m_pOutputPins) ;

    //  success
    (* phr) = S_OK ;

    cleanup :

    return ;
}

CDVRPlay::~CDVRPlay (
    )
{
    int         i ;
    CBasePin *  pPin ;

    TRACE_DESTRUCTOR (TEXT ("CDVRPlay")) ;

    UnloadASFFile_ () ;

    delete m_pReader ;
    delete m_pOutputPins ;
    delete m_pDVRClock ;

    RELEASE_AND_CLEAR (m_pPolicy) ;
    DELETE_RESET_ARRAY (m_pszFilename) ;
}

STDMETHODIMP
CDVRPlay::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    //  ------------------------------------------------------------------------
    //  ISpecifyPropertyPages; allows an app to enumerate CLSIDs for our
    //   property pages

    if (riid == IID_ISpecifyPropertyPages) {

        return GetInterface (
                    (ISpecifyPropertyPages *) this,
                    ppv
                    ) ;
    }

    //  ------------------------------------------------------------------------
    //  IFileSourceFilter;

    else if (riid == IID_IFileSourceFilter) {

        return GetInterface (
                    (IFileSourceFilter *) this,
                    ppv
                    ) ;
    }

    //  ------------------------------------------------------------------------
    //  IReferenceClock

    else if (riid == IID_IReferenceClock    &&
             m_pDVRClock                    &&
             m_pPolicy -> Settings () -> CanImplementIReferenceClock ()) {

        ASSERT (m_pOutputPins -> IsLiveSource ()) ;
        return GetInterface (
                    (IReferenceClock *) m_pDVRClock,
                    ppv
                    ) ;
    }

    //  ------------------------------------------------------------------------
    //  IAMFilterMiscFlags; must implement this interface if we're to be picked
    //   as graph clock; same conditions as IReferenceClock since these are
    //   related

    else if (riid == IID_IAMFilterMiscFlags &&
             m_pDVRClock                    &&
             m_pPolicy -> Settings () -> CanImplementIReferenceClock ()) {

        return GetInterface (
                    (IAMFilterMiscFlags *) this,
                    ppv
                    ) ;
    }

    return CBaseFilter::NonDelegatingQueryInterface (riid, ppv) ;
}

int
CDVRPlay::GetPinCount (
    )
{
    int i ;

    LockFilter_ () ;

    i = m_pOutputPins -> PinCount () ;

    UnlockFilter_ () ;

    return i ;
}

CBasePin *
CDVRPlay::GetPin (
    IN  int i
    )
{
    CBasePin *  pPin ;

    LockFilter_ () ;

    pPin = m_pOutputPins -> GetPin (i) ;

    UnlockFilter_ () ;

    return pPin ;
}

STDMETHODIMP
CDVRPlay::GetPages (
    CAUUID * pPages
    )
{
    HRESULT hr ;

    pPages -> cElems = 1 ;
    pPages -> pElems = reinterpret_cast <GUID *> (CoTaskMemAlloc (pPages -> cElems * sizeof GUID)) ;

    if (pPages -> pElems) {
        (pPages -> pElems) [0] = CLSID_DVRPlayProp ;
        hr = S_OK ;
    }
    else {
        hr = E_OUTOFMEMORY ;
    }

    return hr ;
}

STDMETHODIMP
CDVRPlay::JoinFilterGraph (
    IN  IFilterGraph *  pGraph,
    IN  LPCWSTR         pName
    )
{
    HRESULT hr ;

    if (pGraph) {
        //  on our way in
        hr = CBaseFilter::JoinFilterGraph (pGraph, pName) ;
        if (SUCCEEDED (hr)) {
            hr = LoadASFFile_ () ;
            if (FAILED (hr)) {
                CBaseFilter::JoinFilterGraph (NULL, NULL) ;
            }
        }
    }
    else {
        //  on our way out
        hr = CBaseFilter::JoinFilterGraph (pGraph, pName) ;
        if (SUCCEEDED (hr)) {
            UnloadASFFile_ () ;
        }
    }

    return hr ;
}

STDMETHODIMP
CDVRPlay::Load (
    IN  LPCOLESTR               pszFilename,
    IN  const AM_MEDIA_TYPE *   pmt             //  can be NULL
    )
{
    HRESULT hr ;

    if (!pszFilename) {
        return E_POINTER ;
    }

    LockFilter_ () ;

    DELETE_RESET_ARRAY (m_pszFilename) ;

    m_pszFilename = new WCHAR [lstrlenW (pszFilename) + 1] ;
    if (m_pszFilename) {
        lstrcpyW (m_pszFilename, pszFilename) ;
        hr = LoadASFFile_ () ;
    }
    else {
        hr = E_OUTOFMEMORY ;
    }

    UnlockFilter_ () ;

    return hr ;
}

STDMETHODIMP
CDVRPlay::GetCurFile (
    OUT LPOLESTR *      ppszFilename,
    OUT AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr ;

    if (!ppszFilename ||
        !pmt) {

        return E_POINTER ;
    }

    LockFilter_ () ;

    if (m_pszFilename) {
        (* ppszFilename) = reinterpret_cast <LPOLESTR> (CoTaskMemAlloc ((lstrlenW (m_pszFilename) + 1) * sizeof OLECHAR)) ;
        if (* ppszFilename) {

            //  outgoing filename
            lstrcpyW ((* ppszFilename), m_pszFilename) ;

            //  and media type
            pmt->majortype      = GUID_NULL;
            pmt->subtype        = GUID_NULL;
            pmt->pUnk           = NULL;
            pmt->lSampleSize    = 0;
            pmt->cbFormat       = 0;

            hr = S_OK ;
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }
    else {
        hr = E_UNEXPECTED ;
    }

    UnlockFilter_ () ;

    return hr ;
}

CUnknown *
WINAPI
CDVRPlay::CreateInstance (
    IN  IUnknown *  punkControlling,
    IN  HRESULT *   phr
    )
{
    CDVRPlay *    pCDVRPlay ;

    pCDVRPlay = new CDVRPlay (
                            punkControlling,
                            CLSID_DVRPlay,
                            phr
                            ) ;
    if (!pCDVRPlay ||
        FAILED (* phr)) {

        (* phr) = (FAILED (* phr) ? (* phr) : E_OUTOFMEMORY) ;
        DELETE_RESET (pCDVRPlay) ;
    }

    return pCDVRPlay ;
}

HRESULT
CDVRPlay::LoadASFFile_ (
    )
{
    HRESULT             hr ;
    CDVRReaderProfile * pDVRReaderProfile ;

    hr = S_OK ;

    LockFilter_ () ;

    //  if we're in a graph and have a filename
    if (m_pGraph &&
        m_pszFilename) {

        //  and have not yet instantiated a reader
        if (!m_pReader) {

            //  instantiate now
            m_pReader = new CDVRRecordingReader (
                                m_pszFilename,
                                m_pPolicy,
                                m_pOutputPins,
                                & hr
                                ) ;
            if (m_pReader &&
                SUCCEEDED (hr)) {

                hr = m_pReader -> GetRefdReaderProfile (
                        & pDVRReaderProfile
                        ) ;
                if (SUCCEEDED (hr)) {
                    ASSERT (pDVRReaderProfile) ;
                    hr = m_pOutputPins -> SetReaderProfile (pDVRReaderProfile) ;
                    pDVRReaderProfile -> Release () ;

                    //  if we're reading from a live file, need to clock slave
                    if (m_pReader -> IsLiveSource () &&
                        !m_pDVRClock) {

                        m_pDVRClock = new CDVRClock (GetOwner (), & hr) ;
                        if (!m_pDVRClock) {
                            hr = E_OUTOFMEMORY ;
                        }
                    }
                }
            }
            else {
                hr = (m_pReader ? hr : E_OUTOFMEMORY) ;
            }
        }
    }

    if (SUCCEEDED (hr)) {
        m_SeekingCore.SetDVRReadManager (m_pReader) ;
        m_pOutputPins -> SetLiveSource (m_pDVRClock ? TRUE : FALSE) ;
    }
    else {
        //  reset if anything failed
        DELETE_RESET (m_pReader) ;
        DELETE_RESET (m_pDVRClock) ;
        m_pOutputPins -> SetLiveSource (FALSE) ;
    }


    UnlockFilter_ () ;

    return hr ;
}

HRESULT
CDVRPlay::UnloadASFFile_ (
    )
{
    DELETE_RESET (m_pReader) ;
    return S_OK ;
}

STDMETHODIMP
CDVRPlay::Pause (
    )
{
    HRESULT hr ;

    //  prevent others from manipulating the reader thread
    m_pReader -> ReaderThreadLock () ;

    LockFilter_ () ;

    if (m_State == State_Stopped) {
        //  transition to running

        ASSERT (m_pOutputPins) ;
        hr = m_pOutputPins -> Active () ;
        if (SUCCEEDED (hr)) {
            hr = m_pReader -> Active (m_pClock, m_pDVRClock) ;
            if (SUCCEEDED (hr)) {
                m_State = State_Paused ;
            }
        }
    }
    else {
        m_State = State_Paused ;
        hr = S_OK ;
    }

    UnlockFilter_ () ;

    m_pReader -> ReaderThreadUnlock () ;

    return hr ;
}

STDMETHODIMP
CDVRPlay::Stop (
    )
{
    HRESULT hr ;

    //  prevent others from manipulating the reader thread
    m_pReader -> ReaderThreadLock () ;

    //  don't grab the filter lock while this happens or we expose ourselves
    //   to a deadlock scenario (we've got the filter lock, and we're waiting
    //   synchronously for reader thread to pause, and it's blocked waiting for
    //   the filter lock)
    hr = m_pReader -> Inactive () ;

    //
    //  reader thread is now terminated, and no one is going to start it (we've
    //   got the reader thread lock); it's safe to grab the filter lock
    //

    if (SUCCEEDED (hr)) {

        LockFilter_ () ;

        ASSERT (m_pOutputPins) ;
        m_pOutputPins -> Inactive () ;

        m_State = State_Stopped ;

        UnlockFilter_ () ;
    }

    m_pReader -> ReaderThreadUnlock () ;

    return hr ;
}

STDMETHODIMP
CDVRPlay::Run (
    IN  REFERENCE_TIME  rtStart
    )
{
    return CBaseFilter::Run (rtStart) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\dvrstreamsink\dvrstreamsink.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        DVRStreamSink.cpp

    Abstract:

        This module contains the DVRStreamSink filter code.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#include "dvrall.h"

#include "dvrprof.h"            //  WM Profiles
#include "dvrdsseek.h"          //  pins reference seeking interfaces
#include "dvrpins.h"            //  pins & pin collections
#include "dvrdswrite.h"         //  writer
#include "DVRStreamSink.h"      //  filter declarations

//  disable so we can use 'this' in the initializer list
#pragma warning (disable:4355)

AMOVIESETUP_FILTER
g_sudDVRStreamSink = {
    & CLSID_DVRStreamSink,
    TEXT (DVR_STREAM_SINK_FILTER_NAME),
    MERIT_DO_NOT_USE,
    0,                                          //  no pins advertized
    NULL                                        //  no pins details
} ;

//  ============================================================================

CDVRStreamSink::CDVRStreamSink (
    IN  IUnknown *  punkControlling,
    IN  REFCLSID    rclsid,
    OUT HRESULT *   phr
    ) : CBaseFilter     (TEXT (DVR_STREAM_SINK_FILTER_NAME),
                         punkControlling,
                         new CCritSec,
                         rclsid
                         ),
        m_pInputPins    (NULL),
        m_pWriteManager (NULL),
        m_pDVRWriter    (NULL),
        m_pPolicy       (NULL)
{
    LONG    l ;
    DWORD   dwDisposition ;
    DWORD   dw ;

    TRACE_CONSTRUCTOR (TEXT ("CDVRStreamSink")) ;

    if (FAILED (* phr)) {
        goto cleanup ;
    }

    m_pPolicy = new CDVRPolicy (REG_DVR_STREAM_SINK_ROOT, phr) ;

    if (!m_pLock ||
        !m_pPolicy ||
        FAILED (* phr)) {

        (* phr) = E_FAIL ;
        goto cleanup ;
    }

    m_pWriteManager = new CDVRWriteManager (m_pPolicy) ;
    if (!m_pWriteManager) {
        (* phr) = E_OUTOFMEMORY ;
        goto cleanup ;
    }

    m_pInputPins = new CDVRSinkPinManager (
                            m_pPolicy,
                            this,
                            m_pLock,
                            & m_RecvLock,
                            m_pWriteManager,
                            phr
                            ) ;
    if (!m_pInputPins ||
        FAILED (* phr)) {

        (* phr) = (m_pInputPins ? (* phr) : E_OUTOFMEMORY) ;
        goto cleanup ;
    }

    //  need at least 1 input pin to successfully instantiate
    (* phr) = (m_pInputPins -> PinCount () > 0 ? S_OK : E_FAIL) ;

    cleanup :

    return ;
}

CDVRStreamSink::~CDVRStreamSink (
    )
{
    CBasePin *  pPin ;
    int         i ;

    TRACE_DESTRUCTOR (TEXT ("CDVRStreamSink")) ;

    SetWriterInactive_ () ;
    ASSERT (m_pDVRWriter == NULL) ;

    //  clear out the input pins
    if (m_pInputPins) {
        i = 0 ;
        do {
            pPin = m_pInputPins -> GetPin (i++) ;
            delete pPin ;
        } while (pPin) ;
    }

    delete m_pInputPins ;
    delete m_pWriteManager ;

    RELEASE_AND_CLEAR (m_pPolicy) ;
}

STDMETHODIMP
CDVRStreamSink::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    //  ------------------------------------------------------------------------
    //  ISpecifyPropertyPages; allows an app to enumerate CLSIDs for our
    //   property pages

    if (riid == IID_ISpecifyPropertyPages) {

        return GetInterface (
                    (ISpecifyPropertyPages *) this,
                    ppv
                    ) ;
    }

    //  ------------------------------------------------------------------------
    //  IDVRStreamSink

    if (riid == IID_IDVRStreamSink) {

        return GetInterface (
                    (IDVRStreamSink *) this,
                    ppv
                    ) ;
    }

    if (riid == IID_IDVRStreamSinkPriv) {

        if (m_pDVRWriter) {
            return GetInterface (
                        (IDVRStreamSinkPriv *) m_pDVRWriter,
                        ppv
                        ) ;
        }
        else {
            return E_UNEXPECTED ;
        }
    }

    return CBaseFilter::NonDelegatingQueryInterface (riid, ppv) ;
}
int
CDVRStreamSink::GetPinCount (
    )
{
    int i ;

    TRACE_ENTER_0 (TEXT ("CDVRStreamSink::GetPinCount ()")) ;

    m_pLock -> Lock () ;

    //  input + output pins
    i = m_pInputPins -> PinCount () ;

    m_pLock -> Unlock () ;

    return i ;
}

CBasePin *
CDVRStreamSink::GetPin (
    IN  int iIndex
    )
{
    CBasePin *  pPin ;
    DWORD       dw ;

    TRACE_ENTER_1 (
        TEXT ("CDVRStreamSink::GetPin (%d)"),
        iIndex
        ) ;

    m_pLock -> Lock () ;

    pPin = m_pInputPins -> GetPin (
            iIndex
            ) ;

    //
    //  don't refcount the pin; this is one of dshow's quazi-COM calls
    //

    m_pLock -> Unlock () ;

    return pPin ;
}

STDMETHODIMP
CDVRStreamSink::GetPages (
    CAUUID * pPages
    )
{
    HRESULT hr ;

    pPages -> cElems = 1 ;
    pPages -> pElems = reinterpret_cast <GUID *> (CoTaskMemAlloc (pPages -> cElems * sizeof GUID)) ;

    if (pPages -> pElems) {
        (pPages -> pElems) [0] = CLSID_DVRStreamSinkProp ;
        hr = S_OK ;
    }
    else {
        hr = E_OUTOFMEMORY ;
    }

    return hr ;
}

CUnknown *
WINAPI
CDVRStreamSink::CreateInstance (
    IN  IUnknown *  punkControlling,
    IN  HRESULT *   phr
    )
{
    CDVRStreamSink *    pCDVRStreamSink ;

    TRACE_ENTER_0 (TEXT ("CDVRStreamSink::CreateInstance ()")) ;

    pCDVRStreamSink = new CDVRStreamSink (
                            punkControlling,
                            CLSID_DVRStreamSink,
                            phr
                            ) ;
    if (!pCDVRStreamSink ||
        FAILED (* phr)) {

        (* phr) = (FAILED (* phr) ? (* phr) : E_OUTOFMEMORY) ;
        DELETE_RESET (pCDVRStreamSink) ;
    }

    return pCDVRStreamSink ;
}

CDVRWriter *
CDVRStreamSink::GetWriter_ (
    IN  IWMProfile *    pIWMProfile
    )
{
    HRESULT         hr ;
    CDVRWriter *    pWMWriter ;

    //  don't inline attributes
    pWMWriter = new CDVRIOWriter (
                        static_cast <IDVRStreamSink *> (this),      //  punk, MH forces us to pick
                        m_pPolicy,
                        pIWMProfile,
                        & hr
                        ) ;

    if (!pWMWriter ||
        FAILED (hr)) {

        DELETE_RESET (pWMWriter) ;
    }

    return pWMWriter ;
}

HRESULT
CDVRStreamSink::SetWriterActive_ (
    )
{
    HRESULT hr ;

    hr = LockProfile () ;
    if (SUCCEEDED (hr)) {
        ASSERT (m_pDVRWriter) ;
        hr = m_pWriteManager -> Active (
                m_pDVRWriter,
                m_pClock
                ) ;
    }

    return hr ;
}

HRESULT
CDVRStreamSink::SetWriterInactive_ (
    )
{
    HRESULT hr ;

    hr = m_pWriteManager -> Inactive () ;
    DELETE_RESET (m_pDVRWriter) ;

    return hr ;
}

STDMETHODIMP
CDVRStreamSink::Pause (
    )
{
    HRESULT         hr ;

    FilterLock_ () ;

    if (m_State == State_Stopped) {

        //  stopped -> paused

        //  don't try to activate the writer unless we've got at least 1
        //   stream; if this check was not here, an inert DVRStreamSink sitting
        //   in a filtergraph would prevent it from running
        if (m_pInputPins -> GetProfileStreamCount () > 0) {
            hr = SetWriterActive_ () ;
        }
        else {
            hr = S_OK ;
        }

        if (SUCCEEDED (hr)) {
            hr = m_pInputPins -> Active () ;
        }
    }
    else {
        //  run -> paused

        //  BUGBUG: we're a rendering filter, so we really need to pause here
        hr = S_OK ;
    }

    if (SUCCEEDED (hr)) {
        m_State = State_Paused ;
    }

    FilterUnlock_ () ;

    return hr ;
}

STDMETHODIMP
CDVRStreamSink::Stop (
    )
{
    HRESULT hr ;

    hr = S_OK ;

    RecvLock_ () ;
    FilterLock_ () ;

    hr = SetWriterInactive_ () ;
    if (SUCCEEDED (hr)) {
        hr = m_pInputPins -> Inactive () ;
        if (SUCCEEDED (hr)) {
            m_State = State_Stopped ;
        }
    }

    FilterUnlock_ () ;
    RecvUnlock_ () ;

    return hr ;
}

STDMETHODIMP
CDVRStreamSink::Run (
    IN  REFERENCE_TIME  rtStart
    )
{
    if (m_pDVRWriter) {
        m_pWriteManager -> SetGraphStart (rtStart) ;
    }
    else {
        ASSERT (m_pInputPins -> GetProfileStreamCount () == 0) ;
    }

    return CBaseFilter::Run (rtStart) ;
}

STDMETHODIMP
CDVRStreamSink::CreateRecorder (
    IN  LPCWSTR     pszFilename,
    IN  DWORD       dwReserved,
    OUT IUnknown ** ppRecordingIUnknown
    )
{
    HRESULT hr ;

    FilterLock_ () ;

    if (m_pDVRWriter) {
        hr = m_pDVRWriter -> CreateRecorder (
                pszFilename,
                dwReserved,
                ppRecordingIUnknown
                ) ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    FilterUnlock_ () ;

    return hr ;
}

STDMETHODIMP
CDVRStreamSink::LockProfile (
    )
{
    HRESULT         hr ;
    IWMProfile *    pIWMProfile ;

    FilterLock_ () ;

    if (m_pDVRWriter == NULL) {
        if (m_pInputPins -> GetProfileStreamCount () > 0) {
            hr = m_pInputPins -> GetRefdWMProfile (& pIWMProfile) ;
            if (SUCCEEDED (hr)) {
                ASSERT (pIWMProfile) ;
                m_pDVRWriter = GetWriter_ (pIWMProfile) ;
                pIWMProfile -> Release () ;
            }
        }
        else {
            //  must have at least 1 stream in order to lock the profile
            hr = E_UNEXPECTED ;
        }
    }
    else {
        //  already locked
        hr = S_OK ;
    }

    FilterUnlock_ () ;

    return hr ;
}

STDMETHODIMP
CDVRStreamSink::IsProfileLocked (
    )
{
    HRESULT         hr ;

    FilterLock_ () ;

    if (m_pDVRWriter == NULL) {
        // not locked
        hr = S_FALSE;
    }
    else {
        //  already locked
        hr = S_OK ;
    }

    FilterUnlock_ () ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\dvrstreamsource\dvrstreamsource.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        DVRStreamSource.cpp

    Abstract:

        This module contains the DVRStreamSource code.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#include "dvrall.h"

#include "dvrclock.h"           //  IReferenceClock
#include "dvrprof.h"            //  WM Profiles
#include "dvrdsseek.h"          //  pins reference seeking interfaces
#include "dvrpins.h"            //  pins & pin collections
#include "DVRStreamSource.h"    //  filter declarations
#include "dvrdsread.h"          //  reader
#include "MultiGraphHost.h"     //  Multi Graph Host Service

#pragma warning (disable:4355)

AMOVIESETUP_FILTER
g_sudDVRStreamSource = {
    & CLSID_DVRStreamSource,
    TEXT (DVR_STREAM_SOURCE_FILTER_NAME),
    MERIT_DO_NOT_USE,
    0,                                          //  no pins advertized
    NULL                                        //  no pins details
} ;

//  ============================================================================

CDVRStreamSource::CDVRStreamSource (
    IN  IUnknown *  punkControlling,
    IN  REFCLSID    rclsid,
    OUT HRESULT *   phr
    ) : CBaseFilter     (TEXT (DVR_STREAM_SOURCE_FILTER_NAME),
                         punkControlling,
                         new CCritSec,
                         rclsid
                         ),
        m_pOutputPins   (NULL),
        m_pPolicy       (NULL),
        m_pReader       (NULL),
        m_SeekingCore   (m_pLock,
                         this
                         ),
        m_pDVRClock     (NULL)
{
    DWORD   dwDisposition ;
    DWORD   dw ;
    LONG    l ;

    TRACE_CONSTRUCTOR (TEXT ("CDVRStreamSource")) ;

    m_pPolicy = new CDVRPolicy (REG_DVR_STREAM_SOURCE_ROOT, phr) ;

    if (!m_pLock ||
        !m_pPolicy ||
        FAILED (* phr)) {

        (* phr) = E_FAIL ;
        goto cleanup ;
    }

    m_pDVRClock = new CDVRClock (GetOwner (), phr) ;
    if (!m_pDVRClock ||
        FAILED (* phr)) {

        (* phr) = (m_pDVRClock ? (* phr) : E_OUTOFMEMORY) ;
        goto cleanup ;
    }

    //  success
    (* phr) = S_OK ;

    cleanup :

    return ;
}

CDVRStreamSource::~CDVRStreamSource (
    )
{
    int         i ;
    CBasePin *  pPin ;

    TRACE_DESTRUCTOR (TEXT ("CDVRStreamSource")) ;

    delete m_pReader ;
    delete m_pOutputPins ;

    RELEASE_AND_CLEAR (m_pPolicy) ;
}

STDMETHODIMP
CDVRStreamSource::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    //  ------------------------------------------------------------------------
    //  ISpecifyPropertyPages; allows an app to enumerate CLSIDs for our
    //   property pages

    if (riid == IID_ISpecifyPropertyPages) {

        return GetInterface (
                    (ISpecifyPropertyPages *) this,
                    ppv
                    ) ;
    }

    //  ------------------------------------------------------------------------
    //  IDVRStreamSource

    else if (riid == IID_IDVRStreamSource) {

        return GetInterface (
                    (IDVRStreamSource *) this,
                    ppv
                    ) ;
    }

    //  ------------------------------------------------------------------------
    //  IReferenceClock

    else if (riid == IID_IReferenceClock &&
             m_pPolicy -> Settings () -> CanImplementIReferenceClock ()) {

        //  all ducks should be in row
        ASSERT (m_pDVRClock) ;
        return GetInterface (
                    (IReferenceClock *) m_pDVRClock,
                    ppv
                    ) ;
    }

    //  ------------------------------------------------------------------------
    //  IAMFilterMiscFlags; must implement this interface if we're to be picked
    //   as graph clock;

    else if (riid == IID_IAMFilterMiscFlags &&
             m_pPolicy -> Settings () -> CanImplementIReferenceClock ()) {

        return GetInterface (
                    (IAMFilterMiscFlags *) this,
                    ppv
                    ) ;
    }

    return CBaseFilter::NonDelegatingQueryInterface (riid, ppv) ;
}

int
CDVRStreamSource::GetPinCount (
    )
{
    int i ;

    LockFilter_ () ;

    if (m_pOutputPins) {
        i = m_pOutputPins -> PinCount () ;
    }
    else {
        i = 0 ;
    }

    UnlockFilter_ () ;

    return i ;
}

CBasePin *
CDVRStreamSource::GetPin (
    IN  int i
    )
{
    CBasePin *  pPin ;

    LockFilter_ () ;

    if (m_pOutputPins) {
        pPin = m_pOutputPins -> GetPin (i) ;
    }
    else {
        pPin = NULL ;
    }

    UnlockFilter_ () ;

    return pPin ;
}

STDMETHODIMP
CDVRStreamSource::GetPages (
    CAUUID * pPages
    )
{
    HRESULT hr ;

    pPages -> cElems = 1 ;
    pPages -> pElems = reinterpret_cast <GUID *> (CoTaskMemAlloc (pPages -> cElems * sizeof GUID)) ;

    if (pPages -> pElems) {
        (pPages -> pElems) [0] = CLSID_DVRStreamSourceProp ;
        hr = S_OK ;
    }
    else {
        hr = E_OUTOFMEMORY ;
    }

    return hr ;
}

CUnknown *
WINAPI
CDVRStreamSource::CreateInstance (
    IN  IUnknown *  punkControlling,
    IN  HRESULT *   phr
    )
{
    CDVRStreamSource *    pCDVRStreamSource ;

    pCDVRStreamSource = new CDVRStreamSource (
                            punkControlling,
                            CLSID_DVRStreamSource,
                            phr
                            ) ;
    if (!pCDVRStreamSource ||
        FAILED (* phr)) {

        (* phr) = (FAILED (* phr) ? (* phr) : E_OUTOFMEMORY) ;
        DELETE_RESET (pCDVRStreamSource) ;
    }

    return pCDVRStreamSource ;
}

STDMETHODIMP
CDVRStreamSource::SetStreamSink (
    IN  IDVRStreamSink *    pIDVRStreamSink
    )
{
    HRESULT                 hr ;
    CDVRReaderProfile *     pDVRReaderProfile ;

    if (!pIDVRStreamSink) {
        return E_POINTER ;
    }

    if (m_pOutputPins) {
        ASSERT (m_pReader) ;

        //  we've already been set
        return E_UNEXPECTED ;
    }

    LockFilter_ () ;

    ASSERT (m_pReader == NULL) ;

    //  instantiate our output pin bank
    m_pOutputPins = new CDVRSourcePinManager (
                            m_pPolicy,
                            this,
                            m_pLock,
                            & m_SeekingCore,
                            TRUE                //  live source
                            ) ;
    if (m_pOutputPins) {
        //  we've got our output pin bank;
        //  instantiate our reader
        m_pReader = new CDVRBroadcastStreamReader (
                            pIDVRStreamSink,
                            m_pPolicy,
                            m_pOutputPins,
                            & hr
                            ) ;
        if (m_pReader &&
            SUCCEEDED (hr)) {

            //  now retrieve the reader's profile, and set it on the pins
            hr = m_pReader -> GetRefdReaderProfile (& pDVRReaderProfile) ;
            if (SUCCEEDED (hr)) {
                hr = m_pOutputPins -> SetReaderProfile (pDVRReaderProfile) ;
                pDVRReaderProfile -> Release () ;
            }
        }
    }
    else {
        hr = E_OUTOFMEMORY ;
    }

    if (SUCCEEDED (hr)) {
        ASSERT (m_pOutputPins) ;
        m_SeekingCore.SetDVRSourcePinManager (m_pOutputPins) ;

        ASSERT (m_pReader) ;
        m_SeekingCore.SetDVRReadManager (m_pReader) ;
    }
    else {
        DELETE_RESET (m_pReader) ;
        DELETE_RESET (m_pOutputPins) ;
    }

    UnlockFilter_ () ;

    return hr ;
}

STDMETHODIMP
CDVRStreamSource::Pause (
    )
{
    HRESULT hr ;

    //  prevent others from manipulating the reader thread
    m_pReader -> ReaderThreadLock () ;

    LockFilter_ () ;

    if (m_State == State_Stopped) {
        //  transition to running

        ASSERT (m_pOutputPins) ;
        hr = m_pOutputPins -> Active () ;
        if (SUCCEEDED (hr)) {
            hr = m_pReader -> Active (m_pClock, m_pDVRClock) ;
            if (SUCCEEDED (hr)) {
                m_State = State_Paused ;
            }
        }
    }
    else {
        m_State = State_Paused ;
        hr = S_OK ;
    }

    UnlockFilter_ () ;

    m_pReader -> ReaderThreadUnlock () ;

    return hr ;
}

STDMETHODIMP
CDVRStreamSource::Stop (
    )
{
    HRESULT hr ;

    //  prevent others from manipulating the reader thread
    m_pReader -> ReaderThreadLock () ;

    //  don't grab the filter lock while this happens or we expose ourselves
    //   to a deadlock scenario (we'd have the filter lock, and wait
    //   synchronously for reader thread to pause, and it's blocked waiting for
    //   the filter lock)
    hr = m_pReader -> Inactive () ;

    //
    //  reader thread is now terminated, and no one is going to start it (we've
    //   got the reader thread lock); it's safe to grab the filter lock
    //

    if (SUCCEEDED (hr)) {

        LockFilter_ () ;

        ASSERT (m_pOutputPins) ;
        m_pOutputPins -> Inactive () ;

        m_State = State_Stopped ;

        UnlockFilter_ () ;
    }

    m_pReader -> ReaderThreadUnlock () ;

    return hr ;
}

STDMETHODIMP
CDVRStreamSource::Run (
    IN  REFERENCE_TIME  rtStart
    )
{
    return CBaseFilter::Run (rtStart) ;
}

STDMETHODIMP
CDVRStreamSource::JoinFilterGraph(
    IN  IFilterGraph * pGraphParam,
    IN  LPCWSTR pName)
{
    HRESULT hr;
    IFilterGraph * pGraph = pGraphParam ;

    if (! pGraphParam && m_pGraph )
    {
        hr = m_pGraph -> QueryInterface (
                                    IID_IFilterGraph,
                                    (void **) & pGraph
                                    ) ;
        if (FAILED (hr))
        {
            // Just to be safe ...

            pGraph = NULL ;
        }
    }

    hr = CBaseFilter::JoinFilterGraph (pGraphParam, pName) ;

    if (SUCCEEDED (hr) && pGraph )
    {
        HRESULT hrTmp ;
        IServiceProvider * pSvcProvider ;
        IMultiGraphHost *  pSvc ;

        hrTmp = pGraph -> QueryInterface (
                                IID_IServiceProvider,
                                (void **) & pSvcProvider
                                ) ;
        if (FAILED (hrTmp))
        {
            return hr ;
        }
        hrTmp = pSvcProvider -> QueryService (
                                    GUID_MultiGraphHostService,
                                    IID_IMultiGraphHost,
                                    (void **) & pSvc
                                    ) ;
        pSvcProvider -> Release () ;

        if (FAILED (hrTmp))
        {
            return hr ;
        }

        IGraphBuilder    * pGraphBuilder  = NULL ;

        hrTmp = pGraph -> QueryInterface (
                                IID_IGraphBuilder,
                                (void **) & pGraphBuilder
                                ) ;
        if (FAILED (hrTmp))
        {
            pSvc -> Release () ;
            return hr ;
        }
        pSvc -> LiveSourceReader (
                    pGraphParam ? TRUE : FALSE,
                    pGraphBuilder
                    ) ;


        pGraphBuilder -> Release ();
        pSvc -> Release () ;
    }

    if (pGraph && ! pGraphParam)
    {
        pGraph -> Release () ;
    }
    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\dvrstreamthrough\dvrstreamthrough.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        DVRStreamThrough.cpp

    Abstract:

        This module contains the DVRStreamThrough filter code.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#include "dvrall.h"

#include "dvrprof.h"                //  WMSDK profile
#include "dvrdsseek.h"              //  pins reference seeking interfaces
#include "dvrpins.h"                //  pins & pin collections
#include "dvrdswrite.h"             //  writer
#include "DVRStreamThrough.h"       //  filter declarations

//  disable so we can use 'this' in the initializer list
#pragma warning (disable:4355)

AMOVIESETUP_FILTER
g_sudDVRStreamThrough = {
    & CLSID_DVRStreamThrough,
    TEXT (DVR_STREAM_THROUGH_FILTER_NAME),
    MERIT_DO_NOT_USE,
    0,                                          //  no pins advertized
    NULL                                        //  no pins details
} ;

//  ============================================================================

CDVRStreamThrough::CDVRStreamThrough (
    IN  IUnknown *  punkControlling,
    IN  REFCLSID    rclsid,
    OUT HRESULT *   phr
    ) : CBaseFilter     (TEXT (DVR_STREAM_THROUGH_FILTER_NAME),
                         punkControlling,
                         new CCritSec,
                         rclsid
                         ),
        m_pInputPins    (NULL),
        m_pOutputPins   (NULL),
        m_pSettings     (NULL)
{
    DWORD   dwDisposition ;
    DWORD   dw ;
    LONG    l ;

    TRACE_CONSTRUCTOR (TEXT ("CDVRStreamThrough")) ;

    m_pSettings = new CTSDVRSettings (REG_DVR_STREAM_THROUGH_ROOT) ;

    if (!m_pLock ||
        !m_pSettings) {
        (* phr) = E_OUTOFMEMORY ;
        goto cleanup ;
    }

    m_pInputPins = new CDVRThroughSinkPinManager (
                            m_pSettings,
                            this,
                            m_pLock,
                            & m_RecvLock,
                            this,
                            this,
                            phr
                            ) ;
    if (!m_pInputPins ||
        FAILED (* phr)) {

        (* phr) = (m_pInputPins ? (* phr) : E_OUTOFMEMORY) ;
        goto cleanup ;
    }

    m_pOutputPins = new CDVRSourcePinManager (
                            m_pSettings,
                            this,
                            m_pLock
                            ) ;
    if (!m_pOutputPins ||
        FAILED (* phr)) {

        (* phr) = (m_pOutputPins ? (* phr) : E_OUTOFMEMORY) ;
        goto cleanup ;
    }

    //  need at least 1 input pin to successfully instantiate
    (* phr) = (m_pInputPins -> PinCount () > 0 ? S_OK : E_FAIL) ;

    cleanup :

    return ;
}

CDVRStreamThrough::~CDVRStreamThrough (
    )
{
    CBasePin *  pPin ;
    int         i ;

    TRACE_DESTRUCTOR (TEXT ("CDVRStreamThrough")) ;

    //  clear out the input pins
    if (m_pInputPins) {
        i = 0 ;
        do {
            pPin = m_pInputPins -> GetPin (i++) ;
            delete pPin ;
        } while (pPin) ;
    }

    //  clear out the output pins
    if (m_pOutputPins) {
        i = 0 ;
        do {
            pPin = m_pOutputPins -> GetPin (i++) ;
            delete pPin ;
        } while (pPin) ;
    }

    delete m_pOutputPins ;
    delete m_pInputPins ;

    RELEASE_AND_CLEAR (m_pSettings) ;
}

int
CDVRStreamThrough::GetPinCount (
    )
{
    int i ;

    TRACE_ENTER_0 (TEXT ("CDVRStreamThrough::GetPinCount ()")) ;

    m_pLock -> Lock () ;

    //  input + output pins
    i = m_pInputPins -> PinCount () + m_pOutputPins -> PinCount () ;

    m_pLock -> Unlock () ;

    return i ;
}

CBasePin *
CDVRStreamThrough::GetPin (
    IN  int iIndex
    )
{
    CBasePin *  pPin ;
    DWORD       dw ;

    TRACE_ENTER_1 (
        TEXT ("CDVRStreamThrough::GetPin (%d)"),
        iIndex
        ) ;

    m_pLock -> Lock () ;

    if (iIndex < m_pInputPins -> PinCount ()) {
        //  input pin
        pPin = m_pInputPins -> GetPin (
                iIndex
                ) ;
    }
    else if (iIndex < m_pInputPins -> PinCount () + m_pOutputPins -> PinCount ()) {
        //  output pin
        pPin = m_pOutputPins -> GetPin (
                iIndex - m_pInputPins -> PinCount ()        //  index includes input pins
                ) ;
    }
    else {
        //  out of range
        pPin = NULL ;
    }

    //
    //  don't refcount the pin; this is one of dshow's quazi-COM calls
    //

    m_pLock -> Unlock () ;

    return pPin ;
}

CUnknown *
WINAPI
CDVRStreamThrough::CreateInstance (
    IN  IUnknown *  punkControlling,
    OUT HRESULT *   phr
    )
{
    CDVRStreamThrough *    pCDVRStreamThrough ;

    TRACE_ENTER_2 (
        TEXT ("CDVRStreamThrough::CreateInstance (%08xh, %08xh)"),
        punkControlling,
        phr
        ) ;

    pCDVRStreamThrough = new CDVRStreamThrough (
                            punkControlling,
                            CLSID_DVRStreamThrough,
                            phr
                            ) ;
    if (!pCDVRStreamThrough ||
        FAILED (* phr)) {

        (* phr) = (FAILED (* phr) ? (* phr) : E_OUTOFMEMORY) ;
        DELETE_RESET (pCDVRStreamThrough) ;
    }

    return pCDVRStreamThrough ;
}

HRESULT
CDVRStreamThrough::OnReceive (
    IN  int                         iPinIndex,
    IN  CDVRAttributeTranslator *   pTranslator,
    IN  IMediaSample *              pIMediaSample
    )
{
    TRACE_ENTER_2 (
        TEXT ("CDVRStreamThrough::OnReceive (%d, %08xh)"),
        iPinIndex,
        pIMediaSample
        ) ;

    return S_OK ;
}

HRESULT
CDVRStreamThrough::OnBeginFlush (
    IN  int iPinIndex
    )
{
    TRACE_ENTER_1 (
        TEXT ("CDVRStreamThrough::OnBeginFlush (%d)"),
        iPinIndex
        ) ;

    return S_OK ;
}

HRESULT
CDVRStreamThrough::OnEndFlush (
    IN  int iPinIndex
    )
{
    TRACE_ENTER_1 (
        TEXT ("CDVRStreamThrough::OnEndFlush (%d)"),
        iPinIndex
        ) ;

    return S_OK ;
}

HRESULT
CDVRStreamThrough::OnEndOfStream (
    IN  int iPinIndex
    )
{
    TRACE_ENTER_1 (
        TEXT ("CDVRStreamThrough::OnEndOfStream (%d)"),
        iPinIndex
        ) ;

    return S_OK ;
}

HRESULT
CDVRStreamThrough::OnInputCompleteConnect (
    IN  int             iPinIndex,
    IN  AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_1 (
        TEXT ("CDVRStreamThrough::OnInputCompleteConnect (%d)"),
        iPinIndex
        ) ;

    //  create the output pin
    hr = m_pOutputPins -> CreateOutputPin (
            iPinIndex,
            pmt
            ) ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\dvrstreamsource\dvrstreamsource.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        DVRStreamSource.h

    Abstract:

        This module contains the DVRStreamSource declarations.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef __DVRStreamSource__DVRStreamSource_h
#define __DVRStreamSource__DVRStreamSource_h

extern AMOVIESETUP_FILTER   g_sudDVRStreamSource ;

class CDVRStreamSource :
    public CBaseFilter,
    public ISpecifyPropertyPages,
    public IAMFilterMiscFlags,
    public IDVRStreamSource
{
    CDVRSourcePinManager *      m_pOutputPins ;
    CDVRPolicy *                m_pPolicy ;
    CDVRBroadcastStreamReader * m_pReader ;
    CDVRDShowSeekingCore        m_SeekingCore ;
    CDVRClock *                 m_pDVRClock ;

    void LockFilter_ ()         { m_pLock -> Lock () ; }
    void UnlockFilter_ ()       { m_pLock -> Unlock () ; }

    public :

        CDVRStreamSource (
            IN  IUnknown *  punkControlling,
            IN  REFCLSID    rclsid,
            OUT HRESULT *   phr
            ) ;

        ~CDVRStreamSource (
            ) ;

        DECLARE_IUNKNOWN ;

        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
             ) ;

        //  ====================================================================
        //  IDVRStreamSource

        STDMETHODIMP
        SetStreamSink (
            IN  IDVRStreamSink *    pIDVRStreamSink
            ) ;

        //  ====================================================================
        //  base class

        STDMETHODIMP
        Pause (
            ) ;

        STDMETHODIMP
        Stop (
            ) ;

        STDMETHODIMP
        Run (
            IN  REFERENCE_TIME  rtStart
            ) ;

        STDMETHODIMP
        JoinFilterGraph (
            IN IFilterGraph * pFilterGraph ,
            IN LPCWSTR pName
             ) ;

        int
        GetPinCount (
            ) ;

        CBasePin *
        GetPin (
            IN  int
            ) ;

        //  ====================================================================
        //  IAMFilterMiscFlags method

        STDMETHODIMP_(ULONG)
        GetMiscFlags (
            )
        {
            //  we must implement this interface and return this value if we
            //  want to be selected as graph clock
            return AM_FILTER_MISC_FLAGS_IS_SOURCE ;
        }

        //  ====================================================================
        //  ISpecifyPropertyPages
        STDMETHODIMP
        GetPages (
            CAUUID * pPages
            ) ;

        //  ====================================================================
        //  class-factory method

        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  punkControlling,
            IN  HRESULT *   phr
            ) ;
} ;

#endif  //  __DVRStreamSource__DVRStreamSource_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\shared\dvrdsread.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrdsread.cpp

    Abstract:

        This module contains the code for our reading layer.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        02-Apr-2001     created

--*/

#include "dvrall.h"

#include "dvrprof.h"
#include "dvrdsseek.h"          //  pins reference seeking interfaces
#include "dvrpins.h"
#include "dvrdsread.h"

#pragma warning (disable:4355)

static
HRESULT
GetDVRReadController (
    IN  DWORD                   dwPlaySpeedBracket,
    IN  CDVRReadManager *       pDVRReadManager,
    IN  CDVRSourcePinManager *  pDVRSourcePinManager,
    IN  CDVRPolicy *            pPolicy,
    IN  CDVRSendStatsWriter *   pDVRSendStatsWriter,
    OUT CDVRReadController **   ppCDVRReadController
    )
{
    HRESULT hr ;

    ASSERT (pPolicy) ;
    ASSERT (pDVRReadManager) ;
    ASSERT (pDVRSourcePinManager) ;
    ASSERT (ppCDVRReadController) ;
    ASSERT (pDVRSendStatsWriter) ;

    //  BUGBUG: for now ignore media types, etc..

    switch (dwPlaySpeedBracket) {
        case PLAY_SPEED_BRACKET_FORWARD :
            (* ppCDVRReadController) = new CDVR_F1X_ReadController (
                                                pDVRReadManager,
                                                pDVRSourcePinManager,
                                                pPolicy,
                                                pDVRSendStatsWriter
                                                ) ;
            hr = ((* ppCDVRReadController) ? S_OK : E_OUTOFMEMORY) ;
            break ;

        //  fast reverse
        case PLAY_SPEED_BRACKET_FAST_REVERSE :
        case PLAY_SPEED_BRACKET_REVERSE :
        case PLAY_SPEED_BRACKET_SLOW_REVERSE :
        case PLAY_SPEED_BRACKET_SLOW_FORWARD :
        case PLAY_SPEED_BRACKET_FAST_FORWARD :
            //  not implemented
            hr = E_NOTIMPL ;
            break ;

        default :
            ASSERT (0) ;
            hr = E_FAIL ;
            break ;
    }

    return hr ;
}

static
DWORD
PlayrateToBracket (
    IN  double  dRate
    )
{
    //  this should not get filtered here
    ASSERT (dRate != 0.0) ;

    if (dRate < 1.0) {
        //  fast reverse
        return PLAY_SPEED_BRACKET_FAST_REVERSE ;        //  (.., -1x)
    }
    else if (dRate == -1.0) {
        //  reverse
        return PLAY_SPEED_BRACKET_REVERSE ;             //  -1x
    }
    else if (dRate > -1.0 && dRate < 0.0) {
        //  slow reverse
        return PLAY_SPEED_BRACKET_SLOW_REVERSE ;        //  (-1x, 0x)
    }
    else if (dRate > 0.0 && dRate < 1.0) {
        //  slow forward
        return PLAY_SPEED_BRACKET_SLOW_FORWARD ;        //  (0x, 1x)
    }
    else if (dRate == 1.0) {
        //  forward
        return PLAY_SPEED_BRACKET_FORWARD ;             //  1x
    }
    else {
        //  fast forward
        return PLAY_SPEED_BRACKET_FAST_FORWARD ;        //  (1x, ..)
    }
}

//  ============================================================================
//  CDVRDShowReader
//  ============================================================================

CDVRDShowReader::CDVRDShowReader (
    IN  CDVRPolicy *        pPolicy,
    IN  IDVRReader *        pIDVRReader,
    OUT HRESULT *           phr
    ) : m_pIDVRReader   (pIDVRReader),
        m_pPolicy     (pPolicy)
{
    ASSERT (m_pIDVRReader) ;
    m_pIDVRReader -> AddRef () ;

    ASSERT (m_pPolicy) ;
    m_pPolicy -> AddRef () ;

    (* phr) = S_OK ;

    return ;
}

CDVRDShowReader::~CDVRDShowReader (
    )
{
    m_pPolicy -> Release () ;
    m_pIDVRReader -> Release () ;
}

HRESULT
CDVRDShowReader::GetRefdReaderProfile (
    OUT CDVRReaderProfile **    ppDVRReaderProfile
    )
{
    HRESULT hr ;

    ASSERT (ppDVRReaderProfile) ;

    //  this is a low frequency operation, so it's ok to allocate
    (* ppDVRReaderProfile) = new CDVRReaderProfile (m_pPolicy, m_pIDVRReader, & hr) ;
    if (!(* ppDVRReaderProfile) ||
        FAILED (hr)) {

        hr = ((* ppDVRReaderProfile) ? hr : E_OUTOFMEMORY) ;
        DELETE_RESET (* ppDVRReaderProfile) ;
    }

    return hr ;
}

HRESULT
CDVRDShowReader::Read (
    OUT INSSBuffer **   ppINSSBuffer,
    OUT QWORD *         pcnsStreamTimeOfSample,
    OUT QWORD *         pcnsSampleDuration,
    OUT DWORD *         pdwFlags,
    OUT WORD *          pwStreamNum
    )
{
    QWORD qwDuration;

    ASSERT (m_pIDVRReader) ;
    return m_pIDVRReader -> GetNextSample (
                ppINSSBuffer,
                pcnsStreamTimeOfSample,
                pcnsSampleDuration,
                pdwFlags,
                pwStreamNum
                ) ;
}

//  ============================================================================
//  CDVRDReaderThread
//  ============================================================================

HRESULT
CDVRDReaderThread::ThreadCmd_ (
    IN  DWORD   dwCmd
    )
{
    HRESULT hr ;

    //
    //  caller must lock & unlock wrt calls to CmdWait !!
    //

    if (ThreadExists ()) {

        //  send to the worker thread
        m_dwParam = dwCmd ;
        m_EventSend.Set() ;

        //  but don't wait for him to ack
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRDReaderThread::CmdWaitAck_ (
    IN  DWORD   dwCmd
    )
{
    HRESULT hr ;

    //
    //  caller must lock & unlock wrt calls to ThreadCmd !!
    //

    if (ThreadExists ()) {

        //  make sure we're waiting on the right command
        if (m_dwParam == dwCmd) {
            // wait for the completion to be signalled
            m_EventComplete.Wait() ;

            // done - this is the thread's return value
            hr = HRESULT_FROM_WIN32 (m_dwReturnVal) ;
        }
        else {
            hr = E_UNEXPECTED ;
        }
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRDReaderThread::WaitThreadExited_ (
    )
{
    HRESULT hr ;

    ASSERT (m_dwParam == THREAD_MSG_EXIT) ;

    if (m_hThread) {
        WaitForSingleObject (m_hThread, INFINITE) ;
        CloseHandle (m_hThread) ;
        m_hThread = NULL ;
        hr = S_OK ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRDReaderThread::StartThread_ (
    IN  DWORD   dwInitialCmd
    )
{
    BOOL    r ;
    HRESULT hr ;

    m_AccessLock.Lock () ;

    r = Create () ;
    if (!r && !ThreadExists ()) {
        hr = E_FAIL ;
        goto cleanup ;
    }

    hr = ThreadCmdWaitAck_ (dwInitialCmd) ;

    cleanup :

    m_AccessLock.Unlock () ;

    return hr ;
}

void
CDVRDReaderThread::RuntimeThreadProc_ (
    )
{
    DWORD   dw ;
    HRESULT hr ;

    hr = S_OK ;

    while (SUCCEEDED (hr) &&
           !CheckRequest (& dw)) {

        hr = m_pHost -> Process () ;
        if (FAILED (hr) &&
            !CheckRequest (& dw)) {

            TRACE_ERROR_1 (TEXT ("CDVRDReaderThread::RuntimeThreadProc_ : ReadWrapAndSend_ returned %08xh"), hr) ;

            hr = m_pHost -> ErrorHandler (hr) ;
        }
    }
}

DWORD
CDVRDReaderThread::ThreadProc (
    )
{
    DWORD   dwCmd ;
    DWORD   dwRet ;

    for (;;) {

        dwCmd = GetRequest () ;

        switch (dwCmd) {
            case THREAD_MSG_EXIT :
                Reply (S_OK) ;
                return 0 ;

            case THREAD_MSG_GO_PAUSED :
            case THREAD_MSG_PAUSE :
                Reply (S_OK) ;
                break ;

            case THREAD_MSG_GO :
                Reply (S_OK) ;
                RuntimeThreadProc_ () ;
                break ;

            default :
                return 0 ;
        } ;
    }
}

//  ============================================================================
//  CDVRReadController
//  ============================================================================

CDVRReadController::CDVRReadController (
    IN  CDVRReadManager *       pDVRReadManager,
    IN  CDVRSourcePinManager *  pDVRSourcePinManager,
    IN  CDVRPolicy *            pPolicy,
    IN  CDVRSendStatsWriter *   pDVRSendStatsWriter
    ) : m_pDVRReadManager       (pDVRReadManager),
        m_pDVRSourcePinManager  (pDVRSourcePinManager),
        m_pPolicy               (pPolicy),
        m_pDVRSendStatsWriter   (pDVRSendStatsWriter)
{
    ASSERT (m_pDVRReadManager) ;
    ASSERT (m_pDVRSourcePinManager) ;
    ASSERT (m_pPolicy) ;
    ASSERT (m_pDVRSendStatsWriter) ;

    m_pPolicy -> AddRef () ;
}

CDVRReadController::~CDVRReadController (
    )
{
    InternalFlush_ () ;
    m_pPolicy -> Release () ;
}

HRESULT
CDVRReadController::ErrorHandler (
    IN  HRESULT hr
    )
{
    switch (hr) {
        case NS_E_NO_MORE_SAMPLES :

            TRACE_0 (LOG_AREA_DSHOW, 1,
                TEXT ("CDVRReadController::ErrorHandler got NS_E_NO_MORE_SAMPLES, calling OnEndOfStream_ ()")) ;

            OnEndOfStream_ () ;
            //  leave the failure code so the reader thread exits upon
            //    return
            break ;

        case VFW_E_SAMPLE_TIME_NOT_SET :
            //  we're probably on a new segment boundary and just tried to
            //   send down a sample of timestamped media type, that is not
            //   timestamped; not a real failure because we'll keep trying
            //   until a media sample that is timestamped is found and sent
            //   down
            hr = S_OK ;

            TRACE_0 (LOG_AREA_DSHOW, 1,
                TEXT ("CDVRReadController::ErrorHandler got VFW_E_SAMPLE_TIME_NOT_SET, setting hr to S_OK")) ;

            break ;

        default :

            TRACE_1 (LOG_AREA_DSHOW, 1,
                TEXT ("CDVRReadController::ErrorHandler got %08xh, calling ReadControllerFailure_"),
                hr) ;

            //  all others are passed out wholesale
            hr = ReadFailure_ (hr) ;
            break ;
    }

    TRACE_1 (LOG_AREA_DSHOW, 1,
        TEXT ("CDVRReadController::ErrorHandler : returning %08xh"),
        hr) ;

    return hr ;
}

HRESULT
CDVRReadController::SendSample_ (
    IN  IMediaSample2 * pIMediaSample2,
    IN  CDVROutputPin * pDVROutputPin,
    IN  AM_MEDIA_TYPE * pmtNew
    )
{
    HRESULT hr ;

    hr = pDVROutputPin -> SendSample (pIMediaSample2, pmtNew) ;

    m_pDVRSendStatsWriter -> SampleOut (
        pDVROutputPin -> GetBankStoreIndex (),
        pIMediaSample2,
        m_pDVRReadManager -> RefClock ()
        )  ;

    return hr ;
}

//  ============================================================================
//  CDVR_F_ReadController
//  ============================================================================

HRESULT
CDVR_F_ReadController::ReadFailure_ (
    IN  HRESULT hr
    )
{
    //  forward read failure - might have tried to read stale data

    QWORD   qwSegStart ;

    TRACE_1 (LOG_AREA_DSHOW, 1,
        TEXT ("CDVR_F_ReadController::ReadFailure_ : got %08xh"),
        hr) ;

    m_pDVRReadManager -> ReaderReset () ;

    //
    //  may have tried to read from a time hole, or stale location; the HR
    //   code will tell us this & it's something we can recover from
    //

    if (hr == HRESULT_FROM_WIN32 (ERROR_SEEK)) {

        //  we'll try to restart from where we read last
        qwSegStart = m_pDVRReadManager -> GetLastRead () ;

        TRACE_1 (LOG_AREA_DSHOW, 1,
            TEXT ("CDVR_F_ReadController::ReadFailure_ : got HRESULT_FROM_WIN32 (ERROR_SEEK) .. handling; check/set %I64u"),
            qwSegStart) ;

        hr = m_pDVRReadManager -> CheckSetStartWithinContent (& qwSegStart) ;
        if (SUCCEEDED (hr)) {

            TRACE_1 (LOG_AREA_DSHOW, 1,
                TEXT ("CDVR_F_ReadController::ReadFailure_ : CheckSetStartWithinContent reset qwSegStart to %I64u; seeking to .."),
                qwSegStart) ;

            //  now seek the reader to the start
            hr = m_pDVRReadManager -> SeekReader (& qwSegStart) ;
            if (SUCCEEDED (hr)) {
                //  all went well: update, notify new segment, and resume

                TRACE_0 (LOG_AREA_DSHOW, 1,
                    TEXT ("CDVR_F_ReadController::ReadFailure_ : SeekReader success; setting & notifying new segment")) ;

                //  last good seek location was this
                m_pDVRReadManager -> SetLastRead (qwSegStart) ;

                //  notify new segment boundaries (only start should change)
                m_pDVRReadManager -> SetNewSegmentStart (qwSegStart) ;
                m_pDVRReadManager -> NotifyNewSegment () ;
            }
        }
    }

    return hr ;
}

//  ============================================================================
//  ============================================================================

CDVR_F1X_ReadController::CDVR_F1X_ReadController (
    IN  CDVRReadManager *       pDVRReadManager,
    IN  CDVRSourcePinManager *  pDVRSourcePinManager,
    IN  CDVRPolicy *            pPolicy,
    IN  CDVRSendStatsWriter *   pDVRSendStatsWriter
    ) : CDVR_F_ReadController   (pDVRReadManager, pDVRSourcePinManager, pPolicy, pDVRSendStatsWriter),
        m_rtPTSNormalizer       (UNDEFINED),
        m_pStreamsBitField      (NULL)
{
    Initialize () ;
}

HRESULT
CDVR_F1X_ReadController::ReadWrapAndSend_ (
    )
{
    HRESULT         hr ;
    IMediaSample2 * pIMediaSample2 ;
    INSSBuffer *    pINSSBuffer ;
    CDVROutputPin * pDVROutputPin ;
    AM_MEDIA_TYPE * pmtNew ;

    //  read and get an IMediaSample2-wrapped INSSBuffer
    hr = m_pDVRReadManager -> ReadAndWaitWrap (& pIMediaSample2, & pINSSBuffer, & pDVROutputPin, & pmtNew) ;

    if (SUCCEEDED (hr)) {

        ASSERT (pIMediaSample2) ;
        ASSERT (pDVROutputPin) ;

        hr = NormalizePTSAndSend_ (pIMediaSample2, pDVROutputPin, pmtNew) ;
    }

    return hr ;
}

HRESULT
CDVR_F1X_ReadController::Process (
    )
{
    HRESULT hr ;

    switch (m_ReadCtrlrState) {
        //  --------------------------------------------------------------------
        //  discovering the PTS normalizing val make take a few iterations - we
        //   may be started before the writer goes, in which case we'll
        //   encounter a recoverable error, but won't discover the value on that
        //   iteration
        case DISCOVER_PTS_NORMALIZER :

            ASSERT (!PTSNormalizingValDiscovered_ ()) ;
            hr = TryDiscoverPTSNormalizingVal_ () ;

            //  check if we're done for this state
            if (SUCCEEDED (hr) &&
                PTSNormalizingValDiscovered_ ()) {

                //  cannot have discover the normalizer val without having
                //   read in (and queued) >= 1 media sample
                ASSERT (!MediaSampleQueueEmpty_ ()) ;

                //  we've discovered the PTS normalizing val
                m_ReadCtrlrState = DISCOVER_QUEUE_SEND ;
            }

            //  always break so the reader thread has a sufficiently fine
            //   granularity of check against pending commands
            break ;

        //  --------------------------------------------------------------------
        //  we've now discovered the normalizing val & queued a number of media
        //   samples in the process; send them out
        case DISCOVER_QUEUE_SEND :

            ASSERT (PTSNormalizingValDiscovered_ ()) ;
            if (!MediaSampleQueueEmpty_ ()) {
                hr = SendNextQueued_ () ;
            }
            else {
                //  we've somehow ended up in this state, with an empty media
                //   sample queue; don't fail, but we'll move to the next state
                //   the next time around
                hr = S_OK ;
            }

            //  check if we're done for this state
            if (SUCCEEDED (hr) &&
                MediaSampleQueueEmpty_ ()) {

                //  we've sent the queue we built up during PTS normalizer val
                //   discovery
                m_ReadCtrlrState = STEADY_STATE ;
            }

            //  always break so the reader thread has a sufficiently fine
            //   granularity of check against pending commands
            break ;

        //  --------------------------------------------------------------------
        //  then transition to runtime state
        case STEADY_STATE :
            hr = ReadWrapAndSend_ () ;
            break ;
    } ;

    return hr ;
}

HRESULT
CDVR_F1X_ReadController::Initialize (
    )
{
    m_ReadCtrlrState    = DISCOVER_PTS_NORMALIZER ;
    m_rtPTSNormalizer   = UNDEFINED ;

    FlushMediaSampleQueue_ () ;

    return S_OK ;
}

HRESULT
CDVR_F1X_ReadController::FlushMediaSampleQueue_ (
    )
{
    IMediaSample2 * pIMediaSample2 ;
    CDVROutputPin * pDVROutputPin ;
    AM_MEDIA_TYPE * pmtNew ;
    HRESULT         hr ;

    hr = S_OK ;

    while (!m_PTSNormDiscQueue.Empty () &&
           SUCCEEDED (hr)) {

        hr = m_PTSNormDiscQueue.Pop (& pIMediaSample2, & pDVROutputPin, & pmtNew) ;
        if (SUCCEEDED (hr)) {
            //  we manage the queue's refs on COM interfaces
            pIMediaSample2 -> Release () ;
            delete pmtNew ;

            TRACE_3 (LOG_AREA_DSHOW, 5,
                TEXT ("CDVR_F1X_ReadController::::FlushMediaSampleQueue_ : flushed %08xh %08xh %08xh"),
                pIMediaSample2, pDVROutputPin, pmtNew) ;
        }
    }

    return hr ;
}

HRESULT
CDVR_F1X_ReadController::SendNextQueued_ (
    )
{
    IMediaSample2 * pIMediaSample2 ;
    CDVROutputPin * pDVROutputPin ;
    AM_MEDIA_TYPE * pmtNew ;
    HRESULT         hr ;

    //  should not be getting called if the queue is empty
    ASSERT (!MediaSampleQueueEmpty_ ()) ;
    hr = m_PTSNormDiscQueue.Pop (& pIMediaSample2, & pDVROutputPin, & pmtNew) ;

    TRACE_3 (LOG_AREA_DSHOW, 5,
        TEXT ("CDVR_F1X_ReadController::::SendNextQueued_ : popped %08xh %08xh %08xh"),
        pIMediaSample2, pDVROutputPin, pmtNew) ;

    //  queue is not empty per the first assert
    ASSERT (SUCCEEDED (hr)) ;
    ASSERT (pIMediaSample2) ;
    ASSERT (pDVROutputPin) ;
    //  pmtNew can, and usually will, be NULL

    hr = NormalizePTSAndSend_ (pIMediaSample2, pDVROutputPin, pmtNew) ;

    return hr ;
}

HRESULT
CDVR_F1X_ReadController::NormalizePTSAndSend_ (
    IN  IMediaSample2 * pIMediaSample2,
    IN  CDVROutputPin * pDVROutputPin,
    IN  AM_MEDIA_TYPE * pmtNew
    )
{
    HRESULT hr ;

    //  only send it if it's connected
    if (pDVROutputPin -> IsConnected ()) {
        //  normalize
        hr = NormalizeTimestamps_ (pIMediaSample2) ;
        if (SUCCEEDED (hr)) {
            //  and send
            hr = SendSample_ (
                        pIMediaSample2,
                        pDVROutputPin,
                        pmtNew
                        ) ;
        }
    }
    else {
        //  don't fail the call
        hr = S_OK ;
    }

    //  we're done with the media sample
    pIMediaSample2 -> Release () ;

    return hr ;
}

HRESULT
CDVR_F1X_ReadController::NormalizeTimestamps_ (
    IN  IMediaSample2 * pIMediaSample2
    )
{
    HRESULT         hr ;
    REFERENCE_TIME  rtStart ;
    REFERENCE_TIME  rtStop ;

    //  get the timestamp
    hr = pIMediaSample2 -> GetTime (& rtStart, & rtStop) ;

    if (hr != VFW_E_SAMPLE_TIME_NOT_SET) {
        //  there's at least a start time; normalize both
        rtStart -= Min <REFERENCE_TIME> (rtStart, m_rtPTSNormalizer) ;
        rtStop  -= Min <REFERENCE_TIME> (rtStop, m_rtPTSNormalizer) ;

        //  add back in the desired downstream buffering
        rtStart += m_pDVRReadManager -> DownstreamBuffering () ;
        rtStop  += m_pDVRReadManager -> DownstreamBuffering () ;

        //  set the normalized start/stop values on the media sample
        hr = pIMediaSample2 -> SetTime (
                & rtStart,
                (hr == S_OK ? & rtStop : NULL)
                ) ;
    }
    else {
        //  no timestamp; so nothing to normalize; succes
        hr = S_OK ;
    }

    return hr ;
}

HRESULT
CDVR_F1X_ReadController::TryDiscoverPTSNormalizingVal_ (
    )
{
    HRESULT hr ;
    QWORD   qwPlayStart ;
    QWORD   qwSegStart ;
    QWORD   qwSegStop ;

    m_pDVRReadManager -> GetCurSegmentBoundaries (& qwSegStart, & qwSegStop) ;

    //  start where we hope to land
    qwPlayStart = qwSegStart ;
    hr = FindPTSNormalizerVal_ (& qwPlayStart) ;

    if (SUCCEEDED (hr)) {

        //  last read is this
        m_pDVRReadManager -> SetLastRead (qwPlayStart) ;

        //  mark off our segment boundaries & notify
        m_pDVRReadManager ->  SetNewSegmentStart (qwPlayStart) ;
        m_pDVRReadManager ->  NotifyNewSegment () ;
    }
    else {
        //  failed; make sure we're not holding any media samples
        FlushMediaSampleQueue_ () ;

        //  reset in case we try again
        m_pDVRReadManager -> SetLastRead (qwSegStart) ;
    }

    return hr ;
}

HRESULT
CDVR_F1X_ReadController::FindPTSNormalizerVal_ (
    IN OUT  QWORD * pcnsStreamStart
    )
{
    HRESULT         hr ;
    IMediaSample2 * pIMediaSample2 ;
    INSSBuffer *    pINSSBuffer ;
    CDVROutputPin * pDVROutputPin ;
    int             iStreamCount ;
    int             iStreamsTallied ;
    REFERENCE_TIME  rtCurMin ;
    REFERENCE_TIME  rtStart ;
    REFERENCE_TIME  rtStop ;
    int             iReads ;
    AM_MEDIA_TYPE * pmtNew ;

    //  should always start this with an empty queue
    ASSERT (MediaSampleQueueEmpty_ ()) ;

    //  this method discovers the smallest timestamp, by reading from the
    //  specified starting point and ratcheting a value down

    //  make sure we have a bitfield
    if (m_pStreamsBitField == NULL ||
        m_pStreamsBitField -> BitfieldSize () < m_pDVRReadManager -> StreamCount ()) {

        DELETE_RESET (m_pStreamsBitField) ;

        m_pStreamsBitField = new CSimpleBitfield (m_pDVRReadManager -> StreamCount (), & hr) ;
        if (m_pStreamsBitField == NULL ||
            FAILED (hr)) {

            hr = (m_pStreamsBitField ? hr : E_OUTOFMEMORY) ;

            DELETE_RESET (m_pStreamsBitField) ;

            return hr ;
        }
    }

    //  clear the bitfield
    m_pStreamsBitField -> ClearAll () ;

    //  get the stream count
    iStreamCount = m_pDVRReadManager -> StreamCount () ;

    //  set the count of streams tallied to 0
    iStreamsTallied = 0 ;

    //  seek the reader to the desired offset
    hr = m_pDVRReadManager -> SeekReader (pcnsStreamStart) ;

    //  init to max so we immediately ratchet down
    rtCurMin = MAX_REFERENCE_TIME ;

    //  undefine whatever normalizing val we currently use
    m_rtPTSNormalizer = UNDEFINED ;

    //  while we don't haven't examined timestamps from all the streams,
    //   read the out and check
    for (iReads = 0;
         iReads < MAX_PTS_NORM_DISCOVERY_READS && SUCCEEDED (hr) && iStreamsTallied < iStreamCount;
         iReads++) {

        hr = m_pDVRReadManager -> ReadAndTryWrap (
                & pIMediaSample2,
                & pINSSBuffer,
                & pDVROutputPin,
                & pmtNew
                ) ;
        if (SUCCEEDED (hr)) {

            ASSERT (pIMediaSample2) ;
            ASSERT (pDVROutputPin) ;

            hr = pIMediaSample2 -> GetTime (& rtStart, & rtStop) ;
            if (hr != VFW_E_SAMPLE_TIME_NOT_SET) {
                //  sample has a time;
                //  have we seen this stream yet ?
                if (!m_pStreamsBitField -> IsSet (pDVROutputPin -> GetBankStoreIndex ())) {
                    //  one more stream examined
                    iStreamsTallied++ ;

                    m_pStreamsBitField -> Set (pDVROutputPin -> GetBankStoreIndex ()) ;
                }

                //  ratchet down
                rtCurMin = Min <REFERENCE_TIME> (rtStart, rtCurMin) ;
            }

            //  keep the media sample's ref as the queue's
            hr = m_PTSNormDiscQueue.Push (pIMediaSample2, pDVROutputPin, pmtNew) ;

            TRACE_3 (LOG_AREA_DSHOW, 5,
                TEXT ("CDVR_F1X_ReadController::::FindPTSNormalizerVal_ : queued %08xh %08xh %08xh"),
                pIMediaSample2, pDVROutputPin, pmtNew) ;
        }
    }

    //  don't fail the call if we tried to read beyond the EOF or our stop
    //   point, but only if we've got 1 normalizing val
    if (hr == NS_E_NO_MORE_SAMPLES &&
        rtCurMin != MAX_REFERENCE_TIME) {

        hr = S_OK ;
    }

    if (SUCCEEDED (hr)) {
        //  as long as we read something, we'll use it
        m_rtPTSNormalizer = (rtCurMin != MAX_REFERENCE_TIME ? rtCurMin : m_rtPTSNormalizer) ;

        if (m_rtPTSNormalizer != UNDEFINED) {
            m_pDVRSendStatsWriter -> SetNormalizer (m_rtPTSNormalizer, m_pDVRReadManager -> RefClock ()) ;
        }
        else {
            //  discovered nothing, so fail the call
            hr = E_FAIL ;
        }
    }

    return hr ;
}

//  ============================================================================
//  CDVRReadManager
//  ============================================================================

CDVRReadManager::CDVRReadManager (
    IN  CDVRPolicy *            pPolicy,
    IN  CDVRSourcePinManager *  pDVRSourcePinManager,
    OUT HRESULT *               phr
    ) : m_pDVRDShowReader       (NULL),
        m_ReaderThread          (this),
        m_pDVRSourcePinManager  (pDVRSourcePinManager),
        m_cnsCurrentPlayStart   (0),
        m_cnsCurrentPlayStop    (FURTHER),
        m_pPolicy               (pPolicy),
        m_dPlaybackRate         (PLAY_SPEED_DEFAULT),
        m_cnsLastRead           (0),
        m_rtDownstreamBuffering (0),
        m_pIRefClock            (NULL),
        m_pDVRClock             (NULL),
        m_CurPlaySpeedBracket   (0)
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRReadManager")) ;

    ASSERT (m_pDVRSourcePinManager) ;
    ASSERT (m_pPolicy) ;

    m_pPolicy -> AddRef () ;

    ZeroMemory (m_ppDVRReadController, sizeof m_ppDVRReadController) ;

    //  ignore the return code here - we don't want to fail the load of
    //   the filter because our stats failed to init
    m_DVRSendStatsWriter.Initialize (pPolicy -> Settings () -> StatsEnabled ()) ;

    m_pDVRSourcePinManager -> SetStatsWriter (& m_DVRSendStatsWriter) ;

    ZeroMemory (m_ppDVRReadController, sizeof m_ppDVRReadController) ;
    (* phr) = SetPlaybackRate (m_dPlaybackRate) ;
    if (FAILED (* phr)) { goto cleanup ; }

    //  if above call was successfull, these should now be matched
    ASSERT (::PlayrateToBracket (m_dPlaybackRate) == m_CurPlaySpeedBracket) ;

    cleanup :

    return ;
}

CDVRReadManager::~CDVRReadManager (
    )
{
    DWORD   i ;

    TRACE_DESTRUCTOR (TEXT ("CDVRReadManager")) ;

    //  terminate our reader thread
    TerminateReaderThread_ () ;
    RecycleReader_ (m_pDVRDShowReader) ;
    m_pDVRDShowReader = NULL ;

    //  free our read controllers
    for (i = 0; i < PLAY_SPEED_BRACKET_COUNT; i++) {
        delete m_ppDVRReadController [i] ;
    }

    //  done with the clock
    RELEASE_AND_CLEAR (m_pIRefClock) ;

    //  done with the policy object
    m_pPolicy -> Release () ;
}

HRESULT
CDVRReadManager::Process (
    )
{
    HRESULT hr ;

    ASSERT (m_ppDVRReadController [m_CurPlaySpeedBracket]) ;
    hr = m_ppDVRReadController [m_CurPlaySpeedBracket] -> Process () ;

    return hr ;
}

HRESULT
CDVRReadManager::ReadAndWrap_ (
    IN  BOOL                fWaitMediaSample,       //  vs. fail
    OUT INSSBuffer **       ppINSSBuffer,           //  !not! ref'd
    OUT IMediaSample2 **    ppIMS2,
    OUT CDVROutputPin **    ppDVROutputPin,
    OUT AM_MEDIA_TYPE **    ppmtNew                 //  dynamic format change
    )
{
    HRESULT                 hr ;
    INSSBuffer *            pINSSBuffer ;
    QWORD                   cnsStreamTimeOfSample ;
    QWORD                   cnsSampleDuration ;
    DWORD                   dwFlags ;
    WORD                    wStreamNum ;
    CMediaSampleWrapper *   pMSWrapper ;
    BYTE *                  pbBuffer ;
    DWORD                   dwBufferLength ;

    ASSERT (ppIMS2) ;
    ASSERT (m_pDVRDShowReader) ;
    ASSERT (ppINSSBuffer) ;

    hr = m_pDVRDShowReader -> Read (
            ppINSSBuffer,
            & cnsStreamTimeOfSample,
            & cnsSampleDuration,
            & dwFlags,
            & wStreamNum
            ) ;
    m_DVRSendStatsWriter.INSSBufferRead (hr) ;

    if (SUCCEEDED (hr)) {

        ASSERT (* ppINSSBuffer) ;

        //  last read
        m_cnsLastRead = cnsStreamTimeOfSample ;

        //  make sure we're within our playback boundaries
        if (cnsStreamTimeOfSample < m_cnsCurrentPlayStop) {
            //  get the pin
            (* ppDVROutputPin) = m_pDVRSourcePinManager -> GetNonRefdOutputPin (wStreamNum) ;

            //  only go through the drill if the pin is connected
            if (* ppDVROutputPin) {

                //  and a INSSBuffer wrapper; call can be made blocking or
                //   non-blocking
                if (fWaitMediaSample) {
                    pMSWrapper = (* ppDVROutputPin) -> WaitGetMSWrapper () ;
                }
                else {
                    pMSWrapper = (* ppDVROutputPin) -> TryGetMSWrapper () ;
                }

                if (pMSWrapper) {

                    hr = (* ppINSSBuffer) -> GetBufferAndLength (
                            & pbBuffer,
                            & dwBufferLength
                            ) ;
                    if (SUCCEEDED (hr)) {
                        //  wrap the INSSBuffer in an IMediaSample2
                        hr = pMSWrapper -> Init (
                                (* ppINSSBuffer),
                                pbBuffer,
                                dwBufferLength
                                ) ;
                        if (SUCCEEDED (hr)) {
                            //  translate the flags
                            ASSERT ((* ppDVROutputPin) -> GetTranslator ()) ;
                            hr = (* ppDVROutputPin) -> GetTranslator () -> SetAttributesDShow (
                                    (* ppINSSBuffer),
                                    cnsStreamTimeOfSample,
                                    cnsSampleDuration,
                                    dwFlags,
                                    pMSWrapper,
                                    ppmtNew
                                    ) ;

                            if (SUCCEEDED (hr)) {
                                (* ppIMS2) = pMSWrapper ;
                                (* ppIMS2) -> AddRef () ;
                            }
                        }
                    }

                    pMSWrapper -> Release () ;
                }
                else {
                    hr = E_OUTOFMEMORY ;
                }
            }
            else {
                hr = E_UNEXPECTED ;
            }
        }
        else {
            //  we're at or beyond our play stop; post an end of stream
            hr = NS_E_NO_MORE_SAMPLES ;
        }

        (* ppINSSBuffer) -> Release () ;
    }

    if (FAILED (hr)) {
        (* ppINSSBuffer) = NULL ;
    }

    return hr ;
}

HRESULT
CDVRReadManager::ErrorHandler (
    IN  HRESULT hr
    )
{
    ASSERT (m_ppDVRReadController [m_CurPlaySpeedBracket]) ;
    hr = m_ppDVRReadController [m_CurPlaySpeedBracket] -> ErrorHandler (hr) ;

    return hr ;
}

void
CDVRReadManager::SetReader_ (
    IN CDVRDShowReader *    pDVRDShowReader
    )
{
    ASSERT (pDVRDShowReader) ;
    m_pDVRDShowReader = pDVRDShowReader ;
}

HRESULT
CDVRReadManager::CancelReads_ (
    )
{
    HRESULT hr ;

    if (m_pDVRDShowReader) {
        hr = m_pDVRDShowReader -> GetIDVRReader () -> Cancel () ;
    }
    else {
        hr = S_OK ;
    }

    return hr ;
}

HRESULT
CDVRReadManager::PauseReaderThread_ (
    )
{
    HRESULT hr ;

    m_ReaderThread.Lock () ;

    hr = m_ReaderThread.NotifyPause () ;
    if (SUCCEEDED (hr)) {
        hr = CancelReads_ () ;
        if (SUCCEEDED (hr)) {
            hr = m_ReaderThread.WaitPaused () ;
        }
    }

    m_ReaderThread.Unlock () ;

    return hr ;
}

HRESULT
CDVRReadManager::TerminateReaderThread_ (
    )
{
    HRESULT hr ;

    m_ReaderThread.Lock () ;

    hr = m_ReaderThread.NotifyExit () ;
    if (SUCCEEDED (hr)) {
        hr = CancelReads_ () ;
        if (SUCCEEDED (hr)) {
            hr = m_ReaderThread.WaitExited () ;
        }
    }

    m_ReaderThread.Unlock () ;

    return hr ;
}

HRESULT
CDVRReadManager::RunReaderThread_ (
    IN  BOOL    fRunPaused
    )
{
    HRESULT hr ;

    //  make sure reader thread will start at least close within the ballpark;
    //   don't check return code here - reader thread will do this as well,
    //   and may loop a few times on recoverable errors, all of which are
    //   checked in its loop; we just try and go
    CheckSetStartWithinContent_ (& m_cnsCurrentPlayStart, m_cnsCurrentPlayStop) ;

    //  set our downstream buffering time
    m_rtDownstreamBuffering = DownstreamBuffering_ () ;

    //  make sure this one's reset
    ReaderReset () ;

    //  init the current read controller
    ASSERT (m_ppDVRReadController [m_CurPlaySpeedBracket]) ;
    hr = m_ppDVRReadController [m_CurPlaySpeedBracket] -> Initialize () ;
    if (SUCCEEDED (hr)) {
        //  now resume the thread, though we may resume it as paused if we're going
        //   to wait for a first seek
        if (!fRunPaused) {
            hr = m_ReaderThread.GoThreadGo () ;
        }
        else {
            hr = m_ReaderThread.GoThreadPause () ;
        }
    }

    return hr ;
}

HRESULT
CDVRReadManager::SeekReader (
    IN OUT  QWORD * pcnsSeekStreamTime,
    IN      QWORD   qwStop
    )
{
    HRESULT hr ;
    int     i ;
    QWORD   qwEarliest ;
    QWORD   qwEarliestValid ;
    QWORD   qwLatestValid ;

    //  these values should make sense ..
    ASSERT ((* pcnsSeekStreamTime) < qwStop) ;

    for (i = 0; i < MAX_STALE_SEEK_ATTEMPTS; i++) {
        hr = m_pDVRDShowReader -> GetIDVRReader () -> Seek (* pcnsSeekStreamTime) ;
        if (SUCCEEDED (hr)) {

            TRACE_2 (LOG_AREA_SEEKING, 1,
                TEXT ("CDVRReadManager::SeekReader(); succeeded : %I64d (%d sec)"),
                (* pcnsSeekStreamTime), WMSDKTimeToSeconds (* pcnsSeekStreamTime)) ;

            break ;
        }

        //  something failed; there are some failures we can recover from such
        //   as seeking to a time that has been overwritten by the ringbuffer
        //   logic;

        if (hr == HRESULT_FROM_WIN32 (ERROR_SEEK)) {

            TRACE_1 (LOG_AREA_SEEKING, 1,
                TEXT ("CDVRReadManager::SeekReader(%d sec); tried to seek out of bounds - checking .."),
                WMSDKTimeToSeconds (* pcnsSeekStreamTime)) ;

            //  try to adjust start position forward/backwards
            hr = CheckSetStartWithinContent_ (pcnsSeekStreamTime, qwStop) ;
            if (FAILED (hr)) {

                //  unrecoverable; we are most likely being asked to seek outside
                //   the valid boundaries, but our stop value makes this impossible;
                //   bail

                TRACE_1 (LOG_AREA_SEEKING, 1,
                    TEXT ("CDVRReadManager::SeekReader(); .. checked; unrecoverable error (%08xh); aborting"),
                    hr) ;

                break ;
            }
        }
        else {
            //  an unrecoverable error has occured; abort
            break ;
        }
    }

    return hr ;
}

HRESULT
CDVRReadManager::Active (
    IN  IReferenceClock *   pIRefClock,
    IN  CDVRClock *         pDVRClock
    )
{
    HRESULT hr ;
    BOOL    fRunPaused ;

    if (!m_ppDVRReadController [m_CurPlaySpeedBracket]) {
        hr = E_UNEXPECTED ;
        return hr ;
    }

    m_pIRefClock = pIRefClock ;
    if (m_pIRefClock) {
        m_pIRefClock -> AddRef () ;
    }

    //  can be NULL - if we don't have a live file
    m_pDVRClock = pDVRClock ;

    TRACE_3 (LOG_AREA_TIME, 1,
        TEXT ("CDVRReadManager::Active -- pIRefClock (%08xh) ?= pDVRClock (%08xh) -- %s"),
        pIRefClock, pDVRClock, ((LPVOID) pIRefClock == (LPVOID) pDVRClock ? TEXT ("TRUE") : TEXT ("FALSE"))) ;    //  IRefClock is first in v-table of CDVRClock ..

    //  we may start the thread paused
    fRunPaused = OnActiveWaitFirstSeek_ () ;
    hr = RunReaderThread_ (fRunPaused) ;

    return hr ;
}

HRESULT
CDVRReadManager::Inactive (
    )
{
    HRESULT hr ;

    hr = TerminateReaderThread_ () ;

    if (m_ppDVRReadController [m_CurPlaySpeedBracket]) {
        m_ppDVRReadController [m_CurPlaySpeedBracket] -> Reset () ;
    }

    RELEASE_AND_CLEAR (m_pIRefClock) ;
    m_pDVRClock = NULL ;

    return hr ;
}

HRESULT
CDVRReadManager::CheckSetStartWithinContent_ (
    IN OUT  QWORD * pqwStart,
    IN      QWORD   qwStop
    )
{
    HRESULT hr ;
    QWORD   qwContentStart ;
    QWORD   qwContentStop ;

    //  retrieve the valid boundaries
    hr = GetReaderContentBoundaries_ (& qwContentStart, & qwContentStop) ;

    if (SUCCEEDED (hr)) {

        //  are we earlier than valid ?
        if ((* pqwStart) < qwContentStart) {

            //  given our stop time, can we adjust ?
            if (qwContentStart < qwStop) {

                TRACE_2 (LOG_AREA_SEEKING, 1,
                    TEXT ("CDVRReadManager::CheckSetStartWithinContent_ (); OOB(-) start moved from %d sec -> %d sec"),
                    WMSDKTimeToSeconds ((* pqwStart)), WMSDKTimeToSeconds (qwContentStart)) ;

                //  adjust time forward - we may adjust to most forward
                if (AdjustStaleReaderToEarliest_ ()) {
                    //  adjust start up to earliest good position
                    (* pqwStart) = qwContentStart ;
                }
                else {
                    //  adjust start to latest good
                    (* pqwStart) = qwContentStop ;
                }

                //  success
                hr = S_OK ;
            }
            else {
                //  no wiggle room wrt our stop time; fail
                hr = VFW_E_START_TIME_AFTER_END ;
            }
        }
        //  are we later than valid ?
        else if ((* pqwStart) > qwContentStop) {

            //  given our stop time, can we adjust ?
            if (qwStop > qwContentStop) {

                TRACE_2 (LOG_AREA_SEEKING, 1,
                    TEXT ("CDVRReadManager::CheckSetStartWithinContent_ (); OOB(+) start moved from %d sec -> %d sec"),
                    WMSDKTimeToSeconds ((* pqwStart)), WMSDKTimeToSeconds (qwContentStop)) ;

                //  adjust start time backwards
                (* pqwStart) = qwContentStop ;

                //  success
                hr = S_OK ;
            }
            else {
                //  no wiggle room wrt our stop time; fail
                hr = VFW_E_START_TIME_AFTER_END ;
            }
        }
        else {
            //  start time is within the legal boundaries; so we're ok
            hr = S_OK ;
        }
    }

    return hr ;
}

HRESULT
CDVRReadManager::SeekTo (
    IN  REFERENCE_TIME *    prtStart,
    IN  REFERENCE_TIME *    prtStop,        //  can be NULL
    IN  double              dPlaybackRate
    )
{
    HRESULT hr ;
    BOOL    fThreadRunning ;

    ASSERT (prtStart) ;
    //  prtStop can be NULL

    //  no trick mode support .. yet
    if (dPlaybackRate != m_dPlaybackRate) {
        return E_NOTIMPL ;
    }

    //  validate that the start & stop times make sense wrt each other, if
    //   a stop time is specified
    if (prtStop &&
        (* prtStart) >= (* prtStop)) {

        return VFW_E_START_TIME_AFTER_END ;
    }

    //  all is valid, run the drill
    m_ReaderThread.Lock () ;

    //  if the thread is running
    fThreadRunning = m_ReaderThread.IsRunning () ;
    if (fThreadRunning) {
        //  begin flush before pausing thread; downstream components will
        //   then be able to fail pended deliveries
        DeliverBeginFlush () ;

        //  pause the reader thread (synchronous call)
        PauseReaderThread_ () ;

        //  flush internally
        m_ppDVRReadController [m_CurPlaySpeedBracket] -> Reset () ;

        //  done flushing
        DeliverEndFlush () ;
    }

    //  set the start/stop times; stop time only if specified
    m_cnsCurrentPlayStart   = DShowToWMSDKTime (* prtStart) ;
    m_cnsCurrentPlayStop    = (prtStop ? DShowToWMSDKTime (* prtStop) : m_cnsCurrentPlayStop) ;

    //  make sure we're at least in the ballpark with start/stop
    CheckSetStartWithinContent_ (& m_cnsCurrentPlayStart, m_cnsCurrentPlayStop) ;

    //  set the playback rate
    hr = SetPlaybackRate (dPlaybackRate) ;
    if (SUCCEEDED (hr)) {
        //  if the thread was running
        if (fThreadRunning) {
            //  resume it
            hr = RunReaderThread_ () ;
        }
    }

    m_ReaderThread.Unlock () ;

    return hr ;
}

HRESULT
CDVRReadManager::SetStop (
    IN REFERENCE_TIME rtStop
    )
{
    HRESULT hr ;
    BOOL    r ;
    QWORD   qwStop ;

    //  convert
    qwStop = DShowToWMSDKTime (rtStop) ;

    m_ReaderThread.Lock () ;

    r = m_ReaderThread.IsRunning () ;
    if (r) {
        //  the reader thread is running; we can set this value on the fly
        //   as long as it isn't behind the last read; if it is, there'd be
        //   1 extra read, which would immediately cause the reader thread
        //   to fall out; not catastrophic but there's sufficient level of
        //   bogosity to warrant a failed call; make the check now -- for now
        //   with 0 tolerance
        if (qwStop > m_cnsLastRead) {
            m_cnsCurrentPlayStop = qwStop ;
            hr = S_OK ;
        }
        else {
            //  nope .. fail the call
            hr = VFW_E_TIME_ALREADY_PASSED ;
        }
    }
    else {
        //  only enforce that stop occurs after start; it's legal to set it
        //   to a time that will never occur
        if (qwStop > m_cnsCurrentPlayStart) {
            m_cnsCurrentPlayStop = qwStop ;
            hr = S_OK ;
        }
        else {
            hr = VFW_E_START_TIME_AFTER_END ;
        }
    }

    m_ReaderThread.Unlock () ;

    return hr ;
}

HRESULT
CDVRReadManager::GetCurrentStart (
    OUT REFERENCE_TIME * prtStart
    )
{
    QWORD   qwContentStart ;
    QWORD   qwContentStop ;
    HRESULT hr ;

    ASSERT (prtStart) ;

    hr = GetReaderContentBoundaries_ (& qwContentStart, & qwContentStop) ;
    if (SUCCEEDED (hr)) {
        //  m_cnsCurrentPlayStart could be stale, so we make sure we return
        //   a value that is valid at this instant
        (* prtStart) = WMSDKToDShowTime (Max <QWORD> (m_cnsCurrentPlayStart, qwContentStart)) ;
    }

    return hr ;
}

HRESULT
CDVRReadManager::GetCurrentStop (
    OUT REFERENCE_TIME * prtStop
    )
{
    ASSERT (prtStop) ;

    //  m_cnsCurrentPlayStop might be FURTHER, with means EOS; if that's the
    //   case we'll translate it to MAX_REFERENCE_TIME
    (* prtStop) = WMSDKToDShowTime (m_cnsCurrentPlayStop) ;

    return S_OK ;
}

HRESULT
CDVRReadManager::GetContentExtent (
    OUT REFERENCE_TIME * prtStart,
    OUT REFERENCE_TIME * prtStop
    )
{
    HRESULT hr ;
    QWORD   qwStart ;
    QWORD   qwStop ;

    ASSERT (prtStart) ;
    ASSERT (prtStop) ;

    hr = GetReaderContentBoundaries_ (& qwStart, & qwStop) ;
    if (SUCCEEDED (hr)) {
        (* prtStart)    = WMSDKToDShowTime (qwStart) ;
        (* prtStop)     = WMSDKToDShowTime (qwStop) ;

        TRACE_4 (LOG_AREA_SEEKING, 4,
            TEXT ("CDVRReadManager::GetContentExtent(): start = %d sec; stop_actual = %d sec; stop_reported = %d sec; duration = %d sec"),
            WMSDKTimeToSeconds (* prtStart), WMSDKTimeToSeconds (WMSDKToDShowTime (qwStop)), WMSDKTimeToSeconds (* prtStop), WMSDKTimeToSeconds ((* prtStop) - (* prtStart))) ;
    }

    return hr ;
}

HRESULT
CDVRReadManager::SetPlaybackRate (
    IN  double dPlaybackRate
    )
{
    DWORD   dwPlayrateBracket ;
    HRESULT hr ;

    if (dPlaybackRate == 0.0) {
        return E_INVALIDARG ;
    }

    dwPlayrateBracket = ::PlayrateToBracket (dPlaybackRate) ;

    if (!m_ppDVRReadController [dwPlayrateBracket]) {
        hr = ::GetDVRReadController (
                    dwPlayrateBracket,
                    this,
                    m_pDVRSourcePinManager,
                    m_pPolicy,
                    & m_DVRSendStatsWriter,
                    & m_ppDVRReadController [dwPlayrateBracket]
                    ) ;
        if (FAILED (hr)) {
            DELETE_RESET (m_ppDVRReadController [dwPlayrateBracket]) ;
        }
        else {
            ASSERT (m_ppDVRReadController [dwPlayrateBracket]) ;
        }
    }
    else {
        hr = S_OK ;
    }

    if (SUCCEEDED (hr)) {
        ASSERT (m_ppDVRReadController [dwPlayrateBracket]) ;

        //  we have a read controller; initialize it prior to return
        m_CurPlaySpeedBracket = dwPlayrateBracket ;
        m_dPlaybackRate = dPlaybackRate ;
        hr = m_ppDVRReadController [m_CurPlaySpeedBracket] -> Initialize () ;
    }

    return hr ;
}

void
CDVRReadManager::ReaderReset (
    )
{
    m_pDVRDShowReader -> GetIDVRReader () -> ResetCancel () ;
}

HRESULT
CDVRReadManager::GetReaderContentBoundaries_ (
    OUT QWORD * pqwStart,
    OUT QWORD * pqwStop
    )
{
    return m_pDVRDShowReader -> GetIDVRReader () -> GetStreamTimeExtent (pqwStart, pqwStop) ;
}

//  ============================================================================
//  CDVRRecordingReader
//  ============================================================================

CDVRRecordingReader::CDVRRecordingReader (
    IN  WCHAR *                 pszDVRFilename,
    IN  CDVRPolicy *            pPolicy,
    IN  CDVRSourcePinManager *  pDVRSourcePinManager,
    OUT HRESULT *               phr
    ) : CDVRReadManager (pPolicy,
                         pDVRSourcePinManager,
                         phr)
{
    IDVRReader *        pIDVRReader ;
    CDVRDShowReader *   pDVRDShowReader ;

    TRACE_CONSTRUCTOR (TEXT ("CDVRRecordingReader")) ;

    ASSERT (pszDVRFilename) ;
    ASSERT (pPolicy) ;

    pDVRDShowReader = NULL ;
    pIDVRReader     = NULL ;

    //  base class might have failed us
    if (FAILED (* phr)) { goto cleanup ; }

    (* phr) = DVRCreateReader (
                    pszDVRFilename,
                    pPolicy -> Settings () -> GetDVRRegKey (),
                    & pIDVRReader) ;
    if (FAILED (* phr)) { goto cleanup ; }

    ASSERT (pIDVRReader) ;

    pDVRDShowReader = new CDVRDShowReader (
                                pPolicy,
                                pIDVRReader,
                                phr) ;

    //  done with the reader regardless
    pIDVRReader -> Release () ;

    if (!pDVRDShowReader ||
        FAILED (* phr)) {
        (* phr) = (pDVRDShowReader ? (* phr) : E_OUTOFMEMORY) ;
        goto cleanup ;
    }

    //  success
    SetReader_ (pDVRDShowReader) ;

    cleanup :

    return ;
}

CDVRRecordingReader::~CDVRRecordingReader (
    )
{
    TRACE_DESTRUCTOR (TEXT ("CDVRRecordingReader")) ;
}

//  ============================================================================
//  CDVRBroadcastStreamReader
//  ============================================================================

CDVRBroadcastStreamReader::CDVRBroadcastStreamReader (
    IN  IDVRStreamSink *        pIDVRStreamSink,
    IN  CDVRPolicy *            pPolicy,
    IN  CDVRSourcePinManager *  pDVRSourcePinManager,
    OUT HRESULT *               phr
    ) : CDVRReadManager (pPolicy,
                         pDVRSourcePinManager,
                         phr)
{
    IDVRStreamSinkPriv *    pIDVRStreamSinkPriv ;
    IDVRReader *            pIDVRReader ;
    CDVRDShowReader *       pDVRDShowReader ;

    TRACE_CONSTRUCTOR (TEXT ("CDVRBroadcastStreamReader")) ;

    pIDVRStreamSinkPriv = NULL ;
    pIDVRReader         = NULL ;

    //  base class might have failed us
    if (FAILED (* phr)) { goto cleanup ; }

    ASSERT (pIDVRStreamSink) ;
    (* phr) = pIDVRStreamSink -> QueryInterface (
                    IID_IDVRStreamSinkPriv,
                    (void **) & pIDVRStreamSinkPriv
                    ) ;
    if (FAILED (* phr)) { goto cleanup ; }

    ASSERT (pIDVRStreamSinkPriv) ;
    (* phr) = pIDVRStreamSinkPriv -> GetIDVRReader (& pIDVRReader) ;
    if (FAILED (* phr)) { goto cleanup ; }

    ASSERT (pIDVRReader) ;
    pDVRDShowReader = new CDVRDShowReader (pPolicy, pIDVRReader, phr) ;

    if (!pDVRDShowReader ||
        FAILED (* phr)) {

        (* phr) = (pDVRDShowReader ? (* phr) : E_OUTOFMEMORY) ;
        goto cleanup ;
    }

    //  success
    SetReader_ (pDVRDShowReader) ;

    cleanup :

    RELEASE_AND_CLEAR (pIDVRStreamSinkPriv) ;   //  done with the interface
    RELEASE_AND_CLEAR (pIDVRReader) ;           //  pDVRDShowReader has ref'd this

    return ;
}

CDVRBroadcastStreamReader::~CDVRBroadcastStreamReader (
    )
{
    TRACE_DESTRUCTOR (TEXT ("CDVRBroadcastStreamReader")) ;
}

REFERENCE_TIME
CDVRBroadcastStreamReader::DownstreamBuffering_ (
    )
{
    return MillisToDShowTime (DVRPolicies_ () -> Settings () -> DownstreamBufferingMillis ()) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\dvrstreamthrough\dvrstreamthrough.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        DVRStreamThrough.h

    Abstract:

        This module contains the DVRStreamThrough filter declarations.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef __DVRStreamThrough__DVRStreamThrough_h
#define __DVRStreamThrough__DVRStreamThrough_h

extern AMOVIESETUP_FILTER   g_sudDVRStreamThrough ;

class CDVRStreamThrough :
    public CBaseFilter,                 //  dshow base class
    public CIDVRDShowStream,            //  streaming callback
    public CIDVRPinConnectionEvents     //  input pin events (connection, etc..)
{
    CTSDVRSettings *            m_pSettings ;
    CDVRThroughSinkPinManager * m_pInputPins ;
    CDVRSourcePinManager *      m_pOutputPins ;
    CCritSec                    m_RecvLock ;

    void RecvLock_ ()           { m_RecvLock.Lock () ; }
    void RecvUnlock_ ()         { m_RecvLock.Unlock () ; }

    void FilterLock_ ()         { m_pLock -> Lock () ;      }
    void FilterUnlock_ ()       { m_pLock -> Unlock () ;    }

    public :

        CDVRStreamThrough (
            IN  IUnknown *  punkControlling,
            IN  REFCLSID    rclsid,
            OUT HRESULT *   phr
            ) ;

        ~CDVRStreamThrough (
            ) ;

        //  ====================================================================
        //  pure virtual methods in base class

        int
        GetPinCount (
            ) ;

        CBasePin *
        GetPin (
            IN  int
            ) ;

        //  ====================================================================
        //  class-factory method

        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  punkControlling,
            OUT HRESULT *   phr
            ) ;

        //  ====================================================================
        //  CIDVRDShowStream

        virtual
        HRESULT
        OnReceive (
            IN  int                         iPinIndex,
            IN  CDVRAttributeTranslator *   pTranslator,
            IN  IMediaSample *              pIMediaSample
            ) ;

        virtual
        HRESULT
        OnBeginFlush (
            IN  int iPinIndex
            ) ;

        virtual
        HRESULT
        OnEndFlush (
            IN  int iPinIndex
            ) ;

        virtual
        HRESULT
        OnEndOfStream (
            IN  int iPinIndex
            ) ;

        //  ====================================================================
        //  CIDVRDInputEvents

        virtual
        HRESULT
        OnInputCompleteConnect (
            IN  int             iPinIndex,
            IN  AM_MEDIA_TYPE * pmt
            ) ;
} ;

#endif  //  __DVRStreamThrough__DVRStreamThrough_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\shared\dvrclock.h ===
/*++

    Copyright (c) 2001  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        dvrclock.h

    Abstract:

        This module contains the IReferenceClock declarations

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        24-May-2001     mgates

    Notes:

--*/

class CDVRClock :
    public IReferenceClock          //  reference clock interface
{
    struct ADVISE_NODE {
        SINGLE_LIST_ENTRY   SListEntry ;        //  link
        HANDLE              hSignal ;           //  semaphore or event
        REFERENCE_TIME      rtAdviseTime ;      //  when to advise
        REFERENCE_TIME      rtPeriodTime ;      //  what the period is; 0 in non-periodic advise nodes
    } ;

    IUnknown *              m_punkOwning ;                      //  always aggregated; weak ref !!
    REFERENCE_TIME          m_rtGraphStart ;                    //  graph start time; ::GetTime() returns 0 if earlier than this
    SINGLE_LIST_ENTRY *     m_pAdviseListHead ;                 //  list head to the advise list nodes
    SINGLE_LIST_ENTRY *     m_pAdviseNodeFreePool ;             //  list head to free pool of list nodes
    HANDLE                  m_hThread ;                         //  adviser thread
    HANDLE                  m_hEventUnblockThread ;             //  new advise has been posted
    BOOL                    m_fThreadExit ;                     //  TRUE if the thread must exit
    CRITICAL_SECTION        m_crtIRefConfig ;                   //  IReferenceClock configuration lock
    CRITICAL_SECTION        m_crtGetTime ;                      //  IReferenceClock::GetTime () lock
    LONGLONG                m_QPCTicksPerSecond ;               //  set at initialization to scale the qpc-raw numbers
    LONGLONG                m_llLastReturnedIRefTime ;          //  value for the last time we returned
    LONGLONG                m_llBaseQPCForLastReturnedTime ;    //  QPC time that formed the basis for the last returned time
    double                  m_dCarriedError ;                   //  fractional error that gets rounded out for each call, but which
                                                                //   must be carried from call-call
    UINT                    m_uiTimerResolution ;               //  for timeBeginPeriod and timeEndPeriod calls
    double                  m_dClockSlavingScaler ;             //  value adjusted to clock slave

    LONGLONG                m_llQPCNormalizer ;                 //  sampled when object is instantiated
#define NORMALIZED_QPC(qpc)     ((qpc) + m_llQPCNormalizer)

    void LockIRefConfig_ ()     { EnterCriticalSection (& m_crtIRefConfig) ; }
    void UnlockIRefConfig_ ()   { LeaveCriticalSection (& m_crtIRefConfig) ; }

    void LockGetTime_ ()        { EnterCriticalSection (& m_crtGetTime) ; }
    void UnlockGetTime_ ()      { LeaveCriticalSection (& m_crtGetTime) ; }

    HRESULT
    ConfirmAdviseThreadRunning_ (
        )
    {
        TIMECAPS    tc ;
        MMRESULT    mmRes ;
        DWORD       dw ;

        if (m_hThread == NULL) {

            m_fThreadExit = FALSE ;

            mmRes = timeGetDevCaps (& tc, sizeof tc) ;
            if (mmRes == TIMERR_NOERROR) {
                m_uiTimerResolution = tc.wPeriodMin ;
            }
            else {
                m_uiTimerResolution = 1 ;
            }

            timeBeginPeriod (m_uiTimerResolution) ;

            m_hThread = CreateThread (
                            NULL,                       //  security
                            0,                          //  calling thread's stack size
                            CDVRClock::ThreadEntry,     //  entry point
                            (LPVOID) this,              //  parameter
                            NULL,                       //  flags
                            NULL                        //  thread id
                            ) ;

            if (m_hThread == NULL) {
                //  failure
                dw = GetLastError () ;
                return HRESULT_FROM_WIN32 (dw) ;
            }

            SetThreadPriority (m_hThread, THREAD_PRIORITY_TIME_CRITICAL) ;
        }

        ASSERT (m_hEventUnblockThread != NULL) ;

        //  thread is running
        return S_OK ;
    }

    //  returns the milliseconds until the next timeout
    DWORD
    ProcessNotificationTimeoutLocked_ (
        IN  REFERENCE_TIME  rtNow
        ) ;

    //  returns the milliseconds until the next timeout
    DWORD
    ResetWaitTimeLocked_ (
        IN  REFERENCE_TIME  rtNow
        ) ;

    HRESULT
    AdvisePeriodicLocked_ (
        IN  REFERENCE_TIME  rtStartTime,
        IN  REFERENCE_TIME  rtPeriodTime,
        IN  HANDLE          hSemaphore,
        OUT DWORD_PTR *     pdwpContext
        ) ;

    HRESULT
    AdviseTimeLocked_ (
        IN  REFERENCE_TIME  rtBaseTime,
        IN  REFERENCE_TIME  rtStreamTime,
        IN  HANDLE          hEvent,
        OUT DWORD_PTR *     pdwpContext
        ) ;

    void
    QueueAdviseTimeout_ (
        IN  ADVISE_NODE *   pAdviseNode
        ) ;

    HRESULT
    CancelAdviseTimeout_ (
        IN  ADVISE_NODE *   pAdviseNode
        ) ;

    ADVISE_NODE *
    GetAdviseNode_ (
        )
    //  locks held: the list lock
    {
        ADVISE_NODE *       pAdviseNode ;
        SINGLE_LIST_ENTRY * pSListEntry ;

        if (m_pAdviseNodeFreePool != NULL) {

            pSListEntry = m_pAdviseNodeFreePool ;
            m_pAdviseNodeFreePool = m_pAdviseNodeFreePool -> Next ;

            pAdviseNode = CONTAINING_RECORD (pSListEntry, ADVISE_NODE, SListEntry) ;
            ZeroMemory (pAdviseNode, sizeof ADVISE_NODE) ;
        }
        else {
            pAdviseNode = new ADVISE_NODE ;
            if (pAdviseNode) {
                ZeroMemory (pAdviseNode, sizeof ADVISE_NODE) ;
            }
        }

        return pAdviseNode ;
    }

    void
    RecycleAdviseNode_ (
        IN  ADVISE_NODE *   pAdviseNode
        )
    //  locks held: the list lock
    {
        ASSERT (pAdviseNode) ;
        pAdviseNode -> SListEntry.Next = m_pAdviseNodeFreePool ;
        m_pAdviseNodeFreePool = & pAdviseNode -> SListEntry ;
    }

    //  scales the wait milliseconds to the PCR clock so we wait an
    //   amount that is synced with the headend clock; might increase
    //   or decrease the number of milliseconds we actually wait (based
    //   on the host's clock)
    DWORD
    SkewedWaitMilliseconds_ (
        IN  DWORD   dwMilliseconds
        )
    {
        return (DWORD) (m_dClockSlavingScaler * (double) dwMilliseconds) ;
    }

    void
    UnblockAllWaitingLocked_ (
        ) ;

    public :

        CDVRClock (
            IN  IUnknown *  punkOwning,
            OUT HRESULT *   pHr
            ) ;

        ~CDVRClock (
            ) ;

        //  -------------------------------------------------------------------
        //  called by the filter when there's a graph state transition

        void
        FilterStateChanged (
            IN  FILTER_STATE    OldFilterState,
            IN  FILTER_STATE    NewFilterState,
            IN  REFERENCE_TIME  rtStart             //  0 if not start run
            ) ;

        //  -------------------------------------------------------------------
        //  Advise thread entry point and worker method

        void
        AdviseThreadBody (
            ) ;

        static
        DWORD
        WINAPI
        ThreadEntry (
            IN  LPVOID  pv
            )
        {
            (reinterpret_cast <CDVRClock *> (pv)) -> AdviseThreadBody () ;
            return EXIT_SUCCESS ;
        }

        //  -------------------------------------------------------------------
        //  IReferenceClock methods, including IUnknown

        STDMETHODIMP
        QueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        STDMETHODIMP_(ULONG)
        AddRef (
            ) ;

        STDMETHODIMP_(ULONG)
        Release (
            ) ;

        STDMETHODIMP
        AdvisePeriodic (
            IN  REFERENCE_TIME  rtStartTime,
            IN  REFERENCE_TIME  rtPeriodTime,
            IN  HSEMAPHORE      hSemaphore,
            OUT DWORD_PTR *     pdwpContext
            ) ;

        STDMETHODIMP
        AdviseTime (
            IN  REFERENCE_TIME  rtBaseTime,
            IN  REFERENCE_TIME  rtStreamTime,
            IN  HEVENT          hEvent,
            OUT DWORD_PTR *     pdwpContext
            ) ;

        STDMETHODIMP
        GetTime (
            OUT REFERENCE_TIME *    pTime
            ) ;

        STDMETHODIMP
        Unadvise (
            IN  DWORD_PTR   dwpContext
            ) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\shared\dvrdsread.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrdsread.h

    Abstract:

        This module contains the declarations for our reading layer.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        02-Apr-2001     created

--*/

#ifndef __tsdvr__shared__dvrdsread_h
#define __tsdvr__shared__dvrdsread_h

//  ============================================================================
//  CDVRDShowReader
//  ============================================================================

class CDVRDShowReader
{
    protected :

        IDVRReader *    m_pIDVRReader ;
        CDVRPolicy *    m_pPolicy ;

    public :

        CDVRDShowReader (
            IN  CDVRPolicy *        pPolicy,
            IN  IDVRReader *        pIDVRReader,
            OUT HRESULT *           phr
            ) ;

        virtual
        ~CDVRDShowReader (
            ) ;

        HRESULT
        GetRefdReaderProfile (
            OUT CDVRReaderProfile **
            ) ;

        IDVRReader * GetIDVRReader ()       { return m_pIDVRReader ; }

        virtual BOOL IsLiveSource ()        { return m_pIDVRReader -> IsLive () ; }

        virtual
        HRESULT
        Read (
            OUT INSSBuffer **   ppINSSBuffer,
            OUT QWORD *         pcnsStreamTimeOfSample,
            OUT QWORD *         pcnsSampleDuration,
            OUT DWORD *         pdwFlags,
            OUT WORD *          pwStreamNum
            ) ;
} ;

//  ============================================================================
//  CDVRDReaderThread
//  ============================================================================

class CDVRDReaderThread :
    public CDVRThread
{
    enum {
        THREAD_MSG_EXIT         = 0,    //  thread terminates
        THREAD_MSG_PAUSE        = 1,    //  thread pauses
        THREAD_MSG_GO           = 2,    //  thread is started, and runs
        THREAD_MSG_GO_PAUSED    = 3,    //  thread is started, but begins paused
    } ;

    CDVRReadManager *   m_pHost ;

    void
    RuntimeThreadProc_ (
        ) ;

    HRESULT
    ThreadCmdWaitAck_ (
        IN  DWORD   dwCmd
        )
    {
        HRESULT hr ;

        Lock () ;

        hr = ThreadCmd_ (dwCmd) ;
        if (SUCCEEDED (hr)) {
            hr = CmdWaitAck_ (dwCmd) ;
        }

        Unlock () ;

        return hr ;
    }

    //  must hold the lock to serialize & call in conjunction with CmdWait_ (),
    //   after which the lock can be released (see ThreadCmdWait implementation
    //   above)
    HRESULT
    ThreadCmd_ (
        IN  DWORD   dwCmd
        ) ;

    HRESULT
    CmdWaitAck_ (
        IN  DWORD   dwCmd
        ) ;

    HRESULT
    WaitThreadExited_ (
        ) ;

    HRESULT
    StartThread_ (
        IN  DWORD   dwInitialCmd
        ) ;

    public :

        CDVRDReaderThread (
            CDVRReadManager *   pHost
            ) : m_pHost (pHost) {}

        HRESULT
        GoThreadGo (
            )
        {
            return StartThread_ (THREAD_MSG_GO) ;
        }

        HRESULT
        GoThreadPause (
            )
        {
            return StartThread_ (THREAD_MSG_GO_PAUSED) ;
        }

        HRESULT Pause ()        { return ThreadCmdWaitAck_ (THREAD_MSG_PAUSE) ; }

        HRESULT NotifyPause ()  { return ThreadCmd_ (THREAD_MSG_PAUSE) ; }
        HRESULT WaitPaused ()   { return CmdWaitAck_ (THREAD_MSG_PAUSE) ; }

        HRESULT NotifyExit ()   { return ThreadCmd_ (THREAD_MSG_EXIT) ; }
        HRESULT WaitExited ()   { return WaitThreadExited_ () ; }           //  wait for the thread to really exit

        BOOL IsRunning ()       { return (m_dwParam == THREAD_MSG_GO || m_dwParam == THREAD_MSG_GO_PAUSED ? TRUE : FALSE) ; }

        void Lock ()            { m_AccessLock.Lock () ; }
        void Unlock ()          { m_AccessLock.Unlock () ; }

        virtual
        DWORD
        ThreadProc (
            ) ;
} ;

//  ============================================================================
//  CDVRReadController
//  ============================================================================

class CDVRReadController
{
    protected :

        CDVRReadManager *       m_pDVRReadManager ;
        CDVRSourcePinManager *  m_pDVRSourcePinManager ;
        CDVRPolicy *            m_pPolicy ;
        CDVRSendStatsWriter *   m_pDVRSendStatsWriter ;

        virtual void    InternalFlush_ ()                       { return ; }
        virtual HRESULT ReadFailure_ (IN HRESULT hr)            { return hr ; }
        virtual void    OnEndOfStream_ ()                       { DeliverEndOfStream_ () ; }

        HRESULT DeliverEndOfStream_ ()  { return m_pDVRSourcePinManager -> DeliverEndOfStream () ; }
        HRESULT DeliverBeginFlush_ ()   { return m_pDVRSourcePinManager -> DeliverBeginFlush () ; }
        HRESULT DeliverEndFlush_ ()     { return m_pDVRSourcePinManager -> DeliverEndFlush () ; }
        void    NotifyNewSegment_ ()    { m_pDVRSourcePinManager -> NotifyNewSegment () ; }

        HRESULT
        SendSample_ (
            IN  IMediaSample2 * pIMediaSample2,
            IN  CDVROutputPin * pDVROutputPin,
            IN  AM_MEDIA_TYPE * pmtNew
            ) ;

    public :

        CDVRReadController (
            IN  CDVRReadManager *       pDVRReadManager,
            IN  CDVRSourcePinManager *  pDVRSourcePinManager,
            IN  CDVRPolicy *            pPolicy,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter
            ) ;

        virtual
        ~CDVRReadController (
            ) ;

        //  flushes & initializes internal state
        virtual HRESULT Reset ()        { InternalFlush_ () ; return Initialize () ; }
        virtual HRESULT Initialize ()   { return S_OK ; }

        //  steady state call
        virtual HRESULT Process () = 0 ;

        //  error-handler
        HRESULT ErrorHandler (IN HRESULT hr) ;
} ;

//  ============================================================================
//  CDVR_F_ReadController
//  forward play
//  ============================================================================

class CDVR_F_ReadController :
    public CDVRReadController
{
    protected :

        virtual HRESULT ReadFailure_ (IN HRESULT hr) ;

    public :

        CDVR_F_ReadController (
            IN  CDVRReadManager *       pDVRReadManager,
            IN  CDVRSourcePinManager *  pDVRSourcePinManager,
            IN  CDVRPolicy *            pPolicy,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter
            ) : CDVRReadController (pDVRReadManager, pDVRSourcePinManager, pPolicy, pDVRSendStatsWriter) {}
} ;

//  ============================================================================
//  CDVR_F1X_ReadController
//  1x forward play
//  ============================================================================

class CDVR_F1X_ReadController :
    public CDVR_F_ReadController
{
    //  we're a FSM; state details :
    //
    //      --------------------------------------------------------------------
    //      DISCOVER_PTS_NORMALIZER
    //      --------------------------------------------------------------------
    //          discover the normalizing PTS value; this is the smallest PTS;
    //          we will subsequently subtract that PTS from all outgoing PTSs
    //          so we start from a 0-based timeline
    //
    //      --------------------------------------------------------------------
    //      DISCOVER_QUEUE_SEND
    //      --------------------------------------------------------------------
    //          send each queued media sample; during the normalizing PTS
    //          discovery process, we read in media samples from our starting
    //          point, but don't send them since we don't know how to normalize
    //          their PTSs; if we get to this step we know the normalizing PTS
    //          value; we pull off each sample from the front of the queue,
    //          normalize its PTS (if it has one) and send it; we do this
    //          iteratively vs. as a batch so we can be stopped without
    //          insisting to send all queued media samples first
    //
    //      --------------------------------------------------------------------
    //      STEADY_STATE
    //      --------------------------------------------------------------------
    //          this is the steady-state routine; we read, wrap, and send samples
    //          downstream
    //

    enum F1X_READ_CTLR_STATE {
        DISCOVER_PTS_NORMALIZER,    //  looking for PTS normalizer val
        DISCOVER_QUEUE_SEND,        //  sending out of queue built during pts normalizer val search
        STEADY_STATE                //  steady state
    } ;

    //  object-wide constants
    enum {
        //  this is the maximum number of packets we'll read in to discover
        //   the min PTS following a seek; if we read a PTS out of every
        //   stream before we reach this number, we'll bail; this value just
        //   makes sure that we don't spin, or read the entire stream, to
        //   discover the PTSs;
        MAX_PTS_NORM_DISCOVERY_READS = 100,
    } ;

    class CMediaSampleQueue
    {
        enum {
            ALLOC_QUANTUM = 10
        } ;

        struct MEDIASAMPLE_REC {
            IMediaSample2 * pIMS2 ;
            CDVROutputPin * pDVROutputPin ;
            AM_MEDIA_TYPE * pmtNew ;
        } ;

        TStructPool <MEDIASAMPLE_REC, ALLOC_QUANTUM>    m_MediaSampleRecPool ;
        CTDynQueue  <MEDIASAMPLE_REC *>                 m_MSRecQueue ;

        public :

            CMediaSampleQueue (
                ) : m_MSRecQueue (ALLOC_QUANTUM) {}

            BOOL Empty ()   { return m_MSRecQueue.Empty () ; }

            //  does not refcount either !!
            HRESULT
            Push (
                IN  IMediaSample2 * pIMS2,
                IN  CDVROutputPin * pDVROutputPin,
                IN  AM_MEDIA_TYPE * pmtNew
                )
            {
                HRESULT             hr ;
                MEDIASAMPLE_REC *   pMediaSampleRec ;
                DWORD               dw ;

                ASSERT (pIMS2) ;
                ASSERT (pDVROutputPin) ;

                pMediaSampleRec = m_MediaSampleRecPool.Get () ;
                if (pMediaSampleRec) {

                    //  set
                    pMediaSampleRec -> pIMS2            = pIMS2 ;           //  don't addref
                    pMediaSampleRec -> pDVROutputPin    = pDVROutputPin ;   //  don't addref
                    pMediaSampleRec -> pmtNew           = pmtNew ;          //  can be NULL

                    //  push to queue
                    dw = m_MSRecQueue.Push (pMediaSampleRec) ;
                    if (dw == NOERROR) {
                        hr = S_OK ;
                    }
                    else {
                        hr = HRESULT_FROM_WIN32 (dw) ;
                        m_MediaSampleRecPool.Recycle (pMediaSampleRec) ;
                    }
                }
                else {
                    hr = E_OUTOFMEMORY ;
                }

                return hr ;
            }

            HRESULT
            Pop (
                OUT IMediaSample2 **    ppIMS2,
                OUT CDVROutputPin **    ppDVROutputPin,
                OUT AM_MEDIA_TYPE **    ppmtNew
                )
            {
                HRESULT             hr ;
                MEDIASAMPLE_REC *   pMediaSampleRec ;
                DWORD               dw ;

                ASSERT (ppIMS2) ;
                ASSERT (ppDVROutputPin) ;
                ASSERT (ppmtNew) ;

                if (!Empty ()) {
                    dw = m_MSRecQueue.Pop (& pMediaSampleRec) ;
                    ASSERT (dw == NOERROR) ;        //  queue is not empty

                    (* ppIMS2)          = pMediaSampleRec -> pIMS2 ;            //  no refcounts
                    (* ppDVROutputPin)  = pMediaSampleRec -> pDVROutputPin ;    //  no refcounts
                    (* ppmtNew)         = pMediaSampleRec -> pmtNew ;           //  can be NULL (usually is)

                    m_MediaSampleRecPool.Recycle (pMediaSampleRec) ;

                    hr = S_OK ;
                }
                else {
                    hr = E_UNEXPECTED ;
                }

                return hr ;
            }
    } ;

    F1X_READ_CTLR_STATE     m_ReadCtrlrState ;
    REFERENCE_TIME          m_rtPTSNormalizer ;
    CSimpleBitfield *       m_pStreamsBitField ;

    //  queue is used when we read media samples to discover normalizing val;
    //   we queue the samples vs. discarding them, then fixup the timestamps and
    //   send them off
    CMediaSampleQueue       m_PTSNormDiscQueue ;

    BOOL PTSNormalizingValDiscovered_ ()    { return (m_rtPTSNormalizer != UNDEFINED ? TRUE : FALSE) ; }

    BOOL MediaSampleQueueEmpty_ ()          { return m_PTSNormDiscQueue.Empty () ; }

    HRESULT
    FlushMediaSampleQueue_ (
        ) ;

    HRESULT
    SendNextQueued_ (
        ) ;

    HRESULT
    NormalizePTSAndSend_ (
        IN  IMediaSample2 * pIMediaSample2,
        IN  CDVROutputPin * pDVROutputPin,
        IN  AM_MEDIA_TYPE * pmtNew
        ) ;

    HRESULT
    TryDiscoverPTSNormalizingVal_ (
        ) ;

    HRESULT
    FindPTSNormalizerVal_ (
        IN OUT  QWORD * pcnsStreamStart
        ) ;

    HRESULT
    NormalizeTimestamps_ (
        IN  IMediaSample2 *
        ) ;

    protected :

        HRESULT
        ReadWrapAndSend_ (
            ) ;

    public :

        CDVR_F1X_ReadController (
            IN  CDVRReadManager *       pDVRReadManager,
            IN  CDVRSourcePinManager *  pDVRSourcePinManager,
            IN  CDVRPolicy *            m_pPolicy,
            IN  CDVRSendStatsWriter *   m_pDVRSendStatsWriter
            ) ;

        virtual HRESULT Process () ;
        virtual HRESULT Initialize () ;
} ;

//  ============================================================================
//  CDVR_FF_ReadController
//  fast forward play
//  ============================================================================

class CDVR_FF_ReadController :
    public CDVR_F1X_ReadController
{
    public :

        CDVR_FF_ReadController (
            IN  CDVRReadManager *       pDVRReadManager,
            IN  CDVRSourcePinManager *  pDVRSourcePinManager,
            IN  CDVRPolicy *            pPolicy,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter
            ) : CDVR_F1X_ReadController (pDVRReadManager, pDVRSourcePinManager, pPolicy, pDVRSendStatsWriter) {}
} ;

//  ============================================================================
//  CDVR_R_ReadController
//  reverse play
//  ============================================================================

class CDVR_R_ReadController :
    public CDVRReadController
{
    protected :

        virtual HRESULT ReadFailure_ (IN HRESULT hr) ;

    public :

        CDVR_R_ReadController (
            IN  CDVRReadManager *       pDVRReadManager,
            IN  CDVRSourcePinManager *  pDVRSourcePinManager,
            IN  CDVRPolicy *            pPolicy,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter
            ) : CDVRReadController (pDVRReadManager, pDVRSourcePinManager, pPolicy, pDVRSendStatsWriter) {}
} ;

//  ============================================================================
//  CDVRReadManager
//  ============================================================================

class CDVRReadManager
{
    //
    //  seeking policies
    //
    //      1. it is legal to set a stop position that is beyond the current
    //          boundaries of the file; the file may be growing, or the file
    //          size may not have been known at the time that the caller set
    //          the stop value; should the reader run out beyond the file
    //          length, we'll get get an EOS, and pass that through, before the
    //          reader pauses
    //
    //      2. playback duration can change over time, though it will reach a
    //          plateau when our temporary backing store becomes full and the
    //          ringbuffer wraps
    //
    //      3. start position can become stale over time i.e. the ringbuffer
    //          logic may well overwrite it; we won't update in that case
    //

    friend class CDVRDReaderThread ;

    enum {
        //  this is our default stop time - a time that we'll "never" reach
        FURTHER = MAXQWORD,

        //  if we seek to a stale location i.e. one that has been overwritten
        //   by the ringbuffer logic, we'll loop trying to seek to earliest
        //   time; this is the max number of times we'll retrieve the earliest
        //   non-stale time, and try to seek to it
        MAX_STALE_SEEK_ATTEMPTS = 10,

        //  default play speed it 1x
        PLAY_SPEED_DEFAULT  = 1
    } ;

    CDVRDReaderThread       m_ReaderThread ;
    QWORD                   m_cnsCurrentPlayStart ;
    QWORD                   m_cnsCurrentPlayStop ;
    double                  m_dPlaybackRate ;
    CDVRReadController *    m_ppDVRReadController [PLAY_SPEED_BRACKET_COUNT] ;
    DWORD                   m_CurPlaySpeedBracket ;
    QWORD                   m_cnsLastRead ;
    CDVRDShowReader *       m_pDVRDShowReader ;
    CDVRSourcePinManager *  m_pDVRSourcePinManager ;
    CDVRPolicy *            m_pPolicy ;
    CDVRSendStatsWriter     m_DVRSendStatsWriter ;
    IReferenceClock *       m_pIRefClock ;
    CDVRClock *             m_pDVRClock ;               //  may/may not be IRefClock depending on whether file is live or not
    REFERENCE_TIME          m_rtDownstreamBuffering ;

    HRESULT CancelReads_ () ;
    HRESULT PauseReaderThread_ () ;
    HRESULT TerminateReaderThread_ () ;
    HRESULT RunReaderThread_ (IN BOOL fRunPaused = FALSE) ;

    HRESULT
    ReadAndWrap_ (
        IN  BOOL                fWaitMediaSample,       //  vs. fail i.e. non-blocking
        OUT INSSBuffer **       ppINSSBuffer,           //  !NOT! ref'd; only indirectly via ppIMS2; undefined if call fails
        OUT IMediaSample2 **    ppIMS2,
        OUT CDVROutputPin **    ppDVROutputPin,
        OUT AM_MEDIA_TYPE **    ppmtNew                 //  dynamic format change; don't free
        ) ;

    //  this method compares the specified start & stop positions to the
    //   readable content; should the start position be bad i.e. either beyond
    //   the end, or before the first, the start is repositioned wrt to the
    //   readable content, as long as this does not violate the specified
    //   stop position.
    HRESULT
    CheckSetStartWithinContent_ (
        IN OUT  QWORD * pqwStart,
        IN      QWORD   qwStop
        ) ;

    protected :

        CDVRPolicy *
        DVRPolicies_ (
            )
        {
            return m_pPolicy ;
        }

        HRESULT
        GetReaderContentBoundaries_ (
            OUT QWORD * pqwStart,
            OUT QWORD * pqwStop
            ) ;

        //  called by child classes to set
        void
        SetReader_ (
            IN CDVRDShowReader *
            ) ;

        virtual
        void
        RecycleReader_  (
            IN  CDVRDShowReader *   pDVRReader
            )
        {
            delete pDVRReader ;
        }

        virtual
        BOOL
        AdjustStaleReaderToEarliest_ (
            )
        {
            return TRUE ;
        }

        virtual
        REFERENCE_TIME
        DownstreamBuffering_ (
            )
        {
            return 0 ;
        }

        virtual
        BOOL
        OnActiveWaitFirstSeek_ (
            )
        {
            return FALSE ;
        }

    public :

        CDVRReadManager (
            IN  CDVRPolicy *,
            IN  CDVRSourcePinManager *,
            OUT HRESULT *
            ) ;

        virtual
        ~CDVRReadManager (
            ) ;

        //  go/stop
        HRESULT Active (IN IReferenceClock *, IN CDVRClock *) ;
        HRESULT Inactive () ;

        //  runtime-thread entry
        HRESULT Process () ;

        //  called by reader thread if there's a problem
        HRESULT
        ErrorHandler (
            IN  HRESULT hr
            ) ;

        REFERENCE_TIME DownstreamBuffering ()   { return m_rtDownstreamBuffering ; }

        BOOL IsLiveSource ()        { return (m_pDVRDShowReader ? m_pDVRDShowReader -> IsLiveSource () : FALSE) ; }

        //  dshow-based seeking
        HRESULT SeekTo              (IN REFERENCE_TIME * prtStart, IN REFERENCE_TIME * prtStop, IN double dPlaybackRate) ;
        HRESULT GetCurrentStart     (OUT REFERENCE_TIME * prtStart) ;
        HRESULT GetCurrentStop      (OUT REFERENCE_TIME * prtStop) ;
        double  GetPlaybackRate     ()  { return m_dPlaybackRate ; }
        HRESULT SetPlaybackRate     (IN double dPlaybackRate) ;
        HRESULT GetContentExtent    (OUT REFERENCE_TIME * prtStart, OUT REFERENCE_TIME * prtStop) ;
        HRESULT SetStop             (IN REFERENCE_TIME rtStop) ;

        QWORD   GetLastRead ()              { return m_cnsLastRead ; }
        void    SetLastRead (IN QWORD qw)   { m_cnsLastRead = qw ; }

        int     StreamCount ()              { return m_pDVRSourcePinManager -> PinCount () ; }

        IReferenceClock *   RefClock ()     { return m_pIRefClock ; }

        HRESULT
        SeekReader (
            IN OUT  QWORD * pcnsSeekStreamTime,
            IN      QWORD   qwStop
            ) ;

        HRESULT SeekReader (IN OUT  QWORD * pcnsSeekStreamTime) { return SeekReader (pcnsSeekStreamTime, m_cnsCurrentPlayStop) ; }

        void
        GetCurSegmentBoundaries (
            OUT QWORD * pqwStart,
            OUT QWORD * pqwStop
            )
        {
            (* pqwStart)    = m_cnsCurrentPlayStart ;
            (* pqwStop)     = m_cnsCurrentPlayStop ;
        }

        void
        SetNewSegmentBoundaries (
            IN  QWORD qwStart,
            IN  QWORD qwStop
            )
        {
            m_cnsCurrentPlayStart   = qwStart ;
            m_cnsCurrentPlayStop    = qwStop ;
        }

        void
        SetNewSegmentStart (
            IN  QWORD qwStart
            )
        {
            SetNewSegmentBoundaries (qwStart, m_cnsCurrentPlayStop) ;
        }

        void    ReaderReset () ;

        HRESULT
        CheckSetStartWithinContent (
            IN OUT  QWORD * pqwStart
            )
        {
            return CheckSetStartWithinContent_ (pqwStart, m_cnsCurrentPlayStop) ;
        }

        //  in-band events
        HRESULT DeliverEndOfStream ()   { return m_pDVRSourcePinManager -> DeliverEndOfStream () ; }
        HRESULT DeliverBeginFlush ()    { return m_pDVRSourcePinManager -> DeliverBeginFlush () ; }
        HRESULT DeliverEndFlush ()      { return m_pDVRSourcePinManager -> DeliverEndFlush () ; }
        void    NotifyNewSegment ()     { m_pDVRSourcePinManager -> NotifyNewSegment () ; }

        //  ability for control thread to grab reader thread lock
        void    ReaderThreadLock ()     { m_ReaderThread.Lock () ; }
        void    ReaderThreadUnlock ()   { m_ReaderThread.Unlock () ; }

        //  profile
        HRESULT GetRefdReaderProfile (OUT CDVRReaderProfile ** ppDVRReaderProfile)
        {
            ASSERT (m_pDVRDShowReader) ;
            return m_pDVRDShowReader -> GetRefdReaderProfile (ppDVRReaderProfile) ;
        }

        HRESULT
        ReadAndWaitWrap (
            OUT IMediaSample2 **    ppIMS2,
            OUT INSSBuffer **       ppINSSBuffer,           //  undefined if call fails
            OUT CDVROutputPin **    ppDVROutputPin,
            OUT AM_MEDIA_TYPE **    ppmtNew                 //  dynamic format change; don't free
            )
        {
            //  block if there are no media samples
            return ReadAndWrap_ (TRUE, ppINSSBuffer, ppIMS2, ppDVROutputPin, ppmtNew) ;
        }

        HRESULT
        ReadAndTryWrap (
            OUT IMediaSample2 **    ppIMS2,
            OUT INSSBuffer **       ppINSSBuffer,           //  undefined if call fails
            OUT CDVROutputPin **    ppDVROutputPin,
            OUT AM_MEDIA_TYPE **    ppmtNew                 //  dynamic format change; don't free
            )
        {
            //  don't block if there are no media samples
            return ReadAndWrap_ (FALSE, ppINSSBuffer, ppIMS2, ppDVROutputPin, ppmtNew) ;
        }
} ;

//  ============================================================================
//  CDVRRecordingReader
//  ============================================================================

class CDVRRecordingReader :
    public CDVRReadManager
{
    public :

        CDVRRecordingReader (
            IN  WCHAR *,
            IN  CDVRPolicy *,
            IN  CDVRSourcePinManager *,
            OUT HRESULT *           phr
            ) ;

        virtual
        ~CDVRRecordingReader (
            ) ;
} ;

//  ============================================================================
//  CDVRBroadcastStreamReader
//  ============================================================================

class CDVRBroadcastStreamReader :
    public CDVRReadManager
{
    protected :

        virtual
        BOOL
        OnActiveWaitFirstSeek_ (
            )
        {
            return DVRPolicies_ () -> Settings () -> OnActiveWaitFirstSeek () ;
        }

        virtual
        REFERENCE_TIME
        DownstreamBuffering_ (
            ) ;

    public :

        CDVRBroadcastStreamReader (
            IN  IDVRStreamSink *,
            IN  CDVRPolicy *,
            IN  CDVRSourcePinManager *,
            OUT HRESULT *
            ) ;

        virtual
        ~CDVRBroadcastStreamReader (
            ) ;
} ;

#endif  //  __tsdvr__shared__dvrdsread_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\shared\dvrclock.cpp ===
/*++

    Copyright (c) 2001  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        clock.cpp

    Abstract:

        This module contains the IReferenceClock implementation

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        24-May-2001     mgates

    Notes:

--*/

#include "dvrall.h"

#include "dvrclock.h"

//  ---------------------------------------------------------------------------
//  CDVRClock
//  ---------------------------------------------------------------------------

CDVRClock::CDVRClock (
    IN  IUnknown *  punkOwning,
    OUT HRESULT *   pHr
    ) : m_QPCTicksPerSecond             (1),
        m_hThread                       (NULL),
        m_pAdviseListHead               (NULL),
        m_pAdviseNodeFreePool           (NULL),
        m_llLastReturnedIRefTime        (0),
        m_llBaseQPCForLastReturnedTime  (0),
        m_uiTimerResolution             (0),
        m_rtGraphStart                  (0),
        m_dCarriedError                 (0.0),
        m_punkOwning                    (punkOwning),
        m_dClockSlavingScaler           (1.0),
        m_hEventUnblockThread           (NULL),
        m_fThreadExit                   (FALSE)
{
    LONG            l ;
    LARGE_INTEGER   li ;
    DWORD           dw ;
    DWORD           dwSlaveMult ;

    TRACE_CONSTRUCTOR (TEXT ("CDVRClock")) ;

    ASSERT (pHr) ;
    ASSERT (m_punkOwning) ;     //  weak ref !!

    (* pHr) = S_OK ;

    InitializeCriticalSection (& m_crtIRefConfig) ;
    InitializeCriticalSection (& m_crtGetTime) ;

    //  need the QPC functionality
    if (QueryPerformanceCounter (& li) == 0 ||
        QueryPerformanceFrequency (& li) == 0) {

        (* pHr) = E_FAIL ;
        goto cleanup ;
    }

    m_hEventUnblockThread = CreateEvent (NULL, TRUE, FALSE, NULL) ;
    if (m_hEventUnblockThread == NULL) {
        dw = GetLastError () ;
        (* pHr) = HRESULT_FROM_WIN32 (dw) ;
        goto cleanup ;
    }

    //  qpc frequency (filter makes sure that QueryPerformance_ calls
    //  succeed on the host system)
    QueryPerformanceFrequency (& li) ;
    m_QPCTicksPerSecond = li.QuadPart ;
    ASSERT (m_QPCTicksPerSecond > 0) ;

    //  snapshot our baseline qpc
    QueryPerformanceCounter (& li) ;
    m_llQPCNormalizer = 0 - li.QuadPart ;            //  we ADD this value to normalize, so it must be signed

    cleanup :

    return ;
}

CDVRClock::~CDVRClock (
    )
{
    SINGLE_LIST_ENTRY * pSListEntry ;
    ADVISE_NODE *       pAdviseNode ;
    DWORD               dw ;

    TRACE_DESTRUCTOR (TEXT ("CDVRClock")) ;

    //  exit the thread
    if (m_hThread) {

        //  set these two while holding the lock
        LockIRefConfig_ () ;
        m_fThreadExit = TRUE ;
        SetEvent (m_hEventUnblockThread) ;
        UnlockIRefConfig_ () ;

        WaitForSingleObject (m_hThread, INFINITE) ;
        CloseHandle (m_hThread) ;
    }

    if (m_hEventUnblockThread) {
        CloseHandle (m_hEventUnblockThread) ;
    }

    //  reset the timer resolution
    if (m_uiTimerResolution != 0) {
        timeBeginPeriod (m_uiTimerResolution) ;
    }

    //  free up what's in our free pool list
    while (m_pAdviseNodeFreePool != NULL) {
        //  pull the entry off the front
        pSListEntry = m_pAdviseNodeFreePool ;

        //  advance the list head
        m_pAdviseNodeFreePool  = m_pAdviseNodeFreePool  -> Next ;

        //  free the resources
        pAdviseNode = CONTAINING_RECORD (pSListEntry, ADVISE_NODE, SListEntry) ;
        delete pAdviseNode ;
    }

    //  and in case there are filters that have not canceled their advise requests
    //  we free those too; but we don't expect any
    ASSERT (m_pAdviseListHead == NULL) ;
    while (m_pAdviseListHead != NULL) {
        //  pull entry off the front
        pSListEntry = m_pAdviseListHead ;

        //  move the listhead ahead
        m_pAdviseListHead = m_pAdviseListHead -> Next ;

        //  free the resources
        pAdviseNode = CONTAINING_RECORD (pSListEntry, ADVISE_NODE, SListEntry) ;
        delete pAdviseNode ;
    }

    DeleteCriticalSection (& m_crtIRefConfig) ;
    DeleteCriticalSection (& m_crtGetTime) ;
}

void
CDVRClock::AdviseThreadBody (
    )
{
    DWORD           dwWaitRetVal ;
    DWORD           dwWait ;
    REFERENCE_TIME  rtNow ;
    HRESULT         hr ;

    TRACE_ENTER_0 (TEXT ("CDVRClock::AdviseThreadBody ()")) ;

    dwWait = INFINITE ;

    for (;;) {
        dwWaitRetVal = WaitForSingleObject (m_hEventUnblockThread, dwWait) ;

        LockIRefConfig_ () ;

        if (m_fThreadExit) {
            UnlockIRefConfig_ () ;
            break ;
        }

        hr = GetTime (& rtNow) ;
        if (SUCCEEDED (hr)) {
            switch (dwWaitRetVal) {
                case WAIT_TIMEOUT :
                    //  add on 1 millisecond so we won't spin freely if there's another
                    //   advise node that is less than 1 millisecond from now (giving
                    //   us dwWait of 0)
                    dwWait = ProcessNotificationTimeoutLocked_ (rtNow + 10000) ;
                    break ;

                case WAIT_OBJECT_0 :
                    dwWait = ResetWaitTimeLocked_ (rtNow) ;
                    ResetEvent (m_hEventUnblockThread) ;
                    break ;

                default :
                    //  exit on all others - prevents us from spinning at 100% cpu
                    //   in case of some os error
                    m_fThreadExit = TRUE ;
                    break ;
            } ;
        }

        UnlockIRefConfig_ () ;
    }

    return ;
}

void
CDVRClock::QueueAdviseTimeout_ (
    IN  ADVISE_NODE *   pNewAdviseNode
    )
//  must hold the list lock
{
    SINGLE_LIST_ENTRY **    ppCurSListEntry ;
    ADVISE_NODE *           pCurAdviseNode ;

    TRACE_ENTER_0 (TEXT ("CDVRClock::QueueAdviseTimeout_ ()")) ;

    ASSERT (pNewAdviseNode) ;

    //  list is sorted by advise time; find the slot
    for (ppCurSListEntry = & m_pAdviseListHead;
         (* ppCurSListEntry) != NULL;
         ppCurSListEntry = & (* ppCurSListEntry) -> Next) {

        pCurAdviseNode = CONTAINING_RECORD (* ppCurSListEntry, ADVISE_NODE, SListEntry) ;
        if (pCurAdviseNode -> rtAdviseTime >= pNewAdviseNode -> rtAdviseTime) {
            break ;
        }
    }

    //  and insert it
    pNewAdviseNode -> SListEntry.Next = (* ppCurSListEntry) ;
    (* ppCurSListEntry) = & pNewAdviseNode -> SListEntry ;
}

HRESULT
CDVRClock::CancelAdviseTimeout_ (
    IN  ADVISE_NODE *   pAdviseNode
    )
//  searches the list of advise nodes, and removes it if found
{
    SINGLE_LIST_ENTRY **    ppCurSListEntry ;
    ADVISE_NODE *           pCurAdviseNode ;

    TRACE_ENTER_0 (TEXT ("CDVRClock::CanceldviseTimeout_ ()")) ;

    //  search from beginning to end for the advise node; unfortunately there's
    //   no way to ensure that the caller has not given us a bogus pointer
    for (ppCurSListEntry = & m_pAdviseListHead;
         (* ppCurSListEntry) != NULL;
         ppCurSListEntry = & ((* ppCurSListEntry) -> Next)) {

        pCurAdviseNode = CONTAINING_RECORD (*ppCurSListEntry, ADVISE_NODE, SListEntry) ;

        if (pCurAdviseNode == pAdviseNode) {

            //  unhook
            (* ppCurSListEntry) = pCurAdviseNode -> SListEntry.Next ;
            RecycleAdviseNode_ (pCurAdviseNode) ;

            //  success
            return S_OK ;
        }
    }

    //  failure
    return E_FAIL ;
}

DWORD
CDVRClock::ProcessNotificationTimeoutLocked_ (
    IN  REFERENCE_TIME  rtNow
    )
//  locks held: list lock
{
    SINGLE_LIST_ENTRY * pSListEntry ;
    ADVISE_NODE *       pAdviseNode ;
    REFERENCE_TIME      rtDelta ;
    LONG                lPreviousCount ;

    TRACE_ENTER_1 (TEXT ("CDVRClock::ProcessNotificationTimeoutLocked_ (%016I64x)"), rtNow) ;

    for (pSListEntry = m_pAdviseListHead ;
         pSListEntry != NULL ;
         pSListEntry = m_pAdviseListHead) {

        //  recover the advise_node
        pAdviseNode = CONTAINING_RECORD (pSListEntry, ADVISE_NODE, SListEntry) ;

        //  break from the loop if we are into notifications which must be
        //   signaled in the future.
        if (pAdviseNode -> rtAdviseTime > rtNow) {
            break ;
        }

        //  the list head points to a node that has a notification that must be made
        //  now or in the past

        //  and remove it from the front
        m_pAdviseListHead = pAdviseNode -> SListEntry.Next ;

        //  if it's a period advise
        if (pAdviseNode -> rtPeriodTime != 0) {
            //  signal the semaphore
            ReleaseSemaphore (
                pAdviseNode -> hSignal,
                1,
                & lPreviousCount
                ) ;

            #ifdef DEBUG
            REFERENCE_TIME  rtNow ;
            REFERENCE_TIME  rtDelta ;
            HRESULT         hr ;
            hr = GetTime (& rtNow) ;
            rtDelta = rtNow - pAdviseNode -> rtAdviseTime ;
            TRACE_4 (LOG_AREA_TIME, 4,
                TEXT ("Periodic: now - advise = %10I64d %5I64d; %08xh; %08xh"),
                rtDelta, DShowTimeToMilliseconds (rtDelta), pAdviseNode -> hSignal, hr) ;
            #endif

            //  increment to the next time we need to notify
            pAdviseNode -> rtAdviseTime += pAdviseNode -> rtPeriodTime ;

            //  and queue for the next timeout
            QueueAdviseTimeout_ (
                pAdviseNode
                ) ;
        }
        else {
            //  otherwise, it's a one shot notification

            //  signal the event
            SetEvent (pAdviseNode -> hSignal) ;

            #ifdef DEBUG
            REFERENCE_TIME  rtNow ;
            REFERENCE_TIME  rtDelta ;
            HRESULT         hr ;
            hr = GetTime (& rtNow) ;
            rtDelta = rtNow - pAdviseNode -> rtAdviseTime ;
            TRACE_4 (LOG_AREA_TIME, 4,
                TEXT ("Single: now - advise = %10I64d %5I64d; %08xh; %08xh"),
                rtDelta, DShowTimeToMilliseconds (rtDelta), pAdviseNode -> hSignal, hr) ;
            #endif

            RecycleAdviseNode_ (pAdviseNode) ;
        }
    }

    return ResetWaitTimeLocked_ (rtNow) ;
}

DWORD
CDVRClock::ResetWaitTimeLocked_ (
    IN  REFERENCE_TIME  rtNow
    )
//  locks held: list lock
{
    REFERENCE_TIME  rtDelta ;
    ADVISE_NODE *   pAdviseNode ;

    TRACE_ENTER_0 (TEXT ("CDVRClock::ResetWaitTimeLocked_ ()")) ;

    //  figure out how long we must wait until the next one
    if (m_pAdviseListHead) {
        pAdviseNode = CONTAINING_RECORD (m_pAdviseListHead, ADVISE_NODE, SListEntry) ;
        rtDelta = pAdviseNode -> rtAdviseTime > rtNow ? pAdviseNode -> rtAdviseTime - rtNow : 0 ;

        TRACE_3 (LOG_AREA_TIME, 4,
            TEXT ("WaitNext() : rtAdviseTime = %I64d, rtNow = %I64d, rtAdviseTime - rtNow = %I64d"),
            pAdviseNode -> rtAdviseTime, rtNow, pAdviseNode -> rtAdviseTime - rtNow) ;

        //  safe cast because we are dealing with a delta vs. an absolute time
        return SkewedWaitMilliseconds_ ((DWORD) (DShowTimeToMilliseconds (rtDelta))) ;
    }
    else {
        //  there are none queued to be processed; wait infinitely long
        return INFINITE ;
    }
}

HRESULT
CDVRClock::AdvisePeriodicLocked_ (
    IN  REFERENCE_TIME  rtStartTime,
    IN  REFERENCE_TIME  rtPeriodTime,
    IN  HANDLE          hSemaphore,
    OUT DWORD_PTR *     pdwpContext
    )
{
    ADVISE_NODE *   pAdviseNode ;
    HRESULT         hr ;

    TRACE_ENTER_4 (TEXT ("CDVRClock::AdvisePeriodicLocked_ (%016I64x, %016I64x, %08xh, %8xh)"), rtStartTime, rtPeriodTime, hSemaphore, pdwpContext) ;

    //  confirm that this is a valid request
    if (rtStartTime     < 0     ||
        rtPeriodTime    <= 0    ||
        rtStartTime     == MAX_REFERENCE_TIME) {

        return E_INVALIDARG ;
    }

    //  make sure our advisory thread is up and running
    hr = ConfirmAdviseThreadRunning_ () ;
    if (FAILED (hr)) {
        return hr ;
    }

    //  get a node
    pAdviseNode = GetAdviseNode_ () ;
    if (pAdviseNode == NULL) {
        return E_OUTOFMEMORY ;
    }

    //  set the fields
    pAdviseNode -> hSignal      = hSemaphore ;
    pAdviseNode -> rtAdviseTime = rtStartTime ;
    pAdviseNode -> rtPeriodTime = rtPeriodTime ;

    QueueAdviseTimeout_ (pAdviseNode) ;

    //  if we inserted at the head, processing thread will need to reset its
    //   wait period
    if (m_pAdviseListHead == & pAdviseNode -> SListEntry) {
        SetEvent (m_hEventUnblockThread) ;
    }

    (* pdwpContext) = (DWORD_PTR) pAdviseNode ;

    return S_OK ;
}

HRESULT
CDVRClock::AdviseTimeLocked_ (
    IN  REFERENCE_TIME  rtBaseTime,
    IN  REFERENCE_TIME  rtStreamTime,
    IN  HANDLE          hEvent,
    OUT DWORD_PTR *     pdwpContext
    )
{
    ADVISE_NODE *   pAdviseNode ;
    REFERENCE_TIME  rtAdviseTime ;
    REFERENCE_TIME  rtNow ;
    HRESULT         hr ;

    TRACE_ENTER_4 (TEXT ("CDVRClock::AdviseTimeLocked_ (%016I64x, %016I64x, %08xh, %8xh)"), rtBaseTime, rtStreamTime, hEvent, pdwpContext) ;

    //  confirm that this is a valid request
    rtAdviseTime = rtBaseTime + rtStreamTime ;
    if (rtAdviseTime    <= 0                    ||
        rtAdviseTime    == MAX_REFERENCE_TIME   ||
        rtStreamTime    < 0) {

        return E_INVALIDARG ;
    }

    //  check for an advise time that's now or in the past; if this is the case
    //   we don't need to queue anything
    hr = GetTime (& rtNow) ;
    if (SUCCEEDED (hr) &&
        rtAdviseTime <= rtNow) {

        //  already there; signal & return
        SetEvent (hEvent) ;
        return hr ;
    }

    //  make sure our advisory thread is up and running
    hr = ConfirmAdviseThreadRunning_ () ;
    if (FAILED (hr)) {
        return hr ;
    }

    //  get a node
    pAdviseNode = GetAdviseNode_ () ;
    if (pAdviseNode == NULL) {
        return E_OUTOFMEMORY ;
    }

    //  set the fields
    pAdviseNode -> hSignal      = hEvent ;
    pAdviseNode -> rtAdviseTime = rtAdviseTime ;

    ASSERT (pAdviseNode -> rtPeriodTime == 0) ;

    QueueAdviseTimeout_ (pAdviseNode) ;

    //  if we inserted at the head, processing thread will need to reset its
    //   wait period
    if (m_pAdviseListHead == & pAdviseNode -> SListEntry) {
        SetEvent (m_hEventUnblockThread) ;
    }

    (* pdwpContext) = (DWORD_PTR) pAdviseNode ;

    return S_OK ;
}

//  ---------------------------------------------------------------------------
//      CDVRClock
//  ---------------------------------------------------------------------------

STDMETHODIMP
CDVRClock::QueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    //  delegate always
    return m_punkOwning -> QueryInterface (riid, ppv) ;
}

STDMETHODIMP_(ULONG)
CDVRClock::AddRef (
    )
{
    //  delegate always
    return m_punkOwning -> AddRef () ;
}

STDMETHODIMP_(ULONG)
CDVRClock::Release (
    )
{
    //  delegate always
    return m_punkOwning -> Release () ;
}

STDMETHODIMP
CDVRClock::AdvisePeriodic (
    IN  REFERENCE_TIME  rtStartTime,
    IN  REFERENCE_TIME  rtPeriodTime,
    IN  HSEMAPHORE      hSemaphore,
    OUT DWORD_PTR *     pdwpContext
    )
{
    HRESULT hr ;

    TRACE_ENTER_0 (TEXT ("CDVRClock::AdvisePeriodic ()")) ;

    //  validate the parameters
    if (pdwpContext     == NULL ||
        hSemaphore      == NULL ||
        rtPeriodTime    == 0) {

        return E_INVALIDARG ;
    }

    LockIRefConfig_ () ;
    hr = AdvisePeriodicLocked_ (
            rtStartTime,
            rtPeriodTime,
            reinterpret_cast <HANDLE> (hSemaphore),
            pdwpContext
            ) ;
    UnlockIRefConfig_ () ;

    return hr ;
}

STDMETHODIMP
CDVRClock::AdviseTime (
    IN  REFERENCE_TIME  rtBaseTime,
    IN  REFERENCE_TIME  rtStreamTime,
    IN  HEVENT          hEvent,
    OUT DWORD_PTR *     pdwpContext
    )
{
    HRESULT hr ;

    TRACE_ENTER_0 (TEXT ("CDVRClock::AdviseTime ()")) ;

    if (hEvent      == NULL ||
        pdwpContext == NULL) {

        return E_INVALIDARG ;
    }

    LockIRefConfig_ () ;
    hr = AdviseTimeLocked_ (
            rtBaseTime,
            rtStreamTime,
            reinterpret_cast <HANDLE> (hEvent),
            pdwpContext
            ) ;
    UnlockIRefConfig_ () ;

    return hr ;
}

STDMETHODIMP
CDVRClock::GetTime (
    OUT REFERENCE_TIME *    pTime
    )
/*++
    purpose:
    parameters:
    return values:
    notes:

        This value is computed as follows:

            1. sample the QPC counter
            2. compute delta from last returned value
            3. skew the time (i.e. clock slave)
            4. set the new last returned time
            5. return
--*/
{
    LARGE_INTEGER   liNow ;
    LONGLONG        llDelta ;
    double          dDelta ;
    double          dDeltaScaled ;

    TRACE_ENTER_0 (TEXT ("CDVRClock::GetTime ()")) ;

    if (pTime == NULL) {
        return E_POINTER ;
    }

    LockGetTime_ () ;

    //  sample
    QueryPerformanceCounter (& liNow) ;

    llDelta = NORMALIZED_QPC (liNow.QuadPart) - m_llBaseQPCForLastReturnedTime ;

    //  make sure we don't go backwards; BIOS bugs have made this happen
    llDelta = (llDelta > 0 ? llDelta : 0) ;

    //  save the delta; safe cast because this is a very small delta
    dDelta = (double) llDelta ;

    //  scale according to our slope
    dDeltaScaled = dDelta * m_dClockSlavingScaler ;

    //  accumulate the error
    dDeltaScaled += m_dCarriedError ;

    //  compute the non FP value that we are going to use
    llDelta = (LONGLONG) dDeltaScaled ;

    //  make sure bizarre conditions have not conspired to make the clock run
    //  backwards
    if (llDelta < 0) {
        llDelta = 0 ;
        m_dCarriedError = 0.0 ; //  reset this; we're in no-man's land
    }

    //  carry the error to the next call
    m_dCarriedError = dDeltaScaled - ((double) llDelta) ;
    //m_pStats -> Carry (& m_dCarriedError) ;

    //  save the "now: value off as the basis for the last returned time
    m_llBaseQPCForLastReturnedTime = NORMALIZED_QPC (liNow.QuadPart) ;

    //  save this off as the last returned time
    m_llLastReturnedIRefTime += llDelta ;

    //  set the return value & scale
    (* pTime) = QPCToDShow (m_llLastReturnedIRefTime, m_QPCTicksPerSecond) ;

    UnlockGetTime_ () ;

    //  make sure we return a time that is no earlier than graph start;
    //  filtergraph pads the start time (first call to ::GetTime) by 10 ms
    //  to allow each filter to get up and running; if we blindly return
    //  the time before that first 10 ms has elapsed, we'll start the whole
    //  graph up in catchup mode
    (* pTime) = Max (m_rtGraphStart, (* pTime)) ;

    return S_OK ;
}

STDMETHODIMP
CDVRClock::Unadvise (
    IN  DWORD_PTR   dwpContext
    )
{
    HRESULT hr ;

    TRACE_ENTER_0 (TEXT ("CDVRClock::Unadvise ()")) ;

    if (dwpContext == 0) {
        return E_INVALIDARG ;
    }

    LockIRefConfig_ () ;
    hr = CancelAdviseTimeout_ (reinterpret_cast <ADVISE_NODE *> (dwpContext)) ;
    UnlockIRefConfig_ () ;

    return hr ;
}

void
CDVRClock::FilterStateChanged (
    IN  FILTER_STATE    OldFilterState,
    IN  FILTER_STATE    NewFilterState,
    IN  REFERENCE_TIME  rtStart             //  0 if not start run
    )
{
    TRACE_ENTER_2 (TEXT ("CDVRClock::FilterStateChanged (%08xh, %08xh)"), OldFilterState, NewFilterState) ;

    switch (NewFilterState) {
        case State_Running :

            //  not sure if it's possible to get ::Run twice .. should be an
            //   assert if it isn't
            if (OldFilterState != State_Running) {
                m_dClockSlavingScaler   = 1.0 ;         //  reset scaler as well
                m_rtGraphStart          = rtStart ;
            }

            break ;

        case State_Paused :
            break ;

        case State_Stopped :
            m_rtGraphStart = 0 ;
            break ;
    } ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\shared\dvrdsrec.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrdsrec.cpp

    Abstract:

        This module contains the code for our recording objects

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        23-Apr-2001     created

--*/

#include "dvrall.h"
#include "dvrdsrec.h"

CDVRRecording::CDVRRecording (
    IN  IDVRRecorder *  pIDVRRecorder
    ) : m_pIDVRRecorder (pIDVRRecorder),
        CUnknown        (TEXT ("CDVRRecording"),
                         NULL
                         )
{
    ASSERT (m_pIDVRRecorder) ;
    m_pIDVRRecorder -> AddRef () ;
}

CDVRRecording::~CDVRRecording (
    )
{
    RELEASE_AND_CLEAR (m_pIDVRRecorder) ;
}

STDMETHODIMP
CDVRRecording::NonDelegatingQueryInterface (
    REFIID  riid,
    void ** ppv
    )
{
    //  ========================================================================
    //  IDVRRecordControl

    if (riid == IID_IDVRRecordControl) {

        return GetInterface (
                    (IDVRRecordControl *) this,
                    ppv
                    ) ;
    }

    return CUnknown::NonDelegatingQueryInterface (riid, ppv) ;
}

//  ============================================================================
//  IDVRRecordControl

STDMETHODIMP
CDVRRecording::Start (
    IN  REFERENCE_TIME  rtStart
    )
{
    HRESULT         hr ;

    hr = m_pIDVRRecorder -> StartRecording (DShowToWMSDKTime (rtStart)) ;

    return hr ;
}

STDMETHODIMP
CDVRRecording::Stop (
    IN  REFERENCE_TIME  rtStop
    )
{
    HRESULT hr ;

    hr = m_pIDVRRecorder -> StopRecording (DShowToWMSDKTime (rtStop)) ;

    return hr ;
}

STDMETHODIMP
CDVRRecording::GetRecordingStatus (
    OUT HRESULT* phResult  /* optional */,
    OUT BOOL*    pbStarted /* optional */,
    OUT BOOL*    pbStopped /* optional */
    )
{
    if ( m_pIDVRRecorder )
    {
        return m_pIDVRRecorder -> GetRecordingStatus (phResult, pbStarted, pbStopped) ;

    }
    else
    {
        return E_UNEXPECTED ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\shared\dvrdsseek.h ===
/*++

    Copyright (c) 2001  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        dvrdsseek.h

    Abstract:

        This module contains the IMediaSeeking class declarations.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        10-Apr-2001     mgates      created

    Notes:

--*/

#ifndef __tsdvr__shared__dvrdsseek_h
#define __tsdvr__shared__dvrdsseek_h

class CDVRDShowSeekingCore
{
    GUID                    m_guidTimeFormat ;
    CRITICAL_SECTION        m_crtSeekingLock ;
    CDVRReadManager *       m_pDVRReadManager ;
    CDVRSourcePinManager *  m_pDVRSourcePinManager ;
    CCritSec *              m_pFilterLock ;
    CBaseFilter *           m_pHostingFilter ;

    //  returns the offset last read
    LONGLONG
    GetLastRead_ (
        ) ;

    HRESULT
    TimeToCurrentFormat_ (
        IN  REFERENCE_TIME  rt,
        OUT LONGLONG *      pll
        ) ;

    HRESULT
    CurrentFormatToTime_ (
        IN  LONGLONG            ll,
        OUT REFERENCE_TIME *    prt
        ) ;

    void FilterLock_ ()     { m_pFilterLock -> Lock () ; }
    void FilterUnlock_ ()   { m_pFilterLock -> Unlock () ; }

    public :

        CDVRDShowSeekingCore (
            IN  CCritSec *          pFilterLock,
            IN  CBaseFilter *       pHostingFilter
            ) ;

        ~CDVRDShowSeekingCore (
            ) ;

        void SetDVRSourcePinManager (IN CDVRSourcePinManager *  pDVRSourcePinManager)   { m_pDVRSourcePinManager = pDVRSourcePinManager ; }
        void SetDVRReadManager      (IN CDVRReadManager *       pDVRReadManager)        { m_pDVRReadManager = pDVRReadManager ; }

        void Lock ()        { EnterCriticalSection (& m_crtSeekingLock) ; }
        void Unlock ()      { LeaveCriticalSection (& m_crtSeekingLock) ; }

        BOOL
        IsSeekingPin (
            IN  CDVROutputPin *
            ) ;

        HRESULT
        GetSeekingCapabilities (
            OUT DWORD * pCapabilities
            )
        {
            ASSERT (pCapabilities) ;

            (* pCapabilities) = AM_SEEKING_CanSeekForwards
                              | AM_SEEKING_CanSeekBackwards
                              | AM_SEEKING_CanSeekAbsolute
                              | AM_SEEKING_CanGetStopPos
                              | AM_SEEKING_CanGetDuration ;

            return S_OK ;
        }

        BOOL
        IsSeekingFormatSupported (
            IN  const GUID *    pFormat
            ) ;

        HRESULT
        QueryPreferredSeekingFormat (
            OUT GUID *
            ) ;

        HRESULT
        SetSeekingTimeFormat (
            IN  const GUID *
            ) ;

        HRESULT
        GetSeekingTimeFormat (
            OUT GUID *
            ) ;

        HRESULT
        GetFileDuration (
            OUT LONGLONG *
            ) ;

        HRESULT
        GetFileStopPosition (
            OUT LONGLONG *
            ) ;

        HRESULT
        GetAvailableContent (
            OUT LONGLONG *  pllStartContent,
            OUT LONGLONG *  pllStopContent
            ) ;

        HRESULT
        GetFileStartPosition (
            OUT LONGLONG *
            ) ;

        HRESULT
        SeekTo (
            IN  LONGLONG *  pllStart
            ) ;

        HRESULT
        SeekTo (
            IN  LONGLONG *  pllStart,
            IN  LONGLONG *  pllStop,            //  NULL means don't set
            IN  double      dPlaybackRate = 1.0
            ) ;

        HRESULT
        SetFileStopPosition (
            IN  LONGLONG *
            ) ;

        HRESULT
        SetPlaybackRate (
            IN  double
            ) ;

        HRESULT
        GetPlaybackRate (
            OUT double *
            ) ;

        HRESULT
        ReaderThreadGetSegmentValues (
            OUT REFERENCE_TIME *    prtSegmentStart,
            OUT REFERENCE_TIME *    prtSegmentStop,
            OUT double *            pdSegmentRate
            ) ;
} ;

class CDVRDIMediaSeeking :
    public IMediaSeeking
{
    CDVROutputPin *         m_pOutputPin ;
    GUID                    m_guidSeekingFormat ;
    CDVRDShowSeekingCore *  m_pSeekingCore ;

    void SeekingLock_ ()            { m_pSeekingCore -> Lock () ; }
    void SeekingUnlock_ ()          { m_pSeekingCore -> Unlock () ; }

    public :

        CDVRDIMediaSeeking (
            IN  CDVROutputPin *         pOutputPin,
            IN  CDVRDShowSeekingCore *  pSeekingCore
            ) ;

        ~CDVRDIMediaSeeking (
            ) ;

        //  --------------------------------------------------------------------
        //  IUnknown methods - delegate always

        STDMETHODIMP QueryInterface (REFIID riid, void ** ppv) ;
        STDMETHODIMP_ (ULONG) AddRef () ;
        STDMETHODIMP_ (ULONG) Release () ;

        //  --------------------------------------------------------------------
        //  IMediaSeeking interface methods

        //  Returns the capability flags; S_OK if successful
        STDMETHODIMP
        GetCapabilities (
            OUT DWORD * pCapabilities
            ) ;

        //  And's the capabilities flag with the capabilities requested.
        //  Returns S_OK if all are present, S_FALSE if some are present,
        //  E_FAIL if none.
        //  * pCababilities is always updated with the result of the
        //  'and'ing and can be checked in the case of an S_FALSE return
        //  code.
        STDMETHODIMP
        CheckCapabilities (
            IN OUT  DWORD * pCapabilities
            ) ;

        //  returns S_OK if mode is supported, S_FALSE otherwise
        STDMETHODIMP
        IsFormatSupported (
            IN  const GUID *    pFormat
            ) ;

        //  S_OK if successful
        //  E_NOTIMPL, E_POINTER if unsuccessful
        STDMETHODIMP
        QueryPreferredFormat (
            OUT GUID *  pFormat
            ) ;

        //  S_OK if successful
        STDMETHODIMP
        GetTimeFormat (
            OUT GUID *  pFormat
            ) ;

        //  Returns S_OK if *pFormat is the current time format, otherwise
        //  S_FALSE
        //  This may be used instead of the above and will save the copying
        //  of the GUID
        STDMETHODIMP
        IsUsingTimeFormat (
            IN const GUID * pFormat
            ) ;

        // (may return VFE_E_WRONG_STATE if graph is stopped)
        STDMETHODIMP
        SetTimeFormat (
            IN const GUID * pFormat
            ) ;

        // return current properties
        STDMETHODIMP
        GetDuration (
            OUT LONGLONG *  pDuration
            ) ;

        STDMETHODIMP
        GetStopPosition (
            OUT LONGLONG *  pStop
            ) ;

        STDMETHODIMP
        GetCurrentPosition (
            OUT LONGLONG *  pStart
            ) ;

        //  Convert time from one format to another.
        //  We must be able to convert between all of the formats that we
        //  say we support.  (However, we can use intermediate formats
        //  (e.g. MEDIA_TIME).)
        //  If a pointer to a format is null, it implies the currently selected format.
        STDMETHODIMP
        ConvertTimeFormat(
            OUT LONGLONG *      pTarget,
            IN  const GUID *    pTargetFormat,
            IN  LONGLONG        Source,
            IN  const GUID *    pSourceFormat
            ) ;

        // Set Start and end positions in one operation
        // Either pointer may be null, implying no change
        STDMETHODIMP
        SetPositions (
            IN OUT  LONGLONG *  pStart,
            IN      DWORD       dwStartFlags,
            IN OUT  LONGLONG *  pStop,
            IN      DWORD       dwStopFlags
            ) ;

        // Get StartPosition & StopTime
        // Either pointer may be null, implying not interested
        STDMETHODIMP
        GetPositions (
            OUT LONGLONG *  pStart,
            OUT LONGLONG *  pStop
            ) ;

        //  Get earliest / latest times to which we can currently seek
        //  "efficiently".  This method is intended to help with graphs
        //  where the source filter has a very high latency.  Seeking
        //  within the returned limits should just result in a re-pushing
        //  of already cached data.  Seeking beyond these limits may result
        //  in extended delays while the data is fetched (e.g. across a
        //  slow network).
        //  (NULL pointer is OK, means caller isn't interested.)
        STDMETHODIMP
        GetAvailable (
            OUT LONGLONG *  pEarliest,
            OUT LONGLONG *  pLatest
            ) ;

        // Rate stuff
        STDMETHODIMP
        SetRate (
            IN  double  dRate
            ) ;

        STDMETHODIMP
        GetRate (
            OUT double *    pdRate
            ) ;

        // Preroll
        STDMETHODIMP
        GetPreroll (
            OUT LONGLONG *  pllPreroll
            ) ;
} ;

#endif  //  __tsdvr__shared__dvrdsseek_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\shared\dvrdswrite.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrdswrite.h

    Abstract:

        This module contains the declarations for our writing layer.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef __tsdvr__shared__dvrdswrite_h
#define __tsdvr__shared__dvrdswrite_h

//  ============================================================================
//  CDVRWriter
//  ============================================================================

class CDVRWriter :
    public IDVRStreamSinkPriv
{
    IUnknown *  m_punkControlling ;     //  controlling unknown - we
                                        //   delegate everything; weak ref !!

    protected :

        IDVRRingBufferWriter *  m_pDVRIOWriter ;
        IWMProfile *            m_pIWMProfile ;

        void ReleaseAndClearDVRIOWriter_ () ;

    public :

        CDVRWriter (
            IN  IUnknown *      punkControlling,            //  weak ref !!
            IN  IWMProfile *    pIWMProfile
            ) ;

        virtual
        ~CDVRWriter (
            ) ;

        STDMETHODIMP_ (ULONG)   AddRef ()                                   { return m_punkControlling -> AddRef () ; }
        STDMETHODIMP_ (ULONG)   Release ()                                  { return m_punkControlling -> Release () ; }
        STDMETHODIMP            QueryInterface (REFIID riid, void ** ppv)   { return m_punkControlling -> QueryInterface (riid, ppv) ; }

        IMPLEMENT_IDVRSTREAMSINKPRIV () ;

        virtual
        HRESULT
        Write (
            IN  WORD            wStreamNumber,
            IN  QWORD           cnsSampleTime,
            IN  QWORD           msSendTime,
            IN  QWORD           cnsSampleDuration,
            IN  DWORD           dwFlags,
            IN  INSSBuffer *    pINSSBuffer
            ) = 0 ;

        STDMETHODIMP
        CreateRecorder (
            IN  LPCWSTR     pszFilename,
            IN  DWORD       dwReserved,
            OUT IUnknown ** pRecordingIUnknown
            ) ;

        HRESULT
        Active (
            ) ;
} ;

//  ============================================================================
//  CDVRIOWriter
//  ============================================================================

class CDVRIOWriter :
    public CDVRWriter
{
    public :

        CDVRIOWriter (
            IN  IUnknown *      punkControlling,
            IN  CDVRPolicy *    pPolicy,
            IN  IWMProfile *    pIWMProfile,
            OUT HRESULT *       phr
            ) ;

        virtual
        ~CDVRIOWriter (
            ) ;

        virtual
        HRESULT
        Write (
            IN  WORD            wStreamNumber,
            IN  QWORD           cnsSampleTime,
            IN  QWORD           msSendTime,
            IN  QWORD           cnsSampleDuration,
            IN  DWORD           dwFlags,
            IN  INSSBuffer *    pINSSBuffer
            ) ;
} ;

//  ============================================================================
//  CDVRWriteManager
//  ============================================================================

class CDVRWriteManager :
    public CIDVRDShowStream
{
    CWMINSSBuffer3WrapperPool   m_INSSBuffer3Wrappers ;
    CDVRWriter *                m_pDVRWriter ;
    IReferenceClock *           m_pIRefClock ;
    REFERENCE_TIME              m_rtStartTime ;
    CDVRReceiveStatsWriter      m_DVRReceiveStatsWriter ;

    public :

        CDVRWriteManager (
            IN  CDVRPolicy *
            ) ;

        ~CDVRWriteManager (
            ) ;

        HRESULT
        Active (
            IN  CDVRWriter *        pDVRWriter,
            IN  IReferenceClock *   pIRefClock
            ) ;

        HRESULT
        Inactive (
            ) ;

        void
        SetGraphStart (
            IN  REFERENCE_TIME  rtStart
            )
        {
            m_rtStartTime = rtStart ;
        }

        //  --------------------------------------------------------------------
        //  CIDVRDShowStream

        virtual
        HRESULT
        OnReceive (
            IN  int                         iPinIndex,
            IN  CDVRAttributeTranslator *   pTranslator,
            IN  IMediaSample *              pIMediaSample
            ) ;

        virtual
        HRESULT
        OnBeginFlush (
            IN  int iPinIndex
            ) ;

        virtual
        HRESULT
        OnEndFlush (
            IN  int iPinIndex
            ) ;

        virtual
        HRESULT
        OnEndOfStream (
            IN  int iPinIndex
            ) ;
} ;

#endif  //  __tsdvr__shared__dvrdswrite_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\shared\dvrdswrite.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrdswrite.cpp

    Abstract:

        This module contains the code for our writing layer.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#include "dvrall.h"

#include "dvrprof.h"
#include "dvrdsseek.h"          //  pins reference seeking interfaces
#include "dvrpins.h"
#include "dvrdswrite.h"
#include "dvrdsrec.h"

static
HRESULT
IndexStreamId (
    IN  IWMProfile *    pIWMProfile,
    OUT WORD *          pwStreamId
    )
{
    IWMStreamConfig *   pIWMStreamConfig ;
    DWORD               dwStreamCount ;
    HRESULT             hr ;
    WORD                w ;
    GUID                guidStreamType ;

    ASSERT (pIWMProfile) ;
    ASSERT (pwStreamId) ;

    hr = pIWMProfile -> GetStreamCount (& dwStreamCount) ;

    //  default to 1
    (* pwStreamId) = 1 ;

    //  but look for a video stream
    for (w = 1; w <= dwStreamCount && SUCCEEDED (hr); w++) {
        hr = pIWMProfile -> GetStreamByNumber (w, & pIWMStreamConfig) ;
        if (SUCCEEDED (hr)) {
            hr = pIWMStreamConfig -> GetStreamType (& guidStreamType) ;
            if (SUCCEEDED (hr)) {
                if (DShowWMSDKHelpers::IsWMVideoStream (guidStreamType)) {
                    (* pwStreamId) = w ;
                    pIWMStreamConfig -> Release () ;
                    break ;
                }
            }

            pIWMStreamConfig -> Release () ;
        }
    }

    return hr ;
}

//  ============================================================================
//  CDVRWriter
//  ============================================================================

CDVRWriter::CDVRWriter (
    IN  IUnknown *      punkControlling,            //  weak ref !!
    IN  IWMProfile *    pIWMProfile
    ) : m_punkControlling   (punkControlling),
        m_pIWMProfile       (pIWMProfile),
        m_pDVRIOWriter      (NULL)
{
    ASSERT (m_punkControlling) ;
    ASSERT (m_pIWMProfile) ;
    m_pIWMProfile -> AddRef () ;
}

CDVRWriter::~CDVRWriter (
    )
{
    m_pIWMProfile -> Release () ;
    ASSERT (m_pDVRIOWriter == NULL) ;   //  child classes must free all resources
                                        //    associated with the ringbuffer
}

void
CDVRWriter::ReleaseAndClearDVRIOWriter_ (
    )
{
    if (m_pDVRIOWriter) {
        m_pDVRIOWriter -> Close () ;
    }

    RELEASE_AND_CLEAR (m_pDVRIOWriter) ;
}

HRESULT
CDVRWriter::GetIDVRReader (
    OUT IDVRReader **   ppIDVRReader
    )
{
    HRESULT hr ;

    if (!ppIDVRReader) {
        return E_POINTER ;
    }

    if (m_pDVRIOWriter) {
        hr = m_pDVRIOWriter -> CreateReader (ppIDVRReader) ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRWriter::GetDVRRingBufferWriter (
    OUT IDVRRingBufferWriter **   ppIDVRRingBufferWriter
    )
{
    if (!ppIDVRRingBufferWriter) {
        return E_POINTER ;
    }

    if (m_pDVRIOWriter) {
        m_pDVRIOWriter->AddRef();
    }

    *ppIDVRRingBufferWriter = m_pDVRIOWriter;

    return S_OK ;
}

STDMETHODIMP
CDVRWriter::CreateRecorder (
    IN  LPCWSTR     pszFilename,
    IN  DWORD       dwReserved,
    OUT IUnknown ** ppRecordingIUnknown
    )
{
    HRESULT         hr ;
    CDVRRecording * pDVRRecording ;
    IDVRRecorder *  pIDVRRecorder ;

    ASSERT (pszFilename) ;
    ASSERT (ppRecordingIUnknown) ;

    if (m_pDVRIOWriter) {
        hr = m_pDVRIOWriter -> CreateRecorder (pszFilename, dwReserved, & pIDVRRecorder) ;
        if (SUCCEEDED (hr)) {
            pDVRRecording = new CDVRRecording (pIDVRRecorder) ;
            if (pDVRRecording) {
                (* ppRecordingIUnknown) = NULL ;
                hr = pDVRRecording -> QueryInterface (IID_IUnknown, (void **) ppRecordingIUnknown) ;
            }
            else {
                hr = E_OUTOFMEMORY ;
            }

            pIDVRRecorder -> Release () ;
        }
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRWriter::Active (
    )
{
    HRESULT hr ;

    //  everything is 0-based
    ASSERT (m_pDVRIOWriter) ;
    hr = m_pDVRIOWriter -> SetFirstSampleTime (0) ;

    return hr ;
}

//  ============================================================================
//  CDVRIOWriter
//  ============================================================================

CDVRIOWriter::CDVRIOWriter (
    IN  IUnknown *          punkControlling,
    IN  CDVRPolicy *        pPolicy,
    IN  IWMProfile *        pIWMProfile,
    OUT HRESULT *           phr
    ) : CDVRWriter          (punkControlling, pIWMProfile)
{
    DWORD   dwNumBackingFiles  ;
    QWORD   qwNsBackingFileDuration ;
    WORD    wIndexStreamId ;
    QWORD   qwNsMaxStreamDelta ;
    BOOL    r ;

    ASSERT (m_pDVRIOWriter == NULL) ;   //  parent class init
    ASSERT (phr) ;
    ASSERT (m_pIWMProfile) ;            //  parent class should have snarfed this
    ASSERT (pPolicy) ;

    (* phr) = IndexStreamId (m_pIWMProfile, & wIndexStreamId) ;
    if (FAILED (* phr)) { goto cleanup ; }

    dwNumBackingFiles       = pPolicy -> Settings () -> NumBackingFiles () ;
    qwNsBackingFileDuration = pPolicy -> Settings () -> BackingFileDurationEach () ;
    qwNsMaxStreamDelta      = pPolicy -> Settings () -> MaxStreamDelta () ;

    (* phr) = DVRCreateRingBufferWriter (
                    dwNumBackingFiles,
                    qwNsBackingFileDuration,
                    m_pIWMProfile,
                    wIndexStreamId,
                    pPolicy -> Settings () -> GetDVRRegKey (),
                    NULL,                           // pwszDVRDirectory
                    & m_pDVRIOWriter
                    ) ;
    if (FAILED (* phr)) { goto cleanup ; }

    (* phr) = m_pDVRIOWriter -> SetMaxStreamDelta (qwNsMaxStreamDelta) ;
    if (FAILED (* phr)) { goto cleanup ; }

    cleanup :

    return ;
}

CDVRIOWriter::~CDVRIOWriter (
    )
{
    ReleaseAndClearDVRIOWriter_ () ;
}

HRESULT
CDVRIOWriter::Write (
    IN  WORD            wStreamNumber,
    IN  QWORD           cnsSampleTime,
    IN  QWORD           msSendTime,
    IN  QWORD           cnsSampleDuration,
    IN  DWORD           dwFlags,
    IN  INSSBuffer *    pINSSBuffer
    )
{
    HRESULT hr ;

    ASSERT (m_pDVRIOWriter) ;
    hr = m_pDVRIOWriter -> WriteSample (
            wStreamNumber,
            cnsSampleTime,
            dwFlags,
            pINSSBuffer
            ) ;

    return hr ;
}

//  ============================================================================
//  CDVRWriteManager
//  ============================================================================

CDVRWriteManager::CDVRWriteManager (
    IN  CDVRPolicy *    pPolicy
    ) : m_pDVRWriter    (NULL),
        m_pIRefClock    (NULL)
{
    //  ignore the return code here - we don't want to fail the load of
    //   the filter because our stats failed to init
    ASSERT (pPolicy) ;
    m_DVRReceiveStatsWriter.Initialize (pPolicy -> Settings () -> StatsEnabled ()) ;
}

CDVRWriteManager::~CDVRWriteManager (
    )
{
    Inactive () ;
}

HRESULT
CDVRWriteManager::Active (
    IN  CDVRWriter *        pDVRWriter,
    IN  IReferenceClock *   pIRefClock
    )
{
    if (pIRefClock == NULL) {
        //  must have a clock
        return E_FAIL ;
    }

    ASSERT (pDVRWriter) ;
    ASSERT (m_pDVRWriter == NULL) ;
    ASSERT (m_pIRefClock == NULL) ;

    m_pDVRWriter    = pDVRWriter ;
    m_pIRefClock    = pIRefClock ;

    m_pIRefClock -> AddRef () ;

    m_pDVRWriter -> Active () ;

    return S_OK ;
}

HRESULT
CDVRWriteManager::Inactive (
    )
{
    m_pDVRWriter = NULL ;
    RELEASE_AND_CLEAR (m_pIRefClock) ;

    return S_OK ;
}

HRESULT
CDVRWriteManager::OnReceive (
    IN  int                         iPinIndex,
    IN  CDVRAttributeTranslator *   pTranslator,
    IN  IMediaSample *              pIMediaSample
    )
{
    HRESULT                 hr ;
    CWMINSSBuffer3Wrapper * pINSSBuffer3Wrapper ;
    DWORD                   dwFlags ;
    BYTE *                  pbBuffer ;
    DWORD                   dwLength ;
    QWORD                   cnsSampleTime ;

    m_DVRReceiveStatsWriter.SampleIn (iPinIndex, pIMediaSample) ;

    if (m_pDVRWriter) {
        ASSERT (m_pIRefClock) ;

        pINSSBuffer3Wrapper = m_INSSBuffer3Wrappers.Get () ;
        if (pINSSBuffer3Wrapper) {

            pIMediaSample -> GetPointer (& pbBuffer) ;
            dwLength = pIMediaSample -> GetActualDataLength () ;

            hr = pINSSBuffer3Wrapper -> Init (
                    pIMediaSample,
                    pbBuffer,
                    dwLength
                    ) ;

            if (SUCCEEDED (hr)) {

                hr = pTranslator -> SetAttributesWMSDK (
                        m_pIRefClock,
                        & m_rtStartTime,
                        pIMediaSample,
                        pINSSBuffer3Wrapper,
                        & dwFlags,
                        & cnsSampleTime
                        ) ;

                if (SUCCEEDED (hr)) {
                    hr = m_pDVRWriter -> Write (
                            DShowWMSDKHelpers::PinIndexToWMStreamNumber (iPinIndex),
                            cnsSampleTime,
                            0,
                            1,
                            dwFlags,
                            pINSSBuffer3Wrapper
                            ) ;
                    m_DVRReceiveStatsWriter.SampleWritten (iPinIndex, hr) ;
                }

                pINSSBuffer3Wrapper -> Release () ;
            }
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRWriteManager::OnBeginFlush (
    IN  int iPinIndex
    )
{
    HRESULT hr ;

    if (m_pDVRWriter) {
        ASSERT (m_pIRefClock) ;
        hr = S_OK ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRWriteManager::OnEndFlush (
    IN  int iPinIndex
    )
{
    HRESULT hr ;

    if (m_pDVRWriter) {
        ASSERT (m_pIRefClock) ;
        hr = S_OK ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRWriteManager::OnEndOfStream (
    IN  int iPinIndex
    )
{
    HRESULT hr ;

    if (m_pDVRWriter) {
        ASSERT (m_pIRefClock) ;
        hr = S_OK ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\shared\dvrdsrec.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrdsrec.h

    Abstract:

        This module contains the declarations for our recording objects

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        23-Apr-2001     created

--*/

#ifndef __tsdvr__shared__dvrdsrec_h
#define __tsdvr__shared__dvrdsrec_h

class CDVRRecording :
    public CUnknown,
    public IDVRRecordControl
{
    IDVRRecorder *  m_pIDVRRecorder ;

    public :

        CDVRRecording (
            IN  IDVRRecorder *  pIDVRRecorder
            ) ;

        virtual
        ~CDVRRecording (
            ) ;

        //  ====================================================================
        //  IUnknown

        DECLARE_IUNKNOWN ;

        STDMETHODIMP
        NonDelegatingQueryInterface (REFIID, void **) ;

        //  ====================================================================
        //  IDVRRecordControl

        STDMETHODIMP
        Start (
            IN  REFERENCE_TIME  rtStart
            ) ;

        STDMETHODIMP
        Stop (
            IN  REFERENCE_TIME  rtStop
            ) ;

        STDMETHODIMP
        GetRecordingStatus (
            OUT HRESULT* phResult  /* optional */,
            OUT BOOL*    pbStarted /* optional */,
            OUT BOOL*    pbStopped /* optional */
            ) ;
} ;

#endif  //  __tsdvr__shared__dvrdsrec_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\shared\dvrdsseek.cpp ===
/*++

    Copyright (c) 2001  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        dvrdsseek.h

    Abstract:

        This module contains the IMediaSeeking-related code.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        10-Apr-2001     mgates      created

    Notes:

--*/

#include "dvrall.h"

#include "dvrprof.h"
#include "dvrdsseek.h"
#include "dvrpins.h"
#include "dvrdsread.h"

//  throughought: "current" position means "start" position
//   I've tried to name variables accordingly to remove any confusion

CDVRDShowSeekingCore::CDVRDShowSeekingCore (
    IN  CCritSec *          pFilterLock,
    IN  CBaseFilter *       pHostingFilter
    ) : m_pDVRReadManager   (NULL),
        m_guidTimeFormat    (TIME_FORMAT_MEDIA_TIME),   //  this is it, always
        m_pFilterLock       (pFilterLock),
        m_pHostingFilter    (pHostingFilter)
{
    ASSERT (m_pFilterLock) ;
    ASSERT (pHostingFilter) ;

    InitializeCriticalSection (& m_crtSeekingLock) ;
}

CDVRDShowSeekingCore::~CDVRDShowSeekingCore (
    )
{
    DeleteCriticalSection (& m_crtSeekingLock) ;
}

BOOL CDVRDShowSeekingCore::IsSeekingPin (IN CDVROutputPin * pPin)
{
    O_TRACE_ENTER_0 (TEXT("CDVRDShowSeekingCore::IsSeekingPin ()")) ;
    ASSERT (m_pDVRSourcePinManager) ;
    return m_pDVRSourcePinManager -> IsSeekingPin (pPin) ;
}

HRESULT
CDVRDShowSeekingCore::TimeToCurrentFormat_ (
    IN  REFERENCE_TIME  rt,
    OUT LONGLONG *      pll
    )
{
    ASSERT (pll) ;

    //  only support time for now
    (* pll) = rt ;

    return S_OK ;
}

HRESULT
CDVRDShowSeekingCore::CurrentFormatToTime_ (
    IN  LONGLONG            ll,
    OUT REFERENCE_TIME *    prt
    )
{
    ASSERT (prt) ;

    //  only support time for now
    (* prt) = ll ;

    return S_OK ;
}

BOOL
CDVRDShowSeekingCore::IsSeekingFormatSupported (
    IN  const GUID *    pFormat
    )
/*++
    Description:

        Called by the seeking pin in response to an IMediaSeeking format
        query.

    Parameters:

        pFormat     The following are defined in MSDN:

                        TIME_FORMAT_NONE
                        TIME_FORMAT_FRAME
                        TIME_FORMAT_SAMPLE
                        TIME_FORMAT_FIELD
                        TIME_FORMAT_BYTE
                        TIME_FORMAT_MEDIA_TIME

                    This list is not restrictive however.  MSDN states that 3rd
                    parties are encouraged to define their own GUIDs for
                    seeking granularities.

    Return Values:

        TRUE        format is supported
        FALSE       format is not supported

--*/
{
    BOOL    r ;

    TRACE_ENTER_0 (TEXT ("CDVRDShowSeekingCore::IsSeekingFormatSupported ()")) ;

    //  support only time
    if ((* pFormat) == TIME_FORMAT_MEDIA_TIME) {

        //  time-based seeking is ok
        r = TRUE ;
    }
    else {
        //  everything else is not ok
        r = FALSE ;
    }

    return r ;
}

HRESULT
CDVRDShowSeekingCore::QueryPreferredSeekingFormat (
    OUT GUID * pFormat
    )
{
    O_TRACE_ENTER_0 (TEXT("CDVRDShowSeekingCore::QueryPreferredSeekingFormat ()")) ;

    //  caller should have screened for bad parameters
    ASSERT (pFormat) ;

    (* pFormat) == TIME_FORMAT_MEDIA_TIME ;
    return S_OK ;
}

HRESULT
CDVRDShowSeekingCore::SetSeekingTimeFormat (
    IN  const GUID *    pguidTimeFormat
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRDShowSeekingCore::SetSeekingTimeFormat ()")) ;

    FilterLock_ () ;

    ASSERT (pguidTimeFormat) ;

    if (m_pHostingFilter -> IsStopped ()) {
        if (IsSeekingFormatSupported (pguidTimeFormat)) {
            //  looks ok; set it
            m_guidTimeFormat = (* pguidTimeFormat) ;
            hr = S_OK ;
        }
        else {
            //  error: not supported
            hr = E_INVALIDARG ;
        }
    }
    else {
        //  error: gotta be stopped
        hr = VFW_E_WRONG_STATE ;
    }

    FilterUnlock_ () ;

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::GetSeekingTimeFormat (
    OUT GUID *  pguidTimeFormat
    )
{
    O_TRACE_ENTER_0 (TEXT("CDVRDShowSeekingCore::GetSeekingTimeFormat ()")) ;

    ASSERT (pguidTimeFormat) ;

    (* pguidTimeFormat) = m_guidTimeFormat ;

    return S_OK ;
}

//  BUGBUG: total file duration or start -> stop duration ?????
HRESULT
CDVRDShowSeekingCore::GetFileDuration (
    OUT LONGLONG *  pllDuration
    )
{
    HRESULT     hr ;
    LONGLONG    llStartContent ;
    LONGLONG    llStopContent ;

    O_TRACE_ENTER_0 (TEXT("CDVRDShowSeekingCore::GetFileDuration ()")) ;

    ASSERT (pllDuration) ;

    hr = GetAvailableContent (& llStartContent, & llStopContent) ;
    if (SUCCEEDED (hr)) {
        ASSERT (llStopContent >= llStartContent) ;  //  can be equal
        (* pllDuration) = llStopContent - llStartContent ;
    }

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::GetAvailableContent (
    OUT LONGLONG *  pllStartContent,
    OUT LONGLONG *  pllStopContent
    )
{
    HRESULT         hr ;
    REFERENCE_TIME  rtStart ;
    REFERENCE_TIME  rtStop ;

    ASSERT (pllStartContent) ;
    ASSERT (pllStopContent) ;
    ASSERT (m_pDVRReadManager) ;

    hr = m_pDVRReadManager -> GetContentExtent (
            & rtStart,
            & rtStop
            ) ;
    if (SUCCEEDED (hr)) {
        ASSERT (rtStart <= rtStop) ;    //  can be equal

        hr = TimeToCurrentFormat_ (rtStop, pllStopContent) ;
        if (SUCCEEDED (hr)) {
            hr = TimeToCurrentFormat_ (rtStart, pllStartContent) ;
        }
    }

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::GetFileStopPosition (
    OUT LONGLONG *  pllStop
    )
{
    REFERENCE_TIME  rtStop ;
    HRESULT         hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRDShowSeekingCore::GetFileStopPosition ()")) ;

    ASSERT (pllStop) ;
    ASSERT (m_pDVRReadManager) ;

    hr = m_pDVRReadManager -> GetCurrentStop (& rtStop) ;
    if (SUCCEEDED (hr)) {
        hr = TimeToCurrentFormat_ (rtStop, pllStop) ;
    }

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::GetFileStartPosition (
    OUT LONGLONG *  pllStart
    )
{
    HRESULT         hr ;
    REFERENCE_TIME  rtStart ;

    O_TRACE_ENTER_0 (TEXT("CDVRDShowSeekingCore::GetFileStartPosition ()")) ;

    ASSERT (m_pDVRReadManager) ;
    ASSERT (pllStart) ;

    hr = m_pDVRReadManager -> GetCurrentStart (& rtStart) ;
    if (SUCCEEDED (hr)) {
        hr = TimeToCurrentFormat_ (rtStart, pllStart) ;
    }

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::SeekTo (
    IN  LONGLONG *  pllStart
    )
{
    HRESULT         hr ;
    REFERENCE_TIME  rtStart ;
    REFERENCE_TIME  rtStop ;
    LONGLONG        llStop ;

    O_TRACE_ENTER_1 (TEXT("CDVRDShowSeekingCore::SeekTo (%I64d)"), (* pllStart)) ;

    hr = SeekTo (pllStart, NULL) ;

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::SeekTo (
    IN  LONGLONG *  pllStart,
    IN  LONGLONG *  pllStop,
    IN  double      dPlaybackRate
    )
{
    HRESULT         hr ;
    REFERENCE_TIME  rtStart ;
    REFERENCE_TIME  rtStop ;

    ASSERT (pllStart) ;
    //  pllStop can be NULL

    hr = CurrentFormatToTime_ ((* pllStart), & rtStart) ;
    if (SUCCEEDED (hr)) {

        //  if specified, convert
        if (pllStop) {
            hr = CurrentFormatToTime_ ((* pllStop), & rtStop) ;
        }

        //  make the call
        if (SUCCEEDED (hr)) {
            hr = m_pDVRReadManager -> SeekTo (& rtStart, (pllStop ? & rtStop : NULL), dPlaybackRate) ;
        }
    }

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::SetFileStopPosition (
    IN  LONGLONG *  pllStop
    )
{
    HRESULT         hr ;
    REFERENCE_TIME  rtStop ;

    hr = CurrentFormatToTime_ ((* pllStop), & rtStop) ;
    if (SUCCEEDED (hr)) {
        hr = m_pDVRReadManager -> SetStop (rtStop) ;
    }

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::SetPlaybackRate (
    IN  double  dPlaybackRate
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_1 (TEXT("CDVRDShowSeekingCore::SetPlaybackRate (%2.1f)"), dPlaybackRate) ;

    hr = m_pDVRReadManager -> SetPlaybackRate (dPlaybackRate) ;

    return hr ;
}

HRESULT
CDVRDShowSeekingCore::GetPlaybackRate (
    OUT double *    pdPlaybackRate
    )
{
    ASSERT (pdPlaybackRate) ;
    (* pdPlaybackRate) = m_pDVRReadManager -> GetPlaybackRate () ;

    return S_OK ;
}

HRESULT
CDVRDShowSeekingCore::ReaderThreadGetSegmentValues (
    OUT REFERENCE_TIME *    prtSegmentStart,
    OUT REFERENCE_TIME *    prtSegmentStop,
    OUT double *            pdSegmentRate
    )
{
    HRESULT hr ;

    ASSERT (prtSegmentStart) ;
    ASSERT (prtSegmentStop) ;
    ASSERT (pdSegmentRate) ;

    //  don't grab the media seeking lock; downstream threads call into object
    //   to perform seeking operations; if the bracket (start -> stop) changes,
    //   the locking order is such that the seeking lock is grabbed, and the
    //   receiver thread is signaled SYNCHRONOUSLY to pause, the playback
    //   bracket is reset, the receiver thread resumed, and the seeking
    //   lock released; if we (receiver thread) grab the seeking lock, or
    //   rather, block on the seeking lock, with a seeking thread waiting on
    //   us to pause, we get a deadlock; so we don't grab the lock; return
    //   values are valid because they won't be reset unless receiver thread
    //   is paused.

    //  start - in the current units
    hr = m_pDVRReadManager -> GetCurrentStart (prtSegmentStart) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  stop - in the current units
    hr = m_pDVRReadManager -> GetCurrentStop (prtSegmentStop) ;
    if (FAILED (hr)) { goto cleanup ; }

    hr = GetPlaybackRate (pdSegmentRate) ;
    if (FAILED (hr)) { goto cleanup ; }

    cleanup :

    return hr ;
}

//  ----------------------------------------------------------------------------
//  ----------------------------------------------------------------------------
//  ----------------------------------------------------------------------------

CDVRDIMediaSeeking::CDVRDIMediaSeeking (
    IN  CDVROutputPin *         pOutputPin,
    IN  CDVRDShowSeekingCore *  pSeekingCore
    ) : m_pOutputPin            (pOutputPin),
        m_guidSeekingFormat     (GUID_NULL),
        m_pSeekingCore          (pSeekingCore)
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRDIMediaSeeking")) ;

    ASSERT (m_pOutputPin) ;
    ASSERT (m_pSeekingCore) ;
}

CDVRDIMediaSeeking::~CDVRDIMediaSeeking (
    )
{
    TRACE_DESTRUCTOR (TEXT ("CDVRDIMediaSeeking")) ;
}

//  ----------------------------------------------------------------------------
//  IUnknown interface methods - delegate always

STDMETHODIMP
CDVRDIMediaSeeking::QueryInterface (
    REFIID riid,
    void ** ppv
    )
{
    return m_pOutputPin -> QueryInterface (riid, ppv) ;
}

STDMETHODIMP_ (ULONG)
CDVRDIMediaSeeking::AddRef (
    )
{
    return m_pOutputPin -> AddRef () ;
}

STDMETHODIMP_ (ULONG)
CDVRDIMediaSeeking::Release (
    )
{
    return m_pOutputPin -> Release () ;
}

//  ----------------------------------------------------------------------------
//  IMediaSeeking interface methods

//  Returns the capability flags; S_OK if successful
STDMETHODIMP
CDVRDIMediaSeeking::GetCapabilities (
    OUT DWORD * pCapabilities
    )
{
    O_TRACE_ENTER_0 (TEXT("CDVRDIMediaSeeking::GetCapabilities ()")) ;

    if (!pCapabilities) {
        return E_POINTER ;
    }

    return m_pSeekingCore -> GetSeekingCapabilities (
                                pCapabilities
                                ) ;
}

//  And's the capabilities flag with the capabilities requested.
//  Returns S_OK if all are present, S_FALSE if some are present,
//  E_FAIL if none.
//  * pCababilities is always updated with the result of the
//  'and'ing and can be checked in the case of an S_FALSE return
//  code.
STDMETHODIMP
CDVRDIMediaSeeking::CheckCapabilities (
    IN OUT  DWORD * pCapabilities
    )
{
    HRESULT hr ;
    DWORD   dwCapabilities ;

    O_TRACE_ENTER_0 (TEXT("CDVRDIMediaSeeking::CheckCapabilities ()")) ;

    if (!pCapabilities) {
        return E_POINTER ;
    }

    hr = GetCapabilities (& dwCapabilities) ;
    if (SUCCEEDED(hr))
    {
        dwCapabilities &= (* pCapabilities) ;
        hr =  dwCapabilities ? ( dwCapabilities == (* pCapabilities) ? S_OK : S_FALSE ) : E_FAIL ;
        (* pCapabilities) = dwCapabilities ;
    }
    else {
        (* pCapabilities) = 0 ;
    }

    return hr;
}

//  returns S_OK if mode is supported, S_FALSE otherwise
STDMETHODIMP
CDVRDIMediaSeeking::IsFormatSupported (
    IN  const GUID *    pFormat
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRDIMediaSeeking::IsFormatSupported ()")) ;

    if (!pFormat) {
        return E_POINTER ;
    }

    //
    //  Designated seeking pin will be video, but we have 1 pin that is the
    //   designated seeking pin; all others don't do much
    //
    //  However, we need to support TIME_FORMAT_MEDIA_TIME or the graph
    //   code gets confused and starts using IMediaPosition
    if (m_pSeekingCore -> IsSeekingPin (m_pOutputPin)) {
        hr = (m_pSeekingCore -> IsSeekingFormatSupported (pFormat) ? S_OK : S_FALSE) ;
    }
    else {
        hr = (pFormat == NULL || (* pFormat) == TIME_FORMAT_MEDIA_TIME ? S_OK : S_FALSE) ;
    }

    return hr ;
}

//  S_OK if successful
//  E_NOTIMPL, E_POINTER if unsuccessful
STDMETHODIMP
CDVRDIMediaSeeking::QueryPreferredFormat (
    OUT GUID *  pFormat
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRDIMediaSeeking::QueryPreferredFormat ()")) ;

    if (!pFormat) {
        return E_POINTER ;
    }

    //  comment copied .. :-)
    /*  Don't care - they're all just as bad as one another */

    if (m_pSeekingCore -> IsSeekingPin (m_pOutputPin)) {
        hr = m_pSeekingCore -> QueryPreferredSeekingFormat (pFormat) ;
    }
    else {
        //  not the seeking pin, then we don't support anything
        (* pFormat) = TIME_FORMAT_NONE ;
        hr = S_OK ;
    }

    return hr ;
}

//  S_OK if successful
STDMETHODIMP
CDVRDIMediaSeeking::GetTimeFormat (
    OUT GUID *  pFormat
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRDIMediaSeeking::GetTimeFormat ()")) ;

    if (!pFormat) {
        return E_POINTER ;
    }

    if (m_pSeekingCore -> IsSeekingPin (m_pOutputPin)) {
        hr = m_pSeekingCore -> GetSeekingTimeFormat (pFormat) ;
    }
    else {
        (* pFormat) = TIME_FORMAT_NONE ;
        hr = S_OK ;
    }

    return hr ;
}

//  Returns S_OK if *pFormat is the current time format, otherwise
//  S_FALSE
//  This may be used instead of the above and will save the copying
//  of the GUID
STDMETHODIMP
CDVRDIMediaSeeking::IsUsingTimeFormat (
    IN const GUID * pFormat
    )
{
    HRESULT hr ;
    GUID    guidFormat ;

    O_TRACE_ENTER_0 (TEXT("CDVRDIMediaSeeking::IsUsingTimeFormat ()")) ;

    if (!pFormat) {
        return E_POINTER ;
    }

    if (m_pSeekingCore -> IsSeekingPin (m_pOutputPin)) {
        hr = m_pSeekingCore -> GetSeekingTimeFormat (& guidFormat) ;
    }
    else {
        guidFormat = TIME_FORMAT_NONE ;
        hr = S_OK ;
    }

    if (SUCCEEDED (hr)) {
        hr = (guidFormat == (* pFormat) ? S_OK : S_FALSE) ;
    }

    return hr ;
}

// (may return VFE_E_WRONG_STATE if graph is stopped)
STDMETHODIMP
CDVRDIMediaSeeking::SetTimeFormat (
    IN const GUID * pFormat
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRDIMediaSeeking::SetTimeFormat ()")) ;

    if (!pFormat) {
        return E_POINTER ;
    }

    //  first make sure we're the seeking pin
    if (m_pSeekingCore -> IsSeekingPin (m_pOutputPin)) {
        hr = m_pSeekingCore -> SetSeekingTimeFormat (pFormat) ;
    }
    else {
        //  ya sure.. no one cares what this is
        hr = ((* pFormat) == TIME_FORMAT_NONE ? S_OK : E_FAIL) ;
    }

    return hr ;
}

// return current properties
STDMETHODIMP
CDVRDIMediaSeeking::GetDuration (
    OUT LONGLONG *  pDuration
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRDIMediaSeeking::GetDuration ()")) ;

    if (!pDuration) {
        return E_POINTER ;
    }

    SeekingLock_ () ;

    hr = m_pSeekingCore -> GetFileDuration (pDuration) ;

    SeekingUnlock_ () ;

    return hr ;
}

STDMETHODIMP
CDVRDIMediaSeeking::GetStopPosition (
    OUT LONGLONG *  pStop
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRDIMediaSeeking::GetStopPosition ()")) ;

    if (!pStop) {
        return E_POINTER ;
    }

    SeekingLock_ () ;

    hr = m_pSeekingCore -> GetFileStopPosition (pStop) ;

    SeekingUnlock_ () ;

    return hr ;
}

STDMETHODIMP
CDVRDIMediaSeeking::GetCurrentPosition (
    OUT LONGLONG *  pStart
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRDIMediaSeeking::GetCurrentPosition ()")) ;

    if (!pStart) {
        return E_POINTER ;
    }

    SeekingLock_ () ;

    hr = m_pSeekingCore -> GetFileStartPosition (pStart) ;

    SeekingUnlock_ () ;

    return hr ;
}

//  Convert time from one format to another.
//  We must be able to convert between all of the formats that we
//  say we support.  (However, we can use intermediate formats
//  (e.g. MEDIA_TIME).)
//  If a pointer to a format is null, it implies the currently selected format.
STDMETHODIMP
CDVRDIMediaSeeking::ConvertTimeFormat(
    OUT LONGLONG *      pTarget,
    IN  const GUID *    pTargetFormat,
    IN  LONGLONG        Source,
    IN  const GUID *    pSourceFormat
    )
{
    O_TRACE_ENTER_0 (TEXT("CDVRDIMediaSeeking::ConvertTimeFormat ()")) ;

    return E_NOTIMPL ;
}

// Set Start and end positions in one operation
// Either pointer may be null, implying no change
STDMETHODIMP
CDVRDIMediaSeeking::SetPositions (
    IN OUT  LONGLONG *  pStart,
    IN      DWORD       dwStartFlags,
    IN OUT  LONGLONG *  pStop,
    IN      DWORD       dwStopFlags
    )
{
    HRESULT     hr ;
    LONGLONG    llStart ;
    LONGLONG    llStop ;
    DWORD       dwPosStartBits ;
    DWORD       dwPosStopBits ;
    BOOL        r ;

    O_TRACE_ENTER_0 (TEXT("CDVRDIMediaSeeking::SetPositions ()")) ;

    //  must be the seeking pin
    if (!m_pSeekingCore -> IsSeekingPin (m_pOutputPin)) {
        return E_UNEXPECTED ;
    }

    //  ------------------------------------------------------------------------
    //  obtain some preliminary values we'll use during the course of this
    //   call

    //  the stop position
    hr = GetStopPosition (& llStop) ;
    if (FAILED (hr)) {
        return hr ;
    }

    //  the Start position as well
    hr = GetCurrentPosition (& llStart) ;
    if (FAILED (hr)) {
        return hr ;
    }

    //  ------------------------------------------------------------------------
    //  process "Start"

    dwPosStartBits = dwStartFlags & AM_SEEKING_PositioningBitsMask ;

    //  validate the pointer
    if (dwPosStartBits != AM_SEEKING_NoPositioning &&
        !pStart) {
        return E_POINTER ;
    }

    switch (dwPosStartBits) {
        case AM_SEEKING_NoPositioning :
            hr = S_OK ;
            break ;

        case AM_SEEKING_AbsolutePositioning :
            //  make sure it doesn't exceed the duration
            llStart = (* pStart) ;
            hr = S_OK ;
            break ;

        case AM_SEEKING_RelativePositioning :
            //  pStart is relative to Start position
            llStart += (* pStart) ;
            hr = S_OK ;
            break ;

        case AM_SEEKING_IncrementalPositioning :
            //  flag only applies to stop position; fall through

        default :
            hr = E_INVALIDARG ;
            break ;
    } ;

    if (FAILED (hr)) {
        return hr ;
    }

    //  ------------------------------------------------------------------------
    //  process "stop"

    dwPosStopBits = dwStopFlags & AM_SEEKING_PositioningBitsMask ;

    //  validate the pointer
    if (dwPosStopBits != AM_SEEKING_NoPositioning &&
        !pStop) {
        return E_POINTER ;
    }

    switch (dwPosStopBits) {
        case AM_SEEKING_NoPositioning :
            if (dwPosStartBits != AM_SEEKING_NoPositioning) {
                hr = S_OK ;
            }
            else {
                //  huh ? not sure what the purpose of this call is.. nothing
                //   is valid
                hr = E_INVALIDARG ;
            }

            break ;

        case AM_SEEKING_AbsolutePositioning :
            //  since we can be dynamic, stop can exceed the current duration
            hr = S_OK ;
            break ;

        case AM_SEEKING_RelativePositioning :
            //  pStop is relative to Startly used stop position
            llStop += (* pStop) ;
            hr = S_OK ;
            break ;

        case AM_SEEKING_IncrementalPositioning :
            //  stop is relative to pStart
            if (dwPosStartBits != AM_SEEKING_NoPositioning &&
                pStart) {

                llStop = (* pStart) + (* pStop) ;
                hr = S_OK ;
            }
            else {
                hr = E_INVALIDARG ;
            }

            break ;

        default :
            hr = E_INVALIDARG ;
            break ;
    } ;

    if (FAILED (hr)) {
        return hr ;
    }

    //  ------------------------------------------------------------------------
    //  ok, llStart and llStop now are offsets that bracket our desired
    //   playback

    SeekingLock_ () ;

    //  make sure llStart and llStop make sense
    r = (dwPosStartBits != AM_SEEKING_NoPositioning) && (llStart < 0 || (dwPosStopBits != AM_SEEKING_NoPositioning) && llStart > llStop) ;
    if (!r) {
        if (dwPosStartBits != AM_SEEKING_NoPositioning) {
            //  we have a Start value; may or may not have a stop value
            if (dwPosStopBits == AM_SEEKING_NoPositioning) {
                //  not stop value; seek just to Start

                TRACE_2 (LOG_AREA_SEEKING, 1,
                    TEXT ("IMediaSeeking::SetPosition(); llStart = %I64d (%d sec)"),
                    llStart, DShowTimeToSeconds (llStart)) ;

                hr = m_pSeekingCore -> SeekTo (& llStart) ;
            }
            else {
                //  stop value is present; seek to a Start and specify a stop

                TRACE_4 (LOG_AREA_SEEKING, 1,
                    TEXT ("IMediaSeeking::SetPosition(); llStart = %I64d (%d sec); llStop = %I64d (%d sec)"),
                    llStart, DShowTimeToSeconds (llStart), llStop, DShowTimeToSeconds (llStop)) ;

                hr = m_pSeekingCore -> SeekTo (& llStart, & llStop) ;
            }
        }
        else {
            //  set only the end point
            hr = m_pSeekingCore -> SetFileStopPosition (& llStop) ;
        }
    }
    else {
        //  specified parameters that don't make sense
        hr = E_INVALIDARG ;
    }

    //  ------------------------------------------------------------------------
    //  set outgoing, if desired
    //

    if (SUCCEEDED (hr) &&
        (dwStartFlags & AM_SEEKING_ReturnTime)) {

        ASSERT (pStart) ;
        hr = GetCurrentPosition (pStart) ;

        TRACE_2 (LOG_AREA_SEEKING, 1,
            TEXT ("IMediaSeeking::SetPosition(); returning llStart = %I64d (%d sec)"),
            (* pStart), DShowTimeToSeconds (* pStart)) ;
    }

    if (SUCCEEDED (hr) &&
        (dwStopFlags & AM_SEEKING_ReturnTime)) {

        ASSERT (pStop) ;
        hr = GetStopPosition (pStop) ;

        TRACE_2 (LOG_AREA_SEEKING, 1,
            TEXT ("IMediaSeeking::SetPosition(); returning llStop = %I64d (%d sec)"),
            (* pStop), DShowTimeToSeconds (* pStop)) ;
    }

    SeekingUnlock_ () ;

    return hr ;
}

// Get StartPosition & StopTime
// Either pointer may be null, implying not interested
STDMETHODIMP
CDVRDIMediaSeeking::GetPositions (
    OUT LONGLONG *  pStart,
    OUT LONGLONG *  pStop
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRDIMediaSeeking::GetPositions ()")) ;

    hr = S_OK ;

    SeekingLock_ () ;

    if (pStart) {
        hr = GetCurrentPosition (pStart) ;
    }

    if (pStop &&
        SUCCEEDED (hr)) {
        hr = GetStopPosition (pStop) ;
    }

    SeekingUnlock_ () ;

    return hr ;
}

//  Get earliest / latest times to which we can currently seek
//  "efficiently".  This method is intended to help with graphs
//  where the source filter has a very high latency.  Seeking
//  within the returned limits should just result in a re-pushing
//  of already cached data.  Seeking beyond these limits may result
//  in extended delays while the data is fetched (e.g. across a
//  slow network).
//  (NULL pointer is OK, means caller isn't interested.)
STDMETHODIMP
CDVRDIMediaSeeking::GetAvailable (
    OUT LONGLONG *  pEarliest,
    OUT LONGLONG *  pLatest
    )
{
    HRESULT     hr ;
    LONGLONG    llContentStart ;
    LONGLONG    llContentStop ;

    O_TRACE_ENTER_0 (TEXT("CDVRDIMediaSeeking::GetAvailable ()")) ;

    hr = S_OK ;

    SeekingLock_ () ;

    hr = m_pSeekingCore -> GetAvailableContent (& llContentStart, & llContentStop) ;
    if (SUCCEEDED (hr)) {
        if (pEarliest) {
            (* pEarliest) = llContentStart ;
        }

        if (pLatest) {
            (* pLatest) = llContentStop ;
        }
    }

    SeekingUnlock_ () ;

    return hr ;
}

// Rate stuff
STDMETHODIMP
CDVRDIMediaSeeking::SetRate (
    IN  double  dRate
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRDIMediaSeeking::SetRate ()")) ;

    //  validate the rate request
    if (dRate <= 0.0) {
        return E_INVALIDARG ;
    }

    SeekingLock_ () ;

    hr = m_pSeekingCore -> SetPlaybackRate (dRate) ;

    SeekingUnlock_ () ;

    return hr ;
}

STDMETHODIMP
CDVRDIMediaSeeking::GetRate (
    OUT double *    pdRate
    )
{
    HRESULT hr ;

    O_TRACE_ENTER_0 (TEXT("CDVRDIMediaSeeking::GetRate ()")) ;

    if (!pdRate) {
        return E_POINTER ;
    }

    SeekingLock_ () ;

    hr = m_pSeekingCore -> GetPlaybackRate (pdRate) ;

    SeekingUnlock_ () ;

    return hr ;
}

// Preroll
STDMETHODIMP
CDVRDIMediaSeeking::GetPreroll (
    OUT LONGLONG *  pllPreroll
    )
{
    O_TRACE_ENTER_0 (TEXT("CDVRDIMediaSeeking::GetPreroll ()")) ;

    if (!pllPreroll) {
        return E_POINTER ;
    }

    return E_NOTIMPL ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\shared\dvrpins.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrpins.cpp

    Abstract:

        This module contains the DVR filters' pin-related code.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#include "dvrall.h"

#include "dvrprof.h"
#include "dvrdsseek.h"
#include "dvrpins.h"
#include "dvrdsread.h"

#pragma warning (disable:4355)

//  ============================================================================
//  ============================================================================

static
TCHAR *
CreatePinName (
    IN  int             iPinIndex,
    IN  PIN_DIRECTION   PinDirection,
    IN  int             iBufferLen,
    OUT TCHAR *         pchBuffer
    )
{
    int i ;

    ASSERT (pchBuffer) ;
    ASSERT (iBufferLen >= 16) ;

    if (PinDirection == PINDIR_INPUT) {
        //  input
        i = _sntprintf (
                pchBuffer,
                iBufferLen,
                TEXT ("DVR In - %d"),
                iPinIndex
                ) ;
    }
    else {
        //  output
        i = _sntprintf (
                pchBuffer,
                iBufferLen,
                TEXT ("DVR Out - %d"),
                iPinIndex
                ) ;
    }

    //  make sure it's capped off
    pchBuffer [i] = TEXT ('\0') ;

    return pchBuffer ;
}

TCHAR *
CreateOutputPinName (
    IN  int     iPinIndex,
    IN  int     iBufferLen,
    OUT TCHAR * pchBuffer
    )
{
    return CreatePinName (
                iPinIndex,
                PINDIR_OUTPUT,
                iBufferLen,
                pchBuffer
                ) ;
}

TCHAR *
CreateInputPinName (
    IN  int     iPinIndex,
    IN  int     iBufferLen,
    OUT TCHAR * pchBuffer
    )
{
    return CreatePinName (
                iPinIndex,
                PINDIR_INPUT,
                iBufferLen,
                pchBuffer
                ) ;
}

//  ============================================================================
//  ============================================================================

HRESULT
CDVRPin::SetPinMediaType (
    IN  AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_0 (TEXT ("CDVRPin::SetPinMediaType ()")) ;

    ASSERT (pmt) ;

    FreeMediaType (m_mtDVRPin) ;
    m_mtDVRPin.ResetFormatBuffer () ;

    m_pFilterLock -> Lock () ;

    CopyMediaType (& m_mtDVRPin, pmt) ;
    hr = S_OK ;

    m_pFilterLock -> Unlock () ;

    return hr ;
}

HRESULT
CDVRPin::GetPinMediaType (
    OUT AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_0 (TEXT ("CDVRPin::GetPinMediaType ()")) ;

    ASSERT (pmt) ;

    m_pFilterLock -> Lock () ;

    hr = CopyMediaType (pmt, & m_mtDVRPin) ;

    m_pFilterLock -> Unlock () ;

    return hr ;
}

HRESULT
CDVRPin::GetPinMediaTypeCopy (
    OUT CMediaType **   ppmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_0 (TEXT ("CDVRPin::GetPinMediaType ()")) ;

    ASSERT (ppmt) ;

    (* ppmt) = new CMediaType ;
    if (!(* ppmt)) {
        return E_OUTOFMEMORY ;
    }

    m_pFilterLock -> Lock () ;

    hr = CopyMediaType ((* ppmt), & m_mtDVRPin) ;

    m_pFilterLock -> Unlock () ;

    if (FAILED (hr)) {
        DELETE_RESET (* ppmt) ;
    }

    return hr ;
}

//  ============================================================================
//  ============================================================================

CDVRInputPin::CDVRInputPin (
    IN  TCHAR *                     pszPinName,
    IN  CBaseFilter *               pOwningFilter,
    IN  CIDVRPinConnectionEvents *  pIPinConnectEvent,
    IN  CIDVRDShowStream *          pIDShowStream,
    IN  CCritSec *                  pFilterLock,
    IN  CCritSec *                  pRecvLock,
    IN  CDVRPolicy *                pPolicy,
    OUT HRESULT *                   phr
    ) : CBaseInputPin       (NAME ("CDVRInputPin"),
                             pOwningFilter,
                             pFilterLock,
                             phr,
                             pszPinName
                             ),
        CDVRPin             (pFilterLock,
                             pPolicy
                             ),
        m_pIPinConnectEvent (pIPinConnectEvent),
        m_pIDShowStream     (pIDShowStream),
        m_pRecvLock         (pRecvLock)
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRInputPin")) ;

    ASSERT (m_pIPinConnectEvent) ;
    ASSERT (m_pIDShowStream) ;

    if (FAILED (* phr)) {
        goto cleanup ;
    }

    cleanup :

    return ;
}

CDVRInputPin::~CDVRInputPin (
    )
{
    TRACE_DESTRUCTOR (TEXT ("CDVRInputPin")) ;
}

HRESULT
CDVRInputPin::GetMediaType (
    IN  int             iPosition,
    OUT CMediaType *    pmt
    )
{
    HRESULT hr ;

    if (!NeverConnected_ () &&
        iPosition == 0) {

        hr = GetPinMediaType (pmt) ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVRInputPin::CheckMediaType (
    IN  const CMediaType *  pmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_0 (TEXT ("CDVRInputPin::CheckMediaType ()")) ;

    if (NeverConnected_ ()) {
        //  accept all - once we are connected we take the media type given
        //   to us, and we're subsequently rigid to that media type
        hr = S_OK ;
    }
    else if (IsStopped ()) {
        //  we're stopped - accept iff it's exactly what we are now
        hr = (IsEqual_ (pmt) ? S_OK : S_FALSE) ;
    }
    else {
        //  we're running - this is a dynamic format change - punt
        //    pass/fail
        hr = m_pIPinConnectEvent -> OnQueryAccept (pmt) ;
    }

    return hr ;
}

HRESULT
CDVRInputPin::CompleteConnect (
    IN  IPin *  pReceivePin
    )
{
    HRESULT hr ;
    int     i ;

    TRACE_ENTER_0 (TEXT ("CDVRInputPin::CompleteConnect ()")) ;

    hr = CBaseInputPin::CompleteConnect (pReceivePin) ;
    if (SUCCEEDED (hr)) {

        //  if we've never been connected, callback and if that call
        //   succeeds, weld in our media type
        if (NeverConnected_ ()) {
            ASSERT (m_pIPinConnectEvent) ;
            hr = m_pIPinConnectEvent -> OnInputCompleteConnect (
                    GetBankStoreIndex (),
                    & m_mt
                    ) ;

            if (SUCCEEDED (hr)) {
                SetPinMediaType (& m_mt) ;
                m_pTranslator = DShowWMSDKHelpers::GetAttributeTranslator (
                                    & m_mt,
                                    m_pPolicy,
                                    GetBankStoreIndex ()
                                    ) ;
            }
        }
    }

    return hr ;
}

STDMETHODIMP
CDVRInputPin::QueryAccept (
    IN  const AM_MEDIA_TYPE *   pmt
    )
{
    return m_pIPinConnectEvent -> OnQueryAccept (pmt) ;
}

STDMETHODIMP
CDVRInputPin::Receive (
    IN  IMediaSample *  pIMS
    )
{
    HRESULT hr ;

    LockRecv_ () ;

    hr = CBaseInputPin::Receive (pIMS) ;
    if (SUCCEEDED (hr) &&
        m_pIDShowStream) {

        hr = m_pIDShowStream -> OnReceive (
                GetBankStoreIndex (),
                m_pTranslator,
                pIMS
                ) ;
    }

    UnlockRecv_ () ;

    return hr ;
}

HRESULT
CDVRInputPin::Active (
    IN  BOOL    fInlineProps
    )
{
    HRESULT hr ;

    LockRecv_ () ;

    if (IsConnected ()) {
        hr = CBaseInputPin::Active () ;
    }
    else {
        hr = S_OK ;
    }

    m_pTranslator -> InlineDShowAttributes (fInlineProps) ;

    UnlockRecv_ () ;

    return hr ;
}

//  ============================================================================
//  ============================================================================

CDVROutputPin::CDVROutputPin (
    IN  CDVRPolicy *            pPolicy,
    IN  TCHAR *                 pszPinName,
    IN  CBaseFilter *           pOwningFilter,
    IN  CCritSec *              pFilterLock,
    IN  CDVRDShowSeekingCore *  pSeekingCore,
    IN  CDVRSendStatsWriter *   pDVRSendStatsWriter,
    IN  CDVRSourcePinManager *  pOwningPinBank,
    OUT HRESULT *               phr
    ) : CBaseOutputPin          (NAME ("CDVROutputPin"),
                                 pOwningFilter,
                                 pFilterLock,
                                 phr,
                                 pszPinName
                                 ),
        CDVRPin                 (pFilterLock,
                                 pPolicy
                                 ),
        m_pOutputQueue          (NULL),
        m_IMediaSeeking         (this,
                                 pSeekingCore
                                 ),
        m_fTimestampedMedia     (FALSE),
        m_DVRSegOutputPinState  (STATE_SEG_NEW_SEGMENT),
        m_DVRMediaOutputPinState (STATE_MEDIA_COMPATIBLE),
        m_pSeekingCore          (pSeekingCore),
        m_pOwningPinBank        (pOwningPinBank)
{
    TRACE_CONSTRUCTOR (TEXT ("CDVROutputPin")) ;

    ASSERT (m_pSeekingCore) ;
    ASSERT (m_pPolicy) ;
    ASSERT (m_pOwningPinBank) ;

    if (FAILED (* phr)) {
        goto cleanup ;
    }

    m_cbBuffer  = (long) m_pPolicy -> Settings () -> AllocatorGetBufferSize () ;
    m_cBuffers  = (long) m_pPolicy -> Settings () -> AllocatorGetBufferCount () ;
    m_cbAlign   = (long) m_pPolicy -> Settings () -> AllocatorGetAlignVal () ;
    m_cbPrefix  = (long) m_pPolicy -> Settings () -> AllocatorGetPrefixVal () ;

    if (m_cbBuffer  <= 0 ||     //  buffer size
        m_cBuffers  <= 0 ||     //  number of buffers in pool
        m_cbAlign   <= 0 ||     //  alignment must be >= 1
        m_cbPrefix  < 0) {      //  prefix

        (* phr) = E_INVALIDARG ;
        goto cleanup ;
    }

    m_MSWrappers.SetStatsWriter (pDVRSendStatsWriter) ;

    (* phr) = S_OK ;

    cleanup :

    return ;
}

CDVROutputPin::~CDVROutputPin (
    )
{
    TRACE_DESTRUCTOR (TEXT ("CDVROutputPin")) ;
    delete m_pTranslator ;
}

STDMETHODIMP
CDVROutputPin::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    if (riid == IID_IMemAllocator) {

        return GetInterface (
                    (IMemAllocator *) this,
                    ppv
                    ) ;
    }
    else if (riid == IID_IMediaSeeking) {

        return GetInterface (
                    (IMediaSeeking *) & m_IMediaSeeking,
                    ppv
                    ) ;
    }
    else if (riid == IID_IAMPushSource              &&
             m_pOwningPinBank -> IsLiveSource ()    &&
             m_pPolicy -> Settings () -> CanImplementIReferenceClock ()) {

        return GetInterface (
                    (IAMPushSource *) this,
                    ppv
                    ) ;
    }

    return CBaseOutputPin::NonDelegatingQueryInterface (riid, ppv) ;
}

HRESULT
CDVROutputPin::DecideAllocator (
    IN  IMemInputPin *      pPin,
    IN  IMemAllocator **    ppAlloc
    )
{
    HRESULT                 hr ;
    ALLOCATOR_PROPERTIES    AllocProp ;

    ASSERT (pPin) ;
    ASSERT (ppAlloc) ;

    (* ppAlloc) = this ;
    (* ppAlloc) -> AddRef () ;

    ZeroMemory (& AllocProp, sizeof AllocProp) ;
    hr = pPin -> GetAllocatorRequirements (& AllocProp) ;
    if (SUCCEEDED (hr) ||
        hr == E_NOTIMPL) {

        hr = DecideBufferSize ((* ppAlloc), & AllocProp) ;
        if (SUCCEEDED (hr)) {
            hr = pPin -> NotifyAllocator ((* ppAlloc), TRUE) ;
        }
    }

    return hr ;
}

HRESULT
CDVROutputPin::DecideBufferSize (
    IN  IMemAllocator *         pAlloc,
    IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
    )
{
    ALLOCATOR_PROPERTIES    propActual = {0} ;

    TRACE_ENTER_0 (TEXT ("CDVROutputPin::DecideBufferSize ()")) ;

    ppropInputRequest -> cbBuffer   = m_cbBuffer ;
    ppropInputRequest -> cBuffers   = m_cBuffers ;
    ppropInputRequest -> cbAlign    = m_cbAlign ;
    ppropInputRequest -> cbPrefix   = m_cbPrefix ;

    return pAlloc -> SetProperties (ppropInputRequest, & propActual) ;
}

HRESULT
CDVROutputPin::GetMediaType (
    IN  int             iPosition,
    OUT CMediaType *    pmt
    )
{
    HRESULT hr ;

    if (!NeverConnected_ () &&
        iPosition == 0) {

        hr = GetPinMediaType (pmt) ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CDVROutputPin::CheckMediaType (
    IN  const CMediaType *  pmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_0 (TEXT ("CDVROutputPin::CheckMediaType ()")) ;

    LockFilter_ () ;

    hr = ((* GetMediaType_ ()) == (* pmt) ? S_OK : S_FALSE) ;

    UnlockFilter_ () ;

    return hr ;
}

HRESULT
CDVROutputPin::SendSample (
    IN  IMediaSample2 * pIMS2,
    IN  AM_MEDIA_TYPE * pmtNew
    )
{
    HRESULT                 hr ;
    REFERENCE_TIME          rtStart ;
    REFERENCE_TIME          rtStop ;
    double                  dRate ;

    ASSERT (pIMS2) ;

    LockFilter_ () ;

    if (m_pOutputQueue) {

        if (pmtNew) {
            //  dynamic format change - try first ..
            ASSERT (GetConnected ()) ;
            hr = GetConnected () -> QueryAccept (pmtNew) ;
            if (hr == S_OK) {
                m_DVRMediaOutputPinState = STATE_MEDIA_COMPATIBLE ;
            }
            else {
                m_DVRMediaOutputPinState = STATE_MEDIA_INCOMPATIBLE ;
            }
        }

        if (m_DVRMediaOutputPinState == STATE_MEDIA_COMPATIBLE) {

            //  we're a small state machine - either at the start of a new segment
            //    (STATE_SEG_NEW_SEGMENT) or sending away inside a segment (STATE_SEG_IN_
            //    SEGMENT); if we're just starting a new segment, there are some
            //    actions we must take
            switch (m_DVRSegOutputPinState) {

                case STATE_SEG_NEW_SEGMENT :
                    //
                    //  if we're at the start of a new segment, different media
                    //   types do different things:
                    //   1. timestamped media: a segment must begin with a
                    //       timestamped media sample; in the case of mpeg-2 video
                    //       not all samples are timestamped, so we may/may not
                    //       proceed if we're starting a new segment, depending
                    //       on whether or not the sample is timestamped
                    //

                    if (m_fTimestampedMedia) {
                        hr = pIMS2 -> GetTime (& rtStart, & rtStop) ;
                        if (hr == VFW_E_SAMPLE_TIME_NOT_SET) {
                            //  media is timestamped, but there is no timestamp on
                            //   this media sample; bail
                            break ;
                        }

                        //  stop time may not have been set - don't want to affect
                        //   this operation because of that; we only care that the
                        //   start is set
                        hr = S_OK ;

                        //
                        //  don't care about the rtStart & rtStop values.. though
                        //   they ought to mesh with the segment start & stop
                        //   really
                        //
                    }

                    //  retrieve the segment parameters
                    hr = m_pSeekingCore -> ReaderThreadGetSegmentValues (
                            & rtStart,
                            & rtStop,
                            & dRate
                            ) ;
                    if (SUCCEEDED (hr)) {
                        //  ok, we have the values; pass them down
                        m_pOutputQueue -> NewSegment (
                            rtStart,
                            rtStop,
                            dRate
                            ) ;

                        TRACE_4 (LOG_AREA_SEEKING, 1,
                            TEXT ("pin [%d] NewSegment notification : rtStart = %d sec; rtStop = %d sec; rate = %2.1f"),
                            GetBankStoreIndex (), DShowTimeToSeconds (rtStart), DShowTimeToSeconds (rtStop), dRate) ;
                    }
                    else {
                        //  failed to retrieve the parameters; cannot continue
                        break ;
                    }

                    //
                    //  either the media sample has a timestamp, or the media is
                    //   not timestamped; introduce a discontinuity and try to send
                    //   by falling through; state is updated if send operation is
                    //   successful
                    //

                    pIMS2 -> SetDiscontinuity (TRUE) ;

                    //
                    //  fall through
                    //

                case STATE_SEG_IN_SEGMENT :

                    //
                    //  COutputQueue Release's the media sample's refcount after this
                    //  call completes, so we make sure that we keep 1 count across the
                    //  call
                    //
                    pIMS2 -> AddRef () ;

                    hr = m_pOutputQueue -> Receive (pIMS2) ;

                    //  COutputQueue does not return FAILED HRESULTs in the case of a failure
                    hr = (hr == S_OK ? S_OK : E_FAIL) ;

                    //
                    //  if we succeeded, we're always considered to be IN_SEGMENT;
                    //    if we failed, we were in whatever state we were in before
                    //    the call
                    m_DVRSegOutputPinState = (SUCCEEDED (hr) ? STATE_SEG_IN_SEGMENT : m_DVRSegOutputPinState) ;
            }
        }
        else {
            //  incompatible media type -- drop it
            hr = S_OK ;
        }
    }
    else {
        hr = VFW_E_NOT_CONNECTED ;
    }

    UnlockFilter_ () ;

    return hr ;
}

HRESULT
CDVROutputPin::Active (
    )
{
    HRESULT hr ;

    if (!IsConnected ()) {
        return S_OK ;
    }

    hr = CBaseOutputPin::Active () ;
    if (SUCCEEDED (hr)) {
        ASSERT (m_pOutputQueue == NULL) ;
        ASSERT (IsConnected ()) ;

        m_pOutputQueue = new COutputQueue (
                                GetConnected (),        //  input pin
                                & hr,                   //  retval
                                FALSE,                  //  auto detect
                                TRUE,                   //  send directly
                                1,                      //  batch size
                                FALSE,                  //  exact batch
                                1                       //  queue length
                                ) ;

        if (m_pOutputQueue &&
            SUCCEEDED (hr)) {

            m_DVRMediaOutputPinState = STATE_MEDIA_COMPATIBLE ;

            m_MSWrappers.SetFlowId (GetBankStoreIndex ()) ;
        }
        else {
            hr = (m_pOutputQueue ? hr : E_OUTOFMEMORY) ;
            DELETE_RESET (m_pOutputQueue) ;
        }
    }

    return hr ;
}

HRESULT
CDVROutputPin::Inactive (
    )
{
    HRESULT hr ;

    if (!IsConnected ()) {
        return S_OK ;
    }

    hr = CBaseOutputPin::Inactive () ;
    if (SUCCEEDED (hr)) {
        DELETE_RESET (m_pOutputQueue) ;
    }

    return hr ;
}

HRESULT
CDVROutputPin::SetPinMediaType (
    IN  AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr ;

    hr = CDVRPin::SetPinMediaType (pmt) ;
    if (SUCCEEDED (hr)) {
        m_pTranslator = DShowWMSDKHelpers::GetAttributeTranslator (
                            pmt,
                            m_pPolicy,
                            GetBankStoreIndex ()
                            ) ;
        ASSERT (m_pTranslator) ;

        m_fTimestampedMedia = AMMediaIsTimestamped (pmt) ;
    }

    return hr ;
}

STDMETHODIMP
CDVROutputPin::SetProperties (
    IN  ALLOCATOR_PROPERTIES *  pRequest,
    OUT ALLOCATOR_PROPERTIES *  pActual
    )
{
    if (!pActual) {
        return E_POINTER ;
    }

    //  ignore the request

    pActual -> cbBuffer   = m_cbBuffer ;
    pActual -> cBuffers   = m_cBuffers ;
    pActual -> cbAlign    = m_cbAlign ;
    pActual -> cbPrefix   = m_cbPrefix ;

    return S_OK ;
}

STDMETHODIMP
CDVROutputPin::GetProperties (
    OUT ALLOCATOR_PROPERTIES *  pProps
    )
{
    if (!pProps) {
        return E_POINTER ;
    }

    pProps -> cbBuffer   = m_cbBuffer ;
    pProps -> cBuffers   = m_cBuffers ;
    pProps -> cbAlign    = m_cbAlign ;
    pProps -> cbPrefix   = m_cbPrefix ;

    return S_OK ;
}

STDMETHODIMP
CDVROutputPin::Commit (
    )
{
    //  limit our wrapper pool to our allocator props
    m_MSWrappers.SetMaxAllocate (m_cBuffers) ;

    return S_OK ;
}

STDMETHODIMP
CDVROutputPin::Decommit (
    )
{
    return S_OK ;
}

STDMETHODIMP
CDVROutputPin::GetBuffer (
    OUT IMediaSample **     ppBuffer,
    IN  REFERENCE_TIME *    pStartTime,
    IN  REFERENCE_TIME *    pEndTime,
    IN  DWORD               dwFlags
    )
{
    HRESULT hr ;

    if (!ppBuffer) {
        return E_POINTER ;
    }

    //  low frequency code path -- should it turn out not to be, we should
    //   cache cache the scracth media samples, but for now we don't track
    //   them, just allocate, pass out, and forget.

    (* ppBuffer) = new CScratchMediaSample (
                        m_cbBuffer,
                        pStartTime,
                        pEndTime,
                        dwFlags,
                        & hr
                        ) ;

    if (!(* ppBuffer) ||
        FAILED (hr)) {

        hr = ((* ppBuffer) ? hr : E_OUTOFMEMORY) ;
        DELETE_RESET (* ppBuffer) ;
    }

    return hr ;
}

STDMETHODIMP
CDVROutputPin::ReleaseBuffer (
    IN  IMediaSample *  pBuffer
    )
{
    if (!pBuffer) {
        return E_POINTER ;
    }

    pBuffer -> Release () ;

    return S_OK ;
}

HRESULT
CDVROutputPin::DeliverEndOfStream (
    )
{
    HRESULT hr ;

    if (m_pOutputQueue) {

        ASSERT (IsConnected ()) ;
        m_pOutputQueue -> EOS () ;
        hr = S_OK ;
    }
    else {
        hr = VFW_E_NOT_CONNECTED ;
    }

    return hr ;
}

HRESULT
CDVROutputPin::DeliverBeginFlush (
    )
{
    HRESULT hr ;

    if (m_pOutputQueue) {

        ASSERT (IsConnected ()) ;
        m_pOutputQueue -> BeginFlush () ;
        hr = S_OK ;
    }
    else {
        hr = VFW_E_NOT_CONNECTED ;
    }

    return hr ;
}

HRESULT
CDVROutputPin::DeliverEndFlush (
    )
{
    HRESULT hr ;

    if (m_pOutputQueue) {

        ASSERT (IsConnected ()) ;
        m_pOutputQueue -> EndFlush () ;
        hr = S_OK ;
    }
    else {
        hr = VFW_E_NOT_CONNECTED ;
    }

    return hr ;
}

HRESULT
CDVROutputPin::NotifyNewSegment (
    )
{
    //  safe because the reader thread should never be active on this call, or
    //   the reader thread is the one making the call
    m_DVRSegOutputPinState = STATE_SEG_NEW_SEGMENT ;

    return S_OK ;
}

//  ============================================================================
//  ============================================================================

CDVRSinkPinManager::CDVRSinkPinManager (
    IN  CDVRPolicy *            pPolicy,
    IN  CBaseFilter *           pOwningFilter,
    IN  CCritSec *              pFilterLock,
    IN  CCritSec *              pRecvLock,
    IN  CIDVRDShowStream *      pIDVRDShowStream,
    OUT HRESULT *               phr
    ) : m_pIDVRDShowStream      (pIDVRDShowStream),
        m_pFilterLock           (pFilterLock),
        m_pOwningFilter         (pOwningFilter),
        m_cMaxInputPins         (MAX_PIN_BANK_SIZE),
        m_pRecvLock             (pRecvLock),
        m_pPolicy               (pPolicy),
        m_DVRWriterProfile      (pPolicy,
                                 DVR_STREAM_SINK_PROFILE_NAME,
                                 DVR_STREAM_SINK_PROFILE_DESCRIPTION,
                                 phr
                                 )
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRSinkPinManager")) ;

    ASSERT (m_pRecvLock) ;
    ASSERT (m_pPolicy) ;

    m_pPolicy -> AddRef () ;

    CreateNextInputPin_ () ;
}

CDVRSinkPinManager::~CDVRSinkPinManager (
    )
{
    m_pPolicy -> Release () ;
}

HRESULT
CDVRSinkPinManager::CreateNextInputPin_ (
    )
{
    TCHAR           achBuffer [16] ;
    CDVRInputPin *  pInputPin ;
    HRESULT         hr ;
    int             iBankIndex ;

    TRACE_ENTER_0 (TEXT ("CDVRSinkPinManager::CreateNextInputPin_ ()")) ;

    //  init
    pInputPin = NULL ;

    FilterLock_ () ;

    if (m_cMaxInputPins > PinCount ()) {

        //  create the pin; we're appending, so pin name will be based on the
        //   number of pins in the bank
        pInputPin = new CDVRInputPin (
                            CreateInputPinName (
                                PinCount () + 1,                        //  don't 0-base names
                                sizeof achBuffer / sizeof TCHAR,
                                achBuffer
                                ),
                            m_pOwningFilter,
                            this,                   //  events; we hook these always
                            m_pIDVRDShowStream,     //  stream events
                            m_pFilterLock,
                            m_pRecvLock,
                            m_pPolicy,
                            & hr
                            ) ;
        if (!pInputPin ||
            FAILED (hr)) {

            hr = (FAILED (hr) ? hr : E_OUTOFMEMORY) ;
            goto cleanup ;
        }

        //  add it to the bank
        hr = AddPin (
                pInputPin,
                & iBankIndex
                ) ;
        if (FAILED (hr)) {
            goto cleanup ;
        }

        //  set the pin's bank index
        pInputPin -> SetBankStoreIndex (iBankIndex) ;

        m_pOwningFilter -> IncrementPinVersion () ;
    }
    else {
        hr = E_FAIL ;
    }

    cleanup :

    FilterUnlock_ () ;

    if (FAILED (hr)) {
        delete pInputPin ;
    }

    return hr ;
}

HRESULT
CDVRSinkPinManager::OnInputCompleteConnect (
    IN  int             iPinIndex,
    IN  AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_1 (
        TEXT ("CDVRSinkPinManager::OnInputCompleteConnect (%d)"),
        iPinIndex
        ) ;

    //  make sure the stream can be added to the profile
    hr = m_DVRWriterProfile.AddStream (iPinIndex, pmt) ;
    if (SUCCEEDED (hr)) {
        //  ignore the return value on this; creation of the next input pin
        //   should not affect completion of the previous pin's connection
        CreateNextInputPin_ () ;
    }

    return hr ;
}

HRESULT
CDVRSinkPinManager::OnQueryAccept (
    IN  const AM_MEDIA_TYPE *   pmt
    )
{
    return (m_pPolicy -> Settings () -> SucceedQueryAccept () ? S_OK : S_FALSE) ;
}

BOOL
CDVRSinkPinManager::InlineDShowProps_ (
    )
{
    return m_pPolicy -> Settings () -> InlineDShowProps () ;
}

HRESULT
CDVRSinkPinManager::Active (
    )
{
    HRESULT         hr ;
    int             i ;
    CDVRInputPin *  pPin ;
    BOOL            fInlineProps ;

    //  applies to all or none
    fInlineProps = InlineDShowProps_ () ;

    hr = S_OK ;
    for (i = 0;SUCCEEDED (hr);i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            if (pPin -> IsConnected ()) {
                hr = pPin -> Active (fInlineProps) ;
            }
        }
        else {
            break ;
        }
    }

    return hr ;
}

HRESULT
CDVRSinkPinManager::Inactive (
    )
{
    CDVRInputPin *  pPin ;
    int             i ;

    for (i = 0;;i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            if (pPin -> IsConnected ()) {
                pPin -> Inactive () ;
            }
        }
        else {
            break ;
        }
    }

    return S_OK ;
}

//  ============================================================================
//  ============================================================================

HRESULT
CDVRThroughSinkPinManager::OnInputCompleteConnect (
    IN  int             iPinIndex,
    IN  AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_1 (
        TEXT ("CDVRThroughSinkPinManager::OnInputCompleteConnect (%d)"),
        iPinIndex
        ) ;

    //  make sure the stream can be added to the profile
    hr = m_DVRWriterProfile.AddStream (iPinIndex, pmt) ;
    if (SUCCEEDED (hr)) {

        ASSERT (m_pIDVRInputPinConnectEvents) ;
        hr = m_pIDVRInputPinConnectEvents -> OnInputCompleteConnect (iPinIndex, pmt) ;
        if (SUCCEEDED (hr)) {
            //  ignore the return value on this; creation of the next input pin
            //   should not affect completion of the previous pin's connection
            CreateNextInputPin_ () ;
        }
    }

    return hr ;
}

//  ============================================================================
//  ============================================================================

CDVRSourcePinManager::CDVRSourcePinManager (
    IN  CDVRPolicy *            pPolicy,
    IN  CBaseFilter *           pOwningFilter,
    IN  CCritSec *              pFilterLock,
    IN  CDVRDShowSeekingCore *  pSeekingCore,
    IN  BOOL                    fIsLiveSource
    ) : m_pOwningFilter         (pOwningFilter),
        m_pFilterLock           (pFilterLock),
        m_pWMReaderProfile      (NULL),
        m_pPolicy               (pPolicy),
        m_pSeekingCore          (pSeekingCore),
        m_iVideoPinIndex        (UNDEFINED),
        m_pDVRSendStatsWriter   (NULL),
        m_fIsLiveSource         (fIsLiveSource)
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRSourcePinManager")) ;

    ASSERT (m_pSeekingCore) ;

    ASSERT (m_pPolicy) ;
    m_pPolicy -> AddRef () ;
}

CDVRSourcePinManager::~CDVRSourcePinManager (
    )
{
    CBasePin *  pPin ;
    int         i ;

    TRACE_DESTRUCTOR (TEXT ("CDVRSourcePinManager")) ;

    i = 0 ;
    do {
        pPin = GetPin (i++) ;
        delete pPin ;
    } while (pPin) ;

    RELEASE_AND_CLEAR (m_pWMReaderProfile) ;

    ASSERT (m_pPolicy) ;
    m_pPolicy -> Release () ;
}

HRESULT
CDVRSourcePinManager::SetReaderProfile (
    IN  CDVRReaderProfile * pWMReaderProfile
    )
{
    DWORD           dwPinCount ;
    WORD            wStreamNum ;
    DWORD           dwIndex ;
    HRESULT         hr ;
    CMediaType *    pmt ;
    BOOL            r ;

    ASSERT (pWMReaderProfile) ;

    hr = pWMReaderProfile -> EnumWMStreams (& dwPinCount) ;
    if (FAILED (hr)) { goto cleanup ; }

    for (dwIndex = 0; dwIndex < dwPinCount && SUCCEEDED (hr); dwIndex++) {
        pmt = new CMediaType ;
        if (pmt) {
            hr = pWMReaderProfile -> GetStream (dwIndex, & wStreamNum, pmt) ;
            if (SUCCEEDED (hr)) {
                hr = CreateOutputPin (dwIndex, pmt) ;
            }

            //  we copy the media type in the output pin, so we must free this
            delete pmt ;

            //  create out stream num -> index map
            r = m_StreamNumToPinIndex.CreateMap (wStreamNum, dwIndex) ;
            if (!r) {
                hr = E_OUTOFMEMORY ;
            }
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }

    cleanup :

    return hr ;
}

HRESULT
CDVRSourcePinManager::CreateOutputPin (
    IN  int             iPinIndex,
    IN  AM_MEDIA_TYPE * pmt
    )
{
    TCHAR           achBuffer [16] ;
    CDVROutputPin * pOutputPin ;
    HRESULT         hr ;

    TRACE_ENTER_2 (
        TEXT ("CDVRSourcePinManager::CreateOutputPin (%d, %08xh)"),
        iPinIndex,
        pmt
        ) ;

    FilterLock_ () ;

    //  init
    pOutputPin = NULL ;

    //  create the pin; we're appending, so pin name will be based on the
    //   number of pins in the bank
    pOutputPin = new CDVROutputPin (
                        m_pPolicy,
                        CreateOutputPinName (
                            iPinIndex + 1,          //  index is 0-based
                            sizeof (achBuffer) / sizeof (TCHAR),
                            achBuffer
                            ),
                        m_pOwningFilter,
                        m_pFilterLock,
                        m_pSeekingCore,
                        m_pDVRSendStatsWriter,
                        this,
                        & hr
                        ) ;
    if (!pOutputPin ||
        FAILED (hr)) {

        hr = (FAILED (hr) ? hr : E_OUTOFMEMORY) ;
        goto cleanup ;
    }

    //  add it to the bank
    hr = AddPin (
            pOutputPin,
            iPinIndex
            ) ;
    if (FAILED (hr)) {
        goto cleanup ;
    }

    //  set the pin's bank index
    pOutputPin -> SetBankStoreIndex (iPinIndex) ;

    //  set the media type on the pin
    //  !NOTE! : add this after setting the bank store index, or the flow id
    //   will not be set correctly in the attribute translator
    hr = pOutputPin -> SetPinMediaType (pmt) ;
    if (FAILED (hr)) {
        goto cleanup ;
    }

    //  if we still haven't received a video pin index, check if we've just
    //    added one; use this for seeking purposes; if we have no video pins
    //    the 0th pin is the seeking pin
    if (m_iVideoPinIndex == UNDEFINED &&
        IsAMVideo (pmt)) {

        //  found it
        m_iVideoPinIndex = iPinIndex ;
    }

    //  success !
    m_pOwningFilter -> IncrementPinVersion () ;

    cleanup :

    FilterUnlock_ () ;

    if (FAILED (hr)) {
        delete pOutputPin ;
    }

    return hr ;
}

HRESULT
CDVRSourcePinManager::Active (
    )
{
    HRESULT         hr ;
    int             i ;
    CDVROutputPin * pPin ;

    hr = S_OK ;

    for (i = 0; SUCCEEDED (hr);i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            if (pPin -> IsConnected ()) {
                hr = pPin -> Active () ;
            }
        }
        else {
            break ;
        }
    }

    if (FAILED (hr)) {
        Inactive () ;
    }

    return hr ;
}

HRESULT
CDVRSourcePinManager::Inactive (
    )
{
    CDVROutputPin * pPin ;
    int             i ;

    for (i = 0;;i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            if (pPin -> IsConnected ()) {
                pPin -> Inactive () ;
            }
        }
        else {
            break ;
        }
    }

    return S_OK ;
}

CDVROutputPin *
CDVRSourcePinManager::GetNonRefdOutputPin (
    IN  WORD    wStreamNum
    )
{
    CDVROutputPin * pDVROutputPin ;
    BOOL            r ;
    int             iPinIndex ;

    r = m_StreamNumToPinIndex.Find (wStreamNum, & iPinIndex) ;
    if (r) {
        pDVROutputPin = GetPin (iPinIndex) ;
    }
    else {
        pDVROutputPin = NULL ;
    }

    return pDVROutputPin ;
}

HRESULT
CDVRSourcePinManager::DeliverBeginFlush (
    )
{
    CDVROutputPin * pPin ;
    int             i ;

    for (i = 0;;i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            if (pPin -> IsConnected ()) {
                pPin -> DeliverBeginFlush () ;
            }
        }
        else {
            break ;
        }
    }

    return S_OK ;
}

HRESULT
CDVRSourcePinManager::DeliverEndFlush (
    )
{
    CDVROutputPin * pPin ;
    int             i ;

    for (i = 0;;i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            if (pPin -> IsConnected ()) {
                pPin -> DeliverEndFlush () ;
            }
        }
        else {
            break ;
        }
    }

    return S_OK ;
}

HRESULT
CDVRSourcePinManager::DeliverEndOfStream (
    )
{
    CDVROutputPin * pPin ;
    int             i ;

    for (i = 0;;i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            if (pPin -> IsConnected ()) {
                pPin -> DeliverEndOfStream () ;
            }
        }
        else {
            break ;
        }
    }

    return S_OK ;
}

HRESULT
CDVRSourcePinManager::NotifyNewSegment (
    )
{
    CDVROutputPin * pPin ;
    int             i ;

    for (i = 0;;i++) {
        pPin = GetPin (i) ;
        if (pPin) {
            pPin -> NotifyNewSegment () ;
        }
        else {
            break ;
        }
    }

    return S_OK ;
}

BOOL
CDVRSourcePinManager::IsSeekingPin (
    CDVROutputPin * pDVROutputPin
    )
{
    CDVROutputPin * pPin ;
    int             i ;
    BOOL            r ;

    ASSERT (pDVROutputPin) ;
    if (m_iVideoPinIndex != UNDEFINED) {
        r = (pDVROutputPin -> GetBankStoreIndex () == m_iVideoPinIndex ? TRUE : FALSE) ;
    }
    else {
        //  there's no video pin; 0th pin is the default
        r = (pDVROutputPin -> GetBankStoreIndex () == 0 ? TRUE : FALSE) ;
    }

    return r ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\shared\dvrpins.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrpins.h

    Abstract:

        This module contains the DVR filters' pin-related declarations.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef __tsdvr__shared__dvrpins_h
#define __tsdvr__shared__dvrpins_h

//  ============================================================================
//  ============================================================================

TCHAR *
CreateOutputPinName (
    IN  int     iPinIndex,
    IN  int     iBufferLen,
    OUT TCHAR * pchBuffer
    ) ;

TCHAR *
CreateInputPinName (
    IN  int     iPinIndex,
    IN  int     iBufferLen,
    OUT TCHAR * pchBuffer
    ) ;

//  ============================================================================
//  ============================================================================

class CIDVRPinConnectionEvents
{
    public :

        virtual
        HRESULT
        OnInputCompleteConnect (
            IN  int             iPinIndex,
            IN  AM_MEDIA_TYPE * pmt
            ) = 0 ;

        virtual
        HRESULT
        OnQueryAccept (
            IN  const AM_MEDIA_TYPE *   pmt
            ) = 0 ;
} ;

//  ============================================================================
//  ============================================================================

class CIDVRDShowStream
{
    public :

        virtual
        HRESULT
        OnReceive (
            IN  int                         iPinIndex,
            IN  CDVRAttributeTranslator *   pTranslator,
            IN  IMediaSample *              pIMediaSample
            ) = 0 ;

        virtual
        HRESULT
        OnBeginFlush (
            IN  int iPinIndex
            ) = 0 ;

        virtual
        HRESULT
        OnEndFlush (
            IN  int iPinIndex
            ) = 0 ;

        virtual
        HRESULT
        OnEndOfStream (
            IN  int iPinIndex
            ) = 0 ;
} ;

//  ============================================================================
//  ============================================================================

class CDVRPin
{
    int                     m_iBankStoreIndex ;     //  index into the holding bank
    CCritSec *              m_pFilterLock ;
    CMediaType              m_mtDVRPin ;            //  if connected : == m_mt

    protected :

        CDVRAttributeTranslator *   m_pTranslator ;
        CDVRPolicy *                m_pPolicy ;

        CMediaType * GetMediaType_ ()   { return & m_mtDVRPin ; }

        BOOL IsEqual_ (IN const AM_MEDIA_TYPE * pmt)
        {
            CMediaType  mt ;

            mt = (* pmt) ;

            return (mt == m_mtDVRPin ? TRUE : FALSE) ;
        }

        BOOL NeverConnected_ () { return IsBlankMediaType (& m_mtDVRPin) ; }

    public :

        CDVRPin (
            IN  CCritSec *          pFilterLock,
            IN  CDVRPolicy *        pPolicy
            ) : m_iBankStoreIndex   (UNDEFINED),
                m_pFilterLock       (pFilterLock),
                m_pTranslator       (NULL),
                m_pPolicy           (pPolicy)
        {
            ASSERT (m_pFilterLock) ;
            ASSERT (m_pPolicy) ;

            m_pPolicy -> AddRef () ;

            m_mtDVRPin.InitMediaType () ;
            m_mtDVRPin.majortype    = GUID_NULL ;
            m_mtDVRPin.subtype      = GUID_NULL ;
            m_mtDVRPin.formattype   = GUID_NULL ;
        }

        virtual
        ~CDVRPin ()
        {
            m_pPolicy -> Release () ;
        }

        //  --------------------------------------------------------------------
        //  class methods

        void SetBankStoreIndex (IN int iIndex)  { m_iBankStoreIndex = iIndex ; }
        int  GetBankStoreIndex ()               { return m_iBankStoreIndex ; }

        HRESULT
        SetPinMediaType (
            IN  AM_MEDIA_TYPE * pmt
            ) ;

        HRESULT
        GetPinMediaType (
            OUT AM_MEDIA_TYPE * pmt
            ) ;

        HRESULT
        GetPinMediaTypeCopy (
            OUT CMediaType **   ppmt
            ) ;
} ;

//  ============================================================================
//  ============================================================================

template <class T>
class CTDVRPinBank
{
    enum {
        //  this our allocation unit i.e. pin pointers are allocated 1 block
        //   at a time and this is the block size
        PIN_BLOCK_SIZE = 5
    } ;

    TCNonDenseVector <CBasePin *>   m_Pins ;

    public :

        CTDVRPinBank (
            ) : m_Pins  (NULL,
                         PIN_BLOCK_SIZE
                         ) {}

        virtual
        ~CTDVRPinBank (
            ) {}

        int PinCount ()     { return m_Pins.ValCount () ; }

        T *
        GetPin (
            IN int iIndex
            )
        {
            DWORD       dw ;
            CBasePin *  pPin ;

            dw = m_Pins.GetVal (
                    iIndex,
                    & pPin
                    ) ;

            if (dw != NOERROR) {
                //  most likely out of range
                pPin = NULL ;
            }

            return reinterpret_cast <T *> (pPin) ;
        }

        HRESULT
        AddPin (
            IN  CBasePin *  pPin,
            IN  int         iPinIndex
            )
        {
            HRESULT hr ;
            DWORD   dw ;

            dw = m_Pins.SetVal (
                    pPin,
                    iPinIndex
                    ) ;

            hr = HRESULT_FROM_WIN32 (dw) ;

            return hr ;
        }

        HRESULT
        AddPin (
            IN  CBasePin *  pPin,
            OUT int *       piPinIndex
            )
        {
            DWORD   dw ;

            dw = m_Pins.AppendVal (
                    pPin,
                    piPinIndex
                    ) ;

            return HRESULT_FROM_WIN32 (dw) ; ;
        }

        virtual
        HRESULT
        OnCompleteConnect (
            IN  int             iPinIndex,
            IN  AM_MEDIA_TYPE * pmt
            )
        {
            return S_OK ;
        }
} ;

//  ============================================================================
//  ============================================================================

class CDVRInputPin :
    public CBaseInputPin,
    public CDVRPin
{
    CIDVRPinConnectionEvents *  m_pIPinConnectEvent ;
    CIDVRDShowStream *          m_pIDShowStream ;
    CCritSec *                  m_pRecvLock ;

    void LockFilter_ ()         { CBaseInputPin::m_pLock -> Lock () ;      }
    void UnlockFilter_ ()       { CBaseInputPin::m_pLock -> Unlock () ;    }

    void LockRecv_ ()           { m_pRecvLock -> Lock () ; }
    void UnlockRecv_ ()         { m_pRecvLock -> Unlock () ; }

    public :

        CDVRInputPin (
            IN  TCHAR *                     pszPinName,
            IN  CBaseFilter *               pOwningFilter,
            IN  CIDVRPinConnectionEvents *  pIPinConnectEvent,
            IN  CIDVRDShowStream *          pIDShowStream,
            IN  CCritSec *                  pFilterLock,
            IN  CCritSec *                  pRecvLock,
            IN  CDVRPolicy *                pPolicy,
            OUT HRESULT *                   phr
            ) ;

        ~CDVRInputPin (
            ) ;

        void SetPinConnectEvent (CIDVRPinConnectionEvents * pIPinConnectEvent)         { m_pIPinConnectEvent      = pIPinConnectEvent ; }
        void SetDShowStreamEvent (CIDVRDShowStream * pIDShowStream) { m_pIDShowStream   = pIDShowStream ; }

        //  --------------------------------------------------------------------
        //  CBasePin methods

        HRESULT
        GetMediaType (
            IN  int             iPosition,
            OUT CMediaType *    pmt
            ) ;

        HRESULT
        CheckMediaType (
            IN  const CMediaType *
            ) ;

        virtual
        HRESULT
        CompleteConnect (
            IN  IPin *  pReceivePin
            ) ;

        STDMETHODIMP
        QueryAccept (
            IN  const AM_MEDIA_TYPE *   pmt
            ) ;

        STDMETHODIMP
        Receive (
            IN  IMediaSample *  pIMS
            ) ;

        HRESULT
        Active (
            IN  BOOL    fInlineProps
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class CDVROutputPin :
    public CBaseOutputPin,
    public CDVRPin,
    public IMemAllocator,
    public IAMPushSource
{
    enum DVR_SEG_OUTPUT_PIN_STATE {
        STATE_SEG_NEW_SEGMENT,
        STATE_SEG_IN_SEGMENT,
    } ;

    enum DVR_MEDIA_OUTPUT_PIN_STATE {
        STATE_MEDIA_COMPATIBLE,
        STATE_MEDIA_INCOMPATIBLE,
    } ;

    COutputQueue *              m_pOutputQueue ;
    long                        m_cbBuffer ;
    long                        m_cBuffers ;
    long                        m_cbAlign ;
    long                        m_cbPrefix ;
    CMediaSampleWrapperPool     m_MSWrappers ;
    CDVRDIMediaSeeking          m_IMediaSeeking ;
    BOOL                        m_fTimestampedMedia ;
    DVR_SEG_OUTPUT_PIN_STATE    m_DVRSegOutputPinState ;
    DVR_MEDIA_OUTPUT_PIN_STATE  m_DVRMediaOutputPinState ;
    CDVRDShowSeekingCore *      m_pSeekingCore ;
    CDVRSourcePinManager *      m_pOwningPinBank ;

    void LockFilter_ ()       { CBaseOutputPin::m_pLock -> Lock () ;      }
    void UnlockFilter_ ()     { CBaseOutputPin::m_pLock -> Unlock () ;    }

    public :

        CDVROutputPin (
            IN  CDVRPolicy *            pPolicy,
            IN  TCHAR *                 pszPinName,
            IN  CBaseFilter *           pOwningFilter,
            IN  CCritSec *              pFilterLock,
            IN  CDVRDShowSeekingCore *  pSeekingCore,
            IN  CDVRSendStatsWriter *   pDVRSendStatsWriter,
            IN  CDVRSourcePinManager *  pOwningPinBank,
            OUT HRESULT *               phr
            ) ;

        ~CDVROutputPin (
            ) ;

        DECLARE_IUNKNOWN ;

        //  for IMemAllocator, IAMPushSource, IMediaSeeking
        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        HRESULT
        SendSample (
            IN  IMediaSample2 * pIMS2,
            IN  AM_MEDIA_TYPE * pmtNew
            ) ;

        CMediaSampleWrapper * WaitGetMSWrapper ()   { return m_MSWrappers.Get () ; }
        CMediaSampleWrapper * TryGetMSWrapper ()    { return m_MSWrappers.TryGet () ; }

        CDVRAttributeTranslator * GetTranslator ()  { return m_pTranslator ; }

        //  --------------------------------------------------------------------
        //  CBasePin methods

        HRESULT
        SetPinMediaType (
            IN  AM_MEDIA_TYPE * pmt
            ) ;

        HRESULT
        Active (
            ) ;

        HRESULT
        Inactive (
            ) ;

        HRESULT
        DecideAllocator (
            IN  IMemInputPin *      pPin,
            IN  IMemAllocator **    ppAlloc
            ) ;

        HRESULT
        DecideBufferSize (
            IN  IMemAllocator *         pAlloc,
            IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
            ) ;

        HRESULT
        GetMediaType (
            IN  int             iPosition,
            OUT CMediaType *    pmt
            ) ;

        HRESULT
        CheckMediaType (
            IN  const CMediaType *
            ) ;

        HRESULT
        DeliverEndOfStream (
            ) ;

        HRESULT
        DeliverBeginFlush (
            ) ;

        HRESULT
        DeliverEndFlush (
            ) ;

        HRESULT
        NotifyNewSegment (
            ) ;

        //  ====================================================================
        //  IMemAllocator

        STDMETHODIMP
        SetProperties(
            IN  ALLOCATOR_PROPERTIES *  pRequest,
            OUT ALLOCATOR_PROPERTIES *  pActual
            ) ;

        STDMETHODIMP
        GetProperties(
            OUT ALLOCATOR_PROPERTIES *  pProps
            ) ;

        STDMETHODIMP
        Commit (
            ) ;

        STDMETHODIMP
        Decommit (
            ) ;

        STDMETHODIMP
        GetBuffer (
            OUT IMediaSample **     ppBuffer,
            OUT REFERENCE_TIME *    pStartTime,
            OUT REFERENCE_TIME *    pEndTime,
            IN  DWORD               dwFlags
            ) ;

        STDMETHODIMP
        ReleaseBuffer (
            IN  IMediaSample *  pBuffer
            ) ;

        //  ====================================================================
        //  IAMPushSource

        STDMETHODIMP
        GetPushSourceFlags (
	        OUT ULONG * pFlags
            )
        {
            //  set this purely to get around an ASSERT in quartz
            if (pFlags == NULL) {
                return E_POINTER ;
            }

            //  we're not live in the strict sense; strict sense is that we are
            //   received stored content i.e. non-live content is being pushed
            //   (broadcast) to us.
            (* pFlags) = AM_PUSHSOURCECAPS_NOT_LIVE ;

            return S_OK ;
        }

        STDMETHODIMP
        SetPushSourceFlags (
	        IN  ULONG Flags
            )
        {
            return E_NOTIMPL ;
        }

        STDMETHODIMP
        SetStreamOffset (
            IN  REFERENCE_TIME  rtOffset
            )
        {
            return E_NOTIMPL ;
        }

        STDMETHODIMP
        GetStreamOffset (
            OUT REFERENCE_TIME  * prtOffset
            )
        {
            return E_NOTIMPL ;
        }

        STDMETHODIMP
        GetMaxStreamOffset (
            OUT REFERENCE_TIME  * prtMaxOffset
            )
        {
            return E_NOTIMPL ;
        }

        STDMETHODIMP
        SetMaxStreamOffset (
            IN  REFERENCE_TIME  rtMaxOffset
            )
        {
            return E_NOTIMPL ;
        }

        STDMETHODIMP
        GetLatency(
            IN  REFERENCE_TIME  * prtLatency
            )
        {
            return E_NOTIMPL ;
        }
} ;

//  ============================================================================
//  ============================================================================

class CDVRSinkPinManager :
    public CTDVRPinBank <CDVRInputPin>,
    public CIDVRPinConnectionEvents
{
    BOOL
    InlineDShowProps_ (
        ) ;

    protected :

        CIDVRDShowStream *          m_pIDVRDShowStream ;        //  set on pins we create
        CBaseFilter *               m_pOwningFilter ;           //  owning filter
        CCritSec *                  m_pFilterLock ;             //  owning filter lock
        CCritSec *                  m_pRecvLock ;
        CDVRWriterProfile           m_DVRWriterProfile ;               //  WM profile
        int                         m_cMaxInputPins ;
        CDVRPolicy *                m_pPolicy ;

        void FilterLock_ ()     { m_pFilterLock -> Lock () ;      }
        void FilterUnlock_ ()   { m_pFilterLock -> Unlock () ;    }

        HRESULT
        CreateNextInputPin_ (
            ) ;

    public :

        CDVRSinkPinManager (
            IN  CDVRPolicy *            pPolicy,
            IN  CBaseFilter *           pOwningFilter,
            IN  CCritSec *              pFilterLock,
            IN  CCritSec *              pRecvLock,
            IN  CIDVRDShowStream *      pIDVRDShowStream,
            OUT HRESULT *               phr
            ) ;

        ~CDVRSinkPinManager (
            ) ;

        HRESULT
        Active (
            ) ;

        HRESULT
        Inactive (
            ) ;

        virtual
        HRESULT
        OnInputCompleteConnect (
            IN  int             iPinIndex,
            IN  AM_MEDIA_TYPE * pmt
            ) ;

        virtual
        HRESULT
        OnQueryAccept (
            IN  const AM_MEDIA_TYPE *   pmt
            ) ;

        HRESULT GetRefdWMProfile (OUT IWMProfile ** ppIWMProfile)   { return m_DVRWriterProfile.GetRefdWMProfile (ppIWMProfile) ; }
        DWORD GetProfileStreamCount ()                              { return m_DVRWriterProfile.GetStreamCount () ; }
} ;

class CDVRThroughSinkPinManager :
    public CDVRSinkPinManager
{
    CIDVRPinConnectionEvents *  m_pIDVRInputPinConnectEvents ;

    public :

        CDVRThroughSinkPinManager (
            IN  CDVRPolicy *                pPolicy,
            IN  CBaseFilter *               pOwningFilter,
            IN  CCritSec *                  pFilterLock,
            IN  CCritSec *                  pRecvLock,
            IN  CIDVRDShowStream *          pIDVRDShowStream,
            IN  CIDVRPinConnectionEvents *  pIDVRInputPinConnectEvents,
            OUT HRESULT *               phr
            ) : CDVRSinkPinManager      (pPolicy,
                                         pOwningFilter,
                                         pFilterLock,
                                         pRecvLock,
                                         pIDVRDShowStream,
                                         phr
                                         ),
                m_pIDVRInputPinConnectEvents (pIDVRInputPinConnectEvents)
        {
            ASSERT (m_pIDVRInputPinConnectEvents) ;
        }

        virtual
        HRESULT
        OnInputCompleteConnect (
            IN  int             iPinIndex,
            IN  AM_MEDIA_TYPE * pmt
            ) ;
} ;

class CDVRSourcePinManager :
    public CTDVRPinBank <CDVROutputPin>
{
    CBaseFilter *           m_pOwningFilter ;
    CCritSec *              m_pFilterLock ;
    CDVRReaderProfile *     m_pWMReaderProfile ;
    CTSmallMap <WORD, int>  m_StreamNumToPinIndex ;
    CDVRPolicy *            m_pPolicy ;
    CDVRDShowSeekingCore *  m_pSeekingCore ;
    int                     m_iVideoPinIndex ;
    CDVRSendStatsWriter *   m_pDVRSendStatsWriter ;
    BOOL                    m_fIsLiveSource ;

    void FilterLock_ ()     { m_pFilterLock -> Lock () ;      }
    void FilterUnlock_ ()   { m_pFilterLock -> Unlock () ;    }

    public :

        CDVRSourcePinManager (
            IN  CDVRPolicy *            pPolicy,
            IN  CBaseFilter *           pOwningFilter,
            IN  CCritSec *              pFilterLock,
            IN  CDVRDShowSeekingCore *  pSeekingCore,
            IN  BOOL                    fIsLiveSource = FALSE
            ) ;

        virtual
        ~CDVRSourcePinManager (
            ) ;

        BOOL IsSeekingPin (CDVROutputPin *) ;

        void SetLiveSource (IN BOOL f)  { m_fIsLiveSource = f ; }
        BOOL IsLiveSource ()            { return m_fIsLiveSource ; }

        HRESULT
        SetReaderProfile (
            IN  CDVRReaderProfile * pWMReaderProfile
            ) ;

        void SetStatsWriter (CDVRSendStatsWriter * pDVRSendStatsWriter) { m_pDVRSendStatsWriter = pDVRSendStatsWriter ; }

        HRESULT
        CreateOutputPin (
            IN  int             iPinIndex,
            IN  AM_MEDIA_TYPE * pmt
            ) ;

        HRESULT
        Active (
            ) ;

        HRESULT
        Inactive (
            ) ;

        CDVROutputPin *
        GetNonRefdOutputPin (
            IN  WORD    wStreamNum
            ) ;

        HRESULT
        DeliverBeginFlush (
            ) ;

        HRESULT
        DeliverEndFlush (
            ) ;

        HRESULT
        DeliverEndOfStream (
            ) ;

        HRESULT
        NotifyNewSegment (
            ) ;
} ;

#endif  //  __tsdvr__shared__dvrpins_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\shared\dvrprof.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrprof.cpp

    Abstract:

        This module contains the code for our DShow - WMSDK_Profiles layer.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#include "dvrall.h"

#include "dvrprof.h"

static
REFGUID
WMStreamType (
    IN  AM_MEDIA_TYPE * pmt
    )
{
    static GUID     guidStreamType ;
    HRESULT         hr ;
    WM_MEDIA_TYPE   Wmt ;

    hr = DShowWMSDKHelpers::TranslateDShowToWM (
            pmt,
            & Wmt
            ) ;

    if (SUCCEEDED (hr)) {
        guidStreamType = Wmt.majortype ;

        FreeMediaType (* (AM_MEDIA_TYPE *) & Wmt) ;
    }
    else {
        //  pass it straight through
        guidStreamType = pmt -> majortype ;
    }

    return guidStreamType ;
}

//  don't suck in ws2_32.dll just to do this
#define DVR_NTOHL(l)                                    \
                    ( (((l) & 0xFF000000) >> 24)    |   \
                      (((l) & 0x00FF0000) >> 8)     |   \
                      (((l) & 0x0000FF00) << 8)     |   \
                      (((l) & 0x000000FF) << 24) )

static
BOOL
IsFourCCVBR (
    IN  DWORD   biCompression       //  from BITMAPINFOHEADER
    )
{
    BOOL    r ;

    //  see http://www.microsoft.com/hwdev/devdes/fourcc.htm

    //  make sure we're big-endian
    biCompression = DVR_NTOHL (biCompression) ;

    if (biCompression == 0x4D503432) {      //  MP42
        r = TRUE ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

static
DWORD
GetStreamAvgBitRate (
    IN  AM_MEDIA_TYPE * pmt
    )
{
    DWORD   dwRet ;

    ASSERT (pmt) ;

    //  ========================================================================
    //  mpeg-1 video
    if (pmt -> formattype   == FORMAT_MPEGVideo         &&
        pmt -> pbFormat                                 &&
        pmt -> cbFormat     >= sizeof MPEG1VIDEOINFO) {

        dwRet = reinterpret_cast <MPEG1VIDEOINFO *> (pmt -> pbFormat) -> hdr.dwBitRate ;
    }
    //  ========================================================================
    //  mpeg-2 video
    else if (pmt -> formattype == FORMAT_MPEG2Video     &&
             pmt -> pbFormat                            &&
             pmt -> cbFormat >= sizeof FORMAT_MPEG2Video) {

        dwRet = reinterpret_cast <MPEG2VIDEOINFO *> (pmt -> pbFormat) -> hdr.dwBitRate ;
    }
    //  ========================================================================
    //  mpeg-2 video
    else if (pmt -> formattype == FORMAT_VideoInfo      &&
             pmt -> pbFormat                            &&
             pmt -> cbFormat >= sizeof MPEG2VIDEOINFO) {

        dwRet = reinterpret_cast <VIDEOINFOHEADER *> (pmt -> pbFormat) -> dwBitRate ;
    }
    //  ========================================================================
    //  mpeg-2 video
    else if (pmt -> formattype == FORMAT_VideoInfo2     &&
             pmt -> pbFormat                            &&
             pmt -> cbFormat >= sizeof VIDEOINFOHEADER2) {

        dwRet = reinterpret_cast <VIDEOINFOHEADER2 *> (pmt -> pbFormat) -> dwBitRate ;
    }
    //  ========================================================================
    //  audio
    else if (pmt -> formattype == FORMAT_WaveFormatEx   &&
             pmt -> pbFormat                            &&
             pmt -> cbFormat >= sizeof WAVEFORMATEX) {

        dwRet = reinterpret_cast <WAVEFORMATEX *> (pmt -> pbFormat) -> nAvgBytesPerSec * 8 ;
    }
    //  ========================================================================
    //  dv
    else if (pmt -> majortype == MEDIATYPE_Interleaved  &&
             pmt -> subtype   == MEDIASUBTYPE_dvsd      &&
             pmt -> formattype == FORMAT_DvInfo         &&
             pmt -> pbFormat                            &&
             pmt -> cbFormat >= sizeof DVINFO) {

        // Type 1 DV - will be saved as a generic stream
        dwRet = 25000000;
    }
    //  ========================================================================
    //  dvsd
    else if (pmt -> majortype == MEDIATYPE_Video         &&
             pmt -> subtype   == MEDIASUBTYPE_dvsd       &&
             pmt -> formattype == FORMAT_VideoInfo       &&
             pmt -> pbFormat                             &&
             pmt -> cbFormat >= sizeof FORMAT_VideoInfo) {

        // Type 2 DV

        VIDEOINFO* pFormat = (VIDEOINFO*) pmt -> pbFormat;

        pFormat -> dwBitRate = 25000000;
        pFormat -> bmiHeader.biCompression = pmt -> subtype.Data1;

        dwRet = 25000000;
    }
    //  ========================================================================
    //  mpeg-4 - 3
    else if (pmt -> majortype   == MEDIATYPE_Video          &&
             pmt -> subtype     == WMMEDIASUBTYPE_MP43      &&
             pmt -> formattype  == WMFORMAT_VideoInfo       &&
             pmt -> pbFormat                                &&
             pmt -> cbFormat    >= sizeof WMVIDEOINFOHEADER) {

        dwRet = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) -> dwBitRate ;
    }
    //  ========================================================================
    //  mpeg-4 - S
    else if (pmt -> majortype   == MEDIATYPE_Video          &&
             pmt -> subtype     == WMMEDIASUBTYPE_MP4S      &&
             pmt -> formattype  == WMFORMAT_VideoInfo       &&
             pmt -> pbFormat                                &&
             pmt -> cbFormat    >= sizeof WMVIDEOINFOHEADER) {

        dwRet = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) -> dwBitRate ;
    }
    //  ========================================================================
    //  wmv1
    else if (pmt -> majortype   == MEDIATYPE_Video          &&
             pmt -> subtype     == WMMEDIASUBTYPE_WMV1      &&
             pmt -> formattype  == WMFORMAT_VideoInfo       &&
             pmt -> pbFormat                                &&
             pmt -> cbFormat    >= sizeof WMVIDEOINFOHEADER) {

        dwRet = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) -> dwBitRate ;
    }
    //  ========================================================================
    //  fourcc
    else if (IsVideo (pmt)                                      &&
             pmt -> formattype   == WMFORMAT_VideoInfo          &&
             pmt -> pbFormat                                    &&
             pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER    &&
             IsFourCCVBR (reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) -> bmiHeader.biCompression)) {

        dwRet = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) -> dwBitRate ;
    }
    //  ========================================================================
    //  other ??
    else {
        dwRet = 1 ;
    }

    //  don't return 0; WMSDK will divide by 0
    return (dwRet > 0 ? dwRet : 1) ;
}

static
DWORD
MinBitrate (
    IN AM_MEDIA_TYPE * pmt
    )
{
    DWORD   dwRet ;

    ASSERT (pmt) ;

    //  ========================================================================
    //  mpeg-2
    if (IsVideo (pmt)                                   &&
        pmt -> subtype      == MEDIASUBTYPE_MPEG2_VIDEO &&
        pmt -> formattype   == FORMAT_MPEG2Video        &&
        pmt -> pbFormat                                 &&
        pmt -> cbFormat     >= sizeof FORMAT_MPEG2Video) {

        dwRet = 1 ;
    }
    //  ========================================================================
    //  mpeg-4 - 3
    else if (IsVideo (pmt)                                  &&
             pmt -> subtype      == WMMEDIASUBTYPE_MP43     &&
             pmt -> formattype   == WMFORMAT_VideoInfo      &&
             pmt -> pbFormat                                &&
             pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER) {

        dwRet = 1 ;
    }
    //  ========================================================================
    //  mpeg-4 - S
    else if (IsVideo (pmt)                                  &&
             pmt -> subtype      == WMMEDIASUBTYPE_MP4S     &&
             pmt -> formattype   == WMFORMAT_VideoInfo      &&
             pmt -> pbFormat                                &&
             pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER) {

        dwRet = 1 ;
    }
    //  ========================================================================
    //  wmv1
    else if (IsVideo (pmt)                                  &&
             pmt -> subtype      == WMMEDIASUBTYPE_WMV1     &&
             pmt -> formattype   == WMFORMAT_VideoInfo      &&
             pmt -> pbFormat                                &&
             pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER) {

        dwRet = 1 ;
    }
    //  ========================================================================
    //  fourcc
    else if (IsVideo (pmt)                                      &&
             pmt -> formattype   == WMFORMAT_VideoInfo          &&
             pmt -> pbFormat                                    &&
             pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER    &&
             IsFourCCVBR (reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) -> bmiHeader.biCompression)) {

        dwRet = 1 ;
    }
    //  ========================================================================
    //  other - default to avg
    else {
        dwRet = GetStreamAvgBitRate (pmt) ;
    }

    return dwRet ;
}

static
DWORD
MaxBitrate (
    IN AM_MEDIA_TYPE * pmt
    )
{
    MPEG2VIDEOINFO *    pMpeg2videoInfo ;
    WMVIDEOINFOHEADER * pWMVideoInfoHeader ;
    DWORD               dwRet ;
    DWORD               dwBitsPerFrame ;
    DWORD               dwFramesPerSecond ;

    ASSERT (pmt) ;

    //  ========================================================================
    //  mpeg-2
    if (IsVideo (pmt)                                   &&
        pmt -> subtype      == MEDIASUBTYPE_MPEG2_VIDEO &&
        pmt -> formattype   == FORMAT_MPEG2Video        &&
        pmt -> pbFormat                                 &&
        pmt -> cbFormat     >= sizeof FORMAT_MPEG2Video) {

        pMpeg2videoInfo = reinterpret_cast <MPEG2VIDEOINFO *> (pmt -> pbFormat) ;

        dwBitsPerFrame = pMpeg2videoInfo -> hdr.bmiHeader.biWidth *
                         pMpeg2videoInfo -> hdr.bmiHeader.biHeight *
                         (pMpeg2videoInfo -> hdr.bmiHeader.biBitCount != 0 ? pMpeg2videoInfo -> hdr.bmiHeader.biBitCount : 8) ;

        if (pMpeg2videoInfo -> hdr.AvgTimePerFrame != 0) {
            dwFramesPerSecond = (DWORD) (UNITS / pMpeg2videoInfo -> hdr.AvgTimePerFrame) ;
        }
        else {
            dwFramesPerSecond = VBR_DEF_FPS ;
        }

        dwRet = dwBitsPerFrame * dwFramesPerSecond ;
    }
    //  ========================================================================
    //  mpeg-4 - 3
    else if (IsVideo (pmt)                                      &&
             pmt -> subtype      == WMMEDIASUBTYPE_MP43         &&
             pmt -> formattype   == WMFORMAT_VideoInfo          &&
             pmt -> pbFormat                                    &&
             pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER) {

        pWMVideoInfoHeader = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) ;

        dwBitsPerFrame = pWMVideoInfoHeader -> bmiHeader.biWidth *
                         pWMVideoInfoHeader -> bmiHeader.biHeight *
                         (pWMVideoInfoHeader -> bmiHeader.biBitCount != 0 ? pWMVideoInfoHeader -> bmiHeader.biBitCount : 8) ;

        if (pWMVideoInfoHeader -> AvgTimePerFrame != 0) {
            //  WMSDK sports a 10 MHz clock as well, so use UNITS
            dwFramesPerSecond = (DWORD) (UNITS / pWMVideoInfoHeader -> AvgTimePerFrame) ;
        }
        else {
            dwFramesPerSecond = VBR_DEF_FPS ;
        }

        dwRet = dwBitsPerFrame * dwFramesPerSecond ;
    }
    //  ========================================================================
    //  mpeg-4 - S
    else if (IsVideo (pmt)                                      &&
             pmt -> subtype      == WMMEDIASUBTYPE_MP4S         &&
             pmt -> formattype   == WMFORMAT_VideoInfo          &&
             pmt -> pbFormat                                    &&
             pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER) {

        pWMVideoInfoHeader = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) ;

        dwBitsPerFrame = pWMVideoInfoHeader -> bmiHeader.biWidth *
                         pWMVideoInfoHeader -> bmiHeader.biHeight *
                         (pWMVideoInfoHeader -> bmiHeader.biBitCount != 0 ? pWMVideoInfoHeader -> bmiHeader.biBitCount : 8) ;

        if (pWMVideoInfoHeader -> AvgTimePerFrame != 0) {
            //  WMSDK sports a 10 MHz clock as well, so use UNITS
            dwFramesPerSecond = (DWORD) (UNITS / pWMVideoInfoHeader -> AvgTimePerFrame) ;
        }
        else {
            dwFramesPerSecond = VBR_DEF_FPS ;
        }

        dwRet = dwBitsPerFrame * dwFramesPerSecond ;
    }
    //  ========================================================================
    //  wmv1
    else if (IsVideo (pmt)                                      &&
             pmt -> subtype      == WMMEDIASUBTYPE_WMV1         &&
             pmt -> formattype   == WMFORMAT_VideoInfo          &&
             pmt -> pbFormat                                    &&
             pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER) {

        pWMVideoInfoHeader = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) ;

        dwBitsPerFrame = pWMVideoInfoHeader -> bmiHeader.biWidth *
                         pWMVideoInfoHeader -> bmiHeader.biHeight *
                         (pWMVideoInfoHeader -> bmiHeader.biBitCount != 0 ? pWMVideoInfoHeader -> bmiHeader.biBitCount : 8) ;

        if (pWMVideoInfoHeader -> AvgTimePerFrame != 0) {
            //  WMSDK sports a 10 MHz clock as well, so use UNITS
            dwFramesPerSecond = (DWORD) (UNITS / pWMVideoInfoHeader -> AvgTimePerFrame) ;
        }
        else {
            dwFramesPerSecond = VBR_DEF_FPS ;
        }

        dwRet = dwBitsPerFrame * dwFramesPerSecond ;
    }
    //  ========================================================================
    //  fourcc
    else if (IsVideo (pmt)                                      &&
             pmt -> formattype   == WMFORMAT_VideoInfo          &&
             pmt -> pbFormat                                    &&
             pmt -> cbFormat     >= sizeof WMVIDEOINFOHEADER    &&
             IsFourCCVBR (reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) -> bmiHeader.biCompression)) {

        pWMVideoInfoHeader = reinterpret_cast <WMVIDEOINFOHEADER *> (pmt -> pbFormat) ;

        dwBitsPerFrame = pWMVideoInfoHeader -> bmiHeader.biWidth *
                         pWMVideoInfoHeader -> bmiHeader.biHeight *
                         (pWMVideoInfoHeader -> bmiHeader.biBitCount != 0 ? pWMVideoInfoHeader -> bmiHeader.biBitCount : 8) ;

        if (pWMVideoInfoHeader -> AvgTimePerFrame != 0) {
            //  WMSDK sports a 10 MHz clock as well, so use UNITS
            dwFramesPerSecond = (DWORD) (UNITS / pWMVideoInfoHeader -> AvgTimePerFrame) ;
        }
        else {
            dwFramesPerSecond = VBR_DEF_FPS ;
        }

        dwRet = dwBitsPerFrame * dwFramesPerSecond ;
    }
    //  ========================================================================
    //  other - default to avg
    else {
        dwRet = GetStreamAvgBitRate (pmt) ;
    }

    //  don't return 0; WMSDK faults with divide by 0 error
    return (dwRet > 0 ? dwRet : 1) ;
}

static
WCHAR *
GetWMStreamName (
    IN  LONG            lIndex,
    IN  AM_MEDIA_TYPE * pmt,
    IN  WCHAR *         achBuffer,
    IN  LONG            lBufferLen
    )
{
    int i ;

    i = _snwprintf (
                achBuffer,
                lBufferLen,
                L"%s (%d)",
                (pmt -> majortype == MEDIATYPE_Video ? WM_MEDIA_VIDEO_TYPE_NAME :
                 (pmt -> majortype == MEDIATYPE_Audio ? WM_MEDIA_AUDIO_TYPE_NAME : WM_MEDIA_DATA_TYPE_NAME
                  )
                 ),
                lIndex
                ) ;
    achBuffer [i] = L'\0' ;

    return achBuffer ;
}

static
WCHAR *
GetWMConnectionName (
    IN  LONG            lIndex,
    IN  AM_MEDIA_TYPE * pmt,
    IN  WCHAR *         achBuffer,
    IN  LONG            lBufferLen
    )
{
    int i ;

    i = _snwprintf (
                achBuffer,
                lBufferLen,
                L"%s Connection",
                GetWMStreamName (
                    lIndex,
                    pmt,
                    achBuffer,
                    lBufferLen
                    )
                ) ;

    achBuffer [i] = L'\0' ;

    return achBuffer ;
}

static
HRESULT
GetStreamMediaType (
    IN  IWMStreamConfig *   pIWMStreamConfig,
    OUT WM_MEDIA_TYPE **    ppWmt                   //  CoTaskMemFree to free
    )
{
    HRESULT         hr ;
    IWMMediaProps * pIWMMediaProps ;
    DWORD           dwSize ;
    BYTE *          pb ;

    ASSERT (ppWmt) ;
    ASSERT (pIWMStreamConfig) ;

    pb          = NULL ;
    (* ppWmt)   = NULL ;

    hr = pIWMStreamConfig -> QueryInterface (
            IID_IWMMediaProps,
            (void **) & pIWMMediaProps
            ) ;
    if (SUCCEEDED (hr)) {
        ASSERT (pIWMMediaProps) ;

        //  get the size
        hr = pIWMMediaProps -> GetMediaType (NULL, & dwSize) ;

        if (SUCCEEDED (hr)) {

            //  validate basic size
            if (dwSize >= sizeof WM_MEDIA_TYPE) {
                //  allocate
                pb = reinterpret_cast <BYTE *> (CoTaskMemAlloc (dwSize)) ;
                if (pb) {
                    //  and retrieve
                    hr = pIWMMediaProps -> GetMediaType ((WM_MEDIA_TYPE *) pb, & dwSize) ;

                    if (SUCCEEDED (hr)) {

                        //  set outgoing
                        (* ppWmt) = reinterpret_cast <WM_MEDIA_TYPE *> (pb) ;

                        //  is there a format block ?
                        if ((* ppWmt) -> cbFormat > 0) {
                            //  validate the size again; check at least that it's
                            //   bounded
                            if ((* ppWmt) -> cbFormat <= dwSize - sizeof WM_MEDIA_TYPE) {

                                //  set pbFormat member
                                (* ppWmt) -> pbFormat = pb + sizeof WM_MEDIA_TYPE ;
                            }
                            else {
                                hr = E_FAIL ;
                            }
                        }
                        else {
                            //  no format block exists
                            (* ppWmt) -> pbFormat = NULL ;
                        }
                    }
                }
            }
            else {
                //  size doesn't make sense
                hr = E_FAIL ;
            }
        }

        pIWMMediaProps -> Release () ;
    }

    //  if anything failed
    if (FAILED (hr)) {
        CoTaskMemFree (pb) ;
        (* ppWmt) = NULL ;
    }

    return hr ;
}

static
void
FreeWMMediaType (
    IN  WM_MEDIA_TYPE * pwmt
    )
{
    //
    //  don't free the pbFormat because we allocated a contiguous block of
    //   memory to hold it.. per the WMSDK instructions
    //

    if (pwmt -> pUnk) {
        pwmt -> pUnk -> Release () ;
    }

    CoTaskMemFree (pwmt) ;

    return ;
}

static
HRESULT
SetWMStreamMediaType (
    IN  IWMStreamConfig *   pIWMStreamConfig,
    IN  AM_MEDIA_TYPE *     pmt
    )
{
    HRESULT         hr ;
    IWMMediaProps * pIWMMediaProps ;
    WM_MEDIA_TYPE   Wmt ;

    ASSERT (pmt) ;
    ASSERT (pIWMStreamConfig) ;

    hr = DShowWMSDKHelpers::TranslateDShowToWM (
            pmt,
            & Wmt
            ) ;
    if (SUCCEEDED (hr)) {
        hr = pIWMStreamConfig -> QueryInterface (
                IID_IWMMediaProps,
                (void **) & pIWMMediaProps
                ) ;
        if (SUCCEEDED (hr)) {
            ASSERT (pIWMMediaProps) ;

            hr = pIWMMediaProps -> SetMediaType (& Wmt) ;

            pIWMMediaProps -> Release () ;
        }

        FreeMediaType (* (AM_MEDIA_TYPE *) & Wmt) ;
    }

    return hr ;
}

static
HRESULT
SetDSMediaType (
    IN  AM_MEDIA_TYPE *     pmt,
    IN  IWMStreamConfig *   pIWMStreamConfig
    )
{
    HRESULT         hr ;
    WM_MEDIA_TYPE * pWmt ;

    ASSERT (pmt) ;
    ASSERT (pIWMStreamConfig) ;

    hr = GetStreamMediaType (pIWMStreamConfig, & pWmt) ;
    if (SUCCEEDED (hr)) {
        ASSERT (pWmt) ;

        hr = DShowWMSDKHelpers::TranslateWMToDShow (
                pWmt,
                pmt
                ) ;

        FreeWMMediaType (pWmt) ;
    }

    return hr ;
}

static
BOOL
IsVBRStream (
    IN AM_MEDIA_TYPE * pmt
    )
{
    ASSERT (pmt) ;
    return (MinBitrate (pmt) != MaxBitrate (pmt) ? TRUE : FALSE) ;
}

static
HRESULT
SetVBRProps (
    IN  CMediaType *        pmt,
    IN  IWMStreamConfig *   pIWMStreamConfig
    )
{
    HRESULT             hr ;
    IWMPropertyVault *  pIVMPropertyVault ;
    BOOL                f ;
    DWORD               dwMin ;
    DWORD               dwMax ;
    DWORD               dwAvg ;

    ASSERT (pIWMStreamConfig) ;
    ASSERT (pmt) ;

    hr = pIWMStreamConfig -> QueryInterface (IID_IWMPropertyVault, (void **) & pIVMPropertyVault) ;
    if (SUCCEEDED (hr)) {

        f = TRUE ;
        hr = pIVMPropertyVault -> SetProperty (g_wszVBREnabled, WMT_TYPE_BOOL, (BYTE *) & f, sizeof BOOL) ;
        if (SUCCEEDED (hr)) {
            dwMin = MinBitrate (pmt) ;
            dwMax = MaxBitrate (pmt) ;
            dwAvg = GetStreamAvgBitRate (pmt) ;

            ASSERT (dwMin < dwMax) ;
            ASSERT (dwMin <= dwAvg && dwAvg <= dwMax) ;

            hr = pIVMPropertyVault -> SetProperty (g_wszVBRBitrateMax, WMT_TYPE_DWORD, (BYTE *) & dwMax, sizeof DWORD) ;
            if (SUCCEEDED (hr)) {
                hr = pIVMPropertyVault -> SetProperty (g_wszVBRBitrateAvg, WMT_TYPE_DWORD, (BYTE *) & dwAvg, sizeof DWORD) ;
            }
        }

        pIVMPropertyVault -> Release () ;
    }

    return hr ;
}

//  ============================================================================

CDVRWriterProfile::CDVRWriterProfile (
    IN  CDVRPolicy *        pPolicy,
    IN  const WCHAR *       szName,
    IN  const WCHAR *       szDescription,
    OUT HRESULT *           phr
    ) : m_pIWMProfile       (NULL),
        m_dwBufferWindow    (REG_DEF_WM_BUFFER_WINDOW)
{
    IWMProfileManager * pIWMProfileManager ;
    BOOL                r ;
    IWMPacketSize2 *    pWMPacketSize ;

    TRACE_CONSTRUCTOR (TEXT ("CDVRWriterProfile")) ;

    ASSERT (pPolicy) ;
    m_fInlineDShowProps     = pPolicy -> Settings () -> InlineDShowProps () ;
    m_fUseContinuityCounter = pPolicy -> Settings () -> UseContinuityCounter () ;
    m_dwBufferWindow        = pPolicy -> Settings () -> WMBufferWindowMillis () ;

    pIWMProfileManager = NULL ;

    (* phr) = WMCreateProfileManager (& pIWMProfileManager) ;
    if (FAILED (* phr)) { goto cleanup ; }

    ASSERT (pIWMProfileManager) ;
    (* phr) = pIWMProfileManager -> CreateEmptyProfile (
                WMSDK_COMPATIBILITY_VERSION,
                & m_pIWMProfile
                ) ;
    if (FAILED (* phr)) { goto cleanup ; }

    (* phr) = m_pIWMProfile -> SetName (szName) ;
    if (FAILED (* phr)) { goto cleanup ; }

    (* phr) = m_pIWMProfile -> SetDescription (szDescription) ;
    if (FAILED (* phr)) { goto cleanup ; }

    (* phr) = m_pIWMProfile -> QueryInterface (
                IID_IWMPacketSize2,
                (void **) & pWMPacketSize
                ) ;
    if (FAILED (* phr)) { goto cleanup ; }

    ( *phr) = pWMPacketSize -> SetMinPacketSize (pPolicy -> Settings () -> WMPacketSize ()) ;
    pWMPacketSize -> Release ();
    if (FAILED (* phr)) { goto cleanup ; }

    cleanup :

    RELEASE_AND_CLEAR (pIWMProfileManager) ;

    return ;
}

CDVRWriterProfile::CDVRWriterProfile (
    IN  CDVRPolicy *        pPolicy,
    IN  IWMProfile *        pIWMProfile,
    OUT HRESULT *           phr
    ) : m_pIWMProfile   (pIWMProfile)
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRWriterProfile")) ;

    ASSERT (m_pIWMProfile) ;
    m_pIWMProfile -> AddRef () ;
}

CDVRWriterProfile::~CDVRWriterProfile (
    )
{
    TRACE_DESTRUCTOR (TEXT ("CDVRWriterProfile")) ;

    RELEASE_AND_CLEAR (m_pIWMProfile) ;
}

HRESULT
CDVRWriterProfile::AddStream (
    IN  LONG            lIndex,
    IN  AM_MEDIA_TYPE * pmt
    )
{
    HRESULT             hr ;
    IWMStreamConfig *   pIWMStreamConfig ;
    IWMStreamConfig2 *  pIWMStreamConfig2 ;
    WCHAR               ach [64] ;
    CMediaType          mtCopy ;

    O_TRACE_ENTER_2 (
        TEXT ("CDVRWriterProfile::AddStream"),
        lIndex,
        pmt
        ) ;

    ASSERT (pmt) ;
    ASSERT (m_pIWMProfile) ;

    pIWMStreamConfig    = NULL ;
    pIWMStreamConfig2   = NULL ;

    //  copy the media type so we don't change the actual media type on the pin
    hr = CopyMediaType (& mtCopy, pmt) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  make sure media type is ok
    hr = DShowWMSDKHelpers::MediaTypeSetValidForWMSDK (& mtCopy) ;
    if (FAILED (hr)) { goto cleanup ; }

    hr = m_pIWMProfile -> CreateNewStream (WMStreamType (& mtCopy), & pIWMStreamConfig) ;
    if (FAILED (hr)) { goto cleanup ; }

    ASSERT (pIWMStreamConfig) ;

    hr = pIWMStreamConfig -> QueryInterface (IID_IWMStreamConfig2, (void **) & pIWMStreamConfig2) ;
    if (FAILED (hr)) { goto cleanup ; }

    ASSERT (pIWMStreamConfig2) ;

    hr = pIWMStreamConfig -> SetBufferWindow (m_dwBufferWindow) ;
    if (FAILED (hr)) { goto cleanup ; }

    if (!IsVBRStream (& mtCopy)) {
        hr = pIWMStreamConfig -> SetBitrate (GetStreamAvgBitRate (& mtCopy)) ;
        if (FAILED (hr)) { goto cleanup ; }
    }
    else {
        hr = SetVBRProps (& mtCopy, pIWMStreamConfig) ;
        if (FAILED (hr)) { goto cleanup ; }
    }

    hr = pIWMStreamConfig -> SetConnectionName (GetWMConnectionName (lIndex, & mtCopy, ach, sizeof ach / sizeof WCHAR)) ;
    if (FAILED (hr)) { goto cleanup ; }

    hr = pIWMStreamConfig -> SetStreamName (GetWMStreamName (lIndex, & mtCopy, ach, sizeof ach / sizeof WCHAR)) ;
    if (FAILED (hr)) { goto cleanup ; }

    hr = SetWMStreamMediaType (pIWMStreamConfig, & mtCopy) ;
    if (FAILED (hr)) { goto cleanup ; }

    hr = pIWMStreamConfig -> SetStreamNumber (DShowWMSDKHelpers::PinIndexToWMStreamNumber (lIndex)) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  ========================================================================
    //  INSSBuffer3 props

    //  dynamic format changes (dshow layer); 0xffff means arbitrary size
    hr = pIWMStreamConfig2 -> AddDataUnitExtension (INSSBuffer3Prop_DShowNewMediaType, 0xffff, NULL, 0) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  dshow properties
    hr = pIWMStreamConfig2 -> AddDataUnitExtension (INSSBuffer3Prop_DShowAttributes, sizeof INSSBUFFER3PROP_DSHOWATTRIB, NULL, 0) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  mpeg-2 - specific
    hr = DShowWMSDKHelpers::MaybeAddFormatSpecificExtensions (pIWMStreamConfig2, pmt) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  use a continuity counter - this allows us (for debugging purposes) to
    //   count what we write and check for missing packets on the way back out
    if (m_fUseContinuityCounter) {
        hr = pIWMStreamConfig2 -> AddDataUnitExtension (INSSBuffer3Prop_ContinuityCounter, sizeof DWORD, NULL, 0) ;
        if (FAILED (hr)) { goto cleanup ; }
    }

    //  finally: add it to the profile
    hr = m_pIWMProfile -> AddStream (pIWMStreamConfig) ;

    cleanup :

    RELEASE_AND_CLEAR (pIWMStreamConfig) ;
    RELEASE_AND_CLEAR (pIWMStreamConfig2) ;

    return hr ;
}

DWORD
CDVRWriterProfile::GetStreamCount (
    )
{
    DWORD   dwStreamCount ;
    HRESULT hr ;

    ASSERT (m_pIWMProfile) ;
    hr = m_pIWMProfile -> GetStreamCount (& dwStreamCount) ;
    if (FAILED (hr)) {
        dwStreamCount = 0 ;
    }

    return dwStreamCount ;
}

HRESULT
CDVRWriterProfile::DeleteStream (
    IN  LONG    lIndex
    )
{
    ASSERT (m_pIWMProfile) ;

    //
    //  BUGBUG
    //  what about an arbitrary profile that doesn't have contiguous
    //   stream numbers; should lIndex be the Nth stream, regardless
    //   of the stream numbers ???
    //

    return m_pIWMProfile -> RemoveStreamByNumber (DShowWMSDKHelpers::PinIndexToWMStreamNumber (lIndex)) ;
}

HRESULT
CDVRWriterProfile::GetStream (
    IN  LONG            lIndex,
    OUT CMediaType **   ppmt
    )
{
    HRESULT             hr ;
    IWMStreamConfig *   pIWMStreamConfig ;

    O_TRACE_ENTER_2 (
        TEXT ("CDVRWriterProfile::GetStream"),
        lIndex,
        ppmt
        ) ;

    ASSERT (ppmt) ;
    ASSERT (m_pIWMProfile) ;

    //
    //  BUGBUG
    //  what about an arbitrary profile that doesn't have contiguous
    //   stream numbers; should lIndex be the Nth stream, regardless
    //   of the stream numbers ???
    //

    hr = m_pIWMProfile -> GetStreamByNumber (
                DShowWMSDKHelpers::PinIndexToWMStreamNumber (lIndex),
                & pIWMStreamConfig
                ) ;
    if (SUCCEEDED (hr)) {

        (* ppmt) = new CMediaType ;
        if (* ppmt) {
            hr = SetDSMediaType ((* ppmt), pIWMStreamConfig) ;
            if (FAILED (hr)) {
                delete (* ppmt) ;
                (* ppmt) = NULL ;
            }
        }
        else {
            hr = E_OUTOFMEMORY ;
        }

        pIWMStreamConfig -> Release () ;
    }

    return hr ;
}


//  ============================================================================
//  ============================================================================

CDVRReaderProfile::CDVRReaderProfile (
    IN  CDVRPolicy *        pPolicy,
    IN  IDVRReader *        pIDVRReader,
    OUT HRESULT *           phr
    ) : m_lRef          (1),
        m_pIDVRReader   (pIDVRReader),
        m_pIWMProfile   (NULL),
        m_pPolicy       (pPolicy)
{
    ASSERT (phr) ;
    ASSERT (m_pIDVRReader) ;
    ASSERT (m_pPolicy) ;

    m_pPolicy -> AddRef () ;
    m_pIDVRReader -> AddRef () ;

    (* phr) = m_pIDVRReader -> GetProfile (& m_pIWMProfile) ;
}

CDVRReaderProfile::~CDVRReaderProfile (
    )
{
    ASSERT (m_pIDVRReader) ;

    if (m_pIWMProfile) {
        m_pIDVRReader -> ReleaseProfile (m_pIWMProfile) ;
    }

    m_pIDVRReader -> Release () ;
    m_pPolicy -> Release () ;
}

ULONG
CDVRReaderProfile::Release ()
{
    LONG    lRef ;

    lRef = InterlockedDecrement (& m_lRef) ;
    if (lRef == 0) {
        m_lRef = 1 ;
        delete this ;
        return 0 ;
    }

    ASSERT (lRef > 0) ;
    return lRef ;
}

HRESULT
CDVRReaderProfile::EnumWMStreams (
    OUT DWORD * pdwCount
    )
{
    HRESULT hr ;

    ASSERT (m_pIWMProfile) ;
    hr = m_pIWMProfile -> GetStreamCount (pdwCount) ;

    return hr ;
}

HRESULT
CDVRReaderProfile::GetStream (
    IN  DWORD           dwIndex,
    OUT WORD *          pwStreamNum,
    OUT AM_MEDIA_TYPE * pmt                 //  call FreeMediaType () on
    )
{
    HRESULT             hr ;
    IWMStreamConfig *   pIWMStreamConfig ;
    WM_MEDIA_TYPE *     pWmt ;
    WORD                cDataExtensions ;
    WORD                i ;
    GUID                guidExtensionSystemID ;
    WORD                cbExtensionDataSize ;
    BYTE                bExtensionSystemInfo ;
    DWORD               cbExtensionSystemInfo ;


    ASSERT (pwStreamNum) ;
    ASSERT (pmt) ;
    ASSERT (m_pIWMProfile) ;

    ASSERT (pmt -> pbFormat == NULL) ;
    ZeroMemory (pmt, sizeof AM_MEDIA_TYPE) ;

    pIWMStreamConfig    = NULL ;
    pWmt                = NULL ;

    //  ------------------------------------------------------------------------
    //  get the stream
    hr = m_pIWMProfile -> GetStream (
            dwIndex,
            & pIWMStreamConfig
            ) ;
    if (FAILED (hr)) { goto cleanup ; }

    ASSERT (pIWMStreamConfig) ;

    //  ------------------------------------------------------------------------
    //  stream media type
    hr = GetStreamMediaType (
            pIWMStreamConfig,
            & pWmt
            ) ;
    if (FAILED (hr)) { goto cleanup ; }

    //  ------------------------------------------------------------------------
    //  translate the media type up to dshow
    hr = DShowWMSDKHelpers::TranslateWMToDShow (pWmt, pmt) ;
    if (FAILED (hr)) {
        FreeMediaType (* pmt) ;
        goto cleanup ;
    }

    //  ------------------------------------------------------------------------
    //  stream number
    hr = pIWMStreamConfig -> GetStreamNumber (pwStreamNum) ;
    if (FAILED (hr)) { goto cleanup ; }

    cleanup :

    CoTaskMemFree (pWmt) ;
    RELEASE_AND_CLEAR (pIWMStreamConfig) ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\shared\bak\dvrpins.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrpins.h

    Abstract:

        This module contains the DVR filters' pin-related declarations.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef __tsdvr__shared__dvrpins_h
#define __tsdvr__shared__dvrpins_h

//  ============================================================================
//  ============================================================================

TCHAR *
CreateOutputPinName (
    IN  int     iPinIndex,
    IN  int     iBufferLen,
    OUT TCHAR * pchBuffer
    ) ;

TCHAR *
CreateInputPinName (
    IN  int     iPinIndex,
    IN  int     iBufferLen,
    OUT TCHAR * pchBuffer
    ) ;

//  ============================================================================
//  ============================================================================

class CIDVRPinConnectionEvents
{
    public :

        virtual
        HRESULT
        OnInputCheckMediaType (
            IN  int                 iPinIndex,
            IN  const CMediaType *  pmt
            ) = 0 ;

        virtual
        HRESULT
        OnInputCompleteConnect (
            IN  int iPinIndex
            ) = 0 ;

        virtual
        void
        OnInputBreakConnect (
            IN  int iPinIndex
            ) = 0 ;
} ;

//  ============================================================================
//  ============================================================================

class CIDVRDShowStream
{
    public :

        virtual
        HRESULT
        OnReceive (
            IN  int             iPinIndex,
            IN  IMediaSample *  pIMediaSample
            ) = 0 ;

        virtual
        HRESULT
        OnBeginFlush (
            IN  int iPinIndex
            ) = 0 ;

        virtual
        HRESULT
        OnEndFlush (
            IN  int iPinIndex
            ) = 0 ;

        virtual
        HRESULT
        OnEndOfStream (
            IN  int iPinIndex
            ) = 0 ;
} ;

//  ============================================================================
//  ============================================================================

class CDVRPin
{
    int         m_iBankStoreIndex ;     //  index into the holding bank
    CCritSec *  m_pLock ;
    CMediaType  m_mtDVRPin ;            //  if connected : == m_mt

    protected :

        CMediaType * GetMediaType_ ()   { return & m_mtDVRPin ; }

    public :

        CDVRPin (
            IN  CCritSec *  pLock
            ) : m_iBankStoreIndex   (UNDEFINED),
                m_pLock             (pLock)
        {
            ASSERT (m_pLock) ;

            m_mtDVRPin.InitMediaType () ;
            ASSERT (!m_mtDVRPin.IsValid ()) ;
        }

        virtual
        ~CDVRPin () {}

        //  --------------------------------------------------------------------
        //  class methods

        void SetBankStoreIndex (IN int iIndex)  { m_iBankStoreIndex = iIndex ; }
        int  GetBankStoreIndex ()               { return m_iBankStoreIndex ; }

        HRESULT
        SetPinMediaType (
            IN  AM_MEDIA_TYPE * pmt
            ) ;

        HRESULT
        GetPinMediaType (
            OUT AM_MEDIA_TYPE * pmt
            ) ;
} ;

//  ============================================================================
//  ============================================================================

template <class T>
class CTDVRPinBank
{
    enum {
        //  this our allocation unit i.e. pin pointers are allocated 1 block
        //   at a time and this is the block size
        PIN_BLOCK_SIZE = 5
    } ;

    TCNonDenseVector <CBasePin *>    m_Pins ;

    public :

        CTDVRPinBank (
            ) : m_Pins  (NULL,
                         PIN_BLOCK_SIZE
                         ) {}

        virtual
        ~CTDVRPinBank (
            ) {}

        int PinCount ()     { return m_Pins.ValCount () ; }

        T *
        GetPin (
            IN int iIndex
            )
        {
            DWORD       dw ;
            CBasePin *  pPin ;

            dw = m_Pins.GetVal (
                    iIndex,
                    & pPin
                    ) ;

            if (dw != NOERROR) {
                //  most likely out of range
                pPin = NULL ;
            }

            return reinterpret_cast <T *> (pPin) ;
        }

        HRESULT
        AddPin (
            IN  CBasePin *  pPin,
            IN  int         iPinIndex
            )
        {
            DWORD   dw ;

            dw = m_Pins.SetVal (
                    pPin,
                    iPinIndex
                    ) ;

            return HRESULT_FROM_WIN32 (dw) ; ;
        }

        HRESULT
        AddPin (
            IN  CBasePin *  pPin,
            OUT int *       piPinIndex
            )
        {
            DWORD   dw ;

            dw = m_Pins.AppendVal (
                    pPin,
                    piPinIndex
                    ) ;

            return HRESULT_FROM_WIN32 (dw) ; ;
        }
} ;

//  ============================================================================
//  ============================================================================

class CDVRInputPin :
    public CBaseInputPin,
    public CDVRPin
{
    CIDVRPinConnectionEvents *   m_pIPinEvent ;
    CIDVRDShowStream *      m_pIStream ;

    void Lock_ ()       { CBaseInputPin::m_pLock -> Lock () ;      }
    void Unlock_ ()     { CBaseInputPin::m_pLock -> Unlock () ;    }

    public :

        CDVRInputPin (
            IN  TCHAR *                 pszPinName,
            IN  CBaseFilter *           pOwningFilter,
            IN  CIDVRPinConnectionEvents *   pIPinEvent,
            IN  CIDVRDShowStream *      pIStream,
            IN  CCritSec *              pFilterLock,
            OUT HRESULT *               phr
            ) ;

        ~CDVRInputPin (
            ) ;

        //  --------------------------------------------------------------------
        //  CBasePin methods

        HRESULT
        CheckMediaType (
            IN  const CMediaType *
            ) ;

        virtual
        HRESULT
        CompleteConnect (
            IN  IPin *  pReceivePin
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class CDVROutputPin :
    public CBaseOutputPin,
    public CDVRPin
{
    void Lock_ ()       { CBaseOutputPin::m_pLock -> Lock () ;      }
    void Unlock_ ()     { CBaseOutputPin::m_pLock -> Unlock () ;    }

    public :

        CDVROutputPin (
            IN  TCHAR *         pszPinName,
            IN  CBaseFilter *   pOwningFilter,
            IN  CCritSec *      pFilterLock,
            OUT HRESULT *       phr
            ) ;

        ~CDVROutputPin (
            ) ;

        //  --------------------------------------------------------------------
        //  CBasePin methods

        HRESULT
        DecideBufferSize (
            IN  IMemAllocator *         pAlloc,
            IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
            ) ;

        HRESULT
        GetMediaType (
            IN  int             iPosition,
            OUT CMediaType *    pmt
            ) ;

        HRESULT
        CheckMediaType (
            IN  const CMediaType *
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class CDVRSinkPinManager :
    public CTDVRPinBank <CDVRInputPin>,
    public CIDVRPinConnectionEvents
{
    CIDVRDShowStream *          m_pIDVRDShowStream ;        //  set on pins we create
    CIDVRPinConnectionEvents *       m_pIDVRInputPinEvents ;     //  can be NULL
    CBaseFilter *               m_pOwningFilter ;           //  owning filter
    CCritSec *                  m_pLock ;                   //  owning filter lock

    void Lock_ ()       { m_pLock -> Lock () ; }
    void Unlock_ ()     { m_pLock -> Unlock () ; }

    HRESULT
    CreateNextInputPin_ (
        ) ;

    public :

        CDVRSinkPinManager (
            IN  CBaseFilter *           pOwningFilter,
            IN  CCritSec *              pLock,
            IN  CIDVRDShowStream *      pIDVRDShowStream,
            IN  CIDVRPinConnectionEvents *   pIDVRInputPinEvents     //  can be NULL
            ) ;

        virtual
        HRESULT
        OnInputCheckMediaType (
            IN  int                 iPinIndex,
            IN  const CMediaType *  pmt
            ) ;

        virtual
        HRESULT
        OnInputCompleteConnect (
            IN  int iPinIndex
            ) ;

        virtual
        void
        OnInputBreakConnect (
            IN  int iPinIndex
            ) ;
} ;

class CDVRSourcePinManager :
    public CTDVRPinBank <CDVROutputPin>
{
    CBaseFilter *   m_pOwningFilter ;
    CCritSec *      m_pLock ;

    void Lock_ ()           { m_pLock -> Lock () ;      }
    void Unlock_ ()         { m_pLock -> Unlock () ;    }

    public :

        CDVRSourcePinManager (
            IN  CBaseFilter *   pOwningFilter,
            IN  CCritSec *      pLock
            ) ;

        HRESULT
        CreateOutputPin (
            IN  int             iPinIndex,
            IN  AM_MEDIA_TYPE * pmt
            ) ;

        HRESULT
        Send (
            IN  IMediaSample *  pIMS,
            IN  int             iPinIndex
            ) ;
} ;

#endif  //  __tsdvr__shared__dvrpins_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\shared\bak\dvrpins.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrpins.cpp

    Abstract:

        This module contains the DVR filters' pin-related code.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#include "dvrall.h"

#include "dvrds.h"
#include "dvrpins.h"

//  ============================================================================
//  ============================================================================

static
TCHAR *
CreatePinName (
    IN  int             iPinIndex,
    IN  PIN_DIRECTION   PinDirection,
    IN  int             iBufferLen,
    OUT TCHAR *         pchBuffer
    )
{
    int i ;

    ASSERT (pchBuffer) ;
    ASSERT (iBufferLen >= 16) ;

    if (PinDirection == PINDIR_INPUT) {
        //  input
        i = _sntprintf (
                pchBuffer,
                iBufferLen,
                TEXT ("DVR In - %d"),
                iPinIndex
                ) ;
    }
    else {
        //  output
        i = _sntprintf (
                pchBuffer,
                iBufferLen,
                TEXT ("DVR Out - %d"),
                iPinIndex
                ) ;
    }

    //  make sure it's capped off
    pchBuffer [i] = TEXT ('\0') ;

    return pchBuffer ;
}

TCHAR *
CreateOutputPinName (
    IN  int     iPinIndex,
    IN  int     iBufferLen,
    OUT TCHAR * pchBuffer
    )
{
    return CreatePinName (
                iPinIndex,
                PINDIR_OUTPUT,
                iBufferLen,
                pchBuffer
                ) ;
}

TCHAR *
CreateInputPinName (
    IN  int     iPinIndex,
    IN  int     iBufferLen,
    OUT TCHAR * pchBuffer
    )
{
    return CreatePinName (
                iPinIndex,
                PINDIR_INPUT,
                iBufferLen,
                pchBuffer
                ) ;
}

//  ============================================================================
//  ============================================================================

HRESULT
CDVRPin::SetPinMediaType (
    IN  AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_0 (TEXT ("CDVRPin::SetPinMediaType ()")) ;

    ASSERT (pmt) ;

    m_pLock -> Lock () ;

    m_mtDVRPin = (* pmt) ;
    hr = S_OK ;

    m_pLock -> Unlock () ;

    return hr ;
}

HRESULT
CDVRPin::GetPinMediaType (
    OUT AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_0 (TEXT ("CDVRPin::GetPinMediaType ()")) ;

    ASSERT (pmt) ;

    m_pLock -> Lock () ;

    (* pmt) = m_mtDVRPin ;
    hr = S_OK ;

    m_pLock -> Unlock () ;

    return hr ;
}

//  ============================================================================
//  ============================================================================

CDVRInputPin::CDVRInputPin (
    IN  TCHAR *                 pszPinName,
    IN  CBaseFilter *           pOwningFilter,
    IN  CIDVRPinConnectionEvents *   pIPinEvent,
    IN  CIDVRDShowStream *      pIStream,
    IN  CCritSec *              pFilterLock,
    OUT HRESULT *               phr
    ) : CBaseInputPin   (NAME ("CDVRInputPin"),
                         pOwningFilter,
                         pFilterLock,
                         phr,
                         pszPinName
                         ),
        CDVRPin         (pFilterLock
                         ),
        m_pIPinEvent    (pIPinEvent),
        m_pIStream      (pIStream)
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRInputPin")) ;

    ASSERT (m_pIPinEvent) ;
    ASSERT (m_pIStream) ;

    if (FAILED (* phr)) {
        goto cleanup ;
    }

    cleanup :

    return ;
}

CDVRInputPin::~CDVRInputPin (
    )
{
    TRACE_DESTRUCTOR (TEXT ("CDVRInputPin")) ;
}

HRESULT
CDVRInputPin::CheckMediaType (
    IN  const CMediaType *  pmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_0 (TEXT ("CDVRInputPin::CheckMediaType ()")) ;

    ASSERT (m_pIPinEvent) ;
    hr = m_pIPinEvent -> OnInputCheckMediaType (
            GetBankStoreIndex (),
            pmt
            ) ;

    return hr ;
}

HRESULT
CDVRInputPin::CompleteConnect (
    IN  IPin *  pReceivePin
    )
{
    HRESULT hr ;
    int     i ;

    TRACE_ENTER_0 (TEXT ("CDVRInputPin::CompleteConnect ()")) ;

    hr = CBaseInputPin::CompleteConnect (pReceivePin) ;
    if (SUCCEEDED (hr)) {
        ASSERT (m_pIPinEvent) ;
        hr = m_pIPinEvent -> OnInputCompleteConnect (
                GetBankStoreIndex ()
                ) ;
    }

    return hr ;
}

//  ============================================================================
//  ============================================================================

CDVROutputPin::CDVROutputPin (
    IN  TCHAR *         pszPinName,
    IN  CBaseFilter *   pOwningFilter,
    IN  CCritSec *      pFilterLock,
    OUT HRESULT *       phr
    ) : CBaseOutputPin  (NAME ("CDVROutputPin"),
                         pOwningFilter,
                         pFilterLock,
                         phr,
                         pszPinName
                         ),
        CDVRPin         (pFilterLock
                         )
{
    TRACE_CONSTRUCTOR (TEXT ("CDVROutputPin")) ;

    if (FAILED (* phr)) {
        goto cleanup ;
    }

    cleanup :

    return ;
}

CDVROutputPin::~CDVROutputPin (
    )
{
    TRACE_DESTRUCTOR (TEXT ("CDVROutputPin")) ;
}

HRESULT
CDVROutputPin::DecideBufferSize (
    IN  IMemAllocator *         pAlloc,
    IN  ALLOCATOR_PROPERTIES *  ppropInputRequest
    )
{
    TRACE_ENTER_0 (TEXT ("CDVROutputPin::DecideBufferSize ()")) ;
    return S_OK ;
}

HRESULT
CDVROutputPin::CheckMediaType (
    IN  const CMediaType *  pmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_0 (TEXT ("CDVROutputPin::CheckMediaType ()")) ;

    Lock_ () ;

    hr = ((* GetMediaType_ ()) == (* pmt) ? S_OK : S_FALSE) ;

    Unlock_ () ;

    return hr ;
}

HRESULT
CDVROutputPin::GetMediaType (
    IN  int             iPosition,
    OUT CMediaType *    pmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_1 (
        TEXT ("CDVROutputPin::GetMediaType (%d)"),
        iPosition
        ) ;

    Lock_ () ;

    if (iPosition == 0) {
        (* pmt) = (* GetMediaType_ ()) ;
        hr = S_OK ;
    }
    else {
        hr = VFW_S_NO_MORE_ITEMS ;
    }

    Unlock_ () ;

    return hr ;
}

//  ============================================================================
//  ============================================================================

CDVRSinkPinManager::CDVRSinkPinManager (
    IN  CBaseFilter *           pOwningFilter,
    IN  CCritSec *              pLock,
    IN  CIDVRDShowStream *      pIDVRDShowStream,
    IN  CIDVRPinConnectionEvents *   pIDVRInputPinEvents     //  can be NULL
    ) : m_pIDVRDShowStream      (pIDVRDShowStream),
        m_pIDVRInputPinEvents   (pIDVRInputPinEvents),
        m_pLock                 (pLock),
        m_pOwningFilter         (pOwningFilter)
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRSinkPinManager")) ;

    CreateNextInputPin_ () ;
}

HRESULT
CDVRSinkPinManager::CreateNextInputPin_ (
    )
{
    TCHAR           achBuffer [16] ;
    CDVRInputPin *  pInputPin ;
    HRESULT         hr ;
    int             iBankIndex ;

    TRACE_ENTER_0 (TEXT ("CDVRSinkPinManager::CreateNextInputPin_ ()")) ;

    Lock_ () ;

    //  init
    pInputPin = NULL ;

    //  create the pin; we're appending, so pin name will be based on the
    //   number of pins in the bank
    pInputPin = new CDVRInputPin (
                        CreateInputPinName (
                            PinCount () + 1,                        //  don't 0-base names
                            sizeof (achBuffer) / sizeof (TCHAR),
                            achBuffer
                            ),
                        m_pOwningFilter,
                        this,                   //  events; we hook these always
                        m_pIDVRDShowStream,     //  stream events
                        m_pLock,
                        & hr
                        ) ;
    if (!pInputPin ||
        FAILED (hr)) {

        hr = (FAILED (hr) ? hr : E_OUTOFMEMORY) ;
        goto cleanup ;
    }

    //  add it to the bank
    hr = AddPin (
            pInputPin,
            & iBankIndex
            ) ;
    if (FAILED (hr)) {
        goto cleanup ;
    }

    //  set the pin's bank index
    pInputPin -> SetBankStoreIndex (iBankIndex) ;

    m_pOwningFilter -> IncrementPinVersion () ;

    cleanup :

    Unlock_ () ;

    if (FAILED (hr)) {
        delete pInputPin ;
    }

    return hr ;
}

HRESULT
CDVRSinkPinManager::OnInputCheckMediaType (
    IN  int                 iPinIndex,
    IN  const CMediaType *  pmt
    )
{
    HRESULT hr ;

    TRACE_ENTER_2 (
        TEXT ("CDVRSinkPinManager::OnInputCheckMediaType (%d, %08x)"),
        iPinIndex,
        pmt
        ) ;

    if (m_pIDVRInputPinEvents) {
        hr = m_pIDVRInputPinEvents -> OnInputCheckMediaType (iPinIndex, pmt) ;
    }
    else {
        //  all are welcome
        hr = S_OK ;
    }

    return hr ;
}

HRESULT
CDVRSinkPinManager::OnInputCompleteConnect (
    IN  int iPinIndex
    )
{
    HRESULT hr ;

    TRACE_ENTER_1 (
        TEXT ("CDVRSinkPinManager::OnInputCompleteConnect (%d)"),
        iPinIndex
        ) ;

    if (m_pIDVRInputPinEvents) {
        hr = m_pIDVRInputPinEvents -> OnInputCompleteConnect (iPinIndex) ;
    }
    else {
        hr = S_OK ;
    }

    //  sprout another iff the one that just connected was the last
    if (SUCCEEDED (hr)) {
        if (PinCount () - 1 == iPinIndex) {
            hr = CreateNextInputPin_ () ;
        }
    }

    return hr ;
}

void
CDVRSinkPinManager::OnInputBreakConnect (
    IN  int iPinIndex
    )
{
    TRACE_ENTER_1 (
        TEXT ("CDVRSinkPinManager::OnInputBreakConnect (%d)"),
        iPinIndex
        ) ;

    if (m_pIDVRInputPinEvents) {
        m_pIDVRInputPinEvents -> OnInputBreakConnect (iPinIndex) ;
    }

    return ;
}

//  ============================================================================
//  ============================================================================

CDVRSourcePinManager::CDVRSourcePinManager (
    IN  CBaseFilter *   pOwningFilter,
    IN  CCritSec *      pLock
    ) : m_pOwningFilter (pOwningFilter),
        m_pLock         (pLock)
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRSourcePinManager")) ;
}

HRESULT
CDVRSourcePinManager::CreateOutputPin (
    IN  int             iPinIndex,
    IN  AM_MEDIA_TYPE * pmt
    )
{
    TCHAR           achBuffer [16] ;
    CDVROutputPin * pOutputPin ;
    HRESULT         hr ;

    TRACE_ENTER_2 (
        TEXT ("CDVRSourcePinManager::CreateOutputPin (%d, %08xh)"),
        iPinIndex,
        pmt
        ) ;

    Lock_ () ;

    //  init
    pOutputPin = NULL ;

    //  create the pin; we're appending, so pin name will be based on the
    //   number of pins in the bank
    pOutputPin = new CDVROutputPin (
                        CreateOutputPinName (
                            iPinIndex + 1,          //  index is 0-based
                            sizeof (achBuffer) / sizeof (TCHAR),
                            achBuffer
                            ),
                        m_pOwningFilter,
                        m_pLock,
                        & hr
                        ) ;
    if (!pOutputPin ||
        FAILED (hr)) {

        hr = (FAILED (hr) ? hr : E_OUTOFMEMORY) ;
        goto cleanup ;
    }

    //  set the media type on the pin
    hr = pOutputPin -> SetPinMediaType (pmt) ;
    if (FAILED (hr)) {
        goto cleanup ;
    }

    //  add it to the bank
    hr = AddPin (
            pOutputPin,
            iPinIndex
            ) ;
    if (FAILED (hr)) {
        goto cleanup ;
    }

    //  set the pin's bank index
    pOutputPin -> SetBankStoreIndex (iPinIndex) ;

    //  success !
    m_pOwningFilter -> IncrementPinVersion () ;

    cleanup :

    Unlock_ () ;

    if (FAILED (hr)) {
        delete pOutputPin ;
    }

    return hr ;
}

HRESULT
CDVRSourcePinManager::Send (
    IN  IMediaSample *  pIMS,
    IN  int             iPinIndex
    )
{
    HRESULT hr ;

    TRACE_ENTER_2 (
        TEXT ("CDVRSourcePinManager::Send (%08xh, %d)"),
        pIMS,
        iPinIndex
        ) ;

    return E_NOTIMPL ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrio\dvrdebug.cpp ===
//------------------------------------------------------------------------------
// File: dvrDebug.cpp
//
// Description: Implements debugging functions.
//
// Copyright (c) 2000 - 2001, Microsoft Corporation.  All rights reserved.
//
//------------------------------------------------------------------------------

#include <precomp.h>
#pragma hdrstop

#if defined(DEBUG)

#define DVRIO_DUMP_THIS_FORMAT_STR ""
#define DVRIO_DUMP_THIS_VALUE

// Global variables
DWORD g_nDvrIopDbgCommandLineAssert = 0;
DWORD g_nDvrIopDbgInDllEntryPoint = 0;
DWORD g_nDvrIopDbgOutputLevel = 0; // Higher is more verbose
DWORD g_adwDvrIopDbgLevels[DVRIO_DBG_LEVEL_LAST_LEVEL] = {
    0,          // Internal error
    0,          // Client Error
    0,          // Internal Warning
    10          // Trace
};

// Debug registry key's value  names
static const WCHAR* g_awszDvrIopDbgLevelRegValueNames[] = {
    L"CommandLineAssert",
    L"DebugOutputLevel",
    L"InternalErrorLevel",
    L"ClientErrorLevel",
    L"InternalWarningLevel",
    L"TraceLevel"
};

static DWORD* g_apdwDvrIopDbgLevelVariables
        [sizeof(g_awszDvrIopDbgLevelRegValueNames)/sizeof(g_awszDvrIopDbgLevelRegValueNames[0])] = {
    &g_nDvrIopDbgCommandLineAssert,
    &g_nDvrIopDbgOutputLevel,
    &g_adwDvrIopDbgLevels[DVRIO_DBG_LEVEL_INTERNAL_ERROR_LEVEL],
    &g_adwDvrIopDbgLevels[DVRIO_DBG_LEVEL_CLIENT_ERROR_LEVEL],
    &g_adwDvrIopDbgLevels[DVRIO_DBG_LEVEL_INTERNAL_WARNING_LEVEL],
    &g_adwDvrIopDbgLevels[DVRIO_DBG_LEVEL_TRACE_LEVEL]
};

void DvrIopDbgInit(IN HKEY hRegistryDVRRootKey)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "DvrIopDbgInit"

    // Has no effect for the first call to this fn since we are
    // using default values for the levels. 
    DVRIO_TRACE_ENTER();

    static LONG g_nInit = -1;
    static HANDLE volatile g_hEvent = NULL;

    if (::InterlockedIncrement(&g_nInit))
    {
        // Already intialized
        ::InterlockedDecrement(&g_nInit);

        // It is not critical that we avoid race conditions here,
        // i.e., we suspend this thread until the thread that 
        // started executing this function first completes.

        DWORD dwRet;
        DWORD i = 0;
        while ((dwRet = ::WaitForSingleObject(g_hEvent, INFINITE)) != WAIT_OBJECT_0)
        {
            // Looks like the event hasn't yet been created, poll.
            DVR_ASSERT(dwRet == WAIT_FAILED && GetLastError() == ERROR_INVALID_HANDLE, "");
            ::Sleep(200);
            i += 1;
            if (i == 20)
            {
                // hmmm....
                DVR_ASSERT(0, "Waited too long ...");
                break;
            }
        }
        return;
    }

    // We never close this handle since we don't have a shutdown routine.
    // Also, we don't care if this fails, just go on
    g_hEvent = ::CreateEventW(NULL, TRUE, FALSE, NULL);
    DVR_ASSERT(g_hEvent, "Event creation failed?!");

    // Override default settings from registry
    DvrIopDbgInitFromRegistry(hRegistryDVRRootKey,
                              sizeof(g_awszDvrIopDbgLevelRegValueNames)/sizeof(g_awszDvrIopDbgLevelRegValueNames[0]),
                              g_awszDvrIopDbgLevelRegValueNames,
                              g_apdwDvrIopDbgLevelVariables);

    ::SetEvent(g_hEvent);

    DVRIO_TRACE_LEAVE0();
    
    return;

} // DvrIopDbgInit

// A lot of this lifted from DShow base classes

typedef struct 
{
    HWND  hwnd;
    PCHAR pszTitle;
    PCHAR pszMessage;
    DWORD dwFlags;
    DWORD iResult;
} DVRIO_DEBUG_MSG;

//
// create a thread to call MessageBox(). Calling MessageBox() on
// random threads at bad times can confuse the host app.
//
static DWORD WINAPI 
DvrIopMsgBoxThread(
    IN OUT LPVOID lpParameter
    )
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "DvrIopMsgBoxThread"

    DVRIO_DEBUG_MSG *pMsg = (DVRIO_DEBUG_MSG *)lpParameter;
    pMsg->iResult = MessageBoxA(pMsg->hwnd,
                                pMsg->pszTitle,
                                pMsg->pszMessage,
                                pMsg->dwFlags);
    
    return 0;
}

static DWORD
DvrIopMessageBoxOtherThread(
    IN  HWND  hwnd,
    IN  PCHAR pszTitle,
    IN  PCHAR pszMessage,
    IN  DWORD dwFlags
    )
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "DvrIopMessageBoxOtherThread"

    if(g_nDvrIopDbgInDllEntryPoint)
    {
        // can't wait on another thread because we have the loader
        // lock held in the dll entry point.
        return MessageBoxA(hwnd, pszTitle, pszMessage, dwFlags);
    }
    else
    {
        DVRIO_DEBUG_MSG msg = {hwnd, pszTitle, pszMessage, dwFlags, 0};
        DWORD dwid;
        HANDLE hThread;
        
        hThread = CreateThread(0,                      // security
                               0,                      // stack size
                               DvrIopMsgBoxThread,
                               (LPVOID) &msg,          // arg
                               0,                      // flags
                               &dwid);

        if(hThread)
        {
            WaitForSingleObject(hThread, INFINITE);
            CloseHandle(hThread);
            return msg.iResult;
        }

        // break into debugger on failure.
        return IDCANCEL;
    }
} // DvrIopMessageBoxOtherThread

void DvrIopDbgAssert(
    IN const PCHAR pszMsg,
    IN const PCHAR pszCondition,
    IN const PCHAR pszFileName,
    IN DWORD iLine,
    IN LPVOID pThis /* = NULL */,
    IN DWORD  dwThisId /* = 0 */
    )
{
    // RTL's DbgPrint takes only PCHAR arguments

    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "DvrIopDbgAssert"

    CHAR szInfo[512];
    int nRet;

    if (pThis)
    {
        CHAR szFormat[512];
        nRet = wsprintfA(szFormat, 
                         "%hs\n*** Assertion: \"%hs\" failed\nat line %u of %hs\n",
                         pszMsg, pszCondition, iLine, pszFileName);
        nRet = wsprintfA(szInfo, szFormat, pThis, dwThisId);
    }
    else
    {
        nRet = wsprintfA(szInfo, 
                         "%hs\n*** Assertion: \"%hs\" failed\nat line %u of %hs\n",
                         pszMsg, pszCondition, iLine, pszFileName);
    }

    DbgPrint(szInfo);

    if (g_nDvrIopDbgCommandLineAssert)
    {
        DebugBreak();
    }
    else
    {
        lstrcatA(szInfo, "\nContinue? (Cancel to debug)");

        DWORD MsgId = DvrIopMessageBoxOtherThread(NULL,
                                                  szInfo,
                                                  "DVR IO Assert Failed",
                                                  MB_SYSTEMMODAL | MB_ICONHAND |
                                                  MB_YESNOCANCEL | MB_SETFOREGROUND);
        switch (MsgId)
        {
          case IDNO:              /* Kill the application */

              FatalAppExitW(0, L"Application terminated");
              break;

          case IDCANCEL:          /* Break into the debugger */

              DebugBreak();
              break;

          case IDYES:             /* Ignore assertion continue execution */
              break;
        }
    }
} // DvrIopDbgAssert

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrfilters\shared\dvrprof.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrprof.h

    Abstract:

        This module contains the declarations for our DShow - WMSDK_Profiles
         layer.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef __tsdvr__shared__dvrprof_h
#define __tsdvr__shared__dvrprof_h

//  ============================================================================
//  CDVRWriterProfile
//  ============================================================================

class CDVRWriterProfile
{
    IWMProfile *    m_pIWMProfile ;
    BOOL            m_fInlineDShowProps ;
    BOOL            m_fUseContinuityCounter ;

    //  each stream has a buffering window; this is the time that is
    //   added to the timestamps, in the MUXing layer of the WMSDK; on
    //   the way back out, timestamps will be offset by this amount to
    //   provide a buffering time e.g. delta between transmission start
    //   time over network and rendering on the client;
    DWORD   m_dwBufferWindow ;

    public :

        CDVRWriterProfile (
            IN  CDVRPolicy *        pPolicy,
            IN  const WCHAR *       szName,
            IN  const WCHAR *       szDescription,
            OUT HRESULT *           phr
            ) ;

        CDVRWriterProfile (
            IN  CDVRPolicy *        pPolicy,
            IN  IWMProfile *        pIWMProfile,
            OUT HRESULT *           phr
            ) ;

        ~CDVRWriterProfile (
            ) ;

        HRESULT
        AddStream (
            IN  LONG            lIndex,
            IN  AM_MEDIA_TYPE * pmt
            ) ;

        HRESULT
        DeleteStream (
            IN  LONG    lIndex
            ) ;

        HRESULT
        GetStream (
            IN  LONG            lIndex,
            OUT CMediaType **   ppmt
            ) ;

        DWORD
        GetStreamCount (
            ) ;

        HRESULT
        GetRefdWMProfile (
            OUT IWMProfile **   ppIWMProfile
            )
        {
            HRESULT hr ;

            if (m_pIWMProfile) {
                (* ppIWMProfile) = m_pIWMProfile ;
                (* ppIWMProfile) -> AddRef () ;
                hr = S_OK ;
            }
            else {
                hr = E_UNEXPECTED ;
            }

            return hr ;
        }
} ;

//  ============================================================================
//  CDVRReaderProfile
//  ============================================================================

class CDVRReaderProfile
{
    LONG                m_lRef ;
    IWMProfile *        m_pIWMProfile ;
    IDVRReader *        m_pIDVRReader ;
    CDVRPolicy *        m_pPolicy ;

    public :

        CDVRReaderProfile (
            IN  CDVRPolicy *        pPolicy,
            IN  IDVRReader *        pIDVRReader,
            OUT HRESULT *           phr
            ) ;

        virtual
        ~CDVRReaderProfile (
            ) ;

        ULONG AddRef () { return InterlockedIncrement (& m_lRef) ; }
        ULONG Release () ;

        HRESULT
        EnumWMStreams (
            OUT DWORD *
            ) ;

        HRESULT
        GetStream (
            IN  DWORD           dwIndex,
            OUT WORD *          pwStreamNum,
            OUT AM_MEDIA_TYPE * pmt                 //  call FreeMediaType () on
            ) ;
} ;

#endif  //  __tsdvr__shared__dvrprof_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrio\dvriorecorder.cpp ===
//------------------------------------------------------------------------------
// File: dvrIORecorder.cpp
//
// Description: Implements the class CDVRRecorder
//
// Copyright (c) 2000 - 2001, Microsoft Corporation.  All rights reserved.
//
//------------------------------------------------------------------------------

#include <precomp.h>
#pragma hdrstop

#if defined(DEBUG)
DWORD CDVRRecorder::m_dwNextClassInstanceId = 0;
#define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
#define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
#endif


// ====== Constructor, destructor

CDVRRecorder::CDVRRecorder(IN CDVRRingBufferWriter*  pWriter,
                           IN  LPVOID                pWriterProvidedId,
                           OUT HRESULT*              phr)
    : m_pWriter(pWriter)
    , m_pWriterProvidedId(pWriterProvidedId)
    , m_cnsStartTime(MAXQWORD)  // Same default as ASF_RECORDER_NODE
    , m_cnsEndTime(MAXQWORD)  // Same default as ASF_RECORDER_NODE
    ,m_nRefCount(0)
#if defined(DEBUG)
    , m_dwClassInstanceId(InterlockedIncrement((LPLONG) &m_dwNextClassInstanceId))
#endif
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::CDVRRecorder"

    DVRIO_TRACE_ENTER();

    ::InitializeCriticalSection(&m_csLock);

    DVR_ASSERT(pWriter, "");

    m_pWriter->AddRef();

    if (phr)
    {
        *phr = S_OK;
    }

    DVRIO_TRACE_LEAVE0();
    return;

} // CDVRRecorder::CDVRRecorder

CDVRRecorder::~CDVRRecorder()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::~CDVRRecorder"

    DVRIO_TRACE_ENTER();

    HRESULT hr;

    if (m_cnsStartTime != MAXQWORD && m_cnsEndTime == MAXQWORD)
    {
        // StopRecording at the current time instant
        
        HRESULT hr;

        hr = m_pWriter->StopRecording(m_pWriterProvidedId, 0, TRUE);
        
        DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                        "Recording had not been stopped; stopped at \"now\"; "
                        "ring buffer writer returned hr = 0x%x",
                        hr);
    }

    hr = m_pWriter->DeleteRecorder(m_pWriterProvidedId);

    m_pWriter->Release();

    ::DeleteCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE0();

} // CDVRRecorder::~CDVRRecorder()


// ====== IUnknown

STDMETHODIMP CDVRRecorder::QueryInterface(IN  REFIID riid, 
                                          OUT void   **ppv)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::QueryInterface"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    if (!ppv || DvrIopIsBadWritePtr(ppv, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");        
        hrRet = E_POINTER;
    }
    else if (riid == IID_IUnknown)
    {        
        *ppv = (IUnknown*) this;
        hrRet = S_OK;
    }
    else if (riid == IID_IDVRRecorder)
    {        
        *ppv = (IDVRRecorder*) this;
        hrRet = S_OK;
    }
    else
    {
        *ppv = NULL;
        hrRet = E_NOINTERFACE;
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "no such interface");        
    }

    if (SUCCEEDED(hrRet))
    {
        ((IUnknown *) (*ppv))->AddRef();
    }

    DVRIO_TRACE_LEAVE1(hrRet);
    
    return hrRet;

} // CDVRRecorder::QueryInterface


STDMETHODIMP_(ULONG) CDVRRecorder::AddRef()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::AddRef"

    DVRIO_TRACE_ENTER();

    LONG nNewRef = InterlockedIncrement(&m_nRefCount);

    DVR_ASSERT(nNewRef > 0, 
               "m_nRefCount <= 0 after InterlockedIncrement");

    DVRIO_TRACE_LEAVE1(nNewRef);
    
    return nNewRef <= 0? 0 : (ULONG) nNewRef;

} // CDVRRecorder::AddRef


STDMETHODIMP_(ULONG) CDVRRecorder::Release()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::Release"

    DVRIO_TRACE_ENTER();

    LONG nNewRef = InterlockedDecrement(&m_nRefCount);

    DVR_ASSERT(nNewRef >= 0, 
              "m_nRefCount < 0 after InterlockedDecrement");

    if (nNewRef == 0) 
    {
        // Must call DebugOut before the delete because the 
        // DebugOut references this->m_dwClassInstanceId
        DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE, 
                        "Leaving, object *destroyed*, returning %u",
                        nNewRef);
        delete this;
    }
    else
    {
        DVRIO_TRACE_LEAVE1(nNewRef);
    }

    
    return nNewRef <= 0? 0 : (ULONG) nNewRef;

} // CDVRRecorder::Release


// ====== IDVRRecorder

STDMETHODIMP CDVRRecorder::StartRecording(IN QWORD cnsStartTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::StartRecording"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    ::EnterCriticalSection(&m_csLock);

    if (m_cnsStartTime != MAXQWORD)
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "recording started once before on this recorder instance");        
        hrRet = E_UNEXPECTED;
    }
    else
    {        
        hrRet = m_pWriter->StartRecording(m_pWriterProvidedId, cnsStartTime);
        
        if (SUCCEEDED(hrRet))
        {
            m_cnsStartTime = cnsStartTime;
        }
    }

    ::LeaveCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE1(hrRet);
    
    return hrRet;

} // CDVRRecorder::StartRecording

STDMETHODIMP CDVRRecorder::StopRecording(IN QWORD cnsStopTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::StopRecording"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    ::EnterCriticalSection(&m_csLock);

    if (m_cnsStartTime == MAXQWORD)
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "recording not started on this recorder instance");        
        hrRet = E_UNEXPECTED;
    }
    else if (m_cnsEndTime != MAXQWORD)
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "recording has been stopped on this recorder instance");        
        hrRet = E_UNEXPECTED;
    }
    else if (cnsStopTime <= m_cnsStartTime)
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "stop time must be > start time");        
        hrRet = E_INVALIDARG;
    }
    else
    {        
        hrRet = m_pWriter->StopRecording(m_pWriterProvidedId, cnsStopTime, FALSE);
        
        if (SUCCEEDED(hrRet))
        {
            m_cnsEndTime = cnsStopTime;
        }
    }

    ::LeaveCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE1(hrRet);
    
    return hrRet;

} // CDVRRecorder::StopRecording

STDMETHODIMP CDVRRecorder::CancelRecording()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::CancelRecording"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    ::EnterCriticalSection(&m_csLock);

    if (m_cnsStartTime == MAXQWORD)
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                        "recording not started on this recorder instance");        
        hrRet = E_UNEXPECTED;
    }
    else if (m_cnsEndTime == m_cnsStartTime)
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "recording has previously been cancelled on this recorder instance");        
        hrRet = E_UNEXPECTED;
    }
    else
    {        
        hrRet = m_pWriter->StopRecording(m_pWriterProvidedId, m_cnsStartTime, FALSE);
        
        if (SUCCEEDED(hrRet))
        {
            m_cnsEndTime = m_cnsStartTime;
        }
        else if (hrRet == E_INVALIDARG)
        {
            hrRet = E_UNEXPECTED;
        }
    }

    ::LeaveCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE1(hrRet);
    
    return hrRet;

} // CDVRRecorder::CancelRecording

STDMETHODIMP CDVRRecorder::GetRecordingStatus(OUT HRESULT* phResult OPTIONAL,
                                              OUT BOOL* pbStarted OPTIONAL,
                                              OUT BOOL* pbStopped OPTIONAL)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::GetRecordingStatus"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;
    BOOL pbSet;

    ::EnterCriticalSection(&m_csLock);

    hrRet = m_pWriter->GetRecordingStatus(m_pWriterProvidedId,
                                          phResult,
                                          m_cnsStartTime != m_cnsEndTime?  pbStarted : NULL,
                                          m_cnsStartTime != m_cnsEndTime?  pbStopped : NULL,
                                          &pbSet);


    if (SUCCEEDED(hrRet))
    {
        if (!pbSet && (pbStarted || pbStopped))
        {
            BOOL bStopped;

            if (m_cnsStartTime != m_cnsEndTime)
            {
                // Ring buffer writer did not set the values, so it must have
                // stopped writing. So the recording has been closed.
                bStopped = 1;
            }
            else
            {
                // Recording has not been started or has been cancelled
                bStopped = 0;
            }
            if (pbStarted)
            {
                *pbStarted = bStopped;
            }
            if (pbStopped)
            {
                *pbStopped = bStopped;
            }
        }
    }

    ::LeaveCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE1(hrRet);
    
    return hrRet;

} // CDVRRecorder::GetRecordingStatus

STDMETHODIMP CDVRRecorder::HasFileBeenClosed()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRecorder::HasFileBeenClosed"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    ::EnterCriticalSection(&m_csLock);

    hrRet = m_pWriter->HasRecordingFileBeenClosed(m_pWriterProvidedId);

    ::LeaveCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE1(hrRet);
    
    return hrRet;

} // CDVRRecorder::HasFileBeenClosed
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrio\dvriofilecollection.cpp ===
//------------------------------------------------------------------------------
// File: dvrIOFileCollection.cpp
//
// Description: Implements the class CDVRFileCollection
//
// Copyright (c) 2000 - 2001, Microsoft Corporation.  All rights reserved.
//
//------------------------------------------------------------------------------

#include <precomp.h>
#pragma hdrstop

LPCWSTR CDVRFileCollection::m_kwszDVRTempDirectory = L"TempDVR"; 

#if defined(DEBUG)
DWORD   CDVRFileCollection::m_dwNextClassInstanceId = 0;
#define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
#define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
#endif



// ====== Constructor, destructor

CDVRFileCollection::CDVRFileCollection(IN  DWORD       dwMaxTempFiles,
                                       IN  LPCWSTR     pwszDVRDirectory OPTIONAL,
                                       OUT QWORD**     ppcnsLastStreamTime OPTIONAL,
                                       OUT LONG**      ppnWriterHasClosedFile OPTIONAL,
                                       OUT HRESULT*    phr OPTIONAL)
    : m_dwMaxTempFiles(dwMaxTempFiles)
    , m_cnsStartTime(0)
    , m_cnsEndTime(0)
    , m_pwszTempFilePath(NULL)
    , m_pwszFilePrefix(NULL)
    , m_cnsLastStreamTime(0)
    , m_nNextFileId(DVRIOP_INVALID_FILE_ID + 1)
    , m_nRefCount(0)
#if defined(DEBUG)
    , m_dwClassInstanceId(InterlockedIncrement((LPLONG) &m_dwNextClassInstanceId))
#endif
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::CDVRFileCollection"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    if (dwMaxTempFiles > 0)
    {
        DVR_ASSERT(pwszDVRDirectory && !DvrIopIsBadStringPtr(pwszDVRDirectory), "");
    }
    else
    {
        DVR_ASSERT(!pwszDVRDirectory || !DvrIopIsBadStringPtr(pwszDVRDirectory), "");
    }
    DVR_ASSERT(!ppcnsLastStreamTime || !DvrIopIsBadWritePtr(ppcnsLastStreamTime, 0), "");
    DVR_ASSERT(!ppnWriterHasClosedFile || !DvrIopIsBadWritePtr(ppnWriterHasClosedFile, 0), "");
    DVR_ASSERT(!phr || !DvrIopIsBadWritePtr(phr, 0), "");

    BOOL bRemoveDirectory = 0;

    InitializeListHead(&m_leFileList);
    ::InitializeCriticalSection(&m_csLock);

    __try
    {
        HRESULT hr;

        // Must do this first since the client will Release it if the
        // constructor fails and we want Release() to call the destructor
        AddRef(); // on behalf of the creator of this object

        if (dwMaxTempFiles > 0)
        {
            m_pwszFilePrefix = new WCHAR[16];

            if (!m_pwszFilePrefix)
            {
                hrRet = E_OUTOFMEMORY;
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "alloc via new failed - m_pwszFilePrefix - WCHAR[16]");
                __leave;
            }
            wsprintf(m_pwszFilePrefix, L"DVRTmp%u_", ::GetCurrentProcessId());

            DWORD nLen = wcslen(pwszDVRDirectory);

            nLen += wcslen(m_kwszDVRTempDirectory) + sizeof(WCHAR);

            m_pwszTempFilePath = new WCHAR[nLen];

            if (!m_pwszTempFilePath)
            {
                hrRet = E_OUTOFMEMORY;
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "alloc via new failed - m_pwszTempFilePath - WCHAR[%u]",
                                nLen);
                __leave;
            }
            wsprintf(m_pwszTempFilePath, L"%s\\%s", pwszDVRDirectory, m_kwszDVRTempDirectory);

            if (!::CreateDirectoryW(m_pwszTempFilePath, NULL))
            {
                DWORD dwAttrib = ::GetFileAttributesW(m_pwszTempFilePath);
                if (dwAttrib == (DWORD) (-1))
                {
                    DWORD dwLastError = ::GetLastError();
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                    "::GetFileAttributesW of m_pwszTempFilePath failed; last error = 0x%x", 
                                    dwLastError);
                    hrRet = HRESULT_FROM_WIN32(dwLastError);
                   __leave; 
                }
                if ((dwAttrib & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY)
                {
                    DWORD dwLastError = ERROR_DIRECTORY;
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                    "m_pwszTempFilePath not a directory; last error = 0x%x (ERROR_DIRECTORY)", 
                                    dwLastError);
                    hrRet = HRESULT_FROM_WIN32(dwLastError);
                   __leave; 
                }
            }
            else
            {
                bRemoveDirectory = 1; // in case we have errors after this
            }
            // Ignore returned status
            ::SetFileAttributesW(m_pwszTempFilePath, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
        }

        hrRet = S_OK;
    }
    __finally
    {
        if (SUCCEEDED(hrRet))
        {
            if (ppcnsLastStreamTime)
            {
                *ppcnsLastStreamTime = &m_cnsLastStreamTime;
            }
            else
            {
                DVR_ASSERT(ppcnsLastStreamTime, 
                           "Parameter is not expected to be NULL for serious uses of this class!");
            }
            if (ppnWriterHasClosedFile)
            {
                *ppnWriterHasClosedFile = &m_nWriterHasBeenClosed;
            }
            else
            {
                DVR_ASSERT(ppnWriterHasClosedFile, 
                           "Parameter is not expected to be NULL for serious uses of this class!");
            }
        }
        else 
        {
            if (bRemoveDirectory)
            {
                ::RemoveDirectoryW(m_pwszTempFilePath);
            }
        }
        if (phr)
        {
            *phr = hrRet;
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return;

} // CDVRFileCollection::CDVRFileCollection

CDVRFileCollection::~CDVRFileCollection()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::~CDVRFileCollection"

    DVRIO_TRACE_ENTER();

    CFileInfo*   pFileInfo;
    LIST_ENTRY*  pCurrent = &m_leFileList;  

    while (NEXT_LIST_NODE(pCurrent) != &m_leFileList)
    {
        pCurrent = NEXT_LIST_NODE(pCurrent);
        pFileInfo = CONTAINING_RECORD(pCurrent, CFileInfo, leListEntry);

        DVR_ASSERT(pFileInfo->nReaderRefCount == 0,
                   "Reader ref count is not zero.");

        // This will remove the node from the list when 
        // DeleteUnusedInvalidFileNodes is called. If !bPermanentFile,
        // it will also cause the disk file to be deleted.
        pFileInfo->bWithinExtent = 0;
    }
    
    DWORD* pdwNumInvalidUndeletedTempFiles = NULL;

#if defined(DEBUG)
    DWORD dwNumInvalidUndeletedTempFiles;

    pdwNumInvalidUndeletedTempFiles = &dwNumInvalidUndeletedTempFiles;
#endif

    DeleteUnusedInvalidFileNodes(TRUE, pdwNumInvalidUndeletedTempFiles);

#if defined(DEBUG)
    if (dwNumInvalidUndeletedTempFiles > 0)
    {
        DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                        "Failed to delete %u temporary file%hs.",
                        dwNumInvalidUndeletedTempFiles,
                        dwNumInvalidUndeletedTempFiles == 1? "" : "s");
    }
#endif

    delete [] m_pwszFilePrefix;
    delete [] m_pwszTempFilePath;

    ::DeleteCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE0();

} // CDVRFileCollection::~CDVRFileCollection()


// ====== Refcounting

ULONG CDVRFileCollection::AddRef()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::AddRef"

    DVRIO_TRACE_ENTER();

    LONG nNewRef = InterlockedIncrement(&m_nRefCount);

    DVR_ASSERT(nNewRef > 0, 
               "m_nRefCount <= 0 after InterlockedIncrement");

    DVRIO_TRACE_LEAVE1(nNewRef);
    
    return nNewRef <= 0? 0 : (ULONG) nNewRef;

} // CDVRFileCollection::AddRef


ULONG CDVRFileCollection::Release()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::Release"

    DVRIO_TRACE_ENTER();

    LONG nNewRef = InterlockedDecrement(&m_nRefCount);

    DVR_ASSERT(nNewRef >= 0, 
              "m_nRefCount < 0 after InterlockedDecrement");

    if (nNewRef == 0) 
    {
        // Must call DebugOut before the delete because the 
        // DebugOut references this->m_dwClassInstanceId
        DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE, 
                        "Leaving, object *destroyed*, returning %u",
                        nNewRef);
        delete this;
    }
    else
    {
        DVRIO_TRACE_LEAVE1(nNewRef);
    }

    
    return nNewRef <= 0? 0 : (ULONG) nNewRef;

} // CDVRFileCollection::Release


// ====== Helper methods

void CDVRFileCollection::DeleteUnusedInvalidFileNodes(
    BOOL   bRemoveAllNodes,
    DWORD* pdwNumInvalidUndeletedTempFiles OPTIONAL)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::DeleteUnusedInvalidFileNodes"

    DVRIO_TRACE_ENTER();

    DVR_ASSERT(!pdwNumInvalidUndeletedTempFiles || 
               !DvrIopIsBadWritePtr(pdwNumInvalidUndeletedTempFiles, 0), 
               "pdwNumInvalidUndeletedTempFiles is a bad write pointer");

    DWORD dwNumUndeletedFiles = 0;
    CFileInfo*   pFileInfo;
    LIST_ENTRY*  pCurrent = &m_leFileList;  

    while (NEXT_LIST_NODE(pCurrent) != &m_leFileList)
    {
        pCurrent = NEXT_LIST_NODE(pCurrent);
        pFileInfo = CONTAINING_RECORD(pCurrent, CFileInfo, leListEntry);
        if (!pFileInfo->bPermanentFile && !pFileInfo->bWithinExtent &&
            pFileInfo->nReaderRefCount == 0)
        {
            DVR_ASSERT(pFileInfo->pwszName,
                       "File name is NULL?!");

            // Just remove the node. Temporary files are created to be deleted on close

            // if (!::DeleteFileW(pFileInfo->pwszName))
            // {
            //     DWORD dwLastError = ::GetLastError();
            // 
            //     if (dwLastError != ERROR_FILE_NOT_FOUND)
            //     {
            //         dwNumUndeletedFiles++;
            //         DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
            //                         "Could not delete file although reader ref count = 0, last error = 0x%x",
            //                         dwLastError);
            //         if (!bRemoveAllNodes)
            //         {
            //             // We leave the node as is; we will try the delete  again 
            //             // in subsequent calls to this function
            //             continue;
            //         }
            //     }
            //     // else file already deleted; remove the node
            // }
            // // else file has just been deleted, remove the node
        }
        else if (!pFileInfo->bWithinExtent && pFileInfo->nReaderRefCount == 0)
        {
            // Permanent file not within extent and has not reader; remove the node
            DVR_ASSERT(pFileInfo->bPermanentFile,"");
        }
        else if (!bRemoveAllNodes)
        {
            DVR_ASSERT(pFileInfo->bWithinExtent || pFileInfo->nReaderRefCount > 0, "");
            continue;
        }
        else
        {
            // bRemoveAllNodes is true, so this is a call from the destructor.
            // The destructor sets pFileInfo->bWithinExtent to 0. 
            // So pFileInfo->nReaderRefCount != 0. Assert this.

            DVR_ASSERT(pFileInfo->nReaderRefCount != 0, "");

            // Note that pFileInfo->nReaderRefCount != 0 is an 
            // error, but the destructor has already asserted
            // pFileInfo->nReaderRefCount == 0 to warn anyone 
            // debugging this.
        }

        // Remove the node.
        RemoveEntryList(pCurrent);
        pCurrent = PREVIOUS_LIST_NODE(pCurrent);

        delete pFileInfo;
    }

    if (pdwNumInvalidUndeletedTempFiles)
    {
        *pdwNumInvalidUndeletedTempFiles = dwNumUndeletedFiles;
    }
    
    DVRIO_TRACE_LEAVE0();
    
    return;

} // CDVRFileCollection::DeleteUnusedInvalidFileNodes


HRESULT CDVRFileCollection::UpdateTimeExtent()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::UpdateTimeExtent"

    DVRIO_TRACE_ENTER();

    HRESULT      hrRet;
    DWORD        dwNumTempFiles = m_dwMaxTempFiles;
    CFileInfo*   pFileInfo;
    LIST_ENTRY*  pCurrent = &m_leFileList;
    BOOL         bInExtent = TRUE;

    CFileInfo*   pStart = NULL;  // pointer to node that has the start time
    CFileInfo*   pEnd = NULL;    // pointer to node that has the end time
    
    while (PREVIOUS_LIST_NODE(pCurrent) != &m_leFileList)
    {
        pCurrent = PREVIOUS_LIST_NODE(pCurrent);
        pFileInfo = CONTAINING_RECORD(pCurrent, CFileInfo, leListEntry);

        if (!bInExtent)
        {
            pFileInfo->bWithinExtent = FALSE;
            continue;
        }
        if (pFileInfo->cnsStartTime == pFileInfo->cnsEndTime && 
            pFileInfo->cnsStartTime != MAXQWORD)
        {
            // Regardless of bInExtent, this node is not in the
            // ring buffer's extent
            pFileInfo->bWithinExtent = FALSE;
            continue;
        }
        if (!pEnd)
        {
            pEnd = pFileInfo;
        }
        if (dwNumTempFiles || pFileInfo->bPermanentFile)
        {
            pStart = pFileInfo;
        }
        if (!pFileInfo->bPermanentFile)
        {
            if (dwNumTempFiles)
            {
                dwNumTempFiles--;
            }
            else 
            {
                // We have found one more temp file than 
                // m_dwMaxTempFiles. The next node is the 
                // start of the ring buffer's extent

                bInExtent = FALSE;

                // Go through rest of nodes in the list and 
                // set their bWithinExtent to FALSE.
            }
        }
        else
        {
            // Permanent files extend the extent of the ring buffer extent
            // Nothing to do except to update the bWithinExtent member
        }
        pFileInfo->bWithinExtent = bInExtent;
    }
    if (!pEnd || !pStart) 
    {
        DVR_ASSERT(pEnd == NULL && pStart == NULL, 
                   "Found one but not the other?!");

        m_cnsStartTime = m_cnsEndTime = 0;
        hrRet = S_FALSE;
    }
    else
    {
        m_cnsStartTime = pStart->cnsStartTime;
        m_cnsEndTime = pEnd->cnsEndTime;
        DVR_ASSERT((m_cnsStartTime < m_cnsEndTime) || 
                   (m_cnsStartTime == m_cnsEndTime && m_cnsStartTime == MAXQWORD),
                   "");
        hrRet = S_OK;
    }

    DVRIO_TRACE_LEAVE0();
    
    return hrRet;

} // CDVRFileCollection::UpdateTimeExtent

// ====== Public methods intended for the writer

HRESULT CDVRFileCollection::Lock()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::Lock"

    DVRIO_TRACE_ENTER();

    ::EnterCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE1_HR(S_OK);
    
    return S_OK;

} // CDVRFileCollection::Lock

HRESULT CDVRFileCollection::Unlock()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::Unlock"

    DVRIO_TRACE_ENTER();

    ::LeaveCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE1_HR(S_OK);
    
    return S_OK;

} // CDVRFileCollection::Unlock

HRESULT CDVRFileCollection::AddFile(IN OUT LPWSTR*      ppwszFileName OPTIONAL, 
                                    IN QWORD            cnsStartTime,
                                    IN QWORD            cnsEndTime,
                                    IN BOOL             bPermanentFile,
                                    OUT QWORD**         ppcnsFirstSampleTimeOffsetFromStartOfFile OPTIONAL,
                                    OUT DVRIOP_FILE_ID* pnFileId)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::AddFile"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = S_OK;

    if (!ppwszFileName || !pnFileId || DvrIopIsBadWritePtr(pnFileId, 0) ||
        (*ppwszFileName && DvrIopIsBadStringPtr(*ppwszFileName)) ||
        (*ppcnsFirstSampleTimeOffsetFromStartOfFile && DvrIopIsBadWritePtr(ppcnsFirstSampleTimeOffsetFromStartOfFile, 0)) ||
        cnsStartTime > cnsEndTime ||
        (cnsStartTime == cnsEndTime && cnsStartTime != MAXQWORD)
       )
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }
    
    DWORD dwLastError = 0;
    WCHAR* pwszFileName = NULL;
    BOOL bDeleteFile = 0;   // If non-zero, we must delete pwszFileName on error return
    BOOL bFree = 0; // If non-zero, delete *ppwzsFileName and reset it to NULL on error return

    if (*ppwszFileName)
    {
        // We have been supplied a file name 

        DWORD nLen;
        BOOL bRet = 0; // Return after the __finally block
        
        __try
        {
            // Get fully qualified name of file.
            WCHAR wTempChar;

            nLen = ::GetFullPathNameW(*ppwszFileName, 0, &wTempChar, NULL);
            if (nLen == 0)
            {
                dwLastError = ::GetLastError();
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                                "First GetFullPathNameW failed, nLen = %u, last error = 0x%x",
                                nLen, dwLastError);
                __leave;
            }

            pwszFileName = new WCHAR[nLen+1];

            if (!pwszFileName)
            {
                hrRet = E_OUTOFMEMORY;
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, "alloc via new failed - WCHAR[%u]", nLen+1);
                __leave;
            }

            nLen = ::GetFullPathNameW(*ppwszFileName, nLen+1, pwszFileName, NULL);
            if (nLen == 0)
            {
                dwLastError = ::GetLastError();
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                                "Second GetFullPathNameW failed, nLen = %u, last error = 0x%x",
                                nLen, dwLastError);
                __leave;
            }

            // Verify file is on an NTFS partition @@@@@ any need to do this??
            // @@@@ todo
        }
        __finally
        {
            if (hrRet != S_OK || dwLastError != 0)
            {
                if (dwLastError != 0)
                {
                    hrRet = HRESULT_FROM_WIN32(dwLastError);
                }
                DVRIO_TRACE_LEAVE1_HR(hrRet);
                delete [] pwszFileName;
                bRet = 1;
            }
        }
        if (bRet)
        {
            return hrRet;
        }
    }
    else
    {
        // We have to generate a temp file name 

        DWORD nRet;
        BOOL bRet = 0; // Return after the __finally block

        __try
        {
            pwszFileName = new WCHAR[MAX_PATH+1];

            if (!pwszFileName)
            {
                hrRet = E_OUTOFMEMORY;
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, "alloc via new failed - WCHAR[MAX_PATH+1]");
                __leave;
            }

            // If this call succeeds, it creates the file. We need this feature so that 
            // the generated file name is not reused till the ASF BeginWriting call is
            // issued.
            //
            // The file sink (and the DVR file sink) just overwrites the file it exists. That
            // would be ideal. Else, client will have to delete file, opening a window
            // for this function to generate a file name that has already been assigned.
            
            DVR_ASSERT(m_pwszTempFilePath, "Temp file being created but m_pwszTempFilePath was not initialized?!");
            DVR_ASSERT(m_pwszFilePrefix, "Temp file being created but m_pwszFilePrefix was not initialized?!");

            nRet = ::GetTempFileNameW(m_pwszTempFilePath, m_pwszFilePrefix, 0, pwszFileName);
            if (nRet == 0)
            {
                dwLastError = ::GetLastError();
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                                "GetTempFileNameW failed, last error = 0x%x",
                                dwLastError);
                __leave;
            }
            bDeleteFile = 1;

            ::SetFileAttributesW(pwszFileName, FILE_ATTRIBUTE_NOT_CONTENT_INDEXED | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
	    

            // Copy file name to output param; we will undo this if 
            // the function fails (but not if it returns S_FALSE)

            WCHAR* pwszName = new WCHAR[wcslen(pwszFileName) + 1];
            if (pwszFileName)
            {
                wcscpy(pwszName, pwszFileName);
                *ppwszFileName = pwszName; 
                bFree = 1;
            }
            else
            {
                hrRet = E_OUTOFMEMORY;
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, "alloc via new failed - WCHAR[%u]", wcslen(pwszFileName)+1);
                __leave;
            }
        }
        __finally
        {
            if (hrRet != S_OK || dwLastError != 0)
            {
                if (dwLastError != 0)
                {
                    hrRet = HRESULT_FROM_WIN32(dwLastError);
                }
                DVRIO_TRACE_LEAVE1_HR(hrRet);
                delete [] pwszFileName;

                if (bFree)
                {
                    // Not really necessary since this was the last thing we tried
                    delete [] (*ppwszFileName);
                    *ppwszFileName = NULL;
                }
                bRet = 1;
            }
        }
        if (bRet)
        {
            return hrRet;
        }
    }

    ::EnterCriticalSection(&m_csLock);

    DVR_ASSERT(dwLastError == 0, "");
    hrRet = E_FAIL;

    CFileInfo*   pFileInfo;
    CFileInfo*   pNewNode = NULL;
    LIST_ENTRY*  pCurrent = &m_leFileList;  

    __try
    {
        // Verify that start, end times do not overlap start/end times
        // of other nodes in the list and find the insertion point

        BOOL bFound = 0;

        while (NEXT_LIST_NODE(pCurrent) != &m_leFileList)
        {
            pCurrent = NEXT_LIST_NODE(pCurrent);
            pFileInfo = CONTAINING_RECORD(pCurrent, CFileInfo, leListEntry);
            if (pFileInfo->cnsEndTime == pFileInfo->cnsStartTime &&
                pFileInfo->cnsEndTime != MAXQWORD)
            {
                // Don't consider this node for comparisons.
                // It's not within the extent anyway.

                // Nodes whose start time != end time are in sorted order
                // Nodes whose start time == end time can appear anywhere
                // in the list and are ignored
                continue;
            }
            if (cnsEndTime <= pFileInfo->cnsStartTime)
            {
                // All ok; we should insert before pCurrent
                bFound = 1;
                break;
            }
            if (cnsStartTime >= pFileInfo->cnsEndTime)
            {
                // Keep going on
                continue;
            }
            // Trouble
            DVR_ASSERT(cnsStartTime < pFileInfo->cnsEndTime && cnsEndTime > pFileInfo->cnsStartTime,
                       "Overlapped insert assertion failure?!");
            DvrIopDebugOut4(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "Overlapped insert! Input params: start time: %I64u, end time: %I64u\n"
                            "overlap node values: start time: %I64u, end time: %I64u",
                            cnsStartTime, cnsEndTime, pFileInfo->cnsStartTime, pFileInfo->cnsEndTime);
            __leave;
        }

        // We are ready to insert. We set bWithinTimeExtent to 1 in the constructor,
        // we'll revise this after we insert if needed. Note that we might insert
        // the file and then immediately delete the node (and the file if it is a temp file).
        // This will happen if:
        // - if the file is a permanent file, it is not extending the ring buffer's time extent,
        //   i.e., there is a temp invalid file between the inserted file and the first valid
        //   file in the ring buffer
        // - if the file is a temp file, as for the permanent file condition above, OR if the
        //   ring buffer has max files already and the inserted file's time extent falls 
        //   below the ring buffer's time extent
        // Inserting and then deleting is wasted work, but the code
        // is simpler this way and we won't hit this case because files added by the writer
        // will usually be added beyond the current write time. We return S_FALSE 
        // if we insert and delete right away..
        pNewNode = new CFileInfo(pwszFileName, cnsStartTime, cnsEndTime, bPermanentFile, m_nNextFileId, 1);
        if (!pNewNode)
        {
            hrRet = E_OUTOFMEMORY;
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, "alloc via new failed - CFileInfo");
            __leave;
        }
        pwszFileName = NULL; // since pNewNode holds it and we don't want to delete both on error!

        m_nNextFileId++;

        if (!bFound)
        {
            // We insert at tail
            pCurrent = NEXT_LIST_NODE(pCurrent);;
            DVR_ASSERT(pCurrent == &m_leFileList, "");
        }
        InsertTailList(pCurrent, &(pNewNode->leListEntry));

        // Update the ring buffer's extent
        UpdateTimeExtent();

        if (pNewNode->bWithinExtent)
        {
            hrRet = S_OK;
        }
        else
        {
            // The file we added is not within the time extent of the ring buffer
            hrRet = S_FALSE;
            // Unsafe to use pNewNode after the call to DeleteUnusedInvalidFileNodes
            pNewNode = NULL;
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                "Added file is not in ring buffer extent and has been deleted from ring buffer.");
        }

        //  Delete files if necessary
        DeleteUnusedInvalidFileNodes(FALSE, NULL);
    }
    __finally
    {
        // Note: we can return S_FALSE as described above.
     
        if (FAILED(hrRet) || dwLastError != 0)
        {
            ::LeaveCriticalSection(&m_csLock);
            if (bDeleteFile)
            {
                ::DeleteFileW(pwszFileName);
            }
            if (bFree)
            {
                delete [] (*ppwszFileName);
                *ppwszFileName = NULL;
            }

            delete [] pwszFileName;
            delete pNewNode;
            if (dwLastError != 0)
            {
                hrRet = HRESULT_FROM_WIN32(dwLastError);
            }
        }
        else if (hrRet != S_FALSE)
        {
            // No sense doing this if we deleted the just inserted node.

            *pnFileId = pNewNode->nFileId; 
            if (ppcnsFirstSampleTimeOffsetFromStartOfFile)
            {
                *ppcnsFirstSampleTimeOffsetFromStartOfFile = &pNewNode->cnsFirstSampleTimeOffsetFromStartOfFile;
            }

            // We hold the lock till here since we don't want the 
            // node deleted by some other caller.
            ::LeaveCriticalSection(&m_csLock);
        }
        else
        {
            // hrRet == S_FALSE
            ::LeaveCriticalSection(&m_csLock);
            if (bFree)
            {
                delete [] (*ppwszFileName);
                *ppwszFileName = NULL;
            }
            // Disk file would have been deleted in the call to DeleteUnusedInvalidFileNodes
            // (unless bPermanent was specified, in which case we don't create it.)
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRFileCollection::AddFile

HRESULT CDVRFileCollection::SetFileTimes(IN DWORD dwNumElements, 
                                         IN PDVRIOP_FILE_TIME pFileTimesParam)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::SetFileTimes"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;
    DWORD  i;
    PDVRIOP_FILE_TIME pFileTimes;

    if (!dwNumElements || !pFileTimesParam || 
        DvrIopIsBadReadPtr(pFileTimesParam, dwNumElements*sizeof(DVRIOP_FILE_TIME))
       )
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }
    for (i = 0; i < dwNumElements; i++)
    {
        if (pFileTimesParam[i].cnsStartTime > pFileTimesParam[i].cnsEndTime)
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "bad input argument: start time exceeds end time at index %u", i);
            DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
            return E_INVALIDARG;
        }
    }

    pFileTimes = (PDVRIOP_FILE_TIME) _alloca(dwNumElements*sizeof(DVRIOP_FILE_TIME));
    if (pFileTimes == NULL)
    {
        DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                        "alloca failed - %u bytes", 
                        dwNumElements*sizeof(DVRIOP_FILE_TIME));

        return E_OUTOFMEMORY; // out of stack space
    }
    
    ::EnterCriticalSection(&m_csLock);

    hrRet = E_FAIL;

    CFileInfo*   pFileInfo;
    LIST_ENTRY*  pCurrent = &m_leFileList;  

    i = 0;
    __try
    {
        // Verify that start, end times do not overlap start/end times
        // of other nodes in the list and find the insertion point

        QWORD cnsPrevEndTime = 0;

        // It's easy for the writer (the client of this function) to create the input 
        // argument so that the file ids in the argument are in the same order as 
        // file ids in the file collection. This simplifies the code in this function,
        // so we fail the call if this assumption is violated.

        while (i < dwNumElements && NEXT_LIST_NODE(pCurrent) != &m_leFileList)
        {
            pCurrent = NEXT_LIST_NODE(pCurrent);
            pFileInfo = CONTAINING_RECORD(pCurrent, CFileInfo, leListEntry);
            if (pFileInfo->cnsEndTime == pFileInfo->cnsStartTime &&
                pFileInfo->cnsEndTime != MAXQWORD)
            {
                // Don't consider this node for comparisons.
                // It's not within the extent anyway.

                // Nodes whose start time != end time are in sorted order
                // Nodes whose start time == end time can appear anywhere
                // in the list and are ignored

                // Note that if a file id refers to this node, the call
                // will fail. This is what we want.
                continue;
            }
            if (pFileInfo->nFileId == pFileTimesParam[i].nFileId)
            {
                // Save away the original values in case we have to undo
                pFileTimes[i].nFileId = pFileInfo->nFileId;
                pFileTimes[i].cnsStartTime = pFileInfo->cnsStartTime;
                pFileTimes[i].cnsEndTime = pFileInfo->cnsEndTime;

                pFileInfo->cnsStartTime = pFileTimesParam[i].cnsStartTime;
                pFileInfo->cnsEndTime = pFileTimesParam[i].cnsEndTime;
                i++;
            }
            // The list must remain sorted by file time,
            
            if (pFileInfo->cnsStartTime == pFileInfo->cnsEndTime)
            {
                // This will happen if pFileTimes[i-1].cnsStartTime
                // == pFileTimes[i-1].cnsEndTime. If we don't add this 
                // check here. the caller has a workaround; however this
                // makes it easier for him.

                // This node is going to be marked invalid anyway,    
                // Don't consider it and don't update cnsPrevEndTime
                continue;

            }
            else if (pFileInfo->cnsStartTime < cnsPrevEndTime) 
            {
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                                "Order of nodes in file collection changes.");
                hrRet = E_INVALIDARG;
                break;
            }

            cnsPrevEndTime = pFileInfo->cnsEndTime;
        }
        // Note: Do NOT change i after this. It is used in the 
        // __finally section

        if (hrRet == E_INVALIDARG)
        {
            __leave;
        }
        else if (i == dwNumElements)
        {
            // We haven't advanced pCurrent to the next node
            // Note that we have ensured that dwNumElements > 0, so i > 0
            // so we must have entered the while loop.
            DVR_ASSERT(pCurrent != &m_leFileList, "");

            pCurrent = NEXT_LIST_NODE(pCurrent);
            
            // Verify that the last node whose time we changed has
            // times less than the node following it.
            if (pCurrent != &m_leFileList)
            {
                pFileInfo = CONTAINING_RECORD(pCurrent, CFileInfo, leListEntry);
                if (pFileInfo->cnsStartTime < cnsPrevEndTime)
                {
                    DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                                    "Order of nodes in file collection changes.");
                    hrRet = E_INVALIDARG;
                    __leave;
                }
            }
        }
        else // (hrRet != E_INVALIDARG && i < dwNumElements)
        {
            // We ran out of nodes in the file collection before
            // we processed all the inputs. Either some file id in the
            // input is not in the collection or the order of file ids
            // in the input and the collection are different.

            pCurrent = NEXT_LIST_NODE(&m_leFileList);
            while (pCurrent != &m_leFileList)
            {
                pFileInfo = CONTAINING_RECORD(pCurrent, CFileInfo, leListEntry);
                if (pFileInfo->nFileId == pFileTimesParam[i].nFileId)
                {
                    break;
                }
                pCurrent = NEXT_LIST_NODE(pCurrent);
            }
            if (pCurrent != &m_leFileList)
            {
                // File id in input is not in the collection
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                                "file id %u specified in input param list is not in file collection.", 
                                pFileTimesParam[i].nFileId);
                hrRet = E_INVALIDARG;
            }
            else
            {
                // Order of file ids different

                DVR_ASSERT(0,
                    "Input file list param does not have file ids in same order as file collection.");
                hrRet = E_FAIL;
            }
            __leave;
        }

        // Success! Update the file collection's extent.
        // UpdateTimeExtent() returns either S_OK or S_FALSE
        // and that's what we want to return
        hrRet = UpdateTimeExtent();

        // Delete files if necessary. Files are not likely to be deleted
        // unless start time == end time was specified for some file in 
        // the input
        DeleteUnusedInvalidFileNodes(FALSE, NULL);
    }
    __finally
    {
        // Note: we can return S_FALSE
     
        if (FAILED(hrRet))
        {
            // Undo any changes we made

            DWORD j = 0;
            
            pCurrent = &m_leFileList;
            while (j < i && NEXT_LIST_NODE(pCurrent) != &m_leFileList)
            {
                pCurrent = NEXT_LIST_NODE(pCurrent);
                pFileInfo = CONTAINING_RECORD(pCurrent, CFileInfo, leListEntry);
                if (pFileInfo->nFileId == pFileTimes[j].nFileId)
                {
                    // Restore the original values
                    pFileInfo->cnsStartTime = pFileTimes[j].cnsStartTime;
                    pFileInfo->cnsEndTime = pFileTimes[j].cnsEndTime;
                    j++;
                }
            }
            DVR_ASSERT(j == i, "Irrecoverable failure! Could not restore");
            if (j != i)
            {
                hrRet = E_FAIL;
            }
        }

        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRFileCollection::SetFileTimes

HRESULT CDVRFileCollection::SetMappingHandles(IN DVRIOP_FILE_ID   nFileId,
                                              IN HANDLE           hDataFile,
                                              IN HANDLE           hMemoryMappedFile,
                                              IN HANDLE           hFileMapping,
                                              IN LPVOID           hMappedView,
                                              IN HANDLE           hTempIndexFile)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::SetMappingHandles"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    ::EnterCriticalSection(&m_csLock);

    hrRet = E_FAIL;

    CFileInfo*   pFileInfo;
    LIST_ENTRY*  pCurrent = &m_leFileList;  

    __try
    {
        pCurrent = NEXT_LIST_NODE(pCurrent);
        while (pCurrent != &m_leFileList)
        {
            pFileInfo = CONTAINING_RECORD(pCurrent, CFileInfo, leListEntry);


            if (pFileInfo->nFileId == nFileId)
            {
                if (pFileInfo->hMappedView)
                {
                    UnmapViewOfFile(pFileInfo->hMappedView);
                }
                if (pFileInfo->hFileMapping)
                {
                    ::CloseHandle(pFileInfo->hFileMapping);
                }
                if (pFileInfo->hMemoryMappedFile)
                {
                    ::CloseHandle(pFileInfo->hMemoryMappedFile);
                }
                if (pFileInfo->hTempIndexFile)
                {
                    ::CloseHandle(pFileInfo->hTempIndexFile);
                }
                if (pFileInfo->hDataFile)
                {
                    ::CloseHandle(pFileInfo->hDataFile);
                }

                pFileInfo->hMappedView = hMappedView;
                pFileInfo->hFileMapping = hFileMapping;
                pFileInfo->hMemoryMappedFile = hMemoryMappedFile;
                pFileInfo->hTempIndexFile = hTempIndexFile;
                pFileInfo->hDataFile = hDataFile;
                
                hrRet = S_OK;
                break;
            }
            pCurrent = NEXT_LIST_NODE(pCurrent);
        }
        if (pCurrent == &m_leFileList)
        {
            // File id not in file collection
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "File id %u not found in file collection.", 
                            nFileId);
            hrRet = E_FAIL;
        }
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRFileCollection::SetMappingHandles

// ====== Public methods intended for the reader

HRESULT CDVRFileCollection::GetFileAtTime(IN QWORD              cnsStreamTime, 
                                          OUT LPWSTR*           ppwszFileName OPTIONAL,
                                          OUT QWORD**           ppcnsFirstSampleTimeOffsetFromStartOfFile OPTIONAL,
                                          OUT DVRIOP_FILE_ID*   pnFileId OPTIONAL,
                                          IN BOOL               bFileWillBeOpened)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::GetFileAtTime"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    if ((pnFileId && DvrIopIsBadWritePtr(pnFileId, 0)) ||
        (ppcnsFirstSampleTimeOffsetFromStartOfFile && DvrIopIsBadWritePtr(ppcnsFirstSampleTimeOffsetFromStartOfFile, 0)) ||
        (ppwszFileName && DvrIopIsBadWritePtr(ppwszFileName, 0))
       )
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }
    
    hrRet = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    ::EnterCriticalSection(&m_csLock);

    CFileInfo*   pFileInfo;
    LIST_ENTRY*  pCurrent = &m_leFileList;  

    __try
    {
        while (NEXT_LIST_NODE(pCurrent) != &m_leFileList)
        {
            pCurrent = NEXT_LIST_NODE(pCurrent);
            pFileInfo = CONTAINING_RECORD(pCurrent, CFileInfo, leListEntry);

            // Following test will ignore nodes whose start time == end time
            // (a) because bWithinExtent == FALSE and (b) by the way the test 
            // for times is coded in the if condition below.
            if (pFileInfo->bWithinExtent &&
                cnsStreamTime >= pFileInfo->cnsStartTime &&
                (cnsStreamTime < pFileInfo->cnsEndTime || 
                 (cnsStreamTime == MAXQWORD && pFileInfo->cnsEndTime == MAXQWORD)
                )
               )
            {
                if (ppwszFileName)
                {
                    DVR_ASSERT(pFileInfo->pwszName, "");

                    WCHAR* pwszName = new WCHAR[wcslen(pFileInfo->pwszName) + 1];
                    if (pwszName)
                    {
                        wcscpy(pwszName, pFileInfo->pwszName);
                        *ppwszFileName = pwszName; 
                    }
                    else
                    {
                        hrRet = E_OUTOFMEMORY;
                        DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                        "alloc via new failed - WCHAR[%u]", 
                                        wcslen(pFileInfo->pwszName)+1);
                        __leave;
                    }
                }
                if (pnFileId)
                {
                    *pnFileId = pFileInfo->nFileId;
                }
                if (ppcnsFirstSampleTimeOffsetFromStartOfFile)
                {
                    *ppcnsFirstSampleTimeOffsetFromStartOfFile = &pFileInfo->cnsFirstSampleTimeOffsetFromStartOfFile;
                }
                if (bFileWillBeOpened)
                {
                    pFileInfo->nReaderRefCount++;
                    DvrIopDebugOut2(DVRIO_DBG_LEVEL_TRACE, 
                                    "Reader ref count for file id %u increased to %u.", 
                                    pFileInfo->nFileId, pFileInfo->nReaderRefCount);
                }
                hrRet = S_OK;
                break;
            }
        }
        if (FAILED(hrRet))
        {
            // No file for this time
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "No valid file corresponding to time %I64u found in file collection.", 
                            cnsStreamTime);
        }
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRFileCollection::GetFileAtTime

HRESULT CDVRFileCollection::CloseReaderFile(IN DVRIOP_FILE_ID   nFileId)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::CloseReaderFile"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    ::EnterCriticalSection(&m_csLock);

    hrRet = E_FAIL;

    CFileInfo*   pFileInfo;
    LIST_ENTRY*  pCurrent = &m_leFileList;  

    __try
    {
        pCurrent = NEXT_LIST_NODE(pCurrent);
        while (pCurrent != &m_leFileList)
        {
            pFileInfo = CONTAINING_RECORD(pCurrent, CFileInfo, leListEntry);

            if (pFileInfo->nFileId == nFileId)
            {
                if (pFileInfo->nReaderRefCount == 0)
                {
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                                    "Reader ref count for file id %u is already 0.", 
                                    pFileInfo->nFileId);
                    hrRet = E_FAIL;
                }
                else
                {
                    pFileInfo->nReaderRefCount--;
                    DvrIopDebugOut2(DVRIO_DBG_LEVEL_TRACE, 
                                    "Reader ref count for file id %u decreased to %u.", 
                                    pFileInfo->nFileId, pFileInfo->nReaderRefCount);
                    hrRet = S_OK;
                }
                break;
            }
            pCurrent = NEXT_LIST_NODE(pCurrent);
        }
        if (pCurrent == &m_leFileList)
        {
            // File id not in file collection
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "File id %u not found in file collection.", 
                            nFileId);
            hrRet = E_FAIL;
        }
        if (SUCCEEDED(hrRet))
        {
            // Call this even if the new ref count is not 0;
            // just use this op to clean up
            DeleteUnusedInvalidFileNodes(FALSE, NULL);
        }
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRFileCollection::CloseReaderFile

HRESULT CDVRFileCollection::GetTimeExtentForFile(
    IN DVRIOP_FILE_ID nFileId,
    OUT QWORD*        pcnsStartStreamTime OPTIONAL,  
    OUT QWORD*        pcnsEndStreamTime OPTIONAL)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::GetTimeExtentForFile"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    if ((pcnsStartStreamTime && DvrIopIsBadWritePtr(pcnsStartStreamTime, 0)) || 
        (pcnsEndStreamTime && DvrIopIsBadWritePtr(pcnsEndStreamTime, 0))
       )
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }
    
    ::EnterCriticalSection(&m_csLock);

    hrRet = E_FAIL;

    CFileInfo*   pFileInfo;
    LIST_ENTRY*  pCurrent = &m_leFileList;  

    __try
    {
        pCurrent = NEXT_LIST_NODE(pCurrent);
        while (pCurrent != &m_leFileList)
        {
            pFileInfo = CONTAINING_RECORD(pCurrent, CFileInfo, leListEntry);

            if (pFileInfo->nFileId == nFileId)
            {
                if (pcnsStartStreamTime)
                {
                    *pcnsStartStreamTime = pFileInfo->cnsStartTime;
                }
                if (pcnsEndStreamTime)
                {
                    *pcnsEndStreamTime = pFileInfo->cnsEndTime;
                }
                hrRet = pFileInfo->bWithinExtent? S_OK : S_FALSE;
                break;
            }
            pCurrent = NEXT_LIST_NODE(pCurrent);
        }
        if (pCurrent == &m_leFileList)
        {
            // File id not in file collection
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "File id %u not found in file collection.", 
                            nFileId);
            hrRet = E_FAIL;
        }
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRFileCollection::GetTimeExtentForFile

HRESULT CDVRFileCollection::GetTimeExtent(
    OUT QWORD*        pcnsStartStreamTime OPTIONAL,  
    OUT QWORD*        pcnsEndStreamTime OPTIONAL)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::GetTimeExtent"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    if ((pcnsStartStreamTime && DvrIopIsBadWritePtr(pcnsStartStreamTime, 0)) || 
        (pcnsEndStreamTime && DvrIopIsBadWritePtr(pcnsEndStreamTime, 0))
       )
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }
    
    ::EnterCriticalSection(&m_csLock);

    __try
    {
        if (pcnsStartStreamTime)
        {
            *pcnsStartStreamTime = m_cnsStartTime;
        }
        if (pcnsEndStreamTime)
        {
            *pcnsEndStreamTime = m_cnsLastStreamTime;
        }

        hrRet = S_OK;
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRFileCollection::GetTimeExtent


// We return E_FAIL if cnsStreamTime = MAXQWORD (and 
// m_cnsEndTime)
HRESULT CDVRFileCollection::GetFirstValidTimeAfter(IN  QWORD    cnsStreamTime,  
                                                   OUT QWORD*   pcnsNextValidStreamTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::GetFirstValidTimeAfter"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    if (!pcnsNextValidStreamTime || DvrIopIsBadWritePtr(pcnsNextValidStreamTime, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }
    
    ::EnterCriticalSection(&m_csLock);

    hrRet = E_FAIL;

    CFileInfo*   pFileInfo;
    LIST_ENTRY*  pCurrent = &m_leFileList;  

    __try
    {
        while (NEXT_LIST_NODE(pCurrent) != &m_leFileList)
        {
            pCurrent = NEXT_LIST_NODE(pCurrent);
            pFileInfo = CONTAINING_RECORD(pCurrent, CFileInfo, leListEntry);

            if (pFileInfo->cnsEndTime == pFileInfo->cnsStartTime &&
                pFileInfo->cnsEndTime != MAXQWORD)
            {
                // Don't consider this node for comparisons.
                // It's not within the extent anyway.

                // Nodes whose start time != end time are in sorted order
                // Nodes whose start time == end time can appear anywhere
                // in the list and are ignored
                continue;
            }
            if (cnsStreamTime >= pFileInfo->cnsStartTime &&
                cnsStreamTime < pFileInfo->cnsEndTime)
            {
                *pcnsNextValidStreamTime = cnsStreamTime + 1;
                hrRet = S_OK;
                break;
            }
            else if (cnsStreamTime < pFileInfo->cnsStartTime)
            {
                // No file for this time

                *pcnsNextValidStreamTime = pFileInfo->cnsStartTime;
                hrRet = S_OK;
                break;
            }
        }

        // if hrRet == E_FAIL, we crossed the ring buffer's extent and
        // there is no file. Return E_FAIL and don't change 
        // *pcnsNextValidStreamTime
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRFileCollection::GetFirstValidTimeAfter


// We return E_FAIL for 0 (and m_cnsStartTime)
HRESULT CDVRFileCollection::GetLastValidTimeBefore(IN  QWORD    cnsStreamTime,  
                                                   OUT QWORD*   pcnsLastValidStreamTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRFileCollection::GetLastValidTimeBefore"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    if (!pcnsLastValidStreamTime || DvrIopIsBadWritePtr(pcnsLastValidStreamTime, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }
    
    ::EnterCriticalSection(&m_csLock);

    hrRet = E_FAIL;

    CFileInfo*   pFileInfo;
    LIST_ENTRY*  pCurrent = &m_leFileList;  

    __try
    {
        while (PREVIOUS_LIST_NODE(pCurrent) != &m_leFileList)
        {
            pCurrent = PREVIOUS_LIST_NODE(pCurrent);
            pFileInfo = CONTAINING_RECORD(pCurrent, CFileInfo, leListEntry);

            if (pFileInfo->cnsEndTime == pFileInfo->cnsStartTime &&
                pFileInfo->cnsEndTime != MAXQWORD)
            {
                // Don't consider this node for comparisons.
                // It's not within the extent anyway.

                // Nodes whose start time != end time are in sorted order
                // Nodes whose start time == end time can appear anywhere
                // in the list and are ignored
                continue;
            }
            if (cnsStreamTime > pFileInfo->cnsStartTime &&
                cnsStreamTime <= pFileInfo->cnsEndTime)
            {
                // If cnsStreamTime == MAXQWORD, this covers the case 
                // where a node has (start, end) = (T, QWORD_IFINITE) where 
                // T != MAXQWORD. The next else if clause skips over
                // files with start = end = MAXQWORD
                *pcnsLastValidStreamTime = cnsStreamTime - 1;
                hrRet = S_OK;
                break;
            }
            else if (cnsStreamTime >= pFileInfo->cnsEndTime && 
                     (cnsStreamTime != MAXQWORD || 
                      pFileInfo->cnsEndTime != MAXQWORD)
                    )
            {
                // No file for this time

                *pcnsLastValidStreamTime = pFileInfo->cnsEndTime - 1;
                hrRet = S_OK;
                break;
            }
        }

        // if hrRet == E_FAIL, we crossed the ring buffer's extent and
        // there is no file. Return E_FAIL and don't change 
        // *pcnsLastValidStreamTime
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRFileCollection::GetLastValidTimeBefore
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrio\dvriop.h ===
//------------------------------------------------------------------------------
// File: dvrIOp.h
//
// Description: Private DVR IO API definition
//
// Copyright (c) 2000 - 2001, Microsoft Corporation.  All rights reserved.
//
//------------------------------------------------------------------------------

#ifndef _DVR_IOP_H_
#define _DVR_IOP_H_

#if _MSC_VER > 1000
#pragma once
#endif

// CreateRecorder flags passed in via the dwReserved argument.
// Should eventually be made public - add to dvrioidl.idl
#define DVRIO_PERSISTENT_RECORDING      1

// Forward declarations
class CDVRFileCollection;
class CDVRRingBufferWriter;
class CDVRRecorder;
class CDVRReader;

// Macros
#define NEXT_LIST_NODE(p) ((p)->Flink)
#define PREVIOUS_LIST_NODE(p) ((p)->Blink)
#define NULL_NODE_POINTERS(p) (p)->Flink = (p)->Blink = NULL;
#define LIST_NODE_POINTERS_NULL(p) ((p)->Flink == NULL || (p)->Blink == NULL)
// ============ Debug functions

#if defined(DEBUG)

// Debug levels
typedef enum {
    DVRIO_DBG_LEVEL_INTERNAL_ERROR_LEVEL = 0,
    DVRIO_DBG_LEVEL_CLIENT_ERROR_LEVEL,
    DVRIO_DBG_LEVEL_INTERNAL_WARNING_LEVEL,
    DVRIO_DBG_LEVEL_TRACE_LEVEL,
    DVRIO_DBG_LEVEL_LAST_LEVEL
} DVRIO_DBG_LEVEL_CONSTANTS;

// Global variables
extern DWORD g_nDvrIopDbgCommandLineAssert;
extern DWORD g_nDvrIopDbgInDllEntryPoint;
extern DWORD g_nDvrIopDbgOutputLevel;
extern DWORD g_adwDvrIopDbgLevels[DVRIO_DBG_LEVEL_LAST_LEVEL];

#define DvrIopIsBadStringPtr(p) (IsBadStringPtrW((p), MAXUINT_PTR))
#define DvrIopIsBadReadPtr(p, n) (IsBadReadPtr((p), (n)? (n) :sizeof(*(p))))
#define DvrIopIsBadWritePtr(p, n) (IsBadWritePtr((p), (n)? (n) :sizeof(*(p))))

#define DVR_ASSERT(x, m) if (!(x)) DvrIopDbgAssert("DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m, #x, __FILE__, __LINE__ DVRIO_DUMP_THIS_VALUE)
#define DVR_EXECUTE_ASSERT(x, m) DVR_ASSERT(x, m)
#define DvrIopDebugOut0(level, m) if (level <= g_nDvrIopDbgOutputLevel) DbgPrint("DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m "\n" DVRIO_DUMP_THIS_VALUE)
#define DvrIopDebugOut1(level, m, a) if (level <= g_nDvrIopDbgOutputLevel) DbgPrint("DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m "\n" DVRIO_DUMP_THIS_VALUE, a)
#define DvrIopDebugOut2(level, m, a, b) if (level <= g_nDvrIopDbgOutputLevel) DbgPrint("DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m "\n" DVRIO_DUMP_THIS_VALUE, a, b)
#define DvrIopDebugOut3(level, m, a, b, c) if (level <= g_nDvrIopDbgOutputLevel) DbgPrint("DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m "\n" DVRIO_DUMP_THIS_VALUE, a, b, c)
#define DvrIopDebugOut4(level, m, a, b, c, d) if (level <= g_nDvrIopDbgOutputLevel) DbgPrint("DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m "\n" DVRIO_DUMP_THIS_VALUE, a, b, c, d)
#define DvrIopDebugOut5(level, m, a, b, c, d, e) if (level <= g_nDvrIopDbgOutputLevel) DbgPrint("DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m "\n" DVRIO_DUMP_THIS_VALUE, a, b, c, d, e)
#define DvrIopDebugOut6(level, m, a, b, c, d, e, f) if (level <= g_nDvrIopDbgOutputLevel) DbgPrint("DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m "\n" DVRIO_DUMP_THIS_VALUE, a, b, c, d, e, f)
#define DvrIopDebugOut7(level, m, a, b, c, d, e, f, g) if (level <= g_nDvrIopDbgOutputLevel) DbgPrint("DVR IO: " DVRIO_THIS_FN "(): " DVRIO_DUMP_THIS_FORMAT_STR m "\n" DVRIO_DUMP_THIS_VALUE, a, b, c, d, e, f, g)
#define DVRIO_TRACE_ENTER() DvrIopDebugOut0(DVRIO_DBG_LEVEL_TRACE, "Entering")
#define DVRIO_TRACE_LEAVE0() DvrIopDebugOut0(DVRIO_DBG_LEVEL_TRACE, "Leaving")
#define DVRIO_TRACE_LEAVE1(n) DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE, "Leaving, returning %d", n)
#define DVRIO_TRACE_LEAVE1_HR(n) DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE, "Leaving, returning hr=0x%x", n)
#define DVRIO_TRACE_LEAVE1_ERROR(n, dwError) DvrIopDebugOut2(DVRIO_DBG_LEVEL_TRACE, "Leaving, returning %d, last error=0x%x", n, dwError)

#define DVRIO_DBG_LEVEL_INTERNAL_ERROR              (g_adwDvrIopDbgLevels[DVRIO_DBG_LEVEL_INTERNAL_ERROR_LEVEL])
#define DVRIO_DBG_LEVEL_CLIENT_ERROR                (g_adwDvrIopDbgLevels[DVRIO_DBG_LEVEL_CLIENT_ERROR_LEVEL])
#define DVRIO_DBG_LEVEL_INTERNAL_WARNING            (g_adwDvrIopDbgLevels[DVRIO_DBG_LEVEL_INTERNAL_WARNING_LEVEL])
#define DVRIO_DBG_LEVEL_TRACE                       (g_adwDvrIopDbgLevels[DVRIO_DBG_LEVEL_TRACE_LEVEL])

void DvrIopDbgInit(IN HKEY hRegistryDVRIORootKey);

// Implemented in dvrReg.cpp
void DvrIopDbgInitFromRegistry(
    IN  HKEY  hRegistryKey,
    IN  DWORD dwNumValues, 
    IN  const WCHAR* awszValueNames[],
    OUT DWORD* apdwVariables[])
    ;

void DvrIopDbgAssert(
    IN const PCHAR pszMsg,
    IN const PCHAR pszCondition,
    IN const PCHAR pszFileName,
    IN DWORD iLine,
    IN LPVOID pThis = NULL,
    IN DWORD  dwThisId = 0
    );

#else

#define DvrIopIsBadStringPtr(p)     (0)
#define DvrIopIsBadReadPtr(p, n)    (0)
#define DvrIopIsBadWritePtr(p, n)   (0)

#define DVR_ASSERT(x, m) 
#define DVR_EXECUTE_ASSERT(x, m) ((void) (x))
#define DvrIopDebugOut0(level, m) 
#define DvrIopDebugOut1(level, m, a)
#define DvrIopDebugOut2(level, m, a, b)
#define DvrIopDebugOut3(level, m, a, b, c)
#define DvrIopDebugOut4(level, m, a, b, c, d)
#define DvrIopDebugOut5(level, m, a, b, c, d, e)
#define DvrIopDebugOut6(level, m, a, b, c, d, e, f)
#define DvrIopDebugOut7(level, m, a, b, c, d, e, f, g)
#define DVRIO_TRACE_ENTER()
#define DVRIO_TRACE_LEAVE0()
#define DVRIO_TRACE_LEAVE1(n)
#define DVRIO_TRACE_LEAVE1_HR(n)
#define DVRIO_TRACE_LEAVE1_ERROR(n, dwError)

#endif // DEBUG

// a = b + c, but capped at MAXQWORD
_inline void SafeAdd(QWORD& a, QWORD b, QWORD c)
{
    a = b + c;
    if (a < b)
    {
        // Overflowed. Cap it at MAXQWORD
        a = MAXQWORD;
    }
}

const DWORD k_dwMilliSecondsToCNS = 1000 * 10;
const QWORD k_qwSecondsToCNS = 1000 * k_dwMilliSecondsToCNS;

// Constants
const HKEY g_hDefaultRegistryHive = HKEY_CURRENT_USER;
static const WCHAR* kwszRegDvrKey     = L"Software\\Microsoft\\DVR";
static const WCHAR* kwszRegDvrIoReaderKey   = L"IO\\Reader";
static const WCHAR* kwszRegDvrIoWriterKey   = L"IO\\Writer";

#if defined(DEBUG)

static const WCHAR* kwszRegDvrIoDebugKey    = L"IO\\Debug";

#endif // if defined(DEBUG)

// Values - writer
static const WCHAR* kwszRegDataDirectoryValue = L"DVRDirectory";

static const WCHAR* kwszRegDeleteRingBufferFilesValue = L"DeleteRingBufferFiles";
const DWORD kdwRegDeleteRingBufferFilesDefault = 1;

static const WCHAR* kwszRegCreateValidationFilesValue = L"CreateValidationFiles";
const DWORD kdwRegCreateValidationFilesDefault = 0;

static const WCHAR* kwszRegSyncToleranceValue = L"SyncTolerance";
const DWORD kdwRegSyncToleranceDefault = 0;

static const WCHAR* kwszRegTempRingBufferFileNameValue = L"TempRingBufferFileName";

#if defined(DVR_UNOFFICIAL_BUILD)

static const WCHAR* kwszRegEnforceIncreasingTimestampsValue = L"EnforceIncreasingTimestamps";
const DWORD kdwRegEnforceIncreasingTimestampsDefault = 1;

#endif // defined(DVR_UNOFFICIAL_BUILD)

// Values - reader

static const WCHAR* kwszRegCloseReaderFilesAfterConsecutiveReadsValue = L"CloseReaderFilesAfterConsecutiveReads";
const DWORD kdwRegCloseReaderFilesAfterConsecutiveReadsDefault = 25;    // 25 is arbitrary

// Global private functions
DWORD GetRegDWORD(IN HKEY hKey, IN LPCWSTR pwszValueName, IN DWORD dwDefaultValue);

HRESULT GetRegString(IN HKEY hKey, 
                     IN LPCWSTR pwszValueName,
                     OUT LPWSTR pwszValue OPTIONAL,
                     IN OUT DWORD* pdwSize);

// We define this here for methods inlined in this file
#if defined(DEBUG)
#undef DVRIO_DUMP_THIS_FORMAT_STR
#define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
#undef DVRIO_DUMP_THIS_VALUE
#define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
#endif


// The DVR file collection object, aka the "ring buffer"

class CDVRFileCollection {

public:
    typedef DWORD       DVRIOP_FILE_ID;
    enum {DVRIOP_INVALID_FILE_ID = 0};
    
private:
    // ======== Data members
    
    // The file collection has a time extent. Files in the collection
    // are either within the extent or outside it. Files nodes outside the
    // extent are candidates for removal from the collection; usually
    // they are in the collection only because they have (reader) clients.
    // These files are removed as soon as they have no clients. (As we
    // shall see later, there could be files whose start time = end time
    // = T and T is within the collection's extent; however, these nodes
    // are always considered "outside" the collection and are marked
    // for removal. The exception to this is if T is MAXQWORD; it
    // is legit to set start time = end time = MAXQWORD)

    // Each file in the collection is a "temp" or a "permanent" file. Permanent
    // files are not deleted. A temp file is deleted when its extent falls 
    // outside the collection's extent and it has no clients, i.e., when the 
    // file node is removed from the collection. There are two points to note
    // here: 1. Occasionally a temp file cannot be deleted even if its extent
    // is outside the collection's extent and it has no clients because 
    // DeleteFile fails; in this case the temp file is kept in the collection
    // till DeleteFile succeeds. 2. The collection's extent is actually 
    // determined by the number of temp files in it: the collection's extent
    // can have at most m_dwMaxTempFiles temp files (but any number of 
    // permanent files).
    //
    // A file is said to be INVALID if its extent falls outside the 
    // collection.
    DWORD                   m_dwMaxTempFiles;

    // The time extent of the ring buffer is demarcated by its start
    // and the end times, m_cnsStartTime and m_cnsEndTime.
    //
    // m_cnsLastStreamTime has the last time for which there is data (for a
    // live source, this variable is continually updated by the writer client
    // with each write), and, from a client's viewpoint the actual time 
    // extent is through m_cnsLastStreamTime. m_cnsEndTime is the max time 
    // extent for the last file in the ring buffer. In practice, m_cnsEndTime
    // has little utility, but it's low cost keeping it around. For a source 
    // that is not live, m_cnsEndTime == m_cnsLastStreamTime.
    //
    // All these times are set to 0 in the constructor. The start and end
    // times are updated by AddFile() and SetFileTimes(). A pointer to 
    // m_cnsLastStreamTime is handed back to the client in the constructor 
    // and the client is expected to update it. Reader clients reading
    // non-live files set it once for all at the start; writer clients 
    // MUST update it continually with each write, and reader clients that
    // read live files can set it to MAXQWORD and update it as 
    // and when they desire - this works only because in that case the 
    // file collection object is used exclusively by the reader - it is not
    // shared. NONE of the methods in this class update m_cnsLastStreamTime
    // and none of them check whether m_cnsLastStreamTime lies within 
    // the m_cnsStartTime - m_cnsEndTime range when the latter two members
    // are updated. It is the client's responsibility to do things "right"
    //
    // Our implementation allows time "holes" in the file collection, i.e.,
    // intervals of time that are not backed by any file. This feature is
    // necessary to support recordings that start in the future; however,
    // holes between m_cnsStartTime and m_cnsLastStreamTime could confound
    // the reader because if the reader assumes that file times are contiguous,
    // e.g., a Seek to a time in the hole will fail and the reader has no
    // way to find the first time after the hole except by polling all times.
    // So the writer should be careful of never creating time holes between
    // m_cnsStartTime and m_cnsLastStreamTime. The reader is provided with
    // a function, GetFirstValidTimeAfter() to skip over holes.
    //
    QWORD                   m_cnsStartTime;
    QWORD                   m_cnsEndTime;
    QWORD                   m_cnsLastStreamTime;

    // Next usable file id, initialized to DVRIOP_INVALID_FILE_ID + 1
    DVRIOP_FILE_ID          m_nNextFileId;

    // List of files, nodes in the list are new'd and delete'd on demand
    // Nodes are of type CFileInfo
    LIST_ENTRY              m_leFileList;

    // The temporary directory that holds the temporary files
    LPWSTR                  m_pwszTempFilePath;

    // The prefix used for the temporary files
    LPWSTR                  m_pwszFilePrefix;

    // The name fo the subdirectory of the DVR directory
    // that holds the temporary files
    static LPCWSTR          m_kwszDVRTempDirectory;

    // A pointer to m_nWriterHasBeenClosed is handed back to the caller that
    // creates the file collection. The caller is responsible for updating it.
    LONG                    m_nWriterHasBeenClosed;

    struct CFileInfo 
    {

        #if defined(DEBUG)
        #undef DVRIO_DUMP_THIS_FORMAT_STR
        #define DVRIO_DUMP_THIS_FORMAT_STR ""
        #undef DVRIO_DUMP_THIS_VALUE
        #define DVRIO_DUMP_THIS_VALUE
        #endif

        QWORD               cnsStartTime;
        QWORD               cnsEndTime;
        QWORD               cnsFirstSampleTimeOffsetFromStartOfFile;
        LIST_ENTRY          leListEntry;
        LPCWSTR             pwszName;     // New'd and delete'd
        
        // Following are to be unmapped and closed when the file leaves the ring buffer.
        HANDLE              hDataFile;
        HANDLE              hMemoryMappedFile;
        HANDLE              hFileMapping;
        LPVOID              hMappedView;
        HANDLE              hTempIndexFile;
        
        DVRIOP_FILE_ID      nFileId;
        ULONG               nReaderRefCount;
        BOOL                bPermanentFile;
        
        // bWithinExtent is non zero iff the file is in the ring 
        // buffer's extent. The node can be removed from m_leFileList iff
        // !bWithinExtent && nReaderRefCount == 0; this is regardless
        // of whether the file is temporary or permanent.
        //
        // When bWithinExtent == 0, the disk file can be deleted iff
        // !bPermanentFile && nReaderRefCount == 0. 
        //
        BOOL                bWithinExtent;

        // Note that we do not maintain a writer ref count. Because
        // of the conditions imposed on the minimum value of 
        // the number of temp files that may be supplied when 
        // the ring buffer writer is created and because of the design
        // of how the ring buffer writer opens and closes files,
        // any file opened by the writer will have bWithinExtent set
        // to TRUE. The exception to this is that the writer may
        // call SetFileTimes with the start and end times equal for
        // a file that it has open. We will set bWithinExtent to 0 
        // though the writer has the file open. The writer will close
        // the file soon after the call to SetFileTimes, however.

        // Note: The enforcement of:
        //  Max stream delta time < (dwNumberOfFiles-3)*cnsTimeExtentOfEachFile
        // by the ring buffer writer is what lets us get away with not
        // maintaining a writer ref count. The writer will not have more
        // than dwNumberOfFiles-1 files open (dwNumberOfFiles-3 plus one that 
        // it is opening and one that it is closing). So any file the 
        // writer has open will have bWithinExtent set to TRUE.

        // Methods

        CFileInfo(IN LPCWSTR        pwszFileNameParam, 
                  IN QWORD          cnsStartTimeParam,
                  IN QWORD          cnsEndTimeParam,
                  IN BOOL           bPermanentFileParam, 
                  IN DVRIOP_FILE_ID nFileIdParam,
                  IN BOOL           bWithinExtentParam) 
            : pwszName(pwszFileNameParam) 
            , cnsStartTime(cnsStartTimeParam)
            , cnsEndTime(cnsEndTimeParam)
            , cnsFirstSampleTimeOffsetFromStartOfFile(MAXQWORD)
            , nFileId(nFileIdParam)
            , nReaderRefCount(0)
            , bPermanentFile(bPermanentFileParam)
            , bWithinExtent(bWithinExtentParam)
            , hDataFile(NULL)
            , hMemoryMappedFile(NULL)
            , hFileMapping(NULL)
            , hMappedView(NULL)
            , hTempIndexFile(NULL)
        {
            NULL_NODE_POINTERS(&leListEntry);
        };
        ~CFileInfo() 
        {
            delete [] pwszName;
            if (hMappedView)
            {
                UnmapViewOfFile(hMappedView);
            }
            if (hFileMapping)
            {
                ::CloseHandle(hFileMapping);
            }
            if (hDataFile)
            {
                ::CloseHandle(hDataFile);
            }
            if (hMemoryMappedFile)
            {
                ::CloseHandle(hMemoryMappedFile);
            }
            if (hTempIndexFile)
            {
                ::CloseHandle(hTempIndexFile);
            }
        };
    
        #if defined(DEBUG)
        #undef DVRIO_DUMP_THIS_FORMAT_STR
        #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
        #undef DVRIO_DUMP_THIS_VALUE
        #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
        #endif

    };
        
    // The lock that is held by all public methods
    CRITICAL_SECTION        m_csLock;

    // Ref count on this object
    LONG                    m_nRefCount;

    // Debug data members
#if defined(DEBUG)
    static DWORD            m_dwNextClassInstanceId;
    DWORD                   m_dwClassInstanceId;
#endif

    // ====== Protected methods
protected:
    // Instances of this class are refcounted and can be deleted only
    // by calling Release(). A non-public destructor helps enforce this
    virtual ~CDVRFileCollection();

    // DeleteUnusedInvalidFileNodes():
    //
    // The following method is called in:
    // - AddFile
    // - CloseReaderFile
    // - SetFileTimes (unlikely to cause files to be deleted unless start == 
    //   end time was specified for some file)
    // - the ring buffer's destructor which sets bWithinExtent to 0 on each
    //   temp file node before the call is made. The destructor should ASSERT:
    //   nReaderRefCount == 0.
    //
    // The first argument is set to TRUE to force removal of nodes from the
    // list. Ordinarily, the node is lef tin the list if the file is 
    // temporary, its nReaderRefCount == 0, and the disk file could not be
    // deleted. 
    // 
    // The second argument can be used in the destructor to verify that files
    // all been deleted.
    //
    // This routine removes nodes from m_leFileList if the file ss successfully 
    // deleted.
    //
    // Note that if DeleteFileW fails, this routine should actually verify that 
    // the file exists; if it does not, the node is removed from the list.
    void DeleteUnusedInvalidFileNodes(
        BOOL   bRemoveAllNodes,
        DWORD* pdwNumInvalidUndeletedTempFiles OPTIONAL);

    // UpdateTimeExtent():
    //
    // The following method updates the ring buffer's extent and also the 
    // bWithinExtent member of each node in m_leFileList. It does not 
    // validate that m_cnsLastStreamTime is within the new extent; the caller
    // must make sure that things make sense. In particular, the writer must
    // make sure that m_cnsLastStreamTime >= m_cnsStartTime so that if the 
    // reader calls GetTimeExtent(), the values are reasonable. For example,
    // when SetFirstSampleTime() is called, the writer should lock the file 
    // collection object, call SetFileTimes, change m_cnsLastStreamTime and
    // then unlock the file collection object to prevent readers from
    // getting inconsistent values from GetTimeExtent() or promising 
    // an extent larger than backed by files (so that calls that the reader
    // makes to Seek fail). See SetFileTimes() for more info on why the 
    // writer would call that function when SetFirstSampleTime() is called.
    //
    // Conceptually, this function creates a subcollection S of the file
    // collection by eliminating all nodes whose start times equal their end 
    // times (and this time is NOT MAXQWORD, start time = end time = 
    // MAXQWORD is legit and for us will happen only when recording is
    // in progress, so the recorded node's end time will be MAXQWORD).
    // It sets bWithinExtent of all nodes not in S to 0. If S is empty, it
    // sets m_cnsStartTime = m_cnsEndTime = 0 and returns S_FALSE.
    //
    // Otherwise, it sets m_cnsEndTime to the end time of the last node of S.
    // It then forms another subsollection S' from S: S' is the maximal 
    // subcollection of S got by eliminating the lower time end nodes of S
    // such that S' has at most m_dwMaxTempFiles temporary nodes. 
    // m_cnsStartTime is then set to the start time of the first node of S',
    // In this case, it returns S_OK.
    //
    // Every call to this function recomputes both m_cnsStartTime and 
    // m_cnsEndTime. It also recomputes the bWithinExtent member of every
    // node in the collection.
    // 
    HRESULT UpdateTimeExtent();

    // ====== Public methods
public:

    // Constructor. Although pcnsLastStreamTime is OPTIONAL, both
    // the reader and writer ring buffer objects are expected to 
    // specify it.
    CDVRFileCollection(IN  DWORD       dwMaxTempFiles,
                       IN  LPCWSTR     pwszDVRDirectory OPTIONAL,
                       OUT QWORD**     ppcnsLastStreamTime OPTIONAL,
                       OUT LONG**      ppnWriterHasClosedFile OPTIONAL,
                       OUT HRESULT*    phr OPTIONAL);


    // ====== Refcounting
    
    ULONG AddRef();
    
    ULONG Release();

    // ====== For the ring buffer writer

    // Lock and Unlock.
    //
    // These functions grab and release m_csLock. This allows the writer to
    // prevent readers from accessing the ring buffer. Writers need this 
    // when they call SetFirstSampleTime(). They have to update 
    // m_cnsLastStreamTime and may also have to call SetFileTimes() to 
    // change the ring buffer's time extent. Doing either of these without
    // locking the file collection exposes the reader to inconsistencies:
    // if m_cnsLastStreamTime is updated first, the reader may Seek() to
    // m_cnsLastStreamTime and no file may have been created yet for that
    // time and if SetFileTimes is called first GetTimeExtent will return a
    // time extent (T1, T2) where T1 > T2 (T2 is m_cnsLastStreamTime, which
    // will still be 0.)
    //
    // These methods are also used by both the writer and the reader to guard 
    // against concurrent access to shared variables stored in the file 
    // collection. Examples of these variables are m_cnsLastStreamTime and 
    // CFileInfo::cnsFirstSampleTimeOffsetFromStartOfFile

    HRESULT Lock();

    HRESULT Unlock();

    // AddFile():
    //
    // If the name is supplied in ppwszFileName (i.e., *ppwszFileName != NULL),
    // that file is added to the file collection. It is recommended that the
    // name be a fully qualified one. In this case, *ppwszFileName is not
    // changed by the function and it does not create the file on disk.
    //
    // If *ppwszFileName is NULL when the function is called, a temp file name
    // is generated and added; in this case the temp file name (fully
    // qualified) is returned in ppwszFileName and the file is created on disk
    // if the function returns S_OK. If the function returns S_FALSE or an 
    // error, no file is created on disk, *pnFileId is not set and *ppwszFileName 
    // remains NULL on.return If the function returns S_OK, the caller must free  
    // *ppwszFileName using delete. 
    //
    // The caller may supply a pointer to a QWORD* in ppcnsFirstSampleTimeOffsetFromStartOfFile. 
    // If this argument is not NULL and AddFile returns S_OK, *ppcnsFirstSampleTimeOffsetFromStartOfFile
    // is set to the address of CFileInfo::cnsFirstSample for the corresponding
    // node. The writer should set this to the write time of the first sample
    // and the reader may use it to adjust the sample times it returns to its
    // caller. The file collection's Lock and Unlock methods must be used to 
    // protect concurrent access to this member. (Interlocked* functions can't 
    // be used as the member is 64 bit.)
    //
    // The call fails if (a) start time > end time or (b) if start time = end
    // time and start time != MAXQWORD. The call also fails if
    // the start-end time interval overlaps the start-end time interval of
    // any other file already in the file collection. It is the caller's 
    // responsibility to adjust the file time extents of those files using
    // SetFileTimes() before calling AddFile().
    //
    // Note: samples in the file have (stream) times >= start time and < (not 
    // <=) end time.
    //
    // The start and end times of the ring buffer are updated on successful 
    // addition of the file by calling UpdateTimeExtent() from AddFiles().
    //
    // Note that AddFile places no restriction that the time extent of the added 
    // file be at the end of the file collection or that the addition of this
    // file not cause "holes" in the ring buffer's time extent. 
    //
    // Because AddFile places no restriction on the time extent of the added 
    // file relative to the time extent of the ring buffer, it could happen
    // that the file is added at a point where it does not either fall into the
    // ring buffer's time extent or extend it. For example, the ring buffer
    // may already have m_dwMaxTempFiles temp files and it's time extent could
    // be 500-900 and the added file could be a temp file with extent 400-500.
    // As another example, the ring buffer may have m_dwMaxTempFiles temp files
    // with extent 500-900 a temp file with extent 400-500 waiting to be 
    // deleted and a permanent file could be added with extent 200-300. In these
    // cases, the file is added and deleted immediately by AddFile. And the 
    // function returns S_FALSE. For our scenarios, this case will never arise.
    //
    // Another consequence of allowing holes in the ring buffer is the following:
    // if the ring buffer has m_dwMaxTempFiles temp files with extent 500-900 a 
    // temp file with extent 400-500 waiting to be deleted, adding a *permanent*
    // file with extent 300-400 returns S_FALSE. However, if the temp file with
    // extent 400-500 had already been deleted, it would be possible to add the
    // permanent file and the ring buffer's extent would change to 300-900 with
    // a hole at 400-500. We allow this because our clients will never actually 
    // do this for the scenarios of interest.
    // 
    HRESULT AddFile(IN OUT LPWSTR*      ppwszFileName OPTIONAL, 
                    IN QWORD            cnsStartTime,
                    IN QWORD            cnsEndTime,
                    IN BOOL             bPermanentFile,
                    OUT QWORD**         ppcnsFirstSampleTimeOffsetFromStartOfFile OPTIONAL,
                    OUT DVRIOP_FILE_ID* pnFileId);
    
    typedef struct {
        DVRIOP_FILE_ID  nFileId;
        QWORD           cnsStartTime;
        QWORD           cnsEndTime;
    } DVRIOP_FILE_TIME, *PDVRIOP_FILE_TIME;

    // SetFileTimes():
    //
    // File times of files in the file collection can be changed by calling 
    // SetFileTimes. This call will fail if the applying this change would 
    // leave two files with overlapping file times or if it requires 
    // interchanging the relative order of the files in the collection, e.g.,
    // file A's time extent was 100-200, file B's was 200-300 and the call 
    // changes file A's time extent to 300-400 without changing B's.
    // The call also fails if the start time > the end time in any of
    // of the input DVRIOP_FILE_TIME elements. Start time == end time is 
    // allowed; this is useful if we had added a node whose extent was
    // T1 to T1+T and a recording node is added with start recording time
    // at T1. In this case, we set the file times of the first node to 
    // T1,T1. The call fails if one of the supplied file ids is not
    // in the file collection. The call also fails if one of the 
    // supplied file ids had its start time == end time (as a result of 
    // a previous call to SetFileTimes).
    //
    // This function automatically updates m_cnsStartTime and m_cnsEndTime
    // by calling UpdateExtent(). Although the order of files cannot be changed
    // by this call, the bWithinExtent member of files in the collection
    // could change as a result of calling this function because start time ==
    // end time for one of the input DVRIOP_FILE_TIME elements. 
    //
    // If UpdateExtent returns S_FALSE because the subcollection S' is empty
    // (see UpdateExtent), this function makes the changes to the file times
    // and returns S_FALSE. Note that m_cnsStartTime and m_cnsEndTime 
    // would have been set to 0 in this case.
    //
    // As explained in AddFile, it is possible to create holes in the 
    // collection for times between m_cnsStartTime and m_cnsLastStreamTime
    // by calling this function. We will not forbid that, but
    // this will cause problems for readers. We do not expect this will
    // happen for our scenarios.
    //
    // The function only changes data members in the file collection; sample
    // times already written to ASF files are not changed. This function 
    // should not change file times of a file that has or is being written.
    // The only exception ot this is if the start time equals the end time
    // for such files (and if the file is being written, it should be closed
    // at once). Setting the start time to the end time forces the file node
    // to be deleted from the collection. 
    //
    // There are three practical uses of this function: 1. A writer
    // wants to start recording at time T1 but T1 is already in the time extent
    // of another file - in that case that file's extent is reduced to T1 (and
    // if its start time was T1 the file node would be deleted from the 
    // collection). 2. The writer initially sets up to start writing at time 0.
    // It knows the starting time only when its client gets the first sample
    // (and calls SetFirstSampleTime()). It would use this function to adjust 
    // the times appropriately. 3. On completion of recording, the writer sets 
    // the end time of the recorded node and the start and end times of any 
    // subsequent nodes (all these times were MAXQWORD while recording 
    // was in progress).
    //
    // Final note: It's easy for the writer (the client of this function) to 
    // create the pFileTimes argument so that the file ids in the argument are
    // in the same order as file ids in the file collection. This simplifies 
    // the code in this function, so we fail the call if this assumption is 
    // violated (we assert in this case).

    HRESULT SetFileTimes(IN DWORD dwNumElements, 
                         IN PDVRIOP_FILE_TIME pFileTimes);


    // Set the duplicated handles of the memory mapping so that they
    // can be closed when the file leaves the ring buffer. Only the
    // writer client calls this; ring buffers set up by the reader do not
    // have these values set.
    HRESULT SetMappingHandles(IN DVRIOP_FILE_ID   nFileId,
                              IN HANDLE           hDataFile,
                              IN HANDLE           hMemoryMappedFile,
                              IN HANDLE           hFileMapping,
                              IN LPVOID           hMappedView,
                              IN HANDLE           hTempIndexFile);

    // ====== For the reader

    // Returns the file id and optionally the name of the file corresponding
    // to a stream time. The reader ref count on the file is increased if 
    // bFileWillBeOpened is set. The caller must free *ppwszFileName using 
    // delete.
    //
    // GetFileAtTime fails if the file corresponding to the time has the 
    // bWithinExtent member set to 0. If there is >1 file which matches
    // the time (as could happen if one of them had start time = end time,
    // in which case it is invalid), it returns the valid one. (Note that
    // there will be at most 1 valid file.) 
    //
    // If given MAXQWORD, the function returns the first file whose start
    // time is MAXQWORD. Note that there could be several files in the 
    // collection whose start and end times are MAXQWORD (won't happen
    // for our scenarios).
    //
    // Stream times of samples in files are >= start time and < end time,
    // so if the time presented is the endpoint of a file's extent, the
    // file with the start time is picked. However, the function fails
    // if the presented time matches the end time of a file and no valid file
    // has it as the start time. 
    //
    // Note: Ring Buffer writer uses this function
    //
    HRESULT GetFileAtTime(IN QWORD              cnsStreamTime, 
                          OUT LPWSTR*           ppwszFileName OPTIONAL,
                          OUT QWORD**           ppcnsFirstSampleTimeOffsetFromStartOfFile OPTIONAL,
                          OUT DVRIOP_FILE_ID*   pnFileId OPTIONAL,
                          IN BOOL               bFileWillBeOpened);
    
    // Informs the file collection that the file is no longer being used by the
    // reader.
    HRESULT CloseReaderFile(IN DVRIOP_FILE_ID nFileId);

    // Returns the start and end times of the file. Note that the end time is 
    // maximum time extent of the file, even if this value is greater than 
    // the stream time of the last sample that was written. Times returned are 
    // stream times. This call works even if the file is invalid, but returns
    // S_FALSE. It returns S_OK if the file is valid.
    HRESULT GetTimeExtentForFile(IN DVRIOP_FILE_ID nFileId,
                                 OUT QWORD*        pcnsStartStreamTime OPTIONAL,  
                                 OUT QWORD*        pcnsEndStreamTime OPTIONAL);


    // Returns the time extent of the buffer as stream times. Note that 
    // m_cnsStartTime and m_cnsLastStreamTime are returned.
    HRESULT GetTimeExtent(OUT QWORD*        pcnsStartStreamTime OPTIONAL,  
                          OUT QWORD*        pcnsLastStreamTime OPTIONAL);

    // Returns the first valid stream time after cnsStreamTime. (A stream time
    // is "valid" if it is backed by a file.)
    // We return E_FAIL if cnsStreamTime = MAXQWORD and m_cnsEndTime
    //
    // Note: Ring Buffer writer uses this function
    //
    HRESULT GetFirstValidTimeAfter(IN  QWORD    cnsStreamTime,  
                                   OUT QWORD*   pcnsNextValidStreamTime);

    // Returns the last valid stream time before cnsStreamTime. (A stream time
    // is "valid" if it is backed by a file.)
    // We return E_FAIL if cnsStreamTime = 0 and m_cnsStartTime
    //
    // Note: Ring Buffer writer uses this function
    //
    HRESULT GetLastValidTimeBefore(IN  QWORD    cnsStreamTime,  
                                   OUT QWORD*   pcnsLastValidStreamTime);

};


class CDVRRingBufferWriter : public IDVRRingBufferWriter {

private:

    // ======== Data members

    // ====== For the writer

    // The following are set in the constructor and never change 
    // after that
    DWORD           m_dwNumberOfFiles;          // in the DVR file collection
                                                // backing the ring buffer
    QWORD           m_cnsTimeExtentOfEachFile;  // in nanoseconds
    IWMProfile*     m_pProfile;                 // addref'd and released in 
                                                // Close().
    DWORD           m_dwIndexStreamId;          // id of index stream, set to MAXDWORD 
                                                // if no stream should be indexed.
    HKEY            m_hRegistryRootKey;         // DVR registry key
    HKEY            m_hDvrIoKey;                // DVR\IO registry key
    LPWSTR          m_pwszDVRDirectory;

    // Each ASF_WRITER_NODE represents an ASF writer object and could be 
    // associated with an ASF file that is being written to at any instant.
    //
    // m_leWritersList has a list of nodes that actually correspond to ASF
    // files being written; this list is sorted in increasing order of the 
    // stream time corresponding to the ASF file. 
    //
    // The constructor adds one node to m_leWritersList by calling 
    // AddATemporaryFile so that the file creation overhead is not
    // incurred when writing the first sample.
    //
    // WriteSample detects when an open file should be closed by checking
    // if the sample's time exceeds the file's extent by more than 
    // m_cnsMaxStreamDelta. A request is issued to close the file 
    // asynchronously by calling CloseAllWriterFilesBefore and the list node
    // is transferred to the head of m_leFreeList.
    //
    // WriteSample also detects when a file should be opened - it always
    // verifies that there is a node, q, in m_leWritersList after the node, p,
    // it is writing to and either (a) p's end time is MAXQWORD (i.e., p
    // is a DVR recording file - note that StartingStreamTimeKnown flag cannot
    // be 0 in WriteSample) or (b) q's start time is contiguous with p's end
    // time. (In case (a), q's start and end times would both be set to 
    // MAXQWORD.) Note that the node after p could be a a DVR 
    // recording whose start time is "well into the future"; in this case
    // WriteSample should add a node, q, after p. If a node has to be added, 
    // WriteSample removes a node from m_leFreeList, inserts it to 
    // m_leWritersList and issues a request to asynchronously open the file 
    // by calling AddATemporaryFile. 
    //
    // All clean up is done in the Close method.

    struct ASF_RECORDER_NODE;       // Forward reference

    struct ASF_WRITER_NODE 
    {

        #if defined(DEBUG)
        #undef DVRIO_DUMP_THIS_FORMAT_STR
        #define DVRIO_DUMP_THIS_FORMAT_STR ""
        #undef DVRIO_DUMP_THIS_VALUE
        #define DVRIO_DUMP_THIS_VALUE
        #endif

        // Data members

        QWORD               cnsStartTime;   // stream time
        QWORD               cnsEndTime;     // stream time
        QWORD*              pcnsFirstSampleTimeOffsetFromStartOfFile;

#if defined(DVR_UNOFFICIAL_BUILD)
        QWORD               cnsLastStreamTime; // last stream time written to this file; 
                                               // used only when a validation file is written
#endif // if defined(DVR_UNOFFICIAL_BUILD)

        LIST_ENTRY          leListEntry;
        IWMWriter*          pWMWriter;
        IWMWriterAdvanced3*  pWMWriterAdvanced;
        IDVRFileSink*       pDVRFileSink;

#if defined(DVR_UNOFFICIAL_BUILD)
        // hVal is the handle to the validation file: All data sent to 
        // WriteSample is dumped to this file along with the stream number
        // and stream times
        HANDLE              hVal;
        HKEY                hDvrIoKey;
#endif // if defined(DVR_UNOFFICIAL_BUILD)

        // pwszFileName is set only so that the file anme can be passed
        // on to the ProcessOpenRequest (a static member function) to
        // open the file. It is set only for temporary nodes. 
        // ProcessOpenRequest frees this member by calling delete and sets
        // it to NULL. For permanent nodes, ProcessOpenRequest uses
        // pRecorderNode->pwszFileName to open the file.
        LPCWSTR                 pwszFileName;

        // NULL if this node is a temporary node; else a pointer
        // to the node in the recorders list
        struct ASF_RECORDER_NODE* pRecorderNode;

        // The ring buffer's file identifier
        CDVRFileCollection::DVRIOP_FILE_ID nFileId;

        // Have the memory mapping handles been dupd? 
        enum {
            ASF_WRITER_NODE_HANDLES_NOT_DUPD,
            ASF_WRITER_NODE_HANDLES_DUPD,
            ASF_WRITER_NODE_HANDLES_DUP_FAILED,
        } nDupdHandles;

        // hReadyToWriteTo is set after the file has been opened.
        // WriteSample blocks on this event till it is set. The event
        // is reset after the node has been removed from m_leWritersList
        // and before the close file request is issued.
        HANDLE              hReadyToWriteTo;

        // hFileClosed is set when nodes are created and reset when the 
        // node is removed from m_leFreeList. It remains reset when the 
        // close file request is issued and the node is returned to
        // m_leFreeList. After the file has been closed, the event is 
        // signaled again. The Close() method moves all nodes from 
        // m_leWritersList to m_leFreeList and issues asynchronous close 
        // requests for all of them by calling CloseAllWriterFilesBefore.
        // it then waits till the hFileClosed event of each node in 
        // m_leFreeList is signaled. Similarly, when a node has to be 
        // removed from m_leFreeList to be added to m_leWritersList,
        // it is verified that hFileClosed is set.
        HANDLE              hFileClosed;

        // The returned results of the asynchronous open/close (BeginWriting/
        // EndWriting) operations are stored in hrRet.
        HRESULT             hrRet;

        // Methods
        ASF_WRITER_NODE(HRESULT* phr = NULL) 
            : cnsStartTime(0)
            , cnsEndTime(0)
            , pWMWriter(NULL)
            , pWMWriterAdvanced(NULL)
            , pcnsFirstSampleTimeOffsetFromStartOfFile(NULL)
            , nFileId(CDVRFileCollection::DVRIOP_INVALID_FILE_ID)
            , nDupdHandles(ASF_WRITER_NODE_HANDLES_NOT_DUPD)
            , pRecorderNode(NULL)
            , pwszFileName(NULL)
            , pDVRFileSink(NULL)

#if defined(DVR_UNOFFICIAL_BUILD)

            , hVal(NULL)
            , cnsLastStreamTime(0)

#endif // if defined(DVR_UNOFFICIAL_BUILD)
        {
            #if defined(DVRIO_THIS_FN)
            #undef DVRIO_THIS_FN
            #endif // DVRIO_THIS_FN
            #define DVRIO_THIS_FN "CDVRRingBufferWriter::CDVRRingBufferWriter"

            DVRIO_TRACE_ENTER();

            HRESULT hrRet;
            
            __try
            {
                NULL_NODE_POINTERS(&leListEntry);
                
                hReadyToWriteTo = ::CreateEvent(NULL, TRUE, FALSE, NULL);
                if (hReadyToWriteTo == NULL)
                {
                    DWORD dwLastError = ::GetLastError();
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                    "CreateEvent (hReadyToWriteTo) failed; last error = 0x%x", 
                                    dwLastError);
                    hrRet = HRESULT_FROM_WIN32(dwLastError);
                    hFileClosed = NULL;
                    __leave;
                }

                // Manual reset event, initially set
                hFileClosed = ::CreateEvent(NULL, TRUE, TRUE, NULL);
                if (hFileClosed == NULL)
                {
                    DWORD dwLastError = ::GetLastError();
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                    "CreateEvent (hFileClosed) failed; last error = 0x%x", 
                                    dwLastError);
                    hrRet = HRESULT_FROM_WIN32(dwLastError);

                    __leave;
                }
                hrRet = S_OK;
            }
            __finally
            {
                if (phr)
                {
                    *phr = hrRet;
                }
                DVRIO_TRACE_LEAVE0();
            }
        }

        ~ASF_WRITER_NODE()
        {
            // These handles could be NULL, that's ok - CloseHandle will fail
            ::CloseHandle(hReadyToWriteTo);
            ::CloseHandle(hFileClosed);
            DVR_ASSERT(pRecorderNode == NULL, "");

            // pwszFileName is set to NULL in ProcessOpenRequest
            DVR_ASSERT(pwszFileName == NULL, "");

            DVR_ASSERT(pDVRFileSink == NULL, "");

#if defined(DVR_UNOFFICIAL_BUILD)
            DVR_ASSERT(hVal == NULL, "");
#endif // if defined(DVR_UNOFFICIAL_BUILD)
            
            if (pWMWriter)
            {
                pWMWriter->Release();
            }
            if (pWMWriterAdvanced)
            {
                pWMWriterAdvanced->Release();
            }
        }

        void SetRecorderNode(struct ASF_RECORDER_NODE* p)
        {
            DVR_ASSERT(p == NULL || pRecorderNode == NULL, 
                       "pRecorderNode being set a second time.");
            pRecorderNode = p;
        }
    
        #if defined(DEBUG)
        #undef DVRIO_DUMP_THIS_FORMAT_STR
        #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
        #undef DVRIO_DUMP_THIS_VALUE
        #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
        #endif

    };
    
    typedef ASF_WRITER_NODE *PASF_WRITER_NODE;

    LIST_ENTRY              m_leWritersList;
    LIST_ENTRY              m_leFreeList;

    // The maximum stream time delta, initially set to 0 and initialized by the 
    // client's calling SetMaxStreamDelta.
    QWORD                   m_cnsMaxStreamDelta;
    
    // The constructor calls AddATemporaryFile so that we do not incur the 
    // overhead of "priming a file" when the first sample is written. However,
    // the stream times of the list node in m_leWritersList cannot be set in the
    // constructor - they are unknown till the first sample is written. Tbe
    // StartingStreamTimeKnown flag tracks this. It is set to 0 in 
    // the constructor and set to 1 when SetFirstSampleTime is called.
    // SetFirstSampleTime cannot be called more than once successfully..
    QWORD                   m_cnsFirstSampleTime;

    // Calls to WriteSample succeed only if m_cnsMaxStreamDelta has been set
    // and the Close method has not been called. m_nNotOkToWrite is set to -2
    // in the constructor, incremented in the first successful calls to 
    // SetMaxStreamDelta and SetFirstSampleTime, and decremented in Close. 
    // It's okay to write iff m_nNotOkToWrite == 0. If internal errors
    // have occurred, m_nNotOfToWrite is set to MINLONG; if it is MINLONG,
    // it is never changed.
    LONG                    m_nNotOkToWrite;

    typedef enum {
        StartingStreamTimeKnown = 1,
        WriterClosed            = 2,    // Has Close() been successfully called?
        MaxStreamDeltaSet       = 4,
        SampleWritten           = 8,    // 1 sample has been successfully written or 
                                        // we hit an irrecoverable error in the first
                                        // call to WriteSample (and so m_nNotOkToWrite is
                                        // set to MINLONG).
        FirstTempFileCreated    = 16,   // Used to query kwszTempRingBufferFileNameValue
        EnforceIncreasingTimeStamps = 32// Time stamps provided to the SDK are monotonically
                                        // increasing with a spread of at least 1 msec; if 
                                        // timestamps provided to the writer are <=
                                        // *m_pcnsCurrentStreamTime, the sample's time is bumped
                                        // up to *m_pcnsCurrentStreamTime + 1 msec
    } DVRIOP_WRITER_FLAGS ;
    
    DWORD                   m_nFlags;

    BOOL IsFlagSet(DVRIOP_WRITER_FLAGS f) 
    {
        return (f & m_nFlags)? 1 : 0;
    }

    void SetFlags(DVRIOP_WRITER_FLAGS f)
    {
        m_nFlags |= f;
    }

    void ClearFlags(DVRIOP_WRITER_FLAGS f)
    {
        m_nFlags &= ~f;
    }

    // The lock that is held by WriteSample, Close, CreateRecorder, 
    // Start/StopRecording.
    CRITICAL_SECTION        m_csLock;

    // Ref count on this object
    LONG                    m_nRefCount;

    // ====== For the Recorder

    // m_leRecordersList has a list of recorders that have been created and
    // a) recording has not been started or
    // b) if recording has been started, it has not been stopped or cancelled
    // c) if recording has been stopped, all samples written have times <=
    //    the end recording time.
    //
    // When a recording is cancelled and when a recording is complete (the
    // writer file is closed because no more samples will go into the 
    // recorder file), the recorder is pulled out of m_leRecordersList.
    // The recorder node is not deleted till DeleteRecording is called.
    // 
    // If DeleteRecording is called when a) is true, the recording node is 
    // deleted at once and the node is pulled out of the list. If 
    // DeleteRecording is called when b) or c) is true, the node is marked
    // for deletion but not deleted till the recording is cancelled or
    // the recorded file has been closed.
    // 
    // Each node in this list is an ASF_RECORDER_NODE. This list is 
    // sorted in the order of start/stop times; nodes whose start times
    // are not set yet are put at the end of the list. (Start and stop
    // times of nodes are initialized to MAXQWORD.)
    //
    // CreateRecorder adds a node to m_leRecordersList. It also pulls a
    // node of m_leFreeList and saves it in the pWriterNode member of the
    // node it just added to m_leRecordersList. It then primes the file 
    // for recording and calls BeginWriting synchronously. It returns any
    // error returned by BeginWriting. Note that the start and end stream
    // times on the recorder node are unknown at this point.
    //
    // When StartRecording is called, the start time is set and end time is
    // set to infinite, the ASF_WRITER_NODE (saved in the pWriterNode member)
    // is carefully inserted into m_leWritersList based on its start time and
    // the start/end times on the previous and next nodes in m_leWritersList
    // are set correctly (note: start time of recording may be well into the
    // future, if so the writer node, q, that had been primed in WriteSample
    // goes before the recording node, else it goes after the recording 
    // node. Also take care of boundary case when recording node is
    // added and the StartingStreamTimeKnown flag is 0 and in general when the
    // start recording time is the same as the start time of a node in the 
    // writers list.) After inserting the node, a file is added to the file
    // collection object.
    //
    // After adding node to m_leWritersList, the pWriterNode member is still
    // set to the recorder ASF_WRITER_NODE. This allows the ASF_WRITER_NODE
    // to be accessed later.
    //
    // When StopRecording is called, the end time is set on the recorder node
    // and the times in all nodes in the writers list after that are adjusted
    // StopRecording should fail if the end time is less than the start recording 
    // time or less than or equal to the current stream time. If the time
    // supplied to StopRecording is the same as the start recording time, the 
    // recording is cancelled (provided that no samples have been written to the 
    // recorder file, else the call fails).
    //
    // Files of recordings that are cancelled should be deleted by the client.
    //
    // DeleteRecorder marks a node for recording; as described above the node 
    // might either be deleted right away or after the recording is completed
    // or cancelled.
    //
    // If Start and Stop Recording are called on a recorder with times T1 and T2
    // and then SetFirstSampleTime is called with time = T3 > T2, the recording
    // file is closed when SetFirstSampleTime is called. If T1 < T3 < T2, the 
    // recorder's start time is changed from T1 to T3.
    //
    struct ASF_RECORDER_NODE 
    {

        #if defined(DEBUG)
        #undef DVRIO_DUMP_THIS_FORMAT_STR
        #define DVRIO_DUMP_THIS_FORMAT_STR ""
        #undef DVRIO_DUMP_THIS_VALUE
        #define DVRIO_DUMP_THIS_VALUE
        #endif

        // Data members
        
        // Note that some of the members here are redundant. This is to 
        // allow us to switch the implementation to handle overlapped 
        // recordings (i.e., ASX files) with as few changes as possible.
        // If we had ASX files, we don't need pWriterNode. CreateRecording 
        // would not pull an ASF_WRITER_NODE from m_leFreeList and 
        // StartRecording would not insert pWriterNode into m_leWritersList.
        // Instead, StartRecording would call SetFileTimes to ensure
        // to set some one writer's node had its start time equal to the 
        // start recording time and we would need a method in 
        // CDVRFileCollection to change the temporary attribute of a file
        // node to permanent (note that once the attribute is changed, 
        // CDVRFileCollection would have to call UpdateTimeExtent to 
        // update the file collection's extent). Each call to WriteSample
        // would call a method (currently not spec'd) on each CDVRRecorder
        // to update the extent and the file list in the ASX file; to do 
        // this it would use the pRecorderInstance member (which is 
        // currently unused since we do not have any need to callback the 
        // recorder object from the ring buffer writer class currently).

        // The following are generally in sync with the start, end times
        // on pWriterNode. However, pWriterNode is set to NULL when the
        // recording file is closed. or when recording is cancelled. 
        QWORD                   cnsStartTime;
        QWORD                   cnsEndTime;

        // For ASX files, following member can be removed as noted above
        PASF_WRITER_NODE        pWriterNode;

        // A pointer to the recorder instance. We do NOT addref this
        // member since the recorder instance holds a ref count on the
        // ring buffer writer. The recorder instance calls DeleteRecording 
        // before it is destroyed at which time we delete this node and
        // will not use pRecorderInstance any more.
        CDVRRecorder*           pRecorderInstance;

        LIST_ENTRY              leListEntry;

        LPCWSTR                 pwszFileName;

        typedef enum {
            DeleteRecorderNode      = 1,    // Recorder's file has been written and 
                                            // closed or StartRecording has not been 
                                            // called. If this flag is set,
                                            // recorder node will be 
                                            // deleted when DeleteRecorder is called

            RecorderNodeDeleted     = 2,    // DeleteRecorder sets this flag. It 
                                            // deletes the recorder node only if
                                            // the DeleteRecorderNode flag is set.
            // If this flag is set, this node holds a refcount on
            // pRecorderInstance and it is released when this object is 
            // destroyed. This refcount is held on behalf of the creator
            // and allows the creator to release its refcount on the 
            // object without destroying pRecorderInstance. (Destroying
            // pRecorderInstance has the side effect of stopping the recording
            // immediately if it is in progress and just deleting the 
            // recording if it has not been started.) The creator must 
            // ensure that it has set the start and stop times on the 
            // recording before releasing its refcount; if it does not,
            // it has to call GetRecordings to get back an IDVRRecorder.
            //
            // Note that this object is destroyed when the recording file
            // is closed (which happens when the writer is closed or the
            // the sample time goes past the recorder's stop time). This is
            // when the refcount on pRecorderInstance is released.
            PersistentRecording     = 4

        } DVRIOP_ASF_RECORDER_NODE_FLAGS;
    
        DWORD                   m_nFlags;

        // Result of the recording, viz., of BeginWriting, WriteSample
        // EndWriting, etc.
        HRESULT                 hrRet;

        // Methods
        ASF_RECORDER_NODE(LPCWSTR           pwszFileNameParam,  // MUST be new'd, destructor deletes
                          HRESULT*          phr = NULL)
            : cnsStartTime(MAXQWORD)
            , cnsEndTime(MAXQWORD)
            , pRecorderInstance(NULL)                 // Set later
            , pWriterNode(NULL)                       // Set later
            , pwszFileName(pwszFileNameParam)
            , m_nFlags(DeleteRecorderNode)
            , hrRet(S_OK)
        {
            NULL_NODE_POINTERS(&leListEntry);

            if (phr) 
            {
                *phr = S_OK;
            }
        }

        ~ASF_RECORDER_NODE();

        void SetRecorderInstance(CDVRRecorder* p)
        {
            DVR_ASSERT(pRecorderInstance == NULL, 
                       "pRecorderInstance being set a second time.");
            pRecorderInstance = p;
        }

        void SetWriterNode(PASF_WRITER_NODE p)
        {
            DVR_ASSERT(p == NULL || pWriterNode == NULL, 
                       "pWriterNode being set a second time.");
            pWriterNode = p;
        }

        BOOL IsFlagSet(DVRIOP_ASF_RECORDER_NODE_FLAGS f) 
        {
            return (f & m_nFlags)? 1 : 0;
        }

        void SetFlags(DVRIOP_ASF_RECORDER_NODE_FLAGS f)
        {
            m_nFlags |= f;
        }

        void ClearFlags(DVRIOP_ASF_RECORDER_NODE_FLAGS f)
        {
            m_nFlags &= ~f;
        }
    
        #if defined(DEBUG)
        #undef DVRIO_DUMP_THIS_FORMAT_STR
        #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
        #undef DVRIO_DUMP_THIS_VALUE
        #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
        #endif

    };
    
    typedef ASF_RECORDER_NODE *PASF_RECORDER_NODE;

    LIST_ENTRY        m_leRecordersList;

    // ====== For the Ring Buffer
    // We need a method on the ring buffer that returns a pointer to 
    // its member that holds the max stream time of any written sample (i.e.,
    // max time extent of the ring buffer). WriteSample updates this variable

    QWORD*                  m_pcnsCurrentStreamTime;
    CDVRFileCollection*     m_pDVRFileCollection;   // The ring buffer's 
                                                    // collection of files

    // Similarly, the file collection provides a pointer to a member variable
    // which determines if the writer has stopped writing. The writer updates
    // this; updates must use the Interlocked functions
    LONG*                   m_pnWriterHasBeenClosed;

    // ====== Debug data members
#if defined(DEBUG)
    static DWORD            m_dwNextClassInstanceId;
    DWORD                   m_dwClassInstanceId;
#endif

    // ====== Protected methods
protected:

    // Called asynchronously by a worker thread to "open" ASF files 
    // - this is the callback fn supplied to QueueUserWorkItem.
    // Calls BeginWriting, sets open event.
    // Parameter is actually ASF_WRITER_NODE*
    static DWORD WINAPI ProcessOpenRequest(LPVOID);

    // Removes a free node from the free list (or allocs one), sets outputfilename,
    // sets WM profile and issues request to call BeginWriting async by calling 
    // QueueUserWorkItem with ProcessOpenRequest as the callback function. 
    // On failure, sets rpFreeNode to NULL, cleans up the free node's members and
    // leaves the node in the free list.
    HRESULT PrepareAFreeWriterNode(IN  LPCWSTR                            pwszFileName,
                                   IN  QWORD                              cnsStartTime,
                                   IN  QWORD                              cnsEndTime,    
                                   IN  QWORD*                             pcnsFirstSampleTimeOffsetFromStartOfFile,
                                   IN  CDVRFileCollection::DVRIOP_FILE_ID nFileId,
                                   IN PASF_RECORDER_NODE                  pRecorderNode,
                                   OUT LIST_ENTRY*&                       rpFreeNode);

    // Adds pCurrent to the writer's list. Start and end times must be set
    // on the writer node corresponding to pCurrent. If these times overlap
    // the start, end times of any other node already in m_leWritersList,
    // the node is not added.
    HRESULT AddToWritersList(IN LIST_ENTRY*   pCurrent);

    // Adds a temporary file to the file collection object by calling AddFile
    // (file collection may remove other temporary files as a result of this call)
    // and to the writer's list. Calls PrepareAFreeWriterNode to get and prep 
    // a free node. Calls AddToWritersList to add the node to m_leWritersList
    HRESULT AddATemporaryFile(IN QWORD   cnsStartTime,
                              IN QWORD   cnsEndTime);

    // Called asynchronously by a worker thread to close ASF files 
    // - this is the callback fn supplied to QueueUserWorkItem.
    // Calls EndWriting, set closed event. 
    // Parameter is actually ASF_WRITER_NODE*
    static DWORD WINAPI ProcessCloseRequest(LPVOID);
                                                
    // Call this function to close a writer node after the work item to 
    // ProcessOpenRequest has been queued. The call to BeginWriting 
    // need not have been successful. This function closes the file if
    // BeginWriting succeeded and adds the node to the free list. It
    // deletes the writer node if it hits any error. The argument is a
    // pointer to the writer node's leListEntry member.
    HRESULT CloseWriterFile(LIST_ENTRY* pCurrent);

    // Call this function to close all writer files in m_leWritersList 
    // whose end times are <= cnsStreamTime.
    //
    // Called in WriteSample if the first node's 
    // endtime < sampletime-maxstreamdelta.
    // Called in Close to close all files, supply INFINITE for the argument,
    HRESULT CloseAllWriterFilesBefore(QWORD cnsStreamTime); 

    // ====== Protected methods to support recorders

    // Adds pCurrent to the recorder's list. Start and end times must be set
    // on the recorder node corresponding to pCurrent. If these times overlap
    // the start, end times of any other node already in m_leRecordersList,
    // the node is not added.
    HRESULT AddToRecordersList(IN LIST_ENTRY*   pCurrent);

    // ====== Public methods
public:

    // ====== For the Recorder 

    // The recorder identifier is handed over to the recorder object
    // when it is constructed. This is not really necessary now as 
    // we support only 1 recorder object at any time. pRecorderId
    // is a pointer to the ASF_RECORDER_NODE's leListEntry member.

    // If this is a recording file, we call ring buffer ONLY at start recording
    // time and supply file name and start stream time, ring buffer just adds 
    // file to list. We would already have called BeginWriting before this when
    // recorder is created.
    HRESULT StartRecording(IN LPVOID pRecorderId, IN QWORD cnsStartTime);

    // To stop recording at the next time instant (current stream time + 1), 
    // cnsStopTime can be 0 and a non-zero value is passed in for bNow.
    // Send in recorder's start time to cancel the recording.
    HRESULT StopRecording(IN LPVOID pRecorderId, IN QWORD cnsStopTime, IN BOOL bNow);
    
    HRESULT DeleteRecorder(IN LPVOID pRecorderId);
    
    HRESULT GetRecordingStatus(IN LPVOID pRecorderId,
                               OUT HRESULT* phResult OPTIONAL,
                               OUT BOOL*  pbStarted OPTIONAL,
                               OUT BOOL*  pbStopped OPTIONAL,
                               OUT BOOL*  pbSet);

    HRESULT HasRecordingFileBeenClosed(IN LPVOID pRecorderId);

    // Constructor: arguments same as DVRCreateRingBufferWriter,
    // except that the OUT param is a HRESULT rather than an
    // IDVRRingBufferWriter
    CDVRRingBufferWriter(IN  DWORD       dwNumberOfFiles,
                         IN  QWORD       cnsTimeExtentOfEachFile,
                         IN  IWMProfile* pProfile,
                         IN  DWORD       dwIndexStreamId,
                         IN  HKEY        hRegistryRootKey,
                         IN  HKEY        hDvrIoKey,
                         IN  LPCWSTR     pwszDVRDirectory OPTIONAL,
                         OUT HRESULT*    phr);

    virtual ~CDVRRingBufferWriter();

    // ====== COM interface methods
public:

    // IUnknown

    STDMETHODIMP QueryInterface(IN REFIID riid, OUT void **ppv);
    
    STDMETHODIMP_(ULONG) AddRef();
    
    STDMETHODIMP_(ULONG) Release();

    // IDVRRingBufferWriter
    
    STDMETHODIMP SetFirstSampleTime(IN QWORD cnsStreamTime);

    STDMETHODIMP WriteSample(IN WORD  wStreamNum,
                             IN QWORD cnsStreamTime,
                             IN DWORD dwFlags,
                             IN INSSBuffer *pSample);

    STDMETHODIMP SetMaxStreamDelta(IN QWORD  cnsMaxStreamDelta);

    STDMETHODIMP Close(void);

    // Note that this primes a writer node, but does not add it
    // to the writers list. StartRecording does that.
    STDMETHODIMP CreateRecorder(IN  LPCWSTR        pwszDVRFileName, 
                                IN  DWORD          dwReserved,
                                OUT IDVRRecorder** ppDVRRecorder);

    STDMETHODIMP CreateReader(OUT IDVRReader** ppDVRReader);

    STDMETHODIMP GetDVRDirectory(OUT LPWSTR* ppwszDirectoryName);

    STDMETHODIMP GetRecordings(OUT DWORD*   pdwCount,
                               OUT IDVRRecorder*** pppIDVRRecorder OPTIONAL,
                               OUT LPWSTR** pppwszFileName OPTIONAL,
                               OUT QWORD**  ppcnsStartTime OPTIONAL,
                               OUT QWORD**  ppcnsStopTime OPTIONAL,
                               OUT BOOL**   ppbStarted OPTIONAL);

    STDMETHODIMP GetStreamTime(OUT QWORD*   pcnsStreamTime);
};

class CDVRRecorder : public IDVRRecorder {

private:
    // ======== Data members

    // m_cnsStartTime is set to MAXQWORD till recording is 
    // started and m_cnsEndTime is set to MAXQWORD till 
    // recording is stoppped
    QWORD                   m_cnsStartTime;
    QWORD                   m_cnsEndTime;

    // ====== For the writer

    // The following are set in the constructor and never change 
    // after that
    CDVRRingBufferWriter*   m_pWriter;
    LPVOID                  m_pWriterProvidedId;

    // The lock that is held by Start/StopRecording.
    CRITICAL_SECTION        m_csLock;

    // Ref count on this object
    LONG                    m_nRefCount;

    // Debug data members
#if defined(DEBUG)
    static DWORD            m_dwNextClassInstanceId;
    DWORD                   m_dwClassInstanceId;
#endif

public:

    // Constructor
    CDVRRecorder(IN CDVRRingBufferWriter*  pWriter,
                 IN  LPVOID                pWriterProvidedId,
                 OUT HRESULT*              phr);

    virtual ~CDVRRecorder();

    // ====== COM interface methods
public:

    // IUnknown

    STDMETHODIMP QueryInterface(IN REFIID riid, OUT void **ppv);
    
    STDMETHODIMP_(ULONG) AddRef();
    
    STDMETHODIMP_(ULONG) Release();

    // IDVRRecorder
    
    STDMETHODIMP StartRecording(IN QWORD cnsRecordingStartStreamTime);
    
    STDMETHODIMP StopRecording(IN QWORD cnsRecordingStopStreamTime);

    STDMETHODIMP CancelRecording();

    STDMETHODIMP GetRecordingStatus(OUT HRESULT* phResult OPTIONAL,
                                    OUT BOOL* pbStarted OPTIONAL,
                                    OUT BOOL* pbStopped OPTIONAL);

    STDMETHODIMP HasFileBeenClosed();
};

class CDVRReader : public IDVRReader, public IDVRSourceAdviseSink {

private:
    // ======== Data members

    // Following members are set in the constructor and not changed
    // after that
    HKEY            m_hRegistryRootKey;         // DVR registry key
    HKEY            m_hDvrIoKey;                // DVR\IO registry key

    // ====== For the reader

    // Each ASF_READER_NODE represents an ASF reader object and could be 
    // associated with an ASF file that is being read or with an ASF file
    // whose IWMProfile has been handed out via GetProfile()..
    //
    // m_leFreeList keeps a list of unused ASF_READER_NODE objects.
    // m_leReadersList has a list of nodes that actually correspond to ASF
    // files being read or whose profiles are in use; this list is sorted 
    // by increasing file ids of the ASF files. Note that we do not 
    // maintain the stream times in the nodes since they could be changed
    // if the writer calls SetFileTime. We always call into the associated
    // ring buffer if we wish to determine the time extent of a reader node.
    //
    // GetNextSample detects when an open file should be closed. If 
    // GetNextSample is called consecutively more than m_dwMinConsecutiveReads
    // times without an intervening call to Seek, all open files that have an
    // earlier end time than the file being read (except any file whose profile
    // object is in use) are asynchronously closed by calling CloseReaderFiles
    // and the nodes are transferred to m_leFreeList:
    //
    // GetNextSample tests if the current file is valid in the ring buffer 
    // before reading; if the file has been removed from the ring buffer, 
    // it fails the call. In these cases and in all cases that the read fails,  
    // it calls CloseReaderFiles to close all files (except any file whose 
    // profile object is in use). Note that in these cases, m_leReadersList 
    // could become empty.
    //
    // Also, if the ASF read call made by GetNextSample returns end-of-file, 
    // GetNextSample tests if the file is valid. If it is not, it fails
    // the call and, as before, calls CloseReaderFiles to close all files.
    // The reason we do this is that the reader of a live source may start 
    // reading from time 0 and the writer may write the first sample at 
    // time T1 > 0 to a file different from the one to which the reader was 
    // reading (the one that the reader was reading has its start time set to
    // its end time and is closed by the writer - see SetFileTimes). Typically
    // this will happen only if a StartRecording(T1) command was issued before 
    // the first sample was written and the first sample's time was >= T1
    // (where T1 > the extent of each writer file, i.e., the writer's
    // m_cnsTimeExtentOfEachFile member).
    //
    // Files are NOT closed asynchronously in ReleaseProfile(), see that 
    // function for an explanation.
    //
    // GetNextSample also detects when a file should be opened - it checks
    // that there is a node, q, in m_leReadersList after the node p
    // it is reading such that q's stream times immediately follows p's. 
    // Of course, this is possible only if the reader is reading a live source
    // and is trailing the writer by a file or more. GetNextSample calls the
    // its GetFileAtTime() method to determine if a file can be 
    // opened; and if so, to open it asynchronously.  Note that the reader
    // may be keeping up with the writer, so it may not be possible to 
    // open a file ahead of time. For this reason, GetNextSample tries to
    // open the next reader file only every m_dwMinConsecutiveReads calls.
    // Also, the open next reader file stuff is done only if the source
    // is live (till we support ASX files, it is not done for live files).
    //
    // Files are also opened synchronously in Seek() in GetProfile().
    // 
    // All clean up is done in the Close method, which is called by the 
    // destructor.

    struct ASF_READER_NODE 
    {

        #if defined(DEBUG)
        #undef DVRIO_DUMP_THIS_FORMAT_STR
        #define DVRIO_DUMP_THIS_FORMAT_STR ""
        #undef DVRIO_DUMP_THIS_VALUE
        #define DVRIO_DUMP_THIS_VALUE
        #endif

        LIST_ENTRY          leListEntry;
        IWMSyncReader*      pWMReader;
        IDVRFileSource*     pDVRFileSource;
        QWORD*              pcnsFirstSampleTimeOffsetFromStartOfFile;

        // Must be alloc'd with new; destructor deletes this member
        LPCWSTR             pwszFileName;

        // The ring buffer's file identifier
        CDVRFileCollection::DVRIOP_FILE_ID nFileId;

        // hReadyToReadFrom is set after the file has been opened.
        // GetNextSample and GetProfile block on this event till it is set.
        // The event is reset after the node has been removed from 
        // m_leReadersList and before the close file request is issued.
        HANDLE              hReadyToReadFrom;

        // hFileClosed is set when nodes are created and reset when the 
        // node is removed from m_leFreeList. It remains reset when the 
        // close file request is issued and the node is returned to
        // m_leFreeList. After the file has been closed, the event is 
        // signaled again. The Close() method moves all nodes from 
        // m_leReadersList to m_leFreeList and issues asynchronous close 
        // requests for all of them by calling CloseReaderFiles. It then 
        // waits till the hFileClosed event of each node in m_leFreeList 
        // is signaled. Similarly, when a node has to be removed from 
        // m_leFreeList to be added to m_leReadersList, it is verified 
        // that hFileClosed is set.
        HANDLE              hFileClosed;

        // The returned results of the asynchronous open/close
        // operations are stored in hrRet.
        HRESULT             hrRet;

        // These members are needed only to pass the timeout value to
        // ProcessOpenRequest, which is a static member function.
        // These variable are always initialized in PrepareAFreeReaderNode
        // before they are used in ProcessOpenRequest and they are not used
        // after that.
        DWORD               msTimeOut;
        HANDLE              hCancel;
    
        ASF_READER_NODE(HRESULT* phr = NULL) 
            : pWMReader(NULL)
            , pDVRFileSource(NULL)
            , pwszFileName(NULL)
            , nFileId(CDVRFileCollection::DVRIOP_INVALID_FILE_ID)
        {
            #if defined(DVRIO_THIS_FN)
            #undef DVRIO_THIS_FN
            #endif // DVRIO_THIS_FN
            #define DVRIO_THIS_FN "CDVRRingBufferWriter::CDVRRingBufferWriter"

            DVRIO_TRACE_ENTER();

            HRESULT hrRet;
            
            __try
            {
                NULL_NODE_POINTERS(&leListEntry);
                
                hReadyToReadFrom = ::CreateEvent(NULL, TRUE, FALSE, NULL);
                if (hReadyToReadFrom == NULL)
                {
                    DWORD dwLastError = ::GetLastError();
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                    "CreateEvent (hReadyToReadFrom) failed; last error = 0x%x", 
                                    dwLastError);
                    hrRet = HRESULT_FROM_WIN32(dwLastError);
                    hFileClosed = NULL;
                    __leave;
                }

                // Manual reset event, initially set
                hFileClosed = ::CreateEvent(NULL, TRUE, TRUE, NULL);
                if (hFileClosed == NULL)
                {
                    DWORD dwLastError = ::GetLastError();
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                    "CreateEvent (hFileClosed) failed; last error = 0x%x", 
                                    dwLastError);
                    hrRet = HRESULT_FROM_WIN32(dwLastError);

                    __leave;
                }
                hrRet = S_OK;
            }
            __finally
            {
                if (phr)
                {
                    *phr = hrRet;
                }
                DVRIO_TRACE_LEAVE0();
            }
        }

        ~ASF_READER_NODE()
        {
            // These handles could be NULL, that's ok - CloseHandle will fail
            ::CloseHandle(hReadyToReadFrom);
            ::CloseHandle(hFileClosed);

            if (pWMReader)
            {
                pWMReader->Release();
            }
            if (pDVRFileSource)
            {
                pDVRFileSource->Release();
            }
            delete [] pwszFileName;
        }

        void SetFileName(IN LPCWSTR pwszFileNameParam)
        {
            delete [] pwszFileName;
            pwszFileName = pwszFileNameParam;
        }

        #if defined(DEBUG)
        #undef DVRIO_DUMP_THIS_FORMAT_STR
        #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
        #undef DVRIO_DUMP_THIS_VALUE
        #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
        #endif

    };
    
    typedef ASF_READER_NODE *PASF_READER_NODE;

    // The minimum number of consecutive reads on a file (without intervening
    // seeks) that are necessary before other open files are closed
    DWORD                   m_dwMinConsecutiveReads;
    // The number of consecutive reads so far. The "open one file ahead of 
    // the current reader file" logic is suppressed if this member variable
    // is set to INFINTIE - which it is if the reader corresponds to a non-live
    // file (and till we support ASX files, to a live file)
    DWORD                   m_dwConsecutiveReads;
    LIST_ENTRY              m_leReadersList;
    LIST_ENTRY              m_leFreeList;

    // Pointer to file currently being read by GetNextSample; NULL
    // if none. Set by Seek and automatically changed by GetNextSample if 
    // it hits end-of-file on a read call and file is still valid after
    // the read call returns end-of-file.
    ASF_READER_NODE*        m_pCurrentNode;

    // The lock that is held by Seek, GetNextSample, GetProfile, 
    // ReleaeProfile, GetStreamTimeExtent.
    CRITICAL_SECTION        m_csLock;

    // Ref count on this object
    LONG                    m_nRefCount;

    // If we have issued a profile object via GetProfile to our client,
    // we set m_pProfileNode to the corresponding node. Any calls to 
    // GetProfile while this pointer is set return the profile object
    // associated with that ASF file and m_dwOutstandingProfileCount
    // is incremented. When m_dwOutstandingProfileCount falls to 0,
    // m_pProfileNode is set to NULL. Note that the node pointed to 
    // by m_pProfileNode always remains in m_leReadersList and the 
    // ASF file is remains open as long as m_pProfileNode is not NULL.
    // When m_pProfileNode is reset to NULL, the file is closed in the
    // usual way either because of a call to GetNextSample or to Close
    //
    // Note that if GetProfile succeeds, it AddRef's the reader object to 
    // prevent the client from destroying the reader object while it has
    // an outstanding profile object pointer.
    ASF_READER_NODE*        m_pProfileNode;
    IWMProfile*             m_pWMProfile;
    DWORD                   m_dwOutstandingProfileCount;

    // The following member is non NULL iff m_bDVRProgramFileIsLive is non-zero,
    // i.e., in the case we are reading a live file.
    // For ASX files, the code that uses this member will require some changes.
    ASF_READER_NODE*        m_pLiveFileReaderNode;

    // ====== For the Ring Buffer
    // m_pcnsCurrentStreamTime points to ring buffer variable that holds the 
    // current max time extent. If we create the ring buffer (i.e., we are 
    // reading a DVR program file), this is returned by the ring buffer's 
    // constructor and we initialize this variable. Otherwise, the
    // CDVRRingBufferWriter object that creates us hands us this pointer.
    //
    // Note that if are reading a live DVR program file, we'll update this 
    // variable periodically.

    QWORD*                  m_pcnsCurrentStreamTime;
    CDVRFileCollection*     m_pDVRFileCollection;   // The ring buffer's 
                                                    // collection of files

    BOOL                    m_bDVRProgramFileIsLive;// 0 if we are reading a 
                                                    // live source or a closed file,
                                                    // 1 if we are reading a live file
    BOOL                    m_bSourceIsAFile;       // 1 if we reading a file, 0 if we 
                                                    // reading a live source (ring buffer)

    // Reader updates the following member if it is reading a file; otherwise
    // the writer updates it and the reader just accesses it.
    LONG*                   m_pnWriterHasBeenClosed;// Pointer into file collection object

    // To support Cancel()
    HANDLE                  m_hCancel;

    // Debug data members
#if defined(DEBUG)
    static DWORD            m_dwNextClassInstanceId;
    DWORD                   m_dwClassInstanceId;
#endif

    // ====== Protected methods
protected:

    // Called asynchronously by a worker thread to open ASF files 
    // - this is the callback fn supplied to QueueUserWorkItem.
    // Calls Open, other stuff such as SetReadCompressedSamples, sets open event.
    // Parameter is actually ASF_READER_NODE*
    static DWORD WINAPI ProcessOpenRequest(LPVOID);

    // Removes a free node from the free list (or allocs one) and issues request
    // to open the ASF by calling QueueUserWorkItem with ProcessOpenRequest as 
    // the callback function. 
    //
    // pwszFileName must be alloc'd with new. The function takes care of calling
    // delete on pwszFileName. Note that the pointer pwszFileName may be invalid
    // when the function returns - the file name could have been deleted if the 
    // function failed.
    //
    // On failure, sets rpFreeNode to NULL, cleans up the free node's members and
    // leaves the node in the free list.
    HRESULT PrepareAFreeReaderNode(IN LPCWSTR                              pwszFileName,
                                   IN DWORD                                msTimeOut,
                                   IN QWORD*                               pcnsFirstSampleTimeOffsetFromStartOfFile,
                                   IN CDVRFileCollection::DVRIOP_FILE_ID   nFileId,
                                   OUT LIST_ENTRY*&                        rpFreeNode);

    // Adds pCurrent to the reader's list. The file id must be set
    // on the reader node corresponding to pCurrent. If the id is 
    // the same as the id of any other node already in m_leReadersList,
    // the node is not added.
    HRESULT AddToReadersList(IN LIST_ENTRY*   pCurrent);

    // Opens a permanent file for reading (by calling PrepareAFreeReaderNode),
    // queries the file for it's time extent (and whether it is live), adds 
    // the file collection object by calling AddFile, and also adds the file 
    // to the reader's list by calling AddToReadersList.
    //
    // Currently, this funciton is called only from teh constructor; this will
    // change if we support ASX files (particularly live ASX files that are
    // opened for reading). This function will require some modifications in 
    // that case.
    HRESULT AddAPermanentFile(IN LPCWSTR pwszFileNameParam);

    // If a file corrsponding to cnsStreamTime is already in m_leReadersList,
    // this function returns a pointer to the list entry of the reader node. 
    // Else, this function calls the file collection object to determine the
    // file corresponding to cnsStreamTime (fails if there is none), opens
    // the file for reading (by calling PrepareAFreeReaderNode), and adds the
    // file to the reader's list by calling AddToReadersList. It returns a 
    // a pointer to the list entry of the reader node if it succeeds or NULL
    // if it fails in *pleReaderParam.
    HRESULT GetFileAtTime(IN  QWORD         cnsStreamTime,
                          IN  BOOL          bWaitTillFileIsOpened,
                          OUT LIST_ENTRY**  pleReaderParam);

    // Called asynchronously by a worker thread to close ASF files 
    // - this is the callback fn supplied to QueueUserWorkItem.
    // Calls Close (only if the open succeeeded - as indicated by
    // the reader node's hrRet member), sets closed event. 
    // Parameter is actually ASF_READER_NODE*
    static DWORD WINAPI ProcessCloseRequest(LPVOID);
                                                
    // Call this function to close a reader node file if PrepareAFreeReaderNode
    // succeeded and returned that reader node. The call to Open (the ASF file) 
    // need not have been successful. This function closes the ASF file if Open
    // adds the node to the free list. It also decrements the reader ref count 
    // for this file on the file colleciton object provided the file id of the 
    // reader node is not CDVRFileCollection::DVRIOP_INVALID_FILE_ID. (Note that
    // ProcessCloseRequest cannot do this because it is a static member function
    // and the file collection object is a member fo this class.) If this 
    // function hits an error, it still attempts to close the ASF file and then
    // it deletes the reader node
    //
    // The argument is a pointer to the reader node's leListEntry member.
    HRESULT CloseReaderFile(LIST_ENTRY* pCurrent);

    // Call this function to close all reader files in m_leReadersList 
    // whose end times are <= cnsStreamTime.
    //
    // Called in GetNextSample as described above
    // Called in Close to close all files, supply INFINITE for the argument,
    HRESULT CloseAllReaderFilesBefore(QWORD cnsStreamTime); 

    // Called by the destructor to close all files and clean up.
    // We do not expose this method in IDVRReader because then we'll 
    // have to check if the object's being used after being closed.
    HRESULT Close(void);

    // Sets m_pCurrentNode and resets all associated the member variables 
    void ResetReader(IN PASF_READER_NODE pReaderNode = NULL);

    // Updates the time extent (*m_pcnsCurrentStreamTime) for live DVR program files.
    // If the time extent has not changed, verifies if the file is still live and 
    // updates m_bDVRProgramFileIsLive.
    //
    // If the file is not live or the source is not a file (i.e., m_bDVRProgramFileIsLive
    // is 0, the function returns S_FALSE without doing anything)
    HRESULT UpdateTimeExtent();

    // ====== Public methods
public:

    // Constructor used by the ring buffer writer to read a live source
    // Constructor addrefs pRingBuffer
    CDVRReader(IN  CDVRFileCollection* pRingBuffer,
               IN  QWORD*              pcnsCurrentStreamTime,
               IN  LONG*               pnWriterHasBeenClosed,
               IN  HKEY                hRegistryRootKey,
               IN  HKEY                hDvrIoKey,
               OUT HRESULT*            phr);

    // Constructor used to read a DVR program file
    CDVRReader(IN  LPCWSTR             pwszFileName,
               IN  HKEY                hRegistryRootKey,
               IN  HKEY                hDvrIoKey,
               OUT HRESULT*    phr);

    virtual ~CDVRReader();

    // ====== COM interface methods
public:

    // IUnknown
    
    STDMETHODIMP QueryInterface(IN REFIID riid, OUT void **ppv);
    
    STDMETHODIMP_(ULONG) AddRef();
    
    STDMETHODIMP_(ULONG) Release();

    // IDVRReader
    
    STDMETHODIMP GetProfile(OUT IWMProfile** ppWMProfile);
    
    STDMETHODIMP ReleaseProfile(IN IWMProfile* pWMProfile);

    STDMETHODIMP Seek(IN QWORD cnsSeekStreamTime);

    // Fails if m_pCurrentNode is NULL, so the reader has to Seek 
    // before issuing the first call to GetNextSample. We do not
    // want to special case the first call to GetNextSample. 
    // Also, after the very first call to GetNextSample, the reader
    // should call GetStreamTimeExtent. The reason is that the 
    // reader may do the following:
    // - call GetStreamTimeExtent - returns (0, T)
    // - Seek(0)
    // - GetNextSample - returns sample time > 0 and either > or < T
    // - the reader should NOT assume that the start time of the stream
    //   is still 0. The writer could have changed it  after the call
    //   that the reader made to GetStreamTimeExtent and Seek because
    //   the writer may have written the first sample only after then. 
    //   So the reader should call GetStreamTimeExtent to determine 
    //   the correct start stream time. (Note also that the call to
    //   GetNextSample could fail if the writer invalidated that file -
    //   this is described in the section that spells out when reader
    //   files are closed.)
    STDMETHODIMP GetNextSample(OUT INSSBuffer**    ppSample,
                               OUT QWORD*          pcnsStreamTimeOfSample,
                               OUT QWORD*          pcnsSampleDuration,
                               OUT DWORD*          pdwFlags,
                               OUT WORD*           pwStreamNum);

    // For the end time, returns *m_pcnsCurrentStreamTime, which is not 
    // the end time returned by the file collection object's GetTimeExtent()
    STDMETHODIMP GetStreamTimeExtent(OUT QWORD*  pcnsStartStreamTime,
                                     OUT QWORD*  pcnsEndStreamTime);

    // Returns the first valid stream time after cnsStreamTime. (A stream time
    // is "valid" if it is backed by a file.)
    //
    // Returns E_FAIL if cnsStreamTime = MAXQWORD and m_cnsEndTime
    STDMETHODIMP GetFirstValidTimeAfter(IN  QWORD    cnsStreamTime,  
                                        OUT QWORD*   pcnsNextValidStreamTime);

    // Returns the last valid stream time before cnsStreamTime. (A stream time
    // is "valid" if it is backed by a file.)
    //
    // Returns E_FAIL if cnsStreamTime = 0 and m_cnsStartTime
     STDMETHODIMP GetLastValidTimeBefore(IN  QWORD    cnsStreamTime,  
                                         OUT QWORD*   pcnsLastValidStreamTime);

    // Cancels a pending and all subsequent calls to GetNextSample in
    // which the reader blocks (waiting for the writer to catch up).
    // Has no effect if the reader is reading a fully written file or
    // is lagging behind the reader.
    STDMETHODIMP Cancel();

    // Cancels a previous call to Cancel
    STDMETHODIMP ResetCancel();

    // Returns a non-zero value iff the source is live.
    STDMETHODIMP_(ULONG) IsLive();

    // IDVRSourceAdviseSink
    
    STDMETHODIMP ReadIsGoingToPend();

};

#if defined(DEBUG)
#undef DVRIO_DUMP_THIS_FORMAT_STR
#define DVRIO_DUMP_THIS_FORMAT_STR ""
#undef DVRIO_DUMP_THIS_VALUE
#define DVRIO_DUMP_THIS_VALUE
#endif

_inline CDVRRingBufferWriter::ASF_RECORDER_NODE::~ASF_RECORDER_NODE()
{
    delete [] pwszFileName;
    DVR_ASSERT(pWriterNode == NULL, "");
    if (IsFlagSet(PersistentRecording))
    {
        DVR_ASSERT(pRecorderInstance, "");
        pRecorderInstance->Release();
    }
}

#if defined(DEBUG)
#undef DVRIO_DUMP_THIS_FORMAT_STR
#define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
#undef DVRIO_DUMP_THIS_VALUE
#define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
#endif

#undef DVRIO_DUMP_THIS_FORMAT_STR
#undef DVRIO_DUMP_THIS_VALUE

#endif // _DVR_IOP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrio\dvrioreader.cpp ===
//------------------------------------------------------------------------------
// File: dvrIOReader.cpp
//
// Description: Implements the class CDVRReader
//
// Copyright (c) 2000 - 2001, Microsoft Corporation.  All rights reserved.
//
//------------------------------------------------------------------------------

#include <precomp.h>
#pragma hdrstop

HRESULT STDMETHODCALLTYPE  DVRCreateReader(IN  LPCWSTR      pwszFileName,
                                           IN  HKEY         hRegistryRootKeyParam OPTIONAL, 
                                           OUT IDVRReader** ppDVRReader)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "DVRCreateReader"

    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR ""
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE
    #endif

    DVRIO_TRACE_ENTER();

    if (!ppDVRReader || DvrIopIsBadWritePtr(ppDVRReader, 0) ||
        !pwszFileName || DvrIopIsBadStringPtr(pwszFileName))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }


    HRESULT         hrRet;
    CDVRReader*     p;
    HKEY            hDvrIoKey = NULL;
    HKEY            hRegistryRootKey = NULL;
    BOOL            bCloseKeys = 1; // Close all keys that we opened (only if this fn fails)


    *ppDVRReader = NULL;

    __try
    {
        DWORD dwRegRet;

        if (!hRegistryRootKeyParam)
        {
            dwRegRet = ::RegCreateKeyExW(
                            g_hDefaultRegistryHive,
                            kwszRegDvrKey,       // subkey
                            0,                   // reserved
                            NULL,                // class string
                            REG_OPTION_NON_VOLATILE, // special options
                            KEY_ALL_ACCESS,      // desired security access
                            NULL,                // security attr
                            &hRegistryRootKey,   // key handle 
                            NULL                 // disposition value buffer
                           );
            if (dwRegRet != ERROR_SUCCESS)
            {
                DWORD dwLastError = ::GetLastError();
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                                "RegCreateKeyExW for DVR key failed, last error = 0x%x",
                                dwLastError);
               hrRet = HRESULT_FROM_WIN32(dwLastError);
               __leave;
            }
        }
        else
        {
            if (0 == ::DuplicateHandle(::GetCurrentProcess(), hRegistryRootKeyParam,
                                       ::GetCurrentProcess(), (LPHANDLE) &hRegistryRootKey,
                                       0,       // desired access - ignored
                                       FALSE,   // bInherit
                                       DUPLICATE_SAME_ACCESS))
            {
                DWORD dwLastError = ::GetLastError();
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                                "DuplicateHandle failed for DVR IO key, last error = 0x%x",
                                dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }
        }

        dwRegRet = ::RegCreateKeyExW(
                        hRegistryRootKey,
                        kwszRegDvrIoReaderKey, // subkey
                        0,                   // reserved
                        NULL,                // class string
                        REG_OPTION_NON_VOLATILE, // special options
                        KEY_ALL_ACCESS,      // desired security access
                        NULL,                // security attr
                        &hDvrIoKey,          // key handle 
                        NULL                 // disposition value buffer
                       );
        if (dwRegRet != ERROR_SUCCESS)
        {
            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "RegCreateKeyExW for DVR IO key failed, last error = 0x%x",
                            dwLastError);
           hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

#if defined(DEBUG)
        // Until this point, we have been using default values for the debug levels
        DvrIopDbgInit(hRegistryRootKey);
#endif // DEBUG

        p = new CDVRReader(pwszFileName,
                           hRegistryRootKey, 
                           hDvrIoKey,
                           &hrRet);

        if (p == NULL)
        {
            hrRet = E_OUTOFMEMORY;
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "alloc via new failed - CDVRReader");
            __leave;
        }

        bCloseKeys = 0; // ~CDVRReader will close the keys
        
        if (FAILED(hrRet))
        {
            __leave;
        }


        hrRet = p->QueryInterface(IID_IDVRReader, (void**) ppDVRReader);
        if (FAILED(hrRet))
        {
            DVR_ASSERT(0, "QI for IID_IDVRReader failed");
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "CDVRReader::QueryInterface failed, hr = 0x%x", 
                            hrRet);
            __leave;
        }
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            delete p;

            if (bCloseKeys)
            {
                DWORD dwRegRet;

                if (hDvrIoKey)
                {
                    dwRegRet = ::RegCloseKey(hDvrIoKey);
                    if (dwRegRet != ERROR_SUCCESS)
                    {
                        DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                                   "Closing registry key hDvrIoKey failed.");
                    }
                }
                if (hRegistryRootKey)
                {
                    dwRegRet = ::RegCloseKey(hRegistryRootKey);
                    if (dwRegRet != ERROR_SUCCESS)
                    {
                        DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                                   "Closing registry key hRegistryRootKey failed.");
                    }
                }
            }
        }
        else
        {
            DVR_ASSERT(bCloseKeys == 0, "");
        }
    }

    DVRIO_TRACE_LEAVE1_HR(hrRet);
    return hrRet;

} // DVRCreateReader

// ====== Constructor, destructor

#if defined(DEBUG)
DWORD CDVRReader::m_dwNextClassInstanceId = 0;
#undef DVRIO_DUMP_THIS_FORMAT_STR
#define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
#undef DVRIO_DUMP_THIS_VALUE
#define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
#endif

CDVRReader::CDVRReader(IN  CDVRFileCollection* pRingBuffer,
                       IN  QWORD*              pcnsCurrentStreamTime,
                       IN  LONG*               pnWriterHasBeenClosed,
                       IN  HKEY                hRegistryRootKey,
                       IN  HKEY                hDvrIoKey,
                       OUT HRESULT*            phr)
    : m_dwConsecutiveReads(0)
    , m_hRegistryRootKey(hRegistryRootKey)
    , m_hDvrIoKey(hDvrIoKey)
    , m_pCurrentNode(NULL)
    , m_pProfileNode(NULL)
    , m_pLiveFileReaderNode(NULL)
    , m_pWMProfile(NULL)
    , m_dwOutstandingProfileCount(0)
    , m_pcnsCurrentStreamTime(pcnsCurrentStreamTime)
    , m_pnWriterHasBeenClosed(pnWriterHasBeenClosed)
    , m_pDVRFileCollection(pRingBuffer)
    , m_bDVRProgramFileIsLive(0)
    , m_nRefCount(1)
    , m_bSourceIsAFile(0)
#if defined(DEBUG)
    , m_dwClassInstanceId(InterlockedIncrement((LPLONG) &m_dwNextClassInstanceId))
#endif
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::CDVRReader[using RingBuffer]"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = S_OK;

    // Parameters have been validated, so asserts suffice
    DVR_ASSERT(m_pDVRFileCollection != NULL && !DvrIopIsBadWritePtr(m_pDVRFileCollection, 0), "");
    DVR_ASSERT(m_pcnsCurrentStreamTime != NULL && !DvrIopIsBadWritePtr(m_pcnsCurrentStreamTime, 0), "");
    DVR_ASSERT(m_pnWriterHasBeenClosed != NULL && !DvrIopIsBadWritePtr(m_pnWriterHasBeenClosed, 0), "");
    DVR_ASSERT(!phr || !DvrIopIsBadWritePtr(phr, 0), "");

    m_pDVRFileCollection->AddRef();

    ::InitializeCriticalSection(&m_csLock);
    InitializeListHead(&m_leReadersList);
    InitializeListHead(&m_leFreeList);

    m_dwMinConsecutiveReads = ::GetRegDWORD(m_hDvrIoKey,
                                            kwszRegCloseReaderFilesAfterConsecutiveReadsValue, 
                                            kdwRegCloseReaderFilesAfterConsecutiveReadsDefault);

    if (m_dwMinConsecutiveReads == 0)
    {
        // Not really necessary to do this. We always read at least 1 value
        // from a file before it is closed; so it is clearer if we set this 
        // member to 1.
        m_dwMinConsecutiveReads = 1;
    }

    // Created signaled because ASF SDK tries to read samples 
    // when the file is opened and we don't want to block on that
    m_hCancel = ::CreateEventW(NULL,        // security attr
                               TRUE,        // manual reset
                               TRUE,        // signaled
                               NULL         // name
                              );

    if (m_hCancel == NULL)
    {
        DWORD dwLastError = ::GetLastError();
        DVR_ASSERT(0, "");
        hrRet = HRESULT_FROM_WIN32(dwLastError);
    }

    if (phr)
    {
        *phr = hrRet;
    }
    m_nRefCount--; // Do not call release, we don't want the object destroyed!
    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return;

} // CDVRReader::CDVRReader

CDVRReader::CDVRReader(IN  LPCWSTR             pwszFileName,
                       IN  HKEY                hRegistryRootKey,
                       IN  HKEY                hDvrIoKey,
                       OUT HRESULT*            phr)
    : m_dwConsecutiveReads(0)
    , m_hRegistryRootKey(hRegistryRootKey)
    , m_hDvrIoKey(hDvrIoKey)
    , m_pCurrentNode(NULL)
    , m_pProfileNode(NULL)
    , m_pLiveFileReaderNode(NULL)
    , m_pWMProfile(NULL)
    , m_dwOutstandingProfileCount(0)
    , m_pcnsCurrentStreamTime(NULL)
    , m_pnWriterHasBeenClosed(NULL)
    , m_pDVRFileCollection(NULL)
    , m_bDVRProgramFileIsLive(0)
    , m_nRefCount(1)
    , m_bSourceIsAFile(1)
#if defined(DEBUG)
    , m_dwClassInstanceId(InterlockedIncrement((LPLONG) &m_dwNextClassInstanceId))
#endif
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::CDVRReader[using File]"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    // Parameters have been validated, so asserts suffice
    DVR_ASSERT(pwszFileName != NULL && !DvrIopIsBadStringPtr(pwszFileName), "");
    DVR_ASSERT(!phr || !DvrIopIsBadWritePtr(phr, 0), "");

    ::InitializeCriticalSection(&m_csLock);
    InitializeListHead(&m_leReadersList);
    InitializeListHead(&m_leFreeList);

    __try
    {
        LIST_ENTRY* pReader;
        HRESULT hr;

        m_dwMinConsecutiveReads = ::GetRegDWORD(m_hDvrIoKey,
                                                kwszRegCloseReaderFilesAfterConsecutiveReadsValue, 
                                                kdwRegCloseReaderFilesAfterConsecutiveReadsDefault);
       
        if (m_dwMinConsecutiveReads == 0)
        {
            // Not really necessary to do this. We always read at least 1 value
            // from a file before it is closed; so it is clearer if we set this 
            // member to 1.
            m_dwMinConsecutiveReads = 1;
        }

        // Created signaled because ASF SDK tries to read samples 
        // when the file is opened and we don't want to block on that
        m_hCancel = ::CreateEventW(NULL,        // security attr
                                   TRUE,        // manual reset
                                   TRUE,        // signaled
                                   NULL         // name
                                  );

        if (m_hCancel == NULL)
        {
            DWORD dwLastError = ::GetLastError();
            DVR_ASSERT(0, "");
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        m_pDVRFileCollection = new CDVRFileCollection(0,            // No temp files
                                                      NULL,         // Temporary files directory
                                                      &m_pcnsCurrentStreamTime,
                                                      &m_pnWriterHasBeenClosed,
                                                      &hr);
        if (!m_pDVRFileCollection)
        {
            hrRet = E_OUTOFMEMORY;
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "alloc via new failed - m_pDVRFileCollection");
            __leave;
        }

        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        hr = AddAPermanentFile(pwszFileName);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }
        // For now, we never need to try to open the next file
        // If we support ASX files, remove the "1 ||"
        if (1 || !m_bDVRProgramFileIsLive)
        {
            // No need to try to open the next reader file in GetNextSample.
            m_dwConsecutiveReads = INFINITE;
        }

    }
    __finally
    {
        if (phr)
        {
            *phr = hrRet;
        }
        m_nRefCount--; // Do not call release, we don't want the object destroyed!
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return;

} // CDVRReader::CDVRReader

CDVRReader::~CDVRReader()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::~CDVRReader"

    DVRIO_TRACE_ENTER();

    // Each GetProfile call addref's this object. So this function
    // will be called only when all profiles have been released (by
    // calling ReleaseProfile)
    DVR_ASSERT(m_dwOutstandingProfileCount == 0, "");
    DVR_ASSERT(m_pProfileNode == NULL, "");
    DVR_ASSERT(m_pWMProfile == NULL, "");

    HRESULT hr;

    hr = Close();
        
    DVR_ASSERT(m_hRegistryRootKey, "");

    DWORD dwRegRet = ::RegCloseKey(m_hRegistryRootKey);
    if (dwRegRet != ERROR_SUCCESS)
    {
        DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                   "Closing registry key m_hRegistryRootKey failed.");
    }

    DVR_ASSERT(m_hDvrIoKey, "");

    dwRegRet = ::RegCloseKey(m_hDvrIoKey);
    if (dwRegRet != ERROR_SUCCESS)
    {
        DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                   "Closing registry key m_hDvrIoKey failed.");
    }

    // Close should have cleaned up all this:
    DVR_ASSERT(m_pCurrentNode == NULL, "");
    DVR_ASSERT(m_pDVRFileCollection == NULL, "");
    DVR_ASSERT(m_pcnsCurrentStreamTime == NULL, "");
    DVR_ASSERT(m_pnWriterHasBeenClosed == NULL, "");
    DVR_ASSERT(IsListEmpty(&m_leReadersList), "");
    DVR_ASSERT(IsListEmpty(&m_leFreeList), "");

    if (m_hCancel)
    {
        ::CloseHandle(m_hCancel);
    }
    ::DeleteCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE0();

} // CDVRReader::~CDVRReader()


// ====== Helper methods

// static
DWORD WINAPI CDVRReader::ProcessOpenRequest(LPVOID p)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::ProcessOpenRequest"

    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR ""
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE
    #endif

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    // We don't need to hold any locks in this function. We are guaranteed that
    // pNode won't be removed from m_leReadersList till hReadyToReadFrom is set
    // and Close() will not delete the node without removing it from the 
    // writer's list (and waiting for the file to be closed)

    PASF_READER_NODE pReaderNode = (PASF_READER_NODE) p;

    DVR_ASSERT(pReaderNode, "");
    DVR_ASSERT(pReaderNode->pWMReader, "");
    DVR_ASSERT(pReaderNode->hReadyToReadFrom, "");
    DVR_ASSERT(::WaitForSingleObject(pReaderNode->hReadyToReadFrom, 0) == WAIT_TIMEOUT, "");

    BOOL            bCloseFile = 0;
    BOOL            bCloseReader = 0;
    IStream*        pIStream = NULL;
    IWMProfile*     pWMProfile = NULL;

    __try
    {
        HRESULT hr;

        // Do NOT change pReaderNode->hrRet after this till ProcessCloseRequest.
        // ProcessCloseRequest relies on seeing the value returned by Open
        DVR_ASSERT(pReaderNode->pwszFileName != NULL && 
                   !DvrIopIsBadStringPtr(pReaderNode->pwszFileName), "");

#if 0
        // Note that this call may fail if the BeginWriting call has not yet been
        // issued by the writer. Since the writer does that asynchronously (see Note 1), 
        // the reader may be able to find the file in the file buffer and issue the
        // Open and the BeginWriting may not have compeleted. The reader and writer
        // clients have to be in sync or the reader (the client of this object) 
        // should be prepared to poll, e..g, if Seek() or GetProfile() fails..
        //
        // Note 1: Actually, CDVRRingBufferWriter::AddATemporaryFile calls the 
        // file collection's AddFile method to get a file name before it calls
        // CDVRRingBufferWriter::PrepareAFreeWriterNode (which creates the file).
        // So the problem is not caused just because the call to BeginWriting is
        // made asynchronously. 
        //
        // Note 2: This is not an issue if the reader only opens files for times <= 
        // *m_pcnsCurrentStreamTime (since the writer has already written to them
        // and it updates *m_pcnsCurrentStreamTime only after writing) EXCEPT before
        // the first write. At that time, *m_pcnsCurrentStreamTime is set to the 
        // file's start time though a sample has not been written and the file may
        // not have been fully opened.
        hr = pReaderNode->hrRet = pReaderNode->pWMReader->Open(pReaderNode->pwszFileName);
        if (FAILED(hr))
        {
            hrRet = hr;
            
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "Open failed; hr = 0x%x for file id %u", 
                            hrRet, pReaderNode->nFileId);
            __leave;
        }
#endif

        DVR_ASSERT(pReaderNode->pDVRFileSource, "");

        hr = pReaderNode->pDVRFileSource->Open(pReaderNode->pwszFileName, 
                                               pReaderNode->hCancel,
                                               pReaderNode->msTimeOut);
        if (FAILED(hr))
        {
            hrRet = hr;
            
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "pReaderNode->pDVRFileSource->Open failed; hr = 0x%x for file id %u", 
                            hrRet, pReaderNode->nFileId);
            __leave;
        }
        bCloseFile = 1;

        hr = pReaderNode->pDVRFileSource->QueryInterface(IID_IStream, (LPVOID*) &pIStream);
        if (FAILED(hr))
        {
            hrRet = hr;
            
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "pReaderNode->pDVRFileSource->QueryInterface for IID_IStream failed; hr = 0x%x for file id %u", 
                            hrRet, pReaderNode->nFileId);
            __leave;
        }

        hr = pReaderNode->pWMReader->OpenStream(pIStream);
        if (FAILED(hr))
        {
            hrRet = hr;
            
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "pReaderNode->pWMReader->OpenStream failed; hr = 0x%x for file id %u", 
                            hrRet, pReaderNode->nFileId);
            __leave;
        }
        bCloseReader = 1;
        
        hr = pReaderNode->pWMReader->QueryInterface(IID_IWMProfile, (LPVOID*) &pWMProfile);
        if (FAILED(hr))
        {
            hrRet = hr;
            
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "pReaderNode->pWMReader->QueryInterface for IID_IWMProfile failed; hr = 0x%x for file id %u", 
                            hrRet, pReaderNode->nFileId);
            __leave;
        }

        DWORD dwNumStreams;
        
        hr = pWMProfile->GetStreamCount(&dwNumStreams);
        if (FAILED(hr))
        {
            hrRet = hr;
            
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "pWMProfile->GetStreamCount failed; hr = 0x%x for file id %u", 
                            hrRet, pReaderNode->nFileId);
            __leave;
        }

        DvrIopDebugOut2(DVRIO_DBG_LEVEL_TRACE, 
                        "Num streams for file %u is = %u", 
                        pReaderNode->nFileId, dwNumStreams);

        for (; dwNumStreams > 0; dwNumStreams--)
        {
            hr = pReaderNode->pWMReader->SetReadCompressedSamples((WORD) dwNumStreams, TRUE);
            if (FAILED(hr))
            {
                hrRet = hr;
            
                DvrIopDebugOut3(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "pReaderNode->pWMReader->SetReadCompressedSamples failed for stream %u; hr = 0x%x for file id %u", 
                                dwNumStreams, hrRet, pReaderNode->nFileId);
                __leave;
            }
        }

        DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE, 
                        "Open succeeded for file %u, hrRet = S_OK", 
                        pReaderNode->nFileId);

        hrRet = S_OK;
    }
    __finally 
    {
        if (FAILED(hrRet))
        {
            HRESULT hr;

            if (bCloseReader)
            {
                hr = pReaderNode->pWMReader->Close();
                DVR_ASSERT(SUCCEEDED(hr), "pReaderNode->pWMReader->Close failed");
            }
            if (bCloseFile)
            {
                hr = pReaderNode->pDVRFileSource->Close();
                DVR_ASSERT(SUCCEEDED(hr), "pReaderNode->pDVRFileSource->Close failed");
            }
        }
        if (pWMProfile)
        {
            pWMProfile->Release();
        }
        if (pIStream)
        {
            pIStream->Release();
        }
        pReaderNode->hrRet = hrRet;
        pReaderNode->hCancel = NULL;    // We don't need it and it should not be used
        ::SetEvent(pReaderNode->hReadyToReadFrom);
    }

    // It's unsafe to reference pReaderNode after this as we do not hold any locks

    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return 1;

    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
    #endif
    
} // CDVRReader::ProcessOpenRequest

HRESULT CDVRReader::PrepareAFreeReaderNode(
    IN LPCWSTR                              pwszFileName,
    IN DWORD                                msTimeOut,
    IN QWORD*                               pcnsFirstSampleTimeOffsetFromStartOfFile,
    IN CDVRFileCollection::DVRIOP_FILE_ID   nFileId,
    OUT LIST_ENTRY*&                        rpFreeNode)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::PrepareAFreeReaderNode"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;
    PASF_READER_NODE    pFreeNode;

    LIST_ENTRY*         pCurrent = &m_leFreeList;  
    BOOL                bRestore = 0;

    __try
    {
        pCurrent = NEXT_LIST_NODE(pCurrent);
        while (pCurrent != &m_leFreeList)
        {
            pFreeNode = CONTAINING_RECORD(pCurrent, ASF_READER_NODE, leListEntry);
            DVR_ASSERT(pFreeNode->hFileClosed, "");
            if (::WaitForSingleObject(pFreeNode->hFileClosed, 0) == WAIT_OBJECT_0)
            {
                // Verify that the hReadyToReadFrom event is reset
                DWORD nRet = ::WaitForSingleObject(pFreeNode->hReadyToReadFrom, 0);
                if (nRet == WAIT_TIMEOUT)
                {
                    break;
                }

                DVR_ASSERT(nRet != WAIT_OBJECT_0, "Free list node's hReadyToReadFrom is set?");
                if (nRet == WAIT_OBJECT_0)
                {
                    // This shouldn't happen; ignore the node and go on.
                    // Debug version will assert each time it hits this 
                    // node!
                }
                else
                {
                    // This shouldn't happen either. Ignore this node and 
                    // move on.
                    DWORD dwLastError = ::GetLastError();
                    DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                    "WFSO(hReadyToReadFrom) failed; hReadyToReadFrom = 0x%p, last error = 0x%x", 
                                    pFreeNode->hReadyToReadFrom, dwLastError);
                }
            }
            pCurrent = NEXT_LIST_NODE(pCurrent);
        }
        if (pCurrent == &m_leFreeList)
        {
            // Create a new node

            pFreeNode = new ASF_READER_NODE(&hrRet);
            
            if (pFreeNode == NULL)
            {
                hrRet = E_OUTOFMEMORY;
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "alloc via new failed - ASF_READER_NODE");
                pCurrent = NULL;
                __leave;
            }
            else if (FAILED(hrRet))
            {
                delete pFreeNode;
                pFreeNode = NULL;
                pCurrent = NULL;
                __leave;
            }
            DVR_ASSERT(::WaitForSingleObject(pFreeNode->hFileClosed, 0) == WAIT_OBJECT_0, "");
            DVR_ASSERT(::WaitForSingleObject(pFreeNode->hReadyToReadFrom, 0) == WAIT_TIMEOUT, "");

            InsertHeadList(&m_leFreeList, &pFreeNode->leListEntry);
            pCurrent = NEXT_LIST_NODE(&m_leFreeList);
            DVR_ASSERT(pCurrent == &pFreeNode->leListEntry, "");
        }

        DVR_ASSERT(pCurrent != &m_leFreeList, "");

        // Create an ASF writer object if needed
        if (!pFreeNode->pWMReader)
        {
            IWMSyncReader* pWMReader;
            
            hrRet = ::WMCreateSyncReader(NULL, 0, &pWMReader);
            if (FAILED(hrRet))
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "WMCreateSyncReader failed; hr = 0x%x", 
                                hrRet);
                __leave;
            }
            pFreeNode->pWMReader = pWMReader; // Released only in Close()
        }

        if (!pFreeNode->pDVRFileSource)
        {
            IDVRFileSource* pDVRFileSource;
            IDVRSourceAdviseSink* pDVRSourceAdviseSink = NULL;

            if (m_bSourceIsAFile)
            {
                // When reading from a tuner source (i.e., if m_bSourceIsAFile == 0)
                // the writer updates the stream extent in the file collection object
                // and we get the extent directly from the stream collection object.
                // When reading from a live file, the stream extent is known only 
                // at the DVR Stream Source layer. UpdateTimeExtent() retrieves this
                // info and sets it in the file collection object used by the reader.
                //
                // UpdateTimeExtent is called on demand, e.g., when the client wants 
                // the current time extent or when it seeks. However, if the reader 
                // blocks in the DVR Stream Source, waiting for the writer to catch up,
                // we call UpdateTimeExtent just before it blocks. This is done by
                // providing an advise sink to the DVR Stream Source. 
                //
                // We do not need to provide the sink if we are reading a non-live file
                // source, but it doesn't matter because we'll never be called back.

                hrRet = QueryInterface(IID_IDVRSourceAdviseSink, (void**) &pDVRSourceAdviseSink);
                if (FAILED(hrRet))
                {
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                    "QI for IID_IDVRSourceAdviseSink failed; hr = 0x%x", 
                                    hrRet);
                    __leave;
                }
                DVR_ASSERT(pDVRSourceAdviseSink, "");

                // Release, otherwise, we'll have circular ref counts
                pDVRSourceAdviseSink->Release();

            }
            
            hrRet = ::DVRCreateDVRFileSource(m_hRegistryRootKey, m_hDvrIoKey, &pDVRFileSource, pDVRSourceAdviseSink);
            if (FAILED(hrRet))
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "DVRCreateDVRFileSource failed; hr = 0x%x", 
                                hrRet);
                __leave;
            }
            pFreeNode->pDVRFileSource = pDVRFileSource; // Released only in Close()
        }
        
        pFreeNode->pcnsFirstSampleTimeOffsetFromStartOfFile = pcnsFirstSampleTimeOffsetFromStartOfFile;
        pFreeNode->nFileId = nFileId;
        pFreeNode->msTimeOut = msTimeOut;
        pFreeNode->hrRet = S_OK;
        DVR_ASSERT(pwszFileName != NULL && !DvrIopIsBadStringPtr(pwszFileName), "");
        pFreeNode->SetFileName(pwszFileName);
        pFreeNode->hCancel = m_hCancel;
        ::ResetEvent(pFreeNode->hFileClosed);
        bRestore = 1;

        // Issue the call to Open
        if (::QueueUserWorkItem(ProcessOpenRequest, pFreeNode, WT_EXECUTEDEFAULT) == 0)
        {
            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "QueueUserWorkItem failed; last error = 0x%x", 
                            dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        // Note: If any step can fail after this, we have to be sure
        // to put this node back into the free list
        RemoveEntryList(pCurrent);
        NULL_NODE_POINTERS(pCurrent);

        hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            rpFreeNode = NULL;
            if (bRestore)
            {
                DVR_ASSERT(pFreeNode, "");
                pFreeNode->pcnsFirstSampleTimeOffsetFromStartOfFile = NULL;
                pFreeNode->nFileId = CDVRFileCollection::DVRIOP_INVALID_FILE_ID;
                pFreeNode->hCancel = NULL;
                pFreeNode->SetFileName(NULL);
                ::SetEvent(pFreeNode->hFileClosed);
            }
        }
        else
        {
            rpFreeNode = pCurrent;
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRReader::PrepareAFreeReaderNode


HRESULT CDVRReader::AddToReadersList(IN LIST_ENTRY*   pCurrent)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::AddToReadersList"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    __try
    {
        // Insert into m_leReadersList

        BOOL                bFound = 0;
        LIST_ENTRY*         pTmp = &m_leReadersList;
        PASF_READER_NODE    pReaderNode;
        CDVRFileCollection::DVRIOP_FILE_ID   nFileId;

        pReaderNode = CONTAINING_RECORD(pCurrent, ASF_READER_NODE, leListEntry);
        nFileId = pReaderNode->nFileId;

        while (NEXT_LIST_NODE(pTmp) != &m_leReadersList)
        {
            pTmp = NEXT_LIST_NODE(pTmp);
            pReaderNode = CONTAINING_RECORD(pTmp, ASF_READER_NODE, leListEntry);
            if (nFileId < pReaderNode->nFileId)
            {
                // All ok; we should insert before pTmp
                bFound = 1;
                break;
            }
            if (nFileId == pReaderNode->nFileId)
            {
                // Trouble
                DVR_ASSERT(nFileId != pReaderNode->nFileId, "File id already present in readers list");
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR,
                                "File id %u already in readers list, being reinserted.",
                                pReaderNode->nFileId);
                hrRet = E_FAIL;
                __leave;
            }
        }

        if (!bFound)
        {
            // We insert at tail
            pTmp = NEXT_LIST_NODE(pTmp);;
            DVR_ASSERT(pTmp == &m_leReadersList, "");
        }
        InsertTailList(pTmp, pCurrent);

        hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            // No clean up necessary
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRReader::AddToReadersList

HRESULT CDVRReader::AddAPermanentFile(IN LPCWSTR pwszFileNameParam)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::AddAPermanentFile"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    PASF_READER_NODE    pReaderNode = NULL;
    LPWSTR              pwszFileName = NULL;
    LIST_ENTRY*         pReader = NULL;  
    BOOL                bAdded = 0;
    BOOL                bDecRefCount = 0;
    BOOL                bCloseFile = 0;
    BOOL                bRemoveRingBufferFile = 0;

    __try
    {
        HRESULT hr;

        pwszFileName = new WCHAR[wcslen(pwszFileNameParam)+1];

        if (!pwszFileName)
        {
            hrRet = E_OUTOFMEMORY;
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "alloc via new failed - WCHAR[%u]", 
                            wcslen(pwszFileNameParam)+1);
            __leave;
        }
        wcscpy(pwszFileName, pwszFileNameParam);

        hr = PrepareAFreeReaderNode(pwszFileName,
                                    1000,                   // timeout in msec
                                    NULL,
                                    CDVRFileCollection::DVRIOP_INVALID_FILE_ID,
                                    pReader);

        // PrepareAFreeReaderNode will delete pwszFileName regardless of 
        // whether it succeeds or fails.
        pwszFileName = NULL;

        if (FAILED(hr))
        {
            DVR_ASSERT(pReader == NULL, 
                       "PrepareAFreeReaderNode returns failure but pReader is not NULL");
            hrRet = hr;
            __leave;
        }

        DVR_ASSERT(pReader, "PrepareAFreeReaderNode returns success but pReader is NULL");
        
        pReaderNode = CONTAINING_RECORD(pReader, ASF_READER_NODE, leListEntry);;

        DVR_ASSERT(pReaderNode->hReadyToReadFrom, "");

        // Wait for the ASF file open to complete

        DWORD nRet = ::WaitForSingleObject(pReaderNode->hReadyToReadFrom, INFINITE);
        if (nRet == WAIT_FAILED)
        {
            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "WFSO(hReadyToReadFrom) failed while waiting for file open to complete; "
                            "hReadyToReadFrom = 0x%p, last error = 0x%x", 
                            pReaderNode->hReadyToReadFrom, dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }
        if (pReaderNode->hrRet == HRESULT_FROM_WIN32(ERROR_CANCELLED))
        {
            // SDK pre-reads when it opens a file. Ignore the result if 
            // it could not read because it was reading ahead of the writer..
            pReaderNode->hrRet = S_OK;
        }
        if (FAILED(pReaderNode->hrRet))
        {
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "Open of permanent file failed in ProcessOpenRequest." // pReaderNode-nFileId will be the invalid id
                           );
            hrRet = pReaderNode->hrRet;
            __leave;
        }
        bCloseFile = 1;

        // Note that we will need a start and an end time if we support ASX files

        BOOL bShared;

        hr = pReaderNode->pDVRFileSource->IsFileLive(&m_bDVRProgramFileIsLive, &bShared);
        if (FAILED(hr))
        {
            hrRet = hr;
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "pReaderNode->pDVRFileSource->IsFileLive failed; hr = 0x%x", 
                            hrRet);
            __leave;
        }
        if (bShared)
        {
            // Don't need the file collection lock to update this member here
            // since we know we are not sharing it with a writer

            hr = pReaderNode->pDVRFileSource->GetLastTimeStamp(m_pcnsCurrentStreamTime);
            if (FAILED(hr))
            {
                hrRet = hr;
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "pReaderNode->pDVRFileSource->GetLastTimeStamp failed; hr = 0x%x", 
                                hrRet);
                __leave;
            }
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE, 
                            "File is live, last time stamp is %I64u",
                            *m_pcnsCurrentStreamTime); 

            m_pLiveFileReaderNode = pReaderNode;

            // No need to use Interlocked functions because file collection is not shared
            *m_pnWriterHasBeenClosed = 0;
        }
        else
        {
            // We have to get the duration from the header. Note that this
            // is slightly more than the last time stamp (since it includes the 
            // duration of the last sample), but it will have to do.

            IWMHeaderInfo* pWMHeaderInfo;

            hr = pReaderNode->pWMReader->QueryInterface(IID_IWMHeaderInfo, (void**) &pWMHeaderInfo);

            if (FAILED(hr))
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "QI for IID_IWMHeaderInfo failed, hr = 0x%x",
                                hr);
                hrRet = hr;
                __leave;
            }

            WORD                wStreamNum = 0;
            WMT_ATTR_DATATYPE   Type;
            WORD                wLength = sizeof(*m_pcnsCurrentStreamTime);

            hr = pWMHeaderInfo->GetAttributeByName(&wStreamNum, g_wszWMDuration, &Type, 
                                                   (BYTE*) m_pcnsCurrentStreamTime, &wLength);

            if (FAILED(hr) || Type != WMT_TYPE_QWORD  || wLength != sizeof(*m_pcnsCurrentStreamTime))
            {
                DvrIopDebugOut4(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "pWMHeaderInfo->GetAttributeByName for duration failed, hr = 0x%x, Type = %d (expected %d), length = %d",
                                hr, Type, WMT_TYPE_QWORD, wLength);
                hrRet = hr;
                pWMHeaderInfo->Release();
                __leave;
            }
            pWMHeaderInfo->Release();
            pWMHeaderInfo = NULL;

            if (*m_pcnsCurrentStreamTime == 0)
            {
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "Duration of non-live file is 0, failing open.");        
                hrRet = NS_E_INVALID_DATA;
                __leave;
            }

            // Subtract 1 since the ring buffer extent always corresponds to the last written sample.
            (*m_pcnsCurrentStreamTime)--;

            // No need to use Interlocked functions because file collection is not shared
            *m_pnWriterHasBeenClosed = 1;
            
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE, 
                            "File is not live; extent is %I64u",
                            *m_pcnsCurrentStreamTime); 
        }

        DVR_ASSERT(m_pDVRFileCollection, "");

        hr = m_pDVRFileCollection->AddFile((LPWSTR*) &pReaderNode->pwszFileName, 
                                           0,                   // start time pRecorderNode->cnsStartTime, 
                                           *m_pcnsCurrentStreamTime + 1, 
                                           TRUE,                // bPermanentFile, 
                                           &pReaderNode->pcnsFirstSampleTimeOffsetFromStartOfFile,
                                           &pReaderNode->nFileId);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        DVR_ASSERT(pReaderNode->pcnsFirstSampleTimeOffsetFromStartOfFile, "");

        *pReaderNode->pcnsFirstSampleTimeOffsetFromStartOfFile = 0;

        bRemoveRingBufferFile = 1;

        // Bump up the reader ref count

        CDVRFileCollection::DVRIOP_FILE_ID nTmpFileId;
        
        hr = m_pDVRFileCollection->GetFileAtTime(0,    // Replace with start time of file if we support ASX files
                                                 NULL, // file name optional
                                                 NULL, // pcnsFirstSampleTimeOffsetFromStartOfFile
                                                 &nTmpFileId,
                                                 TRUE  // bFileWillBeOpened
                                                );
        if (FAILED(hr) || nTmpFileId != pReaderNode->nFileId)
        {
            // This can't happen
            DVR_ASSERT(SUCCEEDED(hr), "GetFileAtTime failed");
            DVR_ASSERT(nTmpFileId == pReaderNode->nFileId, "Two files with same start time in file collection?");
            if (SUCCEEDED(hr))
            {

                DVR_EXECUTE_ASSERT(SUCCEEDED(m_pDVRFileCollection->CloseReaderFile(nTmpFileId)), "");
                hrRet = E_FAIL;
            }
            __leave;
        }

        bDecRefCount = 1;

        // Insert into m_leReadersList

        hr = AddToReadersList(pReader);        

        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        bAdded = 1;

        pReaderNode = NULL; // We don't have any reason to use it
        hrRet = S_OK;
    }
    __finally
    {
        // If we succeeeded pwszFileName should be NULL.
        DVR_ASSERT(!pwszFileName || FAILED(hrRet), "");
        
        delete [] pwszFileName;

        if (FAILED(hrRet))
        {
            CDVRFileCollection::DVRIOP_FILE_ID nTmpFileId;
            
            if (bRemoveRingBufferFile)
            {
                nTmpFileId = pReaderNode->nFileId;
            }
            if (bAdded)
            {
                RemoveEntryList(pReader);
                NULL_NODE_POINTERS(pReader);
            }
            if (!bDecRefCount)
            {
                // This prevents CloseReaderFile from decreasing the ref count.
                // Note that it's ok to decrease the reader refcount after 
                // calling SetFileTime (which makes the file collection remove
                // the node for this file when the reader ref count drops to 0).
                pReaderNode->nFileId = CDVRFileCollection::DVRIOP_INVALID_FILE_ID;
            }
            if (bRemoveRingBufferFile)
            {
                // Set the end time to the start time to invalidate the file 
                // in the file collection
                CDVRFileCollection::DVRIOP_FILE_TIME ft = {nTmpFileId, *m_pcnsCurrentStreamTime+1, *m_pcnsCurrentStreamTime+1}; 
                HRESULT hr;

                hr = m_pDVRFileCollection->SetFileTimes(1, &ft);

                // A returned value of S_FALSE is ok. If this fails, 
                // just ignore the error
                DVR_ASSERT(SUCCEEDED(hr), "");
            }
            if (bCloseFile)
            {
                HRESULT hr;
                
                hr = CloseReaderFile(pReader);

                if (FAILED(hr))
                {
                    // Ignore the error and go on. Node has been
                    // deleted.
                }
                else
                {
                    // Note: Close may not have complete yet - that's ok
                }
            }

        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRReader::AddAPermanentFile

HRESULT CDVRReader::GetFileAtTime(IN  QWORD         cnsStreamTime,
                                  IN  BOOL          bWaitTillFileIsOpened,
                                  OUT LIST_ENTRY**  pleReaderParam)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::GetFileAtTime"

    DVRIO_TRACE_ENTER();

    DVR_ASSERT(pleReaderParam && !DvrIopIsBadWritePtr(pleReaderParam, 0), "");

    HRESULT hrRet = E_FAIL;
    CDVRFileCollection::DVRIOP_FILE_ID nFileId;
    PASF_READER_NODE    pReaderNode = NULL;
    LPWSTR              pwszFileName = NULL;
    LIST_ENTRY*         pReader = NULL;  
    BOOL                bDecRefCount = 0;
    BOOL                bCloseFile = 0;
    BOOL                bAdded = 0;

    // Note that we will need a start and an end time if we support ASX files
    QWORD               cnsEndTime;   // time extent of the file; start tiem is always 0

    __try
    {
        HRESULT hr;

        DVR_ASSERT(m_pDVRFileCollection, "");

        hr = m_pDVRFileCollection->GetFileAtTime(cnsStreamTime,
                                                 NULL,      // file name optional
                                                 NULL,      // pcnsFirstSampleTimeOffsetFromStartOfFile
                                                 &nFileId,
                                                 FALSE      // bFileWillBeOpened
                                                );
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        // Check if we already have this file open

        LIST_ENTRY*         pTmp = &m_leReadersList;
        PASF_READER_NODE    pTmpNode = NULL;

        while (NEXT_LIST_NODE(pTmp) != &m_leReadersList)
        {
            pTmp = NEXT_LIST_NODE(pTmp);
            pTmpNode = CONTAINING_RECORD(pTmp, ASF_READER_NODE, leListEntry);
            if (nFileId < pTmpNode->nFileId)
            {
                // Not found
                break;
            }
            if (nFileId == pTmpNode->nFileId)
            {
                // We have the file open
                hrRet = S_OK;
                *pleReaderParam = pTmp;
                __leave;
            }
        }

        QWORD* pcnsFirstSampleTimeOffsetFromStartOfFile = NULL;

        hr = m_pDVRFileCollection->GetFileAtTime(cnsStreamTime,
                                                 &pwszFileName,
                                                 &pcnsFirstSampleTimeOffsetFromStartOfFile,
                                                 &nFileId,
                                                 TRUE  // bFileWillBeOpened
                                                );
        if (FAILED(hr))
        {
            // Presumably, file only just got bumped out of the ring buffer
            hrRet = hr;
            __leave;
        }

        bDecRefCount = 1;

        DVR_ASSERT(pwszFileName, "GetFileAtTime succeeded but file name is NULL");
        DVR_ASSERT(nFileId != CDVRFileCollection::DVRIOP_INVALID_FILE_ID,
                   "GetFileAtTime succeeded but file id returned is DVRIOP_INVALID_FILE_ID");


        // Note that the client of the DVRReader can cancel this operation.
        // So a timeout of INFINITE is ok.
        hr = PrepareAFreeReaderNode(pwszFileName,
                                    2000,                  // timeout
                                    pcnsFirstSampleTimeOffsetFromStartOfFile,
                                    nFileId,
                                    pReader);

        // PrepareAFreeReaderNode will delete pwszFileName regardless of 
        // whether it succeeds or fails.
        pwszFileName = NULL;

        if (FAILED(hr))
        {
            DVR_ASSERT(pReader == NULL, 
                       "PrepareAFreeReaderNode returns failure but pReader is not NULL");
            hrRet = hr;
            __leave;
        }

        // Closing the file will decrease the ref count in CloseReaderFile, so we don't
        // have to decrease the reader ref count ourselves.
        bDecRefCount = 0;
        bCloseFile = 1;

        DVR_ASSERT(pReader, "PrepareAFreeReaderNode returns success but pReader is NULL");
        
        pReaderNode = CONTAINING_RECORD(pReader, ASF_READER_NODE, leListEntry);;

        if (bWaitTillFileIsOpened)
        {
            DVR_ASSERT(pReaderNode->hReadyToReadFrom, "");

            // Wait for the ASF file open to complete

            DWORD nRet = ::WaitForSingleObject(pReaderNode->hReadyToReadFrom, INFINITE);
            if (nRet == WAIT_FAILED)
            {
                DWORD dwLastError = ::GetLastError();
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "WFSO(hReadyToReadFrom) failed while waiting for file open to complete; "
                                "hReadyToReadFrom = 0x%p, last error = 0x%x", 
                                pReaderNode->hReadyToReadFrom, dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }
            if (pReaderNode->hrRet == HRESULT_FROM_WIN32(ERROR_CANCELLED))
            {
                // SDK pre-reads when it opens a file. Ignore the result if 
                // it could not read because it was reading ahead of the writer..
                pReaderNode->hrRet = S_OK;
            }
            if (FAILED(pReaderNode->hrRet))
            {
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "Open of file failed in ProcessOpenRequest." // pReaderNode-nFileId will be the invalid id
                               );
                hrRet = pReaderNode->hrRet;
                __leave;
            }
        }

        // Insert into m_leReadersList

        hr = AddToReadersList(pReader);        

        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        bAdded = 1;

        pReaderNode = NULL; // We don't have any reason to use it
        *pleReaderParam = pReader;
        hrRet = S_OK;
    }
    __finally
    {        
        // If we succeeeded pwszFileName should be NULL.
        DVR_ASSERT(!pwszFileName || FAILED(hrRet), "");
        
        delete [] pwszFileName;

        if (FAILED(hrRet))
        {
            HRESULT hr;

            *pleReaderParam = NULL;

            if (bAdded)
            {
                RemoveEntryList(pReader);
                NULL_NODE_POINTERS(pReader);
            }
            if (bDecRefCount)
            {
                DVR_ASSERT(!bCloseFile, "bCloseFile should be 0 if bDecRefCount is 1");
                DVR_ASSERT(pReader == NULL, "");
                DVR_ASSERT(pReaderNode == NULL, "");

                hr = m_pDVRFileCollection->CloseReaderFile(nFileId);
                if (FAILED(hr))
                {
                    // Ignore the error and go on. Node has been
                    // deleted.
                }
            }
            if (bCloseFile)
            {
                DVR_ASSERT(pReader, "");

                // The following will wait till the file is opened
                // before closing it. 
                //
                // Note that this is a file we just opened, so it can't
                // be equal to m_pProfileNode
                hr = CloseReaderFile(pReader);

                if (FAILED(hr))
                {
                    // Ignore the error and go on. Node has been
                    // deleted.
                }
                else
                {
                    // Note: Close may not have complete yet - that's ok
                }
            }

        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRReader::GetFileAtTime

// static
DWORD WINAPI CDVRReader::ProcessCloseRequest(LPVOID p)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::ProcessCloseRequest"

    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR ""
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE
    #endif


    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    // We don't need to hold any locks in this function. We are guaranteed that
    // pNode won't be deleted till Close() is called and Close() waits for 
    // hFileClosed to be set.

    PASF_READER_NODE pReaderNode = (PASF_READER_NODE) p;

    DVR_ASSERT(pReaderNode, "");
    DVR_ASSERT(pReaderNode->pWMReader, "");
    DVR_ASSERT(pReaderNode->hReadyToReadFrom, "");
    DVR_ASSERT(::WaitForSingleObject(pReaderNode->hFileClosed, 0) == WAIT_TIMEOUT, "");

    if (FAILED(pReaderNode->hrRet))
    {
        // Open failed, don't close the file
        DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                        "Open failed on file id %u, hr = 0x%x; not closing it, "
                        "but moving it to free list",
                        pReaderNode->nFileId, pReaderNode->hrRet);
        hrRet = pReaderNode->hrRet;
    }
    else
    {
        hrRet = pReaderNode->hrRet = pReaderNode->pWMReader->Close();
        if (FAILED(hrRet))
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "Close failed; hr = 0x%x for file id %u", 
                            hrRet, pReaderNode->nFileId);
        }

        // The DVR file source's Close does not fail to close the file.
        // Should not get failure return.
        hrRet = pReaderNode->pDVRFileSource->Close();
        DVR_ASSERT(SUCCEEDED(hrRet), "pReaderNode->pDVRFileSource->Close failed");

        DvrIopDebugOut2(DVRIO_DBG_LEVEL_TRACE, 
                        "Close hr = 0x%x for file %u", 
                        hrRet, pReaderNode->nFileId);
    }

    pReaderNode->pcnsFirstSampleTimeOffsetFromStartOfFile = NULL;
    pReaderNode->nFileId = CDVRFileCollection::DVRIOP_INVALID_FILE_ID;
    pReaderNode->SetFileName(NULL);

    ::SetEvent(pReaderNode->hFileClosed);

    // It's unsafe to reference pReaderNode after this as we do not hold any locks

    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return 1;
    
    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
    #endif

} // CDVRReader::ProcessCloseRequest

HRESULT CDVRReader::CloseReaderFile(LIST_ENTRY* pCurrent)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::CloseReaderFile"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    PASF_READER_NODE    pReaderNode;
    BOOL                bLeak = 0;   // Leak the writer node memory if we fail
    BOOL                bDelete = 0; // Delete the writer node if we fail
    BOOL                bWaitForClose = 0; // Wait for hFileClsoed before deleting
    BOOL                bDecd = 0;  // Called the file collection's CloseReaderFile to decrease its reader ref count

    pReaderNode = CONTAINING_RECORD(pCurrent, ASF_READER_NODE, leListEntry);

    __try
    {
        DWORD nRet;
        HRESULT hr;

        // If this node is the profile node, this function should not be called.
        // File remains open till the caller releases the profile
        if (m_pProfileNode == pReaderNode)
        {
            DVR_ASSERT(m_pProfileNode != pReaderNode, "");
            hrRet = E_INVALIDARG;
            __leave;
        }

        // If this node is the current reader node, this function should not be called.
        // The calling function should call ResetReader() before calling this function.
        if (m_pCurrentNode == pReaderNode)
        {
            DVR_ASSERT(m_pCurrentNode != pReaderNode, "");
            hrRet = E_INVALIDARG;
            __leave;
        }

        if (m_pLiveFileReaderNode == pReaderNode)
        {
            m_pLiveFileReaderNode = NULL;
        }

        // We have to close the file; ensure the open has completed
        DVR_ASSERT(pReaderNode->hReadyToReadFrom, "");
        if (::WaitForSingleObject(pReaderNode->hReadyToReadFrom, INFINITE) == WAIT_FAILED)
        {
            DVR_ASSERT(0, "Reader node's WFSO(hReadyToReadFrom) failed");

            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "WFSO(hReadyToReadFrom) failed; hReadyToReadFrom = 0x%p, last error = 0x%x", 
                            pReaderNode->hReadyToReadFrom, dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);

            // We don't know if the queued user work item has executed or not
            // Better to leak this memory than to potentially av.
            bLeak = 1;
           __leave; 
        }
        bDelete = 1;

        // Verify that hFileClosed is reset
        DVR_ASSERT(pReaderNode->hFileClosed, "");
        nRet = ::WaitForSingleObject(pReaderNode->hFileClosed, 0);
        if (nRet != WAIT_TIMEOUT)
        {
            DVR_ASSERT(nRet != WAIT_OBJECT_0, "Reader node's hFileClosed is set?");
            if (nRet == WAIT_OBJECT_0)
            {
                // hope for the best! Consider treating this an error @@@@
                ::ResetEvent(pReaderNode->hFileClosed);
            }
            else
            {
                DWORD dwLastError = ::GetLastError();
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "WFSO(hFileClosed) failed; hFileClosed = 0x%p, last error = 0x%x", 
                                pReaderNode->hFileClosed, dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }
        }

        bDecd = 1;
        if (pReaderNode->nFileId != CDVRFileCollection::DVRIOP_INVALID_FILE_ID)
        {
            hr = m_pDVRFileCollection->CloseReaderFile(pReaderNode->nFileId);
            if (FAILED(hr))
            {
                DVR_ASSERT(SUCCEEDED(hr), "m_pDVRFileCollection->CloseReaderFile failed");
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "m_pDVRFileCollection->CloseReaderFile failed for file id %u; hr = 0x%x", 
                                pReaderNode->nFileId, hr);

            }
            // Go on - close the file and add this node to the free list
            // The node's state is still "good"
        }
                
        // Issue the call to EndWriting
        if (::QueueUserWorkItem(ProcessCloseRequest, pReaderNode, WT_EXECUTEDEFAULT) == 0)
        {
            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "QueueUserWorkItem failed; last error = 0x%x", 
                            dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }
        bWaitForClose = 1; // We wait only if subsequent operations fail

        // We could do this after the WFSO(hReadyToReadFrom) succeeds
        // We delay it because we may change this function to not
        // not delete the node on failure and retry this function.
        // So it's better to leave the event set until we are 
        // sure of success.
        ::ResetEvent(pReaderNode->hReadyToReadFrom);

        // Insert into m_leFreeList
        LIST_ENTRY*         pTmp = &m_leFreeList;
        PASF_READER_NODE    pFreeNode;

        while (PREVIOUS_LIST_NODE(pTmp) != &m_leFreeList)
        {
            pTmp = PREVIOUS_LIST_NODE(pTmp);
            pFreeNode = CONTAINING_RECORD(pTmp, ASF_READER_NODE, leListEntry);
            if (pFreeNode->pWMReader != NULL)
            {
                InsertHeadList(pTmp, pCurrent);
                bDelete = 0;
                break;
            }
        }
        if (pTmp == &m_leFreeList)
        {
            // Not inserted into free list yet - all nodes in the 
            // free list have pWMWriter == NULL
            InsertHeadList(&m_leFreeList, pCurrent);
            bDelete = 0;
        }
        hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            // We either leak or delete the node on failure, but not both

            DVR_ASSERT(bLeak == 0 || bLeak == 1, "");
            DVR_ASSERT(bDelete == 0 || bDelete == 1, "");
            DVR_ASSERT(bLeak ^ bDelete, "");

            if (bWaitForClose)
            {
                // Currently won't happen since we have no failures 
                // after queueing the work item. However, this is to
                // protect us from code changes

                DWORD nRet;

                nRet = ::WaitForSingleObject(pReaderNode->hFileClosed, INFINITE);
                if (nRet == WAIT_FAILED)
                {
                    DVR_ASSERT(nRet == WAIT_OBJECT_0, "Reader node WFSO(hFileClosed) failed");

                    DWORD dwLastError = ::GetLastError();
                    DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                    "WFSO(hFileClosed) failed, deleting node anyway; hFileClosed = 0x%p, last error = 0x%x", 
                                    pReaderNode->hFileClosed, dwLastError);

                    // Ignore this error
                    // hrRet = HRESULT_FROM_WIN32(dwLastError);
                }
            }
            else
            {
                // Close the file any way

                HRESULT hr;

                if (!bDecd)
                {
                    hr = m_pDVRFileCollection->CloseReaderFile(pReaderNode->nFileId);
                    if (FAILED(hr))
                    {
                        DVR_ASSERT(SUCCEEDED(hr), "m_pDVRFileCollection->CloseReaderFile failed");
                        DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                        "m_pDVRFileCollection->CloseReaderFile failed for file id %u; hr = 0x%x", 
                                        pReaderNode->nFileId, hr);

                    }
                    // Go on - close the file
                }
                ProcessCloseRequest(pReaderNode);
            }
            if (bDelete)
            {
                delete pReaderNode;
            }
        }
        else
        {
            DVR_ASSERT(bLeak == 0 && bDelete == 0, "");
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRReader::CloseReaderFile


HRESULT CDVRReader::CloseAllReaderFilesBefore(QWORD cnsStreamTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::CloseAllReaderFilesBefore"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    PASF_READER_NODE    pReaderNode;
    LIST_ENTRY*         pCurrent = &m_leReadersList;  

    __try
    {
        HRESULT hr;

        while (NEXT_LIST_NODE(pCurrent) != &m_leReadersList)
        {
            pCurrent = NEXT_LIST_NODE(pCurrent);
            pReaderNode = CONTAINING_RECORD(pCurrent, ASF_READER_NODE, leListEntry);

            QWORD cnsEndTime;

            DVR_ASSERT(m_pDVRFileCollection, "");
            
            hr = m_pDVRFileCollection->GetTimeExtentForFile(pReaderNode->nFileId,
                                                            NULL,                // pcnsStartStreamTime OPTIONAL,  
                                                            &cnsEndTime);

            if (FAILED(hr))
            {
                // already logged, just go on
                continue;
            }
            else if (hr != S_FALSE && cnsEndTime > cnsStreamTime)
            {
                // Note thatif hr == S_FALSE, the file is no longer
                // in the ring buffer extent. We should close it 
                // regardless of time. Note that files beyond the 
                // last write time can drop out of the ring buffer 
                // because the writer called SetFileTimes and 
                // set their start time equal to their stop time

                // go on
                continue;
            }
            else if (m_pProfileNode == pReaderNode)
            {
                // We have to leave this file open till the profile
                // is released.
                continue;
            }
            else if (m_pCurrentNode == pReaderNode)
            {
                // Reset, then close
                ResetReader();
            }


            LIST_ENTRY* pPrevious = PREVIOUS_LIST_NODE(pCurrent);

            RemoveEntryList(pCurrent);
            NULL_NODE_POINTERS(pCurrent);

            hr = CloseReaderFile(pCurrent);
            if (FAILED(hr))
            {
                // We ignore this and go on, the node has been deleted
            }

            pCurrent = pPrevious;
        }
        hrRet = S_OK; // even if there was a failure
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            // No clean up
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRReader::CloseAllReaderFilesBefore

HRESULT CDVRReader::Close(void)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::Close"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        HRESULT hr;

        // Just in case we are called from a function other than
        // the destructor
        if(m_dwOutstandingProfileCount != 0)
        {
            DVR_ASSERT(m_dwOutstandingProfileCount == 0, "");
            hrRet = E_UNEXPECTED;
            __leave;
        }
        DVR_ASSERT(m_pProfileNode == NULL, "m_dwOutstandingProfileCount is zero");
        DVR_ASSERT(m_pWMProfile == NULL, "m_dwOutstandingProfileCount is zero");

        hr = CloseAllReaderFilesBefore(MAXQWORD);
        hrRet = hr;

        // This list should be empty by now.
        DVR_ASSERT(IsListEmpty(&m_leReadersList), "");

        // The current reader should be NULL
        DVR_ASSERT(m_pCurrentNode == NULL, "");

        // Delete all the reader nodes.
        LIST_ENTRY* pCurrent;
        
        pCurrent = NEXT_LIST_NODE(&m_leFreeList);
        while (pCurrent != &m_leFreeList)
        {
            PASF_READER_NODE pFreeNode = CONTAINING_RECORD(pCurrent, ASF_READER_NODE, leListEntry);
            
            DVR_ASSERT(pFreeNode->hFileClosed, "");
            
            // Ignore the returned status
            ::WaitForSingleObject(pFreeNode->hFileClosed, INFINITE);
            RemoveEntryList(pCurrent);
            delete pFreeNode;
            pCurrent = NEXT_LIST_NODE(&m_leFreeList);
        }
        
        m_pcnsCurrentStreamTime = NULL;
        m_pnWriterHasBeenClosed = NULL;

        if (m_pDVRFileCollection)
        {
            m_pDVRFileCollection->Release();
            m_pDVRFileCollection = NULL;
        }

        hrRet = S_OK;
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRReader::Close

void CDVRReader::ResetReader(IN PASF_READER_NODE pReaderNode /* = NULL */)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::ResetReader"

    DVRIO_TRACE_ENTER();

    m_pCurrentNode = pReaderNode;
    if (m_dwConsecutiveReads != INFINITE)
    {
        m_dwConsecutiveReads = 0;
    }
    
    DVRIO_TRACE_LEAVE0();
    return;

} // CDVRReader::ResetReader

HRESULT CDVRReader::UpdateTimeExtent()
{

    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::UpdateTimeExtent"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;


    // For ASX files, we may have to add permanent files to the file collection
    // object first

    __try
    {
        QWORD cnsTime;
        HRESULT hr;

        if (!m_bDVRProgramFileIsLive)
        {
            hrRet = S_FALSE;
            __leave;
        }

        DVR_ASSERT(m_pLiveFileReaderNode, "");
    
        hr = m_pLiveFileReaderNode->pDVRFileSource->GetLastTimeStamp(&cnsTime);
        if (FAILED(hr))
        {
            hrRet = hr;
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "m_pLiveFileReaderNode->pDVRFileSource->GetLastTimeStamp failed; hr = 0x%x; ignoring error", 
                            hrRet);
            __leave;
        }

        
        if (*m_pcnsCurrentStreamTime != cnsTime)
        {
            // Get the file collection lock to update this member since
            // the client can try to read it without getting CDVRReader::m_csLock
            // in GetStreamTimeExtent

            DVR_ASSERT(m_pDVRFileCollection, "");
        
            hr = m_pDVRFileCollection->Lock();
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
            
            *m_pcnsCurrentStreamTime = cnsTime;

            hr = m_pDVRFileCollection->Unlock();
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }

            // We have to update the time extent of the file on the file collection object
            // so that GetFileAtTime does not fail.
            CDVRFileCollection::DVRIOP_FILE_TIME ft = {m_pLiveFileReaderNode->nFileId, 0, *m_pcnsCurrentStreamTime+1}; 

            hr = m_pDVRFileCollection->SetFileTimes(1, &ft);

            DVR_ASSERT(hr == S_OK, "");
            if (hr == S_FALSE)
            {
                // This is unexpected
                hrRet = E_FAIL;
                __leave;
            }
            else if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE, 
                            "File is live, last time stamp is %I64u",
                            *m_pcnsCurrentStreamTime); 
            hrRet = S_OK;
            __leave;
        }

        // Verify if file is still live
        
        BOOL bShared;

        hr = m_pLiveFileReaderNode->pDVRFileSource->IsFileLive(&m_bDVRProgramFileIsLive, &bShared);
        if (FAILED(hr))
        {
            hrRet = hr;
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "pReaderNode->pDVRFileSource->IsFileLive failed; hr = 0x%x", 
                            hrRet);
            __leave;
        }
        DVR_ASSERT(bShared, "");

        if (!m_bDVRProgramFileIsLive)
        {
            // No need to use Interlocked functions because file collection is not shared
            *m_pnWriterHasBeenClosed = 0;
        }
        else
        {
            DVR_ASSERT(*m_pnWriterHasBeenClosed == 0, "");
        }


        DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE, 
                        "Timestamp unchanged; File is liveis now %d",
                        m_bDVRProgramFileIsLive); 
        hrRet = S_OK;
    }
    __finally
    {
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRReader::UpdateTimeExtent


// ====== Public methods to support the recorder


// ====== IUnknown

STDMETHODIMP CDVRReader::QueryInterface(IN  REFIID riid, 
                                        OUT void   **ppv)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::QueryInterface"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    if (!ppv || DvrIopIsBadWritePtr(ppv, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");        
        hrRet = E_POINTER;
    }
    else if (riid == IID_IUnknown)
    {        
        *ppv = (IUnknown*) (IDVRReader*) this;
        hrRet = S_OK;
    }
    else if (riid == IID_IDVRReader)
    {        
        *ppv = (IDVRReader*) this;
        hrRet = S_OK;
    }
    else if (riid == IID_IDVRSourceAdviseSink)
    {
        *ppv = (IDVRSourceAdviseSink*) this;
        hrRet = S_OK;
    }
    else
    {
        *ppv = NULL;
        hrRet = E_NOINTERFACE;
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "no such interface");        
    }

    if (SUCCEEDED(hrRet))
    {
        ((IUnknown *) (*ppv))->AddRef();
    }

    DVRIO_TRACE_LEAVE1_HR(hrRet);
    
    return hrRet;

} // CDVRReader::QueryInterface


STDMETHODIMP_(ULONG) CDVRReader::AddRef()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::AddRef"

    DVRIO_TRACE_ENTER();

    LONG nNewRef = InterlockedIncrement(&m_nRefCount);

    DVR_ASSERT(nNewRef > 0, 
               "m_nRefCount <= 0 after InterlockedIncrement");

    DVRIO_TRACE_LEAVE1(nNewRef);
    
    return nNewRef <= 0? 0 : (ULONG) nNewRef;

} // CDVRReader::AddRef


STDMETHODIMP_(ULONG) CDVRReader::Release()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::Release"

    DVRIO_TRACE_ENTER();

    LONG nNewRef = InterlockedDecrement(&m_nRefCount);

    DVR_ASSERT(nNewRef >= 0, 
              "m_nRefCount < 0 after InterlockedDecrement");

    if (nNewRef == 0) 
    {
        // Must call DebugOut before the delete because the 
        // DebugOut references this->m_dwClassInstanceId
        DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE, 
                        "Leaving, object *destroyed*, returning %u",
                        nNewRef);
        delete this;
    }
    else
    {
        DVRIO_TRACE_LEAVE1(nNewRef);
    }
 
    return nNewRef <= 0? 0 : (ULONG) nNewRef;

} // CDVRReader::Release


// ====== IDVRReader

STDMETHODIMP CDVRReader::GetProfile(OUT IWMProfile** ppWMProfile)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::GetProfile"

    DVRIO_TRACE_ENTER();

    if (!ppWMProfile || DvrIopIsBadWritePtr(ppWMProfile, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    HRESULT             hrRet;
    LIST_ENTRY*         pReader = NULL;
    BOOL                bCloseFile = 0;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        HRESULT hr;

        if (m_dwOutstandingProfileCount)
        {
            DVR_ASSERT(m_pProfileNode != NULL, "m_dwOutstandingProfileCount is non-zero");
            DVR_ASSERT(m_pWMProfile != NULL, "m_dwOutstandingProfileCount is non-zero");
            hrRet = S_OK;
            __leave;
        }

        DVR_ASSERT(m_pProfileNode == NULL, "m_dwOutstandingProfileCount is zero");
        DVR_ASSERT(m_pWMProfile == NULL, "m_dwOutstandingProfileCount is zero");

        // Use the "latest" file. Note that this file should have been created
        // by the writer even if the ring buffer writer not started writing.
        QWORD qwLastStreamTime;

        DVR_ASSERT(m_pDVRFileCollection, "");
        
        hr = m_pDVRFileCollection->Lock();
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }
        qwLastStreamTime = *m_pcnsCurrentStreamTime;
        hr = m_pDVRFileCollection->Unlock();
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        hr = GetFileAtTime(qwLastStreamTime, 1 /* bWait */, &pReader);

        if (FAILED(hr))
        {
            DVR_ASSERT(pReader == NULL, "GetFileAtTime fails but pReader != NULL");
            hrRet = hr;
            __leave;
        }
        DVR_ASSERT(pReader != NULL, "GetFileAtTime succeeds but pReader == NULL");

        PASF_READER_NODE    pReaderNode;

        pReaderNode = CONTAINING_RECORD(pReader, ASF_READER_NODE, leListEntry);;

        bCloseFile = 1;

        DVR_ASSERT(pReaderNode->pWMReader, "");

        hr = pReaderNode->pWMReader->QueryInterface(IID_IWMProfile, (void**) &m_pWMProfile);

        if (FAILED(hr))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "QI for IID_IWMProfilefailed, hr = 0x%x",
                            hr);
            hrRet = hr;
            __leave;
        }

        m_pProfileNode = pReaderNode;
        hrRet = S_OK;
    }
    __finally
    {
        HRESULT hr;

        if (SUCCEEDED(hrRet))
        {
            m_dwOutstandingProfileCount++;
            *ppWMProfile = m_pWMProfile; // First QI addref's this, we don't addref it again
            AddRef();
        }
        else if (bCloseFile)
        {
            DVR_ASSERT(pReader, "");
            DVR_ASSERT(m_dwOutstandingProfileCount == 0, "Why did we try to open a file?");
            DVR_ASSERT(m_pWMProfile == NULL, "Why did we try to open a file?");

            // CloseReaderFile will assert this
            DVR_ASSERT(m_pProfileNode == NULL, "Why did we try to open a file?");
            hr = CloseReaderFile(pReader);
            if (FAILED(hr))
            {
                // We ignore this and go on, the node has been deleted
            }
        }
        else
        {
            DVR_ASSERT(pReader == NULL, "bCloseFile == 0");
        }

        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // CDVRReader::GetProfile

STDMETHODIMP CDVRReader::ReleaseProfile(IN IWMProfile* pWMProfile)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::ReleaseProfile"

    DVRIO_TRACE_ENTER();

    if (!pWMProfile || DvrIopIsBadWritePtr(pWMProfile, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    HRESULT             hrRet;
    LIST_ENTRY*         pReader = NULL;
    BOOL                bCloseFile = 0;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        HRESULT hr;

        if (m_dwOutstandingProfileCount && pWMProfile == m_pWMProfile)
        {
            DVR_ASSERT(m_pProfileNode != NULL, "m_dwOutstandingProfileCount is non-zero");
            DVR_ASSERT(m_pWMProfile != NULL, "m_dwOutstandingProfileCount is non-zero");
            hrRet = S_OK;
            __leave;
        }
        if (m_dwOutstandingProfileCount)
        {
            // pWMProfile != m_pWMProfile

            DVR_ASSERT(m_pProfileNode != NULL, "m_dwOutstandingProfileCount is non-zero");
            DVR_ASSERT(m_pWMProfile != NULL, "m_dwOutstandingProfileCount is non-zero");

            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
            DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
            hrRet = E_INVALIDARG;
            __leave;
        }

        DVR_ASSERT(m_pProfileNode == NULL, "m_dwOutstandingProfileCount is zero");
        DVR_ASSERT(m_pWMProfile == NULL, "m_dwOutstandingProfileCount is zero");
        hrRet = E_UNEXPECTED;
    }
    __finally
    {
        HRESULT hr;

        if (SUCCEEDED(hrRet))
        {
            m_dwOutstandingProfileCount--;
            
            if (m_dwOutstandingProfileCount == 0)
            {
                m_pWMProfile->Release();
                m_pWMProfile = NULL;
                m_pProfileNode = NULL;

                // Note that we cannot call CloseReaderFile here since
                // the file could also be opened for reading and we do
                // not maintain a refcount/flag in PASF_READER_NODE that
                // distinguishes files opened for profile info from files
                // opened for reads
            }

            ::LeaveCriticalSection(&m_csLock);
            DVRIO_TRACE_LEAVE1_HR(hrRet);

            // This could delete the object; that's why we 
            // call LeaveCriticalSection first.
            Release();

            // NOTE: Object may have been DESTROYED
        }
        else
        {
            ::LeaveCriticalSection(&m_csLock);
            DVRIO_TRACE_LEAVE1_HR(hrRet);
        }
    }

    return hrRet;

} // CDVRReader::ReleaseProfile

STDMETHODIMP CDVRReader::Seek(IN QWORD cnsStreamTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::Seek"

    DVRIO_TRACE_ENTER();

    HRESULT             hrRet;
    LIST_ENTRY*         pReader = NULL;
    PASF_READER_NODE    pCurrentReaderNode = NULL;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        HRESULT hr;

        hr = UpdateTimeExtent();
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        // Note that we do not bother to validate cnsStreamTime with the start time of 
        // the file collection (which is returned by m_pDVRFileCollection->GetTimeExtent). 
        // If cnsStreamTime is outside the file collection's extent, GetFileAtTime would 
        // fail.
        //
        // We check cnsStreamTime with *m_pcnsCurrentStreamTime because GetFileAtTime would
        // succeed if there was a file created by the writer in advance for a future time.

        QWORD qwLastStreamTime;

        DVR_ASSERT(m_pDVRFileCollection, "");
        
        hr = m_pDVRFileCollection->Lock();
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }
        qwLastStreamTime = *m_pcnsCurrentStreamTime;
        hr = m_pDVRFileCollection->Unlock();
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        if (cnsStreamTime > qwLastStreamTime)
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "Seek failed because seek time = %I64u > stream extent = %I64u",
                            cnsStreamTime, qwLastStreamTime);
            hrRet = HRESULT_FROM_WIN32(ERROR_SEEK);
            __leave;
        }

        hr = GetFileAtTime(cnsStreamTime, 1 /* bWait */, &pReader);

        if (FAILED(hr))
        {
            DVR_ASSERT(pReader == NULL, "GetFileAtTime fails but pReader != NULL");
            if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                hrRet = HRESULT_FROM_WIN32(ERROR_SEEK);
            }
            else
            {
                hrRet = hr;
            }
            __leave;
        }
        DVR_ASSERT(pReader != NULL, "GetFileAtTime succeeds but pReader == NULL");

        // If this file is live (or the reader is reading from a live ring buffer)
        // the writer has either (a) written beyond cnsStreamTime (we tested this 
        // above) or (b) not written any samples at all - in this case cnsStreamTime
        // is equal to the ring buffer's start time. In either case, the writer 
        // will (should) not change the file's starting time. So the following 
        // call will return a result consistent with the previous call to GetFileAtTime,
        // i.e., we don't have to worry about the writer's calling SetFileTimes or
        // changing the starting time of the file between the two calls.

        PASF_READER_NODE    pReaderNode;
        QWORD               cnsStartTime;
        QWORD               cnsEndTime;

        pReaderNode = CONTAINING_RECORD(pReader, ASF_READER_NODE, leListEntry);;

        hr = m_pDVRFileCollection->GetTimeExtentForFile(pReaderNode->nFileId,
                                                        &cnsStartTime, 
                                                        &cnsEndTime);

        DVR_ASSERT(SUCCEEDED(hr), 
                   "GetTimeExtentForFile failed when file is open for reading");

        if (hr == S_FALSE)
        {
            // File has got bumped out of the ring buffer?
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "File id %u has been bumped out of the ring buffer after it was opened",
                            pReaderNode->nFileId);
            hr = CloseAllReaderFilesBefore(cnsEndTime); // always returs success
            hrRet = HRESULT_FROM_WIN32(ERROR_SEEK); // Seek time is not in the ring buffer extent
            __leave;
        }

        // Finally, we ask the ASF reader to seek
        DVR_ASSERT(pReaderNode->pWMReader, "");
        DVR_ASSERT(cnsStreamTime >= cnsStartTime, 
                   "cnsStreamTime is not in the time extent of file returned by GetFileAtTime");

        // Round seek time off to the nearest second. Otherwise, the SDK 
        // seeks to the next second and reads packets backwards till it
        // finds a keyframe just smaller than the value we want to seek to

        QWORD cnsSeekTime = cnsStreamTime - cnsStartTime;
        QWORD cnsRoundedSeekTime = (cnsSeekTime/k_qwSecondsToCNS) * k_qwSecondsToCNS;

        if (cnsSeekTime - cnsRoundedSeekTime > k_qwSecondsToCNS/2)
        {
            cnsRoundedSeekTime += k_qwSecondsToCNS;
            if (cnsRoundedSeekTime + cnsStartTime > (qwLastStreamTime/k_qwSecondsToCNS) * k_qwSecondsToCNS)
            {
                // ok round down in this case, else SetRange will fail
                cnsRoundedSeekTime -= k_qwSecondsToCNS;
            }
        }
        DVR_ASSERT(cnsRoundedSeekTime <= (qwLastStreamTime/k_qwSecondsToCNS) * k_qwSecondsToCNS, "");

        hr = pReaderNode->pWMReader->SetRange(cnsRoundedSeekTime,
                                              0      // Duration - 0 means duration is unlimited
                                             );

        if (FAILED(hr))
        {
            DvrIopDebugOut5(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "SetRange to time %I64u (seek time = %I64u, file start time = %I64u) for file id %u failed, hr = 0x%x",
                            cnsStreamTime - cnsStartTime, cnsStreamTime, cnsStartTime, pReaderNode->nFileId, hr);
            hrRet = hr;

            // We could, but don't have to, close the file.
            __leave;
        }

        pCurrentReaderNode = pReaderNode;
        hrRet = S_OK;
    }
    __finally
    {
        HRESULT hr;

        // Regardless of whether the seek was successful, reset the following.
        // The client has to re-seek before calling GetNextSample if the seek 
        // failed.
        ResetReader(pCurrentReaderNode);

        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    
    return hrRet;

} // CDVRReader::Seek

STDMETHODIMP CDVRReader::GetNextSample(OUT INSSBuffer**    ppSample,
                                       OUT QWORD*          pcnsStreamTimeOfSample,
                                       OUT QWORD*          pcnsSampleDuration,
                                       OUT DWORD*          pdwFlags,
                                       OUT WORD*           pwStreamNum)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::GetNextSample"

    DVRIO_TRACE_ENTER();

    // Arguments will be validated by the WM SDK; we don't use
    // them till the SDK has, so we don't validate them here.

    HRESULT hrRet = E_FAIL;
    BOOL    bCloseFiles = 1; // All files closed if this function hits an error
    BOOL    bReleaseBuffer = 0; // pWMReader->GetNextSample succeeded, but we return an error,
                                // We should release the buffer before we return.
    BOOL    bCancelled = 0;     // Read was cancelled


    ::EnterCriticalSection(&m_csLock);

    __try
    {
        HRESULT hr;
        BOOL    bEOF = 0;
        QWORD   cnsStartTime;
        QWORD   cnsEndTime;

        do 
        {
            if (!m_pCurrentNode)
            {
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                "m_pCurrentNode is NULL, should call Seek first.");

                // Since m_pCurrentNode is NULL, it's unlikely that we have any files to close
                // Note that it won't hurt to remove this.
                bCloseFiles = 0; 
                hrRet = HRESULT_FROM_WIN32(ERROR_SEEK); // Tell caller to seek first
                __leave;
            }

            DVR_ASSERT(m_pDVRFileCollection, "");

            // Is the file still within the ring buffer?
            hr = m_pDVRFileCollection->GetTimeExtentForFile(m_pCurrentNode->nFileId, NULL, NULL);

            if (FAILED(hr) || hr == S_FALSE)
            {
                DVR_ASSERT(hr == S_FALSE, 
                           "GetTimeExtentForFile failed while we have file open for reading?");
            
                if (hr == S_FALSE)
                {
                    DvrIopDebugOut3(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                                    "GetTimeExtentForFile for file id %u returns S_FALSE; file bumped out of the ring buffer",
                                    m_pCurrentNode->nFileId, hr, S_FALSE);
                    // Tell caller to seek first
                    hrRet = HRESULT_FROM_WIN32(ERROR_SEEK);
                }
                else
                {
                    DvrIopDebugOut3(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                                    "GetTimeExtentForFile for file id %u returns hr = 0x%x",
                                    m_pCurrentNode->nFileId, hr, S_FALSE);
                    // hr == E_FAIL; this is an internal error.
                    hrRet = hr;
                }
                __leave;
            }

            // Wait for the hReadyToReadFrom event

            DWORD nRet = ::WaitForSingleObject(m_pCurrentNode->hReadyToReadFrom, INFINITE);
            if (nRet == WAIT_FAILED)
            {
                DVR_ASSERT(0, "Reader node's WFSO(hReadyToReadFrom) failed");

                DWORD dwLastError = ::GetLastError();
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "WFSO(hReadyToReadFrom) failed; hReadyToReadFrom = 0x%p, last error = 0x%x", 
                                m_pCurrentNode->hReadyToReadFrom, dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
               __leave; 
            }

            if (m_pCurrentNode->pWMReader == NULL)
            {
                DVR_ASSERT(m_pCurrentNode->pWMReader != NULL, "");
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "Reader node's pWMReader is NULL?!");
                hrRet = E_FAIL;
                __leave;
            }

            // Verify there was no error in opening the file, i.e., BeginWriting 
            // succeeded
            if (FAILED(m_pCurrentNode->hrRet))
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "Reader node's hrRet indicates failure, hrRet = 0x%x",
                                m_pCurrentNode->hrRet);

                hrRet = m_pCurrentNode->hrRet;
                __leave;
            }

            // We are ready to read.
            DWORD dwOutputNum;
            hr = m_pCurrentNode->pWMReader->GetNextSample(0,  // Get from any stream
                                                          ppSample,
                                                          pcnsStreamTimeOfSample,
                                                          pcnsSampleDuration,
                                                          pdwFlags,
                                                          &dwOutputNum,
                                                          pwStreamNum);

            // Note that for live files, we should not get EOF unless the 
            // writer has actually closed the file and the reader has got to
            // the true end of file
            bEOF = hr == NS_E_NO_MORE_SAMPLES; // @@@@ verify

            if (!bEOF && FAILED(hr))
            {
                DWORD dwInternalError;

                if (hr ==  NS_E_INVALID_REQUEST)
                {
                    // Internal error
                    DVR_ASSERT(SUCCEEDED(hr), "pWMReader->GetNextSample failed");
                    hrRet = E_FAIL;
                    dwInternalError = 1;
                }
                else
                {
                    if (hr == HRESULT_FROM_WIN32(ERROR_CANCELLED))
                    {
                        // Really the caller should be made to do this - if there are 
                        // multiple threads making calls into us, resetting the event
                        // is not good. Also, caller has to do this anyway because 
                        // ERROR_CANCELLED is returned only if the reader read ahead
                        // of the writer and blocked waiting, for the writer.

                        // ResetCancel();

                        bCancelled = 1;
                    }
                    else
                    {
                        // The following is only to trap an error that we hit once 
                        // where the SDK returned ASF_E_BUFFERTOOSMALL when we were
                        // reading a live file and the writer was stopped before the
                        // file completed.

#if defined(DVR_UNOFFICIAL_BUILD)
                        WCHAR buf[256];
                        wsprintf(buf, L"Error 0x%x being returned from GetNextSample()", hr);
                        ::MessageBoxW(NULL, buf, L"DVR IO Reader", MB_OK);
                        DVR_ASSERT(0, "GNS returning an error");
#endif defined(DVR_UNOFFICIAL_BUILD)
                    }
                    
                    hrRet = hr;

                    // No need to close all files if the client caused a temporary error
                    // In any case, should not do that if bCancelled == 1
                    bCloseFiles = 0;
                    dwInternalError = 0;
                }
                if (hr != HRESULT_FROM_WIN32(ERROR_CANCELLED))
                {
                    DvrIopDebugOut2(dwInternalError?
                                    DVRIO_DBG_LEVEL_INTERNAL_ERROR :
                                    DVRIO_DBG_LEVEL_CLIENT_ERROR,
                                    "pWMReader->GetNextSample failed, hr = 0x%x, InternalError = %u",
                                    hr, dwInternalError);
                }
                __leave;
            }

            if (!bEOF)
            {
                bReleaseBuffer = 1;
            }

            // We have read a sample successfully or been returned EOF.
            //
            // Determine if the file is still in the ring buffer and its time extent.
            // If not EOF, making this call a second time is wasteful, but it's safer 
            // since the start time of the file could have changed since the last call 
            // (our writer will not do this - it does not change the start time of a file 
            // that has already been written to)..File could have been bumped out of the 
            // ring buffer during the read, so this call is not totally useless.
        
            hr = m_pDVRFileCollection->GetTimeExtentForFile(m_pCurrentNode->nFileId, 
                                                            &cnsStartTime, 
                                                            &cnsEndTime);

            if (FAILED(hr) || hr == S_FALSE)
            {
                DVR_ASSERT(hr == S_FALSE, 
                           "GetTimeExtentForFile failed while we have file open for reading?");
            
                DvrIopDebugOut3(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                                "GetTimeExtentForFile (after GetNextSample) for file id %u returns hr = 0x%x (S_FALSE = 0x%x)",
                                m_pCurrentNode->nFileId, hr, S_FALSE);

                if (hr == S_FALSE)
                {
                    // Note: Do this regardless of whether bEOF is set or not.
                    // This file got pulled out of the ring buffer. The writer 
                    // has to have written a file after this and we should be 
                    // able to seek to that file. Note that in teh special
                    // case that the writer Closes teh ring buffer after 
                    // creating it, the first file remains in the file collection
                    // and GetTimeExtentForFile will not return S_FALSE.

                    // Tell caller to seek first
                    hrRet = HRESULT_FROM_WIN32(ERROR_SEEK);
                }
                else
                {
                    // hr == E_FAIL; this is an internal error.
                    hrRet = hr;
                }
                __leave;
            }

            if (bEOF)
            {
                // The file is still in the ring buffer, so the EOF we hit was a "good" 
                // result. (Note that we may have called the ASF GetNextSample before the
                // writer wrote the first sample; in this case, the writer may have changed
                // the first sample time and bumped the file we were reading out of the 
                // ring buffer. We know that has not happened if we get here; we'd have 
                // bailed out when GetTimeExtentForFile returned S_FALSE.)

                DvrIopDebugOut0(DVRIO_DBG_LEVEL_TRACE, 
                                "Hit EOF; going to call Seek to start reading from the next file");

                // Note that the call to Seek has the side effect of seeking to the start of
                // the next ASF file. This is necessary if we had previously been reading that
                // file and seeked back (to a different file) and are now switching back to it.
                //
                // Note also that if the writer has not been closed (this is not the "real" EOF,
                // i.e., the EOF of the ring buffer), it has at least 1 file open. So 
                // *m_pcnsCurrentStreamTime, the sample time of the last sample written by the 
                // writer, would be >= cnsEndTime and the file collection object is aware that 
                // there is a file after the one on which we hit EOF. We should be able to seek
                // to that file.
                hr = Seek(cnsEndTime);
                if (FAILED(hr)) 
                {
                    // The failure could be for several reasons. We could have failed to open
                    // the next file. The caller could have called Cancel (which the DVR file
                    // source could have detected while it was opening the file). We could have
                    // hit a time hole that spans the next ASF file's time extent. Or we
                    // could have hit the real EOF. The task here is to detect the last condition.
                    //
                    // On a real EOF, cnsEndTime would be > *m_pcnsCurrentStreamTime since samples
                    // written to a file are < cnsEndTime. So Seek should return HRESULT_FROM_WIN32(ERROR_SEEK).
                    // However, to be safe, check if cnsEndTime > *m_pcnsCurrentStreamTime here.

                    if (hr == HRESULT_FROM_WIN32(ERROR_SEEK))
                    {
                        QWORD qwLastStreamTime;

                        DVR_ASSERT(m_pDVRFileCollection, "");
    
                        HRESULT hrTmp = m_pDVRFileCollection->Lock();
                        if (FAILED(hrTmp))
                        {
                            hrRet = hrTmp;
                            __leave;
                        }
                        qwLastStreamTime = *m_pcnsCurrentStreamTime;
                        hrTmp = m_pDVRFileCollection->Unlock();
                        if (FAILED(hrTmp))
                        {
                            hrRet = hrTmp;
                            __leave;
                        }

                        if (qwLastStreamTime < cnsEndTime)
                        {
                            // We've hit EOF. It's debatable whether this needs to be a success code
                            // rather than a failure; client will have to check for it specially
                            // anyway
                            hrRet = NS_E_NO_MORE_SAMPLES;

                            // Don't need to set bCloseFiles if we get a succeess code; else we do,
                            bCloseFiles = 0;
                        }
                        else
                        {
                            hrRet = hr;
                        }
                    }
                    else
                    {
                        hrRet = hr;
                    }

                    DVR_ASSERT(!bReleaseBuffer, "We should never have set this to 1 since we never read a sample");


                    if (hrRet != NS_E_NO_MORE_SAMPLES)
                    {
                        DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE, 
                                        "Seek to the next file failed after we hit EOF, returning hr = 0x%x",
                                        hrRet);
                    }
                    else
                    {
                        DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE, 
                                        "Seek to the next file failed after we hit the \"real\" EOF, returning hr = 0x%x",
                                        hrRet);
                    }
                    __leave;
                }
            }
        }
        while (bEOF);

        // Change the sample time to the stream time
        ::SafeAdd(*pcnsStreamTimeOfSample, *pcnsStreamTimeOfSample, cnsStartTime);

        DVR_ASSERT(m_pDVRFileCollection, "");
        
        QWORD cnsFirstSampleTimeOffsetFromStartOfFile;

        for (int kkTryAgain = 0; kkTryAgain < 2; kkTryAgain++)
        {
            // This lock is needed only if we are sharing the file with
            // a live source; the writer could be updating the first
            // sample time on the node.  Also, we don't really
            // need to do the stuff in this loop in any other case 
            // (i.e., if we are reading from a file, live or otherwise), 
            // because the first sample's time is always based to 0 in that case.

            hr = m_pDVRFileCollection->Lock();
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }

            cnsFirstSampleTimeOffsetFromStartOfFile = *m_pCurrentNode->pcnsFirstSampleTimeOffsetFromStartOfFile;

            hr = m_pDVRFileCollection->Unlock();
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }

            if (cnsFirstSampleTimeOffsetFromStartOfFile < MAXQWORD)
            {
                break;
            }

            if (kkTryAgain == 0)
            {
                // Writer has not updated this member yet?
                // There is a small chance this can happen since the writer
                // updates this member after WriteSample completes (writer has
                // to verify it completed successfully before updating) and
                // the WriteSample could have caused the sample to be written
                // to the file and read back out before it returned. This is
                // very unlikely to happen.
                //
                // Also note that the test for MAXQWORD catches this only if
                // m_pCurrentNode->pcnsFirstSampleTimeOffsetFromStartOfFile has never been set. If 
                // the writer revises this value downward (because sample times
                // do not increase monotonically), the client gets some 
                // inaccurate info.
                ::Sleep(100);
            }
            else
            {
                // Something's wrong here
                DVR_ASSERT(cnsFirstSampleTimeOffsetFromStartOfFile != MAXQWORD, "First sample time not updated");
            }
        }

        ::SafeAdd(*pcnsStreamTimeOfSample, *pcnsStreamTimeOfSample, cnsFirstSampleTimeOffsetFromStartOfFile);

        hrRet = S_OK; // not changed after this

        // Open the next file if we can and if we haven't already done so.
        if (m_dwConsecutiveReads < m_dwMinConsecutiveReads)
        {
            m_dwConsecutiveReads++;
        }
        if (m_dwConsecutiveReads == m_dwMinConsecutiveReads)
        {
            // We haven't yet opened the next reader file. Try to do this

            QWORD cnsNextTime;

            // Note that we allow for "time holes" after this file here.
            // When we hit EOF (above), we don't seek beyond time holes.
            hr = m_pDVRFileCollection->GetFirstValidTimeAfter(cnsEndTime, 
                                                              &cnsNextTime);
            if (SUCCEEDED(hr))
            {
                LIST_ENTRY* pNextReader;

                hr = GetFileAtTime(cnsNextTime, 0 /* bWait */, &pNextReader);

                if (FAILED(hr))
                {
                    // This should not happen - unless the file just got bumped out of the
                    // ring buffer (via a SetFileTime call)
                    DVR_ASSERT(pNextReader == NULL, "GetFileAtTime fails but pNextReader != NULL");
                }
                else
                {
                    DVR_ASSERT(pNextReader != NULL, "GetFileAtTime succeeds but pNextReader == NULL");
                    
                    // Don't need to try to open a reader file any more (till we switch
                    // to reading some other file)
                    m_dwConsecutiveReads++;
                }
            }
            else
            {
                // There is no file after this one. Defer the next trial for another 
                // m_dwMinConsecutiveReads reads
                m_dwConsecutiveReads = 0;
            }

            // Close all files before the current one
            hr = CloseAllReaderFilesBefore(cnsStartTime);
            if (FAILED(hr))
            {
                // Ignore this
            }
        }

    }
    __finally
    {
        HRESULT hr;

        if (FAILED(hrRet))
        {
            if (bCloseFiles)
            {
                // Close all files
                hr = CloseAllReaderFilesBefore(MAXQWORD);
                if (FAILED(hr))
                {
                    // Ignore this
                }

                // Following must be done; even though CloseAllReaderFilesBefore
                // calls ResetReader(), it does not call it if m_pCurrentNode was
                // equal to m_pProfileNode
                // Following can be skipped for EOF although it doesn't hurt to
                // do it - the failed Seek has already done this. (This comment is
                // irrelevant if we find a success error code to return for EOF such
                // as S_FALSE.)
                ResetReader();

                if (bReleaseBuffer)
                {
                    // pWMReader->GetNextSample succeeded, but we are
                    // failing the call.
                    if (ppSample && *ppSample)
                    {
                        (*ppSample)->Release();
                        *ppSample = NULL;
                    }
                }
            }
        }

        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    
    return hrRet;

} // CDVRReader::GetNextSample

STDMETHODIMP CDVRReader::GetStreamTimeExtent(OUT QWORD*  pcnsStartStreamTime,
                                             OUT QWORD*  pcnsEndStreamTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::GetStreamTimeExtent"

    DVRIO_TRACE_ENTER();

    if (!pcnsStartStreamTime || DvrIopIsBadWritePtr(pcnsStartStreamTime, 0) ||
        !pcnsEndStreamTime || DvrIopIsBadWritePtr(pcnsEndStreamTime, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    HRESULT             hrRet;
    BOOL                m_bUnlock = 0;

    __try
    {
        if (TryEnterCriticalSection(&m_csLock))
        {
            // We need to get here only if we are reading from a
            // live file. UpdateTimeExtent doesn't do anything 
            // in other cases. 

            // If we are reading a live file and can't get in here,
            // no matter. We'll just return the previously cached 
            // values. If the reader has read ahead of the writer
            // and is blocked, the cached values would have been 
            // updated; in other cases, they could be stale.

            m_bUnlock = 1;
            hrRet = UpdateTimeExtent();
            if (FAILED(hrRet))
            {
                __leave;
            }

            // no harm holding on to the critical section lock.
        }

        // We don't need to have a lock on this  object for 
        // the rest of this routine. We assume that the caller
        // has us properly addref'd and so we will nto be destroyed 
        // while this function is executing.

        DVR_ASSERT(m_pDVRFileCollection, "");

        hrRet = m_pDVRFileCollection->GetTimeExtent(pcnsStartStreamTime, 
                                                    pcnsEndStreamTime);
    }
    __finally
    {
        if (m_bUnlock)
        {
            ::LeaveCriticalSection(&m_csLock);
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    
    return hrRet;

} // CDVRReader::GetStreamTimeExtent

STDMETHODIMP CDVRReader::GetFirstValidTimeAfter(IN  QWORD    cnsStreamTime,  
                                                OUT QWORD*   pcnsNextValidStreamTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::GetFirstValidTimeAfter"

    DVRIO_TRACE_ENTER();

    if (!pcnsNextValidStreamTime || DvrIopIsBadWritePtr(pcnsNextValidStreamTime, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    HRESULT             hrRet;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        hrRet = UpdateTimeExtent();
        if (FAILED(hrRet))
        {
            __leave;
        }

        DVR_ASSERT(m_pDVRFileCollection, "");

        hrRet = m_pDVRFileCollection->GetFirstValidTimeAfter(cnsStreamTime, 
                                                             pcnsNextValidStreamTime);
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    
    return hrRet;

} // CDVRReader::GetFirstValidTimeAfter

STDMETHODIMP CDVRReader::GetLastValidTimeBefore(IN  QWORD    cnsStreamTime,  
                                                OUT QWORD*   pcnsLastValidStreamTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::GetLastValidTimeBefore"

    DVRIO_TRACE_ENTER();

    if (!pcnsLastValidStreamTime || DvrIopIsBadWritePtr(pcnsLastValidStreamTime, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    HRESULT             hrRet;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        hrRet = UpdateTimeExtent();
        if (FAILED(hrRet))
        {
            __leave;
        }

        DVR_ASSERT(m_pDVRFileCollection, "");

        hrRet = m_pDVRFileCollection->GetLastValidTimeBefore(cnsStreamTime, 
                                                             pcnsLastValidStreamTime);
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    
    return hrRet;

} // CDVRReader::GetLastValidTimeBefore

STDMETHODIMP CDVRReader::Cancel()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::Cancel"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = S_OK;

    // Caller should have addref'd the object. m_hCancel is 
    // created in the constructor and destroyed in the destructor,
    // so there is no need to grab the critical section.
    DVR_ASSERT(m_hCancel, "");

    if (!::SetEvent(m_hCancel))
    {
        hrRet = HRESULT_FROM_WIN32(::GetLastError());
    }

    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return hrRet;

} // CDVRReader::Cancel

STDMETHODIMP CDVRReader::ResetCancel()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::ResetCancel"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = S_OK;

    // Caller should have addref'd the object. m_hCancel is 
    // created in the constructor and destroyed in the destructor,
    // so there is no need to grab the critical section.
    DVR_ASSERT(m_hCancel, "");

    if (!::ResetEvent(m_hCancel))
    {
        hrRet = HRESULT_FROM_WIN32(::GetLastError());
    }

    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return hrRet;

} // CDVRReader::ResetCancel

STDMETHODIMP_(ULONG) CDVRReader::IsLive()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::IsLive"

    DVRIO_TRACE_ENTER();

    LONG nRet;

    // Caller should have addref'd the object. m_bSourceIsAFile is 
    // set in the constructor and dunchanged thereafter,
    // so there is no need to grab the critical section yet.
    if (!m_bSourceIsAFile)
    {
        nRet = *m_pnWriterHasBeenClosed? 1 : 0;
    }
    else
    {
        ::EnterCriticalSection(&m_csLock);

        __try
        {
            if (m_bDVRProgramFileIsLive)
            {
                // Get current status

                HRESULT hr = UpdateTimeExtent();

                if (FAILED(hr))
                {
                    nRet = 1;                   
                }
                else
                {
                    nRet = m_bDVRProgramFileIsLive? 1 : 0;
                }
            }
            else
            {
                nRet = 0;
            }
        }
        __finally
        {
            ::LeaveCriticalSection(&m_csLock);
        }
    }

    DVRIO_TRACE_LEAVE1(nRet);

    return nRet;

} // CDVRReader::IsLive

STDMETHODIMP CDVRReader::ReadIsGoingToPend()  
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRReader::ReadIsGoingToPend"

    DVRIO_TRACE_ENTER();

    HRESULT             hrRet;

    // We should NOT block in this funciton

    // We should have already acquired all the locks    
    if (!TryEnterCriticalSection(&m_csLock))
    {
        DVR_ASSERT(0, "Sync Reader using a different thread to read bytes than the one calling GetNextSample.");
        return E_FAIL;
    }

    __try
    {
        hrRet = UpdateTimeExtent();
        if (FAILED(hrRet))
        {
            __leave;
        }
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRReader::ReadIsGoingToPend
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrio\dvrreg.cpp ===
//------------------------------------------------------------------------------
// File: dvrReg.cpp
//
// Description: Implements registry related functions.
//
// Copyright (c) 2000 - 2001, Microsoft Corporation.  All rights reserved.
//
//------------------------------------------------------------------------------

#include <precomp.h>
#pragma hdrstop


#if defined(DEBUG)

#define DVRIO_DUMP_THIS_FORMAT_STR ""
#define DVRIO_DUMP_THIS_VALUE

void DvrIopDbgInitFromRegistry(
    IN  HKEY  hRegistryKey,
    IN  DWORD dwNumValues, 
    IN  const WCHAR* awszValueNames[],
    OUT DWORD* apdwVariables[]
    )
{
    // Note: Only DVR_ASSERT variants should be used in this function.
    // No trace, no DvrIopDebugOut except for errors

    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "DvrIopDbgInitFromRegistry"

    // Can't do this: not set up yet!
    // DVRIO_TRACE_ENTER();

    HKEY hDvrIoDebugKey = NULL;
    DWORD dwRegRet;

    __try
    {
        dwRegRet = ::RegCreateKeyExW(
                        hRegistryKey,
                        kwszRegDvrIoDebugKey, // subkey
                        0,                   // reserved
                        NULL,                // class string
                        REG_OPTION_NON_VOLATILE, // special options
                        KEY_ALL_ACCESS,      // desired security access
                        NULL,                // security attr
                        &hDvrIoDebugKey,     // key handle 
                        NULL                 // disposition value buffer
                       );
        if (dwRegRet != ERROR_SUCCESS)
        {
            DVR_ASSERT(hDvrIoDebugKey,
                       "Creation/opening of registry key hDvrIoDebugKey failed.");
            __leave;
        }
        for (DWORD i = 0; i < dwNumValues; i++)
        {
            DWORD dwType;
            DWORD dwVal;
            DWORD dwValBufSize = sizeof(dwVal);
        
            dwRegRet = ::RegQueryValueExW(hDvrIoDebugKey,     // key
                                          awszValueNames[i],  // value name
                                          NULL,               // reserved
                                          &dwType,            // type of value
                                          (LPBYTE) &dwVal,    // Value
                                          &dwValBufSize       // sizeof dwVal
                                         );
            if (dwRegRet == ERROR_SUCCESS && dwType == REG_DWORD)
            {
                *(apdwVariables[i]) = dwVal;
            }
            else if (dwRegRet == ERROR_FILE_NOT_FOUND)
            {
                dwVal = *(apdwVariables[i]);

                dwRegRet = ::RegSetValueExW(hDvrIoDebugKey,     // key
                                            awszValueNames[i],  // value name
                                            NULL,               // reserved
                                            REG_DWORD,          // type of value
                                            (LPBYTE) &dwVal,    // Value
                                            sizeof(DWORD)       // sizeof dwVal
                                           );
                if (dwRegRet != ERROR_SUCCESS)
                {
                    DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                               "Setting value of debug registry key failed.");
                    // Ignore the error and move to the next value
                }
            }
            else
            {
                // Ignore the error and move on
            }
        }
    }
    __finally
    {
        if (hDvrIoDebugKey)
        {
            dwRegRet = ::RegCloseKey(hDvrIoDebugKey);
            if (dwRegRet != ERROR_SUCCESS)
            {
                DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                           "Closing registry key hDvrIoDebugKey failed.");
            }
        }
    }

    // DVRIO_TRACE_LEAVE();

    return;
} // void DvrIopDbgInitFromRegistry

#endif // DEBUG


DWORD GetRegDWORD(IN HKEY hKey, IN LPCWSTR pwszValueName, IN DWORD dwDefaultValue)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "GetRegDWORD"

    DVRIO_TRACE_ENTER();

    if (!hKey || !pwszValueName || DvrIopIsBadStringPtr(pwszValueName))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return dwDefaultValue;
    }

    DWORD dwRet = dwDefaultValue;
    DWORD dwRegRet;

    __try
    {
        DWORD dwType;
        DWORD dwSize;
        DWORD dwValue;

        dwSize = sizeof(DWORD);

        dwRegRet = ::RegQueryValueExW(
                        hKey,
                        pwszValueName,       // value's name
                        0,                   // reserved
                        &dwType,             // type
                        (LPBYTE) &dwValue,   // data
                        &dwSize              // size in bytes
                       );
        if (dwRegRet != ERROR_SUCCESS && dwRegRet != ERROR_FILE_NOT_FOUND)
        {            
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "RegGetValueExW failed; error = 0x%x", 
                            dwRegRet);

            __leave;
        }
        if (dwRegRet == ERROR_FILE_NOT_FOUND)
        {
            dwRegRet = ::RegSetValueExW(hKey,               // key
                                        pwszValueName,      // value name
                                        NULL,               // reserved
                                        REG_DWORD,          // type of value
                                        (LPBYTE) &dwRet,    // Value
                                        sizeof(DWORD)       // sizeof dwVal
                                       );
            if (dwRegRet != ERROR_SUCCESS)
            {
                DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                           "Setting value of debug registry key failed.");
            }
            __leave;
        }
        if (dwType != REG_DWORD)
        {
            DVR_ASSERT(dwType == REG_DWORD, "Type of value is not REG_DWORD");
            
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "Type of value is not REG_DWORD, it is = 0x%x", 
                            dwType);

            __leave;
        }

        dwRet = dwValue;
        __leave;
    }
    __finally
    {
        DVRIO_TRACE_LEAVE1(dwRet);
    }

    return dwRet;

} // GetRegDWORD

HRESULT GetRegString(IN HKEY hKey, 
                     IN LPCWSTR pwszValueName,
                     OUT LPWSTR pwszValue OPTIONAL,
                     IN OUT DWORD* pdwSize)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "GetRegString"

    DVRIO_TRACE_ENTER();

    if (!hKey || !pdwSize || DvrIopIsBadWritePtr(pdwSize, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    if (pwszValue && DvrIopIsBadWritePtr(pwszValue, *pdwSize))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    HRESULT hrRet;
    DWORD dwRegRet;

    __try
    {
        DWORD dwType;

        dwRegRet = ::RegQueryValueExW(
                        hKey,
                        pwszValueName,       // value's name
                        0,                   // reserved
                        &dwType,             // type
                        (LPBYTE) pwszValue,   // data
                        pdwSize              // size in bytes
                       );
        if (dwRegRet == ERROR_FILE_NOT_FOUND)
        {
            WCHAR w[] = L"";
            dwRegRet = ::RegSetValueExW(hKey,               // key
                                        pwszValueName,      // value name
                                        NULL,               // reserved
                                        REG_SZ,             // type of value
                                        (LPBYTE) w,         // Value
                                        sizeof(w)           // sizeof dwVal
                                       );
            if (dwRegRet != ERROR_SUCCESS)
            {
                DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                           "Setting value of debug registry key failed.");
            }
            hrRet = HRESULT_FROM_WIN32(dwRegRet);
            __leave;
        }
        else if (dwRegRet != ERROR_SUCCESS)
        {            
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "RegGetValueExW failed; error = 0x%x", 
                            dwRegRet);

            hrRet = HRESULT_FROM_WIN32(dwRegRet);
            __leave;
        }
        else if (dwType != REG_SZ)
        {
            DVR_ASSERT(dwType == REG_SZ, "Type of value name is not REG_SZ");
            
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "Type of value name is not REG_SZ, it is = 0x%x", 
                            dwType);

            *pdwSize = 0;
            hrRet = E_FAIL;
            __leave;
        }

        hrRet = S_OK;
    }
    __finally
    {
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return hrRet;

} // GetRegString
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrio\precomp.h ===
#ifndef _DVR_IO_PRECOMP_H_
#define _DVR_IO_PRECOMP_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define UNICODE             

#include <nt.h>

// Following two are currently only for definitions of the list 
// function macros. RTL functions are not used. Note that winnt.h
// defines LIST_ENTRY but does not define the macros.
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

// winnt.h is not included by windows.h because nt.h is included
// earlier. As a result MAXDWORD is undefined.

#ifndef MAXDWORD
#define MAXDWORD 0xffffffff
#endif


#include <malloc.h>     // For _alloca

#include <nserror.h>

// Use _DVR_IOP_ to define exported functions.
#define _DVR_IOP_       
#include <dvrIOidl.h>
#include <DVRFileSource.h>
#include <DVRFileSink.h>
#include <dvrIOp.h>

#endif // _DVR_IO_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrio\dvrioringbufferwriter.cpp ===
//------------------------------------------------------------------------------
// File: dvrIORingBufferWriter.cpp
//
// Description: Implements the class CDVRRingBufferWriter
//
// Copyright (c) 2000 - 2001, Microsoft Corporation.  All rights reserved.
//
//------------------------------------------------------------------------------

#include <precomp.h>
#pragma hdrstop

HRESULT STDMETHODCALLTYPE DVRCreateRingBufferWriter(IN  DWORD                   dwNumberOfFiles, 
                                                    IN  QWORD                   cnsTimeExtentOfEachFile, 
                                                    IN  IWMProfile*             pProfile, 
                                                    IN  DWORD                   dwIndexStreamId,
                                                    IN  HKEY                    hRegistryRootKeyParam OPTIONAL,
                                                    IN  LPCWSTR                 pwszDVRDirectory OPTIONAL,
                                                    OUT IDVRRingBufferWriter**  ppDVRRingBufferWriter)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "DVRCreateRingBufferWriter"

    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR ""
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE
    #endif

    DVRIO_TRACE_ENTER();

    if (!ppDVRRingBufferWriter || DvrIopIsBadWritePtr(ppDVRRingBufferWriter, 0) ||
        (pwszDVRDirectory && DvrIopIsBadStringPtr(pwszDVRDirectory))
       )
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        return E_INVALIDARG;
    }

    HRESULT                 hrRet;
    CDVRRingBufferWriter*   p;
    HKEY                    hDvrIoKey = NULL;
    HKEY                    hRegistryRootKey = NULL;
    BOOL                    bCloseKeys = 1; // Close all keys that we opened (only if this fn fails)

    *ppDVRRingBufferWriter = NULL;

    __try
    {
        DWORD dwRegRet;

        if (!hRegistryRootKeyParam)
        {
            dwRegRet = ::RegCreateKeyExW(
                            g_hDefaultRegistryHive,
                            kwszRegDvrKey,       // subkey
                            0,                   // reserved
                            NULL,                // class string
                            REG_OPTION_NON_VOLATILE, // special options
                            KEY_ALL_ACCESS,      // desired security access
                            NULL,                // security attr
                            &hRegistryRootKey,   // key handle 
                            NULL                 // disposition value buffer
                           );
            if (dwRegRet != ERROR_SUCCESS)
            {
                DWORD dwLastError = ::GetLastError();
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                                "RegCreateKeyExW for DVR key failed, last error = 0x%x",
                                dwLastError);
               hrRet = HRESULT_FROM_WIN32(dwLastError);
               __leave;
            }
        }
        else
        {
            if (0 == ::DuplicateHandle(::GetCurrentProcess(), hRegistryRootKeyParam,
                                       ::GetCurrentProcess(), (LPHANDLE) &hRegistryRootKey,
                                       0,       // desired access - ignored
                                       FALSE,   // bInherit
                                       DUPLICATE_SAME_ACCESS))
            {
                DWORD dwLastError = ::GetLastError();
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                                "DuplicateHandle failed for DVR IO key, last error = 0x%x",
                                dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }
        }

        dwRegRet = ::RegCreateKeyExW(
                        hRegistryRootKey,
                        kwszRegDvrIoWriterKey, // subkey
                        0,                   // reserved
                        NULL,                // class string
                        REG_OPTION_NON_VOLATILE, // special options
                        KEY_ALL_ACCESS,      // desired security access
                        NULL,                // security attr
                        &hDvrIoKey,          // key handle 
                        NULL                 // disposition value buffer
                       );
        if (dwRegRet != ERROR_SUCCESS)
        {
            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "RegCreateKeyExW for DVR IO key failed, last error = 0x%x",
                            dwLastError);
           hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }


#if defined(DEBUG)
        // Until this point, we have been using default values for the debug levels
        DvrIopDbgInit(hRegistryRootKey);
#endif // DEBUG

        p = new CDVRRingBufferWriter(dwNumberOfFiles, 
                                     cnsTimeExtentOfEachFile, 
                                     pProfile, 
                                     dwIndexStreamId, 
                                     hRegistryRootKey, 
                                     hDvrIoKey,
                                     pwszDVRDirectory, 
                                     &hrRet);

        if (p == NULL)
        {
            hrRet = E_OUTOFMEMORY;
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "alloc via new failed - CDVRRingBufferWriter");
            __leave;
        }
        
        bCloseKeys = 0; // ~CDVRRingBufferWriter will close the keys

        if (FAILED(hrRet))
        {
            __leave;
        }


        hrRet = p->QueryInterface(IID_IDVRRingBufferWriter, (void**) ppDVRRingBufferWriter);
        if (FAILED(hrRet))
        {
            DVR_ASSERT(0, "QI for IID_IDVRRingBufferWriter failed");
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "CDVRRingBufferWriter::QueryInterface failed, hr = 0x%x", 
                            hrRet);
            __leave;
        }
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            delete p;

            if (bCloseKeys)
            {
                DWORD dwRegRet;

                if (hDvrIoKey)
                {
                    dwRegRet = ::RegCloseKey(hDvrIoKey);
                    if (dwRegRet != ERROR_SUCCESS)
                    {
                        DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                                   "Closing registry key hDvrIoKey failed.");
                    }
                }
                if (hRegistryRootKey)
                {
                    DVR_ASSERT(hRegistryRootKey, "");
                    dwRegRet = ::RegCloseKey(hRegistryRootKey);
                    if (dwRegRet != ERROR_SUCCESS)
                    {
                        DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                                   "Closing registry key hRegistryRootKey failed.");
                    }
                }
            }
        }
        else
        {
            DVR_ASSERT(bCloseKeys == 0, "");
        }
    }

    DVRIO_TRACE_LEAVE1_HR(hrRet);
    return hrRet;

} // DVRCreateRingBufferWriter

// ====== Constructor, destructor

#if defined(DEBUG)
DWORD CDVRRingBufferWriter::m_dwNextClassInstanceId = 0;
#endif

#if defined(DEBUG)
#undef DVRIO_DUMP_THIS_FORMAT_STR
#define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
#undef DVRIO_DUMP_THIS_VALUE
#define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
#endif

CDVRRingBufferWriter::CDVRRingBufferWriter(IN  DWORD       dwNumberOfFiles,
                                           IN  QWORD       cnsTimeExtentOfEachFile,
                                           IN  IWMProfile* pProfile,
                                           IN  DWORD       dwIndexStreamId,
                                           IN  HKEY        hRegistryRootKey,
                                           IN  HKEY        hDvrIoKey,
                                           IN  LPCWSTR     pwszDVRDirectoryParam OPTIONAL,
                                           OUT HRESULT*    phr)
    : m_dwNumberOfFiles(dwNumberOfFiles)
    , m_cnsTimeExtentOfEachFile(cnsTimeExtentOfEachFile)
    , m_pProfile(pProfile)
    , m_dwIndexStreamId(dwIndexStreamId)
    , m_hRegistryRootKey(hRegistryRootKey)
    , m_hDvrIoKey(hDvrIoKey)
    , m_pwszDVRDirectory(NULL)
    , m_cnsMaxStreamDelta(0)
    , m_nFlags(0)
    , m_cnsFirstSampleTime(0)
    , m_nNotOkToWrite(-2)
    , m_pcnsCurrentStreamTime(NULL)
    , m_pnWriterHasBeenClosed(NULL)
    , m_pDVRFileCollection(NULL)
    , m_nRefCount(0)
#if defined(DEBUG)
    , m_dwClassInstanceId(InterlockedIncrement((LPLONG) &m_dwNextClassInstanceId))
#endif
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::CDVRRingBufferWriter"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    DVR_ASSERT(!phr || !DvrIopIsBadWritePtr(phr, 0), "");

    ::InitializeCriticalSection(&m_csLock);
    m_pProfile->AddRef();
    InitializeListHead(&m_leWritersList);
    InitializeListHead(&m_leFreeList);
    InitializeListHead(&m_leRecordersList);

    __try
    {
        HRESULT hr;

        if (pwszDVRDirectoryParam && DvrIopIsBadStringPtr(pwszDVRDirectoryParam))
        {
            hrRet = E_INVALIDARG;
            __leave;
        }

        if (pwszDVRDirectoryParam)
        {
            // Convert the supplied argument ot a fully qualified path

            WCHAR   wTempChar;
            DWORD   dwLastError;
            DWORD   nLen;

            nLen = ::GetFullPathNameW(pwszDVRDirectoryParam, 0, &wTempChar, NULL);
            if (nLen == 0)
            {
                dwLastError = ::GetLastError();
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                                "First GetFullPathNameW failed, nLen = %u, last error = 0x%x",
                                nLen, dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }

            m_pwszDVRDirectory = new WCHAR[nLen+1];
            if (m_pwszDVRDirectory == NULL)
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "alloc via new failed - m_pwszDVRDirectory - WCHAR[%u]",
                                nLen+1);

                hrRet = E_OUTOFMEMORY;
                __leave;
            }

            nLen = ::GetFullPathNameW(pwszDVRDirectoryParam, nLen+1, m_pwszDVRDirectory, NULL);
            if (nLen == 0)
            {
                dwLastError = ::GetLastError();
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                                "Second GetFullPathNameW failed, nLen = %u, last error = 0x%x",
                                nLen, dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }
        }
        if (!m_pwszDVRDirectory)
        {
            // Directory not supplied to fn. Get it from the registry

            DWORD  dwSize;

            hr = GetRegString(m_hDvrIoKey, kwszRegDataDirectoryValue, NULL, &dwSize);

            if (FAILED(hr) && hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                hrRet = hr;
                __leave;
            }

            if (SUCCEEDED(hr) && dwSize > sizeof(WCHAR))
            {
                // + 1 just in case dwSize is not a multiple of sizeof(WCHAR)
                m_pwszDVRDirectory = new WCHAR[dwSize/sizeof(WCHAR) + 1];

                if (!m_pwszDVRDirectory)
                {
                    hrRet = E_OUTOFMEMORY;
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, "alloc via new failed - WCHAR[%u]", dwSize/sizeof(WCHAR)+1);
                    __leave;
                }

                hr = GetRegString(m_hDvrIoKey, kwszRegDataDirectoryValue, m_pwszDVRDirectory, &dwSize);
                if (FAILED(hr))
                {
                    DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                    "GetRegString failed to get value of kwszRegDataDirectoryValue (second call).");
                    hrRet = hr;
                    __leave;
                }
            }
        }
        if (!m_pwszDVRDirectory)
        {
            // Directory not supplied to fn and not set in the registry.
            // Use the temp path

            DWORD dwRet;
            WCHAR w;

            dwRet = ::GetTempPathW(0, &w);

            if (dwRet == 0)
            {
                // GetTempPathW failed
                DVR_ASSERT(0, 
                           "Temporary directory for DVR files not set in registry "
                           "and GetTempPath() failed.");

                DWORD dwLastError = ::GetLastError(); // for debugging only
            
                hrRet = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                __leave;
            }

            // MSDN is confusing: is the value returned by GetTempPathW in bytes or WCHAR? 
            // Does it include space for NULL char at end?
            m_pwszDVRDirectory = new WCHAR[dwRet + 1];

            if (m_pwszDVRDirectory == NULL)
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, "alloc via new failed - WCHAR[%u]", dwRet + 1);

                hrRet = E_OUTOFMEMORY; // out of stack space
                __leave;
            }

            dwRet = ::GetTempPathW(dwRet + 1, m_pwszDVRDirectory);

            if (dwRet == 0)
            {
                // GetTempPathW failed
                DVR_ASSERT(0, 
                           "Temporary directory for DVR files not set in registry "
                           "and GetTempPath() [second call] failed.");

                DWORD dwLastError = ::GetLastError(); // for debugging only
                
                hrRet = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                __leave;
            }

            // Note that m_pwszDVRDirectory includes a trailing \.
            // And we should get a fully qualified path name 
            DVR_ASSERT(dwRet > 1, "");

            // Zap the trailing \.
            if (m_pwszDVRDirectory[dwRet-1] = L'\\')
            {
                m_pwszDVRDirectory[dwRet-1] = L'\0';
            }
        }

        // We add 1 to the number of temporary files provided to us since
        // we create a priming file, which is empty.
        m_pDVRFileCollection = new CDVRFileCollection(m_dwNumberOfFiles + 1,
                                                      m_pwszDVRDirectory,
                                                      &m_pcnsCurrentStreamTime,
                                                      &m_pnWriterHasBeenClosed,
                                                      &hr);
        if (!m_pDVRFileCollection)
        {
            hrRet = E_OUTOFMEMORY;
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "alloc via new failed - m_pDVRFileCollection");
            __leave;
        }

        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        DVR_ASSERT(m_pnWriterHasBeenClosed, "");
        *m_pnWriterHasBeenClosed = 0;

        // Get 1 file ready for writing. Since we don't know the 
        // starting time yet, set the time extent of the file to
        // (0, m_cnsTimeExtentOfEachFile)
        hr = AddATemporaryFile(0, m_cnsTimeExtentOfEachFile);

        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        DWORD dwIncreasingTimeStamps = 1;

#if defined(DVR_UNOFFICIAL_BUILD)

        dwIncreasingTimeStamps = ::GetRegDWORD(m_hDvrIoKey,
                                               kwszRegEnforceIncreasingTimestampsValue, 
                                               kdwRegEnforce