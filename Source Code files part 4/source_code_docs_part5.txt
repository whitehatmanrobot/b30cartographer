s are required by the OS kernel.  These functions are the EFI Run Time Services.  The OS loader must pass the SystemTable to the OS kernel, so the OS kernel can make the Run Time Service calls.  The exact mechanism used to transition from the OS loader to the OS kernel is implementation dependent.  It is important to note that the OS loader could transition to the OS kernel prior to calling ExitBootServices().  In this case, the OS kernel is responsible for calling ExitBootServices() before taking full control of the system. EFI Boot Time Services A high level description of the EFI Boot Time Services are described in this section. These services are APIs exported by the EFI environment, and they are only available at boot time before an operating system takes control of the system.  Once a call to ExitBootServices() is made, the EFI Boot Time Service APIs may no longer be used.   The EFI Boot Time Services are organized into the following groups.   Event Services Memory Allocation Services Protocol Handler Services Image Services Miscellaneous Services Event Services Table A-1 lists the functions used to manage events. Table A-1. Event Services Description CreateEvent Creates a general-purpose event structure. CloseEvent Closes and frees an event structure. CheckEvent Checks whether an event is in the signaled state.  SignalEvent Signals an event. RaiseTPL Raises the task priority level. RestoreTPL Restores/lowers the task priority level. SetTimer Sets an event to be signaled at a particular time. WaitForEvent Waits for an event to be signaled. Memory Allocation Services Table A-2 lists the functions used to allocate and free memory. Table A-2. Memory Allocation Services Description AllocatePages Allocates memory pages of a particular type. FreePages Frees memory pages. GetMemoryMap Returns the current boot services memory map and memory map key. AllocatePool Allocates pool of a particular type. FreePool Frees allocated pool. Protocol Handler Services Table A-3 lists the functions used to manage protocol handles. Table A-3. Protocol Handler Services Description InstallProtocolInterface Adds protocol handler onto an existing or new device handle. UninstallProtocolInterface Removes a protocol handler from a device handle. ReinstallProtocolInterface Replaces a protocol interface. HandleProtocol Queries the list of protocol handlers on a device handle for the requested Protocol Interface. RegisterProtocolNotify Registers for protocol interface installation notifications LocateHandle Locates the handle(s) that support the specified protocol. LocateDevicePath Locates the closest handle that supports the specified protocol on the specified device path. Image Services Table A-4 lists the functions used load, execute, and exit EFI images. Table A-4. Image Services Description LoadImage Function to dynamically load another EFI Image. StartImage Function to transfer control to the Image s entry point. EFI_IMAGE_ENTRY_POINT Prototype of an EFI Image s entry point. Exits the image s entry point. UnloadImage Unloads an image loaded with LoadImage. ExitBootServices Terminates boot services. Miscellaneous Services Table A-5. Miscellaneous Services Description SetWatchdogTimer Resets and sets the system s watchdog timer. Stall Stall the processor for a specified number of microseconds. GetNextMonotonicCount Returns a monotonically increasing count for the platform. InstallConfigurationTable Adds, updates, or removes a configuration table from the EFI System Table EFI Run Time Services A high level description of the EFI Run Time Services are described in this section. These services are APIs exported by the EFI environment, and they are always available.  The EFI Run Time Services are organized into the following groups.   Variable Services Time Services Virtual Memory Services Miscellaneous Services Variable Services The Variable Services are used to maintain environment variables in non-volatile storage.  Table B-1 lists the functions available for retrieving, creating, modifying, and deleting environment variables in non-volatile storage. Table B-1. Variable Services Description GetVariable Returns the value of the specified variable GetNextVariableName Enumerates the current variables names SetVariable Sets the value of the specified variable. Time Services Table B-2 lists the functions available to access the system s Real Time Clock (RTC) and timer hardware. Table B-2. Time Services Description GetTime Returns the current time and date information. SetTime Sets the current time and date. GetWakeupTime Returns the current wakeup alarm clock setting. SetWakeupTime Sets the current wakeup alarm clock setting. Virtual Memory Services Table B-3 lists the functions used transition the firmware from flat physical  mode to virtual runtime mode. Table B-3. Virtual Memory Services Description SetVirtualAddressMap Used by an OS loader to convert from physical addressing to virtual addressing. ConvertPointer Used by EFI components to convert internal pointers when switching to virtual addressing. Miscellaneous Services Table B-4 lists the miscellaneous runtime services. Table B-4. Miscellaneous Services Description GetNextHighMonotonicCount Subsumes the platform s monotonic counter functionality. ResetSystem Resets all processors and devices and reboots the system. EFI Protocol Interfaces A high level description of the EFI Protocol Interfaces are described in this section. These services are APIs exported by the EFI environment through GUID based protocol handles.  The standard set of protocol interfaces are listed here.  Additional protocol interfaces may be added to a system by an EFI device driver.  The EFI Protocol Interfaces are organized into the following groups.   Device Path Protocol Device I/O Protocol Simple Input Protocol Simple Text Output Protocol Block I/O Protocol Disk I/O Protocol File System Protocol Load File Protocol Loaded Image Protocol Serial I/O Protocol Unicode Collation Protocol PXI I/O Protocol Simple Network Protocol Device Path Protocol This protocol does not contain any interfaces.  It simply returns a pointer to the device path for the protocol instance. Device I/O Protocol Table C-2 lists the functions used by device drivers to access hardware devices in a bus specific manner.  Table C-2. Device I/O Protocol Interfaces Description Mem.Read Reads from memory on a bus. Mem.Write Writes to memory on a bus. Io.Read Reads from I/O ports on a bus. Io.Write Writes to I/O ports on a bus. Pci.Read Reads from PCI Configuration Space. Pci.Write Writes to PCI Configuration Space. PciDevicePath Provides an EFI Device Path for a PCI device with the given PCI configuration space address. Provides the device specific addresses needed to access host memory for DMA. Unmap Releases any resources allocated with Map() AllocateBuffer Allocates pages that are suitable for a common buffer mapping. Flush Flushes any posted write data to the device. FreeBuffer Frees pages that were allocated with AllocateBuffer() Simple Input Protocol Table C-3 lists the functions used to access a simple input hardware device. Table C-3. Simple Input Protocol Interfaces Description Reset Resets a simple input device. ReadKeyStroke Read a keystroke from a simple input device. Simple Text Output Protocol Table C-4 lists the functions used to access the standard output device, the standard error device, or any other text based output device. Table C-4. Simple Text Output Protocol Interfaces Description Reset Reset the ConsoleOut device. OutputString Displays the Unicode string on the device at the current cursor location. TestString Test to see if the ConsoleOut device supports this Unicode string. QueryMode Queries information concerning the output device s supported text mode. SetMode Sets the current mode of the output device. SetAttribute Sets the foreground and background color of the text that is output. ClearScreen Clears the screen with the currently set background color. SetCursorPosition Sets the current cursor position. EnableCursor Turns on/off the visibility of the cursor. Block I/O Protocol Table C-5 lists the functions used to access a block based I/O device. Table C-5. Block I/O Protocol Interfaces Description Reset Resets the block device hardware. ReadBlocks Reads the requested number of blocks from the device. WriteBlocks Writes the requested number of blocks to the device. FlushBlocks Flushes any cached blocks. Disk I/O Protocol Table C-6 lists the functions used to access a block based I/O device as a byte stream device. Table C-6. Disk I/O Protocol Interfaces Description ReadDisk Reads data from the disk. WriteDisk Writes data to the disk. Simple File System Protocol Table C-7 lists the functions used to open a partition for file access. Table C-7. Simple File System Protocol Interfaces Description OpenVolume Opens the volume for file I/O access. File System Protocol Table C-8 lists the functions used to maintain files in a partition containing a supported file system. Table C-8. File System Protocol Interfaces Description Opens or creates a new file. Close Closes the current file handle. Delete Deletes a file. Reads bytes from the file. Write Writes bytes to the file. SetPosition Sets the current file position. GetPosition Returns the current file position. GetInfo Gets the requested file or volume information. SetInfo Sets the requested file information. Flush Flushes all modified data associated with the file to the device. Load File Protocol Table C-9 lists the functions used to load drivers from sources other than a file system. Table C-9. Load File Protocol Interfaces Description LoadFile Causes the driver to load the requested file. Loaded Image Protocol Table C-10 lists the functions used to load drivers from sources other than a file system. Table C-10. Loaded Image Protocol Interfaces Description Unload Requests an image to unload. Serial I/O Protocol Table C-11 lists the functions used to access a serial I/O device. Table C-11. Serial I/O Protocol Interfaces Description Reset Resets the hardware device. SetAttributes Sets communication parameters for a serial device.  These include the baud rate, receive FIFO depth, transmit/receive time out, parity, data bits, and stop bit attributes. SetControl Set the control bits on a serial device.  These include Request to Send and Data Terminal Ready. GetControl Read the status of the control bits on a serial device.  These include Clear to Send, Data Set Ready, Ring Indicator, and Carrier Detect. Write Send a buffer of characters to a serial device. Receive a buffer of characters from a serial device. Unicode Collation Protocol Table C-12 lists the functions used to perform case insensitive Unicode string comparisons. Table C-12. Unicode Collation Protocol Interfaces Description StriColl Performs a case insensitive comparison between two Unicode strings. MetaiMatch Performs a case insensitive comparison between aUnicode pattern string and a Unicode string.  The pattern string can use the   wildcard for match any character, and the   wildcard for match any substring. StrLwr Converts characters in a Unicode string to upper case characters. StrUpr Converts characters in a Unicode string to lower case characters. FatToStr Converts a FAT 8.3 file name to a Unicode string StrToFat Converts a Unicode string to a FAT 8.3 file name. PXE I/O Protocol Table C-13 lists the functions used to access a network device. Table C-13. PXE I/O Protocol Interfaces Description Uses the ARP protocol to resolve a MAC address.  Attempts to complete a DHCPv4 D.O.R.A. (discover / offer / request / acknowledge) or DHCPv6 S.A.R.R (solicit / advertise / request / reply) sequence. Discover Attempts to complete the PXE Boot Server and/or boot image discovery sequence. EFI_PXE_BASE_CODE _CALLBACK Callback function that is invoked when the PXE Base Code Protocol is waiting for an event.  Mtftp Is used to perform TFTP and MTFTP services.  SetIpFilter Updates the IP receive filters of a network device and enables software filtering.  SetPackets Updates the contents of the cached DHCP and Discover packets.  SetParameters Updates the parameters that affect the operation of the PXE Base Code Protocol.  SetStationIp Updates the station IP address and/or subnet mask values.  Start Enables the use of PXE Base Code Protocol functions. Disables the use of PXE Base Code Protocol functions. UdpRead Reads a UDP packet from a network interface.  UdpWrite Writes a UDP packet to a network interface.  Simple Network Protocol Table C-14 lists the functions used to access a network device. Table C-14. Simple Network Protocol Interfaces Description GetStatus Reads the current interrupt status and recycled transmit buffer status from the network interface.  Initialize Resets the network adapter and allocates the transmit and receive buffers required by the network interface; also optionally allows space for additional transmit and receive buffers to be allocated MCastIPtoMAC Allows a multicast IP address to be mapped to a multicast HW MAC address.  NVData Allows read and writes to the NVRAM device attached to a network interface.  Receive Receives a packet from the network interface.  Reset Resets the network adapter, and re-initializes it with the parameters that were provided in the previous call to Initialize(). Shutdown Resets the network adapter and leaves it in a state safe for another driver to initialize. Start Changes the network interface from the stopped state to the started state.  StationAddress Allows the station address of the network interface to be modified. Statistics Allows the statistics on the network interface to be reset and/or collected.  Changes the network interface from the started state to the stopped state. Transmit Places a packet in the transmit queue of the network interface.  EFI Library Functions and Macros A high level description of the EFI library functions and macros are described in this section. These library functions are complementary to the APIs described in the EFI specification.  EFI library functions and macros are organized into the following groups.   Initialization Functions Linked List Support Macros String Functions Memory Support Functions CRC Support Functions Text I/O Functions Math Functions Spin Lock Functions Handle and Protocol Functions File I/O Support Functions Device Path Support Functions Miscellaneous Functions Initialization Functions The initialization functions in the EFI Library are used to initialize the execution environment so that other EFI Library function may be used.  Table D-1 lists the initialization support. Table D-1. Initialization Functions Description InitializeLib Initializes the EFI Library. InitializeUnicodeSupport Initializes the use of language dependant Unicode library functions. Linked List Support Macros The EFI Library supplies a set of macros that allow doubly linked lists to be created and maintained.  Table D-2 contains the list of macros. Table D-2. Linked List Support Macros Description InitializeListHead Initializes the head node of a doubly linked list. IsListEmpty Determines if a doubly linked list is empty. RemoveEntryList Removes a node from a doubly linked list. InsertTailList Adds a node to the end of a double linked list. InsertHeadList Adds a node to the beginning of a doubly linked list. String Functions The string functions in the EFI Library perform operations on Unicode and ASCII string.  Table D-3 contains the list of string support functions. Table D-3. String Functions Description StrCmp Compares two Unicode strings. StrnCmp Compares a portion of two Unicode strings. StriCmp Performs a case insensitive comparison of two Unicode strings. StrCpy Copies one Unicode string to another Unicode string. StrCat Concatenates two Unicode strings. StrLen Determines the length of a Unicode string. StrSize Determines the size of a Unicode string in bytes. StrDuplicate Creates a duplicate of a Unicode string. StrLwr Converts characters in a Unicode string to upper case characters. StrUpr Converts characters in a Unicode string to lower case characters. strlena Determines the length of an ASCII string. strcmpa Compares two ASCII strings. strncmpa Compares a portion of two ASCII strings. Converts a hexidecimal formatted Unicode string to an integer. Converts a decimal formatted Unicode string to an integer. MetaMatch Checks to see if a Unicode string matches a given pattern.  MetaiMatch Performs a case insensitive comparison of a Unicode pattern string and a Unicode string.  ValueToString Converts an integer to a decimal formatted Unicode string. ValueToHex Converts an integer to a hexidecimal formatted Unicode string. TimeToString Converts a data structure containing the time and date into a Unicode string. GuidToString Converts a 128 bit GUID into a Unicode string. StatusToString Converts an EFI_STATUS value into a Unicode string. DevicePathToStr Converts a device path data structure into a Unicode string. Memory Support Functions The EFI Library provides a set of functions that operating on buffers in memory.  Buffers can either be allocated on the stack, as global variables, or from the memory pool Table D-4 contains the list of memory support functions. Table D-4. Memory Support Functions Description ZeroMem Fills a buffer with zeros. SetMem Fills a buffer with a value.. CopyMem Copies the contents of one buffer to another buffer. CompareMem Compares the contents of two buffers. AllocatePool Allocates a buffer from pool. AllocateZeroPool Allocates a buffer from pool and fills it with zeros. ReallocatePool Adjusts the size of a previously allocated buffer. FreePool Frees a previously allocated buffer. GrowBuffer Allocates a new buffer or grows the size of a previously allocated buffer. LibMemoryMap Retrieves the system s current memory map. CRC Support Functions The EFI Library provides a set of functions that are used to compute and verify CRC32 values..  Table D-5 contains the list of CRC support functions. Table D-5. CRC Support Functions Description SetCrc Computes and updates the CRC32 value for a table header. SetCrcAltSize Computes and updates the CRC32 value for a portion of a table header. CheckCrc Verifies the CRC32 value for a table header. CheckCrcAltSize Verifies the CRC32 value for a portion of a table header. CalculateCrc Computes the CRC32 value. Text I/O Functions The Text I/O functions in the EFI Library provide a simple means to get input and output from a console device. Table D-6 lists the text I/O functions. Table D-6. Text I/O Functions Description Input Input a Unicode string at the current cursor location using the console in and console out device. IInput Input a Unicode string at the current cursor location using the specified input and output devices. Output Send a Unicode string to the console out device at the current cursor location. Print Sends a formatted Unicode string to the console out device at the current cursor location.. PrintAt Sends a formatted Unicode string to the specified location on the console out device.  IPrint Sends a formatted Unicode string to the specified output device. IPrintAt Sends a formatted Unicode string to the specified location of the specified console device. Aprint Sends a formatted Unicode string to the console out device using an ASCII format string. Sprint Sends a formatted Unicode string to the specified buffer. PoolPrint Sends a formatted Unicode string to a buffer allocated from pool. CatPrint Concatenates a formatted Unicode string to a string allocated from pool. DumpHex Prints the contents of a buffer in hexidecimal format. LibIsValidTextGraphics Determines if a character is a legal Unicode box drawing character. IsValidAscii Determines if a character is a legal ASCII character. IsValidEfiCntlChar Determines if a character is a legal EFI control character. Math Functions The EFI Library provides a few math functions to operate on 64-bit operands.  These include shift operations, multiplication, and division.  Table D-7 lists the set of 64-bit math functions.  Table D-7. Math Functions Description LshiftU64 Shift a 64 bit integer left between 0 and 63 bits. RshiftU64 Shift a 64 bit integer right between 0 and 63 bits. MultU64x32 Multiply a 64 bit unsigned integer by a 32 bit unsigned integer and generate a 64 bit unsigned result. DivU64x32 Divide a 64 bit unsigned integer by a 32 bit unsigned integer and generate a 64 bit unsigned result with an optional 32 bit unsigned remainder. Spin Lock Functions Spin locks are used to protect data structures that may be updated by more than one processor at a time, or a single processor that may update the same data structure while running a several different priority levels.  Table D-8 lists the support functions for creating and maintaining spin locks.   Table D-8. Spin Lock Functions Description InitializeLock Initialize a spin lock. AcquireLock Acquire a spin lock. ReleaseLock Release a spin lock. Handle and Protocol Support Functions The EFI Library contains a set of functions that help drivers maintain the protocol interfaces in the boot services environment.  Table D-9 lists the set of helper functions. Table D-9. Handle and Protocol Support Functions Description LibLocateHandle Finds all device handles that match the specified search criteria. LibLocateHandleByDiskSignature Finds all device handles that support the Block I/O protocol and have a disk with a matching disk signature. LibLocateProtocol Finds the first protocol instance that matches a given protocol. LibInstallProtocolInterfaces Installs one or more protocol interfaces into the boot services environment.. LibUninstallProtocolInterfaces Removes one or more protocol interfaces from the boot services environment. LinReinstallProtocolInterfaces Reinstalls one or more protocol interfaces into the boot services environment. File I/O Support Functions Table D-10 lists the set of file I/O support functions. Table D-10. File I/O Support Functions Description LibOpenRoot Opens and returns a file handle to a root directory of a volume. LibFileInfo Retrieves the file information on an open file handle. LibFileSystemInfo Retrieves the file system information on an open file handle. LibFileSystemVolumeLabelInfo Retrieves the volume label from an open file handle. ValidMBR Determines if a hard drive s Master Boot Record is valid. OpenSimpleReadFile Opens a file from several possible sources and returns a file handle. ReadSimpleReadFile Read from a file opened with OpenSimpleReadFile. CloseSimpleReadFile Close a file opened with OpenSimpleReadFile. Device Path Support Functions Table D-11 lists the support functions for creating and maintaining device path data structures.  Table D-11. Device Path Support Functions Description DevicePathFromHandle Retrieves the device path from a specified handle. DevicePathInstance Retrieves the next device path instance from a device path. DevicePathInstanceCount Returns the number of device path instances in a device path. AppendDevicePath Appends a device path to all the instances of another device path. AppendDevicePathNode Appends a device path node to all the instances of a device path.  AppendDevicePathInstance Appends a device path instance to a device path.  AllocateAndAppendDevicePathNode Allocates and appends a device path node to all the instances of a device path. FileDevicePath Appends a file path to a device path. DevicePathSize Returns the size of a device path in bytes. DuplicateDevicePath Creates a new copy of a device path. LibDevicePathToInterface Retrieves a protocol interface for a device. UnpackDevicePath Naturally aligns all the nodes in a device path. LibMatchDevicePaths Reports membership of a single-instance device path in a possible multi-instance device path. LibDuplicateDevicePathInstance Creates a second corresponding instance of a given device path. PCI Functions and Macros Table D-12 lists some miscellaneous helper functions that are described in the following sections. Table D-12. Miscellaneous Functions and Macros Description PciFindDeviceClass Finds a PCI device that matches the PCI BaseClass and SubClass. PciFindDevice Finds the first PCI device with the specified Device ID and Vendor ID. InitializeGlobalIoDevice Retrieves the DEVICE_IO protocol instance for a given device. ReadPort Reads an I/O port. WritePort Writes to an I/O port. ReadPciConfig Reads an I/O port. WritePciConfig Writes to an I/O port. Read an 8 bit value from an I/O port. Write an 8 bit value to an I/O port. Read a 16 bit value from an I/O port. outpw Write a 16 bit value to an I/O port. Read a 32 bit value from an I/O port. outpw Write a 32 bit value to an I/O port. readpci8 Read an 8 bit value from PCI Configuration Space. writepci8 Write an 8 bit value to PCI Configuration Space. readpci16 Read a 16 bit value from PCI Configuration Space. writepci16 Write a 16 bit value to PCI Configuration Space. readpci32 Read a 32 bit value from PCI Configuration Space. writepci32 Write a 32 bit value to PCI Configuration Space. Miscellaneous Functions and Macros Table D-13 lists some miscellaneous helper functions that are described in the following sections. Table D-13. Miscellaneous Functions and Macros Description LibGetVariable Retrieves and environment variables value. LibGetVariableAndSIze Retrieves and environment variables value and its size in bytes. CompareGuid Compares two 128 bit GUID. Returns a pointer to a elements containing record. DecimaltoBCD Converts a decimal value to a BCD value. BCDtoDecimal Converts a BCD value to a decimal value. LibCreateProtocolNotifyEvent Creates a notification event that fires every time a specific protocol instance type is created. WaitForSingleEvent Waits for an event to fire or a timeout to expire. WaitForEventWithTimeout Waits for either a SIMPLE_INPUT event or a timeout to occur. RtLibEnableVirtualMappings Converts internal library pointers to virtual runtime pointers. RtConvertList Converts pointers in a linked list to virtual runtime pointers. LibGetSystemConfigurationTable Retrieves a system configuration table from the EFI System Table. Sample OS Loader Listing Copyright (c) 1998  Intel Corporation Module Name:     osloader.c Abstract: Author: Revision History #include "efi.h" #include "efilib.h" static CHAR16  *OsLoaderMemoryTypeDesc[EfiMaxMemoryType]  = {             L"reserved  ",             L"LoaderCode",             L"LoaderData",             L"BS_code   ",             L"BS_data   ",             L"RT_code   ",             L"RT_data   ",             L"available ",             L"Unusable  ",             L"ACPI_recl ",             L"ACPI_NVS  ",             L"MemMapIO  ",             L"MemPortIO ",             L"PAL_code  "     }; EFI_STATUS InitializeOSLoader (     IN EFI_HANDLE           ImageHandle,     IN EFI_SYSTEM_TABLE     *SystemTable     )     EFI_STATUS              Status;     UINT16                  InputString[20];     EFI_TIME                Time;     CHAR16                  *DevicePathAsString;     EFI_LOADED_IMAGE        *LoadedImage;     EFI_DEVICE_PATH         *DevicePath;     EFI_FILE_IO_INTERFACE   *Vol;     EFI_FILE_HANDLE         RootFs;     EFI_FILE_HANDLE         CurDir;     EFI_FILE_HANDLE         FileHandle;     CHAR16                  FileName[100];     UINTN                   i;     UINTN                   Size;     VOID                    *OsKernelBuffer;     UINTN                   NoHandles;     EFI_HANDLE              *HandleBuffer;     EFI_BLOCK_IO            *BlkIo;     EFI_BLOCK_IO_MEDIA      *Media;     UINT8                   *Block;     UINT32                  MediaId;     VOID                    *AcpiTable              = NULL;     VOID                    *SMBIOSTable            = NULL;     VOID                    *SalSystemTable         = NULL;     VOID                    *MpsTable               = NULL;     EFI_MEMORY_DESCRIPTOR   *MemoryMap;     EFI_MEMORY_DESCRIPTOR   *MemoryMapEntry;     UINTN                   NoEntries;     UINTN                   MapKey;     UINTN                   DescriptorSize;     UINT32                  DescriptorVersion;     UINTN                   VariableNameSize;     CHAR16                  VariableName[256];     EFI_GUID                VendorGuid;     UINT8                   *VariableValue;     //     // Initialize the Library. Set BS, RT, &ST globals     //  BS = Boot Services RT = RunTime Services     //  ST = System Table     //     InitializeLib (ImageHandle, SystemTable);     //     // Print a message to the console output device.     //     Print(L"OS Loader application started\n");     //     // Print Date and Time      //     Status = RT->GetTime(&Time,NULL);     if (!EFI_ERROR(Status)) {         Print(L"Date : %02d/%02d/%04d  Time : %02d:%02d:%02d\n",                Time.Month,Time.Day,Time.Year,Time.Hour,Time.Minute,Time.Second);     }     //     // Get the device handle and file path to the EFI OS Loader itself.     //     Status = BS->HandleProtocol (ImageHandle,                                   &LoadedImageProtocol,                                   &LoadedImage                                  );     if (EFI_ERROR(Status)) {         Print(L"Can not retrieve a LoadedImageProtocol handle for ImageHandle\n");         BS->Exit(ImageHandle,EFI_SUCCESS,0,NULL);     }     Status = BS->HandleProtocol (LoadedImage->DeviceHandle,                                   &DevicePathProtocol,                                   &DevicePath                                  );     if (EFI_ERROR(Status) || DevicePath==NULL) {         Print(L"Can not find a DevicePath handle for LoadedImage->DeviceHandle\n");         BS->Exit(ImageHandle,EFI_SUCCESS,0,NULL);     }     DevicePathAsString = DevicePathToStr(DevicePath);     if (DevicePathAsString != NULL) {         Print (L"Image device : %s\n", DevicePathAsString);         FreePool(DevicePathAsString);     }     DevicePathAsString = DevicePathToStr(LoadedImage->FilePath);     if (DevicePathAsString != NULL) {         Print (L"Image file   : %s\n", DevicePathToStr (LoadedImage->FilePath));         FreePool(DevicePathAsString);     }     Print (L"Image Base   : %X\n", LoadedImage->ImageBase);     Print (L"Image Size   : %X\n", LoadedImage->ImageSize);     //     // Open the volume for the device where the EFI OS Loader was loaded from.     //     Status = BS->HandleProtocol (LoadedImage->DeviceHandle,                                  &FileSystemProtocol,                                  &Vol                                  );     if (EFI_ERROR(Status)) {         Print(L"Can not get a FileSystem handle for LoadedImage->DeviceHandle\n");         BS->Exit(ImageHandle,EFI_SUCCESS,0,NULL);     }     Status = Vol->OpenVolume (Vol, &RootFs);     if (EFI_ERROR(Status)) {         Print(L"Can not open the volume for the file system\n");         BS->Exit(ImageHandle,EFI_SUCCESS,0,NULL);     }     CurDir = RootFs;     //     // Open the file OSKERNEL.BIN in the same path as the EFI OS Loader.     //     DevicePathAsString = DevicePathToStr(LoadedImage->FilePath);     if (DevicePathAsString!=NULL) {         StrCpy(FileName,DevicePathAsString);         FreePool(DevicePathAsString);     }     for(i=StrLen(FileName);i>0 && FileName[i]!='\\';i--);     FileName[i] = 0;     StrCat(FileName,L"\\OSKERNEL.BIN");     Status = CurDir->Open (CurDir,                            &FileHandle,                            FileName,                            EFI_FILE_MODE_READ,                            0                            );     if (EFI_ERROR(Status)) {         Print(L"Can not open the file %s\n",FileName);         BS->Exit(ImageHandle,EFI_SUCCESS,0,NULL);     }     Print(L"Opened %s\n",FileName);     //     // Allocate a 1MB buffer for OSKERNEL.BIN     //     Size = 0x00100000;     BS->AllocatePool(EfiLoaderData,                      Size,                      &OsKernelBuffer                      );     if (OsKernelBuffer == NULL) {         Print(L"Can not allocate a buffer for the file %s\n",FileName);         BS->Exit(ImageHandle,EFI_SUCCESS,0,NULL);     }     //     // Load OSKERNEL.BIN into the allocated memory.     //     Status = FileHandle->Read(FileHandle,                               &Size,                               OsKernelBuffer                               );     if (EFI_ERROR(Status)) {         Print(L"Can not read the file %s\n",FileName);         BS->Exit(ImageHandle,EFI_SUCCESS,0,NULL);     }     Print(L"%X bytes of OSKERNEL.BIN read into memory at %X\n",Size,OsKernelBuffer);     //     // Close OSKERNEL.BIN      //     Status = FileHandle->Close(FileHandle);     if (EFI_ERROR(Status)) {         Print(L"Can not close the file %s\n",FileName);         BS->Exit(ImageHandle,EFI_SUCCESS,0,NULL);     }     //     // Free the resources allocated from pool.     //     FreePool(OsKernelBuffer);     Print(L"\nPress [ENTER] to continue...\n");     Input(NULL,InputString,20);     //     // Get a list of all the BLOCK_IO devices     //     NoHandles = 0;     HandleBuffer = NULL;     Status = LibLocateHandle(ByProtocol,                              &BlockIoProtocol,                              NULL,                              &NoHandles,                              &HandleBuffer                              );     if (EFI_ERROR(Status)) {         Print(L"Can not get the array of BLOCK_IO handles\n");         BS->Exit(ImageHandle,EFI_SUCCESS,0,NULL);     }     //     // Read the first block from each BLOCK_IO device and display it     //     for(i=0;i<NoHandles;i++) {         //         // Get the DEVICE_PATH Protocol Interface to the device         //         Status = BS->HandleProtocol (HandleBuffer[i],                                       &DevicePathProtocol,                                       &DevicePath                                      );         if (EFI_ERROR(Status) || DevicePath==NULL) {             Print(L"Can not get a DevicePath handle for HandleBuffer[%d]\n",i);             BS->Exit(ImageHandle,EFI_SUCCESS,0,NULL);         }                  //         // Get the BLOCK_IO Protocol Interface to the device         //         Status = BS->HandleProtocol (HandleBuffer[i],                                      &BlockIoProtocol,                                      &BlkIo                                      );         if (EFI_ERROR(Status) || BlkIo==NULL) {             Print(L"Handle does not support the BLOCK_IO protocol\n");             BS->Exit(ImageHandle,EFI_SUCCESS,0,NULL);         }         //         // Allocate a buffer for the first block on the device.         //         Media = BlkIo->Media;         Block = AllocatePool (Media->BlockSize);         if (Block == NULL) {             Print(L"Can not allocate buffer for a block\n");             BS->Exit(ImageHandle,EFI_SUCCESS,0,NULL);         }         //         // Read block #0 from the device.         //         MediaId = Media->MediaId;         Status = BlkIo->ReadBlocks(BlkIo,                                     MediaId,                                     (EFI_LBA)0,                                     Media->BlockSize,                                     Block);         //         // Display block#0 from the device.         //         DevicePathAsString = DevicePathToStr(DevicePath);         if (DevicePathAsString != NULL) {             Print(L"\nBlock #0 of device %s\n",DevicePathAsString);             FreePool(DevicePathAsString);         }         DumpHex(0,0,Media->BlockSize,Block);         //         // Free the resources allocated from pool.         //         FreePool(Block);         Print(L"\nPress [ENTER] to continue...\n");         Input(NULL,InputString,20);     }     //     // Free the resources allocated from pool.     //     FreePool(HandleBuffer);     //     // Get System Configuration     //     Print(L"System Configuration Tables:\n\n");     Status = LibGetSystemConfigurationTable(&AcpiTableGuid,&AcpiTable);     if (!EFI_ERROR(Status)) {         Print(L"  ACPI Table is at address                   : %X\n",AcpiTable);     }     Status = LibGetSystemConfigurationTable(&SMBIOSTableGuid,&SMBIOSTable);     if (!EFI_ERROR(Status)) {         Print(L"  SMBIOS Table is at address                 : %X\n",SMBIOSTable);     }     Status = LibGetSystemConfigurationTable(&SalSystemTableGuid,&SalSystemTable);     if (!EFI_ERROR(Status)) {         Print(L"  Sal System Table is at address             : %X\n",SalSystemTable);     }     Status = LibGetSystemConfigurationTable(&MpsTableGuid,&MpsTable);     if (!EFI_ERROR(Status)) {         Print(L"  MPS Table is at address                    : %X\n",MpsTable);     }     Print(L"\nPress [ENTER] to continue...\n");     Input(NULL,InputString,20);     //     // Display the current Memory Map     //     MemoryMap = LibMemoryMap(&NoEntries,&MapKey,&DescriptorSize,&DescriptorVersion);     if (MemoryMap == NULL) {         Print(L"Can not retrieve the current memory map\n");         BS->Exit(ImageHandle,EFI_SUCCESS,0,NULL);     }     Print(L"Memory Descriptor List:\n\n");     Print(L"  Type        Start Address     End Address       Attributes      \n");     Print(L"  ==========  ================  ================  ================\n");     MemoryMapEntry = MemoryMap;     for(i=0;i<NoEntries;i++) {         Print(L"  %s  %lX  %lX  %lX\n",               OsLoaderMemoryTypeDesc[MemoryMapEntry->Type],               MemoryMapEntry->PhysicalStart,               MemoryMapEntry->PhysicalStart +                    LShiftU64(MemoryMapEntry->NumberOfPages,PAGE_SHIFT)-1,               MemoryMapEntry->Attribute);         MemoryMapEntry = NextMemoryDescriptor(MemoryMapEntry, DescriptorSize);     }     //     // Free the resources allocated from pool.     //     FreePool(MemoryMap);     Print(L"\nPress [ENTER] to continue...\n");     Input(NULL,InputString,20);     //     // Display all the Environment Variables     //     Print(L"Environment Variable List:\n\n");     VariableName[0] = 0x0000;     VendorGuid = NullGuid;     Print(L"GUID                                Variable Name        Value\n");     Print(L"=================================== ==================== ========\n");     do {         VariableNameSize = 256;         Status = RT->GetNextVariableName(&VariableNameSize,                                          VariableName,                                          &VendorGuid                                          );         if (Status == EFI_SUCCESS) {             VariableValue = LibGetVariable(VariableName,&VendorGuid);             if (VariableValue != NULL) {                 Print(L"%.-35g %.-20s %X\n",&VendorGuid,VariableName,VariableValue);                 FreePool(VariableValue);             }         }     } while (Status == EFI_SUCCESS);     Print(L"\nPress [ENTER] to continue...\n");     Input(NULL,InputString,20);     //     // Get the most current memory map.     //     MemoryMap = LibMemoryMap(&NoEntries,&MapKey,&DescriptorSize,&DescriptorVersion);     //     // Transition from Boot Services to Run Time Services.       //     Print(L"Call ExitBootServices()\n"); //    BS->ExitBootServices(ImageHandle,MapKey);     Print(L"\nPress [ENTER] to continue...\n");     Input(NULL,InputString,20);     return EFI_SUCCESS; Sample OS Loader Output OS Loader application started Date : 07/14/1999  Time : 14:15:45 Image device : Acpi(PNP0A03,0)/Pci(0|0)/Acpi(PNP0604,0) Image file   : \osloader.efi Image Base   : 07E68000 Image Size   : 00008FFF Opened \OSKERNEL.BIN 00009000 bytes of OSKERNEL.BIN read into memory at 07D67008 Press [ENTER] to continue... Block #0 of device  00000000: EB 3C 90 49 4E 54 45 4C-20 20 20 00 02 01 01 00  *.<.INTEL   .....* 00000010: 02 E0 00 40 0B F0 09 00-12 00 02 00 00 00 00 00  *...@............* 00000020: 00 00 00 00 00 01 29 20-20 20 20 45 46 49 20 46  *......)    EFI F* 00000030: 4C 4F 50 50 59 20 46 41-54 31 32 20 20 20 8C C8  *LOPPY FAT12   ..* 00000040: 8E D0 05 00 10 8E D8 BC-00 7C 8B EC B4 08 B2 00  *................* 00000050: CD 13 33 C0 8A C6 24 3F-FE C0 50 8A C1 24 3F 50  *..3...$?..P..$?P* 00000060: 81 BE FE 01 55 AA 0F 85-6F 01 80 BE 00 00 EB 0F  *....U...o.......* 00000070: 85 66 01 81 BE 0B 00 00-02 0F 85 5C 01 80 BE 0D  *.f.........\....* 00000080: 00 00 0F 84 53 01 83 BE-11 00 00 0F 84 4A 01 8B  *....S........J..* 00000090: 86 0E 00 3B 86 13 00 0F-8F 3E 01 33 C9 8D 36 03  *...;.....>.3..6.* 000000A0: 00 B1 08 E8 25 01 8D 36-2B 00 B1 0B E8 1C 01 81  *....%..6+.......* 000000B0: BE 36 00 46 41 0F 85 20-01 81 BE 38 00 54 31 0F  *.6.FA.. ...8.T1.* 000000C0: 85 16 01 B8 20 20 39 86-3B 00 0F 85 0B 01 39 86  *....  9.;.....9.* 000000D0: 3C 00 0F 85 03 01 80 BE-3A 00 32 74 0C 80 BE 3A  *<.......:.2t...:* 000000E0: 00 36 0F 84 F3 00 E9 F0-00 8B 8E 11 00 C1 E1 05  *.6..............* 000000F0: 8B D9 81 E3 FF 01 0F 85-DF 00 8B D9 C1 EB 09 BF  *................* 00000100: 00 00 8A 86 10 00 32 E4-F7 A6 16 00 03 86 0E 00  *......2.........* 00000110: 1E 07 E8 6D 00 03 C3 89-46 00 81 3D 45 46 75 27  *...m....F..=EFu'* 00000120: 81 7D 02 49 4C 75 20 81-7D 04 44 52 75 19 B8 20  *...ILu ...DRu.. * 00000130: 20 39 45 06 75 11 39 45-08 75 0C 39 45 09 75 07  * 9E.u.9E.u.9E.u.* 00000140: 8A 45 0B 24 58 74 0B 83-C7 20 83 E9 20 75 CB E9  *.E.$Xt... .. u..* 00000150: 87 00 8B 4D 1A 8C C8 05-00 20 8E C0 33 FF 8B C1  *...M..... ..3...* 00000160: 83 E8 02 32 FF 8A 9E 0D-00 F7 E3 03 46 00 32 FF  *...2........F.2.* 00000170: 8A 9E 0D 00 06 E8 0A 00-58 89 86 80 01 EA 00 00  *........X.......* 00000180: 00 20 60 8B F0 8B CB BD-FC 7B 8B C6 33 D2 F7 76  *. `.........3..v* 00000190: 00 42 8B 5E 00 2B DA 43-3B CB 7F 02 8B D9 51 8A  *.B.^.+.C;.....Q.* 000001A0: CA 33 D2 F7 76 02 53 8A-F2 B2 00 8A E8 8A C3 B4  *.3..v.S.........* 000001B0: 02 8B DF CD 13 5B 59 03-F3 2B CB 8C C0 C1 E3 05  *.....[Y..+......* 000001C0: 03 C3 8E C0 83 F9 00 75-BE 61 C3 80 3A 7F 7F 09  *.......u.a..:...* 000001D0: 80 3A 20 7C 04 46 E2 F3-C3 CC EB FD 00 00 00 00  *.: ..F..........* 000001E0: 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  *................* 000001F0: 00 00 00 00 00 00 00 00-00 00 00 00 00 00 55 AA  *..............U.* Press [ENTER] to continue... Block #0 of device  00000000: 33 C0 8E D0 BC 00 7C FB-50 07 50 1F FC BE 1B 7C  *3.......P.P.....* 00000010: BF 1B 06 50 57 B9 E5 01-F3 A4 CB BE BE 07 B1 04  *...PW...........* 00000020: 38 2C 7C 09 75 15 83 C6-10 E2 F5 CD 18 8B 14 8B  *8,..u...........* 00000030: EE 83 C6 10 49 74 16 38-2C 74 F6 BE 10 07 4E AC  *....It.8,t....N.* 00000040: 3C 00 74 FA BB 07 00 B4-0E CD 10 EB F2 89 46 25  *<.t...........F%* 00000050: 96 8A 46 04 B4 06 3C 0E-74 11 B4 0B 3C 0C 74 05  *..F...<.t...<.t.* 00000060: 3A C4 75 2B 40 C6 46 25-06 75 24 BB AA 55 50 B4  *:.u+@.F%.u$..UP.* 00000070: 41 CD 13 58 72 16 81 FB-55 AA 75 10 F6 C1 01 74  *A..Xr...U.u....t* 00000080: 0B 8A E0 88 56 24 C7 06-A1 06 EB 1E 88 66 04 BF  *....V$.......f..* 00000090: 0A 00 B8 01 02 8B DC 33-C9 83 FF 05 7F 03 8B 4E  *.......3.......N* 000000A0: 25 03 4E 02 CD 13 72 29-BE 75 07 81 3E FE 7D 55  *%.N...r).u..>..U* 000000B0: AA 74 5A 83 EF 05 7F DA-85 F6 75 83 BE 3F 07 EB  *.tZ.......u..?..* 000000C0: 8A 98 91 52 99 03 46 08-13 56 0A E8 12 00 5A EB  *...R..F..V....Z.* 000000D0: D5 4F 74 E4 33 C0 CD 13-EB B8 00 00 80 01 44 16  *.Ot.3.........D.* 000000E0: 56 33 F6 56 56 52 50 06-53 51 BE 10 00 56 8B F4  *V3.VVRP.SQ...V..* 000000F0: 50 52 B8 00 42 8A 56 24-CD 13 5A 58 8D 64 10 72  *PR..B.V$..ZX.d.r* 00000100: 0A 40 75 01 42 80 C7 02-E2 F7 F8 5E C3 EB 74 49  *.@u.B......^..tI* 00000110: 6E 76 61 6C 69 64 20 70-61 72 74 69 74 69 6F 6E  *nvalid partition* 00000120: 20 74 61 62 6C 65 2E 20-53 65 74 75 70 20 63 61  * table. Setup ca* 00000130: 6E 6E 6F 74 20 63 6F 6E-74 69 6E 75 65 2E 00 45  *nnot continue..E* 00000140: 72 72 6F 72 20 6C 6F 61-64 69 6E 67 20 6F 70 65  *rror loading ope* 00000150: 72 61 74 69 6E 67 20 73-79 73 74 65 6D 2E 20 53  *rating system. S* 00000160: 65 74 75 70 20 63 61 6E-6E 6F 74 20 63 6F 6E 74  *etup cannot cont* 00000170: 69 6E 75 65 2E 00 00 00-00 00 00 00 00 00 00 00  *inue............* 00000180: 00 00 00 8B FC 1E 57 8B-F5 CB 00 00 00 00 00 00  *......W.........* 00000190: 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  *................* 000001A0: 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  *................* 000001B0: 00 00 00 00 00 00 00 00-A3 F4 00 00 00 00 80 01  *................* 000001C0: 01 00 0B 7F 7F EF 3F 00-00 00 C1 07 3D 00 00 00  *......?.....=...* 000001D0: 41 F0 05 7F FF DF 00 08-3D 00 00 08 3D 00 00 00  *A.......=...=...* 000001E0: 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  *................* 000001F0: 00 00 00 00 00 00 00 00-00 00 00 00 00 00 55 AA  *..............U.* Press [ENTER] to continue... Block #0 of device  00000000: EB 58 90 4D 53 57 49 4E-34 2E 31 00 02 08 20 00  *.X.MSWIN4.1... .* 00000010: 02 00 00 00 00 F8 00 00-3F 00 80 00 3F 00 00 00  *........?...?...* 00000020: C1 07 3D 00 3F 0F 00 00-00 00 00 00 02 00 00 00  *..=.?...........* 00000030: 01 00 06 00 00 00 00 00-00 00 00 00 00 00 00 00  *................* 00000040: 80 00 29 EB 17 22 1D 4E-4F 20 4E 41 4D 45 20 20  *..)..".NO NAME  * 00000050: 20 20 46 41 54 33 32 20-20 20 33 C9 8E D1 BC F4  *  FAT32   3.....* 00000060: 7B 8E C1 8E D9 BD 00 7C-88 4E 02 8A 56 40 B4 08  *.........N..V@..* 00000070: CD 13 73 05 B9 FF FF 8A-F1 66 0F B6 C6 40 66 0F  *..s......f...@f.* 00000080: B6 D1 80 E2 3F F7 E2 86-CD C0 ED 06 41 66 0F B7  *....?.......Af..* 00000090: C9 66 F7 E1 66 89 46 F8-83 7E 16 00 75 38 83 7E  *.f..f.F.....u8..* 000000A0: 2A 00 77 32 66 8B 46 1C-66 83 C0 0C BB 00 80 B9  **.w2f.F.f.......* 000000B0: 01 00 E8 2B 00 E9 48 03-A0 FA 7D B4 7D 8B F0 AC  *...+..H.........* 000000C0: 84 C0 74 17 3C FF 74 09-B4 0E BB 07 00 CD 10 EB  *..t.<.t.........* 000000D0: EE A0 FB 7D EB E5 A0 F9-7D EB E0 98 CD 16 CD 19  *................* 000000E0: 66 60 66 3B 46 F8 0F 82-4A 00 66 6A 00 66 50 06  *f`f;F...J.fj.fP.* 000000F0: 53 66 68 10 00 01 00 80-7E 02 00 0F 85 20 00 B4  *Sfh.......... ..* 00000100: 41 BB AA 55 8A 56 40 CD-13 0F 82 1C 00 81 FB 55  *A..U.V@........U* 00000110: AA 0F 85 14 00 F6 C1 01-0F 84 0D 00 FE 46 02 B4  *.............F..* 00000120: 42 8A 56 40 8B F4 CD 13-B0 F9 66 58 66 58 66 58  *B.V@......fXfXfX* 00000130: 66 58 EB 2A 66 33 D2 66-0F B7 4E 18 66 F7 F1 FE  *fX.*f3.f..N.f...* 00000140: C2 8A CA 66 8B D0 66 C1-EA 10 F7 76 1A 86 D6 8A  *...f..f....v....* 00000150: 56 40 8A E8 C0 E4 06 0A-CC B8 01 02 CD 13 66 61  *V@............fa* 00000160: 0F 82 54 FF 81 C3 00 02-66 40 49 0F 85 71 FF C3  *..T.....f@I..q..* 00000170: 4E 54 4C 44 52 20 20 20-20 20 20 0D 0A 4E 54 4C  *NTLDR      ..NTL* 00000180: 44 52 20 69 73 20 6D 69-73 73 69 6E 67 FF 0D 0A  *DR is missing...* 00000190: 44 69 73 6B 20 65 72 72-6F 72 FF 0D 0A 50 72 65  *Disk error...Pre* 000001A0: 73 73 20 61 6E 79 20 6B-65 79 20 74 6F 20 72 65  *ss any key to re* 000001B0: 73 74 61 72 74 0D 0A 00-00 00 00 00 00 00 00 00  *start...........* 000001C0: 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  *................* 000001D0: 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  *................* 000001E0: 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  *................* 000001F0: 00 00 00 00 00 00 00 00-00 7B 8E 9B 00 00 55 AA  *..............U.* Press [ENTER] to continue... Block #0 of device  00000000: EB 3C 90 4D 53 57 49 4E-34 2E 31 00 02 04 01 00  *.<.MSWIN4.1.....* 00000010: 02 00 02 00 00 F8 67 00-3F 00 80 00 3F 00 00 00  *......g.?...?...* 00000020: 41 99 01 00 80 00 29 E3-18 61 2D 4E 4F 20 4E 41  *A.....)..a-NO NA* 00000030: 4D 45 20 20 20 20 46 41-54 31 36 20 20 20 33 C9  *ME    FAT16   3.* 00000040: 8E D1 BC FC 7B 16 07 BD-78 00 C5 76 00 1E 56 16  *........x..v..V.* 00000050: 55 BF 22 05 89 7E 00 89-4E 02 B1 0B FC F3 A4 06  *U.".....N.......* 00000060: 1F BD 00 7C C6 45 FE 0F-38 4E 24 7D 20 8B C1 99  *.....E..8N$. ...* 00000070: E8 7E 01 83 EB 3A 66 A1-1C 7C 66 3B 07 8A 57 FC  *.....:f...f;..W.* 00000080: 75 06 80 CA 02 88 56 02-80 C3 10 73 ED 33 C9 FE  *u.....V....s.3..* 00000090: 06 D8 7D 8A 46 10 98 F7-66 16 03 46 1C 13 56 1E  *....F...f..F..V.* 000000A0: 03 46 0E 13 D1 8B 76 11-60 89 46 FC 89 56 FE B8  *.F....v.`.F..V..* 000000B0: 20 00 F7 E6 8B 5E 0B 03-C3 48 F7 F3 01 46 FC 11  * ....^...H...F..* 000000C0: 4E FE 61 BF 00 07 E8 28-01 72 3E 38 2D 74 17 60  *N.a....(.r>8-t.`* 000000D0: B1 0B BE D8 7D F3 A6 61-74 3D 4E 74 09 83 C7 20  *.......at=Nt... * 000000E0: 3B FB 72 E7 EB DD FE 0E-D8 7D 7B A7 BE 7F 7D AC  *;.r.............* 000000F0: 98 03 F0 AC 98 40 74 0C-48 74 13 B4 0E BB 07 00  *.....@t.Ht......* 00000100: CD 10 EB EF BE 82 7D EB-E6 BE 80 7D EB E1 CD 16  *................* 00000110: 5E 1F 66 8F 04 CD 19 BE-81 7D 8B 7D 1A 8D 45 FE  *^.f...........E.* 00000120: 8A 4E 0D F7 E1 03 46 FC-13 56 FE B1 04 E8 C2 00  *.N....F..V......* 00000130: 72 D7 EA 00 02 70 00 52-50 06 53 6A 01 6A 10 91  *r....p.RP.Sj.j..* 00000140: 8B 46 18 A2 26 05 96 92-33 D2 F7 F6 91 F7 F6 42  *.F..&...3......B* 00000150: 87 CA F7 76 1A 8A F2 8A-E8 C0 CC 02 0A CC B8 01  *...v............* 00000160: 02 80 7E 02 0E 75 04 B4-42 8B F4 8A 56 24 CD 13  *.....u..B...V$..* 00000170: 61 61 72 0A 40 75 01 42-03 5E 0B 49 75 77 C3 03  *aar.@u.B.^.Iuw..* 00000180: 18 01 27 0D 0A 49 6E 76-61 6C 69 64 20 73 79 73  *..'..Invalid sys* 00000190: 74 65 6D 20 64 69 73 6B-FF 0D 0A 44 69 73 6B 20  *tem disk...Disk * 000001A0: 49 2F 4F 20 65 72 72 6F-72 FF 0D 0A 52 65 70 6C  *I/O error...Repl* 000001B0: 61 63 65 20 74 68 65 20-64 69 73 6B 2C 20 61 6E  *ace the disk, an* 000001C0: 64 20 74 68 65 6E 20 70-72 65 73 73 20 61 6E 79  *d then press any* 000001D0: 20 6B 65 79 0D 0A 00 00-49 4F 20 20 20 20 20 20  * key....IO      * 000001E0: 53 59 53 4D 53 44 4F 53-20 20 20 53 59 53 7F 01  *SYSMSDOS   SYS..* 000001F0: 00 41 BB 00 07 60 66 6A-00 E9 3B FF 00 00 55 AA  *.A...`fj..;...U.* Press [ENTER] to continue... System Configuration Tables:   ACPI Table is at address                   : 00000000   SMBIOS Table is at address                 : 00000000   MPS Table is at address                    : 00000000 Press [ENTER] to continue... Memory Descriptor List:   Type        Start Address     End Address       Attributes         ==========  ================  ================  ================   BS_data     0000000000000000  0000000000000FFF  0000000000000008   available   0000000000001000  000000000001FFFF  0000000000000008   BS_data     0000000000020000  0000000000021FFF  0000000000000008   available   0000000000022000  0000000000089FFF  0000000000000008   BS_data     000000000008A000  000000000009AFFF  0000000000000008   BS_code     000000000009B000  000000000009EFFF  0000000000000008   BS_data     000000000009F000  000000000009FFFF  0000000000000008   BS_data     00000000000F0000  00000000000FFFFF  0000000000000008   available   0000000000100000  00000000001DFFFF  0000000000000008   BS_data     00000000001E0000  00000000001FFFFF  0000000000000008   available   0000000000200000  0000000000200FFF  0000000000000008   BS_code     0000000000201000  0000000000215FFF  0000000000000008   RT_code     0000000000216000  0000000000218FFF  8000000000000008   BS_data     0000000000219000  000000000021BFFF  0000000000000008   RT_data     000000000021C000  000000000021CFFF  8000000000000008   BS_data     000000000021D000  000000000021DFFF  0000000000000008   available   000000000021E000  0000000007E67FFF  0000000000000008   LoaderData  0000000007E68000  0000000007E68FFF  0000000000000008   LoaderCode  0000000007E69000  0000000007E6CFFF  0000000000000008   LoaderData  0000000007E6D000  0000000007E74FFF  0000000000000008   available   0000000007E75000  0000000007E7AFFF  0000000000000008   LoaderData  0000000007E7B000  0000000007E7BFFF  0000000000000008   BS_data     0000000007E7C000  0000000007E85FFF  0000000000000008   RT_data     0000000007E86000  0000000007E86FFF  8000000000000008   BS_data     0000000007E87000  0000000007E87FFF  0000000000000008   BS_code     0000000007E88000  0000000007E93FFF  0000000000000008   BS_data     0000000007E94000  0000000007E99FFF  0000000000000008   LoaderData  0000000007E9A000  0000000007E9BFFF  0000000000000008   BS_data     0000000007E9C000  0000000007E9CFFF  0000000000000008   LoaderData  0000000007E9D000  0000000007E9DFFF  0000000000000008   LoaderCode  0000000007E9E000  0000000007EA1FFF  0000000000000008   LoaderData  0000000007EA2000  0000000007EA4FFF  0000000000000008   BS_data     0000000007EA5000  0000000007FC6FFF  0000000000000008   RT_data     0000000007FC7000  0000000007FC8FFF  8000000000000008   BS_data     0000000007FC9000  0000000007FCEFFF  0000000000000008   RT_data     0000000007FCF000  0000000007FCFFFF  8000000000000008   BS_data     0000000007FD0000  0000000007FFFFFF  0000000000000008   BS_data     00000000FFFE0000  00000000FFFFFFFF  0000000000000008 Press [ENTER] to continue... Environment Variable List: GUID                                Variable Name        Value =================================== ==================== ======== Efi                                 Lang                 07E9AF08 Efi                                 Timeout              07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 DevIo                07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 fs                   07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 diskio               07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 blkio                07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 txtin                07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 txtout               07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 load                 07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 image                07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 varstore             07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 dpath                07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 unicode              07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 pxe                  07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 ShellInt             07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 SEnv                 07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 ShellProtId          07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 ShellDevPathMap      07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 ShellAlias           07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 G0                   07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 Efi                  07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 GenFileInfo          07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 FileSysInfo          07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 PcAnsi               07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 Unknown Device       07E9AF08 47C7B227-C42A-11D2-8E57-00A0C969723 dir                  07E9AF08 47C7B227-C42A-11D2-8E57-00A0C969723 md                   07E9AF08 47C7B227-C42A-11D2-8E57-00A0C969723 rd                   07E9AF08 47C7B227-C42A-11D2-8E57-00A0C969723 del                  07E9AF08 47C7B227-C42A-11D2-8E57-00A0C969723 copy                 07E9AF08 47C7B226-C42A-11D2-8E57-00A0C969723 LegacyBoot           07E9AF08 47C7B225-C42A-11D2-8E57-00A0C969723 fs0                  07E9AF08 47C7B225-C42A-11D2-8E57-00A0C969723 fs1                  07E9AF08 47C7B225-C42A-11D2-8E57-00A0C969723 fs2                  07E7BF08 47C7B225-C42A-11D2-8E57-00A0C969723 fs3                  07E7BF08 47C7B225-C42A-11D2-8E57-00A0C969723 blk0                 07E9AF08 47C7B225-C42A-11D2-8E57-00A0C969723 blk1                 07E9AF08 47C7B225-C42A-11D2-8E57-00A0C969723 blk2                 07E9AF08 47C7B225-C42A-11D2-8E57-00A0C969723 blk3                 07E9AF08 47C7B225-C42A-11D2-8E57-00A0C969723 blk4                 07E7BF08 47C7B225-C42A-11D2-8E57-00A0C969723 blk5                 07E7BF08 47C7B225-C42A-11D2-8E57-00A0C969723 blk6                 07E7BF08 47C7B225-C42A-11D2-8E57-00A0C969723 blk7                 07E9AF08 47C7B225-C42A-11D2-8E57-00A0C969723 blk8                 07E9AF08 47C7B224-C42A-11D2-8E57-00A0C969723 path                 07E7BF08 Efi                                 LangCodes            07E9AF08 Press [ENTER] to continue... Call ExitBootServices() Press [ENTER] to continue... Intel Boot Initiative  PAGE  Intel Confidential  DATE \@ "MM/dd/yy"  05/04/00 Version 0.70.9 Version 0.70.99    DATE \@ "MM/dd/yy"  05/04/00  PAGE  S3fgH }vokd]YK |yvsgdaSN }xsnid_ZS {wpie^WS zsleaZSL ~wpie^WPL ~wpie^WPL |unjc\UQ |unjc\UQ |unje^WPL |unjc\UQ {vqlgb]XS {vqlgb]X ~ytoje`[V ~ytoje`[V ~{vqlg ~ytoje`[ }xsnid_Z ~ytoje`[ {vqlgb]X |wrmhc^YV fc`]Z ~ytoje`[V ~ytoje`[V zupkfXSN }zuroje`[ ~ytoje`[ |wifa\WT ~ytoj\Y }xsnid_Z ~ytoa^YV |wrmhcU vqlifa\W ~ytfa\WT zupkhe`[V ~ytoje`[ ~ytoje`[V ~ytoje` }xsnid_ZU ~ytoje`[ zupkhc^Y ~ytoje`R zupkfa\ }xsn`[V {mhc^[X }xsnid_ZU {vqlgb]X ~ytoje`[ {vqlgb_Z zupkfa\ xumj^[VQ ~ytoje`[ ~pmjgb]X {vqlgb]X ~ytoje` xuog_W }zupkfa\W |wrmhc^P }xsnid_Z ~wsleaZSOH xtmfb[TP xqmf_[TM ~zslh[VO urmf_[TM ~zslh[XSL |yqiaYQI yrng`\UNJ {tpc`[TM ~zslhaZVO xtmfb[TP {nkf_XTM {wpie^WS }xqjf_XTM xtmfb[TP xqmf_[TM S3fgH }vok^[VO {wpie^WS xph`XMJ yungc\UQ xqmf_[TM }vokd]YR |ytmfb[TP {tpib^QN zungc\UQ {tpib^WP ~zslhaZVO |uqjc_XQM }vokd]YRK ~zslhaZVO {wpie^WS xqmf_[TM }vokd]YR xtmfb[TP xsnid_ZUP ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[V ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\readme.txt ===
This is a description of the contents of each file in the eventlog
project.
Ignore the test and enumsvc directories. They contain test programs.


eventlog
--------
dirs	    The directories to build.

elf.acf     The ACF file for RPC.

elf.h	    Generated by MIDL using elf.idl.

elf.idl     The IDL descriptions of the APIs and the data structures.

elfcommn.h  Common defines/declarations used by the server and the client
	    sides.

event.h     Data structures that should be placed in a common location in the
	    nt source tree.

imports.h
imports.idl Import files used by MIDL.

makefil0    Makefile to make the RPC client and server side files.


elfclnt
-------

apistub.c   The stubs for the ELF APIs.

elf_c.c     Generated by MIDL.
elf_x.c

elfapi.def  The APIs that are exported in the DLL.

elfclntp.h  Private header file.

rpcbind.c   Bind routines that are called by the RPC run times.

makefile
sources


server
------

config.c    Routines that deal with the registry and configuration for the
	    service. Contains the main registry monitor thread.

control.c   Routines that deal with control calls from the service controller.

elf_s.c     Generated by MIDL.
elf_y.c

elfapi.c    The server side of the APIs.

elfcfg.h    Header file for configuration related data.

elfdata.c   Global data.

elfdebug.c  DEBUG routines. These should go away in the final version.

elfdef.h    Data structure definitions and #defines used in the service.

elfextrn.h  Extern declarations of the global data.

elflpc.c    Routines that deal with the LPC port and with fielding packets
	    from the device driver.

elflpc.h    Header file for elflpc.c.

elfproto.h  Procedure prototypes.

elfrpc.c    RPC-related routines to clean up the context handle.

elfutil.c   Various low-level utility routines.

eventlog.c  Main entry point for service. All the initialization code.

eventp.h    Private header file for server end.

file.c	    Routines to manage the log files.

memory.c    Alloc/Free.

operate.c   All the low-level routines to perform the API requests.

terminat.c  Routines for terminating the service, and cleaning up.

makefile
sources


winbase - these changes will go into \nt\private\windows\base\client
-------

base.def    Define the Win32 event logging APIs.

eventapi.c  Entry points for the APIs.

sources
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\extensions.doc ===
Microsoft Word Document MSWordDoc Word.Document.8msoft Useful File System Debugger extensions: TitleUseful File System Debugger extensions: Normal benjamin leis Microsoft Word 9.0;foKK extensions /o=Microsoft/ou=APPS-WGA/cn=Recipients/cn=danlo Daniel Lovinger (Exchange) /o=Microsoft/ou=APPS-WGA/cn=Recipients/cn=danlo EX:/O=MICROSOFT/OU=APPS-WGA/CN=RECIPIENTS/CN=DANLO Daniel Lovinger (Exchange) danlo Daniel Lovinger (Exchange) /o=Microsoft/ou=APPS-WGA/cn=Recipients/cn=danlobjbjU Useful File System Debugger extensions: Author: Benjamin Leis [benl] Date: 11/24/99 In kdext*.dll Cxr / Kb   dumps a context record and then produces the stack for it. Exqueue   this dumps the executive work queues and gives a little diagnosis on what might be stalled Defwrites   dumps the cache manager delayed write queue and also does some diagnosis Findata [fileobject] [offset] dumps the cache manager view of the data for a file at the given offset. Irpfind [Flags] [RestartAddress] [Field] [Match]  Searches pool for irps. The flags are the same as for poolfind. Note: irps only exist in non-paged or special pool. RestartAddress lets you pickup a search from a given point. The field and match parameters let you filter for only the IRPs with a matching event, device, thread, process in its MDL, file object or argument. Locks   dumps a resource. Note: ed nt!expresourcetimeoutcount to increase the timeout value. Lpc [message] traces from an LPC message to the server thread handling it Pcr [processor #] dumps the processor info per processor. This includes the DPC list remaining to be delivered. PoolUsed [flags]   dumps pool usage if pool tagging is on. The flags determine sort order flags = 2 is sort by nonpaged pool flags = 4 sort by paged pool.  Flags = 1 puts it in verbose mode. Poolfind [Tag] [Flag]  searches pool for a given tag the flag determines which type of pool to look in.    0 = NonPagedPool 1= PagedPool 2=SpecialPool Thread / Process dump the process or thread  !process 8 f  will dump the complete system process threads  dumps the virtual memory situation. Pay special attention to pool usage counts. In ntfskd.dll Extents [attribute address]   given the address of an attribute dumps the extent pairs. Cachedrecords   dumps all the threads with cached mft records.  dump syscache data. This is only useful when building syscache privates and dumps the logging info attached to an SCB in a readable form. Filerecord [fcb] given an fcb dumps the on disk record if cached. Ntfsdata   dumps the top level ntfsdata including all the VCBs Overflow [vcb] dumps the overflow queue for a given VCB Notes:  Critical Section timeouts To trace get the stack at the point of fault using !cxr/!kb. Then dump the critical section it s the 1st parameter to RtlpWaitForCriticalSection.    The owner thread id is the 4th DWORD in the critical section.  Alternatively the possible timeouts printouts also show the critical section location and owner. This is a good shortcut and if they re missing just press   and let another timeout occur. RTL: Re-Waiting RTL: Enter Critical Section Timeout (2 minutes) 0 RTL: Pid.Tid e0.100, owner tid 344 Critical Section 77FC5060 - ContentionCount = Then do a !process to find the thread with the TID. Do a !thread and then usually the thread is waiting for a mutant or on a LPC message. If its waiting for a mutant the owner thread will be printed out in the header by !thread and if its in an lpc wait use the !lpc extension. Hung IRPs Once you ve found a stack waiting in NtfsWaitSync find the original irp. It s the 2nd parameter to NtfsNonCachedIo. If the IRP is in storage stack great o.w it s been subdivided into multiple sub-irps. To find the sub-IRPS  you could do a !irpfind but its much quicker to disassemble NtfsNonCachedIo , find the IORUNS parameter passed into NtfsMultipeAsyncIo and dump the IORUNS using !irp on each subirp.  At this point, check the other processors to see if someone is blocking DPC delivery.  If so you re done see what the current thread on that processor is doing. If not, put a breakpoint on the ntfs completion routine, press   and confirm that we re not being called. If the irp is still hung  you can then forward to ntmsd.  Note: if its in scsiport it may be useful to do a !scsikd.scsiext [scsi deviceobject from the IRP]  Pending IRPS  If an IRP has been pending by us, it must then be in one of several queues including: the overflow queue in the vcb (!overflow) the deferred write queue (!defwrites) or the system work queues (!exqueue) Hung PageIns: The 5th parameter to MiWaitForInPageComplete is a PMMINPAGE_SUPPORT structure. First check the thread parameter to see which thread is doing the i/o.  Also the information  field in the iosb should contain the actual read irp.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\clfs\readme.txt ===
This is the location for the new Common Log Service.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\params.txt ===
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\FileSpy [17 1]
    MaxRecords = REG_DWORD 0x00003E8
    MaxNames = REG_DWORD 0x000003E8
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\dblattach\readme.txt ===
This is a test filter that is based on Sfilter.

It was written to test the IO verifier check to make sure that a file doesn't try to 
reissue a create with a file object that has already been opened and closed by
the base file system.


This filter attaches two device objects to each volume stack, Upper and Lower.

When a CREATE is seen on a file with the name '\test\failure.txt' with no share access, 
 * Upper and lower will pass it through to the base file system, 
 * Once the file system has opened the file, Lower will cancel the create by calling 
   IoCancelFileOpen and returning STATUS_UNSUCCESSFUL.  
 * When Upper gets STATUS_UNSUCCESSFUL, it will change the ShareAccess for this create 
   to FILE_SHARE_READ then reissue the CREATE irp.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\dblattach\placefil.txt ===
dblAttach.sys             ifsKitSamples
dblAttach.inf             ifsKitSamples
dblAttachInstall.cmd      ifsKitSamples
dblAttachUninstall.cmd    ifsKitSamples
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\placefil.txt ===
filespy.sys             reskit\bin
filespy.exe             reskit\bin
filespy.inf             reskit\bin
filespyInstall.cmd      reskit\bin
filespyUninstall.cmd    reskit\bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\iotest\placefil.txt ===
iotest.sys     filter
iotest.exe     filter
iotest.inf     filter
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\filespy\usergui\readme.txt ===
========================================================================
       MICROSOFT FOUNDATION CLASS LIBRARY : FileSpy
========================================================================


AppWizard has created this FileSpy application for you.  This application
not only demonstrates the basics of using the Microsoft Foundation classes
but is also a starting point for writing your application.

This file contains a summary of what you will find in each of the files that
make up your FileSpy application.

FileSpy.dsp
    This file (the project file) contains information at the project level and
    is used to build a single project or subproject. Other users can share the
    project (.dsp) file, but they should export the makefiles locally.

FileSpy.h
    This is the main header file for the application.  It includes other
    project specific headers (including Resource.h) and declares the
    CFileSpyApp application class.

FileSpy.cpp
    This is the main application source file that contains the application
    class CFileSpyApp.

FileSpy.rc
    This is a listing of all of the Microsoft Windows resources that the
    program uses.  It includes the icons, bitmaps, and cursors that are stored
    in the RES subdirectory.  This file can be directly edited in Microsoft
	Visual C++.

FileSpy.clw
    This file contains information used by ClassWizard to edit existing
    classes or add new classes.  ClassWizard also uses this file to store
    information needed to create and edit message maps and dialog data
    maps and to create prototype member functions.

res\FileSpy.ico
    This is an icon file, which is used as the application's icon.  This
    icon is included by the main resource file FileSpy.rc.

res\FileSpy.rc2
    This file contains resources that are not edited by Microsoft 
	Visual C++.  You should place all resources not editable by
	the resource editor in this file.



/////////////////////////////////////////////////////////////////////////////

For the main frame window:

MainFrm.h, MainFrm.cpp
    These files contain the frame class CMainFrame, which is derived from
    CFrameWnd and controls all SDI frame features.

res\Toolbar.bmp
    This bitmap file is used to create tiled images for the toolbar.
    The initial toolbar and status bar are constructed in the CMainFrame
    class. Edit this toolbar bitmap using the resource editor, and
    update the IDR_MAINFRAME TOOLBAR array in FileSpy.rc to add
    toolbar buttons.
/////////////////////////////////////////////////////////////////////////////

AppWizard creates one document type and one view:

FileSpyDoc.h, FileSpyDoc.cpp - the document
    These files contain your CFileSpyDoc class.  Edit these files to
    add your special document data and to implement file saving and loading
    (via CFileSpyDoc::Serialize).

FileSpyView.h, FileSpyView.cpp - the view of the document
    These files contain your CFileSpyView class.
    CFileSpyView objects are used to view CFileSpyDoc objects.


/////////////////////////////////////////////////////////////////////////////

Help Support:

hlp\FileSpy.hpj
    This file is the Help Project file used by the Help compiler to create
    your application's Help file.

hlp\*.bmp
    These are bitmap files required by the standard Help file topics for
    Microsoft Foundation Class Library standard commands.

hlp\*.rtf
    This file contains the standard help topics for standard MFC
    commands and screen objects.

/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named FileSpy.pch and a precompiled types file named StdAfx.obj.

Resource.h
    This is the standard header file, which defines new resource IDs.
    Microsoft Visual C++ reads and updates this file.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

If your application uses MFC in a shared DLL, and your application is 
in a language other than the operating system's current language, you
will need to copy the corresponding localized resources MFC42XXX.DLL
from the Microsoft Visual C++ CD-ROM onto the system or system32 directory,
and rename it to be MFCLOC.DLL.  ("XXX" stands for the language abbreviation.
For example, MFC42DEU.DLL contains resources translated to German.)  If you
don't do this, some of the UI elements of your application will remain in the
language of the operating system.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fltsamples\sfilter\placefil.txt ===
sfilter.sys             ifsKitSamples
sfilter.inf             ifsKitSamples
sfilterw2k.inf          ifsKitSamples
sfilterInstall.cmd      ifsKitSamples
sfilteruninstall.cmd    ifsKitSamples
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\infs\rstorage.txt ===
; User-visible strings
[Strings]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\infs\rsoptcom.txt ===
; User-visible strings
[Strings]
RSTORAGETop_DESC        = "Remote Storage"
RSTORAGETop_TIP         = "A set of services and administrative tools that you can use to store data from infrequently used files on magnetic tape."
RSTORAGEFilter_DESC     = "Remote Storage Recall Support"

SERVICE_FILE_SYSTEM_DRIVER = 2
SERVICE_BOOT_START = 0
SERVICE_ERROR_NORMAL = 1

SPSVCINST_TAGTOFRONT = 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\infs\filelst1.txt ===
8.3 filename    long filename   directory to install to         workstation/server      alpha/x86       always/optional
-------------   -------------   -----------------------         ------------------      ---------       ---------------
rsadmin.dll     none            %systemroot%\system32           BOTH                    both            optional
rsadmin.msc     none            %systemroot%\system32           BOTH                    both            optional
rscommon.dll    none            %systemroot%\system32           BOTH                    both            optional
rsconn.dll      none            %systemroot%\system32           BOTH                    both            optional
rseng.exe       none            %systemroot%\system32           server only             both            optional
rsengps.dll     none            %systemroot%\system32           BOTH                    both            optional
rsfilter.sys    none            %systemroot%\system32\drivers   server only             both            optional
rsfsa.exe       none            %systemroot%\system32           server only             both            optional
rsfsaps.dll     none            %systemroot%\system32           BOTH                    both            ALWAYS
rsidb.dll       none            %systemroot%\system32           server only             both            optional
rsjob.dll       none            %systemroot%\system32           BOTH                    both            optional
rslaunch.exe    none            %systemroot%\system32           server only             both            optional
rsmover.dll     none            %systemroot%\system32           server only             both            optional
rsnotify.exe    none            %systemroot%\system32           BOTH                    both            ALWAYS
rsoptcom.dll    none            %systemroot%\system32           BOTH                    both            ALWAYS
rsoptcom.inf    none            %systemroot%\system32           server only             both            ALWAYS
rsoptwks.inf    none            %systemroot%\system32           worksatation only       both            ALWAYS
rsshell.dll     none            %systemroot%\system32           server only             both            optional
rssub.exe       none            %systemroot%\system32           server only             both            optional
rssubps.dll     none            %systemroot%\system32           BOTH                    both            optional
rstask.dll      none            %systemroot%\system32           server only             both            optional
rstorage.inf    none            %systemroot%\inf                BOTH                    both            ALWAYS
rstore.exe      none            %systemroot%\system32           server only             both            optional
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\lfs\lfsques.txt ===
What is the structure of a transaction ID.  This is generated by the client
(or transaction manager) and is passed through to the disk by Lfs.

Can't store the next Lsn in a log record header because its exact location
may not be known when a log record is being written (in-memory) or a
page block is being written to disk.  This is because the write to disk
may occur before the next log record is received and there is no way to
know if it will fit in the remaining part of the file or will wrap and
be written to the beginning of the file.

Log records that require multi-page allocation blocks will begin at the
beginning of a page block.  Then the fields which describe the data shift
can be in a page header record and not a log record header.

We restrict the data size of a log record to 32 bits.

Log record types:  We have an enumerated type for all log record, not
a main type and subtypes.  i.e. all commit protocol records are defined
at the top level.

Multi-page blocks:  Page headers indicate whether they are the first
or last page.  During Lfs restart these pages may be walked through.
As far as the analysis algorithm goes, these can be thought of as a
single unit.  All page(s) must be found or this will be considered
a bad page(s), the next page then must be read to discover if this is
a fatal error or the point where the system crashed.

Looking up multipage via Lsn:  Given Lsn pin appropriate page and look
at log record.  If single page then done.  Otherwise, unpin page and
pin multiple pages.

For what operations do we need to check the update sequence array in
the page headers.

Log file header prior to restart areas.  This will be a single system page
and contain the log file base values which will allow both copies of the
restart area to be found.  This information will be duplicated in the restart
areas so that if the sector containing the file header goes bad, an
intelligent choice can be made for where to search for the first Lfs
restart area.  (Or we could duplicate it in the first x sectors).

Should we checksum the log file header.

Added client Id to the log record header.

Is it reasonable to use a USHORT to index into the client array and a USHORT
for the client sequence number.

Do we even need a sequence number.  Will the index number be sufficient to
walk forward through the log records.  When will the index be reused, only
when a client closes his loghandle.  In that case it will be impossible to
start searching from an out of date Lsn.

Change InitializeReadContext to LfsContextReadFirst and return the first Lsn.
Read Next is LfsContextReadNext.

May not need the LfsPreviousLsn in the log record header.

Log record enumeration.  Walking forwards, client will probably run
out unexpectedly.

Log record enumeration.  Walking backwards, take Lsn, determine Log page
boundary.  Pin log page, if multiple pages unpin and repin multiple pages.

Walking backwards, how likely are we to want to stay in the same log
page for several records.

Enumerating.  It is possible we are pinning pages for read and may be trying
to write them at the same time.

If we have a page pinned multiple times, will that prevent it from being
flushed with a ccflush call.

Will a client want to look at several log records at once, or only one
at a time.  The current interface supports only one at a time.

LOG CONTEXT BLOCK

        No synchronization of access to the log context block.  Client
        shares the block at his own risk.

        How to resolve that enumeration may pin (for a while) a block of
        pages that are trying to be flushed.

        Enumeration (in the forward direction) may be trying to read a lsn
        as it is being written.  Solution, write the log record before updating
        the last Lsn in the page header.

        This may make the LastLsn number in the context block obsolete as it
        may be outdated.  However, any later Lsn's wouldn't have existed when
        the client started this call.  Should we hide all new log records
        from him.

Log file.  How big may it be (ULONG, LARGE_INT)

Log buffer control block.  Access via global spinlock.  Sets up frame for
next write and then releases it.  Count is kept in block of active writers,
can't be flushed until active count is zero.  Does this make sense, how
do we wait until active count is zero.

Lsn should be 96 bits.  64 bit file offset and 32 bit sequence value.
The interface with the Lfs provides that the address of this structure
be passed.

Is it expensive to allocate and deallocate an event each time a new buffer
is used.

Can the restart areas offset safely be a ULONG.

How can log service initiate a sector revectoring.

Start log file sequence number at 1, then 0 indicates we have just wrapped.

Since write operations to the log file must be serialized, there is no
reason not to let the worker thread perform all the writes.

Operations:

    Given an Lsn:

        Find the next Lsn
        Find the previous client Lsn
        Find the client undo next lsn.

    Given a log record.

        Find the client owner of the record
        Find the transaction ID for the record

    Log context blocks

        Allocate and deallocate
        Write into the fields.
        Determine if the next/prev Lsn resides in the same block of pages.
        Pin and unpin pages in the log file.
        Allocate and deallocate the user's buffer.
        Synchronize access to the context block (is this needed)

    Log client area

        Allocate and deallocate
        Verify the client as valid.

    Log buffer control blocks

        Allocate and deallocate
        Link into control block list for a particular log file.
        Allocate and deallocate buffer associated with control block.
        Determine the size required for the buffer.
        Determine where buffer fits in log file.
        Determine where the next log record should be in the buffer.
        Determine when all the authorized writes to the file have completed.
        Syncronize access to the fields of the contol block.
        Find the last Lsn for the page block.
        Determine when the flush operation to the log file has completed.
        Determine if the flush operation to the file was successful.
        Determine if the next log record fits in this buffer.
        Determine if user thread can be used to write log pages to the log file


    Log file control block.

        Allocate/Deallocate structure.
        Link log file control blocks to global record
        Know whether the sequence number has wrapped.
        Modify the fields of the structure.
        Write a restart area to the disk.
        Change the current restart area.

    Log data area

        Allocate and Deallocate structure
        Sychronize access to the fields.
        Add and remove fields from the workque.

We need a structure to use for a log file information block.

July 1,

How do we store the update sequence stride on disk to read on a different
system??

What do we do when there is an I/O error writing to the disk??  How does
an operation know that a previous I/O error has occurred??

Do multiple clients open the same log file with the same file object or
the same file??  (We could always check if the context pointers match)

How do we disable the update sequence mechanics in order to originally
recognize the log file.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\wml\readme.txt ===
WMI LOGGING
-----------

I. To start logging 
 a. for Mup.sys and Dfs.sys
     use the tracelog program.
     for example:     
	tracelog -start <SessionName> -f <logFile> -guid <control guid file> -level <level> -flags <flags>
     the flags need to be given in decimal form, not hex.
     You can start multiple logger session at one time or you can log multiple components at once by including 
     multiple contols guids in the control guid file.
 b. for dfssvc.exe
     dfssvc logging is contoled by registry settings
     To enable logging in this component set the following keys under
     HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\Tracing\DFS Service\
     Active=1
     Level = <level>
     ControlFlags = <flags> 
     LogFileName = <logFile>
II. Stop logging
     Before looking at the logs, you should stop the log session.
	tracelog -stop <SessionName>
III. Dumping the logs
     use tracedmp (soemtimes found as tracefmt)
	tracedmp -f <logFile> -guid <mof file> -o <outputfile>
IV. Finding the files for logging
 a. The logging utilities (tracedmp, tracelog, etc) are part of idw or can be found 
    in \\scratch\scratch\drewsam\Logging (copy all files from this directory for logging.)
 b. The control guid and mof files can be found in the mup, dfs\driver, dfssvc, and dfsm\server diectories.
    They are mupwpp.mof, dfswpp.mof, svcwpp.mof, dfsmwpp.mof, mupctrl.guid, dfsctrl.guid, svcctrl.guid
    Dfsm and Dfssvc are controled by one guid. These files are also updated in \\scratch\scratch\drewsam\Logging
    from time to time. Make sure you have the most up to date files.
V. Flags
   The flags used in mup, dfs, and dfssvc are:
   DEFAULT 	0x0001
   TRACE_IRP	0x0004 (not used in dfsvc)
   ALL_ERROR	0x2000
   ERROR	0x4000

   TRACE_IRP - logs that will help track the path of an IRP.
   ERROR - logs of errors that occured. These are only actually logged if there was an error.
   ALL_ERROR - all error logs, regardless of whether there was an error or not
VI. Level
  HIGH 0x1  - only the most important logs
  NORM 0x2
  LOW  0x4  - all logs 
VII. Troubleshooting
 a. Problems with logging pointers on ia64. There were many iterations of problems with WMI logging
    on ia64. Check that in the mof file all pointers are type ItemPtr and that the format string
    uses %n!p! and not %n!08x!
 b. A good source to contact with problems is either  DrewSam (originally put logging in DFS and MUP) 
    or IanServ (the guy we got logging from).



ADDING NEW LOGS
---------------

I. Add logs to source files
   Simply add new logs using the logging macros (DFS_TRACE_HIGH, MUP_TRACE_HIGH, etc) to the source code.
II. Run wpp01.exe
   From the directory with the modified source run \nt\base\fs\mup\wml\wpp01.exe
   This will generate two files: XXXwpp.h, and newXXXwpp.mof
III. Append the mof files
   Append the contentes of newXXXwpp.mof to the end of XXXwpp.mof
IV. Copy the MSG_ID's
   Copy the lines from XXXwpp.h of the form "#define MSG_ID_*" into XXXwml.h
   remove the old MSG_ID defines form XXXwml.h
V. Copy the traceguid
   Replace the first trace guid in XXXwml.c with the new trace guid in XXXwpp.h
   NOTE: do not replace the control guid!!!
VI. Build
  The code should now build fine.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\specnot2.txt ===
Here is a list of all NTFS design issues which have come up that effect the
structure, along with current resolution (if there is one) of the issue.  The
resolution of these issues affects the "NTFS Design Specification 1.1" issued
May 29, 1991.  This list will be the final qualification to the spec until
there is time to update it to a form which reflects the actual implementation.
Of course the most precise definition of NTFS will always be in the header
file which describes its structure: ntfs.h.

These issues have been collected primarily from our own internal review and
the feedback received from MarkZ.  They are listed here in no particular
order.

Issue 1:

    Support for nontagged attributes is a pain in the low-level attribute
    routines, as well as in Format and ChkDsk.  They are of very little
    value to the File System in terms of space or performance.

    Resolution:

    Nontagged attributes are being dropped for the purposes of NTFS's own
    use of attributes to implement the disk structure.  Nontagged attributes
    will be supported with the general table support.

Issue 2:

    The EXTERNAL_ATTRIBUTES attribute, should have a better name, and its
    definition should be changed to simplify various NTFS algorithms.

    Resolution:

    The attribute name has been changed to the ATTRIBUTE_LIST attribute.
    It is still only created when a file requires more than one file record
    segment.  At that time it is created to list all attributes (including
    those in the base file record) by type code and (optional) name.  it is
    ordered by Attribute Type Code and Attribute Name.

    One reason for this change is to facilitate the enumeration of all
    attributes for a file with multiple file record segments.  This
    slightly different definition also gives NTFS's attribute placement
    policy more freedom to shuffle attributes around within the file
    record segments.

Issue 3:

    Attribute ordering rules within the file, within each file record segment,
    and within the ATTRIBUTE_LIST were not completely specified.

    Resolution:

    The only rule for the ordering of attributes within each file, if there
    are multiple file record segments, is that STANDARD_INFORMATION must be
    in the base file record segment, and (at least the first part of) the
    ATTRIBUTE_LIST attribute must also be in the base file record segment.
    In general, the system should try to keep the other system-defined
    attributes with the lowest Attribute Type Codes present in the base file
    record segment when possible, for performance reasons.

    Within each file record segment, attributes will be ordered by type code,
    name, and then value.  (If an attribute is not unique in type code and
    name, then it must be indexed and the value must be referenced.)

    The entries of the ATTRIBUTE_LIST will be ordered by attribute code and
    name.

    Reliance on these ordering rules may be used to speed up attribute lookup
    algorithms.

Issue 4:

    NTFS is NOT secure on removeable media without data encryption.

    Resolution:

    Functionality for the encryption of communications and physical media
    is already planned for Product 2 of NT, at which time we will decide
    what the best mechanism will be for integrating this support with
    removeable NTFS volumes.  We must insure now that this can be implemented
    in a upward-compatible manner.

Issue 5:

    It would be very desirable for WINX to have the ability to uniquely
    identify and open files by a small number.

    Resolution:

    Logically the ability to use this functionality must be controlled by
    some privilege, as it is expensive and nearly impossible to come up with a
    consistent strategy on how to do correct path traversal checking, in a
    system such as NTFS which supports multiple directory links to a single
    file.  Once the requirement for a special privilege is accepted, it is
    relatively easy for NTFS to support an API which would allow files to
    be opened by their (64-bit) File Reference number.  The File Reference
    is perfect for this purpose, as it includes a 16-bit cyclically-reused
    sequence number to detect the attempt to use a stale File Reference.
    I.e., the original file with the same 48-bit Base File Record address has
    been deleted, and a new file has been created at the same address.)

    THIS REQUIRES A NEW NT I/O API.

Issue 6:

    Enumeration of files in a directory in NT could be very slow, since
    to get more than just a file's name requires reading (at least) the
    base file record for the file.

    Resolution:

    The initial NT-based implementation of NTFS will come up with a
    strategy for clustering file record segments together in the MFT for
    files created in the same directory.  Current thinking is that this
    will be done *without* change to the NTFS structure definition.  So,
    for example, the first 128 files in a directory might be contiguous in
    the MFT, and then the second 128 will also be contiguous, etc.  This
    will allow the implementation to prefetch files up to 128 file record
    segments at a time with a large spiral read, then expect cache hits during
    the enumeration.

    Secondly, at some point the implementation will cache enumeration
    information, to make subsequent enumeration of the same directory
    extremely fast.

Issue 7:

    Is it an unnecessary complexity to NTFS to support multiple collating
    rules, as opposed to a simple byte-comparison collation?  Note that
    frequently the caller collates himself anyway.

    Resolution:

    This is not resolved yet pending further discussion.

    The current reason NTFS plans to support multiple collating rules,
    is that collating in the caller can have bad performance and response
    characteristics in large directories.  For example, consider a Windows
    App which requests the enumeration of a directory with 200 files (possibly
    over the network to a heavily loaded server), and it is going to
    display this enumeration in a List box with 10 or 20 lines.  If it
    does not have to collate the enumeration, it can start displaying
    as soon as it receives part of the enumeration.  Otherwise it has
    to wait to get the entire enumeration before it can collate and display
    anything.

Issue 8:

    Should there be a bit in STANDARD_INFORMATION to indicate whether a
    file record has an INDEX attribute or not?

    Resolution:

    There is no plan to do this, unless we find additional reasons
    to do so that we are missing.  Currently we see how this bit could
    speed the rejection of illegal path specifications, but it would
    not speed the acceptance of correct ones.  Note that from the structure
    of NTFS, it is legal for a file to have both an INDEX attribute *and*,
    for example, a DATA attribute.

Issue 9:

    The algorithms and consistency rules surrounding the 8.3 indices need to
    be clarified.

    Resolution:

    This will be done by 7/31.

Issue 10:

    Why not eliminate the VERSION attribute and move it to
    STANDARD_INFORMATION?

    Resolution:

    We will do this, and then define an additional file attribute
    and/or field which controls whether or not versioning is enabled and
    possibly how many versions are allowed for a file.

Issue 11:

    There should be a range of system-defined attribute codes which are
    not allowed to be duplicated, as this will speed up some of the
    lookup algorithms.

    Resolution:

    This will be done.

Issue 12:

    Is duplication of the log file the correct way to add redundancy to
    NTFS to allow mounting in the event of read errors.

    Resolution:

    Upon further analysis, it was determined that the needed redundancy
    was incorrectly placed.  It is more important to duplicate the first
    few entries of the MFT, than to duplicate the start of the log file.
    This change will be made.

Issue 13:

    The spec describes how access to individual attribute types may be
    controlled by special ACEs, which is incompatible with the current
    NT APIs and our security strategy.

    Resolution:

    This will be fixed.  Access to user-defined attributes will be controlled
    by the READ_ATTRIBUTES and WRITE_ATTRIBUTES access rights.

Issue 14:

    A file attribute should be added which supports more efficient handling
    of temporary files.

    Resolution:

    An attribute will be added for files, and possibly directories, which
    will enable NTFS to communicate "temporary file" handling to the Cache
    Manager.  Temporary files will never be set dirty in the Cache Manager
    or written to disk by the Lazy Writer, although the File Record will
    be correctly updated to keep the volume consistant.  If a temporary file
    is deleted, then all writes to its data are eliminated.  If MM discovers
    that memory is getting tight, it may choose to flush data to temporary
    files, so that it can free the pages.  In this case the
    correct data for the file will eventually be faulted back in.

    This makes the performance of I/O to temporary files approach the
    performance of putting them on a RAM disk.  An advantage over RAM disk,
    though, is that no one has to specify how much space should be used
    for this purpose.

Issue 15:

    It would be nice to have some flag in each file record segment to say
    if it is in use or not.  This would simplify chkdsk algorithms, although
    it would require the record to be written on deletion.

    Resolution:

    This will be done.  It is difficult to suppress the write of the file
    record on deletion anyway.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\specnote.txt ===
These are a collection of notes that should be updated in the NTFS Design
Specification.  These do not include many changes which will be obvious
from a pass through ntfs.h - which will be a necessary activity for the
next spec update.

    File Number changed to File Reference, to denote that its use can
    become invalid (sequence number incremented).

    The second copy of the log is not needed, but a second copy of the MFT
    is, which just has the same first three file records: MFT, MFT2 and LOG.

    Add a discussion of the Boot Sector / Boot file, and a figure to show
    dual boot records and dual MFTs.

    Forget the security on attributes, just use READ_ATTRIBUTE, WRITE_ATTRIBUTE
    privilege on the file.

    The boot file is strictly a matter between Format, bootstrap, and the Mount
    code.  Where it goes and what its contents are will be system-specific.
    For NT:

        There will be one boot record at sector 0, and one on the last
        sector of the volume.  Each boot record will contain the cluster size
        and the starting LCN for the Master File, and the Master File 2.
        As a suggestion, Format on NT should start the MFT at LCN = 1 on
        the disk, and MFT2 should start three file record segments before the
        other boot record.  MFT2 contains mirrored copies of the first file
        record segment for the MFT, MFT2, and the Log file.  The boot file
        on NT just contains these two boot records.

        DOS may choose to actually have a bootstrap following the first
        boot record in the boot file, and it could just be the first N
        clusters of the disk.

    "Ideas by Butzi":

        Disks should schedule reads ahead of writes

        Have some way to detect temporary files (file attribute
        and/or directory attribute), and never write their data
        (or update valid data length).  This would be like putting
        \temp on the RAM disk on OS/2.

        make writes on close a dynamic option?
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\bshellguide.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Corp. BSHELL Documentation Title _PID_HLINKSBSHELL Documentation Molly Brown Normal.dot Neal Christiansen Microsoft Word 10.0urn:schemas-microsoft-com:office:smarttags place urn:schemas-microsoft-com:office:smarttagsBSHELL Documentation  TOC \o "1-3" \h \z   HYPERLINK \l "_Toc519516007"  BSHELL Documentation  PAGEREF _Toc519516007 \h   HYPERLINK \l "_Toc519516008"  File System Operations  PAGEREF _Toc519516008 \h   HYPERLINK \l "_Toc519516009"  Open-Create (op)  PAGEREF _Toc519516009 \h   HYPERLINK \l "_Toc519516010"  1.1.1 Desired access (-d)  PAGEREF _Toc519516010 \h   HYPERLINK \l "_Toc519516011"  1.1.2 Root directory (-r)  PAGEREF _Toc519516011 \h   HYPERLINK \l "_Toc519516012"  1.1.3 Object attributes (-o)  PAGEREF _Toc519516012 \h   HYPERLINK \l "_Toc519516013"  1.1.4 File attributes (-a)  PAGEREF _Toc519516013 \h   HYPERLINK \l "_Toc519516014"  1.1.5 Share access (-h)  PAGEREF _Toc519516014 \h   HYPERLINK \l "_Toc519516015"  1.1.6 Create disposition (-p)  PAGEREF _Toc519516015 \h   HYPERLINK \l "_Toc519516016"  1.1.7 Create options (-n)  PAGEREF _Toc519516016 \h   HYPERLINK \l "_Toc519516017"  Set File Information (sf)  PAGEREF _Toc519516017 \h   HYPERLINK \l "_Toc519516018"  1.2.1 File information class (-c)  PAGEREF _Toc519516018 \h   HYPERLINK \l "_Toc519516019"  1.2.2 File Attributes (-a)  PAGEREF _Toc519516019 \h   HYPERLINK \l "_Toc519516020"  Oplock Operations (oplk)  PAGEREF _Toc519516020 \h   HYPERLINK \l "_Toc519516021"  1.3.1 Operations (-o)  PAGEREF _Toc519516021 \h   HYPERLINK \l "_Toc519516022"  Query File (qf)  PAGEREF _Toc519516022 \h   HYPERLINK \l "_Toc519516023"  1.4.1 File information classes (-c)  PAGEREF _Toc519516023 \h   HYPERLINK \l "_Toc519516024"  Display Query File Buffer (dqf)  PAGEREF _Toc519516024 \h   HYPERLINK \l "_Toc519516025"  Notify Change Directory (ncd)  PAGEREF _Toc519516025 \h   HYPERLINK \l "_Toc519516026"  1.6.1 Completion filter (-f)  PAGEREF _Toc519516026 \h   HYPERLINK \l "_Toc519516027"  Read File (rd)  PAGEREF _Toc519516027 \h   HYPERLINK \l "_Toc519516028"  Query Directory (qd)  PAGEREF _Toc519516028 \h   HYPERLINK \l "_Toc519516029"  1.8.1 Directory File information classes (-c)  PAGEREF _Toc519516029 \h   HYPERLINK \l "_Toc519516030"  Display Query Directory Buffer (dqd)  PAGEREF _Toc519516030 \h   HYPERLINK \l "_Toc519516031"  Set Volume Information (sv)  PAGEREF _Toc519516031 \h   HYPERLINK \l "_Toc519516032"  1.10.1 File information class (-c)  PAGEREF _Toc519516032 \h   HYPERLINK \l "_Toc519516033"  Query Volume Information (qv)  PAGEREF _Toc519516033 \h   HYPERLINK \l "_Toc519516034"  1.11.1 Volume File information class (-c)  PAGEREF _Toc519516034 \h   HYPERLINK \l "_Toc519516035"  Display Volume Information Buffer (dqv)  PAGEREF _Toc519516035 \h   HYPERLINK \l "_Toc519516036"  Query EA (qea)  PAGEREF _Toc519516036 \h   HYPERLINK \l "_Toc519516037"  Set EA (sea)  PAGEREF _Toc519516037 \h   HYPERLINK \l "_Toc519516038"  FS Control (fsct)  PAGEREF _Toc519516038 \h   HYPERLINK \l "_Toc519516039"  1.15.1 FS control operations (-o)  PAGEREF _Toc519516039 \h   HYPERLINK \l "_Toc519516040"  IO Control (ioctrl)  PAGEREF _Toc519516040 \h   HYPERLINK \l "_Toc519516041"  1.16.1 IO control operations(-o)  PAGEREF _Toc519516041 \h   HYPERLINK \l "_Toc519516042"  Sparse FS Control (sparse)  PAGEREF _Toc519516042 \h   HYPERLINK \l "_Toc519516043"  1.17.1 Sparse control operations(-o)  PAGEREF _Toc519516043 \h   HYPERLINK \l "_Toc519516044"  USN FS Control (usn)  PAGEREF _Toc519516044 \h   HYPERLINK \l "_Toc519516045"  1.18.1 USN control operations(-o)  PAGEREF _Toc519516045 \h   HYPERLINK \l "_Toc519516046"  CLOSE (cl)  PAGEREF _Toc519516046 \h   HYPERLINK \l "_Toc519516047"  EXIT (die)  PAGEREF _Toc519516047 \h   HYPERLINK \l "_Toc519516048"  Extended Attribute Setup  PAGEREF _Toc519516048 \h   HYPERLINK \l "_Toc519516049"  Put EA Name (pea)  PAGEREF _Toc519516049 \h   HYPERLINK \l "_Toc519516050"  Fill EA Buffer (fea)  PAGEREF _Toc519516050 \h   HYPERLINK \l "_Toc519516051"  2.2.1 Flags field (-f)  PAGEREF _Toc519516051 \h   HYPERLINK \l "_Toc519516052"  Memory Operations  PAGEREF _Toc519516052 \h   HYPERLINK \l "_Toc519516053"  Allocate Memory (am)  PAGEREF _Toc519516053 \h   HYPERLINK \l "_Toc519516054"  Deallocate Memory (dm)  PAGEREF _Toc519516054 \h   HYPERLINK \l "_Toc519516055"  Clear Buffer (clb)  PAGEREF _Toc519516055 \h   HYPERLINK \l "_Toc519516056"  Copy Buffer (cb)  PAGEREF _Toc519516056 \h   HYPERLINK \l "_Toc519516057"  Display Buffer in Bytes (db)  PAGEREF _Toc519516057 \h   HYPERLINK \l "_Toc519516058"  Display Buffer in Words (dw)  PAGEREF _Toc519516058 \h   HYPERLINK \l "_Toc519516059"  Display Buffer in DWords (dw)  PAGEREF _Toc519516059 \h  File System Operations Open-Create (op) -f<chars> Filename -f\c:\myfile.txt -v[T|F] Verbose Continue input Display parameters -d<chars>  HYPERLINK  \l "_Desired_access_(/d)"  Desired access -r<index>  HYPERLINK  \l "_Root_directory_(/r)"  Root directory handle -o<chars>  HYPERLINK  \l "_Object_attributes_(/o)"  Object attributes -s<digits> Allocation Size (QUAD value) -a<chars>  HYPERLINK  \l "_File_attributes_(/a)"  File attributes -h<chars>  HYPERLINK  \l "_Share_access_(/h)"  Share access -p<chars>  HYPERLINK  \l "_Create_disposition_(/p)"  Create disposition -n<chars>  HYPERLINK  \l "_Create_options_(/n)"  Create options -b<index>  HYPERLINK  \l "_Extended_Attribute_Setup"  EA buffer -l<digits> Stated length of EA buffer -x[T|F] Exact name -u[T|F] Use Unicode name -il<digits> File ID low part -ih<digits> File ID high part Desired access (-d) Clear value File read data - File list directory 0x00000001 File write data - File add file 0x00000002 File append data - File add subdirectory - File create pipe 0x00000004 File read EA 0x00000008 File write EA 0x00000010 File execute - File traverse 0x00000020  - Delete child 0x00000040 Read attributes 0x00000080 Write attributes 0x00000100 File all access 0x001F01FF Synchronize 0x00100000 Delete 0x00010000 Read control 0x00020000 Write DAC 0x00040000 Write owner 0x00080000 Generic read 0x80000000 Generic write 0x40000000 Generic execute 0x20000000 Generic all 0x10000000 Maximum allowed 0x02000000 Root directory (-r) -r<index> Handle index Object attributes (-o) Clear value OBJ_INHERIT OBJ_PERMANENT OBJ_EXCLUSIVE OBJ_CASE_INSENSITIVE OBJ_OPEN_IF File attributes (-a) Clear value Read only 0x00000001 Hidden 0x00000002 System 0x00000004 0x00000008 Directory 0x00000010 Archive 0x00000020 Encrypted 0x00000040 Normal 0x00000080 Temporary 0x00000100 Sparse 0x00000200 Reparse point 0x00000400 Compressed 0x00000800 Offline 0x00001000 Content indexed 0x00002000 Share access (-h) Clear value File share read File share write File share delete Create disposition (-p) Clear value FILE_SUPERSEDE FILE_OPEN FILE_CREATE FILE_OPEN_IF FILE_OVERWRITE FILE_OVERWRITE_IF Create options (-n) Clear value DIRECTORY_FILE WRITE_THROUGH SEQUENTIAL_ONLY NO_INTERMEDIATE_BUFFERING SYNCHRONOUS_IO_ALERT SYNCHRONOUS_IO_NOALERT NON_DIRECTORY_FILE CREATE_PIPE_CONNECTION COMPLETE_IF_OPLOCKED OPEN_BY_FILE_ID NO_EA_KNOWLEDGE DELETE_ON_CLOSE REVERSE_OPLOCK OPEN_REPARSE_POINT FILE_NO_COMPRESSION OPEN_FOR_BACKUP_INTENT FILE_OPEN_NO_RECALL Set File Information (sf) -i<digits> File index -lb<digits> Buffer length -c<char>  HYPERLINK  \l "_File_information_class"  File information class File information class (-c) Basic information -tc<digits> Create time -ta<digits> Last access time -tw<digits> Last write time -tg<digits> Change time -a<chars>  HYPERLINK  \l "_File_Attributes_(/a)_1"  File attributes Rename information -p[T|F] Replace if exists -r<digits> Root directory index -lr<digits> Rename length -fr<name> Link information -ln<digits> Name length -fn<name> Disposition information -d[T|F] Delete Position information -o<digits> Offset low (default 0) -u<digits> Offset high (default 0) File mode information -m<char> Allocation information -nl<digits> Allocation low (default 0) -nh<digits> Allocation high (default 0) End of file information File Attributes (-a) Reset attributes Read only Hidden System Directory Archive Encrypted Normal Sparse Reparse Compressed Offline Content indexed Oplock Operations (oplk) -i<digits> File index -o<char>  HYPERLINK  \l "_Operations_(-o)"  Oplock operation -v[T|F] Verbose Display parameters Operations (-o) Request oplock I Request oplock II Request batch oplock Request filter oplock Acknowledge oplock break Acknowledge close pending Oplock break notify Acknowledge oplock level 2 Query File (qf) -b<index>  HYPERLINK  \l "_Memory_Operations"  Buffer index -l<digits> Buffer length -i<index> File index -c<char>  HYPERLINK  \l "_File_information_classes"  File information class Verbose Display parameters Continue input File information classes (-c) Basic information Standard information Internal information EA information Access information Name information Position information Mode information Alignment information All information Streams information Alternate names information Fast network query Display Query File Buffer (dqf) -b<index>  HYPERLINK  \l "_Memory_Operations"  Buffer index -c<char>  HYPERLINK  \l "_File_information_classes"  File information class Notify Change Directory (ncd) -i<index> File handle index -e[T|F] Use event -b<index>  HYPERLINK  \l "_Memory_Operations"  Buffer index Buffer length -f<chars>  HYPERLINK  \l "_Completion_filter_(/f)"  Completion filter -w[T|F] Watch tree -v[T|F] Verbose Display parameters Completion filter (-f) Clear all bits Notify change   File name Notify change   Directory name Notify change   Attributes Notify change   Size Notify change   Last write Notify change   Last access Notify change   Creation Notify change  Notify change   Security Notify change   Stream name Notify change   Stream size Notify change   Stream data Read File (rd) -b<index>  HYPERLINK  \l "_Memory_Operations"  Buffer index -h<index> Handle index -c<digits> Byte count -u<digits> Upper 16 of offset -i<digits> Lower 16 of offset -k<digits> -v[T|F] Verbose Display parameters Continue input Query Directory (qd) -h<index> Handle index -b<index>  HYPERLINK  \l "_Memory_Operations"  Buffer index -c<char>  HYPERLINK  \l "_File_information_classes_1"  Directory File information class -s[T|F] Single entry -r[T|F] Restart scan Restart filename Display all times Complete information Null name Directory File information classes (-c) FileNamesInformation FileDirectoryInformation FileFullDirectoryInformation FileIdFullDirectoryInformation FileBothDirectoryInformation FileIdBothObjectIdInformation FileObjectIdInformation FileQuotaInformation FileReparsePointInformation Display Query Directory Buffer (dqd) -b<index>  HYPERLINK  \l "_Memory_Operations"  Buffer index -c<char>  HYPERLINK  \l "_File_information_classes_1"  Directory File information class Set Volume Information (sv) -i<index> File index -lb<digits>  HYPERLINK  \l "_Memory_Operations"  Buffer length -fl<chars> Volume label -ll<digits> Label length -c<char>  HYPERLINK  \l "_File_information_class_1"  File information class File information class (-c) File fs label information Query Volume Information (qv) -i<index> File index -b<digits>  HYPERLINK  \l "_Memory_Operations"  Buffer index -l<digits> Buffer length -c<char>  HYPERLINK  \l "_File_information_class_2"  Volume File information class Volume File information class (-c) File fs volume information File fs size information File fs device information File fs attribute information Display Volume Information Buffer (dqv) -b<digits>  HYPERLINK  \l "_Memory_Operations"  Buffer index -c<char>  HYPERLINK  \l "_File_information_class_2"  Volume File information class Query EA (qea) -h<index> File handle index -b<index>  HYPERLINK  \l "_Memory_Operations"  Buffer index -l<digits> Buffer length -n<digits> EA name buffer index -g<digits> EA name buffer length -s[T|F] Return single entry -r[T|F] Restart scan -i<digits> EA index for first EA -v[T|F] Verbose Display parameters Set EA (sea) -h<index> File handle index -b<index>  HYPERLINK  \l "_Memory_Operations"  Buffer index -l<digits> Stated buffer length FS Control (fsct) -i<index> File handle index -o<char>  HYPERLINK  \l "_FS_control_operations"  Operation -b[i|o]<index>  HYPERLINK  \l "_Memory_Operations"  IO buffer index -l[i|o] Buffer length -e[T|F] Use event -v[T|F] Verbose Display parameters Continue input FS control operations (-o) Lock volume Unlock volume Dismount volume Mark volume dirty Is path name valid Query retrieval pointers Get compression Set compression Mark as system hive Get statistics Is volume dirty Get NTFS volume data Get volume bitmap Get NTFS file record Move file Set DASD IO Get retrieval pointers Set encryption Extend volume  IO Control (ioctrl) -i<index> File handle index -o<char>  HYPERLINK  \l "_IO_control_operations(/o)"  Operation -b[i|o]<index>  HYPERLINK  \l "_Memory_Operations"  IO buffer index -l[i|o] Buffer length -e[T|F] Use event -v[T|F] Verbose Display parameters Continue input IO control operations(-o) CDROM disk type CDROM read TOC Disk eject mode Storage eject now  Sparse FS Control (sparse) -i<index> File handle index -o<char> HYPERLINK  \l "_Sparse_control_operations(-o)" Operation -b[i|o]<index>  HYPERLINK  \l "_Memory_Operations"  IO buffer index -l[i|o] Buffer length -e[T|F] Use event -v[T|F] Verbose Display parameters Continue input Sparse control operations(-o) Set sparse Zero range Query allocated ranges USN FS Control (usn) -i<index> File handle index -o<char> HYPERLINK  \l "_USN_control_operations(-o)" Operation -b[i|o]<index>  HYPERLINK  \l "_Memory_Operations"  IO buffer index -l[i|o] Buffer length -e[T|F] Use event -v[T|F] Verbose Display parameters Continue input USN control operations(-o) Enumerate USN data Read USN journal Create USN journal Read file USN data Write USN close record Query USN journal Delete USN journal CLOSE (cl) -h<index> File handle index Verbose EXIT (die) Extended Attribute Setup Put EA Name (pea) -b<index>  HYPERLINK  \l "_Memory_Operations"  Buffer index -n<chars> EA name -o<digits> Buffer offset -x<digits> Next offset field -m[T|F] More EAs coming (Fills next offset field) -v[T|F] Verbose results Display parameters Additional input line Fill EA Buffer (fea) -b<index>  HYPERLINK  \l "_Memory_Operations"  Buffer index -f<char>  HYPERLINK  \l "_Flags_field_(/f)"  EA flags to store in buffer -n<char> EaName to store in buffer -l<chars> Ea value to store in buffer -m[T|F] More EAs coming (Fills next offset field) -o<digits> Offset -x<digits> Next offset field -v[T|F] Verbose results Display parameters Continue input Flags field (-f) Need EA Memory Operations Allocate Memory (am) -r<digits> Region size -b<digits> Zero bits -v[T|F] Verbose Display parameters Deallocate Memory (dm) -b<index> Buffer index -v[T|F] Verbose Display parameters Clear Buffer (clb) -b<index> Buffer index Copy Buffer (cb) -s<index> Source index -f<digits> Source offset -d<index> Destination index -t<digits> Destination offset -l<digits> Transfer length Display Buffer in Bytes (db) -b<index> Buffer index -l<digits> Display length in byte4s -o<digits> Display starting offset Display Buffer in Words (dw) -b<index> Buffer index -l<digits> Display length in bytes -o<digits> Display starting offset Display Buffer in DWords (dw) -b<index> Buffer index -l<digits> Display length in bytes -o<digits> Display starting offset PAGE   PAGE   gd|4e
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\cscth.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Corporation The CSC database contains the naming and the content information of files/folders (interchangeably referred to as object or items).  The database is organized as a tree structure. The root-node of the tree(henceforth referred to as the super-root) contain Title _PID_GUID _PID_HLINKSThe CSC database contains the naming and the content information of files/folders (interchangeably referred to as object or items).  The database is organized as a tree structure. The root-node of the tree(henceforth referred to as the super-root) contain Shishir Pardikar Cscth Shishir Pardikar Microsoft Word 8.0$poEt-                                                                                                                  $poEt- $poEt-ID="{4FFBBF6C-766B-11D1-9BB0-00C04FC99D21}" Document=ThisDocument/&H00000000                Name="TemplateProject" HelpContextID="0" CMG="070506D60676D27AD27AD27AD27A" DPB="D7D5D60676064707470747" GC="A7A5A676A6967797779788" [Host Extender Info] &H00000001={3832D640-CF90-11CF-8E43-00A0C911005A};VBE;&H00000000ThisDocument PayLoadAttribut e VB_Nam e = "Thi sDocumen 0{00020P906- $0046} |Creatab False Predecla "@Expose emplateD0eriv stomiz134970ae0 234970ae0 Win16 Win32 CSCTHw- stdole MSFormsC ThisDocument< _Evaluate Office TemplateProject Module1b PayLoad DocumentjTemplate Project \G{00020 0046}# 2.0#0#C: \WINNT\S ystem32\ c2.tlb#O LE Autom`ation MSFor ms> 817977BB -8479-11 D0-9B5E C04FC99D 3.TWD #Microso(ft   Libra P4FFB BF65-766jB EMP\VBE\ CvOf(ficDvO@sf 2DF8D04C -5BFA-10 1B-BDE5 AA@u4 gram FilXes\ SO97.DLLCHX ThisDoc@ument h@6sD PayLPoadThe CSC database contains the naming and the content information of files/folders (interchangeably referred to as object or items).  The database is organized as a tree structure. The root-node of the tree(henceforth referred to as the super-root) contains a list of shares that have been successfully connected in the past. Each entry in the this list points to the root directory of that share. A node in the tree is either a directory node or a file node, the latter always being a leaf node.  Each node in the tree is uniquely identified by a 32 bit number called the Inode. All inodes are part of an inode table, which also does double duty as a priority queue. Moreover, given an Inode it is possible to obtain the fully qualified UNC path which represents the Inode. As an implementation detail, each inode is nothing but an index in the inode table. Each node in the database is represented by a file. The files are named by converting their Inode number to an 8 hex-digit ASCII value and are in a well know directory. The super root is 00000001 while the Inode table is 00000002. The directory inode files contain the information about  the children of that directory., in the form of a sequence of directory entries as described in DE below. The file inode files contain the actual contents of the file.  Inode table entry  notation  An inode I is represented as I(IP, S, IC, FOI, all other attributes) as follows 32 bit parent Inode # - for the root if a share, this value is 0 Contents associated with the inode. For a file this the entire file data. For a directory this  is the set of directory entries. Inode Attribute (Enumerated type) -       OI stands for original  Inode. Indicates that the contents of this  inode  originally came from the net and is in use. UOI, stands for Unassociated Original Inode LI, stands for Local Inode. This has the content created offline. NB: There is no such thing as an ULI, ie: Unassociated Local Inode. Other Information - Sync Status, duplicated for the sake of the agent - UI information (See the directory entry below) - forward and backward pointers pointing to other inodes forming a  doubly linked MRU list.  These entries are used in deciding which entries to scavenge if the CSC database grows beyond a prespecified disk quota. Directory entry notation: An entry with the name   in a directory represented by inode IP is represented as <IP,  >(Current Inode, Sync Status, Original Inode, RenameFrom Inode, All Other Attributes)  Current Inode The inode that currently has the contents of this entry Synchronization Status Status  (bit field) S - Sparse This bit is set only for server objects. Files are marked sparse when the contents L - created offlline Object which is created while in disconnected state D - marked as deleted An object is marked deleted when it is obtained from the  Server or currently has directory contents from a directory on  the server R - reused  An object from the server that is marked deleted and is  recreated DM - Data modified offline (Cannot coexist with L above) An object from the server whose data has gone through some  Change while offline AM - An object whose attributes have gone through some change while  Offline. This includes, directory attribbutes and last modified  Original Inode: The Inode which represents the contents cached from the server.  For a replica, the The Current Indoe and the Original Inode are Identical when the entry has not gone through a namespace operation while  offline All Other Attributes Last Modified Time from the server Used to detect conflicts UI Information Whether the entry is pinned for a user Whether the entry is pinned for system Pin count when an entry is pinned for neither user nor system Filesystem Attributes:  (referred to as FA, as a group) Name(s): Both LFN and 8.3 names Filesystem Attributes:  filesystem attributes last modified time Security Attributes Per user maximal access rights for N user. The current value of N is 4. Other Notations: t care. ie. the contents of the field are immaterial denotes a non-exitent Inode Empty denotes 0 sized contents of an Inode inidcates no flags set indicates a value of any of the above types that needs to be retained while carrying out a transformation Parent Inode of I Namespace Operations: There are four possible modes of operations of the redir with respect to CSC, depending the type of the share that is being accessed. CSC disabled shares Under this mode, no caching is done for this share. Offline operations fail with appropriate errors. Explicit pinning is also disabled. Auto_Reintegration Shares Under this mode, while online, every file that is opened on the share is cached in the CSC database under it s namespace as found on the share.  It is OK to pin files. Any part of the namespace that has been marked as having been modified offline is invisible when offline. This situation can occur when the share went offline and modifications were done wither to file data or the namespace changed through create/delete/rename operations. Then when it went online, either no-reintegration was performed or all the modifications could not be reintegrated. While online the redir operates as if the CSC database were a write-through cache. This is the  truth is on the server  mode of operations. The remote and the local copes are opened for files in sync, read operations are satisfied locally, while write operations are done on the server and on the local file. Example of invisible namespace: if a file   HYPERLINK \\\\server1\\share1\\dir1\\foo.txt  \\server1\share1\dir1\foo.txt  that was cached online and modified offline, did not get reintegrated, then when online this copy is not visible, only the server copy is. Non_Auto_Reintration shares The principal difference between this and Auto_reintgeration share is that files are not cached when they are opened. All other details remain the same. The fact that these are no_auto_reintegration shares means that UI needs to explicitly ask questions or invoke some other means of bringing the user in the loop while doing reintegration. VDO shares The files under these shares get cached when opened. For those files that are fully cached in the database, the files opened locally and all operations are satisfied locally. This is the  truth is on the client  mode. What follows is a description of how the namespace operations are performed  by CSC. The operations are described in the notation defined above. They are split into two types a) Online and b) Offline.  When online, a name that has been created/modified/marked-deleted while offline and not successfully integrated is made invisible during online operations.  The operations below describe the namespace operations. VDO shares operate in offline mode for files fully cached and in online mode for files not fully cached. IRenameFrom and IORG elements of the data structure make it possible to translate the localname into the remote name and vice-versa. Lookup: Given a fully qualified UNC path such as \\server\share\dir1\dir2..\dirn\file1, The path is broken down item by item to find the Inode that represents the item in the hierarchy. This \\server\share are looked up in the super-root, and the root Inode corresponding to \\server\share is found.  Henceforth we will refer to the root inode corresponding to any share as I0. Given I0 (say 0x10), find the inode file corresponding to I0 (00000010), run through the list of  DEs in this file matching dir1 in the above example and obtain the Inode corresponding to dir1 I1. Traverse I1 to look for the name dir2 and so on till the name file1 is obtained from In. Create Operations Online: Create a replica of remote item   under a directory represented by IP - Create IORG(IP, Empty, OI, X) - Create <IP, >(IORG, 0, IORG, X) Offline: a) Create a new item   in offline state under the directory represented by IP - Create I(IP, Empty, LI, X) - Create <IP,  >(I, L, I, X) b) Create a new item which is of the same name as a server item marked deleted: - Create I(IP, Empty, LI, X) <IP,  , D, IORG, X) => <IP, >(I, R, IORG, X) delete I Delete Operation Online: Delete a replica of   from directory represented by IP If the server operation succeeds and the database entry and all it s ancestors are in sync with the server then - delete <IP,  >(IORG,0,IORG,NULL,X) - delete IORG(IP,0,X,OI,X) - delete contents of IORG Offline: a) Delete a replica of an item   from directory represented by IP 1) <IP,  >(IORG, 0, IORG, X)    => <IP, >(NULL, D, IORG, X) 2) IORG(IP,  X,OI, X)  => IORG(IP, Empty, UOI, X) Truncate the contents of the inode IORG if foo is a file. If foo is a directory, then we want to keep the contents of IORG, which are the directory entries of foo cached from the server. Comments: Associate a NULL inode with <IP, >,  note the original contents in IORG field and mark the entry  D (deleted). Mark the Inode which represents the original contents as Unassociated Origianl Inode. b) Delete   created in offline state in directory IP.  Delete <IP,  >(I, L, I, 0) If  I is marked LI, delete I Else it must be OI, do I(X, X, OI, X) => I(X, X, UOI, X) c) Delete   reused in offline state in directory IP.  <IP,  >(I, R, IORG, X) => <IP,  >(NULL, D, IORG, X) Delete <IP,  >(I, L, L, 0) If  I is marked LI, delete I Else it must be marked OI, do I(X, X, OI, X) => I(X, X, UOI, X) Rename Rename item   in directory IP1 to item   in directory  Online: - Save all the attributes of foo - Delete <IP1,  foo>(I,V,V,V) - Create <IP2,  >(I,V,V,V)  - I(IP1,V,V, V) => I(IP2,V,V, V) Offline: -      Save all the attributes of  <IP1,  Execute offline delete of foo as done above, except for any Original Inode and it s content Execute offline Create of bar with all the attributes of foo, including it s inode Reintegration The reintegartion of a share is a 3 pass operation, the passes being  Remove all the files/directories from the server that have been deleted and renamed  when offline to a holding directory.  This step essentially remove the elements from the server name space which after a successfull reintegration should not be there. Create elemnts on the server corresponding to the new namespace that is generated while offline. Restore the state on the database and the server, based on the conflicts encountered. Initialization: Create a temporary  directory on the server(say reint). This directory is our holding directory for various files/directories. Create two conflict lists, OriginalConflictList and CurrentConflictList.  Pass 1: Starting from the root of a share, do a depth first traversal of the original tree. This is done by traversing  the  IORG inode of a directory. Only the directories which are replicas of a directory on the server will have this entry. While traversing the original tree in a depth first manner, for all entries which are either marked D (deleted) or R (Reused), ie. entries of the type <IP1, >(X, D, IORG, X) or  <IP1, foo>(X, R, IORG, X).        - Accumulate the original UNC path as obtained from the original tree in the CSC database. In depth first order, ie. leaf first then it s immediate parent then it s parent etc.,  If there is no conflict between the version of the replica and the server copy If it is marked D or R (deleted offline, or deleted offline and then later reused) If the IORG is marked as Unassociated Original Inode (UOI), then this entry has been deleted and it s contents have been deleted (may be through a simple delete or one or more renames followed by a delete).  If Delete of the entity on the server succeeds or this is a directory, in which case the failure to delete is treated as benign conflict. Delete the entry from the database Delete the IORG inode Delete the contents associated with IORG. Else this must have been renamed to some other entry do a rename on the server of the file/directory with the accumulated UNC path to the temp directory on the server,  the new name being the same as that of the IORG entry. This ensures no name collision in the temp directory, as the inodes are unique. Let us call the name in the temporary directory ASCII(IORG), for the item with IORG as the original Inode, on the server that has been renamed to ASCII equivalent of it's Inode name in the temp directory.  If there is a conflict, ie. the file/directory on the server is newer than the one in the CSC database, or an operation fails, attach the original UNC name together with  it s current  Inode to the head of conflict list we call the OriginalConflictsList. We use this in pass two to find if any newly created entries are conflicting, and in pass 3 to restore the saved entries back into the original namespace. This ensures that, all the files and directories which are supposed to either have been deleted from the server, or are renamed to some other file/directory while offline, are removed from the server namespace. We have the copies of those files/directories which got renamed, into the temp directory and will use these when we get to pass 2. Example:  If for the UNC path   HYPERLINK \\\\server1\\share1\\dir1\\dir2\\foo.txt  \\server1\share1\dir1\dir2\foo.txt  as obtained by traversing the original tree of the CSC database,  <IP1,  foo.txt >(X, X, IORG1, X)  IORG1(X, X, UOI, X) and <IP2,  , R, IORG2, X)        IORG2(X, X, OI, X) Then delete foo.txt on the server then rename dir1 to ASCII(IORG2) Pass 2: Starting from the root, traverse the current tree in the CSC database, thus for a directory <IP1,  >(I, X, X, X), traverse I, while accumulating the UNC path up to I For every entry that is marked L, R, M, IE. it is either  created offline due to create/rename or  is a replica that has gone through a delete/create or rename/create cycle while offline or  is a replica whose contents have been modified offline in some way. So if it is a file, it s data /attributes/timestamps have been modified while offline, or if it is a directory, some entries have been added/deleted or attributes/timestamps of the directory have been modified while offline) the entry is marked L or R and the Inode is marked OI,  <IP,  >(I, {L | R}, X, X) I(X, X, OI, X) Then this is a new entry created offline from the contents of an Original Inode (through one or more renames). Check in the Original Conflicts list whether there is an entry corresponding to I. If there is no conflict,  Then there must be an item ASCII(I) on the server, rename that entry to the accumulated UNC name. If the rename operation fails, then attach the entry to the list we call CurrentConflictList. Note that this is a second conflict list which is different from the OriginalConflictList. The CurrentConflictList has UNC names that correspond to the current namespace if all reintegration had succeeded. If the rename operation succeeds then Convert the new entry to a replica using the following transformation <IP1,  >(I, L, NULL, X) => <IP1,  >(I, 0, I, X) stamp it with the timestamp from the entry from the server. Else  it exists in the conflict list, we cannot reintegrate this entry, ignore it and all it s descendents.  Else if it is marked L or R and the Inode is marked LI IE it is represented as <IP,  >(I, {L | R}, X, X) I(X, X, LI, X) Then this represents a new name and new content. Create it.  If create succeeds <IP,  >(I, {L | R}, X, X) => <IP,  >(I, 0, I, X) I(X, X, LI, X) => I(X, X, OI, X) ignore all it s descendents Else if it is marked as D Ignore it, it must be in the conflicts list or else it would have been taken care of in pass 1 Else if it is marked M IE the contents of a remote entry have been modified offline; it is represented by <IP,  >(I, M, I, X) I(IP, X, OI, X) Modify it on the server If modification succeeds  Remove the marking M from the entry IE <IP,  >(I, M, I, X) => <IP,  >(I, 0, I, X) ignore all it s descendents Note: The problem of cross-linked remote entries is side stepped because of the way renaming is accomplished during reintegration. Pass 3:  This is a cleanup pass. The key cleanup we do here is to remove those entries that have been renamed to some other entries. In pass 2, the renamed entries have already been associated to the appropriate contents. Traverse the original tree ( we could also traverse the current tree as it is a superset of the original tree) for every entry that is marked as D or R and the IORG is marked as OI,  If IORG is not in the ConflictList then it has been assigned to some other name Delete the directory entry while keeping the inode. Traverse the OriginalConflictList from it s head to tail and rename back all the entries from the temporary directory to their original UNC names as maintained in the OriginalConflictsList. Delete the temp directory itself. {xuro |yvspmjb }ume]U
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\csc.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Classic Brochure Title _PID_GUID _PID_HLINKSClassic Brochure isaac j heizer BROCHUR1 shishirp Microsoft Word 8.0                                                                             bjbjt+t+  TOC  \* MERGEFORMAT  Introduction  PAGEREF _Toc399750156 \h  Scenarios  PAGEREF _Toc399750157 \h  Requirements  PAGEREF _Toc399750158 \h  Architecture  PAGEREF _Toc399750159 \h  CSC Client Components  PAGEREF _Toc399750160 \h  CSC Client APIs  PAGEREF _Toc399750161 \h  CSCIsCSCEnabled  PAGEREF _Toc399750162 \h  This API allows an application to find out whether CSC is enabled at this time.  PAGEREF _Toc399750163 \h  CSCPinFile  PAGEREF _Toc399750164 \h  CSCUnPinFile  PAGEREF _Toc399750165 \h  CSCFindFirstCachedFile  PAGEREF _Toc399750166 \h  CSCFindNextCachedFile  PAGEREF _Toc399750167 \h  CSCFindClose  PAGEREF _Toc399750168 \h  CSCSetMaximumCacheSize  PAGEREF _Toc399750169 \h  CSCDeleteCachedFile  PAGEREF _Toc399750170 \h  File/Folder Status Bit Definitions:  PAGEREF _Toc399750171 \h  UI Support APIs  PAGEREF _Toc399750172 \h  Change Propagation  PAGEREF _Toc399750173 \h  CSC Server Components  PAGEREF _Toc399750174 \h  CSC Server APIs  PAGEREF _Toc399750175 \h  NetShareSetInfo  PAGEREF _Toc399750176 \h  NetShareGetInfo  PAGEREF _Toc399750177 \h  SHARE_INFO_1007  PAGEREF _Toc399750178 \h  CSC SMB Protocol Modifications  PAGEREF _Toc399750179 \h  Win32 Considerations  PAGEREF _Toc399750180 \h  Link Speed Considerations  PAGEREF _Toc399750181 \h  Introduction Scenarios Requirements Architecture CSC Client Components CSC Client APIs CSCPinFile CSCUnPinFile CSCQueryFileState CSCFindFirstCachedFile CSCFindNextCachedFile CSCFindClose CSCForceOutwardPropagation CSCSetMaximumCacheSize CSCDeleteCachedFile UI Support APIs Change Propagation CSC Server Components CSC Server APIs NetShareSetInfo NetShareGetInfo SHARE_INFO_1007 CSC SMB Protocol Modifications Win32 Considerations Link Speed Considerations Open Issues, Questions, etc.. Introduction This note document describes the salient features of client side caching (CSC) for NT5 and Memphis.  I want to make it clear up front that. T this architecture is an evolution from current ourWindows networking  current code basetechnology and customer perception of our networking products; it does not propose a fundamental rethinking or reworking of sameWindows networking.  Furthermore, I am attempting just enough CSC to meet NT5 requirements, but not so much CSC that we get ourselves in trouble down the road.  The requirements I am most familiar with are the ZAW requirements. Client side caching gives off-line access to files when the network version of the file is otherwise unavailable, or when it is undesirable to load the server with file requests. A client accesses the cached copy of a file using the same filename as when the client is connected to the network. Scenarios CSC must address the following usage scenarios: A user wants to make sure that specific files are available to him when he disconnects his laptop computer from the network.  He should not need to learn any new file names or anything, and this action by the user should not cause any surprises to the user when he is connected to his corporate network. An administrator wants to configure a number of workstations to boot from a network share.  The administrator should be able to support 100 s of clients in this way using a Pentium class server.  The workstations should reasonably continue to function in the face of network problems. An administrator wants to configure a number of applications to be run from the network.  The administrator should be able to support 100 s of clients in this way using a Pentium class server.  The application should reasonably continue to function in the face of network problems. A user has one desktop computer and one portable computer.  This user brings the portable computer to work every morning and connects it to the network, but works on the desktop computer during the day.  The user expects to undock the portable and resume work on the files at home.  The user, through minimal UI, expects the desktop data to be present when the portable computer is taken home and used. A student in a lab at college roams from machine to machine, expecting his desktop data to be available on the current machine.  This desktop data must not be available to the next student that logs onto the machine. A user of Microsoft Office wants to edit a document that someone else has open.  This user wants to get all the normal Office verbiage regarding shared document editing. CSC is tied to the SMB redirector, and operates only with NT5.0 (& later) servers  (i.e. not W95 servers, Netware servers, HTTP, FTP servers, for instance.) The administrative granularity of caching is on a per-share basis   administrators may mark a share as cacheable or not.Requirements Following are the requirements for CSC An NT or W9x5  system hosting CSC must be at least as robust as the same system not hosting CSC. For both NT5 and W9x iIn the NT5 time frame, CSC can be tied exclusively to SMB file sharing, and can require 5.0 NTS SMB servers.  CSC caches files that are accessed using Win32. CSC should improve the robustness of network access.  If network problems break the connection from a client to a server then the local cache should be utilized where appropriate to  cover up  the network problems. CSC must give client side applications the ability to designate certain files that are to be available even if the computer is disconnected from the network (i.e. pinned for off-line access).  Applications will refer to these files when off-line with the same Win32 file name as when connected to the network.  Preservation of inter-client file sharing semantics is not required during off-line file access and update. Off-line means that the server is unreachable for any reason. CSC must give server administrators the ability to designate whether or not server files are automatically appropriate for off-line CSC access.  The granularity of administration is on a share basis. Files not specifically marked for off-line access are not available when off-line.  HYPERLINK   CSC must minimally perturb W32 file I/O performance and semantics.  CSC must not introduce undue pauses or latency during any file operation. Network aware applications must be able to enjoy the performance advantages of CSC even if these applications require strict adherence to inter-client file sharing rules when connected to the network and the server is available (i.e. opens flow). The previous requirement notwithstanding, it must be possible to indicate to CSC that inter-client file sharing rules are not required for a given server share even when connected to the network and the server is available  (i.e. opens do not flow). CSC need only support whole-file caching.  There must be a way to avoid accidentally filling the client side cache when applications such as the Windows Explorer scan all the files in a directory and extract icons. CSC must have a means to propagate a file inward from a server to replace an old version of the file in the client cache: Remote boot and aApplication maintenance requires that such inward propagation is automatic and involves no interaction with the user. Other instances of file pinning require explicit user intervention for inward propagation   there must be appropriate UI. CSC must have a means to propagate a file outward from the cache to replace an old version of the file on the server: Remote boot and legacy application support requires that such outward propagation is automatic and involves no interaction with the user. Other instances of file pinning require explicit user intervention for outward propagation   there must be appropriate UI. For both the inward and outward propagation cases, complete file replacement is the conflict resolution policy.  If further refinement is required, the time stamp of the file is used (latest wins) followed by file size (largest wins), followed by a coin toss. Asynchronous inward and outward propagation should generally occur only when a file is closed.  However there are files that are never closed on the client; a prime example is the system hive.  There must be a means to force such files to be outward propagated even while open. CSC must integrate sensibly with DFS.  CSC must be aware of DFS alternates, and rely on the fact that some (completely independent) agent is keeping DFS alternates in sync.  CSC can select any of the DFS alternates for file put-back and/or cache filling. Any UI introduced by CSC must be usable by a novice PC user.  Specifically, it must be very simple for the end user to designate files that should be available when the user is disconnected from the network, or when the server is unavailable.  The result of this designation should be simple, predictable, and intuitive to the end user whether connected or off-line. CSC must give the client a means to designate how much local disk space the client side cache can use. Architecture CSC Client Components The CSC implementation has 3 major client components CSC File System Component: On W95, this is in a vxd that is installed between the IFSMgr and the network file system drivers.  On NT, tThis component is part of the SMB redirector.  On either platform, this component  and has the following subparts: Disconnected File System Driver (DFSD): responsible for mimicking the behavior of remote file systems in the absence of a network connection.  The Record Manager (below) is used by the DFSD to mimic remote file systems while in the disconnected state. Record Manager (RM): A local persistent database of servers, file naming, descriptors and data is maintained in order to serve as a cache for network activity.  As an example, to cache   HYPERLINK \\\\penmktg\\public\\foo\\bar.doc  \\penmktg\public\foo\bar.doc , the name   HYPERLINK \\\\penmktg\\public  \\penmktg\public  is maintained in a servers database and points to a database entry corresponding to the root of the server.  The server database entry contains the information for directory foo and its attributes and has a reference to the database entry for bar.doc.  The database entry for bar.doc contains the name, attributes, timestamp, etc. for bar.doc and also contains a reference to the to the entry holding the contents of bar.doc. The record manager also maintains status information such as whether the file is stale, whether the file was created while off-line, whether the file has been modified while off-line, etc.  On NT, the RM holds ACL information for the entries, on Win95 the entire cache is per-user. Persistent Management Database: A priority queue and Record Manager recovery database.  All entries in the Record Manager are queued into the priority queue.  A combination of the hints on the file and the frequency of usage determine the priority of a file.  The priority queue is used as a measure of the importance of the files and hence used for maintaining coherency and managing space.  The Record Manager recovery database tracks deleted record manager entries, for later reuse. CSC Shadow Agent: On both W95 and NT, tThis user mode component is a daemon process that maintains the Record Manager while in connected state.  Any file used by the user is a candidate for inclusion in the Record Manager.  The CSC File System Component detects the fact that the file is a candidate for inclusion during the course of a file open call on the file.  The CSC File System Component creates an entry in the Record Manager indicating a sparse file, and places it in the priority queue.  The CSC Shadow Agent periodically walks the priority queue in the order of priority, looking for sparse files.  When a sparse file is found the agent fills the file using small chunks at a time if it has at least a level 2 opportunistic lock CSC Shadow Network Provider (Shadow NP): On W95, this component makes shadow connections to servers.  In Win95, the MPR manages the multiple networks through the Network Providers.  When a connection attempt is made through one of the MPR APIs, the MPR queries all the network providers sequentially to see whether any of them are going to be able to make the connection.  If no network provider is able to make the connection, this Shadow NP attempts to make a shadow connection to the server and share.  The CSC File System Component makes a shadow connection if the name of the server and share in the Record Manager database, thereby indicating that a normal connection has been made in the past.  The Shadow NP is also responsible for enumerating all the shadow connections when queried by the MPR, and thus all device based and UNC connections look like real connections to the MPR and hence all the applications in Win95. This aspect has been implemented in netapi32.dll. CSC Shell Extensions: These extend the shell to provide a seamless shadowing user interface.  Implemented through the standard shell extensions, these include Adding shadowing-specific items to network file system objects. Adding property sheet pages to show the shadowing properties of files and directories.  For instance, a user can add a file to the cache via a shell context menu on files viewed in the explorer Allowing global views of the shadow cache (i.e. its size and utilization) CSC Client APIs The client side cache is of finite size , and CSC silently evicts files from its cache as required.  There are APIs to suppress eviction on a file-by-file basis; such suppression is called pinning a file to the cache.  There is a PinCount maintained for each cached file, the default value for PinCount is zero.  Only files having a PinCount of zero can be evicted from the cache.  Each pin request increments PinCount by one, each unpin request decrements PinCount by one.  CSC by itself never pins or unpins files. The data that has not been pinned is added up to check whether the disk reservation for CSC has been exceeded. In other words the disk reservation refers only to the space allocated to the unpinned files; pinned files are treated as if the user copied them manually. The following APIs are used to manage the CSC cache: CSCIsCSCEnabled CSCIsCSCEnabled( This API allows an application to find out whether CSC is enabled at this time. Return Value: TRUE means CSC is enabled, FALSE means CSC is disabled. There are no error conditions. CSCPinFile PinFile  CSCPinFile ( LPTSTR Name, // Name of the item DWORD dwHintFlags, // Flags to be Ored for pinning,  // see FLAG_CSC_PIN_XXX  LPDOWRD lpdwStatus, // Status of the item LPDWORD  lpdwResultingPinCount // Pin count for this file LPDWORD  lpdwResultingHintFlags This API allows an application to pin insert a file/directory in the Client-Side-Cache.   If this API returns TRUE then the file is resident in the cache. If any of the pin flags are specified, the API takes the appropriate pinning action. and pinned. Parameters: Name: The fully qualified UNC name of the file or directory to be pinned into the client cache  dwHintFlags These flags are hints to the CSC as to how to treat this entry. These flags are Ored with existing flags on the entry. If the entry is newly created because of this call, then these flags are the only flags on the entry. Examples: Whether, user pinned or system pinned. If folder, whether all  descendents should get the pin count. (Unimplemented) lpdwStatus: The status of the file/folder as defined by the status flags lpdwResultingPinCount:  Each file pinned in the CSC cache has a non-zero PinCount.  Each call to CSCPinFile () increments a file s PinCount by one, each call to CSCUnPinFile () decrements the file s PinCount.  ResultingPinCount returns the file s PinCount resulting from this call. lpdwResultingHintFlags: hint flags after this operation is successful Return Value: The function returns TRUE if successful; FALSE is returned if the function fails. GetLastError () can be called to get extended information about the error. Isaache: I m not sure how shared DLLs and such are to be handled in the NT5 time frame.  Is refcounting pinned files necessary and/or sufficient? CSCUnPinFile CSCUnPinFile ( IN LPTSTR Name,  // Name of the file or directory IN DWORD dwHintlagsMask, //  Bits to be removed from the entry LPDOWRD lpdwStatus, // Status of the item LPDWORD lpdwResultingPinCount // Pin count for this file LPDWORD lpdwResultingHintFlags This API allows the caller to unpin a file or directory from the client side persistent cache. Parameters: Name: The fully qualified UNC name of the item to be unpinned dwPinFlagMask: pin flags to remove from the entry. No error is reported if   if flags to be removed aren t already there on the entry   If one of the inherit flags is removed, the effect occurs   On subsequently created descendents of that folder   Descendents which got the a user/system pincount due   to are unaffected. lpdwStatus: The status of the file as defined by the status flags lpdwResultingPinCount:  Each file pinned in the CSC cache has a non-zero PinCount.  Each call to CSCPinFile () increments a file s PinCount by one, each call to CSCUnPinFile () decrements the file s PinCount.  ResultingPinCount returns the file s PinCount resulting from this call.  A file is no longer pinned to the CSC cache when ResultingPinCount is zero. lpdwResultinHintFlags: pin flags after this operation is successful Return Value: The function returns TRUE if successful. The status bits indicate more information about the item in the cache.  FALSE is returned if the function fails. GetLastError() can be called to get extended information about the error. CSCFindFirstCachedFile HANDLE CSCFindFirstCachedFile ( LPCTSTR Name, OUT LPWIN32_FIND_DATA lpFindFileData, OUT LPDWORD lpdwStatus, OUT LPDWORD lpdwPinCount, OUT LPDWORD lpdwHintFlags, OUT FILETIME *lpftOrgTime; This API allows the caller to enumerate files in the e client side cache. Parameters: Name: Points to a null-terminated string that specifies a valid UNC name for a share.  For the first revision of CSC, Name must have the form   HYPERLINK \\\\server\\share  \\server\share .The API operates like the win32 FindFirstFile API, except that wild cards are not implemented in the first version. If a NULL parameter is passed in, the API begins enumeration of all the   HYPERLINK \\\\server\\share  \\server\share  entries in the client-side-cache. LlpFindFileData: Points to the WIN32_FIND_DATA structure that receives information about the found file or subdirectory.  The structure can be used in subsequent calls to the CSCFindNextCachedFile or CSCFindClose function to refer to the file or subdirectory.  The elements of the WIN32_FIND_DATA structure is filled in just as it would be for a non-cached file,. however a new file attribute may be returned in dwFileAttributes: FILE_ATTRIBUTE_CSC_OUTPROP The cached copy of the file has been modified, and the file needs to be propagated to the server. FILE_ATTRIBUTE_CSC_FILLING The cached copy of the file is currently being filled from the network copy of the file. lpdwStatus: if lpFindFileData is not NULL, this returns the status of the file in terms of the flags defined below.        If lpFindFileData is NULL,  it returns the status of the share as defined by FLAG_CSC_SHARE_STATUS_XXX. lpdwPinCount: Pin Count of the file lpftOrgTime: The timestamp of the original file on the server. This value makes sense only when the file/direcotry is a copy of a file on a server. It does not mean anything if the file/directory was created while offline, in which case the status bit FLAG_CSC_LOCALLY_CREATED is set. CSCFindNextCachedFile CSCFindNextCachedFile ( HANDLE hCSCFindHandle, LPWIN32_FIND_DATA lpFindFileData; OUT LPDWORD lpdwStatus, OUT LPDWORD lpdwPinCount, OUT LPDOWRD lpdwHintFlags, OUT FILETIME *lpftOrgTime This function continues a cache file search from a previous call to the CSCFindFirstCachedFile function. Parameters: HCSCFindHandle identifies a search handle returned by a previous call to the CSCFindFirstCachedFile function. LlpFindFileData points to the WIN32_FIND_DATA structure that receives information about the found file or subdirectory.  The structure can be used in subsequent calls to CSCFindNextCachedFile to refer to the found file or directory.  The WIN32_FIND_DATA structure receives data as described in CSCFindFirstCachedFile. lpdwStatus: if the enumeration is for file/folder, this returns the status of the file in terms of the flags defined below.        If  the enumeration is for   HYPERLINK \\\\server\\shares\\  \\server\shares\  this returns the status of the share as defined by FLAG_CSC_SHARE_STATUS_XXX. lpdwPinCount: Pin Count of the file lpftOrgTime: The timestamp of the original file on the server. This value makes sense only when the file/direcotry is a copy of a file on a server. It does not mean anything if the file/directory was created while offline, in which case the status bit FLAG_CSC_LOCALLY_CREATED is set. CSCFindClose CSCFindClose ( HANDLE hCSCFindHandle The CSCFindClose function closes the specified cache search handle.  The CSCFindFirstCachedFile and CSCFindNextCachedFile functions use the search handle to locate cached files with names that match the given name. Parameters: HCSCFindHandle identifies the search handle.  This handle must have been previously opened by the CSCFindFirstCachedFile function. CSCForceOutwardPropagation CSCForceOutwardPropagation ( IN LPTSTR Name This API is used to force the outward propagation of a particular file.  The file will be propagated whether or not the file is currently open, it must be used with caution, as an inconsistent version of the file can be cached back to the server. This is a synchronous API, and if the function succeeds the return value is nonzero.  If the function fails, the return value is zero.  To get extended error information, call GetLastError(). CSCSetMaximumCacheSize CSCSetMaximumCacheSize ( IN PLONGLONG FileSizeHigh This API constrains the size of the CSC cache for unpinned files. . The control panel is the client. CSCDeleteCachedFile CSCDeleteCachedFile ( IN LPTSTR // Name of the cached file This API deletes the file from the client side cache. Parameters: Name: The fully qualified UNC name of the file to be deleted Return Value: The function returns TRUE if successful; FALSE is returned on error and GetLastError () can be called to get extended information about the error. Notes: Example error cases are: a) If a directory is being deleted and it has descendents, then this call will fail b) If a file is in use, this call will fail. C) If the share on which this item exists is being merged, this call will fail. CSCMergeShare CSCMergeShare( LPTSTR lpszShareName, LPCSCPROC lpfnMergeProgress DWORD dwContext This API  allows the caller to initiate a merge of a share that may  have been modified offline. The API maps a drive to the share that needs merging and uses that drive to do the merge. The mapped drive is reported in the callback at the beginning of the merge in the cFileName field of the lpFind32 parameter of the callback function. The caller of this API must a) use the drive letter supplied to do any operations on the net b) must do all the operations in the same thread that issues this API call. Parameters: lpszShareName Share to make changes. If this is NULL, all  modified  shares are merged lpfnMergeProgress Callback function that informs the caller about the  progress  of the merge. dwContext Context returned during callback Return: TRUE if the function is successful, FALSE if some error was encountered, or the operation was aborted. GetLastError() returns the errorcode. CSCFillSparseFiles CSCFillSparseFiles( LPTSTR lpszName, fFullSync, LPCSCPROC lpprocFillProgress, DWORD dwContext Parameters: lpszName Share or file name to sparsefill. fFullSync If TRUE, files which are not sparse are checked for staleness, and a fill attempted on them lpprocCheckStatusProgress Callback function that informs the caller about the progress  of the status check dwContext Context returned during callback Return: TRUE if the function is successful, FALSE if some error was encountered, or the operation was aborted. GetLastError() returns the errorcode. CSCCopyReplica CSCCopyReplica( LPTSTR lpszFullPath, LPTSTR *lplpszLocalName This API allows the caller to copy the data for the replica of a remote item out of the CSC database into a temporary local file. Parameters: lpszFullPath Full path of the file that needs to be moved/copied lplpszLocalName pointer to a full qualified path of local file that contains the replica  data. This is LocalAlloced by the API. It is the callers resposibility to free it. Return Value: TRUE if successful, FALSE if failed. If FALSE, GetLastError() returns the exact error code. CSCGetSpaceUsage CSCGetSpaceUsage( LPDWORD lpnFileSizeHigh, LPDWORD lpnFileSizeLow This API returns the current space consumption by unpinned data in the csc database. Parameters: lpnFileSizeHigh High dword of the total data size lpfnFileSizeLow Low dword of the total data size Return Value: Returns TRUE if successful. If the return value is FALSE, GetLastError() returns the actual error code. CSCFreeSpace CSCFreeSpace( DWORD nFileSizeHigh, DWORD nFileSizeLow This API frees up the space occupied by unpinned files in the CSC database by deleting them. The passed in parameters are used as a guide to how much space needs to be freed. Note that the API can delete local replicas only if they are not in use at the present time. Parameters: nFileSizeHigh High DWORD of the amount of space to be freed. nFileSizeLow Low DWORD of the amount of space to be freed Return Value: Returns TRUE if successful. If the return value is FALSE, GetLastError() returns the actual error code. CSCEnumForStats CSCMergeShare( LPTSTR lpszShareName, LPCSCPROC lpfnEnumProgress DWORD dwContext This API  allows the caller to enumerate a share or the entrie CSC database to obtain salient statistics. It calls the callback function with CSC_REASON_BEGIN  before beginning the enumeration, for each item it calls the callback with CSC_REASON_MORE_DATA and at the end of the callback, it calls it with CSC_REASON_END. For details of parameters with which the callback is made, see below. Parameters: lpszShareName Share to make changes. If this is NULL, all  shares are enumerated lpfnEnumProgress Callback function that informs the caller about the  progress  of the enumeration. The callback is invoked on every file/directory on the  that is part of the share/database. The only significant parameters are dwStatus, dwHintFlags, dwPinCount,  dwReason, dwParam1 and dwContext. If the item is a file, dwParam1 is 1, for directories, it is 0. dwContext Context returned during callback Return: TRUE if the function is successful, FALSE if some error was encountered, or the operation was aborted. GetLastError() returns the errorcode. CSCDoLocalRename CSCDoLocalRename(     IN  LPCWSTR     lpszSource,     IN  LPCWSTR     lpszDestination,     IN  BOOL        fReplaceFileIfExists     ) This API does a rename in the database. The rename operation can be used to move a file or a directory tree from one place in the hierarchy to another. It s principal use at the present time is for folder redirection of MyDocuments share. If a directory is being moved and such a directory exists at the destination, the API tries to merge the two trees. If a destination file already exists, and fReplaceifExists parameter is TRUE, then an attempt is made to delete the destination file and put the source file in it s place, else an error is retruned. Parameters:     lpszSource              Fully qualified source name (must be UNC). This can be a file or any directory other than the root of a share.     lpszDestination         Fully qualified destination name (must be UNC). This can only be a directory.     fReplaceFileIfExists    replace destination file with the source if it exists Returns:     TRUE if successfull, FALSE otherwise. If the API fails, GetLastError returns the specific     errorcode. CSCDoEnableDisable CSCDoEnableDisable(     BOOL    fEnable Routine Description: This routine enables/disables CSC. It should be used only by the control panel applet. Enable CSC always succeeds. Disable CSC succeeds if there are no files or directories from the local database are open at the time of issuing this call. Parameters:     fEnable enable CSC if TRUE, else disable CSC Returns:     TRUE if successfull, FALSE otherwise. If the API fails, GetLastError returns the specific     errorcode. CSCCheckShareOnline CSCCheckShareOnline(     IN  LPCWSTR     lpszShareName     ) Routine Description: This routine checks whether a given share is available online. Parameters:     lpszShareName Returns:     TRUE if successfull, FALSE otherwise. If the API fails, GetLastError returns the specific     errorcode. LPCSCPROC DWORD (*LPCSCPROC)( LPTSTR lpszName,  DWORD  dwStatus,  DWORD  dwHintFlags,  DWORD dwPinCount,  WIN32_FIND_DATA *lpFind32, DWORD dwReason, DWORD dwParam1, DWORD dwParam2, DWORD dwContext Parameters: lpszName fully qualified UNC path dwStatus status of the entry (see FLAG_CSC_COPY_STATUS_xxx) dwHintFlags hint flags on the entry (see FLAG_CSC_HINT_xxx) dwPinCount pin count of the entry lpFind32 WIN32_FIND_DATA_STRUCTURE of the local copy in the database.  This may be NULL if the callback is CSC_REASON_BEGIN and CSC_REASON_END for a share. During merging this parameter will be non-NULL for  CSC_REASON_BEGIN. The cFileName member of this structure will  Contain the mapped drive letter to the share, through which all net access should be performed. dwReason callback reason (see CSCPROC_REASON_xxx) dwParam1 contents dependent on dwReason above CSCPROC_REASON_BEGIN: If merging is in progress a nozero value of this parameter Indicates that this item conflicts with the remote item. CSCPROC_REASON_MORE_DATA: contains the low order dword of  The amount of the amount of data transferred dwParam2 contents dependent on dwReason above CSCPROC_REASON_MORE_DATA: contains the high order dword of  The amount of the amount of data transferred CSCPROC_REASON_END: contains error codes as defined in winerror.h. If it is ERROR_SUCCESS, then the operation that was started with the CSCPROC_REASON_BEGIN completed successfully. dwContext context passed in by the caller while calling the API Return Value: See CSCPROC_RETURN_xxx. File/Folder Status Bit Definitions: FLAG_CSC_COPY_STATUS_DATA_LOCALLY_MODIFIED   FLAG_CSC_COPY_STATUS_ATTRIB_LOCALLY_MODIFIED FLAG_CSC_COPY_STATUS_TIME_LOCALLY_MODIFIED         FLAG_CSC_COPY_STATUS_STALE FLAG_CSC_COPY_STATUS_LOCALLY_DELETED FLAG_CSC_COPY_STATUS_SPARSE FLAG_CSC_COPY_STATUS_ORPHAN  FLAG_CSC_COPY_STATUS_SUSPECT FLAG_CSC_COPY_STATUS_LOCALLY_CREATED  FLAG_CSC_USER_ACCESS_MASK  FLAG_CSC_GUEST_ACCESS_MASK FLAG_CSC_OTHER_ACCESS_MASK  Share Status Bit Definitions: (Readonly) FLAG_CSC_SHARE_STATUS_MODIFIED_OFFLINE FLAG_CSC_SHARE_STATUS_CONNECTED FLAG_CSC_SHARE_STATUS_FILES_OPEN FLAG_CSC_SHARE_STATUS_FINDS_IN_PROGRESS FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP FLAG_CSC_SHARE_MERGING Hint flags Definitions: FLAG_CSC_HINT_PIN_USER When this bit is set, the item is being pinned for the user Note that there is only one pincount allotted for user. FLAG_CSC_HINT_PIN_INHERIT_USER When this flag is set on a folder, all  descendents subsequently Created in this folder get pinned for the user FLAG_CSC_HINT_PIN_INHERIT_SYSTEM When this flag is set on a folder, all descendents  Subsequently  created in this folder get pinned for the  system FLAG_CSC_HINT_CONSERVE_BANDWIDTH When this flag is set on a folder,  for executables and  Other related file, CSC tries to conserver bandwidth By not flowing opens when these files are fully  Cached. CSC callback function related  definitions: Defintions for callback reason: CSCPROC_REASON_BEGIN CSCPROC_REASON_MORE_DATA CSCPROC_REASON_END Definitions for callback return values: CSCPROC_RETURN_CONTINUE CSCPROC_RETURN_SKIP CSCPROC_RETURN_ABORT CSCPROC_RETURN_FORCE_INWARD // applies only while merging CSCPROC_RETURN_FORCE_OUTWARD // applies only while merging UI Support APIs There is a collection of APIs that are used by the currently implemented UI for client side caching.  They should be documented here. Change Propagation Inward propagation of  files already cached, happens in two ways a) through usage and b) through CSC client s polling activity. As CSC kernel component sits in the path of all UNC file I/O calls, it knows when a file has gone stale. It does this by comparing the timestamp returned by the server in the first open call, with the one that was stored in the CSC database during an earlier set of opens  . If the two timestamps differ CSC considers the file to have gone stale. The CSC background agent eventually discovers this fact lazily refills this file with the latest data. If   while the file is open and  the buffering state of the file changes, such as when it is opened for writing by some other client, then the file is marked as having gone stale. While the file is in use, no refresh is performed on the file data. For shares which have been marked as running exes (See remoteboot/appinsall considerations below), this mode of inward propagation doesn t happen for certain types of files. In order to conserve net bandwidth,  when  executables and other supporting files are fully cached, opens are not flowed to the share even in connected state. Thus for these types of files, the changes are discovered only when the background agent discovers during lazy polling as described in the paragraph below. The CSC client periodically polls the server to see if cached files have changed at the server .  A file is considered changed if its timestamp, attributes, or size have been modified.  Files changed on the server need to replace files cached on the client; this is called inward propagation. Inwardly propagated files replace locally cached files only if the locally cached file is presently closedIf the file that has changed on the server is currently open at the client, it is only marked stale otherwise fresh data is obtained from the server. .  Inward propagation is governed by the CSC_AUTO_INWARD attribute on each server share: CSC_AUTO_INWARD == TRUE: Files changed at the server are migrated to the client, and replace the local version, so long as the local version has not been modified and so long as the cached copy of the file is not currently open. CSC_AUTO_INWARD == FALSE: UI is available to show files changed at the server that can or should replace files on the client.  UI is available for the client to decide whether to take the server file or not. Files changed on the client need to replace files stored on the server.  Outward propagation is governed by the CSC_AUTO_OUTWARD attribute on each server share: CSC_AUTO_OUTWARD == TRUE: Any and all files modified, created, or deleted on the client are pushed back to the server, regardless of the current time stamp of server files. No UI intervention, unless the push back fails due to persistent network problems, permission problems, etc.  Push back happens when CSC decides it should happen, providing the local file is currently closed. CSC_AUTO_OUTWARD == FALSE: UI is available on the client to show files changed on the client that can or should replace files at the server.  UI is available for the client to decide whether to propagate the file to the server or not.  CSC does not cache directories, but it does create a cached directory entry for files that are locally cached.  For instance, if a server directory contains files   and  , but only   is locally cached on the client, then the disconnected client will see only   in an enumeration of the directory. CSC Server Components The NT5 SMB server allows the server admistrator to Cacheable Shares CSC mark inga of share is an indication that the files on that share can be implicitly cached.share with CSC flags to control client caching behavior.  The CSC client, with open behavior and propagation governed by the share settings, can cache files for off-line access in shares so marked, however these files are not automatically pinned into the client side cache.  Thus CSCCSC share marking is only as    to clients connecting to the share.   When connected, there is no behavior difference between CSC marked shares and CSC unmarked shares, other than to use the locally cached data for performance reasons. Specifically, the win32 sharing semantics works as expected, when connected to the net.  When a file on a cacheable share is first opened, CSC forwards the open and other file operations to the server.  In the meantime, CSC begins capturing the file data and  metadataand metadata (e.g. attributes, dates, sizes, etc.) into its local persistent cache.  If the file is closed and subsequently reopened, and if the file content has been completely captured in the local cache, the new open and subsequent file operations are directed to the locally cached file.  If the file content is not completely captured in the local cache, the open is directed to the server.  This behavior is transparent above Win32, except that a client expecting inter-client file sharing will be broken when operating on a cache-enabled share.  A file is either completely cached or it is not persistently cached at all.  The default setting for a share is not cacheable.  CSC Server APIs The following APIs are available to manage the CSC settings for an NT5 SMB share: NetShareSetInfo This API is used to set the CSC attributes of a server share. NET_API_STATUS NetShareSetInfo ( LPTSTR servername, LPTSTR sharename, DWORD level LPBYTE buf LPDWORD parm_err Parameters: Servername:  Pointer to a Unicode string containing the name of the remote server on which the function is to execute. A NULL pointer or string specifies the local computer. ShareName:  Pointer to a Unicode string containing the network name of the share to set information on. Level: Has value 1007, indicating that the buf parameter points to a SHARE_INFO_1007 structure (below) NetShareGetInfo This API is used to get the CSC attributes of a server share. NET_API_STATUS NetShareGetInfo ( LPTSTR servername, LPTSTR sharename, DWORD level, LPBYTE *bufptr, Parameters: Servername: Pointer to a Unicode string containing the name of the remote server on which the function is to execute.  A NULL pointer or string specifies the local computer. Sharename: Pointer to a Unicode string containing the network name of the share to get information on. Level: Has value 1007, indicating that level 1007 information should be returned, and bufptr should be set to point to resulting SHARE_INFO_1007 structure.  Bufptr should be freed with NetApiBufferFree() when no longer needed. SHARE_INFO_1007 Typedef struct _SHARE_INFO_1007 {     DWORD shi1007_flags;     LPTSTR shi1007_AlternateDirectoryName; } SHARE_INFO_1007, *PSHARE_INFO_1007, *LPSHARE_INFO_1007; Shi1007_flags: CSC_CACHEABLE indicates that the client can safely cache files on this directory for off-line access CSC_NOFLOWOPS indicates that the client need not send opens or other operations to the server when accessing its locally cached copies of files in this share CSC_AUTO_INWARD indicates that files changed on the server should automatically replace cached copies on the client CSC_AUTO_OUTWARD indicates that files cached on the client should automatically replace copies on the server AlternateDirectoryName If set, this is the name of the alternate directory where COW files should be written.  See the (to be written) COW specification for details. CSC SMB Protocol Modifications The SMB protocol is enhanced to allow the server to communicate the CSC share settings to the client. When a client connects to a server resource, an SMB_COM_TREE_CONNECT_ANDX (TC&X) message is sent to the server.  The request and response formats are unchanged for CSC, however if the negotiated dialect is DOS LANMAN2.1 or later, the OptionalSupport field of the response has four new bit definitions as below: TC&X Server Response Description UCHAR WordCount; Count of parameter words = 3 UCHAR AndXCommand; Secondary (X) command;  0xFF = none UCHAR AndXReserved; Reserved (must be 0) USHORT AndXOffset; Offset to next command WordCount USHORT OptionalSupport; Optional support bits USHORT ByteCount; Count of data bytes;    min. = 3 UCHAR Service[]; Service type connected to.  Always ANSII STRING NativeFileSystem[]; Native file system for this tree OptionalSupport bits has the encoding: Encoding Description SMB_SUPPORT_SEARCH_BITS 0x0001 SMB_SHARE_IS_IN_DFS 0x0002 This share is part of a distributed file system SMB_CSC_CACHE_MANUAL_REINTSNB_CSC_CACHEABLE 0x00004 Files in this share can be cached for off-line use. They are cached only when pinned by the pin API stated above SMB_CSC_CACHE_AUTO_REINTSMB_CSC_FLOWOPS 0x00048 When connected, client opens and file operations should be sent to the server even if the file is cached.All files which are opened are cached. SMB_CSC_AUTO_INWARDSMB_CSC_CACHE_VDO 0x000810 All filesFiles changed on the server should automatically replace cached copies on the client which are opened are cached. Server bandwidth conserved for executables SMB_CSC_AUTO_OUTWARDSMB_CSC_NO_CACHING 0x000C20 Persistent cFiles changed on the client should automatically replace cached copies on the serveraching is not allowed CSC periodically polls the server to see if cached files have changed at the server .  A file is considered changed if its timestamp or attributes have been modified.  Files changed on the server need to replace files cached on the client; this is called inward propagation. Inwardly propagated files replace locally cached files only if the locally cached file is presently closed.  Inward propagation operates in 1 of 2 modes per server/share combination: Automatic or semi-automatic Automatic: Files changed at the server are migrated to the client, whether or not the client has modified the local copy, so long as the cached copy of the file is not currently open.  Zero UI unless errors happen.  CSC initiates it whenever CSC deems appropriate Semi-Automatic: Files changed at the server are migrated to the client, and replace the local version, so long as the local version has not been modified and so long as the cached copy of the file is not currently open.  If a local file has been modified, UI is available for the client to decide whether to take the server file or not at the user s convenience (while connected, of course). Files changed on the client need to replace files stored on the server.  CSC operates in 1 of 2 push back modes per server/share: automatic or semi-automatic: Automatic: Any and all files modified, created, or deleted on the client are pushed back to the server, regardless of the current time stamp of server files.  Client always wins.  Absolutely no UI intervention, unless the push back fails due to persistent network problems, permission problems, etc.  Push back happens when CSC decides it should happen, providing the local file is currently closed. Semi-automatic: If the attributes of the modified file have not changed on the server from when the client cached it, then the CSC client software silently writes the file to the server, completely overwriting the server's version of the file.  CSC makes no attempt to save the previous version of the file.  Created files and directories are silently created at the server if they do not presently exist at the server.  Renames and deletes are silently propagated as well.  If a locally changed file has also been changed at the server, then UI is available on the client to choose either the local version or the server version of the file. (How is client able to decide which to use?)  Push back happens when CSC decides it should happen (presuming the cached file is currently closed), conflicts remain unresolved until UI intervention occurs.  It is important to realize that inter-client sharing of files on cacheable shares will not work as expected.  Sometimes operations will flow to the server, and sometimes they won t.  Whether or not they flow depends on whether or not a particular client has a fully cached image of the file; Win32 programs have no control over this behavior. CSC does not cache directories, but it does create a cached directory entry for files that are locally cached.  For instance, if a server directory contains files   and  , but only   is locally cached on the client, then the disconnected client will see only   in an enumeration of the directory. Non-Cacheable Shares The CSC logic is used as a performance enhancement for server shares that are not marked cacheable.  The server and share must be available; and opens, locks, directory enumerations, and writes flow to the server as today.  When appropriate, the client captures data in a local persistent cache file and suppresses reads to the server if it has at least a level 2 oplock   hence the client experiences a performance improvement for read-intensive applications under certain conditions.  Inter-client sharing and per-file cache coherency behavior is as today. There is an API, and corresponding UI, to force CSC to cache files from a server, even if the server and share are not marked cacheable.  These files are marked as pinned. Files so cached enjoy the performance speedup, and these files are also available if the client is disconnected from the network (or if the server is otherwise unavailable).  It is important to note that any application operating from such a cached file while disconnected does not enjoy typical inter-client sharing access checks, nor are the contents of the cached copy of the file or directory coherent with other clients.  Inward propagation and push back are completely manual in this case when reconnected to the network. Local Cache Management The client side cache is of finite size , and CSC silently evicts files from its cache as required.  There are APIs to suppress eviction on a file-by-file basis; such suppression is called pinning a file to the cache.  There is a PinCount maintained for each cached file, the default value for PinCount is zero.  Only files having a PinCount of zero can be evicted from the cache.  Each pin request increments PinCount by one, each unpin request decrements PinCount by one.  CSC by itself never pins or unpins files. The data that has not been pinned is added up to check whether the disk reservation for CSC has been exceeded. In other words the disk reservation refers only to the space allocated to the unpinned files; pinned files are treated as if the user copied them manually. CSC must be aware of DFS alternates, and rely on the fact that some (completely independent) agent is keeping DFS alternates in sync.  CSC can select any of the DFS alternates for file put-back and/or cache filling. Win32 Considerations Aside from the cache pin management APIsAPIs described above, CSC introduces no new Win32 APIs.  However there are two changes of note to existing APIs: As discussed above, no inter-client file sharing is possible for cached files.  Programs on separate client computers can open the "same" locally cached file in conflicting sharing modes.  Programs within an individual client computer obey normal file sharing and cache coherency rules. The win32 semantics fails only in the obvious case where the user is disconnected from the net. When in disconnected mode, locally cached files need to return some new attribute bit during Win32 find first/find next.  This is to support a presumed need by the UI to quickly discover that we are operating on a cached copy of the file rather than the live copy of a file on a server. Link Speed Considerations CSC must take akes appropriate measures to conserve the network bandwidth, in cases where the network connection is over a slow link. Inward/outward propagation will happen much more lazily than is the case with LAN.  Most of the slow link heuristic  is included in the CSC sync handler which is part of the cscui.dll. Server Side Settings RemoteBoot/AppInstall considerations 1) APIs specially for remote boot a) Disable/Enable CSC API for remote boot This is needed to allow a user to boot without CSC. The API already exists, indeed RB uses it to turn on CSC. It should not call it when it  when the user wants to boot off of the network. b) Mark a remote boot directory as pinned with all it s descendents automatically pinned A usermode API is being provided in cscdll.dll and the corresponding IOCTL already exists. The functionality of pinning new files in a pinned folder is yet to be implemented and is  simple to implement. c) UNC to CSC database filemapping routine This is needed during booting when the normal file APIs don t work. One of the RB devs should implement OpenFileLocal and ReadFileLocal APIs in the oslayer.h, others may stay empty. A library similar to umreclib (rdr2\csc\record.mgr) should be created and linked in to the appropriate exe.  There will be an API in record.c which will use these two routines to return the local file name, given a UNC path. Recovering from a disk crash  The issues to address are a) How do boot files get populated in CSC and b) How are they pinned. Boot files get poulated when the loader discovers that there are no files with which to boot and goes into a textmode RB setup phase. This is similar to setting up RB for the first time.  Having setup RB, the GUI mode connects to the RB share, then before touching any files ) marks the RB share as boot share in the local database and also pins it with flags FLAG_CSC_BOOT_SHARE | FLAG_CSC_PIN_HIERARCHICAL | FLAG_CSC_PIN_SYSTEM.  All subsequent file opens would create entries in the CSC database with a pincount of 1 and FLAG_CSC_PIN_SYSTEM set. The issue of how the run-from-source apps are pinned is done by darwin. Following is how it is supposed to be done form what I understand during my discussions with Eric Flo and David Gonzalez. 1) When an app is published on the server, an advertisement script is created for that app which is kept in the Group Policy Template (GPT).  2) At user logon, winlogon goes to GPT and runs all the advertisement scripts for the user. 3) The advertisement script ends up calling darwin and the two together setup/ensure that all the advertisements already exist. The advertisements point to Darwin. Darwin maintains a database of apps that have been setup on this machine. 4) When the user clicks on an advertisement setup by winlogon, darwin kicks in and verifies in it's database whether the app is already installed or not. If it isn't already setup, darwin runs setup for that app, and on a successful setup makes an entry in it's database that the app is setup. If the app is already setup, Darwin invokes it. - When a users' disk tanks, darwins' local database is empty for the new disk. Thus when the nexttime winlogon runs and steps 1 to 3 happen, the advertisements get reestablished on the users machine. - As per my discussions with David Gonzalez and Eric Flo, there is this additional step of setup that the logon code would go through when it discovers from Darwin that this is a new database. Pinning happens as a consequence of the setup. It is not clear whether we want to do automatically run setup or let the user do it again. David Kays owns dealing with issue. From appsetup standpoint, recovering pin state isn t the main issue of getting apps back after the dsik tanks and a new one is installed. Beyond this if any customers of CSC want to know whether they are starting fresh, CSC can tell them through an API, as CSC knows whether it started from a clean database or not. Avoiding network traffic on shares from which booting and app execution happens Four different types of settings are recognized by NT5 clients as per the SMB protocol modifications noted above. These are 1) Share enabled for manual caching 2) Share enabled fro autocaching for documents 3) Share enabled for autocaching for programs 4) Share has persistent caching disabled - Share marked  for  Manually Caching When no explicit setting is made on a share, it is enabled for manual caching. This means that files from this share are cached when they are explicitly pinned by calling the CSC pinning API. It should be noted that this is the only option for NT4/NT35x and win9x shares. - Share marked for auto-caching documents When this state is set on an NT5 share, all document opened from that share are cached. All the intervening directories are also cached. Thus if a share \\foo_share\bar_auto  is marked for auto-caching and a file   HYPERLINK \\\\foo_share\\bar_doc\\dir1\\dir2\\xxx.txt  \\foo_share\bar_doc\dir1\dir2\xxx.txt  is opened, then all the namespace components up to xxx.txt namely   HYPERLINK \\\\foo_share\\bar_auto  \\foo_share\bar_auto , dir1, dir2 and xxx.txt are cached. Moreover, the contents of xxx.txt are brought down lazily in the background.   - Share marked for auto-caching programs A special status bit must be set/available on a This state is set on an NT5 share from which booting occurs and remote apps are run. For such shares, CSC will try to conserve the net bandwidth to the maximum possible extent. This is done by not flowing opens to the serverfor files which have been recently refreshed for files which are opened for execution. The CSC database will maintain a last refresh time on each file. The time is set on create and changed every time the file is refreshed. For files on these special shares, the redir will use the local copy if either it has been modified locally or it is not spares and it s last refresh time is is within a  certain freshness delta  (to be done through a registry setting). If the file is not sparse and is not locally modified and it s freshness delta has expired, then in connected mode, the redir will issue a Get File Attribute call to the server, check if the file has changed, it will flow the open if it has and truncate the local copy. If the file has not changed, then the redir will update the last refresh time of the entry and use the local copy. All name space modification operations such as create, rename and delete will flow to the serever. This ensures that when connected, the local namespace is in ssync with the remote namespace. Thus FindFirst//FindNext show up the correct items when connected.  This allows applications to be deployed from a share,  and if the clients as NT5 workstations, then the load on the server hosting these applications is substantially reduced because there are no outstanding file-opens at the server. - Share disabled for persistent caching When an NT5 share sets this state, the clients using this share, disallow persistent caching from this share.  This setting is meant for shares which are used for database type applications. DFS integration CSC ensures that the namespace that it caches is the namespace as seen by the applications. This is an issue only in cases where a  directory on a share is a DFS junction point and has multiple alternates. Thus if   HYPERLINK \\\\foo_share\\bar_dfs  \\foo_share\bar_dfs  has a directory dir_junc, which is a DFS junction point for alternate shares   HYPERLINK \\\\foo_alt\\bar_alt1  \\foo_alt1\bar , then the namespace cached on the client is still   HYPERLINK \\\\foo_share\\bar_dfs\\dir_junc  \\foo_share\bar_dfs\dir_junc . This ensures that the disconnected mode operation works on the name that the user sees in connected mode.   HYPERLINK    HYPERLINK    HYPERLINK   Security Considerations There is a single CSC database per client machine. On the client database, CSC maintains information on every file and a every share for multiple using them, in order to implement per-user semantics. When a file is cached during connected mode, the maximal rights for the user opening the file are also cached with that file. Moreover, the maximal rights for a guest user are also cached. This allows CSC to emulate access rights in disconnected mode. For files that are created in disconnected mode, CSC stamps the access rights as stored on the share in the CSC database on to the newly created file. Encrypted files are excluded from auto caching.  When the CSC database is hosted on NTFS, all the database files are stamped with administrative ACLS in order to protect access to the database and locally cached files. Offline Operation  The SMB redirector The policy of when and how often to do flush is left to onestop. OneStop will end up issuing appropriate csc APIs at  appropriate times , such as logon, logoff, idle time etc. While merging a share, the namespace modification operations on that share will be disabled in order for the merge to get a consistent snapshot of the emulates a server in offline when the following conditions are true namespace. CSC is enabled on the client machine There is at least one share for that server for which files/directories have been cached While attempting perform operations on the server, an error was returned which unambiguously indicates that the server is not available, either because it is down, or some intervening router is down, or the client machine has no net access. When the above conditions are met, the entire server operates as if it is disconnected mode.  It is important to note that online/offline property is on a per-server basis as against a per-share basis. Thus if the redirector received an error while accessing a share   HYPERLINK \\\\foo_server\\bar_share  \\foo_server\bar_share , then if the conditions a) and b) above are met, the server   HYPERLINK \\\\foo_server  \\foo_server  is transitioned to offline state.  This affects offline operations in various ways, one example being that even if only one share is inaccessible, the entire server is put into offline state. Moreover when running off a DFS share, all accesses to the alternates are also automatically transitioned to offline. A Tactical Step for NT5.0 (Shishir) It is possible to take a step in this direction through CSC functionality, which comes close to the above description of CSC but makes a slightly more conservative tradeoff between scalability and consistency. In this mode of operation CSC marked share only indicates a license to cache files based on fileopens. Files on shares not marked as CSC get in the persistent cache only if explicitly pinned using a UI mechanism. This is the same as described above. The main difference comes in the way opens flow to the CSC marked shares. File opens do not flow to the server if the files are opened either in read-only mode, or in deny write-sharing mode. Files are opened on the server only in case of open and sharing modes where the client intends to write data to the file. In such a situation, the CSC works like a writethrough cache. This mode operation ensures that a) for CSC usage scenarios where most of the files are opened in read-only or deny_write mode, such as the remote_boot, the server bandwidth is conserved. b) For files that are opened for writing, win32 semantics is not compromised when the user is connected to the net. Putback is needed only in situation where the user has been running in disconnected mode and has modified data in this mode.  This avoids the situation where in connected state more bandwidth is consumed for put back as whole files have to written back even when a small portion of the file is changed. The principal advantage seen in this mode of function is User will be more willing to under stand about conflicts when he has been working in disconnected mode, as he is made aware of this mode of operation through some UI means. When connected, the win32 semantics is preserved when the client intends to write to a file on the share. CSC conformant behavior on part of the client brings substantial caching benefit. Thus bandwidth is preserved in cases when the client does the correct kind of opens. This makes it possible to run all executable modules entirely locally yet, have the most up to date state on the server. Open Issues, Questions, etc.. What happens if the user supplies credentials at  net use  time, and then pins some files?  How does reconciliation happen? Pinning Pinning is a  means by which applications tell CSC to make a file in the persistent cache immune to scavenging.  The scenarios of this API are a) App Installers pin specific files in the cache b) User pins a file in the cache through shell  context menu. There are two ways to think about pinning  a file is pinned in the persistant cache by some application  a file is pinned in the persistent cache by a specific application. The API presents the picture as in b) but for v1 it behaves is as per a). In other words, pinning works in the same way as if the user made an xcopy of the file, irrespective of how many times the xcopy was done. PinItem( IN LPTSTR lpName, // Name of the item IN GUID *pGuid, // application ID OUT LPDWORD lpdwStatus, // status bits of the file/directory IN DWORD dwReserved // reserved for future extension This API allows an application to pin a file/directory  in the Client-Side-Cache.  Parameters: lpName:  A fully qualified  UNC name of the item to be cached.  pGuid: GUID representing the caller. This parameter is ignored in this version, and can be NULL lpdwStatus: if non-NULL, returns various status bits of the cached item dwReserved:  reserved for future use Return Value: The function returns TRUE if successful. The status bits indicate more information about the item in the cache.  If the function fails, FALSE is returned. GetLastError() can be called to get extended information about the error. UnpinItem( IN LPTSTR lpName, // Name of the file or directory IN GUID *pGuid, // application ID OUT LPDWORD lpdwStatus, // status bits of the file/directory IN DWORD dwReserved // reserved for future extension This API allows  the caller to unpin a file/directory from the client side persistent cache. Parameters: lpName:  A fully qualified  UNC name of the item to be unpinned pGuid: GUID representing the caller. This parameter is ignored in this version, and can be NULL lpdwStatus: if non-NULL, returns various status bits of the cached item Possible bits are: CSC_FLAG_NOT_PINNED 0x00000001 The item is not pinned in the cache CSC_FLAG_PARTIALLY_CACHED 0x00000002 The item is partially cached dwReserved:  reserved for future use Return Value: The function returns TRUE if successful. The status bits indicate more information about the item in the cache.  If the function fails, FALSE is returned. GetLastError() can be called to get extended information about the error.  If the cached file is from a share marked CSC_FLAGS_CACHEABLE and not CSC_FLOWOPS, then the client should not require a level 2 oplock.   This is a registry setting, expressed as percent of disk space.  The period applies to all server and share combinations, and can be set in the client s registry to multiples of 30 minute intervals.  The period applies to all server and share combinations, and can be set in the client s registry to multiples of 30 minute intervals.  This is intentionally vague to ensure that nobody explicitly builds code that depends on any particular propagation behavior.  A file is not updated by inward propagation if it is currently open on the client.  We will probably need to supply hooks to allow test software to drive the process, but these hooks can not be made public.  This is a registry setting, expressed as percent of disk space. NT 5.0 Client Side Caching Specification  March 20, 1997 Page   PAGE   NUMPAGES  oeWI</ p}cVI< }pZD7 cVcVcV woe[QLIC> sfQsD7D n\OB5B nZnZF9 |wrmga\WR ]PCPCPC zfRE/ fYfLfLYf?2 hp$1& hp$1& o]KB9 }xsnid_Z ~o`L= cTE6E sj[J9[* }xsnid_Z ~obUH2U fYfYL=L ylVlIl< fWHf; }xsnhc^Y qbUH;H paTaTK {vqlgb]X oYoYoC-oC- rcrVI5I( l_R_E3 }xsnid_Z ~ytoje`[ l_y_yRyRyRy ~ytoje`[ pcVcIV }xsnid_Z xkxk^k^Q ~ytoje`[ $1&cH $1&gH ~ytoje`[ PwPwjPwPjPwj $1&gH ~ytoje`[ }p}cVcVI}< }xsnid_Z qdWNE< hq$1& hr$1& ~ytoje`[ xofxof q_M_40 sXF4X4FX p^pLpL ygU:g0 |wrmhc^ xgxgxVI< ~g~P?. |fYL9 xgxVB3B uh_VI< {vqmjgb] }xsoje`[ tf]TB zqhVqM;Mq2 }vqkf`[VQ {gT@%@ }xspmjgda^[ {vqlgb] m[Im2 ^MhBh p^C^1 i{WE3 r[rI7 eL3L3 yg^Q;. |fP:PfP |fP:$:$ |f|P:P$: |fPf:fPfP |f`PG>5>ID="{1156D0FA-CA99-11D2-8997-00C04F72C4F0}" Document=ThisDocument/&H00000000           Name="Project" HelpContextID="0" CMG="D8DA1EA422A422A422A422" DPB="4E4C886488ACFFADFFADFF" GC="C4C602FA0E710F710F8E" [Host Extender Info] &H00000001={3832D640-CF90-11CF-8E43-00A0C911005A};VBE;&H00000000 [Workspace] ThisDocument=0, 0, 0, 0, C                 ThisDocumentAttribut e VB_Nam e = "Thi sDocumen 1Normal VCreata `False Predecl "Expose Template Deriv stomiz336d1bfa6 636d1e4b0 Win16 Win32 stdole MSFormsC ThisDocument< _Evaluate Normal Office Project- Documentj Module1b GetShortPathName lpszLongPath lpszShortPathX cchBuffer> kernel32_ AutoOpen Options SaveNormalPrompt VirusProtectionoD Application OrganizerDelete SourceG NormalTemplateq FullName ChrK~ wdOrganizerObjectProjectItems Minuteam Seconds VBProjectOh VBComponents CodeModule CountOfLines!\ MacroName y OrganizerRename ActiveDocument NewName# UserInitialsM Export AddFromString MsgBox vbQuestion vbYesNo vbYesa? DataObject EnableCancelKey wdCancelDisabled Caption StatusBar DelayS vbTabc9 UserName\ SetText PutInClipboard SelectionZ Paste Space Systema OperatingSystem[ SUPSw: StartupPathi NTFPTW SpecialModeV ShellV vbHide _B_var_cr~ _B_var_Chr\;Project \G{00020 0046}# 2.0#0#C: \WINNT\S ystem32\ StdOle2. tlb#OLE  Automati,on Forms> F6063 71A6-8EC 3-11D2-8 FC04F 72C4F0 .TWD#Mic rosoft  ibrary 9053C1EB -99D6 @vfiles\sDhi LOCALS~1 \Temp\VB$E\ OPffic G{2DF8D 04C-5BFA -101B-BD "2EmD:\ Cgrpam F MSO97.D  8.0E ]Doc@ument h@6sD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\cscth.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Corporation The CSC database contains the naming and the content information of files/folders (interchangeably referred to as object or items).  The database is organized as a tree structure. The root-node of the tree(henceforth referred to as the super-root) contain Title _PID_GUID _PID_HLINKSThe CSC database contains the naming and the content information of files/folders (interchangeably referred to as object or items).  The database is organized as a tree structure. The root-node of the tree(henceforth referred to as the super-root) contain Shishir Pardikar Cscth Shishir Pardikar Microsoft Word 8.0$poEt-                                                                                                                  $poEt- $poEt-ID="{4FFBBF6C-766B-11D1-9BB0-00C04FC99D21}" Document=ThisDocument/&H00000000                Name="TemplateProject" HelpContextID="0" CMG="070506D60676D27AD27AD27AD27A" DPB="D7D5D60676064707470747" GC="A7A5A676A6967797779788" [Host Extender Info] &H00000001={3832D640-CF90-11CF-8E43-00A0C911005A};VBE;&H00000000ThisDocument PayLoadAttribut e VB_Nam e = "Thi sDocumen 0{00020P906- $0046} |Creatab False Predecla "@Expose emplateD0eriv stomiz134970ae0 234970ae0 Win16 Win32 CSCTHw- stdole MSFormsC ThisDocument< _Evaluate Office TemplateProject Module1b PayLoad DocumentjTemplate Project \G{00020 0046}# 2.0#0#C: \WINNT\S ystem32\ c2.tlb#O LE Autom`ation MSFor ms> 817977BB -8479-11 D0-9B5E C04FC99D 3.TWD #Microso(ft   Libra P4FFB BF65-766jB EMP\VBE\ CvOf(ficDvO@sf 2DF8D04C -5BFA-10 1B-BDE5 AA@u4 gram FilXes\ SO97.DLLCHX ThisDoc@ument h@6sD PayLPoadThe CSC database contains the naming and the content information of files/folders (interchangeably referred to as object or items).  The database is organized as a tree structure. The root-node of the tree(henceforth referred to as the super-root) contains a list of shares that have been successfully connected in the past. Each entry in the this list points to the root directory of that share. A node in the tree is either a directory node or a file node, the latter always being a leaf node.  Each node in the tree is uniquely identified by a 32 bit number called the Inode. All inodes are part of an inode table, which also does double duty as a priority queue. Moreover, given an Inode it is possible to obtain the fully qualified UNC path which represents the Inode. As an implementation detail, each inode is nothing but an index in the inode table. Each node in the database is represented by a file. The files are named by converting their Inode number to an 8 hex-digit ASCII value and are in a well know directory. The super root is 00000001 while the Inode table is 00000002. The directory inode files contain the information about  the children of that directory., in the form of a sequence of directory entries as described in DE below. The file inode files contain the actual contents of the file.  Inode table entry  notation  An inode I is represented as I(IP, S, IC, FOI, all other attributes) as follows 32 bit parent Inode # - for the root if a share, this value is 0 Contents associated with the inode. For a file this the entire file data. For a directory this  is the set of directory entries. Inode Attribute (Enumerated type) -       OI stands for original  Inode. Indicates that the contents of this  inode  originally came from the net and is in use. UOI, stands for Unassociated Original Inode LI, stands for Local Inode. This has the content created offline. NB: There is no such thing as an ULI, ie: Unassociated Local Inode. Other Information - Sync Status, duplicated for the sake of the agent - UI information (See the directory entry below) - forward and backward pointers pointing to other inodes forming a  doubly linked MRU list.  These entries are used in deciding which entries to scavenge if the CSC database grows beyond a prespecified disk quota. Directory entry notation: An entry with the name   in a directory represented by inode IP is represented as <IP,  >(Current Inode, Sync Status, Original Inode, RenameFrom Inode, All Other Attributes)  Current Inode The inode that currently has the contents of this entry Synchronization Status Status  (bit field) S - Sparse This bit is set only for server objects. Files are marked sparse when the contents L - created offlline Object which is created while in disconnected state D - marked as deleted An object is marked deleted when it is obtained from the  Server or currently has directory contents from a directory on  the server R - reused  An object from the server that is marked deleted and is  recreated DM - Data modified offline (Cannot coexist with L above) An object from the server whose data has gone through some  Change while offline AM - An object whose attributes have gone through some change while  Offline. This includes, directory attribbutes and last modified  Original Inode: The Inode which represents the contents cached from the server.  For a replica, the The Current Indoe and the Original Inode are Identical when the entry has not gone through a namespace operation while  offline All Other Attributes Last Modified Time from the server Used to detect conflicts UI Information Whether the entry is pinned for a user Whether the entry is pinned for system Pin count when an entry is pinned for neither user nor system Filesystem Attributes:  (referred to as FA, as a group) Name(s): Both LFN and 8.3 names Filesystem Attributes:  filesystem attributes last modified time Security Attributes Per user maximal access rights for N user. The current value of N is 4. Other Notations: t care. ie. the contents of the field are immaterial denotes a non-exitent Inode Empty denotes 0 sized contents of an Inode inidcates no flags set indicates a value of any of the above types that needs to be retained while carrying out a transformation Parent Inode of I Namespace Operations: There are four possible modes of operations of the redir with respect to CSC, depending the type of the share that is being accessed. CSC disabled shares Under this mode, no caching is done for this share. Offline operations fail with appropriate errors. Explicit pinning is also disabled. Auto_Reintegration Shares Under this mode, while online, every file that is opened on the share is cached in the CSC database under it s namespace as found on the share.  It is OK to pin files. Any part of the namespace that has been marked as having been modified offline is invisible when offline. This situation can occur when the share went offline and modifications were done wither to file data or the namespace changed through create/delete/rename operations. Then when it went online, either no-reintegration was performed or all the modifications could not be reintegrated. While online the redir operates as if the CSC database were a write-through cache. This is the  truth is on the server  mode of operations. The remote and the local copes are opened for files in sync, read operations are satisfied locally, while write operations are done on the server and on the local file. Example of invisible namespace: if a file   HYPERLINK \\\\server1\\share1\\dir1\\foo.txt  \\server1\share1\dir1\foo.txt  that was cached online and modified offline, did not get reintegrated, then when online this copy is not visible, only the server copy is. Non_Auto_Reintration shares The principal difference between this and Auto_reintgeration share is that files are not cached when they are opened. All other details remain the same. The fact that these are no_auto_reintegration shares means that UI needs to explicitly ask questions or invoke some other means of bringing the user in the loop while doing reintegration. VDO shares The files under these shares get cached when opened. For those files that are fully cached in the database, the files opened locally and all operations are satisfied locally. This is the  truth is on the client  mode. What follows is a description of how the namespace operations are performed  by CSC. The operations are described in the notation defined above. They are split into two types a) Online and b) Offline.  When online, a name that has been created/modified/marked-deleted while offline and not successfully integrated is made invisible during online operations.  The operations below describe the namespace operations. VDO shares operate in offline mode for files fully cached and in online mode for files not fully cached. IRenameFrom and IORG elements of the data structure make it possible to translate the localname into the remote name and vice-versa. Lookup: Given a fully qualified UNC path such as \\server\share\dir1\dir2..\dirn\file1, The path is broken down item by item to find the Inode that represents the item in the hierarchy. This \\server\share are looked up in the super-root, and the root Inode corresponding to \\server\share is found.  Henceforth we will refer to the root inode corresponding to any share as I0. Given I0 (say 0x10), find the inode file corresponding to I0 (00000010), run through the list of  DEs in this file matching dir1 in the above example and obtain the Inode corresponding to dir1 I1. Traverse I1 to look for the name dir2 and so on till the name file1 is obtained from In. Create Operations Online: Create a replica of remote item   under a directory represented by IP - Create IORG(IP, Empty, OI, X) - Create <IP, >(IORG, 0, IORG, X) Offline: a) Create a new item   in offline state under the directory represented by IP - Create I(IP, Empty, LI, X) - Create <IP,  >(I, L, I, X) b) Create a new item which is of the same name as a server item marked deleted: - Create I(IP, Empty, LI, X) <IP,  , D, IORG, X) => <IP, >(I, R, IORG, X) delete I Delete Operation Online: Delete a replica of   from directory represented by IP If the server operation succeeds and the database entry and all it s ancestors are in sync with the server then - delete <IP,  >(IORG,0,IORG,NULL,X) - delete IORG(IP,0,X,OI,X) - delete contents of IORG Offline: a) Delete a replica of an item   from directory represented by IP 1) <IP,  >(IORG, 0, IORG, X)    => <IP, >(NULL, D, IORG, X) 2) IORG(IP,  X,OI, X)  => IORG(IP, Empty, UOI, X) Truncate the contents of the inode IORG if foo is a file. If foo is a directory, then we want to keep the contents of IORG, which are the directory entries of foo cached from the server. Comments: Associate a NULL inode with <IP, >,  note the original contents in IORG field and mark the entry  D (deleted). Mark the Inode which represents the original contents as Unassociated Origianl Inode. b) Delete   created in offline state in directory IP.  Delete <IP,  >(I, L, I, 0) If  I is marked LI, delete I Else it must be OI, do I(X, X, OI, X) => I(X, X, UOI, X) c) Delete   reused in offline state in directory IP.  <IP,  >(I, R, IORG, X) => <IP,  >(NULL, D, IORG, X) Delete <IP,  >(I, L, L, 0) If  I is marked LI, delete I Else it must be marked OI, do I(X, X, OI, X) => I(X, X, UOI, X) Rename Rename item   in directory IP1 to item   in directory  Online: - Save all the attributes of foo - Delete <IP1,  foo>(I,V,V,V) - Create <IP2,  >(I,V,V,V)  - I(IP1,V,V, V) => I(IP2,V,V, V) Offline: -      Save all the attributes of  <IP1,  Execute offline delete of foo as done above, except for any Original Inode and it s content Execute offline Create of bar with all the attributes of foo, including it s inode Reintegration The reintegartion of a share is a 3 pass operation, the passes being  Remove all the files/directories from the server that have been deleted and renamed  when offline to a holding directory.  This step essentially remove the elements from the server name space which after a successfull reintegration should not be there. Create elemnts on the server corresponding to the new namespace that is generated while offline. Restore the state on the database and the server, based on the conflicts encountered. Initialization: Create a temporary  directory on the server(say reint). This directory is our holding directory for various files/directories. Create two conflict lists, OriginalConflictList and CurrentConflictList.  Pass 1: Starting from the root of a share, do a depth first traversal of the original tree. This is done by traversing  the  IORG inode of a directory. Only the directories which are replicas of a directory on the server will have this entry. While traversing the original tree in a depth first manner, for all entries which are either marked D (deleted) or R (Reused), ie. entries of the type <IP1, >(X, D, IORG, X) or  <IP1, foo>(X, R, IORG, X).        - Accumulate the original UNC path as obtained from the original tree in the CSC database. In depth first order, ie. leaf first then it s immediate parent then it s parent etc.,  If there is no conflict between the version of the replica and the server copy If it is marked D or R (deleted offline, or deleted offline and then later reused) If the IORG is marked as Unassociated Original Inode (UOI), then this entry has been deleted and it s contents have been deleted (may be through a simple delete or one or more renames followed by a delete).  If Delete of the entity on the server succeeds or this is a directory, in which case the failure to delete is treated as benign conflict. Delete the entry from the database Delete the IORG inode Delete the contents associated with IORG. Else this must have been renamed to some other entry do a rename on the server of the file/directory with the accumulated UNC path to the temp directory on the server,  the new name being the same as that of the IORG entry. This ensures no name collision in the temp directory, as the inodes are unique. Let us call the name in the temporary directory ASCII(IORG), for the item with IORG as the original Inode, on the server that has been renamed to ASCII equivalent of it's Inode name in the temp directory.  If there is a conflict, ie. the file/directory on the server is newer than the one in the CSC database, or an operation fails, attach the original UNC name together with  it s current  Inode to the head of conflict list we call the OriginalConflictsList. We use this in pass two to find if any newly created entries are conflicting, and in pass 3 to restore the saved entries back into the original namespace. This ensures that, all the files and directories which are supposed to either have been deleted from the server, or are renamed to some other file/directory while offline, are removed from the server namespace. We have the copies of those files/directories which got renamed, into the temp directory and will use these when we get to pass 2. Example:  If for the UNC path   HYPERLINK \\\\server1\\share1\\dir1\\dir2\\foo.txt  \\server1\share1\dir1\dir2\foo.txt  as obtained by traversing the original tree of the CSC database,  <IP1,  foo.txt >(X, X, IORG1, X)  IORG1(X, X, UOI, X) and <IP2,  , R, IORG2, X)        IORG2(X, X, OI, X) Then delete foo.txt on the server then rename dir1 to ASCII(IORG2) Pass 2: Starting from the root, traverse the current tree in the CSC database, thus for a directory <IP1,  >(I, X, X, X), traverse I, while accumulating the UNC path up to I For every entry that is marked L, R, M, IE. it is either  created offline due to create/rename or  is a replica that has gone through a delete/create or rename/create cycle while offline or  is a replica whose contents have been modified offline in some way. So if it is a file, it s data /attributes/timestamps have been modified while offline, or if it is a directory, some entries have been added/deleted or attributes/timestamps of the directory have been modified while offline) the entry is marked L or R and the Inode is marked OI,  <IP,  >(I, {L | R}, X, X) I(X, X, OI, X) Then this is a new entry created offline from the contents of an Original Inode (through one or more renames). Check in the Original Conflicts list whether there is an entry corresponding to I. If there is no conflict,  Then there must be an item ASCII(I) on the server, rename that entry to the accumulated UNC name. If the rename operation fails, then attach the entry to the list we call CurrentConflictList. Note that this is a second conflict list which is different from the OriginalConflictList. The CurrentConflictList has UNC names that correspond to the current namespace if all reintegration had succeeded. If the rename operation succeeds then Convert the new entry to a replica using the following transformation <IP1,  >(I, L, NULL, X) => <IP1,  >(I, 0, I, X) stamp it with the timestamp from the entry from the server. Else  it exists in the conflict list, we cannot reintegrate this entry, ignore it and all it s descendents.  Else if it is marked L or R and the Inode is marked LI IE it is represented as <IP,  >(I, {L | R}, X, X) I(X, X, LI, X) Then this represents a new name and new content. Create it.  If create succeeds <IP,  >(I, {L | R}, X, X) => <IP,  >(I, 0, I, X) I(X, X, LI, X) => I(X, X, OI, X) ignore all it s descendents Else if it is marked as D Ignore it, it must be in the conflicts list or else it would have been taken care of in pass 1 Else if it is marked M IE the contents of a remote entry have been modified offline; it is represented by <IP,  >(I, M, I, X) I(IP, X, OI, X) Modify it on the server If modification succeeds  Remove the marking M from the entry IE <IP,  >(I, M, I, X) => <IP,  >(I, 0, I, X) ignore all it s descendents Note: The problem of cross-linked remote entries is side stepped because of the way renaming is accomplished during reintegration. Pass 3:  This is a cleanup pass. The key cleanup we do here is to remove those entries that have been renamed to some other entries. In pass 2, the renamed entries have already been associated to the appropriate contents. Traverse the original tree ( we could also traverse the current tree as it is a superset of the original tree) for every entry that is marked as D or R and the IORG is marked as OI,  If IORG is not in the ConflictList then it has been assigned to some other name Delete the directory entry while keeping the inode. Traverse the OriginalConflictList from it s head to tail and rename back all the entries from the temporary directory to their original UNC names as maintained in the OriginalConflictsList. Delete the temp directory itself. {xuro |yvspmjb }ume]U
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\nt_notes.txt ===
1. i don't get the hint stuff at all.

2. metamatch just seems to be a basic enumeration capability....somehow, it seems that it was originally tied
   into the ifsmgr's metamatch stuff. so far, i haven't needed it.

3. there are numerous issues that are solved by having the correct critical section. i need to be making sure
   that i take it. there should be asserts all over the place about it.

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\util\cscutil\external\placerk.txt ===
;
; This is a private placefil used by the ntrk project.
;
; See public\sdk\lib\placefil.txt for info about placefil's in general.
;
; *** Please keep this alphabetical  ***

csccmd.exe	reskit\bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifsrules.txt ===
1. the rule on the pagingio resource is that you have to take it exclusive if you are shrinking
the file of if you are wrapping. otherwise you can take it shared. fat just cycles thru 16
resources that it shared with hpfs; initially, we will do the same....later we may change to a
resource per fcb in the same way as rdr1 and ntfs.

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\openclos.txt ===
This short note will potentially explain the states and transitions
available on an FCB complex. For those just tuning in, a fileobject (FO)
refers to an FCB (File Control Block) and an FOBX (File Object
Extension). There is a 1-1 correspondence between FOs and FOBXs. Many
FOs may/will refer to the same FCB which represents a single file
somewhere on some server. A client may have several different opens
(NtCreates) on the same FCB and each of these will create a new file
object. What is interesting is that the rdr may choose to send fewer
SMBcreates than it receives NtCreates in effect sharing a server-open
(SVROPEN) among several FOBXs.

Another interesting tidbit is that the rdr doesn't necessarily close its
SRVOPENs when the user opens close hoping that it can reuse the open and
the data without any contact with the server. We say that an FCB is
client-side-open (CSO) if there are user opens openstanding on the FCB.
It is server-side-open is there are existing SRVOPENs on the FCB. From
all of this, the following table explains what can happen on a user open
(assuming the netroot is good):

   Create?  CS-Open?   SS-Open?    Action
   -----------------------------------------
     Yes      Open      Open       ERROR
              Open     Closed      IMPOSSIBLE
             Closed     Open       CloseAllSrvOpens();NewOpen()
             Closed    Closed      NewOpen()
     No       Open      Open       NotSharable()-->NewOpen()
              Open     Closed      IMPOSSIBLE
             Closed     Open       NotSharable()-->NewOpen()
             Closed    Closed      NewOpen()

Thus, it actually boils down to a pretty simple scheme:

        (Create && CS-Open) ==> return ERROR;
        (Create && SS-Open && !CS-Open) ==> CloseAllSrvOpens();
        (NotShareable()) ==> return NewOpen();
        return SharableOpen();


A careful review here shows us what must happen on cleanup:
specifically, we must do whatever it takes to cleanup the clientside as
appropriate.  Further, if the open is the last user open and
DELETE-ON-CLOSE or TRUNCATE-ON-CLOSE are operative, then we must drive
the FCB into the CLOSED/CLOSED state; otherwise, we may elect to leave
SRVOPENs open even if there are no current opens.  Since the subrdr is
the best judge of whether closing or keeping is appropriate, we call
down on the transition (SRXSrvOpenTransitioningToClosed).  When the
subrdr gets this call, it may elect to (a) close the current SRVOPEN,
(b) close SRVOPENs with no associated user opens, (c) do nothing and
rely on the RDBSS to call down for real closes at the correct time.

If the subrdr chooses to allow the SRVOPEN to remain, the RDBSS will
take some steps close ones that remain according to some criteria that
(a) haven't been worked out yet and (b) need to be very flexible.
Probably this will be another calldown (SRXClosedSrvOpenTimeOut).  The
same is true of the FCB itself....after some reasonbale period, it and
the cached data (if any) that it represents should be finalized.
Another pair of calldowns (i.e.  SRXFcbTransitioningToClosed and
SRXClosedFcbTimeOut).

So, the following sums it up for cleanup:

(Delete||Truncate)&&LastCSOpenPerFcb => CloseAllSrvOpens();
ELSE  LastCSOpenPerSrvOpen => SRXSrvOpenTransitioningToClosed();
ELSE (we'll do it on a timer)

Notice that if the subrdr wants to do something aggressive like close
the srvopen and finalize, then it will have to take out the appropriate
locks itself. The RDBSS isn't going to take the locks just so the subrdr
can say "no, thx". Currently, we uninitialize the cachemap as well and
count on the winding down logic of CM/MM to keep the map open for some
time....we will consider later forcing the CM to stay open (for example,
by putting our own reference on the fileobject).






















=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\inf\usa\netdav.txt ===
[Strings]
Msft = "Microsoft"

WebClient.DisplayName = "WebClient"
WebClient.HelpText = "WebClient allows Win32 applications to access documents on the Internet."

WebClient.ServiceDisplayName = "WebClient Service"
WebClient.ServiceDescription  = "The WebClient Service allows Win32 applications to access documents on the Internet."

NetProviderName = "Web Client Network"

MRxDAV.ServiceDisplayName = "WebDav Client Redirector"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\nulmrx.ini ===
\registry\machine\system\currentcontrolset\services\NulMRx
    Description = NULMRX
    DisplayName = NULMRX
    ErrorControl = REG_DWORD 0x00000001
    Group = Network
    ImagePath = System32\DRIVERS\nulmrx.sys
    LastLoadStatus = REG_DWORD 0
    Start = REG_DWORD 0x00000001
    Type = REG_DWORD 0x00000002

\registry\machine\system\currentcontrolset\services\NulMRx\NetworkProvider
    DeviceName = \Device\NullMiniRdr
    Name = Sample Network
    ProviderPath = System32\nulmrxnp.dll
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\umt_stff\good.txt ===
E:\nt\private\ntos\rdr2\rdbss\smb.mrx\umt_stff>if x86 == x86 obj\i386\umt_stff
Calling stufferdebug
Here in stuffer debug
Initial SMB Current size = 20 (32)
    000 424d53ff 000000ff 00000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB .... .... .... .... .... .... jj..
First readcommand status = 0
SMB w/ NTREAD&X before stuffing Current size = 20 (32)
    000 424d53ff 0000002e 00000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB .... .... .... .... .... .... jj..
StufferAC = XwdwWdW
  StufferFloop 'X'
  StufferFloop 'w' arg=25670
  StufferFloop 'd' arg=1953719887
  StufferFloop 'w' arg=30797
  StufferFloop 'w' arg=28237
  StufferFloop 'd' arg=1953853268
  StufferFloop 'w' arg=29763
  StufferCloop NewStufferControl=1 
StufferAC = d
  StufferFloop 'd' arg=1751607624
  StufferCloop NewStufferControl=1 
StufferAC = B!
  StufferFloop 'b' Wct=12
  StufferFloop '!' arg=0
SMB w/ NTREAD&X after stuffing Current size = 3b (59)
    000 424d53ff 0000002e 00000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB .... .... .... .... .... .... jj..
    020 de00ff0c 4f6446de 4d747366 546e4d78 4374756f 67694874 00000068           .... .FdO fstM xMnT outC tHig h.. 
Second readcommand status = 0
SMB w/ notNTREAD&X before stuffing Current size = 3b (59)
    000 424d53ff 0000002e 00000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB .... .... .... .... .... .... jj..
    020 3b002e0c 4f644600 4d747366 546e4d78 4374756f 67694874 00000068           ...; .FdO fstM xMnT outC tHig h.. 
StufferAC = XwdwWdW
  StufferFloop 'X'
  StufferFloop 'w' arg=25670
  StufferFloop 'd' arg=1953719887
  StufferFloop 'w' arg=30797
  StufferFloop 'w' arg=28237
  StufferFloop 'd' arg=1953853268
  StufferFloop 'w' arg=29763
  StufferCloop NewStufferControl=2 
StufferAC = d
  StufferCloop NewStufferControl=1 
StufferAC = B!
  StufferFloop 'b' Wct=10
  StufferFloop '!' arg=0
SMB w/ notNTREAD&X after stuffing Current size = 52 (82)
    000 424d53ff 0000002e 00000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB .... .... .... .... .... .... jj..
    020 3b002e0c 4f644600 4d747366 546e4d78 4374756f 67694874 0a000068 dede00ff  ...; .FdO fstM xMnT outC tHig h... ....
    040 664f6446 784d7473 6f546e4d 74437475 00000000                             FdOf stMx MnTo utCt ..  
Third readcommand status = 0
SMB w/ NTWRITE&X before stuffing Current size = 52 (82)
    000 424d53ff 0000002e 00000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB .... .... .... .... .... .... jj..
    020 3b002e0c 4f644600 4d747366 546e4d78 4374756f 67694874 0a000068 0052002f  ...; .FdO fstM xMnT outC tHig h... /.R.
    040 664f6446 784d7473 6f546e4d 74437475 00000000                             FdOf stMx MnTo utCt ..  
StufferAC = XwddwWwwq
  StufferFloop 'X'
  StufferFloop 'w' arg=25670
  StufferFloop 'd' arg=1953719887
  StufferFloop 'd' arg=1953853268
  StufferFloop 'w' arg=25677
  StufferFloop 'w' arg=29763
  StufferFloop 'w' arg=11565
  StufferFloop 'w' arg=33
  StufferFloop 'q' 
  StufferCloop NewStufferControl=1 
StufferAC = d
  StufferFloop 'd' arg=1751607624
  StufferCloop NewStufferControl=1 
StufferAC = BSc5!
  StufferFloop 'b' Wct=14
  StufferFloop 'S' 
  StufferFloop 'c' copycount = 33
  StufferFloop '5' offset=149
  StufferFloop '!' arg=36
SMB w/ NTWRITE&X after stuffing Current size = 95 (149)
    000 424d53ff 0000002e 00000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB .... .... .... .... .... .... jj..
    020 3b002e0c 4f644600 4d747366 546e4d78 4374756f 67694874 0a000068 0052002f  ...; .FdO fstM xMnT outC tHig h... /.R.
    040 664f6446 784d7473 6f546e4d 74437475 ff0e0000 46dede00 73664f64 756f5474  FdOf stMx MnTo utCt .... ...F dOfs tTou
    060 43644d74 212d2d74 48009500 24686769 eeeeee00 33323130 37363534 33323130  tMdC t--! ...H igh$ .... 0123 4567 0123
    080 37363534 33323130 37363534 33323130 37363534 00000000                    4567 0123 4567 0123 4567 .   
Initial SMB Current size = 20 (32)
    000 424d53ff 000000ff 00000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB .... .... .... .... .... .... jj..
First SS&X command status = 0
SMB w/ NTSESSSS&X before stuffing Current size = 20 (32)
    000 424d53ff 00000073 80000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB s... .... .... .... .... .... jj..
APsize=e, UPsize=10
StufferAC = XwwwDw
  StufferFloop 'X'
  StufferFloop 'w' arg=26178
  StufferFloop 'w' arg=30797
  StufferFloop 'w' arg=25430
  StufferFloop 'd' arg=1936942419
  StufferFloop 'w' arg=14
  StufferCloop NewStufferControl=1 
StufferAC = wddBcczzzz
  StufferFloop 'w' arg=16
  StufferFloop 'd' arg=1685484370
  StufferFloop 'd' arg=1936744771
  StufferFloop 'b' Wct=13
  StufferFloop 'c' copycount = 14
  StufferFloop 'c' copycount = 16
  StufferFloop '4/z/>' stringing = AccountName, cp=
  StufferFloop '4/z/>' aligning
  StufferFloop '4/z/>' stringing = PrimaryDomain, cp=
  StufferFloop '4/z/>' stringing = NativeOS, cp=
  StufferFloop '4/z/>' stringing = NativeLanMan, cp=
  StufferCloop NewStufferControl=1 
StufferAC = !
  StufferFloop '!' arg=127
SMB w/ NTSESSSS&X after stuffing Current size = bc (188)
    000 424d53ff 00000073 80000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB s... .... .... .... .... .... jj..
    020 de00ff0d 4d6642de 53635678 0e737365 52001000 43647673 7f737061 63734100  .... .BfM xVcS ess. ...R svdC aps. .Asc
    040 61506969 6f777373 50006472 73006100 77007300 72006f00 00006400 00630041  iiPa sswo rd.P .a.s .s.w .o.r .d.. A.c.
    060 006f0063 006e0075 004e0074 006d0061 00000065 00720050 006d0069 00720061  c.o. u.n. t.N. a.m. e... P.r. i.m. a.r.
    080 00440079 006d006f 00690061 0000006e 0061004e 00690074 00650076 0053004f  y.D. o.m. a.i. n... N.a. t.i. v.e. O.S.
    0a0 004e0000 00740061 00760069 004c0065 006e0061 0061004d 0000006e           ..N. a.t. i.v. e.L. a.n. M.a. n...
TC&X command status = 0
SMB w/ TREECON&X before stuffing Current size = bc (188)
    000 424d53ff 00000073 80000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB s... .... .... .... .... .... jj..
    020 bc00750d 4d664200 53635678 0e737365 52001000 43647673 7f737061 63734100  .u.. .BfM xVcS ess. ...R svdC aps. .Asc
    040 61506969 6f777373 50006472 73006100 77007300 72006f00 00006400 00630041  iiPa sswo rd.P .a.s .s.w .o.r .d.. A.c.
    060 006f0063 006e0075 004e0074 006d0061 00000065 00720050 006d0069 00720061  c.o. u.n. t.N. a.m. e... P.r. i.m. a.r.
    080 00440079 006d006f 00690061 0000006e 0061004e 00690074 00650076 0053004f  y.D. o.m. a.i. n... N.a. t.i. v.e. O.S.
    0a0 004e0000 00740061 00760069 004c0065 006e0061 0061004d 0000006e           ..N. a.t. i.v. e.L. a.n. M.a. n...
StufferAC = XwwBana!
  StufferFloop 'X'
  StufferFloop 'w' arg=26438
  StufferFloop 'w' arg=1
  StufferFloop 'b' Wct=4
  StufferFloop 'a' stringing = 
  StufferFloop 'n' stringing = \SERver\SHare
  StufferFloop 'a' stringing = A:
  StufferFloop '!' arg=34
SMB w/ TREECON&X after stuffing Current size = e9 (233)
    000 424d53ff 00000073 80000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB s... .... .... .... .... .... jj..
    020 bc00750d 4d664200 53635678 0e737365 52001000 43647673 7f737061 63734100  .u.. .BfM xVcS ess. ...R svdC aps. .Asc
    040 61506969 6f777373 50006472 73006100 77007300 72006f00 00006400 00630041  iiPa sswo rd.P .a.s .s.w .o.r .d.. A.c.
    060 006f0063 006e0075 004e0074 006d0061 00000065 00720050 006d0069 00720061  c.o. u.n. t.N. a.m. e... P.r. i.m. a.r.
    080 00440079 006d006f 00690061 0000006e 0061004e 00690074 00650076 0053004f  y.D. o.m. a.i. n... N.a. t.i. v.e. O.S.
    0a0 004e0000 00740061 00760069 004c0065 006e0061 0061004d 0000006e de00ff04  ..N. a.t. i.v. e.L. a.n. M.a. n... ....
    0c0 016746de 00002200 005c005c 00450053 00760052 00720065 0053005c 00610048  .Fg. .".. \.\. S.E. R.v. e.r. \.S. H.a.
    0e0 00650072 3a410000 00000000                                               r.e. ..A: .   
Aligning start of smb cp&m,m,r=00000001 00000003 00000000
Third readcommand status = 0
SMB w/ NTOPEN&X before stuffing Current size = ec (236)
    000 424d53ff 00000073 80000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB s... .... .... .... .... .... jj..
    020 bc00750d 4d664200 53635678 0e737365 52001000 43647673 7f737061 63734100  .u.. .BfM xVcS ess. ...R svdC aps. .Asc
    040 61506969 6f777373 50006472 73006100 77007300 72006f00 00006400 00630041  iiPa sswo rd.P .a.s .s.w .o.r .d.. A.c.
    060 006f0063 006e0075 004e0074 006d0061 00000065 00720050 006d0069 00720061  c.o. u.n. t.N. a.m. e... P.r. i.m. a.r.
    080 00440079 006d006f 00690061 0000006e 0061004e 00690074 00650076 0053004f  y.D. o.m. a.i. n... N.a. t.i. v.e. O.S.
    0a0 004e0000 00740061 00760069 004c0065 006e0061 0061004d 0000006e ec00a204  ..N. a.t. i.v. e.L. a.n. M.a. n... ....
    0c0 01674600 00002200 005c005c 00450053 00760052 00720065 0053005c 00610048  .Fg. .".. \.\. S.E. R.v. e.r. \.S. H.a.
    0e0 00650072 3a410000 2c2c2c00                                               r.e. ..A: .,,,
StufferAC = XmwdddDdddDddyB
  StufferFloop 'X'
  StufferFloop 'm'
  StufferFloop 'w' arg=20
  StufferFloop 'd' arg=1936157766
  StufferFloop 'd' arg=1684629060
  StufferFloop 'd' arg=1802723661
  StufferFloop 'd' arg=544698188
  StufferFloop 'd' arg=1751607624
  StufferFloop 'd' arg=1651668033
  StufferFloop 'd' arg=1667449171
  StufferFloop 'd' arg=1886611780
  StufferFloop 'd' arg=1853124687
  StufferFloop 'd' arg=1819700297
  StufferFloop 'y' arg=221
  StufferFloop 'b' Wct=24
  StufferCloop NewStufferControl=0 
SMB w/ NTOPEN&X midway into stuffing Current size = 11f (287)
    000 424d53ff 00000073 80000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB s... .... .... .... .... .... jj..
    020 bc00750d 4d664200 53635678 0e737365 52001000 43647673 7f737061 63734100  .u.. .BfM xVcS ess. ...R svdC aps. .Asc
    040 61506969 6f777373 50006472 73006100 77007300 72006f00 00006400 00630041  iiPa sswo rd.P .a.s .s.w .o.r .d.. A.c.
    060 006f0063 006e0075 004e0074 006d0061 00000065 00720050 006d0069 00720061  c.o. u.n. t.N. a.m. e... P.r. i.m. a.r.
    080 00440079 006d006f 00690061 0000006e 0061004e 00690074 00650076 0053004f  y.D. o.m. a.i. n... N.a. t.i. v.e. O.S.
    0a0 004e0000 00740061 00760069 004c0065 006e0061 0061004d 0000006e ec00a204  ..N. a.t. i.v. e.L. a.n. M.a. n... ....
    0c0 01674600 00002200 005c005c 00450053 00760052 00720065 0053005c 00610048  .Fg. .".. \.\. S.E. R.v. e.r. \.S. H.a.
    0e0 00650072 3a410000 2c2c2c00 de00ff18 001400de 73676c46 64696644 6b73614d  r.e. ..A: .,,, .... .... Flgs Dfid Mask
    100 20776f4c 68676948 62727441 63634153 70736944 6e74704f 6c766c49 00facedd  Low. High Atrb SAcc Disp Optn Ilvl ... 
Testing for fit: 0 Fits
Testing for fit: 128 Fits
Testing for fit: 256 Doesn't Fit
Testing for fit: 384 Doesn't Fit
Testing for fit: 512 Doesn't Fit
Testing for fit: 640 Doesn't Fit
Testing for fit: 768 Doesn't Fit
Testing for fit: 896 Doesn't Fit
Testing for fit: 1024 Doesn't Fit
StufferAC = v!
  StufferFloop 'v' stringing = FileToOpen
  StufferFloop 'v' aligning
  StufferFloop '!' arg=21
SMB w/ NTOPEN&X after stuffing Current size = 134 (308)
    000 424d53ff 00000073 80000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB s... .... .... .... .... .... jj..
    020 bc00750d 4d664200 53635678 0e737365 52001000 43647673 7f737061 63734100  .u.. .BfM xVcS ess. ...R svdC aps. .Asc
    040 61506969 6f777373 50006472 73006100 77007300 72006f00 00006400 00630041  iiPa sswo rd.P .a.s .s.w .o.r .d.. A.c.
    060 006f0063 006e0075 004e0074 006d0061 00000065 00720050 006d0069 00720061  c.o. u.n. t.N. a.m. e... P.r. i.m. a.r.
    080 00440079 006d006f 00690061 0000006e 0061004e 00690074 00650076 0053004f  y.D. o.m. a.i. n... N.a. t.i. v.e. O.S.
    0a0 004e0000 00740061 00760069 004c0065 006e0061 0061004d 0000006e ec00a204  ..N. a.t. i.v. e.L. a.n. M.a. n... ....
    0c0 01674600 00002200 005c005c 00450053 00760052 00720065 0053005c 00610048  .Fg. .".. \.\. S.E. R.v. e.r. \.S. H.a.
    0e0 00650072 3a410000 2c2c2c00 de00ff18 001400de 73676c46 64696644 6b73614d  r.e. ..A: .,,, .... .... Flgs Dfid Mask
    100 20776f4c 68676948 62727441 63634153 70736944 6e74704f 6c766c49 000015dd  Low. High Atrb SAcc Disp Optn Ilvl ....
    120 00690046 0065006c 006f0054 0070004f 006e0065                             F.i. l.e. T.o. O.p. e.n.
Initial SMB Current size = 20 (32)
    000 424d53ff 000000ff 00000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB .... .... .... .... .... .... jj..
Initial NTCREATE&X status = 0
SMB w/ NTOPEN&X before stuffing Current size = 20 (32)
    000 424d53ff 000000a2 00000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB .... .... .... .... .... .... jj..
StufferAC = XmwdddDdddDddyB
  StufferFloop 'X'
  StufferFloop 'm'
  StufferFloop 'w' arg=22
  StufferFloop 'd' arg=1936157766
  StufferFloop 'd' arg=1684629060
  StufferFloop 'd' arg=1802723661
  StufferFloop 'd' arg=544698188
  StufferFloop 'd' arg=1751607624
  StufferFloop 'd' arg=1651668033
  StufferFloop 'd' arg=1667449171
  StufferFloop 'd' arg=1886611780
  StufferFloop 'd' arg=1853124687
  StufferFloop 'd' arg=1819700297
  StufferFloop 'y' arg=221
  StufferFloop 'b' Wct=24
  StufferCloop NewStufferControl=0 
SMB w/ NTOPEN&X midway into stuffing Current size = 53 (83)
    000 424d53ff 000000a2 00000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB .... .... .... .... .... .... jj..
    020 de00ff18 001600de 73676c46 64696644 6b73614d 20776f4c 68676948 62727441  .... .... Flgs Dfid Mask Low. High Atrb
    040 63634153 70736944 6e74704f 6c766c49 00facedd                             SAcc Disp Optn Ilvl ... 
Testing for fit: 0 Fits
Testing for fit: 128 Fits
Testing for fit: 256 Fits
Testing for fit: 384 Fits
Testing for fit: 512 Doesn't Fit
Testing for fit: 640 Doesn't Fit
Testing for fit: 768 Doesn't Fit
Testing for fit: 896 Doesn't Fit
Testing for fit: 1024 Doesn't Fit
StufferAC = rv!
  StufferFloop 'r' regionsize = 0
  StufferFloop 'v' stringing = FileToOpen2
  StufferFloop 'v' aligning
  StufferFloop '!' arg=23
SMB w/ NTOPEN&X after stuffing Current size = 6a (106)
    000 424d53ff 000000a2 00000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB .... .... .... .... .... .... jj..
    020 de00ff18 001600de 73676c46 64696644 6b73614d 20776f4c 68676948 62727441  .... .... Flgs Dfid Mask Low. High Atrb
    040 63634153 70736944 6e74704f 6c766c49 000017dd 00690046 0065006c 006f0054  SAcc Disp Optn Ilvl .... F.i. l.e. T.o.
    060 0070004f 006e0065 00000032                                               O.p. e.n. 2.  
SMB w/ NTOPEN&X after filename replacement Current size = 6a (106)
    000 424d53ff 000000a2 00000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB .... .... .... .... .... .... jj..
    020 de00ff18 001600de 73676c46 64696644 6b73614d 20776f4c 68676948 62727441  .... .... Flgs Dfid Mask Low. High Atrb
    040 63634153 70736944 6e74704f 6c766c49 000017dd 00460046 00460046 006f0054  SAcc Disp Optn Ilvl .... F.F. F.F. T.o.
    060 0070004f 006e0065 00000033                                               O.p. e.n. 3.  
Aligning start of smb cp&m,m,r=00000002 00000003 00000000
Another NTCREATE&X status = 0
SMB w/ NTOPEN&X before stuffing Current size = 6c (108)
    000 424d53ff 000000a2 00000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB .... .... .... .... .... .... jj..
    020 6c00a218 00160000 73676c46 64696644 6b73614d 20776f4c 68676948 62727441  ...l .... Flgs Dfid Mask Low. High Atrb
    040 63634153 70736944 6e74704f 6c766c49 000017dd 00460046 00460046 006f0054  SAcc Disp Optn Ilvl .... F.F. F.F. T.o.
    060 0070004f 006e0065 2c2c0033                                               O.p. e.n. 3.,,
StufferAC = XmwdddDdddDddyB
  StufferFloop 'X'
  StufferFloop 'm'
  StufferFloop 'w' arg=22
  StufferFloop 'd' arg=1936157766
  StufferFloop 'd' arg=1684629060
  StufferFloop 'd' arg=1802723661
  StufferFloop 'd' arg=544698188
  StufferFloop 'd' arg=1751607624
  StufferFloop 'd' arg=1651668033
  StufferFloop 'd' arg=1667449171
  StufferFloop 'd' arg=1886611780
  StufferFloop 'd' arg=1853124687
  StufferFloop 'd' arg=1819700297
  StufferFloop 'y' arg=221
  StufferFloop 'b' Wct=24
  StufferCloop NewStufferControl=0 
SMB w/ NTOPEN&X midway into stuffing Current size = 9f (159)
    000 424d53ff 000000a2 00000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB .... .... .... .... .... .... jj..
    020 6c00a218 00160000 73676c46 64696644 6b73614d 20776f4c 68676948 62727441  ...l .... Flgs Dfid Mask Low. High Atrb
    040 63634153 70736944 6e74704f 6c766c49 000017dd 00460046 00460046 006f0054  SAcc Disp Optn Ilvl .... F.F. F.F. T.o.
    060 0070004f 006e0065 2c2c0033 de00ff18 001600de 73676c46 64696644 6b73614d  O.p. e.n. 3.,, .... .... Flgs Dfid Mask
    080 20776f4c 68676948 62727441 63634153 70736944 6e74704f 6c766c49 00facedd  Low. High Atrb SAcc Disp Optn Ilvl ... 
StufferAC = s?
  StufferFloop 's' arg=
  StufferFloop '?' out if 0==00000000
SMB w/ NTOPEN&X after alignment Current size = a0 (160)
    000 424d53ff 000000a2 00000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB .... .... .... .... .... .... jj..
    020 6c00a218 00160000 73676c46 64696644 6b73614d 20776f4c 68676948 62727441  ...l .... Flgs Dfid Mask Low. High Atrb
    040 63634153 70736944 6e74704f 6c766c49 000017dd 00460046 00460046 006f0054  SAcc Disp Optn Ilvl .... F.F. F.F. T.o.
    060 0070004f 006e0065 2c2c0033 de00ff18 001600de 73676c46 64696644 6b73614d  O.p. e.n. 3.,, .... .... Flgs Dfid Mask
    080 20776f4c 68676948 62727441 63634153 70736944 6e74704f 6c766c49 eefacedd  Low. High Atrb SAcc Disp Optn Ilvl ....
MRxSmbStuffSetByteCount ByteCount=23
SMB w/ NTOPEN&X after filename replacement Current size = a0 (160)
    000 424d53ff 000000a2 00000000 00000000 00000000 00000000 fefebaba dead6a6a  .SMB .... .... .... .... .... .... jj..
    020 6c00a218 00160000 73676c46 64696644 6b73614d 20776f4c 68676948 62727441  ...l .... Flgs Dfid Mask Low. High Atrb
    040 63634153 70736944 6e74704f 6c766c49 000017dd 00460046 00460046 006f0054  SAcc Disp Optn Ilvl .... F.F. F.F. T.o.
    060 0070004f 006e0065 2c2c0033 de00ff18 001600de 73676c46 64696644 6b73614d  O.p. e.n. 3.,, .... .... Flgs Dfid Mask
    080 20776f4c 68676948 62727441 63634153 70736944 6e74704f 6c766c49 ee0017dd  Low. High Atrb SAcc Disp Optn Ilvl ....
-----------Data size = 16 (22)
    0a0 00690046 0065006c 006f0054 0070004f 006e0065 00000032                    F.i. l.e. T.o. O.p. e.n. 2.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\setup\install.txt ===
1) Copy rdbss.sys and mrxsmb.sys to system32\drivers directory.

2) copy the .ini/.bat files to the directory of your choice from the appropriate
   sub directory SUR/CAIRO.

3) run setup.bat -- This initializes the registry.

3) Reboot the system. The system will come up with the new rdr. The new rdr will be
active as long as it is correctly loaded / unloaded. If the new redirector
fails the workstation service switches over to the old redirector. In order
to switch over to the new redirector run the following command and reboot
        regini rdr2.ini

NOTE: Under Cairo the reboot is required because DFS keeps the Redirector
device open. Under SUR this in conjunction with net start/stop rdr toggles
between the old and the new one.

4) For CAIRO in order to switch to the old redirector use the following
   commands ..

   regini rdr.ini
   regini rdrdfs.ini

   and reboot.

   Similarly for the new redirector use the following commands

   regini rdr2.ini
   regini rdr2dfs.ini

   and reboot.



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\readme.txt ===
This directory contains the remote filesystems projects, contained in the remotefs_branch of this depot.

For further information, email udayh
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverfilter\driver.ini ===
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services
   EDFS
        ErrorControl =	REG_DWORD 0x1
	ImagePath = 	REG_EXPAND_SZ System32\drivers\dfs.sys
	Start = 	REG_DWORD 3
	Type = 		REG_DWORD 0x2
	Group =         REG_SZ filter
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\inc\tracewpp.ini ===
FUNC DFS_TRACE_HIGH{LEVEL=1}(FLAGS ,MSG,...);
FUNC DFS_TRACE_NORM{LEVEL=2}(FLAGS ,MSG,...);
FUNC DFS_TRACE_LOW{LEVEL=3}(FLAGS ,MSG,...);
FUNC DFS_TRACE_ERROR_HIGH{LEVEL=1}(ERROR,FLAGS,MSG,...);
FUNC DFS_TRACE_ERROR_NORM{LEVEL=2}(ERROR,FLAGS,MSG,...);
FUNC DFS_TRACE_ERROR_LOW{LEVEL=3}(ERROR,FLAGS,MSG,...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\sis\tools\placefil.txt ===
cf.exe                  sisTools
refCount.exe            sisTools
rpget.exe               sisTools
sisenum.exe             sisTools
sisSetup.exe            sisTools
volReparseTest.exe      sisTools
flink.exe               sisTools
sisInfo.exe             sisTools
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\daytonam\localwpp.ini ===
// wz and z types were moved to defaultwpp.ini.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\compact\sdk\readme.txt ===
Display and Alter the Compression of Files or Directories


The COMPACT tool compresses files on an NTFS drive.

Usage: 

COMPACT [/C | /U] [/S[:dir]] [/A] [/I] [/Q] [filename [...]]

/C       Compresses the specified directory or file.
/U       Uncompress the specified directory or file.
/S       Performs the specified operation on matching files in the
         given directory and all subdirectories. Default "dir" is 
         the current directory.
/A       Do not ignore hidden or system files.
/I       Ignore errors.
/F       Force the operation to compress or uncompress the 
         specified directory or file.
/Q       Be less verbose.
filename Specifies a pattern, file, or directory.

When used without parameters, COMPACT displays the compression state of the 
current directory. You may use multiple filenames and wildcards.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\fdisk\readme.txt ===
Building NT fdisk's boot code
                    -----------------------------


    The master boot code is contained in the file x86mboot.c, which is
#include'd into fd_nt.c.  The boot code is in the form of an array
(named x86BootCode) of unsigned chars, which is refered to by code in
fd_nt.c when fdisk needs to lay boot code on the disk.

    The x86mboot.c file is generated by different means depending on the
compilation host (ie, whether you're building on x86 or MIPS).


The following applies to x86 ONLY:
----------------------------------

    The master boot code is built from the x86mboot.asm and x86mboot.msg
files in i386 by running masm386 over these files to produce x86mboot.obj.

Then link_60 is run over x86mboot.obj to produce x86mboot.com. The boot code
is at offset 1280 in this file (1280 = 600h-100h.  600h is where the boot
code is assembled, and 100h is where a .com file is loaded by DOS.)  It is
of length 0x1be (512 byte sector - 64-byte partition table - signature word).

The tool bin2c.exe (in sdktoosl) is run over x86mboot.com to generate
i386\x86mboot.c.


The following applies to MIPS ONLY:
-----------------------------------

    On MIPS, the best we can do is check in the 'finished' product of the
x86 process, namely x86mboot.c, into the mips directory (we cannot run
masm386 or link_60 on MIPS!).  If, however, the i386\x86mboot.asm or .msg
files are newer than mips\x86mboot.c, then that means that someone changed
the boot code but did not check in the .c file to mips\x86mboot.c.  So we
generate an error message.

The correct action when receiving this error message is to go to an x86
machine, bget or build the i386\x86mboot.c file, and check that file
into mips\x86mboot.c.  Then sync on the MIPS machine.






    Our build process generates a -I parameter to the compiler based on
the compilation environement (ie, -Imips\ or -Ii386\).  This allows fdisk
to simply '#include "x86mboot.c"' and get either the generated file on x86
or the file under source control for MIPS.  This way we maintain at least
a semblance of the correct dependencies should the x86mboot.msg file be
translated, etc.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\halprof.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Corporation HalStartProfileInterrupt  TitleHalStartProfileInterrupt  Steve Deng Normal.dot Steve Deng Microsoft Word 10.0urn:schemas-microsoft-com:office:smarttags Month 0,yjR 0s(vp ZfFadg jcffiHal Profiling Functions  (Amd64 and X86) Version: 1.00 Date: July 1, 2002  1. Introduction 1.1 What Is Performance Monitoring Performance monitoring is a feature introduced in the Pentium processor. This feature allows counting of performance events through a set of model specific registers (MSRs). The information obtained can be used to optimize the performance of applications, system software and compilers. The event types that can be measured and the ways to measure them are processor dependent.  Microsoft Windows Hardware Abstraction Layers (HALs) support the Performance Monitoring for the Intel and Amd processors. This document only covers the HAL implementation on x86 and Amd64 platforms. 1.2. Overview of Performance Monitoring Implementations The performance monitoring mechanism is processor dependent and is not architectural. Listed below are the types of hardware implementations seen so far.  Pentium Processors Pentium processor provides one control and event select MSR (CESR) and two 40-bit performance counter MSRs (CTR0 and CTR1). There are 59 supported performance events. Two events can be monitored simultaneously. P6 Family Processors P6 family processors include Pentium Pro, Pentium II and III. The P6 family processors provide two 40-bit performance counters (PerfCtr0 and PerfCtr1) and two performance event select registers (PerfEvtSel0 and PerfEvtSel0). Compared with Pentium Processors, P6 s performance monitoring mechanism was enhanced to support a wider selection of events and with more flexible controls. Two events can be monitored simultaneously.  Pentium 4 and Xeon Pentium 4 and Xeon processors provide 45 event selection control registers (ESCR) MSRs, 18 performance counter MSRs, 18 counter configuration control (CCCR) MSRs, one IA32_MISC_ENABLE MSR and one IA32_DS_AREA MSR. In addition to a new set of performance events and a better control over the way of monitoring, Pentium 4 and Xeon processors support advanced features like Precise Event-Based Sampling (PEBS) which provides finer granularity in event counting of at-retirement events.  Amd x86-64  The performance monitoring mechanism of x86-64 is similar to that of P6 family processors. The differences are: The number of performance counters and event select registers is extended to 4. The resolution of performance counter register is extended to 48-bit x86-64 supports its own set of performance events.  2. HAL Profiling Functions A set of HAL functions is provided to facilitate drivers or system software to count the performance events.  HalStartProfileInterrupt  HalStopProfileInterrupt HalSetProfileInterval HalSetSystemInformation HalQuerySystemInformation HalStartProfileInterrupt  HalStartProfileInterrupt ( IN KPROFILE_SOURCE ProfileSource This function enables the monitoring of the hardware event specified by ProfileSource and setup registers to generate performance monitor interrupt (PMI) when the counter overflows. This routine must be called at PROFILE_LEVEL and is called on every processor. Parameters ProfileSource Indicates the source of the profiling.  Return Value HalStopProfileInterrupt  HalStopProfileInterrupt ( IN KPROFILE_SOURCE ProfileSource This function disables the monitoring of the event associated with ProfileSource on current processor. This routine must be called at PROFILE_LEVEL and is called on every processor. Parameters ProfileSource Indicates the source of the profiling.  Return Value HalSetProfileInterval  ULONG_PTR HalStopProfileInterrupt ( IN ULONG_PTR Interval This function sets the interrupt interval for ProfileTime. Parameters Interval Supplies the desired profile interval in 100ns units. Return Value The actual profile interval. HalSetSystemInformation  NTSTATUS HalSetSystemInformation ( IN HAL_SET_INFORMATION_CLASS InformationClass, IN ULONG BufferSize, IN PVOID   Buffer) This function sets HAL or OEM specific system information.  The type of information that is returned depends upon the InformationClass argument.  Parameters InformationClass Constant that describes the information pointed to by Buffer. BufferSize Size of the information pointed to by Buffer. Buffer HAL or OEM specific information described by InformationClass. Return Value STATUS_SUCCESS if the HAL successfully utilizes the information in Buffer. Comment We only cover the information related to performance monitoring here. When InformationClass is HalProfileSourceInterval, this function sets the interval for the specified profile source. The structure pointed by Buffer is defined as typedef struct _HAL_PROFILE_SOURCE_INTERVAL {     KPROFILE_SOURCE ProfileSource;     ULONG_PTR Interval; } HAL_PROFILE_SOURCE_INTERVAL, *PHAL_PROFILE_SOURCE_INTERVAL; When InformationClass is HalProfileSourceInterruptHandler, this function registers an interrupt handler, which is at the location pointed by buffer, for the performance-monitoring counter overflows. HalQuerySystemInformation  NTSTATUS HalQuerySystemInformation ( IN HAL_SET_INFORMATION_CLASS InformationClass, IN ULONG  BufferSize, IN OUT PVOID   Buffer, OUT PULONG   ReturnedLength This function returns HAL or OEM specific information to the caller.  The type of information that is returned depends upon the InformationClass argument. Parameters InformationClass Constant that describes the information pointed to by Buffer. BufferSize Size of the information pointed to by Buffer. Buffer HAL or OEM specific information described by InformationClass. ReturnSize Number of bytes of the information returned at Buffer. Return Value STATUS_SUCCESS if the HAL successfully returned in requested information in Buffer. Comment  We only cover the information related to performance monitoring here. When InformationClass is set to HalProfileSourceInformation, the requested data is returned at location pointed by Buffer in the format of HAL_PROFILE_SOURCE_INFORMATION.  typedef struct _HAL_PROFILE_SOURCE_INFORMATION {     IN OUT KPROFILE_SOURCE ProfileSource;     OUT BOOLEAN            Supported;     OUT ULONG              Interval; } HAL_PROFILE_SOURCE_INFORMATION, *PHAL_PROFILE_SOURCE_INFORMATION; 3. Implementation Notes 3.1 ProfileTime On x86 and Amd64 platforms, ProfileTime is not counted by performance counters. We can use either Time-Stamp Counter (TSC) or other system timers to count the occurrences of time events. Timer interrupt is also separate from performance monitor interrupt (PMI). For APIC systems, there is a separate local APIC interrupt for TSC Timer and performance monitor interrupt (PMI) respectively.  Because of these reasons we handle ProfileTime separately from other profile sources at a few places. 3.2 Interface to MSRs A set of private interface functions is introduced as an effort to hide the hardware differences from upper layer of code. These interface functions translate the performance monitoring requests into a sequence of platform dependent operations, including programming MSR registers.  Here is a list of these functions. HalpPriofileInterface.InitializeProfiling HalpPriofileInterface.EnableMonitoring HalpPriofileInterface.DisableMonitoring  HalpPriofileInterface.SetInterval  HalpPriofileInterface.CheckOverflowStatus  HalpPriofileInterface.QueryInformation InitializeProfiling NTSTATUS InitializeProfiling (     VOID     ) This function does one time initialization of the performance monitoring registers and data structures. This function is called on every processor. EnableMonitoring NTSTATUS EnableMonitoring ( KPROFILE_SOURCE ProfileSource This function enables the monitoring of the performance event specified by ProfileSource and set up MSRs to generate performance monitor interrupt (PMI) when the counter overflows. This routine is called at PROFILE_LEVEL on every processor. On Pentium 4 or Xeon this function does the following Select a performance counter to count the event specified by Source and an associated ESCR to select the events to be counted Set up an ESCR for the specific event to be counted. Set up the CCCR for the performance counter to be used to count the event, by selecting the chosen the ESCR and selecting the desired event filters. Set up the CCCR to generate a PMI when counter overflows. Enable the counter to begin counting. On P6 family processors and Amd s x86-64 this function does the following, Select a performance counter register to count the event  Initialize the selected counter register PerfCtr to its initial count Set up the associated PerfEvlSel register for the specific event to be counted and set EN flag and INT flag. DisableMonitoring DisableMonitoring ( KPROFILE_SOURCE ProfileSource This function disables the monitoring of the hardware event specified by ProfileSource and disables associated performance monitor interrupt (PMI). This routine is called at PROFILE_LEVEL on every processor. On Pentium 4 or Xeon this function does the following Located the CCCR register assigned to the specified event Clear the enable flag and OVF_PMI flag of the CCCR register On P6 family CPU or Amd x86-64, this function does the following Located the PerfEvlSel register assigned to the specified event Clear the EN flag and INT flag of the PerfEvlSel register associated with the selected counter SetInterval NTSTATUS SetInterval ( KPROFILE_SOURCE ProfileSource IN OUT ULONG_PTR *Interval This function adjusts the current interval to specified value. The actual Interval value get used will return to the caller through the pointer Interval. Usually the 2s complement negative value of the integer pointed by Interval will be set the counter register. CheckOverflowStatus CheckOverflowStatus ( OUT POVERFLOW_STATUS pOverflowStatus This function find out the overflowed counters and returns the total number and a array of related profile sources to the caller in following structure. typedef struct _OVERFLOW_STATUS {     ULONG Number;     KPROFILE_SOURCE *pSource; } OVERFLOW_STATUS, *POVERFLOW_STATUS;  On Pentium 4 or Xeon this function will examine the OVL flag of CCCR registers. Record the profile sources associated with overflowed counters to a buffer.  The address of this buffer will be returned to the caller through pSource. On P6 family CPU or Amd x86-64, this function will examine the current value of active counter registers. If a value is less than the initial value of this counter, record the associated profile source to a buffer.  The address of this buffer will be returned to the caller through pSource. QueryInformation   NTSTATUS QueryInformation ( IN HAL_QUERY_INFORMATION_CLASS InformationType, IN ULONG BufferSize, IN OUT PVOID Buffer, OUT PULONG ReturnedLength This is private version of HalQueryInformation. It retrieves the information of specified profile sources.  (See HalQueryInformation in this document for more details). 4. Consideration of Future Works  Performance monitoring mechanism is processor specific. One of the problems today is that this processor dependent knowledge is built into applications. We need to provide a way for applications to retrieve this type of information automatically at run time. Typically a performance tool needs to Enumerate a list of supported profile sources. Retrieve the attributes of each profile source, such as its name, the default interval value and the range of interval setting etc. Find out the number and the dependencies of the profile sources that could be monitored at same time.  Applications could behave more intelligently if it is well informed of the status and cause of failures. The current Hal profile functions don t even have a return code when it start or stop the profiling.   Most processors support the counting of performance events selectively in kernel and/or user mode. We can add this feature to Hal and user API if needed. We need to save/restore performance monitoring MSRs at power state transactions.  mbZbRb gdaV; gd).+ hGSf& gc_W_crcS hGSf& vrnvnj hJSf& mi]TKB wsosososksk {tj{c{ :paV;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\intfilter\howworks.txt ===
Interrupt Affinity Filter -- How it works:
==========================================

IntFiltr works by intercepting a specific PnP IRP that is passed to 
devices (IRP_MN_START_DEVICE).  

The filter looks at the (translated) resource list that is passed along 
with this IRP, and modifies the affinity mask (according to settings 
specified by the user) for any of the Interrupt resources in the device's 
resource list.  This modified IRP is then passed-on to lower drivers in 
the stack.  

As a result, lower drivers (which use entries in this resource list when 
setting up their ISRs) will get their ISRs installed only on the set of 
processors that the user has specified (via the IntFiltr configuration 
tool).  

The end result is that the APIC gets programmed to direct certain 
interrupts to certain subsets of the CPUs in the system (which can be 
verified by doing a "!ioapic" in the debugger).  

                    ------------------------------

NOTE: one of the main challenges in writing this filter was ensuring 
that it could be installed on _any_ device stack.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\intfilter\readme.txt ===
****************************************************************************
* Interrupt-Affinity Filter
* 
* Author: Chris Prince (t-chrpri@microsoft.com)
* Date:   Summer, 1999
****************************************************************************


DESCRIPTION:
============
This Interrupt-Affinity Filter (IntFiltr) allows a user to change the 
CPU-affinity of the interrupts in a system.  

Using this utility, you can direct any device's interrupts to a specific 
processor or set or processors (as opposed to always sending interrupts to 
all the CPUs in the system).  Note that different devices _can_ have 
different interrupt-affinity settings.  This utility will work on any 
machine, regardless of what processor or interrupt controller or HAL is 
used.  

Obviously, this tool is only interesting for multi-processor machines.  



USAGE:
======
There are 2 things that must be done in order to use IntFiltr.  These are: 

(1) Install the filter [only needs to be done once per machine]
(2) Configure the filter [whenever you want to change settings]



1. Installing the IntFiltr
--------------------------
To install IntFiltr, complete the following steps:

(a) Copy intfiltr.sys to your %SYSTEMROOT%\system32\drivers directory.
      [intfiltr.sys is located in the \Install subdirectory of this package]
(b) Update your registry to include the changes listed in intfiltr.reg
      To make these changes, you can just run 'regedit intfiltr.reg'.
      [intfiltr.reg is located in the \Install subdirectory of this package]
  

2. Configuring the IntFiltr
---------------------------
To configure IntFiltr, run intfiltr.exe (located in the \Config 
subdirectory of this package).  

First, highlight a device in the 'Devices' listbox.  Then you can use the 
'Add Filter' and 'Remove Filter' buttons to turn interrupt filtering on 
and off, respectively, for the selected device.  When IntFiltr is 
installed on a device, the string "InterruptAffinityFilter" will appear 
in the 'Upper Filters' listbox.  

You can use the 'Set Mask' button to set the CPU-affinity for the selected 
device's interrupts, or you can use the 'Delete Mask' button to remove a 
device's CPU-affinity mask from the registry.  Beware that if no 
CPU-affinity mask exists for a device, installing IntFiltr on a 
device will have no useful effect.  

The button marked "Don't Restart Device When Making Changes" is intended 
for advanced users.  You can use this button to change a device's filter 
settings without restarting the selected device.  Note that while this 
button is checked, any change you make will not take effect until the next 
time the device is restarted (which will usually not occur until the next 
reboot).  

IMPORTANT NOTE:  Although _all_ the machine's devices will appear in the 
'Devices' list, it only makes sense to install IntFiltr on top of devices 
that have interrupt resources.  To see which devices have interrupt 
resources, you can go into Device Manager and select View -> Resources By 
Type.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\mcasample\imca\halmca.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Intel Corp P6 MCA Architecture in Windows NT 3.51 HAL Title _PID_HLINKSP6 MCA Architecture in Windows NT 3.51 HAL Anil Aggarwal THESIS1.DOT Sean McGrane Microsoft Word 9.0TsG d @HP LaserJet 8100 Series PCL Ne00: winspool HP LaserJet 8100 Series PCL HP LaserJet 8100 Series PCL Letter DINU" HP LaserJet 8100 Series PCL Letter DINU"Intel Processors Machine Check Architectures in Microsoft Windows Intel Pentium  Pro Processor Machine Check Architecture  Implementation in Micrsoft Windows NT 4.0 Anil Aggarwal Intel Corporation IntroductionINTRODUCTION Microsoft Windows NT 4.0 generic HALHardware Abstraction Layers (HALs) for Intel Architectures (halx86, halapic, halmps, halia64)  support) supports the Machine Check Architectures (MCA) for  Intelthe Intel Pentium  Pro and Itanium processors Machine Check Architecture (MCA).. ThisThe HAL enables Machine Check Exception (MCE) reporting for all implementation defined errors.  2. Intel Pentium  Pro Processor Machine Check The mMachine cCheckl eException (MCE)MCE is processor exception 0x18h. The handler for Machine Check Exception is implemented as a task gate for maximum reliability of the exception handler..  The HAL provides a generic exception handler for all errors that cause an exception.  This handler reports the machine check exception code on the screen and causes the operating system to halt gracefully, reducing the possibility of persistent data corruption. In addition, the HAL also provides MCA specific interface that can be used by drivers to :to: rRead the MCA banks to detect anny error that diddoes not generate an exceptionMCE. One case where an error does not generate an any exception is if the bit controlling reporting of the machine check error for a specific bank (MCi_CTL.Eej) bit is turned offcleared. There are also some restartable errors that don t generate Machine Check Exception and are logged in the MCA banks. getObtain control (to possibly log errors to NVRAM) when the Machine Check exception handler getsis invoked by providing two callback routines - ExceptionCallback and DpcCallback Machine Check Exception Handling If the MCA exception handler detects only Intel Pentium  technology (style) MCE support on the platform, it does the following: If a MCA driver is registered with the HAL, call the MCA driver ExceptionCallback function providing the contents of P5_MC_ADDR and P5_MC_TYPE register values. This callback routine can log the register values in NVRAM and return. Call KeBugCheckEx() with the following 4 parameters to halt the system  Low  32 bits of P5_MC_TYPE MSR Always zero High 32 bits of P5_MC_ADDR MSR Low 32 bits of P5_MC_ADDR MSR Maybe we should describe the format of the bugcheck output on the screen? If MCA support (Pentium Pro processor) on the platform is detected, the exception handler determineschecks if the error is restartable. If not, it does the following: call the MCA Driver ExceptionCallback routine to give the MCA driver a chance to log the errors in NVRAM call KeBugCheckEx() with the following 4 parameters  to halt the system.  MCA Bank number that generated Machine Check exception Address field from MCi_ADDR MSR for this MCA bank High 32 bits of MCi_STATUS MSR for this MCA bank Low 32 bits of MCi_STATUS MSR for this MCA bank If the error is restartable, the exception handler requests the timer tick routine to queues a DPC which when called will reports the MCA bank error to the MCA Driver through the DpcCallback routine. 3. Intel Itanium  Processor Machine Check Machines checks, including Machine Check Aborts cause IA64 processor execution to vector to the Processor Abstraction Layer (PAL) PALE_CHECK code in the IA64 ISA.   HYPERLINK ""  When PALE_CHECK has finished processing, it passes control to the System Abstraction Layer (SAL) SAL_ENTRY code in the IA64 ISA, which in turn branches to the SAL MCA handler: SAL_CHECK.  Uncorrected machine checks refer to errors that cannot be corrected at PAL or SAL layers. These may still be fully or partially recoverable at the OS layer.  At that time, the control flow differs between corrected and uncorrected machine checks.  For corrected machine checks, the OS corrected error interrupt handlers will be invoked some time after returning to the interrupted process.  For uncorrected machine checks, SAL exposes an interface to register an OS_MCA callback. After validating this entry point, SAL_CHECK branches to it and provides the necessary information and conditionan Error Record that willo allow the OS to recover whenever possible. The amount of state information savedError Record passed by SAL is implementation-dependentmust comply, at a minimum, with the V3.0 SAL specification (January 2001), Appendix B,  Error Record Structures . The, implying that the HAL had to exposes interfaces for the OEMs to register a driver, and provides the Error Record to the driver. This enables the OEMs to assist  MCA handlers and to provide valid state information to these handlers so these might help the generic HAL MCA handler by attempting recovery of platform specific errors and maintaining the integrity of the platform.  For IA64 PAL, SAL and OS MCA handler s details, please refer to  HYPERLINK "http://www.intel.com/design/ia-64/manuals"  http://www.intel.com/design/ia-64/manuals TIn addition, the IA64 Reference HAL provides an MCA specific interface that can be used by drivers to: Register for delivery of an ExceptionCallback during non-corrected error processing. This callback returns an error severity value to the standard HAL OS_MCA, allowing OEM error recovery. The driver also registers a DpcCallback, which will be performed should the driver recover during ExceptionCallback processing. Register for delivery of two additional DpcCallback. These are delivered during corrected error processing for CPU Corrected errors and/or Platform corrected errors. Read the Error Records during DpcCallback processing.Read the MCA logs Obtain control when the Machine Check exception handler is invoked by providing two callback routines - ExceptionCallback and DpcCallback. The ExceptionCallback has also the capability of returning an error severity value to the standard HAL OS_MCA path to hint this path to continue or halt gracefully the platform. Machine Check Exception Handling After collecting the MCA log, the standard HAL MCA handler calls the MCA driver ExceptionCallback function providing the MCA record. This allows the MCA driver to process the log and makes appropriate consideration with regards to the stability of the system. This callback function returns to an error severity value to let the HAL know if it should consider the event as fatal, recoverable or corrected by the MCA driver. In case of a corrected event and if registered, the MCA driver DpcCallback is then called for asynchronous log collection by the driver. In case of an OS_MCA uncorrected event, the HAL calls KeBugCheckEx( ) with the bugcheck code MACHINE_CHECK_EXCEPTION and the following 4 parameters to halt the system HAL IA64 MCA type, which values could be:  HAL_BUGCHECK_MCA_ASSERT = 1, HAL_BUGCHECK_MCA_GET_STATEINFO  = 2, HAL_BUGCHECK_MCA_CLEAR_STATEINFO = 3, HAL_BUGCHECK_MCA_FATAL = 4.  This last value should be the expected one for the MCA driver, the other values being HAL internal error values. MCA log address MCA maximum log size SAL status of the last SAL interface. MCA INTERFACE FOR DRIVERS The Intel generic HalALs provides the following Intel Pentium  Pro and Itanium technology  MCA specific interface for drivers: HalSetSystemInformation with the HAL_QUERY_INFORMATION_CLASS parameter set to as HalMcaRegisterDriver.  This allows a driver  to register MCA driver callbacks with the HAL. Additionally the Itanium driver may use a HAL_QUERY_INFORMATION_CLASS parameter set to HalCmcRegisterDriver or HalCpeRegisterDriver for delivery of Corrected CPU errors (CMC) and Corrected Platform Errors (CPE). HalQuerySystemInformation with the HAL_QUERY_INFORMATION_CLASS parameter set toas HalMcaLogInformation.  This allows thea driver to read the MCA bank log. Additionally the Itanium driver may use a HAL_QUERY_INFORMATION_CLASS parameter set to HalCmcLogInformation or HalCpeLogInformation to read MCA logs from Corrected CPU errors (CMC) and/or Corrected Platform Errors (CPE). 243.1 HalSetSystemInformation to register MCA Driver NTSTATUS  HalSetSystemInformation( IN HAL_QUERY_INFORMATION_CLASS InformationClass, IN ULONG  BufferSize, OUT PVOID  Buffer, HalSetSystemInformation can be used to register MCA driver with the HAL Parameters InformationClass : Specify HalMcaRegisterDriver to register MCA driver s callback routines with the HAL. There are two callback routines- ExceptionCallback and DpcCallback routine. The ExceptionCallback Routine is called duringwhen the Machine Check Exception handlera non-restartable error is processingfound by the Machine Check Exception handler and it is going to , before it bugchecks the system. The DpcCallback routine is called for when the MCA error is restartable. For Itanium systems, specify  HalCmcRegisterDriver to register a driver s Corrected CPU Error DpcCallback routine, and HalCpeRegisterDriver to register a driver s Corrected Platform Error DpcCallback. errors that generated the Machine Check Exception. BufferSize : Specifies the size in bytes of the buffer supplied by the caller. Buffer : Pointer to a caller-supplied buffer of type MCA_DRIVER_INFO with   // Structure to record the callbacks from driver typedef struct _MCA_DRIVER_INFO {     PDRIVER_EXCPTN_CALLBACK ExceptionCallback;  -  NULL for Itanium corrected error registration     PKDEFERRED_ROUTINE      DpcCallback;     PVOID                   DeviceContext; } MCA_DRIVER_INFO, *PMCA_DRIVER_INFO; ExceptionCallback is the driver supplieddriver-supplied routine to be called when Machine Check Exception occurs for non-restartable errors. The only thing driver is allowed to do at that point is to log the information in NVRAM.  A driver explicitly may not utilize any kernel services or spinlock routines.  The handler is restricted to the same constraints as a driver operating at highest IRQL. DpcCallback is athe driver supplieddriver-supplied routine that getsis called for restartable errrors that caused Machine Check Exception. This routine will be called at DISPATCH_LEVEL. (Comment:  Restartable errors, by definition, do not cause MCE) DeviceContext is the Device specific context for this MCA Driver. Include ntddk.h Return Value HalSetSystemInformation returns STATUS_SUCCESS if the registration is successful. Comments HalSetSystemInformation must be called before any of the other interface routines can be used by a MCA drivera MCA driver can use any of the other interface routines. Only one MCA driver can be registered with the HAL at any time. The exception callback routine or the DPC callback routine parameters cannot be NULL.. 243.2 HalQuerySystemInformation to get MCA bank logs NTSTATUS  HalQuerySystemInformation( IN HAL_QUERY_INFORMATION_CLASS InformationClass, IN ULONG  BufferSize, OUT PVOID  Buffer, OUT PULONG  ReturnedLength HalQuerySystemInformation can be used to read MCA banks status registers Parameters InformationClass : Specify HalMcaLogInformation to read the current MCA error reporting banks log.  If any uncorrected Machine Check error is found, it is returned in the buffer. For Itanium systems, specify HalCmcLogInformation to read the current Corrected CPU Error Log and HalCpeLogInformation to read the current Corrected Platform Error Log BufferSize : Specifies the size in bytes of the buffer supplied by the caller. Buffer : Points to a caller-supplied buffer of type MCA_EXCEPTION that will contain the information returned by this routine. For Itanium, the returned information will be compliant, at a minimum, with the V3.0 SAL specification (January 2001), Appendix B,  Error Record Structures . For Pentium Pro, the information is as described below. typedef union _MCI_STATS { structstruct {     USHORT McaCod;     USHORT MsCod;     ULONG OtherInfo  : 25;     ULONG Damage     ULONG AddressValid     ULONG MiscValid     ULONG Enabled     ULONG UnCorrected     ULONG OverFlow     ULONG Valid } MciStats; ULONGLONG QuadPart; } MCI_STATS, *PMCI_STATS; typedef union _MCI_ADDR{ struct { ULONG Address; ULONG Reserved; } MciAddr; ULONGLONG QuadPart; } MCI_ADDR, *PMCI_ADDR; typedef struct _MCA_EXCEPTION { ULONG VersionNumber; // Version number of this record type MCA_EXCEPTION_TYPE ExceptionType; // MCA or MCE LARGE_INTEGER  TimeStamp; // exception recording timestamp ULONG ProcessorNumber;// processor number union { struct { UCHAR BankNumber; // bank number MCI_STATS Status;      MCI_ADDR Address; ULONGLONG Misc; } Mca; struct { ULONGLONG McAddress; // physical address for the cycle causing the error ULONGLONG McType;  // cycle specification causing the error } Mce; } MCA_EXCEPTION, *PMCA_EXCEPTION; ReturnedLength : Specifies the number of bytes returned in Buffer. Include ntddk.h Return Value HalQuerySystemInformation returns STATUS_SUCCESS if an error log existserror was detected on one of the error reporting MCA banks., The following information is returned: Processor number that had the error in ProcessorNumber MCA bank number that had the error in BankNumber the contents of MCi_STATUS register in Status MCi_ADDR in Address (if Status.. MciStats ..AddressValid is set) MCi_MISC in Misc (if Status.. MciStats MiscValid is set) Time stamp in TimeStamp Comments This function returns as soon as it detects the firstone error. It is the MCA driver responsibility to call this routine again to see if there isare any more errors available.  This routine will clear the valid bit for any machine check bank that reports an error. PAGE   PAGE   {tm{f{f{f J&0Jy {f_XQJQC< dh!|* dh!|*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\mcasample\mcamgmt\owner.txt ===
Owner: Abdullah Ustuner (AUstuner)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\ems\sac\sacrunner\how 2 use.txt ===
SacRunner	[[-I] <input filename>] [-L <normal log filename>] [-NTL nt-log filename] [-BVTL bvt-log filename] [-D <output files directory>]
		[-C <<comma separated connection params>>]

<<comma separated connection params>> -> <com port name>, <baud rate>, <byte size>, <parity>, <stop bits>

ex. -C COM1, 9600, 8, 0, 1

invoke it w/ params like:
SacRunner.exe test.sac -V -LLastSacLog.log -D out -C COM1, 9600, 8,0, 1 -BVTL sacrunner.log.bvt.txt

u can also call the following batch to run it
RunSacRunner.cmd
// call that from the SacRunner Root Dir. with the bin. in bin\i386
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\ems\sac\sacrunner\out\index.txt ===
whatever sac echoed back in return to the command is here

file r in the form: L<x>_C<y>.out
; where x is the line # in the sac command file and y is the count

// make sure that u have the -D<output-dir> option for the sacrunner
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\driver_match\readme.txt ===
1. run sbucket.sql where you substitute in the bucketid you care about.  
 do "results to grid", then save the result set to a file data.<bucketid>.csv in the same dir as all the scripts.

2. run doit.cmd <bucketid>
 make sure perl is in your path, as well as the scripts and dm.exe
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\bin86\system.ini ===
; for 16-bit app support
[386Enh]
woafont=dosapp.fon
EGA80WOA.FON=EGA80WOA.FON
EGA40WOA.FON=EGA40WOA.FON
CGA80WOA.FON=CGA80WOA.FON
CGA40WOA.FON=CGA40WOA.FON

[drivers]
wave=mmdrv.dll
timer=timer.drv

[mci]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\bin86\chs\system.ini ===
; for 16-bit app support
[386Enh]
woafont=app936.fon
EGA80WOA.FON=EGA80WOA.FON
EGA40WOA.FON=EGA40WOA.FON
CGA80WOA.FON=CGA80WOA.FON
CGA40WOA.FON=CGA40WOA.FON

[drivers]
timer=timer.drv

[mci]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\bin86\cht\system.ini ===
; for 16-bit app support
[386Enh]
woafont=app950.fon
EGA80WOA.FON=EGA80WOA.FON
EGA40WOA.FON=EGA40WOA.FON
CGA80WOA.FON=CGA80WOA.FON
CGA40WOA.FON=CGA40WOA.FON

[drivers]
timer=timer.drv

[mci]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\bin86\chp\system.ini ===
; for 16-bit app support
[386Enh]
woafont=app936.fon
EGA80WOA.FON=EGA80WOA.FON
EGA40WOA.FON=EGA40WOA.FON
CGA80WOA.FON=CGA80WOA.FON
CGA40WOA.FON=CGA40WOA.FON

[drivers]
timer=timer.drv

[mci]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\bin86\jpn\system.ini ===
; for 16-bit app support
[386Enh]
woafont=app932.fon
EGA80WOA.FON=EGA80WOA.FON
EGA40WOA.FON=EGA40WOA.FON
CGA80WOA.FON=CGA80WOA.FON
CGA40WOA.FON=CGA40WOA.FON

[drivers]
timer=timer.drv

[mci]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\bin86\kor\system.ini ===
; for 16-bit app support
[386Enh]
woafont=app949.fon
EGA80WOA.FON=EGA80WOA.FON
EGA40WOA.FON=EGA40WOA.FON
CGA80WOA.FON=CGA80WOA.FON
CGA40WOA.FON=CGA40WOA.FON

[drivers]
timer=timer.drv

[mci]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\command\readme.txt ===
This directory contains source files for COMMAND.COM, including
internal commands.

A list of the internal commands, some characteristics, and hints
about where they're found appears in TDATA.ASM, labelled COMTAB.

COMSEG.ASM contains a brief description of each segment in
COMMAND.COM.

  TRANDATA contains data which doesn't usually change, so is
  included in the transient checksum area, while TRANSPACE is
  modifiable, and excluded from the transient checksum.  TRANSPACE
  variable should be treated as uninitialized data for every
  command cycle.

----------------------------------------------------------------------

Here's a listing of the general contents of files,
concentrating on central functions and publics in each module.

Sizes are approximate and probably obsolete by the time you
read this.


Name         Size     Contents
            (000's)

COMEQU   ASM  10   Command.com equates, structures, macros.
COMMAND1 ASM  19   Main header & some resident code: 
		    command.com entry point; exec call; ctrl/c handler.
COMMAND2 ASM  14   Resident code: alloc mem, load, & checksum transient;
		    int 2E (single command line execute) entry point;
		    check for removable media (callable by transient);
		    save user's stdin/out & set to stderr; restore stdin/out;
		    clean up program header, closing files;
		    set terminate, ctrl/c, disk error 'interrupt' vectors;
		    move environment to new segment at end of init.
COMSEG   ASM   1   All segments, in load order.
COMSW    ASM       Build switches: refers to version.inc.
COPY     ASM  28   COPY command.
COPYPR1  ASM   6   Routines for COPY command.
COPYPR2  ASM  10   Routines for COPY command.
CPARSE   ASM   9   Command-line parse routine.
DIR      ASM  73   DIR command.
ENVDATA  ASM       Default environment data definitions.
FORDATA  ASM       A data definition for FOR loop routine (tfor.asm).
IFEQU    ASM       'Equates which are switch-dependent' (none here).
INIT     ASM  47   Command.com initialization routine.
IPARSE   ASM       SYSPARSE equates (this file is probably obsolete).
PARSE2   ASM  13   Command-line parse routines, argv style.
PATH1    ASM  16   Pathname invocation (find an executable or batch file).
PATH2    ASM  13   See PATH1.
RDATA    ASM  17   Resident data definitions.
RUCODE   ASM  19   Language-dependent resident code:
		    ctrl/c batch termination dialog;
		    int 24 disk error handler;
		    DBCS lead byte check ITESTKANJ;
		    reset parse & critical error message ptrs before exiting;
		    RPRINT message printer.
TBATCH   ASM  26   Batch processing routines.
TBATCH2  ASM  15   Batch processing routines.
TCMD1A   ASM  17   Obsolete DIR command.  Module no longer used.
TCMD1B   ASM  20   PAUSE, DEL, RENAME, TYPE, VOL commands.
		    Find & print volume label & serial #.
		    Get/set a file's code page;
		    Set extended error message pointer;
		    Get extended error number.
TCMD2A   ASM  12   VER, CLS command.
		    Support routines for transient:
		    build directory strings; print things.
TCMD2B   ASM  18   CTTY, CHCP, TRUENAME commands.
		    Parse routines to set up error messages.
TCODE    ASM  13   Main entry points to transient.
TDATA    ASM  21   Transient data:  internal command table;
		    parse control blocks; miscellaneous.
TENV     ASM  13   PROMPT, SET commands.  Environment utilities.
		    Restore user directory.
TENV2    ASM  14   CHDIR, MKDIR, RMDIR commands.  Path crunch.
		    Save user directory.
TFOR     ASM  15   FOR loop processing.
TMISC1   ASM  15   Old switch parser; find & execute commands;
		    prescan command-line, removing pipes & redirects;
		    Error recycle point for command.com.
TMISC2   ASM  10   Examine pathname, set up pathname argument.
		    Move string to srcbuf.
		    Set up error message for extended error.
		    Some redirection stuff (IOSET).
TPARSE   ASM   1   Transient interface to system parser SYSPARSE.
TPIPE    ASM  17   Pipe stuff.  DATE, TIME commands.
		    Check for single command execute.
		    Set flag (in resident) to restore default directory.
TPRINTF  ASM  11   Set up and print messages, with substitutions.
TRANMSG  ASM  20   Transient messages and substitution blocks.
TSPC     ASM  11   Transient 'uninitialized' data.
TUCODE   ASM  14   Transient 'modifiable' code:
		    verification prompts for DEL;
		    ECHO, BREAK, VERIFY commands;
		    print date;
UINIT    ASM   7   Data definitions/messages for initialization.
		    Includes parse control block for COMMAND command.
COMMAND  CL1   2   Messages, class 1.  Automatically generated.
COMMAND  CL2   1   Messages, class 2.  Automatically generated.
COMMAND  CL3   1   Messages, class 3.  Automatically generated.
COMMAND  CL4   1   Messages, class 4.  Automatically generated.
COMMAND  CLA   8   Messages, class A.  Automatically generated.
COMMAND  CLB   2   Messages, class B.  Automatically generated.
COMMAND  CLC   3   Messages, class C.  Automatically generated.
COMMAND  CLD   5   Messages, class D.  Automatically generated.
COMMAND  CLE   7   Messages, class E.  Automatically generated.
COMMAND  CLF  18   Messages, class F.  Automatically generated.
COMMAND  CTL       Number of message classes.  Automatically generated.
RESMSG   EQU   2   Message number equates for resident and init code.
COMMAND  LNK       LINK input file.
COMMAND  SKL  10   Message skeleton file.
README   TXT	   This file.

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\cmd\setver\setver.doc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


                        SETVER Command overview
			MS-DOS 5.00
			05/13/90

SETVER is an external MS-DOS command which allows the user to
determine the MS-DOS version number will be reported by MS-DOS
to a specified user application. This will allow applications
which check for a specific version of MS-DOS to run under
MS-DOS 5.0.

A version table has been included as part of the MS-DOS system
files on the user's boot disk. SETVER will update the system
files so that next time and times thereafter, that MS-DOS is
booted, the updated version table will be in effect. NOTE: The
changes to the version table will not take effect until the
user reboots using the updated version of the table.


NOTE:
	Currently there is 512 bytes set aside for entries in the
	table but Ericst may want to up it in the near future so
	for right now I wouldn't mention the number of entries
	which the table will hold. Right now it will hold a minimum
	of 34 entries.

==========================================================================

USEAGE:
		List table:	SETVER [D:]
		Add entry:	SETVER [D:] name.ext N.NN
		Delete entry:	SETVER [D:] name.ext /DELETE
		Display help	SETVER /?

WHERE:
		D: is the drive containing MSDOS.SYS
		name.ext is the executable file name
		N.NN is the major and minor version numbers
		/DELETE is any combination of /D - /DELETE

==========================================================================

MESSAGES:

	If the table is being updated and there are no errors detected
	this message will be displayed.

	"Version table successfully updated"

	If the version table is only being displayed it will listed
	on the screen in the format:

	WIN200.BIN     3.30
	EXCEL.EXE      4.01
	MYPROG.EXE     3.20
	DELNODE.EXE    4.01
	

==========================================================================

EXAMPLE 1:

	SETVER a: excel.exe 4.01

	This example will add a new entry in the table for EXCEL.EXE
	to the version table on drive A: and will tell DOS to always
	report the MS-DOS version number 4.01 to this application.

EXAMPLE 2:

	SETVER	a: excel.exe /DELETE

	This example will delete the EXCEL.EXE entry from the version
	table on drive A:.

EXAMPLE 3:

	SETVER

	This example will list the contents of the version table
	on the current drive.

EXAMPLE 4:

	SETVER /?

	This example will cause the SETVER command to display
	help in using the command.

==========================================================================

RETURN CODES:
	0  Successful completion
	1  Invalid command switch
	2  Invalid file name specified
	3  Insuffient memory
	4  Invalid version number format
	5  Specified entry was not found in table
	6  MS-DOS system files not found
	7  Invalid drive specifier
	8  Too many command line parameters
	9  Missing parameters
	10 Error reading MS-DOS system files
	11 Version table is corrupt in system files
	12 Specifed MS-DOS system files do not support a version table
	13 Insuffient space in version table for new entry
	14 Error writing MS-DOS system files


==========================================================================

ERROR MESSAGES:

ERROR:  Invalid switch

	The user specified an invalid command line switch.

ERROR:  Invalid file name

	The user specified an invalid file name for a new
        version table entry. Possible causes are the specified
        file name did not follow standard MS-DOS file naming
	conventions or was a reserved MS-DOS file name

ERROR:  Insuffient memory

	There is insuffient memory for the program to run.

ERROR:  Invalid version number format must be 2.11 - 9.99

	An invalid version number was specified. Possible causes
	of this are that the specified version number was not in
	the proper format or it was less than 2.11 or greater than
	9.99.

ERROR:  Specified entry was not found in the version table

	The tried to delete an entry which was not in the existing
	version table.

ERROR:  File MSDOS.SYS not found on specified drive

	The user specified a drive which does not contain MS-DOS
	system files.

ERROR:  Invalid drive specifier

	The user specified a drive that does not exist.

ERROR:  Too many command line parameters

	The user specifed too many command line parameters such as
	by specifing both a version number and the /DELETE switch.

ERROR:  Missing parameter

	The user entered a file name but forgot to include either
	a version number or the /DELETE switch.

ERROR:  Reading MS-DOS system file

	There was an error trying to read the system files on the
	specified drive. Possible cause is that the specified drive
	does not contain system files.

ERROR:  Version table is corrupt

	An error was detected in the version table and it is not
	useable. The user should replace the system files on that
	disk and try again.

ERROR:	System files on the specifed drive do not support a version table

	The user specified a drive which contains MS-DOS system files
	which at not version 5.0 or above.

ERROR:  Insuffient space in version table for new entry

	The version table on the specified drive is full. The user can
	delete some entries from the table and try again.
	NOTE:	To be sure of room for the new entry the user should be
		sure that the entry that is deleted has a file name
		at least as long as the new entry.

ERROR:  Writing MS-DOS system file
	
	There was an error while trying to write the updated version
	version table. This would be caused by a bad disk.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\doskrnl\dos\dispatch.txt ===
;	SCCSID = @(#)dispatch.asm	1.1 85/04/10
;	SCCSID = @(#)dispatch.asm	1.1 85/04/10
;
; Major dispatch code and table for MSDOS 2.X and above.
;
;   Modification history:
;
;	Created: MZ 30 March 1983
;
; The system calls are dispatched to in such a fashion as to have their entire
; register set passed to them except for CS:IP and SS:SP.  This reduces the
; need for retreiving information from the user's stack.
;
; There are also critical sections that need to be observed when running in a
; multitasking environment.  These sections are:
;
;   1	critDisk    any of the disk code that will twiddle the buffer cache
;   2	critDevice  all device drivers
;
;   4	critMem     memory allocation stuff
;   5	critNet     network critical section
;
; The system calls below are noted as to which of these critical sections they
; belong.  The critical sections are noted in the source files by the macros
; EnterCrit and LeaveCrit.
;
; The break-down of the individual system calls into source files is as
; follows (* means done):
;
;   *	handle.asm:	Close, Read, Write, LSeek, XDup, XDup2, FileTimes
;	IOCTL.INC:	IOCTL
;   *	file.asm:	Open, Creat, ChMod, Unlink, Rename, CreateTemp,
;			CreateNew
;   *	srvcall.asm:	$ServerCall
;   *	path.asm:	MkDir, RmDir, ChDir, CurrentDir
;   *	alloc.asm:	$Alloc, $Dealloc, $SetBlock, $AllocOper
;			arena_free_process, arena_next -> LOW LEVEL <-
;			check_signature, Coalesce
;   *	search.asm:	DirSearchFirst, DirSearchNext, FindFirst, FindNext,
;			PackName		 -> LOW LEVEL <-
;   *	proc.asm:	Exec, Exit, Abort, Wait, KeepProcess
;   *	cpmio.asm:	StdConInput, StdConOutput, StdAuxInput, StdAuxOutput,
;			StdPrinterOutput, RawConIO, RawConInput,
;			StdConInputNoEcho, StdConStringInput,
;			StdConStringOutput, StdConInputStatus,
;			StdConInputFlush
;			OUT, BUFOUT, RAWOUT, RAWOUT2	-> LOW LEVEL <-
;   *	fcbio.asm:	FCBOpen, FCBClose, FCBDelete, FCBSeqRead, FCBSeqWrite,
;			FCBCreate, FCBRename, FCBRandomRead, FCBRandomWrite,
;			GetFCBFileLength, GetFCBPosition, FCBRandomReadBlock,
;			FCBRandomWriteBlock
;   *	Time.asm:	GetDate, SetDate, GetTime, SetTime
;   *	Parse.asm:	Parse_file_descriptor, PathParse
;   *	GetSet.asm:	GetInterruptVector, SetInterruptVector,
;			GetVerifyOnWrite, SetVerifyOnWrite, GetDMA, SetDMA,
;			GetVersion, SetCTRLCTrapping, GetDriveFreespace,
;			CharOper, International, SetDefaultDrive,
;			GetDefaultDrive
;   *	Misc.asm:	Sleazefunc, SleazefuncDL, GetDefaultDPB, GetDPB,
;			CreateProcessDataBlock, GetINDOSFlag, GetInVars,
;			SetDPB, DupPDB, DiskReset
;			StrCmp, StrCpy, Ucase		 -> LOW LEVEL <-
;
; STUB MODULES
;	Net.asm 	**** This will get broken down more???
;   *	Share.asm	Share_Check, Share_Violation
;   *	Lock.asm	$LockOper
;			DOS_LOCK,DOS_UNLOCK,Lock_Check, Lock_Violation

; INTERNAL INTERFACE MODULES
;   *	Lock.asm	DOS_LOCK, DOS_UNLOCK   -->> STUBS <<--
;   *	Dinfo.asm	DISK_INFO
;   *	Finfo.asm	GET_FILE_INFO, SET_FILE_ATTRIBUTE
;   *	Create.asm	DOS_CREATE, DOS_CREATE_NEW,
;			Set_Mknd_Err	       --> Low level routine <--
;   *	Dup.asm 	DOS_DUP
;   *	Open.asm	DOS_OPEN,
;			SetBadPathError,       --> Low level routines <--
;			Check_Access_AX, Share_Error, Set_SFT_Mode
;   *	Close.asm	DOS_CLOSE, DOS_COMMIT, DOS_CLOSE_GOT_SFT,
;			Free_SFT	       --> Low level routine <--
;   *	Abort.asm	DOS_ABORT
;   *	ISearch.asm	DOS_SEARCH_FIRST, DOS_SEARCH_NEXT,
;			RENAME_NEXT	       --> Low level routine <--
;   *	Dircall.asm	DOS_MKDIR, DOS_CHDIR, DOS_RMDIR
;   *	Rename.asm	DOS_RENAME
;   *	Delete.asm	DOS_DELETE,
;			REN_DEL_Check	       --> Low level routine <--
;   *	Disk.asm	DOS_READ, DOS_WRITE

; LOW LEVEL MODULES
;   *	Fat.asm 	UNPACK, PACK, MAPCLUSTER, FATREAD_SFT,
;			FATREAD_CDS, FAT_operation
;   *	Ctrlc.asm	--> STD/IBM versions <--
;			FATAL, FATAL1, reset_environment, DSKSTATCHK,
;			SPOOLINT, STATCHK, CNTCHAND, DIVOV, RealDivOv,
;			CHARHARD, HardErr
;   *	Buf.asm 	SETVISIT, ScanPlace, PLACEBUF, PLACEHEAD, PointComp,
;			GETBUFFR, GETBUFFRB, FlushBuf, BufWrite,
;			SKIPVISIT
;   *	Disk.asm	SWAPBACK, SWAPCON, get_io_sft, DirRead, FATSecRd,
;			DskRead, SETUP, BREAKDOWN, DISKREAD, DISKWRITE,
;			FIRSTCLUSTER, DREAD, DWRITE, DSKWRITE,
;			READ_LOCK_VIOLATION, WRITE_LOCK_VIOLATION,
;			SETSFT, SETCLUS, AddRec
;   *	Mknode.asm	BUILDDIR, SETDOTENT, MakeNode, NEWENTRY, FREEENT,
;			NEWDIR, DOOPEN,RENAME_MAKE
;   *	FCB.asm 	MakeFcb, NameTrans, PATHCHRCMP, GetLet, TESTKANJ,
;			NORMSCAN, CHK, DELIM
;   *	Rom.asm 	GET_random_record, GETRRPOS1, GetRRPos, SKPCLP,
;			FNDCLUS, BUFSEC, BUFRD, BUFWRT, NEXTSEC,
;			OPTIMIZE, FIGREC, GETREC, ALLOCATE, RESTFATBYT,
;			RELEASE, RELBLKS, GETEOF
;   *	Dev.asm 	IOFUNC, DEVIOCALL, SETREAD, SETWRITE, GOTDPB,
;			DEVIOCALL2, DEV_CLOSE_SFT, DEV_OPEN_SFT
;   *	Dir.asm 	SEARCH, SETDIRSRCH, GETPATH, ROOTPATH, StartSrch,
;			MatchAttributes, DEVNAME, Build_device_ent,
;			FindEntry, Srch, NEXTENT, GETENTRY, GETENT,
;			NEXTENTRY, GetPathNoSet, FINDPATH
;

; critical section information for the system calls

;   System Call 		      Who takes care of the reentrancy
;   Abort			   0	(flushbuf) DOS_Close
;   Std_Con_Input		   1	DOS_Read
;   Std_Con_Output		   2	DOS_Write
;   Std_Aux_Input		   3	DOS_Read
;   Std_Aux_Output		   4	DOS_Write
;   Std_Printer_Output		   5	DOS_Write
;   Raw_Con_IO			   6	DOS_Read/DOS_Write
;   Raw_Con_Input		   7	DOS_Read
;   Std_Con_Input_No_Echo	   8	DOS_Read
;   Std_Con_String_Output	   9	DOS_Write
;   Std_Con_String_Input	   A	DOS_Read
;   Std_Con_Input_Status	   B	DOS_Read
;   Std_Con_Input_Flush 	   C	DOS_Read
;   Disk_Reset			   D	(FlushBuf, ScanPlace, SkipVisit)
;   Set_Default_Drive		   E	*none*
;   FCB_Open			   F	DOS_Open
;   FCB_Close			  10	DOS_Close
;   Dir_Search_First		  11	DOS_Search_First
;   Dir_Search_Next		  12	DOS_Search_Next
;   FCB_Delete			  13	DOS_Delete
;   FCB_Seq_Read		  14	DOS_Read/DOS_Write
;   FCB_Seq_Write		  15	DOS_Read/DOS_Write
;   FCB_Create			  16	DOS_Create
;   FCB_Rename			  17	DOS_rename
;   Get_Default_Drive		  19	*none*
;   Set_DMA			  1A	*none*
;   Get_Default_DPB		  1F	*none*
;   FCB_Random_Read		  21	DOS_Read/DOS_Write
;   FCB_Random_Write		  22	DOS_Read/DOS_Write
;   Get_FCB_File_Length 	  23	Get_file_info
;   Get_FCB_Position		  24	*none*
;   Set_Interrupt_Vector	  25	*none*
;   Create_Process_Data_Block	  26	*none*
;   FCB_Random_Read_Block	  27	DOS_Read/DOS_Write
;   FCB_Random_Write_Block	  28	DOS_Read/DOS_Write
;   Parse_File_Descriptor	  29	*none*
;   Get_Date			  2A	DEVIOCALL
;   Set_Date			  2B	DEVIOCALL
;   Get_Time			  2C	DEVIOCALL
;   Set_Time			  2D	DEVIOCALL
;   Set_Verify_On_Write 	  2E	*none*
;   Get_DMA			  2F	*none*
;   Get_Version 		  30	*none*
;   Keep_Process		  31	$abort...
;   Get_DPB			  32	*none*
;   Set_CTRL_C_Trapping 	  33	*none*
;   Get_InDOS_Flag		  34	*none*
;   Get_Interrupt_Vector	  35	*none*
;   Get_Drive_Freespace 	  36	Disk_Info
;   Char_Oper			  37	*none*
;   International		  38	*none*
;   MKDir			  39	DOS_MkDir
;   RMDir			  3A	DOS_RmDir
;   CHDir			  3B	DOS_ChDir
;   Creat			  3C	DOS_Create
;   Open			  3D	DOS_Open
;   Close			  3E	DOS_Close
;   Read			  3F	DOS_Read
;   Write			  40	DOS_Write
;   Unlink			  41	DOS_Delete
;   LSeek			  42	*none*
;   CHMod			  43	Get_file_info, Set_File_Attribute
;   IOCtl			  44	DEVIOCALL
;   XDup			  45	*none*
;   XDup2			  46	*none*
;   Current_Dir 		  47	$Current_Dir
;   Alloc			  48	$Alloc
;   Dealloc			  49	$Dealloc
;   Setblock			  4A	$SetBlock
;   Exec			  4B
;   Exit			  4C	$abort...
;   Wait			  4D	*none*
;   Find_First			  4E	DOS_Search_First
;   Find_Next			  4F	DOS_Search_Next
;   Set_Current_PDB		  50	*none*
;   Get_Current_PDB		  51	*none*
;   Get_In_Vars 		  52	*none*
;   SetDPB			  53	*none*
;   Get_Verify_On_Write 	  54	*none*
;   Dup_PDB			  55
;   Rename			  56	DOS_Rename
;   File_Times			  57	*none*
;   AllocOper			  58	*none*
;   GetExtendedError		  59	*none*
;   CreateTempFile		  5A	DOS_Create_New
;   CreateNewFile		  5B	DOS_Create_New
;   LockOper			  5C
;   ServerCall			  5D
;   UserOper			  5E
;   AssignOper			  5F
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\v86\tools\src\h2inc\h2inc.doc ===
/*	static char *SCCSID = "@(#) h2inc.doc 13.1 88/11/01" */

	H2INC - .H to .INC file translation program

This program produces .INC files from .H files.  It handles hex and decimal
constant definitions (both word and long), structures, bitfields, and
comments.  It has some trouble with certain kinds of #define statements, but
it currently handles everything interesting in the various internal and public
Winthorn files.

		    COMMAND FORM

    h2inc [-t] [-c] [-g] [-s symfile] file.h [-o outfile]

Example:

    h2inc -s os2def.h -s os2win.h user.h


Translates file.h to an .inc file, sending output to outfile.inc if specified,
or to stdout.  symfile.h is a file to be scanned for typedefs that are used
by file.h.  One or more of "-s symfile.h" may be specified.

The '-c' option retains comments. Default action is to strip comments.
The '-g' option is described later on in this document.
The '-t' option retains the use of the Hungarian tag prepended to structure
element names.  This is not always desired.


		    COMPILER DIRECTIVES

The #undef directive is ignored.  #include is handled by mapping to
the masm include statement.  The quote or angle bracket delimiters are
removed, and any extension is replaced by ".inc":

    #include "file.h"		->  include file.inc
    #include <file.ext>		->  include file.inc

Directives such as #ifdef, #if, #else and #endif are replaced by their
MASM equivalents.

Simple empty #defines are handled by assigning the constant the value of 1:

    #define INCL_GPIINCLUDED	->  INCL_GPIINCLUED equ 1



		    CONSTANTS

h2inc understands hex, octal and decimal constants, both 16 and 32 bits.
Constants in parens or preceded by casts are generally handled pretty well.
Here are some examples illustrating how various constants are translated:

    #define LONG_CONSTANT	0x12345678L
    #define LONG_CONSTANT2	333L
    #define WORD_CONSTANT	0x234
    #define DEC_CONSTANT	(-1)
    #define LONG_DEC_CONSTANT	(-4L)

produces:

    LONG_CONSTANT		equ 012345678H
    LONG_CONSTANT2		equ 333
    WORD_CONSTANT		equ 0234H
    DEC_CONSTANT		equ (-1)
    LONG_DEC_CONSTANT		equ (-4)

	'>>', '<<' and '!' are translated to SHR, SHL and NOT respectively.
	'&' and '|' are translated to AND and OR.

	When a type cast is uncovered,  it is blanked out.  Type casts are
	defined as ([ ]XXX[ ][*][ ]) where XXX is a type KNOWN to h2inc.
	Known types are the built in int, short etc and any other type
	that h2inc has discovered so far, for example in a typedef.


		   STRUCTURES

Fields in a struct are expected only one per line. Field declarations like
"INT a, b" are not handled.

h2inc does a pretty good job of determining whether to use db, dw, or dd. It
knows about all types defined in that .H file, plus the primary C types:
char, int, unsigned, etc. It can also handle things of form "STRUCTURE *"
and "STRUCTURE FAR *", and produce dw or dd as appropriate.

Any primary data type h2inc does not know about is assumed to be a structure.
If a primary data type is defined in another .h file, the "-s symfile" option
will cause h2inc to scan that .h file for any type definitions.  Those
definitions will be used when translating the source file.

Structure types, arrays, and bitfields are handled too.  Below is
an example structure, with its h2inc'd output:

 The example above will get translated as follows:

    typedef FOO DWORD

    typedef struct _STRUCTURE {	  /* str */
	SHORT wOne;
	SHORT wTwo;
	RECT *prc;
	RECT rc;
	FOO  rgrc[10];
	CHAR rgch[20];
	BOOL fOneBit:1;
	BOOL fTwoBits:2;
	BOOL fThreeBits:3;
	SHORT (FAR *lpfn)();
    } STRUCTURE;


    STRUCTURE	struc
	str_wOne	dw  ?
	str_wTwo	dw  ?
	str_prc		dw  ?
	str_rc		(size RECT)/2 dup (?)
	str_rgrc	(size FOO)/2 * 10 dup (?)
	str_rgch	db  20 dup (?)
	str_fs		dw  ?
	str_lpfn	dd  ?
    STRUCTURE	ends
    str_fOneBit		equ	00001h
    str_fTwoBits	equ	00006h
    str_fThreeBits	equ	00038h

As can be seen, bitfields are handled in an interesting way.  The C field
name, prepended with the abbreviation tag, is actually the mask constant
to use, rather than the field offset.  The field offset is ALWAYS "fs"
prepended with the abbreviation tag.

Besides the standard winthorn types, h2inc also keeps track of other types
defined in the file so that it can determine whether to use db, dw, dd, or
dup.

			    IMPROVEMENTS


	o ASM statements and directives can be included in a '.h'
	  file by enclosing as follows
	  /* ASM
		asm statements and directives
	   */
	   These statements and/or directives are not processed, simply
	   copied.
	   There is a variation of ASM directive - ASMX. This works only
	   with '-g'. It is intended to be useful for defining segment
	   related stuff.
	o A structure can be translated to ASM named segment by
	  naming the segment in a standard C comment on the same line
	  as 'struct'. Selectively the fields of the struct (nee segment)
	  can be declared PUBLIC or initialised. The initialisation has
	  two flavours INIT and AINIT. AINIT is for initialising arrays
	  with distinct values. The following eg. illustrates. This is only
	  possible using '-g' option.

		struct foo {			/* SEGMENT FOOSEG */
			short	able;		/* Nothing special */
			short	baker;		/* PUBLIC */
			short	charlie;	/* INIT <MAXFOOBLE> */
			long	delta;		/* PUBLIC INIT <42> */
			char	eagle[16];	/* Vanilla */
			short	fox[MAXFOX];	/* PUBLIC INIT <0> */
			long	golf[MAXG];	/* AINIT <2, 3, 5, 7, 11, 13> */
		};

		Would translate to:

		FOOSEG	segment
		able	DW	?
			PUBLIC	baker
		baker	DW	?
		charlie	DW	MAXFOOBLE
			PUBLIC	delta
		delta	DD	42
		eagle	DB	16 DUP(?)
			PUBLIC	fox
		fox	DW	MAXFOX DUP(0)
		golf	DD	2, 3, 5, 7, 11, 13
			.errnz	($ - golf) - MAXG*(SIZE DWORD)
		FOOSEG	ends

	  with '-c' options on.

	o INT size can be specified as either 16 bits or 32 bits by
	  a directive
		/* INT16 */	or	/* INT32 */
	  if neither is specified, a warning is issued whenever
	  'int' is used.

	o Nested structure declarations are now handled.

	o Bit fields upto 32 bits are supported.

	o Embedded structures i.e. structures within structures should
	  be declared with a typedef. eg.

	  typedef struct foo foo;
	  foo	foobar[MAXFOO];
		of course, the struct foo itself is declared elsewhere.

			IMPROVEMENT IDEAS

- Handle C "typedef enum" enumerated type definition statements.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\setup\win.ini ===
; for 16-bit app support
[fonts]
[extensions]
[mci extensions]
[files]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\suballoc\suballoc.txt ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    suballoc.c

Abstract:

    This module contains code for managing a paritially commited address
    space.  It handles allocation of chunks of memory smaller than the 
    commit granularity.  It commits and decommits memory as needed using
    the supplied function for committing and decommitting memory.  The 
    structures used for tracking the address space are allocated outside
    of the specified addresss space.

Author:

    Dave Hastings (daveh) creation-date 21-Jan-1994
    
Notes:

    Since this package does not actually access memory in the address space
    it is managing, it will work as well with real linear addresses or 
    "Intel Addresses" such as would be encountered with the Insignia Emulator
    on risc.

Revision History:


--*/

//
// Constants
// 

//
// Smallest chunk that will be sub allocated
// 1024 was chosen currently, because that is the
// smallest chunk XMS will allocate.
//
#define SUBALLOC_GRANULARITY        1024

//
// The size of the character array require to hold the 
// bits defining whether the individual allocation entities
// in the commited chunk are allocated or free
//
// BUGBUG Assert that COMMIT_GRANULARITY is a multiple of SUBALLOC_GRANULARITY
//
#define SUBALLOC_BITFIELD_SIZE      COMMIT_GRANULARITY / SUBALLOC_GRANULARITY

//
// Types
//

//
// Routine for committing a specific region of of the address
// space.  Although the return type is NTSTATUS, the only value
// that is checked is 0 (for STATUS_SUCCESS).  If STATUS_SUCCESS
// is returned, it is assumed that the function worked. If not,
// it is assumed that it failed.  No special meaning is attached to
// particular non-zero values.
//
typedef
NTSTATUS 
(*PSACOMMITROUTINE)(
    ULONG BaseAddress,
    ULONG Size
    );

//
// Structure for tracking the address space.  Each chunk of 
// memory of SUBALLOC_GRANULARITY in size is represented by
// a bit.  Each chunk of memory of COMMIT_GRANULARITY is 
// represented by one element of the array of bitfields.
// The FreeCheck array half of the union allows us to check
// whether the entire committed chunk is free more quickly.
//
// ?? Should we add a field to indicate whether the chunk is 
//    committed?  We can always check for all allocated bits
//    zero, and use that as an indication that the chunk is 
//    not committed.
//
// BUGBUG Assert that the bits fit into memory the way we think
// they do.
//
typedef struct _SubAllocation {
    PSACOMMITROUTINE CommitRoutine;
    ULONG BaseAddress;
    ULONG Size;
    union {
        //
        // bitfield with one bit per chunk.  Bit set indicates
        // allocated.  Bit clear indicates free.  All bits 
        // clear indicates un committed
        //
        UINT Allocated[SUBALLOC_BITFIELD_SIZE] : 1;
        //
        // Hopefully a faster way to check all bits.
        //
        UINT FreeCheck[SUBALLOC_BITFIELD_SIZE / sizeof(UINT)];
    } CommitedChunk;
} SUBALLOCATIONDATA, *PSUBALLOCATIONDATA


PVOID
SAInitialize(
    ULONG BaseAddress,
    ULONG Size,
    PSACOMMITROUTINE CommitRoutine
    )
/*++

Routine Description:

    This function performs initialization of the sub allocation package
    for the specified addresss range.  It allocates the data structures
    necessary to track the allocations

Arguments:

    BaseAddress -- Supplies the base address of the address space to
        sub allocate.
    Size -- Supplies the size in bytes of the address space to sub allocate.
    CommitRoutine -- Supplies a pointer to the routine used to commit regions
        of the address space.

Return Value:

    If the function was successful it returns a pointer to the sub-allocation
    data structures.  Otherwise it returns NULL.
    
--*/
{

}

BOOL 
SAQueryFree(
    PVOID SubAllocation,
    PULONG FreeBytes
    )    
/*++

Routine Description:

    This routine returns the number of free bytes in the 
    sub allocated address space.

Arguments:
    
    SubAllocation -- Supplies the pointer returned by SAInitialize
    FreeBytes -- Returns the number of free bytes
   
Return Value:

    TRUE -- if successful, and FreeBytes contains the number of free bytes.
    FALSE otherwise
    
--*/
{

}

BOOL
SAAllocate(
    PVOID SubAllocation,
    ULONG Size,
    PULONG Address
    )
/*++

Routine Description:

    This function allocates a portion of the address space described by 
    SubAllocation.  If necessary, it will commit additional blocks. Address is 
    rounded down to the next lower SUBALLOC_GRANULARITY boundary.
    size is rounded up to the next higher multiple of SUBALLOC_GRANULARITY.

Arguments:

    SubAllocation -- Supplies the pointer returned by SAInitialize.
    Size -- Supplies the size in bytes of the region to allocate.
    Address -- Returns the address of the region allocated.

Return Value:

    TRUE if successful.  If false is returned, no address is returned.
    
Notes:

    Zero is a valid value for the returned address.

--*/
{

}

BOOL
SAFree(
    PVOID SubAllocation,
    ULONG Size,
    ULONG Address
    )
/*++

Routine Description:

    This routine frees a sub-allocated chunk of memory.  If the 
    entire commited block (or blocks) that the specified chunk
    belongs to are free, the chunks are decommitted.  Address is 
    rounded down to the next lower SUBALLOC_GRANULARITY boundary.
    size is rounded up to the next higher multiple of SUBALLOC_GRANULARITY.

Arguments:

    SubAllocation -- Supplies the pointer returned by SAInitialize.
    Size -- Supplies the size in bytes of the region to free.
    Address -- Supplies the address of the region to free.

Return Value:

    TRUE if successful.
    
Notes:

    It is possible to free a different size at a particular 
    address than was allocated.  This will not cause the 
    SubAllocation package any problems.
    
--*/
{

}

BOOL
SAReallocate(
    PVOID SubAllocation,
    ULONG OriginalSize,
    ULONG OriginalAddress,
    ULONG NewSize,
    PULONG NewAddress
    )
/*++

Routine Description:

    This routine reallocates a sub allocated block of memory.
    The sizes are rounded up to the next SUBALLOC_GRANULARITY.
    The Original address is rounded down to the next SUBALLOC_GRANULARITY
    boundary.  Only min(OriginalSize, NewSize) bytes of data are copied to
    the new block.  The block changed in place if possible.

Arguments:

    SubAllocation -- Supplies the pointer returned by SAInitialize.
    OriginalSize -- Supplies the old size in bytes of the block.
    OriginalAddress -- Supplies the old address of the block.
    NewSize -- Supplies the new size in bytes of the block.
    NewAddress -- Returns the new address of the block.

Return Value:

    True if successful.  If unsucessful, no allocation is changed.
    
Notes:

    If the caller does not supply the correct original size for the block,
    some memory may be lost, and the block may be moved unnecessarily.
    
--*/
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\vddserv.doc ===
Installable Virtual Device Driver (VDD) Support For NTVDM
==========================================================

Problem:
--------
There is a class of DOS applications which run on their
own custom hardware. Generally these applications will
have a pluggable card and a 16bit device driver for their
card. As these cards are beyond the scope of normal PC
architecture, NTVDM cannot virtualize them in a secure
manner. So all such applications are not supported under
NTVDM.

Solution:
---------

If an ISV is writing an NT native device driver for such a
card, it is technically quite simple to provide the support
such that the DOS application runs unmodified and in a secure
fashion. The vendor has to write a Virtual Device Driver (VDD)
which will virtualize the card for the DOS application by calling
the native device driver.


	    -----------------------
	    |			  |
	    |	DOS Application	  |	  V86 mode
	    |			  |
	    -----------------------
      I/O-map |	 ^     |Mem-Map	| DMA
      IO      |	 |     |IO	|
    -------------|-----------------------------
	      |  |     |	|
	      V  |     V	V
	    -----------------------
	    |		   | DMA  |
	    |	    NTVDM  -------|	  NT User mode code
	    |			  |
	    -----------------------
		 ^     |
		 |     | Dispatches the event to VDD
		 |     V
	    -----------------------
	    |			  |
	    |	     VDD	  |	  VDD is a DLL attached to NTVDM
	    |			  |
	    -----------------------
		 ^     |
		 |     | Call the real driver
    -------------|-----------------------------
		 |     |
		 |     V
	    -----------------------
	    |			  |
	    |  NT Device Driver	  |	  Kernel mode
	    |			  |
	    -----------------------
		 ^     |
		 |     | Carries out the operation with its card
		 |     V
	    -----------------------
	    |			  |
	    |	 Plugged Card	  |
	    |			  |
	    -----------------------

Following are the main work items to achieve the above solution:

    a. Loading the VDD
    b. Support for I/O mapped I/O
    c. Support for Memory mapped I/O
    d. Support for DMA operations
    e. Register manipulation services
    f. Memory accessing services
    g. Interrupt simulation services
    h. Miscelleneous services


a. Loading the VDD:

    The system administrator will add the command lines in the
    \\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\CONTROL\"VirtualDeviceDrivers"
    section of the registry for all the VDDs to be loaded in the
    VDM process. The command line format is REG_MULT_SZ (i.e. ASCIIZZ).
    This key will laways be present and install program just need to
    add their VDD name.

    [VirtualDeviceDrivers]
      VDD = <full-path of the VDD1.DLL>\0<full-path of the VDD2>\0\0

    VDD ACTION :

    NTVDM will load all these VDDs from the registry at the VDM process
    initialization time and call their initialization routine. VDDs should
    make sure at this time that their respective NT device driver is
    present and make all the resource allocations. The VDD handle passed
    in this initialization routine will be the Id of the VDD when calling
    the VDD services as described below.


b. Support for I/O mapped I/O:

   Following services will be provided for VDDs to deal with  IO
   ports:

   BOOL VDDInstallIOHook (HANDLE, IO_PORT_RANGE, IO_PORT_HANDLERS);
   BOOL VDDDeInstallIOHook (HANDLE, IO_PORT_RANGE);

   The HANDLE is the one passed to the VDD in its DLLInit routine.
   Only one IO hook may be installed for a given port, all subsequent
   requests will fail. On DeInstalling, the default IO hook will be
   placed, which means no one is hooked on those IO ports. IO_PORT_HANDLERS
   should atleast provide a byte read and a byte write handler. In addition,
   word and string handlers can also be provided. In the absense of word
   or string handlers, these will be emulated using byte handlers.
   A port has to be hooked for both read and write. VDDs should not hook
   DMA ports as these are virtualized by NTVDM and services are provided
   for VDDs to access DMA.

   VDD Action:  On an IO access (or on a series of IO accesses) the VDD
                can check if it needs to start the DMA. If so it can call
                the DMA services given in the following section. If it
                does'nt require the DMA or if the DMA has transfered the
                buffer, then the VDD can call its NT device driver to
                complete the desired request. (Its also possible that the
                VDD first requests the device driver and than using DMA
                services copies the contents to the VDM buffer).


c. Support for Memory mapped I/O:

   Following services will be  provided for VDDs to deal with their
   memory mapped addresses:

   BOOL VDDInstallMemoryHooks (HANDLE, ADDR_RANGE, MEMORY_HANDLER);
   BOOL VDDDeInstallMemoryHooks (HANDLE, ADDR_RANGE);

   The addr_range should be a valid range i.e. above RMSIZE and below system
   rom. Only one Memory hook may be installed for a given range, all subsequent
   requests will fail. On deinstalling the range, VDD will no longer get page
   fault on those ranges.     Memory_handler will
   tell on which address the fault occured and whether it was a
   read or write fault. On its return from the memory handler it will be
   assumed that the fault was handled.


   A port-range will actually result in a whole page to be reserved. That
   means the page will not remain available to EMM for EMM page frames and
   UMBs.

   VDD Action: It can map the normal memory and let the app write to it.
	       Later they can use the WIN32 API's or its device driver
	       as per the case to deal the whole memory range.

d. Support for DMA operations

   Following DMA service will be provided for the VDD:

   DWORD VDDRequestDMA (HANDLE, DMA_CHANNEL, BUFFER, TRANSFER_BYTES);
   BOOL VDDQueryDMA (HANDLE, DMA_CHANNEL, DMA_INFO_BUFFER);
   BOOL VDDSetDma (HANDLE, DMA_CHANNEL, INDEX, DMA_INFO_BUFFER);

   NTVDM will control all the DMA ports and will maintain all the
   information on per channel basis. There are two flavors in which
   a VDD can carry-out the DMA operations. It can call VDDRequestDMA
   and this service will interpret the DMA registers and do the
   DMA transfer. It should be clear at this point that this will
   involve two buffer copyings. For example, the VDD will ask the device
   driver to trasnfer some data in a buffer (allocated by VDD) then it will
   call this service to transfer this buffer to the address DOS application
   has asked for (through DMA programming).

   On the other hand, a VDD can collect all the DMA registers using
   VDDQueryDMA and figure out where the DOS application	has asked the
   DMA to take place, in what mode and how much to transfer. Then it can
   call the NT device driver with same address as asked by DOS app. In this
   case there will be only one copying. VDD should use VDDSetDMA after
   such an operation to update the DMA state.

e. Register manipulation services:

   See the reference section for details. There is a get and a set service
   for each V86 registers.


f: Memory Accessing services:

   Following services are provided for Manipulating VDM's memory.

   PVOID GetVDMPointer(ULONG Address, ULONG Size, BOOL ProtectedMode);
   BOOL	FreeVDMPointer(ULONG Address, ULONG Size, BOOL ProtectedMode);
   BOOL	FlushVDMPointer(ULONG Addr,
			ULONG Size, PVOID Buffer, BOOL ProtectedMode);

g: Interrupt simulation services

   Following services is provided for simulating an interrupt to the VDM.

   VOID VDDSimulateInterrupt (BYTE ms, BYTE line, WORD count);


h. Miscellaneous Services

   Following services will be provided for memory allocation/deallocation.

   VDDAllocMem (HANDLE, ADDRESS, PAGES);
   VDDFreeMem  (HANDLE, ADDRESS, PAGES);

   VDD will use VDDAllocMem when it gets a page fault on a page which
   it has hooked using VDDInstallMemoryHook. Later it can free this memory
   using VDDFreeMem. We are asking VDDs to use WIN32 API for all their needs
   and here also a VDD could have used VirtualAlloc and VirtualFree. The
   problem is that on a non-x86 machine this would'nt have worked because
   on such a plateform the VDM memory is under the emulator's control and it
   has to be told of such memory changes.

   Following service will be provided for VDM termination.

   VDDTerminateVDM (VOID);

   VDD will use this service to terminate the VDM. For instance if a VDD
   fails to allocate memory on a memory mapped IO, it may want to terminate
   the VDM as its state is inconsistenet.

   VDDs should always use these services to achieve plateform independence.



---------------- REFERENCE SECTION -------------------------

/** Basic typedefs of VDD IO hooks **/

typedef VOID (*PFNVDD_INB)   (WORD iport,BYTE * data);
typedef VOID (*PFNVDD_INW)   (WORD iport,WORD * data);
typedef VOID (*PFNVDD_INSB)  (WORD iport,BYTE * data,WORD count);
typedef VOID (*PFNVDD_INSW)  (WORD iport,WORD * data,WORD count);
typedef VOID (*PFNVDD_OUTB)  (WORD iport,BYTE data);
typedef VOID (*PFNVDD_OUTW)  (WORD iport,WORD data);
typedef VOID (*PFNVDD_OUTSB) (WORD iport,BYTE * data,WORD count);
typedef VOID (*PFNVDD_OUTSW) (WORD iport,WORD * data,WORD count);

/**  Array of handlers for VDD IO hooks. **/

typedef struct _VDD_IO_HANDLERS {
    PFNVDD_INB	 inb_handler;
    PFNVDD_INW	 inw_handler;
    PFNVDD_INSB	 insb_handler;
    PFNVDD_INSW	 insw_handler;
    PFNVDD_OUTB	 outb_handler;
    PFNVDD_OUTW	 outw_handler;
    PFNVDD_OUTSB outsb_handler;
    PFNVDD_OUTSW outsw_handler;
} VDD_IO_HANDLERS, *PVDD_IO_HANDLERS;

/** Port Range structure **/
typedef struct _VDD_IO_PORTRANGE {
        WORD   First;
        WORD   Last;
} VDD_IO_PORTRANGE, *PVDD_IO_PORTRANGE;

/**  Memory mapped I/O handler. **/

typedef VOID (*PVDD_MEMORY_HANDLER) (PVOID FaultAddress, ULONG RWMode);

/** Buffer for returning DMA information **/
typedef struct _VDD_DMA_INFO {
    WORD    addr;
    WORD    count;
    WORD    page;
    BYTE    status;
    BYTE    mode;
    BYTE    mask;
} VDD_DMA_INFO, *PVDD_DMA_INFO;

/*** VDDInstallIOHook - This service is provided for VDDs to hook the
 *			IO ports they are responsible for.
 *
 * INPUT:
 *      hVDD      ; VDD Handle
 *      cPortRange; Number of VDD_IO_PORTRANGE structures
 *      pPortRange; Pointer to array of VDD_IO_PORTRANGE
 *	IOhandler : VDD handler for the ports.
 *
 * OUTPUT
 *	SUCCESS : Returns TRUE
 *	FAILURE : Returns FALSE
 *		  GetLastError has the extended error information.
 *
 * NOTES:
 *      1. The first one to hook a port will get control. Subsequent
 *         requests will be failed. There is no concept of chaining
 *         the hooks.
 *
 *	2. IOHandler must atleast provide a byte read and a byte write
 *	   handler. Others can be NULL.
 *
 *	3. If word or string handlers are not provided, their effect
 *	   will be emulated using byte handlers.
 *
 *	4. VDDs should not hook DMA ports. NTVDM manages it for all
 *	   the clients and services are provided to perform DMA
 *	   operations and to access and modify DMA data.
 *
 *	5. VDDs should not hook video ports as well. Such a hooking
 *	   will succeed but there is no gurantee that the IO handler will
 *         get called.
 *
 *      6. Each Vdd is allowed to install only one set of IO hooks
 *         at a time.
 *
 *      7. Extended Error codes:
 *
 *         ERROR_ACCESS_DENIED   - One of the requested ports is already hooked
 *         ERROR_ALREADY_EXISTS  - Vdd already has active IO port handlers
 *         ERROR_OUTOFMEMORY     - Insufficient resources for additional VDD
 *                                 Port handler set.
 *         ERROR_INVALID_ADDRESS - One of the IO port handlers has an invalid
 *                                 address.
 */
BOOL VDDInstallIOHook (
     HANDLE            hVdd,
     WORD              cPortRange,
     PVDD_IO_PORTRANGE pPortRange,
     PVDD_IO_HANDLERS  pIOFn
);

/*** VDDDeInstallIOHook - This service is provided for VDDs to unhook the
 *			  IO ports they have hooked.
 *
 * INPUT:
 *	hVDD	: VDD Handle
 *
 * OUTPUT
 *	None
 *
 * NOTES
 *
 *	1. On Deinstalling a hook, the defult hook is placed back on
 *	   those ports. Default hook  returns 0xff on reading
 *	   and ignores the write operations.
 *
 */
VOID VDDDeInstallIOHook (
     HANDLE            hVdd,
     WORD              cPortRange,
     PVDD_IO_PORTRANGE pPortRange
);

/*** VDDInstallMemoryHook - This service is provided for VDDs to hook the
 *			    Memory Mapped IO addresses they are resposible
 *			    for.
 *
 * INPUT:
 *	hVDD	: VDD Handle
 *      addr    : Starting linear address
 *      count   : Number of bytes
 *	MemoryHandler : VDD handler for the memory addresses
 *
 *
 * OUTPUT
 *	SUCCESS : Returns TRUE
 *	FAILURE : Returns FALSE
 *		  GetLastError has the extended error information.
 *
 * NOTES
 *	1. The first one to hook an address will get the control. There
 *	   is no concept of chaining the hooks. VDD should grab the
 *	   memory range in its initialization routine. After all
 *	   the VDDs are loaded, EMM will eat up all the remaining
 *	   memory ranges for UMB support.
 *
 *	2. Memory handler will be called with the address on which the
 *	   page fault occured and with a falg telling whether it was a
 *	   read or write operation.
 *
 *	3. On returning from the hook handler it will be assumed that
 *	   the page fault was handled and the return will go back to the
 *	   VDM.
 *
 *	4. Installing a hook on a memory range will result in the
 *         consumption of memory based upon page boundaries. The Starting
 *         address is rounded down, and the count is rounded up to the
 *         next page boundary. The VDD's memory hook handler will be
 *         invoked for all addreses within the page(s) hooked. The page(s)
 *         will be set aside as mapped reserved sections, and will no
 *         longer be available for use by NTVDM or other VDDs. The VDD is
 *         permitted to manipulate the memory (commit, free, etc) as needed.
 *
 *	5. After calling the MemoryHandler, NTVDM will return to the
 *	   faulting cs:ip in the 16bit app. If the VDD does'nt want
 *	   that to happen it should adjust cs:ip appropriatly by using
 *	   setCS and setIP.
 *
 *	6. Only one VDD will be allowed to have memory hooks in a page.
 *	   In other words a page si owned by a VDD exclusively.
 *
 *	7. Extended Error codes:
 *
 *         ERROR_ACCESS_DENIED   - One of the requested ports is already hooked
 *	   ERROR_OUTOFMEMORY	 - Insufficient resources.
 */
BOOL VDDInstallMemoryHook (
     HANDLE hVDD,
     PVOID pStart,
     DWORD count,
     PVDD_MEMORY_HANDLER MemoryHandler
);

/*** VDDDeInstallMemoryHook - This service is provided for VDDs to unhook the
 *			      Memory Mapped IO addresses.
 *
 * INPUT:
 *	hVDD	: VDD Handle
 *	addr	: Starting linear address
 *	count	: Number of addresses
 *
 * OUTPUT
 *	None
 *
 * NOTES
 *	1. On Deinstalling a hook, the memory range becomes invalid.
 *	   VDM's access of this memory range will cause a page fault.
 *
 *	2. Extended Error codes:
 *	   ERROR_INVALID_PARAMETER - One of the parameter is invalid.
 */
BOOL VDDDeInstallMemoryHook (
     HANDLE hVDD,
     PVOID pStart,
     DWORD count
);

/*** VDDRequestDMA - This service is provided for VDDs to request a DMA
 *		     transfer.
 *
 * INPUT:
 *	hVDD	 VDD Handle
 *	iChannel DMA Channel on which the operation to take place
 *	Buffer	 Buffer where to or from transfer to take place
 *      length   Transfer Count (in bytes)
 *               If Zero, returns the Current VDMA transfer count
 *               in bytes.
 *
 * OUTPUT
 *      DWORD    returns bytes transferred
 *		 if Zero  and GetLastError is set means operation failed.
 *		 if Zero  and GetLastError is clear means VDMA transfer count
 *					   was zero.
 *
 * NOTES
 *	1. This service is intended for those VDDs which do not want to
 *	   carry on the DMA operation on their own. Carrying on a DMA
 *	   operation involves understanding all the DMA registers and
 *	   figuring out what has to be copied, from where and how much.
 *
 *	2. This service will be slower than using VDDQueryDMA/VDDSetDMA and
 *         doing the transfer on your own.
 *
 *      3. Extended Error codes:
 *
 *         ERROR_ALREADY_EXISTS  - Vdd already has active IO port handlers
 *         ERROR_OUTOFMEMORY     - Insufficient resources for additional VDD
 *                                 Port handler set.
 *         ERROR_INVALID_ADDRESS - One of the IO port handlers has an invalid
 *                                 address.
 *
 */
DWORD VDDRequestDMA (
    HANDLE hVDD,
    WORD   iChannel,
    PVOID  Buffer,
    DWORD  length
);

/*** VDDQueryDMA -   This service is provided for VDDs to collect all the DMA
 *		     data.
 *
 * INPUT:
 *	hVDD	 VDD Handle
 *	iChannel DMA Channel for which to query
 *	Buffer	 Buffer where information will be returned
 *
 * OUTPUT
 *	SUCCESS : Returns TRUE
 *	FAILURE : Returns FALSE
 *		  GetLastError has the extended error information.
 *
 *
 * NOTES
 *	1. This service is intended for those VDD which are doing
 *	   performance critical work. These VDD can do their own DMA
 *	   transfers and avoid one extra buffer copying which is a
 *	   overhead in using VDDRequestDMA.
 *
 *	2. VDDs should use VDDSetDMA to properly update the state of
 *         DMA after carrying on the operation.
 *
 *      3. Extended Error codes:
 *
 *         ERROR_INVALID_ADDRESS - Invalid channel
 *
 */
BOOL VDDQueryDMA (
     HANDLE        hVDD,
     WORD          iChannel,
     PVDD_DMA_INFO pDmaInfo
);

/*** VDDSetDMA - This service is provided for VDDs to set the DMA data.
 *
 * INPUT:
 *	hVDD	 VDD Handle
 *	iChannel DMA Channel for which to query
 *      fDMA     Bit Mask indicating which DMA data fields are to be set
 *		 VDD_DMA_ADDR
 *		 VDD_DMA_COUNT
 *		 VDD_DMA_PAGE
 *		 VDD_DMA_STATUS
 *		 VDD_DMA_ALL  (all Above)
 *	Buffer	 Buffer with DMA data
 *
 * OUTPUT
 *	SUCCESS : Returns TRUE
 *	FAILURE : Returns FALSE
 *		  GetLastError has the extended error information.
 *
 * NOTES
 *
 *      1. Extended Error codes:
 *
 *         ERROR_INVALID_ADDRESS - Invalid channel
 *
 */
BOOL VDDSetDMA (
    HANDLE hVDD,
    WORD iChannel,
    WORD fDMA,
    PVDD_DMA_INFO pDmaInfo
);

/** VDDAllocMem - Allocates memory at a given virtual address.
 *
 *   INPUT
 *	hVDD   : VDD
 *	Address: Address where memory is to be allocated (between 640k and 1Mb)
 *	nBytes : Number of bytes to allocate
 *
 *   OUTPUT
 *	SUCCESS : Returns TRUE
 *	FAILURE : Returns FALSE
 *		  GetLastError has the extended error information.
 * Notes:
 *	1. VDDs have to use this service instead of WIN32 VirtualAlloc
 *	   to be plateform independent. On non-x86 machines VDDAllocMem
 *	   tells the CPU emulator about this memory allocation.
 *
 *	2. The address will be made page aligned downwards and nBytes will
 *	   be streched upward to be page aligned.
 *
 *	3. Extended Error codes:
 *	   ERROR_OUTOFMEMORY	 - Insufficient memory
 *	   ERROR_INVALID_ADDRESS - Invalid address
 */
VOID VDDAllocMem (
     HANDLE hVDD,
     PVOID  Address,
     ULONG  nBytes
);

/** VDDFreeMem - Free memory at a given virtual address.
 *
 *   INPUT
 *	hVDD   : VDD
 *	Address: Address where memory is to be freed
 *	nBytes : Number of bytes to free
 *
 *   OUTPUT
 *	SUCCESS : Returns TRUE
 *	FAILURE : Returns FALSE
 *		  GetLastError has the extended error information.
 *
 * Notes:
 *      1. Extended Error codes:
 *	   ERROR_INVALID_ADDRESS - Invalid address
 *
 *	2. The address will be made page aligned downwards and nBytes will
 *	   be streched upward to be page aligned.
 *
 */
VOID VDDFreeMem (
     HANDLE hVDD,
     PVOID  Address,
     ULONG  nBytes
);

/** VDDTerminateVDM - Terminate the VDM.
 *
 *   INPUT
 *	None
 *
 *   OUTPUT
 *	None
 *
 * Notes:
 *	1. VDD should call this service on encoutering a fatal error,
 *	   such that VDDs state is inconsistent.
 *
 *	2. VDD can use MessageBox WIN32 API to putup a popup before
 *	   terminating the VDM.
 */
VOID VDDTerminateVDM (
     VOID
);

/**  Register Manipulation services
 *
 */

ULONG	getEAX(VOID);
USHORT	getAX(VOID);
UCHAR	getAL(VOID);
UCHAR	getAH(VOID);
ULONG	getEBX(VOID);
USHORT	getBX(VOID);
UCHAR	getBL(VOID);
UCHAR	getBH(VOID);
ULONG	getECX(VOID);
USHORT	getCX(VOID);
UCHAR	getCL(VOID);
UCHAR	getCH(VOID);
ULONG	getEDX(VOID);
USHORT	getDX(VOID);
UCHAR	getDL(VOID);
UCHAR	getDH(VOID);
ULONG	getESP(VOID);
USHORT	getSP(VOID);
ULONG	getEBP(VOID);
USHORT	getBP(VOID);
ULONG	getESI(VOID);
USHORT	getSI(VOID);
ULONG	getEDI(VOID);
USHORT	getDI(VOID);
ULONG	getEIP(VOID);
USHORT	getIP(VOID);
USHORT	getCS(VOID);
USHORT	getSS(VOID);
USHORT	getDS(VOID);
USHORT	getES(VOID);
USHORT	getFS(VOID);
USHORT	getGS(VOID);
ULONG	getCF(VOID);
ULONG	getPF(VOID);
ULONG	getAF(VOID);
ULONG	getZF(VOID);
ULONG	getSF(VOID);
ULONG	getIF(VOID);
ULONG	getDF(VOID);
ULONG	getOF(VOID);
USHORT	getMSW(VOID);

VOID	setEAX(ULONG);
VOID	setAX(USHORT);
VOID	setAH(UCHAR);
VOID	setAL(UCHAR);
VOID	setEBX(ULONG);
VOID	setBX(USHORT);
VOID	setBH(UCHAR);
VOID	setBL(UCHAR);
VOID	setECX(ULONG);
VOID	setCX(USHORT);
VOID	setCH(UCHAR);
VOID	setCL(UCHAR);
VOID	setEDX(ULONG);
VOID	setDX(USHORT);
VOID	setDH(UCHAR);
VOID	setDL(UCHAR);
VOID	setESP(ULONG);
VOID	setSP(USHORT);
VOID	setEBP(ULONG);
VOID	setBP(USHORT);
VOID	setESI(ULONG);
VOID	setSI(USHORT);
VOID	setEDI(ULONG);
VOID	setDI(USHORT);
VOID	setEIP(ULONG);
VOID	setIP(USHORT);
VOID	setCS(USHORT);
VOID	setSS(USHORT);
VOID	setDS(USHORT);
VOID	setES(USHORT);
VOID	setFS(USHORT);
VOID	setGS(USHORT);
VOID	setCF(ULONG);
VOID	setPF(ULONG);
VOID	setAF(ULONG);
VOID	setZF(ULONG);
VOID	setSF(ULONG);
VOID	setIF(ULONG);
VOID	setDF(ULONG);
VOID	setOF(ULONG);
VOID	setMSW(USHORT);

/** GetVDMPointer - Findout the linear address of a given VDM address
 *
 *   INPUT
 *	Address - seg/sel:off (hi word has segment or selector and loword
 *		  is offset)
 *	Size	- Range of the pointer
 *	ProtectMode - If protectmode == TRUE its sel:off
 *		      If protectmode == FALSE its seg:off
 *
 *   OUTPUT
 *	Returns Linear address.
 *
 *   NOTES:
 *	1. VDDs should use this service to convert the address rather
 *	   than shifting the seg by 4 and adding the offset. This makes
 *	   them plateform independent. On non-x86 machine VDM's 0 and
 *	   the process's 0 are different and the actual adddress conversion
 *	   is provided by the CPU emulator.
 */
PVOID GetVDMPointer(
      ULONG Address,
      ULONG Size,
      BOOL ProtectedMode
);

/** FlushVDMPointer - Flushes the contents (required because of emulator)
 *
 *   INPUT
 *	Address - seg/sel:off (hi word has segment or selector and loword
 *		  is offset)
 *	Size	- Range of the pointer
 *	Buffer	- Address returned by GetVDMPointer.
 *	ProtectMode - If protecmeode == TRUE its sel:off
 *		      If protecmeode == FALSE its seg:off
 *
 *   OUTPUT
 *	Returns Linear address.
 *
 *   NOTES:
 *	1. VDDs should use this service to make sure that on non-x86
 *	   machines, the CPU emulator gets a chance to flush any data
 *	   associated with a memory range.
 */
BOOL  FlushVDMPointer(
      ULONG Addr,
      ULONG Size,
      PVOID Buffer,
      BOOL ProtectedMode
);

/** FreeVDMPointer - Frees a pointer previously returned by GetVDMPointer
 *
 *   INPUT
 *	Address - seg/sel:off (hi word has segment or selector and loword
 *		  is offset)
 *	Size	- Range of the pointer
 *	ProtectMode - If protecmeode == TRUE its sel:off
 *		      If protecmeode == FALSE its seg:off
 *
 *   OUTPUT
 *	None
 *
 *   NOTES:
 *	1. FreeVDMPointer does FlushVDMPointer as well.
 */
BOOL  FreeVDMPointer(
      ULONG Address,
      ULONG Size,
      BOOL ProtectedMode
);

/** VDDSimulateInterrupt - Simulates an interrupt to the VDM.
 *
 *   INPUT
 *	ms    -	Is either ICA_MASTER or ICA_SLAVE as appropriate
 *	line  - Interrupt line
 *	count - allows a batch of interrupts to be delivered but will usually
 *		be 1.
 *
 *   OUTPUT
 *	None
 */
VOID VDDSimulateInterrupt (
     BYTE ms,
     BYTE line,
     WORD count
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmdbg\vdmdbg.txt ===
An Explanation of VDMDBG.DLL

                            BobDay - 10 Jun 93

Section 1.0 - Overview
Section 2.0 - The Simulated Environment
Section 3.0 - The 32-bit Environment
Section 4.0 - Communication Protocol via Exception
Section 5.0 - The VDM Debugging APIs

1.0 Overview

    This document describes the mechanism used to support debugging DOS and
    WIN16 applications under Windows NT.  The mechanism involves 2 parts
    in the simulated environment, one for v86 mode (or simulated real mode)
    and one for protected mode.  It also involves 3 parts in the 32-bit NT
    environment, one for fielding information from the simulated enviroment
    and sending it to the debugger, one for code in the debugger, and one
    for code in a DLL used by the debugger.

        16-bit simulated environment     32-bit environment

                NTIO.SYS                  DBG.LIB (in NTVDM.EXE)
                KRNL286.EXE               NTSD (WinDbg or equivalent)
                                          VDMDBG.DLL


2.0 Simulated enviroment

    Once the simulated environment is up and running, if one of the normal
    debugging type events occurs it gets simulated to happen exactly the
    way it would on a normal PC.  This means that if an INT 3 occurs, it
    pushes the flags, CS, IP, looks up the address in the IVT and then
    jumps to it.  Same goes for INT 1's and INT D's (GP Faults).  If the
    processor is in protected mode, these interrupts are normally trapped
    by the DOS extender (most of the time DOSX.EXE) and then reflected
    down into the real mode interrupts (except for GP Faults).

    In order to debug in the simulated enviroment, it is necessary to
    catch and process these events.  The simplest way to do this is to
    install our own routines to watch these interrupts and that is
    what NTIO.SYS and KRNL286.EXE do.  They are nothing but small
    stubs which insert themselves into the interrupt chains (NTIO.SYS
    inserts itself into the real mode interrupt chain, and KRNL286.EXE
    inserts itself into the protected mode interrupt chain).  It is important
    to install oneself as early as possible so that other programs (such
    as DEBUG.COM) can install themselves ahead of these small stubs.
    In this way the events are only detected when they are not handled by some
    program in the simulated environment.

    Also, segment loading and unloading notifications are routed to
    these small stubs so that the debugger can be notified when selectors
    are associated with programs and their symbols.

    The small stubs will perform a BOP (a method of transitioning from
    the simulated environment back to the real 32-bit NT environment and
    notifying it that a debug event has occurred). After the BOP, they will
    either perform an IRET instruction to return control back to the simulated
    program generating the interrupt, or pass the interrupt down to the
    previous interrupt handler (continue down the chain).  The decision
    whether to return from or pass the interrupt will be made on the basis
    of the ContinueDebugEvent continue status parameter.  DBG_CONTINUE will
    IRET, DBG_EXCEPTION_NOT_HANDLE will pass it back down the chain.

3.0 32-bit environment

    Once the 32-bit environment has been notified that a debug event has
    occurred, it begins executing code in NTVDM (DBG.C) which parcels up the
    register context (based on the type of event which occurred) and
    communicates all the information to the debugger.

    Since the debugger is in another process's context, communication
    is done through exceptions.  NTVDM will raise an exception with the
    status STATUS_VDM_EVENT.  Exception information will be passed via the
    "lpArguments" parameter to the API RaiseException().

    The lpArguments parameter will cause an array of 4 DWORD values to
    be passed to the debugger. The values of the meanings of the array
    will be discussed in section 4.0

    The debugger should receive this exception and return from the call
    WaitForDebugEvent (debuggers should always have some thread waiting
    for debug events).  By examining the events dwDebugEventCode member,
    the debugger can determine the type of the debug event.  If this type
    is EXCEPTION_DEBUG_EVENT, then the

          u.Exception.ExceptionRecord.ExceptionCode

    member of the debug event structure will contain the exception type.
    If this value is STATUS_VDM_EVENT then the exception is coming from the
    16-bit environment.

    When an exception of this type is detected, a debugger should load (if
    it hasn't done so already) the VDMDBG.DLL and determine the addresses
    of the key functions needed.  The key functions are:

        VDMProcessException
        VDMGetThreadSelectorEntry
        VDMGetPointer
        VDMGetThreadContext
        VDMSetThreadContext
        VDMGetSelectorModule
        VDMGetModuleSelector
        VDMKillWOW
        VDMDetectWOW
        VDMBreakThread
        VDMModuleFirst
        VDMModuleNext
        VDMGlobalFirst
        VDMGlobalNext


    The prototypes and structures used by this DLL are prototyped in the header
    file VDMDBG.H.  Section 5.0 explains each of these functions.

    Debuggers should not use these APIs to deal with the 16-bit environment:

        GetThreadSelectoryEntry
        GetThreadContext
        SetThreadContext

    The APIs ReadProcessMemory and WriteProcessMemory are still useful except
    that the debugger must convert the 16-bit addresses into 32-bit addresses
    (using VDMGetPointer).

    Each and every exception with the exception code of STATUS_VDM_EVENT
    should be passed to the function VDMProcessException.  This function
    filters out the extraneous communication between the 16-bit environment
    and the VDMDBG.DLL.  Most of this extraneous communication a debugger
    can ignore (deals with segment & module loading & unloading, this
    information will be provided via another interface).  If the event is
    part of this communication process, VDMProcessException will return
    FALSE, if not, it will return TRUE.

    If the function VDMProcessException returns FALSE, the debugger can
    immediately call the API ContinueDebugEvent with a continue status of
    DBG_CONTINUE and return to waiting for additional debug events.

    If the function VDMProcessException returns TRUE, then the lpArguments
    parameter of the exception should be processed to determine the type of
    event (INT 1, INT 3, INT D, etc.).  The debugger can then act accordingly.
    When it has completed operating with the thread, the debugger should
    call the API ContinueDebugEvent with a continue status of DBG_CONTINUE
    or DBG_EXCEPTION_NOT_HANDLED.

    For the processing of each of the debug events, the debugger should use
    the API VDMGetThreadSelectorEntry, VDMGetThreadContext, and
    VDMSetThreadContext instead of the likewise named functions listed above
    that are exported from KERNEL32.DLL.  These functions operate on an x86
    CONTEXT structure, even when running on a non-x86 machine.  The debugger
    should likewise present an x86 debugging view (x86 register dump, x86
    dis-assembly, breakpoints are INT 3's, etc.)

4.0 Communication Protocol via. Exceptions

    The method of communicating between the application and debugger
    will be exceptions.  NTVDM will raise an exception and debugger should
    receive it.  NTVDM can detect whether or not it is being debugged, and
    will conditionally raise the exception.

    If a debugger attaches itself to an existing NTVDM process, the
    32-bit environment detects this and comminicates an acknowledgement
    of this attachment.  This allows debuggers to perform initialization
    dealing with the 16-bit environment before beginning any new 16-bit tasks.

    For the simulated 16-bit environment, the exception code will always be
    STATUS_VDM_EVENT.

    On NT, each exception can only contain up to 4 DWORD values.  Here is
    how they are used for this communication.  The first 2 DWORDs contain
    4 WORD fields.  The last two DWORDs are just DWORDs.

      +---------+
      | W1 | W2 | = DW1
      +---------+
      | W3 | W4 | = DW2
      +---------+
      |   DW3   |
      +---------+
      |   DW4   |
      +---------+

    The header file VDMDBG.H contains macros for isolating the individual
    parts of the exception information.

    The W1 field is a WORD which specifies which type of event has occurred.
    This can be one of the following:

        W1 ==  0 - Segment Load Notification (DBG_SEGLOAD)
        W1 ==  1 - Segment Move Notification (DBG_SEGMOVE)
        W1 ==  2 - Segment Free Notification (DBG_SEGFREE)
        W1 ==  3 - Module Load Notification  (DBG_MODLOAD)
        W1 ==  4 - Module Free Notification  (DBG_MODFREE)
        W1 ==  5 - Int 01h break             (DBG_SINGLESTEP)
        W1 ==  6 - Int 03h break             (DBG_BREAKPOINT)
        W1 ==  7 - Int 0Dh break (GP Fault)  (DBG_GPFAULT)
        W1 ==  8 - Divide Overflow           (DBG_DIVOVERFLOW)
        W1 ==  9 - Invalid Opcode Fault      (DBG_INSTRFAULT)
        W1 == 10 - Task starting             (DBG_TASKSTART)
        W1 == 11 - Task stop                 (DBG_TASKSTOP)
        W1 == 12 - DLL starting              (DBG_DLLSTART)
        W1 == 13 - DLL stop                  (DBG_DLLSTOP)

    They are described below.

    The debugger will probably need to be smart enough to know how to manage
    both protected mode selectors and segment numbers from simulated real mode.

    Segment/selector to symbol lookup should be mode sensitive and only use
    segments from the appropriate mode.

4.1 Segment Load Notification

    Under Win16, this event is used to indicate that a selector has just
    been created and that it maps to a module's segment.

    When a .EXE or .DLL is loaded, many of these events will be received.
    No module load notification event will occur (this is the way it is
    done under Windows 3.1 too).

    Under DOS, no segment load notifications will occur.

        W1  = DBG_SEGLOAD (0)
        W2  = Unused
        W3  = Unused
        W4  = Unused
        DW3 = Pointer to a SEGMENT_NOTE structure in NTVDM address space
        DW4 = Reserved

    SEGMENT_NOTE structure field definitions will be:

        Selector1 - Selector assigned to new segment
        Selector2 - Unused
        Segment   - Segment within module
        Module    - Null terminated module name
        FileName  - Null terminated path to executable image
        Type      - Code/data information from segment definition
        Length    - Unused

    VDMProcessException will return FALSE for this event.

4.2 Segment Move Notification

    A segment has changed from one selector number to another.  If the
    new selector number is 0, this should be considered the same as
    discarding (freeing) the segment.

    This event only happens under Win16.  As such, these selectors should be
    tagged as protected mode only selectors.

        W1  = DBG_SEGMOVE (1)
        W2  = Unused
        W3  = Unused
        W4  = Unused
        DW3 = Pointer to a SEGMENT_NOTE structure in NTVDM address space
        DW4 = Reserved

    SEGMENT_NOTE structure field definitions will be:

        Selector1 - Old selector number
        Selector2 - New selector number (0 to discard segment)
        Segment   - Unused
        Module    - Unused
        FileName  - Unused
        Type      - Unused
        Length    - Unused

    VDMProcessException will return FALSE for this event.

4.3 Segment Free Notification

    When a segment is being released, this event will be received.

    This event only happens under Win16.

        W1  = DBG_SEGFREE (2)
        W2  = Unused
        W3  = Unused
        W4  = Unused
        DW3 = Pointer to a SEGMENT_NOTE structure in NTVDM address space
        DW4 = Reserved

    SEGMENT_NOTE structure field definitions will be:

        Selector1 - Selector number
        Selector2 - Unused
        Segment   - Unused
        Module    - Unused
        FileName  - Unused
        Type      - Unused
        Length    - Unused

    VDMProcessException will return FALSE for this event.

4.4 Module Load Notification

    This event is used to indicate that a module is going to take up a
    range of memory.

    This event is used only under DOS.  As such, these segment numbers
    should be tagged as simulated real mode only selectors.

        W1  = DBG_MODLOAD (3)
        W2  = Unused
        W3  = Unused
        W4  = Unused
        DW3 = Pointer to a SEGMENT_NOTE structure in NTVDM address space
        DW4 = Reserved

    SEGMENT_NOTE structure field definitions will be:

        Selector1 - Unused
        Selector2 - Unused
        Segment   - Starting segment
        Module    - Null terminated module name
        FileName  - Null terminated path to executable image
        Type      - Unused
        Length    - Length of module (in bytes)

    VDMProcessException will return FALSE for this event.

4.5 Module Free Notification

    Module freeing notifications happen under both DOS and Win16.  For
    to determine which selectors to free for a Win16 application, all of the
    selectors must be scanned to determine if it was associated with this
    module.  Again, this is the way it is done under Windows 3.1.

        W1  = DBG_MODFREE (4)
        W2  = Unused
        W3  = Unused
        W4  = Unused
        DW3 = Pointer to a SEGMENT_NOTE structure in NTVDM address space
        DW4 = Reserved

    SEGMENT_NOTE structure field definitions will be:

        Selector1 - Unused
        Selector2 - Unused
        Segment   - Unused
        Module    - Null terminated module name
        FileName  - Null terminated path to executable image
        Type      - Unused
        Length    - Unused

    VDMProcessException will return FALSE for this event.

4.6 Int 01h break

    This event probably requires interaction with the debugger and its
    internal breakpoint, trace bit setting mechanisms.

        W1  = DBG_SINGLE_STEP (5)
        W2  = Unused
        W3  = Unused
        W4  = Unused
        DW3 = Unused
        DW4 = Reserved

    VDMProcessException will return TRUE for this event.

4.7 Int 03h break

    This event probably requires interaction with the debugger and its
    internal breakpoints.

        W1  = DBG_BREAKPOINT (6)
        W2  = Unused
        W3  = Unused
        W4  = Unused
        DW3 = Unused
        DW4 = Reserved

    VDMProcessException will return TRUE for this event.

4.8 Int 0Dh break (GP Fault)

    This event probably requires interaction with the debugger and its
    internal breakpoints.

        W1  = DBG_GPFAULT (7)
        W2  = Unused
        W3  = Unused
        W4  = Unused
        DW3 = Unused
        DW4 = Reserved

    It is also important to note that all GP Faults will not be sent via
    this interface.  The Win16 subsystem intercepts some of the GP faults
    in its parameter validation code.  Faults in the parameter validation
    code indicated that an invalid parameter is being passed to one of the
    16-bit APIs.  There is currently no way to intercept these faults, the
    APIs will just return errors in the same mechanism as under Windows 3.1.

    VDMProcessException will return TRUE for this event.

4.9 Divide Overflow break (Int 0)

    This event probably requires interaction with the debugger and its
    internal breakpoints.

        W1  = DBG_DIVOVERFLOW (8)
        W2  = Unused
        W3  = Unused
        W4  = Unused
        DW3 = Unused
        DW4 = Reserved

    VDMProcessException will return TRUE for this event.

4.A Invalid Opcode Fault (Int 6)

        W1  = DBG_INSTRFAULT (9)
        W2  = Unused
        W3  = Unused
        W4  = Unused
        DW3 = Unused
        DW4 = Reserved

    VDMProcessException will return TRUE for this event.

4.B Task starting

    After all of the image has been loaded for the application, but
    before executing the first instruction, this event will occur.

        W1  = DBG_TASKSTART (0Ah)
        W2  = Unused
        W3  = Unused
        W4  = Unused
        DW3 = Pointer to an IMAGE_NOTE structure in NTVDM address space
        DW4 = Reserved

    IMAGE_NOTE structure field definitions will be:

        Module    - Null terminated module name
        FileName  - Null terminated path to executable image

    VDMProcessException will return TRUE for this event.

4.C Task stopping

    After all of the image has been unloaded for the application
    this event will occur.  None of the segments for the application
    will be valid.  This is provided for the debugger to clean up any
    internal data it keeps on a per task basis.

        W1  = DBG_TASKSTOP (0Bh)
        W2  = Unused
        W3  = Unused
        W4  = Unused
        DW3 = Pointer to an IMAGE_NOTE structure in NTVDM address space
        DW4 = Reserved

    IMAGE_NOTE structure field definitions will be:

        Module    - Null terminated module name
        FileName  - Null terminated path to executable image

    VDMProcessException will return TRUE for this event.

4.D Dll starting

    After the image of the DLL has been loaded, but before the
    Dll's initialization code is executed, this event will occur.

        W1  = DBG_DLLSTART (0Ch)
        W2  = Unused
        W3  = Unused
        W4  = Unused
        DW3 = Pointer to an IMAGE_NOTE structure in NTVDM address space
        DW4 = Reserved

    IMAGE_NOTE structure field definitions will be:

        Module    - Null terminated module name
        FileName  - Null terminated path to executable image

    VDMProcessException will return TRUE for this event.

4.E Dll stopping

    After all of the image of the DLL has been unloaded for the Dll
    this event will occur.  None of the segments for the Dll will be
    valid.  This is provided for the debugger to clean up any internal
    data it keeps on a per Dll basis.

        W1  = DBG_DLLSTOP (0Ch)
        W2  = Unused
        W3  = Unused
        W4  = Unused
        DW3 = Pointer to an IMAGE_NOTE structure in NTVDM address space
        DW4 = Reserved

    IMAGE_NOTE structure field definitions will be:

        Module    - Null terminated module name
        FileName  - Null terminated path to executable image

    VDMProcessException will return TRUE for this event.

4.F Attach Acknowlegement

    Once the 16-bit environment has detected that a debugger is present
    it sends this event to allow the debugger to perform any initialization
    processing specific to the 16-bit environment.

        W1  = DBG_ATTACH (0Dh)
        W2  = Unused
        W3  = Unused
        W4  = Unused
        DW3 = Unused
        DW4 = Reserved

    VDMProcessException will return TRUE for this event.

5.0 The VDM debugging APIs

    These APIs are described below:

        VDMProcessException
        VDMGetThreadSelectorEntry
        VDMGetPointer
        VDMGetThreadContext
        VDMSetThreadContext
        VDMGetSelectorModule
        VDMGetModuleSelector
        VDMEnumProcessWOW
        VDMEnumTaskWOW

    The following APIs require WOWDEB.EXE to be loaded and running in the
    Win16 subsystem.  WOWDEB.EXE is started automatically if the debugger
    is present at process creation time (CreateProcess with debug options
    set). If the debugger is attached to the Win16 subsystem process after
    the process has already been created (with the DebugActiveProcess API),
    then the debugger should spawn WOWDEB.EXE before starting the Win16 task
    to be debugged.

        VDMModuleFirst
        VDMModuleNext
        VDMGlobalFirst
        VDMGlobalNext

    This following APIs are obsolete.  They return failure conditions.

        VDMKillWOW
        VDMDetectWOW
        VDMBreakThread

5.1 VDMProcessException

    BOOL VDMProcessException(
        LPDEBUG_EVENT   lpDebugEvent
    );

    The VDMProcessExecption function performs the pre-processing needed to
    prepare the debug event for handling by the debugger.

    This function filters all VDM debugee/debugger communication for
    information which is only used by the VDM debugging DLL (VDMDBG.DLL).
    This function is only valid in the context of processing for debug
    events that are of type STATUS_VDM_EVENT.

    lpDebugEvent    Points to a DEBUG_EVENT structure that was returned
                    from WaitForDebugEvent.

    The return value is TRUE if the debug event should be processed by the
    debugger.

    The return value is FALSE if the debug event should be ignored.  This
    This indicates that no processing should occur for this debug event.
    The event should be continued using ContinueDebugEvent with a continue
    status of DBG_CONTINUE.

5.2 VDMGetThreadSelectorEntry

    BOOL VDMGetThreadSelectorEntry(
        HANDLE          hProcess,
        HANDLE          hThread,
        WORD            wSelector
        LPLDT_ENTRY     lpSelectorEntry
    );

    This function is used to return a descriptor table entry for the
    specified VDM thread corresponding to the specified selector.  This
    function is simimlar to the API GetThreadSelectorEntry except that
    it works on the simulated DOS/WIN16 environment, and it works on all
    systems, not just x86 systems.

    This API returns a simulated descriptor entry on non-x86 systems.
    Simulated descriptor entrys may (on some systems) have the base value
    adjusted to account for the fact that the simulated address space may
    not begin at linear (32-bit) address 0.

    It is also important to note that 16-bit applications may modify
    the contents of the LDT entries.  For example, the Win16 subsystem
    may change the selector's base value to coalesce discontinous memory
    segments.  Also, please see the description in VDMGetPointer.

    hProcess        Supplies a handle to the DOS/WIN16 sub-system process.
                    The handle must have been created with PROCESS_VM_READ
                    access.

    hThread         Supplies a handle to the thread that contains the
                    specified selector.  The handle must have been created
                    with THREAD_QUERY_INFORMATION access.

    wSelector       Supplies the selector value to look up.  The selector
                    value may be a global selector (GDT) or a local selector
                    (LDT).

    lpSelectorEntry If the specifed selector is contained within the
                    thread's descriptor tables, its descriptor table entry
                    is copied into the data structure pointed to by this
                    parameter.  This data can be used to compute the linear
                    base address that segment relative addresses refer to.

    The return value is TRUE if the operation was successful.  In that case,
    the data structure pointed to by lpSelectorEntry receives a copy of the
    specified descriptor table entry.

    Refer to the WinHelp entry for the structure of an LDT_ENTRY.

5.3 VDMGetPointer

    ULONG VDMGetPointer(
        HANDLE          hProcess,
        HANDLE          hThread,
        WORD            wSelector,
        DWORD           dwOffset,
        BOOL            fProtMode
    );

    This function is used to convert a 16-bit address into a flat 32-bit
    address.

    It is also very important to note that under the WIN16 environment,
    pointers derived from protected mode selectors may change.  WIN16 does
    this by changing selector's base value to coalesce memory during
    compaction.  For this reason, it is necessary that any addresses
    evaluated in the 16-bit environment should be reevaluated each time
    an access into 16-bit memory is needed.  An example would be
    placing and removing 16-bit breakpoint instructions.  If the debugger
    is told to place a breakpoint at a given address of SEL:OFFSET, then
    when the breakpoint is needs to be removed, the debugger must reevaluate
    the SEL:OFFSET address since it might have moved in terms of the linear
    32-bit address.

    hProcess        Supplies a handle to the DOS/WIN16 sub-system process.
                    The handle must have been created with PROCESS_VM_READ
                    access.

    hThread         Supplies a handle to the thread that contains the
                    specified selector.  The handle must have been created
                    with THREAD_QUERY_INFORMATION access.

    wSelector       Supplies the selector value to determine the pointer for.

    dwOffset        Supplies the offset value to determine the pointer for.

    fProtMode       Indicates whether the 16-bit address specified is a
                    real mode (v86 mode) address or a protected mode address.
                    Protected mode addresses are translated through the
                    descriptor tables.

    The return value is a 32-bit linear address pointing to the memory
    in the simulated DOS/WIN16 environment that represents the 16-bit address
    specified.  The return value is NULL, if the address specified is invalid.
    On some systems, NULL may be returned for the address 0:0.

    To determine the address of the simulated 16-bit memory, VDMGetPointer
    may be called with the address 0:0 and an fProtMode of FALSE.

5.4 VDMGetThreadContext

    BOOL VDMGetThreadContext(
        LPDEBUG_EVENT   lpDebugEvent,
        LPVDMCONTEXT    lpVDMContext
    );

    The context of a specified simulated DOS or WIN16 thread can be
    retrieved using VDMGetThreadContext.  The context returned will
    always be that of an x86 system.

    This API returns a simulated context for x86 and non-x86 systems.
    Under some systems, values within the context are meaningless.  For
    example, the CONTEXT_DEBUG_REGISTERS portions on RISC systems have
    no effect.

    Release 1 of Windows NT has a 286 emulator on RISC systems.  For this
    reason, only the 16-bit registers can be supported on RISC systems.

    lpDebugEvent    Points to a DEBUG_EVENT structure that was returned
                    from WaitForDebugEvent.

    lpVDMContext    If the specified thread is a simulated DOS or WIN16
                    thread, its context is copied into the data structure
                    pointed to by this parameter.

    The return value is TRUE if the operation was successful.  In that case,
    the data structure pointed to by <lpVDMContext> receives a copy of the
    simulated context.

    Refer to the WinHelp for the structure of a VDMCONTEXT (same as x86
    CONTEXT structure in NTI386.H).

5.5 VDMSetThreadContext

    BOOL VDMSetThreadContext(
        LPDEBUG_EVENT   lpDebugEvent,
        LPVDMCONTEXT    lpVDMContext
    );

    The VDMSetThreadContext function sets the simulated context in the
    specified DOS or WIN16 thread.  The function allows selective context
    to be set based on the value of the ContextFlags member of the context
    structure.  This API operates only when debugging a simulated DOS or
    WIN16 thread.  The caller must have a thread handle which was created
    with THREAD_SET_CONTEXT access.

    The context set will always be that of an x86 system.

    lpDebugEvent    Points to a DEBUG_EVENT structure that was returned
                    from WaitForDebugEvent.

    lpVDMContext    Supplies the address of a context structure that
                    contains the context that is to be set in the specified
                    thread.  The value of the ContextFlags member of this
                    structure specifies which portions of a thread's context
                    are to be set.  Some values in the context structure are
                    not settable and are silently set to the correct values.
                    This include CPU status register bits that specify
                    processor mode, debug register global enabling bits, and
                    other state that must be completely controlled by the
                    system.

    The return value is TRUE if the context was set; otherwise it is FALSE if
    an error occurred.

    Refer to the WinHelp for the structure of a VDMCONTEXT (same as x86
    CONTEXT structure in NTI386.H).

5.6 VDMGetSelectorModule

    BOOL VDMGetSelectorModule(
        HANDLE          hProcess,
        HANDLE          hThread,
        WORD            wSelector,
        PUINT           lpSegmentNumber,
        LPSTR           lpModuleName,
        UINT            nSize,
        LPSTR           lpModulePath,
        UINT            nPathSize
    );

    The VDMGetSelectorModule function is intended to provide an interface
    such that debuggers can determine which module belongs to a code or
    data address.  Given the selector for that address, the function will
    return the module name, and the segment number (0 based) of the segment
    that corresponds to that selector.  If the selector is not a selector
    which directly corresponds to a module, the function will return FALSE.

    hProcess        Supplies a handle to the process of the 16-bit environment

    hThread         Supplies a handle to a thread in the 16-bit environment

    wSelector       Supplies the selector value to look up.

    lpSegmentNumber Returns the segment number within the module.

    lpModuleName    Buffer to receive the module name.

    nModuleSize     Size of the buffer.

    lpModulePath    Buffer to receive the module path name.

    nPathSize       Size of the buffer.

    The return value is TRUE if the selector is mapped directly to a module.
    This means it must be either a code or data segment.  Selectors allocated
    using the global memory management functions are not mapped directly to
    a module.  The return value is FALSE if the function is not successful.

    The function returns the segment number in the address specified by
    the lpSegmentNumber parameter, and the module name in the address
    specified by the lpModuleName parameter.

    It is up to the debugger to determine from the module and segment number
    information the correct symbol, if a symbol lookup is needed.

5.7 VDMGetModuleSelector

    BOOL VDMGetModuleSelector(
        HANDLE          hProcess,
        HANDLE          hThread,
        UINT            uSegmentNumber,
        LPSTR           lpModuleName,
        LPWORD          lpSelector
    );

    The VDMGetModuleSelector function is the reverse operation of the
    VDMGetSelectorModule function.  A module name and segment number
    are converted into a selector number.

    hProcess        Supplies a handle to the process of the 16-bit environment

    hThread         Supplies a handle to a thread in the 16-bit environment

    uSegmentNumber  Supplies the segment number to look up.

    lpModuleName    Specifies the module name of the segment.

    lpSelector      Returns the selector value.

    The return value is TRUE if the module and segment are found.  Also,
    the lpSelector value is filled-in with the selector of that segment.
    Otherwise, the return value is FALSE.

    It is up to the debugger to convert symbol names and expressions into
    modules, segment numbers and offsets.  Usings the modules and segment
    numbers, a selector value can be determined.  In combination with the
    offset, the selector can be used to index into the simulated Win16
    environment for reading, writing, etc.

5.8 VDMEnumProcessWOW

    INT VDMEnumProcessWOW(
        PROCESSENUMPROC fp,
        LPARAM          lparam
    );

    The VDMEnumProcessWOW function enumerates all of the processes in
    the system which are Win16 subsystem processes.  In NT's first release,
    there is only one Win16 subsystem.  For later releases, there may be
    more than one process to support address space seperation for Win16
    tasks.

    fp              Supplies the address of a callback routine.

    lparam          Supplies a parameter to the callback routine.

    The return value is the number of Win16 subsystem processes, or the
    number enumerated before enumeration was terminated.

    BOOL ProcessEnumProc(
        DWORD           dwProcessId,
        DWORD           dwAttributes,
        LPARAM          lparam
    );

    The callback function will be called once for each Win16 subsystem process
    in the system.

    dwProcessId     Provides the process id of a Win16 subsystem.

    dwAttributes    Provides flags indicating information about the process.

    lparam          Provides the parameter passed to VDMEnumProcessWOW

    The callback function should return a non-zero value to terminate
    enumeration.

    The dwAttributes field should be compared with the bit mask WOW_SYSTEM
    to determine if the process is the main Win16 subsystem process.  The
    main Win16 subsystem process will be the process that the next Win16
    task that specifies no address space seperation requirements.

    Win16 subsystem processes which are created due to address space
    seperation will not have the WOW_SYSTEM bit enabled.

5.9 VDMEnumTaskWOW

    INT
    VDMEnumTaskWOW(
        DWORD           dwProcessId,
        TASKENUMPROC    fp,
        LPARAM          lparam
    );

    The VDMEnumTaskWOW function enumerates all of the Win16 tasks currently
    running in the Win16 subsystem process id specified.

    dwProcessId     Supplies the process id of the Win16 subsystem.

    fp              Supplies the address of a callback routine.

    lparam          Supplies a parameter to the callback routine.

    The return value is the number of Win16 tasks or the number of
    tasks enumerated before terminating.

    BOOL TaskEnumProc(
        DWORD           dwThreadId,
        WORD            hMod16,
        WORD            hTask16,
        LPARAM          lparam
    );

    The callback function will be called once for each Win16 task.

    dwThreadId      Provides the thread id of the Win16 task

    hMod16          Provides the Win16 module handle for the task

    hTask16         Provides the Win16 task handle for the task

    lparam          Provides the parameter passed to VDMEnumTaskWOW

    The callback function should return a non-zero value to terminate
    enumeration.

5.A VDMModuleFirst

    BOOL VDMModuleFirst(
        HANDLE          hProcess,
        HANDLE          hThread,
        LPMODULEENTRY   lpModuleEntry,
        DEBUGEVENTPROC  lpEventProc,
        LPVOID          lpData
    );

    This function is used to start enumerating all of the modules currently
    loaded in the 16-bit Windows environment.  It behaves in the same manner
    as the Windows 3.1 ToolHelp API ModuleFirst().

    hProcess        Supplies a handle to the process of the 16-bit environment

    hThread         Supplies a handle to a thread in the 16-bit environment

    lpModuleEntry   Specifies the address of a MODULEENTRY structure which
                    will be filled in with the first module in the module
                    list.

    lpEventProc     Specifies the address of a procedure which might be
                    called in the event of a debug event occuring while
                    the communication session with the 16-bit enviroment
                    is occurring.

    lpData          Specifies a parameter to pass to the debug event procudure

    The return value is TRUE if the operation was successful.  In that case,
    the MODULEENTRY structure will be filled in with information for the
    first module in the module list.

5.B VDMModuleNext

    BOOL VDMModuleNext(
        HANDLE          hProcess,
        HANDLE          hThread,
        LPMODULEENTRY   lpModuleEntry,
        DEBUGEVENTPROC  lpEventProc,
        LPVOID          lpData
    );

    This function is used to continue enumerating all of the modules currently
    loaded in the 16-bit Windows environment.  It behaves in the same manner
    as the Windows 3.1 ToolHelp API ModuleNext().

    hProcess        Supplies a handle to the process of the 16-bit environment

    hThread         Supplies a handle to a thread in the 16-bit environment

    lpModuleEntry   Specifies the address of a MODULEENTRY structure which
                    will be used to determine the next module and which will
                    be filled in with the next module in the module list.

    lpEventProc     Specifies the address of a procedure which might be
                    called in the event of a debug event occuring while
                    the communication session with the 16-bit enviroment
                    is occurring.

    lpData          Specifies a parameter to pass to the debug event procudure

    The return value is TRUE if the operation was successful.  In that case,
    the MODULEENTRY structure will be filled in with information for the
    next module in the module list.

5.C VDMGlobalFirst

    BOOL VDMGlobalFirst(
        HANDLE          hProcess,
        HANDLE          hThread,
        LPGLOBALENTRY   lpGlobalEntry,
        WORD            wFlags,
        DEBUGEVENTPROC  lpEventProc,
        LPVOID          lpData
    );

    This function is used to continue enumerating all of the global memory
    blocks currently allocated in the 16-bit Windows environment.  It
    behaves in the same manner as the Windows 3.1 ToolHelp API GlobalFirst().

    hProcess        Supplies a handle to the process of the 16-bit environment

    hThread         Supplies a handle to a thread in the 16-bit environment

    lpModuleEntry   Specifies the address of a GLOBALENTRY structure which
                    will be filled in with information for the first global
                    memory block matching the specified flags

    wFlags          Specifies which types of global memory blocks to enumerate

    lpEventProc     Specifies the address of a procedure which might be
                    called in the event of a debug event occuring while
                    the communication session with the 16-bit enviroment
                    is occurring.

    lpData          Specifies a parameter to pass to the debug event procudure

    The return value is TRUE if the operation was successful.  In that case,
    the GLOBALENTRY structure will be filled in with information for the
    first global memory block that matches the specified flags.

5.D VDMGlobalNext

    BOOL VDMGlobalNext(
        HANDLE          hProcess,
        HANDLE          hThread,
        LPGLOBALENTRY   lpGlobalEntry,
        WORD            wFlags,
        DEBUGEVENTPROC  lpEventProc,
        LPVOID          lpData
    );

    This function is used to continue enumerating all of the global memory
    blocks currently allocated in the 16-bit Windows environment.  It behaves
    in the same manner as the Windows 3.1 ToolHelp API GlobalNext().

    hProcess        Supplies a handle to the process of the 16-bit environment

    hThread         Supplies a handle to a thread in the 16-bit environment

    lpModuleEntry   Specifies the address of a GLOBALENTRY structure which
                    will be used to determine the next global memory block
                    and which will be filled in with information for the
                    next global memory block matching the specified flags

    wFlags          Specifies which types of global memory blocks to enumerate

    lpEventProc     Specifies the address of a procedure which might be
                    called in the event of a debug event occuring while
                    the communication session with the 16-bit enviroment
                    is occurring.

    lpData          Specifies a parameter to pass to the debug event procudure

    The return value is TRUE if the operation was successful.  In that case,
    the GLOBALENTRY structure will be filled in with information for the
    next global memory block that matches the specified flags.

5.E VDMKillWOW

    BOOL VDMKillWOW(void);

    This function is obsolete and performs no operation.  It returns FALSE.

5.F VDMDetectWOW

    BOOL VDMDetectWOW(void);

    This function is obsolete and performs no operation. It returns FALSE.

5.G VDMBreakThread

    BOOL VDMBreakThread(
        HANDLE          hProcess
        HANDLE          hThread
    );

    This function is obsolete and performs no operation.  It returns FALSE.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\bin\rcpp.err ===
/* SCCSWHAT( "@(#)c1.err	2.29 88/02/25 18:18:00	" ) */
						/* fatals */

1001	"Internal Compiler Error\n\t\t(compiler file '%s', line %d)\n\t\tContact Microsoft Technical Support"
1002	"out of heap space"
1003	"error count exceeds %d; stopping compilation"
1004	"unexpected EOF"
1005	"string too big for buffer"
1006	"write error on compiler intermediate file"
1007	"unrecognized flag '%s' in '%s'"
1008	"no input file specified"
1009	"compiler limit : macros too deeply nested"
1010	"compiler limit : macro expansion too big"
1012	"bad parenthesis nesting - missing '%c'"
1013	"cannot open source file '%s'"
1014	"too many include files"
1015	"cannot open include file '%s'"
1016	"#if[n]def expected an identifier"
1017	"invalid integer constant expression"
1018	"unexpected '#elif'"
1019	"unexpected '#else'"
1020	"unexpected '#endif'"
1021	"bad preprocessor command '%s'"
1022	"expected '#endif'"
1023	"no int size specified"
1024	"no ptr size specified"
1025	"no function size specified"
1026	"parser stack overflow, please simplify your program"
1027	"DGROUP data allocation exceeds 64K"	/* QC, c23 */
1028	"%s segment allocation exceeds 64K"	/* QC */
1031	"compiler limit : function calls too deeply nested"	/* QC, c23 */
1032	"cannot open object listing file '%s'"			/* QC, c23 */
1035	"expression too complex, please simplify"		/* QC, c23 */
1037	"cannot open object file '%s'"					/* QC, c23 */
1041	"cannot open compiler intermediate file - no more files"
1042	"cannot open compiler intermediate file - no such file or directory"
1043	"cannot open compiler intermediate file"
1044	"out of disk space for compiler intermediate file"
1045	"floating point overflow"
1047	"too many %s flags, '%s'"
1048	"unknown option '%c' in '%s'"
1049	"invalid numerical argument '%s'"
1052	"too many #if/#ifdef's"
1053	"compiler limit : struct/union nesting"
1054	"compiler limit : initializers too deeply nested"
1055	"compiler limit : out of keys"
1056	"compiler limit : out of macro expansion space"
1057	"unexpected EOF in macro expansion (missing ')'?)"
1059	"out of near heap space"
1060	"out of far heap space"
1061	"compiler limit : blocks too deeply nested"	/* QC */
1062	"error writing to preprocessor output file"
1063	"compiler limit : compiler stack overflow"	/* QC */
1064	"compiler limit : identifier overflowed internal buffer"
1065	"compiler limit : declarator too complex"
1000	"UNKNOWN FATAL ERROR\n\t\tContact Microsoft Technical Support"

						/* errors */
	
2001	"newline in constant"
2002	"out of macro actual parameter space"
2003	"expected 'defined id'"
2004	"expected 'defined(id)'"
2005	"#line expected a line number, found '%s'"
2006	"#include expected a file name, found '%s'"
2007	"#define syntax"
2008	"'%c' : unexpected in macro definition"
2009	"reuse of macro formal '%s'"
2010	"'%c' : unexpected in formal list"
2011	"'%s' : definition too big"
2012	"missing name following '<'"
2013	"missing '>'"
2014	"preprocessor command must start as first non-whitespace"
2015	"too many chars in constant"
2016	"no closing single quote"
2017	"illegal escape sequence"
2018	"unknown character '0x%x'"
2019	"expected preprocessor command, found '%c'"
2020	"bad octal number '%c'"
2021	"expected exponent value, not '%c'"
2022	"'%ld' : too big for char"
2023	"divide by 0"
2024	"mod by 0"
2025	"'%s' : enum/struct/union type redefinition"
2026	"'%s' : member of enum redefinition"
2028	"struct/union member needs to be inside a struct/union"
2029	"'%Fs' : bit-fields only allowed in structs"
2030	"'%Fs' : struct/union member redefinition"
2031	"'%Fs' : function cannot be struct/union member"
2032	"'%Fs' : base type with near/far/huge not allowed"
2033	"'%Fs' : bit-field cannot have indirection"
2034	"'%Fs' : bit-field type too small for number of bits"
2035	"enum/struct/union '%Fs' : unknown size"
2036	"left of '%s%s' must have a struct/union type"
2037	"left of '%s' specifies undefined struct/union '%Fs'"
2038	"'%s' : not struct/union member"
2039	"'->' requires struct/union pointer"
2040	"'.' requires struct/union name"
2042	"signed/unsigned keywords mutually exclusive"
2043	"illegal break"
2044	"illegal continue"
2045	"'%s' : label redefined"
2046	"illegal case"
2047	"illegal default"
2048	"more than one default"
2050	"non-integral switch expression"
2051	"case expression not constant"
2052	"case expression not integral"
2053	"case value %d already used"
2054	"expected '(' to follow '%Fs'"
2055	"expected formal parameter list, not a type list"
2056	"illegal expression"
2057	"expected constant expression"
2058	"constant expression is not integral"
2059	"syntax error : '%s'"
2060	"syntax error : EOF"
2061	"syntax error : identifier '%s'"
2062	"type '%s' unexpected"
2063	"'%s' : not a function"
2064	"term does not evaluate to a function"
2065	"'%s' : undefined"
2066	"cast to function returning . . . is illegal"
2067	"cast to array type is illegal"
2068	"illegal cast"
2069	"cast of 'void' term to non-void"
2070	"illegal sizeof operand"
2071	"'%Fs' : bad storage class"
2072	"'%Fs' : initialization of a function"
2073	"'%Fs' : cannot initialize array in function"
2074	"'%Fs' : cannot initialize struct/union in function"
2075	"'%Fs' : array initialization needs curly braces"
2076	"'%Fs' : struct/union initialization needs curly braces"
2077	"non-integral field initializer '%Fs'"
2078	"too many initializers"
2079	"'%Fs' uses undefined struct/union '%Fs'"
2082	"redefinition of formal parameter '%Fs'"
2083	"array '%Fs' already has a size"
2084	"function '%Fs' already has a body"
2085	"'%Fs' : not in formal parameter list"
2086	"'%Fs' : redefinition"
2087	"'%Fs' : missing subscript"
2088	"use of undefined enum/struct/union '%s'"
2089	"typedef specifies a near/far function"
2090	"function returns array"
2091	"function returns function"
2092	"array element type cannot be function"
2093	"cannot initialize a static or struct with address of automatic vars"
2094	"label '%Fs' was undefined"
2095	"'%Fs' : actual has type void : parameter %d"
2096	"struct/union comparison illegal"
2097	"illegal initialization"
2098	"non-address expression"
2099	"non-constant offset"
2100	"illegal indirection"
2101	"'&' on constant"
2102	"'&' requires lvalue"
2103	"'&' on register variable"
2104	"'&' on bit-field ignored"
2105	"'%s' needs lvalue"
2106	"'%s' : left operand must be lvalue"
2107	"illegal index, indirection not allowed"
2108	"non-integral index"
2109	"subscript on non-array"
2110	"'+' : 2 pointers"
2111	"pointer + non-integral value"
2112	"illegal pointer subtraction"
2113	"'-' : right operand pointer"
2114	"'%s' : pointer on left; needs integral right"
2115	"'%s' : incompatible types"
2116	"'%s' : bad %s operand"
2117	"'%s' : illegal for struct/union"
2118	"negative subscript"
2119	"'typedefs' both define indirection"
2120	"'void' illegal with all types"
2121	"typedef specifies different enum"
2122	"typedef specifies different struct"
2123	"typedef specifies different union"
2125	"%Fs : allocation exceeds 64K"		/* QC, c23 */
2126	"%Fs : auto allocation exceeds %s"	/* QC, c23 */
2127	"parameter allocation exceeds 32K"	/* QC, c23 */
2130	"#line expected a string containing the file name, found '%s'"
2131	"attributes specify more than one near/far/huge"
2132	"syntax error : unexpected identifier"
2133	"array '%Fs' : unknown size"
2134	"'%Fs' : struct/union too large"
2135	"missing ')' in macro expansion"
2137	"empty character constant"
2138	"unmatched close comment '*/'"
2139	"type following '%s' is illegal"
2140	"argument type cannot be function returning . . ."
2141	"value out of range for enum constant"
2142	"ellipsis requires three periods"
2143	"syntax error : missing '%s' before '%s'"
2144	"syntax error : missing '%s' before type '%Fs'"
2145	"syntax error : missing '%s' before identifier"
2146	"syntax error : missing '%s' before identifier '%s'"
2147	"unknown size"
2148	"array too large"
2149	"'%Fs' : named bit-field cannot have 0 width"
2150	"'%Fs' : bit-field must have type int, signed int, or unsigned int"
2151	"more than one cdecl/fortran/pascal attribute specified"
2152	"'%s' : pointers to functions with different attributes"
2153	"hex constants must have at least 1 hex digit"
2154	"'%s' : does not refer to a segment"
2155	"'%s' : already in a segment"
2156	"pragma must be at outer level"
2157	"'%s' : must be declared before use in pragma list"
2158	"'%s' : is a function"
2159	"more than one storage class specified"
2160	"## cannot occur at the beginning of a macro definition"
2161	"## cannot occur at the end of a macro definition"
2162	"expected macro formal parameter"
2163	"'%s' : not available as an intrinsic"
2164	"'%s' : intrinsic was not declared"
2165	"'%s' : cannot modify pointers to data"
2166	"lval specifies 'const' object"
2167	"'%Fs' : too many actual parameters for intrinsic"
2168	"'%Fs' : too few actual parameters for intrinsic"
2169	"'%Fs' : is an intrinsic, it cannot be defined"
2170	"'%s' : intrinsic not declared as a function"
2171	"'%s' : bad operand"
2172	"'%Fs' : actual is not a pointer : parameter %d"
2173	"'%Fs' : actual is not a pointer : parameter %d, parameter list %d"
2174	"'%Fs' : actual has type void : parameter %d, parameter list %d"
2175	"'%Fs' : unresolved external"	/* QC */
2176	"static far data not supported"	/* QC */
2177	"constant too big"
2178	"'%s' : storage class for same_seg variables must be 'extern'"
2179	"'%Fs' : was used in same_seg, but storage class is no longer 'extern'"
2180	"controlling expression has type 'void'"
2181	"pragma requires command line option '%s'"	/* QC */
2182	"'%Fs' : 'void' on variable"
2183	"'%Fs' : 'interrupt' function must be 'far'"
2184	"'%Fs' : '%s' function cannot be 'pascal/fortran'"
2186	"'%Fs' : 'saveregs/interrupt' modifiers mutually exclusive"
2187	"cast of near function pointer to far function pointer"
2188	"#error : %s"
2190	"'%s' : is a text segment"
2191	"'%s' : is a data segment"
2192	"'%s' : function has already been defined"
2000	"UNKNOWN ERROR\n\t\tContact Microsoft Technical Support"

						/* warnings */
	
4001	"macro '%s' requires parameters"
4002	"too many actual parameters for macro '%s'"
4003	"not enough actual parameters for macro '%s'"
4004	"missing close parenthesis after 'defined'"
4005	"'%s' : redefinition"
4006	"#undef expected an identifier"
4009	"string too big, trailing chars truncated"
4011	"identifier truncated to '%s'"
4012	"float constant in a cross compilation"
4013	"constant too big"
4014	"'%Fs' : bit-field type must be unsigned"
4015	"'%Fs' : bit-field type must be integral"
4016	"'%s' : no function return type, using 'int' as default"
4017	"cast of int expression to far pointer"
4020	"'%Fs' : too many actual parameters"
4021	"'%Fs' : too few actual parameters"
4022	"'%Fs' : pointer mismatch : parameter %d"
4024	"'%Fs' : different types : parameter %d"
4025	"function declaration specified variable argument list"
4026	"function was declared with formal argument list"
4027	"function was declared without formal argument list"
4028	"parameter %d declaration different"
4029	"declared parameter list different from definition"
4030	"first parameter list is longer than the second"
4031	"second parameter list is longer than the first"
4032	"unnamed struct/union as parameter"
4033	"function must return a value"
4034	"sizeof returns 0"
4035	"'%Fs' : no return value"
4036	"unexpected formal parameter list"
4037	"'%Fs' : formal parameters ignored"
4038	"'%Fs' : formal parameter has bad storage class"
4039	"'%Fs' : function used as an argument"
4040	"near/far/huge on '%Fs' ignored"
4041	"formal parameter '%s' is redefined"
4042	"'%Fs' : has bad storage class"
4044	"huge on '%Fs' ignored, must be an array"
4045	"'%s' : array bounds overflow"
4046	"'&' on function/array, ignored"
4047	"'%s' : different levels of indirection"
4048	"array's declared subscripts different"
4049	"'%s' : indirection to different types"
4051	"data conversion"
4052	"different enum types"
4053	"at least one void operand"
4060	"conversion of long address to short address"	/* QC, c23 */
4061	"long/short mismatch in argument : conversion supplied"	/* QC, c23 */
4062	"near/far mismatch in argument : conversion supplied"	/* QC, c23 */
4067	"unexpected characters following '%s' directive - newline expected"
4068	"unknown pragma"
4071	"'%Fs' : no function prototype given"
4074	"non standard extension used - '%s'"
4075	"size of switch expression or case constant too large - converted to int"
4076	"'%s' : may be used on integral types only"
4077	"unknown check_stack option"
4079	"unexpected token '%s'"
4080	"expected 'identifier' for segment name, found '%s'"
4081	"expected a comma, found '%s'"
4082	"expected an identifier, found '%s'"
4083	"expected '(', found '%s'"
4084	"expected a pragma keyword, found '%s'"
4085	"expected [on | off]"
4086	"expected [1 | 2 | 4]"
4087	"'%Fs' : declared with 'void' parameter list"
4088	"'%Fs' : pointer mismatch : parameter %d, parameter list %d"
4089	"'%Fs' : different types : parameter %d, parameter list %d"
4090	"different 'const' attributes"
4091	"no symbols were declared"
4092	"untagged enum/struct/union declared no symbols"
4093	"unescaped newline in character constant in non-active code"
4094	"unexpected newline"
4095	"expected ')', found '%s'"
4096	"huge treated as far"		/* QC */
4098	"void function returning a value"
4099	"expected ')', (too many arguments?)"
4100	"'%Fs' : unreferenced formal parameter"
4101	"'%Fs' : unreferenced local variable"
4102	"'%Fs' : unreferenced label"
4103	"'%Fs' : function definition used as prototype"
4104	"'%s' : near data in same_seg pragma, ignored"
4105	"'%Fs' : code modifiers only on function or pointer to function"
4106	"pragma requires integer between 1 and 127"
4107	"pragma requires integer between 15 and 255"
4108	"pragma requires integer between 79 and 132"
4109	"unexpected identifier '%s'"
4110	"unexpected token 'int constant'"
4111	"unexpected token 'string'"
4112	"macro name '%s' is reserved, %s ignored"
4113	"function parameter lists differed"
4000	"UNKNOWN WARNING\n\t\tContact Microsoft Technical Support"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ctl3dv2\ctl3d.doc ===
Microsoft Word 6.0 Document MSWordDoc Word.Document.6E:\MSOFFICE\WINWORD\TEMPLATE\TECH2.DOT s New in Ctl3d - Version 2.09 Microsoft Word 6.0s New in Ctl3d - Version 2.13 NOTE: This is BETA software, no shipping version will be version 2.13. Once this passes by all the interested parties, and the bugs are worked out, I will release the version. It will most likely be called version 2.50 since it changes the subclassing technique used.  I will be filling in the details of the new functions and features, for now I am VERY interested in knowing if this version breaks any existing applications. Please try the new version with your current products to see if anything has been upset by the new release of ctl3d. New Functions Ctl3dSubclassCtlEx(HWND hwnd, int ct) Subclasses the specified window using the window type given in ct. These can be: CTL3D_BUTTON_CTL Button  CTL3D_LISTBOX_CTL Listbox CTL3D_EDIT_CTL Edit Control CTL3D_COMBO_CTL  Combo Box CTL3D_STATIC_CTL Static Control This function is meant to be use to subclass superclassed ( or cloned ) classes. If you superclass the edit control to make your own edit control ( MyEDIT ) you can use this function to do the subclass. This API does not perform checking on style bits and such to see if the control would normally be subclassed by ctl3d. This means it is very easy to get into trouble using this function.  Ctl3dUnsubclassCtl(HWND hwnd) This funciton will remove ctl3d s subclass from the specified window. Ctl3d s subclass can only be removed if there are no other subclasses on the window after ctl3d s subclass. In other words, if the window has been subclassed by anyone after ctl3d has subclassed the window, the subclass will not be removed. Ctl3d will disable itself in this case. Ctl3dIsAutoSubclass(void) Want to know if this application has already been autosubclassed ? This function will return TRUE if it is. Ctl3dUnAutoSubclass(void) Want to turn off automatic subclassing, may only while you create this particular dialog ? This funciton is what you want. It will turn off autosubclassing. However if another part of the application has also turned on automatic subclassing, then Ctl3dUnAutoSubclass may not remove the automatic subclassing. This funciton is meant to be used by DLLs who need to use automatic subclassing.  New Messages Win32: CTL3D_CTLCOLORMSGBOX CTL3D_CTLCOLOREDIT CTL3D_CTLCOLORLISTBOX CTL3D_CTLCOLORBTN CTL3D_CTLCOLORSCROLLBAR  CTL3D_CTLCOLORSTATIC CTL3D_CTLCOLORDLG Win16: CTL3D_CTLCOLOR (WM_USER+CTLMSGOFFSET) Ctl3d will send these messages to a dialog s window procedure when it has not recieved a response to the regular WM_CTL* messages from the dialogs dialog procedure. This allows MFC applications to handle the color messages that are being eaten between ctl3d and MFC. New Features Automatic Subclassing Ctl3d now automaticly subclasses any control ( that it would normally subclass ) as it is created on a dialog which has been subclassed by ctl3d. This means that controls created by CreateWindow on a dialog will be subclassed without having to call Ctl3dSubclassCtl.  Automatic Subclassing from a DLL Ctl3dAutoSubclass can be used from a DLL. If the client application has called Ctl3dAutoSubclass already, ctl3d keeps count of how many times it is called for the whole app.  Only the last Ctl3dUnregister , or the new Ctl3dUnAutoSubclass will cause the automatic subclassing to be turned off. Thread safe. Ctl3d is now safe to use if you have multiple user interface theads that own controls or dialogs.  Bugs Fixed Hanguel Windows: bug fixed in drawing text. Ctl3d shouldn t paint 3d borders around a icon anymore. Ctl3d shouldn t generate those nasty first chance exceptions in Win32 anymore. However there is still a fix to come. In Windows NT 3.1, ctl3d CANNOT send WM_CTL* color messages to the dialogs dialog proc because the pointer may not be valid. Ctl3d will send it s own CTL3D_CTL* messages in this case. This should be fixed in Daytona, stay tuned. Ctl3d should always paint the bottom of a combo box after it s list box has been dropped and removed. It sometime lost this 3d effect before.  Ctl3d should not send MFC ( or any application that used GetNextDlgItem and radio buttons ) into an infinite loop anymore. Ctl3d No longer paints the area around a radio button in the wrong color in WIN32.  filename TECH2.DOT 03/24/94 Normal Heading 1 Heading 2 Heading 3 Heading 4 Default Paragraph Font Footer Header Footnote Reference Footnote Text Normal Indent indent bullet single-sp bullet abstract bridge byline history art status revision history button-dir abstract title syntax biography title abstract bullet bulleted list 1 disclaimer description number figure in abstract comment numbered list 1 bulleted list 2 numbered list 2 figure in list table title table head no-head list add'l para example code list bulleted list 3 normal precode precode list keywords alpha list 2 quote quoted person note bulleted list note add'l para figure caption table in list example in list boxed heading boxed text button-open button-run code list 2 term1 def1 addl para term2 term3 table rule list para 2 list para 3 kyle,\\MONGOLIA\WRITER\KYLEMAR\CTL3DNEW\NEW3D.DOC Kyle,\\mongolia\writer\KYLEMAR\CTL3DNEW\NEW3D.DOC @Printer LPT1: winspool Printer Letter  N N N Printer Letter  N N N Times New Roman Symbol Arial CG Times Univers Courier New &E:\MSOFFICE\WINWORD\TEMPLATE\TECH2.DOT"What s New in Ctl3d - Version 2.09
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ctl3dv2\readme.txt ===
This source is for debugging purposes only. CTL3DV2.DLL is binplaced from the
\nt\private\mvdm\bin86 directory. It is built and maintained by DeanM. This
special WOW 16-bit version (built w/ SPECIAL_WOW_VERSION) has the load
directory detection disabled since it is a knownDLL (always started from
System32).
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ctl3dv2\new3d.doc ===
Microsoft Word 6.0 Document MSWordDoc Word.Document.6E:\MSOFFICE\WINWORD\TEMPLATE\TECH2.DOT s New in Ctl3d - Version 2.09 Microsoft Word 6.0s New in Ctl3d - Version 2.13 NOTE: This is BETA software, no shipping version will be version 2.13. Once this passes by all the interested parties, and the bugs are worked out, I will release the version. It will most likely be called version 2.50 since it changes the subclassing technique used.  I will be filling in the details of the new functions and features, for now I am VERY interested in knowing if this version breaks any existing applications. Please try the new version with your current products to see if anything has been upset by the new release of ctl3d. New Functions Ctl3dSubclassCtlEx(HWND hwnd, int ct) Subclasses the specified window using the window type given in ct. These can be: CTL3D_BUTTON_CTL Button  CTL3D_LISTBOX_CTL Listbox CTL3D_EDIT_CTL Edit Control CTL3D_COMBO_CTL  Combo Box CTL3D_STATIC_CTL Static Control This function is meant to be use to subclass superclassed ( or cloned ) classes. If you superclass the edit control to make your own edit control ( MyEDIT ) you can use this function to do the subclass. This API does not perform checking on style bits and such to see if the control would normally be subclassed by ctl3d. This means it is very easy to get into trouble using this function.  Ctl3dUnsubclassCtl(HWND hwnd) This funciton will remove ctl3d s subclass from the specified window. Ctl3d s subclass can only be removed if there are no other subclasses on the window after ctl3d s subclass. In other words, if the window has been subclassed by anyone after ctl3d has subclassed the window, the subclass will not be removed. Ctl3d will disable itself in this case. Ctl3dIsAutoSubclass(void) Want to know if this application has already been autosubclassed ? This function will return TRUE if it is. Ctl3dUnAutoSubclass(void) Want to turn off automatic subclassing, may only while you create this particular dialog ? This funciton is what you want. It will turn off autosubclassing. However if another part of the application has also turned on automatic subclassing, then Ctl3dUnAutoSubclass may not remove the automatic subclassing. This funciton is meant to be used by DLLs who need to use automatic subclassing.  New Messages Win32: CTL3D_CTLCOLORMSGBOX CTL3D_CTLCOLOREDIT CTL3D_CTLCOLORLISTBOX CTL3D_CTLCOLORBTN CTL3D_CTLCOLORSCROLLBAR  CTL3D_CTLCOLORSTATIC CTL3D_CTLCOLORDLG Win16: CTL3D_CTLCOLOR (WM_USER+CTLMSGOFFSET) Ctl3d will send these messages to a dialog s window procedure when it has not recieved a response to the regular WM_CTL* messages from the dialogs dialog procedure. This allows MFC applications to handle the color messages that are being eaten between ctl3d and MFC. New Features Automatic Subclassing Ctl3d now automaticly subclasses any control ( that it would normally subclass ) as it is created on a dialog which has been subclassed by ctl3d. This means that controls created by CreateWindow on a dialog will be subclassed without having to call Ctl3dSubclassCtl.  Automatic Subclassing from a DLL Ctl3dAutoSubclass can be used from a DLL. If the client application has called Ctl3dAutoSubclass already, ctl3d keeps count of how many times it is called for the whole app.  Only the last Ctl3dUnregister , or the new Ctl3dUnAutoSubclass will cause the automatic subclassing to be turned off. Thread safe. Ctl3d is now safe to use if you have multiple user interface theads that own controls or dialogs.  Bugs Fixed Hanguel Windows: bug fixed in drawing text. Ctl3d shouldn t paint 3d borders around a icon anymore. Ctl3d shouldn t generate those nasty first chance exceptions in Win32 anymore. However there is still a fix to come. In Windows NT 3.1, ctl3d CANNOT send WM_CTL* color messages to the dialogs dialog proc because the pointer may not be valid. Ctl3d will send it s own CTL3D_CTL* messages in this case. This should be fixed in Daytona, stay tuned. Ctl3d should always paint the bottom of a combo box after it s list box has been dropped and removed. It sometime lost this 3d effect before.  Ctl3d should not send MFC ( or any application that used GetNextDlgItem and radio buttons ) into an infinite loop anymore. Ctl3d No longer paints the area around a radio button in the wrong color in WIN32.  filename TECH2.DOT 03/24/94 Normal Heading 1 Heading 2 Heading 3 Heading 4 Default Paragraph Font Footer Header Footnote Reference Footnote Text Normal Indent indent bullet single-sp bullet abstract bridge byline history art status revision history button-dir abstract title syntax biography title abstract bullet bulleted list 1 disclaimer description number figure in abstract comment numbered list 1 bulleted list 2 numbered list 2 figure in list table title table head no-head list add'l para example code list bulleted list 3 normal precode precode list keywords alpha list 2 quote quoted person note bulleted list note add'l para figure caption table in list example in list boxed heading boxed text button-open button-run code list 2 term1 def1 addl para term2 term3 table rule list para 2 list para 3 kyle,\\MONGOLIA\WRITER\KYLEMAR\CTL3DNEW\NEW3D.DOC Kyle,\\mongolia\writer\KYLEMAR\CTL3DNEW\NEW3D.DOC @Printer LPT1: winspool Printer Letter  N N N Printer Letter  N N N Times New Roman Symbol Arial CG Times Univers Courier New &E:\MSOFFICE\WINWORD\TEMPLATE\TECH2.DOT"What s New in Ctl3d - Version 2.09
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\ddestrs\ddestrs.txt ===
The document breifly describes DdeStrs.exe.

DdeStrs is intended to exercise and stress Dde/Ddeml.

Some areas exercised in the test are ...

    o  Async/fAckRequest advise loops
    o  Async executes
    o  CF_TEXT, CF_DIB, CF_BITMAP, CF_METAFILEPICT, CF_PALETTE,
       and CF_ENHMETAFILE (w32 only) formats.
    o  DdeConnectList/DdeDisconnectList
    o  AppOwned handles [when -a option used]
    o  Variable client/server connects (number of instances running
       of ddestrs.exe)
    o  Cross process/In process and multithread communication.
    o  System Timers


The command line options are ...

DdeStrs [-#%,-e#,-t#,-d,-a,-s,-c,-f#,-nNAME,-i#,-p,-?]

    where -#% allow the user to specify the intensity of
	the run (# = [1...100]) and can be read as stress
	percentage.  1 being low stress 100 being high stress.

    where -e# allows override of the delay set by the stress
	level.	-e0 is usefull if the stress test is the only one
	running and it is desirable for the test to cover ground
	(number of windows, classes, and messages that are
	exercised).  # is in milliseconds.

    where -t# specifies the number of minutes for the test to run.  At
	the end of # minutes the test will shutdown.  Default is 4320 min
	(About a weekend).  Test can also be exited manually at any
	point.

    where -d selects debug mode.  This mode of operation displays
	additional test information and outputs failures to
	the debug terminal.  This mode is intended for debugging
	DdeStrs failures and not for use in public stress runs.

    where -a specifies to use AppOwned handle for data communications.

    where -s specifies that this instance is to run as server only
	[default is -s -c].

    where -c specifies that this instance is to run as client only.
	[default is -s -c].

    where -f# allow specific formats to be used.  Default is all
	formats.  If any specific formats are specified then only
	to formats will be used in the communication.

	[Ex - ddestrs -f1 -f2] will only use formats 1 and 2.

	Formats    1  CF_TEXT
		   2  CF_DIB
		   3  CF_BITMAP
		   4  CF_ENHMETAFILE  (w32 only)
		   5  CF_METAFILEPICT
		   6  CF_PALETTE

    where -nNAME specifies the computer name to connect to.  This
	is used for netdde and only needs to be specified on client
	applications.  NAME=servername, Example '-njohnsp1' for
	computer \\johnsp1.  Use Ddeshare.exe (w31 resources kit or
	Nt sdk) to setup the dde share enabling netdde to work.  DdeStrs
	Service Name=DdeStrs, Topic=Test, and permissions must be
	change or greater (ddestrs.exe uses executes).

    where -i# specifies the number of threads to execute.  # can
	be in the range [1..5].  This option is only available
	for Win Nt.

    where -p specifies pause before data update.  With this specified the user can
	manually start executes and advise updates.  With this connections are established, but
	no data is passed until manually started. DdeStrs adds a 'pause' button to allow stress
	to be started and stopped.  Default is NO -p.

    where -? brings up a brief help list of DdeStrs Options.

Test Usage ...

    Ddestrs will communicate with multiple copies of itself.  Each
    new instance of ddestrs started will cause other instances to
    connect to all running copies available for conversation.  This
    allows the stress level to be tailored both by the -#% and
    by the number of copies of the test running.

Focus Test Api ...

DdeQueryNextServer
DdeClientTransaction
DdeDisconnectList
DdeConnectList
DdeAccessData
DdeAddData
DdePostAdvise
DdeDisconnect
DdeUnaccessData
DdeInitialize
DdeNameService
DdeCreateStringHandle
DdeUninitialize
DdeFreeStringHandle
DdeCmpStringHandles
DdeQueryConvInfo
DdeCreateDataHandle
DdeFreeDataHandle
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\inc\header.txt ===
Header File Organization
        ------------------------

This document describes the rules for public Windows 3.1 header files.  These
rules are designed to promote consistency, clarity, Win32 compatibility, ANSI
compatibility, motherhood, and apple pie a la mode.

In the past, windows.h has been fairly randomly organized: it wasn't very
easy to look in the file and figure out how constants, types, and functions
are related.  However, the new windows.h is much more rationally organized,
and it's now far easier to understand and modify.  In interests of
consistency, readability, and maintainability, it's important that all of our
public header files are consistently organized.

    *  Include a copyright banner at the top of the file.  Something like:

/*****************************************************************************\
*                                                                             *
* header.h -    Brief description of purpose of header file                   *
*                                                                             *
*               Version 3.10                                                  *                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

       If this header file has been released before, the copyright date
       should be something like: 1985-1992.

    *  Arrange your header in functional groups, like windows.h.  Try to
       keep related types, structures, constants and functions as close
       together as possible in the header.  Separate functional groups
       within the header with a banner comment, as in windows.h.

    *  Within a functional group, general typedefs and constants should come
       first, followed by logically organized function prototypes.

    *  Constants or types used by only one or two functions should be
       declared near the function.

    *  Make sure that everything defined in the header file is included by
       default: don't require people to #define things to get certain
       definitions.

    *  If you do want to break up your header file, use the #define NOXXX
       convention used by windows.h.  Try not to have too many groups
       controled by NOXXX #defines, because they get confusing and hard to
       deal with.  Compiler speed and memory capacity is not the problem it
       once was, especially with precompiled headers.

    *  Constants designed to be ANDed or ORed should be defined in hex.
       The number of digits should reflect the data size: 2 for bytes,
       4 for words, and 8 for longs.  Long hex constants should have
       an appended L, e.g., 0x12345678L.

    *  Ordinal constants values (e.g., 1, 2, 3, 4) should be declared
       in decimal.

    *  Provide a comment on all #else's and #endif's that suggests its
       corresponding #ifdef: e.g.

            #ifdef FOO
            ...
            #else   /* FOO */

            #endif  /* !FOO */

    *  Precede the header file with #pragma pack(1), and terminate with
       #pragma pack().  This ensures that the structures declared in the
       header will be packed properly, regardless of what compiler packing
       options the user is using for his own code.  Because the Windows RC
       compiler chokes on #pragma statements in .rc files, it's a good idea
       to include this (and any other #pragmas) in an #ifndef RC_INVOKED.

            #ifndef RC_INVOKED
            #pragma pack(1)         /* Assume byte packing throughout */
            #endif  /* RC_INVOKED */

       and:

            #ifndef RC_INVOKED
            #pragma pack()          /* Revert to default packing */
            #endif  /* RC_INVOKED */

    *  Prevent multiple inclusion of your header file with the following
       construct:

            #ifndef _INC_MYHEADER
            #define _INC_MYHEADER

            ...body of header...

            #endif  /* _INC_MYHEADER */

       This is the convention used by the C runtimes.  For each header there
       is a #define that can be used to determine whether the header has
       already been included.



        Win32 Upward Compatibility
        --------------------------

Part of the goal of 3.1 is to provide a more unified API that will scale with
minimal pain to 32 bits in Win32.  To this end, there are a few things you
have to worry about in your headers (and in your code, but that's a different
story...)

In 32-bit Windows, almost all 16 bit parameters, return values, and field
types have been widened to 32 bits.  This allows us to generate much more
efficient code on the 386 and on RISC machines.

We need a way of declaring the quantities that will "float" to 32 bits in
32-bit Windows.  It turns out that the C language already provides for this
capability: the "int" type, for example, is 16 bits on 16 bit platforms, but
is 32 bits on 32 bit platforms.  "short" is always 16 bits on any platform,
"long" is always 32 bits, and "char" is always 8 bits.

So, functions and structures with "int" declarations are already portably
declared.  The problem, though is with the WORD type.  "WORD" has become an
industry-wide synonym for a 16 bit unsigned quantity.  But, it's also used
widely in Windows header files.

Enter the UINT type.  The new UINT type is typedef'd as "unsigned int": an
unsigned value that is 16 bits on 16 bit platforms, and floats to 32 bits on
32 bit platforms.  In the 3.1 headers, UINT is used in place of WORD wherever
the size of the return value, parameter, or field will change depending on
the platform.

This is a rule that applies to code you write too: on 32 bit platforms, use
of the UINT type rather than WORD will generate faster smaller code.  But be
careful of hard-coded size dependencies on WORD: be sure to use sizeof()
instead of constants, etc.

In some cases there may be structure fields whose size WON'T be changing in
32-bit windows, perhaps because the structure is used in a file format and
compatibility is required.  If you know ahead of time that this is the case,
be sure to use short and WORD to indicate 16 bit quantities across platforms.
There are a few of these exceptions with the 3.1 bitmap information
structures in windows.h.  If you don't know, then use UINT and int.

The new WPARAM, LPARAM, and LRESULT types, used for polymorphic or arbitrary
parameters and return values (e.g., the SendMessage() function), also provide
a useful degree of platform isolation.  The WPARAM type is similar to UINT in
that its size varies with the platform.  WPARAM should be used in function
parameter, return value, AND structure declarations, even though its size may
vary.  The use of these types indicates to the programmer that the value must
be cast and assigned to the proper type before use.

Hence, the following rules:

    *  Use int and UINT instead of short or WORD, UNLESS you know for sure
       that the quantity will remain 16 bits in 32-bit Windows.  The Windows
       HIWORD and LOWORD macros use WORD, for example.  Be sure to check your
       uses of short as well as WORD: there are probably a few lurking out
       there that should be changed to int.  Use int FAR* or UINT FAR* instead
       of LPINT or LPWORD.

    *  Use the LPARAM, WPARAM, and LRESULT types instead of WORD, LONG, or
       DWORD as appropriate.


        ANSI Compatibility
        ------------------

Public header files should be ANSI compliant so that people can take
advantage of the highest compiler warning levels possible.  This also helps
ensure that our header files work with a wider range of development tools.

    *  Don't define constants, typedefs, or functions named with a preceding
       underscore.  This violates the ANSI namespace conventions.  There are
       a few violations of this rule already in existence (e.g., _lread), but
       try not to create any new problems.  (The rules are actually more
       complicated than "don't use underscores", but you're safe if you keep
       away from them).

    *  Don't use "//" style comments in the header: these are convenient
       but non-ANSI, and warning level 4 complains.

    *  Always test your header file by compiling it with the -W4 compiler
       option to ensure that it's ANSI-compatible.

    *  Make sure that you have no identifier conflicts with the following
       C library header files (NOTE: This list may be incomplete.  It's
       a good start, though).

            assert.h
            ctype.h
            errno.h
            float.h
            limits.h
            locale.h
            math.h
            setjmp.h
            signal.h
            stdarg.h
            stddef.h
            stdio.h
            stdlib.h
            string.h
            time.h

    *  Structure declarations should be declared with the "tag" prefix, rather
       than a leading underscore, as shown below:

         typedef struct tagFOO
         {
            int i;
            UINT u;
         } FOO;

    *  Declare fully-prototyped typedefs for all callback functions.  By
       convention, the type name should be all caps and end in PROC. For
       example, the window procedure callback function typedef from windows.h:

        typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);

        Windows 3.0 Backward Compatibility
        ----------------------------------

In order to allow users to develop applications with 3.1 headers that will
still run on 3.0, users can #define the WINVER constant to be equal to the
version number of Windows they are compiling against.  For 3.0, this would be
0x0300.  This constant should be used to ensure that new, non-3.0 compatible
features are not declared when the user is compiling a 3.0 application.  Keep
in mind that this version number is hex, not decimal (to be compatible with
the GetExpWinVer() API).

Some of you may own headers that are designed to work with windows 3.0 as
well as 3.1: in this case, you won't have some of the new 3.1 typedefs and
macros defined (e.g., UINT).  You can use #ifdef _INC_WINDOWS to determine
whether you've included the 3.1 windows.h.  Because yours may not be the only
header that will want to define certain types like UINT and LPCSTR, you
should #define these to be WORD and LPSTR, respectively, since you cannot
typedef something twice.  The other option, of course, is to have separate
3.0 and 3.1 versions of your header.

    *  New, non-3.0 compatible declarations and definitions should be inside
       #ifdef (WINVER >= 0x030a)/#endif so that the 3.1 headers can be used
       to create 3.0-compatible applications.

    *  If your header must be compatible with the 3.0 windows.h, use #ifdef
       _INC_WINDOWS around #definitions that define the missing types.  The
       3.0 windows.h file did not #define _INC_WINDOWS.
       Use #define rather than typedef to ensure that other headers can
       safely do the same thing.  Here's an example that will handle
       most of the common problems:

        #ifndef _INC_WINDOWS    /* If not included with 3.1 headers... */
        #define LPCSTR      LPSTR
        #define WINAPI      FAR PASCAL
        #define CALLBACK    FAR PASCAL
        #define UINT        WORD
        #define LPARAM      LONG
        #define WPARAM      WORD
        #define LRESULT     LONG
        #define HMODULE     HANDLE
        #define HINSTANCE   HANDLE
        #define HLOCAL      HANDLE
        #define HGLOBAL     HANDLE
        #endif  /* _INC_WINDOWS */

        C++ Compatibility
        -----------------

To be able to use functions declared in your header directly from C++, you
need to do one thing:

    *  Bracket the header file typedefs inside an extern "c" {} block,
       conditionally using the __cplusplus #define:
       Near the beginning of your header:

        #ifdef __cplusplus
        extern "C" {            /* Assume C declarations for C++ */
        #endif  /* __cplusplus */

       And at the end:

        #ifdef __cplusplus
        }
        #endif


        STRICT Compatibility and Windows 3.0 Backward Compatibility
        -----------------------------------------------------------

One of the most important features of STRICT is that handle types are no
longer defined as WORDs.  They are declared in such a way that will cause a
compiler error if you try to pass the wrong type of handle or a non-handle
value to a function, for example.  It's important that all of our handle
types be declared this way when the user #defines STRICT.

A number of new types and such have been defined in windows.h, such as
HINSTANCE, HGLOBAL, and HLOCAL, which should be used where appropriate in
place of the generic HANDLE type.  HANDLE should be used only in cases of
an arbitrary handle type.

The WPARAM, LPARAM, and LRESULT types should be used for arbitrary or
polymorphic parameters or return values. Typedefs exist for all callback
functions, which are used in place of FARPROC.

In most cases, functions declared with these types are fully 3.0 compatible
unless STRICT is #defined.  It may sometimes be necessary to use #ifdef
STRICT/#else/#endif to provide 3.0-compatible, non-STRICT declarations in
some cases.

    *  Use DECLARE_HANDLE() to declare handle types.  If you have polymorphic
       API parameters (or structure fields) that are designed to accept more
       than one type of handle (e.g., the GDI SelectObject function), there
       are a few tricks you can employ.  1) Declare a generic handle type
       like HGDIOBJ as void _near*, which will accept any handle type. The
       HANDLE type can be used for this purpose.  2) if the number of
       polymorphic types is small, and there are lots of cases where they can
       be used polymorphically, use DECLARE_HANDLE to declare one handle
       type, and typedef the rest to be the same as the first one (e.g,
       HMODULE and HINSTANCE in windows.h).

    *  Structure and function declarations should use the appropriate STRICT
       type, rather than the generic HANDLE,

    *  Declare arbitrarily or polymorphic types with LPARAM, WPARAM, and
       LRESULT instead of WORD, LONG, or DWORD.  This indicates to a
       programmer that these values should not be used directly, but should
       instead be cast and assigned to the proper type of value before use.

    *  Declare arbitrarily or polymorphic pointer types with void FAR*
       instead of LPSTR or BYTE FAR*.  The nice thing about the void FAR*
       type is that you can pass any type of pointer to it without having to
       cast first.

    *  If any of the above STRICT rules result in declarations that are
       not compatible with previously released versions of the header file,
       use #ifdef STRICT/#else/#endif to ensure that both declarations
       are present.

    *  Use WINAPI instead of FAR PASCAL for declaring APIs.  Use CALLBACK
       instead of FAR PASCAL in callback function typedefs.

    *  Be sure to use "const" where appropriate in your pointer parameters.
       If the pointer is read-only, then it should be const.  If the function
       writes through the pointer, it must not be const.  For const
       zero-terminated string pointers, use LPCSTR instead of LPSTR.

    *  Don't declare NPXXX or SPXXX pointer parameter types for new structures.
       (but don't remove them if they've already been defined in a shipped
       header).  Users are encouraged to use "*", const, _near, _far, and
       _huge explicitly where appropriate.  Now that our headers contain
       "const" pointer types, having LP, NP, and const pointer type variants
       for every structure would just clog the compiler up with typedefs.

    *  Spell out pointer declarations, rather than using the LPXXX type form.
       This allows for use of const and _huge where appropriate, without
       having to define lots of new typedefs:

             SetFoo(const FOO FAR* pfoo);
             GetFoo(FOO FAR* pfoo);

    *  Use parameter names in your API function prototypes.  This greatly
       contributes to the readability and usefulness of your header, at
       very little cost.  Make sure all your APIs and callback declarations
       are fully prototyped.  Use the same naming conventions as in our
       documentation (contact gregro or ralphw for a summary of those
       conventions).  NOTE: As of this writing, windows.h does not yet
       include function prototype names.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\ksource.txt ===
3.1 Kernel Directory
			====================

		Directorys

[debug2]			krnl286.exe debug is built here
[debug3]			krnl386.exe debug is built here
[debug]				kernel.exe debug is built here
[history]			Some dead files
[reckern]			Recording (or swap) kernel is built here
[retail2]			krnl286.exe retail is built here
[retail3]			krnl386.exe retail is built here
[retail]			kernel.exe retail is built here

		Include files

..\inc\cmacros.inc		Such a wonderful(!) macro package
appl.inc*			Include file for application loader routines
pdb.inc*			aka PSP definitions
tdb.inc*			Task data block defintions
eems.inc*
kernel.inc			Half of kernel's definitions
winkern.inc*			The other half.
..\inc\newexe.inc		New exe file, ASM definitions
newexe.h*			New exe file, C definitions
protect.inc*			Protect mode definitions
kdos.inc*
krom.inc*
kernel.h*			C version of kernel's definitions
				Expect this to be out of date!

		Real mode memory manager

gacheck.asm*			g*.asm are the real mode memory management
galloc.asm*			files.  gacheck.asm and glru.asm are shared
gcompact.asm*			with krnl286.exe.	 			   
ginterf.asm*
glru.asm*
gmem.asm*  
gmeminit.asm*
gmoremem.asm*
handle.asm*			Real mode handle table routines
protect.asm*			Real mode stubs

		286pmode memory manager

2galloc.asm*			2*.asm are krnl286 memory management files
2gcompac.asm*			the name matches the real mode file with
2ginterf.asm*			'2' prepended.
2gmem.asm*
2gmemini.asm*
2gmoreme.asm*
2protect.asm*

		386pmode memory manager

3gacheck.asm*			3*.asm are krnl386 memory management files.
3galloc.asm*
3gcompac.asm*
3ginterf.asm*
3glru.asm*
3gmem.asm*
3gmemini.asm*
3gmoreme.asm*
3protect.asm*

		Debugger glue routines

2lddebug.asm*			Interface files for the debugger.  Also
3lddebug.asm*			include debug output routines.
lddebug.asm*


		EMS support.  Mostly dead code here.

emm.asm*
emmsched.asm*
emshead.asm*
emsinit.asm*
emsmisc.asm*
newems.asm*
smartdrv.asm*


		Kernel's interrupt hooks
		
i21entry.asm*			i21*.asm are the kernel's DOS call
i21file.asm*			intercept routines.
i21task.asm*
int24.asm*			The Windows critical error handler
intnn.asm*			Miscallaneous interrupts trapped by kernel


		Data and data segment routines
		
kdata.asm*			Kernel's data
strings.asm			Kernel's strings
kdataend.asm*
mapdata.asm*			DS loading stubs


		Linker definitions

kernel.def*			Kernel's link definitions
rom.def*
kernel.lnk*				      


		Initialisation/Exit code
	
kernstub.asm*			DOS stub to jump to the new exe file
ldboot.asm			Kernel's bootstrap code
ldfastb.asm*			Mostly dead, some ldboot support
ldself.asm*			Loader for Kernel's exe header
dosinit.asm*			Initialisation routines dealing with DOS
enable.asm			Routines to Enable/Disable kernel


		Local memory manager files

lacheck.asm*
lalloc.asm* 	
linterf.asm*
lcompact.asm*
lhandle.asm*


		EXE loader and support
		
ld.asm*				Mostly LoadModule
ldheader.asm*			LoadExeHeader - loads a new exe header
ldappl.asm*			Private loader (Excel 2.x, WinWord) routines
ldcache.asm*			File handle cache and real mode
				XMS segment cache	       	  
ldaux.asm*			Loader support
ldutil.asm*			More loader support
module.asm*			Yet more loader support
ldfile.asm*			LoadNRTable - loader support
ldseg.asm*			LoadSegment and segment allocation routines
ldreloc.asm*			Segment relocation
checksum.asm*			Segment checksum routines
ldint.asm			Segment not present handler and
				other fault handlers
resaux.asm*			Resource loader
ldstack.asm*			Real mode stack patching routines


		Build files

mk.bat*				Front end for makefile
makefile*			THE makefile


		Miscellaneous Kernel entry points

atom.asm*			Atom manager
diskio.asm*			_lopen, _lread etc.
ldopen.asm*			OpenFile
miscapi.asm*			Miscellaneous kernel entry points
lstring.asm*			lstrlen etc.. half dead
winexec.asm*			WinExec()

		Rips
rip.c*				Those lovely beeps and stack traces
ripaux.asm			Support for rips


		Scheduler and task management

schedule.asm*			Scheduler
context.asm*			Scheduler support
task.asm*			Task management


		Really miscellanous routines

rom.asm*			ROM stuff
sft.asm*			SFT handling
stack.asm*			Kernel's temporary stack routines


		Profile routines

up.c*				INI file routines
userpro.asm*			Old INI file routines, mostly dead code
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\newexe.doc ===
New Executable Format

DOS 2.0 Windows will define a new executable format for .EXE files
that is a superset of the current DOS 2.0 .EXE format.  The purpose
of this new format is to provide the additional information needed
to support the new dynamic linking and segmentation facilities provided
by DOS 2.0 Windows and DOS 4.0.  In order for Windows and DOS 4.0
to recognize the new executable format, the existing .EXE format
will be used with a slight modification:

    - the word at offset 18h in the existing .EXE file contains the
      relative byte offset to the relocation table.  If this offset
      is 40h, then that identifies this as a new format .EXE file and
      The word at offset 24h is the relative byte offset from the
      beginning of the file to the beginning of the new format
      executable header.  The remainder of the old format header will
      describe a small program that will either print an error message
      or bring in a loader that can handle the job.  See the picture
      below for the actual file layout.

    - this format will only be used for .EXE files that use the new
      memory model supported by DOS 2.0 Windows and DOS 4.0.  Old .EXE
      files will continue with the DOS 2.0 file format, as modified
      by the DOS 4.0 group.  In that format, the DOS 4.0 behavior bits
      (2 bytes) are stored at offset 20h.

The format of the new .EXE file format looks like:

        00h     -------------------
                |                 |
                | Old EXE Header  |
                |                 |
                -------------------
        20h     | DOS 4.0 bbits   |
        22h     | unused bbits    |
        3eh     | offset to new   | ----
                | EXE header      |    |
        40h     -------------------    |
                | DOS 2.0 Stub    |    |
                |   Program &     |    |
                | Reloc. Table    |    |
        xxh     ------------------- <---
                |                 |
                | New EXE Header  |\
                |                 | \
                -------------------  \
                |                 |   |
                |  Segment Table  |   |
                |                 |   |
                -------------------   |
                |   Resource      |   |           DOS4 and Windows keep this
                |     Table       |   |-----------part as part of their
                -------------------   |           MODULE table, currently
                |    Resident     |   |
                |     Name        |   |
                |     Table       |   |
                -------------------  /
                |  Module Ref     | /
                |     Table       |/
                -------------------
                |    Imported     |
                |     Names       |
                |     Table       |
                -------------------
*               |     Entry       |
*               |     Table       |
                -------------------
                |  Non-Resident   |
                |     Name        |
                |     Table       |
                -------------------
                | Seg #1 Data     |
                | Seg #1 Info     |
                -------------------
                        .
                        .
                        .
                -------------------
                | Seg #n Data     |
                | Seg #n Info     |
                -------------------

    20h - DW  DOS 4.0 behavior bits
*   22h - 3ch - reserved for more behavior info
*   3eh - DW  offset to new executable header

    Program that DOS 2.0 header points to, that will either print out an
    error message or load in a new-EXE loader.

    xxh - Beginning of new executable header
            DW  signature word - can never be too careful
                "N" is low order byte
                "E" is high order byte
            DB  version# of LINK that produced this executable
            DB  revision# of LINK that produced this executable

            DW  Entry Table file offset relative to beginning of new EXE header
            DW  #bytes in Entry Table

            DD  CRC-32 of entire contents of file (with these words taken
                        as 00 during the calculation)

            DW  flag word
                0000h = NOAUTODATA
                0001h = SINGLEDATA (SOLO)
                0002h = MULTIPLEDATA (INSTANCE)
                0004h = runs in real mode
                0008h = runs in protected mode (if 0Ch set, runs in either)
                4000h = non-conforming program (a valid stack is not maintained)
                8000h = Library module (SS:SP info is invalid, CS:IP points
                        to initialization procedure that is called with AX
                        = the module handle.  The procedure must execute a
                        far return to the caller, with AX != 0 to indicate
                        success and AX = 0 to indicate failure to
                        initialize.  DS = the library's data segment if the
                        SINGLEDATA flag is set and the caller's DS
                        otherwise.

                        A program can only contain dynamic links to
                        executables that have this flag set.  If this flag
                        is set, the MULTIPLEDATA flag must be reset.  The
                        SINGLEDATA flag may be set or reset.

            DW  segment# of automatic data segment (index into segment table)
                set to zero if SINGLEDATA and MULTIPLEDATA flag bits are reset

            DW  initial size (bytes) of dynamic heap added to data segment
                (0 if no local alloc)
            DW  initial size (bytes) of stack added to data segment
                (0 if SS!=DS)
            DD  segment#:offset of CS:IP
            DD  segment#:offset of SS:SP
                 Segment# is an index into the module's segment table.
                 The first entry in the segment table is segment number 1.
                 If SS = automatic data segment and SP = 0,
                 the stack pointer is set to the top of the automatic
                 data segment just below the additional heap area.

                         +-------------------------+
                         | additional dynamic heap |
                         +-------------------------+ <- SP
                         |    additional stack     |
                         +-------------------------+
                         |   loaded data segment   |
                         +-------------------------+ <- DS, SS

            DW  #of entries in Segment Table
            DW  #of entries in Module Ref Table
            DW  #bytes in Non-Resident Name Table

            DW  Segment Table file offset relative to beginning of new EXE header
            DW  Resource Table file offset relative to beginning of new EXE header
            DW  Resident Name Table file offset relative to beginning of new EXE header
            DW  Module Ref Table file offset relative to beginning of new EXE header
            DW  Imported Names Table file offset relative to beginning of new EXE header
            DD  Non-Resident Name Table offset relative to beginning of file

*           DW  #moveable entry points
*           DW  alignment shift count for segment data.  Value of zero means
*               use the default value of 9 for 512 byte alignment.
*           DB  12 DUP (?) - room for growth here

    Segment Table
    =============

        "N" segment table entries:

            The first entry in the segment table is segment number 1.
*           DW  logical sector offset to contents of the segment data
*               relative to beginning of file (zero means no file data)
*               The alignment field in the header determines the units
*               of this offset.
            DW  length of segment in file (bytes) (zero means 64k bytes)
            DW  flag word
                    TYPE_MASK       = 0007h ; segment type field
                      CODE          = 0000h ; code segment type
                      DATA          = 0001h ; data segment type
                    ITERATED        = 0008h ; segment data is iterated
                    MOVABLE         = 0010h ; segment is not fixed
                    PURE            = 0020h ; segment can be shared
                    PRELOAD         = 0040h ; segment is not demand loaded
                    ERONLY          = 0080h ; execute only if code segment
                                            ; read only if data segment
                    RELOCINFO       = 0100h ; set if segment has reloc records
                    DEBUGINFO       = 0200h ; set if segment has debug info
                    SEGDPL          = 0C00h ; reserved for 286 DPL bits
                    DISCARDABLE     = F000h ; static discard priority level
            DW  minimum allocation size (bytes)
                Total size of the segment (0 means 65536)

    Resource Table
    ==============

        DW  alignment shift count for resource data

        "N" iterations of record:
         |  DW  type ID - integer type if high order bit is set (8000h)
         |                otherwise offset to type string, relative to
         |                beginning of the resource table
         |              = 0 marks end of resource records
         |
         |  DW  #resources for this type
         |  DD  reserved for runtime use
         |   |
         |   |  "#resources" copies of Resource Entry (8 bytes)
         |   |
         |   |  DW  file offset to contents of the resource data relative
         |   |      to beginning of file.  Offset is in terms of alignment
         |   |      units specified at beginning of resource table.
         |   |  DW  length of resource in file (bytes)
         |   |  DW  flag word
         |   |          MOVEABLE        = 0010h ; resource is not fixed
         |   |          PURE            = 0020h ; resource can be shared
         |   |          PRELOAD         = 0040h ; resource is not demand loaded
         |   |  DW  resource ID - integer type if high order bit is set (8000h)
         |   |      otherwise offset to resource string, relative to beginning
         |   |      of the resource table
         |   |  DD  reserved for runtime use
          \   \

        Resource type and name strings stored at end of resource table
                Note that these strings are NOT null terminated

            DB  length of type or name          ; = 0 if end of resource table
            DB  ASCII text of type or name      ; Case sensitive



    Module Reference Table
    ======================

        "N" entries of the form:  (1-based)

            DW      offset within Imported Names Table to module name string



    Entry Table     (1 based)
    ===========

        "N" bundles of entry definitions.  The ordinal value of an entry
         |  point is its ordinal within the entry table, counting the
         |  first entry as ordinal #1.  The loader must scan over the
         |  bundles until it finds the bundle containing the entry point;
         |  the loader can then multiply by entry size to index the
         |  proper entry.
         |
         |  The linker forms bundles in the densest manner it can, given
         |  the restriction that it cannot reorder entry points to improve
         |  bundling because other EXE files may refer to entry points within
         |  this one by their ordinal in this table.
         |
         |  DB  #entries in this bundle.  All records in one bundle are
         |          either movabe or refer to the same fixed segment.
         |      =0 if no more bundles in Entry Table
         |
         |  DB  segment indicator for this bundle
         |   |       000 - Unused
         |   |       0FF - Movable segment, # is in entry
         |   |       otherwise is segment # of fixed segment
         |   |
         |   |   If fixed segment, entries are 3 bytes:
         |   |       DB  flags
         |   |             0000 0001 - set if entry is exported
         |   |             0000 0010 - set if entry uses global (shared) data segment
         |   |                          "mov ax,#ds-value" must be the 1st
         |   |                          instruction in the prolog of this
         |   |                          entry.  This flag may only be set
         |   |                          for SINGLEDATA library modules.
         |   |             nnnn n--- - # of parameter words
         |   |       DW  offset
         |   |   Else movable segment, entries are 6 bytes:
         |   |       DB  flags
         |   |             0000 0001 - set if entry is exported
         |   |             0000 0010 - set if segment uses global (shared) data segment
         |   |             nnnn n--- - # of parameter words
         |   |       int 3Fh
         |   |       DB  segment#
          \   \      DW  offset



    Resident or Non-resident Name Table Entry (3 + n bytes)
    =========================================

        The strings are CASE SENSITIVE and NOT NULL TERMINATED.  If the
*       .EXE was produced with the /IGNORECASE switch, then all strings
*       will be UPPERCASE

        DB  Length of string            ; =0 if no more strings in table
        DB  ASCII text of string
        DW  ordinal# (index into entry table)

        First string in resident name table is the module name.

        First string in non-resident name table is the module description.


    Imported Names Table Entry (1 + n bytes)
    ==========================

        The strings are CASE SENSITIVE and NOT NULL TERMINATED.  If the
*       .EXE was produced with the /IGNORECASE switch, then all strings
*       will be UPPERCASE

        DB  Length of name              ; =0 if no more strings in Table
        DB  ASCII text of name



    Per segment data:
    ================

      If ITERATED
              DW  #iterations
              DW  #bytes of data
              DB  data bytes
      else
              DB  data bytes


      If RELOCINFO
          DW  #relocation items
          |
          | Relocation Item: (8 bytes)
          |
          |   DB  source type (32 bit address, 16 bit segment, 16 bit offset)
          |       NRSTYP          = 07h   ; source type mask
          |       NRSBYTE         = 00h
          |       NRSSEG          = 02h   ; 16-bit segment
          |       NRSPTR          = 03h   ; 32-bit pointer
          |       NRSOFF          = 05h   ; 16-bit offset
          |   DB  flags
          |       TARGET_MASK     = 03h
          |       INTERNALREF     = 00h
          |       IMPORTORDINAL   = 01h
          |       IMPORTNAME      = 02h
          |       ADDITIVE        = 04h
          |   DW  offset within this segment of source chain
          |       If ADDITIVE flag set, then add target value to source contents,
          |       instead of replacing source and following the chain.
          |       The source chain is a 0xFFFF terminated linked list within
          |       this segment of all references to the target.
          |   Target
          |       INTERNALREF
          |           DB  segment# for fixed segment or FF if movable
          |           DB  0
          |           DW  if moveable segment
*         |                  ordinal# (index into entry table of this module)
          |               if fixed segment
          |                  offset into segment if fixed
          |
          |       IMPORTNAME
          |           DW  index into module ref table
          |           DW  offset within Imported Names Table to proc. name string
          |
          |       IMPORTORDINAL
          |           DW  index into module ref table
          |           DW  procedure ordinal#
          |
          |       OSFIXUP
          |           DW  Operating system fixup type
          |
          |               floating-point fixups
          |                 0001h = FIARQQ, FJARQQ
          |                 0002h = FISRQQ, FJSRQQ
          |                 0003h = FICRQQ, FJCRQQ
          |                 0004h = FIERQQ
          |                 0005h = FIDRQQ
          |                 0006h = FIWRQQ
          |               applied by adding the fixup to the coprocessor instr.
          |               for 1-3, apply the first fixup at the offset, and
          |               the second fixup at the offset+1.  for 4-6, just add
          |               the fixup at the offset.
          |
          |         NOTE: the linker marks these relocations as NRSOFF, but
          |         they must be applied differently.  in ldreloc.asm, we
          |         use a flag to discern this case.
          |
           \          DW  0


      If DEBUGINFO
          DW  # of bytes of debug info
                <debug info - not yet defined>





NOTE: this document does not totally agree with version 1.7, dated 5/05/87.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\patch.txt ===
This is an overview document describing how to create module patches
in Windows 95.

Legal aspects:
--------------
While we are obviously using this module-patching technology to
make already-shipping apps run or run better, it is possible
for us to make a mistake and wrongly patch a module. For example,
there might be two similar versions of an app which need to be
patched differently, but we only know about one of them. Due to the
obvious liability concerns, we need to obtain authorization from
the app vendor for each module patch we put into the registry.
The letter must specify the name of the module, the number of the
segment taking the patch, the bytes being replaced, and the new
bytes taking their place. The letter can be from any responsible
person at the vendor, eg. an engineer who is familiar with the code.
At the same time, talking to the vendor will help us find out how
many different versions there are of an app, so we can figure out
how to patch each one.

See brianrey if you have a module patch you want to check in.
It would be a good idea to get the ball rolling on getting the
letter as soon as possible after you know what the patch is, since
it can sometimes take a while to get these things taken care of.
We already get similar letters for app-hack bits.


How to check in a patch:
------------------------
Since the patch values go in the registry, and since the initial registry
contents are owned by setup, you must work with Andy Hill to get your
module patches checked in.

A common mistake when adding app-patches to msbase.inx is to leave out
field 4 (field 3 if you are a computer), which are flags.  The reason
for the confusion is the flag that means "This is a binary regkey" is 01,
and the opcode for "Change" is also 01, so everything just shifts down
one step and nobody gets hurt.  Except that the patch doesn't work.
eg: If you want to add a key whose value is <01,09,70,00,02,ff,76,eb,15>
WRONG
    HKLM,"SYSTEM\...",Change,01,09,70,00,02,ff,76,eb,15
BETTER
    HKLM,"SYSTEM\...",Change,1,01,09,70,00,02,ff,76,eb,15


How to make a patch:
--------------------
All definitions of the structures used below are in core\kernel\patch.asm.

The loader knows to look in the registry for patch data if the MCF_MODPATCH
bit is set in the [ModuleCompatibility] section in win.ini.
eg.
[ModuleCompatibility]
GENERIC=0x0002

All registry keys and values for module-patching are stored
under HKEY_LOCAL_MACHINE under REGSTR_PATH_APPPATCH:
(from dev\sdk\inc\regstr.h)
#define REGSTR_PATH_APPPATCH "System\\CurrentControlSet\\Control\\SessionManager\\AppPatches"

The actual patches are values stored in the registry under
REGSTR_PATH_APPPATCH\<mod_name>\<signature>\<segment_number>
where
    mod_name        = the module name
    signature       = a signature string identifying the module version
    segment_number  = the hex number of the segment receiving the patches


Signatures:
-----------
Signatures are strings of ANSI characters representing hex numbers
in nibble-swapped byte format (what you see in wdeb386 if you type
db). Blanks and commas are ignored, and may be included for readability.

The easiest way to create a signature is to run dev\tools\binw\gensig.
eg. If you want to patch segment 3 in foo.dll, run "gensig foo.exe 3"
and a tight signature will be written to stdout.

type-1 and -2 signatures:
A type-1 signature specifies a list of byte sequences with byte offsets
(type-2 has word offsets) which must all match for the signature to match.
A 0 byte-count marks the end of the list.
A match-any-file signature is "0100".
eg. signature = "01 02,00,4e,45 02,3e,0a,03 00" is a type-1 signature which
                 || || || || || || || || || ||
    type --------++ || || || || || || || || ||
                    || || || || || || || || ||
    byte count------++ || || || || || || || ||
    offset-------------++ || || || || || || ||
    match bytes-----------++-++ || || || || ||
                                || || || || ||
    byte count------------------++ || || || ||
    offset-------------------------++ || || ||
    match bytes-----------------------++-++ ||
                                            ||
    terminating byte count------------------++
matches if the 2 bytes starting at offset 0 in the exe header match
4e,45 ("NE") and if the 2 bytes starting at offset 3e match 0a,03.
Note- DO NOT include a match on NE in your signature. This is just
for illustrative purposes. The windows version and size(s) of the
segment(s) being patched are good candidates.


type-3, -4 and -5 signatures:
Type-3, -4 and -5 signatures are similar to type-1 and -2 signatures,
except that the offsets are offsets in the module file. Type-3 takes
word offsets, type-4 takes 3-byte offsets, and type-5 takes dword offsets.
eg. signature = "03,03,67,05,c2,0a,00,00"
                 || || || || || || || ||
    type---------++ || || || || || || ||
                    || || || || || || ||
    byte count------++ || || || || || ||
    file offset--------++-++ || || || ||
    match bytes--------------++-++-++ ||
                                      ||
    terminating byte count------------++
matches if the 3 bytes at offset 567h in the file match c2,0a,00.


type-6, -7 and -8 signatures:
Type-6, -7 and -8 signatures specify the file size of the matching
module. The number of bytes used to specify the matching file size
is 2, 3 or 4 respectively.
eg. signature = "06,d0,0c"
                 || || ||
    type---------++ || ||
    file size-------++-++
matches if the file size is 0cd0h.


type-ff signatures:
Type-ff signatures are meta-signatures and consist of a list of the
other types of signatures. Each list element consists of a byte count
and a sub-signature. A 0 byte-count ends the list.
eg. signature = "ff 06,01,02,3e,0a,03,00 03,06,d0,0c 00"
                 || || || || || || || || || || || || ||
    type---------++ || || || || || || || || || || || ||
                    || || || || || || || || || || || ||
    byte count------++ || || || || || || || || || || ||
    sub-type-----------++ || || || || || || || || || ||
    sub-byte-count--------++ || || || || || || || || ||
    hExe offset--------------++ || || || || || || || ||
    match bytes-----------------++-++ || || || || || ||
    sub-type terminator---------------++ || || || || ||
                                         || || || || ||
    byte count---------------------------++ || || || ||
    sub-type--------------------------------++ || || ||
    file size----------------------------------++-++ ||
                                                     ||
    terminating byte count---------------------------++
matches if the 2 bytes at offset 3eh in the exe header match 0a,03
and the file size is 0cd0h.


Criteria for selecting a signature:
-----------------------------------
In terms of time required to validate a signature, the hExe types are
the fastest, the file size types are next-fastest, and the file data
types are the slowest. A signature specifying the expected Windows
version (hExe offset 3e) and the file size is probably sufficient
for most cases, since almost any code change changes the file size.
A signature which also requires a file match on the bytes being replaced
(if they are not fixed up and they are in a segment, they must be
somewhere in the file!) is very good, but might be overkill.
Since file match signatures hit the disk, they might noticeably increase
the load time of the module.

DO NOT match on the NE signature in the module header. This is
just a waste of bytes, since it always matches.
DO match on the file size unless you have a very good reason not to.
If going through the ifs, this is a very cheap test.
DO match on something, since we don't want to rely on just the
name of the module. We have signatures. Use them. If you have
no better idea (eg. there is only one version), match on the
windows version, the size(s) of the segment(s) being patched, and
the file size.


Patch data:
-----------
The patch values specify sequences of bytes to add or replace.
Add's must be placed after the end of the unpatched segment.
The segment is GlobalReAlloc'd as necessary to contain the new code.
Replace's must be within the limits of the unpatched segment,
and they must match the sequence of old bytes in the patch value.
Obviously, replaced bytes cannot contain fixups.
The contents of the value string are not used, except to be sent
to the debugger as a debugging aid when the value is loaded from
the registry. The contents of the value data must be in REG_BINARY
format.

Example:
--------
Note: The registry key show below will not work as shown, since it
has been broken into multiple lines for legibility. Join the lines
together and it works.

==================================================================
REGEDIT4

[HKEY_LOCAL_MACHINE\System\CurrentControlSet\control\SessionManager
\AppPatches\GENERIC
\ff 06,01,02,3e,0a,03,00 03,06,d0,0c 08,03,03,67,05,c2,0a,00,00 00
\1]
"Add"=hex:02,08,f0,03,03,c2,0a,00
"Replace"=hex:01,0b,67,00,03,c2,0a,00,e9,86,03
==================================================================

The Add value has data with a size of 8 bytes, saying that at offset
3f0h that the 3 bytes c2,0a,00 should be added.
    "Add"=hex:02,08,f0,03,03,c2,0a,00
              || || || || || || || ||
    type=Add--++ || || || || || || ||
    total bytes--++ || || || || || ||
    offset----------++-++ || || || ||
    byte count------------++ || || ||
    bytes to add-------------++-++-++

The Replace value has data with a size of 0bh bytes, saying that at
offset 67h that the 3 bytes c2,0a,00 should be replaced with e9,86,03.
    "Replace"=hex:01,0b,67,00,03,c2,0a,00,e9,86,03
                  || || || || || || || || || || ||
    type=Replace--++ || || || || || || || || || ||
    total bytes------++ || || || || || || || || ||
    offset--------------++-++ || || || || || || ||
    byte count----------------++ || || || || || ||
    old bytes--------------------++-++-++ || || ||
    new bytes-----------------------------++-++-++

The combined effect of these two changes is to replace a "retn a" at 67
with "jmp 3f0" and, at 3f0 to add "retn a". The app runs exactly as
before in this case, except for a small detour. When it reaches ip=67,
instead of doing "retn a", it does a "jmp 3f0" and then the "retn a".



Example for code segment 1 of module "INSTALL":
We want to change the message number they are checking against in a WndProc
from 181 to 402.   So here's what ya gatta do....

1. Open a patch.ini file in your favorite editor


2. Run private\tools16\gensig.exe :  gensig file.exe seg#
   where seg# is the 1-based HEX value of the segment you want to patch.  You
   will see the correct segment number to use if you do a "vdmexts!lm sel" 
   dump for the selector of interest under ntsd (it will be under the "Seg"
   heading).
      gensig install.exe 1
      ff06010242136500030600d600  <--- resulting hex string signature


3. Grab the resulting hex string & paste it in your patch.ini file with the 
   following format:  RegistryPath\ModuleName\HexSignature\SegNum

\Registry\MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\AppPatches\INSTALL\ff06010242136500030600d600\1


4. Now the fun part.  The patch bytes list needs to be done in groups of 4 bytes
   because it will be converted to DWORDS later.  

   The first DWORD is the 1-Byte_ByteCount with a bunch of leading zeros:
       0x0000000B  Note: this must match the 1-Byte_ByteCount in the next DWORD
                         See "^^Note:" at the end of this section on how to 
                                     calculate this.

   The second DWORD takes the following format:
      2-Byte_CodeOffset 1-Byte_ByteCount  1-Byte_PatchCode 
        where the 2-Byte_CodeOffset is the same offset you would type to
        disassemble the code under ntsd:  u seg:off
      For this example we want to alter 3 bytes at 1:305 so we need to write:
      0x03050B01 
        \__/\/\/
          \  \ \___ The 1-Byte_PatchCode (01 = "replace")
           \  \____ The 1-Byte_ByteCount (# bytes in the entire patch string)
            \______ The code offset

   Next write a 1-Byte_PatchByteCount followed by the PatchBytes.  For the 3
   bytes we are replacing in this example:
      03 2d 81 01   2d 02 04 00
      \/ \/ \___/   \/ \___/ \/                      ______
       \  \   \      \   \    \___ Zero pad the DWORD      |
        \  \   \      \   \_______ The value "402"         |
         \  \   \      \__________ "Sub" instruction code  |-- PatchBytes
          \  \   \________________ The value "181"         |
           \  \___________________ "Sub" instruction ______|
            \_____________________ 1-Byte_PatchByteCount

       Now DWORD arrange the above 4-byte clusters:
           0x01812d03 0x0004022d

   Put this all together as follows:
          Change1 = REG_BINARY 0x0000000B 0x03050B01 0x01812d03 0x0004022d
                                       \/       \/
                                        \________\__ These two will be the same

            ^^Note: the 1-Byte_ByteCount is the count of the bytes in all of the
                    DWORDS we built except the first one (0x0000000B in this 
                    case) and doesn't count any of the padding zeros in the 
                    last DWORD.  See below:

                                 0 bytes    4 bytes    4 bytes    3 bytes
          Change1 = REG_BINARY 0x0000000B 0x03050B01 0x01812d03 0x0004022d

                1-Byte_ByteCount = 4 + 4 + 3 = 0xB



5. Next add another registry path entry to the "ModuleCompatibility" section:
\Registry\MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ModuleCompatibility

   Followed by a REG_SZ entry for the Module:
          INSTALL = REG_SZ "0x0002"
                            \____/
                               \____ use "0x0002" for WOW in general
                                     and "0x8000" for RISC WOW only


6. The resulting patch.ini file should look like this:

\Registry\MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\AppPatches\INSTALL\ff06010242136500030600d600\1
          Change1 = REG_BINARY 0x0000000B 0x03050B01 0x01812d03 0x0004022d

\Registry\MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ModuleCompatibility
          INSTALL = REG_SZ "0x0002"


7. Run "regini patch.ini" to update the registry

8. Install a checked krnl386 and run the app under ntsd to see any patching
   messages when the module loads.  If you have any problems set a bp at
   PatchAppSegWorker in krnl386 (source: wow16\kernel31\patch.asm) and step
   through what's going on.  Chances are you have the byte order mixed up and
   you can see how you will need to re-arrange the PatchBytes in patch.ini 
   to get what you really want.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\kernel31\swappro\swap.doc ===
1             * 1 1 1 1 1 NORMAL.STY                                                          HPLASER12                     Windows Swap Kernel


This directory contains a special version of the kernel program for Microsoft Windows. By running this special version, called SKERNEL, you can get an accurate accounting of all calls, swaps, discards, and swap returns that occur during a Windows session. Reviewing the information provided by SKERNEL will allow you to develop the most efficient code segmentation scheme for your application.


What You Need to Run SKERNEL
----------------------------

To analyze the swapping activity for your application, you need the following:

1. A special version of the kernel, usually called SKERNEL.EXE and the corresponding symbol file, SKERNEL.SYM.

2. A utility program named SWAP.EXE that analyzes the swap information.

3. Symbol files for the modules you want information about.


How to Use Swap and SKERNEL
---------------------------

To set up Windows and your application for swapping analysis, follow the steps below.

1. Set up a "slow boot" version of Windows, and copy SKERNEL.EXE from this disk to your Windows directory.

1. In the win.ini file, set the SwapProfile variable found in the [kernel] section as follows:

0 = do nothing (acts just like a normal kernel except that thunks will be slightly larger and slower)

1 = record just swap calls, discards, and swap returns

2 = record swap calls, discards, swap returns, and all calls through thunks. Warning: This setting generates a very large amount of data.

If a value is not specified, 1 is assumed.

2. Start SKERNEL.

3. Run the application program that you want to analyze.

4. Exit from Windows.

5. Run SWAP.EXE.  


How SWAP Works
--------------

Swap reads a file named SWAPPRO.DAT that was created while the Windows session was running and combines it with the information found in the symbol files to produce the desired information. Swap then displays a tab delimited file to the screen. The output can also be redirected into a file and then read into a spreadsheet such as Microsoft Excel.

If SWAPPRO.DAT contains a large amount of data, it will take SWAP quite a long time to look up all the module and symbol names. To limit the size of SWAPPRO.DAT (and therefore the time required to match names), you can specify the modules and segments for which SWAP should prepare output. To specify the modules and segments, type the following argument on the command line:

		[module[:segment]]

For example,

		swap gdi:_fontres 

displays only records that contain the _FONTRES segment of GDI. 

You can list multiple modules or module/segment pairs on the command line. Just separate them from each other with spaces.  For example,

		swap gdi:_fontres user

displays records that contain the _FONTRES segment of GDI or any segment of USER.

If you wish to track swap information for SKERNEL, as well as other modules, copy SKERNEL.SYM to your Windows directory, and rename it KERNEL.SYM.

If you have renamed SWAPPRO.DAT (the data collection file) or moved it to another directory since running your application, you can specify the path and filename with the -f command line argument. For example, if you have moved SWAPPRO.DAT to the \tmp directory and renamed it SWAPREC, type the following command to run the Swap program:

		swap -f \tmp\swaprec

What the Output Means
---------------------

The result of SWAP's analysis is displayed on the screen in tabular format. The columns are, from left to right:

Column			Explanation
------              -----------

Type				Tells which kind of event occurred. 
				CALL    = a normal call through a thunk.
				SWAP    = a call through a thunk that 
				          caused a swap
				DISCARD = discard of a segment
				RETURN  = return that caused a swap in 
				          of the caller

				If the segment discard was the result of 
				a swap, then the discard records will 
				occur after the swap record.

Time				The relative time that this event 
				occurred, in milliseconds, with 1/18.2
				second resolution. The first event is
				always time 0.

Segment			For CALL or SWAP, the segment being
(1st occurrence)	called. For DISCARD, the segment
				being discarded. For RETURN, the segment
				being returned to.

				If the module name appears in 
				parentheses, e.g. (USER), then the .SYM
				file for that module was not found.

Offset			For CALL or SWAP, the offset into the
(1st occurrence)	segment being called.  For RETURN, the
				offset into the segment being returned
				to. For DISCARD, this field is blank.

Segment			For CALL or SWAP, the segment that did
(2nd occurrence)	the calling.  For DISCARD and RETURN,
				this field is blank.

				If the module name appears in
				parentheses, i.e., (USER), then the .SYM
				file for that module was not found.

Offset			For CALL or SWAP, the offset into the
(2nd occurrence)    segment that did the calling. For 
				DISCARD and RETURN, this field is blank.
roduce the desired                          N                            N        < ;    N     information. Swap      H	
(  . @H  D:\WIN21\CORE\SDKKERN\SWAPPRO\  *,05:>"  cm  p10  p12  pt  li 7 x   1                 x       $  &  (  F  d  f      (  m *  m s  m u  m   m   m   m 1
<    P<    p   p   p I  n K  n   c   c   c   c   X   X   X   X I  X u  
<    
<    P<
<    PI  K  p w  p y  p   e   e   e   e   e   e   e   e   e   e   e   e {  
<
<    P
<    {  }  	  	  
  
  
   
  6
  8
  z
  |
      "  $  w  y            b  p d  e |  e ~           "  8  Y  [           y  
<    P
<      P   $  Q  n  p            G  r            0  2  V     P          C  n  p            G  p  r        	     P         (       8/12/88 8/12/88   93933?933?)33?o?33?3g3?
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ole\client\readme.txt ===
We never have built OLECLI.DLL for WOW.

Until NT 5, we just distributed the Win 3.1 version.

On NT 5, we distribute the Win '98 version.

The difficulty is that nobody seems to know how this gets built,
from what sources it was built, or the tools used to build it -- 
not even the Win'98 folks who built the Win'98 version (scary huh?).

So for now the Win '98 binary is just checked into the 
private\mvdm\bin86 dir with the respective FE Win '98 versions.

-- cmjones   08/24/98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\sherlock\sherlock.doc ===
!                    6  FD                  N5                                   B    B   B    B    B    B    B   )B  X B    B    B    B    B  
 B   B    B  N B    B    B    B    B    B    B    B    B    B    B    B   C   C  B C  Y C    B    C    C    C                                                                                Sherlock - The Document
This document is intended to provide preliminary information on Sherlock, a system diagnostic tool.  The purpose of Sherlock is to diagnose the cause of system errors.  Currently, when an application fails, the system provides a simple dialog box:

UNRECOVERABLE APPLICATION ERROR
Terminating Current Application
OK

This doesn't supply enough information to find and fix the problem.  If a user gets too many UAE errors, they can install Sherlock in windows.  Sherlock will generate a special file on disk with information that will help technicions fix the problem.
Installing Sherlock
Make sure SHERLOCK.DLL is in your windows or windows\system directory.  Make sure SHERLOCK.EXE is in your windows or windows\system directory.
Add SHERLOCK.EXE to your LOAD= or RUN= line in WIN.INI.  Alternatively, use ProgMan or FileMan to run Sherlock.  You will see the Sherlock icon on your desktop.
Using Sherlock
When a system error occurs, such as Unrecoverable Application Error (UAE), Sherlock will write a special file in your windows\system directory.  By default, this file will have a large amount of information.  You can reduce the size of this file by instructing Sherlock to skip certain less-important information.
By default, this report is called "SHERLOCK.LOG".  You can change the name and location of this file by adding a "logfile=" entry to the [SHERLOCK] section of WIN.INI.  You can also redirect output to a serial or parallel device.  For example, to send reports to a debugging terminal, add this line:
[sherlock]
logfile=com1
Report Format
Each section of a Sherlock report can be disabled by adding it to the "skipinfo=" entry of the [SHERLOCK] section of WIN.INI.  For example, to disable the module list output of a report, add this line:
[sherlock]
skipinfo=module
Sherlock Report Header
The first section of the report indicates the Sherlock software version (0.7), time and date of event, the fault type ('Invalid Opcode'), selector:offset of the fault, and segment number and file name of the current application.

Sherlock 0.7 Failure Report - Fri Apr  5 21:39:16 1991
Elementary - a 'Invalid Opcode' fault has occured at 0df5:0416.
This is from segment 1 of 'C:\TEMP\DIBTEST.EXE' (DIBTEST)
The cause appears to be 'Invalid Opcode'.

This part of the report is mandatory, it cannot be disabled.
CPU Registers
The 16 bit CPU registers, segment registers linear base address and limit, whether the selectors are Code, Data, or NULL.  This section is important, but you can disable it by adding "skipinfo=regs" to the [SHERLOCK] section of WIN.INI.

CPU Registers (regs)
ax = 000f  bx = 0000  cx = 0004  dx = 0103  si = 0094  di = 0094  bp = 1702
cs:ip = 0df5:0416  8053bce0:0e9f Code Ex/R    ds = 0dfd  80539560:277f Data R/W 
ss:sp = 0dfd:16ec  80539560:277f Data R/W     es = 0000         0:0000 Null Ptr 

32 Bit CPU Registers
If the CPU is a 386 or 486, the 32 bit register contents will be displayed, unless "skipinfo=32bit" is added to WIN.INI.

CPU 32 bit Registers (32bit)
eax = 0000000f  ebx = ffff0000  ecx = 03040004  edx = 00000103
esi = 00000094  edi = 00000094  ebp = 00001702  esp = 800116ec
fs = 0000         0:0000 Null Ptr     gs = 0000         0:0000 Null Ptr 
eflag = 00000202

Disassembly
The instructions before and after the faulting instruction are disassembled.  In this case, an illegal opcode was executed in the application, and so it is disassembled as an unknown instruction.  This section can be disabled with "skipinfo=disasm".  The faulting instruction is marked with the (module name:symbol+offset) of that address.  This last feature requires the presence of a .SYM file with debugging symbols in the same directory as the associated .EXE file.

Instruction Disassembly (disasm)
0df5:0411  e8 0266               call    near 067a
0df5:0414  44                    inc     sp
0df5:0415  44                    inc     sp
(DIBTEST:_GPFault+013f)
0df5:0416  0f ff                 ?Unknown 0f ff
0df5:0418  ff ff                 ?       di
0df5:041a  eb 06                 jmp     short 0422

Stack Dump/Trace
The stack dump shows stack frames, letting you know the calling sequence that produced the fault.  The example shows that function GPFault was called by DoCommand, which was called by MAINWNDPROC, called by USER:DISPATCHMESSAGE, called by WINMAIN.  The CS:IP and SS:SP of the stack frame are also displayed.

Stack Dump (stack)
Stack Frame 0 of DIBTEST  cs:ip 0df5:0416(1)   ss:bp 0dfd:1702
0df5:040e  68 024e               push    024e
0df5:0411  e8 0266               call    near 067a
0df5:0414  44                    inc     sp
0df5:0415  44                    inc     sp
(DIBTEST:_GPFault+013f)
0df5:0416  0f ff                 ?Unknown 0f ff
0df5:0418  ff ff                 ?       di
0df5:041a  eb 06                 jmp     short 0422
0df5:041c  56                    push    si

Stack Frame 1 of DIBTEST  cs:ip 0df5:0451(1)   ss:bp 0dfd:170e
0df5:044a  77 0a                 jnbe    short 0456
0df5:044c  57                    push    di
0df5:044d  56                    push    si
0df5:044e  e8 fe86               call    near 02d7
(DIBTEST:_DoCommand+001c)
0df5:0451  83 c4 04              add     sp, 04
0df5:0454  eb 71                 jmp     short 04c7
0df5:0456  8b c7                 mov     ax, di
0df5:0458  3d 007b               cmp     ax, 007b

Stack Frame 2 of DIBTEST  cs:ip 0df5:04f4(1)   ss:bp 0dfd:171c
0df5:04eb  eb 16                 jmp     short 0503
0df5:04ed  ff 76 0a              push    word ptr [bp+0a]
0df5:04f0  56                    push    si
0df5:04f1  e8 ff41               call    near 0435
(DIBTEST:MAINWNDPROC+0027)
0df5:04f4  83 c4 04              add     sp, 04
0df5:04f7  99                    cwd
0df5:04f8  eb 1f                 jmp     short 0519
0df5:04fa  6a 00                 push    00

Stack Frame 3 of USER     cs:ip 06d5:29c1(1)   ss:bp 0dfd:1736
06d5:29b5  8e c2                 mov     es, dx
06d5:29b7  8b d9                 mov     bx, cx
06d5:29b9  83 c3 38              add     bx, 38
06d5:29bc  9a 3fc2 00fd          callf   00fd:3fc2
(USER:DISPATCHMESSAGE+004f)
06d5:29c1  c3                    retn
06d5:29c2  e8 d6a0               call    near 0065
06d5:29c5  00 07                 add     [bx], al
06d5:29c7  8b 5e 0e              mov     bx, [bp+0e]

Stack Frame 4 of DIBTEST  cs:ip 0df5:062f(1)   ss:bp 0dfd:1754
0df5:0625  16                    push    ss
0df5:0626  8d 46 ee              lea     ax, [bp+ee]
0df5:0629  50                    push    ax
0df5:062a  9a 2972 06d5          callf   06d5:2972
(DIBTEST:WINMAIN+0050)
0df5:062f  16                    push    ss
0df5:0630  8d 46 ee              lea     ax, [bp+ee]
0df5:0633  50                    push    ax
0df5:0634  6a 00                 push    00

Stack Frame 5 of DIBTEST  cs:ip 0df5:00a3(1)   ss:bp 0dfd:1762
0df5:0094  ff 36 0016            push    word ptr [0016]
0df5:0098  ff 36 001c            push    word ptr [001c]
0df5:009c  ff 36 001e            push    word ptr [001e]
0df5:00a0  e8 053c               call    near 05df
(DIBTEST:+00a4)
0df5:00a3  50                    push    ax
0df5:00a4  e8 0746               call    near 07ed
0df5:00a7  8c d8                 mov     ax, ds
0df5:00a9  8e c0                 mov     es, ax

Task List
System tasks are all active applications.  Disable with "skipinfo=tasks".

System Tasks (tasks)
Task Name PROGMAN, File Name C:\MS\WIN\PROGMAN.EXE
  Handle 06bd, Flags 0001
Task Name SHERLOCK, File Name D:\SHERLOCK.EXE
  Handle 0d4d, Flags 0001
Task Name WINEXIT, File Name C:\MS\WIN\DON\WINEXIT.EXE
  Handle 0b55, Flags 0001
Task Name IDLEWILD, File Name C:\MS\WEP\IDLEWILD.EXE
  Handle 0b9d, Flags 0001
Task Name DIBTEST, File Name C:\TEMP\DIBTEST.EXE
  Handle 0dc5, Flags 0001

Module List
The module list is very large, and probably not vital.  I recommend disabling it with "skipinfo=modules".

System Modules (modules)
Module Name KERNEL, File Name C:\MS\WIN\SYSTEM\KRNL386.EXE
  Handle 00f5, Flags 0017
Module Name SYSTEM, File Name C:\MS\WIN\SYSTEM\SYSTEM.DRV
  Handle 00ed, Flags 000f
Module Name KEYBOARD, File Name C:\MS\WIN\SYSTEM\KEYBOARD.DRV
  Handle 011d, Flags 000f
Module Name MOUSE, File Name C:\MS\WIN\SYSTEM\MOUSE.DRV
  Handle 0135, Flags 000e
Module Name DISPLAY, File Name C:\MS\WIN\SYSTEM\SHELLSCR.DRV
  Handle 0195, Flags 000f
Module Name SOUND, File Name C:\MS\WIN\SYSTEM\SOUND.DRV
  Handle 02e5, Flags 000e
Module Name COMM, File Name C:\MS\WIN\SYSTEM\COMM.DRV
  Handle 02ed, Flags 000e
Module Name FONTS, File Name C:\MS\WIN\SYSTEM\VGASYS.FON
  Handle 0305, Flags 0002
Module Name OEMFONTS, File Name C:\MS\WIN\SYSTEM\VGAOEM.FON
  Handle 032d, Flags 0002
Module Name GDI, File Name C:\MS\WIN\SYSTEM\GDI.EXE
  Handle 033d, Flags 000e
Module Name FIXFONTS, File Name C:\MS\WIN\SYSTEM\VGAFIX.FON
  Handle 0325, Flags 0001
Module Name DISPLAY, File Name C:\MS\WIN\SYSTEM\VGA.DRV
  Handle 048d, Flags 0001
Module Name USER, File Name C:\MS\WIN\SYSTEM\USER.EXE
  Handle 0345, Flags 000d
Module Name FLSYS30, File Name C:\MS\WIN\SYSTEM\FLSYS30.DLL
  Handle 0835, Flags 0001
Module Name MODERN, File Name C:\MS\WIN\SYSTEM\MODERN.FON
  Handle 09ed, Flags 0001
Module Name SCRIPT, File Name C:\MS\WIN\SYSTEM\SCRIPT.FON
  Handle 0995, Flags 0001
Module Name ROMAN, File Name C:\MS\WIN\SYSTEM\ROMAN.FON
  Handle 09a5, Flags 0001
Module Name SYMBOL, File Name C:\MS\WIN\SYSTEM\SYMBOLE.FON
  Handle 0a55, Flags 0001
Module Name TMSRE, File Name C:\MS\WIN\SYSTEM\TMSRE.FON
  Handle 0a65, Flags 0001
Module Name COURE, File Name C:\MS\WIN\SYSTEM\COURE.FON
  Handle 0a75, Flags 0001
Module Name HELVE, File Name C:\MS\WIN\SYSTEM\HELVE.FON
  Handle 0a85, Flags 0001
Module Name PROGMAN, File Name C:\MS\WIN\PROGMAN.EXE
  Handle 06cd, Flags 0001
Module Name WINEXIT, File Name C:\MS\WIN\DON\WINEXIT.EXE
  Handle 0b15, Flags 0001
Module Name IDLEWILD, File Name C:\MS\WEP\IDLEWILD.EXE
  Handle 0b4d, Flags 0001
Module Name ABOUTWEP, File Name C:\MS\WEP\ABOUTWEP.DLL
  Handle 0bd5, Flags 0001
Module Name IWLIB, File Name C:\MS\WEP\IWLIB.DLL
  Handle 0bdd, Flags 0007
Module Name DROPOUT, File Name C:\MS\WEP\DROPOUT.IW
  Handle 0c2d, Flags 0001
Module Name FIREWORK, File Name C:\MS\WEP\FIREWORK.IW
  Handle 0c4d, Flags 0001
Module Name LINES, File Name C:\MS\WEP\LINES.IW
  Handle 0c65, Flags 0001
Module Name SHUFFLE, File Name C:\MS\WEP\SHUFFLE.IW
  Handle 0c7d, Flags 0001
Module Name STARS, File Name C:\MS\WEP\STARS.IW
  Handle 0c95, Flags 0001
Module Name WIPE, File Name C:\MS\WEP\WIPE.IW
  Handle 0c9d, Flags 0001
Module Name SHERLOCK, File Name D:\SHERLOCK.EXE
  Handle 0d3d, Flags 0001
Module Name TOOLHELP, File Name C:\MS\WIN\SYSTEM\TOOLHELP.DLL
  Handle 0d7d, Flags 0001
Module Name DIBTEST, File Name C:\TEMP\DIBTEST.EXE
  Handle 0dd5, Flags 0001

System Info
System info is miscallaneous information available.  Disable with "skipinfo=info".

System Info (info)
Windows version 3.0
System Free Space 6186272
LargestFree 6266880, MaxPagesAvail 1530, MaxPagesLockable 484
TotalLinear 1951, TotalUnlockedPages 491, FreePages 350
TotalPages 652, FreeLinearSpace 1531, SwapFilePages 1058
Page Size 4096
5 tasks executing.
WinFlags -
  80386 or 80386 SX
  Enhanced mode
  Protect mode

Other Reports
At this point, Sherlock's GP Fault decoding logic is incomplete.  We detect many possible GP faults, but not all.  Examples we detect are null pointer usage, writing to code segments, segment limit violations, divide by zero.  Other faults may occur that display as "Unable to detect."  Let us know if that is a problem for you.
Here are some other sample fault displays.  They were generated with the WIN.INI entry  "skipinfo=info, modules, tasks, stack, 32bit".

Sherlock 0.7 Failure Report - Mon Apr  8 11:20:09 1991
Elementary - a 'General Protection' fault has occured at 0e05:0311.
This is from segment 1 of 'C:\TEMP\DIBTEST.EXE' (DIBTEST)
The cause appears to be 'Exceed segment bounds'.

CPU Registers (regs)
ax = 0028  bx = ffff  cx = 0004  dx = 0103  si = 008d  di = 008d  bp = 1702
cs:ip = 0e05:0311  8053e080:0e9f Code Ex/R    ds = 0e0d  80529e20:277f Data R/W 
ss:sp = 0e0d:16ec  80529e20:277f Data R/W     es = 0e0d  80529e20:277f Data R/W 

Instruction Disassembly (disasm)
0e05:0306  8c 5e fe              mov     [bp+fe], ds
0e05:0309  c7 46 fc ffff         mov     word ptr [bp+fc], ffff
0e05:030e  c4 5e fc              les     bx, [bp+fc]
(DIBTEST:_GPFault+003a)
0e05:0311  26 ff 37              push    word ptr es:[bx]
0e05:0314  ff 76 fe              push    word ptr [bp+fe]
0e05:0317  ff 76 fc              push    word ptr [bp+fc]


Sherlock 0.7 Failure Report - Mon Apr  8 11:20:20 1991
Elementary - a 'Divide by 0' fault has occured at 0e1d:03fe.
This is from segment 1 of 'C:\TEMP\DIBTEST.EXE' (DIBTEST)
The cause appears to be 'Divide by 0'.

CPU Registers (regs)
ax = 0001  bx = 0000  cx = 0004  dx = 0000  si = 0093  di = 0093  bp = 1702
cs:ip = 0e1d:03fe  8053fa80:0e9f Code Ex/R    ds = 0e15  8052a180:277f Data R/W 
ss:sp = 0e15:16ec  8052a180:277f Data R/W     es = 0000         0:0000 Null Ptr 

Instruction Disassembly (disasm)
0e1d:03f9  44                    inc     sp
0e1d:03fa  a1 0054               mov     ax, [0054]
0e1d:03fd  99                    cwd
(DIBTEST:_GPFault+0127)
0e1d:03fe  f7 3e 0056            idiv    word ptr [0056]
0e1d:0402  50                    push    ax
0e1d:0403  68 0244               push    0244


ceed segment bounds'.

CPU Registers (regs)
ax = 0028  bx = ffff  cx = 0004  dx = 0103  si = 008d  di = 008d  bp = 1702
cs:ip = 0e05:0311  8053e080:0e9f Code Ex/R    ds = 0e0d  80529e20:277f Data R/W 
ss:sp = 0e0d:16ec  80529e20:277f Data R/W     es = 0e0d  80529e20:277f Data R/W 

Instruction Disa          /                  	  
      a  ]  C      e    _      W,  ,  .  %.  /  /  6                                                                                                                                                                                                                                                                                                                      $    0 !                    }    /  j                  	  	  	  !
  \
  
  
  
  
        )  {        _  a        I  [  ]  j  A  C  e          =  j              >  m             !    !    ! `   !    !     !     !    !    !    !    !    !    !    !    ! C    E  r          K  x        %  Z           5  p          D  y          J  {        '  Z          5  b          >  k  m      !  [          2  c  e  p          "  Q  l           B   ]   _   l            /!  J!  !  !  !  !  3"  N"  "  "  "  "      !    !    !    ! `\"  2#  M#  #  #  #  #  /$  J$  $  $  $  $  -%  H%  %  %  %  %  1&  L&  &  &  &  &  0'  K'  '  '  '  '  )(  D(  ~(  (  (  (  $)  ?)  q)  )  )  )  *  .*  _*  z*  *  *  *  +  E+  `+  +  +  +  ,  :,  U,  W,  d,  ,  ,  ,  ,  ,  =-  v-  -  -  -  -  -  .  .  .  '.  q/  /  /  30  x0  0  0  0  0     !     !    !    !    !    !    ! `U0  J1  1  1  1  2  H2  2  2  2  3  N3  3  3  3  3  4  >4  f4  h4  ~4  4  5  o5  q5  5  5  5  6  46  n6  6  6  6  6                                                                                                                                                                                                                                                                                                                                          ! `"        
              N5       &      s&  g/  N5          4    K     6             6       "  0  6       N Terminal 	System  
Courier  Roman Times Roman  Times New Roman  HP Printers LPT1: HPPCL HP LaserJet `F%sv        @ 8 F                   d       .                          
         w  "      =/    h    ee                     Y   Sherlock Preliminary Report  I hope someone cleans this up.Don CorbittDon Corbitt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\sherlock\sherlock.txt ===
Changes to Sherlock

8 May 1991
==========
donc    Put report in Windows, not Windows\System, directory (before today)
donc    Fix hang when switched to using TaskMan (before today)
donc    Increase stack size - TIGA hang (before today)
donc    Change version to 0.71
donc    Avoid divide-by-0 in GDI (jont)
donc    Link with ToolHelp again, not Sherlock.DLL (timg)
donc    Fix mispelled 'occurred'
donc    Validate code segment on stack walk (hang bug)
donc    Add sherlock version # to pop-up box
donc    Decode more faulting instructions - [rep] string group
donc    Decode xlat instruction
donc    Show file date, size, and time
donc    Detect large Sherlock file and warn user
donc    Show local variables
donc    Reformat output, so it fits 80 column lines even when mailed
donc    Show owner of code in DisAsm
donc    Two line summary of important info

9 May 1991
==========
donc    Disable divide-by-0 fault unless "trapzero=1" in [sherlock] win.ini
donc    Changed version to 0.72
donc    Return whether error was Read, Write or Read/Write of memory

15 May 1991
===========
donc    Change version to 0.73
donc    Change name to Dr. Watson (when?)

5 June 1991
===========
donc    Change version to 0.74
donc    cmp was treated as RMW, now is Read
donc    "xchg ax, reg" was shown as "xchg reg"
donc    Change icon from Sherlock pipe to Doctor bag and stethescope
donc    Print out app stack values (base, top, lowest, size)
donc    Return 1 to WM_INITDIALOG (fix focus bug??)
donc    Sign extend 1 byte address immediates
donc    Change "occured" to "occurred" in dialog box
donc    Disable disassembly of stack trace after 'N' levels, default 2
donc    Print out USER and GDI heap stats (free, max, %, seg)
kensy   Write util to add symbols to log file created with no access
donc    Reduce memory used - don't call sprintf(), vsprintf(), open(), write()
donc    Move information (windows version, etc) to top of log entry
donc    "mov [mem], reg" was RMW, now is Write
donc    Remove Tab2Spc() in DisAsm86(), leave tabs in disassmbly
donc    Don't save regs unless we are trapping the interrupt
donc    Allow just commas between entries in skipinfo= in [Dr. Watson]
donc    Add asterisk (*****) line before each report
donc    Add "Stop Dr. Watson" entry each time program is terminated
donc    Show Windows build, user, organization in report (Win 3.10.34d+)
donc    Make OK button the default in Clues dialog box
donc    Change JNLE to JG, etc

7 June 1991
===========
donc    Change version to 0.74a
donc    Allow skipping local vars (skipinfo=locals)
donc    Change default skipinfo from nothing to modules+disasm
donc    Change $tag$ line so all seperators are '$', not tabs

15 June 1991
============
donc    Add sound to GP fault printing (skipinfo=sound)
donc    Allow GP continuation if GPFault&1
donc    Don't bring up dialog box if GPFault&2
donc    Allow GP continuation for memory access, segment load instructions
donc    Don't do complete report if more than 2 reports have already been done

24 June 1991
============
donc    Disable sound unless GPContinue & 16
donc    Add SysErrorBox() if fault is ignorable.
donc    SysErrorBox behaves differently Win3 and Win3.1, so do I
donc    Default GPContine == 1

26 June 1991
============
donc    Fix crash in Win 3.0 when compiled with MSC (GetVersion())
donc    Allow 3 full reports, 20 total reports, per session
donc    Skip UAE box when RAE box seen

24 July 1991
============
donc    Use pretty new icon Doctor.ico
donc    Show stack values as unsigned
donc    Return 1 to WM_INITDIALOG (bug #9248)

31 July 1991
============
donc    Include time on "Attempt to continue" line

2 Aug 1991
==========
donc	Only ask for clues once
donc	Show debug/retail in info
donc	Version 0.77
donc	Show parameter validation messages
donc	Stack trace show calling routine
donc	skipinfo 'par' to skip param validation tracing
donc	skipinfo 'err' to skip error tracing
donc	Copyright line in message box

5 Aug 1991
==========
donc    Version 0.78
donc	Only warn large file once
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\user\readme.txt ===
Building user16:

If you don't have USER sources that match the build you're testing on,
and you're building x86 free, you will want to use:

nmake NONX86=1

which will build a version which does not embed copies of user32.dll
code into user.exe.

When you're building checked or on RISC, this is a non-issue.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\win87em\win87hdr.txt ===
Microsoft (R) EXE File Header Utility  Version 2.01    
Copyright (C) Microsoft Corp 1985-1990.  All rights reserved.

.EXE size (bytes)         3200
Magic number:             5a4d
Bytes on last page:       00a3
Pages in file:            0018
Relocations:              0000
Paragraphs in header:     0020
Extra paragraphs needed:  0000
Extra paragraphs wanted:  ffff
Initial stack location:   0004:0100
Word checksum:            eb10
Entry point:              0000:0000
Relocation table address: 0040
Reserved words:
 0000 0000 0000 0000 0000 0000 0000 0000
 0000 0000 0000 0000 0000
New .EXE header address:  00000400
Memory needed:            12K

Library:                  WIN87EM
Description:              Microsoft Windows 3.1 Coprocessor/Emulator Library 7.00.00
Operating system:         Microsoft Windows
Data:                     NONE
Initialization:           Global
Initial CS:IP:            seg   1 offset 0058
Initial SS:SP:            seg   0 offset 0000
Linker version:           5.01
32-bit Checksum:          00b41495
Segment Table:            00000440 length 0010 (16)
Resource Table:           00000450 length 0000 (0)
Resident Names Table:     00000450 length 004f (79)
Module Reference Table:   0000049f length 0002 (2)
Imported Names Table:     000004a1 length 0013 (19)
Entry Table:              000004b4 length 0015 (21)
Non-resident Names Table: 000004c9 length 003e (62)
Movable entry points:     0
Segment sector size:      512
Application type:         WINDOWAPI
Other module flags:       
no. type address  file  mem   flags
  1 CODE 00000800 02763 02763 EXECUTEREAD, PRELOAD, NONCONFORMING, NOIOPL,
                              relocs, (fixed), (nondiscardable), (nonshared)
  2 DATA 00003000 00170 00170 READWRITE, SHARED, PRELOAD, NOEXPANDDOWN, NOIOPL,
                              (fixed), (nondiscardable)


Exports:
ord seg offset name
  2   1  0089  WEP exported
  1   1  002a  __FPMATH exported
  3   1  01ab  __WIN87EMINFO exported
  4   1  0220  __WIN87EMRESTORE exported
  5   1  01e3  __WIN87EMSAVE exported

  1 type   offset target
    OFFSET  2692  imp KERNEL.__WINFLAGS
    PTR     0613  imp KERNEL.171
    PTR     0665  imp KERNEL.176
    BASE    0e0a  seg   2 offset 016f
    BASE    274d  seg   2 offset 0170
   5 relocations
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\write\readme.txt ===
/************************************************************/
/* Windows Write, Copyright 1985-1990 Microsoft Corporation */
/************************************************************/

                                                     ** 21-January-1988

        MS-WRITE for version 2.0 of Windows is a weird bird in that it 
cannot be compiled with standard tools (ie: MASM 5.0 etc.).  You will
need to set up a separate environment from which to make it using the 
tools in the \WRITE\TOOLS subdirectory.  We are sorry for this inconvenience
and will attempt to remedy this in future versions of MS-WINDOWS.

Sincerely,

OEM Support Group

                                                     ** 27-February-1989
                                                        pault

I am trying to remove the above restriction.  The Win "DEV" SLM project is
being used to build MS-WRITE for Windows 3.0, currently without problems.
Make sure autoexec references are made/added as follows:
        set path=\dev;\dev\tools
        set include=\dev\inc
        set lib=\dev\lib

WRITE is the makefile for this project.  DO NOT USE MAKEFILE -- I do not
know where it came from or why it's here, and of course we may learn that
things are not currently as rosy as we believe, but this is how I *THINK*
the product has been made in the past...
        
        MAKE WRITE              MAKE "DEBUGDEF=-DDEBUG" "DFLAGS=/Zd" WRITE
        builds the standard     builds a debugging version
        release version

        
                                                     ** 28-March-1989
                                                        pault

The above procedure was not generating quite the same WRITE.EXE as we've 
previously had (Win 2.x).  In talking with anyone who's ever been involved
at all, this is the information I have learned:

   1. Nobody wants this product or claims responsibility for it.
   2. It has been a nightmare for everyone who has worked on, with,
      or around it. 
   3. The international version was incorporated at some time during
      2.x and is now "built in".
   4. There was at one time an online help system designed which was 
      never included in a shipped version.
   5. The 6 or 8 batch files, .libs, and makefiles "makefile" and 
      "wrtmake" are for the 2.x version; since we have since grown up 
      I am removing them...
   6. The K*.* files (or *.K* files) apply to the Kanji make process and
      they have N-O-T been updated yet, but are being left in the project
      (i.e. they must be modified or add to the "write" makefile).  Also
      see the file EDM.EDM (hey, file naming is our specialty here at MS).
   
I have made mods to the project and "write" makefile to incorporate the
subtle changes from 2.x.  Variations of the make process are/will be 
documented inside the makefile.

        
                                                     ** 8-June-1989
                                                        pault

In order to ease localization of this product, all string-related info
in GLOBDEFS.H should really be moved to WRITE.RC because that's where
it belongs and it'll also make things a lot cleaner.  [True for Kanji?]

                                                        
                                                     ** 31-August-1989
                                                        pault

Due to major changes in Write.rc and the split into Write.dlg, whoever
takes on the task of localization to Intl or Kanji should be sure to
start over with the new Write.rc and Write.dlg.

                                                        
                                                     ** 18-October-1989
                                                        pault

I've just made a major revision with regard to font handling in Write.
The first one was to make sure that the endmark is always displayed in
the system font.  The Kanji version already ensured this so I grouped
all the code concerning this under the define 'SYSENDMARK', and enabled
it in the Z version.

The second one was to revamp font enumeration... (under 'NEWFONTENUM')

Old method: Call EnumFonts to get a list of fonts available, and "filter 
            out" fonts which did not match our desired aspect ratio (based 
            on the overall display dimensions).  In addition, any fonts 
            which were not the ANSI character set (i.e. the tmCharSet or 
            lfCharSet fields in the TEXTMETRICS and LOGFONT structures, 
            respectively) were "swallowed".  A specific byproduct of this 
            was that screen fonts such as Modern, Script, Symbol, etc.
            could not be used in Write.

New method: Call EnumFonts to get a list of fonts available.  No filtering-
            out is done.  The major problem here became an issue with the
            Write file format: the font name and font family are stored in
            the document but naturally not the appropriate character set 
            value (since only ANSI had been previously allowed).  So now
            when we read a new document in, we enumerate all the fonts and
            then for each font in the doc we try to match up the correct
            character set value.  

            This slows things down ever-so-slightly and we also have the 
            possibility of getting confused if someone names a font of one
            character set the same as one of a different character set, but 
            there wasn't much alternative -- it was either make this kind
            of guess or revise the file format which would have created a
            lot more problems at this point.


                                                     ** 23-October-1989

FernandD has worked on the localization issue mentioned above and checked
in changes for Rel 1.46

                                                     
                                                     ** 24-October-1989
                                                        pault

One change involved in the above NEWFONTENUM was to use FORM1.C instead 
of the (presumably) faster FORMAT.ASM.  So this sparks the idea to keep
a list of some performance ideas for future use...

done?   task
-----   ----
        1) handcode critical routines (including the use format.asm 
           instead of form1.c)
        2) make use of register vars
        3) chipa suggests breaking up really large segments, and eliminating
           very small ones
  X     4) remove inefficient lockdown of dialog procs, etc.  not sure
           why this is currently done but it forces a large amount of 
           code to be fixed at write startup, and this hampers the general
           idea of movable segments in a winapp!
        5) remove use of C run-time libs

                                                     ** 25-October-1989

It has just been decided to remove support for ExtDeviceMode from Write
(primarily because none of the other apps had it!)  This means that when
you change Printer.Setup inside Write, that affects the global Windows
printer settings (rather than just those for the current Write session).
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\genwowit.txt ===
readme for genwowit.exe

This tool generates two source files for wow32, wowit.c and wowit.h,
from the input file wow.it.  wow.it contains one pseudo-prototype
for each API we want to have an interpreted thunk for.  The program
converts these psuedo-prototypes into interpreted thunk byte streams
in wowit.c's InstrSwamp byte array, and entries in wowit.c's
IntThunkTable which point to the API and the thunk instruction stream.
The psuedo-prototypes can have two names separated by an equals sign,
indicating the 16-bit API name on the left is thunked to the 32-bit
API name on the right.

The bytecode instruction streams consist of 0 or more argument conversion
opcodes, which don't have the high bit (0x80) set, followed by a return
code conversion opcode, which does have the high bit set.

genwowit tries to keep InstrSwamp as small as possible by pointing
multiple interpreted thunks at the same instruction stream when they
share prototypes (args & retval types).  See for example below how
UpdateColors, StartPage, EndPage, and GetTextCharacterExtra all
use the first instruction stream because they all take a GDI handle
and return an int.

Further, genwowit will point into the middle of an existing instruction
stream if it contains the instruction stream it needs.  For example see
below how the wowit.c IntThunkTable GetRasterizerCaps entry points to
InstrSwamp + 0xb, which is 3 bytes into the instruction stream for
TextOut, because ignoring the first three TextOut args they have the
same prototype.

An example, here's a tiny wow.it and the wowit.h and wowit.c that result.

----- wow.it begin
INT   UpdateColors(HGDI);
INT   StartPage(HGDI);
INT   EndPage(HGDI);
DWORD GetFontData(HGDI, DWORD, DWORD, PTR, DWORD);
WORD  GetRasterizerCaps(PTR, INT);
WORD  IsGDIObject=GetObjectType(HGDI);
WORD  GetTextAlign(HGDI);
INT   GetTextCharacterExtra(HGDI);
INT   SetTextCharacterExtra(HGDI, INT);
DWORD GetTextColor(HGDI);
INT   GetTextFace(HGDI, INT, PTR);
INT   SetTextJustification(HGDI, INT, INT);
WORD  TextOut(HGDI, INT, INT, PTR, INT);
----- wow.it end

here's the output genwowit produces on the console:

Generated wowit.h and wowit.c from wow.it
13 thunks, 8 unique instruction streams, 29 instruction bytes, 5 max args.

And the files:

----- wowit.h begin
//
// wowit.h generated by genwowit.exe from wow.it, DO NOT EDIT.
//

#include "intthunk.h"

#define MAX_IT_ARGS  5

#define IT_WORD                 ( (UCHAR) 0x0 )
#define IT_INT                  ( (UCHAR) 0x1 )
#define IT_DWORD                ( (UCHAR) 0x2 )
#define IT_LPDWORD              ( (UCHAR) 0x3 )
#define IT_PTR                  ( (UCHAR) 0x4 )
#define IT_PTRORATOM            ( (UCHAR) 0x5 )
#define IT_HGDI                 ( (UCHAR) 0x6 )
#define IT_HUSER                ( (UCHAR) 0x7 )
#define IT_COLOR                ( (UCHAR) 0x8 )
#define IT_HINST                ( (UCHAR) 0x9 )
#define IT_HICON                ( (UCHAR) 0xa )
#define IT_16ONLY               ( (UCHAR) 0xb )
#define IT_32ONLY               ( (UCHAR) 0xc )

#define IT_RETMASK              ( (UCHAR) 0x80 )
#define IT_DWORDRET             ( IT_RETMASK | (UCHAR) 0x0 )
#define IT_WORDRET              ( IT_RETMASK | (UCHAR) 0x1 )
#define IT_INTRET               ( IT_RETMASK | (UCHAR) 0x2 )
#define IT_HGDIRET              ( IT_RETMASK | (UCHAR) 0x3 )
#define IT_HUSERRET             ( IT_RETMASK | (UCHAR) 0x4 )
#define IT_ZERORET              ( IT_RETMASK | (UCHAR) 0x5 )
#define IT_HICONRET             ( IT_RETMASK | (UCHAR) 0x6 )
#define IT_ONERET               ( IT_RETMASK | (UCHAR) 0x7 )
#define IT_HPRNDWPRET           ( IT_RETMASK | (UCHAR) 0x8 )

#define ITID_UpdateColors                             0
#define ITID_StartPage                                1
#define ITID_EndPage                                  2
#define ITID_GetFontData                              3
#define ITID_GetRasterizerCaps                        4
#define ITID_IsGDIObject                              5
#define ITID_GetTextAlign                             6
#define ITID_GetTextCharacterExtra                    7
#define ITID_SetTextCharacterExtra                    8
#define ITID_GetTextColor                             9
#define ITID_GetTextFace                              10
#define ITID_SetTextJustification                     11
#define ITID_TextOut                                  12

#define ITID_MAX 12
----- wowit.h end

----- wowit.c begin
//
// wowit.c generated by genwowit.exe from wow.it, DO NOT EDIT.
//

#include "precomp.h"
#pragma hdrstop
#define WOWIT_C
#include "wowit.h"

CONST BYTE InstrSwamp[] = {
    /*   0  0x0   */ IT_HGDI, IT_INTRET, 
    /*   1  0x2   */ IT_HGDI, IT_DWORD, IT_DWORD, IT_PTR, IT_DWORD, IT_DWORDRET, 
    /*   2  0x8   */ IT_HGDI, IT_INT, IT_INT, IT_PTR, IT_INT, IT_WORDRET, 
    /*   3  0xe   */ IT_HGDI, IT_WORDRET, 
    /*   4  0x10  */ IT_HGDI, IT_INT, IT_INTRET, 
    /*   5  0x13  */ IT_HGDI, IT_DWORDRET, 
    /*   6  0x15  */ IT_HGDI, IT_INT, IT_PTR, IT_INTRET, 
    /*   7  0x19  */ IT_HGDI, IT_INT, IT_INT, IT_INTRET, 
};

INT_THUNK_TABLEENTRY IntThunkTable[] = {
    /*   0 */ { (FARPROC) UpdateColors,                    InstrSwamp + 0x0    },  /* 0 */ 
    /*   1 */ { (FARPROC) StartPage,                       InstrSwamp + 0x0    },  /* 0 */ 
    /*   2 */ { (FARPROC) EndPage,                         InstrSwamp + 0x0    },  /* 0 */ 
    /*   3 */ { (FARPROC) GetFontData,                     InstrSwamp + 0x2    },  /* 1 */ 
    /*   4 */ { (FARPROC) GetRasterizerCaps,               InstrSwamp + 0xb    },  /* 2 + 3 */ 
    /*   5 */ { (FARPROC) GetObjectType,                   InstrSwamp + 0xe    },  /* 3 */ 
    /*   6 */ { (FARPROC) GetTextAlign,                    InstrSwamp + 0xe    },  /* 3 */ 
    /*   7 */ { (FARPROC) GetTextCharacterExtra,           InstrSwamp + 0x0    },  /* 0 */ 
    /*   8 */ { (FARPROC) SetTextCharacterExtra,           InstrSwamp + 0x10   },  /* 4 */ 
    /*   9 */ { (FARPROC) GetTextColor,                    InstrSwamp + 0x13   },  /* 5 */ 
    /*  10 */ { (FARPROC) GetTextFace,                     InstrSwamp + 0x15   },  /* 6 */ 
    /*  11 */ { (FARPROC) SetTextJustification,            InstrSwamp + 0x19   },  /* 7 */ 
    /*  12 */ { (FARPROC) TextOut,                         InstrSwamp + 0x8    },  /* 2 */ 
};
----- wowit.c end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\readit.txt ===
readme for interpreted thunks

Interpreted Thunks are an attempt to replace the simplest thunk functions
in WOW with a bit of data.  Each thunk consists of a pointer to the Win32
API routine (actually to a callable loader thunk in one of the pages set
aside for fixups if needed) and a pointer to a variable-length byte stream
which dictates how to convert arguments and return values.  The first byte
is an opcode indicating how to thunk the leftmost argument, the last byte
is distinguished by having its high bit set (0x8?) and indicates how to
thunk the return value.

A tool called genwowit reads a source file called wow.it which contains
psuedo-prototypes (really thunk descriptions) and generates wowit.h
and wowit.c with the actualy thunk table and assiociated instruction
"swamp" containing all the bytecode instruction streams.  See
\nt\private\sdktools\genwowit\readme.txt for details.

Note that the major restriction of interpreted thunks as implemented is
that pointers to structures which need thunking are not supported.

Here's a tiny wow.it and the wowit.h and wowit.c that result.

----- wow.it begin
INT   UpdateColors(HGDI);
INT   StartPage(HGDI);
INT   EndPage(HGDI);
DWORD GetFontData(HGDI, DWORD, DWORD, PTR, DWORD);
WORD  GetRasterizerCaps(PTR, INT);
WORD  IsGDIObject=GetObjectType(HGDI);
WORD  GetTextAlign(HGDI);
INT   GetTextCharacterExtra(HGDI);
INT   SetTextCharacterExtra(HGDI, INT);
DWORD GetTextColor(HGDI);
INT   GetTextFace(HGDI, INT, PTR);
INT   SetTextJustification(HGDI, INT, INT);
WORD  TextOut(HGDI, INT, INT, PTR, INT);
----- wow.it end

here's the output genwowit produces on the console:

Generated wowit.h and wowit.c from wow.it
13 thunks, 8 unique instruction streams, 29 instruction bytes, 5 max args.

And the files:

----- wowit.h begin
//
// wowit.h generated by genwowit.exe from wow.it, DO NOT EDIT.
//

#include "intthunk.h"

#define MAX_IT_ARGS  5

#define IT_WORD                 ( (UCHAR) 0x0 )
#define IT_INT                  ( (UCHAR) 0x1 )
#define IT_DWORD                ( (UCHAR) 0x2 )
#define IT_LPDWORD              ( (UCHAR) 0x3 )
#define IT_PTR                  ( (UCHAR) 0x4 )
#define IT_PTRORATOM            ( (UCHAR) 0x5 )
#define IT_HGDI                 ( (UCHAR) 0x6 )
#define IT_HUSER                ( (UCHAR) 0x7 )
#define IT_COLOR                ( (UCHAR) 0x8 )
#define IT_HINST                ( (UCHAR) 0x9 )
#define IT_HICON                ( (UCHAR) 0xa )
#define IT_16ONLY               ( (UCHAR) 0xb )
#define IT_32ONLY               ( (UCHAR) 0xc )

#define IT_RETMASK              ( (UCHAR) 0x80 )
#define IT_DWORDRET             ( IT_RETMASK | (UCHAR) 0x0 )
#define IT_WORDRET              ( IT_RETMASK | (UCHAR) 0x1 )
#define IT_INTRET               ( IT_RETMASK | (UCHAR) 0x2 )
#define IT_HGDIRET              ( IT_RETMASK | (UCHAR) 0x3 )
#define IT_HUSERRET             ( IT_RETMASK | (UCHAR) 0x4 )
#define IT_ZERORET              ( IT_RETMASK | (UCHAR) 0x5 )
#define IT_HICONRET             ( IT_RETMASK | (UCHAR) 0x6 )
#define IT_ONERET               ( IT_RETMASK | (UCHAR) 0x7 )
#define IT_HPRNDWPRET           ( IT_RETMASK | (UCHAR) 0x8 )

#define ITID_UpdateColors                             0
#define ITID_StartPage                                1
#define ITID_EndPage                                  2
#define ITID_GetFontData                              3
#define ITID_GetRasterizerCaps                        4
#define ITID_IsGDIObject                              5
#define ITID_GetTextAlign                             6
#define ITID_GetTextCharacterExtra                    7
#define ITID_SetTextCharacterExtra                    8
#define ITID_GetTextColor                             9
#define ITID_GetTextFace                              10
#define ITID_SetTextJustification                     11
#define ITID_TextOut                                  12

#define ITID_MAX 12
----- wowit.h end

----- wowit.c begin
//
// wowit.c generated by genwowit.exe from wow.it, DO NOT EDIT.
//

#include "precomp.h"
#pragma hdrstop
#define WOWIT_C
#include "wowit.h"

CONST BYTE InstrSwamp[] = {
    /*   0  0x0   */ IT_HGDI, IT_INTRET, 
    /*   1  0x2   */ IT_HGDI, IT_DWORD, IT_DWORD, IT_PTR, IT_DWORD, IT_DWORDRET, 
    /*   2  0x8   */ IT_HGDI, IT_INT, IT_INT, IT_PTR, IT_INT, IT_WORDRET, 
    /*   3  0xe   */ IT_HGDI, IT_WORDRET, 
    /*   4  0x10  */ IT_HGDI, IT_INT, IT_INTRET, 
    /*   5  0x13  */ IT_HGDI, IT_DWORDRET, 
    /*   6  0x15  */ IT_HGDI, IT_INT, IT_PTR, IT_INTRET, 
    /*   7  0x19  */ IT_HGDI, IT_INT, IT_INT, IT_INTRET, 
};

INT_THUNK_TABLEENTRY IntThunkTable[] = {
    /*   0 */ { (FARPROC) UpdateColors,                    InstrSwamp + 0x0    },  /* 0 */ 
    /*   1 */ { (FARPROC) StartPage,                       InstrSwamp + 0x0    },  /* 0 */ 
    /*   2 */ { (FARPROC) EndPage,                         InstrSwamp + 0x0    },  /* 0 */ 
    /*   3 */ { (FARPROC) GetFontData,                     InstrSwamp + 0x2    },  /* 1 */ 
    /*   4 */ { (FARPROC) GetRasterizerCaps,               InstrSwamp + 0xb    },  /* 2 + 3 */ 
    /*   5 */ { (FARPROC) GetObjectType,                   InstrSwamp + 0xe    },  /* 3 */ 
    /*   6 */ { (FARPROC) GetTextAlign,                    InstrSwamp + 0xe    },  /* 3 */ 
    /*   7 */ { (FARPROC) GetTextCharacterExtra,           InstrSwamp + 0x0    },  /* 0 */ 
    /*   8 */ { (FARPROC) SetTextCharacterExtra,           InstrSwamp + 0x10   },  /* 4 */ 
    /*   9 */ { (FARPROC) GetTextColor,                    InstrSwamp + 0x13   },  /* 5 */ 
    /*  10 */ { (FARPROC) GetTextFace,                     InstrSwamp + 0x15   },  /* 6 */ 
    /*  11 */ { (FARPROC) SetTextJustification,            InstrSwamp + 0x19   },  /* 7 */ 
    /*  12 */ { (FARPROC) TextOut,                         InstrSwamp + 0x8    },  /* 2 */ 
};
----- wowit.c end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow32\thunkdll.txt ===
How to add a new thunk table for a new 16-bit thunk DLL:

 - modify wow16\kernel31\kernel.def and add an export similar to __MOD_KERNEL
   rebuild the 16-bit libraries  (nmake in mvdm\wow16\lib)

 - modify the Thunk macro in inc\wow.h and add another externA
   update the MOD_ constants in wow.h, the profiling code still uses them.
   regenerate wow.inc

 - update kernel31\kdata.asm and add another MOD_ variable

 - declare and make public a new __MOD_ value for exporting  (ldboot.asm)

 - create the table (.h file) for inclusion into wowtbl.c

 - wowtbl.h  - add a field to the tableoffsets structure

 - wowtbl.c  - #include the table into aw32WOW and update apszModNames,
    InitThunkTableOffsets, ModFromCallID, and TableOffsetFromName

 - update makefile.inc with the new dependency
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\readme.txt ===
11-Nov-92

Conventions:

    BUGBUG - usual meaning

    PERFNOTE    - place where we should write some code to be more
                  time or space efficient, but which functions correctly
                  as is today.

    WARNNOTE    - some code that "works", but may someday break.
                  (a bugbug that we aren't going to fix)

                  OR - code that works reliably, but has behavior
                        that people may not like.



Build Products:

    config.lib  - linked into ntoskrnl.exe

    bconfig.lib - linked into boot loader (ntldr, osloader)

    uconfig.lib - linked into tools in sdktools\regini

    sconfig.lib - linked into setup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\inc\ntc.txt ===
Assigned Node Type Codes

Most system structures start off with a two byte identifier.  Some components
refer to this as a NodeTypeCode.  To make development and debugging easier each
each component is assigned a range of type code values.


The following table is used to keep track of assigned type code values used
by various system components.


0x0100

0x0200  0x02f9 - 0x02ff CACHE

0x0300  0x0301 - 0x0309 CDFS

0x0400  0x0401 - 0x0408 NPFS

0x0500  0x0500 - 0x050b FASTFAT

0x0600  0x0600          RAW
        0x0601 - 0x0608 MAILSLOT

0x0700  0x0700 - 0x070e CNTFS

0x0800  0x0800 - 0x0804 LFS

0x0900  0x0901 - 0x090a UDFS

0x0a00  0x0a00 - 0x0a01 CNSS

0x0b00

0x0c00

0x0d00  0x0d01 - 0x0d0e DFS
        0x0d01 - 0x0d0e MUP

0x0e00  0x0e04          EFS

0x0f00  0x0f01 - 0x0f10 NW\RDR

0x1000

0xeb00  0xeb00 - 0xecff RDR2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\init\w32kexps.txt ===
DbgPrompt
ExDesktopObjectType CONSTANT        // Data - use pointer for access
ExEnumHandleTable
ExEventObjectType CONSTANT          // Data - use pointer for access
ExWindowStationObjectType CONSTANT  // Data - use pointer for access
KePulseEvent
KeRaiseUserException
KeServiceDescriptorTable CONSTANT   // Data - use pointer for access
KeSetKernelStackSwapEnable
KeUserModeCallback
LdrAccessResource
LdrFindResource_U
LdrFindResourceDirectory_U
LpcRequestPort
LpcRequestWaitReplyPort
MmAdjustWorkingSetSize
MmCreateSection
MmGrowKernelStack
MmMapViewOfSection
MmSectionObjectType CONSTANT
MmUnmapViewOfSection
NlsMbCodePageTag CONSTANT           // Data - use pointer for access
NlsAnsiCodePage CONSTANT            // Data - use pointer for access
NlsOemCodePage CONSTANT             // Data - use pointer for access
ObAssignSecurity
ObCheckCreateObjectAccess
ObCheckObjectAccess
ObOpenObjectByName
ObReferenceObjectByName
ObSetSecurityDescriptorInfo
PsLookupProcessByProcessId
PsLookupThreadByThreadId
PsReferenceImpersonationToken
PsReferencePrimaryToken
PsRevertToSelf
RtlAddAce
RtlAreAllAccessesGranted
RtlAreAnyAccessesGranted
RtlCreateUnicodeString
RtlFindMessage
RtlFormatCurrentUserKeyPath
RtlGetDefaultCodePage
RtlImageNtHeader
RtlIntegerToChar
RtlRaiseException
RtlSetSaclSecurityDescriptor
RtlZeroHeap
SeCaptureSecurityDescriptor
SeCloseObjectAuditAlarm
SeCreateAccessState
SeDeleteAccessState
SePrivilegeCheck
SePrivilegeObjectAuditAlarm
SeReleaseSecurityDescriptor
ZwAlertThread
ZwClearEvent
ZwCreateTimer
ZwDuplicateToken
ZwOpenProcess
ZwOpenThread
ZwPulseEvent
ZwQueryInformationProcess
ZwQueryObject
ZwQuerySecurityObject
ZwResetEvent
ZwSetDefaultLocale
ZwSetDefaultUILanguage
ZwSetInformationObject
ZwSetTimer
ZwWaitForMultipleObjects
ZwTerminateProcess
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ob\ob.txt ===
Here is a breakdown of what each module exports

    obinit.c    KMUTANT ObpInitKillMutant;
                UNICODE_STRING ObpDosDevicesShortName;
                ULARGE_INTEGER ObpDosDevicesShortNamePrefix;
                ULARGE_INTEGER ObpDosDevicesShortNameRoot
                PDEVICE_MAP ObSystemDeviceMap

                ObInitSystem (
                ObDupHandleProcedure (
                ObAuditInheritedHandleProcedure (
                ObInitProcess (
                ObInitProcess2 (
                ObDestroyHandleProcedure (
                ObKillProcess (
                ObFindHandleForObject (

    obcreate.c  ObCreateObject (
                ObDeleteCapturedInsertInfo (
                ObFreeObjectCreateInfoBuffer (
                ObpCaptureObjectCreateInformation (
                ObpCaptureObjectName (
                ObpFreeObjectNameBuffer (
                ObpAllocateObject (
                ObpFreeObject (

    obhandle.c  NtDuplicateObject (
                ObGetHandleInformation (
                ObpIncrPointerCount (
                ObpDecrPointerCountWithResult (
                ObpIncrementHandleCount (
                ObpDecrementHandleCount (
                ObpCreateHandle (
                ObpCreateUnnamedHandle (
                ObpTranslateGrantedAccessIndex (

    obinsert.c  ObInsertObject (

    obref.c     ObOpenObjectByName (
                ObOpenObjectByPointer (
                ObReferenceObjectByHandle (
                ObReferenceObjectByName (
                ObReferenceObjectByPointer (
                ObDereferenceObject (
                ObfReferenceObject (
                ObpDeleteNameCheck (

    obse.c      NtSetSecurityObject (
                NtQuerySecurityObject (
                ObCheckObjectAccess (
                ObCheckCreateObjectAccess (
                ObAssignObjectSecurityDescriptor (
                ObGetObjectSecurity (
                ObReleaseObjectSecurity (
                ObValidateSecurityQuota (
                ObAssignSecurity (
                ObSetSecurityDescriptorInfo (
                ObpCheckObjectReference (
                ObpCheckTraverseAccess (
                ObpValidateAccessMask (

    obtype.c    ObCreateObjectType (
                ObEnumerateObjectsByType(
                ObGetObjectInformation(

    obdir.c     NtCreateDirectoryObject (
                NtOpenDirectoryObject (
                NtQueryDirectoryObject (
                ObpLookupDirectoryEntry (
                ObpInsertDirectoryEntry (
                ObpDeleteDirectoryEntry (
                ObpLookupObjectName (

    obdevmap.c  ObSetDeviceMap (
                ObQueryDeviceMapInformation (
                ObInheritDeviceMap (
                ObDereferenceDeviceMap (

    oblink.c    NtCreateSymbolicLinkObject (
                NtOpenSymbolicLinkObject (
                NtQuerySymbolicLinkObject (
                ObpParseSymbolicLink (
                ObpDeleteSymbolicLinkName (
                ObpCreateSymbolicLinkName (

    obclose.c   NtClose (
                NtMakeTemporaryObject (
                ObMakeTemporaryObject (

    obquery.c   NtQueryObject (
                NtSetInformationObject (
                ObGetObjectName (
                ObQueryNameString (
                ObQueryTypeName (
                ObQueryTypeInfo (
                ObQueryObjectAuditingByHandle (

    obsdata.c   ObpInitSecurityDescriptorCache (
                ObpLogSecurityDescriptor (
                ObpReferenceSecurityDescriptor (
                ObDeassignSecurity (
                ObpDereferenceSecurityDescriptor (
                ObpAcquireDescriptorCacheReadLock (
                ObpReleaseDescriptorCacheLock (

    obwait.c    NtSignalAndWaitForSingleObject (
                NtWaitForSingleObject (
                NtWaitForMultipleObjects (
                ObWaitForSingleObject (

Module Name:

    obinit.c

Global variables and who references them

    GENERIC_MAPPING ObpTypeMapping = ...

        obinit.c\ObInitSystem

    GENERIC_MAPPING ObpDirectoryMapping = ...

        obinit.c\ObInitSystem

    GENERIC_MAPPING ObpSymbolicLinkMapping = ...

        obinit.c\ObInitSystem

    extern EPROCESS_QUOTA_BLOCK PspDefaultQuotaBlock;

        obinit.c\ObInitSystem

    KMUTANT ObpInitKillMutant;

        obhandle.c\NtDuplicateObject
        obinit.c\ObInitSystem
        obinit.c\ObInitProcess
        obinit.c\ObKillProcess
        obinit.c\ObFindHandleForObject

    ULONG ObpProtectionMode;

        obinit.c\ObpGetDosDevicesProtection

    ULONG ObpAuditBaseDirectories;

        obinit.c\ObInitSystem

    ULONG ObpAuditBaseObjects

        obinit.c\ObInitSystem

    UNICODE_STRING ObpDosDevicesShortName;

        obdir.c\ObpLookupObjectName
        obinit.c\ObpCreateDosDevicesDirectory

    ULARGE_INTEGER ObpDosDevicesShortNamePrefix;

        obdir.c\ObpLookupObjectName
        obinit.c\ObpCreateDosDevicesDirectory

    ULARGE_INTEGER ObpDosDevicesShortNameRoot

        obdir.c\ObpLookupObjectName
        obinit.c\ObpCreateDosDevicesDirectory

    PDEVICE_MAP ObSystemDeviceMap

        obdevmap.c\ObSetDeviceMap
        obdevmap.c\ObQueryDeviceMapInformation
        obdevmap.c\ObInheritDeviceMap

Procedures

    BOOLEAN
    ObInitSystem (
        VOID
        )

        Called By:

        It calls:   GENERIC_MAPPING ObpTypeMapping = ...
                    GENERIC_MAPPING ObpDirectoryMapping = ...
                    GENERIC_MAPPING ObpSymbolicLinkMapping = ...
                    extern EPROCESS_QUOTA_BLOCK PspDefaultQuotaBlock;
                    KMUTANT ObpInitKillMutant;
                    ULONG ObpAuditBaseDirectories;
                    ULONG ObpAuditBaseObjects;

                    obinit.c\ObpCreateDosDevicesDirectory (
                    obref.c\ObReferenceObjectByHandle (
                    obtype.cObCreateObjectType (
                    obdir.c\NtCreateDirectoryObject (
                    obdir.c\ObpLookupDirectoryEntry (
                    obdir.c\ObpInsertDirectoryEntry (
                    oblink.c\ObpParseSymbolicLink (
                    obclose.c\NtClose (
                    obsdata.c\ObpInitSecurityDescriptorCache (

    BOOLEAN
    ObDupHandleProcedure (
        PEPROCESS Process,
        PVOID HandleTableEntry
        )

        Called By:  obinit.c\ObInitProcess

        It calls:   obhandle.c\ObpIncrPointerCount (
                    obhandle.c\ObpIncrementHandleCount (
                    obhandle.c\ObpTranslateGrantedAccessIndex (

    BOOLEAN
    ObAuditInheritedHandleProcedure (
        IN PVOID HandleTableEntry,
        IN PVOID HandleId,
        IN PVOID EnumParameter
        )

        Called By:  obinit.c\ObInitProcess

        It Calls:

    NTSTATUS
    ObInitProcess (
        PEPROCESS ParentProcess OPTIONAL,
        PEPROCESS NewProcess
        )

        Called By:

        It Calls:   obinit.c\KMUTANT ObpInitKillMutant;

                    obinit.c\ObDupHandleProcedure (
                    obinit.c\ObAuditInheritedHandleProcedure (

    VOID
    ObInitProcess2 (
        PEPROCESS NewProcess
        )

        Called By:

        It Calls:

    VOID
    ObDestroyHandleProcedure (
        IN HANDLE HandleIndex,
        IN PVOID HandleTableEntry
        )

        Called By:  obinit.c\ObKillProcess

        It Calls:

    VOID
    ObKillProcess (
        BOOLEAN AcquireLock,
        PEPROCESS Process
        )

        Called By:

        It Calls:   obinit.c\KMUTANT ObpInitKillMutant;

                    obinit.c\ObDestroyHandleProcedure (

    BOOLEAN
    ObpEnumFindHandleProcedure (
        PVOID HandleTableEntry,
        PVOID HandleId,
        PVOID EnumParameter
        )

        Called By:  obinit.c\ObFindHandleForObject

        It Calls:   obhandle.c\ObpTranslateGrantedAccessIndex (

    BOOLEAN
    ObFindHandleForObject (
        IN PEPROCESS Process,
        IN PVOID Object OPTIONAL,
        IN POBJECT_TYPE ObjectType OPTIONAL,
        IN POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL,
        OUT PHANDLE Handle
        )

        Called By:

        It Calls:   obinit.c\KMUTANT ObpInitKillMutant;

                    obinit.c\ObpEnumFindHandleProcedure (

    NTSTATUS
    ObpCreateDosDevicesDirectory (
        VOID
        )

        Called By:  obinit.c\ObInitSystem

        It Calls:   obinit.c\UNICODE_STRING ObpDosDevicesShortName;
                    obinit.c\ULARGE_INTEGER ObpDosDevicesShortNamePrefix;
                    obinit.c\ULARGE_INTEGER ObpDosDevicesShortNameRoot;

                    obinit.c\ObpGetDosDevicesProtection (
                    obinit.c\ObpFreeDosDevicesProtection (
                    obdir.c\NtCreateDirectoryObject (
                    obdevmap.c\ObSetDeviceMap (
                    oblink.c\NtCreateSymbolicLinkObject (
                    obclose.c\NtClose (

    NTSTATUS
    ObpGetDosDevicesProtection (
        PSECURITY_DESCRIPTOR SecurityDescriptor
        )

        Called By:  obinit.c\ObpCreateDosDevicesDirectory

        It Calls:   ULONG ObpProtectionMode;

    VOID
    ObpFreeDosDevicesProtection (
        PSECURITY_DESCRIPTOR SecurityDescriptor
        )

        Called By:  obinit.c\ObpCreateDosDevicesDirectory

        It Calls:

Module Name:

    obcreate.c

Global variables and who references them

    BOOLEAN ObpShowAllocAndFree;

        obcreate.c\ObpAllocateObject
        obcreate.c\ObpFreeObject

    ULONG ObpObjectsCreated;

        obcreate.c\ObpAllocateObject

    ULONG ObpObjectsWithPoolQuota;

        obcreate.c\ObpAllocateObject

    ULONG ObpObjectsWithHandleDB;

        obcreate.c\ObpAllocateObject

    ULONG ObpObjectsWithName;

        obcreate.c\ObpAllocateObject

    ULONG ObpObjectsWithCreatorInfo;

        obcreate.c\ObpAllocateObject

Procedures

    NTSTATUS
    ObCreateObject (
        IN KPROCESSOR_MODE ProbeMode,
        IN POBJECT_TYPE ObjectType,
        IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
        IN KPROCESSOR_MODE OwnershipMode,
        IN OUT PVOID ParseContext OPTIONAL,
        IN ULONG ObjectBodySize,
        IN ULONG PagedPoolCharge,
        IN ULONG NonPagedPoolCharge,
        OUT PVOID *Object
        )

        Called By:  obdir.c\NtCreateDirectoryObject
                    oblink.c\NtCreateSymbolicLinkObject

        It Calls:   obcreate.c\ObpCaptureObjectCreateInformation (
                    obcreate.c\ObpFreeObjectNameBuffer (
                    obcreate.c\ObpAllocateObject (
                    obcreate.c\ObpFreeObject (

    NTSTATUS
    ObpCaptureObjectCreateInformation (
        IN POBJECT_TYPE ObjectType OPTIONAL,
        IN KPROCESSOR_MODE ProbeMode,
        IN POBJECT_ATTRIBUTES ObjectAttributes,
        IN OUT PUNICODE_STRING CapturedObjectName,
        IN POBJECT_CREATE_INFORMATION ObjectCreateInfo,
        IN LOGICAL UseLookaside
        )

        Called By:  obcreate.c\ObCreateObject
                    obref.c\ObOpenObjectByName

        It Calls:   obcreate.c\ObpCaptureObjectName (

    NTSTATUS
    ObpCaptureObjectName (
        IN KPROCESSOR_MODE ProbeMode,
        IN PUNICODE_STRING ObjectName,
        IN OUT PUNICODE_STRING CapturedObjectName,
        IN LOGICAL UseLookaside
        )

        Called By:  obcreate.c\ObpCaptureObjectCreateInformation
                    obref.c\ObReferenceObjectByName

        It Calls:   obcreate.c\ObpAllocateObjectNameBuffer (

    PWCHAR
    ObpAllocateObjectNameBuffer (
        IN ULONG Length,
        IN LOGICAL UseLookaside,
        IN OUT PUNICODE_STRING ObjectName
        )

        Called By:  obcreate.c\ObpCaptureObjectName

        It Calls:

    VOID
    FASTCALL
    ObpFreeObjectNameBuffer (
        OUT PUNICODE_STRING ObjectName
        )

        Called By:  obcreate.c\ObCreateObject
                    obref.c\ObOpenObjectByName
                    obref.c\ObReferenceObjectByName

        It Calls:

    NTKERNELAPI
    VOID
    ObDeleteCapturedInsertInfo (
        IN PVOID Object
        )

        Called By:

        It Calls:

    NTSTATUS
    ObpAllocateObject (
        IN POBJECT_CREATE_INFORMATION ObjectCreateInfo,
        IN KPROCESSOR_MODE OwnershipMode,
        IN POBJECT_TYPE ObjectType OPTIONAL,
        IN PUNICODE_STRING ObjectName,
        IN ULONG ObjectBodySize,
        OUT POBJECT_HEADER *ReturnedObjectHeader
        )

        Called By:  obcreate.c\ObCreateObject
                    obtype.c\ObCreateObjectType

        It Calls:   obcreate.c\BOOLEAN ObpShowAllocAndFree;
                    obcreate.c\ULONG ObpObjectsCreated;
                    obcreate.c\ULONG ObpObjectsWithPoolQuota;
                    obcreate.c\ULONG ObpObjectsWithHandleDB;
                    obcreate.c\ULONG ObpObjectsWithName;
                    obcreate.c\ULONG ObpObjectsWithCreatorInfo;

    VOID
    FASTCALL
    ObpFreeObject (
        IN PVOID Object
        )

        Called By:  obcreate.c\ObCreateObject
                    obref.c\ObRemoveObjectRoutine

        It Calls:   obcreate.c\BOOLEAN ObpShowAllocAndFree;

    VOID
    FASTCALL
    ObFreeObjectCreateInfoBuffer (
        IN POBJECT_CREATE_INFORMATION ObjectCreateInfo
        )

        Called By:

        It Calls:


Module Name:

    obhandle.c

Global variables and who references them

    extern KMUTANT ObpInitKillMutant;

Procedures

    LONG
    FASTCALL
    ObpIncrPointerCount (
        IN POBJECT_HEADER ObjectHeader
        )

        Called By:  obdir.c\ObpLookupObjectName
                    obhandle.c\ObpCreateHandle
                    obhandle.c\ObpCreateUnnamedHandle
                    obinit.c\ObDupHandleProcedure
                    obref.c\ObReferenceObjectByHandle
                    obref.c\ObfReferenceObject
                    obref.c\ObReferenceObjectByPointer
                    obwait.c\NtWaitForMultipleObjects

        It Calls:

    LONG
    FASTCALL
    ObpDecrPointerCount (
        IN POBJECT_HEADER ObjectHeader
        )

        Called By:  obhandle.c\ObpCreateHandle
                    obhandle.c\ObpCreateUnnamedHandle

        It Calls:

    BOOLEAN
    FASTCALL
    ObpDecrPointerCountWithResult (
        IN POBJECT_HEADER ObjectHeader
        )

        Called By:  obref.c\ObfDereferenceObject

        It Calls:

    VOID
    FASTCALL
    ObpIncrHandleCount (
        IN POBJECT_HEADER ObjectHeader
        )

        Called By:  obhandle.c\ObpIncrementHandleCount
                    obhandle.c\ObpIncrementUnnamedHandleCount

        It Calls:

    BOOLEAN
    FASTCALL
    ObpDecrHandleCount (
        IN POBJECT_HEADER ObjectHeader
        )

        Called By:  obhandle.c\ObpDecrementHandleCount

        It Calls:

    POBJECT_HANDLE_COUNT_ENTRY
    ObpInsertHandleCount (
        POBJECT_HEADER ObjectHeader
        )

        Called By:  obhandle.c\ObpIncrementHandleDataBase

        It Calls:

    NTSTATUS
    ObpIncrementHandleDataBase (
        IN POBJECT_HEADER ObjectHeader,
        IN PEPROCESS Process,
        OUT PULONG NewProcessHandleCount
        )

        Called By:  obhandle.c\ObpIncrementHandleCount
                    obhandle.c\ObpIncrementUnnamedHandleCount

        It Calls:   obhandle.c\ObpInsertHandleCount (

    NTSTATUS
    ObpIncrementHandleCount (
        OB_OPEN_REASON OpenReason,
        PEPROCESS Process,
        PVOID Object,
        POBJECT_TYPE ObjectType,
        PACCESS_STATE AccessState OPTIONAL,
        KPROCESSOR_MODE AccessMode,
        ULONG Attributes
        )

        Called By:  obhandle.c\ObpCreateHandle
                    obhandle.c\NtDuplicateObject
                    obinit.c\ObDupHandleProcedure

        It Calls:   obhandle.c\ObpIncrHandleCount (
                    obhandle.c\ObpIncrementHandleDataBase (
                    obhandle.c\ObpChargeQuotaForObject (
                    obse.c\ObCheckObjectAccess (

    NTSTATUS
    ObpIncrementUnnamedHandleCount (
        PACCESS_MASK DesiredAccess,
        PEPROCESS Process,
        PVOID Object,
        POBJECT_TYPE ObjectType,
        KPROCESSOR_MODE AccessMode,
        ULONG Attributes
        )

        Called By:  obhandle.c\ObpCreateUnnamedHandle

        It Calls:   obhandle.c\ObpIncrHandleCount (
                    obhandle.c\ObpIncrementHandleDataBase (
                    obhandle.c\ObpChargeQuotaForObject (

    NTSTATUS
    ObpChargeQuotaForObject (
        IN POBJECT_HEADER ObjectHeader,
        IN POBJECT_TYPE ObjectType,
        OUT PBOOLEAN NewObject
        )

        Called By:  obhandle.c\ObpIncrementHandleCount
                    obhandle.c\ObpIncrementUnnamedHandleCount

        It Calls:

    VOID
    ObpDecrementHandleCount (
        PEPROCESS Process,
        POBJECT_HEADER ObjectHeader,
        POBJECT_TYPE ObjectType,
        ACCESS_MASK GrantedAccess
        )

        Called By:  obclose.c\NtClose
                    obhandle.c\ObpCreateHandle
                    obhandle.c\ObpCreateUnnamedHandle
                    obhandle.c\NtDuplicateObject

        It Calls:   obhandle.c\ObpDecrHandleCount (
                    obref.c\ObpDeleteNameCheck (

    NTSTATUS
    ObpCreateHandle (
        IN OB_OPEN_REASON OpenReason,
        IN PVOID Object,
        IN POBJECT_TYPE ExpectedObjectType OPTIONAL,
        IN PACCESS_STATE AccessState,
        IN ULONG ObjectPointerBias OPTIONAL,
        IN ULONG Attributes,
        IN BOOLEAN DirectoryLocked,
        IN KPROCESSOR_MODE AccessMode,
        OUT PVOID *ReferencedNewObject OPTIONAL,
        OUT PHANDLE Handle
        )

        Called By:  obinsert.c\ObInsertObject
                    obref.c\ObOpenObjectByName
                    obref.c\ObOpenObjectByPointer

        It Calls:   obhandle.c\ObpIncrPointerCount (
                    obhandle.c\ObpDecrPointerCount (
                    obhandle.c\ObpIncrementHandleCount (
                    obhandle.c\ObpDecrementHandleCount (
                    obhandle.c\ObpComputeGrantedAccessIndex (

    NTSTATUS
    ObpCreateUnnamedHandle (
        IN PVOID Object,
        IN ACCESS_MASK DesiredAccess,
        IN ULONG ObjectPointerBias OPTIONAL,
        IN ULONG Attributes,
        IN KPROCESSOR_MODE AccessMode,
        OUT PVOID *ReferencedNewObject OPTIONAL,
        OUT PHANDLE Handle
        )

        Called By:  obinsert.c\ObInsertObject

        It Calls:   obhandle.c\ObpIncrPointerCount (
                    obhandle.c\ObpDecrPointerCount (
                    obhandle.c\ObpIncrementUnnamedHandleCount (
                    obhandle.c\ObpDecrementHandleCount (
                    obhandle.c\ObpComputeGrantedAccessIndex (

    NTSTATUS
    NtDuplicateObject (
        IN HANDLE SourceProcessHandle,
        IN HANDLE SourceHandle,
        IN HANDLE TargetProcessHandle OPTIONAL,
        OUT PHANDLE TargetHandle OPTIONAL,
        IN ACCESS_MASK DesiredAccess,
        IN ULONG HandleAttributes,
        IN ULONG Options
        )

        Called By:

        It Calls:   obinit.c\KMUTANT ObpInitKillMutant;

                    obhandle.c\ObpIncrementHandleCount (
                    obhandle.c\ObpDecrementHandleCount (
                    obhandle.c\ObpValidateDesiredAccess (
                    obhandle.c\ObpComputeGrantedAccessIndex (
                    obref.c\ObReferenceObjectByHandle (
                    obref.c\ObDereferenceObject (
                    obclose.c\NtClose (

    NTSTATUS
    ObpValidateDesiredAccess (
        IN ACCESS_MASK DesiredAccess
        )

        Called By:  obhandle.c\NtDuplicateObject

        It Calls:

    NTSTATUS
    ObpCaptureHandleInformation (
        IN OUT PSYSTEM_HANDLE_TABLE_ENTRY_INFO *HandleEntryInfo,
        IN HANDLE UniqueProcessId,
        IN PVOID HandleTableEntry,
        IN HANDLE HandleIndex,
        IN ULONG Length,
        IN OUT PULONG RequiredLength
        )

        Called By:  obhandle.c\ObGetHandleInformation

        It Calls:   obhandle.c\ObpTranslateGrantedAccessIndex (

    NTSTATUS
    ObGetHandleInformation (
        OUT PSYSTEM_HANDLE_INFORMATION HandleInformation,
        IN ULONG Length,
        OUT PULONG ReturnLength OPTIONAL
        )

        Called By:

        It Calls:   obhandle.c\ObpCaptureHandleInformation (

Global variables and who references them

    ULONG ObpXXX1;

        obhandle.c\ObpComputeGrantedAccessIndex

    ULONG ObpXXX2;

        obhandle.c\ObpComputeGrantedAccessIndex

    ULONG ObpXXX3;

        obhandle.c\ObpTranslateGrantedAccessIndex

Procedures

    USHORT
    ObpComputeGrantedAccessIndex (
        ACCESS_MASK GrantedAccess
        )

        Called By:  obhandle.c\ObpCreateHandle
                    obhandle.c\ObpCreateUnnamedHandle
                    obhandle.c\NtDuplicateObject

        It Calls:   obhandle.c\ULONG ObpXXX1;
                    obhandle.c\ULONG ObpXXX2;

    ACCESS_MASK
    ObpTranslateGrantedAccessIndex (
        USHORT GrantedAccessIndex
        )

        Called By:  obclose.c\NtClose
                    obhandle.c\ObpCaptureHandleInformation
                    obinit.c\ObDupHandleProcedure
                    obinit.c\ObpEnumFindHandleProcedure
                    obref.c\ObReferenceObjectByHandle
                    obwait.c\NtWaitForMultipleObjects

        It Calls:   obhandle.c\ULONG ObpXXX3;


Module Name:

    obinsert.c

Procedures

    NTSTATUS
    ObInsertObject (
        IN PVOID Object,
        IN PACCESS_STATE AccessState OPTIONAL,
        IN ACCESS_MASK DesiredAccess OPTIONAL,
        IN ULONG ObjectPointerBias,
        OUT PVOID *NewObject OPTIONAL,
        OUT PHANDLE Handle
        )

        Called By:  obdir.c\NtCreateDirectoryObject
                    oblink.c\NtCreateSymbolicLinkObject

        It Calls:   obhandle.c\ObpCreateHandle (
                    obhandle.c\ObpCreateUnnamedHandle (
                    obref.c\ObpDeleteNameCheck (
                    obref.c\ObDereferenceObject (
                    obse.c\ObGetObjectSecurity (
                    obse.c\ObReleaseObjectSecurity (
                    obse.c\ObAssignSecurity (
                    obse.c\ObpValidateAccessMask (
                    obdir.c\ObpDeleteDirectoryEntry (
                    obdir.c\ObpLookupObjectName (
                    oblink.c\ObpCreateSymbolicLinkName (


Module Name:

    obref.c

Global variables and who references them

    BOOLEAN ObpRemoveQueueActive;

        obref.c\ObfDereferenceObject
        obref.c\ObpProcessRemoveObjectQueue

Procedures

    ULONG
    ObGetObjectPointerCount (
        IN PVOID Object
        )

        Called By:

        It Calls:

    NTSTATUS
    ObOpenObjectByName (
        IN POBJECT_ATTRIBUTES ObjectAttributes,
        IN POBJECT_TYPE ObjectType OPTIONAL,
        IN KPROCESSOR_MODE AccessMode,
        IN OUT PACCESS_STATE AccessState OPTIONAL,
        IN ACCESS_MASK DesiredAccess OPTIONAL,
        IN OUT PVOID ParseContext OPTIONAL,
        OUT PHANDLE Handle
        )

        Called By:  obdir.c\NtOpenDirectoryObject
                    oblink.c\NtOpenSymbolicLinkObject

        It Calls:   obcreate.c\ObpCaptureObjectCreateInformation (
                    obcreate.c\ObpFreeObjectNameBuffer (
                    obhandle.c\ObpCreateHandle (
                    obref.c\ObDereferenceObject (
                    obse.c\ObpValidateAccessMask (
                    obdir.c\ObpLookupObjectName (

    NTSTATUS
    ObOpenObjectByPointer (
        IN PVOID Object,
        IN ULONG HandleAttributes,
        IN PACCESS_STATE PassedAccessState OPTIONAL,
        IN ACCESS_MASK DesiredAccess,
        IN POBJECT_TYPE ObjectType OPTIONAL,
        IN KPROCESSOR_MODE AccessMode,
        OUT PHANDLE Handle
        )

        Called By:

        It Calls:   obhandle.c\ObpCreateHandle (
                    obref.c\ObReferenceObjectByPointer (
                    obref.c\ObDereferenceObject (

    NTSTATUS
    ObReferenceObjectByHandle (
        IN HANDLE Handle,
        IN ACCESS_MASK DesiredAccess,
        IN POBJECT_TYPE ObjectType OPTIONAL,
        IN KPROCESSOR_MODE AccessMode,
        OUT PVOID *Object,
        OUT POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL
        )

        Called By:  obclose.c\NtMakeTemporaryObject
                    obdevmap.c\ObSetDeviceMap
                    obdir.c\ObpLookupObjectName
                    obdir.c\NtQueryDirectoryObject
                    obhandle.c\NtDuplicateObject
                    obinit.c\ObInitSystem
                    oblink.c\NtQuerySymbolicLinkObject
                    obquery.c\NtQueryObject
                    obse.c\NtSetSecurityObject
                    obse.c\NtQuerySecurityObject
                    obwait.c\NtSignalAndWaitForSingleObject
                    obwait.c\NtWaitForSingleObject
                    obwait.c\ObWaitForSingleObject

        It Calls:   obhandle.c\ObpIncrPointerCount (
                    obhandle.c\ObpTranslateGrantedAccessIndex (

    NTSTATUS
    ObReferenceObjectByName (
        IN PUNICODE_STRING ObjectName,
        IN ULONG Attributes,
        IN PACCESS_STATE AccessState OPTIONAL,
        IN ACCESS_MASK DesiredAccess OPTIONAL,
        IN POBJECT_TYPE ObjectType,
        IN KPROCESSOR_MODE AccessMode,
        IN OUT PVOID ParseContext OPTIONAL,
        OUT PVOID *Object
        )

        Called By:

        It Calls:   obcreate.c\ObpCaptureObjectName (
                    obcreate.c\ObpFreeObjectNameBuffer (
                    obse.c\ObpCheckObjectReference (
                    obdir.c\ObpLookupObjectName (


    LONG
    FASTCALL
    ObfReferenceObject (
        IN PVOID Object
        )

        Called By:

        It Calls:   obhandle.c\ObpIncrPointerCount (

    NTSTATUS
    ObReferenceObjectByPointer (
        IN PVOID Object,
        IN ACCESS_MASK DesiredAccess,
        IN POBJECT_TYPE ObjectType,
        IN KPROCESSOR_MODE AccessMode
        )

        Called By:  obdir.c\ObpLookupObjectName
                    oblink.c\ObpParseSymbolicLink
                    obref.c\ObOpenObjectByPointer

        It Calls:   obhandle.c\ObpIncrPointerCount (

    LONG
    FASTCALL
    ObfDereferenceObject (
        IN PVOID Object
        )

        Called By:  obref.c\ObDereferenceObject

        It Calls:   obref.c\BOOLEAN ObpRemoveQueueActive;

                    obhandle.c\ObpDecrPointerCountWithResult (
                    obref.c\ObpProcessRemoveObjectQueue (
                    obref.c\ObpRemoveObjectRoutine (

    VOID
    ObpProcessRemoveObjectQueue (
        PVOID Parameter
        )

        Called By:  obref.c\ObfDereferenceObject

        It Calls:   obref.c\BOOLEAN ObpRemoveQueueActive;

                    obref.c\ObpRemoveObjectRoutine (

    VOID
    ObpRemoveObjectRoutine (
        PVOID Object
        )

        Called By:  obref.c\ObfDereferenceObject
                    obref.c\ObpProcessRemoveObjectQueue

        It Calls:

    VOID
    ObpDeleteNameCheck (
        IN PVOID Object,
        IN BOOLEAN TypeMutexHeld
        )

        Called By:  obclose.c\ObMakeTemporaryObject
                    obhandle.c\ObpDecrementHandleCount
                    obinsert.c\ObInsertObject

        It Calls:   obref.c\ObDereferenceObject (
                    obdir.c\ObpLookupDirectoryEntry (
                    obdir.c\ObpDeleteDirectoryEntry (
                    oblink.c\ObpDeleteSymbolicLinkName (

    LONG
    ObDereferenceObject (
        IN PVOID Object
        )

        Called By:  obclose.c\NtClose
                    obclose.c\NtMakeTemporaryObject
                    obdevmap.c\ObSetDeviceMap
                    obdevmap.c\ObDereferenceDeviceMap
                    obdir.c\ObpLookupObjectName
                    obdir.c\NtQueryDirectoryObject
                    obhandle.c\NtDuplicateObject
                    obinsert.c\ObInsertObject
                    oblink.c\ObpProcessDosDeviceSymbolicLink
                    oblink.c\NtCreateSymbolicLinkObject
                    oblink.c\NtQuerySymbolicLinkObject
                    obquery.c\NtQueryObject
                    obref.c\ObOpenObjectByName
                    obref.c\ObOpenObjectByPointer
                    obref.c\ObpDeleteNameCheck
                    obse.c\NtSetSecurityObject
                    obse.c\NtQuerySecurityObject
                    obwait.c\NtSignalAndForSingleObject
                    obwait.c\NtWaitForSingleObject
                    obwait.c\NtWaitForMultipleObjects
                    obwait.c\ObWaitForSingleObject

        It Calls:   obref.c\ObfDereferenceObject (


Module Name:

    obse.c

Procedures

    NTSTATUS
    NtSetSecurityObject (
        IN HANDLE Handle,
        IN SECURITY_INFORMATION SecurityInformation,
        IN PSECURITY_DESCRIPTOR SecurityDescriptor
        )

        Called By:

        It Calls:   obref.c\ObReferenceObjectByHandle (
                    obref.c\ObDereferenceObject (

    NTSTATUS
    NtQuerySecurityObject (
        IN HANDLE Handle,
        IN SECURITY_INFORMATION SecurityInformation,
        OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
        IN ULONG Length,
        OUT PULONG LengthNeeded
        )

        Called By:

        It Calls:   obref.c\ObReferenceObjectByHandle (
                    obref.c\ObDereferenceObject (

    BOOLEAN
    ObCheckObjectAccess (
        IN PVOID Object,
        IN OUT PACCESS_STATE AccessState,
        IN BOOLEAN TypeMutexLocked,
        IN KPROCESSOR_MODE AccessMode,
        OUT PNTSTATUS AccessStatus
        )

        Called By:  obhandle.c\ObpIncrementHandleCount

        It Calls:   obse.c\ObGetObjectSecurity (
                    obse.c\ObReleaseObjectSecurity (

    BOOLEAN
    ObpCheckObjectReference (
        IN PVOID Object,
        IN OUT PACCESS_STATE AccessState,
        IN BOOLEAN TypeMutexLocked,
        IN KPROCESSOR_MODE AccessMode,
        OUT PNTSTATUS AccessStatus
        )

        Called By:  obref.c\ObReferenceObjectByName

        It Calls:   obse.c\ObGetObjectSecurity (
                    obse.c\ObReleaseObjectSecurity (

    BOOLEAN
    ObpCheckTraverseAccess (
        IN PVOID DirectoryObject,
        IN ACCESS_MASK TraverseAccess,
        IN PACCESS_STATE AccessState OPTIONAL,
        IN BOOLEAN TypeMutexLocked,
        IN KPROCESSOR_MODE PreviousMode,
        OUT PNTSTATUS AccessStatus
        )

        Called By:  obdir.c\ObpLookupObjectName

        It Calls:   obse.c\ObGetObjectSecurity (
                    obse.c\ObReleaseObjectSecurity (

    BOOLEAN
    ObCheckCreateObjectAccess (
        IN PVOID DirectoryObject,
        IN ACCESS_MASK CreateAccess,
        IN PACCESS_STATE AccessState,
        IN PUNICODE_STRING ComponentName,
        IN BOOLEAN TypeMutexLocked,
        IN KPROCESSOR_MODE PreviousMode,
        OUT PNTSTATUS AccessStatus
        )

        Called By:  obdir.c\ObpLookupObjectName

        It Calls:   obse.c\ObGetObjectSecurity (
                    obse.c\ObReleaseObjectSecurity (

    NTSTATUS
    ObAssignObjectSecurityDescriptor (
        IN PVOID Object,
        IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
        IN POOL_TYPE PoolType
        )

        Called By:

        It Calls:   obsdata.c\ObpLogSecurityDescriptor (

    NTSTATUS
    ObGetObjectSecurity (
        IN PVOID Object,
        OUT PSECURITY_DESCRIPTOR *SecurityDescriptor,
        OUT PBOOLEAN MemoryAllocated
        )

        Called By:  obinsert.c\ObInsertObject
                    oblink.c\ObpProcessDosDeviceSymbolicLink
                    obse.c\ObCheckObjectAccess
                    obse.c\ObpCheckObjectReference
                    obse.c\ObpCheckTraverseAccess
                    obse.c\ObCheckCreateObjectAccess

        It Calls:   obsdata.c\ObpReferenceSecurityDescriptor (

    VOID
    ObReleaseObjectSecurity (
        IN PSECURITY_DESCRIPTOR SecurityDescriptor,
        IN BOOLEAN MemoryAllocated
        )

        Called By:  obinsert.c\ObInsertObject
                    obse.c\ObCheckObjectAccess
                    obse.c\ObpCheckObjectReference
                    obse.c\ObpCheckTraverseAccess
                    obse.c\ObCheckCreateObjectAccess

        It Calls:   obsdata.c\ObpDereferenceSecurityDescriptor (

    NTSTATUS
    ObValidateSecurityQuota (
        IN PVOID Object,
        IN ULONG NewSize
        )

        Called By:

        It Calls:

    NTSTATUS
    ObAssignSecurity (
        IN PACCESS_STATE AccessState,
        IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
        IN PVOID Object,
        IN POBJECT_TYPE ObjectType
        )

        Called By:  obinsert.c\ObInsertObject

        It Calls:

    NTSTATUS
    ObSetSecurityDescriptorInfo (
        IN PVOID Object,
        IN PSECURITY_INFORMATION SecurityInformation,
        IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
        IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
        IN POOL_TYPE PoolType,
        IN PGENERIC_MAPPING GenericMapping
        )

        Called By:

        It Calls:   obsdata.c\ObpLogSecurityDescriptor (
                    obsdata.c\ObpDereferenceSecurityDescriptor (
                    obsdata.c\ObpAcquireDescriptorCacheReadLock (
                    obsdata.c\ObpReleaseDescriptorCacheLock (

    NTSTATUS
    ObpValidateAccessMask (
        PACCESS_STATE AccessState
        )

        Called By:  obinsert.c\ObInsertObject
                    obref.c\ObOpenObjectByName

        It Calls:


Module Name:

    obtype.c

Procedures

    NTSTATUS
    ObCreateObjectType (
        IN PUNICODE_STRING TypeName,
        IN POBJECT_TYPE_INITIALIZER ObjectTypeInitializer,
        IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
        OUT POBJECT_TYPE *ObjectType
        )

        Called By:  obinit.c\ObInitSystem

        It Calls:   obcreate.c\ObpAllocateObject (
                    obdir.c\ObpLookupDirectoryEntry (
                    obdir.c\ObpInsertDirectoryEntry (

    NTSTATUS
    ObEnumerateObjectsByType(
        IN POBJECT_TYPE ObjectType,
        IN OB_ENUM_OBJECT_TYPE_ROUTINE EnumerationRoutine,
        IN PVOID Parameter
        )

        Called By:

        It Calls:

    NTSTATUS
    ObGetObjectInformation(
        IN PCHAR UserModeBufferAddress,
        OUT PSYSTEM_OBJECTTYPE_INFORMATION ObjectInformation,
        IN ULONG Length,
        OUT PULONG ReturnLength OPTIONAL
        )

        Called By:

        It Calls:   obquery.c\ObQueryNameString (


Module Name:

    obdir.c

Procedures

    NTSTATUS
    NtCreateDirectoryObject (
        OUT PHANDLE DirectoryHandle,
        IN ACCESS_MASK DesiredAccess,
        IN POBJECT_ATTRIBUTES ObjectAttributes
        )

        Called By:  obinit.c\ObInitSystem
                    obinit.c\ObpCreateDosDevicesDirectory

        It Calls:   obcreate.c\ObCreateObject (
                    obinsert.c\ObInsertObject (

    NTSTATUS
    NtOpenDirectoryObject (
        OUT PHANDLE DirectoryHandle,
        IN ACCESS_MASK DesiredAccess,
        IN POBJECT_ATTRIBUTES ObjectAttributes
        )

        Called By:

        It Calls:   obref.c\ObOpenObjectByName (

    PVOID
    ObpLookupDirectoryEntry (
        IN POBJECT_DIRECTORY Directory,
        IN PUNICODE_STRING Name,
        IN ULONG Attributes
        )

        Called By:  obdir.c\ObpLookupObjectName
                    obinit.c\ObInitSystem
                    oblink.c\ObpProcessDosDeviceSymbolicLink
                    obref.c\ObpDeleteNameCheck
                    obtype.c\ObCreateObjectType

        It Calls:

    BOOLEAN
    ObpInsertDirectoryEntry (
        IN POBJECT_DIRECTORY Directory,
        IN PVOID Object
        )

        Called By:  obdir.c\ObpLookupObjectName
                    obinit.c\ObInitSystem
                    obtype.c\ObCreateObjectType

        It Calls:   obinit.c\ObInitSystem (

    BOOLEAN
    ObpDeleteDirectoryEntry (
        IN POBJECT_DIRECTORY Directory
        )

        Called By:  obinsert.c\ObInsertObject
                    obref.c\ObpDeleteNameCheck

        It Calls:

    NTSTATUS
    ObpLookupObjectName (
        IN HANDLE RootDirectoryHandle,
        IN PUNICODE_STRING ObjectName,
        IN ULONG Attributes,
        IN POBJECT_TYPE ObjectType,
        IN KPROCESSOR_MODE AccessMode,
        IN PVOID ParseContext OPTIONAL,
        IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
        IN PVOID InsertObject OPTIONAL,
        IN OUT PACCESS_STATE AccessState,
        OUT PBOOLEAN DirectoryLocked,
        OUT PVOID *FoundObject
        )

        Called By:  obinsert.c\ObInsertObject
                    obref.c\ObOpenObjectByName
                    obref.c\ObReferenceObjectByName

        It Calls:   obinit.c\UNICODE_STRING ObpDosDevicesShortName;
                    obinit.c\ULARGE_INTEGER ObpDosDevicesShortNamePrefix;
                    obinit.c\ULARGE_INTEGER ObpDosDevicesShortNameRoot

                    obhandle.c\ObpIncrPointerCount (
                    obref.c\ObReferenceObjectByHandle (
                    obref.c\ObReferenceObjectByPointer (
                    obref.c\ObDereferenceObject (
                    obse.c\ObpCheckTraverseAccess (
                    obse.c\ObCheckCreateObjectAccess (
                    obdir.c\ObpLookupDirectoryEntry (
                    obdir.c\ObpInsertDirectoryEntry (

    NTSTATUS
    NtQueryDirectoryObject (
        IN HANDLE DirectoryHandle,
        OUT PVOID Buffer,
        IN ULONG Length,
        IN BOOLEAN ReturnSingleEntry,
        IN BOOLEAN RestartScan,
        IN OUT PULONG Context,
        OUT PULONG ReturnLength OPTIONAL
        )

        Called By:

        It Calls:   obref.c\ObReferenceObjectByHandle (
                    obref.c\ObDereferenceObject (


Module Name:

    obdevmap.c

Procedures

    NTSTATUS
    ObSetDeviceMap (
        IN PEPROCESS TargetProcess,
        IN HANDLE DirectoryHandle
        )

        Called By:  obinit.c\ObpCreateDosDevicesDirectory

        It Calls:   obinit.c\PDEVICE_MAP ObSystemDeviceMap

                    obref.c\ObReferenceObjectByHandle (
                    obref.c\ObDereferenceObject (

    NTSTATUS
    ObQueryDeviceMapInformation (
        IN PEPROCESS TargetProcess,
        OUT PPROCESS_DEVICEMAP_INFORMATION DeviceMapInformation
        )

        Called By:

        It Calls:   obinit.c\PDEVICE_MAP ObSystemDeviceMap

    VOID
    ObInheritDeviceMap (
        IN PEPROCESS NewProcess,
        IN PEPROCESS ParentProcess
        )

        Called By:

        It Calls:   obinit.c\PDEVICE_MAP ObSystemDeviceMap

    VOID
    ObDereferenceDeviceMap (
        IN PEPROCESS Process
        )

        Called By:

        It Calls:   obref.c\ObDereferenceObject (


Module Name:

    oblink.c

Global variables and who references them

    extern POBJECT_TYPE IoDeviceObjectType;

        oblink.c\ObpProcessDosDeviceSymbolicLink

Procedures

    NTSTATUS
    ObpParseSymbolicLink (
        IN PVOID ParseObject,
        IN PVOID ObjectType,
        IN PACCESS_STATE AccessState,
        IN KPROCESSOR_MODE AccessMode,
        IN ULONG Attributes,
        IN OUT PUNICODE_STRING CompleteName,
        IN OUT PUNICODE_STRING RemainingName,
        IN OUT PVOID Context OPTIONAL,
        IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
        OUT PVOID *Object
        )

        Called By:  obinit.c\ObInitSystem

        It Calls:   obref.c\ObReferenceObjectByPointer (

    VOID
    ObpProcessDosDeviceSymbolicLink (
        POBJECT_SYMBOLIC_LINK SymbolicLink,
        ULONG Action
        )

        Called By:  oblink.c\ObpDeleteSymbolicLinkName
                    oblink.c\ObpCreateSymbolicLinkName

        It Calls:   oblink.c\extern POBJECT_TYPE IoDeviceObjectType;

                    obref.c\ObDereferenceObject (
                    obse.c\ObGetObjectSecurity (
                    obdir.c\ObpLookupDirectoryEntry (

    VOID
    ObpDeleteSymbolicLinkName (
        POBJECT_SYMBOLIC_LINK SymbolicLink
        )

        Called By:  obref.c\ObpDeleteNameCheck

        It Calls:   oblink.c\ObpProcessDosDeviceSymbolicLink (

    VOID
    ObpCreateSymbolicLinkName (
        POBJECT_SYMBOLIC_LINK SymbolicLink
        )

        Called By:  obinsert.c\ObInsertObject

        It Calls:   oblink.c\ObpProcessDosDeviceSymbolicLink (

    NTSTATUS
    NtCreateSymbolicLinkObject (
        OUT PHANDLE LinkHandle,
        IN ACCESS_MASK DesiredAccess,
        IN POBJECT_ATTRIBUTES ObjectAttributes,
        IN PUNICODE_STRING LinkTarget
        )

        Called By:  obinit.c\ObpCreateDosDevicesDirectory

        It Calls:   obcreate.c\ObCreateObject (
                    obinset.c\ObInsertObject (
                    obref.c\ObDereferenceObject (

    NTSTATUS
    NtOpenSymbolicLinkObject (
        OUT PHANDLE LinkHandle,
        IN ACCESS_MASK DesiredAccess,
        IN POBJECT_ATTRIBUTES ObjectAttributes
        )

        Called By:

        It Calls:   obref.c\ObOpenObjectByName (

    NTSTATUS
    NtQuerySymbolicLinkObject (
        IN HANDLE LinkHandle,
        IN OUT PUNICODE_STRING LinkTarget,
        OUT PULONG ReturnedLength OPTIONAL
        )

        Called By:

        It Calls:   obref.c\ObReferenceObjectByHandle (
                    obref.c\ObDereferenceObject (


Module Name:

    obclose.c

Global variables and who references them

    extern BOOLEAN SepAdtAuditingEnabled;

        obclose.c\NtClose

Procedures

    NTSTATUS
    NtClose (
        IN HANDLE Handle
        )

        Called By:  obhandle.c\NtDuplicateObject
                    obinit.c\ObInitSystem
                    obinit.c\ObpCreateDosDevicesDirectory

        It Calls:   obclose.c\extern BOOLEAN SepAdtAuditingEnabled;

                    obhandle.c\ObpDecrementHandleCount (
                    obhandle.c\ObpTranslateGrantedAccessIndex (
                    obref.c\ObDereferenceObject (

    NTSTATUS
    NtMakeTemporaryObject (
        IN HANDLE Handle
        )

        Called By:

        It Calls:   obref.c\ObReferenceObjectByHandle (
                    obref.c\ObDereferenceObject (
                    obclose.c\ObMakeTemporaryObject (

    VOID
    ObMakeTemporaryObject (
        IN PVOID Object
        )

        Called By:  obclose.c\NtMakeTemporaryObject

        It Calls:   obref.c\ObpDeleteNameCheck (


Module Name:

    obquery.c

Procedures

    NTSTATUS
    NtQueryObject (
        IN HANDLE Handle,
        IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
        OUT PVOID ObjectInformation,
        IN ULONG ObjectInformationLength,
        OUT PULONG ReturnLength OPTIONAL
        )

        Called By:

        It Calls:   obref.c\ObReferenceObjectByHandle (
                    obref.c\ObDereferenceObject (
                    obquery.c\ObQueryNameString (
                    obquery.c\ObQueryTypeInfo (

    PUNICODE_STRING
    ObGetObjectName (
        IN PVOID Object
        )

        Called By:

        It Calls:

    NTSTATUS
    ObQueryNameString (
        IN PVOID Object,
        OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
        IN ULONG Length,
        OUT PULONG ReturnLength
        )

        Called By:  obquery.c\NtQueryObject
                    obtype.c\ObGetObjectInformation

        It Calls:

    NTSTATUS
    ObQueryTypeName (
        IN PVOID Object,
        PUNICODE_STRING ObjectTypeName,
        IN ULONG Length,
        OUT PULONG ReturnLength
        )

        Called By:  obtype.c\ObGetObjectInformation

        It Calls:

    NTSTATUS
    ObQueryTypeInfo (
        IN POBJECT_TYPE ObjectType,
        OUT POBJECT_TYPE_INFORMATION ObjectTypeInfo,
        IN ULONG Length,
        OUT PULONG ReturnLength
        )

        Called By:  obquery.c\NtQueryObject

        It Calls:

    NTSTATUS
    ObQueryObjectAuditingByHandle (
        IN HANDLE Handle,
        OUT PBOOLEAN GenerateOnClose
        )

        Called By:

        It Calls:

    BOOLEAN
    ObpSetHandleAttributes (
        IN OUT PVOID TableEntry,
        IN ULONG Parameter
        )

        Called By:  obquery.c\NtSetInformationObject

        It Calls:

    NTSTATUS
    NTAPI
    NtSetInformationObject (
        IN HANDLE Handle,
        IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
        IN PVOID ObjectInformation,
        IN ULONG ObjectInformationLength
        )

        Called By:  obquery.c\ObpSetHandleAttributes (

        It Calls:


Module Name:

    obsdata.c

Global variables and who references them

    ULONG ObsDebugFlags = 0;

    ULONG ObsTotalCacheEntries = 0;

    PLIST_ENTRY *ObsSecurityDescriptorCache = NULL;

    ERESOURCE ObsSecurityDescriptorCacheLock;

Procedures

    NTSTATUS
    ObpInitSecurityDescriptorCache (
        VOID
        )

        Called By:  obinit.c\ObInitSystem

        It Calls:

    ULONG
    ObpHashSecurityDescriptor (
        PSECURITY_DESCRIPTOR SecurityDescriptor
        )

        Called By:  obsdata.c\ObpLogSecurityDescriptor

        It Calls:   obsdata.c\ObpHashBuffer (

    ULONG
    ObpHashBuffer (
        PVOID Data,
        ULONG Length
        )

        Called By:  obsdata.c\ObpHashSecurityDescriptor

        It Calls:

    NTSTATUS
    ObpLogSecurityDescriptor (
        IN PSECURITY_DESCRIPTOR InputSecurityDescriptor,
        OUT PSECURITY_DESCRIPTOR *OutputSecurityDescriptor
        )

        Called By:  obse.c\ObAssignObjectSecurityDescriptor
                    obse.c\ObSetSecurityDescriptorInfo

        It Calls:   obsdata.c\ObpHashSecurityDescriptor (
                    obsdata.c\ObpCreateCacheEntry (
                    obsdata.c\ObpCompareSecurityDescriptors (
                    obsdata.c\ObpAcquireDescriptorCacheWriteLock (
                    obsdata.c\ObpReleaseDescriptorCacheLock (

    PSECURITY_DESCRIPTOR_HEADER
    ObpCreateCacheEntry (
        PSECURITY_DESCRIPTOR InputSecurityDescriptor,
        ULONG FullHash
        )

        Called By:  obsdata.c\ObpLogSecurityDescriptor

        It Calls:

    PSECURITY_DESCRIPTOR
    ObpReferenceSecurityDescriptor (
        PVOID  Object
        )

        Called By:  obse.c\ObGetObjectSecurity

        It Calls:   obsdata.c\ObpAcquireDescriptorCacheWriteLock (
                    obsdata.c\ObpReleaseDescriptorCacheLock (

    NTSTATUS
    ObDeassignSecurity (
        IN OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
        )

        Called By:

        It Calls:   obsdata.c\ObpDereferenceSecurityDescriptor (

    VOID
    ObpDereferenceSecurityDescriptor (
        PSECURITY_DESCRIPTOR SecurityDescriptor
        )

        Called By:  obsdata.c\ObDeassignSecurity
                    obse.c\ObReleaseObjectSecurity
                    obse.c\ObSetSecurityDescriptorInfo

        It Calls:   obsdata.c\ObpDestroySecurityDescriptorHeader (
                    obsdata.c\ObpAcquireDescriptorCacheWriteLock (
                    obsdata.c\ObpReleaseDescriptorCacheLock (

    VOID
    ObpDestroySecurityDescriptorHeader (
        IN PSECURITY_DESCRIPTOR_HEADER Header
        )

        Called By:  obsdata.c\ObpDereferenceSecurityDescriptor

        It Calls:

    BOOLEAN
    ObpCompareSecurityDescriptors (
        IN PSECURITY_DESCRIPTOR SD1,
        IN PSECURITY_DESCRIPTOR SD2
        )

        Called By:  obsdata.c\ObpLogSecurityDescriptor

        It Calls:

    VOID
    ObpAcquireDescriptorCacheWriteLock (
        VOID
        )

        Called By:  obsdata.c\ObpLogSecurityDescriptor
                    obsdata.c\ObpReferenceSecurityDescriptor
                    obsdata.c\ObpDereferenceSecurityDescriptor

        It Calls:

    VOID
    ObpAcquireDescriptorCacheReadLock (
        VOID
        )

        Called By:  obse.c\ObSetSecurityDescriptorInfo

        It Calls:

    VOID
    ObpReleaseDescriptorCacheLock (
        VOID
        )

        Called By:  obsdata.c\ObpLogSecurityDescriptor
                    obsdata.c\ObpReferenceSecurityDescriptor
                    obsdata.c\ObpDereferenceSecurityDescriptor
                    obse.c\ObSetSecurityDescriptorInfo

        It Calls:


Module Name:

    obwait.c

Global variables and who references them

    extern POBJECT_TYPE ExEventObjectType;

        obwait.c\NtSignalAndWaitForSingleObject

    extern POBJECT_TYPE ExMutantObjectType;

        obwait.c\NtSignalAndWaitForSingleObject

    extern POBJECT_TYPE ExSemaphoreObjectType;

        obwait.c\NtSignalAndWaitForSingleObject

Procedures

    NTSTATUS
    NtSignalAndWaitForSingleObject (
        IN HANDLE SignalHandle,
        IN HANDLE WaitHandle,
        IN BOOLEAN Alertable,
        IN PLARGE_INTEGER Timeout OPTIONAL
        )

        Called By:

        It Calls:   obwait.c\extern POBJECT_TYPE ExEventObjectType;
                    obwait.c\extern POBJECT_TYPE ExSemaphoreObjectType;
                    obwait.c\extern POBJECT_TYPE ExMutantObjectType;

                    obref.c\ObReferenceObjectByHandle (
                    obref.c\ObDereferenceObject (

    NTSTATUS
    NtWaitForSingleObject (
        IN HANDLE Handle,
        IN BOOLEAN Alertable,
        IN PLARGE_INTEGER Timeout OPTIONAL
        )

        Called By:

        It Calls:   obref.c\ObReferenceObjectByHandle (
                    obref.c\ObDereferenceObject (

    NTSTATUS
    NtWaitForMultipleObjects (
        IN ULONG Count,
        IN HANDLE Handles[],
        IN WAIT_TYPE WaitType,
        IN BOOLEAN Alertable,
        IN PLARGE_INTEGER Timeout OPTIONAL
        )

        Called By:

        It Calls:   obhandle.c\ObpIncrPointerCount (
                    obhandle.c\ObpTranslateGrantedAccessIndex (
                    obref.c\ObDereferenceObject (

    NTSTATUS
    ObWaitForSingleObject (
        IN HANDLE Handle,
        IN BOOLEAN Alertable,
        IN PLARGE_INTEGER Timeout OPTIONAL
        )

        Called By:

        It Calls:   obref.c\ObReferenceObjectByHandle (
                    obref.c\ObDereferenceObject (
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\locking.txt ===
14 April 1997
19 May 1997

Locking Rules for Po interface code

1.  The Dope structure and all elements in it
    or referred to by it, including idle, notify,
    and channel structures, are protected by a
    global lock named PopDopeGlobalLock.
    use PopLockDopeGlobal and PopUnlockDopeGlobal.

    EXCEPTION:  PoSetDeviceBusy is allowed to wack
                directly on the IdleCount variable.


2.  The Irp serial list is protected by the
    PopIrpSerialLock, accessed via
    PopLockIrpSerialList and PopReleaseIrpSerialList,
    note that the later does NOT lower IRQL.
    PowerFlags (sys state, dev state, pend, active) are
    also protected by the irpserial list lock.

3.  Notify network protected by eresource named PopNotifyLock,
    dope/notify data protected by the DopeGlobalLock.

4.  Lock order:
        PopNotifyLock, DopeGlobalLock, IrpSerialLock.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\po\notes.txt ===
Questions:
    If we send an inrush IRP to A (which is inrush) and A sends it on
    to B, which is not (so we'll process it normally), does anything weird happen?

Driver Rules:
    1.  Must call PoCallDriver for IRP_MJ_POWER regardless
        of the minor code.

    3.  When a driver has received a power irp, and wishes to pass it
        on to other drivers, the following rules apply.

        a.  The SystemContext field must be copied into the next stack location.

        b.  if a driver passes a given irp on to multiple parallel drivers
            (for example, an FT driver that calls multiple disk drivers with
            a single request) then the driver must pass the power irp on to
            each driver one at a time.  it could pass on multiple copies in
            parallel, but if and only if they are not INRUSH.

    4.  If a single irp's stack of functions contains both Power functions and
        non-power functions, the SystemContext field must be propogated accross
        the non-power functions.

        Example:

            driver A gets MJ_PNP_POWER, MN_SET_POWER, incoming SystemContext = s0

            A calls B with MJ_IOCTL, MN..., to get B to do some side function
            associated with powering down (flushing a hardware cache, say)

            B calls C with MJ_POWER, MN_SET_POWER, ...

            Then A must pass SystemContext on to B, which must pass it on to C
            (via a call to PoCallDriver)  PoCallDriver may modify the SystemContext
            that was passed in, so that C gets a different one.

        If this is not done, when the power IRP is passed to C, PoCallDriver won't
        know it's a continuation of a previous IRP, and therefore may do the wrong
        thing.

        (For example, if A and C have INRUSH set, and B doesn't pass on the
            SystemContext value passed into A, then when B does PoCallDriver(C, irp)
            it will be enqueued forever because PoCallDriver thinks it is
            another, different, inrush irp.)

    5.  Any code that fills in a stack location with the first Power function
        of that IRP's stack must set SystemContext to 0.

@@  inrush will lead to deadlocks if two inrush DOs are ever in the same
    stack
!!> special context rules allow an irp to flow up and down a stack,
    need to be sure this is well doc'd.
    if a driver has D0_INRUSH set, and an INRUSH irp arrives, that irp
    might get held up waiting for some other irp to clear in that driver.
    (e.g. some other driver power state irp that didn't set power TO D0
          might hold up all inrush irps in the system)
    if DO is marked inrush, we will always call it at DPC level, just
    to avoid confusion over what is pageable and what is not.

    inrush applies only to device irps, or to device irps and system irps?
    if the later, then an inrush DO can only ever see one irp at time regardless
    of type!!!
!!> driver can receive a SystemPowerState irp even while INRUSH is locked.

!!> when calling any driver that does not set PAGE or INRUSH, we must call
    it from a worker thread at IRQL 0, regardless of where PoCallDriver was called.
    if it is an INPAGE device, we must call it from DPC at IRQL 2.
    not sure about INRUSH, I think it's at DPC too.

??  how will MN_POWER_SEQUENCE and MN_WAIT_WAKE fit into all this?

DOE content

    The contents of the DOE are 100% private.  There is a special
    declaration that allows the PoSetDeviceBusy() call to be a macro.
    (Actually, best if PoSetDeviceBusy() takes a system returned pointer,
     then there are no longer any fixed offsets to worry about.)

    The idea is that any value not needed by every DO is stored in a
    power control block (POB).  Any operation that might allocate this
    object must allow for failure of the allocation!!!


SPEC NOTES:
    Any operation that might allocate a POB must allow for failure to allocate.
    None of the DOE data is public.


Power irp rules.  Allowed one DevicePowerState and one SystemPowerState
irp at a time.

Context Values:
    If low order bit of the context field is 1, it is a flag.
    If 0, it is a pointer.
    If the whole thing is null, then no value.
    So:
        if (SystemContext == 0)
            no context set
        else if (SystemContext & 1)
            test for flag values
        else
            it's a pointer to some structure

    (need to change some code to match this.)

IRP Queues:
    Use a single global holding queue.  When a DO is busy, the IRP is
    enqueued on the tail of this queue.  Whenever a power IRP completes
    AND the "pending" bit is set, run the entire list looking for an
    IRP of that type for that DO, and dispatch it to the DO if we find it.

    This means that each DOE has only 2 bits to mark S and D active,
    and 2 bits to mark S and D pending.

    If we search the entire list and do not find any Irps for that DO,
    then the pending bit is cleared along with the active one.


Power IRPs, Inrush, and copying
    Globally, only one IRP is allowed to be active on any INRUSH DO in
    the system at any time.

    Active and Pending bits have different meanings for INRUSH DevObj
    than for normal devobj.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\sample\wmilib\readme.txt ===
This directory contains a sample PnP upper filter driver whose only 
purpose is to provide WMI data blocks. Typically driver writers will copy the 
sample code into their own driver and make any minor modifications so that the
WMI data blocks are always available when the driver is loaded. Alternatively
WmiSamp can be left as a filter driver if WMI data blocks should only be made
available when the filter driver is loaded. Drivers that link to classpnp.sys
should use a similar library that is part of classpnp.

    WMI enabling a driver with the sample code consists of doing 5 things:

1. Determining what data needs to be provided and organize it into data blocks
   that contain related data items. For example packets sent and bytes sent
   could be part of a single data block while transmit errors could be part
   of a data block that contains other error counts. Determine if the device
   needs notifications of when to enable and disable collections in the case
   of data blocks that impose a performance hit to collect.

2. Write a Managed Object Format (.mof) file that describes the data blocks. 
   In doing this the driver writer will need to run the guidgen tool to 
   create globally unique guids that are assigned to the data blocks. Guidgen
   *MUST* be run so that no two data blocks will have the same guid. Reference
   the .bmf file (.bmf files are created when mof files are compiled by the 
   mofcomp tool) in the driver's .rc file so that the .bmf file data is 
   included as a resource of the driver's .sys file. WmiLib hardcodes the 
   resource name as MofResourceName.

3. Build the GUIDREGINFO structure with the guids for the data blocks defined
   in the .mof file. If the device wants to be notified of when to start and
   stop collection of a data block the WMIREG_FLAG_EXPENSIVE flag should be
   set for the data block in the GUIDREGINFO structure.

4. Implement the 6 WMI function callback routines and reference them in a 
   WMI_INFO structure.


    The sample code supports does not support more than one instance of a 
data block for each device, that is a single device object can only supply
one instance of a data block. Drivers that create multiple device objects
will supply multiple instances for a data block (ie, 1 data block per device
object).

    The sample code does not support dynamic instance names. Instance names 
are statically defined when device registers with WMI. The PQUERY_WMI_REGINFO
callback allows the device to specify a unique instance name for the device or
the PDO for the device. If the PDO is specified then WMI will translate it to 
the device instance name and use that as the unique instance name.

    All data blocks registered for a device will use the same instance name.
That is different data blocks for a device object cannot specify different 
instance names.

    The sample code can be extended to overcome these limitations if the need
arises, however this sample code should be sufficient for most applications.

    All WMI callback functions that pass the irp as a parameter are 
responsible to call WmiLibCompleteRequest when the request has been satisfied
so that the IRP can be completed. If the WMI callback function cannot 
complete the request immediately it can mark the irp pending and return
STATUS_PENDING, but it must call WmiLibComnpleteRequest when the request 
actually finishes.

    The sample code uses a simple linear search to determine the guid index
for any guid passed. If a driver provides a long list of guids then 
WmiLibFindGuid may need to be updated to use a better searching mechanism.

    WmiLib counts on a number of fields being present in the device extension
in order for it to process the WMI requests. See Wmilib.h for their 
description.

    Finally the sample code uses a static global variable to store the 
values for the data block. This is not quite correct since each device object
will typically have its own set of data that composes its instance of a 
data block. Really the global variable should be part of the device extension,
however I did not want to confuse the device extension with extra stuff.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\sample\wmilib\wmisamp.ini ===
\registry\machine\system\currentcontrolset\services\WmiSamp
    Type = REG_DWORD 0x00000001
    Start = REG_DWORD 0x00000001
    Group = PnP Filter
    ErrorControl = REG_DWORD 0x00000001

\registry\machine\system\currentcontrolset\enum\root\*PNP0400\2_0_20_0_0_0
    UpperFilters = REG_MULTI_SZ "WmiSamp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\howtobuild.txt ===
To build 16-bit makeboot:
-------------------------
change directory to the makeboot directory
in a 16-bit razzle environment type: build

the directory structure is the same as winnt, so the exe shows up in usa\obj\i386\makeboot.exe

To build 32-bit makebt32:
-------------------------
change directory to the makebt32 directory
in a 32-bit razzle environment type: build

the exe shows up in obj\i386\makebt32.exe
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bosprep\placefil.txt ===
bosprep.exe retail
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cfgmgrf\readme.txt ===
cfgmgrf moved to BASE\pnp\cfgmgrf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\placefil.txt ===
;
; app
;
loadstate.exe       valueadd\msft\usmt
scanstate.exe       valueadd\msft\usmt
scanstate_a.exe     valueadd\msft\usmt
migwiz.man          retail
migwiz.sed          retail
migcab.sed          retail
migwiz.exe          retail
migwiz_a.exe        retail
migload.exe         retail
;
; engine
;
migism.dll          valueadd\msft\usmt:retail
migism_a.dll        valueadd\msft\usmt:retail
;
; utils
log.dll             valueadd\msft\usmt:retail
iconlib.dll         valueadd\msft\usmt:retail
;
; modules
;
sysmod.dll          valueadd\msft\usmt:retail
sysmod_a.dll        valueadd\msft\usmt:retail
script.dll          valueadd\msft\usmt:retail
script_a.dll        valueadd\msft\usmt:retail
guitrn.dll          retail
guitrn_a.dll        retail
unctrn.dll          valueadd\msft\usmt
unctrn_a.dll        valueadd\msft\usmt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\placed\usa\mgwzcopy.txt ===
[TEXT: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\placed\gui\placefil.txt ===
;
; INFs
;
migism.inf          retail
USMTDef.inf         retail
migwiz.inf          retail
miguser.inf         retail
migsys.inf          retail
migapp.inf          retail
sysfiles.inf        retail
mgwzcopy.inf        retail
migwiz.htm          retail
migwiz2.htm         retail
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\placed\console\placefil.txt ===
;
; INFs
;
migism.inf          valueadd\msft\usmt
USMTDef.inf         valueadd\msft\usmt
migwiz.inf          valueadd\msft\usmt
miguser.inf         valueadd\msft\usmt
migsys.inf          valueadd\msft\usmt
migapp.inf          valueadd\msft\usmt
sysfiles.inf        valueadd\msft\usmt
;
; DOCs
;
UsmtInfCommands.doc valueadd\msft\usmt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\placed\usa\migism.txt ===
[Strings]
;none
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\placed\usa\migapp.txt ===
[Strings]
acroread40 = "Adobe Acrobat Reader"
acroread50 = "Adobe Acrobat Reader"
photoshop6 = "Adobe Photoshop"
ATMDeluxe41 = "Adobe Type Manager Deluxe 4.1"
aim = "AOL Instant Messenger"
battlecom = "BattleCom"
CmdExe = "Command Prompt settings"
cuteftp4 = "CuteFTP"
Eudora5 = "Eudora 5"
EudoraAddBook = "Eudora Migrated Address Book.txt"
GameVoice = "Sidewinder Game Voice"
icq = "ICQ"
Netmeeting3 = "Microsoft Netmeeting"
MMJukeBox6 = "MusicMatch Jukebox"
msnexp10 = "MSN Explorer"
msnzone6 = "MSN Gaming Zone"
msmedia7 = "Windows Media Player"
msmoney2001 = "Microsoft Money"
msmsgr36 = "Microsoft Messenger"
msmvm1 = "Windows Movie Maker"
Lotus = "Lotus SmartSuite"
Odigo = "Odigo Messenger"
office = "Microsoft Office"
Access_XP =  "Microsoft Access 2002"
Excel_XP =  "Microsoft Excel 2002"
FrontPage_XP =  "Microsoft FrontPage 2002"
Outlook_XP =  "Microsoft Outlook 2002"
PhotoDraw_XP =  "Microsoft PhotoDraw 2002"
PowerPoint_XP = "Microsoft PowerPoint 2002"
Publisher_XP =  "Microsoft Publisher 2002"
Word_XP = "Microsoft Word 2002"
Access_2000 = "Microsoft Access 2000"
Excel_2000 = "Microsoft Excel 2000"
FrontPage_2000 = "Microsoft FrontPage 2000"
Outlook_2000 = "Microsoft Outlook 2000"
PhotoDraw_2000 = "Microsoft PhotoDraw 2000"
PowerPoint_2000 = "Microsoft PowerPoint 2000"
Publisher_2000 = "Microsoft Publisher 2000"
RealJukebox2 = "RealJukebox 2 Basic"
RealPlayer8 = "RealPlayer 8 Basic"
Word_2000 = "Microsoft Word 2000"
Access_97 = "Microsoft Access 97"
Excel_97 = "Microsoft Excel 97"
Outlook_97_98 = "Microsoft Outlook 97 & 98"
PowerPoint_97 = "Microsoft PowerPoint 97"
Word_97 = "Microsoft Word 97"
Works_Suite_2001 = "Microsoft Works 2001"
Prodigy = "Prodigy Internet"
Quicken2001 = "Quicken"
Quicken2001HAndB = "Quicken 2001 Home and Business"
QuickTime5 = "QuickTime Player 5"
RogerWilco = "Roger Wilco"
Sonique = "Sonique Media Player"
WordPerfectOffice_2000 = "WordPerfect Office 2000"
WinAmp = "WinAmp Media Player"
WsFTPLE5 = "WS_FTP Limited Edition"
WinZip8 = "WinZip"
yahoomsgr = "Yahoo! Messenger"
GetRight4 = "GetRight Download Manager"
GoZilla = "Go!Zilla"

;
; unlocalized strings:
;
HkrWindowsNT        = "HKR\Software\Microsoft\Windows NT\CurrentVersion"
HklmWindowsNT       = "HKLM\Software\Microsoft\Windows NT\CurrentVersion"
HkrWindows          = "HKR\Software\Microsoft\Windows\CurrentVersion"
HklmWindows         = "HKLM\Software\Microsoft\Windows\CurrentVersion"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\placed\usa\migwiz.txt ===
[Strings]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\placed\usa\miguser.txt ===
[Strings]
@*: This is the location of Quick Launch. Please localize to match your localized system directory name.
QuickLaunchDir = "%csidl_appdata%\Microsoft\Internet Explorer\Quick Launch"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\placed\usa\migsys.txt ===
[Strings]
accessibility = "Accessibility"
mouse_and_keyboard = "Mouse and keyboard"
internet_settings = "Internet Explorer settings"
internet_security_settings = "Internet Explorer security settings"
International = "Regional settings"
Multimedia = "Sounds and multimedia"
outlook_express = Outlook Express
display = "Display properties"
screensaver = "Screen Saver selection"
folderoptions = "Folder options"
taskbar = "Taskbar options"
classic = "Classic desktop"
@c:ODBC = "ODBC Data Sources"
@*: This is the default data source for ODBC. It is a subdirectory in
@*: Program Files. Please localize to match your localized system directory name.
@c:ODBCDataSource = "Common Files\ODBC\Data Sources"
@*:
@*: Commented out for now
@*:
@*:@c:Certificates = "Certificates"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\placed\usa\usmtdef.txt ===
[Strings]
@*: These are subdirectories in Program Files. Accessories9X is on Win9x systems, while
@*: AccessoriesNT and WindowsNT are on NT systems. Please localize accordingly.
Accessories9X = "Accessories"
AccessoriesNT = "Accessories"
WindowsNT = "Windows NT"
@*:
@*:
@*: These are the name of the screen saver files on Win9x systems. They can be found in %windir%\system
@*: directory. Please localize only if localized on your system. For the short file names there are 5
@*: strings. This is to accomodate the case where the short file name is different for different Win9x
@*: systems (for example is 3DFLYI~1.SCR on Win95 Gold but it is 3DFLYI~2.SCR on Win98 Gold).
@*:
ss3dfo_9X = "3D Flying Objects.scr"
ss3dfo_9X_Short_1 = "3DFLYI~1.SCR"
ss3dfo_9X_Short_2 = "3DFLYI~1.SCR"
ss3dfo_9X_Short_3 = "3DFLYI~1.SCR"
ss3dfo_9X_Short_4 = "3DFLYI~1.SCR"
ss3dfo_9X_Short_5 = "3DFLYI~1.SCR"
sspipes_9X = "3D Pipes.scr"
sspipes_9X_Short_1 = "3DPIPE~1.SCR"
sspipes_9X_Short_2 = "3DPIPE~1.SCR"
sspipes_9X_Short_3 = "3DPIPE~1.SCR"
sspipes_9X_Short_4 = "3DPIPE~1.SCR"
sspipes_9X_Short_5 = "3DPIPE~1.SCR"
sstext3d_9X = "3D Text.scr"
sstext3d_9X_Short_1 = "3DTEXT~1.SCR"
sstext3d_9X_Short_2 = "3DTEXT~1.SCR"
sstext3d_9X_Short_3 = "3DTEXT~1.SCR"
sstext3d_9X_Short_4 = "3DTEXT~1.SCR"
sstext3d_9X_Short_5 = "3DTEXT~1.SCR"
ssflwbox_9X = "3D Flower Box.scr"
ssflwbox_9X_Short_1 = "3DFLOW~1.SCR"
ssflwbox_9X_Short_2 = "3DFLOW~1.SCR"
ssflwbox_9X_Short_3 = "3DFLOW~1.SCR"
ssflwbox_9X_Short_4 = "3DFLOW~1.SCR"
ssflwbox_9X_Short_5 = "3DFLOW~1.SCR"
scrnsave_9X = "Blank Screen.scr"
scrnsave_9X_Short_1 = "BLANKS~1.SCR"
scrnsave_9X_Short_2 = "BLANKS~1.SCR"
scrnsave_9X_Short_3 = "BLANKS~1.SCR"
scrnsave_9X_Short_4 = "BLANKS~1.SCR"
scrnsave_9X_Short_5 = "BLANKS~1.SCR"
ssbezier_9X = "Curves and Colors.scr"
ssbezier_9X_Short_1 = "CURVES~1.SCR"
ssbezier_9X_Short_2 = "CURVES~1.SCR"
ssbezier_9X_Short_3 = "CURVES~1.SCR"
ssbezier_9X_Short_4 = "CURVES~1.SCR"
ssbezier_9X_Short_5 = "CURVES~1.SCR"
ssstars_9X = "Flying Through Space.scr"
ssstars_9X_Short_1 = "FLYING~2.SCR"
ssstars_9X_Short_2 = "FLYING~2.SCR"
ssstars_9X_Short_3 = "FLYING~2.SCR"
ssstars_9X_Short_4 = "FLYING~2.SCR"
ssstars_9X_Short_5 = "FLYING~2.SCR"
ssmyst_9X = "Mistify Your Mind.scr"
ssmyst_9X_Short_1 = "MYSTIF~1.SCR"
ssmyst_9X_Short_2 = "MYSTIF~1.SCR"
ssmyst_9X_Short_3 = "MYSTIF~1.SCR"
ssmyst_9X_Short_4 = "MYSTIF~1.SCR"
ssmyst_9X_Short_5 = "MYSTIF~1.SCR"
ssmypics_9X = "My Pictures Screen Saver.scr"
ssmypics_9X_Short_1 = "MYPICT~1.SCR"
ssmypics_9X_Short_2 = "MYPICT~1.SCR"
ssmypics_9X_Short_3 = "MYPICT~1.SCR"
ssmypics_9X_Short_4 = "MYPICT~1.SCR"
ssmypics_9X_Short_5 = "MYPICT~1.SCR"
ssmarque_9X = "Scrolling Marquee.scr"
ssmarque_9X_Short_1 = "SCROLL~1.SCR"
ssmarque_9X_Short_2 = "SCROLL~1.SCR"
ssmarque_9X_Short_3 = "SCROLL~1.SCR"
ssmarque_9X_Short_4 = "SCROLL~1.SCR"
ssmarque_9X_Short_5 = "SCROLL~1.SCR"

;
; unlocalized strings:
;
HkrWindowsNT        = "HKR\Software\Microsoft\Windows NT\CurrentVersion"
HklmWindowsNT       = "HKLM\Software\Microsoft\Windows NT\CurrentVersion"
HkrWindows          = "HKR\Software\Microsoft\Windows\CurrentVersion"
HklmWindows         = "HKLM\Software\Microsoft\Windows\CurrentVersion"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\reqdlls\placefil.txt ===
loadras.dll  retail:winstate\console
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\placed\usa\sysfiles.txt ===
[Strings]

@*: The following items are subdirectories in %programfiles% as they are installed by various
@*: Win9x and NT flavours. Most of them are not localized on any system. Some of them are localized
@*: on some systems but not localized on others. If one of these subdirs is localized on at least one
@*: Windows release please localize accordingly.
accessories     = "Accessories"
commonfiles     = "Common Files"
complusapps     = "ComPlus Applications"
directx         = "Directx"
iconnwizard     = "ICW-Internet Connection Wizard"
ieak            = "IEAK"
iexplore        = "Internet Explorer"
exchange        = "Microsoft Exchange"
scriptdbg       = "Microsoft Script Debugger"
gamingzone      = "MSN Gaming Zone"
netmeeting      = "NetMeeting"
onlineservices  = "Online Services"
orktools        = "ORKTools"
outlookexpress  = "Outlook Express"
plus            = "Plus!"
snapshotviewer  = "Snapshot Viewer"
msn             = "The Microsoft Network"
mediaplayer     = "Windows Media Player"
winnt           = "Windows NT"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\placed\usa\usmtinfcommands.doc ===
Microsoft Word Document MSWordDoc Word.Document.8TitleNormal Microsoft Word 10.0urn:schemas-microsoft-com:office:smarttags Street urn:schemas-microsoft-com:office:smarttags PlaceType urn:schemas-microsoft-com:office:smarttags PlaceName urn:schemas-microsoft-com:office:smarttags country-region urn:schemas-microsoft-com:office:smarttags place urn:schemas-microsoft-com:office:smarttags address (|1&|2Operating System User State Migration Tool   INF Commands  Microsoft Corporation Published: January 2003 Abstract This white paper documents the INF commands used by the User State Migration Tool (USMT) and the Files and Settings Transfer Wizard (FASTWiz) to control what state is migrated. Information Technology (IT) professionals and consultants who customize USMT for Windows XP deployments are the target audience of this document. This document is not comprehensive documentation on USMT or FASTWiz, but instead focuses on the INF commands. The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication. This document is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, AS TO THE INFORMATION IN THIS DOCUMENT. Complying with all applicable copyright laws is the responsibility of the user. Without limiting the rights under copyright, no part of this document may be reproduced, stored in or introduced into a retrieval system, or transmitted in any form or by any means (electronic, mechanical, photocopying, recording, or otherwise), or for any purpose, without the express written permission of Microsoft Corporation. Microsoft may have patents, patent applications, trademarks, copyrights, or other intellectual property rights covering subject matter in this document. Except as expressly provided in any written license agreement from Microsoft, the furnishing of this document does not give you any license to these patents, trademarks, copyrights, or other intellectual property. Unless otherwise noted, the example companies, organizations, products, domain names, e-mail addresses, logos, people, places and events depicted herein are fictitious, and no association with any real company, organization, product, domain name, e-mail address, logo, person, place or event is intended or should be inferred.  2003 Microsoft Corporation. All rights reserved. Microsoft, Win32, Windows, and Windows NT are either registered trademarks or trademarks of Microsoft Corporation in the United States or other countries or regions. The names of actual companies and products mentioned herein may be the trademarks of their respective owners. Contents Introduction The Anatomy of an INF Components and Individual State INF Template [Version] Section [Applications] Section [System Settings] Section [User Settings] Section [.Environment] Section [.Detect] Section [.Detect.n] Section [.Instructions] Section      [Copy This State] Section [Disabled Components] Section [RemapEnvVar] Section [Strings] Section Types, Object Names, and Attributes INF Commands Overview File Commands CopyFiles CopyFilesEx DelFiles ForceSrcFile ForceDestFile Registry Commands AddReg RenReg DelReg RegFile RegFolder RegIcon ForceSrcReg ForceDestReg DestDelReg INI Commands AddIni RenIni DelIni IniFile IniFolder IniIcon ForceSrcIni ForceDestIni Miscellaneous Commands ProcessSection Precedence Re-rooting Recognized INF Variables The Default INFs and Their Components/Applications Migsys.inf Miguser.inf Migapp.inf Sysfiles.inf Migwiz.inf Migration.inf Files and Settings Transfer Wizard INF and Migwiz.inf Migration.inf   The Command-Line State Store Command-Line Parameters And Usage Unicode or ANSI Take All vs. Take Known Suggested Command-Lines Take Known Model (Recommended) Take All Model Command-Line Parameters Scanstate Loadstate Return Codes and Logs Common Scenarios To Create An INF File To Add A Component To Add Individual State Summary Introduction User state migration is usually an important part of successfully deploying Microsoft  Windows  XP in a large organization. Migrating the user state of an organization's computers typically means handling the special applications, folders, and settings specific to the organization. For the User State Migration Tool (USMT), that means customization of the INF files. This document covers the supported INF commands for USMT. This document does not cover USMT usage scenarios, migration planning, and USMT tool documentation. The main focus of this document is how to create new INF files and how to customize existing INF files. This documentation refers only to USMT version 2.5, which released with the Microsoft Windows Server 2003 family for use with Windows XP. The Anatomy of an INF An INF file is the set of rules that USMT and the Files and Settings Transfer Wizard (FASTWiz) use to migrate a user s state. The command-line tools, Scanstate.exe and Loadstate.exe, can use multiple INF files. Sample INF file listings in this document may have line wraps due to margin limitations. If you view this document in Microsoft  Word, please turn on paragraph marks to view the line breaks. Components and Individual State The INF file describes components and individual state, and the rules for migrating them. Individual state is the state not associated with a component. Some examples of individual state include a specific registry setting, file, file type, or folder. A component is a set of related rules that define the state for one item. For example, an application s state, Accessibility Settings, or Classic Desktop can be a component. Both individual state and components are important to a successful migration, and most INF files have both. When dealing with elements of state that clearly belong together, it is good to take the extra steps to make them a component. Components can be exposed to the user through  Settings  in FASTWiz. Components are also easy blocks to include or exclude for sub-groups in the deployment. INF Template The example below incorporates all of the possible sections. It is not a valid sample INF file. [Version] Signature = $Windows NT$ [Applications] <App Section Name>,  Display Name Acrobat Reader 40, %acroread40% [Acrobat Reader 40.Environment] ; %VarName% = <Type>, <Object Name> %PhotoshopSuite6Path% = Registry, HKLM\Software\Adobe\Photoshop\6.0\ApplicationPath [] [Acrobat Reader 40.Detect] ; How I detect the app is installed on the source, and destination ; Each of these lines are ANDed together ; <Type>, <Object Name>, <Attributes> Registry, HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall\Adobe Acrobat 4.0 [UninstallString], EXISTS Registry, HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall\Adobe Acrobat 4.0 [ProductId], !EXISTS [Acrobat Reader 40.Detect.1] ; If you have a x.Detect.1 you do NOT have a x.Detect section for this app ; If either this OR x.Detect.n is true, then the app is installed ; There can be any number of x.Detect.# sections [Acrobat Reader 40.Detect.2] ; If you have this section you also have a x.Detect.1 and not a x.Detect section for this app ; If either this OR x.Detect.1 is true, then the app is installed [Acrobat Reader 40.Instructions] Copy This State  section which only executes if the .Detect evaluates to true (or is absent) ; INFRule = AppName.SectionName DestDelReg = Acrobat Reader 40.DestDelReg AddReg = Acrobat Reader 40.AddReg [Acrobat Reader 40.DestDelReg] HKR\Software\Adobe\Acrobat Reader\4.0\AdobeViewer [AllowOpenFile] [Acrobat Reader 40.Addreg] HKR\Software\Adobe\Acrobat Reader\4.0\AdobeViewer [AllowOpenFile] [Acrobat Reader 40] Copy this State  section which always executes regardless of the .Detect section ; (This assumes Acrobat Reader 40 is listed in the Applications section)  [Copy This State] ; INFRule = AppName.SectionName CopyFiles = SampleCopyFileSection [SampleCopyFileSection] DIR=C:\Data\* *.FSW, %CSIDL_PERSONAL% [Strings] acroread40 = "Adobe Acrobat Reader"  [Version] Section Required Only one per INF Specific to individual INFs Each INF needs to have one and only one [Version] section. The [Version] section must always be the same. It contains one line, a signature line. Parameters Signature Always $Windows NT$. [Version] Signature = $Windows NT$ [Applications] Section Optional Only one per INF Combined across INFs The [Applications] section lists all of the components that USMT understands. Each line is a separate component. The syntax for a detail line is: Component Section Name,  Display Name Parameters Component SectionName Unique for each component across all INF files used. Each INF file s [Applications] section is combined, and Component Section Name must be unique across all used. If it is not unique, each of the lines in the component s sections are combined with other similar sections. (For example, if there are two MyApp components listed, and each has a [.Detect] section, the lines in each of the [.Detect] sections combine into a single [.Detect] section.) Display Name Can use an INF string variable defined in the [Strings] section. Using string variables makes it easier to localize the displayed strings in the INF file. [Applications] Acrobat Reader 40, %acroread40% [Strings] acroread40 = "Adobe Acrobat Reader" [System Settings] Section Optional Only one per INF file Combined across INF files The [System Settings] section lists all of the components that USMT understands. Each line is a separate component. The syntax for a detail line is: Component Section Name,  Display Name Parameters Component SectionName Unique for each component across all INF files used. Each INF file s [System Settings] section is combined, and Component Section Name must be unique across all used. If it is not unique, each of the lines in the component s sections are combined with other similar sections. (For example, if there are two MyApp components listed, and each has a [.Detect] section, the lines in each of the [.Detect] sections combine into a single [.Detect] section.) Display Name Can use an INF string variable defined in the [Strings] section. Using string variables makes it easier to localize the displayed strings in the INF file. [System Settings] Accessibility, %accessibility% [Strings] accessibility = "Accessibility"  [User Settings] Section Optional Only one per INF file Combined across INF files The [User Settings] section lists all of the components that USMT understands. Each line is a separate component. The syntax for a detail line is: Component Section Name,, dir, %CSIDL_NAME% Parameters Component SectionName Unique for each component across all INF files used. Each INF file s [User Settings] section is combined, and Component Section Name must be unique across all used. If it is not unique, each of the lines in the component s sections are combined with other similar sections. (For example, if there are two MyApp components listed, and each has a [.Detect] section, the lines in each of the [.Detect] sections combine into a single [.Detect] section.) %CSIDL_NAME% The CSIDL_NAME represents the folder that the component refers to. [User Settings] Desktop Items,, dir,%csidl_desktopdirectory% [.Environment] Section Optional Only one per component section Unique for given component across INF files The [.Environment] section is used to create temporary environment variables for use in the component s sections. These are primarily used to determine the installation path of either the application or a specific sub-folder for the application (for example, plug-ins). The variable created here can then be used later with an INF rule to migrate specific files to a specific folder, regardless of the application installed in a different folder on the destination. This component section is processed first, even before [.Detect] sections. The syntax for a detail line is: %VARIABLENAME% = Type, Object Name Parameters VARIABLENAME Follows the naming rules for an environment variable. It must be unique across INF files. Can be one of the following: Description Registry The environment variable is set to the value of the registry setting specified by Object Name. Directory The environment variable is set to the folder of the path given using Object Name. INIFile The environment variable is set to the value of the setting specified by Object Name. Object Name Has a specific meaning for each of the Types. Meaning of Object Name Registry RegistryRoot\RegistryKey [SettingName]. [] denotes the (Default) value. Directory <Drive:>\Folder. UNC paths are also supported. INIFile <Drive:>\Folder\filename.ini/section/setting. UNC paths are also supported. More information on Types and Object Names is given below in  Types, Object Names, and Attributes." [Acrobat Reader 40.Environment] %PhotoshopSuite6Path% = Registry, HKLM\Software\Adobe\Photoshop\6.0\ApplicationPath [] [.Detect] Section Optional  Only one per component Unique for given component The [.Detect] section is used to determine if the component is present on the source and destination computers. If the [.Detect] section is omitted, it is assumed that the component is present and the component s [.Instructions] section is executed. If there is a [.Detect] section, each of the lines in the [.Detect] section is evaluated and then ANDed together. In order for the component to be detected, each of the lines in the [.Detect] section must be true. There are also [.Detect.n] sections which are ORed together. See below for more details on the [.Detect.n] sections. The [.Detect] section improves performance by not processing rules for components that are not installed. The [.Detect] section also makes the FASTWiz UI less confusing for the user because components not detected on the user s system will not be listed as a component to be migrated. The syntax for a detail line is: Type, Object Name, Attributes Parameters Can be one of the following: Description Registry A value of the registry setting specified by Object Name. Directory A folder of the path specified using Object Name. A file specified by Object Name. System An operating system. Object Name Is specific to the Type. Meaning of Object Name Registry RegistryRoot\RegistryKey [SettingName]. [] denotes the (Default) value. Directory <Drive:>\Folder. UNC paths are also supported. <Drive:>\Folder\Filename.ext. UNC paths are also supported. System OS.Version Name.SubVersion. Attributes Can be one of the following for any Type (except as noted below): Attribute Value Exists TRUE if Object Name exists. Applies to: Registry, Directory, System, File, INIFile SameObjectName(ObjName) TRUE if ObjName equals Object Name. Applies to: Registry, Directory, File, INIFile SameObjectContent(ObjName) TRUE if the content of ObjName and Object Name are equal. Applies to: Registry, INIFile Matches(Value) TRUE if Value equals the content of Object Name. Applies to: Registry, INIFile Version(Field, Pattern) TRUE if the version number of the FILE object to which Object Name points matches the version specified. Field is the name of the field containing the version information. Pattern indicates the string pattern to match. Applies to: File, Registry If it is a Registry object, its value must point to a file. Each attribute can be changed to NOT (or FALSE) by adding an exclamation point (!) to the beginning. For example, !EXISTS means does not exist. More information on Types, Object Names, and Attributes is given below in  Types, Object Names, and Attributes. [Acrobat Reader 40.Detect] Registry, HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall\Adobe Acrobat 4.0 [UninstallString], EXISTS Registry, HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall\Adobe Acrobat 4.0 [ProductId], !EXISTS [.Detect.n] Section Optional (For more information, read the description below.) The [.Detect.n] sections are similar to the [.Detect] section. All of the lines in a given [.Detect.n] section are ANDed together. The big difference is that the [.Detect.n] sections are ORed together. If any of the [.Detect.n] sections evaluates to TRUE, then the component is detected. If a component uses [.Detect.n] sections, it must not also have a [.Detect] section. The n in the [.Detect.n] sections is a numeric counter starting at 1. There should only be one [.Detect.1] section and one [.Detect.2] section for a given component across all INF files. The syntax for a detail line is the same as the syntax for the [.Detect] section: Type, Object Name, Attributes [SampleApp.Detect.1] File, %SampleAppPath%\SampleApp.exe, VERSION("ProductVersion","6.*") [SampleApp.Detect.2] File, %SampleAppPath%\SubApp.exe, VERSION("ProductVersion","* 3.*") [.Instructions] Section Required (see notes) Only one per component section Unique for given component across INF files The [.Instructions] section provides the INF rules used to migrate the state for the component. The standard INF commands are used in the [.Instructions] section (for more information, see "INF Commands"). Each command will list a section of registry objects or file objects that the command acts on. It is recommended that these section names begin with the component name they belong to. This is a convention, not a requirement, but it improves the maintenance and readability of the INF files. The [.Instructions] section is not executed if the component is not detected via the [.Detect] section or the [.Detect.n] sections. If the component does not have a [.Detect] section or any [.Detect.n] sections, it is assumed to be detected, and the [.Instructions] section is always executed (even if the component is not installed). The [.Instructions] section is required for a component, but not for an INF file. The syntax for a detail line is: INFCommand = Component.SectionName Parameters INFCommand  Any of the INF commands listed under "INF Commands" in this document. Component SectionName  Any valid INF section name. By convention the format of the name is Component.INFCommand. There must be a matching section in the INF file that contains the command details. [Acrobat Reader 40.Instructions] DestDelReg = Acrobat Reader 40.DestDelReg AddReg = Acrobat Reader 40.AddReg [Acrobat Reader 40.DestDelReg] HKR\Software\Adobe\Acrobat Reader\4.0\AdobeViewer [AllowOpenFile] [Acrobat Reader 40.Addreg] HKR\Software\Adobe\Acrobat Reader\4.0\AdobeViewer [AllowOpenFile] [Copy This State] Section Required (see notes) Only one per INF Combined across INFs The [Copy This State] section lists the INF commands used to migrate individual state. It is the equivalent to the [.Instructions] section, but for individual state instead of component state. The standard INF commands are used in the [Copy This State] section (for more information, see "INF Commands"). Each command will list a section of registry objects or file objects that the command acts on. The [Copy This State] section is always executed when in the INF file. The [Copy This State] section is required for individual state, but not for an INF file. The syntax for a detail line is: INFCommand = SectionName Parameters INFCommand  Any of the INF commands listed under "INF Commands" in this document. SectionName  Any valid INF section name. There must be a matching section in the INF file that contains the command details. The section names must be unique across all INF files. If not, they are combined with similarly named sections. [Copy This State] CopyFiles = SampleCopyFileSection [SampleCopyFileSection] DIR = C:\Data\* *.FSW, %CSIDL_PERSONAL% [Disabled Components] Section Optional (see notes) Only one per INF file Combined across INF files This section is not used in any of the shipping INF files. This section has only one main purpose: to disable the migration of Network Printers and Mapped Drives. The [Disabled Components] section lists the section names that must be  turned off  or not used. This section does override the [Copy This State] section, and the [.Instructions] section.  The syntax for a detail line is: SectionName Parameters SectionName  Any valid INF section name. There must be a matching section in the INF file that contains the command details. The section names must be unique across all INF files. If not, they are combined with similarly named sections. [Disabled Components] Net Printers and Drives [RemapEnvVar] Section Optional (see notes) Only one per INF file Combined across INF files This section is not used in any of the shipping INF files. This section has only one main purpose: to control the re-mapping and re-rooting of folders during migration. The [RemapEnvVar] section provides a way to indicate which environment variables must be considered for re-mapping and re-rooting during migration. Normally, only  known roots  like CSIDLs are used for this. By using the [RemapEnvVar] section and an environment variable, you can create new  known roots. The syntax for a detail line is: EnvironmentVariable Parameters EnvironmentVariable Any valid environment variable defined on both the source and destination system. It must not be enclosed in percent signs (%) as is normally done with environment variables. The [RemapEnvVar] sections are combined across all INF files used. [RemapEnvVar] CDATA This is an example of using [RemapEnvVar] with the two most common methods. [RemapEnvVar] CDATA MYSTUFF [Copy This State] CopyFiles = RemapExample [RemapExample] DIR = %CDATA%\* DIR = %MYSTUFF%\*, %CSIDL_PERSONAL% First, examine CDATA. On the source computer CDATA is defined as  C:\DataFiles . On the destination computer it is defined as  C:\Documents and Settings\All Users\My Documents\Data . This section of the INF file copies all files and folders in  C:\DataFiles  on the source computer, and places them in  C:\Documents and Settings\All Users\My Documents\Data , preserving the folder structure under  C:\DataFiles . For example,  C:\DataFiles\TrpRpt\Fabrikam.doc  becomes  C:\Documents and Settings\All Users\My Documents\Data\TrpRpts\Fabrikam.doc MYSTUFF is an example of creating a larger known root used in path substitution. In the example above, MYSTUFF is defined as  C:\MyStuff  on the source computer, and as  C:\My Stuff  on the destination computer. Normally, with a rule like  DIR = C:\MyStuff, %CSIDL_PERSONAL%  is the largest known root. So, if, on the source, there is  C:\MyStuff\TrpRpt\Fabrikam.doc , it becomes  C:\Documents and Settings\<UserName>\My Documents\MyStuff\TrpRpt\Fabrikam.doc . By using the [RemapEnvVar] section,  C:\MyStuff  becomes the largest known root, resulting in  C:\Documents and Settings\<UserName>\My Documents\TrpRpt\Fabrikam.doc. [Strings] Section Optional Only one per INF file Combines across INF files The [Strings] section defines the string variables used in the INF file. The [Strings] section is combined across all INF files used, so each string variable must be unique across INF files. The syntax for a detail line is: StringVariable =  String Value Parameters StringVariable A variable name unique across all used INF files. It must also be unique from [.Environment] variables and system environment variables. It must begin with a letter. String Value The value for the variable. [Strings] acroread40 = "Adobe Acrobat Reader" Types, Object Names, and Attributes Type can be any of the following: Description Directory Refers to any folder (local or on the network). Refers to any file (local or on the network). INIFile Refers to a value in a specified INI file. Registry Refers to a registry tree, key, or value. System Refers to the operating system. Object Name is specific to the Type as follows: Meaning of Object Name Directory A standard UNC or DOS path  Prototype: <Drive>:\Folder \\ServerName\Share\Folder Example: Directory, %CSIDL_PERSONAL%\TripRpts The full path and file name of a file. Prototype: <Drive>:\Folder\Filename.ext \\ServerName\Share\Folder\Filename.ext Example: File, %CSIDL_PERSONAL%\TripRpts\Fabrikam.doc INIFile registry  value stored in an INIFile Prototype: <Drive>:\Folder\sample.ini/section/key \\ServerName\Share\Folder\sample.ini/section/key Example: IniFile, %WINDIR%\myapp.ini/Settings/DataFolder Registry A registry tree, key, or value Prototype: RegistryRoot\RegistryKey [SettingName] Example: Registry, HKR\Software\MyApp\UserInfo [UserID]  Open and closed square brackets ([]) denote the (Default) value. System Version of operating system Prototype: OS.Version Name OS.Version Name can be any of the following: OS.Version Name for a Single OS Version Meaning 9X.Windows 95.Gold Windows 95 Gold 9X.Windows 95   OSR2.Gold Windows 95 OSR2 9X.Windows 98.Gold Windows 98 Gold 9X.Windows 98.Second Edition Windows 98 Second Edition 9X.Windows Millennium.Gold Windows Millennium Gold NT.Windows NT4.Gold Windows NT 4 Gold NT.Windows 2000.Gold Windows 2000 Gold NT.Windows 2000.XP Windows XP OS.Version Name for OS Family Groupings Meaning 9X.Windows 95 Windows 95 Gold and OSR2 9X.Windows 98 Windows 98 Gold and Second Edition All versions of Windows 95/98/Millennium NT.Windows 2000 Windows 2000 and Windows XP All versions of Windows NT/2000/XP Object Name can include system environment variables, CSIDLs, [Component.Environment] variables, and string variables. Attribute can be one of the following for any Type (except as noted below): Attribute Value Exists Evaluates to TRUE if Object Name exists. Applies to: Registry, Directory, System, File, INIFile SameObjectName(ObjName) Evaluates to TRUE if ObjName extends out to be equal to Object Name. Applies to: Registry, Directory, File, INIFile SameObjectContent(ObjName) Evaluates to TRUE if the content of ObjName equals the content of Object Name. Applies to: Registry, INIFile Matches(Value) Evaluates to TRUE if value equals the content of Object Name. Applies to: Registry, INIFile Version(Field, Pattern) Evaluates to TRUE if the version number of the FILE object to which Object Name points matches the version specified. Field indicates the name of the field that contains the version information. Pattern indicates the string pattern to match. Wildcards can be used in Pattern. Applies to: File, Registry If it is a Registry object, its value must point to a file. INF Commands Overview These are the INF commands used to indicate what state to migrate and how. With these commands you can migrate files, folders, registry trees, keys, and values. During migration these items can be renamed or moved to a new location. These are the core commands of the migration INF files. INF commands are used in [Copy This State] and [Component.Instructions] sections. The syntax for a detail line is: INFCommand = UniqueSectionName Parameters INFCommand  Any one of the INF commands listed below. UniqueSectionName  The section name with the details for the INF command. It must be unique across all INF files. If it is part of the component, it must follow the naming convention Component.INFCommand, although it is not required. The information about what the INF command specifically acts on is contained in the details section for that INF command. A single INF command can have multiple defined detail sections (one per line). [Copy This State] CopyFiles = SampleCopyFileSection CopyFiles = InHouseFileTypes [SampleCopyFileSection] DIR = C:\Data\* [InHouseFileTypes] *.nat *.ell File Commands File commands handle migrating folders, file types, and individual files. Migrated shortcuts to files which are relocated during migration are corrected to point to the new file location. By default, all local drives are scanned, but rules can be drive-specific, or even folder-specific. It is recommended that you change partitions between the source computer and destination computer. Wildcards Wildcards are supported where * is any number of characters (including 0) and ? is any single character. (The wildcards follow the general usage rules of MS-DOS.) Dealing With Folders When a detail section is referring to a folder, the line needs to start with DIR =. File Collision If a file is migrated to the destination and another file already exists on that destination, they collide. If the files are the same, the source file is discarded (because the destination is the same). If the files are not the same, and neither of the special file rules, ForceDestFile or ForceSrcFile, are used, then the file is renamed, appending an   at the end, where n is a numeric counter starting with 1. Usage Of Variables System environment variables, [Component.Environment] variables, string variables, and CSIDLs are supported in the detail lines of INF commands. See  Recognized INF Variables  for details on variables automatically supported by USMT. Some examples: [Copy This State] CopyFiles = SampleCopyFileSection [SampleCopyFileSection] DIR = C:\Data\* DIR = C:\Reports DIR = ?:\Stuff\* *.FSW, %CSIDL_PERSONAL% C:\Data\*.doc, %CSIDL_PERSONAL% C:\Data\*\*.xls, %CSIDL_PERSONAL% In the above example, the line  DIR = C:\Data\*  refers to the folder C:\Data and all its subfolders. So, both the folders and all files in those folders will be migrated. The line  DIR = C:\Reports  includes the folder C:\Reports and all files in it, but not the subfolders in C:\Reports. The line  DIR = ?:\Stuff\*  includes the folder \Stuff on the root of any local non-removable drive. For example, if there is a C:\Stuff and a D:\Stuff, both are migrated. The line  *.FSW, %CSIDL_PERSONAL%  refers to any file matching the pattern. The line  C:\Data\*.doc, %CSIDL_PERSONAL%  refers to all files matching the *.DOC pattern in the C:\Data folder. The line  C:\Data\*\*.xls, %CSIDL_PERSONAL%  refers to all files matching the *.XLS pattern in the C:\Data folder or any of its subfolders. CopyFiles CopyFiles includes files or folders in the list of items to migrate. CopyFiles can also have the file or folder re-rooted during migration. Any known portions of the path will automatically be converted. For example, migrating C:\My Documents\reports\sample.doc from a Windows 98 system, the  C:\My Documents  portion is known as %CSIDL_PERSONAL% (My Documents). This would automatically be converted on the Windows XP system to the new My Documents folder, C:\Documents and Settings\UserName\My Documents. So the final file location would be: C:\Documents and Settings\UserName\My Documents\Reports\sample.doc. The syntax for a detail line about files is: Path\Filename.ext, NewRootPath Parameters Path\Filename.ext The file pattern used for the rule. It can contain wildcards, system environment variables, component environment variables, or CSIDLS. It does not require a full path to be given. UNC paths are supported. Examples *.doc, %CSIDL_PERSONAL% %CSIDL_PROGRAMFILES%\*\*.xls, %CSIDL_PERSONAL%\SprdShts mymoney.mny NewRootPath Optional: If used, the file(s) are re-rooted to the new path given. For a managed environment you want to move all of a user intellectual property  files into their profile, specifically to My Documents (%CSIDL_PERSONAL%). The syntax for a detail line about folders is: DIR = Path, NewRootPath Parameters The folder pattern used for the rule. It can contain wildcards, system environment variables, component environment variables, or CSIDLs. UNC paths are supported. Examples DIR = %CSIDL_PERSONAL%\* DIR = ?:\Data\* DIR = C:\Reports, %CSIDL_PERSONAL% NewRootPath Optional. If used, the file(s) are re-rooted to the new path given. For a managed environment, move all of a user intellectual property  files into their profile, specifically to My Documents (%CSIDL_PERSONAL%). Normally, there are multiple detail lines. CopyFilesEx CopyFilesEx is similar to CopyFiles with one exception. CopyFilesEx does not re-root files and folders when a NewRootPath is given. Instead, the files and folders are simply moved directly to that path. For example: Given the CopyFilesEx details of: *.doc, %CSIDL_PERSONAL% and a file on a Windows 98 source of: C:\My Documents\reports\sample.doc the final file location would be: C:\Documents and Settings\UserName\My Documents\sample.doc. Notice that the  reports  subfolder is not preserved. This works similarly for migrating folders. The folder is moved to the given destination, but the internal files and folder structure are preserved. For example: Give the CopyFilesEx details of: DIR=C:\Data, %CSIDL_PERSONAL% and a file and folder structure on the source of: C:\Data C:\Data\expenses.xls C:\Data\TripRpt\Fabrikam.doc The final file and folder structure would be: C:\Documents and Settings\UserName\My Documents\Data C:\Documents and Settings\UserName\My Documents\Data\expenses.xls C:\Documents and Settings\UserName\My Documents\Data\TripRpt\Fabrikam.doc The syntax for a detail line about folders is: Path\Filename.ext, NewtPath Parameters Path\Filename.ext The file pattern used for the rule. It can contain wildcards, system environment variables, component environment variables, or CSIDLs. It does not require a full path to be given. UNC paths are supported. Examples *.doc, %CSIDL_PERSONAL% %CSIDL_PROGRAMFILES%\*\*.xls, %CSIDL_PERSONAL%\SprdShts NewPath Optional. If used, the file(s) are written to the new path given. For a managed environment, move all of a user intellectual property  files into their profile, specifically to My Documents (%CSIDL_PERSONAL%). The syntax for a detail line about folders is: DIR = Path, NewtPath Parameters The folder pattern used for the rule. It can contain wildcards, system environment variables, component environment variables, or CSIDLs. UNC paths are supported. Example DIR = C:\Reports, %CSIDL_PERSONAL% NewRootPath Optional. If used, the file(s) are written to the new path given. For a managed environment, move all of a user intellectual property  files into the user profile, specifically to My Documents (%CSIDL_PERSONAL%). Normally, there are multiple detail lines. If the file or folder is not moved to a new location, then use CopyFiles instead of CopyFilesEx. DelFiles This does not actually delete any file and is safe to use. DelFiles excludes files from migration. A common use of this command is to exclude temporary files from folders included in the migration. For example, assuming %CSIDL_PERSONAL% is migrated (which it is by default), including a DelFiles rule to exclude %CSIDL_PERSONAL%\*\*.tmp would exclude all *.tmp files in the My Documents folder hierarchy from migration. The syntax for a detail line about folders is: Path\Filename.ext Parameters Path\Filename.ext The file pattern used for the rule. It can contain wildcards, system environment variables, component environment variables, or CSIDLs. It does not require a full path to be given. UNC paths are supported. Examples *.tmp %CSIDL_PERSONAL%\*\*.tmp NewRootPath Optional. If used, the file(s) are re-rooted to the new path given. For a managed environment, move all of a user intellectual property  files into the user profile, specifically to My Documents (%CSIDL_PERSONAL%). The syntax for a detail line about folders is: DIR = Path Parameters The folder pattern used for the rule. It can contain wildcards, system environment variables, component environment variables, or CSIDLs. UNC paths are supported. Example DIR = %CSIDL_INTERNET_CACHE%\* Normally, there are multiple detail lines. ForceSrcFile ForceSrcFile is a special command. By itself it does not affect whether a file or folder is migrated. It checks whether a file is migrated,and if there is already a file with the same name of the destination, it determines how to handle the name collision. When ForceSrcFile is used, the file from the source will overwrite the destination file. The syntax for a detail line about files is: Path\Filename.ext Parameters Path\FileName.ext The file pattern used for the rule. It can contain wildcards, system environment variables, component environment variables, or CSIDLs. It does not require a full path to be given. UNC paths are supported. The syntax for a detail line about folders is: DIR = Path Parameters The folder pattern used for the rule. It can contain wildcards, system environment variables, component environment variables, or CSIDLs. UNC paths are supported. Important Because this can lead to data loss on the destination (for example, if the destination file had valid data in it), it is recommended that you use this command only in extreme cases. Also, because this command is rarely used, most often there is only one detail line in the section, although it does support multiple lines. ForceDestFile ForceDestFile is a special command. By itself it does not affect whether a file or folder is migrated. It checks whether a file is migrated,and if there is already a file with the same name of the destination, it determines how to handle the name collision. When ForceDestFile is used, the file from the source will be discarded. It will not be given a new name as normally happens with file collision, nor will it overwrite the destination file. The syntax for a detail line about files is: Path\Filename.ext Parameters Path\Filename.ext The file pattern used for the rule. It can contain wildcards, system environment variables, component environment variables, or CSIDLs. It does not require a full path to be given. UNC paths are supported. The syntax for a detail line about folders is: DIR = Path Parameters The folder pattern used for the rule. It can contain wildcards, system environment variables, component environment variables, or CSIDLs. UNC paths are supported. Important Because this can lead to data loss, it is recommended that you use this command only in extreme cases. Also, because it is rarely used, most often there is only one detail line in the section, although it does support multiple lines. Registry Commands Registry commands handle the migration of registry trees, keys, and values. They can also handle the migration of files, folders, or icons that a registry value points to. By default, all of HKey_Current_User is migrated by the command-line tools, except for the registry trees, keys, and values excluded. Using /x /s /f /u will cause only included registry trees, keys, and values to be migrated. Wildcards Wildcards are supported. * refers to any number of characters (including 0). ? is any single character. Registry Collision When a registry tree, key, or value is migrated, and it already exists on the destination, the registry items collide. If neither of the special commands ForceDestReg or ForceSrcReg are used, then the destination value is overwritten with the source value. Usage Of Variables System environment variables, [Component.Environment] variables, string variables, and CSIDLs are supported in the detail lines of INF commands. [Copy This State] AddReg = SampleAddRegSection [SampleAddRegSection] HKR\Software\MyCompany\MyApp\Settings\* HKLM\Software\MyCompany\MyApp\Settings [HighScore] HKR\Software\MyCompany\MyApp\Profiles [] In the above example, the line  HKR\Software\MyCompany\MyApp\Settings\*  says to migrate the registry tree starting with HKEY_CURRENT_USER\Software\MyCompany\MyApp\Settings. The line  HKLM\Software\MyCompany\MyApp\Settings [HighScore]  says to migrate the specific value HighScore from the registry key HKEY_LOCAL_MACHINE\Software\MyCompany\MyApp\Settings. The link  HKR\Software\MyCompany\MyApp\Profiles []  says to migrate the default value for the key HKEY_CURRENT_USER\Software\MyCompnay\MyApps\Profiles. AddReg AddReg includes registry trees, keys, or values in what is migrated. The syntax for a detail line is: RegRoot\RegKey\RegSubKey [RegValue] Parameters RegRoot Can be either HKLM for HKey_Local_Machine or HKR for HKey_Current_User. RegKey\RegSubKey Any combination of registry keys and subkeys. RegValue Optional. This is a specific registry value in the given key. For the (Default) value of a key, use opening and closing square brackets ([]). Normally, there are multiple detail lines. RenReg RenReg, like AddReg, adds a registry tree, key, or value to the list of objects to migrate, but it also provides a way to move that registry tree, key, or value to a new location. The syntax for a detail line is: RegRoot\RegKey\RegSubKey [RegValue] = NewRegPath Parameters RegRoot Can be either HKLM for HKey_Local_Machine or HKR for HKey_Current_User. RegKey\RegSubKey Any combination of registry keys and subkeys. RegValue Optional: This is a specific registry value in the given key. For the (Default) value of a key, use opening and closing square brackets ([]). NewRegPath Is the registry tree that includes items matching the left side pattern. The wildcard items are preserved, but the specifically called out items (aside from value) are replaced with the new path. Example HKLM\Software\MyApp\Profiles\* = HKR\Software\MyComp\MyApp\Profiles This will move all registry trees, keys, and values in the HKLM profiles tree to the HKR profiles tree preserving their internal structure. Sometimes there are multiple detail lines. DelReg DelReg excludes registry trees, keys, or values in what is migrated. The syntax for a detail line is: RegRoot\RegKey\RegSubKey [RegValue] Parameters RegRoot Can be either HKLM for HKey_Local_Machine or HKR for HKey_Current_User. RegKey\RegSubKey Any combination of registry keys and subkeys. RegValue Optional. This is a specific registry value in the given key. For the (Default) value of a key, use opening and closing square brackets ([]). Normally, there are multiple detail lines. RegFile RegFile is very similar to AddReg. It is used to include registry trees, keys, or values in what is migrated. The added feature of RegFile is that if the registry key points to a file, that file is also migrated. The normal automatic path repair is done (as explained in CopyFiles) on the file s path. Those changes are also reflected in registry value. Also, like CopyFiles, you can use RegFile to re-root a file (for more information, see "Re-rooting"). The syntax for a detail line is: RegRoot\RegKey\RegSubKey [RegValue] = NewRegPath, NewRootPath Parameters RegRoot Can be either HKLM for HKey_Local_Machine or HKR for HKey_Current_User. RegKey\RegSubKey Any combination of registry keys and subkeys. RegValue  Optional. This is a specific registry value in the given key. For the (Default) value of a key, use opening and closing square brackets ([]). NewRegPath Optional. Items that match the left side pattern are moved into this registry tree. The wildcard items are preserved, but the specifically called out items (aside from value) are replaced with the new path. Example HKLM\Software\MyApp\Profiles\* = HKR\Software\MyComp\MyApp\Profiles This will move all registry trees, keys, and values in the HKLM profiles tree to the HKR profiles tree, preserving their internal structure. NewRootPath Optional. If used, the file(s) are re-rooted to the new path given. For a managed environment you want to move all of a user intellectual property  files into the user profile, specifically to My Documents (%CSIDL_PERSONAL%). Normally, there are multiple detail lines. RegFolder RegFolder is very similar to RegFile, except that if the registry key points to a folder, the contents of the folder are also migrated. The normal automatic path repair is done (as explained in CopyFiles) on the file's path. Those changes are also reflected in registry value. Also, like CopyFiles, you can use RegFolder to re-root a file (for more information, see "Re-rooting"). The syntax for a detail line is: RegRoot\RegKey\RegSubKey [RegValue], NewRootPath Parameters RegRoot Can be either HKLM for HKey_Local_Machine or HKR for HKey_Current_User. RegKey\RegSubKey Any combination of registry keys and subkeys. RegValue Optional. This is a specific registry value in the given key. For the (Default) value of a key, use opening and closing square brackets ([]). NewRootPath Optional. If used, the file(s) are re-rooted to the new path given. For a managed environment, move all of a user intellectual property  files into their profile, specifically to My Documents (%CSIDL_PERSONAL%). Normally, there are multiple detail lines. RegIcon RegIcon is very similar to AddReg. It is used to include registry trees, keys, or values in what is migrated. The added feature of RegIcon is that if the registry key points to an icon, the icon is also migrated. The icon is extracted and added to a migrated icons file. The registry value is updated to reflect this change. The syntax for a detail line is: RegRoot\RegKey\RegSubKey [RegValue] Parameters RegRoot Can be either HKLM for HKey_Local_Machine or HKR for HKey_Current_User. RegKey\RegSubKey Any combination of registry keys and subkeys. RegValue Optional. This is a specific registry value in the given key. For the (Default) value of a key, use opening and closing square brackets ([]). ForceSrcReg This is the default behavior. ForceSrcReg does not affect anything if a registry tree, key, or value is migrated. If it is migrated and the same value exists on the destination computer, this INF command indicates that the destination computer must be overwritten with the source. This is the default behavior. ForceDestReg ForceDestReg does not affect anything if a registry tree, key, or value is migrated. If it is migrated and the same value exists on the destination computer, this INF command indicates that the value on the source computer must be discarded, and the destination computer must be left as it is. DestDelReg This is a dangerous command, and must be used with extreme caution. Important DestDelReg will delete the registry tree, key, or value specified from the destination computer before any other migration is done. This is a permanent deletion. The main reason for using this command is to enable the migration of default application settings, where the application stores the  default  settings by not having a registry value for them. If the tree on the destination is deleted first, then if the value did exist (with a non-default value set) the  default  will be migrated, because after the migration of the keys, it will be absent. Again, this is a dangerous INF command, and must be used only by advanced users and in extreme cases. It is recommended that you completely back up the operating system on which you test. INI Commands INI commands handle the migration of settings stored in INI files. They can also handle the migration of files, folders, or icons that a setting points to.  Wildcards Wildcards are supported. * refers to any number of characters (including 0). ? is any single character. Setting Collision When a setting is migrated, and it already exists on the destination, they collide. If neither of the special commands, ForceDestIni or ForceSrcIni, are used, then the destination setting is overwritten with the source setting. Usage Of Variables System environment variables, [Component.Environment] variables, string variables, and CSIDLs are supported in the detail lines of INF commands.  [Applications] TestApp, Test Application [TestApp.Environment] TestAppPath = Registry, HKLM\Software\TestApp [AppPath] [TestApp.Instructions] CopyFiles = TestApp.CopyFiles [TestApp.TestApp.CopyFiles] Dir=%TestAppPath%\Library\* Dir=%TestAppPath%\Playlist\* AddIni AddIni includes settings in an INI file in what is migrated. The syntax for a detail line is: INIFileName, Section, Setting Parameters IniFileName This is the file name of the INI file searched. Wildcards are not supported. Section This is the section the setting or settings to migrate are in. Wildcards are supported. Setting This is the specific setting, or settings, to migrate. Wildcards are supported. For example, when all settings in a specific section need to be migrated this can simply be a *. Normally, there are multiple detail lines. The IniFileName does not have to be the same for all lines in the section. RenIni RenIni, like AddIni, adds a setting to the list of objects to migrate, but it also provides a way to move that setting to a new location. The syntax for a detail line is: IniFileName, Section, Setting, DestIniFileName, DestSection, DestSetting Parameters IniFileName This is the file name of the INI file searched. Wildcards are not supported. Section This is the section the setting or settings to migrate are in. Wildcards are supported. Setting This is the specific setting, or settings, to migrate. Wildcards are supported. For example, when all settings in a specific section need to be migrated this can simply be a *. DestIniFileName This is the file name of the INI file the setting is migrated to. Wildcards are not supported. If this is left blank, IniFileName (the source filename) is used. A full path is not required, and if not supplied, the path of the source file is used (although mapped to the new system). DestSection This is the Section the migrated settings are written to. Wildcards are not supported. If this field is left blank, the original Section names are used. If this field is present, settings are written to the specified Section name regardless of their source Section name. DestSetting This is the Setting the migrated setting is written to. Wildcards are not supported. If the field is left blank, the original Setting names are used. If the field is present, settings migrated (via this command) are written to that setting name. When migrating multiple source settings with this RenIni line, leave this field blank. Example C:\Windows\System32\MyApp.ini, Win95 Settings, *,,Settings, This will move all settings in the C:\Windows\System32\MyApp.ini in the Win95 Settings section to the Settings section of a newly created C:\Windows\System32\MyApp.ini on the destination computer. Sometimes there are multiple detail lines. DelIni DelIni excludes settings from what is migrated. The syntax for a detail line is: INIFileName, Section, Setting Parameters IniFileName This is the file name of the INI file searched. Wildcards are not supported. Section This is the section the setting or settings to not migrate are in. Wildcards are supported. Setting This is the specific setting, or settings, to not migrate. Wildcards are supported. For example, when all settings in a specific section need to not be migrated this can simply be a *. Normally, there are multiple detail lines. IniFile IniFile is very similar to AddIni. It is used to include settings in what is migrated. The added feature of IniFile is if the setting points to a file, that file is also migrated. The normal automatic path repair is done (as explained in CopyFiles) on the file s path. Those changes are also reflected in registry value. Also, like CopyFiles, you can use IniFile to re-root a file (for more information, see "Re-rooting"). The syntax for a detail line is: IniFileName, Section, Setting, DestIniFileName, DestSection, DestSetting, NewRootPath, LocationHint Parameters IniFileName This is the file name of the INI file searched. Wildcards are not supported. Section This is the section the setting or settings to migrate are in. Wildcards are supported. Setting This is the specific setting, or settings, to migrate. Wildcards are supported. For example, when all settings in a specific section need to be migrated, this can simply be a *. DestIniFileName This is the file name of the INI file the setting is migrated to. Wildcards are not supported. If this is left blank, IniFileName (the source filename) is used. A full path is not required, and if not supplied, the path of the source file is used (although mapped to the new system). DestSection This is the Section the migrated settings are written to. Wildcards are not supported. If this field is left blank, the original Section names are used. If this field is present, settings are written to the specified Section name regardless of their source Section name. DestSetting This is the Setting the migrated setting is written to. Wildcards are not supported. If the field is left blank, the original Setting names are used. If the field is present, settings migrated (via this command) are written to that setting name. NewRootPath The file is re-rooted to this path. For a managed environment, move all of a user intellectual property  files into the user profile, specifically to My Documents (%CSIDL_PERSONAL%). LocationHint This is a semi-colon (;) separated list of paths used to find the object if the path provided is incomplete. For example: if you have an INI file containing  arial.ttf  and a LocationHint containing  c:\windows;c:\windows\system32;c:\windows\fonts , USMT will try to find arial.ttf by looking in each of those folders. When searching a path, it treats it as though it were part of the original path, so, for example, when using c:\windows, it would look for c:\windows\arial.ttf. Normally, there are multiple detail lines. See RegFile for a more complete description. IniFolder IniFolder is very similar to IniFile, except that if the setting points to a folder, the contents of the folder are also migrated. The normal automatic path repair is done (as explained in CopyFiles) on the file's path. Those changes are also reflected in the setting. Also, as with CopyFiles, you can use IniFolder to re-root a file (for more information, see "Re-rooting"). The syntax for a detail line is: IniFileName, Section, Setting, DestIniFileName, DestSection, DestSetting, NewRootPath, LocationHint Parameters IniFileName This is the file name of the INI file searched. Wildcards are not supported. Section This is the section the setting or settings to migrate are in. Wildcards are supported. Setting This is the specific setting, or settings, to migrate. Wildcards are supported. For example, when all settings in a specific section need to be migrated, this can simply be a *. DestIniFileName This is the file name of the INI file the setting is migrated to. Wildcards are not supported. If this is left blank, IniFileName (the source filename) is used. A full path is not required, and if not supplied, the path of the source file is used (although mapped to the new system). DestSection This is the Section the migrated settings are written to. Wildcards are not supported. If this field is left blank, the original Section names are used. If this field is present, settings are written to the specified Section name regardless of their source Section name. DestSetting This is the Setting the migrated setting is written to. Wildcards are not supported. If the field is left blank, the original Setting names are used. If the field is present, settings migrated (via this command) are written to that setting name.  NewRootPath The files are re-rooted to this path. For a managed environment, move all of a user intellectual property  files into the user profile, specifically to My Documents (%CSIDL_PERSONAL%). LocationHint This is a semi-colon (;) separated list of paths used to find the object, if the path provided is incomplete. For example: if you have INI file containing  arial.ttf  and a LocationHint containing  c:\windows;c:\windows\system32;c:\windows\fonts , USMT will try to find arial.ttf by looking in each of those folders. When searching a path, it treats it as though it were part of the original path, so, for example, when using c:\windows, it would look for c:\windows\arial.ttf. Normally, there are multiple detail lines. IniIcon IniIcon is very similar to AddIni. It is used to include settings in what is migrated. The added feature of IniIcon is that if the setting points to an icon, the icon is also migrated. The icon is extracted and added to a migrated icons file. The INI setting is updated to reflect this change. The syntax for a detail line is: IniFileName, Section, Setting, DestIniFileName, DestSection, DestSetting,, LocationHint Parameters IniFileName This is the file name of the INI file searched. Wildcards are not supported. Section This is the section the setting or settings to migrate are in. Wildcards are supported. Setting This is the specific setting, or settings, to migrate. Wildcards are supported. For example, when all settings in a specific section need to be migrated, this can simply be a *. DestIniFileName This is the file name of the INI file the setting is migrated to. Wildcards are not supported. If this is left blank, IniFileName (the source filename) is used. A full path is not required, and if not supplied, the path of the source file is used (although mapped to the new system). DestSection This is the Section the migrated settings are written to. Wildcards are not supported. If this field is left blank, the original Section names are used. If this field is present, settings are written to the specified Section name regardless of their source Section name. DestSetting This is the Setting the migrated setting is written to. Wildcards are not supported. If the field is left blank, the original Setting names are used. If the field is present, settings migrated (via this command) are written to that setting name.  Intentionally Empty Field There is an intentionally empty field between DestSetting and LocationHint. LocationHint This is a semi-colon (;) separated list of paths used to find the object, if the path provided is incomplete. For example: if you have an INI file containing  arial.ttf  and a LocationHint containing  c:\windows;c:\windows\system32;c:\windows\fonts , USMT will try to find arial.ttf by looking in each of those folders. When searching a path, it treats it as though it were part of the original path, so, for example, when using c:\windows, it would look for c:\windows\arial.ttf. ForceSrcIni This is the default behavior. ForceSrcIni does not affect anything if a setting is migrated. If it is migrated and the same value exists on the destination computer, this INF command indicates that the destination computer must be overwritten with the source. This is the default behavior. This syntax matches that of AddIni, and should be in terms of the source location. ForceDestIni ForceDestIni does not affect anything if a registry tree, key, or value is migrated. If it is migrated and the same value exists on the destination computer, this INF command indicates that the value on the source computer must be discarded, and the destination computer must be left as it is. This syntax matches that of AddIni, and should be in terms of the source location. Miscellaneous Commands ProcessSection This command tells the INF file to process another section as part of this section. It is an include command for INFs. A common example of its use is if there are two or more high-level components that use the state from the same sub-component (or another component). For example, use this command if the Modem Settings are migrated individually, as part of Dial-Up Networking settings or as part of Internet Browser settings. Instead of defining those settings three times, define them once as Modem Settings, and then include them in both Dial-Up Networking and Internet Browser by using a Process Section command, pointing to Modem Settings in each. Precedence The general rule for precedence is a simple one, the rule that most closely matches the circumstances of the object is the rule that is used. For example, a general CopyFiles rule like  *.doc, %CSIDL_PERSONAL%  is less specific about C:\TripRpt\Fabrikam.doc than a rule like  DIR = C:\TripRpt\* . In this example, Fabrikam.doc would remain in the folder C:\TripRpt on the new computer, instead of being re-rooted to My Documents. However, if there is also a rule saying  C:\TripRpt\*.doc, %CSIDL_PERSONAL%  then it would also be migrated to My Documents. In the case where there are two rules that are equally specific about a file, the rule precedence order for registry rules is: RegFile RegFolder RegIcon RenReg AddReg DelReg The rule precedence order for file rules is: RegFile RegFolder SysFile.inf   EXCLUDE CopyFilesEx CopyFiles DelFiles If two similar rules refer to the same file but with different specifications, the outcome is based on the order in which the rules are encountered. For example, if there is one CopyFiles rule that says  *.doc  and another CopyFiles rule that says  *.doc, %CSIDL_PERSONAL% , the files either are moved or not moved to the My Documents folder as part of the migration, depending on the order in which the rules were encountered. In this case, all of the files handled by these rules would have the same outcome of either being moved or not being moved. The advice on rule precedence is: Keep it simple. t have conflicting rules. Test, test, test. Re-rooting A simple definition of re-rooting is to move the files to a new location, preserving the folder structure. More specifically, the largest known root in the source path is replaced with the new root path provided. Known roots include CSIDLs, system environment variables, and [Component.Environment] variables, plus the default root path (\). In most cases, the largest known path will be the root path of the drive, for example C:\. But sometimes a large root path is found and replaced. Examples CopyFiles rule details: *.doc, %CSIDL_PERSONAL% Source Files These are on a Windows 98 computer. C:\sample1.doc C:\Data\sample2.doc C:\Program Files\Sample Suite\SubApp\sample3.doc C:\My Documents\sample4.doc C:\My Documents\My Pictures\sample5.doc C:\Windows\sample6.doc C:\Windows\System32\sample7.doc Destination and Reasons for Change Sample 1: Largest found root is C:\. It is replaced with %CSIDL_PERSONAL% resulting in a final path of: C:\Documents and Settings\UserName\My Documents\sample1.doc Sample 2: Largest found root is again C:\. It is replaced with %CSIDL_PERSONAL% resulting in a final path of: C:\Documents and Settings\UserName\My Documents\Data\sample2.doc Sample 3: Largest found root is now C:\Program Files, because it is %CSIDL_PROGRAM_FILES%. It is replaced with %CSIDL_PERSONAL% resulting in a final path of: C:\Documents and Settings\UserName\My Documents\Sample Suite\SubApp\sample3.doc Sample 4: Largest found root is now C:\My Documents, because that is %CSIDL_PERSONAL%. That is replaced with %CSIDL_PERSONAL% resulting in a final path of: C:\Documents and Settings\UserName\My Documents\sample4.doc In this case, %CSIDL_PERSONAL% evaluates differently on the source computer, a Windows 98 computer, and the destination computer, a Windows XP computer. This is why the final path is different from the source path, even though they had the same CSIDL root. Sample 5: Largest found root is now C:\My Documents\My Pictures, because that is %CSIDL_MYPICTURES%. This is replaced with %CSIDL_PERSONAL% resulting in a final path of: C:\Documents and Settings\UserName\My Documents\sample5.doc Sample 6: Largest found root is now C:\Windows, because that is %CSIDL_WINDOWS%. This is replaced with %CSIDL_PERSONAL% resulting in a final path of: C:\Documents and Settings\UserName\My Documents\sample6.doc Sample 7: Largest found root is now C:\Windows\System32, because that is %CSIDL_SYSTEM%. This is replaced with %CSIDL_PERSONAL% resulting in a final path of: C:\Documents and Settings\UserName\My Documents\sample7.doc Final Destination Files C:\Documents and Settings\UserName\My Documents\sample1.doc C:\Documents and Settings\UserName\My Documents\Data\sample2.doc C:\Documents and Settings\UserName\My Documents\Sample Suite\SubApp\sample3.doc C:\Documents and Settings\UserName\My Documents\sample4.doc C:\Documents and Settings\UserName\My Documents\sample5.doc C:\Documents and Settings\UserName\My Documents\sample6.doc C:\Documents and Settings\UserName\My Documents\sample7.doc Recognized INF Variables This is a comprehensive list of the variables recognized by the INF files. These variables do not have to be listed in the [RemapEnvVar] section. The INF files will also recognize any environment variables defined in the system, but determining the values of the variables listed here will always be attempted. Some of these variables cannot be determined due to operating system type and version dependencies. Please consult MSDN (http://msdn.microsoft.com/) or Microsoft Visual Studio documentation for additional information concerning CSIDL identifiers. Variable Meaning ALLUSERSPROFILE The folder for the profile of AllUsers. This is where shared documents and shared pictures are. Commonly this is C:\Documents and Settings\AllUsers. APPDATA Same as CSIDL_APPDATA CommonProgramFiles Same as CSIDL_PROGRAM_FILES CSIDL_ADMINTOOLS The folder per-user administrative tools, and customized MMC consoles are stored in. This is part of the current user s profile, and roams as part of roaming user profiles. CSIDL_ALTSTARTUP The folder of the user s nonlocalized startup group CSIDL_APPDATA The folder per-user application specific data is stored. This is part of the current user s profile, and roams as part of roaming user profiles. CSIDL_BITBUCKET The virtual folder representing the Recycle Bin CSIDL_COMMON_ADMINTOOLS The AllUser version of CSIDL_ADMINTOOLS CSIDL_COMMON_ALTSTARTUP The AllUser version of CSIDL_ALTSTARTUP CSIDL_COMMON_APPDATA The AllUser version of CSIDL_APPDATA CSIDL_COMMON_DESKTOPDIRECTORY The AllUser version of CSIDL_DESKTOP CSIDL_COMMON_DOCUMENTS The AllUser version of CSIDL_PERSONAL CSIDL_COMMON_FAVORITES The AllUser version of CSIDL_FAVORITES CSIDL_COMMON_PROGRAMS The AllUser version of CSIDL_PROGRAMS CSIDL_COMMON_STARTMENU The AllUser version of CSIDL_STARTMENU CSIDL_COMMON_STARTUP The AllUser version of CSIDL_STARTUP CSIDL_COMMON_TEMPLATES The AllUser version of CSIDL_TEMPLATES CSIDL_CONTROLS The virtual folder containing icons for the Control Panel applications CSIDL_COOKIES The per-user folder for storing Internet cookies CSIDL_DESKTOP The virtual folder that is the root of the namespace; the Windows Desktop CSIDL_DESKTOPDIRECTORY The per-user folder where desktop items are stored CSIDL_DRIVES My Computer, a virtual folder CSIDL_FAVORITES The per-user folder where favorites are stored CSIDL_FONTS The folder where fonts are stored CSIDL_HISTORY The per-user folder where the IE history is stored CSIDL_INTERNET The virtual folder representing the Internet CSIDL_INTERNET_CACHE The per-user folder that is the Internet cache CSIDL_LOCAL_APPDATA The folder where per-user application-specific data is stored. This is part of the current user s profile, but does not roam as part of roaming user profiles. CSIDL_MYMUSIC The per-user folder for storing music CSIDL_MYPICTURES The per-user folder for storing pictures CSIDL_MYVIDEO The per-user folder for storing video CSIDL_NETHOOD The per-user folder where network link objects are stored CSIDL_NETWORK The virtual folder representing the network CSIDL_PERSONAL The per-user folder for My Documents CSIDL_PRINTERS The virtual folder containing installed printers CSIDL_PRINTHOOD The per-user folder storing printer link objects CSIDL_PROFILE The profile path for the user currently logged in CSIDL_PROGRAM_FILES The Program Files folder CSIDL_PROGRAM_FILES_COMMON The folder for components shared across programs CSIDL_PROGRAMS The per-user folder containing a user s programs group in the Start Menu CSIDL_RECENT The per-user folder with links to recently used files CSIDL_SENDTO The per-user folder containing Send To items CSIDL_STARTMENU The per-user folder representing the Start Menu CSIDL_STARTUP The per-user folder representing the Startup group CSIDL_SYSTEM The Windows system folder, commonly C:\Windows\System32 CSIDL_TEMPLATES The per-user folder for Templates CSIDL_WINDOWS The same as SYSTEMROOT or WINDIR PROFILESFOLDER The folder where all the profiles are stored ProgramFiles Same as CSIDL_PROGRAM_FILES SYSTEM The primary system folder under Windows (System on Win9x, and System32 on NT systems) SYSTEM16 The System folder under Windows SYSTEM32 The System32 folder under Windows SYSTEMROOT The path to the Windows installation The folder user for temporary storage Same meaning as TEMP USERPROFILE Same as CSIDL_PROFILE WINDIR The path to the Windows installation The Default INFs and Their Components/Applications Migsys.inf Migsys.inf contains settings related to the operating system. The components in this file are: Accessibility Options Classic Desktop (pre-Luna look & feel) Display Properties Folder Options Fonts Internet Options Localization / International Settings Mouse and Keyboard ODBC Data Source Names Outlook Express Screen Saver Selection Sounds and Multimedia Taskbar These components are listed in the [System Settings] section in Migsys.inf. To disable the migration of any of these settings, insert a semicolon (;) before the line that lists the setting group you want to disable. This is an example of disabling the migration of Mouse and Keyboard. [System Settings] Accessibility, %accessibility% Fonts,, dir, %csidl_fonts% ;Mouse and Keyboard, %mouse_and_keyboard% Browser, %internet_settings% International, %International% Multimedia, %Multimedia% Outlook Express, %outlook_express% Display, %display% ScreenSaver, %screensaver% FolderOptions, %folderoptions% TaskBar, %taskbar% Classic, %classic% Notice the semicolon in front of the fourth line. This will cause USMT to ignore this line.  In order not to migrate any of these settings, do not include this INF on the command line. (For more information, see "Take All vs Take Known.") The INF rules for components (like Mouse and Keyboard) can modify the settings that are migrated. To comment out a line, add a semicolon in front of it. Miguser.inf Miguser.inf contains settings more specifically related to users. The components in this file are: Desktop  Favorites My Pictures My Documents Shared Desktop Shared Documents Shared Favorites Shared Start Menu Items Start Menu Items These components are listed in the [User Settings] section in Miguser.inf. To disable the migration of any of these settings, insert a semicolon (;) before the line that lists the setting group that you want to disable. Below is an example of disabling the migration of Start Menu Items. [User Settings] Desktop Items,, dir,%csidl_desktopdirectory% Shared Desktop Items,, dir,%csidl_common_desktopdirectory% ;Start Menu Items,, dir,%csidl_startmenu% Shared Start Menu Items,, dir,%csidl_common_startmenu% Favorites,, dir,%csidl_favorites% Shared Favorites,, dir,%csidl_common_favorites% My Pictures,, dir,%csidl_mypictures% My Documents,, dir,%csidl_personal% Shared Documents,, dir,%csidl_common_documents% Notice the semicolon in front of the fourth line. This will cause USMT to ignore this line.  In order not to migrate any of these settings, do not include this INF on the command line. (For more information, see "Take All vs Take Known.") The INF rules for components (like Start Menu Items) can modify the settings that are migrated. To comment out a line, add a semicolon in front of it. Migapp.inf Migapp.inf contains settings more specifically related to users. The components in this file are: Access 2000 Access 97 Access XP Acrobat Reader 4.0 Acrobat Reader 5.0 Adobe Photoshop Suite 6 BattleCom Command Prompt CuteFTP Eudora 5 Excel 2000 Excel 97 Excel XP FrontPage XP FrontPage  2000 GameVoice 1 GetRight 4 GoZilla Lotus SmartSuite Microsoft Office Money 2001 MSN Messenger MSN Zone  Explorer Music Match Jukebox Netmeeting Odigo Outlook 97 & 98 Outlook XP Outlook  2000 PhotoDraw  2000 PowerPoint 97 PowerPoint XP PowerPoint  2000 Prodigy Internet Publisher 2000 Publisher XP Quicken 2001 Quicken 2001 Home & Business QuickTime Player 5 RealJukebox 2 RealPlayer 8 Basic RogerWilco Sonique WinAmp Windows Media Player Windows Messenger Windows Movie Maker WinZip Word 2000 Word 97 Word XP WordPerfect Office 2000 Works 2001 WS_FTP LE 5 Yahoo Messenger These components are listed in the [Applications] section in Migapp.inf. To disable the migration of any of these settings, insert a semicolon (;) before the line that lists the setting group that you want to disable. Below is an example of disabling the migration of Adobe Photoshop Suite 6. [Applications] Acrobat Reader 40, %acroread40% Acrobat Reader 50, %acroread50% ;Adobe Photoshop Suite 6, %photoshop6% AIM, %AIM% BattleCom, %battlecom% CmdExe, %cmdexe% CuteFTP 4, %cuteftp4% Notice the semicolon in front of the fourth line. This will cause USMT to ignore this line.  In order not to migrate any of these settings, do not include this INF on the command line. (For more information, see "Take All vs Take Known.") The INF rules for components (like Adobe Photoshop Suite 6) can modify the settings that are migrated. To comment out a line, add a semicolon in front of it. Sysfiles.inf This is a list of files that must not be migrated despite any other rules. These are operating system files that will conflict with the newer version of the files on Windows XP. SysFiles.INF file should not be modified. The only modification that you might want to make is to add more files to the list of files that never migrate under any circumstances. Migwiz.inf Migwiz.inf is the primary INF file for the FASTWiz GUI. It is discussed in detail later in this document. Migration.inf Migration.inf is created by Scanstate. It contains much of the state collected on the source computer. Migration.inf is stored in the destination location provided on the command line. Files and Settings Transfer Wizard INF and Migwiz.inf [CopyFiles] The list of files placed onto the wizard disc that FASTWiz creates. If you create a new INF for the GUI to use during the migration, the INF must be included in this list. Add the file name in a separate line. [OOBE] Reserved for future use. [Settings Only] The components transferred when the user selects Settings Only, regardless of transport. [Settings Only.Ext] The components transferred when the user selects Settings Only, and the transport is not floppy. [Files Only] The components transferred when the user selects Files Only, regardless of transport. [Files Only.Ext] The components transferred when the user selects Files Only, and the transport is not floppy. [Files And Settings] The components transferred when the user selects Files And Settings, regardless of transport. [Files And Settings.Ext] The components transferred when the user selects Files And Settings, and the transport is not floppy. [Screened Extensions] These are file types that the user does not transfer when the list of File Types to add is displayed. If the user manually adds the file type by using the edit box, the file type will be transferred (unless blocked by Sysfiles.inf). [EXT.IgnoreEXE] FASTWiz will automatically include most registered file types when the user selects Files Only or Files and Settings. If the type handler is one of these executables, then it is not included as a default type to transfer. [EXT.Exclude] Regardless of registration, these File Types are not added to the list of items to migrate by default. However, the user can still manually add them. If the File Types are also listed in Sysfiles.inf, they will not be migrated, regardless of what the user does. [EXT.Include] These file types are included in the default items to migrate, regardless of whether they are registered. The user can manually remove them. [AppsToInstallOnDest] Applications listed here need to be installed on the destination computer before the settings are applied. The user will be warned at the end of the scan to ensure that these applications are installed on the destination computer first. The user is also warned on the apply side that the applications must be installed before applying the settings. In most cases, if the application is installed later to the same location where it was installed on the former computer, it will still work. However, this behavior is not reliable. Migration.inf   The Command-Line State Store The Migration.inf is created by Scanstate and holds most of the migrating settings. In general, it must not be modified. It most often includes the sections listed below. For debugging issues, check what is stored in the Migration.inf to ensure that the state was scanned correctly. [Version] [Environment] [Object Types] [Data] [Registry] [File] [Cookies] [Printers] [RasConnection] [MappedDrives] Command-Line Parameters And Usage USMT consists of two command-line tools and the FASTWiz GUI tool. This section discusses the command-line parameters and usage of Scanstate.exe and Loadstate.exe. Scanstate.exe is used to collect the user s state (files and settings) from the former computer and installation. Loadstate.exe applies the user state collected by Scanstate.exe on the new computer and installation. These tools are located on the Windows XP CD in the ValueAdd\MSFT\USMT folder. Unicode or ANSI There are Unicode and ANSI versions of Scanstate.exe tools. The Unicode version is for scanning NT-based systems (Windows NT, Windows 2000, and Windows XP), and is located in ValueAdd\MSFT\USMT. The ANSI version is for scanning 9x-based systems (Windows 95, Windows 98, and Windows ME), and is located in ValueAdd\MSFT\USMT\ANSI. Internet Explorer version 4.0 or later must be installed with either the Unicode or the ANSI version. Regardless of which version of Scanstate.exe is used, the Unicode version of Loadstate.exe in ValueAdd\MSFT\USMT must be used to apply the state. Take All vs. Take Known When performing a migration with USMT you can use one of two models, Take All or Take Known. These refer to the user s registry (HKEY_CURRENT_USER). The recommended solution is to use the Take Known model. In the Take All model, HKEY_CURRENT_USER is migrated in its entirety, aside from rules in the INFs to exclude certain portions. Advantages Disadvantages Many settings for non-supported applications are also migrated successfully. More like the upgrade experience. Less controlled migration. Garbage in HKEY_CURRENT_USER is also migrated. Risk of some applications not working correctly due to invalid settings for the new environment. In the Take Known model, the only parts of HKEY_CURRENT_USER that are migrated are the ones indicated by the INFs. Advantages Disadvantages Controlled Migration. Highly unlikely to break anything. INFs must be customized to handle applications not supported by default. Suggested Command-Lines Remember:  Scanstate must be run by the user who is migrating. Loadstate must be run by a user with local administrator access who is not the user who is migrated. The user s profile must not exist on the destination computer before running Loadstate.exe. Take Known Model (Recommended) Scanning: Scanstate \\ServerName\Share\Folder /I miguser.inf /I migapp.inf /I migsys.inf /I sysfiles.inf /v 7 /x /s /f Applying: Loadstate \\ServerName\Share\Folder /v 7 Take All Model Scanning: Scanstate \\ServerName\Share\Folder /I miguser.inf /I migapp.inf /I migsys.inf /I sysfiles.inf /v 7 Applying: Loadstate \\ServerName\Share\Folder /v 7 Command-Line Parameters Scanstate Parameter Meaning Invokes Help. /i filename.inf Specifies an INF file containing rules that define what state to migrate. Multiple /i parameters can be used. /l logfile.txt Specifies a path and file name to save the log to. By default the log is saved in CSIDL_LOCAL_APPDATA\scanstate.log. /v <Verbosity> Specifies the level of detail used in the log. Use 0 (default) for least detail. Use 7 for most detail. Specifies that no settings or files be migrated by default. Specifies that settings listed in the INFs be migrated.  System  elements are also migrated. These are Network Printers, RAS Connections, and Cookies. Specifies that files listed in the INFs be migrated. Enables collection of the entire HKEY_CURRENT_USER by default. (Scanstate.exe should use the Take Known model.) Specifies to continue when encountering an error that can be ignored. (An error code is still returned.) Pre-Scan the system to determine how much storage space will be needed. It generates a space estimate file (USMTsize.txt) instead of an actual store. The file is a tab-delimited file with two columns. The first column is block size, and the second is how many bytes are required at that block size. The first line of the file is the numbers for the store location indicated on the command-line. /md <domain name> Provides an easy way to change the domain name during migration. If after the migration the user will be part of a different domain, this is an easy way to provide the domain the user should be created in. /mu <user name> Provides an easy way to change the user s logon name during migration. If after the migration the user will have a new logon name, this is an easy way to change it so the user is created with the correct logon name. If there is already a migration store at the indicated target location, the store is overwritten without warning. If /x, /f, /s, and /u are not used on the command-line, the default is /f /s /u. /x is ignored if /f /s /u are also used. Loadstate Parameter Meaning Invokes Help. /i filename.inf Specifies an INF file containing rules that define what state to migrate. Multiple /i parameters can be used. /l logfile.txt Specifies a path and file name to save the log to. By default the log is saved in CSIDL_LOCAL_APPDATA\scanstate.log. /v <Verbosity> Specifies the level of detail used in the log. Use 0 (default) for least detail. Use 7 for most detail. Specifies that no settings or files be migrated by default. Specifies that settings listed in the INFs be migrated. Specifies that files listed in the INFs be migrated. Enables collection of the entire HKEY_CURRENT_USER by default. (Scanstate.exe should use the Take Known model.) /md <domain name> Provides an easy way to change the domain name during migration. If after the migration the user will be part of a different domain, this is an easy way to provide the domain the user should be created in. /mu <user name> Provides an easy way to change the user s logon name during migration. If after the migration the user will have a new logon name, this is an easy way to change it so the user is created with the correct logon name. Loadstate migrated settings to the current user. The migrated user is not created, and administrator rights are not required.  WARNING: This will have slightly different results than running from administrator mode.  For example, security can prevent some settings or files from being restored. Also, the /md and /mu switches are ignored. If /x, /f, /s, and /u are not used on the command-line, the default is /f /s /u. /x is ignored if /f /s /u are also used. Return Codes and Logs Scanstate.exe and Loadstate.exe return 0 if successful. A value other than 0 means there was an error. The common Windows error codes are used. You can use a tool like Error Lookup (included with Visual Studio) to learn more details on specific error codes. USMT (command-line) logs are stored in %CSIDL_LOCAL_APPDATA% for the user running the tool. On a Windows XP system, this is usually C:\Documents and Settings\UserName\Local Settings\Application Data. The Scanstate.exe log file is scanstate.log. The Loadstate.exe log file is loadstate.log. These logs can be written to other folders and other file names by using the /l switch. FASTWiz logs are also stored in %CSIDL_LOCAL_APPDATA%. The FASTWiz log file is FASTWiz.log. The results displayed on the final page of FASTWiz are stored in FASTWiz.htm. Common Scenarios To Create An INF File Start Notepad (or your preferred text editor). Create a [Version] section. Add the signature line. Create an empty [Applications] section. Create an empty [Copy This State] section. Create an empty [Strings] section. Save the file using an INF extension. To Add A Component List the component in an [Applications] section. Optional: Create a [.Environment] section. Optional: Create a [.Detect] section to detect if the application is installed. Optional: Create [.Detect.n] sections instead. Create a [.Instructions] section listing the rules to do the migration. Create a section for each section referenced in the [.Instructions] section listing the objects to migrate. To Add Individual State Add an INF command to the [Copy This State] section. Create a section for the section named with the INF command in the [Copy This State] section listing the objects to migrate. Summary This document explains the INF files for the User State Migration Tools (USMT), Files and Settings Transfer Wizard (FASTWiz), and the INF commands. It also explains how to perform basic modifications to these files and how to create your own INF files to use with the migration tools. Information Technology (IT) professionals and consultants who customize USMT for Windows XP deployments are the primary audience of this document. The reader is assumed to have a basic understanding of scripting, although no real programming knowledge is required. It is recommended that the reader also be familiar with using a text editor, such as Notepad or Microsoft  Visual Studio For large-scale automated migrations with the User State Migration Tool, IT professionals can refer to User State Migration in Windows XP at, http://www.microsoft.com/windowsxp/pro/techinfo/howitworks/userstate. PAGE   Windows XP White Paper  User State Migration Tool   INF Commands   PAGE  Should this be  does not override ?? Checking with Nathan Definition: Re-rooting Re-rooting preserves the folder hierarchy in which the file or folder is located, but places it all in the folder given as the new root. H,I]K 4Y,>RP G(#U% /[MqlHn $kz/7 OkCm~ HX_S? %8H?6S" 5TZhp EeczI t`hdz +Cqqn~jg'O 8X| ) 2hUVIq '||L=d Wlb}) ;mT>i 8b>r 7 |V9!E  $V>6M \^Z*. "UY(r Mj(8H $e|LT> @$H.@ 8\+|D qiF2l,|b |l95, 5%$V>  g+bU Qk>8\+ "d48` =dv@%$J =TB"B^ 4)^Tn qDeD0l 3S,Ot #)HV; bvuww
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\complnce\comptest\readme.txt ===
This test harness helps in testing the compliance
matrix without creating the actual media.

It parses a text file which specifies the matrix
in sections. 

Each section name starts with '[' and ']'. The '#' 
character is used as string separator.

Some well known sections are [type#values], [var#values],
[suite#values] and [error#vaules] etc. These sections 
define keys which can be used in the actual testcase.
For e.g. [type#values] defines "pro=0x40" which indicates
that product type professional's internal representation
using DWORD is 0x40.

The value sections need to be at the start of the
test matrix text file. The other kind of sections 
which can be present in this test case matrix file are
called "Test Sections". These sections contain the actual
test cases.

For e.g.

[test#pro#5.0#2031#none#retail#fpp]
win3x#3.1#950#none#any=typeerr,no
win9x#9.5#950#none#any=none,yes
ntw#3.1#1057#none#any=vererr,no


indicates that the sections is for testing professional, 
version 5.0, build 2031, with not product suites and is
of type FPP retail variation. Each line in this section 
indicates the target platform for which this media needs
to be tested for upgrade. 

For e.g.

win9x#9.5#950#none#any=none,yes

Indicates that Windows 9X, version 9.5 and build number 950
with no product suites and of type any variation needs to
pass on upgrade with this professional media. 

Another e.g.

ntw#3.1#1057#none#any=vererr,no

Indicates that NT workstation version 3.1, build number 1057,
with no product suites and of type any variation, needs to
fail on upgrade with version error with the given professional
media.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\eulas_etc\sbsonly\export\oemeula.txt ===
This is a legal agreement ("Agreement") between you (either
an individual or an entity), the end user ("Recipient"), and
Microsoft Corporation ("Microsoft"). BY
INSTALLING, COPYING OR OTHERWISE USING THE
PRODUCT (AS DEFINED BELOW), YOU AGREE TO BE
BOUND BY THE TERMS OF THIS AGREEMENT. IF YOU
DO NOT AGREE TO THE TERMS OF THIS AGREEMENT,
DO NOT INSTALL, COPY OR USE THE PRODUCT.

MICROSOFT LICENSE AGREEMENT for Microsoft Windows 2000
Server Pre-Release Code

1.	GRANT OF LICENSE. 

	(a)  Solely for internal testing, Microsoft grants Recipient
a limited, non-exclusive, non-assignable, nontransferable,
royalty-free license to: (i) install and use two (2) copies
of the server software component of the software
accompanying this agreement (the "Product") on computer's
residing on Recipient's premises (a computer running the
server software component of the Product shall be referred
to as the "Server"), and (ii) install and use an unlimited
number of copies of the client software components of the
Product (including any profiles created using the Product),
on client computers residing on Recipient's premises and
connected to a Server. All other rights are reserved to
Microsoft. Recipient shall not rent, lease, sell,
sublicense, assign, or otherwise transfer the Product or any
accompanying printed materials ("Documentation"). Recipient
may not reverse engineer or decompile the Product, except to
the extent that the foregoing restriction is expressly
prohibited by local law. Recipient may not use the Product
in a live operating environment where it may be relied upon
to perform in the same manner as a commercially released
product or with data that has not been sufficiently backed
up. Recipient may not use the Product for benchmark or
performance testing. Microsoft and its suppliers shall
retain title and all ownership rights to the Product, and
this Agreement shall not be construed in any manner as
transferring any rights of ownership or license to the
Product or to the features or information therein, except as
specifically stated herein.

	(b)  At Microsoft's request, Recipient agrees to provide
reasonable feedback to Microsoft, including but not limited
to usability, bug reports and test results, with respect to
the Product testing. In addition, if requested by Microsoft,
Recipient will use reasonable efforts to review and comment
on all documentation supplied. All bug reports, test results
and other feedback made by Recipient shall be the property
of Microsoft and may be used by Microsoft for any purpose it
sees fit. Due to the nature of the development work,
Microsoft is not certain if errors or discrepancies in the
Product may be corrected.

	(c)  Recipient's use of the Product shall take place solely
at Recipient's site. Recipient may not demonstrate or show
the Product to third parties without the express written
permission of Microsoft.

	(d)  The Product may contain Windows NetMeeting, 
technology that enables applications to be shared between 
two or more computers, even if an application is installed 
on only one of the computers. Recipient may use this 
technology (as permitted in Section 1(a) above), with all 
Microsoft application products for multi-party conferences. 
For non-Microsoft applications, Recipient should consult the
accompanying license agreement or contact the licensor to
determine whether application sharing is permitted by the
licensor.

Note Regarding Windows 95 and Windows 98 Client Software.
The Product may include Windows 95 and Windows 98 client
software. This Agreement does not give you any rights to
install or use copies of the Windows 95 or Windows 98
operating systems. You must purchase a separate license to
acquire such rights.

2.	TERM OF AGREEMENT. The term of this Agreement shall
commence upon Recipient's copying, installing or using the
Product and shall continue unless terminated by Microsoft in
writing at any time, with or without cause. This Agreement
will terminate without notice upon the commercial release of
the Product. Upon the termination of this Agreement,
Recipient shall cease use of the Product and, shall, upon
request, promptly return to Microsoft, or certify
destruction of, all full or partial copies of the Product
and related materials provided by Microsoft.

3.	SUPPORT. Microsoft is not obligated to provide technical
or other support for the Product. However, limited technical
support ("Support Services"), if noted in the materials
provided to Recipient by Microsoft, may be available. Use of
any such Support Services is governed by the Microsoft
policies and programs described in "online" documentation,
and/or in other Microsoft-provided materials. Any
supplemental software code provided to Recipient as part of
the Support Services shall be considered part of the Product
and subject to the terms and conditions of this Agreement.
With respect to technical information Recipient provides to
Microsoft as part of the Support Services, Microsoft may use
such information for its business purposes, including for
product support and development. Microsoft will not utilize
such technical information in a form that personally
identifies Recipient. Such limited Support Services may not
be available in all countries outside the United States and
will be discontinued once the Product is commercially
released.

4.	MAINTENANCE. Microsoft is not obligated to provide
maintenance, technical support, or updates to Recipient for
Product licensed under this Agreement. In no event shall
Microsoft be obligated to provide Recipient, free of charge,
a copy of the commercial release version of the Product in
connection with Recipient's participation in the testing
program. Microsoft is not obligated to make the Product
commercially available.

5.	DISCLAIMER OF WARRANTIES. To the maximum extent 
permitted by applicable law, Microsoft and its suppliers 
provide the Product and any (if any) Support Services AS 
IS AND WITH ALL FAULTS, and hereby disclaim all warranties 
and conditions, either express, implied or statutory, 
including, but notlimited to, any (if any) implied warranties 
or conditions of merchantability, of fitness for a particular 
purpose, of lack of viruses, of accuracy or completeness of 
responses, of results, and of lack of negligence or lack of 
workmanlike effort, all with regard to the Product, and the 
provision of or failure to provide Support Services. ALSO,
THERE IS NO WARRANTY OR CONDITION OF TITLE,
QUIET ENJOYMENT, QUIET POSSESSION,
CORRESPONDENCE TO DESCRIPTION OR
NON-INFRINGEMENT, WITH REGARD TO THE PRODUCT.
THE ENTIRE RISK AS TO THE QUALITY OF OR
ARISING OUT OF USE OR PERFORMANCE OF THE
PRODUCT AND SUPPORT SERVICES, IF ANY, REMAINS
WITH YOU. 

6.	EXCLUSION OF INCIDENTAL, CONSEQUENTIAL AND 
CERTAIN OTHER DAMAGES. To the maximum extent permitted 
by applicable law, in no event shall Microsoft or its 
suppliers be liable for any special, incidental, indirect,
or consequential damages whatsoever (including, but not 
limited to, damages for loss of profits or confidential 
or other information, for business interruption, for 
personal injury, for loss of privacy, for failure to 
meet any duty including of good faith or of reasonable 
care, for negligence, and for any other pecuniary or 
other loss whatsoever) arising out of or in any way 
related to the use of or inability to use the Product, 
the provision of or failure to provide Support Services, 
or otherwise under or in connection with any provision 
of Agreement, even in the event of the fault, tort 
(including negligence), strict liability, breach of contract
or breach of warranty of Microsoft or any supplier, and even
if Microsoft or any supplier has been advised of the
possibility of such damages. 

7.	LIMITATION OF LIABILITY AND REMEDIES. 
Notwithstanding any damages that you might incur for 
any reason whatsoever (including, without limitation, 
all damages referenced above and all direct or general 
damages), the entire liability of Microsoft and any of 
its suppliers under any provision of this Agreement and 
your exclusive remedy for all of the foregoing shall 
be limited to the greater of the amount actually paid 
by you for the Product or U.S.$5.00. The foregoing 
limitations, exclusions and disclaimers shall apply 
to the maximum extent permitted by applicable law,
even if any remedy fails its essential purpose.

8.	GOVERNING LAW; ATTORNEYS' FEES. This 
Agreement shall be construed and controlled by the 
laws of the State of Washington and Recipient consents 
to the jurisdiction and venue in the federal courts 
sitting in King County, Washington, unless no federal 
subject matter jurisdiction exists, in which case 
Recipient consents to the jurisdiction and venue in the 
Superior Court of King County, Washington. Recipient 
waives all defenses of lack of personal jurisdiction 
and forum nonconveniens. Process may be served on either 
party in the manner authorized by applicable law or court 
rule. If either Microsoft or Recipient employs attorneys 
to enforce any rights arising out of or relating to this 
Agreement, the prevailing party shall be entitled to
recover reasonable attorneys' fees.

9.	U.S. GOVERNMENT RESTRICTED RIGHTS. 
The Product and Documentation provided to the U.S. 
Government pursuant to solicitations issued on or after 
December 1, 1995 is provided with the commercial rights 
and restrictions described elsewhere herein. Product and 
Documentation provided to the U.S. Government pursuant 
to solicitations issued prior to December 1, 1995 is 
provided with RESTRICTED RIGHTS as provided for in FAR, 
48 CFR 52.227-14 (JUNE 1987) or FAR, 48 CFR 252.227-7013 
(OCT 1988), as applicable.

10.	EXPORT RESTRICTIONS. Recipient agrees that Recipient
will not export or re-export the Product or Documentation to
any country, person or entity subject to U.S. export
restrictions. Recipient specifically agrees not to export or
re-export the Product or Documentation (i) to any country to
which the U. S. has embargoes or restricted the export of
goods or services which currently include but are not
necessarily limited to Cuba, Iran, Iraq, Libya, North Korea,
Sudan and Syria, or to any national of any such country,
wherever located, who intends to transmit or transport the
Product or Documentation back to such country; (ii) to any
person or entity who Recipient knows or has reason to know
will utilize the Product or Documentation in the design,
development or production of nuclear, chemical or biological
weapons; or (iii) to any person or entity who has been
prohibited from participating in U.S. export transactions by
any federal agency of the U.S. government. 

Should you have any questions concerning this Agreement, or
if you desire to contact Microsoft for any reason, please
write: Microsoft Corporation, WWPG Beta Team, One Microsoft
Way, Redmond, WA 98052-6399.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\eulas_etc\sbsonly\export\eula.txt ===
180 DAY LICENSE

This is a legal agreement ("Agreement") between you (either an
individual or an entity), the end user ("Recipient"), and
Microsoft Corporation ("Microsoft").  BY INSTALLING, COPYING OR
OTHERWISE USING THE PRODUCT (AS DEFINED
BELOW), YOU AGREE TO BE BOUND BY THE TERMS OF
THIS AGREEMENT.  IF YOU DO NOT AGREE TO THE
TERMS OF THIS AGREEMENT, DO NOT INSTALL, COPY
OR USE THE PRODUCT.

MICROSOFT LICENSE AND NON-DISCLOSURE
AGREEMENT FOR PRE-RELEASE CODE 

for the Microsoft Product code-named "Whistler" 

   1. GRANT OF LICENSE FOR DUAL DISTRIBUTION. 
      
   (a) Microsoft may provide the software accompanying this
   Agreement (the "Product") as a web-based download or on a
   CD-ROM.  Solely for internal testing, Microsoft grants
   Recipient a limited, non-exclusive, non-assignable,
   nontransferable, royalty-free license to:  (i) install and
   use two (2) copies of the server software component of the
   Product on computers residing on Recipient's premises (a
   computer running the server software component of the
   Product shall be referred to as the "Server"), and (ii)
   install and use an unlimited number of copies of the client
   software components of the Product (including any profiles
   created using the Product), on client computers residing on
   Recipient's premises and connected to a Server.  The
   foregoing server software component limit is aggregate and
   applies regardless of how many copies of the Product
   Recipient obtains from Microsoft.  If Recipient is
   downloading the Product from a Microsoft web site,
   Recipient may make one (1) additional copy of the Product
   onto a CD-ROM to exercise the rights granted above.  All
   other rights are reserved to Microsoft.  Recipient shall
   not rent, lease, sell, sublicense, assign, or otherwise
   transfer the Product or any accompanying printed materials
   ("Documentation").  Recipient may not reverse engineer or
   decompile the Product, except to the extent that local law
   expressly prohibits the foregoing restriction.  Recipient
   may not use the Product in a live operating environment
   where it may be relied upon to perform in the same manner
   as a commercially released product or with data that has
   not been sufficiently backed up.  Recipient may not use the
   Product for benchmark or performance testing.  Microsoft
   and its suppliers shall retain title and all ownership
   rights to the Product, and this Agreement shall not be
   construed in any manner as transferring any rights of
   ownership or license to the Product or to the features or
   information therein, except as specifically stated herein.

   (b) YOUR RIGHT TO USE THE PRODUCT SHALL BE
   EFFECTIVE FROM THE DATE YOU FIRST
   INSTALL ANY PORTION OF THE PRODUCT ON
   ANY DEVICE FOR A PERIOD OF ONE HUNDRED
   EIGHTY (180) DAYS. THE PRODUCT IS TIME
   SENSITIVE AND WILL NOT FUNCTION UPON
   EXPIRATION OF THE 180 DAY PERIOD.
   NOTICE OF EXPIRATION WILL NOT ACTIVELY
   BE GIVEN, SO YOU NEED TO PLAN FOR THE
   EXPIRATION DATE AND MAKE A COPY OF AND
   REMOVE YOUR IMPORTANT DATA BEFORE
   EXPIRATION. If you desire to use the Product after your
   evaluation is completed, you will need to acquire a validly
   licensed copy of the non-evaluation version of the Product.

   (c) At Microsoft's request, Recipient agrees to provide
   reasonable feedback to Microsoft, including but not limited
   to usability, bug reports and test results, with respect to
   the Product testing.  In addition, if requested by
   Microsoft, Recipient will use reasonable efforts to review
   and comment on all documentation supplied.  All bug
   reports, test results and other feedback made by Recipient
   shall be the property of Microsoft and may be used by
   Microsoft for any purpose it sees fit.  Due to the nature
   of the development work, Microsoft is not certain if errors
   or discrepancies in the Product may be corrected.

   (d) Recipient's use of the Product shall take place solely at
   Recipient's site.  Recipient may not demonstrate or show
   the Product to third parties without the express written
   permission of Microsoft.


   (e) Recipient's use of software applications installed on or
   accessed through the Product's IntelliMirror, Terminal
   Services, or application-sharing functionality may require
   additional licenses - please consult the license agreement
   accompanying such software.


   2. TERM OF AGREEMENT.  The term of this Agreement shall
      commence upon Recipient's copying, installing or
      using the Product and shall continue unless
      terminated by Microsoft in writing at any time, with
      or without cause.  This Agreement will terminate
      without notice upon the commercial release of the
      Product.  Upon the termination of this Agreement,
      Recipient shall cease use of the Product and, shall,
      upon request, promptly return to Microsoft, or
      certify destruction of, all full or partial copies of
      the Product and related materials provided by
      Microsoft.

   3. SUPPORT.  Microsoft is not obligated to provide technical
      or other support for the Product.  However, limited
      technical support ("Support Services"), if noted in
      the materials provided to Recipient by Microsoft, may
      be available.  Use of any such Support Services is
      governed by the Microsoft policies and programs
      described in "online" documentation, and/or in other
      Microsoft-provided materials.  Any supplemental
      software code provided to Recipient as part of the
      Support Services shall be considered part of the
      Product and subject to the terms and conditions of
      this Agreement.  With respect to technical
      information Recipient provides to Microsoft as part
      of the Support Services, Microsoft may use such
      information for its business purposes, including for
      product support and development.  Microsoft will not
      utilize such technical information in a form that
      personally identifies Recipient.  Such limited
      Support Services may not be available in all
      countries outside the United States and will be
      discontinued once the Product is commercially
      released.

   4. MAINTENANCE.  Microsoft is not obligated to provide
      maintenance, technical support, or updates to
      Recipient for Product licensed under this Agreement. 
      In no event shall Microsoft be obligated to provide
      Recipient, free of charge, a copy of the commercial
      release version of the Product in connection with
      Recipient's participation in the testing program. 
      Microsoft is not obligated to make the Product
      commercially available.

   5. DISCLAIMER OF WARRANTIES.  To the
      maximum extent permitted by applicable law, Microsoft
      and its suppliers provide to Recipient the Product
      and Support Services AS IS
      AND WITH ALL FAULTS; and
      Microsoft and its suppliers hereby disclaim with
      respect to the Product and Support Services all
      warranties and conditions, whether express, implied
      or statutory, including, but not limited to, any (if
      any) warranties, duties or conditions of or related
      to:  merchantability, fitness for a particular
      purpose, lack of viruses, accuracy or completeness of
      responses, results, workmanlike effort and lack of
      negligence.  ALSO THERE IS NO
      WARRANTY, DUTY OR CONDITION OF
      TITLE, QUIET ENJOYMENT, QUIET
      POSSESSION, CORRESPONDENCE TO
      DESCRIPTION OR NON-INFRINGEMENT. 
      THE ENTIRE RISK ARISING OUT OF
      USE OR PERFORMANCE OF THE PRODUCT
      AND ANY SUPPORT SERVICES REMAINS
      WITH RECIPIENT.

   6. EXCLUSION OF INCIDENTAL, CONSEQUENTIAL
      AND CERTAIN OTHER DAMAGES.  TO
      THE MAXIMUM EXTENT PERMITTED BY
      APPLICABLE LAW, IN NO EVENT SHALL
      MICROSOFT OR ITS SUPPLIERS BE
      LIABLE FOR ANY SPECIAL,
      INCIDENTAL, INDIRECT, PUNITIVE OR
      CONSEQUENTIAL DAMAGES WHATSOEVER
      (INCLUDING, BUT NOT LIMITED TO,
      DAMAGES FOR:  LOSS OF PROFITS,
      LOSS OF CONFIDENTIAL OR OTHER
      INFORMATION, BUSINESS
      INTERRUPTION, PERSONAL INJURY,
      LOSS OF PRIVACY, FAILURE TO MEET
      ANY DUTY (INCLUDING OF GOOD FAITH
      OR OF REASONABLE CARE),
      NEGLIGENCE, AND ANY OTHER
      PECUNIARY OR OTHER LOSS
      WHATSOEVER) ARISING OUT OF OR IN
      ANY WAY RELATED TO THE USE OF OR
      INABILITY TO USE THE PRODUCT OR
      THE SUPPORT SERVICES, OR THE
      PROVISION OF OR FAILURE TO
      PROVIDE SUPPORT SERVICES, OR
      OTHERWISE UNDER OR IN CONNECTION
      WITH ANY PROVISION OF THIS
      AGREEMENT, EVEN IF MICROSOFT OR
      ANY SUPPLIER HAS BEEN ADVISED OF
      THE POSSIBILITY OF SUCH DAMAGES.  


   7. LIMITATION OF LIABILITY AND REMEDIES. 
      Notwithstanding any damages that Recipient might
      incur for any reason whatsoever (including, without
      limitation, all damages referenced above and all
      direct or general damages), the entire liability of
      Microsoft and any of its suppliers under any
      provision of this Agreement and your exclusive remedy
      for all of the foregoing shall be limited to actual
      damages incurred by Recipient based on reasonable
      reliance up to the greater of the amount actually
      paid by Recipient for the Product or U.S.$5.00.  The
      foregoing limitations, exclusions and disclaimers
      shall apply to the maximum extent permitted by
      applicable law, even if any remedy fails its
      essential purpose.

   8. GOVERNING LAW; ATTORNEYS' FEES.  This
      Agreement shall be construed and controlled by the
      laws of the State of Washington and Recipient
      consents to the jurisdiction and venue in the federal
      courts sitting in King County, Washington, unless no
      federal subject matter jurisdiction exists, in which
      case Recipient consents to the jurisdiction and venue
      in the Superior Court of King County, Washington. 
      Recipient waives all defenses of lack of personal
      jurisdiction and forum non conveniens.  Process may
      be served on either party in the manner authorized by
      applicable law or court rule.  If either Microsoft or
      Recipient employs attorneys to enforce any rights
      arising out of or relating to this Agreement, the
      prevailing party shall be entitled to recover
      reasonable attorneys' fees.

   9. U.S. GOVERNMENT RESTRICTED RIGHTS.  The
      Product and Documentation provided to the U.S.
      Government pursuant to solicitations issued on or
      after December 1, 1995 is provided with the
      commercial rights and restrictions described
      elsewhere herein.  Product and Documentation provided
      to the U.S. Government pursuant to solicitations
      issued prior to December 1, 1995 is provided with
      RESTRICTED RIGHTS as provided for
      in FAR, 48 CFR 52.227-14 (JUNE 1987) or FAR, 48 CFR
      252.227-7013 (OCT 1988), as applicable.

  10. EXPORT RESTRICTIONS.  Recipient
      acknowledges that the Product is of U.S. origin. 
      Recipient agrees to comply with all applicable
      international and national laws that apply to these
      products, including the U.S. Export Administration
      Regulations, as well as end-user, end-use and
      country destination restrictions issued by U.S. and
      other governments.  For additional information on
      exporting Microsoft products, see 
      http://www.microsoft.com/exporting/. 
       

Should you have any questions concerning this Agreement, or if
you desire to contact Microsoft for any reason, please write: 
Microsoft Corporation, WWPG Beta Team, One Microsoft Way,
Redmond, WA  98052-6399.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\readme.txt ===
Instructions to build the hives:

The hives are now checked in and are only built on an as needed bases. This was
done to eliminate one of the requirements that users must be admin to build the
system.  In order to make a change to setupreg.ini, setupp.ini, or the hive building 
scripts (mkhive*.cmd), you need to check out the hives, and update them after you 
are done building. Ideally - the new hive files should be checked in with the same 
change number as the ini changes so it's easy to understand what the diffs are.

Again, building hives requires admin access.  If you're not an admin on your machine,
do so now - signin as Administrator, open a cmd window, and run:

Net Localgroup Administrators /add <your domain/username>

When you're done, come back to this directory and run the mkit.cmd script.

It will build the hives, checkout the necessary files under the bin dir, and
copy the new hives over. Is up to you to actually run a build and make sure
the new hives are valid. When you're satisfied, submit all the checked out files
under the bin directory (not just setupreg.*).

Oh, and there's no requirement that you be running x86 in order to build the
hives - the files themselves are generic (the initial versions were built
on an ia64 machine).

Any questions/problems/etc - see bryant
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\setupreg.ini ===
//
// SKU differentiations
//
#ifdef _STEPUP_
#define STEPUP 1
#else
#define STEPUP 0
#endif
#ifndef EVALTIME
#define EVALTIME 0
#endif
#ifndef SUITE_TYPE
#define SUITE_TYPE 0
#endif

//
//  predefined ACEs for creating ACLs
//
//      R == Read
//      W == Write (values & subkeys, create keys)
//      D == Delete keys
//      X == Execute
//   Full == All access
//
#define AdminFull       1
#define AdminR          2
#define AdminRW         3
#define AdminRWD        4
#define CreatorFull     5
#define CreatorRW       6
#define WorldFull       7
#define WorldR          8
#define WorldRW         9
#define WorldRWD        10
#define PowerFull       11
#define PowerRW         12
#define PowerRWD        13
#define SystemOpFull    14
#define SystemOpRW      15
#define SystemOpRWD     16
#define SystemFull      17
#define SystemRW        18
#define SystemR         19
#define AdminRWX        20
#define IntUserFull     21
#define IntUserR        22
#define IntUserRW       23
#define IntUserRWD      24
#define UserRW          25
#define TermUserFull    26
#define TermUserR       27
#define TermUserRW      28
#define TermUserRWD     29
#define UserR           30
#define PowerR          31


//
// RESTRICT_CPU is used to build protucts this place
// a very hard limit on the number of processors
//
// a value of 0 means for NTW, the hard limit is 2, and for NTS, the hard limit is 4
// a value of 1-32 means that the hard limit is the number specified
// a value > 32 means that the hard limit is 32 processors and GUI setup operates
// on registered processors as it does today
//

System
    ControlSet001
        Control

            //
            // This key and all subkeys will be migrated to the system hive
            //

            Arbiters

                //
                // AllocationOrder controls the order in which resources are
                // given to PnP devices.
                //

                AllocationOrder

                    //
                    // The PCI arbiter arbitrates both PCI and ISA resources
                    // NB. PCI I/O space is 32 bit
                    // The size of this list is 0x28 + NumberOfEntries * 0x20 bytes
                    //

                    Pci = REG_RESOURCE_REQUIREMENTS  0x00000248             \
                        0x00000248 0 0 0 0 0 0 1   0x00010001 0x00000011    \
                                                                            \
                          0x0100 0  0 0  0x00010000 0 0xffffffff 0          \
                          0x0108 0  0 0  0x00000500 0 0x0000ffff 0          \
                          0x0108 0  0 0  0x00000140 0 0x0000017F 0          \
                          0x0108 0  0 0  0x00000200 0 0x000002FF 0          \
                          0x0108 0  0 0  0x00000300 0 0x0000036F 0          \
                          0x0108 0  0 0  0x00000378 0 0x0000037A 0          \
                          0x0108 0  0 0  0x000002E8 0 0x000002FF 0          \
                          0x0108 0  0 0  0x000001F0 0 0x000001F8 0          \
                          0x0108 0  0 0  0x000003B0 0 0x000003CF 0          \
                          0x0108 0  0 0  0x000003E8 0 0x000003FF 0          \
                          0x0108 0  0 0  0x000001CE 0 0x000001CF 0          \
                          0x0108 0  0 0  0x00000100 0 0x000003FF 0          \
                                                                            \
                          0x0300 0  0 0  0x00100000 0 0xFFFFFFFF 0          \
                          0x0308 0  0 0  0x000F0000 0 0x000FFFFF 0          \
                          0x0308 0  0 0  0x00080000 0 0x000BFFFF 0          \
                          0x0308 0  0 0  0x00080000 0 0x000FFFFF 0          \
                          0x0308 0  0 0  0x00080000 0 0xFFBFFFFF 0


                    Root = REG_RESOURCE_REQUIREMENTS  0x00000468            \
                        0x00000468 0 0 0 0 0 0 1   0x00010001 0x00000022    \
                                                                            \
                          0x0100 0  0 0  0x0500 0 0xFFFF 0                  \
                          0x0108 0  0 0  0x0140 0 0x017F 0                  \
                          0x0108 0  0 0  0x0200 0 0x02FF 0                  \
                          0x0108 0  0 0  0x0300 0 0x036F 0                  \
                          0x0108 0  0 0  0x0378 0 0x037A 0                  \
                          0x0108 0  0 0  0x02E8 0 0x02FF 0                  \
                          0x0108 0  0 0  0x01F0 0 0x01F8 0                  \
                          0x0108 0  0 0  0x03B0 0 0x03CF 0                  \
                          0x0108 0  0 0  0x03E8 0 0x03FF 0                  \
                          0x0108 0  0 0  0x01CE 0 0x01CF 0                  \
                          0x0108 0  0 0  0x0100 0 0x03FF 0                  \
                                                                            \
                          0x0208 0  0x09 0x09  0 0 0 0                      \
                          0x0208 0  0x08 0x08  0 0 0 0                      \
                          0x0208 0  0x07 0x07  0 0 0 0                      \
                          0x0208 0  0x0B 0x0B  0 0 0 0                      \
                          0x0208 0  0x0A 0x0A  0 0 0 0                      \
                          0x0208 0  0x02 0x02  0 0 0 0                      \
                          0x0200 0  0x03 0x03  0 0 0 0                      \
                          0x0208 0  0x05 0x05  0 0 0 0                      \
                          0x0208 0  0x04 0x04  0 0 0 0                      \
                          0x0208 0  0x0F 0x0F  0 0 0 0                      \
                          0x0208 0  0x0D 0x0D  0 0 0 0                      \
                          0x0208 0  0x0E 0x0E  0 0 0 0                      \
                          0x0208 0  0x06 0x06  0 0 0 0                      \
                          0x0208 0  0x0C 0x0C  0 0 0 0                      \
                          0x0208 0  0x01 0x01  0 0 0 0                      \
                                                                            \
                          0x0300 0  0 0  0x00100000 0 0xFFFFFFFF 0          \
                          0x0308 0  0 0  0x000F0000 0 0x000FFFFF 0          \
                          0x0308 0  0 0  0x00080000 0 0x000BFFFF 0          \
                          0x0308 0  0 0  0x00080000 0 0x000FFFFF 0          \
                          0x0308 0  0 0  0x00080000 0 0xFFBFFFFF 0          \
                                                                            \
                          0x0400 0  0x06 0x0F  0 0 0 0                      \
                          0x0408 0  0x03 0x04  0 0 0 0                      \
                          0x0408 0  0x00 0x0F  0 0 0 0

                //
                // Reserved resources are not allocated until there is no other
                // alternative.  They are normally for well known legacy devices.
                //

                ReservedResources

                    //
                    // IO: 2f8-2ff (COM2), 3b0-3bb & 3c0-3df (VGA) 3bc-3be (LPT1)
                    //     3f8-3ff (COM1), Plus all the bits what ATI/S3 want to use
                    // Memory: a0000-bffff (VGA) fff00000-ffffffff (Top 64Mb of
                    //     memory for the BIOS to play with)
                    //
                    // The size of this list is 0x28 + NumberOfEntries * 0x20 bytes
                    //

                    PCStandard = REG_RESOURCE_REQUIREMENTS 0x00000108       \
                        0x00000108 0 0 0 0 0 0 1   0x00010001 0x00000007    \
                          0x0100 0  0 0  0x02F8 0 0x02FF 0                  \
                          0x0108 0  0 0  0x03B0 0 0x03BB 0                  \
                          0x0108 0  0 0  0x03BC 0 0x03BE 0                  \
                          0x0108 0  0 0  0x03C0 0 0x03DF 0                  \
                          0x0108 0  0 0  0x03F8 0 0x03FF 0                  \
                                                                            \
                          0x0300 0  0 0  0x000A0000 0 0x000BFFFF 0          \
                          0x0308 0  0 0  0xFFF00000 0 0xFFFFFFFF 0

                    //
                    // As for PCStandard but used when a broken legacy PCI video
                    // card is encountered.  Note the large number of positive
                    // decode IO ranges.
                    //

                    BrokenVideo = REG_RESOURCE_REQUIREMENTS 0x00000528      \
                        0x00000528 0 0 0 0 0 0 1   0x00010001 0x00000028    \
                          0x0100 0  0 0  0x02EC 0 0x02EF 0                  \
                          0x0108 0  0 0  0x02F8 0 0x02FF 0                  \
                          0x0108 0  0 0  0x03B0 0 0x03BB 0                  \
                          0x0108 0  0 0  0x03C0 0 0x03DF 0                  \
                          0x0108 0  0 0  0x03BC 0 0x03BE 0                  \
                          0x0108 0  0 0  0x03F8 0 0x03FF 0                  \
                          0x0108 0  0 0  0x42e8 0 0x42ef 0                  \
                          0x0108 0  0 0  0x4ae8 0 0x4aef 0                  \
                          0x0108 0  0 0  0x82e8 0 0x82ef 0                  \
                          0x0108 0  0 0  0x86e8 0 0x86ef 0                  \
                          0x0108 0  0 0  0x8ae8 0 0x8aef 0                  \
                          0x0108 0  0 0  0x8ee8 0 0x8eef 0                  \
                          0x0108 0  0 0  0x92e8 0 0x92ef 0                  \
                          0x0108 0  0 0  0x96e8 0 0x96ef 0                  \
                          0x0108 0  0 0  0x9ae8 0 0x9aef 0                  \
                          0x0108 0  0 0  0x9ee8 0 0x9eef 0                  \
                          0x0108 0  0 0  0xa2e8 0 0xa2ef 0                  \
                          0x0108 0  0 0  0xa6e8 0 0xa6ef 0                  \
                          0x0108 0  0 0  0xaae8 0 0xaaef 0                  \
                          0x0108 0  0 0  0xaee8 0 0xaeef 0                  \
                          0x0108 0  0 0  0xb6e8 0 0xb6ef 0                  \
                          0x0108 0  0 0  0xbae8 0 0xbaef 0                  \
                          0x0108 0  0 0  0xbee8 0 0xbeef 0                  \
                          0x0108 0  0 0  0xc2e8 0 0xc2ef 0                  \
                          0x0108 0  0 0  0xc6e8 0 0xc6ef 0                  \
                          0x0108 0  0 0  0xcae8 0 0xcaef 0                  \
                          0x0108 0  0 0  0xcee8 0 0xceef 0                  \
                          0x0108 0  0 0  0xd2e8 0 0xd2ef 0                  \
                          0x0108 0  0 0  0xd6e8 0 0xd6ef 0                  \
                          0x0108 0  0 0  0xdae8 0 0xdaef 0                  \
                          0x0108 0  0 0  0xdee8 0 0xdeef 0                  \
                          0x0108 0  0 0  0xe2e8 0 0xe2ef 0                  \
                          0x0108 0  0 0  0xe6e8 0 0xe6ef 0                  \
                          0x0108 0  0 0  0xeae8 0 0xeaef 0                  \
                          0x0108 0  0 0  0xeee8 0 0xeeef 0                  \
                          0x0108 0  0 0  0xf6e8 0 0xf6ef 0                  \
                          0x0108 0  0 0  0xfae8 0 0xfaef 0                  \
                          0x0108 0  0 0  0xfee8 0 0xfeef 0                  \
                                                                            \
                          0x0300 0  0 0  0x000A0000 0 0x000BFFFF 0          \
                          0x0308 0  0 0  0xFFF00000 0 0xFFFFFFFF 0

                    //
                    // This entry defines PCStandard plus an extra requirement
                    // for broken BIOS's which have an unreported device decoding 
                    // memory accesses based at 0xF8000000. This has been observed
                    // on NEC and Sony laptops.
                    //
                    
                    BrokenMemAtF8 = REG_RESOURCE_REQUIREMENTS 0x00000108    \
                        0x00000108 0 0 0 0 0 0 1   0x00010001 0x00000007    \
                          0x0100 0  0 0  0x02F8 0 0x02FF 0                  \
                          0x0108 0  0 0  0x03B0 0 0x03BB 0                  \
                          0x0108 0  0 0  0x03BC 0 0x03BE 0                  \
                          0x0108 0  0 0  0x03C0 0 0x03DF 0                  \
                          0x0108 0  0 0  0x03F8 0 0x03FF 0                  \
                                                                            \
                          0x0300 0  0 0  0x000A0000 0 0x000BFFFF 0          \
                          0x0308 0  0 0  0xF8000000 0 0xFBFFFFFF 0          \
                          0x0308 0  0 0  0xFFF00000 0 0xFFFFFFFF 0

                    //
                    // NTRAID #417271
                    // This is a workaround for a bug in our code that is too
                    // risky to fix for XP.  Reserve memory from f0000000-
                    // ffffffff on this Gateway Solo 9500 and we don't hit the
                    // problem.
                    //
                    
                    Gateway9500Workaround= REG_RESOURCE_REQUIREMENTS 0x00000108 \
                        0x00000108 0 0 0 0 0 0 1   0x00010001 0x00000007    \
                          0x0100 0  0 0  0x02F8 0 0x02FF 0                  \
                          0x0108 0  0 0  0x03B0 0 0x03BB 0                  \
                          0x0108 0  0 0  0x03BC 0 0x03BE 0                  \
                          0x0108 0  0 0  0x03C0 0 0x03DF 0                  \
                          0x0108 0  0 0  0x03F8 0 0x03FF 0                  \
                                                                            \
                          0x0300 0  0 0  0x000A0000 0 0x000BFFFF 0          \
                          0x0308 0  0 0  0xF0000000 0 0xFFFFFFFF 0


                    Root = PCStandard
                    Pci = PCStandard

            Class
                {4D36E967-E325-11CE-BFC1-08002BE10318}
                    UpperFilters = REG_MULTI_SZ "PartMgr"

                {4D36E96B-E325-11CE-BFC1-08002BE10318}
                    UpperFilters = REG_MULTI_SZ "kbdclass"

                {4D36E96F-E325-11CE-BFC1-08002BE10318}
                    UpperFilters = REG_MULTI_SZ "mouclass"

                {4D36E972-E325-11CE-BFC1-08002bE10318}
                    0000
                        Linkage
                            Export = REG_MULTI_SZ "\Device\{54C7D140-09EF-11D1-B25A-F5FE627ED95E}"
                            Bind = REG_MULTI_SZ "\Device\{54C7D140-09EF-11D1-B25A-F5FE627ED95E}"
                            UpperBind = REG_MULTI_SZ "Tcpip"

                {4D36E97B-E325-11CE-BFC1-08002BE10318}
                    LegacyAdapterDetection = REG_DWORD 1

            COM Name Arbiter

            DeviceClasses
            
            GroupOrderList
                //
                // PLEASE NOTE:  The fields for the values are defined below:
                //
                //  <GroupName> = REG_BINARY NumOfBytes \
                //                           NumOfTags  \
                //                           Tag1       \
                //                           Tag2       \
                //                           ...
                //
                //  The field NumOfBytes = (NumOfTags + 1) * 4.
                //
                drivers = REG_BINARY 12 \
                                     0x00000002 \
                                     0x00000001 \
                                     0x00000002


                Boot Bus Extender = REG_BINARY 24 \
                                               0x00000005 \
                                               0x00000001 \
                                               0x00000002 \
                                               0x00000003 \
                                               0x00000005 \
                                               0x00000004

                System Bus Extender = REG_BINARY 48 \
                                                 0x0000000b \
                                                 0x00000003 \
                                                 0x00000004 \
                                                 0x00000001 \
                                                 0x00000008 \
                                                 0x00000009 \
                                                 0x0000000a \
                                                 0x0000000b \
                                                 0x0000000c \
                                                 0x0000000d \
                                                 0x0000000e \
                                                 0x0000000f

                Input Device Support = REG_BINARY 32 \
                                                  0x00000007 \
                                                  0x00000001 \
                                                  0x00000002 \
                                                  0x00000003 \
                                                  0x00000004 \
                                                  0x00000005 \
                                                  0x00000006 \
                                                  0x00000007
                
            HAL
                80867110 = REG_DWORD 1
                11060596 = REG_DWORD 1
                11060686 = REG_DWORD 0x22004005
                10390530 = REG_DWORD 1
                10390620 = REG_DWORD 1
                10B90533 = REG_DWORD 1
                10B91533 = REG_DWORD 1
                1166004F = REG_DWORD 1
                11660050 = REG_DWORD 1
                11660200 = REG_DWORD 1
                80862440 = REG_DWORD 8
                80862410 = REG_DWORD 8
                80862420 = REG_DWORD 8
                8086244C = REG_DWORD 8
                80862480 = REG_DWORD 8
                8086248C = REG_DWORD 8
                

            IDConfigDB                 [UserR PowerR   AdminFull SystemFull CreatorFull]
                CurrentConfig     =  REG_DWORD   0
                UserWaitInterval  =  REG_DWORD  30
                Hardware Profiles      [UserR PowerR   AdminFull SystemFull CreatorFull]
                    0000               [UserR PowerR   AdminFull SystemFull CreatorFull]
                        PreferenceOrder     = REG_DWORD -1
                        Pristine            = REG_DWORD  1
                        Aliasable           = REG_DWORD  0
            Pnp
                Pci
                    CardList
                        Intel 82441FX = REG_BINARY 0x10 0x00000001 0x12378086 0x00000000 0x00000000
                        Intel 82439HX = REG_BINARY 0x10 0x00000001 0x12508086 0x00000000 0x00000000
                        Intel 82439TX = REG_BINARY 0x10 0x00000001 0x71008086 0x00000000 0x00000000
                        Intel 82443LX/EX = REG_BINARY 0x10 0x00000001 0x71808086 0x00000000 0x00000000
                        Intel 82443BX1 = REG_BINARY 0x10 0x00000001 0x71908086 0x00000000 0x00000000
                        Intel 82443BX2 = REG_BINARY 0x10 0x00000001 0x71928086 0x00000000 0x00000000
                        Intel 82443GX = REG_BINARY 0x10 0x00000001 0x71A08086 0x00000000 0x00000000
                        VIA Tech1 = REG_BINARY 0x10 0x00000001 0x05011106 0x00000000 0x00000000
                        VIA Tech2 = REG_BINARY 0x10 0x00000001 0x06911106 0x00000000 0x00000000
                        Toshiba = REG_BINARY 0x10 0x00000001 0x06011179 0x00000000 0x00000000
                        Ali = REG_BINARY 0x10 0x00000001 0x152110B9 0x00000000 0x00000000

                PciIrqRouting
                    Options = REG_DWORD 0x0000000F
                    IrqRoutingTables
                        VLSI Sample = REG_BINARY 0x40 \
                                                 24,50,49,52,00,01,40,00,FF,FF,00,00,00,00,00,00, \
                                                 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00, \
                                                 00,58,01,28,DE,02,28,DE,03,28,DE,04,28,DE,01,00, \
                                                 00,60,02,28,DE,03,28,DE,04,28,DE,01,28,DE,01,00
                        IBM Mach VLSI Chipset = REG_BINARY 0x40 \
                                                           24,50,49,52,00,01,40,00,FF,FF,00,00,00,00,00,00, \
                                                           00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00, \
                                                           00,58,01,28,DE,03,28,DE,02,28,DE,01,28,DE,01,00, \
                                                           00,60,02,28,DE,01,28,DE,03,28,DE,02,28,DE,01,00
                        Dell 4 PCI slot = REG_BINARY 0x60 \
                                                     24,50,49,52,00,01,60,00,FF,FF,00,00,00,00,00,00, \
                                                     00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00, \
                                                     00,68,60,B8,0E,61,B8,0E,62,B8,0E,63,B8,0E,01,00, \
                                                     00,70,61,B8,0E,62,B8,0E,63,B8,0E,60,B8,0E,01,00, \
                                                     00,78,62,B8,0E,63,B8,0E,60,B8,0E,61,B8,0E,01,00, \
                                                     00,80,63,B8,0E,60,B8,0E,61,B8,0E,62,B8,0E,01,00
                        Dell 2 PCI slot = REG_BINARY 0x40 \
                                                     24,50,49,52,00,01,40,00,FF,FF,00,00,00,00,00,00, \
                                                     00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00, \
                                                     00,60,60,B8,0E,61,08,8E,62,08,8E,63,B8,0E,01,00, \
                                                     00,68,62,B8,0E,63,08,8E,61,08,8E,60,B8,0E,01,00
                        Gateway 2000 3 PCI slot = REG_BINARY 0x50 \
                                                             24,50,49,52,00,01,50,00,FF,FF,00,00,00,00,00,00, \
                                                             00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00, \
                                                             00,30,62,B8,8E,61,B8,8E,60,B8,8E,63,B8,8E,0A,00, \
                                                             00,70,61,B8,8E,60,B8,8E,62,B8,8E,63,B8,8E,0B,00, \
                                                             00,60,60,B8,8E,62,B8,8E,61,B8,8E,63,B8,8E,0C,00
                        Intel 430MX Motherboard Sample = REG_BINARY 0x80 \
                                                                    24,50,49,52,00,01,80,00,FF,FF,00,00,00,00,00,00, \
                                                                    00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00, \
                                                                    00,70,60,F8,DE,61,F8,DE,60,F8,DE,61,F8,DE,05,00, \
                                                                    00,78,61,F8,DE,60,F8,DE,61,F8,DE,60,F8,DE,63,00, \
                                                                    00,88,61,F8,DE,60,F8,DE,61,F8,DE,60,F8,DE,06,00, \
                                                                    00,90,60,F8,DE,61,F8,DE,60,F8,DE,61,F8,DE,03,00, \
                                                                    00,98,61,F8,DE,60,F8,DE,61,F8,DE,60,F8,DE,61,00, \
                                                                    00,A0,60,B8,8E,62,B8,8E,61,B8,8E,63,B8,8E,01,00
                    IrqMiniports
                        04828086
                            Name = REG_SZ "Intel 82375EB/SB"
                            Instance = REG_DWORD 0x00000000
                            Parameters = REG_DWORD 0x00000000
                        122E8086
                            Name = REG_SZ "Intel 82371FB"
                            Instance = REG_DWORD 0x00000001
                            Parameters = REG_DWORD 0x00000000
                        04848086
                            Name = REG_SZ "Intel 82378"
                            Instance = REG_DWORD 0x00000001
                            Parameters = REG_DWORD 0x00000000
                        12348086
                            Name = REG_SZ "Intel 82371MX"
                            Instance = REG_DWORD 0x00000001
                            Parameters = REG_DWORD 0x00000000
                        70008086
                            Name = REG_SZ "Intel 82371SB"
                            Instance = REG_DWORD 0x00000001
                            Parameters = REG_DWORD 0x00000000
                        71108086
                            Name = REG_SZ "Intel 82371AB/EB"
                            Instance = REG_DWORD 0x00000001
                            Parameters = REG_DWORD 0x00000000
                        76008086
                            Name = REG_SZ "Intel 82372FB"
                            Instance = REG_DWORD 0x00000001
                            Parameters = REG_DWORD 0x00000000
                        00061004
                            Name = REG_SZ "VLSI"
                            Instance = REG_DWORD 0x00000002
                            Parameters = REG_DWORD 0x00000000
                        C5581045
                            Name = REG_SZ "Opti Viper"
                            Instance = REG_DWORD 0x00000003
                            Parameters = REG_DWORD 0x00000000
                        C5681045
                            Name = REG_SZ "Opti Viper Max"
                            Instance = REG_DWORD 0x00000003
                            Parameters = REG_DWORD 0x00000000
                        00081039
                            Name = REG_SZ "SiS5503"
                            Instance = REG_DWORD 0x00000004
                            Parameters = REG_DWORD 0x00000000

                        01021004
                            Name = REG_SZ "VLSI Eagle"
                            Instance = REG_DWORD 0x00000005
                            Parameters = REG_DWORD 0x00000000
                        152310B9
                            Name = REG_SZ "ALi 1523"
                            Instance = REG_DWORD 0x00000006
                            Parameters = REG_DWORD 0x00000000
                        0011100B
                            Name = REG_SZ "NS 87560"
                            Instance = REG_DWORD 0x00000007
                            Parameters = REG_DWORD 0x00000000
                        AE290E11
                            Name = REG_SZ "Compaq MISC-3"
                            Instance = REG_DWORD 0x00000008
                            Parameters = REG_DWORD 0x00000000
                        153310B9
                            Name = REG_SZ "ALi 1533"
                            Instance = REG_DWORD 0x00000009
                            Parameters = REG_DWORD 0x00000000
                        C7001045
                            Name = REG_SZ "Opti Fire Star"
                            Instance = REG_DWORD 0x0000000A
                            Parameters = REG_DWORD 0x00000000
                        05861106
                            Name = REG_SZ "VT82C586B"
                            Instance = REG_DWORD 0x0000000B
                            Parameters = REG_DWORD 0x00000000
                        05961106
                            Name = REG_SZ "VT82C596B"
                            Instance = REG_DWORD 0x0000000B
                            Parameters = REG_DWORD 0x00000000
                        06861106
                            Name = REG_SZ "VT82C686B"
                            Instance = REG_DWORD 0x0000000B
                            Parameters = REG_DWORD 0x00000000
                        A0F30E11
                            Name = REG_SZ "Compaq OSB"
                            Instance = REG_DWORD 0x0000000C
                            Parameters = REG_DWORD 0x00000000
                        00020E11
                            Name = REG_SZ "Compaq CMC-2"
                            Instance = REG_DWORD 0x0000000D
                            Parameters = REG_DWORD 0x00000000
                        00001078
                            Name = REG_SZ "Cyrix 5520 Rev 0"
                            Instance = REG_DWORD 0x0000000E
                            Parameters = REG_DWORD 0x00000000
                        00021078
                            Name = REG_SZ "Cyrix 5520 Rev 1"
                            Instance = REG_DWORD 0x0000000E
                            Parameters = REG_DWORD 0x00000000
                        06021179
                            Name = REG_SZ "Toshiba"
                            Instance = REG_DWORD 0x0000000F
                            Parameters = REG_DWORD 0x00000000
                        00021066
                            Name = REG_SZ "Vesuvius"
                            Instance = REG_DWORD 0x00000011
                            Parameters = REG_DWORD 0x00000001
                        80021066
                            Name = REG_SZ "Vesuvius"
                            Instance = REG_DWORD 0x00000011
                            Parameters = REG_DWORD 0x00000001

            ScsiPort
                SpecialTargetList
                        DiskCOMPAQPCST32430N________
                                OneLun = REG_DWORD 1
                        DiskMICROP__3243-19MZ__Q4D__
                                OneLun = REG_DWORD 1
                        DiskMICROP__4421-07___0502SJ
                                OneLun = REG_DWORD 1
                        DiskSEAGATE_ST34502LC_______
                                OneLun = REG_DWORD 1
                        DiskIBM_____DNES-309170W____
                                OneLun = REG_DWORD 1
                        CDROMYAMAHACRW4416S__________
                                OneLun = REG_DWORD 1
                        CDROMCyberDrvSCSI_CD-ROM_120S
                                OneLun = REG_DWORD 1
                        CdRomhp______CD-Writer+_M820_
                                OneLun = REG_DWORD 1
                        WormYAMAHA_CDR100___________
                                OneLun = REG_DWORD 1
                        ProcessorESH-SHVSVA_HSBP_M10_____
                                OneLun = REG_DWORD 1
                        ChangerJVC_____CD-CHG_MC-1600__
                                OneLun = REG_DWORD 1
                        ScannerUMAX____Astra_2400S_____
                                SetLunInCdb = REG_DWORD 1
                        ScannerUMAX____Astra_2200______
                                SetLunInCdb = REG_DWORD 1
                        ScannerUMAX____Astra_1200S_____
                                SetLunInCdb = REG_DWORD 1
                        ScannerUMAX____Astra_1220S_____
                                SetLunInCdb = REG_DWORD 1
                        ScannerUMAX____Astra_610S______
                                SetLunInCdb = REG_DWORD 1
                        ScannerUMAX____Astra_600S______
                                SetLunInCdb = REG_DWORD 1
                        ScannerLinoHellSAPHIR3_________
                                SetLunInCdb = REG_DWORD 1
                        Scanner________Scanner_________
                                SetLunInCdb = REG_DWORD 1
                        Scanner________Scanner_600_____
                                SetLunInCdb = REG_DWORD 1
                        ScannerMICROTEKScanMakerIII____
                                SetLunInCdb = REG_DWORD 1
                        ScannerMICROTEKScanMakerIIsp___
                                SetLunInCdb = REG_DWORD 1

            ServiceGroupOrder
                List = REG_MULTI_SZ "drivers" \
                                    "Boot Bus Extender" \
                                    "System Bus Extender" \
                                    "Input Device Support"

            Session Manager
                Memory Management
                    PagedPoolSize = REG_DWORD 0x00                    

            SystemResources
                BusValues
                    Internal     = REG_BINARY 8 0  0
                    Isa          = REG_BINARY 8 1  0
                    Eisa         = REG_BINARY 8 2  1
                    MCA          = REG_BINARY 8 3  1
                    TurboChannel = REG_BINARY 8 4  0
                    PCI          = REG_BINARY 8 5  1
                    VME          = REG_BINARY 8 6  0
                    NuBus        = REG_BINARY 8 7  0
                    PCMCIA       = REG_BINARY 8 8  1
                    CBus         = REG_BINARY 8 9  0
                    MPI          = REG_BINARY 8 10 0
                    MPSA         = REG_BINARY 8 11 0

                ReservedResources
                    Isa = REG_RESOURCE_LIST         0x0274      \
                        1 1 1 0 38                              \
                        0x0101      0x0000 0        0x0100      \
                        0x0301      0x42E8 0    0x2             \
                        0x0301      0x4AE8 0    0x2             \
                        0x0301      0x82E8 0    0x4             \
                        0x0301      0x86E8 0    0x4             \
                        0x0301      0x8AE8 0    0x4             \
                        0x0301      0x8EE8 0    0x4             \
                        0x0301      0x92E8 0    0x4             \
                        0x0301      0x96E8 0    0x4             \
                        0x0301      0x9AE8 0    0x4             \
                        0x0301      0x9EE8 0    0x4             \
                        0x0301      0xA2E8 0    0x4             \
                        0x0301      0xA6E8 0    0x4             \
                        0x0301      0xAAE8 0    0x4             \
                        0x0301      0xAEE8 0    0x4             \
                        0x0301      0xB6E8 0    0x4             \
                        0x0301      0xBAE8 0    0x4             \
                        0x0301      0xBEE8 0    0x4             \
                        0x0301      0xC2E8 0    0x4             \
                        0x0301      0xC6E8 0    0x4             \
                        0x0301      0xCAE8 0    0x4             \
                        0x0301      0xCEE8 0    0x4             \
                        0x0301      0xD2E8 0    0x4             \
                        0x0301      0xD6E8 0    0x4             \
                        0x0301      0xDAE8 0    0x4             \
                        0x0301      0xDEE8 0    0x4             \
                        0x0301      0xE2E8 0    0x4             \
                        0x0301      0xE6E8 0    0x4             \
                        0x0301      0xEAE8 0    0x4             \
                        0x0301      0xEEE8 0    0x4             \
                        0x0301      0xF000 0        0x1000      \
                        0x0302      0x03 0x03       0xffffffff  \
                        0x0302      0x04 0x04       0xffffffff  \
                        0x0302      0x0E 0x0E       0xffffffff  \
                        0x0302      0x06 0x06       0xffffffff  \
                        0x0302      0x0C 0x0C       0xffffffff  \
                        0x0302      0x01 0x01       0xffffffff  \
                        0x0303      0xEFFFFFFF 0    0x10000000

                    Eisa = REG_RESOURCE_LIST        0x0124      \
                        1 2 1 0 0x11                            \
                        0x0301      0x0400 0    0x100           \
                        0x0301      0xFC00 0    0x400           \
                        0x0301      0xEC00 0    0x400           \
                        0x0301      0xDC00 0    0x400           \
                        0x0301      0xCC00 0    0x400           \
                        0x0301      0xBC00 0    0x400           \
                        0x0301      0xAC00 0    0x400           \
                        0x0301      0x9C00 0    0x400           \
                        0x0301      0x8C00 0    0x400           \
                        0x0301      0x7C00 0    0x400           \
                        0x0301      0x6C00 0    0x400           \
                        0x0301      0x5C00 0    0x400           \
                        0x0301      0x4C00 0    0x400           \
                        0x0301      0x3C00 0    0x400           \
                        0x0301      0x2C00 0    0x400           \
                        0x0301      0x1C00 0    0x400           \
                        0x0301      0x0C00 0    0x400

                AssignmentOrdering
                    Isa     = PCFlat
                    Eisa    = PCFlat
                    MCA     = PCFlat
                    PCMCIA  = PCFlat

                    PCFlat = REG_RESOURCE_REQUIREMENTS  0x000004A8          \
                        0x000004A8 0 0 0 0 0 0 1   0x00010001 0x00000024    \
                          0x0100 0  0 0  0x0500 0 0xFFFF 0                  \
                                                                            \
                          0x0108 0  0 0  0x0140 0 0x017F 0                  \
                          0x0108 0  0 0  0x0200 0 0x02FF 0                  \
                          0x0108 0  0 0  0x0300 0 0x036F 0                  \
                                                                            \
                          0x0108 0  0 0  0x0378 0 0x037A 0                  \
                          0x0108 0  0 0  0x02E8 0 0x02FF 0                  \
                          0x0108 0  0 0  0x01F0 0 0x01F8 0                  \
                          0x0108 0  0 0  0x03B0 0 0x03CF 0                  \
                          0x0108 0  0 0  0x03E8 0 0x03FF 0                  \
                          0x0108 0  0 0  0x01CE 0 0x01CF 0                  \
                          0x0108 0  0 0  0x0100 0 0x03FF 0                  \
                                                                            \
                          0x0200 0  0x0F 0x0F  0 0 0 0                      \
                          0x0208 0  0x0D 0x0D  0 0 0 0                      \
                          0x0208 0  0x0C 0x0C  0 0 0 0                      \
                          0x0208 0  0x09 0x09  0 0 0 0                      \
                          0x0208 0  0x08 0x08  0 0 0 0                      \
                          0x0208 0  0x07 0x07  0 0 0 0                      \
                          0x0208 0  0x0B 0x0B  0 0 0 0                      \
                          0x0208 0  0x0A 0x0A  0 0 0 0                      \
                          0x0208 0  0x02 0x02  0 0 0 0                      \
                          0x0208 0  0x05 0x05  0 0 0 0                      \
                          0x0208 0  0x03 0x03  0 0 0 0                      \
                          0x0208 0  0x04 0x04  0 0 0 0                      \
                          0x0208 0  0x0E 0x0E  0 0 0 0                      \
                          0x0208 0  0x06 0x06  0 0 0 0                      \
                          0x0208 0  0x0C 0x0C  0 0 0 0                      \
                          0x0208 0  0x01 0x01  0 0 0 0                      \
                          0x0208 0  0x00 0x0F  0 0 0 0                      \
                                                                            \
                          0x0300 0  0 0  0x00100000 0 0xFFFFFFFF 0          \
                          0x0308 0  0 0  0x000F0000 0 0x000FFFFF 0          \
                          0x0308 0  0 0  0x00080000 0 0x000BFFFF 0          \
                          0x0308 0  0 0  0x00080000 0 0x000FFFFF 0          \
                          0x0308 0  0 0  0x00080000 0 0xFFBFFFFF 0          \
                                                                            \
                          0x0400 0  0x06 0x0F  0 0 0 0                      \
                          0x0408 0  0x03 0x04  0 0 0 0                      \
                          0x0408 0  0x00 0x0F  0 0 0 0

                    PCI = REG_RESOURCE_REQUIREMENTS  0x00000128             \
                        0x00000128 0 0 0 0 0 0 1   0x00010001 0x00000008    \
                          0x0100 0  0 0  0x0500 0 0xFFFF 0                  \
                                                                            \
                          0x0200 0  0x00 0xFF  0 0 0 0                      \
                                                                            \
                          0x0300 0  0 0  0x00100000 0 0xFFFFFFFF 0          \
                          0x0308 0  0 0  0x000F0000 0 0x000FFFFF 0          \
                          0x0308 0  0 0  0x00080000 0 0x000BFFFF 0          \
                          0x0308 0  0 0  0x00080000 0 0x000FFFFF 0          \
                          0x0308 0  0 0  0x00080000 0 0xFFBFFFFF 0          \
                                                                            \
                          0x0400 0  0x06 0xFF  0 0 0 0
            NetworkProvider
                Order
                    ProviderOrder = REG_SZ LanmanWorkstation
            ComputerName
                ComputerName

            UsbFlags
                IgnoreHWSerNum04710302 = REG_BINARY 1 1
                IgnoreHWSerNum07810002 = REG_BINARY 1 1
                GenericUSBDeviceString = REG_SZ "USB Device"
                GenericCompositeUSBDeviceString = REG_SZ "Composite USB Device"

        Hardware Profiles              [UserR PowerR   AdminFull SystemFull CreatorFull]
            0000                       [UserR PowerR   AdminFull SystemFull CreatorFull]
                Software               [UserR PowerRWD AdminFull SystemFull CreatorFull]
                System                 [UserR PowerR   AdminFull SystemFull CreatorFull]

        Services

            setupdd
                //
                // Do NOT change the unnamed value without also changing
                // SpReadSKUStuff() in text mode setup (spconfig.c)
                //
                = REG_BINARY 16 EVALTIME STEPUP RESTRICT_CPU SUITE_TYPE
                group = drivers
                start = REG_DWORD 0x00000000
                tag = REG_DWORD 0x00000001
                type = REG_DWORD 0x00000001
            Pci
                group = Boot Bus Extender
                tag =  REG_DWORD 0x00000002
                Parameters
                     // Devices specific settings (value name is DevID
                     // cat with VenID)
                     // Bit 0: Devices video wanting no IRQ
                     // Bit 1: Devices PCMCIA wanting IRQ
                     // Bit 2: Devices Dual PCI IDE without programming
                     // code with bit 3 set

                     1045C621 = REG_BINARY 8 0x00000004 0x00000000
                     10950640 = REG_BINARY 8 0x00000004 0x00000000
                     80861230 = REG_BINARY 8 0x00000004 0x00000000
                     80867010 = REG_BINARY 8 0x00000004 0x00000000

                     // Bit 3: Devices needing no enum at all

                     104B0140 = REG_BINARY 8 0x00000008 0x00000000
                     11790603 = REG_BINARY 8 0x00000008 0x00000000
                     80867113 = REG_BINARY 8 0x00000008 0x00000000
                     497884C5 = REG_BINARY 8 0x00000008 0x00000000
                     11063040 = REG_BINARY 8 0x00000008 0x00000000

                     // Bit 4: Devices needing no resources but having
                     // garbage in base address registers

                     0E111000 = REG_BINARY 8 0x00000010 0x00000000
                     0E112000 = REG_BINARY 8 0x00000010 0x00000000
                     10390406 = REG_BINARY 8 0x00000010 0x00000000
                     80860482 = REG_BINARY 8 0x00000010 0x00000000
                     80860008 = REG_BINARY 8 0x00000010 0x00000000
                     10140002 = REG_BINARY 8 0x00000010 0x00000000

                     // Bit 5: Devices needing dword access

                     10800600 = REG_BINARY 8 0x00000020 0x00000000

                     // Bit 6: Devices being single function parading as
                     // multiple functions

                     10131100 = REG_BINARY 8 0x00000040 0x00000000

                     // Bit 7: Device always enabled

                     10B95219 = REG_BINARY 8 0x00000080 0x00000000

                     // Bit 8: Device is IDE even though not class code of
                     // 0101

                     1C1C0001 = REG_BINARY 8 0x00000100 0x00000000
                     10970038 = REG_BINARY 8 0x00000100 0x00000000

                     // Bit 9: Device is video even though not class code
                     // of 0001 or 03xx
                     // Bit 10: Automatically fail to start the device. It
                     // is not supported in pmode

                     100BD001 = REG_BINARY 8 0x00000400 0x00000000

                     // Bit 11: Device can only appear on bus 0 (improperly
                     // decode type 1 transactions)

                     808604A3 = REG_BINARY 8 0x00000800 0x00000000
                     10AA0000 = REG_BINARY 8 0x00000800 0x00000000
                     533388D1 = REG_BINARY 8 0x00000800 0x00000000

                     // Bit 12: Device can only appear on dev <16

                     11790605 = REG_BINARY 8 0x00001000 0x00000000

                     // Bit 13: Bridge device can only have children at Dev0

                     10131110 = REG_BINARY 8 0x00002000 0x00000000

                     //
                     // Most Ricoh cardbus controllers
                     //
                     11800478 = REG_BINARY 8 0x00002000 0x00000000
                     11800475 = REG_BINARY 8 0x00002000 0x00000000
                     11800476 = REG_BINARY 8 0x00002000 0x00000000
                     11800478 = REG_BINARY 8 0x00002000 0x00000000
                     11800475 = REG_BINARY 8 0x00002000 0x00000000

                     // Bit 14: Do not modify the command bits of the device

                     // 10040102 = REG_BINARY 8 0x00004000 0x00000000 (in multibit section)

                     10040101 = REG_BINARY 8 0x00004000 0x00000000
                     10421000 = REG_BINARY 8 0x00004000 0x00000000

                     // BUGBUG(andrewth) - hack to make Compaq Proliant 5000's
                     // boot (don't turn on 2nd EISA bridge).
                     // This should go away post Beta2

                     80860482 = REG_BINARY 8 0x00004000 0x00000000

                     // Bit 15: Device is VGA even though not class code
                     // of 0001 or 0300 (only has meaning if bit 9 is set).
                     // Bit 16: Device is MF CardBus controller that shares
                     // Command register

                     104CAC12 = REG_BINARY 8 0x00010000 0x00000000
                     11800466 = REG_BINARY 8 0x00010000 0x00000000

                     // Bit 17: Device is a PCI/PCI bridge with straight
                     // thru routing (pin A to pin A, etc).
                     // Bit 18: Device is a subtractive decode PCI-PCI
                     // bridge with writable IO window

                     10140095 = REG_BINARY 8 0x00040000 0x00000000
                     //
                     // Intel ICH/ICH2 are forced into subtractive mode
                     //
                     80862418 = REG_BINARY 8 0x00040000 0x00000000
                     80862428 = REG_BINARY 8 0x00040000 0x00000000
                     8086244E = REG_BINARY 8 0x00040000 0x00000000
                     80862448 = REG_BINARY 8 0x00040000 0x00000000

                     // Bit 19: Device is a PCI/ISA bridge with F-DMA ability

                     8086122E = REG_BINARY 8 0x00080000 0x00000000
                     80867000 = REG_BINARY 8 0x00080000 0x00000000
                     80867110 = REG_BINARY 8 0x00080000 0x00000000
                     80867600 = REG_BINARY 8 0x00080000 0x00000000

                     // Bit 20: Device does not allow IRQ sharing
                     // Bit 21: Device does not allow level triggered IRQ
                     // Bit 22: Device has dynamically configurable
                     // subsystem IDs.

                     10024747 = REG_BINARY 8 0x00400000 0x00000000
                     10024754 = REG_BINARY 8 0x00400000 0x00000000
                     53338901 = REG_BINARY 8 0x00400000 0x00000000
                     101300D6 = REG_BINARY 8 0x00400000 0x00000000
                     104CAC15 = REG_BINARY 8 0x00400000 0x00000000
                     110B0004 = REG_BINARY 8 0x00400000 0x00000000
                     1000000F = REG_BINARY 8 0x00400000 0x00000000
                     104CAC17 = REG_BINARY 8 0x00400000 0x00000000
                     10239397 = REG_BINARY 8 0x00400000 0x00000000
                     10024742 = REG_BINARY 8 0x00400000 0x00000000
                     10024744 = REG_BINARY 8 0x00400000 0x00000000
                     10024749 = REG_BINARY 8 0x00400000 0x00000000
                     10024750 = REG_BINARY 8 0x00400000 0x00000000
                     10024751 = REG_BINARY 8 0x00400000 0x00000000
                     10024755 = REG_BINARY 8 0x00400000 0x00000000
                     10024757 = REG_BINARY 8 0x00400000 0x00000000
                     10024759 = REG_BINARY 8 0x00400000 0x00000000
                     10024C42 = REG_BINARY 8 0x00400000 0x00000000
                     10024C44 = REG_BINARY 8 0x00400000 0x00000000
                     10024C47 = REG_BINARY 8 0x00400000 0x00000000
                     10024C49 = REG_BINARY 8 0x00400000 0x00000000
                     10024C50 = REG_BINARY 8 0x00400000 0x00000000
                     10024C51 = REG_BINARY 8 0x00400000 0x00000000
                     10025654 = REG_BINARY 8 0x00400000 0x00000000
                     10025655 = REG_BINARY 8 0x00400000 0x00000000
                     10025656 = REG_BINARY 8 0x00400000 0x00000000
                     121A0003 = REG_BINARY 8 0x00400000 0x00000000
                     11C15811 = REG_BINARY 8 0x00400000 0x00000000
                     
                     1045C861107B9300 = REG_BINARY 8 0x00400000 0x00000000
                     1045C8611045C861 = REG_BINARY 8 0x00400000 0x00000000
                     
                     // Bit 23: Device does not allow the WritePostingEnable
                     // bit to be set in CBB on the same bus.

                     // Bit 24: Create with the old ID (note that these are
                     // overridable so that when they rev their driver they
                     // can clear that bit).

                     80861231 = REG_BINARY 8 0x01000000 0x00000000
                     12730002 = REG_BINARY 8 0x01000000 0x00000000
                     1014007D = REG_BINARY 8 0x01000000 0x00000000
                     12850100 = REG_BINARY 8 0x01000000 0x00000000

                     // Bit 25: Do not shrink the memory window of this bridge.
                     // Bit 26: Turn off parity on this device
                     // Bit 27: Dont program the BAR registers for non-PCI
                     // children.

                     12176836 = REG_BINARY 8 0x08000000 0x00000000
                     12176832 = REG_BINARY 8 0x08000000 0x00000000

                     // Bit 29: Devices that claim to be able to do Power
                     //         management but don't get it right.

                     109107A0 = REG_BINARY 8 0x20000000 0x00000000
                     80867800 = REG_BINARY 8 0x20000000 0x00000000
                     10c88005 = REG_BINARY 8 0x20000000 0x00000000
                     10c88006 = REG_BINARY 8 0x20000000 0x00000000
                     10c80005 = REG_BINARY 8 0x20000000 0x00000000
                     10c80006 = REG_BINARY 8 0x20000000 0x00000000
                     102B1001 = REG_BINARY 8 0x20000000 0x00000000
                     // E&S graphics adapter
                     10DD0100 = REG_BINARY 8 0x20000000 0x00000000
                     // CMD Devices
                     10950646 = REG_BINARY 8 0x20000000 0x00000000
                     10950670 = REG_BINARY 8 0x20000000 0x00000000
                     // CMD IDE controller that turns into a Raid controller after D3->D0
                     10950648 = REG_BINARY 8 0x20000000 0x00000000
   
                     // NMA2 Audio
                     10C88005 = REG_BINARY 8 0x20000000 0x00000000
                     // Intel 64bit power managed bridge.  This device forgets
                     // its on a 64bit bus when D3->D0 and appears to corrupt
                     // bus traffic there after. Bug 411282 (in both DEC and
                     // intel vendor ID variants)
                     10110026 = REG_BINARY 8 0x20000000 0x00000000
                     8086B154 = REG_BINARY 8 0x20000000 0x00000000
                     
                     53338904 = REG_BINARY 8 0x20000000 0x00000000
                     
                     // VIA AGP Bridges - Raid #401073
                     11068598 = REG_BINARY 8 0x20000000 0x00000000
                     11068605 = REG_BINARY 8 0x20000000 0x00000000

                     // Bit 30: Devices we shouldn't disable the decodes on for
                     //         various reasons.  This is rather like preserve
                     //         command (bit 14) but we are allowed to turn on
                     //         the device just not turn it off.


                     // In this particular case it is a Toshiba docking bridge
                     // if we turn off the decodes as part of an APM suspend then
                     // the BIOS fails the resume because it can't see the floppy
                     // controller in the dock
                     11790609 = REG_BINARY 8 0x40000000 0x00000000

                     //
                     // This is another APM docking issue with IBM machines.  If
                     // we reset the bridge the PIIX IDE contoller they have
                     // hidden in config space apprears and is reset so the
                     // channels are disabled and the IDE devices are surprise
                     // removed.  By not clearing the decodes on the docking
                     // bridge we don't reset it and all is well
                     //
                     10140047 = REG_BINARY 8 0x40000000 0x00000000

                     // Bit 31: Devices that lose SSID after being having their
                     //         power management registers set to D0 from D3.
                     //

                     102B051B = REG_BINARY 8 0x80000000 0x00000000
                     102B1001 = REG_BINARY 8 0x80000000 0x00000000
                     102B0520 = REG_BINARY 8 0x80000000 0x00000000
                     102B0521 = REG_BINARY 8 0x80000000 0x00000000
                     102B1025 = REG_BINARY 8 0x80000000 0x00000000
                     102B0525 = REG_BINARY 8 0x80000000 0x00000000
                     102B2527 = REG_BINARY 8 0x80000000 0x00000000
                     102B2537 = REG_BINARY 8 0x80000000 0x00000000
                     102B0527 = REG_BINARY 8 0x80000000 0x00000000
                     102B0528 = REG_BINARY 8 0x80000000 0x00000000
                     80867121 = REG_BINARY 8 0x80000000 0x00000000
                     80867123 = REG_BINARY 8 0x80000000 0x00000000
                     80867125 = REG_BINARY 8 0x80000000 0x00000000
                     80861132 = REG_BINARY 8 0x80000000 0x00000000
                     90050050 = REG_BINARY 8 0x80000000 0x00000000
                     9005005F = REG_BINARY 8 0x80000000 0x00000000
                     10024752 = REG_BINARY 8 0x80000000 0x00000000
                     1002474F = REG_BINARY 8 0x80000000 0x00000000
                     1002474D = REG_BINARY 8 0x80000000 0x00000000
                     10024753 = REG_BINARY 8 0x80000000 0x00000000
                     1002474C = REG_BINARY 8 0x80000000 0x00000000
                     1002474E = REG_BINARY 8 0x80000000 0x00000000
                     10024C4D = REG_BINARY 8 0x80000000 0x00000000
                     10024C4E = REG_BINARY 8 0x80000000 0x00000000
                     10024C52 = REG_BINARY 8 0x80000000 0x00000000
                     10024C53 = REG_BINARY 8 0x80000000 0x00000000
                     10239880 = REG_BINARY 8 0x80000000 0x00000000
                     10DE00A0 = REG_BINARY 8 0x80000000 0x00000000
                     10DE00A1 = REG_BINARY 8 0x80000000 0x00000000
                     10DE00A3 = REG_BINARY 8 0x80000000 0x00000000
                     10DE00B0 = REG_BINARY 8 0x80000000 0x00000000
                     10DE00B1 = REG_BINARY 8 0x80000000 0x00000000
                     10DE00B3 = REG_BINARY 8 0x80000000 0x00000000
                     10DE0100 = REG_BINARY 8 0x80000000 0x00000000
                     10DE0101 = REG_BINARY 8 0x80000000 0x00000000
                     10DE0102 = REG_BINARY 8 0x80000000 0x00000000
                     10DE0103 = REG_BINARY 8 0x80000000 0x00000000
                     10DE0120 = REG_BINARY 8 0x80000000 0x00000000
                     10DE0121 = REG_BINARY 8 0x80000000 0x00000000
                     10DE0122 = REG_BINARY 8 0x80000000 0x00000000
                     10DE0123 = REG_BINARY 8 0x80000000 0x00000000
                     10DE0150 = REG_BINARY 8 0x80000000 0x00000000
                     10DE0151 = REG_BINARY 8 0x80000000 0x00000000
                     10DE0152 = REG_BINARY 8 0x80000000 0x00000000
                     10DE0153 = REG_BINARY 8 0x80000000 0x00000000
                     10DE0200 = REG_BINARY 8 0x80000000 0x00000000
                     10DE0201 = REG_BINARY 8 0x80000000 0x00000000
                     10DE0202 = REG_BINARY 8 0x80000000 0x00000000
                     10DE0203 = REG_BINARY 8 0x80000000 0x00000000
                     12D20018 = REG_BINARY 8 0x80000000 0x00000000
                     12D20019 = REG_BINARY 8 0x80000000 0x00000000
                     10136003 = REG_BINARY 8 0x80000000 0x00000000
                     3D3D000A = REG_BINARY 8 0x80000000 0x00000000
                     
                     // Bit 32: Early video cards that ignore the  
                     //         PCI spec and decode all sorts of legacy
                     //         ranges.
                     
                     10024158 = REG_BINARY 8 0x00000000 0x00000001
                     10024354 = REG_BINARY 8 0x00000000 0x00000001
                     10024358 = REG_BINARY 8 0x00000000 0x00000001
                     10024554 = REG_BINARY 8 0x00000000 0x00000001
                     10024754 = REG_BINARY 8 0x00000000 0x00000001
                     10024758 = REG_BINARY 8 0x00000000 0x00000001
                     10024C54 = REG_BINARY 8 0x00000000 0x00000001
                     10025654 = REG_BINARY 8 0x00000000 0x00000001
                     10025654 = REG_BINARY 8 0x00000000 0x00000001
                     53338810 = REG_BINARY 8 0x00000000 0x00000001
                     53338811 = REG_BINARY 8 0x00000000 0x00000001
                     53338812 = REG_BINARY 8 0x00000000 0x00000001
                     53338814 = REG_BINARY 8 0x00000000 0x00000001
                     53338880 = REG_BINARY 8 0x00000000 0x00000001
                     533388B0 = REG_BINARY 8 0x00000000 0x00000001
                     533388C0 = REG_BINARY 8 0x00000000 0x00000001
                     533388C1 = REG_BINARY 8 0x00000000 0x00000001
                     533388D0 = REG_BINARY 8 0x00000000 0x00000001
                     533388D1 = REG_BINARY 8 0x00000000 0x00000001
                     533388F0 = REG_BINARY 8 0x00000000 0x00000001
                     53338901 = REG_BINARY 8 0x00000000 0x00000001
                     53338902 = REG_BINARY 8 0x00000000 0x00000001

                     // Bit 33: Devices with incorrect class codes.
                     //         Treat as if they specified generic
                     //         system device class code.

                     0E11B109 = REG_BINARY 8 0x00000000 0x00000002
                     
                     // Bit 34: Bridges that need to be reset on 
                     //         power up
                     
                     // More than one bit
                     100C3202 = REG_BINARY 8 0x00008A00 0x00000000
                     10668002 = REG_BINARY 8 0x00300000 0x00000000
                     10660002 = REG_BINARY 8 0x00300000 0x00000000
                     10040102 = REG_BINARY 8 0x02004000 0x00000000
                     1045C814 = REG_BINARY 8 0x20400000 0x00000000
                     10024756 = REG_BINARY 8 0x20400000 0x00000000
                     10024757 = REG_BINARY 8 0x20400000 0x00000000
                     10024759 = REG_BINARY 8 0x20400000 0x00000000
                     1002475A = REG_BINARY 8 0x20400000 0x00000000
                     1000000B = REG_BINARY 8 0xa0000000 0x00000000
                     10DE0020 = REG_BINARY 8 0xa0000000 0x00000000
                     10DE0028 = REG_BINARY 8 0xa0000000 0x00000000
                     10DE0029 = REG_BINARY 8 0xa0000000 0x00000000
                     10DE002A = REG_BINARY 8 0xa0000000 0x00000000
                     10DE002B = REG_BINARY 8 0xa0000000 0x00000000
                     10DE002C = REG_BINARY 8 0xa0000000 0x00000000
                     10DE002D = REG_BINARY 8 0xa0000000 0x00000000
                     10DE002E = REG_BINARY 8 0xa0000000 0x00000000
                     10DE002F = REG_BINARY 8 0xa0000000 0x00000000

                     // Specific devices that don't need the workarounds
                     // specified above.

                     101300D6101880D6 = REG_BINARY 8 0x00000000 0x00000000

            PciIde
                group = System Bus Extender
                tag =  REG_DWORD 0x00000003
            IntelIde
                group = System Bus Extender
                tag =  REG_DWORD 0x00000004
            CmdIde
                group = System Bus Extender
                tag =  REG_DWORD 0x00000004
            TosIde
                group = System Bus Extender
                tag =  REG_DWORD 0x00000004
            ViaIde
                group = System Bus Extender
                tag =  REG_DWORD 0x00000004
            AliIde
                group = System Bus Extender
                tag =  REG_DWORD 0x00000004

            tffsport
                Parameters
                    LegacyDetection       = REG_DWORD    0x00000001

            atapi
                Parameters
                    LegacyDetection       = REG_DWORD    0x00000001
                    GhostSlave            = REG_MULTI_SZ "SunDisk "
                    UseCheckPowerForFlush = REG_MULTI_SZ "SAMSUNG WNR-31601A (1600MB)             " \
                                                         "SAMSUNG WNR-31601A (1.6GB)              " \
                                                         "IBM-DTCA-24090                          TC6OAA2A" \
                                                         "IBM-DTCA-24090                          TC6IAA2A" \
                                                         "IBM-DPLA-25120                          PL8OAA2A" \
                                                         "IBM-DPLA-25120                          PL8IAA2A" \
                                                         "IBM-DPLA-25120                          PL8IAA4A" \
                                                         "IBM-DTCA-23240                          TC5OAA2A" \
                                                         "IBM-DTCA-23240                          TC5IAA2A" \
                                                         "IBM-DPLA-24480                          PL7OAA2A" \
                                                         "IBM-DPLA-24480                          PL7IAA2A"
                    NoFlushDevice         = REG_MULTI_SZ "QUANTUM_LPS525A                         " \
                                                         "SCR-730                                 "
                    PioOnlyDevice         = REG_MULTI_SZ "    Conner Peripherals 425MB - CFS425A  " \
                                                         "MATSHITA CR-581                         " \
                                                         "FX600S                                  " \
                                                         "CD-44E                                  " \
                                                         "QUANTUM TRB850A                         " \
                                                         "QUANTUM MARVERICK 540A                  " \
                                                         " MAXTOR MXT-540  AT                     " \
                                                         "Maxtor 71260 AT                         " \
                                                         "Maxtor 7850 AV                          " \
                                                         "Maxtor 7540 AV                          " \
                                                         "Maxtor 7213 AT                          " \
                                                         "Maxtor 7345                             " \
                                                         "Maxtor 7245 AT                          " \
                                                         "Maxtor 7245                             " \
                                                         "Maxtor 7211AU                           " \
                                                         "Maxtor 7171 AT                          " \
                                                         "CD-316E                                 " \
                                                         "SAMSUNG_SCR-2430" \
                                                         "CR-2801TE"
                    NonRemovableMedia     = REG_MULTI_SZ "Kingston Technology DataPak 340         " \
                                                         "SunDisk SDP5A-10                        " \
                                                         "SunDisk SDCFB-10                        " \
                                                         "SunDisk SDP3B-20                        " \
                                                         "SunDisk SDP3B-175                       " \
                                                         "SunDisk SDP5-2.5                        " \
                                                         "Calluna Technology CT260MC              " \
                                                         "BN-S004AC-S 1.00"                         \
                                                         "Calluna Technology CT520RM"               \
                                                         "Hitachi CV 5.1.1"                         \
                                                         "      ATA_FLASH "                         \
                                                         "Mitsubishi ATA Card "                     \
                                                         "LEXAR ATA_FLASH"                          \
                                                         "MICRON MTCF004A"                          \
                                                         "Micron MTCF008A"                          \
                                                         "SunDisk SDP3B-110"                        \
                                                         "SunDisk SDCFB-4"                          \
                                                         "BN-CAB-T"                                 \
                                                         "MEMORYSTICK   8M  8K"
                    NoPowerDownDevice     = REG_MULTI_SZ "RD-DRC001-M                             " \
                                                         "CS-R37 0                                "
                    AutoEjectZipDevice    = REG_MULTI_SZ "IOMEGA  ZIP 100       ATAPI             23.D    " \
                                                         "IOMEGA  ZIP 100       ATAPI             21.D    " \
                                                         "IOMEGA  ZIP 100       ATAPI             20.D    " \
                                                         "IOMEGA  ZIP 100       ATAPI             91.D    " \
                                                         "IOMEGA  ZIP 100                         B.29    " \
                                                         "IOMEGA  ZIP 100                         B.22    "
                    NeedIdentDevice         = REG_MULTI_SZ "QUANTUM FIREBALL"
            acpi
                group = Boot Bus Extender
                tag =  REG_DWORD 0x00000001
            cdrom
                AutoRunAlwaysDisable = REG_MULTI_SZ "NRC     MBR-7   " \
                                                    "NRC     MBR-7.4 " \
                                                    "PIONEER_CHANGR_DRM-1804X" \
                                                    "PIONEER_CD-ROM_DRM-6324X" \
                                                    "PIONEER_CD-ROM_DRM-624X"
            Pcmcia
                group = System Bus Extender
                tag =  REG_DWORD 0x00000001
                Parameters
                    ForcePolledMode       = REG_DWORD    0x00000001
            isapnp
                group = Boot Bus Extender
                tag =  REG_DWORD 0x00000003

                Parameters
                     // Card specific settings (value name is serial id)
                     // Bit 0: Devices that break isolation protocol
                     //        after being started

                     ADP1502 = REG_DWORD 0x00000001
                     ADP1505 = REG_DWORD 0x00000001
                     ADP1510 = REG_DWORD 0x00000001
                     ADP1512 = REG_DWORD 0x00000001
                     ADP1515 = REG_DWORD 0x00000001
                     ADP1520 = REG_DWORD 0x00000001
                     ADP1522 = REG_DWORD 0x00000001
                     ADP3015 = REG_DWORD 0x00000001
                     ADP3215 = REG_DWORD 0x00000001
                     ADP6360 = REG_DWORD 0x00000001
                     ADP6370 = REG_DWORD 0x00000001

                     // all TI 8 bit isapnp controllerless modems need this
                     USR0014 = REG_DWORD 0x00000001
                     USR1001 = REG_DWORD 0x00000001
                     USR1002 = REG_DWORD 0x00000001
                     USR1003 = REG_DWORD 0x00000001
                     USR1004 = REG_DWORD 0x00000001
                     USR6001 = REG_DWORD 0x00000001
                     USR6002 = REG_DWORD 0x00000001
                     USR6003 = REG_DWORD 0x00000001
                     USR6004 = REG_DWORD 0x00000001
                     USR6005 = REG_DWORD 0x00000001
                     USR6006 = REG_DWORD 0x00000001
                     USR6007 = REG_DWORD 0x00000001
                     USR6008 = REG_DWORD 0x00000001
                     USR6009 = REG_DWORD 0x00000001
                     USR600A = REG_DWORD 0x00000001
                     USR600B = REG_DWORD 0x00000001
                     USR600C = REG_DWORD 0x00000001
                     USR600D = REG_DWORD 0x00000001
                     USR600E = REG_DWORD 0x00000001
                     USR600F = REG_DWORD 0x00000001
                     USR6010 = REG_DWORD 0x00000001
                     USR6011 = REG_DWORD 0x00000001
                     USR6012 = REG_DWORD 0x00000001
                     USR6101 = REG_DWORD 0x00000001
                     USR6020 = REG_DWORD 0x00000001
                     USR0041 = REG_DWORD 0x00000001
                     USR002C = REG_DWORD 0x00000001
                     AZT4029 = REG_DWORD 0x00000001
                     AZT4023 = REG_DWORD 0x00000001
                     USR0040 = REG_DWORD 0x00000001
                     HAY8601 = REG_DWORD 0x00000001

                     // Bit 2: Ignore boot config
                     EQX2400 = REG_DWORD 0x00000002
                     EQX0900 = REG_DWORD 0x00000002
                     EQX1B00 = REG_DWORD 0x00000002
                     EQX1700 = REG_DWORD 0x00000002
                     EQX0700 = REG_DWORD 0x00000002
                     EQX0F00 = REG_DWORD 0x00000002
                     EQX0800 = REG_DWORD 0x00000002
                     EQX1000 = REG_DWORD 0x00000002
                     EQX3F00 = REG_DWORD 0x00000002
                     EQX1200 = REG_DWORD 0x00000002
                     // Bit 3: Force level interrupts
                     // Bit 4: Force edge interrupts

                     // Bit 5: IBM memory boot config
                     IBM0001 = REG_DWORD 0x00000010

            acpiec
                group = Boot Bus Extender
                tag =  REG_DWORD 0x00000005
            ohci1394
                group = Boot Bus Extender
                tag =  REG_DWORD 0x00000004
            mountmgr
                group = System Bus Extender
                tag =  REG_DWORD 0x00000008
            ftdisk
                group = System Bus Extender
                tag =  REG_DWORD 0x00000009
            partmgr
                group = System Bus Extender
                tag =  REG_DWORD 0x0000000a
            volsnap
                group = System Bus Extender
            fdc
                group = System Bus Extender
                tag =  REG_DWORD 0x0000000b
            dmload
                group = System Bus Extender
                tag =  REG_DWORD 0x0000000c
            dmio
                group = System Bus Extender
                tag =  REG_DWORD 0x0000000d
            sbp2port
                group = System Bus Extender
                tag =  REG_DWORD 0x0000000e
            dmboot
                Parameters
                    setup =  REG_DWORD 0x00000001

            Ndis
                group = drivers
                tag = REG_DWORD 0x00000002
            Tcpip
                Linkage
                    Export = REG_MULTI_SZ "\Device\Tcpip_{54C7D140-09EF-11D1-B25A-F5FE627ED95E}"
                    Bind = REG_MULTI_SZ "\Device\{54C7D140-09EF-11D1-B25A-F5FE627ED95E}"
                Parameters
                    DisableDHCPMediaSense = REG_DWORD 0x00000001
                    Adapters
                        {54C7D140-09EF-11D1-B25A-F5FE627ED95E}
                            IpConfig = REG_MULTI_SZ "Tcpip\Parameters\Interfaces\{54C7D140-09EF-11D1-B25A-F5FE627ED95E}"
                    Interfaces
                        {54C7D140-09EF-11D1-B25A-F5FE627ED95E}
                            IPAddress = REG_MULTI_SZ "0.0.0.0"
                            SubnetMask = REG_MULTI_SZ "0.0.0.0"
                            NTEContextList = REG_MULTI_SZ "0x00000002"
            NetBT
                Linkage
                    Export = REG_MULTI_SZ "\Device\NetBT_Tcpip_{54C7D140-09EF-11D1-B25A-F5FE627ED95E}"
                    Bind = REG_MULTI_SZ "\Device\Tcpip_{54C7D140-09EF-11D1-B25A-F5FE627ED95E}"
                Parameters
                    TransportBindName = "\Device\"
                    BroadcastAddress = REG_DWORD 0xffffffff
                    Interfaces
                        Tcpip_{54C7D140-09EF-11D1-B25A-F5FE627ED95E}
            LanmanWorkstation
                Linkage
                    Export = REG_MULTI_SZ "\Device\LanmanWorkstation_NetbiosSmb" \
                                          "\Device\LanmanWorkstation_NetBT_Tcpip_{54C7D140-09EF-11D1-B25A-F5FE627ED95E}"
                    Bind = REG_MULTI_SZ "\Device\NetbiosSmb" \
                                        "\Device\NetBT_Tcpip_{54C7D140-09EF-11D1-B25A-F5FE627ED95E}"
                networkprovider
                    Devicename = REG_SZ \Device\LanmanRedirector
                    ProviderPath = REG_EXPAND_SZ %SystemRoot%\System32\ntlanman.dll
                    Name = Microsoft Windows Network
                Parameters
            mrxsmb
                Linkage
                Parameters
            rdbss
               Linkage
               Parameters

            adpu160m
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            adpu320
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            afcnt
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            aha154x
                Parameters
                    PnpInterface
                        1 = REG_DWORD 0x00000001
                        3 = REG_DWORD 0x00000001

            aic116x
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            aic78u2
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            aic78xx
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            cbidf2k
                Parameters
                    PnpInterface
                        1 = REG_DWORD 0x00000001
                        5 = REG_DWORD 0x00000001

            perc2
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            hpn
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            dpti2o
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            buslogic
                Parameters
                    PnpInterface
                        1 = REG_DWORD 0x00000001
                        2 = REG_DWORD 0x00000001
                        5 = REG_DWORD 0x00000001

            flashpnt
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            dac2w2k
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            dac960nt
                Parameters
                    PnpInterface
                        2 = REG_DWORD 0x00000001
                        5 = REG_DWORD 0x00000001

            cpqcissm
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            cpqfcalm
                Parameters
                    PnpInterface
                        2 = REG_DWORD 0x00000001
                        5 = REG_DWORD 0x00000001

            cpqarray
                Parameters
                    PnpInterface
                        2 = REG_DWORD 0x00000001
                        5 = REG_DWORD 0x00000001

            cpqarry2
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            cpqfws2e
                Parameters
                    PnpInterface
                        2 = REG_DWORD 0x00000001
                        5 = REG_DWORD 0x00000001

            amsint
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            i2omp
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            iirsp
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            ipsraidn
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            nfrd960
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            symc810
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            symc8xx
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            sym_hi
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            sym_u3
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            symmpi
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            sparrow
                Parameters
                    PnpInterface
                        1 = REG_DWORD 0x00000001

            ql10wnt
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            ql2100
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            ql2200
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            ql2300
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001
            ql1280
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            ql12160
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            lp6nds35
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            asc
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            asc3550
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            asc3350p
                Parameters
                    PnpInterface
                        1 = REG_DWORD 0x00000011

            abp480n5
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            mraid35x
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001
            dellcerc
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            fireport
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            ini910u
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001
                                            
            ql1240
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001


            cd20xrnt
                Parameters
                    PnpInterface
                        1 = REG_DWORD 0x00000011

            ultra
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            hpt3xx
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001

            ql1080
                Parameters
                    PnpInterface
                        5 = REG_DWORD 0x00000001



            serial
                group = Input Device Support
                tag =  REG_DWORD 0x00000001

            serenum
                group = Input Device Support
                tag =  REG_DWORD 0x00000002

            usbohci
                group = Input Device Support
                tag =  REG_DWORD 0x00000003

            usbuhci
                group = Input Device Support
                tag =  REG_DWORD 0x00000004

            usbhub
                group = Input Device Support
                tag =  REG_DWORD 0x00000005
                    
            hidusb
                group = Input Device Support
                tag =  REG_DWORD 0x00000006

            usbstor
                group = Input Device Support
                tag =  REG_DWORD 0x00000007


    Select
        Current = REG_DWORD 0x00000001
        Default = REG_DWORD 0x00000001
        LastKnownGood = REG_DWORD 0x00000001
        Failed = REG_DWORD 0x00000000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\setupp.ini ===
[Pid]
Pid = "00000270"
ExtraData=62706A776C7766637274CE52597B39
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setupp2p.ini ===
[Pid]
ExtraData=706C6C776167676277769EA7E02284
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setupp.ini ===
[Pid]
ExtraData=796A627577696A717474395E6C6CCC
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setupp16p.ini ===
[Pid]
ExtraData=7377666B7467796D786A7A9EE4AD07
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setupp4p.ini ===
[Pid]
ExtraData=706C6C776167676277769EA7E02284
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setupp8p.ini ===
[Pid]
ExtraData=706C6C776167676277769EA7E02284
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setuppreg.ini ===
[Pid]
ExtraData=706C6C776167676277769EA7E02284
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setuppret.ini ===
[Pid]
ExtraData=706C6C776167676277769EA7E02284
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setupptb15.ini ===
[Pid]
ExtraData=7377666B7467796D786A7A9EE4AD07
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setupptb30.ini ===
[Pid]
ExtraData=7377666B7467796D786A7A9EE4AD07
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setupp32ptb444.ini ===
[Pid]
ExtraData=76797A6F646772667278627D808D51
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setupp32p.ini ===
[Pid]
ExtraData=7377666B7467796D786A7A9EE4AD07
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setupptb240.ini ===
[Pid]
ExtraData=76797A6F646772667278627D808D51
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setupptb120.ini ===
[Pid]
ExtraData=76797A6F646772667278627D808D51
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setupptb150.ini ===
[Pid]
ExtraData=76797A6F646772667278627D808D51
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setupptb180.ini ===
[Pid]
ExtraData=76797A6F646772667278627D808D51
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setupptb5.ini ===
[Pid]
ExtraData=7377666B7467796D786A7A9EE4AD07
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setupptb360.ini ===
[Pid]
ExtraData=76797A6F646772667278627D808D51
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setupptb60.ini ===
[Pid]
ExtraData=7377666B7467796D786A7A9EE4AD07
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setupptb90.ini ===
[Pid]
ExtraData=7377666B7467796D786A7A9EE4AD07
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setupptb444.ini ===
[Pid]
ExtraData=76797A6F646772667278627D808D51
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setuppupg.ini ===
[Pid]
ExtraData=796A627477686A7174743D7C7BF786
Pid=55182000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setupp16p.ini ===
[Pid]
ExtraData=796D6E677A6D696B666703A6B319B8
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setupp32ptb444.ini ===
[Pid]
ExtraData=66686A736367746661692D6361FE08
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\blade\setuppv.ini ===
[Pid]
ExtraData=796A627577696A717474395E6C6CCC
Pid=55182270
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setupp2p.ini ===
[Pid]
ExtraData=796D6E677A6D696B666703A6B319B8
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setupp.ini ===
[Pid]
ExtraData=696A646575676C717576435AF5CA9C
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setupp32p.ini ===
[Pid]
ExtraData=796D6E677A6D696B666703A6B319B8
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setupp64ptb444.ini ===
[Pid]
ExtraData=66686A736367746661692D6361FE08
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setupp8p.ini ===
[Pid]
ExtraData=796D6E677A6D696B666703A6B319B8
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setuppret.ini ===
[Pid]
ExtraData=796D6E677A6D696B666703A6B319B8
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setupp4p.ini ===
[Pid]
ExtraData=796D6E677A6D696B666703A6B319B8
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setupp64p.ini ===
[Pid]
ExtraData=796D6E677A6D696B666703A6B319B8
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setupptb150.ini ===
[Pid]
ExtraData=66686A736367746661692D6361FE08
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setupptb180.ini ===
[Pid]
ExtraData=66686A736367746661692D6361FE08
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setupptb240.ini ===
[Pid]
ExtraData=66686A736367746661692D6361FE08
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setupptb360.ini ===
[Pid]
ExtraData=66686A736367746661692D6361FE08
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setupptb444.ini ===
[Pid]
ExtraData=66686A736367746661692D6361FE08
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setupptb15.ini ===
[Pid]
ExtraData=6277686D726D61767A758EF4DBB565
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setuppreg.ini ===
[Pid]
ExtraData=766B6C63676B707A646B74BCB51636
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setupptb30.ini ===
[Pid]
ExtraData=6277686D726D61767A758EF4DBB565
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setupptb120.ini ===
[Pid]
ExtraData=6277686D726D61767A758EF4DBB565
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setupptb5.ini ===
[Pid]
ExtraData=6277686D726D61767A758EF4DBB565
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setuppupg.ini ===
[Pid]
ExtraData=696A646675666C7175766E697DC65A
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setupptb60.ini ===
[Pid]
ExtraData=6277686D726D61767A758EF4DBB565
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setupptb90.ini ===
[Pid]
ExtraData=6277686D726D61767A758EF4DBB565
Pid=55037000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setupp32ptb444.ini ===
[Pid]
ExtraData=7368757571697065727488264E87DD
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setupp2p.ini ===
[Pid]
ExtraData=696A646575676C717576435AF5CA9C
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\datacenter\setuppv.ini ===
[Pid]
ExtraData=696A646575676C717576435AF5CA9C
Pid=55037270
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setupp.ini ===
[Pid]
ExtraData=7368757571697065727488264E87DD
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setupp32p.ini ===
[Pid]
ExtraData=6C75786B6E67656A766A51BDC81F3D
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setupp16p.ini ===
[Pid]
ExtraData=6C75786B6E67656A766A51BDC81F3D
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setupp8p.ini ===
[Pid]
ExtraData=6C75786B6E67656A766A51BDC81F3D
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setupp4p.ini ===
[Pid]
ExtraData=696A646575676C717576435AF5CA9C
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setuppret.ini ===
[Pid]
ExtraData=696A646575676C717576435AF5CA9C
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setuppreg.ini ===
[Pid]
ExtraData=696A646575676C717576435AF5CA9C
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setupptb15.ini ===
[Pid]
ExtraData=6C75786B6E67656A766A51BDC81F3D
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setupptb444.ini ===
[Pid]
ExtraData=7368757571697065727488264E87DD
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setupptb30.ini ===
[Pid]
ExtraData=6C75786B6E67656A766A51BDC81F3D
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setupptb5.ini ===
[Pid]
ExtraData=6C75786B6E67656A766A51BDC81F3D
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setupptb180.ini ===
[Pid]
ExtraData=70656171796977757066706BA53D08
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setupptb150.ini ===
[Pid]
ExtraData=70656171796977757066706BA53D08
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setupptb120.ini ===
[Pid]
ExtraData=70656171796977757066706BA53D08
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setupptb360.ini ===
[Pid]
ExtraData=70656171796977757066706BA53D08
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setupptb240.ini ===
[Pid]
ExtraData=70656171796977757066706BA53D08
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setupptb90.ini ===
[Pid]
ExtraData=70656171796977757066706BA53D08
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setupptb60.ini ===
[Pid]
ExtraData=70656171796977757066706BA53D08
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setuppupg.ini ===
[Pid]
ExtraData=73687576716A70657274C54606F15E
Pid=55039000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\enterprise\setuppv.ini ===
[Pid]
ExtraData=7368757571697065727488264E87DD
Pid=55039270
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setupp32ptb444.ini ===
[Pid]
ExtraData=6C626A7169656E72636816F6135192
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setupp4p.ini ===
[Pid]
ExtraData=666F6D6765636376687810AD174A48
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setupp8p.ini ===
[Pid]
ExtraData=666F6D6765636376687810AD174A48
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setupp16p.ini ===
[Pid]
ExtraData=666F6D6765636376687810AD174A48
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setupp32p.ini ===
[Pid]
ExtraData=666F6D6765636376687810AD174A48
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setupp2p.ini ===
[Pid]
ExtraData=666F6D6765636376687810AD174A48
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setupp.ini ===
[Pid]
ExtraData=6C626A7169656E72636816F6135192
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setuppreg.ini ===
[Pid]
ExtraData=666F6D6765636376687810AD174A48
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setuppret.ini ===
[Pid]
ExtraData=666F6D6765636376687810AD174A48
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setupptb180.ini ===
[Pid]
ExtraData=6C626A7169656E72636816F6135192
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setupptb240.ini ===
[Pid]
ExtraData=6C626A7169656E72636816F6135192
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setupptb360.ini ===
[Pid]
ExtraData=6C626A7169656E72636816F6135192
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setupptb444.ini ===
[Pid]
ExtraData=6C626A7169656E72636816F6135192
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setupptb30.ini ===
[Pid]
ExtraData=697A706D786576676274B9A4F7A74B
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setupptb90.ini ===
[Pid]
ExtraData=697A706D786576676274B9A4F7A74B
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setupptb60.ini ===
[Pid]
ExtraData=697A706D786576676274B9A4F7A74B
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setupptb120.ini ===
[Pid]
ExtraData=697A706D786576676274B9A4F7A74B
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setupptb5.ini ===
[Pid]
ExtraData=697A706D786576676274B9A4F7A74B
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setupptb15.ini ===
[Pid]
ExtraData=697A706D786576676274B9A4F7A74B
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setupptb150.ini ===
[Pid]
ExtraData=697A706D786576676274B9A4F7A74B
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setuppupg.ini ===
[Pid]
ExtraData=6C626A7269666E7263685B965B2797
Pid=55041000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setupp2p.ini ===
[Pid]
ExtraData=62707667706F726E7377A7C7A644B0
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setupp.ini ===
[Pid]
ExtraData=6C6D75656B6975747075F06FE4B149
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\personal\setuppv.ini ===
[Pid]
ExtraData=6C626A7169656E72636816F6135192
Pid=55041270
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setupp8p.ini ===
[Pid]
ExtraData=62707667706F726E7377A7C7A644B0
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setupp32ptb444.ini ===
[Pid]
ExtraData=6C6D75656B6975747075F06FE4B149
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setupp16p.ini ===
[Pid]
ExtraData=62707667706F726E7377A7C7A644B0
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setupp4p.ini ===
[Pid]
ExtraData=62707667706F726E7377A7C7A644B0
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setupp32p.ini ===
[Pid]
ExtraData=6673796D68696A79756BE052CAA7F6
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setuppreg.ini ===
[Pid]
ExtraData=62707667706F726E7377A7C7A644B0
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setuppret.ini ===
[Pid]
ExtraData=62707667706F726E7377A7C7A644B0
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setupptb15.ini ===
[Pid]
ExtraData=6673796D68696A79756BE052CAA7F6
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setupptb30.ini ===
[Pid]
ExtraData=6673796D68696A79756BE052CAA7F6
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setupptb5.ini ===
[Pid]
ExtraData=6673796D68696A79756BE052CAA7F6
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setupptb90.ini ===
[Pid]
ExtraData=6673796D68696A79756BE052CAA7F6
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setupptb60.ini ===
[Pid]
ExtraData=6673796D68696A79756BE052CAA7F6
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setupptb150.ini ===
[Pid]
ExtraData=69637379616963696E678AD5F11E91
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setupptb180.ini ===
[Pid]
ExtraData=69637379616963696E678AD5F11E91
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setupptb120.ini ===
[Pid]
ExtraData=69637379616963696E678AD5F11E91
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setupptb240.ini ===
[Pid]
ExtraData=69637379616963696E678AD5F11E91
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setupptb444.ini ===
[Pid]
ExtraData=69637379616963696E678AD5F11E91
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setupptb360.ini ===
[Pid]
ExtraData=69637379616963696E678AD5F11E91
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setuppupg.ini ===
[Pid]
ExtraData=6C6D75646B6A75747075941E33508A
Pid=55034000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\professional\setuppv.ini ===
[Pid]
ExtraData=6C6D75656B6975747075F06FE4B149
Pid=55034270
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setupp2p.ini ===
[Pid]
ExtraData=6C6D75656B6975747075F06FE4B149
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setupp.ini ===
[Pid]
ExtraData=766B6C63676B707A646B74BCB51636
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setupp32ptb444.ini ===
[Pid]
ExtraData=766B6C63676B707A646B74BCB51636
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setuppreg.ini ===
[Pid]
ExtraData=6C6D75656B6975747075F06FE4B149
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setuppret.ini ===
[Pid]
ExtraData=6C6D75656B6975747075F06FE4B149
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setupptb15.ini ===
[Pid]
ExtraData=6F706F69646B6E656969793BECB37E
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setupp32p.ini ===
[Pid]
ExtraData=6F706F69646B6E656969793BECB37E
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setupp16p.ini ===
[Pid]
ExtraData=6F706F69646B6E656969793BECB37E
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setupp4p.ini ===
[Pid]
ExtraData=6F706F69646B6E656969793BECB37E
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setupptb30.ini ===
[Pid]
ExtraData=6F706F69646B6E656969793BECB37E
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setupptb360.ini ===
[Pid]
ExtraData=766B6C63676B707A646B74BCB51636
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setupptb444.ini ===
[Pid]
ExtraData=766B6C63676B707A646B74BCB51636
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setupptb5.ini ===
[Pid]
ExtraData=6F706F69646B6E656969793BECB37E
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setupp8p.ini ===
[Pid]
ExtraData=6F706F69646B6E656969793BECB37E
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setupptb120.ini ===
[Pid]
ExtraData=737A716F776B786F6B77E3642F2412
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setupptb240.ini ===
[Pid]
ExtraData=737A716F776B786F6B77E3642F2412
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setupptb150.ini ===
[Pid]
ExtraData=737A716F776B786F6B77E3642F2412
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setupptb180.ini ===
[Pid]
ExtraData=737A716F776B786F6B77E3642F2412
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setupptb90.ini ===
[Pid]
ExtraData=737A716F776B786F6B77E3642F2412
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setuppupg.ini ===
[Pid]
ExtraData=766B6C62676C707A646BD06BE2025A
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setupptb60.ini ===
[Pid]
ExtraData=737A716F776B786F6B77E3642F2412
Pid=55038000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\server\setuppv.ini ===
[Pid]
ExtraData=766B6C63676B707A646B74BCB51636
Pid=55038270
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setupp32p.ini ===
[Pid]
ExtraData=767277696A6968706B6800CD82D368
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setupp16p.ini ===
[Pid]
ExtraData=767277696A6968706B6800CD82D368
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setupp.ini ===
[Pid]
ExtraData=636573736D6B6B6B666AA8FAE3A354
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setupp32ptb444.ini ===
[Pid]
ExtraData=636573736D6B6B6B666AA8FAE3A354
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setupp2p.ini ===
[Pid]
ExtraData=767277696A6968706B6800CD82D368
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setupp4p.ini ===
[Pid]
ExtraData=767277696A6968706B6800CD82D368
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setupp8p.ini ===
[Pid]
ExtraData=767277696A6968706B6800CD82D368
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setupptb15.ini ===
[Pid]
ExtraData=767277696A6968706B6800CD82D368
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setupptb240.ini ===
[Pid]
ExtraData=636573736D6B6B6B666AA8FAE3A354
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setupptb360.ini ===
[Pid]
ExtraData=636573736D6B6B6B666AA8FAE3A354
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setupptb444.ini ===
[Pid]
ExtraData=636573736D6B6B6B666AA8FAE3A354
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setupptb5.ini ===
[Pid]
ExtraData=767277696A6968706B6800CD82D368
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setuppreg.ini ===
[Pid]
ExtraData=7368757571697065727488264E87DD
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setupptb120.ini ===
[Pid]
ExtraData=7962716F746B7A616D767C144B2356
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setupptb180.ini ===
[Pid]
ExtraData=7962716F746B7A616D767C144B2356
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setuppret.ini ===
[Pid]
ExtraData=7368757571697065727488264E87DD
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setupptb150.ini ===
[Pid]
ExtraData=7962716F746B7A616D767C144B2356
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setupptb30.ini ===
[Pid]
ExtraData=7962716F746B7A616D767C144B2356
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setuppupg.ini ===
[Pid]
ExtraData=636573746D6C6B6B666A361864D4B4
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setuppv.ini ===
[Pid]
ExtraData=636573736D6B6B6B666AA8FAE3A354
Pid=55183270
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setupptb60.ini ===
[Pid]
ExtraData=7962716F746B7A616D767C144B2356
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hives\bin\smallbiz\setupptb90.ini ===
[Pid]
ExtraData=7962716F746B7A616D767C144B2356
Pid=55183000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\hwdb\hwdb\placefil.txt ===
; This file is used to specify where every file built by the NT build lab is
; binplaced relative to the root of the distribution point.  If a file is not
; listed, it will end up in the dump directory.
;
; The format is like this:
;
; <imagename>    <class name>
;
; where <imagename> is the filename.ext and <class name> is the directory off
; the root of the distribution point (retail is a placeholder for the root).
; If there are multiple class names for a single image, use a colon to separate
; each.
;
; All bits that ship in the NT base product and are installed with winnt32,
; must have a class name of retail.
;

    hwdb.dll        winnt32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\escpeinf\escpeinf.txt ===
Author: Sandy Coyne
Date: March 7, 2000


Given two files as input, ESCPEINF.EXE generates one output file.

Usage: escpeinf U|C <input file> <output file> <layout.inf>
        U = Upgrade
        C = Clean Install
All fields are required.

The input file must be an inf file containing a [File Security] section. If it does not contain that section, the output file should be identical to the input.

All comparisons are case insensitive. All quotes are required where shown.

Any line that does not fit the following format should be copied to the output file unchanged.

Recognized Input Lines, only in the [File Security] section:

	"<directory>\<WildCardName>",<Integer>,"<SecurityDescriptorString>"

After a line containing a wildcard, there may be zero or more exception lines:

	Exception="<ExceptionFileName>"


Input Detail:
<directory> must be one of the directories in the layout.inf [WinntDirectories] section, and it must begin with "%SystemRoot%" or "%SystemDirectory%"   An example is "%SystemRoot%\Help"

<WildCardName> must be a filename containing at least one wildcard.   An example is "*.hlp"

<Integer> must be a natural integer. Since ESCAPE only accepts a few low numbers, it is possible that huge integers will break the tool. This is okay.   An example is "2"

<SecurityDescriptorString> is a properly formatted security descriptor string. One important aspect of this formatting is that it cannot contain any whitespace.  An example is "D:P(A;;GRGX;;;BU)(A;;GRGX;;;PU)(A;;GA;;;BA)(A;;GA;;;SY)"

<ExceptionFileName> is a file name, with no path. If desired, it can contain wildcards.   Examples are "win.ini" or "*.hlp"

Output:
The Recognized Input Lines will not appear in the output. In their place will be lines in this format:
	"<directory>\<filename1>",<Integer>,"<SecurityDescriptorString>"
	"<directory>\<filename2>",<Integer>,"<SecurityDescriptorString>"
	"<directory>\<filename3>",<Integer>,"<SecurityDescriptorString>"
			.
			.
			.

Output Detail:
<directory> will be identical to the <directory> field of the input.

<filenameX> will be a filename that is found in the layout.inf that matches the <WildCardName> field of the input and is destined for <directory>, except if the filename matches the <ExceptionFileName> field, or if the file is never installed in this mode (Upgrade or Clean Install).

<Integer> will be identical to the <Integer> field of the input.

<SecurityDescriptorString> will be identical to the <SecurityDescriptorString> field of the input.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migdlls\src\miglib\dll\placefil.txt ===
; This file is used to specify where every file built by the NT build lab is
; binplaced relative to the root of the distribution point.  If a file is not
; listed, it will end up in the dump directory.
;
; The format is like this:
;
; <imagename>    <class name>
;
; where <imagename> is the filename.ext and <class name> is the directory off
; the root of the distribution point (retail is a placeholder for the root).
; If there are multiple class names for a single image, use a colon to separate
; each.
;
; All bits that ship in the NT base product and are installed with winnt32,
; must have a class name of retail.
;

    miglibnt.dll        retail
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\checkinf\checkinf.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Corp. Program Description Title _PID_GUIDProgram Description Dapeng Zhu Normal Dapeng Zhu Microsoft Word 8.0Program Description This program checks against INF files that are used by an optional component.  During the test of Optional Component Manager, many document bugs were found.  The main purpose of the program is to check for such bugs in the INF file. Program Usage The program gets its input from the command line.  The input is either a master INF file or a component s INF file for use with Optional Component Manager. If it is a master INF file, the program checks all the INF files that it points to in the [Components] section.  If the input is a single component s INF file, certain errors are not checked since information may be incomplete.  Command line switches can t be viewed by typing checkinf without any argument. Program Structure The program is written in C++.  Various classes are used to represent optional component and their relations.  The class definitions can be found in component.h.  All the member functions that are not inline are implemented in component.cpp.  Checkinf.cpp is the main program that utilizes the classes to for errors in the INF files. Source code location %_NTDRIVE%\nt\private\windows\setup\ocmanage\testoc\checkinf Errors checked The program builds a link list of all the components.  It checks for the validity of Inf files during the process.  E.g. there should be at least one component listed in the [Components] section; there should be at least two fields in a "Needs =" line, etc. The program checks the validity of the IconIndex key.  It should have at least two fields.  If the second field is a number, its value should be between 0 and 66. (There are three bad numbers that will confuse the user).  If it is not a number, it should be a "*" The program checks the need relationship among the components.   A component that has children can't need a another component A component can't need a component with children There should not be any cycle, e.g. a needs b, b needs a Need and Exclude relationship should not exist at the same time between two components A component can t need a non-existent component if a master INF file is given. The program checks the exclude relationship among the components. A component that has children can t need another component A component can t need a component with children A component can t exclude a non-existent component Component that has children should not have Copyfiles section.  In fact, it will give out a warning if there is any suspicious section for such a component. The program checks if there are two components with same IDs. The program checks for components with same description The number in "Modes" line should be valid (0-3) Each component INF file must have a LayoutFile = Layout.inf line No Component INF file should have [SourceDisksNames] and [SourceDisksFiles] section. Sample Output The output was generated by the running the program on the optional components that come with 1859 fre.wks sysoc.inf opened H:\work\checkinf\i386\netoc.inf opened H:\work\checkinf\i386\rsoptwks.inf opened H:\work\checkinf\i386\iis.inf opened H:\work\checkinf\i386\mtsnt5.inf opened H:\work\checkinf\i386\setupqry.inf opened H:\work\checkinf\i386\msmqocm.inf opened H:\work\checkinf\i386\ims.inf opened H:\work\checkinf\i386\imagevue.inf opened IconIndex not present for component msmq mts_core needs mdac, which is not in the list LayoutFile not found in file rsoptwks.inf LayoutFile not found in file iis.inf LayoutFile not found in file setupqry.inf LayoutFile not found in file msmqocm.inf LayoutFile not found in file ims.inf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\hctlib\hctlib.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft HCT Common Library Routines Title _PID_GUIDHCT Common Library Routines Jason Allor Normal Jazon Allor Microsoft Word 8.0HCT Common Library Routines By: Jason Allor (JasonAll) Needed Files All files are located in testapps\hct\hctlib hctlib.lib: This file must be linked into the program via the sources file. It is located under testapps\hct\hctlib\lib\*\hctlib.lib hcttools.h, logutils.h, ntlog.h: must be included by your program NOTE: if you add any new functions to this library, please update this file accordingly. Interface HctTools.c Memory Management Routines: NOTE: All memory management and assert functionality can be turned off by compiling the library without the  Debug flag. VOID InitializeMemoryManager() Call this function at the very beginning of the test, before any memory allocations are made. VOID CheckAllocs() Call this function at the very end of the test, just before the test exits. This function will verify that all memory has been freed. If any memory is left unfreed, the function will create a MessageBox pointing to the malloc locations of the memory that is unfreed, and the program will exit abnormally. BOOL _Malloc(void **ppv, size_t size) Use this routine anytime you wish to allocate memory. The routine will allocate the memory, shred the contents of the memory, and keep a record of this memory allocation. The function will return TRUE if the memory allocation succeeded, and FALSE if the memory allocation failed. The interface to this function is different from that of the standard malloc function. Following is an example of how to call this function: PSAMPLE_STRUCT pSampleStruct; BOOL bResult; Old Malloc: pSampleStruct = (PSAMPLE_STRUCT)malloc(sizeof(SAMPLE_STRUCT)); New Malloc: bResult = Malloc(&pSampleStruct, sizeof(SAMPLE_STRUCT)); VOID _Free(void **ppv) Use this routine anytime you wish to free previously allocated memory. The routine will check to make sure that ppv points to memory that was actually allocated, free the memory, and set the value of ppv to NULL. Example of how to call the function: Old Free: free(pSampleStruct); New Free: _Free(&pSampleStruct); Other Routines: VOID _ASSERT(BOOL bExpression) This function will assert if bExpression is FALSE. If the function asserts, it will create a MessageBox containing the line number and file name of the _ASSERT call, and the program will exit abnormally. PTCHAR ErrorMsg(IN          ULONG  ulError,                      IN OUT PTCHAR tszBuffer) Converts a standard windows error number (of the type returned by GetLastError()) into a word description of the error. If a word description of the error cannot be found, the number stored in ulError is converted into a string and this string is returned. ulError is the error number to convert. tszBuffer is a buffer in which to store the word description. This buffer will be returned from the function. PWCHAR AnsiToUnicode(IN      PCHAR     cszAnsi,                                             OUT  PWCHAR  wszUnicode,                                            IN      ULONG    ulSize) Converts an ANSI string to a UNICODE string, and returns the new Unicode string.  cszAnsi points to the ANSI string to convert.  wszUnicode points to a buffer large enough to store the new Unicode string. ulSize must be equal to the length of the wszUnicode string. PCHAR UnicodeToAnsi(IN     PWCHAR wszUnicode,                                        OUT  PCHAR    cszAnsi,                                        IN     ULONG    ulSize) Converts a Unicode string to an ANSI string, and returns the new ANSI string. wszUnicode points to the Unicode string to convert.  cszAnsi points to a buffer large enough to store the new ANSI string.  ulSize must be equal to the length of the cszAnsi string. PTCHAR ConvertAnsi(IN     PCHAR     cszAnsi,                                      OUT PWCHAR  wszUnicode,                                      IN    ULONG     ulSize) Receives an ANSI string, and returns the same string in either its ANSI or Unicode version, depending on whether the program was compiled as ANSI or Unicode.  cszAnsi points to the ANSI string to (possibly) convert.  wszUnicode points to a buffer large enough to hold the new Unicode string, if needed.  ulSize must be equal to the length of the wszUnicode string.   The function will either return cszAnsi or wszUnicode depending on whether the ANSI version or the Unicode version must be returned. PTCHAR ConvertUnicode(IN    PWCHAR  wszUnicode,                                            OUT PCHAR     cszAnsi,                                            IN    ULONG     ulSize) Receives a Unicode string, and returns the same string in either its ANSI or Unicode version, depending on whether the program was compiled as ANSI or Unicode.  wszUnicode points to the Unicode string to (possibly) convert.  cszAnsi points to a buffer large enough to hold the new ANSI string, if needed. ulSize must be equal to the length of the cszAnsi string.  The function will either return cszAnsi or wszUnicode depending on whether the ANSI version or the Unicode version must be returned.                                             LogUtils.c Logging Routines: HANDLE InitLog(IN PTCHAR tszLogName,                              IN PTCHAR tszTitle,                             IN BOOL      bConsole) Initializes a log. If ntlog.dll is present on the system, the log will be in ntlog format. If not, the log will be in a format that resembles ntlog.  tszLogName specifies the name of the log, such as  program.log tszTitle specifies the title of the console window in which the log output will be displayed. bConsole specifies whether or not a console window must be created. If the program is a windows program, a console should probably be created. If the program is a console program, a console might not need to be created. VOID ExitLog() Closes the log file. VOID Log(IN double       dFunctionNumber,                   IN DWORD   dwLogLevel,                   IN PTCHAR  tszLogString,                   IN  Prints out a line of output to the log. This function will automatically format the log output so that it will not run past the end of the line. If the string is longer than one log line, the string will be broken up into multiple log outputs, each printed on a new line. This gives the appearance of word wrap formatting. If the log is being run without ntlog.dll installed, TLS_INFO log lines will be printed to the console in gray, PASS lines will be printed in green, and SEV lines will be printed in red. dFunctionNumber can be any number. This is used to record where in the program the log line originated. One possible format is to give each function its own function number, so that every log line in that function would begin with that unique number.  dwLogLevel may be either TLS_INFO, TLS_SEV2, TLS_PASS, etc. Or you may use the shorter versions, INFO, SEV2, and PASS. tszLogString is a printf style string that will be printed to the log.  is the arguments to the tszLogString, if any. VOID LogBlankLine() Prints a blank line to the log. VOID AddLogParticipant(IN HANDLE hLog) Adds a new thread or process to the log. This is only necessary if the log is using ntlog.dll. hLog must be equal to the value returned from the InitLog function. VOID RemoveLogParticipant(IN HANDLE hLog) Removes a thread or process from the log. This is only necessary if the log is using ntlog.dll. hLog must be equal to the value returned from the InitLog function }xsni
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\octest\file2.txt ===
file4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\octest\file6.txt ===
file4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\octest\file7.txt ===
file4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\octest\file1.txt ===
file4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\octest\file8.txt ===
file4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\octest\hugefile.txt ===
file4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\octest\file3.txt ===
file4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\octest\file5.txt ===
file4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\octest\file4.txt ===
file4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\octest\coverage.txt ===
This document describes the functionality tested in each of the various 
OC Manager test scenario groups.

------------------------------------------------------------------------------

'octest 1' tests the following:

-- Skip Pages

The welcome page contains a checkbox that will enable the user to skip page 2. 
If the checkbox is left unchecked, page 2 will appear as normal. If the 
checkbox is checked, page 2 should be skipped when the user clicks the 'Next' 
and 'Back' buttons.


-- Change Mode

The modes page will allow the user to change the installation mode between 
the four mode choices: Minimal, Typical, Laptop, and Custom. The user may 
change the mode and click the 'Next' or 'Back' buttons. The new mode should 
be reflected on the new wizard page.


-- If all children are disabled, parent should be disabled

On the components selection page, unselect all children of a component and 
hit ok. The component should now be unselected.


-- If some but not all children are enabled, parent should be enabled but greyed

On the components selection page, select some children of a component and 
unselect others. Verify that the component is checked but the checkbox is 
greyed out. Change the selection configuration of the component's children. 
Leave only one child selected, etc., and verify that the component's checkbox 
is checked and greyed accordingly.


-- Force OC Manager to prompt for files

Run the test so that the copy files are not in the current directory or 
any system path directory. When OC Manager prepares to copy the files, 
it should prompt for the location of the files. Attempt to answer with 
invalid locations. Finally, direct OC Manager to the correct location. 
The files should be copied. This may also be attempted with the files 
scattered across multiple directories.


-- Check component dependencies

Some subcomponents depend upon other subcomponents. If one subcomponent is 
not selected, another subcomponent may not be selected without also 
selecting the first. If the first subcomponent is deselected, both 
subcomponents must be deselected. The following procedure will test this:

- Select master Unicode component so that it is checked and not greyed.

- Verify that Unicode component_2_1_1 is checked and not greyed

- Uncheck Unicode component_2_1_1 and verify that Unicode_2_1_2 also 
  becomes unselected.

- Select Unicode component_2_1_2 and verify that Unicode component_2_1_1 
  also becomes selected.

- Unselect Unicode component_2_1_2 and verify that Unicode component_2_1_1 
  is not affected.

- Click OK and verify that Unicode component_2_1 is greyed.

- If Unicode component_2_2 is checked, uncheck it.

- Verify that ANSI component_2 is not checked.

- Check ANSi component_2 and verify that Unicode component_2_2 is now checked.

- Uncheck ANSI component_2 and Unicode component_2_2.

- Verify that ANSI component_1 is not checked.

- Check ANSI component_1 and verify that ANSI component_2 and Unicode 
  component_2_2 are now checked.


-- If a component has multiple children and one or some of them refuse to 
   be selected, but others can be selected, verify that the component may 
   be selected.

- Select master ANSI component so that it is checked and not greyed. 

- Unselect all ANSI components.

- Select ANSI component_2.

- Select ANSI component_1_1.

- Select ANSI component_1_2.

- Verify that ANSI component_1 is checked but greyed.

- Verify that the master ANSI component is checked but greyed.


-- Verify that needs dependencies and components that refuse to be 
   selected work together.

- Make sure that ANSI component_1 and ANSI component_2 are both unchecked.

- Check ANSI component_1_1 and click OK.

- Verify that ANSI component_1 is checked and greyed.

- Verify that ANSI component_2 is now checked.


------------------------------------------------------------------------------

'octest 2' tests the following:

-- Nonexistent component INF

The oc2.inf file points to component INF files that do not exist. 
The OC Manager should respond with an error message. If the test is
running from the command line, it should exit. If the test is running
during system setup, this compoment should be skipped but setup should
continue.


------------------------------------------------------------------------------

'octest 3' tests the following:


------------------------------------------------------------------------------

'octest 4' tests the following:

-- Nonexistent components in PageAdd and PageReplace sections

The oc4.inf lists nonexistent components in the PageAdd and PageReplace
sections. OC Manager should pop up windows complaining about these 
invalid components, but it should continue to install the valid
component, unicomp.

Unicomp.inf also contains links to these nonexistent components and 
their nonexistent subcompoments.


------------------------------------------------------------------------------

'octest 5' tests the following:

-- Multiple compoments in same compoment INF file

There are two components, unicomp and ansicomp. Both share the same INF
file, comp.inf. This is not standard procedure. Each component is supposed
to have its own INF file. However, this procedure works in most instances,
although not in every way. 


------------------------------------------------------------------------------

'octest 6' tests the following:
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\ocmanage\testoc\octest\inf\i7\unicomp.log ===
INFO  (3.10) -----------------------------------
INFO   
INFO  (3.10) [11:22:40]  OC_SET_LANGUAGE
INFO  (3.10) Component = unicomp   Subcomponent = (null)
INFO  (3.10) Primary = 9 Secondary = 1
INFO   
INFO  (3.10) -----------------------------------
INFO   
INFO  (3.10) [11:22:40]  OC_QUERY_STATE
INFO  (3.10) Component = unicomp   Subcomponent = unicomp_1_1
INFO   
INFO  (3.10) -----------------------------------
INFO   
INFO  (3.10) [11:22:40]  OC_QUERY_STATE
INFO  (3.10) Component = unicomp   Subcomponent = unicomp_1_2
INFO   
INFO  (3.10) -----------------------------------
INFO   
INFO  (3.10) [11:22:40]  OC_QUERY_STATE
INFO  (3.10) Component = unicomp   Subcomponent = unicomp_2
INFO   
INFO  (3.10) -----------------------------------
INFO   
INFO  (3.10) [11:22:40]  OC_CALC_DISK_SPACE
INFO  (3.10) Component = unicomp   Subcomponent = unicomp_1_1
INFO   
INFO  (3.10) -----------------------------------
INFO   
INFO  (3.10) [11:22:40]  OC_CALC_DISK_SPACE
INFO  (3.10) Component = unicomp   Subcomponent = unicomp_1_2
INFO   
INFO  (3.10) -----------------------------------
INFO   
INFO  (3.10) [11:22:40]  OC_CALC_DISK_SPACE
INFO  (3.10) Component = unicomp   Subcomponent = unicomp_2
INFO   
INFO  (3.10) -----------------------------------
INFO   
INFO  (3.10) [11:22:40]  OC_REQUEST_PAGES
INFO  (3.10) Component = unicomp   Subcomponent = (null)
INFO  (3.10) Maximum Welcome Pages  = 10
INFO   
INFO  (3.10) -----------------------------------
INFO   
INFO  (3.10) [11:22:40]  OC_REQUEST_PAGES
INFO  (3.10) Component = unicomp   Subcomponent = (null)
INFO  (3.10) Maximum Mode Pages = 10
INFO   
INFO  (3.10) -----------------------------------
INFO   
INFO  (3.10) [11:22:40]  OC_REQUEST_PAGES
INFO  (3.10) Component = unicomp   Subcomponent = (null)
INFO  (3.10) Maximum Early Pages = 10
INFO   
INFO  (3.10) -----------------------------------
INFO   
INFO  (3.10) [11:22:40]  OC_REQUEST_PAGES
INFO  (3.10) Component = unicomp   Subcomponent = (null)
INFO  (3.10) Maximum Early Pages = 11
INFO   
INFO  (3.10) -----------------------------------
INFO   
INFO  (3.10) [11:22:40]  OC_REQUEST_PAGES
INFO  (3.10) Component = unicomp   Subcomponent = (null)
INFO  (3.10) Maximum Prenet Pages = 10
INFO   
INFO  (3.10) -----------------------------------
INFO   
INFO  (3.10) [11:22:40]  OC_REQUEST_PAGES
INFO  (3.10) Component = unicomp   Subcomponent = (null)
INFO  (3.10) Maximum Postnet Pages = 10
INFO   
INFO  (3.10) -----------------------------------
INFO   
INFO  (3.10) [11:22:40]  OC_REQUEST_PAGES
INFO  (3.10) Component = unicomp   Subcomponent = (null)
INFO  (3.10) Maximum Late Pages = 10
INFO   
INFO  (3.10) -----------------------------------
INFO   
INFO  (3.10) [11:22:40]  OC_REQUEST_PAGES
INFO  (3.10) Component = unicomp   Subcomponent = (null)
INFO  (3.10) Maximum Late Pages = 11
INFO   
INFO  (3.10) -----------------------------------
INFO   
INFO  (3.10) [11:22:40]  OC_REQUEST_PAGES
INFO  (3.10) Component = unicomp   Subcomponent = (null)
INFO  (3.10) Maximum Final Pages = 10
INFO   
INFO  (3.10) -----------------------------------
INFO   
INFO  (3.10) [11:22:40]  OC_WIZARD_CREATED
INFO  (3.10) Component = unicomp   Subcomponent = (null)
INFO   
INFO  (3.10) -----------------------------------
INFO   
INFO  (3.10) [11:22:43]  OC_CLEANUP
INFO  (3.10) Component = unicomp   Subcomponent = (null)
INFO   
INFO   
INFO   
INFO  (0.00) Log Statistics:
INFO   
INFO  (0.00) Pass:  0	0%
INFO  (0.00) Fail:  0	0%
INFO  (0.00) Total: 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\issues.txt ===
This file contains a list of open issues for porting the files in this
directory from the Millenium source tree to the Whistler source tree.

* Where should OOBE bins and data be binplaced?  retail\winnt32?
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\changes.txt ===
This file details changes made to files in this directory to port the code from
the Win9x tree to the Whistler tree.

* Added dirs file.  
* Added sources.inc for macros that apply to all oobe directories.  
* Removed oobe.mk and Win9x makefile.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\common\changes.txt ===
This file details changes made to files in this directory to port the code from
the Win9x tree to the Whistler tree.

* Added sources file and standard NT makefile.  Removed obcommon.mk, depend.mk, 
  and Win9x makefile.
* util.cpp:Add PumpMessageQueue( )
* util.cpp: Added IsThreadActive( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\data\oobeinfo.ini ===
[StartupOptions]
StartUrl=

[options]
MouseTutorial=0
JoinDomain=1
AdminPw=1

[OEMRegistrationPage]
OEMAddRegPage=0
PostToOEM=0
RegPostURL=

[Signup]
ISPSignup=MSN
OfferCode=0
Locales=1,81
IDLocales=1,81,33,49,107,61,44
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\data\changes.txt ===
This file details changes made to files in this directory to port the code from
the Win9x tree to the Whistler tree.

* Added sources file and standard NT makefile.  
* Removed Win9x makefile. 
* Files are binplaced in retail\winnt32\oobe
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\data\placefil.txt ===
migip.dun       retail
migrate.isp     retail
migrate.obe     retail
migx25a.dun     retail
migx25b.dun     retail
migx25c.dun     retail
msobe.isp       retail
obeip.dun       retail
oobeinfo.ini    retail
phone.inf       retail
phone.obe       retail
reg.isp         retail
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\html\changes.txt ===
This file details changes made to files in this directory to port the code from
the Win9x tree to the XP tree.

* Added sources file and standard NT makefile.
* Added placefil.txt.  Binplace root is retail\winnt32\oobe.
* Removed Win9x makefile. 
* dskshell.htm, migrate.js, setup\msobshel.js: 
  changed calls to Dial[Ex]\ReDial[Ex] to use two parameters: connection type
  and isp file.  For changes to Dial[Ex]\ReDial[Ex] handling in CObMain::Invoke.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\html\issues.txt ===
This file contains a list of open issues for porting the files in this
directory from the Millenium source tree to the XP source tree.

* Where should these files be binplaced?
* no imetut1.htm or ime directory
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\html\placefil.txt ===
act_plcy.htm                        retail
    acterror.htm                        retail
    actdone.htm                         retail
    activ.htm                           retail
    activerr.htm                        retail
    activsvc.htm                        retail
    activate.htm                        retail
    actshell.htm                        retail
    adeskerr.htm                        retail
    adrdyreg.htm                        retail
    actlan.htm                          retail
    actconn.htm                         retail
    agtcore.js                          retail
    agtscrpt.js                         retail
    apolicy.htm                         retail
    aprvcyms.htm                        retail
    areg1.htm                           retail
    aregdial.htm                        retail
    aregdone.htm                        retail
    aregsty2.css                        retail
    aregstyl.css                        retail
    arrow.gif                           retail
    ausrinfo.htm                        retail
    backdown.jpg                        retail
    backoff.jpg                         retail
    backover.jpg                        retail
    backup.jpg                          retail
    badeula.htm                         retail
    badpkey.htm                         retail
    btn1.gif                            retail
    btn2.gif                            retail
    btn3.gif                            retail
    bullet1.gif                         retail
    bulzano.jpg                         retail
    bulzanom.jpg                        retail
    but1_dwn.gif                        retail
    but1_idl.gif                        retail
    but1_up.gif                         retail
    but2_dwn.gif                        retail
    but2_idl.gif                        retail
    but2_up.gif                         retail
    but3_dwn.gif                        retail
    but3_idl.gif                        retail
    but3_up.gif                         retail
    but4_dwn.gif                        retail
    but4_idl.gif                        retail
    but4_up.gif                         retail
    clicking.gif                        retail
    clickhr.gif                         retail
    clickerx.wav                        retail
    cnncterr.htm                        retail
    compname.htm                        retail
    desktop3.gif                        retail
    dialmgr.js                          retail
    dialtone.gif                        retail
    dialtone.htm                        retail
    dialup.gif                          retail
    dialup.htm                          retail
    drdyisp.htm                         retail
    drdymig.htm                         retail
    drdyoem.htm                         retail
    drdyref.htm                         retail
    dslmain.htm                         retail
    dslmain.js                          retail
    dsl_a.htm                           retail
    dsl_b.htm                           retail
    dtiwait.htm                         retail
    dtsgnup.htm                         retail
    error.js                            retail
    eula.jpg                            retail
    fini.htm                            retail
    grn_btn.gif                         retail
    hand1.gif                           retail
    hand2.gif                           retail
    heidelb.jpg                         retail
    heidelbm.jpg                        retail
    hndshake.htm                        retail
    hnwprmpt.htm                        retail
    iconn.htm                           retail
    iconnect.htm                        retail
    iconnect.js                         retail
    icntlast.htm                        retail
    ics.htm                             retail
    icsdc.htm                           retail
    icsmgr.js                           retail
    ident1.htm                          retail
    ident2.htm                          retail
    intro.wmv                           retail
    isp.htm                             retail
    isptype.htm                         retail
    isptype.js                          retail
    isp2busy.htm                        retail
    ispcnerr.htm                        retail
    ispcnfg.ins                         opk\samples\oobe
    ispdtone.htm                        retail
    isppberr.htm                        retail
    isphdshk.htm                        retail
    ispins.htm                          retail
    ispnoanw.htm                        retail
    ispphbsy.htm                        retail
    ispsbusy.htm                        retail
    ispsgnup.htm                        opk\samples\oobe
    ispwait.htm                         retail
    jndomain.htm                        retail
    jndom_a.htm                         retail
    keybd.htm                           retail
    keybdcmt.htm                        retail
    magnify.gif                         retail
    merlin.gif                          retail
    migdial.htm                         retail
    miglist.htm                         retail
    migpage.htm                         retail
    migrate.js                          retail
    monitor.gif                         retail
    monitor2.gif                        retail
    mouse.gif                           retail
    mousewn1.gif                        retail
    mslogo.jpg                          retail
    newbtm1.jpg                         retail
    newbtm8.jpg                         retail
    newmark1.jpg                        retail
    newmark8.jpg                        retail
    newtop1.jpg                         retail
    newtop8.jpg                         retail
    mousetut.js                         retail
    mouse.htm                           retail
    mouse_a.htm                         retail
    mouse_b.htm                         retail
    mouse_c.htm                         retail
    mouse_d.htm                         retail
    mouse_e.htm                         retail
    mouse_f.htm                         retail
    mouse_g.htm                         retail
    mouse_h.htm                         retail
    mouse_i.htm                         retail
    mouse_j.htm                         retail
    mouse_k.htm                         retail
    mouse4.gif                          retail
    mouseimg.gif                        retail
    msobshel.htm                        retail
    neweula.htm                         retail
    neweula2.htm                        retail
    nextdown.jpg                        retail
    nextoff.jpg                         retail
    nextover.jpg                        retail
    nextup.jpg                          retail
    noanswer.htm                        retail
    nousbkbd.htm                        opk\samples\oobe
    nousbkm.htm                         opk\samples\oobe
    nousbms.htm                         opk\samples\oobe
    oemcoa.jpg                          retail
    oemhw.htm                           opk\samples\oobe
    oemisp.htm                          opk\samples\oobe
    oemlogo.gif                         retail
    oempriv.htm                         retail
    oemsgnup1.htm                       opk\samples\oobe
    oemsgnupoff.htm                     opk\samples\oobe
    oemsgnupon.htm                      opk\samples\oobe
    oobestyl.css                        retail
    oobeutil.js                         retail
    paris.jpg                           retail
    parism.jpg                          retail
    pisa.jpg                            retail
    pisam.jpg                           retail
    prague.jpg                          retail
    praguem.jpg                         retail
    prodkey.gif                         retail
    progress.gif                        retail
    pberr.htm                           retail
    prodkey.htm                         retail
    prvcyms.htm                         retail
    pulse.htm                           retail
    qmark.acs                           retail
    qmark.gif                           retail
    rcnterr.htm                         retail
    rdrdyreg.htm                        opk\samples\oobe
    rdtone.htm                          retail
    refdial.htm                         retail
    reg1.htm                            retail
    reg3.htm                            retail
    regdial.htm                         retail
    regconn.htm                         opk\samples\oobe
    regdone.htm                         opk\samples\oobe
    reglan.htm                          opk\samples\oobe
    regrmnd.htm                         opk\samples\oobe
    regshell.htm                        opk\samples\oobe
    regstyl.css                         opk\samples\oobe
    rdeskerr.htm                        opk\samples\oobe
    rhndshk.htm                         retail
    rnoansw.htm                         retail
    rnomdm.htm                          retail
    roempriv.htm                        opk\samples\oobe
    rprvcyms.htm                        opk\samples\oobe
    rpberr.htm                          retail
    rpulse.htm                          retail
    rregdial.htm                        opk\samples\oobe
    rtoobusy.htm                        retail
    rusrinfo.htm                        opk\samples\oobe
    sconnect.htm                        retail
    sconnect.js                         retail
    scntlast.htm                        retail
    security.htm                        retail
    skipdown.jpg                        retail
    skipoff.jpg                         retail
    skipover.jpg                        retail
    skipup.jpg                          retail
    thanks10.png                        retail
    thanks8.png                         retail
    timezone.htm                        retail
    title.wma                           retail
    toobusy.htm                         retail
    tyrol.jpg                           retail
    tyrolm.jpg                          retail
    username.htm                        retail
    venice.jpg                          retail
    venicem.jpg                         retail
    verona.jpg                          retail
    veronam.jpg                         retail
    welcome.htm                         retail
    wpaback.jpg                         retail
    wpabtm.jpg                          retail
    wpaflag.jpg                         retail
    wpakey.jpg                          retail
    wpatop.jpg                          retail
    swpaback.jpg                        retail
    swpabtm.jpg                         retail
    swpaflag.jpg                        retail
    swpakey.jpg                         retail
    swpatop.jpg                         retail
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\inc\changes.txt ===
This file details changes made to files in this directory to port the code from
the Win9x tree to the Whistler tree.

* Added setupx32.h from Millenium setup project for msobmain\auditmd.cpp.
* Add Bool2VarBool inline function to util.h.  Maps BOOL values to VARIANT_BOOL
  values appropriately: zero values remain zero, non-zero values become -1.
* Changed MSOBMAIN_ENRTY to MSOBMAIN_ENTRY.
* changed _DEBUG to DBG.
* Added ValidateEula stub to map eula validation to setupx.dll (Win9x) or
  syssetup.dll (Winnt)
  * added msobstub.h to depot for exported function declarations, typedefs, etc.
  * msobstub.h: added ValidateEula declaration
* util.h: added prototype for PumpMessageQueue( )
* appdefs.h: defined WM_OBCOMM_DIAL_DONE
* util.h: added prototype for IsThreadActive( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\idl\changes.txt ===
This file details changes made to files in this directory to port the code from
the Win9x tree to the Whistler tree.

* Added sources file and standard NT makefile.  
* Removed idl.mk and Win9x makefile. 
* Removed include <basetsd.h> from obcomm.idl.  It is included via
  unknwn.idl.
* obcomm.idl
    * Added OnDialEvent method to IObCommunicationManager
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\msobcomm\changes.txt ===
This file details changes made to files in this directory to port the code from
the Win9x tree to the Whistler tree.

* Added sources file and standard NT makefile.  
* Removed msobcomm.mk and Win9x makefile. 
* Changed condition of #if in rnaapi.cpp\RasGetEntryProperties from WINVER !=
  0x400 to WINVER < 0x400.  This is potentially dangerous because the code was
  hand tuned to windows ver 4.  In fact, ChrisK said that there is a security
  hole here somewhere that was not fixed because the cost was higher than the
  risk.
* Removed definition of RASAUTODIALENTRY from inshdlr.h.  It is defined in
  ras.h.
* Removed definition for RASDT_Atm obcomglb.h.  Already defined in ras.h.
* Moved msobcomm.rc and resources.h from messages\usa to root.  Removed all
  references to messages\usa.
* Moved version info from msobcomm.rcv to msobcomm.rc.
* Removed msobcomm.rcv and msobcomm.aps.
* Included tchar.h in obcomglb.h for TCHAR and related macros.
* Removed include <netmpr.h> from ienews.cpp.  Not needed in NT build.
* Changed return value of Sz2W from int to WORD since that is what it is really
  returning.
* Changed parameter of GetSz from WORD to DWORD.  This was causing a data
  conversion error when GetSz was called with a resource ID.
* Cast return value from Sz2W in StrToSubip to BYTE to resolve data conversion
  error.
* Mapped symbols in DEF file exports table to actual symbol names in
  obcommon.lib to resolve unresolved externals.
* Commented out DESCRIPTION in msobcomm.def to resolve LNK4017 (DESCRIPTION
  statement not supported for the target platform; ignored)
* Included shellapi.h for ShellExecute
* changed _DEBUG to DBG.
* Fixed invalid handle exception during shutdown.
    * refdial.cpp: initialized m_hDialThread to NULL in constructor.
* import.cpp: CISPImport::ImportConnection
    * call to Rnaapi.InetConfigClientEx now takes szDefPhoneBook as second
      parameter instead of NULL.  
        * NT: szDefPhoneBook points to an null-terminated
          string containing the fully qualified path to the default phone.  
        * Win9x: szDefPhoneBook is NULL.
* misc.cpp
    * include shlobj.h, assert.h
    * added GetCommonAppDataDirectory( ): wrapper around 
      SHGetFolderPath(CSIDL_COMMON_APPDATA)
    * added GetDefaultPhoneBook( ): returns fully qualified path to rasphone.pbk
* obcomglb.h
    * added prototypes for
        * GetCommonAppDataDirectory
        * GetDefaultPhoneBook
* sources
    * added shfolder.lib to TARGETLIBS for SHGetFolderPath
* refdial.cpp
    * CRefDial::CRefDial: initialized BSTRs.  Fixed AV due to freeing
      uninitialized memory.
    * CRefDial::~CRefDial: wait for threads to finish before exiting
      destructor.  Fixed AV due to closing invalid thread handle.
* msobcomm.cpp, msobcomm.h, refdial.cpp, refdial.h
    Added OnDialEvent method.  This creates a way to notify the communication
    manager of dialing thread state: particularly that the thread is exiting.
    This fixes an AV that occurred because CRefDial was trying to close the
    handle of a non-existent thread (m_hDialThread) in the destructor.
* refdial.cpp, msobcomm.cpp, import.cpp,rnaapi.cpp
    * changed _NT_ to WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\msobdl\changes.txt ===
This file details changes made to files in this directory to port the code from
the Win9x tree to the Whistler tree.

* Added sources file and standard NT makefile.  
* Removed msobdl.mk and Win9x makefile. 
* Moved files from messages\usa to root.
* Moved version info from msobdl.rcv to msobdl.rc.
* Removed msobdl.rcv.
* Commented out DESCRIPTION line in msobdl.def to fix: warning LNK4017:
  DESCRIPTION statement not supported for the target platform; ignored
* changed _DEBUG to DBG.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\msobmain\changes.txt ===
This file details changes made to files in this directory to port the code from
the Win9x tree to the Whistler tree.

* Added sources file and standard NT makefile.  
* Removed msobmain.mk and Win9x makefile. 
* Moved files from messages\usa to root.
* Moved version info from msobmain.rcv to msobmain.rc.
* Removed msobmain.rcv.
* Commented out DESCRIPTION line in msobmain.def to fix: warning LNK4017:
  DESCRIPTION statement not supported for the target platform; ignored
* Mapped symbols in DEF file exports table to actual symbol names in
  obcommon.lib to resolve unresolved externals.
* Removed definitions for cszEqual, cszAmpersand, cszPlus, and cszQuestion from
  htmparse.cpp.  They are already defined in appdefs.h.
* Included shellapi.h in main.cpp and msobmain.cpp for ShellExecute.
* Added void return type to CProductID::SaveState in pid.h and pid.cpp.
* Moved icon resources from messages\usa to res.
* Where BOOL values are mapped to VARIANT_BOOLs use Bool2VarBool to map 0 to 0
  and non-zero to -1.
* #if 0'd all calls to 16-bit code.
* changed _DEBUG to DBG.
* eula.cpp: CEula::ValidateEULA now calls the ValidateEula stub in msobstub.lib
  instead of calling setupx directly to get the path to a valid eula file.
* sources: added msobstub.lib to TARGETLIBS
* msobmain.cpp: 
    * Fixed bug in CObMain::Invoke(DISPID_EXTERNAL_DIAL).  Scripts
      sometimes called window.external.dial with a BSTR as the first parameter,
      sometimes with an integer.  Handler code tried to convert parameter from
      wide chars to ascii in both cases.

      Solution: Rewrote the code for
      DISPID_EXTERNAL_DIAL/REDIAL/DIALEX/REDIALEX. 
      * For DIAL/REDIAL: Changed parameter passing so that two params are
        required
        * first param is always connection type 
        * second param is always isp file name
      * For DIALEX/REDIALEX: Changed parameter passing so that three parameters
        are required:
        * first param is always connection type, second param is always isp file
        * name, optional third param is migration isp index. 
      * Moved common code to CObMain;:OnDial method.
* msobmain.h:
    * Added prototype for CObMain::OnDial( )
* sysclock.h:
    * definition of TIME_ZONE_REGKEY depends on platform
* msobmain.cpp
    * CObMain::Invoke(DISPID_EXTERNAL_FINISH)
        * Set fFinish to TRUE if WINNT.  This will change when PID validation
          is available for syssetup.
    * MainWndProc
        * Added case for WM_OBCOMM_DIAL_DONE
* pid.cpp
    * CProductID::ValidatePID
        * ifdef WINNT set m_dwPidState to PID_STATE_VALID
        * set *pbIsValid to TRUE
    * CProductID::get_PIDAcceptance
        * ifdef WINNT always return TRUE
* msobmain.cpp, pid.cpp, userinfo.cpp, language.cpp, tapiloc.cpp,
  tapiloc.h sysclock.h
  * changed _NT_ to WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\msobmain\issues.txt ===
This file contains a list of open issues for porting the files in this
directory from the Millenium source tree to the Whistler source tree.

* Need to add platform independent layer for NT\Win9x.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\msobshel\changes.txt ===
This file details changes made to files in this directory to port the code from
the Win9x tree to the Whistler tree.

* Added sources file and standard NT makefile.  
* Removed msobshel.mk and Win9x makefile. 
* Moved resource files from messages\usa to root.
* Moved version info from msobshel.rcv to msobshel.rc.
* Removed msobshel.rcv.
* Commented out DESCRIPTION line in msobshel.def to fix: warning LNK4017:
  DESCRIPTION statement not supported for the target platform; ignored
* Mapped symbols in DEF file exports table to actual symbol names in
  obcommon.lib to resolve unresolved externals.
* Included comdef.h in statpane.h, btnpane.h, statuspn.h, and mainpane.h for
  basic COM interface declarations.
* Moved image resources from messages\usa\images to res
* Moved html resources from messages\usa to res
* Modified all references to messages\usa and messages\usa\images
* The following files contained dead code and were not ported: 
    btnpane.cpp, btnpane.h, statpane.cpp, statpane.h
* Standardized API used to find html files to GetSystemDir
    * mainpane.cpp: changed GetModuleFileName to GetOOBEDir (which calls
      GetSystemDir)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\msobweb\changes.txt ===
This file details changes made to files in this directory to port the code from
the Win9x tree to the Whistler tree.

* Added sources file and standard NT makefile.  
* Removed msobweb.mk and Win9x makefile. 
* Moved files from messages\usa to root.
* Moved version info from msobweb.rcv to msobweb.rc.
* Removed msobweb.rcv.
* Commented out DESCRIPTION line in msobweb.def to fix: warning LNK4017:
  DESCRIPTION statement not supported for the target platform; ignored
* Mapped symbols in DEF file exports table to actual symbol names in
  obcommon.lib to resolve unresolved externals.
* Included mshtml.h in msobweb.cpp for IHTMLElement, IHTMLDocument2,
  IHTMLWindow2 declarations.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\oobe\msoobe\changes.txt ===
This file details changes made to files in this directory to port the code from
the Win9x tree to the Whistler tree.

* Added sources file and standard NT makefile.  
* Removed msoobe.mk and Win9x makefile. 
* Moved files from messages\usa to root.
* Moved version info from msoobe.rcv to msoobe.rc.
* Removed msoobe.rcv.
* Pass Unicode version of command line (returned by GetCommandLine( )) to
  LaunchOOBE( ) instead of ANSI lpCmdLine.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\placefil.txt ===
;
; This is a private placefil used by the OPK project for most of the tools.
;
; Some tools need to go into architecture specific directorys.  See
; admin\ntsetup\opktools\$(TARGET_DIRECTORY)\placefil.txt for these files.
;
; See public\sdk\lib\placefil.txt for info about placefil's in general.
;
; *** Please keep this alphabetical  ***
;


autorun.inf                     opk
install.ins                     opk\wizard
langinst.exe                    opk\wizard
oem.tag                         opk\wizard
oeminfo.ini                     opk\wizard
oobeinfo.ini                    opk\wizard
opk.msi                         opk
opkinput.inf                    opk\wizard
setup.exe                       opk
setupmgr.exe                    opk\wizard
unattend.txt                    opk\wizard
winbom.ini                      opk\wizard


;
; WinPE binaries
;
bldhives.exe                    opk\winpe
BuildOptionalComponents.vbs     opk\winpe
depend.exe                      opk\winpe
dskimage.exe                    opk\winpe
etfsboot.com                    opk\winpe
oemmint.exe                     opk\winpe
oscdimg.exe                     opk\winpe
sam                             opk\winpe
sam.log                         opk\winpe
security                        opk\winpe
security.log                    opk\winpe
software.log                    opk\winpe
winpe.bmp                       opk\winpe
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\amd64\placefil.txt ===
;
; This is a private placefil used by the OPK project for the tools
; that need to be placed in an arch specific (amd64) directory.
;
; Any files added here need to be also added to the placex86 file.
;
; See public\sdk\lib\placefil.txt for info about placefil's in general.
;
; *** Please keep this alphabetical  ***
;

factory.exe             opk\tools\amd64
setupcl.exe             retail:opk\tools\amd64
setupmgr.exe            opk\tools\amd64
sysprep.exe             opk\tools\amd64

;
; WinPE files
;

netcfg.exe              opk\tools\amd64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\bioslock\readme.txt ===
For more information see 

1) "%sdxroot%\base\ntsetup\docs\Microsoft System Locked Media Whitepaper.doc".

It is a white paper which details how to create BIOS locked solution.
This doc was shared with OEMs for NT4 + W2K BIOS locked solution.


*****
This is dead code for XP and future versions of the OS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\cvtarea\readme.txt ===
PM Owner: DGolds

Tool for OEM injection of files into FAT images under DOS.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\deploycb\placedep.txt ===
makefile.deploy			dump\deploytools
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\files\wizard\oeminfo.ini ===
[ V e r s i o n ] 
 
 M i c r o s o f t   W i n d o w s   X P   a n d   t h e   W i n d o w s   . N E T   S e r v e r   f a m i l y 
 
 W i n V e r = 5 . 0 1 
 
 
 
 
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\files\wizard\oobeinfo.ini ===
[StartupOptions]
StartUrl=

[options]
Tonepulse=1
JoinDomain=1
AdminPw=1

[OEMRegistrationPage]
PostToOEM=0
RegPostURL=

[Signup]
ISPSignup=MSN
OEMOfferCode=0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\files\wizard\unattend.txt ===
;This is the default Unattended installation file
;Target Path should be new directory 
;Adminpassword is blank.
 
[Unattended]
Unattendmode = FullUnattended
OemPreinstall = Yes
TargetPath = *
Filesystem = LeaveAlone
OemSkipEula = YES
FactoryMode = YES

[UserData]
FullName = "Your User Name"
OrgName = "Your Company Name"
ComputerName = *

[GuiUnattended]
TimeZone = "004"
AdminPassword = *
AutoLogon = Yes
OEMSkipRegional = 1
OEMSkipWelcome = 1

[LicenseFilePrintData]
AutoMode = "PerServer"
AutoUsers = "5"

[Display]
BitsPerPel = 4
XResolution = 800
YResolution = 600
VRefresh = 70

[Branding]
BrandIEUsingUnattended = No
IEBrandingFile = install.ins

[Networking]

[Identification]
JoinWorkgroup = Workgroup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\ia64\placefil.txt ===
;
; This is a private placefil used by the OPK project for the tools
; that need to be placed in an arch specific (ia64) directory.
;
; Any files added here need to be also added to the placex86 file.
;
; See public\sdk\lib\placefil.txt for info about placefil's in general.
;
; *** Please keep this alphabetical  ***
;


factory.exe             opk\tools\ia64
msdinst.exe             opk\tools\ia64
setupcl.exe             retail:opk\tools\ia64
setupmgr.exe            opk\tools\ia64
sysprep.exe             opk\tools\ia64



;
; WinPE files
;
netcfg.exe              opk\tools\ia64
efinvr.exe		        opk\tools\ia64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\files\wizard\winbom.ini ===
[ V e r s i o n ] 
 
 s i g n a t u r e = " $ C H I C A G O $ " 
 
 
 
 [ F a c t o r y ] 
 
 R e s e a l = N o 
 
 
 
 [ C o m p u t e r S e t t i n g s ] 
 
 A u d i t A d m i n A u t o L o g o n = Y e s 
 
 S o u r c e P a t h = % w i n d i r % 
 
 
 
 [ N e t C a r d s ] 
 
 
 
 [ W i n P E ] 
 
 
 
 [ W i n P E . n e t ] 
 
 S t a r t N e t = Y e s 
 
 
 
 [ D i s k C o n f i g ] 
 
 D i s k 1 = D i s k 1 . c o n f i g 
 
 
 
 [ D i s k 1 . c o n f i g ] 
 
 S i z e 1 = * 
 
 P a r t i t i o n T y p e 1 = p r i m a r y 
 
 F i l e S y s t e m 1 = n t f s 
 
 Q u i c k F o r m a t 1 = y e s 
 
 
 
 [ O e m R u n O n c e ] 
 
 
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\i386\placefil.txt ===
;
; This is a private placefil used by the OPK project for the tools
; that need to be placed in architecture specific directory.
;
; Any files added here also need to be added to the other
; admin\ntsetup\opktools\$(TARGET_DIRECTORY)\placefil.txt files.
;
; See public\sdk\lib\placefil.txt for info about placefil's in general.
;
; *** Please keep this alphabetical  ***
;


cvtarea.exe		opk\tools\x86
factory.exe             opk\tools\x86
msdinst.exe             opk\tools\x86
oformat.com		opk\tools\x86
setupcl.exe             retail:opk\tools\x86
setupmgr.exe            opk\tools\x86
sys.exe			opk\tools\x86
sysprep.exe             opk\tools\x86


;
; WinPE files
;
netcfg.exe              opk\tools\x86
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\format.doc ===
A WALK THROUGH FORMAT
			---------------------
			  Ver.5.00.410Beta
			  ----------------

	Upon entry to Format, the routine Main_Init is called.  This 
performs all the parsing of the command line, and determines the 
default value for DeviceParameters, which represents the highest 
capacity format for the disk drive being used.  Upon return, a copy of 
SwitchMap (a word value which holds all the switches entered on the 
command line) is saved in SwitchCopy.

	The memory block allocated to the Format code is then resized 
using Int 21h function 4Ah, so as to free extra un-needed memory 
allocated for the FORMAT.COM program when it was loaded.

	Module GLBLINIT is responsible for allocating all the buffers 
needed by Format.  These buffers are listed below.


Name			Size				Primary Usage
---------------------------------------------------------------------		
DirectorySector		1 sector (512 bytes)	Holds a zeroed 
						sector to be written to 
						disk as the root dir.

FatSpace		FAT+RootDir+		Holds new FAT.  
			7 sectors		Reserves space for 
						buffers needed by 						
						Mirror.

FatSector		1 sector		Read in old FAT 
						one sector at a time.

DirBuf			1 sector		General-purpose use e.g.
						reading in boot sector,
      		 				first sector of root dir.

ClustBound_Buffer_Seg 	1 cluster		Read in bad clusters
						on fixed disks.

mStart			Biggest block of 	Read in system files,
						if needed.


	A buffer for system files will be allocated only if /S is specified.  
If this is present, system files will be read in at this time.  The system 
files are read in now so as to prevent an extra disk swap later, i.e. it is 
assumed that the system disk will be in the default drive at this point.  
In case the buffer was not big enough for all the system files (IO.SYS, 
MSDOS.SYS, COMMAND.COM), they will be read in as much as 
possible.  The remainder will then be read in when the system files 
are being written out to disk, after completion of formatting (This idea
is now prevented: if the files cannot be all read prior to format, format
will fail).

	The 1-cluster buffer will be allocated only if the drive being 
formatted is a fixed disk.

	This module also determines the default value for 
DeviceParameters (by a call to routine GetDeviceParameters, which 
obtains them through Int 21h function 440Dh, subfunction 60h).  These 
default parameters are copied to SavedParams.

	A failure of any function call in GLBLINIT will result in the 
termination of Format.

	The portion after the call to Global_Init is the main loop of the 
program.  The code between 'SysLoop' and 'call More' is repeated for 
each disk to be formatted.

	The routine InitSysParm restores the state of several variables 
so that they are in the original state at the outset for each disk being 
formatted.  Thus DeviceParameters are restored from SavedParams 
and SwitchMap is restored from SwitchCopy.

	All allocated buffers are zeroed out in the routine 
ZeroAllBuffers.

	After prompting the user for the disk to be formatted, disk 
access is ensured through a call to Get_Disk_Access.

	Now module PHASE1 is invoked.  This module primarily 
determines the final value of DeviceParameters to be used in 
formatting the disk.  It also handles all the logical requirements to 
validate a safe format.

	In Phase1Initialisation firstly a media sensing call is made, for 
removable media.  This will utilize new media sensing capabilities of 
the hardware to determine what type of disk is being used.  If this 
function is supported, the BPB field in DeviceParameters will be set to 
that of the media detected.  Media sensing can be supported only on 
3.5in disks.

	The routine Set_BPB_Info is now called to handle the case 
when the disk to be formatted is a non-FAT disk.  This routine will set 
DeviceParameters appropriately in this case. 
Note: This case has not been tested, or ever observed, for that matter.

	The CheckSwitches routine takes action based on the size 
specification switches (/F /N /T /1 /4 /8) entered by the user.  If /F was 
specified, it will be translated into the appropriate value for /N & /T.  
Thus SwitchMap may be modified.  Also, DeviceParameters will be set 
appropriately, for all the formats supported.
Note:  CheckSwitches does NOT modify DeviceParameters if it detects 
that the size specification entered by the user is equal to the default 
size for that drive.  This property is taken into account in determining 
the validity of a safe format in PHASE1.

	Upon return from CheckSwitches, a copy of DeviceParameters 
is saved in SwitchDevParams.

	If the user had specified an unconditional format (/U present), 
the format will be done either according to the entered size 
specification, or else to the default size for the drive (which is its 
maximum capacity).

	If /U is not present, the routine DetermineExistingFormat is 
called.  This routine reads the first 2 sectos and validates the boot
sector (the first sector) on the disk.  If the existing format is found
to be valid, then ResetDeviceParameters is called to copy the BPB read
off the boot sector into that of DeviceParameters.  Further, for removable
media the field DP_CYLINDERS is calculated and set.

	If the disk is not found to have a valid format at this point, 
another routine is called to check in case a disk with a CP/M-type boot 
sector is present (for 160K and 180K disks).  The routine DetermineCPMFormat
validates the first sector of the FAT (the second sector read in 
DetermineExistingFormat) by examining the media descriptor byte.  If this is
found to be a CP/M media descriptor, DeviceParameters will be modified.  
A table of customized BPBs is used for this purpose.  <In short, this is 
an extensive routine which will almost always have to be called, while 
being applicable only in obsolete cases.>

	If the disk if found NOT to have a valid format, a check is made 
to see if there was an error reading the disk due to an open door, etc.  
If so, a message will be given and Format will be terminated.  
Otherwise SwitchMap is checked to see if /Q was specified.  Since 
there is no valid existing format, Quick format cannot be done, so a 
warning message will be issued, and the user will be prompted 
whether or not to continue with an unconditional format.  If the user 
chooses to continue, /Q will be turned off, and /U will be turned on.  

	There is one exception to this logic: the user is allowed to 
enter /Q together with a size specification, which means "Quick format 
all pre-formatted disks with their original format, but format new disks 
with the specified size".  Thus, if /Q is present, SwitchMap is checked 
for (/F, /N or /T) and if these are present, the warning message is not 
given.  Instead, the message is jumped over, and the program 
continues as if the user had entered "Yes" to the continue prompt.  
The code will now continue, with DeviceParameters finalized, at 
DevParamsOk.

	In case the disk is found to have a valid existing format, then 
the values of SwitchDevParams and DeviceParameters are compared 
for equality.  If found to be equal, execution continues at 
DevParamsOk (i.e. there is no conflict between any user-specified 
size and the existing format on disk).  Otherwise a warning message
will be issued since there is a conflict between the entered size or
default size andthe format on disk, and the user will be asked 
whether to proceed with an unconditional format.  If the user chooses 
to continue, /U will be turned on and SwitchDevParams will be copied 
into DeviceParameters, so as to utilize the size specification given by 
the user.

	The only exception to the last case is when /Q is present 
together with a size specification, as explained above. Then a safe 
format will be done using the current disk format.

	After having finalized DeviceParameters, the track layout in 
DeviceParameters is initialized, in the loop LoadSectorTable.  Some 
other initialisation is performed here also, such as determining the 
starting sector, and whether we have a 12 or 16-bit FAT.  The total 
number of clusters is also computed.

	After PHASE1, the MIR_MAIN module will be invoked to create 
the recovery file in case /U has not been turned on.  In order to 
accomodate any buffer space needed by the Mirror utility, it is 
necessary to release the space used by the FatSpace buffer.  This 
buffer is originally made big enough to accomodate all the buffer 
requirements of Mirror (this is FAT + Root Dir + Boot Sector + 6 extra 
sectors + 1 surplus sector to allow for arena headers).  The FatSpace 
buffer is re-allocated upon successful return from Mirror.  In case the 
creation of the recovery file failed, the user will be given the option of 
continuing with an unconditional format.

	Phase2Initialisation performs some calculations relating to the 
format to be performed.

	The routine ShowFormatSize is now called to display the size 
of the format to be done.

	Finally, the actual disk formatting is done in module 
DSKFRMT.  The FatSpace buffer is initialised and loaded with the 
media descriptor byte at the start.  The drive parameters are set to 
those of the intended format through a call to SetDeviceParameters, 
using the DeviceParameters parameter block.  For a Quick format, the 
routine QuickFormat is called.  This pseudo-formats the disk by 
copying all bad cluster markers from the old FAT into the new FAT.  
The old FAT is traversed sequentially, and is read in 1 sector at a 
time, into FatSector.

	In the case of a regular format, SwitchMap is first checked to 
see if /U is present.  If it is, the 'Format and Verify Track' operation will 
be performed on each track.  Otherwise only 'Verify Track' will be 
performed.

	The routine Write_Disk_Info writes out the new boot sector, 
root directory and FAT, as well as the system files, if requested.  Great 
care is taken not to over-write any old files if a system transfer is 
being done together with a safe format.  There are four cases which 
must be addressed here.  These are as follows.

		[1]	Unconditional format without system files
		[2]	Unconditional format with system files
		[3]	Safe format without system files
		[4]	Safe format with system files

	Cases [1], [2] and [3] are all handled the same way.  This is as 
follows.  The boot sector is written out, followed by a zeroed root 
directory, and the new FAT (which is zero except for bad cluster 
markers).  If needed, the system files can now be written out.

	Case [4] is handled in a special way, as described below.  The 
boot sector and a zeroed root directory is written out.  The disk is now 
checked to see if there is enough space for the system files.  At this 
point the old FAT on the disk is still there, so the free space cannot 
overlap any allocated clusters.

	If there is insufficient space, the user will be given a warning 
message and prompted whether to perform a system transfer which 
will prevent later recovery, or just not to transfer the system files.  If 
the user chooses to continue with the transfer, then the old FAT will 
first be over-written with the new FAT, and then system files will be 
written out.  If the user chooses not to continue, the new FAT will be 
written out, and system files will not be transferred.

	If there is sufficient space, then it is necessary to ensure that 
IO.SYS (the first system file) is written out to a location on disk so that 
it is contiguous.  This is achieved by calculating the number of 
clusters needed to accomodate a size of 1.5Kbytes (the maximum 
size of IO.SYS).  This value will be between 1 and 3.  The old FAT will 
then be scanned to find a free cluster block of this size, and disk 
allocation will be forced to start from there, using an undocumented 
DPB function.  In case such a cluster block cannot be found (extremely 
unlikely), the user will be given a warning that system transfer will 
destroy disk files and the program will proceed as described above.  
Once the cluster block is found, the system files are now written out to 
disk.  Since the old FAT is still on disk, this method obviates the 
possibility of over-writing old disk files.  After transfer is complete, the 
FAT chains for the three system files will be copied from the old FAT 
into the new FAT.  Note that the root directory entries will automatically 
appear in the new root directory as the system files are written out.  
The new FAT will then be written out to disk, over the old FAT.

	The routine More prompts the user whether another disk is to 
be formatted.  If the user chooses to format another disk, execution 
will resume at SysLoop, where the original state of parameters will be 
restored.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\readme.txt ===
PM Owner: DGolds

Tool for OEM NTFS-alignment-aware FAT formatting under DOS environments. The source
here is modified from the format source in the 9x source tree and does NOT compile
under the NT build environment. Aside from the message file in messages\usa-ms (to
match the 9x convention), the include files external to the format source are not
present.

OFORMAT.MAK is the 9x build makefile, not a VC++ generated makefile.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\safefmt.doc ===
SAFEFORMAT

=======================================================================

The following new source files have been added to the format
directory.

      SAFE.ASM    - Additional program source code
      SAFE.INC    - Extrn definitions to be included in other modules
      SAFEDEF.INC - Structure and equates used in SAFE.ASM
      NEWFMT.DOC  - This information and specification file


All changes to the existing format program have been incorporated
within conditionals. The defined value SAFE will determine whether
the new safe format is built. The build the safe format add the
command line switch for the assembler "-DSAFE=1". To disable
creation of the safe format and build the normal format program
change the switch to -DSAFE=0.

=======================================================================

The design specification for the MS-DOS 4.x safe format and unformat
utility is based on the these underlying assumptions.


FORMAT assumptions:

  1.  The utility is version dependent and will alway fail to run
      under versions of DOS (as reported by DOS function 30h)
      other the version it was designed for.

  2.  The utility will only attempt to preserve and restore existing
      DOS 4.x compatible parititions.

  3.  The utililty will incorporate general safty features but will
      rely on the integrety of the underlying operating system for
      detecting error conditions while accessing the hard disk.

  4.  There will be no attempt to allow restoration of a partition
      which was recognized as being damaged before the format
      operation had begun.

  5.  If for any reason the restoration files cannot be created
      the user will notified and allowed to decide if the format
      should continue without the restoration ability. There is
      one exception to this assumption and that is the case where
      a partition is detected to be unformated as described later.

  6.  The default operation during format will be to create the
      restoration file. A command line switch will allow the user
      to disable the feature.

  7.  All disk access will be done via DOS file handles and interrupts
      25h and 26h to allow DOS to detect and return any error
      conditions.

  8.  Only the first copy of the FAT will be saved. If any sectors
      in the first copy of the FAT cannot be successfully read
      using int 25h, an attempt will be made to read the corresponding
      sectors from the second copy of the FAT. Only if the
      corresponding sectors in both copies of the FAT cannot be read
      will it be assumed the the FAT is bad and a restoration file
      cannot be created.

  9.  The restoration file must contain all information neccessary
      to allow the restoration program to restore the original
      partition immediately after a format. If the original partition
      was a boot partition it must be restored so that it will boot
      the original operating system which was present before the
      format operation.

  10. The system files will consist of the either of the following
      2 groups of files plus COMMAND.COM.
      (IO.SYS and MSDOS.SYS) or (IBMBIO.SYS and IBMDOS.SYS)

  11. It will be assumed that a partition has never been formatted
      if the boot record is not valid using the conditions that the
      last 2 bytes of a boot sector contain a boot signature and
      the first byte is near or short jump opcode. When a partition
      has never been formatted a restoration file will not be
      created. There will be no need to alert the user to this action
      and formating will proceed as it does with the existing DOS 4.x
      utility.

  12. The restoration file will be created in the root directory
      before formating begins and this directory entry will be
      restored to the root directory as the 4th entry in the new
      root directory with an E5h placed in the first byte of the
      first 3 directory entries to allow room for operating system
      files. The restoration file will use the name "UNFORMAT.DAT"
      and will be created with HIDDEN, SYSTEM and READONLY
      attributes set.

  13. Any previous restoration file will be deleted at the time
      a new restoration file is created.

      WARNING: This will mean that if a user reformats a hard
      disk immediately after a previous format, the original
      contents of the hard disk will be lost.

  14. The restoration file will be designed so that it can allow
      restoration of the hard disk reguardless of the condition of
      boot sector, FAT or root directory after completion of the
      format operation. This feature is only for possible future
      enhancements and in this implementation there will be no
      attempt to restore a hard disk if the restoration file
      cannot be successfully read from the disk using the normal
      DOS file and sector read and write operations.

  15. The FAT which is written to the restoration file will also
      contain the FAT allocation chain for the restoration file.

  16. The DOS control C check will be disabled while the system areas
      of the disk are being written to help minimize the chance of
      losing the restoration file's directory entry and FAT chain.

      NOTE:
      The user will still be allowed to CTRL C out of the format at
      any time previous to this without damaging the integrity of
      the existing partition other than the deletion of any
      previously existing restoration file. 

  17. There will be 2 checksums in the restoration file header. One
      will be a checksum of the sector containing the file header
      and the other will be a checksum of the entire restoration
      file. The file header checksum will be used to confirm the
      file header is the valid starting sector of a restoration
      file and the file checksum will be used to insure the
      integrety of entire restoration file before a restoration
      is done.

  18. The information contained in the restoration file is intended
      to only allow the restoration of a hard disk partition if the
      UNFORMAT utility is used before any new files are written to
      the partition after a format operation. If any new files are
      written the partition is formatted it will void the integrety
      of the original FAT and the partition will be corrupt.

  19. The FORMAT utility must allow restoration of the original
      partition even in the event that the /S option is used to
      install a new operating system on the partition. This will
      be accomplished by assuring that the new OS does not
      overwrite any existing allocated areas other than the first
      2 clusters of the disk which have been saved in the restoration
      file.

  20. The fatal disk error handler will be changed so that IGNORE is
      not an option for handling of fatal disk errors. Only RETRY,
      FAIL and ABORT will be valid options.

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\samples\placesam.txt ===
;
; This is a private placefil used by the OPK project for docs and samples
;
; See public\sdk\lib\placefil.txt for info about placefil's in general.
;
; *** Please keep this alphabetical  ***
;
; All file names must be unique, for files in \docs and \samples

; NOTE: This is a place holder to show the syntax. Replace with real file names
; foo                     opk\docs
; NOTE: This is a place holder to show the syntax. Replace with real file names


Isp.zip				opk\samples\oobe
Factory_Winbom1.ini		opk\samples\sysprep_factory
Factory_Winbom2.ini		opk\samples\sysprep_factory
OOBE_Winbom1.ini		opk\samples\sysprep_factory
sysprep.inf			opk\samples\sysprep_factory
Sysprep1.inf			opk\samples\sysprep_factory
WinPE_winbom1.ini		opk\samples\sysprep_factory
UP2MPsysprep.inf		opk\samples\sysprep_factory
MP2UPsysprep.inf		opk\samples\sysprep_factory
diskpart1.cmd			opk\samples\sysprep_factory
CMDLINES.TXT			opk\samples\setup
transfer.bat			opk\samples\setup
UNATTND1.TXT			opk\samples\setup
UNATTND2.TXT			opk\samples\setup
WINNT.SIF			opk\samples\setup
OEMLogo.ico			opk\samples\graphics
oemlogo_SysProp.gif		opk\samples\graphics
oemlogo_WinWel.gif		opk\samples\graphics
oeminfo.ini      		opk\samples\branding
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\samples\sysprep_factory\factory_winbom2.ini ===
; This is an example of a Winbom.ini file that creates user accounts on
; the destination computer and then reseals the computer so that
; Windows Welcome runs on startup.
;
[Version]
Signature = "$CHICAGO$"

[factory]
WinBomType = Factory
Reseal = Yes
ResealMode = OOBE
Logging = Yes
LogFile = C:\windows\system32\FactoryLog.txt
ResealFlags = "-NoSidGen"

[UserAccounts]
Pat
Garth
Stephanie

[Account.Pat]
description = "Pat Coleman's Account"
password = "Hf&63"
alias = "PatC"
passport = "PatC@Woodgrove.com"

[Account.Garth]
description = "Garth Fort's Account"
password = "Is#ns"
alias = "GarthF"
passport = "GarthF@Woodgrove.com"

[Account.Stephanie]
description = "Stephanie Conroy's Account"
password = "**ijy3"
alias = "StephC"
passport = "StephC@Woodgrove.com"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\samples\sysprep_factory\factory_winbom1.ini ===
; This is an example of a Winbom.ini file that processes Plug and Play drivers.
;
[Version]
Signature = "$CHICAGO$"

[Factory]
WinBomType = Factory
Reseal = NO
Logging = YES
LogFile = C:\windows\OEMDriver\Factory_PnP_Log.txt

[PnpDriverUpdate]
Username = PatColeman
Password = PC&1234
Domain = WOODGROVE
TargetRoot = %windir%\OEMdriver
WaitForPnP = Yes
UpdateInstalledDrivers = No
DevicePath = C:\windows\OEMdriver

[PnpDrivers]
\\ServerName\drivers\sound = sound
\\ServerName\drivers\video = video
\\ServerName\drivers\network = network
floppy:\drivers = oemdrivers
cdrom:\drivers = oemdrivers

[NetCards]
NICPnPID = C:\Windows\OEMDriver\Network\Netcard.inf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\samples\setup\cmdlines.txt ===
; The following commands create a local user "Pat" with a password of
; "1234&Pat" and place the user in the Administrators group.
; 
;
[Commands]
"net user /add Pat 1234&Pat"
"net localgroup administrators /add Pat"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\samples\sysprep_factory\winpe_winbom1.ini ===
; This is a sample Winbom.ini file that is processed during WinPE
; to partition, format, and install a configset to a destination computer.
; 
; This example is specific to IA64 computers due to settings in
; the DiskConfig section.
;
[Version]
signature = $CHICAGO$

[Factory]
WinBomType = WinPE

[ComputerSettings]
AuditAdminAutoLogon = Yes
DisplayResolution = 1024X768x16

[NetCards]

[WinPE]
Restart = Reboot
Lang = ENG
Sku = PRO
ConfigSet = Pro_IA64
SourceRoot = \\Build_Server\OPKTools
Username = Guest
Password = 6FyB#

[WinPE.net]
StartNet = Yes

[DiskConfig]
Disk1 = Disk1.config

[Disk1.config]
WipeDisk = YES
Size1 = *
SetActive1 = YES
PartitionType1 = PRIMARY
FileSystem1 = NTFS
QuickFormat1 = YES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\samples\setup\unattnd1.txt ===
;This is a sample unattended installation file that installs a Web server
;running Windows Server 2003, Windows Server 2003 - Enterprise Edition, or Windows XP Professional.
;IIS components are not installed on Windows XP Home Edition.
;USING THIS SAMPLE FILE WILL ENABLE IIS, WHICH MIGHT NOT BE THE DEFAULT BEHAVIOR.
;IIS, MTS, and Index Server are ON.
;Target Path should be the default directory or <default>.
;The Administrator password is blank.
 
[Unattended]
Unattendmode = FullUnattended
OemPreinstall = NO
TargetPath = *
Filesystem = ConvertNtfs

[UserData]
FullName = "Pat Coleman"
OrgName = "Woodgrove Bank"
ComputerName = "Coleman01"

[GuiUnattended]
TimeZone = "004"
AdminPassword = *
AutoLogon = Yes

[LicenseFilePrintData]
AutoMode = "PerServer"
AutoUsers = "5"

[Display]
BitsPerPel = 16
XResolution = 1024
YResolution = 768
VRefresh = 70

[Networking]


[Identification]
JoinWorkgroup = Workgroup

;Installs the necessary files for the designated optional components.
;These options are not the default settings for installed components on all versions.
[Components]
iis_common = on
iis_inetmgr = on
iis_www = on
iis_ftp = on
iis_htmla = on 
iis_doc = on 
iis_pwmgr = on 
iis_smtp = on 
iis_smtp_docs = on 
mts_core = on 
msmq = off
terminalservices = off
reminst = off
certsrv = off
rstorage = off
indexsrv_system = on
certsrv_client = off
certsrv_server = off
certsrv_doc = off

[InternetServer] 
;Without these keys, the specified IIS will use the default settings.
;PathFTPRoot = "%systemdrive%\Custom\FTPRoot"
;PathWWWRoot = "%systemdrive%\Custom\WWWRoot"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\samples\setup\unattnd2.txt ===
;This is a sample unattended installation file.
;Target Path should be new directory. 
;The "Pat" custom theme will be enabled.
;The Administrator password is blank.

[Unattended]
UnattendMode = FullUnattended
OemPreinstall = YES
TargetPath = TestingOS
FileSystem = LeaveAlone

[GuiUnattended]
AutoLogon =Yes
AdminPassword = *
TimeZone = 004

[UserData]
FullName = "Pat Coleman"
OrgName = "Woodgrove Bank"
ComputerName = "Coleman01"
ProductId = "xxxxx-xxxxx-xxxxx-xxxxx-xxxxx"

[Shell]
CustomDefaultThemeFile = "C:\Windows\Pat.theme"

[LicenseFilePrintData]
AutoMode = "PerServer"
AutoUsers = "5"

[Display]
BitsPerPel = 16
XResolution = 1024
YResolution = 768
VRefresh = 70

[Networking]

[NetAdapters]
Adapter01 = params.Adapter01

[params.Adapter01]
INFID = *

[NetClients]
MS_MSClient = params.MS_MSClient

[params.MS_MSClient]
InfID = MS_MSClient

[NetProtocols]
MS_TCPIP = params.MS_TCPIP

[params.MS_TCPIP]
AdapterSections = params.MS_TCPIP.Adapter01

[params.MS_TCPIP.Adapter01]
SpecificTo = Adapter01
DHCP = yes

[NetServices]
MS_Server = params.MS_Server

[params.MS_Server]

[Identification]
JoinWorkgroup = Workgroup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\samples\sysprep_factory\oobe_winbom1.ini ===
; This is an example of a Winbom.ini file that contains all 
; of the sections that would be processed by Factory during Windows Welcome.
;
[Version]
Signature = "$Chicago$"

[Factory]
WinBomType = OOBE
Reseal = YES
ResealMode = OOBE

[ComputerSettings]
ExtendPartition = 1
SourcePath = %WINDIR%\options
TestCert=
DisplayResolution = 1024x768x16
OptimizeShell = YES
FontSmoothing = On
Hibernation=
PowerScheme=

[Shell]
DelayCleanup = YES
StartMessenger = NO
MSNExplorer = NO
DefaultStartPanelOff = NO
DefaultThemesOff = YES
CustomDefaultThemeFile=

[PnPDrivers]
UpdateInstalledDrivers = YES

[Components]
AccessOpt = On
Calc = On
CharMap = On
Chat = On
DeskPaper = On
Dialer = On
Fax = On
FreeCell = On
Hearts = On
HyperTrm = On
IEAccess = On
Media_Clips = On
Media_Utopia = On
MineSweeper = On
MousePoint = On
MSNExplorer = On
MSWordPad = On
ObjectPkg = On
Paint = On
PinBall = On
Rec = On
Reminst = On
rStorage = On
Solitaire = On
Spider = On
Templates = On
TerminalServer = Off
TSClients = On
TSWebClient = On
Vol = On
WMPOCM = On
ZoneGames = On
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\samples\branding\oeminfo.ini ===
[ G e n e r a l ] 
 
 M a n u f a c t u r e r   =   F a b r i k a m ,   I n c . 
 
 M o d e l   =   B r a n d   X   P e n t i u m   P r o c e s s o r 
 
 s u p p o r t u r l = w w w . f a b r i k a m . c o m 
 
 
 
 [ O E M S p e c i f i c ] 
 
 S u b M o d e l   =   4 5 6 A 0 1 2 3 
 
 S e r i a l N o   =   1 2 3 4 5 6 7 8 
 
 O E M 1   =   B u i l t   f r o m   i m a g e   2 0 0 1 0 6 3 0 
 
 O E M 2   =   F a c t o r y   l o c a t i o n :   R e d m o n d ,   W a s h i n g t o n 
 
 
 
 [ I C W ] 
 
 P r o d u c t   =   B r a n d   X   f r o m   F a b r i k a m ,   I n c . 
 
 
 
 [ S u p p o r t   I n f o r m a t i o n ] 
 
 L i n e 1   =   F o r   t e c h n i c a l   s u p p o r t : 
 
 L i n e 2   =       I n   t h e   U S A : 
 
 L i n e 3   =           C a l l   1 - 8 0 0 - 5 5 5 - 1 2 3 4   f r o m   8   A . M .   t o   8   P . M .   E S T 
 
 L i n e 4   =           f o r   s o f t w a r e   a n d   h a r d w a r e   s u p p o r t . 
 
 L i n e 5   =   
 
 L i n e 6   =       I n   E n g l a n d : 
 
 L i n e 7   =           C a l l   4 4 4 - 3 3 2 4   f o r   h a r d w a r e   c o n f i g u r a t i o n   s u p p o r t . 
 
 L i n e 8   =           C a l l   5 5 5 - 6 6 4 8   f o r   s o f t w a r e   s u p p o r t . 
 
 L i n e 9   =   
 
 
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\sbsi\placeproset.txt ===
Readme.txt      opk\sbsi\pro\setup
Setup.exe       opk\sbsi\pro\setup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\sbsi\per\setup\setup.ini ===
[Startup]
AppName=Microsoft Windows XP Home Edition SBSI
FreeDiskSpace=560
BaseName=WXPPER
CmdLine=/h/l
[ISUPDATE]
UpdateURL=
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\sbsi\placeperset.txt ===
Readme.txt      opk\sbsi\per\setup
Setup.exe       opk\sbsi\per\setup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\sbsi\placeper.txt ===
DATA.TAG        opk\sbsi\per\setup
data1.cab       opk\sbsi\per\setup
data1.hdr       opk\sbsi\per\setup
flash.exe       opk\sbsi\per\setup
lang.dat        opk\sbsi\per\setup
layout.bin      opk\sbsi\per\setup
os.dat          opk\sbsi\per\setup
readme.txt      opk\sbsi\per
setup.exe       opk\sbsi\per
silent.bat      opk\sbsi\per
second.iss      opk\sbsi\per\setup
Silent.iss      opk\sbsi\per\setup
setup.bmp       opk\sbsi\per\setup
SETUP.INI       opk\sbsi\per\setup
setup.ins       opk\sbsi\per\setup
setup.lid       opk\sbsi\per\setup
_INST32I.EX_    opk\sbsi\per\setup
_ISDel.exe      opk\sbsi\per\setup
_Setup.dll      opk\sbsi\per\setup
_sys1.cab       opk\sbsi\per\setup
_sys1.hdr       opk\sbsi\per\setup
_user1.cab      opk\sbsi\per\setup
_user1.hdr      opk\sbsi\per\setup
DBMerge.exe     opk\sbsi\per\setup\dbmerge
LEARN32.DLL     opk\sbsi\per\setup\dbmerge
Syllabi2.cdx    opk\sbsi\per\setup\dbmerge
Syllabi2.dbf    opk\sbsi\per\setup\dbmerge
Syllabus.cdx    opk\sbsi\per\setup\dbmerge
Syllabus.dbf    opk\sbsi\per\setup\dbmerge
L10_Aa.CBZ      opk\sbsi\per\setup\cbz
L10_Ba.CBZ      opk\sbsi\per\setup\cbz
L10_Ca.CBZ      opk\sbsi\per\setup\cbz
L10_Da.CBZ      opk\sbsi\per\setup\cbz
L10_Ea.CBZ      opk\sbsi\per\setup\cbz
L10_Fa.CBZ	opk\sbsi\per\setup\cbz
L11_Aa.CBZ      opk\sbsi\per\setup\cbz
L11_Ba.CBZ      opk\sbsi\per\setup\cbz
L11_Ca.CBZ      opk\sbsi\per\setup\cbz
L11_Da.CBZ      opk\sbsi\per\setup\cbz
L11_Ea.CBZ      opk\sbsi\per\setup\cbz
L11_Fa.CBZ      opk\sbsi\per\setup\cbz
L12_Aa.CBZ      opk\sbsi\per\setup\cbz
L12_Ba.CBZ      opk\sbsi\per\setup\cbz
L12_Ca.CBZ      opk\sbsi\per\setup\cbz
L12_Da.CBZ      opk\sbsi\per\setup\cbz
L12_Ea.CBZ      opk\sbsi\per\setup\cbz
L13_Aa.CBZ      opk\sbsi\per\setup\cbz
L13_Ba.CBZ      opk\sbsi\per\setup\cbz
L13_Ca.CBZ      opk\sbsi\per\setup\cbz
L13_Da.CBZ      opk\sbsi\per\setup\cbz
L13_Ea.CBZ	opk\sbsi\per\setup\cbz
L13_Fa.CBZ	opk\sbsi\per\setup\cbz
L14_Aa.CBZ      opk\sbsi\per\setup\cbz
L14_Ba.CBZ      opk\sbsi\per\setup\cbz
L14_Ca.CBZ      opk\sbsi\per\setup\cbz
L14_Da.CBZ      opk\sbsi\per\setup\cbz
L14_Ea.CBZ      opk\sbsi\per\setup\cbz
L15_Aa.CBZ      opk\sbsi\per\setup\cbz
L15_Ba.CBZ      opk\sbsi\per\setup\cbz
L15_Ca.CBZ      opk\sbsi\per\setup\cbz
L15_Da.CBZ      opk\sbsi\per\setup\cbz
L15_Ea.CBZ      opk\sbsi\per\setup\cbz
L15_Fa.CBZ      opk\sbsi\per\setup\cbz
L16_Aa.CBZ      opk\sbsi\per\setup\cbz
L16_Ba.CBZ      opk\sbsi\per\setup\cbz
L16_Ca.CBZ      opk\sbsi\per\setup\cbz
L16_Da.CBZ      opk\sbsi\per\setup\cbz
L16_Ea.CBZ      opk\sbsi\per\setup\cbz
L17_Aa.CBZ      opk\sbsi\per\setup\cbz
L17_Ba.CBZ      opk\sbsi\per\setup\cbz
L17_Ca.CBZ      opk\sbsi\per\setup\cbz
L17_Da.CBZ      opk\sbsi\per\setup\cbz
L17_Ea.CBZ      opk\sbsi\per\setup\cbz
L1_Aa.CBZ       opk\sbsi\per\setup\cbz
L2_Aa.CBZ       opk\sbsi\per\setup\cbz
L2_Ba.CBZ       opk\sbsi\per\setup\cbz
L2_Ca.CBZ       opk\sbsi\per\setup\cbz
L2_Da.CBZ       opk\sbsi\per\setup\cbz
L2_Ea.CBZ       opk\sbsi\per\setup\cbz
L2_Fa.CBZ       opk\sbsi\per\setup\cbz
L2_Ga.CBZ       opk\sbsi\per\setup\cbz
L2_Ha.CBZ       opk\sbsi\per\setup\cbz
L2_Ia.CBZ       opk\sbsi\per\setup\cbz
L3_Aa.CBZ       opk\sbsi\per\setup\cbz
L3_Ba.CBZ       opk\sbsi\per\setup\cbz
L3_Ca.CBZ       opk\sbsi\per\setup\cbz
L3_Da.CBZ       opk\sbsi\per\setup\cbz
L3_Ea.CBZ       opk\sbsi\per\setup\cbz
L4_Aa.CBZ       opk\sbsi\per\setup\cbz
L4_Ba.CBZ       opk\sbsi\per\setup\cbz
L4_Ca.CBZ       opk\sbsi\per\setup\cbz
L4_Da.CBZ       opk\sbsi\per\setup\cbz
L4_Ea.CBZ       opk\sbsi\per\setup\cbz
L4_Fa.CBZ       opk\sbsi\per\setup\cbz
L4_Ga.CBZ       opk\sbsi\per\setup\cbz
L4_Ha.CBZ       opk\sbsi\per\setup\cbz
L5_Aa.CBZ       opk\sbsi\per\setup\cbz
L5_Ba.CBZ       opk\sbsi\per\setup\cbz
L5_Ca.CBZ       opk\sbsi\per\setup\cbz
L5_Da.CBZ       opk\sbsi\per\setup\cbz
L5_Ea.CBZ       opk\sbsi\per\setup\cbz
L5_Fa.CBZ       opk\sbsi\per\setup\cbz
L5_Ga.CBZ       opk\sbsi\per\setup\cbz
L5_Ha.CBZ       opk\sbsi\per\setup\cbz
L6_Aa.CBZ       opk\sbsi\per\setup\cbz
L6_Ba.CBZ       opk\sbsi\per\setup\cbz
L6_Ca.CBZ       opk\sbsi\per\setup\cbz
L6_Da.CBZ       opk\sbsi\per\setup\cbz
L6_Ea.CBZ       opk\sbsi\per\setup\cbz
L6_Fa.CBZ       opk\sbsi\per\setup\cbz
L7_Aa.CBZ       opk\sbsi\per\setup\cbz
L7_Ba.CBZ       opk\sbsi\per\setup\cbz
L7_Ca.CBZ       opk\sbsi\per\setup\cbz
L7_Da.CBZ       opk\sbsi\per\setup\cbz
L7_Ea.CBZ       opk\sbsi\per\setup\cbz
L7_Fa.CBZ       opk\sbsi\per\setup\cbz
L8_Aa.CBZ       opk\sbsi\per\setup\cbz
L8_Ba.CBZ       opk\sbsi\per\setup\cbz
L8_Ca.CBZ       opk\sbsi\per\setup\cbz
L8_Da.CBZ       opk\sbsi\per\setup\cbz
L8_Ea.CBZ       opk\sbsi\per\setup\cbz
L9_Aa.CBZ       opk\sbsi\per\setup\cbz
L9_Ba.CBZ       opk\sbsi\per\setup\cbz
L9_Ca.CBZ       opk\sbsi\per\setup\cbz
L9_Da.CBZ       opk\sbsi\per\setup\cbz
L9_Ea.CBZ       opk\sbsi\per\setup\cbz
L9_Fa.CBZ       opk\sbsi\per\setup\cbz
U1L1De.wav      opk\sbsi\per\setup\wave
U1L1Ee.wav      opk\sbsi\per\setup\wave
U1L1Fe.wav      opk\sbsi\per\setup\wave
U1L1Ge.wav      opk\sbsi\per\setup\wave
U1L1He.wav      opk\sbsi\per\setup\wave
U1L2Be.wav      opk\sbsi\per\setup\wave
U1L2Ce.wav      opk\sbsi\per\setup\wave
U1L2De.wav      opk\sbsi\per\setup\wave
U1L3Be.wav      opk\sbsi\per\setup\wave
U1L3Ce.wav      opk\sbsi\per\setup\wave
U1L3De.wav      opk\sbsi\per\setup\wave
U1L3Ee.wav      opk\sbsi\per\setup\wave
U1L3Fe.wav      opk\sbsi\per\setup\wave
U1L3Ge.wav      opk\sbsi\per\setup\wave
U2L1Be.wav      opk\sbsi\per\setup\wave
U2L1Ce.wav      opk\sbsi\per\setup\wave
U2L1De.wav      opk\sbsi\per\setup\wave
U2L1Fe.wav      opk\sbsi\per\setup\wave
U2L1Ge.wav      opk\sbsi\per\setup\wave
U2L2Be.wav      opk\sbsi\per\setup\wave
U2L2Ce.wav      opk\sbsi\per\setup\wave
U2L2De.wav      opk\sbsi\per\setup\wave
U2L2Ee.wav      opk\sbsi\per\setup\wave
U2L3Be.wav      opk\sbsi\per\setup\wave
U2L3Ce.wav      opk\sbsi\per\setup\wave
U2L3De.wav      opk\sbsi\per\setup\wave
U2L3Ee.wav      opk\sbsi\per\setup\wave
U2L4Be.wav      opk\sbsi\per\setup\wave
U2L4Ce.wav      opk\sbsi\per\setup\wave
U2L4De.wav      opk\sbsi\per\setup\wave
U2L5Ce.wav      opk\sbsi\per\setup\wave
U2L5De.wav      opk\sbsi\per\setup\wave
U2L5Ee.wav      opk\sbsi\per\setup\wave
U3L1Ce.wav      opk\sbsi\per\setup\wave
U3L1De.wav      opk\sbsi\per\setup\wave
U3L1Ee.wav	opk\sbsi\per\setup\wave
U3L3Be.wav      opk\sbsi\per\setup\wave
U3L3Ce.wav      opk\sbsi\per\setup\wave
U3L3De.wav      opk\sbsi\per\setup\wave
U3L3Fe.wav      opk\sbsi\per\setup\wave
U3L5Be.wav      opk\sbsi\per\setup\wave
U3L5Ce.wav      opk\sbsi\per\setup\wave
U3L5De.wav      opk\sbsi\per\setup\wave
U3L5Ee.wav      opk\sbsi\per\setup\wave
U4L1Ce.wav      opk\sbsi\per\setup\wave
U4L1Ee.wav      opk\sbsi\per\setup\wave
U4L1Fe.wav      opk\sbsi\per\setup\wave
U4L2Be.wav      opk\sbsi\per\setup\wave
U4L2Ce.wav      opk\sbsi\per\setup\wave
U4L2De.wav      opk\sbsi\per\setup\wave
U4L3Be.wav      opk\sbsi\per\setup\wave
U4L3Ce.wav      opk\sbsi\per\setup\wave
U4L3De.wav      opk\sbsi\per\setup\wave
U5L1Be.wav      opk\sbsi\per\setup\wave
U5L1Ce.wav      opk\sbsi\per\setup\wave
U5L1De.wav      opk\sbsi\per\setup\wave
U5L2Ce.wav      opk\sbsi\per\setup\wave
U5L2De.wav      opk\sbsi\per\setup\wave
fin_shot.swf    opk\sbsi\per\setup\lib
L10_A.LDZ       opk\sbsi\per\setup\lib
L10_B.LDZ       opk\sbsi\per\setup\lib
L10_C.LDZ       opk\sbsi\per\setup\lib
L10_D.LDZ       opk\sbsi\per\setup\lib
L10_E.LDZ       opk\sbsi\per\setup\lib
L10_F.LDZ	opk\sbsi\per\setup\lib
L11_A.LDZ       opk\sbsi\per\setup\lib
L11_B.LDZ       opk\sbsi\per\setup\lib
L11_C.LDZ       opk\sbsi\per\setup\lib
L11_D.LDZ       opk\sbsi\per\setup\lib
L11_E.LDZ       opk\sbsi\per\setup\lib
L11_F.LDZ       opk\sbsi\per\setup\lib
L12_A.LDZ       opk\sbsi\per\setup\lib
L12_B.LDZ       opk\sbsi\per\setup\lib
L12_C.LDZ       opk\sbsi\per\setup\lib
L12_D.LDZ       opk\sbsi\per\setup\lib
L12_E.LDZ       opk\sbsi\per\setup\lib
L13_A.LDZ       opk\sbsi\per\setup\lib
L13_B.LDZ       opk\sbsi\per\setup\lib
L13_C.LDZ       opk\sbsi\per\setup\lib
L13_D.LDZ       opk\sbsi\per\setup\lib
L13_E.LDZ       opk\sbsi\per\setup\lib
L13_F.LDZ       opk\sbsi\per\setup\lib
L14_A.LDZ       opk\sbsi\per\setup\lib
L14_B.LDZ       opk\sbsi\per\setup\lib
L14_C.LDZ       opk\sbsi\per\setup\lib
L14_D.LDZ       opk\sbsi\per\setup\lib
L14_E.LDZ       opk\sbsi\per\setup\lib
L15_A.LDZ       opk\sbsi\per\setup\lib
L15_B.LDZ       opk\sbsi\per\setup\lib
L15_C.LDZ       opk\sbsi\per\setup\lib
L15_D.LDZ       opk\sbsi\per\setup\lib
L15_E.LDZ       opk\sbsi\per\setup\lib
L15_F.LDZ       opk\sbsi\per\setup\lib
L16_A.LDZ       opk\sbsi\per\setup\lib
L16_B.LDZ       opk\sbsi\per\setup\lib
L16_C.LDZ       opk\sbsi\per\setup\lib
L16_D.LDZ       opk\sbsi\per\setup\lib
L16_E.LDZ       opk\sbsi\per\setup\lib
L17_A.LDZ       opk\sbsi\per\setup\lib
L17_B.LDZ       opk\sbsi\per\setup\lib
L17_C.LDZ       opk\sbsi\per\setup\lib
L17_D.LDZ       opk\sbsi\per\setup\lib
L17_E.LDZ       opk\sbsi\per\setup\lib
L1_A.LDZ       opk\sbsi\per\setup\lib
L2_A.LDZ       opk\sbsi\per\setup\lib
L2_B.LDZ       opk\sbsi\per\setup\lib
L2_C.LDZ       opk\sbsi\per\setup\lib
L2_D.LDZ       opk\sbsi\per\setup\lib
L2_E.LDZ       opk\sbsi\per\setup\lib
L2_F.LDZ       opk\sbsi\per\setup\lib
L2_G.LDZ       opk\sbsi\per\setup\lib
L2_H.LDZ       opk\sbsi\per\setup\lib
L2_I.LDZ       opk\sbsi\per\setup\lib
L3_A.LDZ       opk\sbsi\per\setup\lib
L3_B.LDZ       opk\sbsi\per\setup\lib
L3_C.LDZ       opk\sbsi\per\setup\lib
L3_D.LDZ       opk\sbsi\per\setup\lib
L3_E.LDZ       opk\sbsi\per\setup\lib
L4_A.LDZ       opk\sbsi\per\setup\lib
L4_B.LDZ       opk\sbsi\per\setup\lib
L4_C.LDZ       opk\sbsi\per\setup\lib
L4_D.LDZ       opk\sbsi\per\setup\lib
L4_E.LDZ       opk\sbsi\per\setup\lib
L4_F.LDZ       opk\sbsi\per\setup\lib
L4_G.LDZ       opk\sbsi\per\setup\lib
L4_H.LDZ       opk\sbsi\per\setup\lib
L5_A.LDZ       opk\sbsi\per\setup\lib
L5_B.LDZ       opk\sbsi\per\setup\lib
L5_C.LDZ       opk\sbsi\per\setup\lib
L5_D.LDZ       opk\sbsi\per\setup\lib
L5_E.LDZ       opk\sbsi\per\setup\lib
L5_F.LDZ       opk\sbsi\per\setup\lib
L5_G.LDZ       opk\sbsi\per\setup\lib
L5_H.LDZ       opk\sbsi\per\setup\lib
L6_A.LDZ       opk\sbsi\per\setup\lib
L6_B.LDZ       opk\sbsi\per\setup\lib
L6_C.LDZ       opk\sbsi\per\setup\lib
L6_D.LDZ       opk\sbsi\per\setup\lib
L6_E.LDZ       opk\sbsi\per\setup\lib
L6_F.LDZ       opk\sbsi\per\setup\lib
L7_A.LDZ       opk\sbsi\per\setup\lib
L7_B.LDZ       opk\sbsi\per\setup\lib
L7_C.LDZ       opk\sbsi\per\setup\lib
L7_D.LDZ       opk\sbsi\per\setup\lib
L7_E.LDZ       opk\sbsi\per\setup\lib
L7_F.LDZ       opk\sbsi\per\setup\lib
L8_A.LDZ       opk\sbsi\per\setup\lib
L8_B.LDZ       opk\sbsi\per\setup\lib
L8_C.LDZ       opk\sbsi\per\setup\lib
L8_D.LDZ       opk\sbsi\per\setup\lib
L8_E.LDZ       opk\sbsi\per\setup\lib
L9_A.LDZ       opk\sbsi\per\setup\lib
L9_B.LDZ       opk\sbsi\per\setup\lib
L9_C.LDZ       opk\sbsi\per\setup\lib
L9_D.LDZ       opk\sbsi\per\setup\lib
L9_E.LDZ       opk\sbsi\per\setup\lib
L9_F.LDZ       opk\sbsi\per\setup\lib
record_1.swf       opk\sbsi\per\setup\lib
SHAMMI02.HLP       opk\sbsi\per\setup\lib
SHAMMI04.HLP       opk\sbsi\per\setup\lib
SHAMMI05.HLP       opk\sbsi\per\setup\lib
SHAMMI06.HLP       opk\sbsi\per\setup\lib
SHAMMI07.HLP       opk\sbsi\per\setup\lib
SHAMMI09.HLP       opk\sbsi\per\setup\lib
SHAMMI12.HLP       opk\sbsi\per\setup\lib
SHAMMI13.HLP       opk\sbsi\per\setup\lib
SHAMMI14.HLP       opk\sbsi\per\setup\lib
SHAMMI15.HLP       opk\sbsi\per\setup\lib
SHAMMI19.HLP       opk\sbsi\per\setup\lib
SHAMMI20.HLP       opk\sbsi\per\setup\lib
SHAMMI21.HLP       opk\sbsi\per\setup\lib
shot01_1.swf       opk\sbsi\per\setup\lib
U0L1Ae.swf       opk\sbsi\per\setup\lib
U1L1Ae.swf       opk\sbsi\per\setup\lib
U1L1Be.swf       opk\sbsi\per\setup\lib
U1L1Ce.swf       opk\sbsi\per\setup\lib
U1L1De.swf       opk\sbsi\per\setup\lib
U1L1Ee.swf       opk\sbsi\per\setup\lib
U1L1Fe.swf       opk\sbsi\per\setup\lib
U1L1Ge.swf       opk\sbsi\per\setup\lib
U1L1He.swf       opk\sbsi\per\setup\lib
U1L1Ie.swf       opk\sbsi\per\setup\lib
U1L2Ae.swf       opk\sbsi\per\setup\lib
U1L2Be.swf       opk\sbsi\per\setup\lib
U1L2Ce.swf       opk\sbsi\per\setup\lib
U1L2De.swf       opk\sbsi\per\setup\lib
U1L2Ee.swf       opk\sbsi\per\setup\lib
U1L3Ae.swf       opk\sbsi\per\setup\lib
U1L3Be.swf       opk\sbsi\per\setup\lib
U1L3Ce.swf       opk\sbsi\per\setup\lib
U1L3De.swf       opk\sbsi\per\setup\lib
U1L3Ee.swf       opk\sbsi\per\setup\lib
U1L3Fe.swf       opk\sbsi\per\setup\lib
U1L3Ge.swf       opk\sbsi\per\setup\lib
U1L3He.swf       opk\sbsi\per\setup\lib
U2L1Ae.swf       opk\sbsi\per\setup\lib
U2L1Be.swf       opk\sbsi\per\setup\lib
U2L1Ce.swf       opk\sbsi\per\setup\lib
U2L1De.swf       opk\sbsi\per\setup\lib
U2L1Ee.swf       opk\sbsi\per\setup\lib
U2L1Fe.swf       opk\sbsi\per\setup\lib
U2L1Ge.swf       opk\sbsi\per\setup\lib
U2L1He.swf       opk\sbsi\per\setup\lib
U2L2Ae.swf       opk\sbsi\per\setup\lib
U2L2Be.swf       opk\sbsi\per\setup\lib
U2L2Ce.swf       opk\sbsi\per\setup\lib
U2L2De.swf       opk\sbsi\per\setup\lib
U2L2Ee.swf       opk\sbsi\per\setup\lib
U2L2Fe.swf       opk\sbsi\per\setup\lib
U2L3Ae.swf       opk\sbsi\per\setup\lib
U2L3Be.swf       opk\sbsi\per\setup\lib
U2L3Ce.swf       opk\sbsi\per\setup\lib
U2L3De.swf       opk\sbsi\per\setup\lib
U2L3Ee.swf       opk\sbsi\per\setup\lib
U2L3Fe.swf       opk\sbsi\per\setup\lib
U2L4Ae.swf       opk\sbsi\per\setup\lib
U2L4Be.swf       opk\sbsi\per\setup\lib
U2L4Ce.swf       opk\sbsi\per\setup\lib
U2L4De.swf       opk\sbsi\per\setup\lib
U2L4Ee.swf       opk\sbsi\per\setup\lib
U2L5Ae.swf       opk\sbsi\per\setup\lib
U2L5Be.swf       opk\sbsi\per\setup\lib
U2L5Ce.swf       opk\sbsi\per\setup\lib
U2L5De.swf       opk\sbsi\per\setup\lib
U2L5Ee.swf       opk\sbsi\per\setup\lib
U2L5Fe.swf       opk\sbsi\per\setup\lib
U3L1Ae.swf       opk\sbsi\per\setup\lib
U3L1Be.swf       opk\sbsi\per\setup\lib
U3L1Ce.swf       opk\sbsi\per\setup\lib
U3L1De.swf       opk\sbsi\per\setup\lib
U3L1fe.swf	 opk\sbsi\per\setup\lib
U3L1Ee.swf       opk\sbsi\per\setup\lib
U3L3Ae.swf       opk\sbsi\per\setup\lib
U3L3Be.swf       opk\sbsi\per\setup\lib
U3L3Ce.swf       opk\sbsi\per\setup\lib
U3L3De.swf       opk\sbsi\per\setup\lib
U3L3Fe.swf       opk\sbsi\per\setup\lib
U3L3Ge.swf       opk\sbsi\per\setup\lib
U3L5Ae.swf       opk\sbsi\per\setup\lib
U3L5Be.swf       opk\sbsi\per\setup\lib
U3L5Ce.swf       opk\sbsi\per\setup\lib
U3L5De.swf       opk\sbsi\per\setup\lib
U3L5Ee.swf       opk\sbsi\per\setup\lib
U3L5Fe.swf       opk\sbsi\per\setup\lib
U4L1Ae.swf       opk\sbsi\per\setup\lib
U4L1Be.swf       opk\sbsi\per\setup\lib
U4L1Ce.swf       opk\sbsi\per\setup\lib
U4L1De.swf       opk\sbsi\per\setup\lib
U4L1Ee.swf       opk\sbsi\per\setup\lib
U4L1Fe.swf       opk\sbsi\per\setup\lib
U4L1Ge.swf       opk\sbsi\per\setup\lib
U4L2Ae.swf       opk\sbsi\per\setup\lib
U4L2Be.swf       opk\sbsi\per\setup\lib
U4L2Ce.swf       opk\sbsi\per\setup\lib
U4L2De.swf       opk\sbsi\per\setup\lib
U4L2Ee.swf       opk\sbsi\per\setup\lib
U4L3Ae.swf       opk\sbsi\per\setup\lib
U4L3Be.swf       opk\sbsi\per\setup\lib
U4L3Ce.swf       opk\sbsi\per\setup\lib
U4L3De.swf       opk\sbsi\per\setup\lib
U4L3Ee.swf       opk\sbsi\per\setup\lib
U4L3Fe.swf       opk\sbsi\per\setup\lib
U5L1Ae.swf       opk\sbsi\per\setup\lib
U5L1Be.swf       opk\sbsi\per\setup\lib
U5L1Ce.swf       opk\sbsi\per\setup\lib
U5L1De.swf       opk\sbsi\per\setup\lib
U5L1Ee.swf       opk\sbsi\per\setup\lib
U5L2Ae.swf       opk\sbsi\per\setup\lib
U5L2Be.swf       opk\sbsi\per\setup\lib
U5L2Ce.swf       opk\sbsi\per\setup\lib
U5L2De.swf       opk\sbsi\per\setup\lib
U5L2Ee.swf       opk\sbsi\per\setup\lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\sbsi\placepro.txt ===
readme.txt      opk\sbsi\pro
setup.exe       opk\sbsi\pro
silent.bat      opk\sbsi\pro
DATA.TAG        opk\sbsi\pro\setup
data1.cab       opk\sbsi\pro\setup
data1.hdr       opk\sbsi\pro\setup
flash.exe       opk\sbsi\pro\setup
foo.cmd         opk\sbsi\pro\setup
foo.txt         opk\sbsi\pro\setup
lang.dat        opk\sbsi\pro\setup
layout.bin      opk\sbsi\pro\setup
os.dat          opk\sbsi\pro\setup
second.iss      opk\sbsi\pro\setup
Silent.iss      opk\sbsi\pro\setup
setup.bmp       opk\sbsi\pro\setup
SETUP.INI       opk\sbsi\pro\setup
setup.ins       opk\sbsi\pro\setup
setup.lid       opk\sbsi\pro\setup
_INST32I.EX_    opk\sbsi\pro\setup
_ISDel.exe      opk\sbsi\pro\setup
_Setup.dll      opk\sbsi\pro\setup
_sys1.cab       opk\sbsi\pro\setup
_sys1.hdr       opk\sbsi\pro\setup
_user1.cab      opk\sbsi\pro\setup
_user1.hdr      opk\sbsi\pro\setup
DBMerge.exe     opk\sbsi\pro\setup\dbmerge
LEARN32.DLL     opk\sbsi\pro\setup\dbmerge
Syllabi2.cdx    opk\sbsi\pro\setup\dbmerge
Syllabi2.dbf    opk\sbsi\pro\setup\dbmerge
Syllabus.cdx    opk\sbsi\pro\setup\dbmerge
Syllabus.dbf    opk\sbsi\pro\setup\dbmerge
L10_Aa.CBZ      opk\sbsi\pro\setup\cbz
L10_Ba.CBZ      opk\sbsi\pro\setup\cbz
L10_Ca.CBZ      opk\sbsi\pro\setup\cbz
L10_Da.CBZ      opk\sbsi\pro\setup\cbz
L10_Ea.CBZ      opk\sbsi\pro\setup\cbz
L11_Aa.CBZ      opk\sbsi\pro\setup\cbz
L11_Ba.CBZ      opk\sbsi\pro\setup\cbz
L11_Ca.CBZ      opk\sbsi\pro\setup\cbz
L11_Da.CBZ      opk\sbsi\pro\setup\cbz
L11_Ea.CBZ      opk\sbsi\pro\setup\cbz
L12_Aa.CBZ      opk\sbsi\pro\setup\cbz
L12_Ba.CBZ      opk\sbsi\pro\setup\cbz
L12_Ca.CBZ      opk\sbsi\pro\setup\cbz
L12_Da.CBZ      opk\sbsi\pro\setup\cbz
L12_Ea.CBZ      opk\sbsi\pro\setup\cbz
L12_Fa.CBZ      opk\sbsi\pro\setup\cbz
L13_Aa.CBZ      opk\sbsi\pro\setup\cbz
L13_Ba.CBZ      opk\sbsi\pro\setup\cbz
L13_Ca.CBZ      opk\sbsi\pro\setup\cbz
L13_Da.CBZ      opk\sbsi\pro\setup\cbz
L13_Ea.CBZ      opk\sbsi\pro\setup\cbz
L13_Fa.CBZ      opk\sbsi\pro\setup\cbz
L13_Ga.CBZ      opk\sbsi\pro\setup\cbz
L13_Ha.CBZ      opk\sbsi\pro\setup\cbz
L13_Ia.CBZ      opk\sbsi\pro\setup\cbz
L14_Aa.CBZ      opk\sbsi\pro\setup\cbz
L14_Ba.CBZ      opk\sbsi\pro\setup\cbz
L14_Ca.CBZ      opk\sbsi\pro\setup\cbz
L14_Da.CBZ      opk\sbsi\pro\setup\cbz
L14_Ea.CBZ      opk\sbsi\pro\setup\cbz
L14_Fa.CBZ      opk\sbsi\pro\setup\cbz
L14_Ga.CBZ      opk\sbsi\pro\setup\cbz
L15_Aa.CBZ      opk\sbsi\pro\setup\cbz
L15_Ba.CBZ      opk\sbsi\pro\setup\cbz
L15_Ca.CBZ      opk\sbsi\pro\setup\cbz
L15_Da.CBZ      opk\sbsi\pro\setup\cbz
L16_Aa.CBZ      opk\sbsi\pro\setup\cbz
L16_Ba.CBZ      opk\sbsi\pro\setup\cbz
L16_Ca.CBZ      opk\sbsi\pro\setup\cbz
L16_Da.CBZ      opk\sbsi\pro\setup\cbz
L16_Ea.CBZ      opk\sbsi\pro\setup\cbz
L17_Aa.CBZ      opk\sbsi\pro\setup\cbz
L17_Ba.CBZ      opk\sbsi\pro\setup\cbz
L17_Ca.CBZ      opk\sbsi\pro\setup\cbz
L17_Da.CBZ      opk\sbsi\pro\setup\cbz
L17_Ea.CBZ      opk\sbsi\pro\setup\cbz
L18_Aa.CBZ      opk\sbsi\pro\setup\cbz
L18_Ba.CBZ      opk\sbsi\pro\setup\cbz
L18_Ca.CBZ      opk\sbsi\pro\setup\cbz
L18_Da.CBZ      opk\sbsi\pro\setup\cbz
L18_Ea.CBZ      opk\sbsi\pro\setup\cbz
L19_Aa.CBZ      opk\sbsi\pro\setup\cbz
L19_Ba.CBZ      opk\sbsi\pro\setup\cbz
L19_Ca.CBZ      opk\sbsi\pro\setup\cbz
L19_Da.CBZ      opk\sbsi\pro\setup\cbz
L19_Ea.CBZ      opk\sbsi\pro\setup\cbz
L1_Aa.CBZ      opk\sbsi\pro\setup\cbz
L20_Aa.CBZ      opk\sbsi\pro\setup\cbz
L20_Ba.CBZ      opk\sbsi\pro\setup\cbz
L20_Ca.CBZ      opk\sbsi\pro\setup\cbz
L20_Da.CBZ      opk\sbsi\pro\setup\cbz
L20_Ea.CBZ      opk\sbsi\pro\setup\cbz
L20_Fa.CBZ      opk\sbsi\pro\setup\cbz
L20_Ga.CBZ      opk\sbsi\pro\setup\cbz
L2_Aa.CBZ      opk\sbsi\pro\setup\cbz
L2_Ba.CBZ      opk\sbsi\pro\setup\cbz
L2_Ca.CBZ      opk\sbsi\pro\setup\cbz
L2_Da.CBZ      opk\sbsi\pro\setup\cbz
L2_Ea.CBZ      opk\sbsi\pro\setup\cbz
L2_Fa.CBZ      opk\sbsi\pro\setup\cbz
L2_Ga.CBZ      opk\sbsi\pro\setup\cbz
L2_Ha.CBZ      opk\sbsi\pro\setup\cbz
L3_Aa.CBZ      opk\sbsi\pro\setup\cbz
L3_Ba.CBZ      opk\sbsi\pro\setup\cbz
L3_Ca.CBZ      opk\sbsi\pro\setup\cbz
L3_Da.CBZ      opk\sbsi\pro\setup\cbz
L3_Ea.CBZ      opk\sbsi\pro\setup\cbz
L4_Aa.CBZ      opk\sbsi\pro\setup\cbz
L4_Ba.CBZ      opk\sbsi\pro\setup\cbz
L4_Ca.CBZ      opk\sbsi\pro\setup\cbz
L4_Da.CBZ      opk\sbsi\pro\setup\cbz
L4_Ea.CBZ      opk\sbsi\pro\setup\cbz
L4_Fa.CBZ      opk\sbsi\pro\setup\cbz
L4_Ga.CBZ      opk\sbsi\pro\setup\cbz
L4_Ha.CBZ      opk\sbsi\pro\setup\cbz
L5_Aa.CBZ      opk\sbsi\pro\setup\cbz
L5_Ba.CBZ      opk\sbsi\pro\setup\cbz
L5_Ca.CBZ      opk\sbsi\pro\setup\cbz
L5_Da.CBZ      opk\sbsi\pro\setup\cbz
L5_Ea.CBZ      opk\sbsi\pro\setup\cbz
L5_Fa.CBZ      opk\sbsi\pro\setup\cbz
L6_Aa.CBZ      opk\sbsi\pro\setup\cbz
L6_Ba.CBZ      opk\sbsi\pro\setup\cbz
L6_Ca.CBZ      opk\sbsi\pro\setup\cbz
L6_Da.CBZ      opk\sbsi\pro\setup\cbz
L6_Ea.CBZ      opk\sbsi\pro\setup\cbz
L6_Fa.CBZ      opk\sbsi\pro\setup\cbz
L7_Aa.CBZ      opk\sbsi\pro\setup\cbz
L7_Ba.CBZ      opk\sbsi\pro\setup\cbz
L7_Ca.CBZ      opk\sbsi\pro\setup\cbz
L7_Da.CBZ      opk\sbsi\pro\setup\cbz
L7_Ea.CBZ      opk\sbsi\pro\setup\cbz
L7_Fa.CBZ      opk\sbsi\pro\setup\cbz
L8_Aa.CBZ      opk\sbsi\pro\setup\cbz
L8_Ba.CBZ      opk\sbsi\pro\setup\cbz
L8_Ca.CBZ      opk\sbsi\pro\setup\cbz
L8_Da.CBZ      opk\sbsi\pro\setup\cbz
L8_Ea.CBZ      opk\sbsi\pro\setup\cbz
L8_Fa.CBZ      opk\sbsi\pro\setup\cbz
L9_Aa.CBZ      opk\sbsi\pro\setup\cbz
L9_Ba.CBZ      opk\sbsi\pro\setup\cbz
L9_Ca.CBZ      opk\sbsi\pro\setup\cbz
L9_Da.CBZ      opk\sbsi\pro\setup\cbz
L9_Ea.CBZ      opk\sbsi\pro\setup\cbz
U1L1Dr.wav     opk\sbsi\pro\setup\wave
U1L1Er.wav     opk\sbsi\pro\setup\wave
U1L1Fr.wav     opk\sbsi\pro\setup\wave
U1L1Gr.wav     opk\sbsi\pro\setup\wave
U1L1Hr.wav     opk\sbsi\pro\setup\wave
U1L2Cr.wav     opk\sbsi\pro\setup\wave
U1L2Dr.wav     opk\sbsi\pro\setup\wave
U1L2Er.wav     opk\sbsi\pro\setup\wave
U1L3Cr.wav     opk\sbsi\pro\setup\wave
U1L3Dr.wav     opk\sbsi\pro\setup\wave
U1L3Er.wav     opk\sbsi\pro\setup\wave
U1L3Fr.wav     opk\sbsi\pro\setup\wave
U1L3Gr.wav     opk\sbsi\pro\setup\wave
U1L3Hr.wav     opk\sbsi\pro\setup\wave
U2L1Dr.wav     opk\sbsi\pro\setup\wave
U2L1Er.wav     opk\sbsi\pro\setup\wave
U2L1Fr.wav     opk\sbsi\pro\setup\wave
U2L2Dr.wav     opk\sbsi\pro\setup\wave
U2L2Er.wav     opk\sbsi\pro\setup\wave
U2L3Cr.wav     opk\sbsi\pro\setup\wave
U2L3Dr.wav     opk\sbsi\pro\setup\wave
U2L3Er.wav     opk\sbsi\pro\setup\wave
U2L3Fr.wav     opk\sbsi\pro\setup\wave
U2L4Cr.wav     opk\sbsi\pro\setup\wave
U2L4Dr.wav     opk\sbsi\pro\setup\wave
U2L4Er.wav     opk\sbsi\pro\setup\wave
U2L4Fr.wav     opk\sbsi\pro\setup\wave
U2L5Cr.wav     opk\sbsi\pro\setup\wave
U2L5Dr.wav     opk\sbsi\pro\setup\wave
U2L5Er.wav     opk\sbsi\pro\setup\wave
U3L1Dr.wav     opk\sbsi\pro\setup\wave
U3L1Er.wav     opk\sbsi\pro\setup\wave
U3L2Cr.wav     opk\sbsi\pro\setup\wave
U3L2Dr.wav     opk\sbsi\pro\setup\wave
U3L2Er.wav     opk\sbsi\pro\setup\wave
U3L3Cr.wav     opk\sbsi\pro\setup\wave
U3L3Dr.wav     opk\sbsi\pro\setup\wave
U3L3Er.wav     opk\sbsi\pro\setup\wave
U3L3Fr.wav     opk\sbsi\pro\setup\wave
U4L1Dr.wav     opk\sbsi\pro\setup\wave
U4L1Er.wav     opk\sbsi\pro\setup\wave
U4L1Fr.wav     opk\sbsi\pro\setup\wave
U4L1Hr.wav     opk\sbsi\pro\setup\wave
U4L1Ir.wav     opk\sbsi\pro\setup\wave
U4L2Dr.wav     opk\sbsi\pro\setup\wave
U4L2Er.wav     opk\sbsi\pro\setup\wave
U4L2Fr.wav     opk\sbsi\pro\setup\wave
U4L2Gr.wav     opk\sbsi\pro\setup\wave
U4L3Dr.wav     opk\sbsi\pro\setup\wave
U4L4Dr.wav     opk\sbsi\pro\setup\wave
U4L4Er.wav     opk\sbsi\pro\setup\wave
U5L1Cr.wav     opk\sbsi\pro\setup\wave
U5L1Dr.wav     opk\sbsi\pro\setup\wave
U5L1Er.wav     opk\sbsi\pro\setup\wave
U5L2Dr.wav     opk\sbsi\pro\setup\wave
U5L2Er.wav     opk\sbsi\pro\setup\wave
U5L3Dr.wav     opk\sbsi\pro\setup\wave
U5L3Er.wav     opk\sbsi\pro\setup\wave
U5L4Dr.wav     opk\sbsi\pro\setup\wave
U5L4Er.wav     opk\sbsi\pro\setup\wave
U5L4Fr.wav     opk\sbsi\pro\setup\wave
U5L4Gr.wav     opk\sbsi\pro\setup\wave
L10_A.LDZ       opk\sbsi\pro\setup\lib
L10_B.LDZ       opk\sbsi\pro\setup\lib
L10_C.LDZ       opk\sbsi\pro\setup\lib
L10_D.LDZ       opk\sbsi\pro\setup\lib
L10_E.LDZ       opk\sbsi\pro\setup\lib
L11_A.LDZ       opk\sbsi\pro\setup\lib
L11_B.LDZ       opk\sbsi\pro\setup\lib
L11_C.LDZ       opk\sbsi\pro\setup\lib
L11_D.LDZ       opk\sbsi\pro\setup\lib
L11_E.LDZ       opk\sbsi\pro\setup\lib
L12_A.LDZ       opk\sbsi\pro\setup\lib
L12_B.LDZ       opk\sbsi\pro\setup\lib
L12_C.LDZ       opk\sbsi\pro\setup\lib
L12_D.LDZ       opk\sbsi\pro\setup\lib
L12_E.LDZ       opk\sbsi\pro\setup\lib
L12_F.LDZ       opk\sbsi\pro\setup\lib
L13_A.LDZ       opk\sbsi\pro\setup\lib
L13_B.LDZ       opk\sbsi\pro\setup\lib
L13_C.LDZ       opk\sbsi\pro\setup\lib
L13_D.LDZ       opk\sbsi\pro\setup\lib
L13_E.LDZ       opk\sbsi\pro\setup\lib
L13_F.LDZ       opk\sbsi\pro\setup\lib
L13_G.LDZ       opk\sbsi\pro\setup\lib
L13_H.LDZ       opk\sbsi\pro\setup\lib
L13_I.LDZ       opk\sbsi\pro\setup\lib
L14_A.LDZ       opk\sbsi\pro\setup\lib
L14_B.LDZ       opk\sbsi\pro\setup\lib
L14_C.LDZ       opk\sbsi\pro\setup\lib
L14_D.LDZ       opk\sbsi\pro\setup\lib
L14_E.LDZ       opk\sbsi\pro\setup\lib
L14_F.LDZ       opk\sbsi\pro\setup\lib
L14_G.LDZ       opk\sbsi\pro\setup\lib
L15_A.LDZ       opk\sbsi\pro\setup\lib
L15_B.LDZ       opk\sbsi\pro\setup\lib
L15_C.LDZ       opk\sbsi\pro\setup\lib
L15_D.LDZ       opk\sbsi\pro\setup\lib
L16_A.LDZ       opk\sbsi\pro\setup\lib
L16_B.LDZ       opk\sbsi\pro\setup\lib
L16_C.LDZ       opk\sbsi\pro\setup\lib
L16_D.LDZ       opk\sbsi\pro\setup\lib
L16_E.LDZ       opk\sbsi\pro\setup\lib
L17_A.LDZ       opk\sbsi\pro\setup\lib
L17_B.LDZ       opk\sbsi\pro\setup\lib
L17_C.LDZ       opk\sbsi\pro\setup\lib
L17_D.LDZ       opk\sbsi\pro\setup\lib
L17_E.LDZ       opk\sbsi\pro\setup\lib
L18_A.LDZ       opk\sbsi\pro\setup\lib
L18_B.LDZ       opk\sbsi\pro\setup\lib
L18_C.LDZ       opk\sbsi\pro\setup\lib
L18_D.LDZ       opk\sbsi\pro\setup\lib
L18_E.LDZ       opk\sbsi\pro\setup\lib
L19_A.LDZ       opk\sbsi\pro\setup\lib
L19_B.LDZ       opk\sbsi\pro\setup\lib
L19_C.LDZ       opk\sbsi\pro\setup\lib
L19_D.LDZ       opk\sbsi\pro\setup\lib
L19_E.LDZ       opk\sbsi\pro\setup\lib
L1_A.LDZ       opk\sbsi\pro\setup\lib
L20_A.LDZ       opk\sbsi\pro\setup\lib
L20_B.LDZ       opk\sbsi\pro\setup\lib
L20_C.LDZ       opk\sbsi\pro\setup\lib
L20_D.LDZ       opk\sbsi\pro\setup\lib
L20_E.LDZ       opk\sbsi\pro\setup\lib
L20_F.LDZ       opk\sbsi\pro\setup\lib
L20_G.LDZ       opk\sbsi\pro\setup\lib
L2_A.LDZ       opk\sbsi\pro\setup\lib
L2_B.LDZ       opk\sbsi\pro\setup\lib
L2_C.LDZ       opk\sbsi\pro\setup\lib
L2_D.LDZ       opk\sbsi\pro\setup\lib
L2_E.LDZ       opk\sbsi\pro\setup\lib
L2_F.LDZ       opk\sbsi\pro\setup\lib
L2_G.LDZ       opk\sbsi\pro\setup\lib
L2_H.LDZ       opk\sbsi\pro\setup\lib
L3_A.LDZ       opk\sbsi\pro\setup\lib
L3_B.LDZ       opk\sbsi\pro\setup\lib
L3_C.LDZ       opk\sbsi\pro\setup\lib
L3_D.LDZ       opk\sbsi\pro\setup\lib
L3_E.LDZ       opk\sbsi\pro\setup\lib
L4_A.LDZ       opk\sbsi\pro\setup\lib
L4_B.LDZ       opk\sbsi\pro\setup\lib
L4_C.LDZ       opk\sbsi\pro\setup\lib
L4_D.LDZ       opk\sbsi\pro\setup\lib
L4_E.LDZ       opk\sbsi\pro\setup\lib
L4_F.LDZ       opk\sbsi\pro\setup\lib
L4_G.LDZ       opk\sbsi\pro\setup\lib
L4_H.LDZ       opk\sbsi\pro\setup\lib
L5_A.LDZ       opk\sbsi\pro\setup\lib
L5_B.LDZ       opk\sbsi\pro\setup\lib
L5_C.LDZ       opk\sbsi\pro\setup\lib
L5_D.LDZ       opk\sbsi\pro\setup\lib
L5_E.LDZ       opk\sbsi\pro\setup\lib
L5_F.LDZ       opk\sbsi\pro\setup\lib
L6_A.LDZ       opk\sbsi\pro\setup\lib
L6_B.LDZ       opk\sbsi\pro\setup\lib
L6_C.LDZ       opk\sbsi\pro\setup\lib
L6_D.LDZ       opk\sbsi\pro\setup\lib
L6_E.LDZ       opk\sbsi\pro\setup\lib
L6_F.LDZ       opk\sbsi\pro\setup\lib
L7_A.LDZ       opk\sbsi\pro\setup\lib
L7_B.LDZ       opk\sbsi\pro\setup\lib
L7_C.LDZ       opk\sbsi\pro\setup\lib
L7_D.LDZ       opk\sbsi\pro\setup\lib
L7_E.LDZ       opk\sbsi\pro\setup\lib
L7_F.LDZ       opk\sbsi\pro\setup\lib
L8_A.LDZ       opk\sbsi\pro\setup\lib
L8_B.LDZ       opk\sbsi\pro\setup\lib
L8_C.LDZ       opk\sbsi\pro\setup\lib
L8_D.LDZ       opk\sbsi\pro\setup\lib
L8_E.LDZ       opk\sbsi\pro\setup\lib
L8_F.LDZ       opk\sbsi\pro\setup\lib
L9_A.LDZ       opk\sbsi\pro\setup\lib
L9_B.LDZ       opk\sbsi\pro\setup\lib
L9_C.LDZ       opk\sbsi\pro\setup\lib
L9_D.LDZ       opk\sbsi\pro\setup\lib
L9_E.LDZ       opk\sbsi\pro\setup\lib
SHAMMI01.HLP       opk\sbsi\pro\setup\lib
SHAMMI02.HLP       opk\sbsi\pro\setup\lib
SHAMMI04.HLP       opk\sbsi\pro\setup\lib
SHAMMI05.HLP       opk\sbsi\pro\setup\lib
SHAMMI06.HLP       opk\sbsi\pro\setup\lib
SHAMMI07.HLP       opk\sbsi\pro\setup\lib
SHAMMI09.HLP       opk\sbsi\pro\setup\lib
SHAMMI12.HLP       opk\sbsi\pro\setup\lib
SHAMMI13.HLP       opk\sbsi\pro\setup\lib
SHAMMI14.HLP       opk\sbsi\pro\setup\lib
SHAMMI15.HLP       opk\sbsi\pro\setup\lib
SHAMMI16.HLP       opk\sbsi\pro\setup\lib
SHAMMI17.HLP       opk\sbsi\pro\setup\lib
SHAMMI18.HLP       opk\sbsi\pro\setup\lib
SHAMMI19.HLP       opk\sbsi\pro\setup\lib
SHAMMI20.HLP       opk\sbsi\pro\setup\lib
SHAMMI21.HLP       opk\sbsi\pro\setup\lib
U0L1Aa.swf       opk\sbsi\pro\setup\lib
U0L1Ar.swf       opk\sbsi\pro\setup\lib
U1L1Ar.swf       opk\sbsi\pro\setup\lib
U1L1Cr.swf       opk\sbsi\pro\setup\lib
U1L1Dr.swf       opk\sbsi\pro\setup\lib
U1L1Er.swf       opk\sbsi\pro\setup\lib
U1L1Fr.swf       opk\sbsi\pro\setup\lib
U1L1Gr.swf       opk\sbsi\pro\setup\lib
U1L1Hr.swf       opk\sbsi\pro\setup\lib
U1L1Ir.swf       opk\sbsi\pro\setup\lib
U1L2Ar.swf       opk\sbsi\pro\setup\lib
U1L2Cr.swf       opk\sbsi\pro\setup\lib
U1L2Dr.swf       opk\sbsi\pro\setup\lib
U1L2Er.swf       opk\sbsi\pro\setup\lib
U1L2Fr.swf       opk\sbsi\pro\setup\lib
U1L3Ar.swf       opk\sbsi\pro\setup\lib
U1L3Cr.swf       opk\sbsi\pro\setup\lib
U1L3Dr.swf       opk\sbsi\pro\setup\lib
U1L3Er.swf       opk\sbsi\pro\setup\lib
U1L3Fr.swf       opk\sbsi\pro\setup\lib
U1L3Gr.swf       opk\sbsi\pro\setup\lib
U1L3Hr.swf       opk\sbsi\pro\setup\lib
U1L3Ir.swf       opk\sbsi\pro\setup\lib
U2L1Ar.swf       opk\sbsi\pro\setup\lib
U2L1Cr.swf       opk\sbsi\pro\setup\lib
U2L1Dr.swf       opk\sbsi\pro\setup\lib
U2L1Er.swf       opk\sbsi\pro\setup\lib
U2L1Fr.swf       opk\sbsi\pro\setup\lib
U2L1Gr.swf       opk\sbsi\pro\setup\lib
U2L2Ar.swf       opk\sbsi\pro\setup\lib
U2L2Cr.swf       opk\sbsi\pro\setup\lib
U2L2Dr.swf       opk\sbsi\pro\setup\lib
U2L2Er.swf       opk\sbsi\pro\setup\lib
U2L2Fr.swf       opk\sbsi\pro\setup\lib
U2L2Gr.swf       opk\sbsi\pro\setup\lib
U2L3Ar.swf       opk\sbsi\pro\setup\lib
U2L3Cr.swf       opk\sbsi\pro\setup\lib
U2L3Dr.swf       opk\sbsi\pro\setup\lib
U2L3Er.swf       opk\sbsi\pro\setup\lib
U2L3Fr.swf       opk\sbsi\pro\setup\lib
U2L3Gr.swf       opk\sbsi\pro\setup\lib
U2L4Ar.swf       opk\sbsi\pro\setup\lib
U2L4Cr.swf       opk\sbsi\pro\setup\lib
U2L4Dr.swf       opk\sbsi\pro\setup\lib
U2L4Er.swf       opk\sbsi\pro\setup\lib
U2L4Fr.swf       opk\sbsi\pro\setup\lib
U2L4Gr.swf       opk\sbsi\pro\setup\lib
U2L5Ar.swf       opk\sbsi\pro\setup\lib
U2L5Cr.swf       opk\sbsi\pro\setup\lib
U2L5Dr.swf       opk\sbsi\pro\setup\lib
U2L5Er.swf       opk\sbsi\pro\setup\lib
U2L5Fr.swf       opk\sbsi\pro\setup\lib
U3L1Ar.swf       opk\sbsi\pro\setup\lib
U3L1Cr.swf       opk\sbsi\pro\setup\lib
U3L1Dr.swf       opk\sbsi\pro\setup\lib
U3L1Er.swf       opk\sbsi\pro\setup\lib
U3L1Fr.swf       opk\sbsi\pro\setup\lib
U3L2Ar.swf       opk\sbsi\pro\setup\lib
U3L2Cr.swf       opk\sbsi\pro\setup\lib
U3L2Dr.swf       opk\sbsi\pro\setup\lib
U3L2Er.swf       opk\sbsi\pro\setup\lib
U3L2Fr.swf       opk\sbsi\pro\setup\lib
U3L3Ar.swf       opk\sbsi\pro\setup\lib
U3L3Cr.swf       opk\sbsi\pro\setup\lib
U3L3Dr.swf       opk\sbsi\pro\setup\lib
U3L3Er.swf       opk\sbsi\pro\setup\lib
U3L3Fr.swf       opk\sbsi\pro\setup\lib
U3L3Gr.swf       opk\sbsi\pro\setup\lib
U4L1Ar.swf       opk\sbsi\pro\setup\lib
U4L1Cr.swf       opk\sbsi\pro\setup\lib
U4L1Dr.swf       opk\sbsi\pro\setup\lib
U4L1Er.swf       opk\sbsi\pro\setup\lib
U4L1Fr.swf       opk\sbsi\pro\setup\lib
U4L1Gr.swf       opk\sbsi\pro\setup\lib
U4L1Hr.swf       opk\sbsi\pro\setup\lib
U4L1Ir.swf       opk\sbsi\pro\setup\lib
U4L1Jr.swf       opk\sbsi\pro\setup\lib
U4L2Ar.swf       opk\sbsi\pro\setup\lib
U4L2Cr.swf       opk\sbsi\pro\setup\lib
U4L2Dr.swf       opk\sbsi\pro\setup\lib
U4L2Er.swf       opk\sbsi\pro\setup\lib
U4L2Fr.swf       opk\sbsi\pro\setup\lib
U4L2Gr.swf       opk\sbsi\pro\setup\lib
U4L2Hr.swf       opk\sbsi\pro\setup\lib
U4L3Ar.swf       opk\sbsi\pro\setup\lib
U4L3Cr.swf       opk\sbsi\pro\setup\lib
U4L3Dr.swf       opk\sbsi\pro\setup\lib
U4L3Er.swf       opk\sbsi\pro\setup\lib
U4L4Ar.swf       opk\sbsi\pro\setup\lib
U4L4Cr.swf       opk\sbsi\pro\setup\lib
U4L4Dr.swf       opk\sbsi\pro\setup\lib
U4L4Er.swf       opk\sbsi\pro\setup\lib
U4L4Fr.swf       opk\sbsi\pro\setup\lib
U5L1Ar.swf       opk\sbsi\pro\setup\lib
U5L1Cr.swf       opk\sbsi\pro\setup\lib
U5L1Dr.swf       opk\sbsi\pro\setup\lib
U5L1Er.swf       opk\sbsi\pro\setup\lib
U5L1Fr.swf       opk\sbsi\pro\setup\lib
U5L2Ar.swf       opk\sbsi\pro\setup\lib
U5L2Cr.swf       opk\sbsi\pro\setup\lib
U5L2Dr.swf       opk\sbsi\pro\setup\lib
U5L2Er.swf       opk\sbsi\pro\setup\lib
U5L2Fr.swf       opk\sbsi\pro\setup\lib
U5L3Ar.swf       opk\sbsi\pro\setup\lib
U5L3Cr.swf       opk\sbsi\pro\setup\lib
U5L3Dr.swf       opk\sbsi\pro\setup\lib
U5L3Er.swf       opk\sbsi\pro\setup\lib
U5L3Fr.swf       opk\sbsi\pro\setup\lib
U5L4Ar.swf       opk\sbsi\pro\setup\lib
U5L4Cr.swf       opk\sbsi\pro\setup\lib
U5L4Dr.swf       opk\sbsi\pro\setup\lib
U5L4Er.swf       opk\sbsi\pro\setup\lib
U5L4Fr.swf       opk\sbsi\pro\setup\lib
U5L4Gr.swf       opk\sbsi\pro\setup\lib
U5L4Hr.swf       opk\sbsi\pro\setup\lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\sbsi\per\readme.txt ===
--------------------------------------------------------------
Microsoft(r) Windows XP Home Edition Step by Step Interactive
--------------------------------------------------------------

(c)2001 Microsoft(r) Corporation. All rights reserved.

This document provides information about Microsoft(r) Windows XP Home Edition Step by Step Interactive as well as answers to questions that you might have.


------------------------
How to Use This Document
------------------------

To view the Readme file in Windows Notepad, maximize the Notepad window, and turn on the Word Wrap feature. To print the Readme file, open it in Notepad or another word-processing program, and click Print on the File menu.

--------
CONTENTS
--------

   1. PRODUCT DEFINITION
   2. SYSTEM REQUIREMENTS
   3. INSTALLATION TIPS
   4. THE SIMULATED TRAINING ENVIRONMENT
   5. TROUBLESHOOTING
   6. VISIT MICROSOFT ON THE WEB


------------------
PRODUCT DEFINITION
------------------

Microsoft (r) Windows XP Home Edition Step by Step Interactive is a multimedia, self-paced training product that uses a combination of simulations and informative topics to create an easy and flexible learning environment.

This interactive training is available in the following languages: Brazilian Portuguese, Dutch, English, French, German, Italian, Japanese, Korean, Simplified Chinese, Spanish, Swedish, and Traditional Chinese. 

For information on corporate licensing programs for Microsoft Interactive Training products, please contact your Microsoft Field Representative or Large Account Reseller.


-------------------
SYSTEM REQUIREMENTS
-------------------

Microsoft Windows 95 or Windows NT 4.0 with Microsoft Internet Explorer 4 (or higher), or
Microsoft Windows 98, Windows Me, Microsoft Windows 2000 Professional, 32-bit Microsoft Windows XP Home Edition or 32-bit Microsoft Windows XP Professional.
Multimedia PC with a 75Mhz Pentium or higher processor.
16 MB RAM for Windows 95/98,32 MB RAM for Windows NT/Me, 64 MB RAM for Windows 2000 Professional, and 64 MB RAM for Windows XP.
A full installation requires 100 MB of hard disk space.
Super VGA 640 x 480 display with at least 256 colors.
Microsoft Mouse or compatible pointing device.
Windows-compatible sound card and headphones or speakers required for Audio syllabus.


-----------------
INSTALLATION TIPS
-----------------

Microsoft(r) Windows XP Home Edition Step by Step Interactive assumes that you have some specific Windows options set on your computer. Check the following list to ensure that you have everything set up properly to run the Microsoft(r) Windows XP Home Edition Step by Step Interactive lessons:


For Windows 95, Windows 98 and Windows NT 4.0:

To hear audio, you must have the Windows Audio Compression Codecs installed.

>>>>To install the codecs:
1. Click the Start button on the Windows taskbar.
2. Point to Settings.
3. Click Control Panel.
4. Double-click the Add/Remove Programs icon.
5. Click the Windows Setup tab.
6. Click Multimedia in the Components list.
7. Click Details.
8. Select the Audio Compression check box.
9. Click OK.
10. Click OK, and follow the instructions.


For Windows 2000 or Windows Me:

To hear audio, you must have the Windows Audio Compression Codecs installed.  This is usually already available and running on your computer if you have a sound card and are running Windows 2000 or Windows Me.

>>>>To verify that the codecs is working properly:
1. Click the Start button.
2. Point to Settings.
3. Click Control Panel.
4. Double-click the Add/Remove Hardware icon.
5. Click Next in the Add/Remove Hardware Wizard.
6. Choose Add/Troubleshoot a device and click Next.
7. If Audio Codecs appears in the installed hardware list, click Next. The wizard will check the status and display if the Codecs is working properly.
8. Click Next to continue with the troubleshooting wizard.


Some lessons will only work if your computer is connected to a network of other computers. If you are in a business environment, see your system administrator to configure your network connection.

If you would like to print some of these files, you must be connected to a printer. You may notice improper page layout on some dot-matrix printers.

----------------------------------
THE SIMULATED TRAINING ENVIRONMENT
----------------------------------

As you use this Microsoft(r) Windows XP Home Edition Step by Step Interactive training title, you may notice some differences between the simulation environment and the actual Windows XP Home Edition product. These differences are due to the fact that this training title was finalized shortly before the final version of Windows XP Home Edition was available, and will not affect your ability to learn and master Windows XP Home Edition. 

---------------
TROUBLESHOOTING
---------------

For users of anti-virus software:
You may experience severe performance problems while running Microsoft Interactive Training products and some anti-virus software programs at the same time. If this occurs, we recommend not using Microsoft Interactive Training's Cache Manager feature while your anti-virus software is running.

If you are having display problems:
Some video cards are not compatible with Internet Explorer 4. If you experience display problems, check with your hardware manufacturer for an updated driver.

If you are having problems with the animations:
Some video cards are not compatible with DirectX, which is used to play animations in Microsoft (r) Windows XP Home Edition Step by Step Interactive. If you experience problems with playback, your video card may be incompatible with the latest version of DirectX. Check with your hardware manufacturer for an updated driver.

If you are having audio problems -1 :
If you are experiencing no audio or poor quality audio, you may need updated drivers. Check with your hardware manufacturer, or visit the Microsoft DirectX Web site at http://www.microsoft.com/directx/ for more information.

If you are having audio problems -2 :
If you are experiencing problems with audio stuttering when playing certain topics and you are using a Dell computer, please visit the Dell Technical Support site at http://support.dell.com/filelib/download/index.asp?fileid=1071&libid=3 and download the WS410 Audio Drivers (Crystal 4237b) Windows 95 v A00. (Note: The exact file name is DD28693.EXE.)

If you are aware of a computer which exhibits the scratchy/choppy audio playback problem but which does not use one of the sound cards listed above, please send e-mail in English only to MSPINPUT@MICROSOFT.COM. Please include the operating system you are using, the type of sound card that you have, and the exact symptoms of the problem.

If the training is installed on a NTFS disk drive, users other than those with Administrator or Power User privileges may not be able to access the training content.  In order to correct this, all users must be given read/write privileges to all the files in Database folder of the training title (usually found in C:\windows\help\sbsi\training). 

--------------------------
VISIT MICROSOFT ON THE WEB
--------------------------

http://www.microsoft.com - The Microsoft Corporation Home Page
http://mspress.microsoft.com/ - The Microsoft Press Home Page

Microsoft(r) Windows XP Home Edition Step by Step Interactive

The names of companies, products, people, characters, and/or data mentioned herein are fictitious and are in no way intended to represent any real individual, company, product, or event, unless otherwise noted.


---------------------------------------------------
(c)2001 Microsoft Corporation. All rights reserved.
---------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\sbsi\per\setup\readme.txt ===
--------------------------------------------------------------
Microsoft(r) Windows XP Home Edition Step by Step Interactive
--------------------------------------------------------------

(c)2001 Microsoft(r) Corporation. All rights reserved.

This document provides information about Microsoft(r) Windows XP Home Edition Step by Step Interactive as well as answers to questions that you might have.


------------------------
How to Use This Document
------------------------

To view the Readme file in Windows Notepad, maximize the Notepad window, and turn on the Word Wrap feature. To print the Readme file, open it in Notepad or another word-processing program, and click Print on the File menu.

--------
CONTENTS
--------

   1. PRODUCT DEFINITION
   2. SYSTEM REQUIREMENTS
   3. INSTALLATION TIPS
   4. THE SIMULATED TRAINING ENVIRONMENT
   5. TROUBLESHOOTING
   6. VISIT MICROSOFT ON THE WEB


------------------
PRODUCT DEFINITION
------------------

Microsoft (r) Windows XP Home Edition Step by Step Interactive is a multimedia, self-paced training product that uses a combination of simulations and informative topics to create an easy and flexible learning environment.

This interactive training is available in the following languages: Brazilian Portuguese, Dutch, English, French, German, Italian, Japanese, Korean, Simplified Chinese, Spanish, Swedish, and Traditional Chinese. 

For information on corporate licensing programs for Microsoft Interactive Training products, please contact your Microsoft Field Representative or Large Account Reseller.


-------------------
SYSTEM REQUIREMENTS
-------------------

Microsoft Windows 95 or Windows NT 4.0 with Microsoft Internet Explorer 4 (or higher), or
Microsoft Windows 98, Windows Me, Microsoft Windows 2000 Professional, 32-bit Microsoft Windows XP Home Edition or 32-bit Microsoft Windows XP Professional.
Multimedia PC with a 75Mhz Pentium or higher processor.
16 MB RAM for Windows 95/98,32 MB RAM for Windows NT/Me, 64 MB RAM for Windows 2000 Professional, and 64 MB RAM for Windows XP.
A full installation requires 100 MB of hard disk space.
Super VGA 640 x 480 display with at least 256 colors.
Microsoft Mouse or compatible pointing device.
Windows-compatible sound card and headphones or speakers required for Audio syllabus.


-----------------
INSTALLATION TIPS
-----------------

Microsoft(r) Windows XP Home Edition Step by Step Interactive assumes that you have some specific Windows options set on your computer. Check the following list to ensure that you have everything set up properly to run the Microsoft(r) Windows XP Home Edition Step by Step Interactive lessons:


For Windows 95, Windows 98 and Windows NT 4.0:

To hear audio, you must have the Windows Audio Compression Codecs installed.

>>>>To install the codecs:
1. Click the Start button on the Windows taskbar.
2. Point to Settings.
3. Click Control Panel.
4. Double-click the Add/Remove Programs icon.
5. Click the Windows Setup tab.
6. Click Multimedia in the Components list.
7. Click Details.
8. Select the Audio Compression check box.
9. Click OK.
10. Click OK, and follow the instructions.


For Windows 2000 or Windows Me:

To hear audio, you must have the Windows Audio Compression Codecs installed.  This is usually already available and running on your computer if you have a sound card and are running Windows 2000 or Windows Me.

>>>>To verify that the codecs is working properly:
1. Click the Start button.
2. Point to Settings.
3. Click Control Panel.
4. Double-click the Add/Remove Hardware icon.
5. Click Next in the Add/Remove Hardware Wizard.
6. Choose Add/Troubleshoot a device and click Next.
7. If Audio Codecs appears in the installed hardware list, click Next. The wizard will check the status and display if the Codecs is working properly.
8. Click Next to continue with the troubleshooting wizard.


Some lessons will only work if your computer is connected to a network of other computers. If you are in a business environment, see your system administrator to configure your network connection.

If you would like to print some of these files, you must be connected to a printer. You may notice improper page layout on some dot-matrix printers.

----------------------------------
THE SIMULATED TRAINING ENVIRONMENT
----------------------------------

As you use this Microsoft(r) Windows XP Home Edition Step by Step Interactive training title, you may notice some differences between the simulation environment and the actual Windows XP Home Edition product. These differences are due to the fact that this training title was finalized shortly before the final version of Windows XP Home Edition was available, and will not affect your ability to learn and master Windows XP Home Edition. 

---------------
TROUBLESHOOTING
---------------

For users of anti-virus software:
You may experience severe performance problems while running Microsoft Interactive Training products and some anti-virus software programs at the same time. If this occurs, we recommend not using Microsoft Interactive Training's Cache Manager feature while your anti-virus software is running.

If you are having display problems:
Some video cards are not compatible with Internet Explorer 4. If you experience display problems, check with your hardware manufacturer for an updated driver.

If you are having problems with the animations:
Some video cards are not compatible with DirectX, which is used to play animations in Microsoft (r) Windows XP Home Edition Step by Step Interactive. If you experience problems with playback, your video card may be incompatible with the latest version of DirectX. Check with your hardware manufacturer for an updated driver.

If you are having audio problems -1 :
If you are experiencing no audio or poor quality audio, you may need updated drivers. Check with your hardware manufacturer, or visit the Microsoft DirectX Web site at http://www.microsoft.com/directx/ for more information.

If you are having audio problems -2 :
If you are experiencing problems with audio stuttering when playing certain topics and you are using a Dell computer, please visit the Dell Technical Support site at http://support.dell.com/filelib/download/index.asp?fileid=1071&libid=3 and download the WS410 Audio Drivers (Crystal 4237b) Windows 95 v A00. (Note: The exact file name is DD28693.EXE.)

If you are aware of a computer which exhibits the scratchy/choppy audio playback problem but which does not use one of the sound cards listed above, please send e-mail in English only to MSPINPUT@MICROSOFT.COM. Please include the operating system you are using, the type of sound card that you have, and the exact symptoms of the problem.

If the training is installed on a NTFS disk drive, users other than those with Administrator or Power User privileges may not be able to access the training content.  In order to correct this, all users must be given read/write privileges to all the files in Database folder of the training title (usually found in C:\windows\help\sbsi\training). 

--------------------------
VISIT MICROSOFT ON THE WEB
--------------------------

http://www.microsoft.com - The Microsoft Corporation Home Page
http://mspress.microsoft.com/ - The Microsoft Press Home Page

Microsoft(r) Windows XP Home Edition Step by Step Interactive

The names of companies, products, people, characters, and/or data mentioned herein are fictitious and are in no way intended to represent any real individual, company, product, or event, unless otherwise noted.


---------------------------------------------------
(c)2001 Microsoft Corporation. All rights reserved.
---------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\sbsi\pro\setup\setup.ini ===
[Startup]
AppName=Microsoft Windows XP Pro Step by Step Interactive
FreeDiskSpace=560
EnableLangDlg=Y
CmdLine=/h/l
BaseName=WXPPRO
[ISUPDATE]
UpdateURL=
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\sbsi\pro\readme.txt ===
--------------------------------------------------------------
Microsoft(r) Windows XP Professional Step by Step Interactive
--------------------------------------------------------------

(c)2002 Microsoft (r) Corporation. All rights reserved.

This document provides information about Microsoft(r) Windows XP Professional Step by Step Interactive as well as answers to questions that you might have.


------------------------
How to Use This Document
------------------------

To view the Readme file in Windows Notepad, maximize the Notepad window, and turn on the Word Wrap feature. To print the Readme file, open it in Notepad or another word-processing program, and click Print on the File menu.

--------
CONTENTS
--------

   1. PRODUCT DEFINITION
   2. SYSTEM REQUIREMENTS
   3. INSTALLATION TIPS
   4. THE SIMULATED TRAINING ENVIRONMENT
   5. TROUBLESHOOTING
   6. TEXT BASED VERSION OF MICROSOFT INTERACTIVE TRAINING
   7. VISIT MICROSOFT ON THE WEB


------------------
PRODUCT DEFINITION
------------------

Microsoft (r) Windows XP Professional Step by Step Interactive is a multimedia, self-paced training product that uses a combination of simulations and informative topics to create an easy and flexible learning environment.

This interactive training is available in the following languages: English, French, German, Italian, Japanese, and Spanish. 

For information on corporate licensing programs for Microsoft Interactive Training products, please contact your Microsoft Field Representative or Large Account Reseller.


-------------------
SYSTEM REQUIREMENTS
-------------------

Microsoft Windows 95 or Windows NT 4.0 with Microsoft Internet Explorer 4 (or higher), or
Microsoft Windows 98, Windows Me, Microsoft Windows 2000 Professional, 32-bit Microsoft Windows XP Home Edition or 32-bit Microsoft Windows XP Professional.
Multimedia PC with a 75Mhz Pentium or higher processor.
16 MB RAM for Windows 95/98, 32 MB RAM for Windows NT/Me, 64 MB RAM for Windows 2000 Professional, and 64 MB RAM for Windows XP.
A full installation requires 102 MB of hard disk space.
Super VGA 640 x 480 display with at least 256 colors.
Microsoft Mouse or compatible pointing device.
Windows-compatible sound card and headphones or speakers required for Audio syllabus.


-----------------
INSTALLATION TIPS
-----------------

Microsoft(r) Windows XP Professional Step by Step Interactive assumes that you have some specific Windows options set on your computer. Check the following list to ensure that you have everything set up properly to run the Microsoft(r) Windows XP Professional Step by Step Interactive lessons:


For Windows 95, Windows 98 and Windows NT 4.0:

To hear audio, you must have the Windows Audio Compression Codecs installed.

>>>>To install the codecs:
1. Click the Start button on the Windows taskbar.
2. Point to Settings.
3. Click Control Panel.
4. Double-click the Add/Remove Programs icon.
5. Click the Windows Setup tab.
6. Click Multimedia in the Components list.
7. Click Details.
8. Select the Audio Compression check box.
9. Click OK.
10. Click OK, and follow the instructions.


For Windows 2000 or Windows Me:

To hear audio, you must have the Windows Audio Compression Codecs installed.  This is usually already available and running on your computer if you have a sound card and are running Windows 2000 or Windows Me.

>>>>To verify that the codecs is working properly:
1. Click the Start button.
2. Point to Settings.
3. Click Control Panel.
4. Double-click the Add/Remove Hardware icon.
5. Click Next in the Add/Remove Hardware Wizard.
6. Choose Add/Troubleshoot a device and click Next.
7. If Audio Codecs appears in the installed hardware list, click Next. The wizard will check the status and display if the Codecs is working properly.
8. Click Next to continue with the troubleshooting wizard.


Some lessons will only work if your computer is connected to a network of other computers. If you are in a business environment, see your system administrator to configure your network connection.

If you would like to print some of these files, you must be connected to a printer. You may notice improper page layout on some dot-matrix printers.

----------------------------------
THE SIMULATED TRAINING ENVIRONMENT
----------------------------------

As you use this Microsoft(r) Windows XP Professional Step by Step Interactive training title, you may notice some differences between the simulation environment and the actual Windows XP Professional product. These differences are due to the fact that this training title was finalized shortly before the final version of Windows XP Professional was available, and will not affect your ability to learn and master Windows XP Professional. 


---------------
TROUBLESHOOTING
---------------

For users of anti-virus software:
You may experience severe performance problems while running Microsoft Interactive Training products and some anti-virus software programs at the same time. If this occurs, we recommend not using Microsoft Interactive Training's Cache Manager feature while your anti-virus software is running.

If you are having display problems:
Some video cards are not compatible with Internet Explorer 4. If you experience display problems, check with your hardware manufacturer for an updated driver.

If you are having problems with the animations:
Some video cards are not compatible with DirectX, which is used to play animations in Microsoft (r) Office XP Professional Step by Step Interactive. If you experience problems with playback, your video card may be incompatible with the latest version of DirectX. Check with your hardware manufacturer for an updated driver.

If you are having audio problems -1 :
If you are experiencing no audio or poor quality audio, you may need updated drivers. Check with your hardware manufacturer, or visit the Microsoft DirectX Web site at http://www.microsoft.com/directx/ for more information.

If you are having audio problems -2 :
If you are experiencing problems with audio stuttering when playing certain topics and you are using a Dell computer, please visit the Dell Technical Support site at http://support.dell.com/filelib/download/index.asp?fileid=1071&libid=3 and download the WS410 Audio Drivers (Crystal 4237b) Windows 95 v A00. (Note: The exact file name is DD28693.EXE.)

If you are aware of a computer which exhibits the scratchy/choppy audio playback problem but which does not use one of the sound cards listed above, please send e-mail in English only to MSPINPUT@MICROSOFT.COM. Please include the operating system you are using, the type of sound card that you have, and the exact symptoms of the problem.


---------------------------------------------------
TEXT BASED VERSION OF MICROSOFT INTERACTIVE TRAINING
---------------------------------------------------

This PC ships with an audio-only version of Microsoft Interactive Training. A CD with both a text-only and an audio course is available at no charge (shipping charges may apply).  You will need to provide the representative with your PC serial number and manufacturer as proof of ownership.

To order your replacement CD, please find your country in the list provided and supply the information requested in the below form by phone, fax or post.  Please allow 2-4 weeks for your product to arrive.
Maximum 1 order per PC.

In the United States and Canada, please call 1-800-MSPRESS (677-7377), and choose option 2, replacement CDs.

In the United Kingdom, please call 0870 6010100 

In Australia, please call 13 20 58

In New Zealand, please call +64 9 357 5575

In India, please call +91 22 5188583/5960264

In Asia, please call 1833378 (Choose Language and then choose option 6 for media)


For details on ordering via mail or fax worldwide, please see http://mspress.microsoft.com/officexp/sbsi/coupon/


--------------------------
VISIT MICROSOFT ON THE WEB
--------------------------

http://www.microsoft.com - The Microsoft Corporation Home Page
http://mspress.microsoft.com/ - The Microsoft Press Home Page

Microsoft(r) Windows XP Professional Step by Step Interactive
The names of companies, products, people, characters, and/or data mentioned herein are fictitious and are in no way intended to represent any real individual, company, product, or event, unless otherwise noted.

---------------------------------------------------
(c)2002 Microsoft Corporation. All rights reserved.
---------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setup\howto.txt ===
How to add new files to be installed:
 Easy
 1. Add new files to file.idt table.

 Complicated
 1. Use orca and open opk.msx.
 2. Add a new component if necessary (Component table).
 3. Associate new component to feature (FeatureComponents table).
 4. Add new component directory to director.idt.
 5. Add new component files to file.idt.

How to remove files from being installed:
 Easy
 1. Remove them from file.idt.

How to update the file.idt with file sizes:
 1. Update the file.idt table with filesizes and versions msifiler.exe -d opk.msi -v

How to modify custom action UpgradeMessage:
 1. Modify upgrade.vbs.
 2. Import upgrade.vbs into Binary table Binary7 [Binary Data].

How to add custom actions:
 1. Create vbscript upgrade.vbs.
 2. Import vbscript into Binary table (Binary7).
 3. Add row CustomAction table CA2 type 6, Source Binary7, Target UpgradeMessage.
 4. Add row InstallUISequence table Action CA2.

How to block future downgrades:
 1. By updating the ProductCode to a new GUID.
 2. By updating the Version in Property table
 3. By keeping the Upgrade table to find UpgradeCode it will block downgrade retail installs.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\sbsi\pro\setup\readme.txt ===
--------------------------------------------------------------
Microsoft(r) Windows XP Professional Step by Step Interactive
--------------------------------------------------------------

(c)2002 Microsoft (r) Corporation. All rights reserved.

This document provides information about Microsoft(r) Windows XP Professional Step by Step Interactive as well as answers to questions that you might have.


------------------------
How to Use This Document
------------------------

To view the Readme file in Windows Notepad, maximize the Notepad window, and turn on the Word Wrap feature. To print the Readme file, open it in Notepad or another word-processing program, and click Print on the File menu.

--------
CONTENTS
--------

   1. PRODUCT DEFINITION
   2. SYSTEM REQUIREMENTS
   3. INSTALLATION TIPS
   4. THE SIMULATED TRAINING ENVIRONMENT
   5. TROUBLESHOOTING
   6. TEXT BASED VERSION OF MICROSOFT INTERACTIVE TRAINING
   7. VISIT MICROSOFT ON THE WEB


------------------
PRODUCT DEFINITION
------------------

Microsoft (r) Windows XP Professional Step by Step Interactive is a multimedia, self-paced training product that uses a combination of simulations and informative topics to create an easy and flexible learning environment.

This interactive training is available in the following languages: English, French, German, Italian, Japanese, and Spanish. 

For information on corporate licensing programs for Microsoft Interactive Training products, please contact your Microsoft Field Representative or Large Account Reseller.


-------------------
SYSTEM REQUIREMENTS
-------------------

Microsoft Windows 95 or Windows NT 4.0 with Microsoft Internet Explorer 4 (or higher), or
Microsoft Windows 98, Windows Me, Microsoft Windows 2000 Professional, 32-bit Microsoft Windows XP Home Edition or 32-bit Microsoft Windows XP Professional.
Multimedia PC with a 75Mhz Pentium or higher processor.
16 MB RAM for Windows 95/98, 32 MB RAM for Windows NT/Me, 64 MB RAM for Windows 2000 Professional, and 64 MB RAM for Windows XP.
A full installation requires 102 MB of hard disk space.
Super VGA 640 x 480 display with at least 256 colors.
Microsoft Mouse or compatible pointing device.
Windows-compatible sound card and headphones or speakers required for Audio syllabus.


-----------------
INSTALLATION TIPS
-----------------

Microsoft(r) Windows XP Professional Step by Step Interactive assumes that you have some specific Windows options set on your computer. Check the following list to ensure that you have everything set up properly to run the Microsoft(r) Windows XP Professional Step by Step Interactive lessons:


For Windows 95, Windows 98 and Windows NT 4.0:

To hear audio, you must have the Windows Audio Compression Codecs installed.

>>>>To install the codecs:
1. Click the Start button on the Windows taskbar.
2. Point to Settings.
3. Click Control Panel.
4. Double-click the Add/Remove Programs icon.
5. Click the Windows Setup tab.
6. Click Multimedia in the Components list.
7. Click Details.
8. Select the Audio Compression check box.
9. Click OK.
10. Click OK, and follow the instructions.


For Windows 2000 or Windows Me:

To hear audio, you must have the Windows Audio Compression Codecs installed.  This is usually already available and running on your computer if you have a sound card and are running Windows 2000 or Windows Me.

>>>>To verify that the codecs is working properly:
1. Click the Start button.
2. Point to Settings.
3. Click Control Panel.
4. Double-click the Add/Remove Hardware icon.
5. Click Next in the Add/Remove Hardware Wizard.
6. Choose Add/Troubleshoot a device and click Next.
7. If Audio Codecs appears in the installed hardware list, click Next. The wizard will check the status and display if the Codecs is working properly.
8. Click Next to continue with the troubleshooting wizard.


Some lessons will only work if your computer is connected to a network of other computers. If you are in a business environment, see your system administrator to configure your network connection.

If you would like to print some of these files, you must be connected to a printer. You may notice improper page layout on some dot-matrix printers.

----------------------------------
THE SIMULATED TRAINING ENVIRONMENT
----------------------------------

As you use this Microsoft(r) Windows XP Professional Step by Step Interactive training title, you may notice some differences between the simulation environment and the actual Windows XP Professional product. These differences are due to the fact that this training title was finalized shortly before the final version of Windows XP Professional was available, and will not affect your ability to learn and master Windows XP Professional. 


---------------
TROUBLESHOOTING
---------------

For users of anti-virus software:
You may experience severe performance problems while running Microsoft Interactive Training products and some anti-virus software programs at the same time. If this occurs, we recommend not using Microsoft Interactive Training's Cache Manager feature while your anti-virus software is running.

If you are having display problems:
Some video cards are not compatible with Internet Explorer 4. If you experience display problems, check with your hardware manufacturer for an updated driver.

If you are having problems with the animations:
Some video cards are not compatible with DirectX, which is used to play animations in Microsoft (r) Office XP Professional Step by Step Interactive. If you experience problems with playback, your video card may be incompatible with the latest version of DirectX. Check with your hardware manufacturer for an updated driver.

If you are having audio problems -1 :
If you are experiencing no audio or poor quality audio, you may need updated drivers. Check with your hardware manufacturer, or visit the Microsoft DirectX Web site at http://www.microsoft.com/directx/ for more information.

If you are having audio problems -2 :
If you are experiencing problems with audio stuttering when playing certain topics and you are using a Dell computer, please visit the Dell Technical Support site at http://support.dell.com/filelib/download/index.asp?fileid=1071&libid=3 and download the WS410 Audio Drivers (Crystal 4237b) Windows 95 v A00. (Note: The exact file name is DD28693.EXE.)

If you are aware of a computer which exhibits the scratchy/choppy audio playback problem but which does not use one of the sound cards listed above, please send e-mail in English only to MSPINPUT@MICROSOFT.COM. Please include the operating system you are using, the type of sound card that you have, and the exact symptoms of the problem.


---------------------------------------------------
TEXT BASED VERSION OF MICROSOFT INTERACTIVE TRAINING
---------------------------------------------------

This PC ships with an audio-only version of Microsoft Interactive Training. A CD with both a text-only and an audio course is available at no charge (shipping charges may apply).  You will need to provide the representative with your PC serial number and manufacturer as proof of ownership.

To order your replacement CD, please find your country in the list provided and supply the information requested in the below form by phone, fax or post.  Please allow 2-4 weeks for your product to arrive.
Maximum 1 order per PC.

In the United States and Canada, please call 1-800-MSPRESS (677-7377), and choose option 2, replacement CDs.

In the United Kingdom, please call 0870 6010100 

In Australia, please call 13 20 58

In New Zealand, please call +64 9 357 5575

In India, please call +91 22 5188583/5960264

In Asia, please call 1833378 (Choose Language and then choose option 6 for media)


For details on ordering via mail or fax worldwide, please see http://mspress.microsoft.com/officexp/sbsi/coupon/


--------------------------
VISIT MICROSOFT ON THE WEB
--------------------------

http://www.microsoft.com - The Microsoft Corporation Home Page
http://mspress.microsoft.com/ - The Microsoft Press Home Page

Microsoft(r) Windows XP Professional Step by Step Interactive
The names of companies, products, people, characters, and/or data mentioned herein are fictitious and are in no way intended to represent any real individual, company, product, or event, unless otherwise noted.

---------------------------------------------------
(c)2002 Microsoft Corporation. All rights reserved.
---------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\winpeoc\imgbld\winpe.ini ===
Input file for CreatePE.js --- Tue Jul 03 17:37:10 2001

[Architecture]
32

[OPK Location]
\\robsvbl1\latest\opk

[WinXP Location]
\\robsvbl1\latest\pro

[Image Destination]
HDD
c:\test_image\nice
bootable

[Startup]


[Winbom]
winbom.ini

[Optional Components]
BuildWSH.vbs
BuildHTA.vbs
BuildADO.vbs

[Wallpaper]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\winpeoc\imgbld\sample.ini ===
Input file for CreatePE.js --- Wed Jun 27 14:53:16 2001

[Architecture]
32

[OPK Location]
\\robsvbl1\latest\opk

[WinXP Location]
\\robsvbl1\latest\pro

[Image Destination]
HDD
c:\test_image\foo

[Startup]
c:\yah\t.cmd

[Winbom]
winbom.ini

[Wallpaper]

[Optional Components]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\winpeoc\imgbld\status.log ===
Tue Jul 03 17:37:11 2001	LOG FILE created!
Tue Jul 03 17:37:11 2001	Computer Name=RAJITSS_DEV,User Name=t-rajiss

Tue Jul 03 17:37:11 2001	(*) Arch Type = I386
Tue Jul 03 17:37:11 2001	(*) OPK Locatoin =  \\robsvbl1\latest\opk
Tue Jul 03 17:37:11 2001	(*) Windows XP Locatoin =  \\robsvbl1\latest\pro
Tue Jul 03 17:37:12 2001	(*) Mapping \\robsvbl1\latest\opk to Z:
Tue Jul 03 17:37:13 2001	(S) OPK CD is verified!
Tue Jul 03 17:37:13 2001	(*) Mapping \\robsvbl1\latest\pro to Y:
Tue Jul 03 17:37:13 2001	(S) WinXP verified!
Tue Jul 03 17:37:14 2001	(S) OPK files copied from\\robsvbl1\latest\opk to C:\WinPE.temp.build
Tue Jul 03 17:37:15 2001	(S) Fixed winpesys.inf to run t.cmd when WinPE starts up.
Tue Jul 03 17:37:15 2001	(S) Changed Wallpaper!
Tue Jul 03 17:37:15 2001	(*) Now running mkimg.cmd
Tue Jul 03 17:39:08 2001	(*) BuildWSH.vbs is installing component.
Tue Jul 03 17:39:09 2001	(S) BuildWSH.vbs component installed.
Tue Jul 03 17:39:09 2001	(*) BuildHTA.vbs is installing component.
Tue Jul 03 17:39:11 2001	(S) BuildHTA.vbs component installed.
Tue Jul 03 17:39:11 2001	(*) BuildADO.vbs is installing component.
Tue Jul 03 17:39:15 2001	(S) BuildADO.vbs component installed.
Tue Jul 03 17:39:15 2001	(*) making HDD version of WinPE bootable!
Tue Jul 03 17:39:51 2001	(S) HDD version of WinPE in now bootable!
Tue Jul 03 17:39:51 2001	(S) mkimg.cmd complete!

Tue Jul 03 17:39:51 2001	The new image of WinPE can be found at c:\test_image\nice
Tue Jul 03 17:39:51 2001	COMPLETE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\wpebins\software.log ===
[TEXT: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\wpebins\sam.log ===
[TEXT: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\wpebins\security.log ===
[TEXT: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\winpeoc\xwinpe\excised code.txt ===
'Private Sub FilenameList_LostFocus(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles FilenameList.LostFocus
    '    UpdateFilenames()
    'End Sub

    'Private Sub RefreshSelectedFilenameTree_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) handles Refr
    '    SelectedComponentTree.Nodes.Clear()
    '    XComponent2SelectedComponentNode.Clear()
    '    UpdateSelectedComponents()
    'End Sub

    '#If 0 Then
    '            If XComponent2SelectedComponentNode(Component) Is Nothing Then
    '                ComponentNode = SelectedComponentTree.Nodes.Add(Component.DisplayName)
    '                XComponent2SelectedComponentNode(Component) = ComponentNode
    '                XSelectedComponentNode2Component(ComponentNode) = Component
    '                If XComponent2FilenameList(Component) Is Nothing Then
    '                    FileNode = ComponentNode.Nodes.Add("(component not yet unkooked)")
    '                    Dim NodeFont As Font
    '                    NodeFont = FileNode.NodeFont
    '                    If NodeFont Is Nothing Then
    '                        NodeFont = SelectedComponentTree.Font
    '                    End If
    '                    FileNode.NodeFont = New Font(NodeFont, NodeFont.Style + FontStyle.Italic)
    '                Else
    '                    For Each Filename In XComponent2FilenameList(Component)
    '                        FileNode = ComponentNode.Nodes.Add(Filename)
    '                        If Filenames.ContainsKey(Filename) Then
    '                            Dim NodeFont As Font
    '                            NodeFont = FileNode.NodeFont
    '                            If NodeFont Is Nothing Then
    '                                NodeFont = SelectedComponentTree.Font
    '                            End If
    '                            FileNode.NodeFont = New Font(NodeFont, NodeFont.Style + FontStyle.Bold)
    '                        End If
    '                    Next
    '                End If
    '            End If
    '            If Not XObject2NodeList(Component) Is Nothing Then
    '                For Each ComponentNode In XObject2NodeList(Component)
    '                    ComponentNode.Checked = True
    '                Next
    '            End If
    '        Next

    '        ' remove nodes for components no longer selected
    '        Dim Marked As ArrayList : Marked = New ArrayList()
    '        For Each Component In XComponent2SelectedComponentNode.Keys
    '            If Not SelectedComponents.ContainsKey(Component) Then
    '                Marked.Add(Component)
    '                ComponentNode = XComponent2SelectedComponentNode(Component)
    '                SelectedComponentTree.Nodes.Remove(ComponentNode)
    '                XSelectedComponentNode2Component.Remove(ComponentNode)
    '            End If
    '        Next
    '        For Each Component In Marked
    '            XComponent2SelectedComponentNode.Remove(Component)
    '            If Not XObject2NodeList(Component) Is Nothing Then
    '                For Each ComponentNode In XObject2NodeList(Component)
    '                    ComponentNode.Checked = False
    '                Next
    '            End If
    '        Next
    '        If Marked.Count > 0 Then
    '            UpdateCheckedFiles()
    '        End If

    '#End If
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\readme\probrep.txt ===
Microsoft(R) Windows NT(TM) 4.0 Problem Report Template	        
(Please see instructions below to submit this report) 

Name                           : 
Company                        : 
Area Code & Phone              : 

Internet Address               :
Country (if outside the U.S.)  :
Language Version               :

***** PROBLEM INFORMATION ******

Product Release      :  
Type "winver" at the command line while Windows NT is running.

Product Type         : < >Workstation < >Server

Install Method       : < >CD-ROM  
		           < >WINNT.EXE  < >WINNT32.EXE 

Install Type         : < >Upgrade from: 
		           < >Clean Install


PROBLEM TITLE: 
[Please replace this line with a one-line summary of the issue]

PROBLEM DESCRIPTION: Please provide a complete description of 
the problem, circumstances, and any actions you may have taken.
----------------------------------------------------------------------




PROBLEM OCCURS: 
< >Always < >Sometimes < >Didn't happen again < >Didn't try it again

Did this problem exist in Version 3.51? < > YES  < > NO

STEP BY STEP INSTRUCTIONS we can follow to reproduce the problem here:
Please be explicit and complete, if we cannot reproduce the problem
here, the issue may not be resolved in the next release.
  1. 
  2. 
  3.
  4.



**** BASIC CONFIGURATION ****

Computer brand & model			    :
  Bus Architecture (check all that apply)			                           
  < >ISA < >EISA < >MCA < >VESA < >PCI 
  < >RISC < > PCMCIA (PC CARD) < >Other:

System BIOS (manufacturer & version/date)   : 
CPU(s) (type, speed and manufacturer)       : 
Memory (RAM)                                : 
Mouse model & type (PS-2/serial/bus) (COM/IRQ)  : 
Sound Card (model/address/IRQ)              : 
Communications Modem (model/address/IRQ)    : 
Other adapters (scanner/PC CARD)            : 


****** VIDEO CONFIGURATION ******
Video adapter                   : 
  < > ISA  < > EISA  < > PCI  < > VESA  < > MCA
Video memory
  < > 512Kb  < > 1Mb  < > 2Mb  < > 4Mb  < > 8Mb
Video driver                    :
Video resolution                : < >640x480    < >800x600 
				  < >1024x768   < >1280x1024
				  < > Other: 
Color depth                     : < >16 colors  < >256 colors 
				  < >64K        < >16.7 million
				  < >True color < >Other: 


****** HARD DISK CONFIGURATION ******
For each hard drive, list the following:

Drive:
   < >IDE  [Enter model name] 
     < > Master  < > Slave
     < > Primary IDE channel  < > Secondary
   < >SCSI [Enter model name & SCSI id #]
     Disk controller:
  Partitions:
    Letter:     File System: < > Fat < > NTFS  Size: 
    Letter:     File System: < > Fat < > NTFS  Size:
  
****** CD-ROM CONFIGURATION ******
CD-ROM drive brand & model   : 
Is this a CD changer? < >  # of discs:____

  < > SCSI  [ID#] < > OTHER 
      Terminated < > Yes  < > No

  < > IDE/ATAPI
     < > Master  < > Slave
     < > Primary IDE channel  < > Secondary

Controlling adapter (Address and IRQ): 


****** NETWORK CONFIGURATION ******
Network card type, IRQ & address: 
Network protocol(s)             : 

Network cabling                 : 
Novell Server version           :       number of users:

****** PRINTER CONFIGURATION ******
Printer brand & model           : 
Printer Port: < >LPT1 < >LPT2 < >COM1 < >COM2 < >File < >Network
Driver                          :
Memory                          :
Printer cartridges              : 


How To Submit This Report
=========================
Please e-mail this form to ntbug@microsoft.com Note: this is not a support mechanism, and you are not guaranteed a response.  If your problem is time-critical you should contact Microsoft as outlined in "Guide to Services and Support" in your documentation.  Please send mail to ntbug@microsoft.com if you require an ftp location, or have any other questions or comments regarding the problem report process.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\readme\setup.txt ===
CONTENTS
=========

This file contains important material pertaining to Windows NT version 4.0
Setup not available in the Microsoft Windows NT Start Here: Basics and
Installation or in Help, as well as information on changes that occurred
after publication. We recommend you read this document BEFORE installing
Windows NT.

Additional late-breaking information about Windows NT is available in
the following files:

   Readme.wri
   Network.wri
   Printer.wri

Network.wri contains information related to networks, including further
information about network adapter cards, network services and
interoperability. Readme.wri contains general information about Windows NT
version 4.0, including information on specific hardware and software
applications. Printer.wri contains information related to printing,
including information on specific printers.

For best printing results, open and print this using Notepad with a 12-pont
non-character-based font, such as Times New Roman.


- Before You Call for Support on a Setup Issue

- Creating Windows NT Setup Startup Disks

- El Torito (No Emulation) Bootable CD-ROM Format

- Setting Up Windows NT version 4.0 on Computers with 
  Multiple CD-ROM Drives Installed

- Microsoft Windows NT SCSI Driver Changes

- Network Adapter Drivers

- Duplexing with the Compaq FastWide SCSI 2 EISA Controller

- Winnt/Winnt32 Disk Space Errors

- HPFS File Systems

- Microsoft Windows Messaging

- Schedule+ version 1.0

- Disable FPNW/DSMN for Windows NT Server version 3.51 Before Upgrading

- Upgrading DNS Servers

- Upgrading WINS, DHCP and RPL Databases

- Removing Remotely Possible/32 Before Upgrading

- Detecting and Disabling the Floating-Point Division Error

- Digital Alpha Systems

- Micron Computers

- Displaying Setup on Laptop Computers

- Disconnecting UPS Devices

- Intergraph G91 Display Adapters

- SoundBlaster/SCSI Problems

- Devices That Must Be Manually Installed

- Using Multiple Windows NT Installations on a Single Computer

- Using NTHQ if Setup Fails


Before You Call for Support on a Setup Issue
=======================================================================

Before you call for support on a Setup issue, run the NHTQ tool using
Makedisk.bat from \Support\Hqtool on the Windows NT version 4.0 compact
disc. For more information on using this tool, see "Using NHTQ if Setup
Fails" later in this document.

At a minimum, we recommend you gather the following information: 

	Version of Windows NT 
	Upgrade or fresh install 
	Forms of setup attempted (Setup boot disk, winnt, winnt /b) 
	At exactly what point does setup fail? 
	What exact error message is given, if any 
	Has the system been scanned for a virus? 
	Computer make/model 
	Bus type (EISA/ISA/MCA/PCI) 
	Memory (RAM) 
	Disk controllers 
	Disk/type/size 
	CD-ROM 
	Tape drive 
	Network adapter 
	Serial ports 
	Other adapters 

The following additional information may also be of use in getting your 
problem solved:

For your computer - 

	BIOS version 
	Was Setup tried with Shadowing disabled? 
	Was Setup tried with External Cache disabled? 


For SCSI controllers -

	IRQ, DMA channel, I/O address 
	SCSI BIOS version 
	SCSI IDs of devices 
	Which devices have termination enabled? 
	Greater than 1 GB support enabled on adapter? 
	Max Sync Xfer Rate on adapter 
	Have hard drives been low level formatted on this adapter? 
	Using driver from distribution media or vendor supplied driver? 


For IDE controllers -

	IRQ, DMA channel, I/O address 
	Dual channel controller? 
	Translation used for drives having more than 1024 cylinders
         (LBA/Disk Manager) 


For disk drives -

	Partition information 
	Cylinder, heads, sectors per track 
	Is write cache enabled or disabled on hard disk drives? 


For tape drives -

	Firmware version 
	Placement in SCSI chain 


For network adapter -

	IRQ, RAM address, I/O address



Creating Windows NT Setup Startup Disks
=======================================================================

If your Windows NT Workstation or Windows NT Server Setup floppy disks 
become corrupted, or are misplaced, you can create a new set by using
Winnt.exe or Winnt32.exe from your Windows NT Workstation or Windows NT
Server compact disc. These disks can be used to start Windows NT Workstation
or Windows NT Server Setup, or can be used with your Emergency Repair Disk
(ERD).

Note
You can create these boot disks from a computer running MS-DOS, Windows
version 3.1, Windows for Workgroups, Windows 95, Windows NT Workstation, or
Windows NT Server.

To create Windows NT Workstation or Windows NT Server startup disks:

     1. Insert the Windows NT Workstation or Windows NT Server compact disc
        into a CD-ROM drive.
     2. From the MS-DOS command prompt, change to the CD-ROM drive and the
        correct platform folder (for example, \I386 for x86-based
        computers).
     3. If the computer you are using is running Windows NT, type:

        winnt32 /ox

        at the command prompt, press Enter, and follow the instructions.

If the computer you are using is running MS-DOS or Windows version 3.1,
Windows for Workgroups, or Windows 95, type winnt /ox at the command prompt,
press Enter, and follow the instructions.


El Torito (No Emulation) Bootable CD-ROM Format
=======================================================================

If your computer's BIOS does not support the El Torito (no emulation)
bootable CD-ROM format, you might get an error when you start your computer
with the Windows NT compact disc inserted in the CD-ROM drive. To work
around this problem, remove the compact disc from the CD-ROM drive and
restart your computer.


Setting Up Windows NT version 4.0 on Computers with
Multiple CD-ROM Drives Installed
=======================================================================

If you have multiple compact disc drives installed, place the Windows NT 
compact disc in the drive that has first priority on your computer.


Windows NT SCSI Driver Changes
=======================================================================

With the release of Windows NT version 4.0, drivers for certain SCSI
adapters have been moved from the base operating system to the Windows NT
Driver Library (\DRVLIB) included on the Windows NT version 4.0 compact
disc. Check the following list to determine if any of your adapters are
affected by this change. If your computer has an adapter that appears on
this list, you must create a driver disk before installing Windows NT
version 4.0. Use this disk to install the appropriate driver(s) during
Setup, or keep the disk handy and install the driver using the Control Panel
once Setup is complete.

The following drivers have been moved:

     always.sys
     dtc329x.sys
     t128.syst13b.sys
     tmv1.sys
     ultra124.sys
     wd33c93.sys

The following adapters are affected by this change:

SCSI ADAPTERS -

     Always IN-2000
     Data Technology Corp. 3290
     Maynard 16-bit SCSI Adapter
     MediaVision Pro Audio Spectrum-16
     Trantor T-128
     Trantor T-130B

DISK CONTROLLERS -

     UltraStor 124f EISA Disk Array Controller

Please see the Windows NT Hardware Compatibility List for additional
information on these storage adapters.

To create a driver disk for drivers that have been moved to the Driver
Library:

     1. Create a blank formatted 3.5-inch disk.
     2. Copy all files from the following directory to the blank disk:

        \drvlib\storage\retired\CPU_TYPE

        where CPU_TYPE is X86 if you are using a machine with an x86-based
        processor; MIPS if your computer uses a MIPS RISC processor; or
        ALPHA if your computer uses a Digital Alpha processor.
     3. Label this disk "Drivers Disk".

To install drivers from the drivers disk during Windows NT version 4.0
Setup:

     1. Start Windows NT Setup. 
        During the course of Setup, a message appears stating "Setup has
        recognized the following mass storage devices in your computer." 
     2. When prompted, press S to skip detection, then press S again to
        display a list of supported SCSI host adapters. 
     3. Select Other from the bottom of the list. 
     4. Insert the Drivers Disk when prompted to do so, and select your host
        adapter from this list.

Windows NT will now recognize any devices attached to this adapter. Repeat
this step for each host adapter not already recognized by Windows NT Setup.

To install drivers when Setup recognizes one of the supported SCSI host
adapters without making the devices attached to it available for use:

     1. Restart Windows NT Setup. 
     2. When Windows NT Setup displays the message "Setup is inspecting your
        computer's hardware configuration...," press F6. 
        This prevents Windows NT Setup from performing disk controller
        detection and allows you to install the driver from the Drivers Disk
        you created. Note that all SCSI adapters will have to be installed
        manually.
     3. When Windows NT Setup displays the message "Setup could not
        determine the type of one or more mass storage devices installed in
        your system, or you have chosen to manually specify an adapter,"
        press S to display a list of supported SCSI host adapters. 
     4. Select Other from the bottom of the list. 
     5. Insert the Drivers Disk you made when prompted to do so, and select
        your host adapter from this list. Note that in some cases, Windows
        NT Setup will repeatedly prompt you to swap disks.

Windows NT will now recognize any devices attached to this adapter. Repeat
this step for each host adapter not already recognized by Windows NT Setup.

To install drivers from your drivers disk after running Windows NT version
4.0 Setup:

     1. After installing the properly configured adapter in your machine,
        start Windows NT version 4.0 as normal.
     2. Click Start, point to Control Panel, then open the SCSI Adapters
        program.
     3. Select the Drivers tab, then click the Add button.
     4. Click the Have Disk button, insert your drivers disk into Drive A:,
        and then click OK.
     5. Highlight the desired driver from the list presented, and then click
        OK. Then, click Continue to load the driver.
     6. You need to restart your Windows NT version 4.0 system to activate
        the driver. Click the Restart Computer button to shutdown and
        restart.

Warning:

If you are upgrading from Windows NT version 3.51, you must know the names
of all SCSI adapters before running Setup. To view this list, open Windows
NT Setup (in the Main program group in Windows NT version 3.51) and click
Add/Remove SCSI Adapters on the Options menu. Record the names of all
adapters on this list and keep them handy for use during Windows NT version
4.0 Setup.


Network Adapter Drivers
=======================================================================

Microsoft provides network adapter drivers from third-party vendors on the 
Windows NT Workstation and Windows NT Server version 4.0 compact discs.
These drivers, which are located in the \DRVLIB folder have all met 
specific standards of installation and operation. 

Most PCI, EISA, and MCA adapters in the \DRVLIB can be detected and
successfully installed during Setup. Most ISA and PCMCIA adapters are not
detected but can be installed manually during Setup. 

For ISA adapters that can be detected, two identical adapters cannot be
detected during Setup.  The adapter with the lowest I\O address will be
detected, while the others will not. They can, however, be installed
manually added. For multiprocessor systems, two identical ISA adapters may
not be supported due to hardware limitations of the adapter.  The NE2000 is
an example of this limitation.

Most network adapters in the \DRVLIB do not support the unattended answer 
file (unattend.txt) for use in automated installations of Windows NT.  
Exceptions are the IBM Auto 16/4 Token Ring Adapter, IBM AutoStreamer 
Token Ring adapters, IBM Token Ring LanStreamer PCI adapter, 3Com 
Etherlink III PCI adapters, and the Intel EtherExpress PRO/100B adapter.

Some adapters may quit functioning if you upgrade from an earlier version to 
the Windows NT version 4.0.  This can be caused by changes in the registry,
such as adapter driver name changes, service dependency changes, or an
obsolete network adapter driver. Removing the old driver and installing it
again from the menu will correct the startup problem for adapters listed on
the Hardware Compatibility List (HCL).  Xircom IIPS and Eicon ISDN are
examples of adapters that must be reinstalled.

Some adapters generate errors during Setup because the configuration
settings cannot be verified.  This can be caused by conflicting settings for 
interrupt and I/O addresses.   The error can also be displayed if Setup
calls an executable helper which sets up the configuration.  If the adapter
driver starts and connects to the network, the error can be ignored.  If
not, the error is an indication there are resource conflicts which will have
to be fixed.  The Intel E100B and IBM Streamer adapters are examples of
drivers that use their own executable setup routines.

Microsoft does not recommend the use of 8-bit network adapters with 
Windows NT Workstation or Windows NT Server. Support for these adapters 
is included in some cases due to customer requirements, but older hardware 
represented by this technology does not provide good performance or 
reliability.

> Network PnP Mode

PnP mode is not supported. Network adapters that support PnP mode must be 
reconfigured with a software setup utility provided by the manufacturer. This 
includes system board mounted network adapters, 3Com EtherLink III B
models, and Standard Microsystems SMC8416 Ultra PnP adapters.

> Bus-Master Adapters

Bus-Master adapters are not supported on Motorola Power PC computers. 
These include the Proteon p1390, p1392, p1392plus, and IBM 4/16 Token 
Ring Adapter II. IBM Power PC systems are supported.

> PCMCIA Adapters

If your PCMCIA adapter does not start, or operates incorrectly, try using a 
different interrupt for the network adapter. Interrupts 2, 5, and 10 are
often reserved on portable computers. In these cases, Microsoft recommends 
changing the interrupt to 3, 11, or 15. If the settings are changed during 
installation, the adapter will not start until installation is completed and the
system is restarted. If you know the settings presented by Setup
will cause a conflict, you can change them, but the adapter will not start
until installation is completed and the computer is restarted.

> Eicon WAN or the USR WAN (non-ISDN) Adapters

During Setup, selecting any Eicon WAN or the USR WAN (non-ISDN) adapters
will result in a dialog box that cannot be exited. This will cause the
installation to fail because rebooting is necessary to recover. For these
adapters, complete the installation and add the adapter later.

> Xircom Corporate Series CreditCard Ethernet Adapter IIps

Xircom Corporate Series CreditCard Ethernet Adapter IIps adapters will stop 
working if you upgrade from Windows NT version 3.51. Because the driver 
name changed for this adapter, and because of the subsequent effect on the 
registry, the IIps adapter must be manually removed and reinstalled.

> Intel EtherExpress PRO/10P PCI LAN Adapter drivers

If you install Windows NT version 4.0 from a network drive and have both
an Intel EtherExpress PRO/10P PCI LAN Adapter driver and a PCI SCSI 
controller installed, Setup may indicate one or more files are corrupt when
it verifies the copy from the temporary directory to the 
%systemroot%\system32\drivers folder.

This problem occurs because the network adapter is not reset correctly when 
Setup warm starts the computer. You can avoid this problem by turning the 
computer off and then back on instead of allowing Setup to warm start the 
computer.

> Digiboard PCIMAC and PCIMAC/4 ISDN Adapters

Digiboard PCIMAC and PCIMAC/4 ISDN adapters do not always work correctly in
multibus PCI-based computers.

> NE2000 or Compatible Network Adapters

Installing or upgrading to Windows NT 4.0 with a NE2000 or compatible
network adapter set to an I/O address of 340 hex, may cause the system to
hang when booting into text-mode Setup. If this occurs, either remove the
NE2000 adapter or change its I/O address and restart Setup to continue the
installation. The NE2000 will operate normally at I/O address 340 hex after
Setup is complete.

> AMD PCnet Adapters on Intergraph TD Workstations

Detecting early versions of the AMD PCnet adapter can cause the system to 
hang.  If this occurs, restart Windows NT Setup by rebooting the computer,
select the AM1500T network adapter and set the configuration parameters
manually to match the jumpers.  Intergraph models TD-1, TD2 and TD-3 
are examples of computers with the early AMD adapter built onto the 
system board.


Duplexing with the Compaq FastWide SCSI 2 EISA Controller
=======================================================================

If you utilize the Compaq FastWide SCSI 2 EISA controller and require 
duplexing with mirrored partitions, both controllers must be set to use 
64 heads/32 sectors translation.  The EISA partition and the operating 
system partition must both be located in the first 1024 cylinders.  It is 
also recommended both drives posses the same SCSI ID number.  By 
default, this is 0.  Refer to the controller documentation or contact Compaq 
support for details on advanced configuration options.

If the primary drive fails, it will be neccessay to move the shadowed drive 
to the first controller in order to restart the computer.  An alternate solution
is to change the controller boot order.  Make the shadowed drive's controller 
the primary boot controller.  Refer to the controller documentation or contact 
Compaq support for details on advanced configuration options.


Winnt/Winnt32 Disk Space Errors
=======================================================================

Winnt.exe and Winnt32.exe will report an error if unable to find a drive
with enough diskspace available, or if the drive specified with the /t
switch has insufficient free disk space.  If such an error occurs, you must
free some disk space and then run Winnt or Winnt32 again.

In some cases, Winnt and Winnt32 will not report a disk space error, but at
some point during the file copy process, will report an error copying a
file due to lack of disk space. This occurs when the drive to which the
temporary directory, $win_nt$~ls, is being copied is formatted with a
cluster of size 32KB or greater and has only the minimum free disk space
allowed. If this error occurs, you must free additional disk space, and
re-run winnt/winnt32.

Running Windows NT Setup from MS-DOS 6.20 may cause invalid 
filename errors on files that start with an exclamation point.  The 
error message can be ignored and the files can be skipped.


HPFS File Systems
=======================================================================

Windows NT version 4.0 does not support the OS/2 File System (HPFS). You 
cannot access disks that are formatted with HPFS from Windows NT version
4.0. If you have a previous version of Windows NT installed on a disk
formatted with HPFS, Setup cannot upgrade it to Windows NT version 4.0.

You can use the Convert.exe program supplied with previous versions of 
Windows NT to convert disks formatted with HPFS to the Windows NT File 
System (NTFS). Windows NT version 4.0 Convert.exe does not provide this
capability. Do not convert any disks you need to access when using other
operating systems such as OS/2.

Note:
Convert.exe can convert only HPFS version 1.x drives smaller than 4
gigabytes (GB). It fails on HPFS 2.x drives (those HPFS drives larger than 4
GB).


Windows Messaging
=======================================================================

Note
The following information does not apply if you are running the Exchange
Client for Microsoft Exchange Server.

If you are a currently running Windows NT version 4.0 Beta 1 or Beta 2 and
are using the Exchange Client, use the following procedure to remove 
Microsoft Exchange before upgrading to Windows NT version 4.0.

To remove Microsoft Exchange and then install Windows NT version 4.0:

     1. Click Start, point to Settings, and then click Control Panel.
     2. Double-click Add/Remove Programs.
     3. On the Windows NT Setup tab, clear the Microsoft Exchange check
        box, and then click OK.
     4. After Microsoft Exchange has been removed, start Windows NT
        version 4.0 Setup.
     5. When prompted to select the type of installation, click Custom
        Setup.
     6. On the Select Components page, select Windows Messaging (new 
        name for Exchange in Windows NT version 4.0).

If you are a Windows NT 4.0 Beta Exchange Client user and you have already
installed Windows NT version 4.0 (final), you need to remove Exchange and
reinstall Windows Messaging to ensure proper operation of the Messaging
Client.

To remove Microsoft Exchange and install Windows Messaging after upgrading
from Windows NT version 4.0 Beta 1 or Beta 2 to  Windows NT version 4.0
(final):

     1. Right-click the Taskbar, click Properties.
     2. On the Start menu Programs tab, click Remove.
     3. Select Microsoft Exchange from the list, and then click Remove.
     4. Click Close, and then click OK.
     5. Click Start, point to Settings, and then click Control Panel.
     6. Double-click Add/Remove Programs.
     7. On the Windows NT Setup tab, clear the Windows Messaging check box,
        and then click OK.


Using Schedule+ 1.0 with Windows Messaging in NT 4.0
=======================================================================

Windows Messaging is designed to work with Microsoft Schedule+ version 7.0.
When Windows Messaging is installed, you can still use Schedule+ 1.0 in
standalone mode, but you will not be able to send or receive meeting requests.

You are eligible for a free upgrade to Schedule+ 7.0.  In the U.S.,
call 1-800-360-7561. In Canada call, 1-800-933-4750. Outside the U.S.
and Canada, contact your local dealer.


Disable FPNW/DSMN for Windows NT Server version 3.51 Before Upgrading
=======================================================================

If you are performing an upgrade from Windows NT Server 3.51 with FPNW or 
DSMN services installed on the computer, these services are not compatible 
with Windows NT Server 4.0.  Microsoft Services for NetWare will be released 
shortly for use with Windows NT Server 4.0.  Prior to upgrading to Windows NT 
Server 4.0, disable these services by selecting Control Panel, Services.  Select 
"File and Print Services for NetWare" or "Directory Service Manager for NetWare" 
from the list, click Startup then click Disabled.  You should not attempt to reinstall 
FPNW or DSMN for Windows NT Server 3.51 on Windows NT Server 4.0. 


Upgrading DNS Servers
=======================================================================

Before upgrading a Windows NT version 3.51 Resource Kit DNS Server to
Windows NT version 4.0, you need to delete some registry entries. For more
information, see "To Upgrade a Windows NT 3.51 Resource Kit DNS Server" and
"To Install a DNS Server" in TCP/IP Help.


Upgrading WINS, DHCP, and RPL Databases
=======================================================================
	 
The information in this section pertains only to Windows NT Server. When
upgrading a Windows NT Server version 3.51 (or earlier) release to Windows
NT version 4.0, the databases for WINS, DHCP, and RPL must be converted to
the new database format. This is required because the services now use an
improved database engine that is faster and that compacts automatically to
prevent fragmentation and consequential growth of the database. The database
conversion procedure occurs automatically as part of an upgrade
installation.


Removing Remotely Possible/32 Before Upgrading
=======================================================================

If you have Remotely Possible/32 version 2.0 or 2.1 installed on a computer
running Windows NT version 3.51, you must uninstall Remotely Possible before 
installing Windows NT version 4.0. If you do not, Windows NT might not
install correctly. You can uninstall Remotely Possible by running the
Remove.bat file located on the Remotely Possible distribution disk. After
you have upgraded to Windows NT version 4.0, you can reinstall Remotely
Possible.

For more information about running Remotely Possible/32 versions 2.0 and 2.1
under Windows NT Workstation or Windows NT Server version 4.0, see the
Remotely Possible/32 section in "Application Notes" in Readme.wri.


Detecting and Disabling the Floating-Point Division Error
=======================================================================

Setup automatically detects the Intel Pentium floating-point division error.
If the error is detected on your system, Setup prompts you to disable the
floating-point hardware on the chip. If you choose not to have the
floating-point hardware disabled during Setup, you can disable the hardware
later with a command line utility called Pentnt.exe.


Digital Alpha Systems
=======================================================================

If you are installing this release on a Digital Alpha system, please consult
the Release Notes available from:
	http://www.windowsnt.digital.com/support/sysoft.htm


Micron Computers
=======================================================================

If you encounter problems during Windows NT version 4.0 Setup on your Micron
computer, upgrade your system BIOS to the latest BIOS version available from
Micron.


Displaying Setup on Laptop Computers
=======================================================================

During text mode setup, some laptops with the WDC 90C24 chipset may show
some screen text distortion.

Laptops support a mode that adds additional scan lines between rows of
characters. This allows the entire LCD to be used when in 80x25 line text
modes. However, when in 43 line text mode (the mode in which Windows NT
Setup runs), the additional scan lines are forced off the bottom of the 
display. Certain laptop machines that start in this mode exhibit this 
behavior. Users encountering this problem will not be able to see the white 
instruction line on the bottom of the setup screen. This line indicates what 
keystrokes are used to exit and continue Setup. Continue with Setup and the
video drivers will be reset upon entering the graphical (GUI) portion of
Windows NT Setup.


Disconnecting UPS Devices
=======================================================================

Disconnect the serial cable connecting an uninterruptible power supply (UPS) 
device before running Setup. Windows NT attempts to automatically detect 
devices connected to serial ports, which can cause problems with UPS equipment.


Intergraph G91 Display Adapters
=======================================================================

The Weitek-compatible display driver included with Windows NT version 4.0
does not work with the Intergraph G91 display adapters. Contact Intergraph
for an updated driver.

To use Intergraph G91 display adapters with Windows NT version 4.0, run the
G91 display driver provided with the Intergraph computer.

To use Intergraph G91 display adapters with Windows NT version 4.0:

     1. During the Windows NT version 4.0 Setup process, click Cancel when
        the Display Settings dialog box is displayed.
     2. Once installation has been completed, load the drivers supplied with
        the Intergraph computer.


Sound Blaster/SCSI Problems
=======================================================================

Sound Blaster/SCSI cards and PCI SCSI cards may display a blue screen
reading INACCESSIBLE_BOOT_DEVICE when performing a new installation or an
upgrade. This occurs because the BIOS assigns the PCI SCSI card an interrupt
that is already in use.  If this occurs, physically remove the sound card
before reinstalling, or remove the driver during text mode portion of Setup
and then reinstall after the installation/upgrade is complete.


Devices That Must be Manually Installed
=======================================================================

The following devices must be manually installed. Do not choose to have
Windows NT version 4.0 Setup automatically detect them.

 E-Tech Pocket Fax/Modem
 Multi-tech Multimodem (various models)
 Penril modems (various models)

The Modems option in Control Panel will close when you attempt to
query these devices.


Using Multiple Windows NT Installations on a Single Computer
=======================================================================

If you are installing Windows NT Workstation or Server version 4.0 on a
computer already loaded with at least one other Windows NT installation,
and if the computer participates on a Windows NT domain, you must use a
different computer name and machine account for each Windows NT
installation. This is because a unique security identifier (SID) is used for 
each installation of Windows NT on a domain.


Using NTHQ If Setup Fails
=======================================================================

NTHQ detects the installed hardware components on x86-based computers. It 
was designed to assist Microsoft Product Support engineers when a computer
does not boot or becomes unstable. 

To use NTHQ, run Makedisk.bat from the \support\hqtool directory on the 
Windows NT Workstation or Windows NT Server compact disc. Makedisk.bat
creates a bootable floppy disk that you can use to start your computer and
automatically run the diagnostic tool.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setupapi\readme.txt ===
SetupAPI has been moved to BASE\pnp\setupapi
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setupmsi\buildno.txt ===
[TEXT: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setupmsi\dtcinfo.txt ===
ProductName       =    Microsoft Windows Server 2003 Datacenter Edition
DialogCaption     =    Microsoft Windows Server 2003 Setup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setupmsi\entinfo.txt ===
ProductName       =    Microsoft Windows Server 2003 Enterprise Edition
DialogCaption     =    Microsoft Windows Server 2003 Setup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setupmsi\blainfo.txt ===
ProductName       =    Microsoft Windows Server 2003 Web Edition
DialogCaption     =    Microsoft Windows Server 2003 Setup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setupmsi\placefil.txt ===
; This file is used to specify where every file built by the NT build lab is
; binplaced relative to the root of the distribution point.  If a file is not
; listed, it will end up in the dump directory.
;
; The format is like this:
;
; <imagename>    <class name>
;
; where <imagename> is the filename.ext and <class name> is the directory off
; the root of the distribution point (retail is a placeholder for the root).
; If there are multiple class names for a single image, use a colon to separate
; each.
;


winnt32.msi     congeal_scripts\setupmsi
blainfo.txt     congeal_scripts\setupmsi
dtcinfo.txt     congeal_scripts\setupmsi
entinfo.txt     congeal_scripts\setupmsi
perinfo.txt     congeal_scripts\setupmsi
proinfo.txt     congeal_scripts\setupmsi
sbsinfo.txt     congeal_scripts\setupmsi
srvinfo.txt     congeal_scripts\setupmsi
buildno.txt     congeal_scripts\setupmsi
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setupmsi\sbsinfo.txt ===
ProductName       =    Microsoft Windows Server 2003 Small Business Server
DialogCaption     =    Microsoft Windows Server 2003 Setup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setupmsi\proinfo.txt ===
ProductName       =    Windows XP Professional
DialogCaption     =    Windows XP Setup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setupmsi\srvinfo.txt ===
ProductName       =    Microsoft Windows Server 2003
DialogCaption     =    Microsoft Windows Server 2003 Setup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setupmsi\perinfo.txt ===
ProductName       =    Windows XP Home Edition
DialogCaption     =    Windows XP Setup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\placefil.txt ===
; This file is used to specify where every file built by the NT build lab is
; binplaced relative to the root of the distribution point.  If a file is not
; listed, it will end up in the dump directory.
;
; The format is like this:
;
; <imagename>    <class name>
;
; where <imagename> is the filename.ext and <class name> is the directory off
; the root of the distribution point (retail is a placeholder for the root).
; If there are multiple class names for a single image, use a colon to separate
; each.
;
; All bits that ship in the NT base product and are installed with winnt32,
; must have a class name of retail.
;

;
; migration dll.
;
regdiff.dll     retail
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\spsetup\placefil.txt ===
; This file is used to specify where every file built by the NT build lab is
; binplaced relative to the root of the distribution point.  If a file is not
; listed, it will end up in the dump directory.
;
; The format is like this:
;
; <imagename>    <class name>
;
; where <imagename> is the filename.ext and <class name> is the directory off
; the root of the distribution point (retail is a placeholder for the root).
; If there are multiple class names for a single image, use a colon to separate
; each.
;
; All bits that ship in the NT base product and are installed with winnt32,
; must have a class name of retail.
;

;
; migration dll.
;
spsetup.dll     retail
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\spsrestr\placefil.txt ===
; This file is used to specify where every file built by the NT build lab is
; binplaced relative to the root of the distribution point.  If a file is not
; listed, it will end up in the dump directory.
;
; The format is like this:
;
; <imagename>    <class name>
;
; where <imagename> is the filename.ext and <class name> is the directory off
; the root of the distribution point (retail is a placeholder for the root).
; If there are multiple class names for a single image, use a colon to separate
; each.
;
; All bits that ship in the NT base product and are installed with winnt32,
; must have a class name of retail.
;

;
; migration dll.
;
spsrestr.exe     retail
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\update2\placefil.txt ===
; This file is used to specify where every file built by the NT build lab is
; binplaced relative to the root of the distribution point.  If a file is not
; listed, it will end up in the dump directory.
;
; The format is like this:
;
; <imagename>    <class name>
;
; where <imagename> is the filename.ext and <class name> is the directory off
; the root of the distribution point (retail is a placeholder for the root).
; If there are multiple class names for a single image, use a colon to separate
; each.
;
; All bits that ship in the NT base product and are installed with winnt32,
; must have a class name of retail.
;

;
; migration dll.
;
update2.exe     retail
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\srvpack_binary_release\langcode.txt ===
;
;SP    Pkg    Target
;drop
;
 ar    ara    ara
 br    ptb    br
 cn    chs    chs
 cs    csy    cs
 da    dan    da
 de    ger    ger
 el    ell    el
 en    enu    usa
 es    esn    es
 fi    fin    fi
 fr    fra    fr
 gb    ptg    gb
 he    heb    heb
 hu    hun    hu
 it    ita    it
 ja    jpn    jpn
 ko    kor    kor
 nl    nld    nl
 no    nor    no
 pl    plk    pl
;pt    ptb    pt
 ru    rus    ru
 sv    sve    sv
 tr    trk    tr
 tw    cht    cht
;tw           chh
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\srvpack_binary_release\placefil.txt ===
;
;  Copyright (c) 2002  Microsoft Corporation
;
;  Module Name:
;
;      placefil.txt
;
;  Abstract:
;
;      This file is used to specify where every file built in this directory is
;      binplaced relative to the root of the distribution point.  If a file is not
;      listed, it will end up in the dump directory.
;
;  The format is like this:
;
;      <imagename>    <class name>
;
;      where <imagename> is the filename.ext and <class name> is the directory off
;      the root of the distribution point (retail is a placeholder for the root).
;      If there are multiple class names for a single image, use a colon to separate
;      each.
;
;  Author:
;
;      Rick Goodwill (richg)  2/14/2002
;
;  ------------------------------------------------------------------------------
;
;
spcustom.dll   idw\srvpack
spuninst.exe   idw\srvpack
update.exe     idw\srvpack
spmsg.dll      idw\srvpack
spcustom.pdb   symbols
spuninst.pdb   symbols
update.pdb     symbols
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\kernel\upgrade.doc ===
- 1@	   -             7  D                  (6  $                                @  `  @  ` y@  
 @   @    @    @   @  J 1A  ^ A    A    A    A  
 A   A    A  ( A    A    A   A    A    A    A    A    A   A    A    A  0 B   B    B   C  4 C  % B   @  J       B    B                                                                    WINDOWS NT 1.0 to 1.0a UPGRADE: DESIGN

AUTHOR:  	SUNIL PAI
DATE:		Sept. 28, 1993.   Version 1.0.
REVISED: 	Dec. 8, 1993.  Version 1.1 (Rearranged to separate functionality which is not being implemented).

REQUIREMENTS

1. Upgrade 1.0 to 1.0a.
2. Upgrade 1.0AS to 1.0aAS.
3. Upgrade 1.0 to 1.0a AS.  [WON'T BE IMPLEMENTED FOR 1.0a]
4. Implement safety features in upgrade, making sure that we don't end up with an unbootable system either because of some error during setup or due to external factors like power failure or user induced failure.


WORK INVOLVED IN UPGRADING

1. Copy over new versions of the files and new files that need to be always copied.
2. Make registry changes (1.0 -> 1.0a)
3. Make program group changes and the registry.  (1.0 -> 1.0a)
4. Do the Winnt-> AS changes if it is such an upgrade. [NOT IMPLEMENTED FOR 1.0a]
5. Generate a repair diskette for the new system.
6. Set up the new system for secure operation.
7. Do all the above in a safe manner.

ALTERNATIVES CONSIDERED

1. Upgrade in place.  That is upgrade our running tree to a 1.0a system.  The main problem with this is that we need to be careful we don't end up with an unbootable system.

2. Install a new version and upgrade information from the current tree.  The problems with this are that it is hard to clone a tree from the current tree and be sure we have everything we need.  Third party software is a big issue.  It is difficult to transfer configuration information from one tree to another.  Also one can never no where there are hard coded paths to stuff.   Also the disk space requirement prevents most people from using this approach.  The advantage in this is that it is safe.  If the new tree doesn't work, the old tree is still around.

We are choosing to upgrade in place.

ALGORITHM TO UPGRADE IN PLACE

Upgrade is done basically by text setup.  It is possible to run a utility to gather information from a running system and apply it as an answer to the questions asked by text setup, however this is not implemented for this release.   The following is the sequence of events in an upgrade.

- Text setup boots and asks for hardware information.  May ask for third party driver information.  This is solely for use during Setup and is not applied to the tree to be upgraded.
- Finds out all NT installations which can be upgraded by looking at the boot.ini/NVRAM variables.  It applies the following criteria to check if a system can be upgraded.
	- An NT tree actually exists as described by the boot.ini/NVRAM boot set.
	- Version as found from the registry on the tree is less than or equal to the current version.  
	- The type of NT ( WINNT/AS) is the same as our current product.
- The valid installations are presented to the user. The user can choose to upgrade an installation or choose a new tree for installation.  
	- If the user had attempted to upgrade the tree before, the user is warned about this and can choose to either reattempt the upgrade or install fresh into the same tree, backing up the hives.  
	- If the tree chosen for upgrade doesn't have enough space or its corresponding system partition doesn't have enough space, the user is warned about this.  The user can either exit setup and create enough space or choose another tree for upgrade or specify another tree to install.
Note that if there is a single tree for upgrade, all the analysis above is done without user input and then the user is presented with the appropriate dialog for input.
- If the user selects to cancel upgrade, he is given the choice of selecting a new partition / directory.  If the partition / directory he selects is the same one as the one offered to him before ( from the osloader or from the NT installations) the user is again offered the choice of upgrade / fresh install.  If he indicates he wants to install fresh we will clean out the NT tree except for the known hives which are renamed.
- If the user accepts upgrade, text setup marks the registry on the system with the upgradeinprogress value.  It then adds the system ( minus new network stuff  and hives and minus other files if a win31 system also present in same place) to the copy list and copies it.  The files are only copied if present on the target unless marked mandatory.  It also deletes files which have been removed from the product since 1.0.
- Does whatever registry modification is needed in the system hive:
	- Deletes keys that have disappeared since 1.0.
	- Add keys that have been added since 1.0 and the values within.
	- Disables the network services from starting, storing the old start values.  Other services may also be disabled if they cause service controller popups.
- Sets up for winlogon to execute setup in upgrade mode (tell setup - it is an upgrade, - win31 also present in directory, - where source is.).
- Continue the boot.
- When winlogon executes setup in upgrade mode it does not block SAM initialization.  Just runs gui setup before running winlogon.
- Gui setup comes up, realizes it is an upgrade in initial.inf.  It does the following:
	- [Do any registry modifications that can be deferred from the text setup stage to the gui stage].
                - Make the product version and source entries.
- Calls network setup to upgrade the network.
	- Sets up for setacl conversion.
	- Prepares emergency repair diskette. (is it possible to hold hives as they may be big?)
	- If  process succeeded delete local source if present and clear the UpgradeInProgress and SetupInProgress values.
	- Invokes perfmon provided code to convert the old perfmon data into the new format.
	- Reboots.
- If the above process fails then user can always install a fresh 1.0a system into the NT tree.

NETWORK UPGRADE (PROVIDED BY TERRYK)

1.	In text mode setup, the upgrade.inf file will copy all the network related inf files (oem*.inf) to the system with all the other setup files.
2.	During second boot (GUI) setup, it will do the following:
2.1.	Search under "Registry\Machine\Software\Microsoft\XXX\CurrentVersion\NetRules" (where XXX is the network components) and get a list of update inf file names and inf options. We will skip all the file name which ends with a number (i.e., oemnsv04.inf) because they may not belonged to Microsoft.
2.2.	Call each inf file with [Upgrade] option with the src path points to the CD or floppy disk. The new inf file will put the upgrade file list into the setup copy list. Meanwhile, the inf file will also upgrade the registry for the upgrade component (if necessary).
2.3.	If the update option list contains special component (i.e., TCP/IP, NetBT , streams,...), we will call the new inf file with [Install] option to install the new component. The new inf file should take care of the old components by either disable the components or remove the components from the registry directly.
2.4.	Call setup's [copyfilelist] to copy the upgrade files before we start the network control panel.
2.5.	Enable all the network services by changing the StartType value to the original one (which we saved during text mode setup).
2.6.	Start Network Control Panel Applet.
2.7.	Recompute binding
2.8.	Restart network
2.9.	Query domain name in Winnt->AS case and do necessary.[NOT IMPLEMENTED FOR 1.0A]

SAFETY DURING UPGRADE

Since we are upgrading in place, there are chances that midway through the upgrade we may fail and the user ends up with an unbootable system.  To guard against this we need to implement safety measures.  We are not implementing measures to let the user go back to the old system.  The user is only guaranteed to end up with a new system which boots.

Journalling was considered as a measure to implement safety, however it is too difficult to implement in the given timeframe.

What is implemented is the following:

- On failure the user can always reattempt upgrade.  Upgrade is designed in such a way that it can be reapplied any number of times without any restrictions.  If you fail during the upgrade process you can boot text setup again and reapply upgrade.

- In the remote possibility that upgrade just doesn't end up yielding a good system, the user can always install fresh into the same tree and Setup will back up the hives for the user.  Tools can be provided with the resource kit to extract information from the backed up hives and reapply them to the new hives.  The difficult part here may be the account information.

WINNT->AS UPGRADE  [NOT IMPLEMENTED FOR 1.0A]

On AS systems we need to provide for a WINNT->AS upgrade.   This can be a WINNT -> Primary Domain controller or a WINNT -> Backup Domain controller.  We are not considering WINNT->Backup Domain controller because of the following reasons:

- Most cases of an AS upgrade are going to be in environments where a person will upgrade his WINNT machine which has lots of accounts to a Primary Domain controller.
- Changing the WINNT to a backup domain controller involves changing the sid of the account domain to the sid of the Primary Domain controller and fixing any place where this sid appears.  This is definitely not trivial, if not impossible.
- The work involved will take us more than the 1.0a timeframe.

The work involved in converting a WINNT -> Primary Domain controller is:

- Text setup to set the registry to block SAM initilization on GUI Setup boot.  Also pass an input parameter to GUI Setup indicating that we have a WINNT-AS upgrade.	
- During GUI Setup network setup queries domain name in Winnt->AS case and applies it to the registry.
-GUI Setup creates event "\NT_CONVERT_TO_AS" to inform Sam that the database needs to be converted and sets event "\INSTALLATION_SECURITY_HOLD" to ask SAM to start the process.
- SAM starts the conversion process and does the following:
	- Create additional GlobalGroups:
		- Domain Admins
		- Domain Users
		- Domain Replicator
	- Change "None" GlobalGroup to "Users" GlobalGroup
	- Create additional LocalGroups:
		- System Operators
		- Account Operators
		- Print Operators
	- Change ACLs in SAM
		- Account Operators now used
	- Delete PowerUsers LocalGroup [TBD: CAN THIS BE LEFT AROUND, THIS CAN SIMPLIFY THE UPGRADE]
	- Signals event "\SAM_SERVICE_STARTED" once it is done.
- Setup waits on event "\SAM_SERVICE_STARTED"  which is signalled when initialization is done.
- Change the product type in the registry to AS.
- Does the stuff needed by LSA:
 	- Add a privilege to the administrators account.
- If Winnt -> AS creates the extra common program group to hold AS items.

IMPLEMENTATION

MAKING UPGRADE REGISTRY ENTRIES IN THE SIF FILE

Brief Description of Registry Changes During Upgrade

- Copy over the new hives as systnew, softnew, deftnew.  These are available as templates for our use.
- Save the perflib data & disable the network components in the destination  hive.
- Recurse down the controlset001 in systnew and copy any keys/values NOT PRESENT in the destination. Do the same with the softnew hive.
- Delete all keys listed in the sif file.
- Add all keys / values listed in the sif file.

Sections:

1. The following section allows us to specify services to disable which may
cause popups when net services are disabled:

[NetServicesToDisable]
ServiceName1
...

2. The following section allows us to remove keys which have been removed
since the Windows NT 3.1 release.  The key is deleted recursively, all
subkeys are deleted too.

[KeysToDelete]
<RootName>, <RootRelativePath>
...

where <RootName> ::=  System | Software | Default | ControlSet

An example of this is:

ControlSet, Services\hpfs_rec.


3. The following sections allow us to add/change keys / values under keys which have changed since the Windows NT 3.1 release.  Most changes are picked up the recursive comparison of the hives that is executed first. New keys and values need not be listed in this section.  This section is to catch the following cases:

   - When the hive has been changed since 511 and somebody changes the
     same value again.
   - When some value which already exists in the hive is changed.

[KeysToAdd]
<RootName>, <RootRelativePath> [, <ValueSection>]
...

If the <ValueSection> is not specified, the template hive is used to find out all subkeys/values to create under the root name.  If the <ValueSection> is specified it is of the following format:

[<ValueSection>]
<ValueName> [, <ValueType>, <ValueData>]
...

<ValueType> and <ValueData> are optional and when these are not specified the template hive is used to find out what these should be.  More often we do not need to use the <ValueType> and <ValueData>.  The only time we need to use these is when the data in the template hives is not what we want in the final registry.

Format of the value is the following:

a. Type REG_SZ:          name , REG_SZ,           "value string"
b. Type REG_EXPAND_SZ    name , REG_EXPAND_SZ,    "value string"
c. Type REG_MULTI_SZ     name , REG_MULTI_SZ,     "value string1", "value string2", ...
d. Type REG_BINARY       name , REG_BINARY,       byte1, byte2, ...
e. Type REG_BINARY_DWORD name , REG_BINARY_DWORD, dword1, dword2, ...
f. Type REG_DWORD        name , REG_DWORD,        dword

examples:

System, REG_SZ, lsass.exe
MyValue
Hello1, REG_EXPAND_SZ, "%SystemRoot%\nt\system32"
DeleteList, REG_MULTI_SZ, "file1" "file2" "file3"
Data, REG_BINARY, 00, 01, 02, 0a, 1f
VideoGroupOrder, REG_BINARY_DWORD, 00000001, 0000000a, 0000000f
Start, REG_DWORD, 00000003


REG_BINARY_DWORD is actually REG_BINARY however it lets us specify the binary data using dwords. All data in the value data is in hex, however don't prefix the data with 0x.  This is assumed.

 See NETWORK UPGRADE section.




	Jan 6, 1994. Version 1.2 (Added IMPLEMENTATION section to describe the sif entries to modify the registry)Sif                   U  c      m              8  9    1    .  "  "  *  +  +  9+  ;+  q+  -  !-  [7  \7  a7  p7  7  7  7  7  `@  u@  w@  y@                                                                                                                                                                                                                                                                                  
                 
         
       `(          S  U  c  e  ~                &  N        D  k  m      7  9  n  p          	  	  
  B      4        L          ]        %  ~    #  S  v    F                 !    !     !     ! 0    ! 0    ! 0    !     !     !     !     !     ! `    !  ?      3  5      2  ?      i            0  2            <   >   8!  :!  "  "  "  "  #  #  z$  k%  %  %  %  %  &  	'  '  '  (  /(  A(  X(  (  (  (  (  (  	)  ))  )  )  "*  T*  u*  *  *  *  +  +  9+  ;+       ! 0    ! 0    !     !     !    !    !    !    !    ! h   ! h    !  A;+  q+  s+  +  /,  ,  ,  -  -  !-  #-  p-  -  -  -  -  -  -  .  `.  z.  |.  .  .  .  .  .  .  /  /  //  1/  3/  t0  v0  0  0  1  1  (1  [1  `1  b1  &2  (2  :2  d2  i2  k2  3  3  3  3  4  Z4  4  4  ?5  x5  z5  5  5  5  5  5  6  76  x6  6  6  6  Y7  [7  {7  }7  7  7  7  w@  y@                           ! `            !            !     !     !  O        F        	                          For Registry Upgrade

%  N6       "   (           "   "   "   (                                          N6       /
    $  -  N6     L         E     @ 
     f      )  +  2  V4  c5  e5  &6  N6   ! !  !        !  !  !  !         y@       ;+  y@     (  Times New Roman 	Symbol & Arial (     Sunil Pai's Printer \\undead2\cool_4si winspool Sunil Pai's Printer  386 BUILD_M | T Y                     Letter  2\cmd.exe HOMEDRIVE=C: HOM                                                                               N N N  '                      )          >  )  +  +  +  +  2  V4  c5  e5  &6  (6  L6  N6       7     Q     9+    7    -    `@     -     3     5    u@     6    w@    [7     7    "       h    rk%3-Ce     )       %       	SUNIL PAI	Sunil Pai         
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\spddlang\spddlang.txt ===
This file details an interface to be used to supply locale/language-specific
function for display, keyboard handling, etc, within text setup.

The goals are as follows:

1) Provide a straightforward means for supporting fully localized text display,
   keyboard handling, and other features, in various locales, especially
   Far Eastern ones.

2) Avoid impacting setupdd.sys's size or performance when such function is not
   required.

To this end features such as DBCS font support, locale-specific keyboard detection,
and various other features are to be removed and placed into an export driver.
Setupdd.sys will be linked such that this driver is automatically referenced
and loaded when setupdd.sys is loaded. Setupdd.sys will itself export a set of
routines for use by the language-specific driver when carrying out its function.

Language-specific drivers will be built in the setup\textmode\spddlang directory.
Such drivers are logically part of setupdd.sys. No special set of include files
will be created for the interfaces below; they will be contained in various
header files in setup\textmode\kernel. Language-specific drivers' SOURCES files
should be set up so they include setup\textmode\kernel in their INCLUDES and
#include spprecmp.h.

*******************************************************************************

The functions listed below must be exported from every language-specific driver.

NTSTATUS
SplangInitializeFontSupport(
    IN PCWSTR BootDevicePath,
    IN PCWSTR DirectoryOnBootDevice
    );

/*++

Routine Description:

    This routine is called by setupdd.sys to allow the language-specific
    font support to be initialized. The language-specific driver should
    load any font it requires and perform any additioanl initialization.

Arguments:

    BootDevicePath - supplies the path of the device from which the system
        booted. This is a full NT-style path that includes a directory spec.

    DirectoryOnBootDevice - supplies directory relative to root of boot
        device.

Return Value:

    NT Status code indicating outcome. If this routine returns a non-success
    status code, then setupdd.sys will not switch into non-US character mode.
    The implementation of this routine is free to call SpBugCheck or otherwise
    inform the user of any errors if it wishes to halt setup if font
    initialization fails.

--*/


NTSTATUS
SplangTerminateFontSupport(
    VOID
    );

/*++

Routine Description:

    This routine may be called in certain conditions to cause font support
    for a particular language to be terminated. The implementation should
    clean up any resources allocated during SplangInitializeFontSupport().

Arguments:

    None.

Return Value:

    NT Status code indicating outcome.

--*/


PVIDEO_FUNCTION_VECTOR
SplangGetVideoFunctionVector(
    IN SpVideoType VideoType,
    IN PSP_VIDEO_VARS VideoVariableBlock
    );

/*++

Routine Description:

    This routine is called by setupdd.sys upon successful return from
    SplangInitializeFontSupport, to request a pointer to a vector of
    language-specific display support routines for a given display
    type (vga or frame buffer).

Arguments:

    VideoType - a value from the SpVideoType enum indicating which display
        vector is requested. Currently one of SpVideoVga or SpVideoFrameBuffer.

    VideoVariableBlock - supplies a pointer to a block of video variables that
        are shared between the high-level code in setup\textmode\spvideo.c and
        the display-specific code.

Return Value:

    Pointer to the language-specific video functions vector to use for
    displaying text. NULL if the requested type is not supported. In this case
    the display will not be switched into non-US character mode.

--*/


ULONG
SplangGetColumnCount(
    IN PCWSTR String
    );

/*++

Routine Description:

    This routine is called by setupdd.sys to determine how many columns
    on the screen a particular string will occupy. This may be different
    than the number of characters in the string due to full/half width
    characters in the character set, etc. Full width chars occupy two columns
    whereas half-width chars occupy one column. If the font in use is
    fixed-pitch or does not support DBCS, the number of columns is by
    definition equal to the number of characters in the string.

Arguments:

    String - points to unicode string whose width in columns is desired.

Return Value:

    Number of columns occupied by the string.

--*/


PWSTR
SplangPadString(
    IN int    Size,
    IN PCWSTR String
    );

/*++

Routine Description:

    This routine is called by setupdd.sys to generate a padded string
    appropriate for SBCS or DBCS as appropriate.

Arguments:

    Size - specifies the length to which to pad the string.

    String - points to unicode string that needs to be padded.

Return Value:

    Pointer to padded string. Note that this is a static buffer and thus
    the caller must duplicate the string if it is needed across multiple
    calls to this routine.

--*/


VOID
SplangSelectKeyboard(
    IN BOOLEAN UnattendedMode,
    IN PVOID SifHandle,
    IN PHARDWARE_COMPONENT *HwComponents
    );

/*++

Routine Description:

    This routine is called by setupdd.sys to allow language-specific processing
    for the keyboard selection. The implementation can confirm a keyboard
    type at this time.

Arguments:

    UnattendedMode - supplies a flag indicating whether we are running in
        unattended mode. If so, the implementation may wish to do nothing,
        since the user will not be entering any paths.

    SifHandle - supplies handle to open setup information file (txtsetup.sif).

    HwComponents - supplies the address of the master hardware components
        array.

Return Value:

    None. If a failure occurs, it is up to the implementation to decide whether
    to continue or to SpBugCheck.

--*/


VOID
SplangReinitializeKeyboard(
    IN BOOLEAN UnattendedMode,
    IN PVOID SifHandle,
    IN PWSTR Directory,
    OUT PVOID *KeyboardVector,
    IN PHARDWARE_COMPONENT *HwComponents
    );

/*++

Routine Description:

    This routine is called by setupdd.sys to allow language-specific processing
    for the keyboard. The implementation can reinitialize the keyboard layout
    at this time.

    This routine will be called before the user is asked to enter any paths
    or other text that includes typing anything other than keys such as
    ENTER, function keys, backspace, escape, etc.

Arguments:

    UnattendedMode - supplies a flag indicating whether we are running in
        unattended mode. If so, the implementation may wish to do nothing,
        since the user will not be entering any paths.

    SifHandle - supplies handle to open setup information file (txtsetup.sif).

    Directory - supplies the directory on the boot device from which the
        new layout dll is to be loaded.

    KeyboardVector - supplies the address of a pointer to the keyboard
        vector table. The implementation should overwrite this value with
        whatever is returned from SpLoadKbdLayoutDll().

    HwComponents - supplies the address of the master hardware components
        array.

Return Value:

    None. If a failure occurs the implementation must leave the currently active
    keybaord in place.

--*/


WCHAR
SplangGetLineDrawChar(
    IN LineCharIndex WhichChar
    );

/*++

Routine Description:

    This routine is called by setupdd.sys to retreive the unicode value for
    a particular line drawing character. An implementation must make these
    characters available in the character set somehow.

Arguments:

    WhichChar - supplies the index of the character desired.

Return Value:

    Unicode value for the character in question. Because the character
    will be displayed using the language-specific module, the implementation
    can materialize this character by playing whatever tricks it needs to,
    such as overlaying a hardcoded glyph into the character set, etc.

--*/


WCHAR
SplangGetCursorChar(
    VOID
    );

/*++

Routine Description:

    This routine is called by setupdd.sys to retreive the unicode value
    of a character to be used as the cursor when the user is asked to
    enter text.

Arguments:

    None.

Return Value:

    Unicode value for the character to be used as the cursor.

--*/


NTSTATUS
SplangSetRegistryData(
    IN PVOID  SifHandle,
    IN HANDLE ControlSetKeyHandle,
    IN PHARDWARE_COMPONENT *HwComponents
    );

/*++

Routine Description:

    This routine is called by setupdd.sys to cause language-specific
    information to be written into the current control set in the registry.

Arguments:

    SifHandle - supplies a handle to the open setup information file
        (txtsetup.sif).

    ControlSetKeyHandle - supplies a handle to the current control set
        root in the registry (ie, HKEY_LOCAL_MACHINE\CurrentControlSet).

    HwComponents - supplies the address of the master hardware components
        array.

Return Value:

    NT Status value indicating outcome. A non-success status is considered
    critical and causes Setup to abort.

--*/


BOOLEAN
SplangQueryMinimizeExtraSpacing(
    VOID
    );

/*++

Routine Description:

    This routine is called by setupdd.sys to determine whether to
    eliminate uses of extra spacing on the screen to set off things
    like menus and lists from text. Languages whose text takes up
    a lot of room on the screen might opt to eliminate such spacing
    to allow menus to display more than a couple of items at a time, etc.

    The return value affects numerous screens, such as the partition menu,
    upgrade lists, etc.

Arguments:

    None.

Return Value:

    Boolean value indicating whether the implementation wants unnecessary
    spaces eliminated when text, menu, etc, are displayed.

--*/

*******************************************************************************

The functions listed below are exported from setupdd.sys for use by
language-specific drivers. Such drivers are free to use any NT API normally
available to NT device drivers in addition to the routines listed below.


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\textmode\winnt\us2\placefil.txt ===
; This file is

; This file is used to specify where every file built by the NT build lab is
; binplaced relative to the root of the distribution point.  If a file is not
; listed, it will end up in the dump directory.
;
; The format is like this:
;
; <imagename>    <class name>
;
; where <imagename> is the filename.ext and <class name> is the directory off
; the root of the distribution point (retail is a placeholder for the root).
; If there are multiple class names for a single image, use a colon to separate
; each.
;
; All bits that ship in the NT base product and are installed with winnt32,
; must have a class name of retail.
;
; If you add a new file to the list, please refrain from creating your own
; special section.  Doing so makes it difficult to detect duplicates.  If
; you're unable to add your image due to a collision with an existing name,
; work it out with the other developer.  Options include creating another
; placefil.txt for your project or using the ALT_PROJECT_TARGET macro in your
; sources file to change the base of the distribution point (doing so means
; your project will not install as part of base NT).
;
;     sort /+17 < placefil.txt > placefil.srt
;
; will generate a list sorted by class name if you want.
;
; NOTE: This is not the master placefil.txt for NT, the master is in
; \nt\public\sdk\lib. This version is for the langpack. To see where the
; files are really going, look in the sources files
;

winnt.exe cht:chs:kor:ara:heb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\devupgrd\placefil.txt ===
; This file is used to specify where every file built by the NT build lab is
; binplaced relative to the root of the distribution point.  If a file is not
; listed, it will end up in the dump directory.
;
; The format is like this:
;
; <imagename>    <class name>
;
; where <imagename> is the filename.ext and <class name> is the directory off
; the root of the distribution point (retail is a placeholder for the root).
; If there are multiple class names for a single image, use a colon to separate
; each.
;
; All bits that ship in the NT base product and are installed with winnt32,
; must have a class name of retail.
;

;
; migration dll.
;
migrate.dll win9xmig\devupgrd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\migdlls\setup\placefil.txt ===
; This file is used to specify where every file built by the NT build lab is
; binplaced relative to the root of the distribution point.  If a file is not
; listed, it will end up in the dump directory.
;
; The format is like this:
;
; <imagename>    <class name>
;
; where <imagename> is the filename.ext and <class name> is the directory off
; the root of the distribution point (retail is a placeholder for the root).
; If there are multiple class names for a single image, use a colon to separate
; each.
;
; All bits that ship in the NT base product and are installed with winnt32,
; must have a class name of retail.
;

;
; migration dll.
;
migrate.dll win9xmig\setup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\reqdlls\placefil.txt ===
cabinet.dll  winnt32\win9xupg
cfgmgr32.dll winnt32\win9xupg
setupapi.dll winnt32\win9xupg
imagehlp.dll winnt32\win9xupg
msvcrt.dll   winnt32\win9xupg
twid.exe     winnt32\win9xupg
e95only.dat  winnt32\win9xupg
ismig.dll    winnt32\win9xupg
jpegim32.flt win9xmig\setup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\win95upg\w95upgnt\migmain\pbk.txt ===
[ENTRY]
        -- Taken from the Dial Up entry name in Win9x

    Type=<RASET-code>
        -- RASET codes are defined in ras.h. They are
           RASET_Phone (0x1) , RASET_Vpn (0x2), RASET_Direct (0x3), RASET_Internet (0x4).
           This setting determines what is dialup options are presented to the end user.

    Description=<description>
        -- This is not used by NT5 and nothing is migrated to it.

    AutoLogon=<1/0>
        -- ???????????????

    DialParamsUID=<unique-ID>
        -- ???????????????

    Guid=<guid>
        -- Nothing is migrated to this setting. A GUID will be assigned to the entry
           the first time it is used on NT 5.0.

    UsePwForNetwork=<1/0>
        -- This is unused on NT 5.0 and nothing is migrated to it.

    ServerType=<ST-code>
        -- This is unused on NT 5.0 and nothing is migrated to it.

    BaseProtocol=<BP-code>          ;same
    Authentication=<AS-code>        ;same
    ExcludedProtocols=<NP-bits>     ;same
    LcpExtensions=<1/0>             ;same
    DataEncryption=<DE-code>        ;same, but new codes for IpSec
    SkipNwcWarning=<1/0>            ;same
    SkipDownLevelDialog=<1/0>       ;same
    SwCompression=<1/0>             ;same
    UseCountryAndAreaCodes=<1/0>    ;Deleted, becomes "UseDRules" of 1st phone#
    AreaCode=<string>               ;Deleted, becomes "AreaCode" of 1st phone#
    CountryID=<id>                  ;Deleted, becomes "CountryID" of 1st #
    CountryCode=<code>              ;Deleted, becomes "CountryCode" of 1st #

    ShowMonitorIconInTaskBar=<1/0>
        -- The answer to this is the value stored in !(<HKR\Remote Access\[DialUi]> & DIALUI_DONT_SHOW_ICON)

    CustomAuthKey=<EAP-code>
        -- Nothing is migrated to this key from Windows9x.

    CustomAuthData=<hexdump>
        -- Nothing is migrated to this key from Windows9x.

    AuthRestrictions=<AR-code>
        -- Nothing is migrate to this key from Windows9x.

    OverridePref=<RASOR-bits>
        -- Set to "15" on upgrade. This ensures that
           RedialAttempts, RedialSeconds, IdleDisconnectSeconds, and RedialOnLinkFailure are used from the
           entry. This is also the default set on NT 5.0.

    DialMode=<DM-code>
        -- Nothing migrated currently for this setting. Need to have multilink tested further to see if there is
           something that can be put there (I do not think that there is..)

    DialPercent=<0-100>
        -- Hardcoded to '90' during migration.

    DialSeconds=<1-n>
        -- Hardcoded to '120' during migration.

    HangUpPercent=<0-100>
        -- Hardcoded to '50' during migration.

    HangUpSeconds=<1-n>
        -- Hardcoded to '120' during migration.

    RedialAttempts=<n>
        -- <HKR\Remote Access\[RedialTry]>

    RedialSeconds=<n>
        -- let d = <HKR\Remote Access\[RedialWait]>, then DialSeconds = HIWORD(d) * 60 + LOWORD(d)

    IdleDisconnectSeconds=<-1,0-n>
        -- Hardcoded to '-1' during migration.

    RedialOnLinkFailure=<1/0>
        -- Defaults to 0 during migration.

    CallbackMode=<1/0>
        -- Defaults to 0 during migration.

    CustomDialDll=<path>            ;same, i.e. NYI
    CustomDialFunc=<func-name>      ;same, i.e. NYI
    AuthenticateServer=<1/0>        ;same

    SecureLocalFiles=<1/0>
        -- Not used during migration.
    ShareMsFilePrint=<1/0>
        -- Not used during migration.
    BindMsNetClient=<1/0>
        -- Not used during migration (need to investigate.)

    SharedPhoneNumbers=<1/0>        ;New
    PrerequisiteEntry=<entry-name>  ;New
    PreviewUserPw=<1/0>             ;New
    PreviewDomain=<1/0>             ;New
    PreviewPhoneNumber=<1/0>        ;New
    ShowDialingProgress=<1/0>       ;New

    IpPrioritizeRemote=<1/0>        ;same (PPP/SLIP only)
    IpHeaderCompression=<1/0>       ;same (PPP/SLIP only)
    IpAddress=<a.b.c.d>             ;same (PPP/SLIP only)
    IpAssign=<ASRC-code>            ;same (PPP/SLIP only)
    IpDnsAddress=<a.b.c.d>          ;same (PPP/SLIP only)
    IpDns2Address=<a.b.c.d>         ;same (PPP/SLIP only)
    IpWinsAddress=<a.b.c.d>         ;same (PPP/SLIP only)
    IpWins2Address=<a.b.c.d>        ;same (PPP/SLIP only)
    IpNameAssign=<ASRC-code>        ;same (PPP/SLIP only)
    IpFrameSize=<1006/1500>         ;same (SLIP only)

    In general each section contains subsections delimited by
    MEDIA=<something> and DEVICE=<something> lines.  There can be any number
    of DEVICE subsections.  There can be multiple MEDIA/DEVICE sets where the
    position of the set determines it's sub-entry index, the first being 1,
    the second 2, etc.

    For serial media, the program currently expects 1 to 4 DEVICE subsections,
    representing a preconnect switch, modem, X.25 PAD, and postconnect switch.
    Following is a full entry:

    MEDIA=serial                    ;same
    Port=<port-name>                ;same
    Device=<device-name>            ;same
    ConnectBps=<bps>                ;same, for old MXS support only

    DEVICE=switch                   ;same
    Type=<switchname or Terminal>   ;Deleted, converted to 2 fields below
    Name=<switchname>               ;New, name of switch or empty if none
    Terminal=<1/0>                  ;New, terminal is to run with/without above

    DEVICE=modem                    ;same

    PhoneNumber=<phonenumber1>      ;same
    AreaCode=<area-code1>           ;New
    CountryID=<id>                  ;New
    CountryCode=<country-code>      ;New
    UseDialingRules=<1/0>           ;New
    Comment=<arbitrary-text1>       ;New, 'Description' from upgrade
    ...
    PhoneNumber=<phonenumber2>      ;same
    AreaCode=<area-code1>           ;New
    CountryID=<id>                  ;New
    CountryCode=<country-code>      ;New
    UseDialingRules=<1/0>           ;New
    Comment=<arbitrary-text2>       ;New
    ...
    PhoneNumber=<phonenumberN>      ;same
    AreaCode=<area-code1>           ;New
    CountryID=<id>                  ;New
    CountryCode=<country-code>      ;New
    UseDialingRules=<1/0>           ;New
    Comment=<arbitrary-textn>       ;New

    LastSelectedPhone=<index>       ;New
    PromoteAlternates=<1/0>         ;same
    TryNextAlternateOnFail=<1/0>    ;New

    TapiBlob=<hexdump>              ;same, i.e. #if 0'd out
    ManualDial=<1/0>                ;For old MXS support only
    HwFlowControl=<1/0>             ;For old MXS support only
    Protocol=<1/0>                  ;For old MXS support only
    Compression=<1/0>               ;For old MXS support only

    DEVICE=pad                      ;same
    X25Pad=<padtype>                ;same
    X25Address=<X121address>        ;same
    UserData=<userdata>             ;same
    Facilities=<facilities>         ;same

    DEVICE=switch                   ;same
    Type=<switchname or Terminal>   ;Deleted, converted to 2 fields below
    Name=<switchname>               ;New, name/path of switch or empty if none
    Terminal=<1/0>                  ;New, terminal is to run with/without above

    For ISDN media, the program expects exactly 1 DEVICE subsection.  Note
    that ISDN is now identical to the "other" case.

    MEDIA=isdn                      ;same
    Port=<port-name>                ;same
    Device=<device-name>            ;same

    DEVICE=isdn                     ;same

    PhoneNumber=<phonenumber1>      ;same
    AreaCode=<area-code1>           ;New
    CountryID=<id>                  ;New
    CountryCode=<country-code>      ;New
    UseDialingRules=<1/0>           ;New
    Comment=<arbitrary-text1>       ;New, 'Description' from upgrade
    ...
    PhoneNumber=<phonenumber2>      ;same
    AreaCode=<area-code1>           ;New
    CountryID=<id>                  ;New
    CountryCode=<country-code>      ;New
    UseDialingRules=<1/0>           ;New
    Comment=<arbitrary-text2>       ;New
    ...
    PhoneNumber=<phonenumberN>      ;same
    AreaCode=<area-code1>           ;New
    CountryID=<id>                  ;New
    CountryCode=<country-code>      ;New
    UseDialingRules=<1/0>           ;New
    Comment=<arbitrary-textn>       ;New

    LastSelectedPhone=<index>       ;New
    PromoteAlternates=<1/0>         ;same
    TryNextPhoneNumberOnFail=<1/0>  ;New

    LineType=<0/1/2>                ;same
    Fallback=<1/0>                  ;same
    EnableCompression=<1/0>         ;For old protocol only
    ChannelAggregation=<channels>   ;For old protocol only

    For X.25 media, the program expects exactly 1 DEVICE subsection.

    MEDIA=x25                       ;same
    Port=<port-name>                ;same
    Device=<device-name>            ;same

    DEVICE=x25                      ;same
    X25Address=<X121address>        ;same
    UserData=<userdata>             ;same
    Facilities=<facilities>         ;same

    For other media, the program expects exactly one DEVICE subsection with
    device name matching the media.  "Other" media and devices are created for
    entries assigned to all non-serial medias including ISDN which now matches
    the rules for "other".

    MEDIA=<media>                   ;same
    Port=<port-name>                ;same
    Device=<device-name>            ;same

    DEVICE=<media>                  ;same

    PhoneNumber=<phonenumber1>      ;same
    AreaCode=<area-code1>           ;New
    CountryID=<id>                  ;New
    CountryCode=<country-code>      ;New
    UseDialingRules=<1/0>           ;New
    Comment=<arbitrary-text1>       ;New, 'Description' from upgrade
    ...
    PhoneNumber=<phonenumber2>      ;same
    AreaCode=<area-code1>           ;New
    CountryID=<id>                  ;New
    CountryCode=<country-code>      ;New
    UseDialingRules=<1/0>           ;New
    Comment=<arbitrary-text2>       ;New
    ...
    PhoneNumber=<phonenumberN>      ;same
    AreaCode=<area-code1>           ;New
    CountryID=<id>                  ;New
    CountryCode=<country-code>      ;New
    UseDialingRules=<1/0>           ;New
    Comment=<arbitrary-textn>       ;New

    LastSelectedPhone=<index>       ;New
    PromoteAlternates=<1/0>         ;same
    TryNextPhoneNumberOnFail=<1/0>  ;New

    The phonebook also supports the concept of "custom" entries, i.e. entries
    that fit the MEDIA followed by DEVICE subsection rules but which do not
    include certain expected key fields.  A custom entry is not editable with
    the UI, but may be chosen for connection.  This gives us a story for new
    drivers added by 3rd parties or after release and not yet fully supported
    in the UI. (NOTE: Support for this may be dropped in RAS API)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winbrand\placefil.txt ===
;
; This is a private placefil used by the Windows Branding project.
;
; See public\sdk\lib\placefil.txt for info about placefil's in general.
;
; *** Please keep this alphabetical  ***
;

winbrand.dll     retail
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\dll\appcompattest\placefil.txt ===
testwinnt32u.DLL		DUMP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\winnt32\fsfilter\fsfilter.txt ===
This component appears to use a type of device driver called a file
system filter driver. File system filter drivers allow other companies to write programs that can access files on your hard disks. They are typically
used in products such as virus checkers or backup applications, but may also be 
used with storage devices like CD-ROMs, 'jukeboxes', or tape drives. 

This particular driver has not been tested with Microsoft Windows XP, and you should not continue to upgrade with this driver loaded. However, your computer does not have enough information to identify which add-on product is using this driver.

You can proceed by doing one of the following:

1. Identify and uninstall the program that is using this driver. Sometimes the driver name clearly identifies which product uses it. A current list of driver names and the programs that use them can be found in the Release Notes on your Windows XP CD, or at http://www.microsoft.com/windows/server/deploy/fileprint/fsfilteruse.

2. In Control Panel, double-click Devices. Find the entry for this driver, click <B>Startup</B>, and then click Disabled. Click OK, click Close, and then restart your computer. Restart Windows XP Setup. You can proceed with the upgrade, but the product thar::!t
was using this driver will not function properly now.

For a list of devices supported by Windows XP, please see the Microsoft Windows XP Hardware Compatibility List at  http://www.microsoft.com/hwtest/hcl. Your Windows XP CD includes a copy of this list (drive:\Support\hcl.txt) that was accurate as of the date Windows XP was released.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\ansi\placefil.txt ===
;
; This private placefile allows the ANSI build of setupapi.dll
; to go to the Win9x upgrade.  To add additional destinations,
; append a colon and then your dir name (or retail for the root)
;

setupapi.dll        winnt32\win9xupg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\readme.txt ===
DevCon2

COM based device management objects
Experimental, not a build target. Do not add to 'dirs' (yet)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\expackdll\placefil.txt ===
; This file is used to specify where every file built by the NT build lab is
; binplaced relative to the root of the distribution point.  If a file is not
; listed, it will end up in the dump directory.
;
; The format is like this:
;
; <imagename>    <class name>
;
; where <imagename> is the filename.ext and <class name> is the directory off
; the root of the distribution point (retail is a placeholder for the root).
; If there are multiple class names for a single image, use a colon to separate
; each.
;
; All bits that ship in the NT base product and are installed with winnt32,
; must have a class name of retail.
;

;
; migration dll.
;
msoobci.dll     dump
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\filter.txt ===
; FILTER INF
;
[Version]
signature="$Windows NT$"
ClassGUID={00000000-0000-0000-0000-000000000000}

[FileFilters]
;
; what to do based on filename
;
MYFILE.INF = 0,MyFile.Filter,"{00000000-0000-0000-0000-000000000000}"
;
; <filename> = <action>, <filter_section>, <guid>
;
; action:
;
;    0 (default) - check INF
;    1           - ignore INF
;
; filter_section:
;
;    if specified, section with rules for specified INF
;
; guid:
;
;    if specified, INF must match this GUID.
;

[ErrorFilters]
;
; default action based on error tag
;
123 = 0
;
; <tag> = <action>
;
; action:
;
;    0 (default) - log error
;    1           - ignore error
;

[GuidFilters]
;
; what to do based on GUID
;
"{00000000-0000-0000-0000-000000000000}" = 4, MyFile.Filter
;
; action:
; 0 (default) - check INF
; 1           - ignore INF
; 4           - fail INF
;
; filter_section:
;
; if specified, section with rules for specified GUID
;

[MyFile.Filter]
;
; specific errors to ignore for given INF file
; section specified via [FileFilters]
;
123 = 1, "blah"
;
; <tag> = <action> {,<param>}*
;
; action:
;
;
;    0 (default) - log error
;    1           - ignore error
;    2           - ignore error only if it matches parameters inline
;
; For each parameter specified, "*" = wild
;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\placefil.txt ===
; This file is used to specify where every file built by the NT build lab is
; binplaced relative to the root of the distribution point.  If a file is not
; listed, it will end up in the dump directory.
;
; The format is like this:
;
; <imagename>    <class name>
;
; where <imagename> is the filename.ext and <class name> is the directory off
; the root of the distribution point (retail is a placeholder for the root).
; If there are multiple class names for a single image, use a colon to separate
; each.
;
; All bits that ship in the NT base product and are installed with winnt32,
; must have a class name of retail.
;
; If you add a new file to the list, please refrain from creating your own
; special section.  Doing so makes it difficult to detect duplicates.  If
; you're unable to add your image due to a collision with an existing name,
; work it out with the other developer.  Options include creating another
; placefil.txt for your project or using the ALT_PROJECT_TARGET macro in your
; sources file to change the base of the distribution point (doing so means
; your project will not install as part of base NT).
;
;     sort /+17 < placefil.txt > placefil.srt
;
; will generate a list sorted by class name if you want.
;
; IMPORTANT NOTE:
;
; If you add a file to the system, YOU MUST make sure layout.inf is updated
; before you start depending on it or else you will cause a BVT break. Do
; not attempt to modify layout.inf yourself, but follow instructions on:
;     http://winweb/setup/addtob/default.htm
;
;        PLEASE KEEP THIS LIST SORTED
;---------------------------------------------
hpsim.sys				pcisim
shpc.sys				pcisim
softpci.exe                             pcisim
softpci.inf				pcisim
softpci.sys				pcisim
spcikd.dll				pcisim
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\softpci script engine specification.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Internal Test Specification Template TitleTest Specification Template Vincent Geglia Brandon Allsop Microsoft Word 10.0urn:schemas-microsoft-com:office:smarttags Minute g.8gt$( n" 4g#]N MsdX~y F(+i4e' JHyFB $M7B# r.CW" ^F_Lm>j+ #z=s[ S5pwk iTQtql )b~Al3 )oCwZPicture (Metafile) StaticMetafileMicrosoft Word Times New Roman Microsoft Word Times New Roman Microsoft Word Times New Roman Microsoft Word "Arialbjbjk EMBED StaticMetafile Windows Operating Systems SoftPCI Script Engine Specification BrandonA Feature Overview This specification details the scripting support provided by SoftPCI.   The scripting support allows you to install a large number of  Virtual  PCI hardware without having to go through the SoftPCI UI.  It is assumed that the user has a fundamental understanding of PCI hardware and particularly PCI Configuration Space. Details on configspace can be found in the PCI 2.2 Specification (chapter 6) or chapter 19 of the PCI System Architecture 4th Edition book. Feature Architecture The script engine support in SoftPCI provides the ability to control literally all aspects of a PCI devices configuration space region.  It also allows for dynamic creation of small or large PCI hierarchies.  This section describes the Script file syntax.  Script File The script file can be a file with any name and any extension desired.  Example script files may have *.INI extensions but this is not required.  The only requirement currently in place is that the file cannot be UNICODE and must be a standard ANSI text file.   Script File Sections and Parameters This spec refers to  sections  as those items which will appear in brackets   and  parameters  are items that follow the given section.   SOFTPCI Section This section indicates to SoftPCI this is a valid script file.  It must be the first section in the file and has only one parameter which is used to denote script file version.   Should a new script file format be defined, backward compatibility with older script files will be maintained.   Syntax: [SOFTPCI] Version=1 INSTALL Section This section is used to specify the additional  virtual device  sections that need to be parsed.  The parameters are user defined and can by any value desired.  Note: The sections that each parameter defines will be parsed in the order they are listed in this section.  This is important because you may want to create a virtual bridge with virtual devices behind it and for this to work the bridge must be listed first.   Syntax: [INSTALL] device1 device2 bridge1 bridge2 device3 device4 somecoolprivatescriptdevice User defined Virtual Device Sections These sections are derived from the  parameters  given to the INSTALL section.  They are user defined and can be any value.   Syntax: [device1] Virtual Device Parameters  The parameters for each user defined virtual device section can vary.  Only the TYPE parameter is required to install a generic  default  SoftPCI device.  The following describes each parameter in-depth. TYPE Parameter This REQUIRED parameter defines what type of device will be installed.  Valid values are Device, PPBridge, HPBridge, CBDevice, CBBridge, and Private. These are defined as follows: Device   This type defines a default Microsoft SoftPCI device.   PPBridge   This type defines a default Microsoft SoftPCI-PCI Bridge. HPBridge   This type defines a default Microsoft SoftPCI-HOTPLUG Bridge.  This is used to simulate the SHPC (Standard HotPlug Controller) hardware that has recently been spec d out by the PCI SIG. CBDevice   Microsoft SoftPCI CardBus Device. (Not Implemented Yet) CBBridge   Microsoft SoftPCI-CardBus Bridge. (Not Implemented Yet) Private   User defined configspace for all registers.  This type requires that the user supplies all required register settings and mask bits needed for the device. Everything is zero by default! Example: [device1] type=device [bridge1] type=ppbridge [foodevice] type=private SLOT Parameter This parameter is used to describe the  location  for the device being created.  It is essentially the Device and Function number for the new device.  The PCI Spec defines that the max device number per PCI bus is 32 (0 - 0x1f) and the max functions per device is 8 (0   7) (see PCI Spec or Mindshare PCI Architecture for details on PCI Device and Function numbers).    This parameter is OPTIONAL only if you are installing a device that will not have  children .  Therefore if TYPE = Device and SLOT is not specified, SoftPCI will default to BUS 0 (first root bus) and install the device at the next available device number, function 0.  If you install a bridge without specifying this parameter then you will not be able to install any devices behind the bridge. For format for this parameter is XXYY where XX is the device number and YY is the function number.  Example: [device1] type=device slot=0500 (  Here we are installing this device as DEVICE 5 FUNCTION 0 [device2] type=device slot=0501 (  Here we are installing this device as DEVICE 5 FUNCTION 1 NOTE: The PCI spec requires that FUNCTION 0 exist before you can install a sub-function.  Therefore if you fail to install a FUNCTION 0 device before a FUNCTION 1 - 7 device the install will fail. PARENTPATH Parameter This OPTIONAL parameter defines the  Parent SLOT destination bus  for this new device.  If this parameter is omitted then BUS 0 or first root bus is assumed. The format for this parameter is as follows: Parentpath = FFXX\DEVFUNC\DEVFUNC\....    The first value (FFXX) differs slightly from the SLOT format and is used to describe ROOT BUS to start from.  To describe a root bus, the DEVICE number field must be set to FF and the FUNCTION number field is used to describe the root bus number. Example: ParentPath=FF00\0200\0500  In this example we are placing a device specified by "SLOT" behind bridge located at 0500 (which is behind bridge 0200 on root 0).  If   parameter doesn t exist then we will default to next available device number, function 0. CONFIGSPACE Parameter This parameter is used to define the current configuration register settings for the device being created.  This parameter is optional if TYPE is anything other than  Private .  If this parameter is not specified then the default config registers are used for the device (see section 2.2.3.1.6 for details on default register values).  For TYPE=Private devices the user is required to specify the entire configuration register set needed for the type of device being created.  Examples of this are the Vendor and Device IDs, HeaderType and Class codes etc.  Checkout PCI 2.2 spec for full config space register layout. Each configuration space buffer for PCI devices is 256 byes in size.  Therefore configspace OFFSETS range from 0   0xff.  The syntax used by the Script Engine is: OFFSET: VALUE, VALUE, VALUE, ... Here is an example a SoftPCI device config space buffer: 00: DCBBABCD,04000087,06048000,00810008 10: 00000000,00000000,00818100,0000E0E0 20: FFE0FBF0,0000FFF0,00000000,00000000 30: 00000000,00000000,00000000,00000000 40: 00000000,00000000,00000000,00000000 50: 00000000,00000000,00000000,00000000 60: 00000000,00000000,00000000,00000000 70: 00000000,00000000,00000000,00000000 80: 00000000,00000000,00000000,00000000 90: 00000000,00000000,00000000,00000000 A0: 00000000,00000000,00000000,00000000 B0: 00000000,00000000,00000000,00000000 C0: 00000000,00000000,00000000,00000000 D0: 00000000,00000000,00000000,00000000 E0: 00000000,00000000,00000000,00000000 F0: 00000000,00000000,00000000,00000000 Each OFFSET must be a HEX value from 0 to 0xff separated by a   and then the first HEX value at the specified offset.  Currently no alignment restrictions exist and you can specify any offset and any value as long as the value is no larger than 4 bytes (ULONG) and does not run past the end of configspace.   Examples: 19: 23 31: 12345678 Note that in the example above we will be modifying offset 0x19 with a one byte value of 0x23.  In the next example we are modifying offset 0x31 but we are writing a full 4 byte value starting at this address.  This means that 0x31   0x34 will be updated!  It is strongly recommended that offsets be aligned with value sizes being written to avoid unexpected problems! Another Example: 04: 07, ffff1234,,8765 Each comma   that separates a register value causes the specified OFFSET to be incremented to the next 4 byte (ULONG) boundary before writing the value following the comma. In the example above we start at offset 0x4 and we write the one byte value of 0x7.  We then increment the offset to 0x8 and write the 4 byte value 0xffff1234. The next two commas increment out offset to 0x10 (we skipped 0xc) and we write the 2 byte value 0x8765.  NOTE:  If the beginning offset is not aligned on a 4 byte boundary the offset is still incremented to the next 4 byte aligned offset.  Therefore if you start at offset 0x19 then a comma will cause the offset to increment to 0x1c. Currently there is no limit to the number of values you can place on a single line as long as you stay with in the 256 byte configspace limit. CONFIGSPACEMASK Parameter This parameter is used to define the current configuration register MASK settings for the device being created.  This parameter is optional if TYPE is anything other than  Private .  The syntax and format of this parameter is identical to the CONFIGSPACE parameter (see section 2.2.3.1.4 above).   The ConfigSpaceMask is used to define which bits in the devices configuration space can be changed (writable). A register value of zero in the config mask means that the register is  Read Only  and therefore the value currently set at the same offset in the ConfigSpace buffer cannot be changed. Examples: ConfigSpace= 00: DCBBABCD, 07 ConfigSpaceMask= 00: 00000000, 03 In the example above we define offset 0x00 to a value of 0xDCBBABCD and offset 0x4 to a value of 0x7.  The ConfigSpaceMask for this device has offset 0x00 set to a value of 0 and offset 0x4 set to a value of 0x3. This means that only the first 2 bits (bit 0 and bit 1) at offset 0x4 can get changed and offset 0x00 is  Read Only Default ConfigSpace and ConfigSpaceMask Below is a break down of what each device TYPE will use as default config space values.  You can override these values using the ConfigSpace and ConfigSpaceMask parameters. Device   (VEN_ABCD&DEV_DCBA) Default Config: 00: DCBAABCD,,04800000,00809911 2C: DCBAABCD Config Space Mask: 04: 02000143,04800000,0000FFFF PPBridge   (VEN_ABCD&DEV_DCBB) Default Config: 00: DCBBABCD,04000080,06048000,00810008 Config Space Mask: 04: FF 18: 00FFFFFF,0000F0F0 20: FFF0FFF0,0000FFF0 HPBridge   (VEN_ABCD&DEV_DCBC) Default Config: Not defined yet Config Space Mask: Not defined yet CBDevice   (VEN_ABCD&DEV_DCBD) SUPPORT FOR THIS DEVICE TYPE NOT IMPLEMENTED YET CBBridge - (VEN_ABCD&DEV_DCBE) SUPPORT FOR THIS DEVICE TYPE NOT IMPLEMENTED YET Private - User defined configspace for all registers. Everything is zero by default! NOTE: Configspace registers and Mask values not defined above are defaulted to 0.   Example Script File [SOFTPCI] Version=1 [INSTALL] device1 bridge1 device2 SomeCoolPrivateDevice [device1] Type=Device ConfigSpaceMask= 14: FFFFF000 [bridge1] Type=PPBridge Slot=0b00 ParentPath=FF00 [device2] Type =Device Slot=1600 ParentPath=ff00\0b00 ConfigSpace= 04: 00000007 50: 00f20000,00000000,00000000,00000000 70: 00000000,ABCDEFFF,00000000,00000000 f0: 00000000,,,00000001 ConfigSpaceMask= 04: 00000007 10: ffff0000,00000000,ff01,00000000 9c: 08 fc: 00000001 [SomeCoolPrivateDevice] Type=private Slot=0300 ParentPath=FF00\0b00 ConfigSpace= 00: 25308086,20900006,06000002,00000000 10: D0000008,00000000,00000000,00000000 20: 00000000,00000000,00000000,000E1025 30: 00000000,000000A0,00000000,00000000 40: 80808092,80808080,80808080,80808080 50: 00020805,00000000,31111000,00000000 60: 00080008,00080008,00080008,00080008 70: 00080008,00080008,00080008,00080008 80: 00000000,00000000,0000008F,00000000 90: 00030003,08010061,00001955,00380A80 A0: 00200002,1F000217,00000104,00000000 B0: 00000080,00000030,00000000,00891020 C0: 11504044,00000800,0000C200,00000000 D0: 0E002802,33000003,B53109AF,7F060001 E0: 00000000,00000000,252D232E,00000007 F0: 00010000,8030FC74,00000F38,00000000 configspacemask= 70: 000ff000,,,abcd F0: 12345678,9abcdeff Software Requirements SoftPCI v1.2 or later.  Installation Procedures Script support is provided when SoftPCI is installed.    Logging Mechanism Error logging has yet to be implemented but the plan is to have a log file generated that reports any problems that are encountered in the script file parsed. Test Components (Modules) %sdxroot%\base\testsrc\pnp\pcisim\softpci\SoftPCI Specification.doc   The individuals responsible for reviewing and/or approving this proposal should indicate they have done so by putting their name on the line below. Developer: ________________________________________________________ Development Lead: ________________________________________________________ Test Developer: ________________________________________________________ Test Lead/Manager: ________________________________________________________ Program Manager: ________________________________________________________ sbQb@ vpv_v_vTpNpNp gd-qK ucucucucucucuR yhyWyWy yhyhFh wof^QDQ tctctRt  m\K\:\ gdtNv xnaTaLDL gdtNv gdtNv yky]ykLy>y gdtNv xtfYOt gdtNv
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\softpci specification.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Internal Test Specification Template TitleTest Specification Template Vincent Geglia Brandon Allsop Microsoft Word 10.0urn:schemas-microsoft-com:office:smarttags PlaceType urn:schemas-microsoft-com:office:smarttags PlaceName urn:schemas-microsoft-com:office:smarttags place g.8gt$( n" 4g#]N MsdX~y F(+i4e' JHyFB $M7B# r.CW" ^F_Lm>j+ #z=s[ S5pwk iTQtql )b~Al3 )oCwZ IDATx^ H!)Y%$ ta9|( I/paDo =OSD\- pTy"z ):ZITV0 V6MSMO {RTh& )9=]$ )9%fe ?*ejW-6 L+=+' P:Jc* 4MI8e }&+=M d8dS>e< ,~:9= *A<Es PnB)& ,<wgt< J!/=% <l).c rnC)` ,$muKEm W~p5>{.> 8AG, p2 ysraYB sY3)9 3L%?Qo 1:T_r "1S6C#g ]@7UX]xBo $]E)W 0MC]c wwS:J% /DQw-I zbI\q fFsJu bYnKi y6!EU pPE!  DnelS Omel2H ^N[1i s_DOQ"[ D:inzJ ]"StQw EaD~3 D1QXO cPzD"| 9nG(0% 2L)K) 9G2cF  zEEm [7}Jz .}3}^aW> .g$SWu9 -(Y(( =.*Vk QI8R/" c9=s6<` Gpp!" `xc-= 4MI8e /ov.o ClQ-N aQL>h fKY+,\ ^N[1i s<r.J\w' 4aW;2 z/mB0- ,V9C# 4R6F[y C_T$l ,;`cRK d:CW9 #I[uE 2Z.+qDy I"YEo Dq+y> -oTQ~ )6ebE W*s#d b3:SK .Y(x*3 uN>}T wHC[- gqF1; {"d9( lE-la /ov.o y6!EU (LqI$ lp/el tkzRG) \r[^N |2Lbo@ {S(%L _)fkB ?T.tg PyVQ, lY7wO \|&w<! R]PxjA "q4<`t 80c]l xyrP, =:8%(> =[)UL fU35c JT\c1 lp/el W~p5>{.> #kvtE S|#G}X 1-!'fl) ;2|.GJeY 2Z.+qDy wS9MR lp/el {>7u[ (lnu_ .lvk\ /ov.o "q4= % IYs(i' ^@n_|*_ hz@J> 4R6F[y lp/el 5c3(_ @L[S> `xc-= nEW/& 2LDls :F7(v!W DrH/@ Dq+y> Lk.3> 1A%2g C_T$l ^N[1i s?n#ec 5c3(_ 2LtdJ 34B4pQ% SmjLNYy )0}FL/ "q4= % g1"G);)/ /ov.o XL[S> Y9C#$ \GCKxb `xc-= BV6blE .pwuO h-j06 K'oqvtuYpx[W q;{4)t |O]]R Q*D]X x$>7u /ov.o "q4= % XL[S> h*^o4XN;T 6dZ+k ^N[1i 'WJe_tk hsIF! +z:GNhy JY3)M '9C#$ SS2:Ja 1^o4XN !!wxYy XsL;} ^N[1i ,;`cRK 2LtdJ xIO#ec bD6(;)/ ^N[1i @`J`Y T]1<A b}7yv QSIDATx^ ^xL^X k*Wvn\ }Z'Iw T>UC? jJvl? l[96} T-[3BE KD+cjPi% @x\EG szLwo ;g#&jEwa n_v&"  `$Pd W^rY4 Y}L[t #6@a\ %)""r8 ['Ou: vYvXJ u;r[^M xI,7Q! `hcDi *BuWk5 By~P?Vf Aq26^ t[kn0 LG/#.4 5|r<6 `RJdef er+L0 .tOui ek.~V s9+ctR N0e6< fD|F? `\N#3[ zaF8a d\_7cs=( &6JCY L7(6gN" +6Ex) ;7}}T ~<Dsa< EXPJyDs Da_Mx 5|rVO ]Isfd N@WHEk wi;]* [X[c+E X2\*) gA/dP gc-M) LG/#.4 :r=uC \t!O[ 6}%"V 13^~.+ RY$B2^ h}Ehy =%QgL }FU)Q Jn3B} :L#^ca E7JCY _5OAx fs%VF k0-aG #%Uf|+ri ^luO5 Ea.C&\ (Q_zenY }8r12{ [9^QM PibNV s,/;I 5|{l4 C^-lI IDATx^ lg;vR 4EtYa wnAnBi z9?)i >RpoE 1m2db s4gq|z Wt~}= GN\ Wd Z7^nM A<K<? 2B5s1 )bi[HP A)`,/ j+cSn S~U<7J pAWwnU sfCm) Z&Z#Jlq?m x%luO ip4~emt a~yu]Vn t@dYgF =+7$Ww7 (M:){ V=mBh< {YoHw)o 4I,V;BR 3F8z+ yS"~^ PYqf# hW4*, h5y?h h5y?h gAsC^ E[-.` GSfg}- =zd4K D*a\E+  n5y?h!4 B<;GI >8~cv w1.E:U 6pm'O *eBh< 25nc' WQE>"  =k]C l\={u b=V1b X_V2w7 7[]c- J]Q&3 \7.C# /4shJ Dgym2 n5y?h!4>@ s4gq|z 2FQ}w "P:BqF9 *1wY"T a2ox> S[=Lp~ j5y?h!4>@ {F#rw2[ ZA@lV |<}_Oz Cvc]< ^K1Rf 6vtV( x.*eI "2I9A [On9~X P8J`* p5sMB GEhTW W~U,g }$C<; Xh|\qo(q $:C?mrt 0d1}f pU) c G|YS:f+ piQzAo Q%og+* @vOtY n3n{z XEqLh <g"&CA  xIy%@? oo%IR 1Su<" w:f/vo 8[tg(G :k;9v 9W19; ?eeUj 5wLc;Q zdV",9^,h qov8s ,/#wV Z6grAkBaytd oluNu 7$Hfv .+Stu~ EnY1o xbnm= 2FUi< Sqtw6 V'=ww oQ]6+ }aJaq Z/i<b !4>G8 FOwF9 jkbq[ (){n\B )PJ.I cU4g\ ]]hE- mlK_o )8_d> yo{tg ?~eg1: k+E`I AnV7NL1 !4>G8 lrz}=J ;yQAV E]#%[ wNm#p 46m4N s'or'o~ mU(>p <g"&CA  0K?ki`w |c?cp GSFs}- 1k5y?h! }Fk-J 3('(BN< ~Mon) A[X)[ \!E_E 9/.by L#yGGw^ 7j.e: 7^c?o lb*U: GedsW w6w.c JG(sK +c6ve  _k .x IRenYz Wq\kPl oSC)C {gw]> 2{rm,/ _QK.l{/ GnYF@ LqzF8 55Xu6" @@&@Y !%{M=@ 6=?lQ sQ7I6; 3<hu) h|ula IDATx^ k@F%X ^*iUe s@@peD: TY(6  -?8{1T;J 8T.rQ g98hh p&)B` G@</6{:b c.%GC*$ !`@ ] <~C|>9 cii)_ U!q&1B G `D=@@  AB g !xD^r! )/.*VY ,#/=1 \GIOk |K|> Eza gUb-4 #ad"h2 Hiofm #>+7s{ QD1bPC =l1wa ^s\Zk:> *rmWd i{qiE H=qbb yOA4NE dE*QO qs+ho 6/E>mr JZ}D6n [Wbv$ S|^ic EcCUZ _!_9_YX iWZXg )R.#@ vb%XQ 1CFiI$ X4qY[g =!^UZ z@^Yi oy;_y [v_:] QBB 3 fqE8m >3W~d0!0 ^aG+>L $"K&rV* wvh`%  w!rg FdX0Yp M+r_4 mzD/C V^)9G g1k!y yPLTE IDATx xbeo2 M[{[- im($kYm 4nK)V rz`oz }V[?k ^o{{{ lifijnj WM"UN3la v[SU{ 5)Mfk 7%w=a jPLTE IDATx /6;;;) l1Yg_;yJyh a)Xy`~~^ {gn`=Q &uW0e wV*cc s?a?r ?#/vY CYo*U ~dx/}g3 e5em+ ES^Vo gYC#Z |ku&g m\}+s A}k"V ;-.W%N IDATx /2P+X WkrrZ 5'3?Lu 'LqR> SWoSg IDATx ~}~}O> ?A:/z {jffvj &}-yeq u5gKw }c1&s 9's9s `QEWw p-4uwPicture (Metafile) StaticMetafileMicrosoft Word Times New Roman Microsoft Word Times New Roman Microsoft Word Times New Roman Microsoft Word "Arialbjbjk EMBED StaticMetafile Windows Operating Systems SoftPCI Test Specification BrandonA Feature Overview SoftPCI is a test tool that provides the ability to simulate PCI hardware under Windows 200x.  Doing this allows for extensive testing of the PCI driver as well as general Windows PnP by giving us a means of creating virtual hardware configurations that may not be easily accessible otherwise. Timeframe This is an on-going development project but it is currently fully functional.  There are lots of improvements still to make moving forward.   Milestones Release Testing Strategy   Functionality Testing <Describe the testing approach for assuring the component is functional.> Robustness / Reliability Testing <Describe the testing approach for assuring the component is robust and reliable.  Also define robustness criteria> Compatibility Testing <Describe the testing approach for assuring the component is compatible with other components or hardware> Corner (Fringe) Case Testing <Describe the testing approach for covering Corner or Fringe cases.> Negative (Error Path) Testing <Describe the testing approach for covering Negative test cases, and error paths.> Regression Testing <Define which subset of tests will comprise the regression test suite> Test Architecture After the HAL/ACPI has detected and enumerated a root PCI bus (PNP0A03), SoftPCI gets loaded as a lower function filter to the PCI root FDO.  Thereafter the following occurs: During AddDevice: Query for a PCI_BUS_INTERFACE_STANDARD interface in order to determine that we are indeed loading as a Filter DO and not an FDO. This is necessary because SoftPCI is also the FDO driver for all SoftPCI devices created. PCI.SYS is the FDO for all SoftPCI-PCI Bridges.  If FDO AddDevice, create the FDO, attached to device stack and return. IF FilterDO AddDevice IoRegisterDeviceInterface() so user mode can talk to our driver. During StartDevice: If FDO, succeed IRP and return. If Filter DO : Wait for the IRP to come back up the stack from the PDO and then grab the bus number out of the CM_RESOURCE_LIST for the root bus we are filtering.  This will be used when dealing with multi-root bus systems in the future. Query the registry for any SoftPCI devices to load on this root bus, otherwise boot without any SoftPCI devices being present. This allows for persistent devices to exist across reboot should a machine need to be rebooted for some reason.  Registry format is currently as follows: [HKLM\CCS\Control\SoftPCI] \FFxx\yyzz\Config Where xx is the root bus, yy is the device number and zz is the function number of the given device.  Note:   is used for the first entry to denote a root PCI bus and not an actual PCI device.  Config is a REG_BINARY key containing the contents of the devices Current, Default, and Mask buffers. At this point SoftPCI is loaded and filtering the stack.  Now when PCI sends down a query for PCI_BUS_INTERFACE_STANDARD, SoftPCI waits for it to come back up the stack and then replaces the configuration space read/write functions provided by the HAL/ACPI with private functions existing in SoftPCI.  From this point forward any attempts by the PCI driver to read configuration space will go through SoftPCI s private routines and SoftPCI can now decided to return either   configuration space in response.  The PCI driver deals with the returned configuration data the same regardless of source and this is how SoftPCI devices come to exist. SoftPCI UI The following is an example of the current SoftPCI UI.  As you can see it provides a tree view of only PCI hardware (both real and virtual) that is present in the machine. As the user changes selection in the tree the TAB information on the right is updated to reflect information about the current selected device.  The  Resources  tab displays the current allocated resources for the selected device. The ConfigSpace tab will display the current values for the devices config space. Only  Virtual  or SoftPCI created devices will contain a  SoftPCI Mask .  The Mask is used to tell SoftPCI which bits in a given virtual devices config space are writeable.  It is treated like a very large bit mask where any bits that are set are considered writable and can therefore be changed from 1 to 0 or visa versa.   For more information and examples of how the Config Mask works see the SoftPCI Scripting Engine Specification. One method of creating a SoftPCI device or bridge is to Right-Click on a given bridge or   and select  Install Device Here   This will display the following Install Device dialog: From here you can choose which type of device you would like to install.  Currently only the first 3 options are supported/implemented.  Selecting a device from this list will install a  SoftPCI  default device with the following Vendor and Device Ids: DEVICE   -  Microsoft SoftPCI Device . VENID = 0xABCD, DEVID = 0xDCBA PCI BRIDGE  Microsoft SoftPCI-PCI Bridge    VENID = 0xABCD, DEVID = 0xDCBB HOTPLUG BRIDGE   "Microsoft SoftPCI-HotPlug PCI Bridge"  VENID = 0xABCD, DEVID = 0xDCBC Cardbus devices and bridges have not been implemented yet. Selecting  DEVICE  will give you the following options.  Here you can basically only manipulate whether or not he device has  Decode  bits enabled by default and the type/size of the Base Address Registers (BARs).   The BARs are used to describe what resource type and size the device decodes.  You cannot specify a default range or  boot config  using the current version of this UI.  This can be done using the Scripting Engine.  In the example below the 1st and 3rd BAR have been activated and they have been set to a desired length.   In this case we are saying that this SoftPCI device decodes both IO and Memory.  When this device is installed Windows will arbitrate 128 bytes of Memory and 32 bytes of IO and assign it to the device. It is not required to implement any BARs if you do not wish the device to be allocated any resources.   MEM = Memory Bar IO = IO Bar PF = Memory Bar that is Prefetchable 64 BIT = This is a 64 bit Memory BAR.  When this is selected the next BAR will be greyed out and disabled.  This is because by default each BAR is 32 bits in length and per PCI spec if you need to decode more than a 32 bit address then you have you use 2 BAR slots to describe the full 64 bit BAR. Selecting  PCI BRIDGE  from the device type list will result in the following dialog.  Here we are given some of the same options as a  DEVICE  but we are limited to only 2 BARs.  We also have a new option of installing a bridge that is considered to be  Subtractive  decode.  This type of decode attribute designates that the bridge decodes all resource ranges that it sees.  Therefore a bridge that is subtractive decode will not have resources  bridge windows  assigned to it.  By default bridges are considered  Positive  decode which means they are assigned a specific Memory and IO range or  Window  that they will decode an any address outside this range is ignored.  You cannot specify the size/value of a bridges decode window using the current UI. -INSERT HOTPLUG SCREEN SHOTS AND DESCRIPTIONS HERE- SoftPCI Scripting Support See separate script engine spec located at:  %SDXROOT%\base\testsrc\pnp\pcisim\softpci\SoftPCI Script Engine Specification.doc Software Requirements Windows 2000 or later for free (non-debug) builds of SoftPCI.  WinXP or later is required for debug builds to work. Installation Procedures Currently SoftPCI is installed by running SoftPCI.exe and then selecting  Install SoftPCI Support  from the  Options  menu.   Command Line Switches /S:<Script File> -  This will cause SoftPCI to parse the specified file for devices to automatically install. /I -  Installs SoftPCI kernel mode (driver) support  (CURRENTLY NOT IMPLEMENTED) Logging Mechanism Currently there is no logging  Test Components (Modules) Test Component #1   SOFTPCI.EXE This is the GUI application used to manipulate everything PCI related in the machine.  It provides a  Device Manager  style tree view of only PCI hardware in the machine.  You can install pre-defined SoftPCI Devices, Bridges, and Hot-Plug Bridges. Test Component #2   SOFTPCI.SYS This is the kernel mode counter part and is responsible for creating and maintaining the  Virtual PCI  world that is exposed to Windows. Test Component #3   HPSIM.SYS This is the SHPC (Standard HotPlug PCI Controller) simulator driver (developed by DWalker) and is responsible for simulating the upcoming hotplug controller functionality. Test Interfaces Interface #1  I have considered making the IOCTLS (or even better moving to WMI) public such that others would only have install the SoftPCI driver support and then they could write their own UI to do what ever they wanted.  If this would be useful I should have a problem doing it. Test and Development Cases Check-in Validation Anyone making changes to PCI.SYS or any other kernel mode component that may have an impact on how PCI behaves can use this tool to validate their changes in a heavily populated PCI environment before actually making a potentially bad check-in.   PCI PnP Stress Testing By taking literally dozens of PCI devices and bridges that get created and removed, and all with potentially varying resource requirements, we can pretty much stress test our PCI Driver (and PnP engine) more thoroughly than we ever could with real hardware.   OS Feature Development Example of this would be as follows - Multi-Level Bridge Rebalancing development of multi-level resource rebalancing / partial arbitration by creating every possible (and possibly even some that may not be physically possible) PCI configuration required to simulate a given resource scenario. PCI Hack Flag validation Create as many devices as possible that meet a given hack flag criteria to ensure the proper work around is in place.  This would probably be a good one to go along with the check-in validation to ensure changes don t break existing workarounds. Result Interpretation <Describe how results should be interpreted> Regression pass result criteria Full test pass result criteria Approval and Signoff The individuals responsible for reviewing and/or approving this proposal should indicate they have done so by putting their name on the line below. Developer: AndrewTh, DWalker_______________________________________ Development Lead: AndrewTh_______________________________________________ Test Developer: BrandonA________________________________________________ Test Lead/Manager: WillemV_________________________________________________ Program Manager: JonSm, ArieV_____________________________________________ gd2"t gd2"t {wn[n[n[n[nRn gd2"t gd2"t gd2"t
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\test.ini ===
;       SOFTPCI Device Installation Script
;
;       For more details on SoftPCI Scripting support see 
;       "%sdxroot%\base\testsrc\pnp\pcisim\softpci\SoftPCI Script Engine Specification.doc"
;
;
;       
;       INSTALL - This section designates the list of devices to be installed 
;
;       Type - "Device"   - SoftPCI Device. VENID = 0xABCD, DEVID = 0xDCBA
;              "PPBridge" - SoftPCI-PCI Bridge. VENID = 0xABCD, DEVID = 0xDCBB
;              "HPBridge" - SoftPCI-HOTPLUG Bridge. VENID = 0xABCD, DEVID = 0xDCBC
;              "CBDevice" - SoftPCI CardBus Device. VENID = 0xABCD, DEVID = 0xDCBD  (NOT CURRENTLY SUPPORTED!)
;              "CBBridge" - SoftPCI-CardBus Bridge. VENID = 0xABCD, DEVID = 0xDCBE  (NOT CURRENTLY SUPPORTED!)
;              "Private"  - User defined configspace for all registers
;               
;               Note: For all types other than "Private" any "ConfigSpace=" or "ConfigSpaceMask"
;                     offset not explicitly modified will be defaulted to values as defined in 
;                     the SoftPCI Specification. If using "Private" then user must provide all required
;                     registers in order to complete device install. Examples are Vendor ID, HeaderType, and 
;                     BaseClass/SubClass.
;                     
;
;       Slot -  The Device and Function number of the device. Example 0501 = DEV 5 FUNC 1
;               If not specified then next available DEV number will be used and function 0 will
;               be assumed. Function numbers higher than 0 will fail install unless function 0 already
;               exists.
;
;       ParentPath -   Path to the desination of "Slot". The "Slot" itself is not
;                      included in this path. If path doesnt exist first root bus is assumed.
;                      Must specify FF for the device number when specifying the root bus. The function
;                      number for Root buses is treated as the bus number for that root bus.
;
;                       Example:  FFXX\DEVFUNC\DEVFUNC\....   
;                                 FF00\0200\0501       <--- Place a device specified by "Slot" behind bridge
;                                                           located at 0501 (which is behind bridge 0200 on root 0).
;
;       ConfigSpace - Specifies the OFFSET: VALUE, VALUE etc.  OFFSET can be on any boundary (BYTE, WORD, DWORD) and
;                     value size will be determined autmatically.  You can specify up to 4 values on each line separated
;                     by commas.  Each comma will increment the offset by a DWORD (4 bytes).
;
;                       Example:  3C: 0b                <-- here we will be updating one single byte at offset 0x3C.
;                                 3C: 0000000b          <-- here the entire DWORD at 0x3C will be updated
;                                 E0: 000b, 0000a0b0    <-- here we modify WORD at 0xE0 and DWORD at 0xE4
;
;       ConfigSpaceMask - Specifies the OFFSET: VALUE, VALUE etc.  Bits set in these registers
;                         indicate bits that are writeable in the devices ConfigSpace.
;

[SOFTPCI]
Version=1

[INSTALL]
device2
bridge1
bridge2
device3
device4
bridge3
SomeCoolPrivateDevice

[device1]	
Type=Device
ConfigSpaceMask=
00: FFFFFFFF,FFFFFFFF,FFFFFFFF,FFFFFFFF
14: FFFFF000

[device2]
Type = Device
Slot=1600
ParentPath=ff00
ConfigSpace=
04: 00000007
50: 00f20000,00000000,00000000,00000000
70: 00000000,ABCDEFFF,00000000,00000000
f0: 00000000,00000000,00000000,00000001
ConfigSpaceMask=
04: 00000007
10: ffff0000,00000000,ff01,00000000
9c: 00000008
fc: 00000001

[bridge1]
Type=PPBridge
Slot=0b00
ParentPath=FF00

[bridge2]
Type=pPBridge
Slot=0100
ParentPath=ff00\0b00

[device3]
Type=Device
Slot=0000
ParentPath=FF00\0b00

[device4]
Type=Device
Slot=1200
ParentPath=ff00\0b00

[SomeCoolPrivateDevice]
Type=private
Slot=0300
ParentPath=FF00\0b00\0100
ConfigSpace=
00: 25308086,20900006,06000002,00000000
10: D0000008,00000000,00000000,00000000
20: 00000000,00000000,00000000,000E1025
30: 00000000,000000A0,00000000,00000000
40: 80808092,80808080,80808080,80808080
50: 00020805,00000000,31111000,00000000
60: 00080008,00080008,00080008,00080008
70: 00080008,00080008,00080008,00080008
80: 00000000,00000000,0000008F,00000000
90: 00030003,08010061,00001955,00380A80
A0: 00200002,1F000217,00000104,00000000
B0: 00000080,00000030,00000000,00891020
C0: 11504044,00000800,0000C200,00000000
D0: 0E002802,33000003,B53109AF,7F060001
E0: 00000000,00000000,252D232E,00000007
F0: 00010000,8030FC74,00000F38,00000000
configspacemask=
70: 000ff000,,,abcd
F0: 12345678,9abcdeff
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\scrubber\scrubber.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Scrubber: Design and Maintenance TitleScrubber: Design and Maintenance Jason Cobb Normal.dot Jason Cobb Microsoft Word 10.0Scrubber Tool: Design and Maintenance All of the Windows NT-based operating systems, including Windows 2000 and Windows XP and .NET, have a limit on the size of the registry system hive.  If the system hive grows above this limit then the system will not boot.  InMB Windows 2000, there was 16 megabytes of memory available at boot time. In this 16 megabytes, the SYSTEM Hive, Page Frame Number (PFN) database, loader, kernel, HAL, and boot drivers must load. Windows .NET increases the size of the memory available at boot time for the system as follows: Windows .NET (32-bit) is limited to a quarter (1/4) of available memory up to 1GB.  Windows .NET (32-bit) with the /3GB switch is still limited to the 16 megabytes.  Windows .NET (64-bit) has been increased to 32 megabytes.  Additionally, Windows .NET has a safe-guard built in that won t allow the system hive to grow larger then system memory; it accomplishes this by failing all future registry writes.  By far the largest consumer of the system hive is Plug and Play (PnP).  PnP stores information about each piece of hardware, along with their corresponding driver and device interface information, in the system hive.  This includes the device s hardware and compatible IDs, description, manufacturer, provider, the INF that was used to install the driver, the setup class of the driver, and other information.  PnP stores this information in the system hive not only for live devices (devices that are currently present on the machine), but also for phantom devices (devices that were once in the machine but are not currently).  PnP has to remember information about phantom devices or else it would need to search for drivers every time the device was enumerated again.  On certain large server machine configurations, these phantom devnodes can consume so much space that they will push the system hive over its size limit.  This happens when companies add and remove huge cabinets of disks for backup and maintenance.   The purpose of the scrubber tool is to clean out the phantom devnode information for devices of class GUID_DEVCLASS_DISKDRIVE and GUID_DEVCLASS_VOLUME.  The code can be easily modified to handle additional classes simply by adding additional classes to the ClassesToClean array.  To clean out the registry information for these phantom devnodes, the code simply enumerates all the devices of the classes specified in the ClassesToClean array by calling SetupDiGetClassDevs.  If the DIGCF_PRESENT flag is not passed to SetupDiGetClassDevs then it will include phantoms in the list.  Scrubber then enumerates the devices in this list and checks if they are a live device or a phantom.  To determine if a device is a phantom, Scrubber simply calls CM_Get_DevNode_Status on the devnode and if the return code is either CR_NO_SUCH_DEVINST or CR_NO_SUCH_VALUE then the devnode is considered a phantom.  For all phantom devnodes Scrubber calls SetupDiCallClassInstaller with DIF_REMOVE to clean up all traces of this devnode from the system hive.   The above description works fine on Windows XP and beyond, however it doesn t clean up all the registry information on Windows 2000.  Due to a bug in Windows 2000 only the device s hardware and software keys get cleaned up, but the device s device interface values do not get cleaned up.  Since the device interface values can get quite large, Scrubber needed special code to manually clean these up in Windows 2000.  To clean up the device interface values in Windows 2000 Scrubber enumerates through the array DeviceInterfacesToClean.  This array contains the following device interfaces: DiskClassGuid, PartitionClassGuid, WriteOnceDiskClassGuid, VolumeClassGuid, and StoragePortClassGuid.  Other device interface values can easily be added by adding the new device interface GUID to the DeviceInterfacesToClean array.  For each of these device interface GUIDs, Scrubber calls SetupDiGetClassDevs with the DIGCF_DEVICEINTERFACE flag and passes in the device interface GUID and the phantom devnode.  It then calls SetupDiEnumDeviceInterfaces to enumerate through the device interfaces and SetupDiRemoveDeviceInterface to remove them from the system hive. The reason that Scrubber only cleans up disk and volume devnodes is because that is the only real customer case we have seen of phantom devnodes taking up so much space that the system hive is at its limit.  Deleting all phantom devnodes on the machine can be very dangerous and can cause unknown problems and maybe even a bug check.  Because of this, any new device class that is added to Scrubber must be thoroughly tested to ensure that no adverse behavior occurs.  There are known devnodes like the ROOT devnode that always show up as a phantom.  If this devnode is deleted from the system hive then the machine will not boot. Once the phantom devnodes are removed from the system hive the registry system hive needs to be compressed.  This is very important, since the registry does not compress its empty space when a key or value is removed.  Therefore if the registry is not told to compress then there will be no space savings.  Compressing the registry varies from Windows version to Windows version.  To compress the registry in Windows 2000, RegSaveKey must be called on the system hive.  This will save the entire system hive to a file on the disk.  When the registry is saved as a file, all empty space in the registry will be removed, thus shrinking the hive.  To get the shrunk hive to load again the RegReplaceKey API must be called.  The registry is not replaced until the machine is rebooted. It is important to reboot the system immediately following the call to RegReplaceKey since any subsequent updates to the system hive will be lost once the system is rebooted and any later call to RegReplaceKey is ignored. On Windows .NET, a new system call has been added, RegCompressKey, which allows inplace registry compression with none of the side effects or RegReplaceKey; it is safe to call at any time. The operating system also will attempt to compress the registry on shutdown if it determines that there is greater than 10% free space in the uncompressed system hive. Building the Scrubber Tool The scrubber tool lives in the Windows XP source tree under nt\base\pnp\tools\scrubber.  It should be built using the Windows XP version of the DDK and SDK. File List makefile precomp.h scrubber.c scrubber.h scrubber.rc sources Microsoft Confidential Page   PAGE   DATE \@ "M/d/yyyy"  10/3/2001 gd/K@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\goliath.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Lanworks Modules Title _PID_GUIDModules Normal Microsoft Word 8.00u{nn vDzr~ @%#;_JFvCorelFLOW C:\My Documents\goliath.cfl1C:\COREL\OFFICE7\BONUS\flow\smartlib\Patterns.ssl 1C:\COREL\OFFICE7\BONUS\flow\smartlib\Pattfill.ssl 0C:\COREL\OFFICE7\BONUS\flow\smartlib\Arrowhd.ssl COmsLayer Layer1 COmsFilledShape COmsGroup COmsGraphicAttributes COmsConnector DDDH| COmsName Process COmsShadow COmsRoutingAttributes COmsOutline  COmsFill, DDDH| DDDH| fjAXJ DDDH| DDDH| (jAXJ DDDH| DDDH| COmsRectangleM /4DjAjCN /4DjA /4DjAjCN /4DjA DDDH| Guides COmsGridLayerr Arial AvantGarde Bk BT CommonBullets Swis721 BT Default Paragraph Text WFillHandle WRefCountFill WOutlineHandle WRefCountOutline Default Paragraph Text Default Artistic TextBuilding Goliath Goliath is built from several independent binary modules. Each module is a resource in the DLL for the RBFG.  The modules are combined together by the DLL and copied to the disk as a single file. Tools Goliath is built with the following tools: Borland TASM v3.1 Borland TLINK v5.1 Borland MAKE MASM 6.1 NMAKE EXE2BIN Lanworks CHECKSUM utility (included in \goliath\bin directory) The physical layout of the Goliath boot file is shown in the following figure: The single file supports multiple adapters by having multiple UNDI s and NAD s for all the supported adapters.  The UNDI s contain only adapter specific code and use the common BootWare module for the TCP/IP and PXE functions.  The NADs contain both the adapter specific and common BootWare code. The loader as a table of the starting offsets within the file for each UNDI and NAD.  At boot time the loader checks the PC for a supported adapter and loads the appropriate UNDI or NAD.  This table is built by the Remote Boot Floppy Generator (RBFG) Program when it creates a boot floppy.  Modules BOOT sector Description: Floppy boot sector.  Loads first 512 bytes of  GOLIATH  file Passes control to start of file, the  loader Directory: \goliath\bootsec To build: a.bat file Dependencies:  Tools: TASM, TLINK, EXE2BIN Loader Description: Start of GOLIATH file.  Loads the remainder of the file into memory Loads the language file (if there is one) into top of memory. Determines the type of adapter installed If there is a UNDI for the adapter, it is relocated below language file at top of memory, then the BootWare module is located below the UNDI. If no UNDI is available the complete NAD is located at the top of memory. Passes control to BootWare or NAD module. Directory: \goliath\loader To build: a.bat file Dependencies:  Tools: TASM, TLINK, EXE2BIN BootWare Description: Common, adapter independent, TCP/IP and PXE module for UNDI supported adapters. Directory: \goliath\bootware To build: makefile file Dependencies:  \goliath\bootware\ai - adapter interface module \goliath\bootware\pxe - PXE API module \goliath\bootware\tcpip - TCP/IP module \goliath\bootware\common - common functions an print routines Tools: TASM, TLINK, EXE2BIN, CHECKSUM Description: Adapter dependent modules.  Each UNDI supports one adapter chipset. Directory: under \goliath\undi To build: Each UNDI has a batch or make file. Dependencies:  various Tools: varies, some UNDI s use TASM, some use MASM and some a combination of booth Description: Complete adapter dependent and BootWare modules.  Each NAD supports one adapter chipset. Directory: under \goliath\nad To build: Each NAD has a batch or make file. Dependencies:  various Tools: varies, some use TASM, some use MASM and some a combination of booth Author:   AUTHOR   Cowan  PAGE   DATE  11-Mar-98  EMBED CorelFLOW.Diagram.3   0u{nn vDzr~ @%#;_JFv
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\remoteboot\bootfloppy\src\language\strings.txt ===
Strings common to all adapters
-----------------------------

BootWare Goliath v0.99 (30Oct97)

NTLDR: I/O error reading disk..      Please insert another disk

This is not a PCI PC!

No supported adapter found!

(C) Copyright Lanworks Technologies Inc. 1987-1997. All rights reserved.

NT remote boot floppy

Press a key to reboot system.

BOOTP

DHCP

BINL server

Server:

Local:

Transferring

Not enough extended memory for image.

Too many retries

File transfer error:

Image file too large.

Transmit error

SMC9432 adapter
---------------

SMC EtherPower II 10/100 9432 v1.1 (970910).

Initializing SMC EtherPower II Adapter

Error: Unable to read configuration from adapter.

Error initializing adapter

Adapter is improperly installed or not connected to the network.

Could not find SMC EtherPower II adapter.

Media: 10Base-T

Media: 100Base-T

Error reading SMC 9432 EEPROM

Intel strings
-------------

Intel 82557-based Ethernet LAN Adapter v3.10   (970625)

Initializing 82557 based adapter.

Configuring Ethernet Adapter

Press <F1> to continue

Unable to find adapter.

Initializing BootWare...

Found Adapter

The network driver could not detect a PHY at the specified address...Try re-loading the driver without specifying the PHY address or..check the PHY address...

The network driver could not detect a cable link...Auto-negotiation will remainenabled and thespeed will be determined at link time...

The network driver will use the82503 10BaseT front-end...

The network driver detected a link on MII PHY at PHY address 0...It will isolate PHY 1 (if present) and put PHY0 in Normal mode

The network driver detected a PHY supporting 100Base-T4...Full Duplex is not supported for thisPHY and the override was ignored...The network driver will default to auto negotiation mode...

Cannot find an EtherExpress(TM)PRO/100B adapter...Cause  : A previous version of the EtherExpress(TM) PRO/100 a dapter..  was found in this computer. This adapter does not support the..  driver you are trying to load...Action : Use the driver on the Intel Configuration and Driver disk that ..         shipped with this adapter...

Cannot find an EtherExpress(TM) PRO/100B adapter...Cause  : The following are possible causes :..1. The system does not support PCI bus...2. The PCI adapter may not be properly installed in the slot...3. Some of the PCI adapter resources in config space may be invalid..   because the PCI BIOS could not allocate the resources...Action : Check for possible errors listed above, run adapter diagnostics,..         and if the problem persists, contact your network supplier...

The network adapter failed self test...Cause  : The adapter failed to respond to a self test initialization command...Action : Run adapter diagnostics to verify that the adapter works properly...

The network adapter did not receive the proper resources from the PCI BIOS...Cause  : The PCI BIOS was unable to assign some of the resources requested by the adapter...Action : Remove some PCI devices from machine to see if resources get allocated...         If problems persist, contact your network supplier...

Illegal node address : multicast address format...Cause  : The node address of the adapter has a multicast..         address format, where the least significant bit of..         the most significant address byte is a 1...Action : Specify a unique node address override using the NODE parameter..         in NET.CFG or on command line...

 Illegal node address : all zeroes...Cause  : The node address of the adapter contains all zeroes...         This is not a valid ethernet address...Action : Specify a unique node address override using the NODE parameter..         in NET.CFG or on command line.

Unable to configure the network adapter...Cause  : The network adapter did not respond to a configuration..         command during initialization...Action : Verify that the adapter is properly installed in the..         slot. Verify that a terminated cable is connected to..         the adapter. If the problem persists, run diagnostics

Unable to set up the node address of the adapter...Cause  : The network adapter did not respond to a node address set up..         command during initialization...Action : Verify that the adapter is properly installed in the..         slot. Verify that a terminated cable is connected to..         the adapter. If the problem persists, run diagnostics

EEPROM checksum was incorrect...Cause  : The installed EEPROM may be bad...Action : Replace the EEPROM and try loading the driver again

checksum error

3Com 90x strings
----------------

3Com 3C90X EtherLink PCI v3.01 (971017)

Reboot system for changes to take effect

Ethernet card improperly installed or not connected.

Transmit error

Could not find 3C90X

Only ROMSize of 64K is supported

Newer BootWare version is available for this adapter

New EtherLink found. Need new BootWare version.

Unable to update BootWare 3C90X. Configuration changes are not saved.

BootWare Update verification failed.

Update Successful (00)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\sc\scdev.txt ===
USING SC.EXE TO DEVELOP WINDOWS NT SERVICES  
January 1995

(From MSDN Library, July 1996)

A little-known command-line utility, SC.EXE, can help you develop your services for Microsoft Windows NT. SC.EXE, which is provided in the Win32 Software Development Kit (SDK) MSTOOLS directory, implements calls to all of the Windows NT service control application programming interface (API) functions. You can set the parameters to these functions by specifying them on the command line. SC.EXE also displays service status and retrieves the values stored in the status structure fields. The utility also lets you specify the name of a remote computer so that you can call the service API functions or view the service status structures on the remote computer.

This article describes how to use the SC.EXE utility to obtain detailed information about Windows NT services. For more information about developing Windows NT services and for detailed reference information about the Windows NT Service API functions, such as ControlService and QueryServiceStatus, see the Win32 SDK documentation (Development Library, Product Documentation, SDKs).

SC.EXE is a development tool that provides more detailed and accurate information about services than the two end-user utilities that are provided with the operating system. The Services Control Panel application and the network command-line interface, NET.EXE, can tell you that a service is running, stopped, or paused. These tools are fine for completely debugged and running services when everything is going smoothly. But when things go wrong, as sometimes happens when developing new code, the information provided by these tools can be misleading.

For instance, if during the development stage your service hangs in the start-pending state, the Control Panel and NET.EXE report its state as running. If the service hangs when in the stop-pending state, NET START reports the status as running, and the Control Panel reports it as stopped. If you then attempt to start it, the Control Panel tells you the service is already running. This can be quite confusing.

SC.EXE lets you query the service status and retrieve the values stored in the status structure fields. The NET.EXE program and the Services Control Panel application don't provide the complete status for the service. The SC program, however, will tell you the exact state of the service as well as show you the last checkpoint number and wait hint. The checkpoint can then be used as a debugging tool because it provides a clear indication of how far along the initialization had progressed before the program froze.

SC.EXE also allows you to call any of the service control API functions and vary any of the parameters from the command line. This offers several advantages to the service developer. For instance, it provides a convenient way of creating or configuring the service information in the Registry and the Service Control Manager's database. The developer doesn't have to configure the service by manually creating entries in the Registry and then rebooting the machine in order to force the Service Control Manager to update its database.

As a command line program, SC.EXE can also be used to create tests for your service. You can create batch (command) files that call SC.EXE with various parameters that control the service. This is useful if you want to see how your service behaves when it is repeatedly started and stopped. If you have more than one service in your service process, you can leave one service running so that the process doesn't go away, and then repeatedly start and stop the other service while looking for evidence of memory leaks due to an incomplete cleanup.
The following sections contain reference information for the commands SC, SC QC, and SC QUERY.

SC

The SC command-line utility uses the following syntax:

Syntax1
sc [Servername] Command Servicename [Optionname= Optionvalue...]

Syntax2
sc [Command]

Use Syntax1 to run SC.EXE. Use Syntax2 to display help information (except for the "query" command--see the "Comments" section below for more information).

Parameters

Servername
Optional. Specifies the name of the server when you want to run the commands on a remote computer. The name must start with two double backslash characters, such as "\\myserver". To run SC on the local computer, do not supply this parameter.

Command
Specifies the SC command. Note that many of the SC commands require administrative privilege on the specified computer. SC supports the following commands:
  
Command	Description

config		Changes the configuration of a service (persistent).

continue	Sends a CONTINUE control request to a service.

control		Sends a control to a service.

create		Creates a service (adds it to the registry).

delete		Deletes a service (from the registry).

EnumDepend	Enumerates service dependencies.

GetDisplayName	Gets the DisplayName for a service.

GetKeyName	Gets the ServiceKeyName for a service.

interrogate	Sends an INTERROGATE control request to a service.

pause		Sends a PAUSE control request to a service.

qc		Queries configuration for the service. For detailed information, see the reference section, "SC QC."

query		Queries the status for a service, or enumerates the status for types of services. For detailed information, see the reference section, "SC QUERY."

start		Starts a service.

stop		Sends a STOP request to a service.

Servicename
Specifies the name given to the service key in the registry. Note that this is different from the display name, which is what you see with NET START and the Services Control Panel application. SC uses the service key name as the primary identifier for the service.

Optionname
The Optionname and Optionvalue parameters allow you to specify the names and values of optional command parameters. Note that there is no space between the Optionname and the equal sign. You can supply zero, one, or more optional parameters name and value pairs.

For a list of the available Optionname values, request help for the command by entering "sc Command", where Command is a valid SC command name, as listed in the Command parameter description above.

Optionvalue
Specifies the value for the parameter named by Optionname. The range of valid values is often restricted for each Optionname. For a list of available values, request help for each command. 

Comments

Many of the commands require administrator privileges, so it's a good idea to make sure that you are an administrator of the machine where the development is being done.

When you enter "SC" with no parameters, SC.EXE displays help information that lists the available commands. When you enter "SC" followed by a command name, you can get specific information about that command. For example, enter "SC CREATE" to get help specific to the CREATE command. 

The exception to this syntax is "SC QUERY", which dumps the status of all services and drivers currently running in the system. For help on the QUERY command, enter "SC", and respond to the prompt, "Would you like to see help for the QUERY command?" by entering "y" for yes.

When you use the START command, you can pass arguments to the service's main function. Note that the arguments are not passed to the service process's main function.

SC CREATE

The SC CREATE command creates an entry for the service in the Registry and in the Service Control Manager's database.

Syntax1
sc [Servername] create Servicename [Optionname=Optionvalue...]

Parameters

Servername
Optional. Specifies the name of the server when you want to run the commands on a remote computer. The name must start with two double backslash characters, such as "\\myserver". To run SC on the local computer, do not supply this parameter.

Servicename
Specifies the name given to the service key in the Registry. Note that this is different from the display name, which is what you see with NET START and the Services Control Panel application. SC uses the service key name as the primary identifier for the service.

Optionname
The Optionname and Optionvalue parameters allow you to specify the names and values of optional parameters. Note that there is no space between the Optionname and the equal sign. You can supply zero, one, or more optional parameters name and value pairs. The SC QUERY command supports the following values:
  
Optionname	Optionvalue
Description

type=		own, share, interact, kernel, filesys	
Type of service being created. Optionvalues include types used by drivers. (default = share)

start=		boot, system, auto, demand, disabled
Start type for the service. Option values include types used by drivers. (default = demand)

error=		normal, severe, critical, ignore
Severity of error if the service fails to start during boot. (default = normal)

binPath=	(string)	
Path name to the service binary file. There is no default for this. This string must be supplied.

group=		(string)
Name of group which this service is a member of. The list of groups are stored in the Registry under ServiceGroupOrder. (default = nothing)

tag=		(string)
If this string is set to "yes", SC will obtain a TagId from the CreateService call. However, SC does not display the tag so it's pointless to use this. (default = nothing)

depend=		(space separated string)
Names of services or groups which must start before this service.

obj=		(string)
Name of account in which the service will run. For drivers, this is the NT driver object name. (default = LocalSystem)

DisplayName=	(string)	
A string that can be used by user-interface programs to identify the service.

password=	(string)
A password string. This is required if an account other than LocalSystem is used.

Optionvalue
Specifies the value for the parameter named by Optionname. See the Optionname reference for a list of supported values. When a string is to be input, the use of empty quotes means that an empty string will be passed in.

Comments

The SC CREATE command performs the operations of the CreateService API function. 

Example 1

The following example creates a registry entry for the service named "NewService" on the computer called "\\myserver":
  
sc \\myserver create NewService binpath= c:\nt\system32\NewServ.exe
  
By default this service will be created as a WIN32_SHARE_PROCESS with a SERVICE_DEMAND_START start-type. It will not have any dependencies, and will run in the LocalSystem security context.

Example 2

The following example creates the service on the local computer as an auto-start service that runs in its own process. It has dependencies on the TDI group and on the NetBIOS service. Notice that you must add quotes around the list of space-separated dependencies.
  
sc create NewService binpath= c:\nt\system32\NewServ.exe type= own 
 start= auto depend= "+TDI Netbios"
  
Example 3

The service developer can run the service in the context of the kernel debugger by temporarily changing the binary path (image path) for the service. The following example shows how to call SC to change the service configuration:
  
sc config NewService binpath= "ntsd -d c:\nt\system32\NewServ.exe"
  
This example causes the Service Control Manager to invoke NTSD.EXE with the following argument string:
  
"-d c:\nt\system32\NewServ.exe".
  
NTSD will in turn break on the debugger when it loads NEWSERV.EXE so that breakpoints can be set in the service code.
SC QC

The SC QC "query configuration" command lists information about the service configuration from the QUERY_SERVICE_CONFIG structure.

Syntax1
sc [Servername] qc Servicename [Buffersize]

Parameters

Servername
Optional. Specifies the name of the server when you want to run the commands on a remote computer. The name must start with two double backslash characters, such as "\\myserver". To run SC on the local computer, do not supply this parameter.

Servicename
Specifies the name given to the service key in the registry. Note that this is different from the display name, which is what you see with NET START and the Services Control Panel application. SC uses the service key name as the primary identifier for the service.

Buffersize
Optional. Specifies the size of the buffer in bytes. 

Comments

The SC QC command displays the contents of the QUERY_SERVICE_CONFIG structure:
  
Information displayed by the SC QC command	Corresponding field from the QUERY_SERVICE_CONFIG structure

TYPE			dwServiceType
START_TYPE		dwStartType
ERROR_CONTROL		dwErrorControl
BINARY_PATH_NAME	lpBinaryPathName
LOAD_ORDER_GROUP	lpLoadOrderGroup
TAG			dwTagId
DISPLAY_NAME		lpDisplayName
DEPENDENCIES		lpDependencies
SERVICE_START_NAME	lpServiceStartName

Example 1

The following example queries the configuration of the service named "NewService" that was created in Example 1 for the Create command:
  
sc \\myserver qc NewService
  
The SC utility displays the following information:
  
SERVICE_NAME: NewService
        TYPE               : 20  WIN32_SHARE_PROCESS
        START_TYPE         : 3   DEMAND_START
        ERROR_CONTROL      : 1   NORMAL
        BINARY_PATH_NAME   : c:\nt\system32\NewServ.exe
        LOAD_ORDER_GROUP   :
        TAG                : 0
        DISPLAY_NAME       : NewService
        DEPENDENCIES       :
        SERVICE_START_NAME : LocalSystem
  
NewService has the ability to share a process with other services. It will not be auto-started. The binary file name is NEWSERV.EXE. This service doesn't depend on any other services, and will run in the Local System security context. Because this basically returns the results from a call to QueryServiceStatus, a more detailed explanation of these results can be obtained from the documentation on that API function.

SC QUERY

The SC QUERY command obtains information about the service.

Syntax
sc [Servername] query { Servicename | Optionname= Optionvalue... }

Parameters

Servername
Optional. Specifies the name of the server when you want to run the command on a remote computer. The name must start with two double backslash characters, such as "\\myserver".

Servicename
Specifies the name given to the service key in the Registry. Note that this is different from the display name, which is what you see with NET START and the Services Control Panel application. SC uses the service key name as the primary identifier for the service. Note that you can supply either the Servicename or the options, but not both. When the Servicename is supplied, the other options are ignored.

Optionname
The Optionname and Optionvalue parameters allow you to specify the names and values of optional parameters. Note that there is no space between the Optionname and the equal sign. You can supply zero, one, or more optional parameters name and value pairs. The SC QUERY command supports the following values:
  
Optionname	Optionvalue
Description

type=		driver, service, all	
Type of services to enumerate (default = service)

state=		active, inactive, all
State of services to enumerate  (default = active)

bufsize=	(numeric value)
The size in bytes of the enumeration buffer (default = 1024 bytes)

ri=		(numeric value)
The resume index number at which to begin the enumeration (default = 0)

Optionvalue
Specifies the value for the parameter named by Optionname. See the Optionname reference for a list of supported values.

Comments

The SC QUERY command displays the contents of the SERVICE_STATUS structure:
  
Information displayed by SC QUERY command	Corresponding field from the SERVICE_STATUS structure

TYPE			dwServiceType
STATE			dwCurrentState, dwControlsAccepted
WIN32_EXIT_CODE		dwWin32ExitCode
SERVICE_EXIT_CODE	dwServiceSpecificExitCode
CHECKPOINT		dwCheckPoint
WAIT_HINT		dwWaitHint

Using the SC QUERY command after booting the machine will tell you whether or not an attempt was made to start this service. If the service was started successfully, the WIN32_EXIT_CODE field should contain a zero (0). If the service failed to start when an attempt was made, this field should contain an exit code provided by the service when it realized it couldn't start.

Examples

To query the status of the service, "NewService," enter:
  
sc query NewService
  
SC displays the following information:
  
    SERVICE_NAME: NewService
        TYPE               : 20  WIN32_SHARE_PROCESS
        STATE              : 1  STOPPED
                           (NOT_STOPPABLE,NOT_PAUSABLE,IGNORES_SHUTDOWN)
        WIN32_EXIT_CODE    : 1077       (0x435)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x0
  
Notice that there is an exit code for this service, even though it has not yet been run. Entering the Windows NT command "net helpmsg 1077" at the command line returns the following text information for error 1077:
  
No attempts to start the service have been made since the last boot.
  
Net Helpmsg can be used to display the text for most Windows NT error messages. This particular exit code indicates that this service hasn't yet been run. Although obvious in this case, this particular exit code is a useful one to look for if you are expecting your service to be auto-started or perhaps when another auto-start service has a dependency on your service. 

To enumerate status for active services and drivers, use the following command:
  
sc query 
  
To display status for the messenger service, use the following command:
  
sc query messenger 
  
To enumerate only active drivers, use the following command:
  
sc query type= driver
  
To enumerate only Win32 services, use the following command:
  
sc query type= service
  
To enumerate all services and drivers, use the following command:
  
sc query state= all
  
To enumerate with a 50 byte buffer, use the following command:
  
sc query bufsize= 50
  
To enumerate with resume index = 14, use the following command:
  
sc query ri= 14 
  
To enumerate all interactive services, use the following command:
  
sc query type= service type= interact
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\server\todo.txt ===
EVENT_CALL_TO_FUNCTION_FAILED is the most common use (26 uses) of ScLogEvent
 - add a wrapper function for this and simplify the calls.

Unify codepaths in ScTerminateServiceProcess -- two blocks of duplicated code.

Slight shutdown perf improvements?
    1.  Make special stop message asynchronous
    2.  Don't wait for the process to terminate on shutdown
    3.  Use a separate transact critsec per image record

sc.exe -- When sc query (or enumdepend) fails b/c buffer is too small, print out
command line that the user should use to get all the info (or the remaining info)

Client -- StartServiceCtrlDispatcher[A,W] need to be more similar.  They're
currently very different.

Release locks around calls to ReportEvent and srvsvc portion of SetServiceBits?

GetDefaultDomainName -- is there a Win32 API for this?
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\sc\svchost\hosting your service from svchost.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Hosting your service from svchost.exe Title _PID_HLINKSHosting your service from svchost.exe Shaun Cox (shaunco) svchost.exe is a generic host process for services that are implemented in DLLs.   It is very easy to write (or convert) your service to take advantage of svchost.   The basic steps are: 1) Export a ServiceMain entrypoint from a DLL. 2) Choose a Svchost Group to run under. 3) Setup your service to use the correct ImagePath. 4) Process-wide COM security issues. Normal.dot Jonathan Schwartz Microsoft Word 10.0 Xt|f +0AbEX( !jA6<:Hosting your service from svchost.exe Author:  Shaun Cox (  HYPERLINK "mailto:shaunco"  shaunco Owner:  Jonathan Schwartz (  HYPERLINK "mailto:jschwart"  jschwart Created:  April 20, 1998 Modified:  August 11, 1998 Overview svchost.exe is a generic host process for services that are implemented in DLLs.   It is very easy to write (or convert) your service to take advantage of svchost.   The basic steps are:  Export a ServiceMain entrypoint from a DLL  Choose a Svchost Group to run under  Setup your service to use the correct ImagePath  Process-wide COM security issues  Here are other items of interest:  Things to keep in mind  Debugging tips  Export a ServiceMain entrypoint from your DLL Your DLL must export an entry point with a signature matching LPSERVICE_MAIN_FUNCTIONW (found in \nt\public\sdk\inc\winsvc.h)  typedef VOID (WINAPI *LPSERVICE_MAIN_FUNCTIONW)(     DWORD dwNumServicesArgs,     LPWSTR *lpServiceArgVectors     ); (Note the wide version and not the ANSI version.) The implementation of this function is specific to your service. Additionally, the service should have the following values located under its 'Parameters' key (i.e. located under HKLM\System\CurrentControlSet\Services\<service>\Parameters): ServiceDll  : REG_EXPAND_SZ : <path to DLL>  REQUIRED ServiceMain : REG_SZ        : <FunctionName> OPTIONAL If the ServiceMain value is not present, then it defaults to "ServiceMain". Choose a Svchost Group to run under Svchost Groups provide a means of separating or combining services in the same instance of svchost.exe.  Svchost Groups can be chosen arbitrarily.  One instance of svchost.exe will run for each Svchost Group defined. Svchost Groups are defined based on the registry values found under HKLM\Software\Microsoft\Windows NT\CurrentVersion\Svchost.  Each value under this key represents a Svchost Group.  Each value is a REG_MULTI_SZ and contains the services that run under that Svchost Group.  The following is an example: netsvcs: REG_MULTI_SZ: Netman Rasauto Rasman RemoteAccess foosvcs: REG_MULTI_SZ: MyService SomeOtherService For the above example, the four services (Netman, Rasauto, Rasman, and RemoteAccess) would run under one instance of svchost.exe, while MyService and SomeOtherService would run under a different instance of svchost.exe. Choose your Svchost Group while keeping the following in mind:  Don't just add one because you think you need your own.  The only reason svchost.exe exists is to reduce our process count.  Try to pick the closest "matching" Svchost Group already defined.  For example, if your service is network related, you probabaly belong in the netsvcs Svchost Group.  Everyone belonging to a specific Svchost Group must agree on process-wide security settings.  These security settings can (but don't necessarily need to) be setup by a call to CoInitializeSecurity made by svchost on behalf of the services.  For more information see Process Security Issues.  Setup your service to use the correct ImagePath After choosing your Svchost Group (above) you are ready to specify the ImagePath your service needs in order to run in svchost.exe.  Each service that will be resident in an instance of the svchost.exe process must have an ImagePath of the following form:  %SystemRoot%\System32\svchost.exe -k <svchost group> For example, if you picked the 'netsvcs' Svchost Group, the ImagePath for the service should look like: %SystemRoot%\System32\svchost.exe -k netsvcs (ImagePath is a REG_EXPAND_SZ, hence the %SystemRoot% stuff.) Important: The service controller elects to run a service in the same process as other services ONLY if the expanded forms of their ImagePaths match IDENTICALLY. (Case sensitively as well.) Pay attention to capitalization, extraneous spaces, and other typos in your ImagePath. Important: The service Type (located under HKLM\System\CurrentControlSet\Services\<service>\Type (REG_DWORD) MUST have the SERVICE_WIN32_SHARE_PROCESS bit set. (0x20) If it does not, the service will not be allowed to run inside an instance of the svchost.exe process. Process-wide COM Security Issues Svchost accommodates multiple services in the same process by lending a hand setting up the COM security settings for the process.  All of the services that share the process must agree on a common set of COM security settings.  Once decided, the settings are parameterized in the registry under the Svchost Group specific registry key.  This key is located at HKLM\Software\Microsoft\Windows NT\CurrentVersion\Svchost\<Svchost Group>.  Where <Svchost Group> is the name of the Svchost Group chosen above.  Svchost looks for a REG_DWORD parameter called CoInitalizeSecurityParam.   If the value is non-zero, Svchost will call CoInitializeSecurity at the time the Svchost instance is started (i.e., when the first service in the Svchost Group is started).  The following is an example. CoInitializeSecurityParam: REG_DWORD: 1 If there is a non-zero value for CoInitializeSecurityParam, Svchost will look for the following values under the same registry key. If present, they will override some of the default parameters Svchost passes to CoInitializeSecurity: Value name  CoInitializeSecurity parameter  Value type  Default value AuthenticationLevel  dwAuthnLevel  REG_DWORD  RPC_C_AUTHN_LEVEL_PKT (0x4) ImpersonationLevel  dwImpLevel  REG_DWORD  RPC_C_IMP_LEVEL_IMPERSONATE (0x3) AuthenticationCapabilities  dwCapabilities  REG_DWORD  EOAC_NO_CUSTOM_MARSHAL | EOAC_DISABLE_AAA (0x3000) Unless you absolutely need to override the above defaults (e.g., for compatibility reasons), you should leave them as is. Things to keep in mind Please use the common   HYPERLINK "http://networking/archive/ncidev/docs/rtlthreadpool.htm"  thread pool functions  checked into the RTL library (or the Win32 equivalents) rather than rolling your own.  Be sure to have NO MEMORY LEAKS between starts/stops of your service. Since you're sharing the service with others, please be kind. ;-)  Don't assume that the process goes away when your service is stopped. Since it is shared with other services, you most likely will be stopped and started in the same process instance. There is a subtle ramification to this: Any global variables that you changed after your service started, will retain these settings after it is stopped and will be present for the next restart. You should therefore re-initialize your globals when shutting down if you depend on the initialized value when starting up. Starting/stopping your service repeatedly overnight while running its instance of svchost.exe under pageheap is an excellent way to make sure your service behaves well in this regard.  Important: If your service is marked to start automatically (Type=2) you will need to place a dependency on the RpcSs service, if your Svchost Group is configured to invoke CoInitializeSecurity.  This is because the CoInitializeSecurity API needs RpcSs to be running in order to successfully complete.  Debugging Tips Having lots of services in the same process can sometimes be a pain to debug. svchost.exe provides a way to isolate your service from the rest by simply specifying your own Svchost Group.  Be sure to use 'sc config binpath=' to change the ImagePath as opposed to editing the registry directly.  To run your service under the debugger, you have three options.  Attach a debugger after your service has started.  Modify the ImagePath of your service to include the debugger executable.  Set a registry key so that a DebugBreak will be issued by svchost just before your service is started.  (You must be using a checked version of svchost.exe for this to work.)  Method 1 is obvious.  Method 2 is more difficult because you have to change the ImagePaths of every service that shares the same instance of svchost with your service. To do Method 3, you should copy a checked version of svchost.exe to your machine and add the following registry key and value: HKLM\Software\Microsoft\Windows NT\CurrentVersion\Svchost\<service>     DebugBreak = REG_DWORD 1 where <service> is the name of the service as it appears under the Services registry key. If you stop and restart your service, a DebugBreak will be issued causing the JIT debugger to be launched.  (You'll probably want to change this from the default of Dr. Watson to something more useful like ntsd.) Revision History Date  Revision April 20, 1998 Initial version. April 29, 1998 Added more detail and cleaned it up a bit. May 01, 1998 Changed the term "Service Group" to "Svchost Group" to avoid confusion with the published concept already in use by the Service Control Manager. May 15, 1998 Added description of DebugBreak registry key usage. July 1, 1998 Updated Debugging Tips to explain that a checked svchost.exe is required. July 20, 1998 Started Process Security Issues section. December 21, 2000 Revamped Process Security Issues section.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\winreg.doc ===
Microsoft Word 6.0 Document MSWordDoc Word.Document.6C:\WIN16APS\WINWORD\TEMPLATE\NORMAL.DOT     Differences between Win32 and Win16 Registry APIs Jaime Sasson Jaime Sasson Microsoft Word 6.0    Differences between Win32 and Win16 Registry APIs Auther:  Jaime Sasson Date:    04/29/94 Version: 1.0 This document describes the differences between the 16-bit registry APIs and the equivalent 32-bit APIs implemented on Windows NT. The features of the 16-bit APIs that are not present on the corresponding 32-bit API, were added to the WOW layer of Windows NT to correct problems caused on some 16-bit apps. Except for the behavior of RegDeleteKey, none of these features are documented on the Win16 Programmer's Reference. Here are the differences: 1. On Win16 a handle of value 0 is equivalent to HKEY_CLASSES_ROOT.     On NT, such a handle is invalid.    This behavior of the Win16 APIs is not documented.    This difference affects all Registry APIs.    This feature was added due to problems on Lotus Amipro. 2. On Win16, APIs that take a subkey name, interpret:         hKey = 0, and lpszSubKey = ".classes\\foo\\bar"    equivalent to:         hKey = HKEY_CLASSES_ROOT, and lpszSubKey = "foo\\bar"    This behavior of the Win16 APIs is not documented.    This difference affects the following APIs:         RegCreateKey         RegDeleteKey         RegOpenKey         RegQueryValue         RegSetValue    This feature was added due to problems on Lotus Amipro. 3. On Win16, RegDeleteKey deletes a key and all its subkeys.    On NT, it does not delete subkeys recursively.    This behavior of the Win16 API is documented.    The behavior of the Win32 is also documented.    This feature was added due to problems on MS Publisher.    It was decided on the early design phase of the registry APIs that this would be the behavior of RegDeleteKey.  This decision was based on security issues, and some other characteristics of  NT that would make this API incompatible with the 16-bit API anyway (e.g. multiple processes deleting the same key at the same time).    This is the only documented behavior of the 16-bit registry API that is not implemented on NT. 4. On Win16 RegQueryValue:     4.1 - Succeeds when the buffer for the data is not big enough for the data. In this case the API will copy to the buffer whatever fits in the buffer. There is no way for the caller to find out whether or not the data returned is the complete data, if the size of the data returned is exactly the size of the buffer supplied by the caller.           On NT, the API will return an error code indicating that the buffer is not big enough for the data. The API will also return the required buffer size, so that the caller can allocate a bigger buffer and retry the call. In case of failure due to buffer not big enough, the caller cannot assume that the buffer contains partial data.           The documentation of the 16 bit API is not clear about this behavior. It just says that the API will return in one of its parameters, the number of characters that were copied to the buffer, but it doesn't say if the API should fail if the buffer is not big enough.          The behavior of the NT API is documented in details.           This feature was added due to problems MS Works.    4.2 - Succeeds and returns an empty string if the API is called on a key that has no value.         - On NT, the API returns an error code indicating that the value doesn't exist.           This behavior on Win16 is not documented.           This feature was added due to problems on Harvard Project. Normal Default Paragraph Font Jaime Sasson C:\TMP\REGREP.DOC Jaime Sasson C:\TMP\WINREG.DOC @\\JAIMES4\laser1 winspool \\JAIMES4\laser1 Letter  N N N \\JAIMES4\laser1 Letter  N N N Times New Roman Symbol Arial 5    Differences between Win32 and Win16 Registry APIs Jaime Sasson Jaime Sasson
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\cntrtext.txt ===
Extensible Counter Loading & Unloading Utilities

                Design Specification and Overview



                                                       created: 15 Feb 93
                                                                a-robw
                                                                russbl

                                                       updated: 16 Nov 95
                                                                a-robw

Overview
                                   
Device driver, service and application developers that wish to provide 
performance measuring capability in their software must have a way to 
incorporate the names of the performance counters and counter objects 
into the registry. Currently the only methods available are the manual 
installation of the names into the registry or for each developer to 
devise a scheme to do it programmatically. Since the "correct" way to 
do this is poorly documented and difficult to explain, the following 
utilities and library functions are provided to make the installation
and removal of these extensible counters much simpler and less prone 
to error and confusion.

The two command line utilities provided with Windows NT are shown below.

    > LodCtr MyDriver.INI

    > UnLodCtr MyDriver


LoadPerf.DLL is provided to the software developer to provide access 
to these same functions (in both Unicode & ANSI formats) from within 
a setup program.

    LoadPerfCounterTextStrings (
        LPTSTR  szCommandLine
        BOOL    bQuietModeFlag)

    UnloadPerfCounterTextStrings (
        LPTSTR  szCommandLine,
        BOOL    bQuietMode)

The contents of the string arguments in the above functions are the
same as those for the command line.
 

The installation utility (LodCtr) accepts as an argument the name of 
the device or application's counter .INI file. The format of the .INI 
file is described in detail later in this document. This utility will 
enter the counter names and explain text stored in the .INI file into 
the corresponding data file and update the necessary keys and values 
for the extensible performance counter DLL.

The removal utility UnLodCtr accepts as an argument, the name of the 
regsistry key which is to have its names removed from the data files.
This key is the registry key that the application, service or device 
driver us using under the ...\Services key and has the Performance
subkey.
 
The extensible performance counter DLL must be written to look up 
the base values of the counter names and explain text during 
initialization for this to function properly.

.INI file format

The .ini file for the extensible performance counter will consist 
of keys and values in a format similar to that of a MS-Windows 
.INI file (e.g. WIN.INI) This will allow a format that is somewhat 
self-documenting as well as allow current Win32 utilities to process 
it and parse the data (e.g. GetPrivateProfileString). A single file 
was selected to minimize the development and maintenance overhead of 
adding or modifying counters and adding foreign language support. 
The contents of the .INI file are described below:


Usage Notes:

The following assumptions are made in the use of counter names and
explain text and should be followed in order to insure predictable and
reliable operation.

    - Index number ranges must not be overlapping between drivers

        The range of index numbers used by an extensible counter 
        must fall between the first and last values (see below).
        (gaps are allowed within the range used). If LodCtr is used
        then this won't be a problem.

    - Names must be assigned to EVEN numbers and Explain text assigned
        to ODD numbers.

        If the convention is followed as shown in the examples below,
        where each item is given an offset of an even number starting 
        from 0, then LodCtr will do the right thing and make this 
        assignment automatically. For this to work, however, the offest 
        values MUST ALWAYS BE EVEN NUMBERS.

    - Manual assignment of counter index values is not recommended.
        
        Failure to follow all the assumptions or manually modifying
        or "hard-coding" index values may result in counter name 
        text corruption or erroneous display of names.

    - Symbol file format must conform to the following:
        
        #define NAME    decimal_number

        The symbol file processor is pretty dumb and can read .H header
        files but will only understand lines that conform to the above
        format. (in line comments after the number are OK) see the
        example below for more information.


// Begin .INI file format

[info]
drivername=<name of device found under the CurrentControlSet\Services key>
symbolfile=<.h file containing symbolic offsets of counters>

[languages] // one key (value optional) for each language supported in file
009=
 .
 .
 .
 .


[text]  // counter & explain text for customer-defined counters
offset_langid_NAME=text
offset_langid_HELP=text

// offset must be a symbolic constant (from symbolfile)
// offset value must be an even number (see code example for why)
// NAME and HELP are literal text and identify counter names or 
// explain text
// langid must be listed as a key under [languages]
// text must be entered on a single line (though it can be a long one)

// end .INI file format


The .ini file must be loaded into the registry before the extensible
performance counter DLL is initialized (e.g. during or immediately 
after the driver is loaded for the first time. Once the counter names 
are loaded, however, they will remain until they are removed or NT is 
reinstalled.


Following is an example of how the various components of an extensible 
counter would incorporate the definitions of the .INI file and the use
of the LodCtr and UnLodCtr utilities.  This example has one object and
two counters.

// begin devdef.H file

// legal constant definitions

#define OBJECT_1    0
#define DEVICE_COUNTER_1    2
#define DEVICE_COUNTER_2    4


// end devdef.H file

// BEGIN: Object & Counter structure initialization file

// defines static structures used to build the perf data that is
// returned by the extensible counter routines

#include "devdef.h"
        
MY_DEVICE_CTR_DEFINITION MyDeviceCtrDefinition = {

    {   sizeof(MY_DEVICE_CTR_DEFINITION) + SIZE_OF_CTR_DATA,
        sizeof(MY_DEVICE_CTR_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        OBJECT_1,
        0,
        OBJECT_1,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(MY_DEVICE_CTR_DEFINITION-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        1,
        0,
        0
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DEVICE_COUNTER_1,
        0,
        DEVICE_COUNTER_1,
        0,
        0,
        PERF_DETAIL_ADVANCED, 
        PERF_COUNTER_COUNTER, 
        sizeof(DWORD),
        DEVICE_COUNTER_1_DATA_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DEVICE_COUNTER_2,
        0,
        DEVICE_COUNTER_2,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DEVICE_COUNTER_2_DATA_OFFSET,
    }
};

// END: Object & Counter structure initialization file

// begin .INI file example
[info]
drivername=DriverName
symbolfile=devdef.h

[languages] 
009=English
00C=OtherLanguage

[text]  
OBJECT_1_009_NAME=Device Name
OBJECT_1_009_HELP=Displays performance statistics on Device Name
OBJECT_1_00C_NAME=Device Name in other language
OBJECT_1_00C_HELP=Displays performance of Device Name in other language

DEVICE_COUNTER_1_009_NAME=Counter A
DEVICE_COUNTER_1_009_HELP=Displays the current value of Counter A
DEVICE_COUNTER_1_00C_NAME=Counter A in other language
DEVICE_COUNTER_1_00C_HELP=Displays the value of Counter A in other language

DEVICE_COUNTER_2_009_NAME=Counter B
DEVICE_COUNTER_2_009_HELP=Displays the current rate of Devices B
DEVICE_COUNTER_2_00C_NAME=Counter B in other language
DEVICE_COUNTER_2_00C_HELP=Displays the rate of Device B in other language

// end .INI file


OpenPerformanceData ( ... args ... ) 
{

        .
        .
        .

    // execute this code before accessing or passing any perf. data
    // objects.

    status = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        "\\System\\CurrentControlSet\\Service\\DriverName\\Performance",
        NULL,
        SAM, 
        &hKeyDriverPerf);

    size = sizeof (DWORD);
    Status = RegQueryValueEx (
                hKeyDriverPerf, 
                "First Counter"
                0L,
                &type,
                (LPBYTE)&dwFirstCounter,
                &size);

    size = sizeof (DWORD);
    Status = RegQueryValueEx(
                hKeyDriverPerf, 
                "First Help"
                0L,
                &type,
                (LPBYTE)&dwFirstHelp,
                &size);

    //
    //  NOTE: the initialization program could also retrieve
    //      LastCounter and LastHelp if they wanted to do 
    //      bounds checking on the new number. e.g.
    //
    //      counter->CounterNameTitleIndex += dwFirstCounter;
    //      if (counter->CounterNameTitleIndex > dwLastCounter) {
    //          LogErrorToEventLog (INDEX_OUT_OF_BOUNDS);
    //      }

    For each counter object {
        Object->ObjectNameTitleIndex += dwFirstCounter;
        Object->ObjectHelpTitleIndex += dwFirstHelp;

        for each counter definition in the object {
            counter->CounterNameTitleIndex += dwFirstCounter;
            counter->CounterHelpTitleIndex += dwFirstHelp;

        }
    }

    RegCloseKey (hKeyDriverPerf);
        .
        .
        .

}


When LodCtr has loaded the contents of the .INI file the following 
registry keys will have been updated.  The ":" indicates a Value of
a Key; other symbols are keys in the registry.

MACHINE
    SYSTEM
        CurrentControlSet
            Services
                <devicename>
                    Performance
                        :First Counter (updated to show current value)
                        :First Help    (updated to show current value)
                        :Last Counter  (updated to show current value)
                        :Last Help     (updated to show current value)
                
MACHINE
    SOFTWARE
        Microsoft
            Windows NT
                CurrentVersion
                    Perflib            
                        :Last Counter (updated to show current value)
                        :Last Help    (updated to show current value)  



After UnLodCtr is run to remove a driver's counters from the data file,
the following changes to the registry will take place

MACHINE
    SYSTEM
        CurrentControlSet
            Services
                <devicename>
                    Performance
                        :First Counter     (value deleted)
                        :First Help        (value deleted)
                        :Last Counter      (value deleted)
                        :Last Help         (value deleted)
                
MACHINE
    SOFTWARE
        Microsoft
            Windows NT
                CurrentVersion
                    Perflib            
                        :Last Counter (updated to show current value)
                        :Last Help    (updated to show current value)  


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\initodat\readme.txt ===
Oct. 1993.

Changes to PerfMon perfc???.ini and perfh???.ini files
------------------------------------------------------

These init files used to be under oakbin for NT1.0.  However, for NT1.0a,
these counter names and help texts are removed from the registry to save size
and improve system performance.  (save 200K bytes of pool paged per language).
The newPerfmon will look for these names in PerfC???.dat and PerfH???.dat inside 
the System32 directory.  If you have to modify any of the ini files, you have to run
a utility to convert them into a data file.  The utility, initodat.exe, is in
sdktools\cntrtext\initodat.  This tool will convert the ini file to dat file 
in the same directory.  You have to move it to the System32 directory after
the conversion.


InitoDat  filename

        Usage:-

        filename is the name of the initialization file that contains
        the counter name definitions or explain text for a specific
        language.  Initodat will create a data file using the same
        name with .dat extension in the current directory.


Please direct any question/comments to either RezaB or a-honwah.



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\readme.txt ===
Oct. 1993.

Changes to PerfMon perfc???.ini and perfh???.ini files
------------------------------------------------------

These init files used to be under oakbin for NT1.0.  However, for NT1.0a,
these counter names and help texts are removed from the registry to save size
and improve system performance.  (save 200K bytes of paged pool per language).
The newPerfmon will look for these names in PerfC???.dat and PerfH???.dat inside 
the System32 directory.  If you have to modify any of the ini files, you have to run
a utility to convert them into a data file.  The utility, initodat.exe, is in
sdktools\cntrtext\initodat.  This tool will convert the ini file to dat file 
in the same directory.  You have to move it to the System32 directory after
the conversion.


InitoDat  filename

        Usage:-

        filename is the name of the initialization file that contains
        the counter name definitions or explain text for a specific
        language.  Initodat will create a data file using the same
        name with .dat extension in the current directory.


A copy of InitoDat.exe for x86 is included here.  Also, I have converted
all the current ini fiels to dat files, too.


Please direct any question/comment to either RezaB or a-honwah.  Thanks.



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\ara\perfh001.ini ===
[info]
drivername=ContentIndex
symbolfile=perfci.h

[objects]
CIOBJECT_009_NAME=Indexing Service

[languages]
009=English
000=Neutral

[text]
CIOBJECT_009_NAME=Indexing Service
CIOBJECT_009_HELP=Indexing Service

NUM_WORDLIST_009_NAME=Word lists
NUM_WORDLIST_009_HELP=Number of word lists.

NUM_PERSISTENT_INDEX_009_NAME=Saved indexes
NUM_PERSISTENT_INDEX_009_HELP=Number of saved indexes.

INDEX_SIZE_009_NAME=Index size (MB)
INDEX_SIZE_009_HELP=Size of the content index (*.ci files only) in megabytes.

FILES_TO_BE_FILTERED_009_NAME=Files to be indexed
FILES_TO_BE_FILTERED_009_HELP=Number of files to be filtered and added to the index.

DEFERRED_FILTER_FILES_009_NAME=Deferred for indexing
DEFERRED_FILTER_FILES_009_HELP=Number of files not available and deferred for indexing.

NUM_UNIQUE_KEY_009_NAME=Unique keys
NUM_UNIQUE_KEY_009_HELP=Number of unique keys (words, etc.) in the index.

RUNNING_QUERIES_009_NAME=Running queries
RUNNING_QUERIES_009_HELP=Number of active query client connections.

MERGE_PROGRESS_009_NAME=Merge progress
MERGE_PROGRESS_009_HELP=Percent merge complete for the current merge.

DOCUMENTS_FILTERED_009_NAME=# documents indexed
DOCUMENTS_FILTERED_009_HELP=Number of documents indexed since the index was mounted.

NUM_DOCUMENTS_009_NAME=Total # documents
NUM_DOCUMENTS_009_HELP=Total number of documents in the index.

TOTAL_QUERIES_009_NAME=Total # of queries
TOTAL_QUERIES_009_HELP=Total number of queries since the index was mounted.

CIOBJECT_000_NAME=Indexing Service
CIOBJECT_000_HELP=Indexing Service

NUM_WORDLIST_000_NAME=Word lists
NUM_WORDLIST_000_HELP=Number of word lists.

NUM_PERSISTENT_INDEX_000_NAME=Saved indexes
NUM_PERSISTENT_INDEX_000_HELP=Number of saved indexes.

INDEX_SIZE_000_NAME=Index size (MB)
INDEX_SIZE_000_HELP=Size of the content index (*.ci files only) in megabytes.

FILES_TO_BE_FILTERED_000_NAME=Files to be indexed
FILES_TO_BE_FILTERED_000_HELP=Number of files to be filtered and added to the index.

DEFERRED_FILTER_FILES_000_NAME=Deferred for indexing
DEFERRED_FILTER_FILES_000_HELP=Number of files not available and deferred for indexing.

NUM_UNIQUE_KEY_000_NAME=Unique keys
NUM_UNIQUE_KEY_000_HELP=Number of unique keys (words, etc.) in the index.

RUNNING_QUERIES_000_NAME=Running queries
RUNNING_QUERIES_000_HELP=Number of active query client connections.

MERGE_PROGRESS_000_NAME=Merge progress
MERGE_PROGRESS_000_HELP=Percent merge complete for the current merge (if any).

DOCUMENTS_FILTERED_000_NAME=# documents indexed
DOCUMENTS_FILTERED_000_HELP=Number of documents indexed since the index was mounted.

NUM_DOCUMENTS_000_NAME=Total # documents
NUM_DOCUMENTS_000_HELP=Total number of documents in index.

TOTAL_QUERIES_000_NAME=Total # of queries
TOTAL_QUERIES_000_HELP=Total number of queries since the index was mounted.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\ara\perfc001.ini ===
[info]
drivername=ContentIndex
symbolfile=perfci.h

[objects]
CIOBJECT_009_NAME=Indexing Service

[languages]
009=English
000=Neutral

[text]
CIOBJECT_009_NAME=Indexing Service
CIOBJECT_009_HELP=Indexing Service

NUM_WORDLIST_009_NAME=Word lists
NUM_WORDLIST_009_HELP=Number of word lists.

NUM_PERSISTENT_INDEX_009_NAME=Saved indexes
NUM_PERSISTENT_INDEX_009_HELP=Number of saved indexes.

INDEX_SIZE_009_NAME=Index size (MB)
INDEX_SIZE_009_HELP=Size of the content index (*.ci files only) in megabytes.

FILES_TO_BE_FILTERED_009_NAME=Files to be indexed
FILES_TO_BE_FILTERED_009_HELP=Number of files to be filtered and added to the index.

DEFERRED_FILTER_FILES_009_NAME=Deferred for indexing
DEFERRED_FILTER_FILES_009_HELP=Number of files not available and deferred for indexing.

NUM_UNIQUE_KEY_009_NAME=Unique keys
NUM_UNIQUE_KEY_009_HELP=Number of unique keys (words, etc.) in the index.

RUNNING_QUERIES_009_NAME=Running queries
RUNNING_QUERIES_009_HELP=Number of active query client connections.

MERGE_PROGRESS_009_NAME=Merge progress
MERGE_PROGRESS_009_HELP=Percent merge complete for the current merge.

DOCUMENTS_FILTERED_009_NAME=# documents indexed
DOCUMENTS_FILTERED_009_HELP=Number of documents indexed since the index was mounted.

NUM_DOCUMENTS_009_NAME=Total # documents
NUM_DOCUMENTS_009_HELP=Total number of documents in the index.

TOTAL_QUERIES_009_NAME=Total # of queries
TOTAL_QUERIES_009_HELP=Total number of queries since the index was mounted.

CIOBJECT_000_NAME=Indexing Service
CIOBJECT_000_HELP=Indexing Service

NUM_WORDLIST_000_NAME=Word lists
NUM_WORDLIST_000_HELP=Number of word lists.

NUM_PERSISTENT_INDEX_000_NAME=Saved indexes
NUM_PERSISTENT_INDEX_000_HELP=Number of saved indexes.

INDEX_SIZE_000_NAME=Index size (MB)
INDEX_SIZE_000_HELP=Size of the content index (*.ci files only) in megabytes.

FILES_TO_BE_FILTERED_000_NAME=Files to be indexed
FILES_TO_BE_FILTERED_000_HELP=Number of files to be filtered and added to the index.

DEFERRED_FILTER_FILES_000_NAME=Deferred for indexing
DEFERRED_FILTER_FILES_000_HELP=Number of files not available and deferred for indexing.

NUM_UNIQUE_KEY_000_NAME=Unique keys
NUM_UNIQUE_KEY_000_HELP=Number of unique keys (words, etc.) in the index.

RUNNING_QUERIES_000_NAME=Running queries
RUNNING_QUERIES_000_HELP=Number of active query client connections.

MERGE_PROGRESS_000_NAME=Merge progress
MERGE_PROGRESS_000_HELP=Percent merge complete for the current merge (if any).

DOCUMENTS_FILTERED_000_NAME=# documents indexed
DOCUMENTS_FILTERED_000_HELP=Number of documents indexed since the index was mounted.

NUM_DOCUMENTS_000_NAME=Total # documents
NUM_DOCUMENTS_000_HELP=Total number of documents in index.

TOTAL_QUERIES_000_NAME=Total # of queries
TOTAL_QUERIES_000_HELP=Total number of queries since the index was mounted.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\br\perfc016.ini ===
"1",     "1847",

    "2",     "Sistema",

    "4",     "Memria",

    "6",     "% tempo de processador",

    "10",     "Operaes de leitura de arquivo/s",

    "12",     "Operaes de gravao de arquivo/s",

    "14",     "Operaes de controle de arquivo/s",

    "16",     "Bytes de leitura de arquivo/s",

    "18",     "Bytes de gravao de arquivo/s",

    "20",     "Bytes de controle de arquivo/s",

    "24",     "Bytes disponveis",

    "26",     "Bytes confirmados",

    "28",     "Falhas de pginas/seg",

    "30",     "Limite de confirmao",

    "32",     "Cpias de gravao/s",

    "34",     "Falhas de transio/s",

    "36",     "Falhas de cache/s",

    "38",     "Falhas de demanda zero/s",

    "40",     "Pginas/s",

    "42",     "Leituras de pgina/s",

    "44",     "Comprimento da fila de processador",

    "46",     "Estado de segmento",

    "48",     "Sada de pginas/s",

    "50",     "Gravaes de pgina/s",

    "52",     "Navegador",

    "54",     "Anncios de servidor/s",

    "56",     "Bytes de pool paginvel",

    "58",     "Bytes de pool no-paginvel",

    "60",     "Alocaes de pool paginvel",

    "64",     "Alocaes de pool no-paginvel",

    "66",     "Bytes residentes de pool paginvel",

    "68",     "Total de bytes de cdigo do sistema",

    "70",     "Bytes residentes de cdigo do sistema",

    "72",     "Total de bytes de driver do sistema",

    "74",     "Bytes residentes de driver do sistema",

    "76",     "Bytes residentes de cache do sistema",

    "78",     "Anncios de domnio/s",

    "80",     "Pacotes de seleo/s",

    "82",     "Gravaes de processador de mensagens/s",

    "84",     "Solicitaes de lista do servidor/s",

    "86",     "Cache",

    "88",     "Mapeamentos de dados/s",

    "90",     "Mapeamentos de dados sncronos/s",

    "92",     "Mapeamentos de dados assncronos/s",

    "94",     "Acertos de mapa de dados %",

    "96",     "Mapas de dados fixados/s",

    "98",     "Leituras fixadas/s",

    "100",     "Leituras fixadas sncronas/s",

    "102",     "Leituras fixadas asssncronas/s",

    "104",     "Acertos de leituras fixadas %",

    "106",     "Leituras de cpia/s",

    "108",     "Leituras de cpia sncronas/s",

    "110",     "Leituras de cpia assncronas/s",

    "112",     "Acertos de leituras de cpia %",

    "114",     "Leituras MDL/s",

    "116",     "Leituras MDL sncronas/s",

    "118",     "Leituras MDL assncronas/s",

    "120",     "Acertos de leituras de MDL %",

    "122",     "Leituras antecipadas/s",

    "124",     "Leituras rpidas/s",

    "126",     "Leituras rpidas sncronas/s",

    "128",     "Leituras rpidas assncronas/s",

    "130",     "Falhas de recursos de leituras rpidas/s",

    "132",     "Leituras rpidas impossveis/s",

    "134",     "Liberaes para gravao lenta/s",

    "136",     "Pginas para gravao lenta/s",

    "138",     "Dados liberados/s",

    "140",     "Pginas de dados liberadas/s",

    "142",     "% tempo de usurio",

    "144",     "% tempo privilegiado",

    "146",     "Alternncias de contexto/s",

    "148",     "Interrupes/s",

    "150",     "Chamadas do sistema/s",

    "152",     "Cargas de TLB de nvel 1/s",

    "154",     "Cargas de TLB de nvel 2/s",

    "156",     "Enumeraes de servidor/s",

    "158",     "Enumeraes de domnio/s",

    "160",     "Outras enumeraes/s",

    "162",     "Notificaes do servidor perdidas",

    "164",     "Datagramas do processador de mensagens perdidos",

    "166",     "Solicitaes de lista de servidor perdidas",

    "168",     "Falha em alocaes de anncio do servidor/s",

    "170",     "Falhas de alocaes do processador de mensagens",

    "172",     "Pico de bytes virtuais",

    "174",     "Bytes virtuais",

    "178",     "Pico do conjunto de trabalho",

    "180",     "Conjunto de trabalho",

    "182",     "Pico de bytes de arquivo de paginao",

    "184",     "Bytes de arquivo de paginao",

    "186",     "Bytes particulares",

    "188",     "Total de anncios/s",

    "190",     "Total de enumeraes/s",

    "198",     "Comprimento da fila de disco atual",

    "200",     "% tempo de disco",

    "202",     "% tempo de leitura de disco",

    "204",     "% tempo de gravao de disco",

    "206",     "Mdia de disco s/transferncia",

    "208",     "Mdia de disco s/leitura",

    "210",     "Mdia de disco s/gravao",

    "212",     "Transferncias de disco/s",

    "214",     "Leituras de disco/s",

    "216",     "Gravaes de disco/s",

    "218",     "Bytes de disco/s",

    "220",     "Bytes de leitura de disco/s",

    "222",     "Bytes de gravao de disco/s",

    "224",     "Mdia de bytes de disco/transferncia",

    "226",     "Mdia de bytes de disco/leitura",

    "228",     "Mdia de bytes de disco/gravao",

    "230",     "Processo",

    "232",     "Segmento",

    "234",     "PhysicalDisk",

    "236",     "LogicalDisk",

    "238",     "Processador",

    "240",     "% tempo total de processador",

    "242",     "% tempo total de usurio",

    "244",     "% tempo total privilegiado",

    "246",     "Total de interrupes/s",

    "248",     "Processos",

    "250",     "Segmentos",

    "252",     "Eventos",

    "254",     "Semforos",

    "256",     "Excluses mtuas",

    "258",     "Sees",

    "260",     "Objetos",

    "262",     "Redirecionador",

    "264",     "Bytes recebidos/s",

    "266",     "Pacotes recebidos/s",

    "268",     "Bytes de leitura de paginao/s",

    "270",     "Bytes de leitura de no-paginao/s",

    "272",     "Bytes de leitura de cache/s",

    "274",     "Bytes de leitura de rede/s",

    "276",     "Bytes transmitidos/s",

    "278",     "Pacotes transmitidos/s",

    "280",     "Bytes de gravao de paginao/s",

    "282",     "Bytes de gravao de no-paginao/s",

    "284",     "Bytes de gravao de cache/s",

    "286",     "Bytes de gravao de rede/s",

    "288",     "Operaes de leitura/s",

    "290",     "Operaes de leitura aleatrias/s",

    "292",     "Leitura de pacotes/s",

    "294",     "Leituras grandes/s",

    "296",     "Leitura de pacotes pequenos/s",

    "298",     "Operaes de gravao/s",

    "300",     "Operaes de gravao aleatrias/s",

    "302",     "Gravao de pacotes/s",

    "304",     "Gravaes grandes/s",

    "306",     "Gravao de pacotes pequenos/s",

    "308",     "Leituras negadas/s",

    "310",     "Gravaes negadas/s",

    "312",     "Erros de rede/seg",

    "314",     "Sesses de servidor",

    "316",     "Reconexo do servidor",

    "318",     "Conexes ao ncleo",

    "320",     "Conecta o Lan Manager 2.0",

    "322",     "Conecta o Lan Manager 2.1",

    "324",     "Conecta o Windows NT",

    "326",     "Desconexes de servidor",

    "328",     "Sesses de servidor travadas",

    "330",     "Servidor",

    "336",     "Razo de espera de segmento",

    "340",     "Tempo limite de sesses",

    "342",     "Sesses com erros",

    "344",     "Logoff de sesses",

    "346",     "Logoff forado de sesses",

    "348",     "Logon de erros",

    "350",     "Erros de permisses de acesso",

    "352",     "Erros de concesses de acesso",

    "354",     "Erros do sistema",

    "356",     "Bloqueio de solicitaes rejeitadas",

    "358",     "Falta de itens de trabalho",

    "360",     "Total de arquivos abertos",

    "362",     "Arquivos abertos",

    "366",     "Localizaes de pastas de arquivos",

    "370",     "Pool de falhas no-paginveis",

    "372",     "Pico de pool no-paginvel",

    "376",     "Pool de falhas paginveis",

    "378",     "Pico de pool paginvel",

    "388",     "Total de bytes/s",

    "392",     "Comandos atuais",

    "398",     "NWLink NetBIOS",

    "400",     "Pacotes/s",

    "404",     "Blocos de contexto enfileirado/s",

    "406",     "Operaes de dados de arquivo/s",

    "408",     "% de espao livre",

    "410",     "Megabytes livres",

    "412",     "Conexes abertas",

    "414",     "Conexes sem novas tentativas",

    "416",     "Conexes com novas tentativas",

    "418",     "Desconexes locais",

    "420",     "Desconexes remotas",

    "422",     "Falhas de vnculo",

    "424",     "Falhas de adaptador",

    "426",     "Tempos limite de sesso de conexo",

    "428",     "Conexes canceladas",

    "430",     "Falhas de recursos remotos",

    "432",     "Falhas de recursos locais",

    "434",     "Falhas de computador no encontrado",

    "436",     "Falhas de escuta",

    "438",     "Datagramas/s",

    "440",     "Bytes de datagramas/s",

    "442",     "Datagramas enviados/s",

    "444",     "Bytes de datagramas enviados/s",

    "446",     "Datagramas recebidos/s",

    "448",     "Bytes de datagramas recebidos/s",

    "452",     "Pacotes enviados/s",

    "456",     "Quadros/s",

    "458",     "Bytes de quadro/s",

    "460",     "Quadros enviados/s",

    "462",     "Bytes de quadros enviados/s",

    "464",     "Quadros recebidos/s",

    "466",     "Bytes de quadros recebidos/s",

    "468",     "Quadros reenviados/s",

    "470",     "Bytes de quadros reenviados/s",

    "472",     "Quadros rejeitados/s",

    "474",     "Bytes de quadros rejeitados/s",

    "476",     "Resposta de expiraes",

    "478",     "Confirmao de expirao",

    "480",     "Janela de transmisso mxima",

    "482",     "Janela de transmisso mdia",

    "484",     "Acmulo de confirmaes em fila/s",

    "486",     "Tempo limite de confirmaes acumuladas",

    "488",     "IPX NWLink",

    "490",     "SPX NWLink",

    "492",     "NetBEUI",

    "494",     "Recurso NetBEUI",

    "496",     "Mximo usado",

    "498",     "Mdia utilizada",

    "500",     "Recursos esgotados",

    "502",     "Conexo NBT",

    "506",     "Bytes enviados/s",

    "508",     "Total de bytes/s",

    "510",     "Interface de rede",

    "512",     "Bytes/s",

    "520",     "Largura de banda atual",

    "524",     "Pacotes recebidos de difuso ponto-a-ponto/s",

    "526",     "Pacotes recebidos de difuso no-ponto-a-ponto/s",

    "528",     "Pacotes recebidos descartados",

    "530",     "Erros de pacotes recebidos",

    "532",     "Pacotes recebidos desconhecidos",

    "536",     "Pacotes enviados de difuso ponto-a-ponto/s",

    "538",     "Pacotes enviados de difuso no-ponto-a-ponto/s",

    "540",     "Pacotes de sada descartados",

    "542",     "Erros de pacotes de sada",

    "544",     "Comprimento da fila de sada",

    "546",     "IPv4",

    "548",     "IPv6",

    "552",     "Erros de cabealho de datagramas recebidos",

    "554",     "Erros de endereo de datagramas recebidos",

    "556",     "Datagramas encaminhados/s",

    "558",     "Protocolo desconhecido de datagramas recebidos",

    "560",     "Datagramas recebidos descartados",

    "562",     "Datagramas recebidos entregues/s",

    "566",     "Datagramas de sada descartados",

    "568",     "Datagramas de sada sem rota",

    "570",     "Fragmentos recebidos/s",

    "572",     "Fragmentos reorganizados/s",

    "574",     "Falhas de fragmentos reorganizados/s",

    "576",     "Datagramas fragmentados/s",

    "578",     "Falhas de fragmentao",

    "580",     "Fragmentos criados/s",

    "582",     "ICMP",

    "584",     "Mensagens/s",

    "586",     "Mensagens recebidas/s",

    "588",     "Erros de mensagens recebidas",

    "590",     "Destino de envio inacessvel",

    "592",     "Tempo de recebimento excedido",

    "594",     "Problema no parmetro de recebimento",

    "596",     "Desconexes de origem recebidas",

    "598",     "Redirecionamento de recebimento/s",

    "600",     "Eco de recebimento/s",

    "602",     "Resposta de eco recebido/s",

    "604",     "Carimbo de data/hora recebido/s",

    "606",     "Resposta de carimbo de data/hora recebido/s",

    "608",     "Mscara de endereo recebida",

    "610",     "Resposta de mscara de endereo recebida",

    "612",     "Mensagens enviadas/s",

    "614",     "Erros de mensagens de sada",

    "616",     "Destino de envio inacessvel",

    "618",     "Tempo de envio excedido",

    "620",     "Problema no parmetro de envio",

    "622",     "Desconexes de origem enviadas",

    "624",     "Redirecionamento de envio/s",

    "626",     "Eco de envio/s",

    "628",     "Resposta de eco de envio/s",

    "630",     "Carimbo de data/hora enviado/s",

    "632",     "Resposta de carimbo de data/hora enviado/s",

    "634",     "Mscara de endereo enviada",

    "636",     "Resposta de mscara de endereo enviada",

    "638",     "TCPv4",

    "640",     "Segmentos/s",

    "642",     "Conexes estabelecidas",

    "644",     "Conexes ativas",

    "646",     "Conexes passivas",

    "648",     "Falhas de conexo",

    "650",     "Conexes redefinidas",

    "652",     "Segmentos recebidos/s",

    "654",     "Segmentos enviados/s",

    "656",     "Segmentos retransmitidos/s",

    "658",     "UDPv4",

    "660",     "% tempo total de DPC",

    "662",     "% tempo total de interrupo",

    "664",     "Datagramas sem porta/s",

    "666",     "Erros de datagramas recebidos",

    "670",     "Unidade de armazenamento de disco",

    "672",     "Falhas de alocao",

    "674",     "Tempo de atividade do sistema",

    "676",     "Contagem de identificadores do sistema",

    "678",     "Entradas livres de tabela de paginao do sistema",

    "680",     "Contagem de segmentos",

    "682",     "Base de prioridade",

    "684",     "Tempo decorrido",

    "686",     "Correes de alinhamento/s",

    "688",     "Despachos de exceo/s",

    "690",     "Emulaes flutuantes/s",

    "692",     "Logon/s",

    "694",     "Prioridade atual",

    "696",     "% tempo de DPC",

    "698",     "% tempo de interrupo",

    "700",     "Arquivo de paginao",

    "702",     "% uso",

    "704",     "% uso mximo",

    "706",     "Endereo inicial",

    "708",     "PC do usurio atual",

    "710",     "Espao mapeado sem acesso",

    "712",     "Espao mapeado somente leitura",

    "714",     "Espao mapeado leitura/gravao",

    "716",     "Espao mapeado gravao/cpia",

    "718",     "Espao mapeado executvel",

    "720",     "Espao mapeado do tipo somente execuo/leitura",

    "722",     "Espao mapeado do tipo execuo/leitura/gravao",

    "724",     "Espao mapeado do tipo execuo/gravao/cpia",

    "726",     "Espao reservado sem acesso",

    "728",     "Espao reservado somente leitura",

    "730",     "Espao reservado do tipo leitura/gravao",

    "732",     "Espao reservado do tipo gravao/cpia",

    "734",     "Espao reservado do tipo executvel",

    "736",     "Espao reservado do tipo somente execuo/leitura",

    "738",     "Espao reservado do tipo execuo/leitura/gravao",

    "740",     "Imagem",

    "742",     "Espao reservado do tipo execuo/gravao/cpia",

    "744",     "Espao no atribudo sem acesso",

    "746",     "Espao no atribudo do tipo somente leitura",

    "748",     "Espao no atribudo do tipo leitura/gravao",

    "750",     "Espao no atribudo do tipo gravao/cpia",

    "752",     "Espao no atribudo do tipo executvel",

    "754",     "Espao no atribudo do tipo somente execuo/leitura",

    "756",     "Espao no atribudo do tipo execuo/leitura/gravao",

    "758",     "Espao no atribudo do tipo execuo/gravao/cpia",

    "760",     "Espao de imagem sem acesso",

    "762",     "Espao de imagem somente leitura",

    "764",     "Espao de imagem leitura/gravao",

    "766",     "Espao de imagem gravao/cpia",

    "768",     "Espao de imagem executvel",

    "770",     "Espao de imagem executvel somente leitura",

    "772",     "Espao de imagem executvel leitura/gravao",

    "774",     "Espao de imagem executvel gravao/cpia",

    "776",     "Bytes de imagem reservados",

    "778",     "Bytes de imagem livres",

    "780",     "Bytes reservados",

    "782",     "Bytes livres",

    "784",     "Processo de identificao",

    "786",     "Espao de endereo de processo",

    "788",     "Sem acesso",

    "790",     "Somente leitura",

    "792",     "Leitura/gravao",

    "794",     "Gravao/cpia",

    "796",     "Executvel",

    "798",     "Somente execuo/leitura",

    "800",     "Execuo/leitura/gravao",

    "802",     "Execuo/gravao/cpia",

    "804",     "Segmento de identificao",

    "806",     "Falhas de recepo do processador de mensagens",

    "808",     "Falhas de gravao do processador de mensagens",

    "810",     "Falhas de abertura do processador de mensagens/s",

    "812",     "Notificaes mestres duplicadas",

    "814",     "Datagramas invlidos/s",

    "816",     "Detalhes de segmento",

    "818",     "Bytes de cache",

    "820",     "Mximo de bytes de cache",

    "822",     "Entrada de pginas/s",

    "824",     "Pginas de transio realocadas/s",

    "870",     "Porta RAS",

    "872",     "Bytes transmitidos",

    "874",     "Bytes recebidos",

    "876",     "Quadros transmitidos",

    "878",     "Quadros recebidos.",

    "880",     "Percentual de compactao (sada)",

    "882",     "Percentual de compactao (entrada)",

    "884",     "Erros de CRC",

    "886",     "Erros de tempo limite",

    "888",     "Erros de saturao da porta serial",

    "890",     "Erros de alinhamento",

    "892",     "Erros de saturao de buffer",

    "894",     "Total de erros",

    "896",     "Bytes transmitidos/s",

    "898",     "Bytes recebidos/s",

    "900",     "Quadros transmitidos/s",

    "902",     "Quadros recebidos/s",

    "904",     "Total de erros/s",

    "906",     "Total RAS",

    "908",     "Total de conexes",

    "920",     "Servidor WINS",

    "922",     "Registros exclusivos/s",

    "924",     "Registros de grupo/s",

    "926",     "Nmero total de registros/s",

    "928",     "Renovaes exclusivas/s",

    "930",     "Renovaes de grupo/s",

    "932",     "Nmero total de renovaes/s",

    "934",     "Liberaes/s",

    "936",     "Consultas/s",

    "938",     "Conflitos exclusivos/s",

    "940",     "Conflitos de grupo/s",

    "942",     "Nmero total de conflitos/s",

    "944",     "Liberaes com xito/s",

    "946",     "Liberaes com falha/s",

    "948",     "Consultas com xito/s",

    "950",     "Consultas com falha/s",

    "952",     "Contagem de identificadores",

    "1000",     "Servidor MacFile",

    "1002",     "Mximo de memria paginvel",

    "1004",     "Memria paginvel atual",

    "1006",     "Mximo de memria no-paginvel",

    "1008",     "Memria no-paginvel atual",

    "1010",     "Sesses atuais",

    "1012",     "Mx. de sesses",

    "1014",     "Arquivos abertos no momento",

    "1016",     "Mximo de arquivos abertos",

    "1018",     "Logons com falha",

    "1020",     "Dados lidos/s",

    "1022",     "Dados gravados/s",

    "1024",     "Dados recebidos/s",

    "1026",     "Dados transmitidos/s",

    "1028",     "Comprimento da fila atual",

    "1030",     "Comprimento mximo da fila",

    "1032",     "Segmentos atuais",

    "1034",     "Segmentos mximos",

    "1050",     "AppleTalk",

    "1052",     "Pacotes recebidos/s",

    "1054",     "Pacotes enviados/s",

    "1056",     "Bytes recebidos/s",

    "1058",     "Bytes de sada/s",

    "1060",     "Tempo mdio/pacote DDP",

    "1062",     "Pacotes DDP/s",

    "1064",     "Tempo mdio/pacote AARP",

    "1066",     "Pacotes AARP/s",

    "1068",     "Tempo mdio/pacote ATP",

    "1070",     "Pacotes ATP/s",

    "1072",     "Tempo mdio/pacote NBP",

    "1074",     "Pacotes NBP/s",

    "1076",     "Tempo mdio/pacote ZIP",

    "1078",     "Pacotes ZIP/s",

    "1080",     "Tempo mdio/pacote RTMP",

    "1082",     "Pacotes RTMP/s",

    "1084",     "Tentativas locais ATP",

    "1086",     "Tempos limite de resposta ATP",

    "1088",     "Resposta ATP XO/s",

    "1090",     "Resposta ATP ALO/s",

    "1092",     "Liberao de recepo ATP/s",

    "1094",     "Pool no-paginvel atual",

    "1096",     "Pacotes roteados recebidos/s",

    "1098",     "Pacotes deslocados",

    "1100",     "Tentativas remotas ATP",

    "1102",     "Pacotes roteados enviados/s",

    "1110",     "Segmento de rede",

    "1112",     "Total de quadros recebidos/s",

    "1114",     "Total de bytes recebidos/s",

    "1116",     "Quadros de difuso seletiva recebidos/s",

    "1118",     "Quadros de difuso seletiva recebidos/s",

    "1120",     "% Utilizao da rede",

    "1124",     "% Quadros de difuso seletiva",

    "1126",     "% de quadros de difuso seletiva",

    "1150",     "Telefonia",

    "1152",     "Linhas",

    "1154",     "Dispositivos telefnicos",

    "1156",     "Linhas ativas",

    "1158",     "Telefones ativos",

    "1160",     "Chamadas de sada/s",

    "1162",     "Chamadas de entrada/s",

    "1164",     "Aplicativos do cliente",

    "1166",     "Chamadas de sada atuais",

    "1168",     "Chamadas de entrada atuais",

    "1228",     "Servio de gateway para NetWare",

    "1230",     "Servio de cliente para NetWare",

    "1232",     "Contagem NCP de leituras de pacotes rompidos/s",

    "1234",     "Tempos limite de leitura de pacote rompidos/s",

    "1236",     "Contagem NCP de gravao de pacotes rompidos/s",

    "1238",     "Tempos limite de gravao de pacote rompidos/s",

    "1240",     "E/S de pacotes rompidos/s",

    "1242",     "Conectar NetWare 2.x",

    "1244",     "Conectar NetWare 3.x",

    "1246",     "Conectar NetWare 4.x",

    "1260",     "Total de logons",

    "1300",     "Filas de trabalho do servidor",

    "1302",     "Comprimento da fila",

    "1304",     "Segmentos ativos",

    "1306",     "Segmentos disponveis",

    "1308",     "Itens de trabalho disponveis",

    "1310",     "Itens de trabalho emprestados",

    "1312",     "Falta de itens de trabalho",

    "1314",     "Clientes atuais",

    "1320",     "Bytes transferidos/s",

    "1324",     "Bytes lidos/s",

    "1328",     "Bytes gravados/s",

    "1332",     "Total de operaes/s",

    "1334",     "DPCs enfileirados/s",

    "1336",     "Taxa de DPC",

    "1342",     "Total de DPCs enfileirados/s",

    "1344",     "Taxa total de DPC",

    "1350",     "% quota do Registro em uso",

    "1360",     "Memria VL",

    "1362",     "Tamanho virtual VLM % em uso",

    "1364",     "Tamanho virtual VLM",

    "1366",     "Pico de tamanho virtual VLM ",

    "1368",     "Tamanho virtual VLM disponvel",

    "1370",     "Carga comprometida VLM",

    "1372",     "Pico de carga comprometida VLM",

    "1374",     "Carga comprometida VLM do sistema",

    "1376",     "Pico de carga comprometida VLM do sistema",

    "1378",     "Taxa de confirmao compartilhada VLM do sistema",

    "1380",     "KBytes disponveis",

    "1382",     "MBytes disponveis",

    "1400",     "Comprimento mdio da fila de disco",

    "1402",     "Comprimento mdio da fila de leitura de disco",

    "1404",     "Comprimento mdio da fila de gravao de disco",

    "1406",     "% bytes confirmados em uso",

    "1408",     "Imagem inteira",

    "1410",     "Identificao de processo de criao",

    "1412",     "Operaes de leitura de ES/s",

    "1414",     "Operaes de gravao de ES/s",

    "1416",     "Operaes de dados de ES/s",

    "1418",     "Outras operaes de ES/s",

    "1420",     "Bytes de leitura de E/S/s",

    "1422",     "Bytes de gravao de E/S/s",

    "1424",     "Bytes de dados de ES/s",

    "1426",     "Outros bytes de E/S/s",

    "1450",     "Fila de impresso",

    "1452",     "Total de trabalhos impressos",

    "1454",     "Bytes impressos/s",

    "1456",     "Total de pginas impressas",

    "1458",     "Trabalhos",

    "1460",     "Referncias",

    "1462",     "Referncias mx.",

    "1464",     "Spool de trabalhos",

    "1466",     "Spool mximo de trabalhos",

    "1468",     "Erros de impressora sem papel",

    "1470",     "Erros do tipo no pronto",

    "1472",     "Erros de trabalho",

    "1474",     "Enumerar chamadas de impressora de rede",

    "1476",     "Adicionar chamadas de impressora de rede",

    "1478",     "Conjunto de trabalho - particular",

    "1480",     "Conjunto de trabalho - compartilhado",

    "1482",     "% tempo ocioso",

    "1484",     "E/S dividida/s",

    "1500",     "Objeto de trabalho",

    "1502",     "% de tempo atual de processador",

    "1504",     "% de tempo atual de modo de usurio",

    "1506",     "% de tempo atual de modo de ncleo",

    "1508",     "Este perodo mSec - processador",

    "1510",     "Este perodo mSec - modo de usurio",

    "1512",     "Este perodo mSec - modo de ncleo",

    "1514",     "Pginas/s",

    "1516",     "Contagem de processo - total",

    "1518",     "Contagem de processo - ativa",

    "1520",     "Contagem de processo - finalizada",

    "1522",     "Total de mSec - processador",

    "1524",     "Total de mSec - modo de usurio",

    "1526",     "Total de mSec - modo de ncleo",

    "1530",     "TCPv6",

    "1532",     "UDPv6",

    "1534",     "ICMPv6",

    "1536",     "Pacote recebido grande demais",

    "1538",     "Consulta de participao recebida",

    "1540",     "Relatrio de participao recebido",

    "1542",     "Reduo de participao recebida",

    "1544",     "Solicitao de roteador recebida",

    "1546",     "Anncio de roteador recebido",

    "1548",     "Detalhes do objeto de trabalho",

    "1550",     "Solicitao de vizinho recebida",

    "1552",     "Anncio de vizinho recebido",

    "1554",     "Pacote enviado grande demais",

    "1556",     "Consulta de participao enviada",

    "1558",     "Relatrio de participao enviado",

    "1560",     "Reduo de participao enviada",

    "1562",     "Solicitao de roteador enviada",

    "1564",     "Anncio de roteador enviado",

    "1566",     "Solicitao de vizinho enviada",

    "1568",     "Anncio de vizinho enviado",

    "1746",     "% tempo ocioso",

    "1748",     "% tempo C1",

    "1750",     "% tempo C2",

    "1752",     "% tempo C3",

    "1754",     "Transies C1/s",

    "1756",     "Transies C2/s",

    "1758",     "Transies C3/s",

    "1760",     "Pilha",

    "1762",     "Bytes confirmados",

    "1764",     "Bytes reservados",

    "1766",     "Bytes virtuais",

    "1768",     "Bytes livres",

    "1770",     "Comprimento de lista livre",

    "1772",     "Taxa mdia de alocao",

    "1774",     "Taxa mdia livre",

    "1776",     "Comprimento de intervalos no confirmados",

    "1778",     "Alocaes - livres",

    "1780",     "Alocaes de cache/s",

    "1782",     "Liberaes de cache/s",

    "1784",     "Alocaes <1K/s",

    "1786",     "Libera <1K/s",

    "1788",     "Alocaes 1-8K/s",

    "1790",     "Libera 1-8K/s",

    "1792",     "Aloca acima de 8K/s",

    "1794",     "Aloca acima de 8K/s",

    "1796",     "Total de alocaes/s",

    "1798",     "Total de liberaes/s",

    "1800",     "Blocos em cache de pilha",

    "1802",     "Maior profundidade de cache",

    "1804",     "Fragmentao de %",

    "1806",     "% VAFragmentation",

    "1808",     "Conteno de bloqueio de pilha",

    "1846",     "Marcador de fim",
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\chs\prfh0804.ini ===
"3",     "System performance object ",

    "5",     "Memory performance object ()()",

    "7",     "% Processor Time () 100% ",

    "9",     "% Total DPC Time (DPCs) (DPC ) Processor: % DPC Time  DPS System: % Total DPC Time  System: % Total Privileged Time DPC ",

    "11",     "File Read Operations/sec ()",

    "13",     "File Write Operations/sec ()",

    "15",     "File Control Operations/sec () System: File Data Operations/sec /",

    "17",     "File Read Bytes/sec ()/",

    "19",     "File Write Bytes/sec ()/",

    "21",     "File Control Bytes/sec ()",

    "23",     "% Total Interrupt Time  Processor: % Interrupt Time DPC ()",

    "25",     "Available Bytes () MSDN / Windows Server 2003 Resource Kit ",

    "27",     "Committed Byte ",

    "29",     "Page Faults/sec ()()",

    "31",     "Commit Limit ",

    "33",     "Write Copies/sec ",

    "35",     "Transition Faults/sec is ",

    "37",     "Cache Faults/sec ()() IP ",

    "39",     "Demand Zero Faults/sec  Windows Windows ",

    "41",     "Pages/sec  Memory\\Pages Input/sec  Memory\\Pages Output/sec : Memory\\Page Faults/sec ()",

    "43",     "Page Reads/sec ()\\Pages Reads/sec \\Pages Input/sec ",

    "45",     "Processor Queue Length  10 ",

    "47",     "Thread State 0 1 2 3 4 5 6 7 ",

    "49",     "Pages Output/sec Windows ",

    "51",     "Page Writes/sec ",

    "53",     "Browser performance object ",

    "55",     "Announcements Server/sec ",

    "57",     "Pool Paged Bytes ()()Memory\\Pool Paged Bytes  Process\\Pool Paged Bytes  Process\\Pool Paged Bytes\\_Total",

    "59",     "Pool Nonpaged Bytes ()()Memory\\Pool Nonpaged Bytes  Process\\Pool Nonpaged Bytes  Pool Nonpaged Bytes\\_Total",

    "61",     "Pool Paged Allocs ()()",

    "63",     "Pool Paged Resident Bytes ()()",

    "65",     "Pool Nonpaged Allocs ()()",

    "67",     "Bytes Total/sec () Frame Bytes/sec  Datagram Bytes/sec ",

    "69",     "System Code Total Bytes  Ntoskrnl.exe, Hal.dll  Ntldr/osloader ",

    "71",     "System Code Resident Bytes  Memory\\System Code Total Bytes Memory\\System Code Resident Bytes ( Memory\\System Code Total Bytes) ; ",

    "73",     "System Driver Total Bytes ()(Memory\\System Driver Resident Bytes) Memory\\System Code Total Bytes ",

    "75",     "System Driver Resident Bytes () Memory\\System Driver Total Bytes () System Driver Resident Bytes  System Driver Total Bytes ",

    "77",     "System Cache Resident Bytes  Memory\\System Code Resident Bytes ; ",

    "79",     "Announcements Domain/sec ",

    "81",     "Election Packets/sec ",

    "83",     "Mailslot Writes/sec ",

    "85",     "Server List Requests/sec ",

    "87",     "Cache performance object () I/O ",

    "89",     "Data Maps/sec ( NTFS)",

    "91",     "Sync Data Maps/sec  NTFS ",

    "93",     "Async Data Maps/sec  NTFS ",

    "95",     "Data Map Hit ",

    "97",     "Data Map Pins/sec  pinning  pinned ",

    "99",     "Pin Reads/sec  pinned  pinned ",

    "101",     "Sync Pin Reads/sec  pinned  pinned  pinned ",

    "103",     "Async Pin Reads/sec  pinned  pinned ",

    "105",     "Pin Read Hit  pin  pinned LAN ( LAN )",

    "107",     "Copy Reads/sec ()LAN ( LAN )",

    "109",     "Sync Copy Reads/sec ()",

    "111",     "Async Copy Reads/sec ()",

    "113",     "Copy Read Hits LAN Redirector LAN ",

    "115",     "MDL Reads/sec  Memory Descriptor List (MDL)MDL (DMA)LAN ",

    "117",     "Sync MDL Reads/sec  Memory Descriptor List (MDL) MDL (DMA)",

    "119",     "Async MDL Reads/sec  Memory Descriptor List (MDL)MDL (DMA)",

    "121",     "MDL Read Hits  Memory Descriptor List ",

    "123",     "Read Aheads/sec ",

    "125",     "Fast Reads/sec  I/O ",

    "127",     "Sync Fast Reads/sec  I/O ()",

    "129",     "Async Fast Reads/sec  I/O ()()",

    "131",     "Fast Read Resource Misses/sec ",

    "133",     "Fast Read Not Possibles/sec (API)",

    "135",     "Lazy Write Flushes/sec  Lazy Writer Lazy Writer ",

    "137",     "Lazy Write Pages/sec  Lazy Writer Lazy Writer ",

    "139",     "Data Flushes/sec ",

    "141",     "Data Flush Pages/sec ",

    "143",     "% User Time ",

    "145",     "% Privileged Time  Windows (explicit)(implicit)Windows  Windows ",

    "147",     "Context Switches/sec () Thread\\Context Switches/sec ",

    "149",     "Interrupts/sec (DPCs)() 10 ",

    "151",     "System Calls/sec ",

    "153",     "Level 1 TLB Fills/sec  Page Table Entry (PTE)  Translation Lookaside Buffer (TLB)  PTE TLB ",

    "155",     "Level 2 TLB Fills/sec  Page Table Entry (PTE)  Translation Lookaside Buffer (TLB)  PTE  PTE  TLB ",

    "157",     "% User Time Windows Windows  Windows ",

    "159",     "% Privileged Time  Windows (explicit)(implicit)Windows  Windows ",

    "161",     "Enumerations Server/sec ",

    "163",     "Enumerations Domain/sec ",

    "165",     "Enumerations Other/sec ",

    "167",     "Missed Server Announcement ",

    "169",     "Missed Mailslot Datagram  Mailslot Datagram ",

    "171",     "Missed Server List Requests ",

    "173",     "Virtual Bytes Peak ",

    "175",     "Virtual Bytes ",

    "177",     "Page Faults/sec  Page Fault()",

    "179",     "Working Set Peak  Working Set Working Set  Working Set  Working Set  Working Set ",

    "181",     "Working Set  Working Set Working Set  Working Set  Working Set  Working Set ",

    "183",     "Page File Bytes Peak ",

    "185",     "Page File Bytes ",

    "187",     "Private Bytes ",

    "189",     "% Processor Time ",

    "191",     "% Processor Time ",

    "193",     "% User Time  Windows NT ExecutiveWindows NT Windows NT ",

    "195",     "% Privileged Time  Windows (explicit)(implicit)Windows  Windows ",

    "197",     "Context Switches/sec Windows NT Windows NT ",

    "199",     "Current Disk Queue Length ",

    "201",     "% Disk Time ",

    "203",     "% Disk Read Time ",

    "205",     "% Disk Write Time ",

    "207",     "Avg. Disk sec/Transfer ",

    "209",     "Avg. Disk sec/Read ",

    "211",     "Avg. Disk sec/Write ",

    "213",     "Disk Transfers/sec /",

    "215",     "Disk Reads/sec ",

    "217",     "Disk Writes/sec ",

    "219",     "Disk Bytes/sec ",

    "221",     "Disk Read Bytes/sec ",

    "223",     "Disk Write Bytes/sec ",

    "225",     "Avg. Disk Bytes/Transfer ",

    "227",     "Avg. Disk Bytes/Read ",

    "229",     "Avg. Disk Bytes/Write ",

    "231",     "Process performance object ",

    "233",     "Thread performance object ",

    "235",     "Physical Disk performance object ()",

    "237",     "Logical Disk performance object (: C)",

    "239",     "Processor performance object ",

    "241",     "% Total Processor Time  Process: % Processor Time  100% ():  50%  100% ",

    "243",     "% Total User Time %System: % Total User Time  System: % Total Privileged Time  % Total Processor Time 100% ()",

    "245",     "% Total Privileged Time ()%System: % Total User Time  System: % Total Privileged Time  % Total Processor Time 100%()",

    "247",     "Total Interrupts/sec  Processor: Interrupts/sec  DPC 10 ",

    "249",     "Processes ",

    "251",     "Threads ",

    "253",     "Events ",

    "255",     "Semaphores ",

    "257",     "Mutexes ",

    "259",     "Sections ",

    "261",     "Object performance object ",

    "263",     "Redirector performance object ",

    "265",     "Bytes Received/sec ()",

    "267",     "Packets Received/sec ( SMB  Server Message Block) Bytes Received/sec ()",

    "269",     "Read Bytes Paging/sec ()( Read Bytes Cache/sec)(Windows NT )",

    "271",     "Read Bytes Non-Paging/sec () Named Pipes  Transactions",

    "273",     "Read Bytes Cache/sec ( Read Bytes Paging/sec)",

    "275",     "Read Bytes Network/sec  Bytes Received/sec ( Bytes Received/sec)",

    "277",     "Bytes Transmitted/sec ()",

    "279",     "Packets Transmitted/sec ( SMB ) Bytes Transmitted/sec ",

    "281",     "Write Bytes Paging/sec () 'paged out'( Write Bytes Cache/sec)",

    "283",     "Write Bytes Non-Paging/sec () Named Pipes and Transactions",

    "285",     "Write Bytes Cache/sec ",

    "287",     "Write Bytes Network/sec ( Named Pipes  Transactions ) Bytes Transmitted/sec ( Transmitted Bytes/sec)",

    "289",     "File Read Operations/sec ",

    "291",     "Read Operations Random/sec  1",

    "293",     "Read Packets/sec  1",

    "295",     "Reads Large/sec  2  1",

    "297",     "Read Packets Small/sec  1/4 1",

    "299",     "File Write Operations/sec  Redirector (API)",

    "301",     "Write Operations Random/sec  1",

    "303",     "Write Packets/sec  1",

    "305",     "Writes Large/sec  1",

    "307",     "Write Packets Small/sec  1/4 1",

    "309",     "Reads Denied/sec  Raw Reads Redirector () Raw Read",

    "311",     "Writes Denied/sec  Raw Write () Raw Read",

    "313",     "Network Errors/sec  SMB (Server Manager Block) ",

    "315",     "Server Sessions : ",

    "317",     "Server Reconnects  10 ()",

    "319",     "Connects Core  MS-Net SMB  MS-Net SMB Xenix  VAX",

    "321",     "Connects LAN Manager 2.0  LAN Manager 2.0  LMX ",

    "323",     "Connects LAN Manager 2.1  LAN Manager 2.1  LMX ",

    "325",     "Connects Windows NT  Windows 2000 ",

    "327",     "Server Reconnects  Server Reconnects",

    "329",     "Server Sessions Hung ",

    "331",     "Server performance object ",

    "333",     "",

    "335",     "",

    "337",     "Thread Wait Reason () 0  7 1  8(Page In) 2  9 3  10 4  11 5  12 6  314 (Event Pair High)15 (Event Pair Low)16  LPC 17  LPC 18 19 (Page Out)20  20 ()",

    "339",     "% DPC Time (DPC)DPC  DPC DPC ",

    "341",     " AutoDisconnect  AutoDisconnect ",

    "343",     "",

    "345",     " Sessions Times Out  Sessions Errored Out ",

    "347",     "",

    "349",     "",

    "351",     "STATUS_ACCESS_DENIED",

    "353",     "",

    "355",     "",

    "357",     " SMB  MaxWorkItem  MinFreeWorkItems ",

    "359",     "STATUS_DATA_NOT_ACCEPTED  MaxWorkItem  MinFreeWorkItems ",

    "361",     " I/O ",

    "363",     "",

    "365",     "",

    "367",     "",

    "369",     " Windows(R) NT Registry  MaxNonpagedMemoryUsage ",

    "371",     "",

    "373",     "",

    "375",     " MaxPagedMemoryUsage ",

    "377",     "",

    "379",     "",

    "381",     "Server Announce Allocations Failed/sec ()",

    "383",     "Mailslot Allocations Failed ",

    "385",     "Mailslot Receives Failed ",

    "387",     "Mailslot Writes Failed ",

    "389",     "Bytes Total/sec ",

    "391",     "File Data Operations/sec (overhead) Bytes/sec ",

    "393",     "Current Commands ()/",

    "395",     "",

    "397",     "% Interrupt Time  10 ",

    "399",     "NWLink NetBIOS  IPX ",

    "401",     "Packets/sec () Bytes/sec ",

    "405",     "Context Blocks Queued per second  work context blocks  FSP ",

    "407",     "File Data Operations/sec : ",

    "409",     "% Free Space ",

    "411",     " MB 1 MB = 1,048,576 ",

    "413",     "Connections Open ",

    "415",     "Connections No Retries ",

    "417",     "Connections With Retries  ",

    "419",     "Disconnects Local ",

    "421",     "Disconnects Remote ",

    "423",     "Failures Link ",

    "425",     "Failures Adapter ",

    "427",     "Connection Session Timeout ",

    "429",     "Connections Canceled ",

    "431",     "Failures Resource Remote ",

    "433",     "Failures Resource Local ",

    "435",     "Failures Not Found ",

    "437",     "Failures No Listen ",

    "439",     "Datagrams/sec ",

    "441",     "Datagram Bytes/sec ",

    "443",     "Datagrams Sent/sec ",

    "445",     "Datagram Bytes Sent/sec ",

    "447",     "Datagrams Received/sec ",

    "449",     "Datagram Bytes Received/sec ",

    "451",     "Packets/sec ",

    "453",     "Packets Sent/sec ",

    "455",     "Packets Received/sec ",

    "457",     "Frames/sec ()()",

    "459",     "Frame Bytes/sec ()()",

    "461",     "Frames Sent/sec ()",

    "463",     "Frame Bytes Sent/sec ()",

    "465",     "Frames Received/sec ()",

    "467",     "Frame Bytes Received/sec ()",

    "469",     "Frames Re-Sent/sec ()",

    "471",     "Frame Bytes Re-Sent/sec ",

    "473",     "Frames Rejected/sec ()",

    "475",     "Frame Bytes Rejected/sec ()",

    "477",     "Expirations Response  T1 ",

    "479",     "Expirations Ack  T2 ",

    "481",     "Window Send Maximum ",

    "483",     "Window Send Average  ",

    "485",     "Piggyback Ack Queued/sec ",

    "487",     "Piggyback Ack Timeouts ",

    "489",     "NWLink IPX performance object  IPX ",

    "491",     "NWLink SPX performance object SPX",

    "493",     "NetBEUI performance object  NetBIOS End User Interface ",

    "495",     "NetBEUI Resource performance object  NetBEUI ",

    "497",     "Used Maximum  NetBEUI ()",

    "499",     "Used Average ",

    "501",     "Times Exhausted ()",

    "503",     "NBT Connection performance object  NBT ",

    "505",     "Bytes Received/sec  NBT  NBT ",

    "507",     "Bytes Sent/sec  NBT  NBT ",

    "509",     "Bytes Total/sec  NBT  NBT ",

    "511",     "Network Interface performance object  TCP/IP ",

    "513",     "Bytes Total/sec Network Interface\\Bytes Received/sec  Network Interface\\Bytes Received/sec  Network Interface\\Bytes Sent/sec ",

    "515",     "Packets/sec ",

    "517",     "Packets Received/sec ",

    "519",     "Packets Sent/sec ",

    "521",     "Current Bandwidth /",

    "523",     "Bytes Received/sec Network Interface\\Bytes Received/sec  Network Interface\\Bytes Total/sec ",

    "525",     "Packets Received Unicast/sec ()",

    "527",     "Packets Received Non-Unicast/sec ()",

    "529",     "Packets Received Discarded ",

    "531",     "Packets Received Error ",

    "533",     "Packets Received Unknown ",

    "535",     "Bytes Sent/sec ()Network Interface\\Bytes Sent/sec  Network Interface\\Bytes Total/sec ",

    "537",     "Packets Sent Unicast/sec ",

    "539",     "Packets Sent Non-Unicast/sec ()",

    "541",     "Packets Outbound Discarded ",

    "543",     "Packets Outbound Error ",

    "545",     "Output Queue Length () 2(NDIS) 0",

    "547",     "IP performance object  IP  IP  IP ",

    "549",     "Datagrams/sec () IP  IP ",

    "551",     "Datagrams Received/sec  IP ()Datagrams Received/sec  Datagrams/sec ",

    "553",     "Datagrams Received Header Error  IP  IP ",

    "555",     "Datagrams Received Address Errors  IP  IP (0.0.  0.0)(Class E) IP ",

    "557",     "Datagrams Forwarded/sec  IP  IP ",

    "559",     "Datagrams Received Unknown Protocol ",

    "561",     "Datagrams Received Discarded  IP ()",

    "563",     "Datagrams Received Delivered/sec  IP  Internet  (ICMP)",

    "565",     "Datagrams Sent/sec  IP ( ICMP) IP  Datagrams Forwarded/sec Datagrams Sent/sec  Datagrams/sec ",

    "567",     "Datagrams Outbound Discarded  IP () Datagrams Forwarded/sec ",

    "569",     "Datagrams Outbound No Route  IP  Datagrams Forwarded/sec ",

    "571",     "Fragments Received/sec is  IP ",

    "573",     "Fragments Re-assembled/sec  IP ",

    "575",     "Fragment Re-assembly Failures  IP  IP  ( RFC 815) ",

    "577",     "Fragmented Datagrams/sec ",

    "579",     "Fragmentation Failures  IP  ()",

    "581",     "Fragments Created/sec  IP ",

    "583",     "ICMP performance object  ICMP  ICMP ",

    "585",     "Messages/sec  ICMP ",

    "587",     "Messages Received/sec  ICMP ",

    "589",     "Messages Received Errors  ICMP  ICMP ",

    "591",     "Received Destination Unreachable  ICMP Destination Unreachable ",

    "593",     "Received Time Exceeded  ICMP Time Exceeded ",

    "595",     "Received Parameter Problem  ICMP Parameter Problem ",

    "597",     "Received Source Quench  ICMP Source Quench ",

    "599",     "Received Redirect/sec  ICMP ",

    "601",     "Received Echo/sec  ICMP ",

    "603",     "Received Echo Reply/sec  ICMP ",

    "605",     "Received Timestamp/sec  ICMP ",

    "607",     "Received Timestamp Reply/sec ICMP Timestamp Reply ",

    "609",     "Received Address Mask  ICMP Address Mask Request ",

    "611",     "Received Address Mask Reply  ICMP Address Mask Reply ",

    "613",     "Messages Sent/sec ",

    "615",     "Messages Outbound Errors  ICMP () ICMP  ICMP  IP ",

    "617",     "Sent Destination Unreachable  ICMP Destination Unreachable ",

    "619",     "Sent Time Exceeded  ICMP Time Exceeded ",

    "621",     "Sent Parameter Problem  ICMP Parameter Problem ",

    "623",     "Sent Source Quench  ICMP Source Quench ",

    "625",     "Sent Redirect/sec  ICMP ",

    "627",     "Sent Echo/sec  ICMP Echo ",

    "629",     "Sent Echo Reply/sec  ICMP ",

    "631",     "Sent Timestamp/sec  ICMP ",

    "633",     "Sent Timestamp Reply/sec  ICMP ",

    "635",     "Sent Address Mask  ICMP Address Mask Request ",

    "637",     "Sent Address Mask Reply  ICMP Address Mask Reply ",

    "639",     "TCP performance object  TCP  TCP Segment  TCP  TCP ",

    "641",     "Segments/sec  TCP  TCP segment ",

    "643",     "Connections Established  ESTABLISHED  CLOSE-WAIT  TCP ",

    "645",     "Connections Active  TCP  CLOSED  SYN-SENT ",

    "647",     "Connections Passive  TCP  LISTEN  SYN-RCVD ",

    "649",     "Connection Failures  TCP  SYN-SENT  CLOSED  SYN-RCVD  TCP  SYN-RCVD  LISTEN ",

    "651",     "Connections Reset  TCP  ESTABLISHED  CLOSE-WAIT  CLOSED ",

    "653",     "Segments Received/sec ()",

    "655",     "Segments Sent/sec ",

    "657",     "Segments Retransmitted/sec ",

    "659",     "UDP performance object  UDP  UDP  UDP ",

    "661",     "Datagrams/sec  UDP ",

    "663",     "Datagrams Received/sec  UDP  UDP ",

    "665",     "Datagrams No Port/sec  UDP ",

    "667",     "Datagrams Received Error () UDP ",

    "669",     "Datagrams Sent/sec  UDP ",

    "671",     "",

    "673",     "",

    "675",     "System Up Time ()",

    "677",     "",

    "679",     "Free System Page Table Entries ",

    "681",     "",

    "683",     "",

    "685",     "()",

    "687",     "Alignment Fixups/sec ",

    "689",     "Exception Dispatches/sec ",

    "691",     "Floating Emulations/sec ",

    "693",     "Logon/sec ",

    "695",     "",

    "697",     "",

    "699",     "()",

    "701",     "Paging File performance object ",

    "703",     " Page File  Process\\Page File Bytes",

    "705",     " Page File  Process\\Page File Bytes Peak",

    "707",     "",

    "709",     "",

    "711",     "Mapped Space ()",

    "713",     "Mapped Space ()",

    "715",     "Mapped Space ()/",

    "717",     "Mapped Space ()",

    "719",     "Mapped Space ()",

    "721",     "Mapped Space ()/",

    "723",     "Mapped Space ()//",

    "725",     "Mapped Space ()",

    "727",     "Reserved Space ",

    "729",     "Reserved Space ",

    "731",     "Reserved Space /",

    "733",     "Reserved Space /",

    "735",     "Reserved Space ",

    "737",     "Reserved Space /",

    "739",     "Reserved Space //",

    "741",     "Image performance object ",

    "743",     "Reserved Space ",

    "745",     "Unassigned Space ",

    "747",     "Unassigned Space ",

    "749",     "Unassigned Space /",

    "751",     "Unassigned Space /",

    "753",     "Unassigned Space ",

    "755",     "Unassigned Space /",

    "757",     "Unassigned Space //",

    "759",     "Unassigned Space ",

    "761",     "Image Space ",

    "763",     "Image Space ",

    "765",     "Image Space /",

    "767",     "Image Space /",

    "769",     "Image Space ",

    "771",     "Image Space /",

    "773",     "Image Space //",

    "775",     "Image Space ",

    "777",     "Bytes Image Reserved ",

    "779",     "Bytes Image Free ",

    "781",     "Bytes Reserved ",

    "783",     "Bytes Free ",

    "785",     "ID Process ID Process  ID Process ",

    "787",     "Process Address Space performance object ",

    "789",     "Image Space ",

    "791",     "Image Space ",

    "793",     "Image Space /",

    "795",     "Image Space /",

    "797",     "Image Space ",

    "799",     "Image Space /",

    "801",     "Image Space //",

    "803",     "Image Space ",

    "805",     "ID Thread ID Thread ",

    "807",     "Mailslot Opens Failed/sec ",

    "809",     "Duplicate Master Announcement ",

    "811",     "Illegal Datagrams/sec ",

    "813",     "Announcements Total/sec  Announcements Server/sec  Announcements Domain/sec ",

    "815",     "Enumerations Total/sec  Enumerations Server/secEnumerations Domain/sec  Enumerations Other/sec ",

    "817",     "Thread Details performance object ",

    "819",     "Cache Bytes  Memory\\System Cache Resident Bytes Memory\\System Driver Resident BytesMemory\\System Code Resident Bytes  Memory\\Pool Paged Resident Bytes ",

    "821",     "Cache Bytes Peak ",

    "823",     "Pages Input/sec  Memory\\Pages Input/sec   Memory\\Page Reads/sec ",

    "825",     "Transition Pages RePurposed ()()",

    "871",     "RAS performance object  RAS ",

    "873",     "",

    "875",     "",

    "877",     "",

    "879",     "",

    "881",     "",

    "883",     "",

    "885",     " CRC  CRC ",

    "887",     "",

    "889",     "",

    "891",     "",

    "893",     "",

    "895",     " CRC",

    "897",     "",

    "899",     "",

    "901",     "",

    "903",     "",

    "905",     " CRC",

    "907",     "RAS performance object (RAS)",

    "909",     "",

    "921",     "WINS Server performance object  WINS ",

    "923",     "Unique Registrations/sec  WINS ",

    "925",     "Group Registrations/sec  WINS ",

    "927",     "Total Number of Registrations/sec  WINS ",

    "929",     "Unique Renewals/sec  WINS ",

    "931",     "Group Renewals/sec  WINS ",

    "933",     "Total Number of Renewals/sec  WINS ",

    "935",     "Total Number of Releases/sec  WINS ",

    "937",     "Total Number of Queries/sec  WINS ",

    "939",     "Unique Conflicts/sec  WINS /",

    "941",     "Group Conflicts/sec  WINS /",

    "943",     "Total Number of Conflicts/sec  WINS ",

    "945",     "",

    "947",     "",

    "949",     "",

    "951",     "",

    "953",     "",

    "1001",     "Macintosh AFP ",

    "1003",     " MacFile ",

    "1005",     " MacFile ",

    "1007",     " MacFile ",

    "1009",     " MacFile ",

    "1011",     " MacFile ",

    "1013",     " MacFile ",

    "1015",     " MacFile  Macintosh ",

    "1017",     " MacFile  Macintosh ",

    "1019",     " MacFile ",

    "1021",     "",

    "1023",     "",

    "1025",     "",

    "1027",     "",

    "1029",     "",

    "1031",     "",

    "1033",     "MacFile ",

    "1035",     "MacFile ",

    "1051",     "AppleTalk ",

    "1053",     " Appletalk ",

    "1055",     " Appletalk ",

    "1057",     " Appletalk ",

    "1059",     " Appletalk ",

    "1061",     " DDP ()",

    "1063",     " Appletalk  DDP ",

    "1065",     " AARP ()",

    "1067",     " Appletalk  AARP ",

    "1069",     " ATP ()",

    "1071",     " Appletalk  ATP ",

    "1073",     " NBP ()",

    "1075",     " Appletalk  NBP ",

    "1077",     " ZIP ()",

    "1079",     " Appletalk  ZIP ",

    "1081",     " RTMP ()",

    "1083",     " Appletalk  RTMP ",

    "1085",     " ATP ",

    "1087",     " ATP ",

    "1089",     " ATP ",

    "1091",     " ATP ",

    "1093",     " ATP ",

    "1095",     " AppleTalk ",

    "1097",     "",

    "1099",     "",

    "1101",     " ATP ",

    "1103",     "",

    "1111",     "",

    "1113",     "",

    "1115",     "",

    "1117",     "",

    "1119",     "",

    "1121",     "",

    "1125",     "",

    "1127",     "",

    "1151",     "",

    "1153",     "",

    "1155",     "",

    "1157",     "",

    "1159",     "",

    "1161",     "",

    "1163",     "",

    "1165",     "",

    "1167",     "",

    "1169",     "",

    "1229",     "Gateway Service For NetWare performance object ",

    "1231",     "Client Service For NetWare object ",

    "1233",     "Packet Burst Read NCP Count/sec  NetWare Core Protocol  Packet Burst Read Packet Burst  ",

    "1235",     "Packet Burst Read Timeouts/sec  NetWare NetWare  Burst Read Request ",

    "1237",     "Packet Burst Write NCP Count/sec  NetWare Core Protocol  Packet Burst Write Packet Burst ",

    "1239",     "Packet Burst Write Timeouts/sec  NetWare NetWare  Burst Write Request ",

    "1241",     "Packet Burst IO/sec  Packet Burst Read NCPs/sec  Packet Burst Write NCPs/sec ",

    "1243",     "Connect NetWare 2.x  NetWare 2.x ",

    "1245",     "Connect NetWare 3.x  NetWare 3.x ",

    "1247",     "Connect NetWare 4.x  NetWare 4.x ",

    "1261",     "Logon Total ",

    "1301",     "Server Work Queues performance object ",

    "1303",     "Queue Length  CPU ",

    "1305",     "Active Threads  CPU  CPU ",

    "1307",     "Available Threads  CPU ",

    "1309",     " CPU  CPU  MinFreeWorkItems  Blocking Queue ",

    "1311",     " CPU  CPU  CPU  'MaxWorkItems'  'MinFreeWorkItems'  Blocking Queue ",

    "1313",     " CPU  'MaxWorkItems'  Blocking Queue ",

    "1315",     "Current Clients  CPU  CPU  Blocking Queue ",

    "1317",     " CPU ",

    "1319",     " CPU ",

    "1321",     " CPU ",

    "1323",     "Read Operations/sec  CPU  Blocking Queue ",

    "1325",     "Read Bytes/sec  CPU ",

    "1327",     "Write Operations/sec  CPU  Blocking Queue ",

    "1329",     "Write Bytes/sec  CPU ",

    "1331",     "Total Bytes/sec  CPU ",

    "1333",     "Total Operations/sec  CPU  Blocking Queue ",

    "1335",     "DPCs Queued/sec  (DPC)  DPC DPC  DPC  DPC  DPC ",

    "1337",     "DPC Rate  (DPC)  DPC DPC  DPC  DPC  DPC ",

    "1343",     "Total DPCs Queued/sec (DPC) DPC (DPC ) DPC  DPC  DPC Processor: DPCs Queued/sec ",

    "1345",     "Total DPC Rate (DPC) DPC (DPC ) DPC DPC  DPC Processor: DPC Bypasses/sec ",

    "1351",     "% Registry Quota In Use  Total Registry Quota Allowed ",

    "1361",     "",

    "1363",     "VLM % Virtual Size In Use",

    "1365",     " VLM ",

    "1367",     " VLM  VLM ",

    "1369",     " VLM ",

    "1371",     " VLM ",

    "1373",     " VLM ",

    "1375",     " VLM ",

    "1377",     " VLM ",

    "1379",     " VLM ",

    "1381",     "Available KBytes  KB () MSDN / Windows Server 2003 Resource Kit ",

    "1383",     "Available MBytes  MB () MSDN / Windows Server 2003 Resource Kit ",

    "1401",     "Avg. Disk Queue Length ()",

    "1403",     "Avg. Disk Read Queue Length ()",

    "1405",     "Avg. Disk Write Queue Length ()",

    "1407",     "% Committed Bytes In Use  Memory\\Committed Bytes  Memory\\Commit Limit (Committed memory Commit Limit )",

    "1409",     "Full Image performance object Full Image counter  Image object  Full Image object  Image object ",

    "1411",     "Creating Process ID value  Process ID",

    "1413",     " I/O  I/O ",

    "1415",     " I/O  I/O ",

    "1417",     "/ I/O  I/O ",

    "1419",     "/ I/O  I/O ",

    "1421",     " I/O  I/O ",

    "1423",     " I/O ",

    "1425",     " I/O / I/O ",

    "1427",     " I/O () I/O ",

    "1451",     "",

    "1453",     "",

    "1455",     "",

    "1457",     " GDI ",

    "1459",     "",

    "1461",     "()",

    "1463",     "()",

    "1465",     "",

    "1467",     "",

    "1469",     "",

    "1471",     "",

    "1473",     "",

    "1475",     "",

    "1477",     "",

    "1479",     "Working Set - ",

    "1481",     "Working Set - ",

    "1483",     "% Idle Time ",

    "1485",     "Split IO/Sec  I/O  I/O  I/O  I/O ",

    "1501",     "",

    "1503",     "Current % Processor Time ",

    "1505",     "Current % User mode Time ",

    "1507",     "Current % Kernel mode Time ",

    "1509",     "This Period mSec - Processor ",

    "1511",     "This Period mSec - ",

    "1513",     "This Period mSec - ",

    "1515",     "Pages/Sec ",

    "1517",     "Process Count - ()",

    "1519",     "Process Count - ",

    "1521",     "Process Count - ",

    "1523",     "Total mSec - ",

    "1525",     "Total mSec - ",

    "1527",     "Total mSec - ",

    "1549",     "% Job object Detail ",

    "1537",     "Received Packet Too Big ",

    "1539",     "Received Membership Query ",

    "1541",     "Received Membership Report ",

    "1543",     "Received Membership Reduction ",

    "1545",     "Received Router Solicit ",

    "1547",     "Received Router Advert ",

    "1551",     "Received Neighbor Solicit ",

    "1553",     "Received Neighbor Advert ",

    "1555",     "Sent Packet Too Big ",

    "1557",     "Sent Membership Query ",

    "1559",     "Sent Membership Report ",

    "1561",     "Sent Membership Reduction ",

    "1563",     "Sent Router Solicit ",

    "1565",     "Sent Router Advert is ",

    "1567",     "Sent Neighbor Solicit ",

    "1569",     "Sent Neighbor Advert ",

    "1747",     "% Idle Time ",

    "1749",     "% C1 Time  C1 % C1 Time C1  % C1 ",

    "1751",     "% C2 Time  C2 % C2 Time C2 C2  C1  C2 ",

    "1753",     "% C3 Time  C3 % C3 Time  C3 C3  C3  C3 ",

    "1755",     "C1 Transitions/sec  CPU  C1 CPU  C1 ",

    "1757",     "C2 Transitions/sec  CPU  C2 CPU  C2 ",

    "1759",     "C3 Transitions/sec  CPU  C3 CPU  C3 ",

    "1761",     "",

    "1763",     "(FreeBytes + AllocatedBytes)",

    "1765",     "()",

    "1767",     "ReservedBytes ",

    "1769",     " freelists ()",

    "1771",     " 1k ",

    "1773",     "1/Average time per allocation ( allocs)",

    "1775",     "1/Average time per free ( frees)",

    "1777",     "",

    "1779",     "allocations  frees ()",

    "1781",     " Allocations/sec",

    "1783",     " Frees/sec",

    "1785",     " 1k  Allocations/sec ()",

    "1787",     " 1k  Frees/sec ()",

    "1789",     " 1-8k  Allocations/sec ",

    "1791",     " 1-8k  Frees/sec ",

    "1793",     " 8k  Allocations/sec ",

    "1795",     " 8k  Frees/sec ",

    "1797",     "Allocations/sec ()",

    "1799",     "Frees/sec ()",

    "1801",     "",

    "1803",     "",

    "1805",     "(FreeBytes / CommittedBytes) *100",

    "1807",     "(VirtualBytes / ReservedBytes) * 100",

    "1809",     " Collisions/sec ",

    "1847",     "",
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\br\perfh016.ini ===
"3",     "O objeto de desempenho de sistema consiste em contadores que se aplicam a mais de uma instncia de um processador de componente no computador. ",

    "5",     "O objeto de desempenho de memria consiste em contadores que descrevem o comportamento das memrias fsica e virtual no computador. A memria fsica  a quantidade de memria de acesso randmico no computador. A memria virtual consiste no espao em memria fsica e no disco. Muitos dos contadores de memria monitoram a paginao, que  o movimento de pginas de cdigo e dados entre a memria de disco e fsica. O excesso de paginao, um sintoma de escassez de memria, pode provocar retardos que interferem em todos os processos do sistema.",

    "7",     "'% tempo de processador'  o percentual de tempo decorrido que o processador gasta para executar um segmento ocupado. Ele  calculado medindo a durao do segmento ocioso que est ativo no intervalo de exemplo e subtraindo esse tempo da durao do intervalo (cada processador possui um segmento ocioso que consome ciclos quando nenhum outro segmento est pronto para execuo). Esse contador  o principal indicador da atividade do processador e exibe o percentual mdio do tempo de ocupao observado durante o intervalo de exemplo. Ele  calculado monitorando o tempo em que o servio est inativo e subtraindo esse valor de 100%.",

    "9",     "'% tempo total de DPC'  o percentual de tempo mdio que todos os processadores gastam recebendo e atendendo as DPCs (chamadas de procedimento deferidas). As DPCs so interrupes que funcionam em uma prioridade mais baixa que as interrupes padro.  a soma do Processador: '% tempo de DPC total' de todos os processadores no computador, dividido pelo nmero de processadores. Sistema: % '% tempo de DPC total'  um componente do Sistema: '% tempo total privilegiado' porque as DPCs so executadas em modo privilegiado. As DPCs so contadas separadamente e no so um componente da contagem de interrupo. Este contador exibe o tempo mdio de ocupao como um percentual do tempo de exemplo.",

    "11",     "Operaes de leitura de arquivo/s  a taxa combinada de solicitaes de leitura do sistema de arquivos para todos os dispositivos no computador, inclusive as solicitaes de leitura do cache do sistema de arquivos. A medida  em nmero de leituras. Esse contador exibe a diferena entre os valores observados nas duas ltimas amostragens, dividida pela durao do intervalo de amostragem.  ",

    "13",     "'Operaes de gravao de arquivo/s'  a taxa combinada das solicitaes de gravao do sistema de arquivos para todos os dispositivos no computador, incluindo as solicitaes para gravar dados no cache do sistema de arquivos. A medida  em nmero de gravaes. Esse contador exibe a diferena entre os valores observados nos dois ltimos exemplos, dividida pela durao do intervalo de exemplo.",

    "15",     "'Operaes de controle de arquivo/s'  a taxa combinada de operaes do sistema de arquivos que no sejam leituras nem gravaes, tais como solicitaes de controle do sistema de arquivos e solicitaes para obter informaes sobre as caractersticas ou status do dispositivo. Isso  o inverso de 'Sistema: operaes de dados de arquivo/s' e  medido em nmero de operaes por segundo. Esse contador exibe a diferena entre os valores observados nas duas ltimas amostragens, dividida pela durao do intervalo de amostragem. ",

    "17",     "'Bytes de leitura de arquivo/s'  a taxa geral em que os bytes so lidos para satisfazer s solicitaes de leitura do sistema de arquivos para todos os dispositivos no computador, inclusive as leituras do cache do sistema de arquivos. A medida  em nmero de bytes por segundo. Esse contador exibe a diferena entre os valores observados nas duas ltimas amostragens, dividida pela durao do intervalo de amostragem.  ",

    "19",     "'Bytes de gravao de arquivo/s'  a taxa geral em que os bytes so gravados para satisfazer s solicitaes de gravao do sistema de arquivos para todos os dispositivos no computador, inclusive as gravaes no cache do sistema de arquivos. A medida  em nmero de bytes por segundo. Esse contador exibe a diferena entre os valores observados nas duas ltimas amostragens, dividida pela durao do intervalo de amostragem.  ",

    "21",     "'Bytes de controle de arquivo/s'  a taxa geral em que os bytes so transferidos para todas as operaes do sistema de arquivos que no sejam leituras ou gravaes, inclusive as solicitaes de controle do sistema de arquivos e as solicitaes para informaes sobre as caractersticas ou status do dispositivo.  medida em nmeros de bytes. Esse contador exibe a diferena entre os valores observados nas duas ltimas amostragens, dividida pela durao do intervalo de amostragem. ",

    "23",     "'% tempo total de interrupo'  a porcentagem de tempo mdia que todos os processadores gastam recebendo e atendendo a interrupes de hardware durante os intervalos de amostragem, em que o valor  um indicador indireto da atividade dos dispositivos que geram interrupes. Essa  a soma de 'Processador: % tempo de interrupo' de todos os processadores do computador, dividida pelo nmero de processadores. Os DPCs so contados separadamente e no so um componente da contagem de interrupes. Este valor  um indicador indireto da atividade dos dispositivos que geram interrupes, como o timer do sistema, o mouse, drivers de disco, linhas de comunicao de dados, placas de interface de rede e outros perifricos. ",

    "25",     "'Bytes disponveis'  a quantidade de memria fsica, em bytes, imediatamente disponvel para alocao para um processo ou para uso pelo sistema. Ela  igual  soma da memria designada para as listas em espera (armazenada em cache), livre e de zero pgina. Para obter uma explicao completa sobre o gerenciador de memria, consulte a MSDN e/ou o captulo 'System Performance and Troubleshooting Guide' no Windows Server 2003 Resource Kit.",

    "27",     "'Bytes confirmados'  a quantidade de memria virtual confirmada, em bytes. Memria confirmada  a memria fsica que tem espao reservado no(s) arquivo(s) de paginao de disco. Pode haver um ou mais arquivos de paginao em cada unidade fsica. Este contador exibe apenas o ltimo valor observado; ele no  uma mdia.",

    "29",     "'Falhas de pginas/seg'  o nmero mdio de falhas de pginas por segundo.  medido em nmero de falhas de pginas por segundo porque h somente uma falha de pgina em cada operao com falha; portanto,  igual tambm ao nmero de operaes com falha de pgina. Esse contador inclui falhas de hardware (aquelas que exigem acesso a disco) e software (em que a falha de pgina encontra-se em outro lugar na memria fsica). A maioria dos processadores pode tratar grandes nmeros de falhas de software sem conseqncias significativas. Entretanto, as falhas de hardware, que exigem acesso a disco, podem causar atrasos significativos.",

    "31",     "'Limite de confirmao'  a quantidade de memria virtual que pode ser confirmada sem precisar estender os arquivos de paginao.  medido em bytes. A memria confirmada  a memria fsica que tem espao reservado nos arquivos de paginao de disco. Pode haver um arquivo de paginao em cada unidade lgica. Se os arquivos de paginao forem expandidos, esse limite aumenta na mesma medida. Esse contador exibe apenas o ltimo valor observado, ele no  uma mdia.",

    "33",     "'Cpias de gravao/s'  a freqncia com a qual ocorrem falhas de pginas causadas por tentativas de gravao que foram atendidas por cpia da pgina de outro local da memria fsica. Essa  uma maneira econmica de compartilhar dados, pois as pginas so copiadas somente se algo for gravado nelas; caso contrrio, as pginas so compartilhadas. Esse contador mostra o nmero de cpias, sem considerar o nmero de pginas copiadas em cada operao.",

    "35",     "'Falhas de transio/s'  a freqncia com a qual as falhas de pginas so resolvidas atravs da recuperao de pginas que estavam sendo utilizadas por outro processo que compartilhava a pgina ou estavam na lista de pginas modificadas ou na lista de espera, ou estavam sendo gravadas em disco no momento da falha. As pginas so recuperadas sem atividade adicional do disco. As falhas de transio so contadas em nmero de falhas. Como somente uma pgina falha em cada operao, isso tambm eqivale ao nmero de pginas com falha.",

    "37",     "'Falhas de cache/s'  a taxa em que as falhas ocorrem quando uma pgina apontada no cache do sistema de arquivos no  encontrada e deve ser recuperada a partir de outro lugar da memria (uma falha leve) ou do disco (uma falha grave). O cache do sistema de arquivos  uma rea da memria fsica que armazena as pginas de dados usadas recentemente para os aplicativos. A atividade do cache  um indicador confivel da maioria das operaes de E/S do aplicativo. Esse contador mostra o nmero de falhas, sem se preocupar com o nmero de pginas erradas em cada operao.",

    "39",     "'Falhas de demanda zero/s'  a taxa na qual uma pgina zerada  exigida para satisfazer a falha. Pginas zeradas, pginas esvaziadas de dados armazenados anteriormente e preenchidas com zeros, so um recurso de segurana do Windows que evita que os processos vejam os dados armazenados por processos mais antigos que usaram o espao de memria. O Windows mantm uma lista de pginas zeradas para acelerar esse processo. Esse contador mostra o nmero de falhas, sem considerar o nmero de pginas recuperadas para satisfazer a falha. Esse contador exibe a diferena entre os valores observados nos dois ltimos exemplos, dividida pela durao do intervalo de exemplo.",

    "41",     "'Pginas/s'  a taxa em que as pginas so lidas do ou gravadas no disco para resolver as falhas de pginas de hardware. Esse contador  um indicador primrio dos tipos de falhas que causam atrasos no sistema todo.  a soma de 'Memria\\Entrada de pginas/s' e 'Memria\\Sada de pginas/seg'. Conta-se em nmero de pginas; portanto, pode ser comparado com outros contadores de pgina, como 'Memria\\Falhas de pginas/seg', sem converso. Inclui as pginas recuperadas para satisfazer s falhas dos arquivos mapeados de memria no-cache do cache do sistema de arquivos (normalmente solicitado pelos aplicativos).",

    "43",     "'Leituras de pgina/s'  a taxa em que o disco foi lido para resolver as falhas de pginas de hardware. Mostra o nmero de operaes de leitura, sem se preocupar com o nmero de pginas recuperadas em cada operao. As falhas de pginas de hardware ocorrem quando um processo refere-se a uma pgina na memria virtual que no est no conjunto de trabalho ou em outro lugar na memria fsica e deve ser recuperada do disco. Esse contador  um indicador primrio dos tipos de falhas que causam atrasos no sistema todo. Ele inclui operaes de leitura para satisfazer s falhas no cache do sistema de arquivos (normalmente solicitadas pelos aplicativos) e em arquivos de memria mapeados que no esto armazenados em cache. Compare o valor de 'Memria\\Leituras de pgina/s' com o valor de 'Memria\\Entrada de pginas/s' para determinar o nmero mdio de pginas lidas durante cada operao.",

    "45",     "'Comprimento da fila de processador'  o nmero de segmentos na fila do processador. Ao contrrio dos contadores de disco, esse contador mostra apenas os segmentos prontos, e no os segmentos em execuo. H uma fila nica para o tempo de processador mesmo em computadores com vrios processadores. Portanto, se um computador possui vrios processadores, voc precisa dividir esse valor pelo nmero de processadores que atendem  carga de trabalho. Uma fila de processadores mantidos com menos de 10 segmentos por processador normalmente  aceitvel, dependendo da carga de trabalho.",

    "47",     "'Estado de segmento'  o estado atual do segmento, que pode ser 0 para 'Inicializado', 1 para 'Pronto', 2 para 'Em execuo', 3 para 'Espera', 4 para 'Finalizado', 5 para 'Aguardar', 6 para 'Transio', 7 para 'Desconhecido'. Um segmento em execuo est utilizando um processador. Um segmento em espera est prestes a utilizar um processador. Um segmento pronto deseja usar um processador, mas no h nenhum livre. Um segmento em transio est aguardando um recurso para ser executado como, por exemplo, aguardando que sua pilha de execuo seja paginada a partir do disco. Um segmento que aguarda no tem uso para o processador porque est aguardando a concluso de uma operao perifrica ou a liberao de um recurso.",

    "49",     "'Sada de pginas/seg'  a taxa em que as pginas so gravadas no disco para liberar espao na memria fsica. As pginas so gravadas no disco somente se forem alteradas na memria fsica; portanto, provavelmente so destinadas a armazenar dados, no cdigo. Uma alta taxa de sada de pginas pode indicar memria insuficiente. O Windows grava mais pginas no disco para liberar espao, quando a memria fsica  pequena. Esse contador mostra o nmero de pginas e pode ser comparado com outras contagens de pginas, sem converso.",

    "51",     "'Gravaes de pgina/s'  a taxa em que as pginas so gravadas no disco para liberar espao na memria fsica. As pginas so gravadas no disco apenas se forem alteradas enquanto esto na memria fsica; portanto, provavelmente elas so destinadas a armazenar dados, no cdigo. Esse contador mostra as operaes de gravao, sem considerar o nmero de pginas gravadas em cada operao. Esse contador exibe a diferena entre os valores observados nos dois ltimos exemplos, dividida pela durao do intervalo de exemplo.",

    "53",     "O objeto de desempenho de navegador consiste em contadores que medem a freqncia de anncios, enumeraes e outras transmisses do navegador.",

    "55",     "'Anncios de servidor/s'  a taxa com a qual os servidores neste domnio se anunciaram para este servidor.",

    "57",     "'Bytes de pool paginvel'  o tamanho, em bytes, do pool paginvel, uma rea da memria do sistema (memria fsica usada pelo sistema operacional) para objetos que podem ser gravados em disco quando no esto sendo usados. 'Memria\\Bytes de memria paginvel'  calculado de maneira diferente de 'Processo\\Bytes de memria paginvel'; portanto, diferente de 'Processo\\Bytes de memria paginvel\\_Total'. Esse contador exibe apenas o ltimo valor observado; no  uma mdia.",

    "59",     "'Bytes de pool no-paginvel'  o tamanho, em bytes, do pool no-paginvel. Uma rea da memria do sistema (memria fsica usada pelo sistema operacional) para objetos que no podem ser gravados em disco, mas permanecem na memria fsica enquanto estiverem alocados. 'Memria\\Bytes de memria no-paginvel'  calculado de maneira diferente de Processo\\'Bytes de memria no-paginvel'; portanto, diferente de 'Processo\\Bytes de memria no-paginvel\\_Total'. Esse contador exibe somente o ltimo valor observado; no  uma mdia.",

    "61",     "'Alocaes de pool paginvel'  o nmero de chamadas para alocar espao no pool paginvel. O pool paginvel  uma rea da memria dos sistema (memria fsica usada pelo sistema operacional) para objetos que podem ser gravados em disco, quando no esto sendo usados.  medido em nmeros de chamadas para alocar espao, independentemente da quantidade de espao alocado em cada chamada. Esse contador exibe apenas o ltimo valor observado; no  uma mdia.",

    "63",     "'Bytes residentes de pool paginvel'  o tamanho atual, em bytes, do pool paginvel. O pool paginvel  uma rea da memria do sistema (memria fsica usada pelo sistema operacional) para objetos que podem ser gravados em disco quando no esto sendo usados. O espao usado pelos pools paginveis e no paginveis so tomados da memria fsica; portanto, um pool muito grande nega espao de memria aos processos. Esse contador exibe apenas o ltimo valor observado; no  uma mdia.",

    "65",     "'Alocaes de pool no-paginvel'  o nmero de chamadas para alocar espao no pool no-paginvel. O pool no-paginvel  uma rea da memria do sistema para objetos que no podem ser gravados em disco e devem permanecer na memria fsica enquanto estiverem alocados.  medido em nmeros de chamadas para alocar espao, independentemente da quantidade de espao alocado em cada chamada. Esse contador exibe apenas o ltimo valor observado; no  uma mdia.",

    "67",     "'Total de bytes/s'  a taxa total de bytes enviados a ou recebidos pela rede por meio do protocolo, mas apenas para os quadros (pacotes) que contm dados. Esta  a soma de 'Bytes de quadro/s' e 'Bytes de datagramas/s'.",

    "69",     "'Total de bytes de cdigo do sistema'  o tamanho, em bytes, do cdigo do sistema operacional paginvel atualmente na memria virtual.  uma parcela do total de memria fsica utilizada pelo sistema operacional que pode ser gravada em disco quando no estiver em uso. Esse valor  calculado atravs da soma dos bytes em Ntoskrnl.exe, Hal.dll, dos drivers de inicializao e dos sistemas de arquivos carregados por Ntldr/osloader. Esse contador no inclui cdigo que tenha que permanecer em memria fsica e no possa ser gravado em disco. Esse contador exibe somente o ltimo valor observado; no  uma mdia.",

    "71",     "'Bytes residentes de cdigo do sistema'  o tamanho, em bytes, do cdigo do sistema operacional atualmente na memria fsica que pode ser gravado em disco quando no estiver em uso. Esse valor  um componente de 'Memria\\\\Total de bytes no cdigo do sistema', que tambm inclui o cdigo do sistema operacional em disco. 'Memria\\\Bytes residentes no cdigo do sistema' (e 'Memria\\\\Total de bytes de cdigo do sistema') no inclui cdigo que tenha que permanecer em memria fsica e no possa ser gravado em disco. Esse contador exibe somente o ltimo valor observado; no  uma mdia.",

    "73",     "'Total de bytes de driver do sistema'  o tamanho, em bytes, da memria virtual paginvel atualmente em utilizao por drivers de dispositivo. A memria paginvel pode ser gravada em disco quando no estiver em uso. Ela inclui memria fsica (Memria\\Bytes residentes de drivers do sistema) e cdigo e dados paginados para o disco.  um componente de 'Memria\\Total de bytes de cdigo do sistema'. Esse contador exibe somente o ltimo valor observado; no  uma mdia.  ",

    "75",     "'Bytes residentes de driver do sistema'  o tamanho, em bytes, da memria fsica paginvel sendo utilizada pelos drivers de dispositivo.  o conjunto de trabalho (rea da memria fsica) dos drivers. Esse valor  um componente de 'Memria\\Total de bytes de drivers do sistema', que tambm inclui memria de driver gravada em disco. Nem 'Memria\\Bytes residentes de drivers do sistema' nem 'Memria\\Total de bytes de driver do sistema' inclui memria que no possa ser gravada em disco.",

    "77",     "'Bytes residentes de cache do sistema'  o tamanho, em bytes, do cdigo do sistema operacional paginvel no cache do sistema de arquivos. Esse valor inclui somente pginas fsicas atuais e no inclui nenhuma pgina de memria virtual que no esteja residente no momento. Esse valor no  igual ao valor do cache do sistema exibido no 'Gerenciador de tarefas'. Por isso, esse valor pode ser menor que o tamanho real da memria virtual sendo usada pelo cache do sistema de arquivos. Esse valor  um componente de 'Memria\\Bytes residentes de cdigo do sistema' que representa todo o cdigo de sistema operacional paginvel atualmente na memria fsica. Esse contador exibe somente o ltimo valor observado; no  uma mdia. ",

    "79",     "'Anncios de domnio/s'  a taxa  qual um domnio se anuncia  rede.",

    "81",     "'Pacotes de seleo/s'  a taxa  qual pacotes de seleo de navegador foram recebidos por esta estao de trabalho.",

    "83",     "'Gravaes de processador de mensagens/s'  a taxa  qual mensagens do processador de mensagens foram recebidas com xito.",

    "85",     "'Solicitaes de lista do servidor/s'  a taxa em que as solicitaes para recuperar uma lista de servidores do navegador foram processadas por essa estao de trabalho.",

    "87",     "O objeto de desempenho de cache consiste em contadores que monitoram o cache do sistema de arquivos, uma rea da memria fsica que armazena dados recentemente utilizados o maior tempo possvel para permitir acesso a eles sem necessidade de ler no disco. Como os aplicativos geralmente usam o cache, este  monitorado como um indicador das operaes de E/S dos aplicativos. Quando h bastante memria, o cache pode aumentar, mas quando a memria  pequena, o cache pode ser pequeno demais e tornar-se ineficaz.",

    "89",     "'Mapeamentos de dados/s'  a freqncia que um sistema de arquivos, como, por exemplo, o NTFS, mapeia uma pgina de um arquivo no cache do sistema de arquivos para ler a pgina.",

    "91",     "'Mapeamentos de dados sncronos/s' conta a freqncia com a qual um sistema de arquivos, como o NTFS, mapeia a pgina de um arquivo no cache do sistema de arquivos para ler a pgina, e aguarda a recuperao da pgina caso ela no esteja na memria principal.",

    "93",     "'Mapeamentos de dados assncronos/s'  a freqncia com que um aplicativo usando um sistema de arquivos, como, por exemplo, o NTFS, mapeia uma pgina de arquivo no cache do sistema de arquivos para ler a pgina e no espera a pgina ser recuperada, caso no esteja na memria principal.",

    "95",     "'% acertos de mapas de dados'  o percentual de mapas de dados no cache do sistema de arquivos que poderia ser resolvido sem precisar recuperar uma pgina do disco, porque a pgina j estava na memria fsica.",

    "97",     "'Mapas de dados fixados/s'  a freqncia de mapas de dados no cache do sistema de arquivos que resultou na fixao de uma pgina na memria principal, uma ao normalmente preparatria para a gravao no arquivo em disco. Quando fixado, o endereo fsico da pgina na memria principal e o endereo virtual no cache do sistema de arquivos no sero alterados.",

    "99",     "'Leituras fixadas/s'  a freqncia de dados de leitura preparatria no cache do sistema de arquivos para gravar os dados de volta no disco. As pginas lidas dessa maneira so fixadas na memria aps a leitura. Quando fixado, o endereo fsico de uma pgina no cache do sistema de arquivos no  alterado.",

    "101",     "'Leituras fixadas sncronas/s'  a freqncia de leitura de dados para o cache do sistema de arquivos antes da gravao dos dados de volta no disco. As pginas lidas dessa forma so fixadas na memria quando a leitura  concluda. O sistema de arquivos s reassumir o controle depois que a pgina for fixada no cache do sistema de arquivos, particularmente se o disco tiver que ser acessado para recuperao da pgina. Enquanto estiver fixado, o endereo fsico de uma pgina no cache do sistema de arquivos no ser alterado.",

    "103",     "'Leituras fixadas asssncronas/s'  a freqncia de leitura de dados preparatria no cache do sistema de arquivos para gravar os dados de volta no disco. As pginas lidas dessa maneira so fixadas na memria aps a leitura. O sistema de arquivos obter novamente o controle imediatamente, mesmo se o disco precisar ser acessado para recuperar a pgina. Quando fixado, o endereo fsico da pgina no ser alterado.",

    "105",     "'Acertos de leituras de fixao'  o percentual de solicitaes de leitura de fixao que ocorrem no cache do sistema de arquivos, ou seja, no exigem uma leitura de disco para fornecer acesso  pgina no cache do sistema de arquivos. Quando fixado, o endereo fsico de uma pgina no cache do sistema de arquivos no  alterado. O redirecionador da rede local usa esse mtodo para recuperar os dados do cache, enquanto o servidor de rede local o usa para fazer pequenas transferncias. Normalmente, esse tambm  o mtodo usado pelo sistema de arquivos de disco.",

    "107",     "'Leituras de cpia/s'  a freqncia de leituras das pginas do cache do sistema de arquivos que envolve uma cpia de memria dos dados a partir do cache para o buffer do aplicativo. O redirecionador de rede local usa esse mtodo para recuperar as informaes do cache do sistema de arquivos, enquanto o servidor de rede local o usa para pequenas transferncias. Esse mtodo tambm  usado pelos sistemas de arquivo de disco.",

    "109",     "'Leituras de cpia sncronas/s'  a freqncia de leituras de pginas do cache do sistema de arquivos que envolvam uma cpia da memria dos dados do cache para o buffer do aplicativo. O sistema de arquivos s reassumir o controle aps o trmino da operao de cpia, mesmo que o disco precise ser acessado para recuperao da pgina.",

    "111",     "'Leituras de cpia assncronas/s'  a freqncia de leituras de pginas da cache do sistema de arquivos que envolvem uma cpia de memria dos dados da cache para o buffer do aplicativo. O aplicativo retoma o controle imediatamente, mesmo que o disco deva ser acessado para recuperar a pgina.",

    "113",     "'% acertos de leituras de cpia'  o percentual de solicitaes de leitura de cpia de cache que ocorrem no cache, ou seja, elas no exigem uma leitura de disco para fornecer acesso  pgina no cache. A leitura de cpia  uma operao de leitura de arquivo satisfeita por uma cpia de memria a partir de uma pgina no cache do buffer do aplicativo. O redirecionador de rede local usa esse mtodo para recuperar as informaes do cache, enquanto o servidor de rede local o usa para pequenas transferncias. Esse mtodo  usado tambm pelos sistemas de arquivo de disco.",

    "115",     "'Leituras MDL/s'  a freqncia de leituras do cache do sistema de arquivos que usa uma MDL (lista do descritor de memria) para acessar os dados. A MDL contm o endereo fsico de cada pgina envolvida na transferncia e, portanto, pode empregar um dispositivo de hardware DMA (acesso direto  memria) para efetuar a cpia. O servidor da rede local usa esse mtodo para grandes transferncias fora do servidor.",

    "117",     "'Leituras MDL sncronas/s'  a freqncia de leituras do cache do sistema de arquivos que emprega uma lista de descritores de memria (MDL) para acessar as pginas. A MDL contm o endereo fsico de cada pgina na transferncia, permitindo assim acesso direto  memria (DMA) das pginas. Se a(s) pgina(s) acessada(s) no estiver(em) na memria principal, o chamador aguardar a falha das pginas a partir do disco.",

    "119",     "'Leituras MDL assncronas/s'  a freqncia de leituras do cache do sistema de arquivos que usa uma MDL (listas de descrio de memria) para acessar as pginas. A MDL contm o endereo fsico de cada pgina na transferncia, permitindo, portanto, que o DMA (acesso direto  memria) das pginas seja feito. Se as pginas acessadas no estiverem na memria principal, o programa aplicativo que realizou a chamada no aguardar as pginas falharem no disco.",

    "121",     "'Acertos de leituras MDL'  a porcentagem de solicitaes de leitura de lista de descritores de memria (MDL) para a cache do sistema de arquivos que acertaram a cache, ou seja, que no necessitaram de acessos ao disco para fornecer acesso  memria (s) pgina(s) em cache.",

    "123",     "'Leituras antecipadas/s'  a freqncia de leituras de cache de sistema de arquivos em que a cache detecta acesso seqencial a um arquivo. As leituras do tipo 'read ahead' permitem que os dados sejam transferidos em blocos maiores do que aqueles solicitados pelo aplicativo, reduzindo o tempo gasto por acesso.",

    "125",     "'Leituras rpidas/s'  a freqncia de leituras a partir do cache do sistema de arquivos que ignora o sistema de arquivos instalado e recupera os dados diretamente do cache. Normalmente, as solicitaes de E/S chamam o sistema de arquivos apropriado para recuperar os dados de um arquivo, mas esse caminho permite a recuperao direta de dados do cache sem o envolvimento do sistema de arquivos, se os dados estiverem no cache. Mesmo se os dados no estiverem no cache, uma chamada do sistema de arquivos  evitada",

    "127",     "'Leituras rpidas sncronas/s'  a freqncia de leituras do cache do sistema de arquivos que ignora o sistema de arquivos instalado e recupera os dados diretamente do cache. Normalmente, as solicitaes de E/S de arquivos fazem com que o sistema de arquivos apropriado recupere dados de um arquivo, porm, este caminho permite uma recuperao direta de dados do cache sem envolver o sistema de arquivos caso os dados estejam no cache. Mesmo que os dados no estejam no cache, evita-se uma chamada do sistema de arquivos. Se os dados no estiverem no cache, a solicitao (chamada do programa aplicativo) aguardar at que os dados tenham sido recuperados do disco.",

    "129",     "'Leituras rpidas assncronas/s'  a freqncia de leituras do cache do sistema de arquivos que ignora o sistema de arquivos instalado e recupera os dados diretamente do cache. Normalmente, as solicitaes de E/S do arquivo chamaro o sistema de arquivos apropriado para recuperar os dados de um arquivo, mas esse caminho permite que os dados sejam recuperados do cache diretamente (sem o envolvimento do sistema de arquivos), se os dados estiverem no cache. Mesmo se os dados no estiverem no cache, a chamada do sistema de arquivos  evitada. Se os dados no estiverem no cache, a solicitao (chamada do programa de aplicativo) no aguardar a recuperao dos dados do disco, mas obter o controle imediatamente.",

    "131",     "'Falhas de recursos de leituras rpidas/s'  a freqncia de erros de cache necessria devido  falta de recursos disponveis para satisfazer a solicitao.",

    "133",     "'Leituras rpidas impossveis/s'  a freqncia de tentativas com a qual uma chamada de funo API ignora o sistema de arquivos para obter os dados no cache do sistema de arquivos que no puderam ser respeitados sem chamar o sistema de arquivos.",

    "135",     "'Liberaes para gravao lenta/s'  a taxa em que o segmento de gravador lento foi gravado no disco. A gravao lenta  o processo de atualizao do disco aps a alterao da pgina na memria, de tal maneira que o aplicativo que alterou o arquivo no precise aguardar a gravao do disco para ser concludo antes de continuar. Mais de uma pgina pode ser transferida em cada operao de gravao.",

    "137",     "'Pginas para gravao lenta/s'  a taxa em que o segmento de gravador lento foi gravado no disco. A gravao lenta  o processo de atualizao do disco aps a alterao da pgina na memria, de tal maneira que o aplicativo que alterou o arquivo no precise aguardar a gravao do disco para ser concludo antes de continuar. Mais de uma pgina pode ser transferida por cada operao de gravao.",

    "139",     "'Dados liberados/s'  a taxa  qual a cache do sistema de arquivos liberou seu contedo para o disco como resultado de uma solicitao para liberar ou satisfazer uma solicitao de gravao de arquivo write-through. Mais de uma pgina pode ser transferida em cada operao de liberao.",

    "141",     "'Pginas de dados liberadas/s'  o nmero de pginas que o cache do sistema de arquivos liberou para o disco como resultado de uma solicitao para liberar ou satisfazer uma solicitao de gravao de arquivo write-through. Mais de uma pgina pode ser transferida em cada operao de limpeza.",

    "143",     "'% tempo de usurio'  o percentual de tempo decorrido que o processador gasta no modo de usurio. O modo de usurio  um modo de processamento restrito projetado para aplicativos, subsistemas de ambiente e subsistemas integrais. A alternativa, o modo privilegiado,  projetada para os componentes do sistema operacional e permite acesso direto ao hardware e toda a memria. O sistema operacional alterna os segmentos do aplicativo para o modo privilegiado a fim de acessar os servios do sistema operacional. Esse contador exibe o tempo mdio de ocupao como um percentual do tempo de exemplo.",

    "145",     "'% tempo privilegiado'  a porcentagem de tempo decorrido que os segmentos de processo gastaram executando o cdigo em modo privilegiado. Quando um servio do sistema do Windows  chamado, muitas vezes o servio  executado em modo privilegiado para obter acesso aos dados privados do sistema. Esses dados so protegidos contra acesso por segmentos executados no modo de usurio. As chamadas ao sistema podem ser explcitas ou implcitas, como falhas de pginas ou interrupes. Diferentemente de alguns sistemas operacionais antigos, o Windows usa limites de processo para proteo de subsistema alm da proteo tradicional dos modos privilegiado e de usurio. Parte do trabalho executado pelo Windows para o aplicativo pode aparecer em outros processos de subsistema, em adio ao tempo privilegiado no processo. ",

    "147",     "'Alternncias de contexto/s'  a taxa combinada na qual todos os processadores no computador so alternados de um segmento para outro. As alternncias de contexto ocorrem quando um segmento em execuo voluntariamente abandona o processador, sendo apropriado por um segmento pronto de prioridade mais alta ou alterna entre o modo de usurio e o modo privilegiado (kernel) para usar um servio de subsistema ou executivo.  a soma de 'Segmento\\Alternncias de contexto/s' para todos os segmentos em execuo em todos os processadores no computador e  medido em nmeros de alternncias. H contadores de alternncia de contexto nos objetos de sistema e segmento. Esse contador exibe a diferena entre os valores observados nas duas ltimas amostragens, dividida pela durao do intervalo de amostragem. ",

    "149",     "'Interrupes/s'  a taxa mdia, em incidentes por segundo, em que o processador recebeu e atendeu as interrupes de hardware. No inclui DPCs (chamadas de procedimento deferidas), que so contadas separadamente. Esse valor  um indicador indireto da atividade dos dispositivos que geram interrupes, tais como relgio do sistema, mouse, drivers de disco, linhas de comunicao de dados, placas de interface de rede e outros dispositivos perifricos. Esses dispositivos normalmente interrompem o processador quando concluem uma tarefa ou exigem ateno. A execuo normal do segmento  suspensa. O relgio do sistema normalmente interrompe o processador a cada 10 milissegundos, criando uma atividade de interrupo em segundo plano. Esse contador exibe a diferena entre os valores observados nos dois ltimos exemplos, dividida pela durao do intervalo de exemplo.",

    "151",     "'Chamadas do sistema/s'  a freqncia combinada de chamadas de rotinas de servio do sistema operacional por parte de todos os processos em execuo no computador. Essas rotinas realizam todo o agendamento e a sincronizao das atividades no computador e fornecem acesso a dispositivos no-grficos, gerenciamento de memria e gerenciamento de espao para nome. Esse contador exibe a diferena entre os valores observados nas duas ltimas amostragens, dividida pela durao do intervalo de amostragem. ",

    "153",     "'Cargas de TLB de nvel 1/s'  a freqncia das falhas que ocorrem quando a referncia  realizada na memria cuja PTE (entrada da tabela de pgina) no est no TLB (buffer de converso  parte). Em alguns computadores, essa falha  tratada pelo software que carrega a PTE no TLB, e esse contador  incrementado.",

    "155",     "'Cargas de TLB de nvel 2/s'  a freqncia das falhas que ocorrem quando a referncia  realizada na memria cuja PTE (entrada da tabela de pgina) no est no TLB (buffer de converso  parte) nem  a pgina que contm a PTE. Em alguns computadores, essa falha  tratada pelo software que carrega a PTE no TLB, e esse contador  incrementado.",

    "157",     "'% tempo de usurio'  o percentual de tempo decorrido que os segmentos do processo gastam ao executar o cdigo no modo de usurio. Aplicativos, subsistemas de ambiente e subsistemas integrais so executados no modo de usurio. O cdigo executado no modo de usurio no pode prejudicar a integridade do executvel do Windows, do kernel e dos drivers de dispositivo. Ao contrrio de alguns sistemas operacionais antigos, o Windows usa os limites do processo para proteo do subsistema, alm da proteo tradicional dos modos de usurio e privilegiado. Alguns trabalhos feitos pelo Windows em nome do aplicativo podem aparecer em outros processos do subsistema, alm do tempo privilegiado no processo.",

    "159",     "'% tempo privilegiado'  a porcentagem de tempo decorrido que os segmentos de processo gastaram executando o cdigo em modo privilegiado. Quando um servio do sistema do Windows  chamado, muitas vezes o servio  executado em modo privilegiado para obter acesso aos dados privados do sistema. Esses dados so protegidos contra acesso por segmentos executados no modo de usurio. As chamadas ao sistema podem ser explcitas ou implcitas, como falhas de pginas ou interrupes. Diferentemente de alguns sistemas operacionais antigos, o Windows usa limites de processo para proteo de subsistema alm da proteo tradicional dos modos privilegiado e de usurio. Parte do trabalho executado pelo Windows para o aplicativo pode aparecer em outros processos de subsistema, em adio ao tempo privilegiado no processo.",

    "161",     "'Enumeraes de servidor/s'  a taxa  qual solicitaes de pesquisa de servidor foram processadas por esta estao de trabalho.",

    "163",     "'Enumeraes de domnio/s'  a taxa  qual solicitaes de pesquisa de domnio foram processadas por esta estao de trabalho.",

    "165",     "'Outras enumeraes/s'  a taxa em que as solicitaes de busca processadas por essa estao de trabalho no so solicitaes de busca de domnio ou servidor.",

    "167",     "'Notificaes do servidor perdidas'  o nmero de anncios do servidor ausentes devido a limites de configurao ou alocao.",

    "169",     "'Datagramas do processador de mensagens perdidos'  o nmero de datagramas do processador de mensagens que foram descartados devido a limites de configurao ou alocao.",

    "171",     "'Solicitaes de lista de servidor perdidas'  o nmero de solicitaes para recuperar uma lista de servidores do navegador recebidos por esta estao de trabalho, mas que no puderam ser processados.",

    "173",     "'Pico de bytes virtuais'  o tamanho mximo, em bytes, do espao de endereo virtual que o processo utilizou em dado momento. O uso do espao de endereo virtual no implica necessariamente o uso do disco ou das pginas de memria principal correspondentes. Porm, o espao virtual  finito e o processo pode limitar sua capacidade de carregar bibliotecas.",

    "175",     "'Bytes virtuais'  o tamanho atual, em bytes, do espao de endereo virtual que o processo est utilizando. O uso do espao de endereo virtual no implica necessariamente o uso do disco ou das pginas de memria principal correspondentes. O espao virtual  finito e o processo pode limitar sua capacidade de carregar bibliotecas.",

    "177",     "'Falhas de pginas/seg'  a taxa em que ocorrem as falhas de pginas por segmentos em execuo neste processo. Uma falha de pgina ocorre quando um segmento refere-se a uma pgina de memria virtual que no se encontra no conjunto de trabalho na memria principal. Talvez isso no faa a pgina ser procurada a partir do disco, caso esteja na lista de espera e, portanto, j na memria principal, ou, se estiver em uso por outro processo com o qual a pgina  compartilhada.",

    "179",     "'Pico do conjunto de trabalho'  o tamanho mximo, em bytes, do 'Conjunto de trabalho' deste processo em dado momento. O conjunto de trabalho  o conjunto de pginas de memria utilizadas recentemente pelos segmentos do processo. Se a memria disponvel do computador estiver acima de um valor limite, as pginas sero mantidas no 'Conjunto de trabalho' de um processo mesmo que no estejam em uso. Se a memria disponvel cair abaixo de um valor limite, as pginas sero retiradas do 'Conjunto de trabalho'. Se forem requisitadas, sero reinseridas no Conjunto de trabalho por falha de software antes de sair da memria principal.",

    "181",     "O 'Conjunto de trabalho'  o tamanho atual, em bytes, do conjunto de trabalho deste processo. O conjunto de trabalho  o conjunto de pginas de memria utilizadas recentemente pelos segmentos do processo. Se a memria disponvel do computador estiver acima de um valor limite, as pginas sero mantidas no Conjunto de trabalho de um processo mesmo que no estejam em uso. Se a memria disponvel cair abaixo de um valor limite, as pginas sero retiradas do 'Conjunto de trabalho'. Se forem requisitadas, sero reinseridas no 'Conjunto de trabalho' por falha de software antes de sair da memria principal.",

    "183",     "'Pico de bytes de arquivo de paginao'  a quantidade mxima de memria virtual, em bytes, que este processo reservou para uso no(s) arquivo(s) de paginao. Os arquivos de paginao so usados para armazenar pginas de memria usadas pelo processo que no est contido em outros arquivos. Os arquivos de paginao so compartilhados por todos os processos, e a falta de espao em arquivos de paginao pode evitar que outros processos aloquem memria. Se no houver um arquivo de paginao, este contador reflete a quantidade mxima de memria virtual que o processo reservou para uso na memria fsica.",

    "185",     "'Bytes de arquivo de paginao'  a quantidade atual de memria virtual, em bytes, que este processo reservou para uso no(s) arquivo(s) de paginao. Os arquivos de paginao armazenam as pginas de memria usadas pelo processo que no esto contidas em outros arquivos. Os arquivos de paginao so compartilhados por todos os processos e a falta de espao nesses arquivos pode impedir que outros processos aloquem memria. Se no houver um arquivo de paginao, este contador reflete a quantidade atual de memria virtual que o processo reservou para uso na memria fsica.",

    "187",     "'Bytes particulares'  o tamanho atual, em bytes, da memria alocada por esse processo que no pode ser compartilhada com outros processos.",

    "189",     "'% tempo de processador'  a porcentagem de tempo decorrido em que todos os segmentos de processo usaram o processador para executar instrues. Uma instruo  a unidade bsica de execuo em um computador, um segmento  o objeto que executa instrues e um processo  o objeto criado quando um programa  executado. O cdigo executado para lidar com algumas interrupes de hardware e condies de desvio  includo nessa contagem.",

    "191",     "'% tempo de processador'  a porcentagem de tempo decorrido em que todos os segmentos de processo usaram o processador para executar instrues. Uma instruo  a unidade bsica de execuo em um computador, um segmento  o objeto que executa instrues e um processo  o objeto criado quando um programa  executado. O cdigo executado para lidar com algumas interrupes de hardware e condies de desvio  includo nessa contagem.",

    "193",     "'% tempo de usurio'  a porcentagem de tempo decorrido que este segmento gastou executando cdigo em modo de usurio. Aplicativos, subsistemas de ambiente e subsistemas integrais so executados em modo de usurio. O cdigo executado em modo de usurio no pode danificar a integridade do Windows NT Executive, Kernel e drivers de dispositivo. Diferentemente de alguns sistemas operacionais mais antigos, o Windows NT usa limites de processo para proteger subsistemas, alm da proteo tradicional dos modos de usurio e privilegiado. Esses processos de subsistema fornecem proteo adicional. Portanto, parte do trabalho executado pelo Windows NT para o aplicativo pode aparecer em outros processos de subsistema em adio ao tempo privilegiado no processo.",

    "195",     "'% tempo privilegiado'  a porcentagem de tempo decorrido que os segmentos de processo gastaram executando o cdigo em modo privilegiado. Quando um servio do sistema do Windows  chamado, muitas vezes o servio  executado em modo privilegiado para obter acesso aos dados privados do sistema. Esses dados so protegidos contra acesso por segmentos executados no modo de usurio. As chamadas ao sistema podem ser explcitas ou implcitas, como falhas de pginas ou interrupes. Diferentemente de alguns sistemas operacionais antigos, o Windows usa limites de processo para proteo de subsistema alm da proteo tradicional dos modos privilegiado e de usurio. Parte do trabalho executado pelo Windows para o aplicativo pode aparecer em outros processos de subsistema, em adio ao tempo privilegiado no processo.",

    "197",     "'Alternncias de contexto/s'  a taxa de alternncias de um segmento para outro. As alternncias de segmentos podem ocorrer dentro de um nico processo ou atravs dos processos. Uma alternncia de segmento pode ser causada por um segmento solicitando informaes a outro ou por um segmento sendo apropriado por outro segmento de prioridade mais alta, tornando-se pronto para execuo. Ao contrrio de alguns sistemas operacionais antigos, o Windows NT usa limites de processo para proteo do subsistema, alm da proteo tradicional dos modos de usurio e privilegiado. Esses processos de subsistema fornecem proteo adicional. Portanto, algum trabalho realizado pelo Windows NT em nome de um aplicativo aparece em outros processos do subsistema, alm do tempo privilegiado no aplicativo. Alternar para o processo do subsistema causa uma alternncia de contexto no segmento do aplicativo. Alternar novamente causa outra alternncia de contexto no segmento do subsistema.",

    "199",     "'Comprimento da fila de disco atual'  o nmero de solicitaes pendentes no disco no momento em que os dados de desempenho so coletados. Inclui tambm solicitaes em servio no momento da coleta. Esse  um instantneo, no uma mdia sobre o intervalo de tempo. Em um dispositivo de discos com vrios eixos pode haver diversas solicitaes ativas ao mesmo tempo, mas outras solicitaes concorrentes esto aguardando o servio. Esse contador pode refletir um comprimento de fila transitrio alto ou baixo, mas se houver uma carga sustentada na unidade de disco,  provvel que seja consistentemente alta. O tempo de processamento dessas solicitaes  atrasado em relao proporcional ao comprimento dessa fila menos o nmero de eixos nos discos. Para obter um bom desempenho, a mdia dessa diferena deve ser menor que dois.",

    "201",     "'% tempo de disco'  a porcentagem de tempo decorrido durante a qual a unidade de disco selecionada estava ocupada atendendo a solicitaes de leitura ou gravao.",

    "203",     "'% tempo de leitura de disco'  a porcentagem de tempo decorrido durante a qual a unidade de disco selecionada estava ocupada atendendo a solicitaes de leitura.",

    "205",     "'% tempo de gravao de disco'  a porcentagem de tempo decorrido durante a qual a unidade de disco selecionada estava ocupada atendendo a solicitaes de gravao.",

    "207",     "'Mdia de disco s/transferncia'  o tempo, em segundos, da mdia de transferncias de disco.",

    "209",     "'Mdia de disco s/leitura'  o tempo mdio, em segundos, das leituras de dados do disco.",

    "211",     "'Mdia de disco s/gravao'  o tempo mdio, em segundos, das gravaes de dados para o disco.",

    "213",     "'Transferncias de disco/s'  a taxa de operaes de leituras e gravao no disco.",

    "215",     "'Leituras de disco/s'  a taxa de lidos operaes no disco.",

    "217",     "'Gravaes de disco/s'  a taxa de operaes de gravao no disco.",

    "219",     "'Bytes de disco/s'  a taxa  qual bytes so transferidos para ou do disco durante operaes de gravao ou leitura.",

    "221",     "'Bytes de leitura de disco/s'  a taxa  qual bytes so transferidos do disco durante operaes de leitura.",

    "223",     "'Bytes de gravao de disco/s'  taxa  qual bytes so transferidos para o disco durante operaes de gravao.",

    "225",     "'Mdia de bytes de disco/transferncia'  o nmero mdio de bytes transferidos do disco durante as operaes de leitura ou gravao.",

    "227",     "'Mdia de bytes de disco/leitura'  o nmero mdio de bytes transferidos do disco durante as operaes de leitura.",

    "229",     "'Mdia de bytes de disco/gravao'  o nmero mdio de bytes transferidos do disco durante as operaes de gravao.",

    "231",     "O objeto de desempenho de processo consiste em contadores que monitoram os programas aplicativos em execuo e os processos do sistema. Todos os segmentos em um processo compartilham o mesmo espao de endereo e tm acesso aos mesmos dados.",

    "233",     "O objeto de desempenho de segmento consiste em contadores que medem aspectos do comportamento de segmentos. Um segmento  o objeto bsico que executa instrues em um processador. Todos os processos em execuo tm pelo menos um segmento.",

    "235",     "O objeto de desempenho de disco fsico consiste em contadores que monitoram as unidades de disco rgido ou fixo em um computador. Os discos so utilizados para armazenar arquivos, programas e dados de paginao, so lidos para que esses itens sejam recuperados e recebem gravaes para registrar alteraes a esses itens. Os valores dos contadores de disco fsico totalizam os valores dos discos lgicos (ou parties) em que estiverem divididos.",

    "237",     "O objeto de desempenho de disco lgico consiste em contadores que monitoram as parties lgicas de  unidades de disco rgido ou fixo. O 'Monitor de desempenho' identifica discos lgicos pela letra de unidade como, por exemplo, C.",

    "239",     "O objeto de desempenho de processador consiste em contadores que medem aspectos da atividade do processador. O processador  a parte do computador que realiza os clculos aritmticos e lgicos, inicia operaes em perifricos e executa os segmentos de processos. Um computador pode ter vrios processadores. O objeto de processador representa cada processador como uma instncia do objeto.",

    "241",     "'% tempo total de processador'  o percentual de tempo mdio em que todos os processadores no computador esto executando segmentos ocupados. Este contador foi projetado como indicador principal da atividade do processador em computadores com multiprocessador.  igual  soma do 'Processo: '% tempo total de processador' para todos os processadores, dividida pelo nmero de processadores.  calculado pela soma do tempo que todos os processadores gastam executando o segmento do processo ocioso em cada intervalo de exemplo, subtraindo esse valor de 100% e dividindo a diferena pelo nmero de processadores no computador. (Cada processador tem um segmento ocioso que consome ciclos quando nenhum outro segmento est pronto para a execuo). Por exemplo, em um computador com multiprocessador, um valor de 50% significa que todos os processadores esto ocupados em metade do intervalo de exemplo, ou que metade dos processadores est ocupada em todo o intervalo de exemplo. Esse contador exibe o percentual mdio do tempo de ocupao observado durante o intervalo de exemplo.  calculado pela monitorao do tempo em que o servio est inativo e subtraindo esse valor de 100%. ",

    "243",     "'% tempo total de usurio'  o percentual mdio de tempo ocupado que todos os processadores gastam no modo de usurio.  a soma de 'Processador: % tempo total de usurio' para todos os processadores no computador, dividida pelo nmero de processadores. 'Sistema: % tempo total de usurio' e 'Sistema: % tempo total privilegiado' somado a '% tempo total de processador', mas nem sempre a 100%. (O modo de usurio  um modo de processamento restrito projetado para aplicativos, subsistemas de ambiente e subsistemas integrais. A alternativa, o modo privilegiado,  projetada para componentes do sistema operacional e permite acesso direto ao hardware e a toda a memria. O sistema operacional alterna os segmentos do aplicativo para o modo privilegiado a fim de acessar os servios do sistema operacional). Esse contador exibe o tempo mdio de execuo como um percentual do tempo de exemplo. ",

    "245",     "'% tempo total privilegiado'  o percentual mdio de tempo ocupado que todos os processadores gastam no modo privilegiado (kernel).  a soma de 'Processador: % tempo total privilegiado' para todos os processadores no computador, dividido pelo nmero de processadores. 'Sistema: % tempo total do usurio' e 'Sistema: % tempo total privilegiado' somado a '% tempo total de processador', mas nem sempre a 100%. (Modo privilegiado  um modo de processamento projetado para componentes do sistema operacional que permite acesso direto ao hardware e a toda a memria. O sistema operacional alterna os segmentos do aplicativo no modo privilegiado para acessar os servios do sistema operacional. A alternativa, o modo de usurio,  um modo de processamento restrito projetado para os aplicativos e subsistemas do ambiente). Esse contador exibe o tempo de ocupao mdio como um percentual do tempo de amostragem. ",

    "247",     "'Total de interrupes/s'  a freqncia combinada de interrupes de hardware recebidas e atendidas por todos os processadores no computador.  a soma de 'Processador: interrupes/s' de todos os processadores, sendo dividida pelo nmero de processadores e medida em nmero de interrupes. No inclui DPCs, que so contadas separadamente. Esse valor  um indicador indireto da atividade de dispositivos que geram interrupes, como o timer do sistema, o mouse, drivers de disco, linhas de comunicao de dados, placas de interface de rede e outros dispositivos perifricos. Esses dispositivos normalmente interrompem o processador ao conclurem uma tarefa ou necessitar de ateno. A execuo normal de segmentos  suspensa durante as interrupes. A maioria dos clocks de sistema interrompe o processador a cada 10 milissegundos, criando um segundo plano de atividade de interrupo. Esse contador mostra a diferena entre os valores observados nas duas ltimas amostragens, dividida pela durao do intervalo de amostragem. ",

    "249",     "'Processos'  o nmero de processos no computador no momento da coleta de dados.  uma contagem instantnea, no uma mdia sobre o intervalo de tempo. Cada processo representa a execuo de um programa.",

    "251",     "'Segmentos'  o nmero de segmentos no computador na hora da coleta dos dados. Essa contagem  instantnea, no  uma mdia em relao ao intervalo de tempo. Um segmento  a entidade executvel bsica que pode executar instrues em um processador.",

    "253",     "'Eventos'  o nmero de eventos no computador no momento da coleta de dados. Essa  uma contagem instantnea, no uma mdia sobre o intervalo de tempo. Um evento  usado quando dois ou mais segmentos tentam sincronizar a execuo.",

    "255",     "'Semforos'  o nmero de semforos no computador no momento da coleta de dados.  uma contagem instantnea, no uma mdia sobre o intervalo de tempo. Os segmentos usam semforos para obter acesso exclusivo s estruturas de dados que compartilham com outros segmentos.",

    "257",     "'Excluses mtuas' conta o nmero de excluses mtuas no computador no momento da coleta de dados.  uma contagem instantnea, no uma mdia sobre o intervalo de tempo. As 'Excluses mtuas' so usadas pelos segmentos para garantir que apenas um segmento esteja executando uma determinada seo de cdigo.",

    "259",     "'Sees'  o nmero de sees no computador no momento da coleta de dados.  uma contagem instantnea, no uma mdia sobre o intervalo de tempo. Uma seo  parte da memria virtual criada por um processo de armazenamento de dados. Um processo pode compartilhar sees com outros processos.",

    "261",     "O objeto de desempenho de objeto consiste em contadores que monitoram objetos lgicos no sistema como, por exemplo, processos, segmentos, excluses mtuas e sinais. Essas informaes podem ser utilizadas para detectar o consumo desnecessrio de recursos do computador. Cada objeto requer memria para armazenar informaes bsicas sobre o objeto.",

    "263",     "O objeto de desempenho de redirecionador consiste em contadores que monitoram conexes de rede originadas no computador local.",

    "265",     "'Bytes recebidos/s'  a taxa de bytes de entrada no redirecionador da rede. Isso inclui todos os dados de aplicativo, bem como informaes de protocolo de rede (como cabealhos de pacote).",

    "267",     "'Pacotes recebidos/s'  a taxa em que o redirecionador est recebendo pacotes (tambm chamada SMBs ou blocos de mensagens do servidor). As transmisses de rede dividem-se em pacotes. O nmero mdio de bytes recebidos em um pacote pode ser obtido dividindo 'Bytes recebidos/s' por esse contador. Alguns pacotes recebidos talvez no contenham os dados de entrada (por exemplo, o reconhecimento de uma gravao realizada pelo redirecionador contaria como um pacote de entrada).",

    "269",     "'Bytes de leitura de paginao/s'  a taxa em que o redirecionador est tentando ler os bytes em resposta a falhas de pginas. As falhas de pginas so causadas pela carga de mdulos (tais como programas e bibliotecas), por uma ausncia no cache (consulte 'Bytes de leitura de cache/s') ou por arquivos diretamente mapeados no espao de endereo dos aplicativos (um recurso de alto desempenho do Windows NT).",

    "271",     "'Bytes de leitura de no-paginao/s' so os bytes lidos pelo redirecionador em resposta s solicitaes de arquivo normais por meio de um aplicativo, quando eles so redirecionados para virem de outro computador. Alm das solicitaes de arquivo, esse contador inclui outros mtodos de leitura atravs da rede, tais como, pipes nomeados e transaes. Esse contador no conta as informaes do protocolo de rede, apenas os dados do aplicativo.",

    "273",     "'Bytes de leitura de cache/s'  a taxa em que os aplicativos esto acessando o cache do sistema de arquivos usando o redirecionador. Algumas dessas solicitaes de dados so satisfeitas recuperando os dados do cache. As solicitaes que precisam do cache geram uma falha de pgina (consulte 'Bytes de leitura de paginao/s').",

    "275",     "'Bytes de leitura de rede/s'  a taxa em que os aplicativos esto lendo os dados atravs da rede. Isso ocorre quando os dados do cache do sistema de arquivos no so encontrados e devem ser recuperados da rede. Dividir esse valor por 'Bytes recebidos/s' indica a proporo dos dados de aplicativo que trafegam pela rede (consulte 'Bytes recebidos/s').",

    "277",     "'Bytes transmitidos/s'  a taxa  qual bytes saem do redirecionador para a rede. Isso inclui todos os dados de aplicativo, bem como informaes de protocolo de rede (como cabealhos de pacote e itens semelhantes).",

    "279",     "'Pacotes transmitidos/s'  a taxa em que o redirecionador est enviando pacotes (chama-se tambm SMBs ou blocos de mensagem do servidor). As transmisses da rede dividem-se em pacotes. O nmero mdio de bytes transmitidos em um pacote pode ser obtido pela diviso de 'Bytes transmitidos/s' por esse contador.",

    "281",     "'Bytes de gravao de paginao/s'  a freqncia com a qual o redirecionador tenta gravar bytes que foram modificados nas pginas em uso pelos aplicativos. Os dados de programa modificados por mdulos (como programas e bibliotecas) e carregados na rede so transferidos para o arquivo de paginao quando no so mais necessrios. Outras pginas de sada so oriundas do cache do sistema de arquivos (ver 'Bytes de gravao de cache/s').",

    "283",     "'Bytes de gravao de no-paginao/s'  a freqncia de gravao de bytes pelo redirecionador em resposta s sadas normais de arquivos de um aplicativo redirecionadas para outro computador. Alm das solicitaes de arquivos, essa contagem inclui outros mtodos de gravao atravs da rede como, por exemplo, pipes nomeados e transaes. Esse contador no considera informaes do protocolo de rede, somente dados de aplicativos.",

    "285",     "'Bytes de gravao de cache/s'  a freqncia com a qual os aplicativos do computador gravam dados no cache do sistema de arquivos atravs do redirecionador. Os dados podem no abandonar o computador imediatamente. Eles podem ficar retidos no cache para alteraes posteriores, antes de serem gravados na rede. Isso reduz o trfego de rede. Cada gravao de um byte no cache  contada aqui.",

    "287",     "'Bytes de gravao de rede/s'  a freqncia com a qual os aplicativos gravam dados atravs da rede. Isso ocorre quando o cache do sistema de arquivos  ignorado como, por exemplo, no caso de pipes nomeados ou transaes, ou quando o cache grava os bytes em disco para deixar espao para outros dados. Dividindo-se este contador pelo valor de 'Bytes transmitidos/s', obtm-se a proporo de dados de aplicativos que transitam na rede (ver 'Bytes transmitidos/s').",

    "289",     "'Operaes de leitura de arquivo/s'  a taxa em que os aplicativos esto solicitando dados ao redirecionador. Cada chamada a um sistema de arquivos ou de API (interface de programa de aplicativo) similar conta como uma operao.",

    "291",     "'Operaes de leitura aleatrias/s' conta a taxa em que, arquivo a arquivo, as leituras so realizadas de maneira no-seqencial. Se uma leitura  realizada usando um determinado identificador de arquivo e seguida por outra leitura que no seja imediatamente vizinha ao prximo byte, esse contador  incrementado em uma unidade.",

    "293",     "'Leitura de pacotes/s'  a taxa em que os pacotes de leitura esto sendo colocados na rede. Sempre que um nico pacote  enviado com uma solicitao de leitura de dados remota, esse contador  incrementado em uma unidade.",

    "295",     "'Leituras grandes/s'  a taxa em que as leituras duas vezes maiores que o tamanho do buffer negociado do servidor so realizadas pelos aplicativos. Muitas dessas leituras podem distorcer os recursos do servidor. Esse contador  incrementado uma vez a cada leitura. Ele no conta pacotes.",

    "297",     "'Leitura de pacotes pequenos/s'  a taxa em que as leituras com menos de um quarto do tamanho do buffer negociado do servidor so feitas pelos aplicativos. Um valor alto pode indicar desperdcio de buffers no servidor. Esse contador  incrementado uma vez para cada leitura e no conta os pacotes.",

    "299",     "'Operaes de gravao de arquivo/s'  a taxa em que os aplicativos esto enviando dados ao redirecionador. Cada chamada a um sistema de arquivos ou de API (interface de programa de aplicativo) similar conta como uma operao.",

    "301",     "'Operaes de gravao aleatrias/s'  a freqncia com a qual so realizadas gravaes no seqenciais, arquivo por arquivo. Se for realizada uma gravao com uso de um determinado identificador de arquivo seguida de outra gravao que se no envolve o byte imediatamente contguo, este contador ser incrementado em uma unidade.",

    "303",     "'Gravao de pacotes/s'  a freqncia com a qual as gravaes so enviadas para a rede. Cada vez que um pacote individual  enviado com uma solicitao para gravar dados remotos, este contador  incrementado em uma unidade.",

    "305",     "'Gravaes grandes/s'  a freqncia com a qual os aplicativos realizam gravaes cujo tamanho  superior ao dobro do tamanho do buffer negociado com o servidor. Muitas operaes desse tipo podem sobrecarregar os recursos do servidor. Esse contador  incrementado em uma unidade para cada gravao: ele considera gravaes e no pacotes.",

    "307",     "'Gravao de pacotes pequenos/s'  a freqncia com a qual os aplicativos realizam gravaes cujo tamanho  inferior a um quarto do tamanho de buffer negociado com o servidor. Muitas operaes desse tipo podem indicar um desperdcio de buffers no servidor. Esse contador  incrementado em uma unidade para cada gravao: ele considera gravaes e no pacotes.",

    "309",     "'Leituras negadas/s'  a taxa de solicitaes para leituras no-processadas que no puderam ser acomodadas pelo servidor. Quando uma leitura  muito maior que o tamanho do buffer negociado do servidor, o redirecionador solicita uma leitura no-processada que, se concedida, permite a transferncia dos dados sem lotes de sobrecarga de protocolo em cada pacote. Para efetuar esse procedimento, o servidor deve bloquear outras solicitaes; portanto, a solicitao  negada, se o servidor estiver realmente ocupado.",

    "311",     "'Gravaes negadas/s'  a freqncia com a qual o servidor no consegue atender a solicitaes de gravaes no processadas. Quando uma gravao  muito maior do que o tamanho do buffer negociado com o servidor, o redirecionador solicita permisso para uma gravao no processada que, quando concedida, permite a transferncia de dados sem sobrecarga de protocolo em cada pacote. Para isso, o servidor precisaria bloquear outras solicitaes. Portanto, a solicitao ser negada se o servidor estiver realmente ocupado.",

    "313",     "'Erros de rede/seg'  a taxa em que ocorrem erros graves inesperados. Tais erros geralmente indicam que o redirecionador e um ou mais servidores esto tendo srias dificuldades de comunicao. Por exemplo, um erro de protocolo SMB (bloco de mensagens do servidor)  um erro de rede. Uma entrada  gravada no log de eventos do sistema e fornece detalhes.",

    "315",     "'Sesses de servidor' conta o nmero total de objetos de segurana que o redirecionador gerencia. Por exemplo, um logon em um servidor seguido de um acesso  rede para o mesmo servidor estabelecer uma conexo, mas duas sesses.",

    "317",     "'Reconexo do servidor' conta o nmero de vezes em que o redirecionador precisou reconectar-se a um servidor para concluir uma nova solicitao ativa. Voc pode ser desconectado pelo servidor se permanecer inativo por muito tempo. Localmente, mesmo se todos os arquivos remotos estiverem fechados, o redirecionador manter as suas conexes intactas por dez minutos. Essas conexes so chamadas de 'Conexes inativas'. A reconexo gasta muito tempo.",

    "319",     "'Conexes ao ncleo' conta o nmero de conexes que voc tem a servidores que executam o protocolo original MS-Net SMB, inclusive a prpria MS-Net e Xenix e VAX.",

    "321",     "'Conecta o Lan Manager 2.0' conta as conexes a servidores Lan Manager 2.0, inclusive servidores LMX.",

    "323",     "'Conecta o Lan Manager 2.1' conta as conexes a servidores Lan Manager 2.1, inclusive servidores LMX.",

    "325",     "'Conecta o Windows NT' conta as conexes a computadores com Windows 2000 ou verses anteriores.",

    "327",     "'Desconexes de servidor' conta o nmero de vezes que um servidor desconectou o redirecionador. Consulte tambm 'Reconexo do servidor'.",

    "329",     "'Sesses de servidor travadas' conta o nmero de sesses ativas cujo tempo limite foi atingido e que no podem continuar devido a uma falta de resposta do servidor remoto.",

    "331",     "O objeto de desempenho de servidor consiste em contadores que medem a comunicao entre o computador local e a rede.",

    "333",     "O nmero de bytes que o servidor recebeu da rede. Indica o grau de ocupao do servidor.",

    "335",     "O nmero de bytes que o servidor enviou na rede. Indica at que nvel o servidor est ocupado.",

    "337",     "'Razo de espera de segmento' s  aplicvel quando o segmento est em um estado de espera (consulte 'Estado de segmento'). Ele  0 ou 7 quando o segmento est aguardando pelo executivo, 1 ou 8 para uma pgina livre, 2 ou 9 para uma pgina de entrada, 3 ou 10 para uma alocao de pool, 4 ou 11 para uma demora de execuo, 5 ou 12 para uma condio suspensa, 6 ou 13 para uma solicitao do usurio, 14 para um par de eventos elevados, 15 para um par de eventos baixos, 16 para um recebimento de chamada de procedimento local, 17 para uma resposta de chamada de procedimento local, 18 para memria virtual, 19 para uma pgina de sada; 20 e valores superiores no foram atribudos ainda. Os pares de evento so usados para a comunicao com subsistemas protegidos (consulte 'Opes de contexto').",

    "339",     "'% tempo de DPC'  o percentual de tempo que o processador gasta recebendo e atendendo as DPCs (chamadas de procedimento deferidas) durante o intervalo de exemplo. As DPCs so interrupes que funcionam em uma prioridade mais baixa que as interrupes padro. '% tempo de DPC'  um componente de '% tempo privilegiado' porque as DPCs so executadas em modo privilegiado. Elas so contadas separadamente e no so componentes dos contadores de interrupo. Esse contador exibe o tempo mdio de ocupao como um percentual do tempo de amostragem. ",

    "341",     "O nmero de sesses que foram fechadas pelo fato do tempo de ociosidade ter ultrapassado o valor do parmetro AutoDisconnect do servidor. Mostra se a configurao de AutoDisconnect est ajudando a conservar recursos.",

    "343",     "O nmero de sesses que foram fechadas devido a condies de erro inesperadas ou de sesses que atingiram o tempo limite de desconexo automtica e foram desconectadas normalmente.",

    "345",     "O nmero de sesses finalizadas normalmente. til para interpretar as estatsticas de 'Tempo limite de sesses' e 'Sesses com erros' -- permite o clculo de percentuais.",

    "347",     "O nmero de sesses que foram foradas a fazer logoff. Pode indicar quantas sesses foram foradas a fazer logoff devido a restries no tempo de logon.",

    "349",     "O nmero de falhas em tentativas de logon no servidor. Pode indicar a utilizao de programas de deteco de senhas para violar a segurana no servidor.",

    "351",     "O nmero de vezes em que aberturas para clientes falharam com STATUS_ACCESS_DENIED.  Pode indicar se algum est tentando acesso randmico a arquivos na expectativa de obter algo que no esteja adequadamente protegido.",

    "353",     "O nmero de vezes em que foi negado o acesso a arquivos abertos com xito. Pode indicar tentativas de acessar arquivos sem a autorizao de acesso adequada.",

    "355",     "O nmero de vezes em que foi detectado um erro interno de servidor. Erros inesperados geralmente indicam um problema com o servidor.",

    "357",     "O nmero de vezes em que o servidor recusou-se a bloquear SMBs devido a contagem insuficiente ou itens de trabalho livres. Indica que os parmetros de servidor MaxWorkItem ou MinFreeWorkItems podem precisar de ajustes.",

    "359",     "O nmero de vezes que STATUS_DATA_NOT_ACCEPTED foi informado no momento de indicar recebimento. Isso ocorre quando nenhum item de trabalho encontra-se disponvel ou no pode ser alocado para atender  solicitao de entrada. Indica que os parmetros InitWorkItems ou MaxWorkItems podem precisar de ajustes.",

    "361",     "O nmero de tentativas de abertura bem-sucedidas realizadas pelo servidor para os clientes. til para determinar a quantidade de E/S de arquivos, a sobrecarga associada a operaes baseadas em caminhos e a eficcia dos bloqueios opcionais.",

    "363",     "O nmero de arquivos abertos no momento no servidor. Indica a atividade do servidor no momento.",

    "365",     "O nmero de sesses ativas no servidor no momento. Indica a atividade do servidor no momento.",

    "367",     "O nmero de pesquisas de arquivos ativas no servidor no momento. Indica a atividade do servidor no momento.",

    "369",     "O nmero de bytes de memria no-paginvel do computador que o servidor est usando.  Esse valor  til para determinar os valores de MaxNonpagedMemoryUsage no Registro do WindowsNT.",

    "371",     "O nmero de vezes em que alocaes do pool no-paginvel falharam. Indica que a memria fsica do computador  pequena demais.",

    "373",     "O nmero mximo de bytes de reserva de memria no-paginvel que o servidor teve em uso em determinado ponto. Indica a quantidade de memria fsica que o computador deve ter.",

    "375",     "O nmero de bytes de memria de computador paginvel que o servidor est utilizando no momento. Isso pode ajudar a determinar os valores adequados para o parmetro MaxPagedMemoryUsage.",

    "377",     "O nmero de vezes em que alocaes de memria paginvel falharam. Indica que a memria fsica do computador ou o arquivo de paginao  pequeno(a) demais.",

    "379",     "O nmero mximo de bytes de reserva de memria paginvel alocado no servidor. Indica os tamanhos corretos do(s) arquivo(s) de paginao e da memria fsica.",

    "381",     "'Falha em alocaes de anncio do servidor/s'  a taxa que expressa as falhas ocorridas durante os anncios do servidor (ou domnio), devido a falta de memria.",

    "383",     "'Falhas de alocaes do processador de mensagens'  o nmero de vezes que o receptor do datagrama falhou ao alocar um buffer para armazenar a gravao do processador de mensagens do usurio.",

    "385",     "'Falhas de recepo do processador de mensagens' indica o nmero de mensagens do processador de mensagens que no puderam ser recebidas devido a falhas de transporte.",

    "387",     "'Falhas de gravao do processador de mensagens'  o nmero total de mensagens do processador de mensagens que foram recebidas com xito, mas que no puderam ser gravadas no processador de mensagens.",

    "389",     "'Total de bytes/s'  a taxa  qual o redirecionador est processando bytes de dados. Isso inclui todos os dados de aplicativo e arquivo, alm de informaes protocolo, como cabealhos de pacote.",

    "391",     "'Operaes de dados de arquivo/s'  a taxa que o redirecionador usa quando est processando as operaes de dados. Uma operao deve incluir muitos bytes, j que cada operao tem sobrecarga. A eficincia desse caminho pode ser determinada dividindo 'Bytes/s' por esse contador, para obter o nmero mdio de bytes transferidos por operao.",

    "393",     "'Comandos atuais' conta o nmero de solicitaes feitas ao redirecionador que esto atualmente enfileiradas para o servio. Se esse nmero  muito maior que o nmero de placas adaptadoras de rede instaladas no computador, a rede e/ou o servidor que est sendo acessado ficar seriamente afunilado.",

    "395",     "O nmero de bytes que o servidor enviou e recebeu da rede. Esse valor fornece uma indicao geral do grau de ocupao do servidor.",

    "397",     "'% tempo de interrupo'  o tempo que o processador gasta recebendo e atendendo as interrupes de hardware durante intervalos de exemplo. Esse valor  um indicador indireto da atividade dos dispositivos que geram as interrupes, tais como relgio do sistema, mouse, drivers de disco, linhas de comunicao de dados, placas de interface de rede e outros dispositivos perifricos. Esses dispositivos normalmente interrompem o processador ao concluir uma tarefa ou exigem ateno. A execuo normal do segmento  suspensa durante as interrupes. A maioria dos relgios do sistema interrompe o processador a cada 10 milissegundos, criando um plano de fundo da atividade de interrupo, e suspende a execuo normal do segmento durante as interrupes. Esse contador exibe o tempo mdio de ocupao como um percentual do tempo de exemplo.",

    "399",     "O objeto de desempenho NWLink NetBIOS consiste em contadores que monitoram taxas de transporte IPX e conexes. ",

    "401",     "'Pacotes/s'  a taxa em que o redirecionador est processando os pacotes de dados. Um pacote inclui (espera-se) muitos bytes. Espera-se isso porque cada pacote tem uma sobrecarga de protocolo. Voc pode determinar a eficincia desse caminho dividindo 'Bytes/s' por esse contador para determinar o nmero mdio de bytes transferidos/pacote. Tambm  possvel dividir esse contador por 'Operaes/s' para determinar o nmero mdio de pacotes por operao, outra medida de eficincia.",

    "405",     "'Blocos de contexto enfileirados por segundo'  a taxa  qual blocos de contexto de trabalho tiveram de ser colocados na fila FSP do servidor para aguardar uma ao do servidor.",

    "407",     "'Operaes de dados de arquivo/s'  a taxa combinada de operaes de leitura e gravao em todos os discos lgicos no computador.  o inverso de 'Sistema: operaes de controle de arquivo/s'. Esse contador exibe a diferena entre os valores observados nos dois ltimos exemplos, dividida pela durao do intervalo de exemplo. ",

    "409",     "'% de espao livre'  o percentual de espao livre utilizvel total na unidade de disco lgica selecionada.",

    "411",     "'Megabytes livres' exibe o espao no alocado, em megabytes, na unidade de disco. Um megabyte  igual a 1.048.576 bytes.",

    "413",     "'Conexes abertas'  o nmero de conexes abertas no momento para este protocolo. Este contador mostra apenas a contagem atual e no acumula os valores ao longo do tempo.",

    "415",     "'Conexes sem novas tentativas'  a contagem total de conexes que foram feitas com xito na primeira tentativa. Este nmero  um acumulador e mostra um total cumulativo.",

    "417",     "'Conexes com novas tentativas'  a contagem total de conexes feitas aps repetir a tentativa. Uma repetio ocorre quando a primeira tentativa de conexo falha. Esse nmero  um acumulador e mostra um total em execuo.",

    "419",     "'Desconexes locais'  o nmero de desconexes de sesso que foram iniciadas pelo computador local. Este nmero  um acumulador e mostra um total cumulativo.",

    "421",     "'Desconexes remotas'  o nmero de desconexes de sesso que foram iniciadas pelo computador remoto. Este nmero  um acumulador e mostra um total cumulativo.",

    "423",     "'Falhas de vnculo'  o nmero de conexes que foram abandonadas devido a uma falha do vnculo. Este nmero  um acumulador e mostra um total cumulativo.",

    "425",     "'Falhas de adaptador'  o nmero de conexes que foram abandonadas devido a uma falha do adaptador. Este nmero  um acumulador e mostra um total cumulativo.",

    "427",     "'Tempos limite de sesso de conexo'  o nmero de conexes que foram abandonadas devido ao tempo limite da sesso. Este nmero  um acumulador e mostra um total cumulativo.",

    "429",     "'Conexes canceladas'  o nmero de conexes que foram canceladas. Este nmero  um acumulador e mostra um total cumulativo.",

    "431",     "'Falhas de recursos remotos'  o nmero de conexes que falharam devido a problemas ou insuficincia de recurso no computador remoto. Esse nmero  um acumulador e mostra um total cumulativo.",

    "433",     "'Falhas de recursos locais'  o nmero de conexes que falharam devido a problemas ou insuficincia de recurso no computador local. Esse nmero  um acumulador e mostra um total em execuo.",

    "435",     "'Falhas de computador no encontrado'  o nmero de tentativas de conexo que falharam porque o computador remoto no pde ser encontrado. Este nmero  um acumulador e mostra um total cumulativo.",

    "437",     "'Falhas de escuta'  o nmero de conexes rejeitadas porque o computador remoto no detectou as solicitaes de conexo.",

    "439",     "'Datagramas recebidos/s'  a taxa em que os bytes de datagrama so processados pelo computador. Este contador exibe a soma de datagramas enviados e recebidos. O datagrama  um pacote sem conexo cuja entrega a um computador remoto no  garantida.",

    "441",     "'Bytes de datagramas/s'  a taxa em que os bytes de datagrama so processados pelo computador. Este contador  a soma dos bytes de datagramas enviados e recebidos. O datagrama  um pacote sem conexo cuja entrega a um computador remoto no  garantida.",

    "443",     "'Datagramas enviados/s'  a taxa  qual datagramas so enviados do computador. O datagrama  um pacote sem conexo cuja entrega a um computador remoto no  garantida.",

    "445",     "'Bytes de datagramas enviados/s'  a taxa  qual bytes de datagrama so enviados do computador. O datagrama  um pacote sem conexo cuja entrega a um computador remoto no  garantida.",

    "447",     "'Datagramas recebidos/s'  a taxa em que os bytes de datagrama so recebidos pelo computador. O datagrama  um pacote sem conexo cuja entrega a um computador remoto no  garantida.",

    "449",     "'Bytes de datagramas recebidos/s'  a taxa em que os bytes de datagrama so recebidos pelo computador. O datagrama  um pacote sem conexo cuja entrega a um computador remoto no  garantida.",

    "451",     "'Pacotes/s'  a taxa em que os pacotes so processados pelo computador. Essa conta  a soma de 'Pacotes enviados' e 'Pacotes recebidos' por segundo. Esse contador inclui todos os pacotes processados: pacotes de controle e de dados.",

    "453",     "'Pacotes enviados/s'  a taxa em que os pacotes so enviados pelo computador. Esse contador conta todos os pacotes enviados pelo computador, ou seja, pacotes de controle e de dados.",

    "455",     "'Pacotes recebidos/s'  a taxa em que os pacotes so recebidos pelo computador. Esse contador conta todos os pacotes processados: pacotes de controle e de dados.",

    "457",     "'Quadros/s'  a taxa  qual quadros de dados (ou pacotes) so processados pelo computador. Este contador  a soma dos quadros de dados enviados e dos quadros de dados recebidos. Este contador conta apenas os quadros (pacotes) que contm dados.",

    "459",     "'Bytes de quadro/s'  a taxa em que os bytes de dados so processados pelo computador. Este contador  a soma de bytes de quadros enviados e recebidos. Este contador conta apenas os bytes em quadros (pacotes) que contm dados.",

    "461",     "'Quadros enviados/s'  a taxa  qual quadros de dados so enviados pelo computador. Este contador conta apenas the quadros (pacotes) que contm dados.",

    "463",     "'Bytes de quadros enviados/s'  a taxa em que os bytes de dados so enviados pelo computador. Este contador conta apenas os bytes em quadros (pacotes) que contm dados.",

    "465",     "'Quadros recebidos/s'  a taxa em que os quadros de dados so recebidos pelo computador. Esse contador conta apenas os quadros (pacotes) que contm dados.",

    "467",     "'Bytes de quadros recebidos/s'  a taxa em que os bytes de dados so recebidos pelo computador. Esse contador conta apenas os quadros (pacotes) que contm dados.",

    "469",     "'Quadros reenviados/s'  a taxa em que os quadros de dados (pacotes) so reenviados pelo computador. Esse contador conta apenas os quadros ou pacotes que contm dados.",

    "471",     "'Bytes de quadros reenviados/s'  a taxa em que os bytes de dados so reenviados pelo computador. Esse contador conta apenas os bytes em quadros que contm dados.",

    "473",     "'Quadros rejeitados/s'  a taxa  qual quadros de dados so rejeitados. Este contador conta apenas the quadros (pacotes) que contm dados.",

    "475",     "'Bytes de quadros rejeitados/s'  a taxa  qual bytes de dados so rejeitados. Este contador conta apenas os bytes em quadros de dados (pacotes) que contm dados.",

    "477",     "'Resposta de expiraes'  a contagem de expiraes de timer T1.",

    "479",     "'Confirmao de expirao'  a contagem de expiraes de timer T2.",

    "481",     "'Janela de transmisso mxima'  o nmero mximo de bytes de dados que ser enviado antes de aguardar uma confirmao do computador remoto.",

    "483",     "'Janela de transmisso mdia'  a mdia do nmero de bytes de dados enviados antes de aguardar uma confirmao do computador remoto.",

    "485",     "'Acmulo de confirmaes em fila/s'  a velocidade com que confirmaes acumuladas so colocadas na fila. As confirmaes acumuladas so confirmaes relativas a pacotes recebidos que sero includas no prximo pacote de sada para o computador remoto.",

    "487",     "'Tempo limite de confirmaes acumuladas'   o nmero de vezes que no foi possvel enviar uma confirmao acumulada porque no havia pacote de sada apropriado para o remoto onde ocorreria o acmulo. Uma confirmao acumulada  uma confirmao relativa a um pacote recebido, que ser includa no prximo pacote de sada para o computador remoto. Se nenhum pacote de sada for enviado durante o tempo limite, ser enviado um pacote de confirmao, e esse contador ser incrementado.",

    "489",     "O objeto de desempenho NWLink IPX consiste em contadores que medem a transmisso de datagramas de e para computadores utilizando protocolo IPX.",

    "491",     "O objeto de desempenho NWLink SPX consiste em contadores que medem a transmisso de dados e conexes de sesses para computadores que utilizam o protocolo SPX.",

    "493",     "O objeto de desempenho NetBEUI consiste em contadores que medem a transmisso de dados para atividade de rede que atende ao padro de interface de usurio final NetBIOS.",

    "495",     "O objeto de desempenho de recurso NetBEUI consiste em contadores que controlam o uso de buffers pelo protocolo NetBEUI.",

    "497",     "'Mximo usado'  o nmero mximo de recursos (buffers) NetBEUI em uso em um dado momento. Esse valor  til para dimensionar os recursos mximos fornecidos. O nmero entre parnteses aps o nome do recurso  utilizado para identificar o recurso em mensagens do log de eventos.",

    "499",     "'Mdia utilizada'  o nmero atual de recursos (buffers) em uso no momento. O nmero entre parntesis aps o nome do recurso  utilizado para identificar o recurso em mensagens do log de eventos.",

    "501",     "'Recursos esgotados'  o nmero de vezes que todos os recursos (buffers) estavam em uso. O nmero entre parnteses aps o nome do recurso  utilizado para identificar o recurso nas mensagens do log de eventos.",

    "503",     "O objeto de desempenho de conexo NBT consiste em contadores que medem a freqncia com a qual bytes so enviados e recebidos atravs da conexo NBT entre o computador local e um computador remoto. A conexo  identificada pelo nome do computador remoto.",

    "505",     "'Bytes recebidos/s'  a taxa em que os bytes so recebidos pelo computador local por meio de uma conexo NBT para algum computador remoto. Todos os bytes recebidos pelo computador local por meio de uma conexo NBT particular so contados.",

    "507",     "'Bytes enviados/s'  a taxa em que os bytes so enviados pelo computador local por meio de uma conexo NBT para algum computador remoto. Todos os bytes enviados pelo computador local por meio de uma conexo NBT particular so contados.",

    "509",     "'Total de bytes/s'  a taxa em que os bytes so recebidos pelo computador local por meio de uma conexo NBT para algum computador remoto. Todos os bytes enviados ou recebidos pelo computador local por meio de uma conexo NBT particular so contados.",

    "511",     "O objeto de desempenho de interface de rede consiste em contadores que medem a freqncia com a qual bytes e pacotes so enviados e recebidos atravs de uma conexo de rede TCP/IP. Ele inclui contadores que monitoram erros de conexo.",

    "513",     "'Total de bytes/s'  a taxa  qual bytes so enviados e recebidos em cada adaptador de rede, inclusive caracteres de enquadramento. 'Interface de rede\\Bytes recebidos/s'  a soma de 'Interface de rede\\Bytes recebidos/s' e 'Interface de rede\\Bytes enviados/s'.",

    "515",     "'Pacotes/s'  a taxa em que pacotes so enviados e recebidos na interface de rede.",

    "517",     "'Pacotes recebidos/s'  a taxa em que pacotes so recebidos na interface de rede.",

    "519",     "'Pacotes enviados/s'  a taxa em que pacotes so enviados na interface de rede.",

    "521",     "'Largura de banda atual'  uma estimativa da largura de banda atual da interface de rede em bits por segundo (BPS). Para interfaces que no variam em largura de banda ou para aquelas em que no se pode fazer nenhuma estimativa exata, esse valor  a largura de banda nominal.",

    "523",     "'Bytes recebidos/s'  a taxa  qual bytes so recebidos em cada adaptador de rede, inclusive caracteres de enquadramento. 'Interface de rede\\Bytes recebidos/s'  um subconjunto de 'Interface de rede\\Total de bytes/s'.",

    "525",     "'Pacotes recebidos de difuso ponto-a-ponto/s'  a taxa  qual pacotes de difuso ponto a ponto (sub-rede) so entregues a um protocolo de camada mais elevada.",

    "527",     "'Pacotes recebidos de difuso no-ponto-a-ponto/s'  a taxa  qual pacotes de no-difuso ponto a ponto (difuso ponto a ponto de sub-rede ou difuso seletiva de sub-rede) so entregues a um protocolo de camada mais elevada.",

    "529",     "'Pacotes recebidos descartados'  o nmero de pacotes de entrada que foram escolhidos para serem descartados, mesmo que nenhum erro tenha sido detectado para evitar a entrega para um protocolo de camada mais elevada. Um possvel motivo para descartar os pacotes poderia ser liberar espao no buffer.",

    "531",     "'Erros de pacotes recebidos'  o nmero de pacotes de entrada que continham erros que os impediram de ser entregues a um protocolo de camada mais elevada.",

    "533",     "'Pacotes recebidos desconhecidos'  o nmero de pacotes recebidos pela interface que foram descartados devido a um protocolo desconhecido ou sem suporte.",

    "535",     "'Bytes enviados/s'  a taxa  qual bytes so enviados em cada adaptador de rede, inclusive caracteres de enquadramento. 'Interface de rede\\Bytes enviados/s'  um subconjunto de 'Interface de rede \\Total de bytes/s.",

    "537",     "'Pacotes enviados de difuso ponto-a-ponto/s'  a taxa em que os pacotes so solicitados para serem transmitidos a endereos de difuso ponto a ponto de sub-rede por protocolos de nvel mais alto. A taxa inclui os pacotes descartados ou no enviados.",

    "539",     "'Pacotes enviados de difuso no-ponto-a-ponto/s'  a taxa em que os pacotes so solicitados para serem transmitidos a endereos que no so de difuso ponto a ponto (difuso de sub-rede ou difuso seletiva de sub-rede) por protocolos de nvel mais alto. A taxa inclui os pacotes descartados ou no enviados.",

    "541",     "'Pacotes de sada descartados'  o nmero de pacotes de sada que foram escolhidos para serem descartados mesmo que nenhum erro tenha sido detectado para evitar a transmisso. Um possvel motivo para descartar os pacotes poderia ser liberar espao no buffer.",

    "543",     "'Erros de pacotes de sada'  o nmero de pacotes de sada que no puderam ser transmitidos devido a erros.",

    "545",     "'Comprimento da fila de sada'  o comprimento da fila de pacotes de sada (em pacotes). Se for maior que dois, haver atrasos e o afunilamento dever ser encontrado e eliminado, se possvel. Como as solicitaes so enfileiradas pela NDIS (especificao da interface do driver de rede) nesta implementao, esse valor ser sempre 0.",

    "547",     "O objeto de desempenho IP consiste em contadores que medem a freqncia com a qual datagramas IP so enviados e recebidos com o uso de protocolos IP. Ele tambm inclui contadores que monitoram erros de protocolo IP.",

    "549",     "'Datagramas/s'  a taxa, em incidentes por segundo, na qual os datagramas de IP foram recebidos de ou enviados s interfaces, inclusive os que contm erro. Os datagramas encaminhados no so includos nessa taxa.",

    "551",     "'Datagramas recebidos/s'  a taxa, em incidentes por segundo, na qual os datagramas de IP so recebidos das interfaces, incluindo os que contm erro. 'Datagramas recebidos/s'  um subconjunto de 'Datagramas/s'.",

    "553",     "'Erros de cabealho de datagramas recebidos'  o nmero de datagramas de entrada descartados devido a erros nos cabealhos IP, incluindo somas de verificao invlidas, combinao de nmero de verso, outros erros de formato, vida til excedida, erros descobertos no processamento de suas opes IP etc.",

    "555",     "'Erros de endereo de datagramas recebidos'  o nmero de datagramas de entrada descartados porque o endereo IP em seu campo de destino do cabealho IP no era vlido para o computador. Essa contagem inclui endereos invlidos (por exemplo, 0.0.  0.0) e endereos de classes para as quais no h suporte (por exemplo, Classe E). Para entidades que no esto em gateways IP e no encaminham datagramas, esse contador inclui datagramas que foram descartados porque o endereo de destino no era um endereo local.",

    "557",     "'Datagramas encaminhados/s'  a taxa, em incidentes por segundo, na qual se tentou localizar as rotas para encaminhar os datagramas de entrada ao seu destino final, porque o servidor local no foi o destino IP final. Em servidores que no funcionam como Gateways IP, essa taxa inclui somente pacotes que foram encaminhados para a origem por meio dessa entidade, onde o processamento da opo encaminhada para a origem foi bem-sucedido.",

    "559",     "'Protocolo desconhecido de datagramas recebidos'  o nmero de datagramas endereados localmente que foram recebidos com xito, mas foram descartados devido a um protocolo desconhecido ou porque no havia suporte para os mesmos.",

    "561",     "'Datagramas recebidos descartados'  o nmero de datagramas IP de entrada que foram descartados embora problemas tenham impedido seu processamento (por exemplo, falta de espao em buffer). Este contador no inclui datagramas descartados enquanto aguardavam reorganizao.",

    "563",     "'Datagramas recebidos entregues/s'  a taxa, em incidentes por segundo,  qual datagramas de entrada foram entregues com xito a protocolos IP de usurio, inclusive Internet Control Message Protocol (ICMP).",

    "565",     "'Datagramas enviados/s'  a taxa, em incidentes por segundo, na qual os datagramas de IP foram fornecidos para transmisso por protocolos de usurio IP local (incluindo ICMP). Esse contador no inclui nenhum datagrama contado em 'Datagramas encaminhados/s'. 'Datagramas enviados/s'  um subconjunto de 'Datagramas/s'.",

    "567",     "'Datagramas de sada descartados'  o nmero de datagramas IP de sada que foram descartados embora nenhum problema tivesse sido encontrado para impedir sua transmisso ao destino (por exemplo, falta de espao em buffer). Este contador inclui os datagramas contados em 'Datagramas encaminhados/s' que atenderem a este critrio.",

    "569",     "'Datagramas de sada sem rota'  o nmero de datagramas IP que foram descartados porque nenhuma rota pde ser encontrada para transmiti-los ao destino. Este contador inclui quaisquer pacotes contados em 'Datagramas encaminhados/s' que atendam a este critrio de 'nenhuma rota'.",

    "571",     "'Fragmentos recebidos/s'  a taxa, em incidentes por segundo,  qual fragmentos IP que precisam ser reorganizados nesta entidade so recebidos.",

    "573",     "'Fragmentos reorganizados/s'  a taxa, em incidentes por segundo,  qual fragmentos IP foram reorganizados com xito.",

    "575",     "'Falhas de fragmentos reorganizados/s'  o nmero de falhas detectadas pelo algoritmo de remontagem de IP, como tempos limite, erros etc. No  necessariamente uma contagem de fragmentos de IP descartados, j que alguns algoritmos (especialmente o RFC 815) perdem o rastro do nmero de fragmentos combinando-os conforme eles so recebidos.",

    "577",     "'Datagramas fragmentados/s'  a taxa, em incidentes por segundo,  qual datagramas so fragmentados com xito.",

    "579",     "'Falhas de fragmentao'  o nmero de datagramas de IP descartados porque precisavam ser fragmentados, mas no foram (por exemplo, porque o sinalizador 'Don't Fragment' [No fragmentar] estava definido).",

    "581",     "'Fragmentos criados/s'  a taxa, em incidentes por segundo,  qual fragmentos de datagramas IP foram gerados como resultado da fragmentao.",

    "583",     "O objeto de desempenho ICMP consiste em contadores que medem as taxas de envio e recepo das mensagens usando protocolos ICMP. Ele tambm inclui contadores que monitoram erros de protocolo ICMP.",

    "585",     "'Mensagens/s'  a taxa total, em incidentes por segundo, em que as mensagens ICMP foram enviadas e recebidas pela entidade. A taxa inclui mensagens recebidas ou enviadas com erros.",

    "587",     "'Mensagens recebidas/s'  a taxa, em incidentes por segundo, em que as mensagens ICMP foram recebidas. A taxa inclui mensagens recebidas com erros.",

    "589",     "'Erros de mensagens recebidas'  o nmero de mensagens ICMP que a entidade recebeu, mas que tinham erros, como somas de verificao ICMP incorretas, comprimento incorreto etc.",

    "591",     "'Mensagens de destinos inacessveis recebidas'  o nmero de mensagens de destino ICMP recebidas que no foram alcanadas.",

    "593",     "'Tempo de recebimento excedido'  o nmero de mensagens de tempo excedido ICMP recebidas.",

    "595",     "'Problema no parmetro de recebimento'  o nmero de mensagens de problema de parmetro ICMP recebidas.",

    "597",     "'Desconexes de origem recebidas'  o nmero de mensagens de retardamento de origem ICMP recebidas.",

    "599",     "'Redirecionamento de recebimento/s'  a taxa, em incidentes por segundo, em que as mensagens de redirecionamento ICMP foram recebidas.",

    "601",     "'Eco de recebimento/s'  a taxa, em incidentes por segundo, em que as mensagens de eco ICMP foram recebidas.",

    "603",     "'Resposta de eco recebido/s'  a taxa, em incidentes por segundo, em que as mensagens de resposta de eco ICMP foram recebidas.",

    "605",     "'Carimbo de data/hora recebido/s'  a taxa, em incidentes por segundo, em que as mensagens de solicitao de carimbo de data/hora ICMP foram recebidas.",

    "607",     "'Resposta de carimbo de data/hora recebido/s'  a taxa de mensagens de resposta ao carimbo de data/hora ICMP recebidas.",

    "609",     "'Mscara de endereo recebida'  o nmero de mensagens de solicitao de mscara de endereo ICMP recebidas.",

    "611",     "'Resposta de mscara de endereo recebida'  o nmero de mensagens de resposta de mscara de endereo ICMP recebidas.",

    "613",     "'Mensagens enviadas/s'  a taxa, em incidentes por segundo,  qual o servidor tentou executar o envio. A taxa inclui as mensagens enviadas com erros.",

    "615",     "'Erros de mensagens de sada'  o nmero de mensagens ICMP que no foram enviadas por problemas no ICMP, como ausncia de buffers. Esse valor no inclui os erros descobertos fora da camada ICMP, tal como os que registram a falha de IP para rotear o datagrama resultante. Em algumas implementaes, nenhum tipo de erro  includo no valor desse contador.",

    "617",     "'Destino de envio inacessvel'  o nmero de mensagens de destino inacessvel ICMP enviadas.",

    "619",     "'Tempo de envio excedido'  o nmero de mensagens de tempo excedido ICMP enviadas.",

    "621",     "'Problema no parmetro de envio'  o nmero de mensagens de problema de parmetro ICMP enviadas.",

    "623",     "'Desconexes de origem enviadas'  o nmero de mensagens de retardamento da origem ICMP enviadas.",

    "625",     "'Redirecionamento de envio/s'  a taxa, em incidentes por segundo, em que as mensagens de redirecionamento ICMP foram enviadas.",

    "627",     "'Eco de envio/s'  a taxa de mensagens de eco ICMP enviadas.",

    "629",     "'Resposta de eco de envio/s'  a taxa, em incidentes por segundo, em que as mensagens de resposta de eco ICMP foram enviadas.",

    "631",     "'Carimbo de data/hora enviado/s'  a taxa, em incidentes por segundo, em que as mensagens de solicitao de carimbo de data/hora ICMP so enviadas.",

    "633",     "'Resposta de carimbo de data/hora enviado/s'  a taxa, em incidentes por segundo, em que as mensagens de resposta ao carimbo de data/hora ICMP so enviadas.",

    "635",     "'Mscara de endereo enviada'  o nmero de mensagens de solicitao de mscara de endereo ICMP (protocolo de mensagens de controle da Internet) enviadas.",

    "637",     "'Resposta de mscara de endereo enviada'  o nmero de mensagens de resposta de mscara de endereo ICMP enviadas.",

    "639",     "O objeto de desempenho TCP consiste em contadores que medem a freqncia com a qual os segmentos TCP so enviados e recebidos com uso do protocolo TCP. Ele inclui contadores que monitoram o nmero de conexes TCP em cada estado de conexo TCP.",

    "641",     "Pacotes recebidos/s  a taxa em que pacotes so recebidos pelo servidor DHCP.",

    "643",     "'Conexes estabelecidas'  o nmero de conexes TCP para as quais o estado atual  ESTABLISHED ou CLOSE-WAIT.",

    "645",     "'Conexes ativas'  o nmero de vezes que conexes TCP fizeram uma transio direta ao estado SYN-SENT do estado CLOSED.",

    "647",     "'Conexes passivas'  o nmero de vezes que conexes TCP fizeram uma transio direta ao estado SYN-RCVD do estado LISTEN.",

    "649",     "'Falhas de conexo'  o nmero de vezes que as conexes TCP fizeram uma transio direta para o estado CLOSED do estado SYN-SENT ou SYN-RCVD, mais o nmero de vezes que as conexes TCP fizeram uma transio direta para o estado LISTEN do estado SYN-RCVD.",

    "651",     "'Conexes redefinidas'  o nmero de vezes que conexes TCP fizeram uma transio direta ao estado CLOSED do estado ESTABLISHED ou CLOSE-WAIT.",

    "653",     "'Segmentos recebidos/s'  a taxa em que os segmentos so recebidos, incluindo os recebidos com erro. Essa contagem inclui segmentos recebidos nas conexes estabelecidas atualmente.",

    "655",     "'Segmentos enviados/s'  a taxa em que os segmentos so enviados, incluindo os que esto em conexes atuais, mas excluindo os que contm apenas bytes retransmitidos.",

    "657",     "'Segmentos retransmitidos/s'  a taxa em que os segmentos so retransmitidos, ou seja, segmentos transmitidos que contm um ou mais bytes transmitidos anteriormente.",

    "659",     "O objeto de desempenho UDP consiste em contadores que medem a freqncia com a qual os datagramas UDP so enviados e recebidos atravs do protocolo UDP. Ele inclui contadores que monitoram os erros de protocolo UDP.",

    "661",     "'Datagramas/s'  a taxa em que datagramas so enviados e recebidos pela entidade.",

    "663",     "'Datagramas recebidos/s'  a taxa em que datagramas UDP so entregues a usurios UDP.",

    "665",     "'Datagramas sem porta/s'  a taxa de datagramas UDP recebidos para a qual no h aplicativos na porta de destino.",

    "667",     "'Erros de datagramas recebidos'  o nmero de datagramas UDP recebidos que no puderam ser enviados por algum motivo que no seja a falta de um aplicativo na porta de destino.",

    "669",     "'Datagramas enviados/s'  a taxa em que datagramas UDP so enviados pela entidade.",

    "671",     "'Estatsticas de dispositivo de armazenamento de disco' do outro computador",

    "673",     "O nmero de falhas de alocao informadas pelo dispositivo de armazenamento em disco",

    "675",     "'Tempo de atividade do sistema'  o tempo transcorrido (em segundos) em que o computador est em funcionamento desde que foi inicializado da ltima vez. Esse contador exibe a diferena entre a hora de incio e a hora atual. ",

    "677",     "O nmero atual de manipuladores de sistema em uso.",

    "679",     "'Entradas livres de tabela de paginao do sistema'  o nmero de entradas de tabela de paginao que no esto em uso pelo sistema no momento. Este contador exibe apenas o ltimo valor observado; ele no  uma mdia. ",

    "681",     "O nmero de segmentos atualmente ativos neste processo. Uma instruo  a unidade bsica de execuo em um processador e um segmento  o objeto que executa as instrues. Todo processo em andamento tem pelo menos um segmento.",

    "683",     "A prioridade bsica atual deste processo. Segmentos dentro de um processo podem aumentar ou diminuir sua prpria prioridade bsica em relao  prioridade bsica do processo.",

    "685",     "O tempo total transcorrido, em segundos, desde o incio da execuo deste processo.",

    "687",     "'Correes de alinhamento/s'  a taxa, em incidentes por segundos,  qual falhas de alinhamento foram corrigidas pelo sistema.",

    "689",     "'Despachos de exceo/s'  a taxa, em incidentes por segundo,  qual excees foram despachadas pelo sistema.",

    "691",     "'Emulaes flutuantes/s'  a taxa de emulaes flutuantes realizadas pelo sistema. Esse contador exibe a diferena entre os valores observados nos dois ltimos exemplos, dividida pela durao do intervalo de exemplo.",

    "693",     "'Logon/s'  a taxa de todos os logons do servidor.",

    "695",     "A prioridade dinmica atual deste segmento. O sistema pode elevar a prioridade dinmica do segmento acima da prioridade bsica se o segmento estiver tratando de entradas do usurio, ou diminu-la at a prioridade bsica se o segmento tornar-se limitado pelo processo.",

    "697",     "A prioridade dinmica atual deste segmento. O sistema pode elevar a prioridade dinmica do segmento acima da prioridade bsica se o segmento estiver tratando de entradas do usurio, ou diminu-la at a prioridade bsica se o segmento tornar-se limitado pelo processo.",

    "699",     "O tempo total transcorrido, em segundos, desde o incio da execuo deste processo.",

    "701",     "O objeto de desempenho de arquivo de paginao consiste em contadores que monitoram o(s) arquivo(s) de paginao no computador. O arquivo de paginao  um espao reservado no disco que faz backup de memria fsica confirmada no computador.",

    "703",     "A quantidade percentual da instncia do arquivo de paginao em uso. Consulte tambm 'Processo\\Bytes de arquivo de paginao'.",

    "705",     "O uso mximo da instncia do arquivo de pginas em percentual. Consulte tambm 'Processo\\Pico de bytes de arquivo de paginao'.",

    "707",     "Iniciando endereo virtual para este segmento.",

    "709",     "Contador de programa de usurio atual para este segmento.",

    "711",     "'Espao mapeado'  a memria virtual que foi mapeada para um endereo virtual especfico (ou intervalo de endereos virtuais) no espao de endereo virtual do processo. A proteo 'No Access' impede que um processo grave ou leia nessas pginas e gera uma violao de acesso se uma dessas aes for tentada.",

    "713",     "'Espao mapeado'  a memria virtual que foi mapeada para um endereo virtual especfico (ou intervalo de endereos virtuais) no espao de endereo virtual do processo. A proteo 'Read Only' impede que o contedo dessas pginas seja modificado. Se houver tentativas de gravar ou modificar essas pginas,  gerada uma violao de acesso.",

    "715",     "'Espao mapeado'  a memria virtual que foi mapeada para um endereo virtual especfico (ou intervalo de endereos virtuais) no espao de endereo virtual do processo. A proteo 'Read/Write' permite que um processo leia, modifique e grave nessas pginas.",

    "717",     "'Espao mapeado'  a memria virtual que foi mapeada para um endereo virtual especfico (ou intervalo de endereos virtuais) no espao de endereo virtual do processo. A proteo 'Write Copy'  usada quando a memria  compartilhada para leitura, mas no para gravao. Quando os processos esto lendo essa memria, podem compartilhar a mesma memria. Contudo, quando um processo de compartilhamento deseja ter acesso de gravao a essa memria compartilhada,  criada uma cpia dela.",

    "719",     "'Espao mapeado'  a memria virtual que foi mapeada para um endereo virtual especfico (ou intervalo de endereos virtuais) no espao de endereo virtual do processo. 'Executable memory'  a memria que pode ser executada por programas, mas no pode ser lida nem gravada. Nem todos os tipos de processador do suporte a esse tipo de proteo.",

    "721",     "'Espao mapeado'  a memria virtual que foi mapeada para um endereo virtual especfico (ou intervalo de endereos virtuais) no espao de endereo virtual do processo. 'Execute/Read Only memory'  a memria que pode ser executada e lida.",

    "723",     "'Espao mapeado'  a memria virtual que foi mapeada para um endereo virtual especfico (ou intervalo de endereos virtuais) no espao de endereo virtual do processo. 'Execute/Read/Write memory'  a memria que pode ser executada, lida e modificada por programas.",

    "725",     "'Espao mapeado'  a memria virtual que foi mapeada para um endereo virtual especfico (ou intervalo de endereos virtuais) no espao de endereo virtual do processo. 'Execute Write Copy'  a memria que pode ser executada pelos programas, permitindo tambm leitura e gravao. Esse tipo de proteo  usado quando a memria precisa ser compartilhada entre processos. Se os processos de compartilhamento apenas lerem a memria, todos eles usaro a mesma memria. Se um processo de compartilhamento desejar ter acesso de gravao, ser criada uma cpia da memria para esse processo.",

    "727",     "'Espao reservado'  memria virtual que foi reservada para uso futuro por um processo, mas ainda no foi mapeada nem confirmada. A proteo 'Sem acesso' impede que um processo grave ou leia nessas pginas e gera uma violao de acesso se uma dessas aes for tentada.",

    "729",     "'Espao reservado'  a memria virtual que foi reservada para uso futuro por um processo, mas no foi mapeada nem confirmada. A proteo 'Read Only' impede que o contedo dessas pginas seja modificado. Se houver tentativas de gravar ou modificar essas pginas, ser gerada uma violao de acesso.",

    "731",     "'Espao reservado'  a memria virtual que foi reservada para uso futuro por um processo, mas no foi mapeada nem confirmada. A proteo 'Read/Write' permite que um processo leia, modifique e grave nessas pginas.",

    "733",     "'Espao reservado'  uma memria virtual reservada para uso futuro por um processo, mas que no foi mapeada ou confirmada. A proteo da cpia de gravao  usada quando a memria  compartilhada para leitura e no gravao. Quando os processos esto lendo essa memria, eles podem compartilhar a mesma memria; entretanto, quando um processo de compartilhamento pretende ter acesso de leitura/gravao para essa memria compartilhada, uma cpia dessa memria  realizada.",

    "735",     "'Espao reservado'  a memria virtual que foi reservada para uso futuro por um processo, mas no foi mapeada nem confirmada. 'Execute Write Copy'  a memria que pode ser executada, lida e gravada pelos programas. 'Executable memory'  a memria que pode ser executada pelos programas, mas no pode ser lida nem gravada. Nem todos os tipos de processador do suporte a esse tipo de proteo.",

    "737",     "'Espao reservado'  a memria virtual que foi reservada para uso futuro por um processo, mas no foi mapeada nem confirmada. 'Execute/Read Only memory'  a memria que pode ser executada e lida.",

    "739",     "'Espao reservado'  a memria virtual que foi reservada para uso futuro por um processo, mas no foi mapeada nem confirmada. 'Execute/Read/Write memory'  a memria que pode ser executada, lida e modificada pelos programas.",

    "741",     "O objeto de desempenho de imagem consiste em contadores que monitoram o uso do endereo virtual de imagens executadas por processos no computador.",

    "743",     "'Espao reservado'  a memria virtual que foi reservada para uso futuro por um processo, mas no foi mapeada nem confirmada. 'Execute Write Copy'  a memria que pode ser executada, lida e gravada pelos programas. Esse tipo de proteo  usado quando a memria precisa ser compartilhada entre processos. Se os processos de compartilhamento apenas lerem a memria, todos eles usaro a mesma memria. Se um processo de compartilhamento desejar ter acesso de gravao, ser criada uma cpia da memria para esse processo.",

    "745",     "'Espao no atribudo'  a memria virtual mapeada e confirmada em uso pelo processo que no  atribuvel a nenhuma imagem em particular executada pelo processo. A proteo 'No Access' impede que um processo grave ou leia nessas pginas e gera uma violao de acesso se uma dessas aes for tentada.",

    "747",     "'Espao no atribudo'  a memria virtual mapeada e confirmada em uso pelo processo que no  atribuvel a nenhuma imagem em particular executada pelo processo. A proteo 'Read Only' impede que o contedo dessas pginas seja modificado. Se houver tentativas de gravar ou modificar essas pginas, ser gerada uma violao de acesso.",

    "749",     "'Espao no atribudo'  a memria virtual mapeada e confirmada em uso pelo processo que no  atribuvel a nenhuma imagem em particular executada pelo processo. A proteo 'Read/Write' permite que um processo leia, modifique e grave nessas pginas.",

    "751",     "'Espao no atribudo'  a memria virtual mapeada e confirmada em uso pelo processo que no  atribuvel a nenhuma imagem em particular executada pelo processo. A proteo 'Write Copy'  usada quando a memria  compartilhada para leitura, mas no para gravao. Quando os processos esto lendo essa memria, podem compartilhar a mesma memria. Contudo, quando um processo de compartilhamento deseja ter acesso de leitura/gravao a essa memria compartilhada,  criada uma cpia da memria para gravao.",

    "753",     "'Espao no atribudo'  a memria virtual mapeada e confirmada em uso pelo processo que no  atribuvel a nenhuma imagem em particular executada pelo processo. 'Executable memory'  a memria que pode ser executada pelos programas, mas no pode ser lida nem gravada. Nem todos os tipos de processador do suporte a esse tipo de proteo.",

    "755",     "'Espao no atribudo'  a memria virtual mapeada e confirmada em uso pelo processo que no  atribuvel a nenhuma imagem em particular executada pelo processo. 'Execute/Read Only memory'  a memria que pode ser executada e lida.",

    "757",     "'Espao no atribudo'  a memria virtual mapeada e confirmada em uso pelo processo que no  atribuvel a nenhuma imagem em particular executada pelo processo. 'Execute/Read/Write memory'  a memria que pode ser executada, lida e gravada pelos programas.",

    "759",     "'Espao no atribudo'  a memria virtual mapeada e confirmada em uso pelo processo que no  atribuvel a nenhuma imagem em particular executada pelo processo. 'Execute Write Copy'  a memria que pode ser executada, lida e gravada pelos programas. Esse tipo de proteo  usado quando a memria precisa ser compartilhada entre processos. Se os processos de compartilhamento apenas lerem a memria, todos eles usaro a mesma memria. Se um processo de compartilhamento desejar ter acesso de gravao, ser criada uma cpia da memria para esse processo.",

    "761",     "'Espao de imagem'  o espao de endereo virtual em uso pelas imagens que esto sendo executadas pelo processo. Essa  a soma de todos os espaos de endereo com esta proteo alocada por imagens executadas pelo processo selecionado. A proteo 'No Access' impede que um processo grave ou leia nessas pginas e gera uma violao de acesso se uma dessas aes for tentada.",

    "763",     "'Espao de imagem'  o espao de endereo virtual em uso pelas imagens que esto sendo executadas pelo processo. Essa  a soma de todos os espaos de endereo com esta proteo alocada por imagens executadas pelo processo selecionado. A proteo 'Read Only' impede que o contedo dessas pginas seja modificado. Qualquer tentativa de gravar ou modificar as pginas gera uma violao de acesso.",

    "765",     "'Espao de imagem'  o espao de endereo virtual em uso pelas imagens que esto sendo executadas pelo processo. Essa  a soma de todos os espaos de endereo com esta proteo alocada por imagens executadas pelo processo selecionado. A proteo 'Read/Write' permite que um processo leia, modifique e grave nessas pginas.",

    "767",     "'Espao de imagem'  o espao de endereo virtual em uso pelas imagens que esto sendo executadas pelo processo. Essa  a soma de todos os espaos de endereo com esta proteo alocada por imagens executadas pelo processo selecionado. A proteo 'Write Copy'  usada quando a memria  compartilhada para leitura, mas no para gravao.  Quando os processos esto lendo essa memria, podem compartilhar a mesma memria. Contudo, quando um processo de compartilhamento deseja ter acesso de leitura/gravao a esta memria compartilhada,  criada uma cpia dela para gravao.",

    "769",     "'Espao de imagem'  o espao de endereo virtual em uso pelas imagens que esto sendo executadas pelo processo. Essa  a soma de todos os espaos de endereo com esta proteo alocada por imagens executadas pelo processo selecionado. 'Executable memory'  a memria que pode ser executada por programas, mas no permite leitura nem gravao. Nem todos os tipos de processar do suporte a esse tipo de proteo.",

    "771",     "'Espao de imagem'  o espao de endereo virtual em uso pelas imagens que esto sendo executadas pelo processo. Essa  a soma de todos os espaos de endereo com esta proteo alocada por imagens executadas pelo processo selecionado. A memria 'Execute/Read Only'  a memria que pode ser executada e lida.",

    "773",     "'Espao de imagem'  o espao de endereo virtual em uso pelas imagens que esto sendo executadas pelo processo. Essa  a soma de todos os espaos de endereo com esta proteo alocada por imagens executadas pelo processo selecionado. A memria 'Execute/Read/Write'  a memria que pode ser executada por programas, permitindo tambm a leitura, gravao e modificao.",

    "775",     "'Espao de imagem'  o espao de endereo virtual em uso pelas imagens que esto sendo executadas pelo processo. Essa  a soma de todos os espaos de endereo com esta proteo alocada por imagens executadas pelo processo selecionado. 'Execute Write Copy'  a memria que pode ser executada pelos programas, permitindo tambm leitura e gravao. Esse tipo de proteo  usado quando a memria precisa ser compartilhada entre processos. Se os processos de compartilhamento apenas lerem a memria, todos eles usam a mesma memria. Se um processo desejar ter acesso de gravao,  criada uma cpia da memria para esse processo.",

    "777",     "'Bytes de imagem reservados'  a soma de toda a memria virtual reservada por imagens no processo.",

    "779",     "'Bytes de imagem livres'  a quantidade de espao de endereo virtual que no est em uso ou est reservado por imagens no processo.",

    "781",     "Bytes reservados'  a quantidade total de memria virtual reservada para uso futuro por esse processo.",

    "783",     "'Bytes livres'  o espao total de endereo virtual no utilizado do processo.",

    "785",     "'Processo de identificao'  o identificador exclusivo deste processo. Os nmeros do 'Identificador de processo' so reutilizados; portanto, eles apenas identificam um processo durante a vida til desse processo.",

    "787",     "O objeto de desempenho de espao de endereo do processo consiste em contadores que monitoram a alocao e o uso de um processo selecionado.",

    "789",     "'Espao de imagem'  o espao de endereo virtual em uso pela imagem selecionada com esta proteo. A proteo 'Sem acesso' impede que um processo grave ou leia essas pginas e gera uma violao de acesso se uma dessas aes for tentada.",

    "791",     "'Espao de imagem'  o espao de endereo virtual em uso pela imagem selecionada com esta proteo. A proteo 'Somente leitura' impede que o contedo dessas pginas seja modificado. Quaisquer tentativas de gravar ou modificar essas pginas geram uma violao de acesso.",

    "793",     "'Espao de imagem'  o espao de endereo virtual em uso pela imagem selecionada com esta proteo. A proteo 'Leitura/gravao' permite que um processo leia, modifique e grave nessas pginas.",

    "795",     "'Espao de imagem'  o espao de endereo virtual em uso pela imagem selecionada com esta proteo. A proteo 'Gravao/cpia'  usada quando a memria  compartilhada para leitura, mas no para gravao. Quando processos esto lendo a memria, podem compartilhar a mesma memria; contudo, quando um processo de compartilhamento deseja ter acesso de leitura/gravao  memria compartilhada,  feita uma cpia da memria para gravao.",

    "797",     "'Espao de imagem'  o espao de endereo virtual em uso pela imagem selecionada com esta proteo. A memria executvel  aquela que permite a execuo por programas, mas no permite a leitura nem a gravao. Nem todos os tipos de processador do suporte a esse tipo de proteo.",

    "799",     "'Espao de imagem'  o espao de endereo virtual em uso pela imagem selecionada com esta proteo. A memria do tipo somente execuo/leitura  aquela que permite a execuo, bem como a leitura.",

    "801",     "'Espao de imagem'  o espao de endereo virtual em uso pela imagem selecionada com esta proteo. A memria do tipo execuo/leitura/gravao  aquela que permite a execuo por programas, bem como a leitura e a gravao.",

    "803",     "'Espao de imagem'  o espao do endereo virtual em uso pela imagem selecionada com essa proteo. Execute Write Copy  a memria que pode ser executada por programas, bem como lida e gravada. Esse tipo de proteo  usado quando a memria precisa ser compartilhada entre os processos. Se os processos de compartilhamento apenas lem a memria, todos eles usaro a mesma memria. Se um processo de compartilhamento deseja acesso de gravao, uma cpia da memria ser feita para esse processo.",

    "805",     "'Segmento de identificao'  o identificador exclusivo desse segmento. Os nmeros do 'Identificador de segmento' so reutilizados; portanto, eles apenas identificam um segmento para a vida til desse segmento.",

    "807",     "'Falhas de abertura do processador de mensagens/s' indica a taxa em que as mensagens do processador de mensagens a serem enviadas para os processadores de mensagem que no esto presentes so recebidas por esta estao de trabalho.",

    "809",     "'Notificaes mestres duplicadas' indica o nmero de vezes que o navegador mestre detectou outro navegador mestre no mesmo domnio.",

    "811",     "'Datagramas invlidos/s'  a taxa em que os datagramas formatados incorretamente so recebidos pela estao de trabalho.",

    "813",     "'Total de anncios/s'  a soma de 'Anncios de servidor/s' e 'Anncios de domnio/s'.",

    "815",     "'Total de enumeraes/s'  a taxa  qual solicitaes de pesquisa foram processadas por esta estao de trabalho. Esta  a soma de 'Enumeraes de servidor/s', 'Enumeraes de domnio/s' e 'Outras enumeraes/s'.",

    "817",     "O objeto de desempenho de detalhes de segmentos consiste em contadores que medem aspectos do comportamento de segmentos que so difceis ou demorados para coleta. Esses contadores se distinguem dos contadores no objeto de segmento por terem um alta sobrecarga.",

    "819",     "'Bytes de cache'  a soma dos contadores 'Memria\\Bytes residentes de cache do sistema', 'Memria\\Bytes residentes de driver do sistema', 'Memria\\Bytes residentes de cdigo do sistema' e 'Memria\\Bytes residentes de pool paginvel'. Esse contador exibe apenas o ltimo valor observado, ele no  uma mdia. ",

    "821",     "'Mximo de bytes de cache'  o nmero mximo de bytes usados pela cache de sistema de arquivos desde a ltima vez em que o sistema foi reiniciado. Esse valor pode ser maior do que o tamanho da cache. Este contador exibe apenas o ltimo valor observado; ele no  uma mdia. ",

    "823",     "'Entrada de pginas/s'  a taxa em que as pginas so lidas do disco para resolver as falhas de paginao fsica. As falhas de paginao fsica ocorrem quando um processo refere-se a uma pgina na memria virtual que no est no conjunto de trabalho ou em qualquer outro lugar na memria fsica e deve ser recuperado do disco. Quando ocorre uma falha de paginao, o sistema tenta ler vrias pginas vizinhas na memria para maximizar o benefcio da operao de leitura. Compare o valor de 'Memria\\Entrada de pginas/s' como o valor de 'Memria\\Leituras de pgina/s' para determinar o nmero mdio de pginas lidas na memria durante cada operao de leitura.",

    "825",     "'Pginas de transio realocadas'  a taxa  qual o nmero de pginas de transio em cache foram reutilizadas para um propsito diferente.  Essas pginas teriam permanecido na cache de pginas para fornecer uma falha de software rpida (em vez da recuperao no armazenamento de backup) caso a pgina tenha sido acessada no futuro.  Observe que estas pginas podem conter memria particular ou compartilhvel.",

    "871",     "O objeto de desempenho RAS consiste em contadores que monitoram portas individuais de servio de acesso remoto do dispositivo RAS no computador.",

    "873",     "O nmero total de bytes transmitidos nessa conexo.",

    "875",     "O nmero total de bytes recebidos nessa conexo.",

    "877",     "O nmero total de quadros de dados transmitidos nessa conexo.",

    "879",     "O nmero total de quadros de dados recebidos nessa conexo.",

    "881",     "A taxa de compactao para os bytes que esto sendo transmitidos.",

    "883",     "A taxa de compactao para os bytes que esto sendo recebidos.",

    "885",     "O nmero total de erros de CRC para essa conexo. Os erros de CRC ocorrem quando o quadro recebido contm dados errados.",

    "887",     "O nmero total de erros de tempo limite para essa conexo. Os erros de tempo limite ocorrem quando um item esperado no  recebido a tempo.",

    "889",     "O nmero total de erros de saturao da porta serial para essa conexo. Os erros de saturao da porta serial ocorrem quando o hardware no pode tratar a taxa de recebimento dos dados.",

    "891",     "O nmero total de erros de alinhamento para essa conexo. Os erros de alinhamento ocorrem quando um byte recebido  diferente do byte esperado.",

    "893",     "O nmero total de erros de saturao de buffer para essa conexo. Os erros de saturao de buffer ocorrem quando o software no pode tratar a taxa de recebimento dos dados.",

    "895",     "O nmero total de erros de CRC, tempo limite, saturao da porta serial, alinhamento e saturao de buffer para essa conexo.",

    "897",     "O nmero de bytes transmitidos por segundo.",

    "899",     "O nmero de bytes recebidos por segundo.",

    "901",     "O nmero de quadros transmitidos por segundo.",

    "903",     "O nmero de quadros recebidos por segundo.",

    "905",     "O nmero total de erros de CRC, tempo limite, saturao da porta serial, alinhamento e saturao de buffer por segundo.",

    "907",     "O objeto de desempenho RAS consiste em contadores que combinam valores para todas as portas do dispositivo do servio de acesso remoto (RAS) no computador.",

    "909",     "O nmero total de conexes de acesso remoto.",

    "921",     "O objeto de desempenho de servidor WINS consiste em contadores que monitoram comunicaes utilizando o servio do servidor WINS.",

    "923",     "'Registros exclusivos/s'  a freqncia com a qual registros exclusivos so recebidos pelo servidor WINS.",

    "925",     "'Registros de grupo/s'  a taxa em que o registro de grupo  recebido pelo servidor WINS.",

    "927",     "'Nmero total de registros/s'  a soma de registros exclusivos e em grupo por segundo.  a freqncia total na qual os registros so recebidos pelo servidor WINS.",

    "929",     "'Renovaes exclusivas/s'  a freqncia com a qual renovaes exclusivas so recebidas pelo servidor WINS.",

    "931",     "'Renovaes de grupo/s'  a freqncia com a qual renovaes de grupo so recebidas pelo servidor WINS.",

    "933",     "'Nmero total de renovaes/s'  a soma de renovaes exclusivas e em grupo por segundo.  a freqncia total na qual as renovaes so recebidas pelo servidor WINS.",

    "935",     "'Nmero total de liberaes/s'  a freqncia total na qual as liberaes so recebidas pelo servidor WINS.",

    "937",     "'Nmero total de consultas/s'  a freqncia com a qual as consultas so recebidas pelo servidor WINS.",

    "939",     "'Conflitos exclusivos/s'  a freqncia com a qual registros/renovaes exclusivos(as) recebidos(as) pelo servidor WINS resultaram em conflitos com registros no banco de dados.",

    "941",     "'Conflitos de grupo/s'  a taxa em que o registro de grupo recebido pelo servidor WINS resultou em conflitos com os registros no banco de dados.",

    "943",     "'Nmero total de conflitos/s'  a soma de conflitos exclusivos e em grupo por segundo.  a freqncia total na qual os conflitos foram vistos pelo servidor WINS.",

    "945",     "Nmero total de liberaes com xito/s",

    "947",     "Nmero total de liberaes com falha/s",

    "949",     "Nmero total de consultas com xito/s",

    "951",     "Nmero total de consultas com falha/s",

    "953",     "O nmero total de identificadores abertos por este processo. Esse nmero  igual  soma dos identificadores atualmente abertos por cada segmento neste processo.",

    "1001",     "Servios para Servidor de arquivos Macintosh AFP.",

    "1003",     "A quantidade mxima de recursos de memria paginvel utilizada pelo servidor MacFile.",

    "1005",     "A quantidade atual dos recursos de memria paginvel utilizados pelo servidor MacFile.",

    "1007",     "A quantidade mxima de recursos de memria no paginada utilizada pelo servidor MacFile.",

    "1009",     "A quantidade atual dos recursos de memria no paginados utilizados pelo servidor MacFile.",

    "1011",     "O nmero de sesses conectadas ao servidor MacFile no momento. Indica a atividade do servidor no momento.",

    "1013",     "O nmero mximo de sesses conectadas de uma vez ao servidor MacFile. Indica o nvel de uso do servidor.",

    "1015",     "O nmero de arquivos internos abertos no momento no servidor MacFile. Essa contagem no inclui arquivos abertos em nome de clientes Macintosh.",

    "1017",     "O nmero mximo de arquivos internos abertos em determinado momento no servidor MacFile. Esse contador no inclui arquivos abertos em nome de clientes Macintosh.",

    "1019",     "O nmero de falhas em tentativas de logon no servidor MacFile. Pode indicar a utilizao de programas de deteco de senhas para violar a segurana no servidor.",

    "1021",     "O nmero de bytes lidos do disco por segundo.",

    "1023",     "O nmero de bytes gravados no disco por segundo.",

    "1025",     "O nmero de bytes recebidos da rede por segundo. Indica o grau de ocupao do servidor.",

    "1027",     "O nmero de bytes enviados na rede por segundo. Indica o grau de ocupao do servidor.",

    "1029",     "O nmero de itens de trabalho pendentes aguardando processamento.",

    "1031",     "O nmero mximo de itens de trabalho pendentes aguardando ao mesmo tempo.",

    "1033",     "O nmero atual de segmentos utilizados pelo servidor MacFile. Indica o grau de ocupao do servidor.",

    "1035",     "O nmero mximo de segmentos utilizados pelo servidor MacFile. Indica o nvel de uso mximo do servidor.",

    "1051",     "Protocolo AppleTalk",

    "1053",     "O nmero de pacotes recebidos por segundo pelo AppleTalk nesta porta.",

    "1055",     "O nmero de pacotes enviados por segundo pelo AppleTalk nesta porta.",

    "1057",     "O nmero de bytes recebidos por segundo pelo AppleTalk nesta porta.",

    "1059",     "O nmero de bytes enviados por segundo pelo AppleTalk nesta porta.",

    "1061",     "Tempo mdio em milissegundos para processar um pacote DDP nesta porta.",

    "1063",     "O nmero de pacotes DDP recebidos por segundo pelo AppleTalk nesta porta.",

    "1065",     "Tempo mdio em milissegundos para processar um pacote AARP nesta porta.",

    "1067",     "O nmero de pacotes AARP recebidos por segundo pelo AppleTalk nesta porta.",

    "1069",     "Tempo mdio em milissegundos para processar um pacote ATP nesta porta.",

    "1071",     "O nmero de pacotes ATP recebidos por segundo pelo AppleTalk nesta porta.",

    "1073",     "Tempo mdio em milissegundos para processar um pacote NBP nesta porta.",

    "1075",     "O nmero de pacotes NBP recebidos por segundo pelo AppleTalk nesta porta.",

    "1077",     "Tempo mdio em milissegundos para processar um pacote ZIP nesta porta.",

    "1079",     "O nmero de pacotes ZIP recebidos por segundo pelo AppleTalk nesta porta.",

    "1081",     "Tempo mdio em milissegundos para processar um pacote RTMP nesta porta.",

    "1083",     "O nmero de pacotes RTMP recebidos por segundo pelo AppleTalk nesta porta.",

    "1085",     "Nmero de solicitaes ATP retransmitidas nesta porta.",

    "1087",     "Nmero de timers de liberao ATP que expiraram nesta porta.",

    "1089",     "Nmero de respostas de transao 'ATP Exatamente uma' por segundo nesta porta.",

    "1091",     "Nmero de respostas de transao ATP Pelo menos uma  por segundo nesta porta.",

    "1093",     "O nmero de pacotes de liberao de transao ATP recebidos por segundo nesta porta.",

    "1095",     "A quantidade atual dos recursos de memria no-paginvel utilizados pelo servidor AppleTalk.",

    "1097",     "O nmero de pacotes de entrada roteados nesta porta.",

    "1099",     "Nmero de pacotes interrompidos devido a limitaes nesta porta.",

    "1101",     "Nmero de solicitaes ATP retransmitidas para esta porta.",

    "1103",     "O nmero de pacotes de sada roteados nesta porta.",

    "1111",     "Fornece estatstica de rede para o segmento de rede local por meio do servio de monitorao de rede.",

    "1113",     "O nmero total de quadros recebidos por segundo neste segmento de rede.",

    "1115",     "O nmero total de bytes recebidos por segundo neste segmento de rede.",

    "1117",     "O nmero total de quadros de difuso seletiva recebidos por segundo neste segmento de rede.",

    "1119",     "O nmero total de quadros de difuso ponto-a-ponto recebidos por segundo neste segmento de rede.",

    "1121",     "Porcentagem de largura de banda de rede em uso neste segmento de rede.",

    "1125",     "Percentual da largura de banda da rede, composto do trfego de difuso neste segmento da rede.",

    "1127",     "Percentual da largura de banda da rede, composto do trfego de difuso seletiva neste segmento da rede.",

    "1151",     "Sistema de telefonia",

    "1153",     "O nmero de linhas telefnicas atendidas por este computador.",

    "1155",     "O nmero de dispositivos telefnicos atendidos por este computador.",

    "1157",     "O nmero de linhas telefnicas atendidas por este computador que esto atualmente ativas.",

    "1159",     "O nmero de dispositivos telefnicos que esto sendo monitorados no momento.",

    "1161",     "A freqncia de chamadas de sada feitas por este computador.",

    "1163",     "A freqncia de chamadas de entrada respondidas por este computador.",

    "1165",     "O nmero de aplicativos que esto utilizando servios de telefonia no momento.",

    "1167",     "Chamadas de sada atuais sendo atendidas por este computador.",

    "1169",     "Chamadas de chamadas entrada atuais sendo atendidas por este computador.",

    "1229",     "O objeto de desempenho de servio gateway para NetWare consiste em contadores que medem o servio do servidor gateway.",

    "1231",     "O objeto de servio de cliente para NetWare consiste em contadores que medem as taxas de transmisso de pacotes, os logons e as conexes.",

    "1233",     "'Contagem NCP de leituras de pacotes rompidos/s'  a taxa de solicitaes de Protocolo NetWare de ncleo para leituras de pacotes rompidos. 'Pacotes rompidos'  um protocolo que aprimora o desempenho.",

    "1235",     "'Tempos limite de leitura de pacote rompidos/s'  a taxa  qual o servio NetWare precisa retransmitir uma solicitao de leitura de pacotes rompidos porque o servidor NetWare levou muito tempo para responder.",

    "1237",     "'Contagem NCP de gravao de pacotes rompidos/s'  a taxa de solicitaes de protocolo NetWare de ncleo para gravao de pacotes rompidos. 'Pacotes rompidos'  um protocolo que aprimora o desempenho.",

    "1239",     "'Tempos limite de gravao de pacote rompidos/s'  a taxa  qual o servio NetWare precisa retransmitir uma solicitao de gravao de pacote rompido porque o servidor NetWare levou muito tempo para responder.",

    "1241",     "E/S de pacotes rompidos/s'  a soma de 'NCPs de leitura de pacotes rompidos/s' mais 'NCPs de gravao de pacotes rompidos/s'.",

    "1243",     "Conectar conexes de conta NetWare 2.x para servidores NetWare 2.x.",

    "1245",     "Conectar conexes de conta NetWare 3.x para servidores NetWare 3.x.",

    "1247",     "Conectar conexes de conta NetWare 4.x para servidores NetWare 4.x.",

    "1261",     "'Total de logons' inclui todos os logons interativos, logons de rede, logons de servio, logons bem-sucedidos e logons com falhas desde a ltima reinicializao do computador.",

    "1301",     "O objeto de desempenho de filas de trabalho do servidor consiste em contadores que monitoram o comprimento das filas e dos objetos nas filas.",

    "1303",     "Comprimento de fila  o comprimento atual da fila de trabalho de servidor para esta CPU. Um comprimento de fila mantido superior a quatro indica congestionamento no processador. Essa  uma contagem instantnea, e no uma mdia temporal.",

    "1305",     "Segmentos ativos'  o nmero de segmentos funcionando atualmente em uma solicitao do cliente do servidor para esta CPU. O sistema mantm esse nmero o menor possvel para minimizar a troca de contexto desnecessria. Essa  uma contagem instantnea para a CPU, no  uma mdia temporal.",

    "1307",     "Segmentos disponveis'  o nmero de segmentos do servidor nesta CPU que no esto funcionando atualmente em solicitaes de um cliente. O servidor ajusta dinamicamente o nmero de segmentos para maximizar o desempenho do servidor.",

    "1309",     "Todas as solicitaes de um cliente so representadas no servidor como um 'item de trabalho' e o servidor mantm um pool de itens de trabalho disponveis por CPU para agilizar o processamento.  Esse  o nmero instantneo de itens de trabalho disponveis para esta CPU.  Um valor mantido prximo a zero indica a necessidade de aumentar o valor 'MinFreeWorkItems' do Registro para o servio 'Servidor'. Esse valor  sempre 0 na instncia de 'Blocking Queue'.",

    "1311",     "Todas as solicitaes de um cliente so representadas no servidor como um 'item de trabalho' e o servidor mantm um pool de itens de trabalho disponveis por CPU para agilizar o processamento.  Quando uma CPU fica sem itens de trabalho, pega emprestado um item de trabalho liberado de outra CPU.  Um valor maior deste contador pode indicar a necessidade de aumentar os valores 'MaxWorkItems' ou 'MinFreeWorkItems' do Registro para o servio 'Servidor'. Esse valor  sempre 0 na instncia de 'Blocking Queue'.",

    "1313",     "Todas as solicitaes de um cliente so representadas no servidor como um 'item de trabalho' e o servidor mantm um pool de itens de trabalho disponveis por CPU para agilizar o processamento.  Um valor mantido acima de zero indica a necessidade de aumentar o valor 'MaxWorkItems' do Registro para o servio 'Servidor'. Esse valor  sempre 0 na instncia de 'Blocking Queue'.",

    "1315",     "Clientes atuais'  a contagem instantnea dos clientes que esto sendo atendidos por esta CPU. O servidor equilibra ativamente a carga de clientes por todas as CPUs no sistema. Esse valor ser sempre 0 na instncia da fila de bloqueio.",

    "1317",     "A freqncia com a qual o servidor est recebendo bytes dos clientes de rede nesta CPU. Esse valor  uma medida do grau de ocupao do servidor.",

    "1319",     "A freqncia com a qual o servidor est enviando bytes aos clientes de rede nesta CPU. Esse valor  uma medida do grau de ocupao do servidor.",

    "1321",     "A freqncia com a qual o servidor est enviando e recebendo bytes dos clientes de rede nesta CPU. Esse valor  uma medida do grau de ocupao do servidor.",

    "1323",     "Operaes de leitura/s'  a taxa em que o servidor est realizando as operaes de leitura de arquivo para os clientes nesta CPU. Esse valor  uma medida da ocupao do servidor e ser sempre 0 na instncia da fila de bloqueio.",

    "1325",     "Bytes lidos/s'  a taxa em que o servidor est lendo os dados dos arquivos para os clientes nesta CPU. Esse valor  uma medida da ocupao do servidor.",

    "1327",     "Operaes de gravao/s'  a freqncia com a qual o servidor realiza operaes de gravao de arquivos para os clientes nesta CPU. Esse valor  uma medida do grau de ocupao do servidor. Esse valor ser sempre 0 na instncia 'Bloquear fila'.",

    "1329",     "Bytes gravados/s'  a freqncia com a qual o servidor grava dados em arquivos para os clientes nesta CPU. Esse valor  uma medida do grau de ocupao do servidor.",

    "1331",     "Total de bytes/s'  a freqncia com a qual o servidor l dados e grava dados nos arquivos para os clientes nesta CPU. Esse valor  uma medida do grau de ocupao do servidor.",

    "1333",     "Total de operaes/s'  a taxa de desempenho do servidor nas operaes de leitura e gravao de arquivos para os clientes nesta CPU. Esse valor  uma medida do grau de ocupao do servidor. Esse valor ser sempre 0 na instncia 'Bloquear fila'.",

    "1335",     "'DPCs enfileirados/s'  a taxa mdia, em incidentes por segundo, na qual as chamadas de procedimento deferidas (DPCs) foram adicionadas  fila de DPC do processador. As DPCs so interrupes que funcionam em uma prioridade mais baixa que as interrupes padro. Cada processador tem sua prpria fila de DPC. Esse contador mede a taxa em que os DPCs so adicionados  fila, no o nmero de DPCs na fila. Esse contador exibe a diferena entre os valores observados nas duas ltimas amostragens, dividida pela durao do intervalo de amostragem. ",

    "1337",     "'Taxa de DPC'  a taxa em que as DPCs (chamadas de procedimento deferidas) foram adicionadas s filas de DPC dos processadores entre os pulsos do timer do relgio do processador. DPCs so interrupes que funcionam em uma prioridade mais baixa que as interrupes padro. Cada processador tem sua prpria fila de DPC. Esse contador mede a taxa pela qual as DPCs foram adicionadas  fila, no o nmero de DPCs na fila. Esse contador exibe somente o ltimo valor observado, ele no  uma mdia.",

    "1343",     "'Total de DPCs enfileirados/s'  a freqncia combinada na qual chamadas de procedimento deferidas (DPCs) so adicionadas  fila DPC de todos os processadores no computador. (DPCs so interrupes executadas a uma prioridade inferior a das interrupes padro.) Cada processador tem sua prpria fila de DPC. Esse contador mede a freqncia com a qual DPCs so adicionadas  fila, e no o nmero de DPCs na fila. Ele  a soma de 'Processador: DPCs enfileiradas/s' de todos os processadores no computador, dividida pelo nmero de processadores. Esse contador exibe a diferena entre os valores observados nas duas ltimas amostragens dividida pela durao do intervalo de amostragem. ",

    "1345",     "'Taxa total de DPC'  a freqncia combinada na qual chamadas de procedimento deferidas (DPCs) so adicionadas s filas DPC de todos os processadores entre pulsos do timer do clock do sistema de cada processador. (DPCs so interrupes executadas a uma prioridade inferior a das interrupes padro.) Cada processador tem sua prpria fila de DPC. Esse contador mede a freqncia com a qual DPCs so adicionadas  fila, e no o nmero de DPCs na fila. Ele  a soma de 'Processador: taxa DPC' de todos os processadores no computador, dividida pelo nmero de processadores. Esse contador exibe apenas o ltimo valor observado; no se trata de uma mdia. ",

    "1351",     "'% quota do Registro em uso'  o percentual da cota de Registro total permitida usado atualmente pelo sistema. Esse contador s exibe o valor percentual atual, no  uma mdia. ",

    "1361",     "Contadores que indicam o status de alocaes de memria muito grandes locais e do sistema.",

    "1363",     "Tamanho virtual VLM % em uso",

    "1365",     "Tamanho atual do espao virtual de memria VLM de processo em bytes.",

    "1367",     "O tamanho mximo, em bytes, do espao de memria virtual VLM do processo. Esse valor indica o tamanho mximo da memria virtual VLM do processo desde o incio do mesmo.",

    "1369",     "O tamanho atual, em bytes, do espao de memria virtual VLM do processo que pode ser alocado. Observe que a alocao mxima permitida pode ser inferior a este valor devido  fragmentao do espao de memria.",

    "1371",     "O tamanho atual, em bytes, do espao de memria VLM confirmado relativo ao processo atual.",

    "1373",     "O tamanho mximo, em bytes, do espao de memria VLM confirmada relativa ao processo atual desde o incio do mesmo.",

    "1375",     "O tamanho atual, em bytes, de todo o espao de memria VLM compartilhado confirmado relativo ao sistema.",

    "1377",     "O tamanho mximo, em bytes, de todo o espao de memria VLM compartilhado confirmado desde que o sistema foi iniciado.",

    "1379",     "O tamanho atual, em bytes, de todo o espao de memria VLM compartilhado confirmado relativo ao sistema.",

    "1381",     "'KBytes disponveis'  a quantidade de memria fsica, em Kilobytes, imediatamente disponvel para alocao para um processo ou para uso pelo sistema. Ela  igual  soma da memria designada para as listas em espera (armazenada em cache), livre e de zero pgina. Para obter uma explicao completa sobre o gerenciador de memria, consulte a MSDN e/ou o captulo 'System Performance and Troubleshooting Guide' no Windows Server 2003 Resource Kit.",

    "1383",     "'MBytes disponveis'  a quantidade de memria fsica, em Megabytes, imediatamente disponvel para alocao para um processo ou para uso pelo sistema. Ela  igual  soma da memria designada para as listas em espera (armazenada em cache), livre e de zero pgina. Para obter uma explicao completa sobre o gerenciador de memria, consulte a MSDN e/ou o captulo 'System Performance and Troubleshooting Guide' no Windows Server 2003 Resource Kit.",

    "1401",     "'Comprimento mdio da fila de disco de disco'  o nmero mdio de solicitaes de gravao enfileiradas para o disco selecionado durante o intervalo de amostragem.",

    "1403",     "'Comprimento mdio da fila de leitura de disco'  o nmero mdio de solicitaes de gravao enfileiradas para o disco selecionado durante o intervalo de amostragem.",

    "1405",     "Comprimento mdio da fila de gravao de disco'  o nmero mdio de solicitaes de gravao enfileiradas para o disco selecionado durante o intervalo de exemplo.",

    "1407",     "'% bytes confirmados em uso'  a taxa de 'Memria\\Bytes confirmados' para a 'Memria\\Limite de confirmao'. A memria confirmada  a memria fsica em uso para a qual o espao reservado no arquivo de paginao deve ser gravado em disco. O limite de confirmao  determinado pelo tamanho do arquivo de paginao. Se o arquivo de paginao  ampliado, o limite de confirmao aumenta e a taxa  reduzida. Este contador exibe somente o valor percentual atual, no  uma mdia.",

    "1409",     "O objeto de desempenho de imagem inteira consiste em contadores que monitoram o uso do endereo virtual de imagens executadas por processos no computador. Os contadores de imagem inteira so os mesmo contadores contidos no objeto de imagem, exceto pelo nome da instncia. No objeto de imagem inteira, o nome da instncia inclui o caminho completo dos arquivos dos mdulos carregados, enquanto no objeto de imagem, s o nome do arquivo  exibido.",

    "1411",     "O valor de 'Identificao de processo de criao'  a 'Identificao do processo' que criou o processo. O processo de criao pode ter sido finalizado e, portanto, este valor pode no mais identificar um processo em andamento.",

    "1413",     "A freqncia com a qual o processo est gerando operaes de E/S de leitura. Esse contador considera toda a atividade de E/S gerada pelo processo, incluindo E/Ss de arquivo, rede e dispositivo.",

    "1415",     "A freqncia com a qual o processo est gerando operaes de E/S de gravao. Esse contador considera toda a atividade de E/S gerada pelo processo, incluindo E/Ss de arquivo, rede e dispositivo.",

    "1417",     "A freqncia com a qual o processo est gerando operaes de E/S de leitura e gravao. Esse contador considera toda a atividade de E/S gerada pelo processo, incluindo E/Ss de arquivo, rede e dispositivo.",

    "1419",     "A freqncia com a qual o processo est gerando operaes de E/S que no sejam nem operaes de leitura nem de gravao (por exemplo, uma funo de controle). Esse contador considera toda a atividade de E/S gerada pelo processo, incluindo E/Ss de arquivo, rede e dispositivo.",

    "1421",     "A taxa  qual o processo est lendo bytes de operaes de E/S. Este contador conta toda a atividade de E/S gerada pelo processo, inclusive E/S de arquivo, rede e dispositivo.",

    "1423",     "A taxa  qual o processo est gravando bytes para operaes de E/S. Este contador toda a atividade de E/S gerada pelo processo, inclusive E/S de arquivo, rede e dispositivo.",

    "1425",     "A freqncia com a qual o processo est lendo e gravando bytes em operaes de E/S. Esse contador considera toda a atividade de E/S gerada pelo processo, incluindo E/Ss de arquivo, rede e dispositivo.",

    "1427",     "A freqncia com a qual o processo est gerando bytes para operaes de E/S que no envolvem dados, como operaes de controle. Esse contador considera toda a atividade de E/S gerada pelo processo, incluindo E/S de arquivo, rede e dispositivo.",

    "1451",     "Exibe estatsticas de desempenho sobre a fila de impresso.",

    "1453",     "Nmero total de trabalhos impressos em uma fila de impresso desde a ltima reinicializao.",

    "1455",     "O nmero de bytes por segundo impressos em uma fila de impresso.",

    "1457",     "Nmero total de pginas impressas atravs de GDI em uma fila de impresso desde a ltima inicializao.",

    "1459",     "Nmero atual de trabalhos em uma fila de impresso.",

    "1461",     "Nmero atual de referncias (conexes ativas) a esta impressora.",

    "1463",     "Nmero mximo de referncias (conexes ativas) a esta impressora.",

    "1465",     "Nmero atual de trabalhos de spool em uma fila de impresso.",

    "1467",     "Nmero mximo de trabalhos de spool em uma fila de impresso desde a ltima reinicializao.",

    "1469",     "Nmero total de erros de falta de papel na fila de impresso desde a ltima reinicializao.",

    "1471",     "Nmero total de erros de impressora no pronta em uma fila de impresso desde a ltima inicializao.",

    "1473",     "Nmero total de erros de trabalho na fila de impresso desde a ltima reinicializao.",

    "1475",     "Nmero total de chamadas de clientes de pesquisa a este servidor de impresso para solicitar listas de pesquisa na rede desde a ltima reinicializao.",

    "1477",     "Nmero total de chamadas de outros servidores de impresso para adicionar impressoras de rede compartilhadas a este servidor desde a ltima reinicializao.",

    "1479",     "'Conjunto de trabalho - particular' exibe o tamanho, em bytes, do conjunto de trabalho que  utilizado somente para este processo e no  nem pode ser compartilhado por outros processos.",

    "1481",     "'Conjunto de trabalho - compartilhado' exibe o tamanho, em bytes, do conjunto de trabalho que pode ser compartilhado e usado por outros processos. Embora parte do conjunto de trabalho de um processo possa ser compartilhada, isso no significa necessariamente que outros processos a estejam utilizando.",

    "1483",     "'% tempo ocioso' relata a porcentagem de tempo durante o intervalo de amostragem em que o disco estava ocioso.",

    "1485",     "A E/S dividida por segundo informa a freqncia com a qual as E/Ss para o disco foram divididas em vrias E/Ss. Uma E/S dividida pode resultar de uma solicitao de dados que sejam muito grandes para caber em uma nica E/S ou de um disco fragmentado.",

    "1501",     "Informa os dados estatsticos e de uso do processador coletados por cada objeto de trabalho nomeado ativo.",

    "1503",     "'% de tempo atual de processador' mostra a porcentagem do intervalo de amostragem em que os processos no objeto trabalho executaram cdigo.",

    "1505",     "'% de tempo atual de modo de usurio' mostra o percentual do intervalo de amostragem que os processos no objeto de trabalho gastam executando o cdigo no modo de usurio.",

    "1507",     "'% de tempo atual de modo de ncleo' mostra o percentual do intervalo de exemplo que os processos no objeto de trabalho gastam executando o cdigo no modo kernel ou privilegiado.",

    "1509",     "'Este perodo mSec - processador' mostra o tempo, em milissegundos, do tempo do processador usado por todos os processos no objeto de trabalho, inclusive os j finalizados ou no mais associados ao objeto de trabalho, desde quando foi estabelecido um limite de tempo para o trabalho.",

    "1511",     "'Este perodo mSec - modo de usurio' mostra o tempo, em milissegundos, do tempo do processador no modo de usurio usado por todos os processos no objeto de trabalho, inclusive os j finalizados ou no mais associados ao objeto de trabalho, desde quando foi estabelecido um limite de tempo para o trabalho.",

    "1513",     "'Este perodo mSec - modo de ncleo' mostra o tempo, em milissegundos, do tempo do processador no modo de ncleo usado por todos os processos no objeto de trabalho, inclusive os j finalizados ou no mais associados ao objeto de trabalho, desde quando foi estabelecido um limite de tempo para o trabalho.",

    "1515",     "'Pginas/s' mostra a taxa de falhas de pginas de todos os processos no objeto de trabalho.",

    "1517",     "'Contagem de processo - total: mostra o nmero de processos, ativos e finalizados, associados ao objeto de trabalho.",

    "1519",     "'Contagem de processo - ativa': mostra o nmero de processos associados atualmente com o objeto de trabalho.",

    "1521",     "'Contagem de processo - finalizada': mostra o nmero de processos finalizados devido  violao de limite.",

    "1523",     "'Total de mSec - processador' mostra, em milissegundos, o tempo do processador utilizado por todos os processos no objeto de trabalho, inclusive os j finalizados ou no mais associados ao objeto de trabalho, desde a criao do objeto de trabalho.",

    "1525",     "'Total ms - modo de usurio' mostra, em milissegundos, o tempo do processador no modo de usurio utilizado por todos os processos no objeto de trabalho, inclusive os j finalizados ou no mais associados ao objeto de trabalho, desde a criao do objeto de trabalho.",

    "1527",     "'Total ms - modo de ncleo' mostra, em milissegundos, o tempo do processador no modo de ncleo utilizado por todos os processos no objeto de trabalho, inclusive os j finalizados ou no mais associados ao objeto de trabalho, desde a criao do objeto de trabalho.",

    "1549",     "'% de detalhes sobre o objeto de trabalho' mostra as informaes de desempenho detalhadas sobre os processos ativos que compem um objeto de trabalho.",

    "1537",     "'Pacote recebido grande demais'  o nmero de pacotes recebidos que so maiores do que o esperado.",

    "1539",     "'Consulta de participao recebida'  o nmero de pacotes recebidos que fazem uma consulta sobre sua participao em grupos.",

    "1541",     "'Relatrio de participao recebido'  o nmero de pacotes recebidos que fazem um relatrio sobre sua participao em grupos.",

    "1543",     "'Reduo de participao recebida'  o nmero de pacotes recebidos que cancelaram sua participao em grupos.",

    "1545",     "'Solicitao de roteador recebida'  o nmero de pacotes recebidos que solicitam o roteador.",

    "1547",     "'Anncio de roteador recebido'  o nmero de pacotes recebidos que anunciam o roteador.",

    "1551",     "'Solicitao de vizinho recebida'  o nmero de pacotes recebidos que solicitam um vizinho.",

    "1553",     "'Anncio de vizinho recebido'  o nmero de pacotes recebidos que anunciam um vizinho.",

    "1555",     "'Pacote enviado grande demais'  o nmero de pacotes enviados que so maiores do que o esperado.",

    "1557",     "'Consulta de participao enviada'  o nmero de pacotes enviados que fazem uma consulta sobre sua participao em grupos.",

    "1559",     "'Relatrio de participao enviado'  o nmero de pacotes enviados que fazem um relatrio sobre sua participao em grupos.",

    "1561",     "'Reduo de participao enviada'  o nmero de pacotes enviados que cancelaram sua participao em grupos.",

    "1563",     "'Solicitao de roteador enviada'  o nmero de pacotes enviados que solicitam o roteador.",

    "1565",     "'Anncio de roteador enviado'  o nmero de pacotes enviados que anunciam o roteador.",

    "1567",     "'Solicitao de vizinho enviada'  o nmero de pacotes enviados que solicitam um vizinho.",

    "1569",     "'Anncio de vizinho enviado'  o nmero de pacotes enviados que anunciam um vizinho.",

    "1747",     "'% tempo ocioso'  a porcentagem de tempo em que o processador est ocioso durante o intervalo de amostragem",

    "1749",     "% C1 Time  a porcentagem de tempo que o processador passa no estado ocioso C1 de baixa energia. % C1 Time  um subconjunto do tempo ocioso total do processador. O estado ocioso C1 de baixa energia permite que o processador mantenha todo o seu contexto e retorne rapidamente ao estado de execuo. Nem todos os sistemas do suporte ao estado C1 %.",

    "1751",     "% C2 Time  a porcentagem de tempo que o processador passa no estado ocioso C2 de baixa energia. % C2 Time  um subconjunto do tempo ocioso total do processador. O estado ocioso C2 de baixa energia permite que o processador mantenha o contexto de caches do sistema. O estado ocioso C2 de baixa energia  um estado de baixa energia e latncia de sada mais elevada do que o estado C1. Nem todos os sistemas do suporte ao estado C2.",

    "1753",     "'% tempo C3'  a porcentagem de tempo em que o processador est no estado ocioso de baixa energia C3. '% tempo C3'  um subconjunto do tempo ocioso total de processador. Quando o processador est no estado ocioso de baixa energia C3, no  possvel manter a coerncia das caches. O estado de energia C3  um estado de energia mais baixa e latncia de sada mais alta do que C2. Nem todos os sistemas do suporte ao estado C3.",

    "1755",     "'Transies C1/s'  a taxa  qual a CPU entra no estado ocioso de baixa energia C1. A CPU entra no estado C1 quando est suficientemente ociosoa, e sai desse estado ao ocorrer qualquer interrupo. Este contador exibe a diferena entre os valores observados nas duas ltimas amostragens, dividida pela durao do intervalo de amostragem.",

    "1757",     "'Transies C2/s'  a taxa  qual a CPU entra no estado ocioso de baixa energia C2. A CPU entra no estado C2 quando est suficientemente ociosa, e sai desse estado ao ocorrer em qualquer interrupo. Este contador exibe a diferena entre os valores observados nas duas ltimas amostragens, dividida pela durao do intervalo de amostragem.",

    "1759",     "'Transies C3/s'  a taxa  qual a CPU entra no estado ocioso de baixa energia C3. A CPU entra no estado C3 quando est suficientemente ociosa, e sai desse estado ao ocorrer qualquer interrupo. Este contador exibe a diferena entre os valores observados nas duas ltimas amostragens, dividida pela durao do intervalo de amostragem.",

    "1761",     "Contadores para desempenho de pilha para os quais devem ser usadas pilhas",

    "1763",     "Memria ativamente usada por esta pilha (FreeBytes + AllocatedBytes)",

    "1765",     "Total do espao de endereo virtual reservado a esta pilha (inclui intervalos no confirmados)",

    "1767",     "ReservedBytes menos ltimo intervalo no-confirmado em cada segmento",

    "1769",     "Memria nas listas livres nessa pilha (no inclui intervalos ou blocos no confirmados no cache da pilha)",

    "1771",     "Nmero de blocos na lista de blocos livres com mais de 1k",

    "1773",     "1/Tempo mdio por alocao (excluindo alocaes de cache de pilha)",

    "1775",     "1/Tempo mdio por liberao (excluindo liberaes para cache de pilha)",

    "1777",     "Nmero de intervalos no confirmados no endereo virtual reservado",

    "1779",     "Diferena entre nmero de alocaes e liberaes (para deteco de vazamentos)",

    "1781",     "Alocaes/s de cache de pilha",

    "1783",     "Liberaes/s do cache da pilha",

    "1785",     "Alocaes/s de tamanho <1k bytes (inclusive cache de pilha)",

    "1787",     "Frees/s de tamanho <1k bytes (inclusive cache de pilha)",

    "1789",     "Alocaes/s de tamanho igual a 1-8k bytes",

    "1791",     "Liberaes/s de tamanho de 1-8k bytes",

    "1793",     "Alocaes/s de tamanho acima de 8k bytes ",

    "1795",     "Liberaes/s de tamanho superior a 8k bytes",

    "1797",     "Alocaes/s (inclusive de cache de pilha)",

    "1799",     "Liberaes/s (inclusive para cache de pilha)",

    "1801",     "Nmero total de blocos no cache da pilha ",

    "1803",     "Maior nmero de blocos de qualquer tamanho no cache da pilha",

    "1805",     "(FreeBytes / CommittedBytes) *100",

    "1807",     "(VirtualBytes / ReservedBytes) * 100",

    "1809",     "Colises/s no bloqueio de pilha",

    "1847",     "Marcador de fim",
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\chs\prfc0804.ini ===
"1",     "1847",

    "2",     "System",

    "4",     "Memory",

    "6",     "% Processor Time",

    "10",     "File Read Operations/sec",

    "12",     "File Write Operations/sec",

    "14",     "File Control Operations/sec",

    "16",     "File Read Bytes/sec",

    "18",     "File Write Bytes/sec",

    "20",     "File Control Bytes/sec",

    "24",     "Available Bytes",

    "26",     "Committed Bytes",

    "28",     "Page Faults/sec",

    "30",     "Commit Limit",

    "32",     "Write Copies/sec",

    "34",     "Transition Faults/sec",

    "36",     "Cache Faults/sec",

    "38",     "Demand Zero Faults/sec",

    "40",     "Pages/sec",

    "42",     "Page Reads/sec",

    "44",     "Processor Queue Length",

    "46",     "Thread State",

    "48",     "Pages Output/sec",

    "50",     "Page Writes/sec",

    "52",     "Browser",

    "54",     "Announcements Server/sec",

    "56",     "Pool Paged Bytes",

    "58",     "Pool Nonpaged Bytes",

    "60",     "Pool Paged Allocs",

    "64",     "Pool Nonpaged Allocs",

    "66",     "Pool Paged Resident Bytes",

    "68",     "System Code Total Bytes",

    "70",     "System Code Resident Bytes",

    "72",     "System Driver Total Bytes",

    "74",     "System Driver Resident Bytes",

    "76",     "System Cache Resident Bytes",

    "78",     "Announcements Domain/sec",

    "80",     "Election Packets/sec",

    "82",     "Mailslot Writes/sec",

    "84",     "Server List Requests/sec",

    "86",     "Cache",

    "88",     "Data Maps/sec",

    "90",     "Sync Data Maps/sec",

    "92",     "Async Data Maps/sec",

    "94",     "Data Map Hits %",

    "96",     "Data Map Pins/sec",

    "98",     "Pin Reads/sec",

    "100",     "Sync Pin Reads/sec",

    "102",     "Async Pin Reads/sec",

    "104",     "Pin Read Hits %",

    "106",     "Copy Reads/sec",

    "108",     "Sync Copy Reads/sec",

    "110",     "Async Copy Reads/sec",

    "112",     "Copy Read Hits %",

    "114",     "MDL Reads/sec",

    "116",     "Sync MDL Reads/sec",

    "118",     "Async MDL Reads/sec",

    "120",     "MDL Read Hits %",

    "122",     "Read Aheads/sec",

    "124",     "Fast Reads/sec",

    "126",     "Sync Fast Reads/sec",

    "128",     "Async Fast Reads/sec",

    "130",     "Fast Read Resource Misses/sec",

    "132",     "Fast Read Not Possibles/sec",

    "134",     "Lazy Write Flushes/sec",

    "136",     "Lazy Write Pages/sec",

    "138",     "Data Flushes/sec",

    "140",     "Data Flush Pages/sec",

    "142",     "% User Time",

    "144",     "% Privileged Time",

    "146",     "Context Switches/sec",

    "148",     "Interrupts/sec",

    "150",     "System Calls/sec",

    "152",     "Level 1 TLB Fills/sec",

    "154",     "Level 2 TLB Fills/sec",

    "156",     "Enumerations Server/sec",

    "158",     "Enumerations Domain/sec",

    "160",     "Enumerations Other/sec",

    "162",     "Missed Server Announcements",

    "164",     "Missed Mailslot Datagrams",

    "166",     "Missed Server List Requests",

    "168",     "Server Announce Allocations Failed/sec",

    "170",     "Mailslot Allocations Failed",

    "172",     "Virtual Bytes Peak",

    "174",     "Virtual Bytes",

    "178",     "Working Set Peak",

    "180",     "Working Set",

    "182",     "Page File Bytes Peak",

    "184",     "Page File Bytes",

    "186",     "Private Bytes",

    "188",     "Announcements Total/sec",

    "190",     "Enumerations Total/sec",

    "198",     "Current Disk Queue Length",

    "200",     "% Disk Time",

    "202",     "% Disk Read Time",

    "204",     "% Disk Write Time",

    "206",     "Avg. Disk sec/Transfer",

    "208",     "Avg. Disk sec/Read",

    "210",     "Avg. Disk sec/Write",

    "212",     "Disk Transfers/sec",

    "214",     "Disk Reads/sec",

    "216",     "Disk Writes/sec",

    "218",     "Disk Bytes/sec",

    "220",     "Disk Read Bytes/sec",

    "222",     "Disk Write Bytes/sec",

    "224",     "Avg. Disk Bytes/Transfer",

    "226",     "Avg. Disk Bytes/Read",

    "228",     "Avg. Disk Bytes/Write",

    "230",     "Process",

    "232",     "Thread",

    "234",     "PhysicalDisk",

    "236",     "LogicalDisk",

    "238",     "Processor",

    "240",     "% Total Processor Time",

    "242",     "% Total User Time",

    "244",     "% Total Privileged Time",

    "246",     "Total Interrupts/sec",

    "248",     "Processes",

    "250",     "Threads",

    "252",     "Events",

    "254",     "Semaphores",

    "256",     "Mutexes",

    "258",     "Sections",

    "260",     "Objects",

    "262",     "Redirector",

    "264",     "Bytes Received/sec",

    "266",     "Packets Received/sec",

    "268",     "Read Bytes Paging/sec",

    "270",     "Read Bytes Non-Paging/sec",

    "272",     "Read Bytes Cache/sec",

    "274",     "Read Bytes Network/sec",

    "276",     "Bytes Transmitted/sec",

    "278",     "Packets Transmitted/sec",

    "280",     "Write Bytes Paging/sec",

    "282",     "Write Bytes Non-Paging/sec",

    "284",     "Write Bytes Cache/sec",

    "286",     "Write Bytes Network/sec",

    "288",     "Read Operations/sec",

    "290",     "Read Operations Random/sec",

    "292",     "Read Packets/sec",

    "294",     "Reads Large/sec",

    "296",     "Read Packets Small/sec",

    "298",     "Write Operations/sec",

    "300",     "Write Operations Random/sec",

    "302",     "Write Packets/sec",

    "304",     "Writes Large/sec",

    "306",     "Write Packets Small/sec",

    "308",     "Reads Denied/sec",

    "310",     "Writes Denied/sec",

    "312",     "Network Errors/sec",

    "314",     "Server Sessions",

    "316",     "Server Reconnects",

    "318",     "Connects Core",

    "320",     "Connects Lan Manager 2.0",

    "322",     "Connects Lan Manager 2.1",

    "324",     "Connects Windows NT",

    "326",     "Server Disconnects",

    "328",     "Server Sessions Hung",

    "330",     "Server",

    "336",     "Thread Wait Reason",

    "340",     "Sessions Timed Out",

    "342",     "Sessions Errored Out",

    "344",     "Sessions Logged Off",

    "346",     "Sessions Forced Off",

    "348",     "Errors Logon",

    "350",     "Errors Access Permissions",

    "352",     "Errors Granted Access",

    "354",     "Errors System",

    "356",     "Blocking Requests Rejected",

    "358",     "Work Item Shortages",

    "360",     "Files Opened Total",

    "362",     "Files Open",

    "366",     "File Directory Searches",

    "370",     "Pool Nonpaged Failures",

    "372",     "Pool Nonpaged Peak",

    "376",     "Pool Paged Failures",

    "378",     "Pool Paged Peak",

    "388",     "Bytes Total/sec",

    "392",     "Current Commands",

    "398",     "NWLink NetBIOS",

    "400",     "Packets/sec",

    "404",     "Context Blocks Queued/sec",

    "406",     "File Data Operations/sec",

    "408",     "% Free Space",

    "410",     "Free Megabytes",

    "412",     "Connections Open",

    "414",     "Connections No Retries",

    "416",     "Connections With Retries",

    "418",     "Disconnects Local",

    "420",     "Disconnects Remote",

    "422",     "Failures Link",

    "424",     "Failures Adapter",

    "426",     "Connection Session Timeouts",

    "428",     "Connections Canceled",

    "430",     "Failures Resource Remote",

    "432",     "Failures Resource Local",

    "434",     "Failures Not Found",

    "436",     "Failures No Listen",

    "438",     "Datagrams/sec",

    "440",     "Datagram Bytes/sec",

    "442",     "Datagrams Sent/sec",

    "444",     "Datagram Bytes Sent/sec",

    "446",     "Datagrams Received/sec",

    "448",     "Datagram Bytes Received/sec",

    "452",     "Packets Sent/sec",

    "456",     "Frames/sec",

    "458",     "Frame Bytes/sec",

    "460",     "Frames Sent/sec",

    "462",     "Frame Bytes Sent/sec",

    "464",     "Frames Received/sec",

    "466",     "Frame Bytes Received/sec",

    "468",     "Frames Re-Sent/sec",

    "470",     "Frame Bytes Re-Sent/sec",

    "472",     "Frames Rejected/sec",

    "474",     "Frame Bytes Rejected/sec",

    "476",     "Expirations Response",

    "478",     "Expirations Ack",

    "480",     "Window Send Maximum",

    "482",     "Window Send Average",

    "484",     "Piggyback Ack Queued/sec",

    "486",     "Piggyback Ack Timeouts",

    "488",     "NWLink IPX",

    "490",     "NWLink SPX",

    "492",     "NetBEUI",

    "494",     "NetBEUI Resource",

    "496",     "Used Maximum",

    "498",     "Used Average",

    "500",     "Times Exhausted",

    "502",     "NBT Connection",

    "506",     "Bytes Sent/sec",

    "508",     "Total Bytes/sec",

    "510",     "Network Interface",

    "512",     "Bytes/sec",

    "520",     "Current Bandwidth",

    "524",     "Packets Received Unicast/sec",

    "526",     "Packets Received Non-Unicast/sec",

    "528",     "Packets Received Discarded",

    "530",     "Packets Received Errors",

    "532",     "Packets Received Unknown",

    "536",     "Packets Sent Unicast/sec",

    "538",     "Packets Sent Non-Unicast/sec",

    "540",     "Packets Outbound Discarded",

    "542",     "Packets Outbound Errors",

    "544",     "Output Queue Length",

    "546",     "IPv4",

    "548",     "IPv6",

    "552",     "Datagrams Received Header Errors",

    "554",     "Datagrams Received Address Errors",

    "556",     "Datagrams Forwarded/sec",

    "558",     "Datagrams Received Unknown Protocol",

    "560",     "Datagrams Received Discarded",

    "562",     "Datagrams Received Delivered/sec",

    "566",     "Datagrams Outbound Discarded",

    "568",     "Datagrams Outbound No Route",

    "570",     "Fragments Received/sec",

    "572",     "Fragments Re-assembled/sec",

    "574",     "Fragment Re-assembly Failures",

    "576",     "Fragmented Datagrams/sec",

    "578",     "Fragmentation Failures",

    "580",     "Fragments Created/sec",

    "582",     "ICMP",

    "584",     "Messages/sec",

    "586",     "Messages Received/sec",

    "588",     "Messages Received Errors",

    "590",     "Received Dest. Unreachable",

    "592",     "Received Time Exceeded",

    "594",     "Received Parameter Problem",

    "596",     "Received Source Quench",

    "598",     "Received Redirect/sec",

    "600",     "Received Echo/sec",

    "602",     "Received Echo Reply/sec",

    "604",     "Received Timestamp/sec",

    "606",     "Received Timestamp Reply/sec",

    "608",     "Received Address Mask",

    "610",     "Received Address Mask Reply",

    "612",     "Messages Sent/sec",

    "614",     "Messages Outbound Errors",

    "616",     "Sent Destination Unreachable",

    "618",     "Sent Time Exceeded",

    "620",     "Sent Parameter Problem",

    "622",     "Sent Source Quench",

    "624",     "Sent Redirect/sec",

    "626",     "Sent Echo/sec",

    "628",     "Sent Echo Reply/sec",

    "630",     "Sent Timestamp/sec",

    "632",     "Sent Timestamp Reply/sec",

    "634",     "Sent Address Mask",

    "636",     "Sent Address Mask Reply",

    "638",     "TCPv4",

    "640",     "Segments/sec",

    "642",     "Connections Established",

    "644",     "Connections Active",

    "646",     "Connections Passive",

    "648",     "Connection Failures",

    "650",     "Connections Reset",

    "652",     "Segments Received/sec",

    "654",     "Segments Sent/sec",

    "656",     "Segments Retransmitted/sec",

    "658",     "UDPv4",

    "660",     "% Total DPC Time",

    "662",     "% Total Interrupt Time",

    "664",     "Datagrams No Port/sec",

    "666",     "Datagrams Received Errors",

    "670",     "Disk Storage Unit",

    "672",     "Allocation Failures",

    "674",     "System Up Time",

    "676",     "System Handle Count",

    "678",     "Free System Page Table Entries",

    "680",     "Thread Count",

    "682",     "Priority Base",

    "684",     "Elapsed Time",

    "686",     "Alignment Fixups/sec",

    "688",     "Exception Dispatches/sec",

    "690",     "Floating Emulations/sec",

    "692",     "Logon/sec",

    "694",     "Priority Current",

    "696",     "% DPC Time",

    "698",     "% Interrupt Time",

    "700",     "Paging File",

    "702",     "% Usage",

    "704",     "% Usage Peak",

    "706",     "Start Address",

    "708",     "User PC",

    "710",     "Mapped Space No Access",

    "712",     "Mapped Space Read Only",

    "714",     "Mapped Space Read/Write",

    "716",     "Mapped Space Write Copy",

    "718",     "Mapped Space Executable",

    "720",     "Mapped Space Exec Read Only",

    "722",     "Mapped Space Exec Read/Write",

    "724",     "Mapped Space Exec Write Copy",

    "726",     "Reserved Space No Access",

    "728",     "Reserved Space Read Only",

    "730",     "Reserved Space Read/Write",

    "732",     "Reserved Space Write Copy",

    "734",     "Reserved Space Executable",

    "736",     "Reserved Space Exec Read Only",

    "738",     "Reserved Space Exec Read/Write",

    "740",     "Image",

    "742",     "Reserved Space Exec Write Copy",

    "744",     "Unassigned Space No Access",

    "746",     "Unassigned Space Read Only",

    "748",     "Unassigned Space Read/Write",

    "750",     "Unassigned Space Write Copy",

    "752",     "Unassigned Space Executable",

    "754",     "Unassigned Space Exec Read Only",

    "756",     "Unassigned Space Exec Read/Write",

    "758",     "Unassigned Space Exec Write Copy",

    "760",     "Image Space No Access",

    "762",     "Image Space Read Only",

    "764",     "Image Space Read/Write",

    "766",     "Image Space Write Copy",

    "768",     "Image Space Executable",

    "770",     "Image Space Exec Read Only",

    "772",     "Image Space Exec Read/Write",

    "774",     "Image Space Exec Write Copy",

    "776",     "Bytes Image Reserved",

    "778",     "Bytes Image Free",

    "780",     "Bytes Reserved",

    "782",     "Bytes Free",

    "784",     "ID Process",

    "786",     "Process Address Space",

    "788",     "No Access",

    "790",     "Read Only",

    "792",     "Read/Write",

    "794",     "Write Copy",

    "796",     "Executable",

    "798",     "Exec Read Only",

    "800",     "Exec Read/Write",

    "802",     "Exec Write Copy",

    "804",     "ID Thread",

    "806",     "Mailslot Receives Failed",

    "808",     "Mailslot Writes Failed",

    "810",     "Mailslot Opens Failed/sec",

    "812",     "Duplicate Master Announcements",

    "814",     "Illegal Datagrams/sec",

    "816",     "Thread Details",

    "818",     "Cache Bytes",

    "820",     "Cache Bytes Peak",

    "822",     "Pages Input/sec",

    "824",     "Transition Pages RePurposed/sec",

    "870",     "RAS Port",

    "872",     "Bytes Transmitted",

    "874",     "Bytes Received",

    "876",     "Frames Transmitted",

    "878",     "Frames Received.",

    "880",     "Percent Compression Out",

    "882",     "Percent Compression In",

    "884",     "CRC Errors",

    "886",     "Timeout Errors",

    "888",     "Serial Overrun Errors",

    "890",     "Alignment Errors",

    "892",     "Buffer Overrun Errors",

    "894",     "Total Errors",

    "896",     "Bytes Transmitted/Sec",

    "898",     "Bytes Received/Sec",

    "900",     "Frames Transmitted/Sec",

    "902",     "Frames Received/Sec",

    "904",     "Total Errors/Sec",

    "906",     "RAS Total",

    "908",     "Total Connections",

    "920",     "WINS Server",

    "922",     "Unique Registrations/sec",

    "924",     "Group Registrations/sec",

    "926",     "Total Number of Registrations/sec",

    "928",     "Unique Renewals/sec",

    "930",     "Group Renewals/sec",

    "932",     "Total Number of Renewals/sec",

    "934",     "Releases/sec",

    "936",     "Queries/sec",

    "938",     "Unique Conflicts/sec",

    "940",     "Group Conflicts/sec",

    "942",     "Total Number of Conflicts/sec",

    "944",     "Successful Releases/sec",

    "946",     "Failed Releases/sec",

    "948",     "Successful Queries/sec",

    "950",     "Failed Queries/sec",

    "952",     "Handle Count",

    "1000",     "MacFile Server",

    "1002",     "Max Paged Memory",

    "1004",     "Current Paged Memory",

    "1006",     "Max NonPaged Memory",

    "1008",     "Current NonPaged memory",

    "1010",     "Current Sessions",

    "1012",     "Maximum Sessions",

    "1014",     "Current Files Open",

    "1016",     "Maximum Files Open",

    "1018",     "Failed Logons",

    "1020",     "Data Read/sec",

    "1022",     "Data Written/sec",

    "1024",     "Data Received/sec",

    "1026",     "Data Transmitted/sec",

    "1028",     "Current Queue Length",

    "1030",     "Maximum Queue Length",

    "1032",     "Current Threads",

    "1034",     "Maximum Threads",

    "1050",     "AppleTalk",

    "1052",     "Packets In/sec",

    "1054",     "Packets Out/sec",

    "1056",     "Bytes In/sec",

    "1058",     "Bytes Out/sec",

    "1060",     "Average Time/DDP Packet",

    "1062",     "DDP Packets/sec",

    "1064",     "Average Time/AARP Packet",

    "1066",     "AARP Packets/sec",

    "1068",     "Average Time/ATP Packet",

    "1070",     "ATP Packets/sec",

    "1072",     "Average Time/NBP Packet",

    "1074",     "NBP Packets/sec",

    "1076",     "Average Time/ZIP Packet",

    "1078",     "ZIP Packets/sec",

    "1080",     "Average Time/RTMP Packet",

    "1082",     "RTMP Packets/sec",

    "1084",     "ATP Retries Local",

    "1086",     "ATP Response Timouts",

    "1088",     "ATP XO Response/Sec",

    "1090",     "ATP ALO Response/Sec",

    "1092",     "ATP Recvd Release/Sec",

    "1094",     "Current NonPaged Pool",

    "1096",     "Packets Routed In/Sec",

    "1098",     "Packets dropped",

    "1100",     "ATP Retries Remote",

    "1102",     "Packets Routed Out/Sec",

    "1110",     "Network Segment",

    "1112",     "Total frames received/second",

    "1114",     "Total bytes received/second",

    "1116",     "Broadcast frames received/second",

    "1118",     "Multicast frames received/second",

    "1120",     "% Network utilization",

    "1124",     "% Broadcast Frames",

    "1126",     "% Multicast Frames",

    "1150",     "Telephony",

    "1152",     "Lines",

    "1154",     "Telephone Devices",

    "1156",     "Active Lines",

    "1158",     "Active Telephones",

    "1160",     "Outgoing Calls/sec",

    "1162",     "Incoming Calls/sec",

    "1164",     "Client Apps",

    "1166",     "Current Outgoing Calls",

    "1168",     "Current Incoming Calls",

    "1228",     "Gateway Service For NetWare",

    "1230",     "Client Service For NetWare",

    "1232",     "Packet Burst Read NCP Count/sec",

    "1234",     "Packet Burst Read Timeouts/sec",

    "1236",     "Packet Burst Write NCP Count/sec",

    "1238",     "Packet Burst Write Timeouts/sec",

    "1240",     "Packet Burst IO/sec",

    "1242",     "Connect NetWare 2.x",

    "1244",     "Connect NetWare 3.x",

    "1246",     "Connect NetWare 4.x",

    "1260",     "Logon Total",

    "1300",     "Server Work Queues",

    "1302",     "Queue Length",

    "1304",     "Active Threads",

    "1306",     "Available Threads",

    "1308",     "Available Work Items",

    "1310",     "Borrowed Work Items",

    "1312",     "Work Item Shortages",

    "1314",     "Current Clients",

    "1320",     "Bytes Transferred/sec",

    "1324",     "Read Bytes/sec",

    "1328",     "Write Bytes/sec",

    "1332",     "Total Operations/sec",

    "1334",     "DPCs Queued/sec",

    "1336",     "DPC Rate",

    "1342",     "Total DPCs Queued/sec",

    "1344",     "Total DPC Rate",

    "1350",     "% Registry Quota In Use",

    "1360",     "VL Memory",

    "1362",     "VLM % Virtual Size In Use",

    "1364",     "VLM Virtual Size",

    "1366",     "VLM Virtual Size Peak ",

    "1368",     "VLM Virtual Size Available",

    "1370",     "VLM Commit Charge",

    "1372",     "VLM Commit Charge Peak",

    "1374",     "System VLM Commit Charge",

    "1376",     "System VLM Commit Charge Peak",

    "1378",     "System VLM Shared Commit Charge",

    "1380",     "Available KBytes",

    "1382",     "Available MBytes",

    "1400",     "Avg. Disk Queue Length",

    "1402",     "Avg. Disk Read Queue Length",

    "1404",     "Avg. Disk Write Queue Length",

    "1406",     "% Committed Bytes In Use",

    "1408",     "Full Image",

    "1410",     "Creating Process ID",

    "1412",     "IO Read Operations/sec",

    "1414",     "IO Write Operations/sec",

    "1416",     "IO Data Operations/sec",

    "1418",     "IO Other Operations/sec",

    "1420",     "IO Read Bytes/sec",

    "1422",     "IO Write Bytes/sec",

    "1424",     "IO Data Bytes/sec",

    "1426",     "IO Other Bytes/sec",

    "1450",     "Print Queue",

    "1452",     "Total Jobs Printed",

    "1454",     "Bytes Printed/sec",

    "1456",     "Total Pages Printed",

    "1458",     "Jobs",

    "1460",     "References",

    "1462",     "Max References",

    "1464",     "Jobs Spooling",

    "1466",     "Max Jobs Spooling",

    "1468",     "Out of Paper Errors",

    "1470",     "Not Ready Errors",

    "1472",     "Job Errors",

    "1474",     "Enumerate Network Printer Calls",

    "1476",     "Add Network Printer Calls",

    "1478",     "Working Set - Private",

    "1480",     "Working Set - Shared",

    "1482",     "% Idle Time",

    "1484",     "Split IO/Sec",

    "1500",     "Job Object",

    "1502",     "Current % Processor Time",

    "1504",     "Current % User Mode Time",

    "1506",     "Current % Kernel Mode Time",

    "1508",     "This Period mSec - Processor",

    "1510",     "This Period mSec - User Mode",

    "1512",     "This Period mSec - Kernel Mode",

    "1514",     "Pages/Sec",

    "1516",     "Process Count - Total",

    "1518",     "Process Count - Active",

    "1520",     "Process Count - Terminated",

    "1522",     "Total mSec - Processor",

    "1524",     "Total mSec - User Mode",

    "1526",     "Total mSec - Kernel Mode",

    "1530",     "TCPv6",

    "1532",     "UDPv6",

    "1534",     "ICMPv6",

    "1536",     "Received Packet Too Big",

    "1538",     "Received Membership Query",

    "1540",     "Received Membership Report",

    "1542",     "Received Membership Reduction",

    "1544",     "Received Router Solicit",

    "1546",     "Received Router Advert",

    "1548",     "Job Object Details",

    "1550",     "Received Neighbor Solicit",

    "1552",     "Received Neighbor Advert",

    "1554",     "Sent Packet Too Big",

    "1556",     "Sent Membership Query",

    "1558",     "Sent Membership Report",

    "1560",     "Sent Membership Reduction",

    "1562",     "Sent Router Solicit",

    "1564",     "Sent Router Advert",

    "1566",     "Sent Neighbor Solicit",

    "1568",     "Sent Neighbor Advert",

    "1746",     "% Idle Time",

    "1748",     "% C1 Time",

    "1750",     "% C2 Time",

    "1752",     "% C3 Time",

    "1754",     "C1 Transitions/sec",

    "1756",     "C2 Transitions/sec",

    "1758",     "C3 Transitions/sec",

    "1760",     "Heap",

    "1762",     "Committed Bytes",

    "1764",     "Reserved Bytes",

    "1766",     "Virtual Bytes",

    "1768",     "Free Bytes",

    "1770",     "Free List Length",

    "1772",     "Avg. alloc rate",

    "1774",     "Avg. free rate",

    "1776",     "Uncommitted Ranges Length",

    "1778",     "Allocs - Frees",

    "1780",     "Cached Allocs/sec",

    "1782",     "Cached Frees/sec",

    "1784",     "Allocs <1K/sec",

    "1786",     "Frees <1K/sec",

    "1788",     "Allocs 1-8K/sec",

    "1790",     "Frees 1-8K/sec",

    "1792",     "Allocs over 8K/sec",

    "1794",     "Frees over 8K/sec",

    "1796",     "Total Allocs/sec",

    "1798",     "Total Frees/sec",

    "1800",     "Blocks in Heap Cache",

    "1802",     "Largest Cache Depth",

    "1804",     "% Fragmentation",

    "1806",     "% VAFragmentation",

    "1808",     "Heap Lock contention",

    "1846",     "End Marker";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\cht\prfh0404.ini ===
"3",     "[System performance object] pAopbqQMBzWC",

    "5",     "[Memory performance object] pAopbqyzOMOCOOWHsOCO]tWOChOp@A [] OM{XbOWC[ Excessive paging] OOA|PtBz{C",

    "7",     "[% Processor Time] OBzDmCpOApbYAmBAAhoC(CBz@mApGSLAm|jC)opBzDnA|u@CpOAAAM 100% hoC",

    "9",     "[% Total DPC Time] OBzBz DPC ({Is) C(DPC O@_Auv_nCC) Kni: [Processor: % DPC Time] OpqWBzHBzC[System: % Total DPC Time] O [ System: % Total Privileged Time] @A] DPC ObSvUCDPC|Q}pABO_p@Cop|u@C",

    "11",     "[File Read Operations/sec] OqWtnDXtvA]AtnDCpOpCop|[tAAHC",

    "13",     "[File Write Operations/sec] OqWtgJnDXtvA]AtgJnDCpOpgJCop|[tAAHC",

    "15",     "[File Control Operations/sec] OtL@Xtv (O]OgJ)AptnDmSATnDCoO [System: File Data Operations/sec] ABO@pCop|[tAAHC",

    "17",     "[File Read Bytes/sec] ObqWmtnDtvA]AtCpOpCCop|[tAAHC",

    "19",     "[File Write Bytes/sec] ObqWmtgJnDgJtvA]AtgJCpOpCCop|[tAAHC",

    "21",     "[File Control Bytes/sec] OtWtv (O]OgJ)A]AtnDAHmSTnDCpOpCop|[tAAHC",

    "23",     "[% Total Interrupt Time] ObABz{ObMBzw_AO_mCOqWBz [Processor: % Interrupt Time] [`HBzCDPC Q}pABO_pCoO|_mAptpBBBqTuBdHLmC",

    "25",     "[Available Bytes] ObqWiOq (Hp)COMksOAiORO[`COzA MSDN / Windows  Server 2003 Resource Kit tMn`C",

    "27",     "[Committed Bytes] OOqAOCOOOAQOdbCCu@CopusOdAOC",

    "29",     "[Page Faults/sec] OCBz~CpOp~A]bC~@Auo@~A]o]~@Cop]tw~ (ns) n~(bO~)CjhBztBzjqn~COBzw~nisA]|PYC",

    "31",     "[Commit Limit] OOqAoqb|W[jpCpOCOOOAQOdbCCiH]t@CpGQXRAo|nW[CopusOdAOC",

    "33",     "[Write Copies/sec] OgJ~tCwgqOs~CoO@`@A]bNgJP]sA_hNN@O@Cop|psC",

    "35",     "[Transition Faults/sec] O_t@Bz{@BbMWBMb~YNQgJHM~tvC_oB~CL~H~p; ]C@u@~AHo]~C",

    "37",     "[Cache Faults/sec] ObjMto~CqOsCtO@s{OCAiHP_{ I/O @Cop|~AC@~C",

    "39",     "[Demand Zero Faults/sec] Oks~~tvCksOMeAAN 0 CoO Windows w\CoiHe~CWindows |@@ksM[tBztCopp~Az|sCopOdtAAHC",

    "41",     "[Pages/sec] OqgJAHKMw~tCopOPto~DnCO [Memory\\Pages Input/se] M [Memory\\Pages Output/sec] O`pCpOpAMLp (p: Memory\\Page Faults/sec) A[HC]tAoOt (q`O{nD) DO~C",

    "43",     "[Page Reads/sec] OFMw~tvCqC@lhA|@CBz{bOu@bOAqAN|ow~CopOPto~DnC]tFt~ (q`O{nD)AbDO~C [Memory\\Pages Reads/sec] P [Memory\\Pages Input/sec] HPwC@C",

    "45",     "[Processor Queue Length] ObBzCCopMpPBOA|puNAOCYbBzqABzu@CC]pGqBzAzNHAu@qBzCu@qwACBzC 10 BzCOiHC",

    "47",     "[Thread State] OeAC0 OlA1 ONA2 OA3 ORA4 Ow A5 OA6 OeA7 OC|BzCRNnBzAwNBz|nDBzAiBzCb [Transition] |i~CpAW|QiCLkBzA]nL@AQ~C",

    "49",     "[Pages Output/sec] OgJHOtvCubO~|Qg^CHiHxsAxs{XCpGXWvAiOCWindows |bOANhg^AHKXhCop|AAiNiHMLpC",

    "51",     "[Page Writes/sec] OgJAXOCubO~|Qg^CHO@sAO{XCopupgJ@AC@gJCopOdtAAHC",

    "53",     "Browser OpitvBC|tvML Browser pC",

    "55",     "[Announcements Server/sec] ObAitvC",

    "57",     "[Pool Paged Bytes] ObAOtO (tOO@~tO)AobiHQg^C[Memory\\Pool Paged Bytes] pM [Process\\Pool Paged Bytes] PAH@wM [Process\\Pool Paged Bytes\\_Total] PCopu[AOC",

    "59",     "[Pool Nonpaged Bytes] ObDADOtOAtmLkgJ (tO O@~tO)AobiHQg^COoQtmAOOAC[Memory\\Pool Nonpaged Bytes] pM [Process\\Pool NonPaged Bytes] PAH@wM [Process\\Pool Nonpaged Bytes\\_Total] PCopu[AOC",

    "61",     "[Pool Paged Allocs] ObtmIsCOtO (tOO@~tO)AobiHQg^CouptmIsACIstmjpCopu[dAOC",

    "63",     "[Pool Paged Resident Bytes] OejpAOCOtO (tOO@~tO)AobiHQg^CQD|qOXAHjiLkOCopu[dAOC",

    "65",     "[Pool Nonpaged Allocs] ObDtmIsCDOtOAtmLkgJCoQtmAOOACouptmIsAbCIstmjpCopu[dAOC",

    "67",     "[Bytes Total/sec] OgqTwe`MAOupt[CoO [Frame Bytes/sec] M [Datagram Bytes/sec] `XC",

    "69",     "[System Code Total Bytes] OebOi@~t{XjpCO@~tOCoObAiHQg^CopJ Ntldr/osloader  Ntoskrnl.exeAHal.dllA}t`MCop]txsbOg^{XCopu[dAOC",

    "71",     "[System Code Resident Bytes] OebOBiHQg^@~t{XCoO [Memory\\System Code Total Bytes] C[Memory\\System Code Total Bytes] ]]tbW@~t{XC[Memory\\System Code Resident Bytes] M [System Code Total Bytes] ]txsbOg^{XCopu[dAOC",

    "73",     "[System Driver Total Bytes] OeQmX{iOC(iObAiHQg^C) ]tO ([Memory\\System Driver Resident Bytes]) wWM{XCO [Memory\\System Code Total Bytes] Copu[dAOC",

    "75",     "[System Driver Resident Bytes] OeQmX{iOCOX{u@ (O)CoO [Memory: System Driver Total Bytes] A[Memory\\System Driver Total Bytes] ]]twgQg^X{OC[Memory\\System Driver Resident Bytes] M [Memory\\System Driver Total Bytes] ]tg^OC",

    "77",     "[System Cache Resident Bytes] Obti@~t{XjpCou]teAB]tDendOCbu@ztC]oiptOqCoO [Memory\\System Code Resident Bytes] ANebOi@~t{XCopu[dAOC",

    "79",     "[Announcements Domain/sec] ONviWtvC",

    "81",     "[Election Packets/sec] Ou@s]tvC",

    "83",     "[Mailslot Writes/sec] OQ\ltvC",

    "85",     "[Server List Requests/sec] OnDswQu@BzLsAMtvC",

    "87",     "Cache ]ttOpCoOsFgsLAiC]{WA]{I/O @COhAeq|W[CpGOA|opLkC",

    "89",     "[Data Maps/sec] OtAp NTFSANtWvC",

    "91",     "[Sync Data Maps/sec] ptAp NTFSANtWvCpGbDOA|C",

    "93",     "[Async Data Maps/sec] O{tAp NTFSANtWvApGbDOA|C",

    "95",     "[Data Map Hits] ObtCoqWNiHiRA]wgbOC",

    "97",     "[Data Map Pins/sec] ObtWvCbDOSwiRoAq`|N@gJCSwQAbDO}AHbt}|QC",

    "99",     "[Pin Reads/sec] OtwWvAw|Qg^CAo|bDOQ_CQAt}|QC",

    "101",     "[Sync Pin Reads/sec] OtwWvAw|Qg^CAo|bDOQ_CtNLksovA@tQA~so (OpGsv~)CQAt}|QC",

    "103",     "[Async Pin Reads/sec] OtwWvAw|Qg^CAo|bOQ_CtNLksovA@tQA~soCQAt}|QC",

    "105",     "[Pin Read Hits] Oibt pin nDA]NOtAsCQAt}|QCLAN sVokqALAN Server ]OokipqCokq`]QtC",

    "107",     "[Copy Reads/sec] OqtWvAotoA{wsOL{CLAN sVokqALAN Server ]OokipqCokq`]QtC",

    "109",     "[Sync Copy Reads/sec] OqtWvAotoA{wsOL{CYWsAtsA~sovC",

    "111",     "[Async Copy Reads/sec] OqtWvAotoA{wsOL{CYWsA{|sovC",

    "113",     "[Copy Read Hits] OnDRA]NOAonDnosCO@@ANOs{wCLAN sVokqALAN Server ]OokipqCokq`]QtC",

    "115",     "[MDL Reads/sec] OtWvAoOyzM (MDL) sCMDL  ]te@C}AiMwOs (DMA) mvTCLAN Server okijqeC",

    "117",     "[Sync MDL Reads/sec] OtWvAoOyzM (MDL) sCMDL ]te@C}AiOs (DMA) \iCpGwsbDOAIs|qsC",

    "119",     "[Async MDL Reads/sec] tWvAoOyzM (MDL) sCMDL ]te@C}AiOs (DMA) \iCpGwsbDOAIs|qsC",

    "121",     "[MDL Read Hits] OOyzM (MDL) nDbtRvC]NOAonDnosC",

    "123",     "[Read Aheads/sec] OtWvA|Co|i~\{nDjAoiHCCBzOC",

    "125",     "[Fast Reads/sec] OtWvA@|LwtAqC@A I/O nD|tq CpGsbAo|\qAgLtCNbA]iKtC",

    "127",     "[Sync Fast Reads/sec] OtWvA@|LwtAqC@A I/O nD|tqCpGsbAo|\qAgLtCNbA]iKtCpGbAnD ({Is) |qWC",

    "129",     "[Sync Fast Reads/sec] OtWvA@|LwtAqC@A I/O nD|tqCpGsbAo| \qAgLtCNbA]iKtCpGbAnD ({Is) |qWC",

    "131",     "[Fast Read Resource Misses/sec] OnTWvA]nDSiC",

    "133",     "[Fast Read Not Possibles/sec] O{ (API) IsLtotWvCt~ooC",

    "135",     "[Lazy Write Flushes/sec] O Lazy Writer gJtvCLazy Writing O@Bz{AOoA|NsWCH{AgJNi~CogJ@iH@gJnXC",

    "137",     "[Lazy Write Pages/sec] O Lazy Writer gJtvCLazy Writing O@Bz{AOoA|NsWCH{AgJNi~CogJ@iH@gJnXC",

    "139",     "[Data Flushes/sec] OtNeeszgJtvCo@iOsznDAOxsnDCosz@iH@gJnXC",

    "141",     "[Data Flush Pages/sec] OtNeszgJtvCo@iOsznDAOxsnDCosz@iH@gJnXC",

    "143",     "[% User Time] ObBzCO@BzA]p{AltAXltCt~@OSvA]p@~tA\swOC@~t|N{Svs@~tACopLC",

    "145",     "[% Privileged Time] OSvUABz{b{XgLC Windows tAQIsAAq`|bSvUAHopKtCunbUANO@oQsCtIsiHOTTAp~_CP@@~tPOAFO@Sv~AWindows BzuO@ltC@ Windows N{u@i|bBzSv~AX{bLltBzC",

    "147",     "[Context Switches/sec] ObqWBzXtvCBzQuvNAN|oBzCbSv () AHKltAA]|oBzCOqWBz Thread\ Context Switches/sec `MABOpCb System  Thread WBzepCop|[tAAHC",

    "149",     "[Interrupts/sec] OBzCAw_tC]t DPCAH}pCoO|_mCm]ttBBX{BqTuBdLgmComu@nJA|BzoX_C`|]o_Cjht|Cj 10 @_BzCop|[tAAHC",

    "151",     "[System Calls/sec] OqWBz{@~tA`IsCo`qW{PBBzADmsAOzWzCop|[tAAHC",

    "153",     "[Level 1 TLB Fills/sec] OO~oWvCoOJ (PTE) bw (TLB) CbYqAo~|nBzAq PTE J TLB Ap|pJC",

    "155",     "[Level 2 TLB Fills/sec] OO~oWvCoOJ (PTE) bw (TLB) CbYqAo~|nBzAq PTE J TLB Ap|pJC",

    "157",     "[% User Time] ObBz{{XC|{AltXltCb{X|` Windows AmX{XCWindows ML@~tPOAFHSv~ABz{O@ltCY Windows z{u@AFX{bBz{Svq~A]i|X{bLltBz{C",

    "159",     "[% Privileged Time] ODmBzbSvUOC Windows AQIsAAq`ObSvAHotpsvCoO@CtIsiHOTOtAp~_CP@~tPOAWindows FHSv~ABz{O@ltCHY Windows z{u@AFX{bBz{Svq~A]i|X{bLltBz{C",

    "161",     "[Enumerations Server/sec] Ou@BzAsnDtvC",

    "163",     "[Enumerations Domain/sec] Ou@BzsnDtvC",

    "165",     "[Enumerations Other/sec] Ou@BzsnDtvConDOAsnDA]OsnDC",

    "167",     "[Missed Server Announcements] OAiCoAOb]wtmL{oC",

    "169",     "[Missed Mailslot Datagrams] OlyCoyOb]wtmL{oC",

    "171",     "[Missed Server List Requests] OsAMnDAoMwgQu@|BzC",

    "173",     "[Virtual Bytes Peak] OBz{C}jC}@wDOCLAB|zJ{wOC",

    "175",     "[Virtual Bytes] OBz{e}C}@w|DOCLABz{|zJ{wOC",

    "177",     "[Page Faults/sec] OBz{o~tvCObu@DOAN|o~CpGbRMANi|PQg^A]wgbDOCpGwgQL@Bz{Ao~]|Qg^C",

    "179",     "[Working Set Peak] bNIBz{u@jpWCu@O@KBz{WOCpGqiORABz{u@OO_bA|CiOAN|Bz{u@OCBz{noOA|Qg^u@C",

    "181",     "[Working Set] OeBz{u@jpWCu@O@KBz{WOCpGqiORABz{u@OO_bA|CiOAN|Bz{u@OCBz{noOA|Qg^u@C",

    "183",     "[Page File Bytes Peak] OBz{OdOWCQxsBz{OABobLCBz{|@@CpGA|TLBz{tmOCpGSApNuMBz{OdOOWC",

    "185",     "[Page File Bytes] OBz{OdeOCQxsBz{OABobLCBz{|@@CpGA|TLBz{tmOCpGSApNuMBz{OdOeOC",

    "187",     "[Private Bytes] OetmBz{jpWAoMLBz{@C",

    "189",     "[% Processor Time] OBz{BzgLCOq@AOqABz{O{Cop]]tFBzYw_]{XC",

    "191",     "[% Processor Time] OBz{BzgLCOq@AOqABz{O{Cop]]tFBzYw_]{XC",

    "193",     "[% User Time] ObOOC{ltMXltbCb{X|` Windows NT AmX{XCWindows NT ML@~tPOAFHSv~ABz{O@ltColtBz{B~O@CHYWindows NT z{u@AFX{bzBz{Svq~A]i|X{bLltBz{C",

    "195",     "[% Privileged Time] ObSv{XgLC Windows tAQIsAAq`|bSvUAHotpsvCoO@AbLksCtIsiHOTOtAp_~CWindows ML@~tPOAFHSv~ABz{O@ltColtBz{B~O@CHY Windows z{u@AFX{bzBz{Svq~A]i|X{bLltBz{C",

    "197",     "[Context Switches/sec] OtvCob@Bz{Bz{C@nDLTAQLuvNAN|oCWindows NT ML@~tPOAFHSv~ABz{O@ltColtBz{B~O@CHYWindows NT z{u@AFX{bzBz{Svq~A]i|X{bLltBz{CltBz{|P{eCqltBz{^|PLltoeC",

    "199",     "[Current Disk Queue Length] OAbW|BznDC]tbi AnDCOAO@qChwmbY@i|oXnDAO]LP@nDbACopiMCCCpGbWJ@Ao|@OCCw|PnDoCpGp}nAotC 2C",

    "201",     "[% Disk Time] OigJ@AOC",

    "203",     "[% Disk Read Time] Oi@AOC",

    "205",     "[% Disk Write Time] OigJ@AOC",

    "207",     "[Avg. Disk sec/Transfer] O@AHC",

    "209",     "[Avg. Disk sec/Read] OAHC",

    "211",     "[Avg. Disk sec/Write] OgJAHC",

    "213",     "[Disk Transfers/sec] Og@C",

    "215",     "[Disk Reads/sec] O@C",

    "217",     "[Disk Writes/sec] OgJ@C",

    "219",     "[Disk Bytes/sec] OWbgJL{tvC",

    "221",     "[Disk Read Bytes/sec] OWbL{tvC",

    "223",     "[Disk Write Bytes/sec] OWbgJL{tvC",

    "225",     "[Avg. Disk Bytes/Transfer] OWbgJL{tvC",

    "227",     "[Avg. Disk Bytes/Read] OWbL{tvC",

    "229",     "[Avg. Disk Bytes/Write] OWbgJL{tvC",

    "231",     "Process ]tFpA{tBz{CbBz{|@P}ABiHsPC",

    "233",     "Thread ]tFpAppAO@iHbBzCBz{@C",

    "235",     "Physical Disk ]tFpAqWTwwCxsA{ABiHi@AgJCpOO () p`MC",

    "237",     "Logical Disk ]tFpATwwWCPerformance Monitor |NAp C OC",

    "239",     "Processor ]tFpApBzpCBzOq@ApAN@lABz{C@xqiHBzCPBzNPBzC",

    "241",     "[% Total Processor Time] ObqWbDmBzCopQ]pbhBzqWBzDnCpONBz [Process: % Processor Time] `MAHBzC|NABzbmBz{[`ANoH 100%AAHqWBz`C(CBz@ Idle ASnAo|@jC) pAbhBzqWA50% b@bBzbLAb@bABzbLCop|b[LCpOAmAMH 100%C",

    "243",     "[% Total User Time] ObBzDmCONqWBz [Processor:% User Time] [`AHBzC[System: % Total User Time] M [ System: % Total Privileged Time] `MO [% Total Processor Time]AOo`M@wO 100%C(O@B]p{AltAXltCt~@OSvA]p@~tA\swOC@~t|N{Svs@~tAC) opLC",

    "245",     "[% Total Privileged Time] ObSv () BzDmCOqWBz [Processor: % Privileged Time] [`AHBzC[System: % Total User Time]  [System: % Total Privileged Time] `MO [% Total Processor Time]AOo`M@wO 100%C(Sv]p@~tw@X{C\swOCt~@OA@BzA]p{AltAXltC) opLC",

    "247",     "[Total Interrupts/sec] OqWBzw_etvCOBz [Processor: Interrupts/sec] `MAAHBzABp_C]t DPCADPC Q}pCoO|_mAptAAX{AqTuAdLmComu@DA|BzoX_C`|]o_Cjht|Cj 10 @_BzA_Cop|[tAAHC",

    "249",     "[Processes] ObqWBz{CoOpAOpCCBz{N@{C",

    "251",     "[Threads] ObqWCoOpAOpCO@AiHbBzC",

    "253",     "[Events] ObqWCNoOpAOpCP@AN|C",

    "255",     "[Semaphores] ObqWHCoOpAOpC|HoML@csvC",

    "257",     "[Mutexes] ObqW Mutex CoOpAOpC Mutex TOu@@SO{XqC",

    "259",     "[Sections] ObqWqCoOpAOpCqOO@AOBz{AxsC@Bz{iHMLBz{@qC",

    "261",     "Object tpAtApABz{BBmutexe HCoTiHqnCCnOsTC",

    "263",     "Redirector tpAqWsuC",

    "265",     "[Bytes Received/sec] OqJ Redirector tvC]t{qTwT (pA]Y)C",

    "267",     "[Packets Received/sec] O Redirector ]tvC(]s SMB  Server Message Blocks)CQ@]CpGno]AiHNoH [Bytes Received/sec] CY]iS]tJC(pARedirector gJ]O@J)C",

    "269",     "[Read Bytes Paging/sec] ORedirector b^~tvC~iO]J~ (p{w)Ao~ (\ [Read Bytes Cache/sec])AO]{} (oO Windows NT @kC)o~C",

    "271",     "[Read Bytes Non-Paging/sec] O Redirector tvAoOF^{QsVLqoX@nDCFnD~Aop]]tLkA]ARWD (Named Pipe) (Transaction)CoppqTwTAup{C",

    "273",     "[Read Bytes Cache/sec] O{ Redirector sttvCo@nDiHqCpGYnDAi|_~ (\ [Read Bytes Paging/sec])C",

    "275",     "[Read Bytes Network/sec] O{tvC{btWnANWCpGNoH [Bytes Received/sec]ANObWy (\[Bytes Received/sec])C",

    "277",     "[Bytes Transmitted/sec] O Redirector eWtvC]t{qTwT (p]Y)C",

    "279",     "[Packets Transmitted/sec] O Redirector e]tv (]s SMBs  Server Message Blocks)CQ@]CpGno]AiHoH [Bytes Transmitted/sec]C",

    "281",     "[Write Bytes Paging/sec] O Redirector NgJ{tvCqWJ (p{{w) |{CpGnoA|q'oCLtX (\ [Write Bytes Cache/sec])C",

    "283",     "[Write Bytes Non-Paging/sec] O Redirector gJtvAogJOF^{QsVLqoX@nDCFnD~Aop]]tLkA]ARWD (Named Pipe) (Transaction)CoppqTwTAup{C",

    "285",     "[Write Bytes Cache/sec] ObzqW{ Redirector gJttvCgJi|W}zqAbgJeAiHdbLCoiH`yqCop|pC@gJC",

    "287",     "[Write Bytes Network/sec]  O{gJtvC{LtApRWD (Named Pipe)  (Transaction)ANg^HW[iLA{N|NgJC[Transmitted/sec] NJ (\ Transmitted Bytes/sec])C",

    "289",     "[File Read Operations/sec] O{V Redirector nDtvCC@tIs{ (API) IsAQO@@C",

    "291",     "[Read Operations Random/sec] pDtv (WO@~L)CpGSNXAMhLAO~Apu|p@C",

    "293",     "[Read Packets/sec] ON]WtvCCtnD]QeWAopN|W[ 1C",

    "295",     "[Reads Large/sec] O{jqtvAoqWLAAweqConOohAi|vTACop|poCoAp]C",

    "297",     "[Read Packets Small/sec] O{pqtvAoqpAAweq|@ConOohA|yAOCop|poCoAp]C",

    "299",     "[File Write Operations/sec] O{Ne Redirector tvCC@tIs{ (API) IsAQO@@C",

    "301",     "[Write Operations Random/sec] pDgJtv (WO@~L)CpGSNXgJAMhgJLAO~Apu|p@C",

    "303",     "[Write Packets/sec] ONgJeWtvCC@tgJ]QeWAopN|W[ 1C",

    "305",     "[Writes Large/sec] O{jqgJtvAogJqWLAAweqCogJnOohAi|vTACop|poCoAp]C",

    "307",     "[Write Packets Small/sec] O{pqgJtvAogJqpAAweq|@CogJnOohA|yAOCop|poCoAp]C",

    "309",     "[Reads Denied/sec] OALk` Raw Read nDtvCqAAweqjhARedirector |nD Raw Read \bC][JqTw`NieCpGno@AALnDApGAbLAA|nDC",

    "311",     "[Writes Denied/sec] OALk` Raw Write nDtvCgJqAAweqjhARedirector |nD Raw Write \bC][JqTw`NieCpGno@AALnDApGAbLAA|nDC",

    "313",     "[Network Errors/sec] YN~~otCo~q` Redirector @AoYqTCpASMB (Server Manager Block) qTw~O~CoG|ObtxAC",

    "315",     "[Server Sessions] p Redirector zwCpbnJAWi@|@suAo|u@qC",

    "317",     "[Server Reconnects] pz Redirector ssuAsnDCpGz@qSsuAA|_zsuCbqWNwARedirector O|NsuOdQCoOdsus 'vsu'C]ssuOC",

    "319",     "[Connects Core] pbAWl MS-Net SMB qTwsuA]t MS-NetBXenix  VAX suC",

    "321",     "[Connects LAN Manager 2.0] ps LAN Manager 2.0 AsuA]t LMX AC",

    "323",     "[Connects LAN Manager 2.1] ps LAN Manager 2.1 AsuA]t LMX AC",

    "325",     "[Connects Windows NT] ps Windows 2000 qC",

    "327",     "[Server Disconnects] pANz Redirector _suC\ [Server Reconnects]C",

    "329",     "[Server Sessions Hung] pwgOABLkoA^u@qC",

    "331",     "Server pAiHpMqqTC",

    "333",     "AqAAL{C",

    "335",     "AeAAL{C",

    "337",     "[Thread Wait Reason] O]CbnAO 0  7CiAO 1  8CiAO 2  9CtmAO 3  10C]AO 4  11C]mAAO 5  12CnDAO 6  13C Event Pair High AO 14C Event Pair Low AO 15C LPC AO 16C LPC ^AO17COAO 18CXhAO 19C20 HW|]CEvent Pairs MO@ltqT (\ Context Switches)C",

    "339",     "[% DPC Time] ObABzbA DPC CDPC O@_A@_uvnCC[% DPC Time] O [% Privileged Time] A] DPC bSvCQ}pAB]tb_pCopLC",

    "341",     "oOwQu@qA]mWLA AutoDisconnect C AutoDisconnect]wiHUz`C",

    "343",     "oOwQu@qA]oN~~AiO autodisconnect FAHQ_suC",

    "345",     "oOQ`u@qAo [Sessions Times Out]  [Sessions Errored Out] pU -- pC",

    "347",     "oOQjnXu@qAohu@qb]nJqQjnXC",

    "349",     "oOnJAoCoAWO_QKX}{}awC",

    "351",     "}N STATUS_ACCESS_DENIED CoYHHNsAQnoO@C",

    "353",     "Q\as}CbSsvUAsC",

    "355",     "oOA~CN~~oq`NADC",

    "357",     "oOAQ SMB oQA]iu@pCoX MaxWorkItem  MinFreeWorkItems AO_nC",

    "359",     "oOb STATUS_DATA_NOT_ACCEPTED Q^CoSiu@ASu@iQtmAnDCziHoP_ MaxWorkItems O_nC",

    "361",     "oOA}\CoPw I/O qB|@q}wvC",

    "363",     "oOebAW}CoeAqC",

    "365",     "oOebAWu@qCoeAqC",

    "367",     "oOebAWCoeAqC",

    "369",     "AiqOqCUPO WindowsNT n MaxNonpagedMemoryUsage C",

    "371",     "oOtmDoCoqOC",

    "373",     "oOAwbDjCoiHMwqnhOC",

    "375",     "oOAeqiOCoiHMw MaxPagedMemoryUsage A]wC",

    "377",     "tmwgCqOpFC",

    "379",     "oOAwgtmjCoOOA]wC",

    "381",     "[Server Announce Allocations Failed/sec] OA() i]OotvC",

    "383",     "[Mailslot Allocations Failed] OytmwCowslgJC",

    "385",     "[Mailslot Receives Failed] N]o~LklHC",

    "387",     "[Mailslot Writes Failed] Ow\OLkgJlHC",

    "389",     "[Bytes Total/sec] O Redirector BztvCo]A{A[WqTwTAp]YC",

    "391",     "[File Data Operations/sec] O Redirector Bz@tvC@@]t\hA]@]]t`]BzCNoH Bytes/secAiHo@APwo|C",

    "393",     "[Current Commands] pebCAnDAonDo RedirectorCpGoqWwdjhA () As|YvTC",

    "395",     "oOAeqWCoiDzAL{C",

    "397",     "[% Interrupt Time] OBzbAbBzw_WCoO|_mCm]ttBBX{BqTuBdLgmComu@nJA|BzoX_C`|]o_Cjht|Cj 10 @_BzCop|LC",

    "399",     "NWLink NetBIOS tpA IPX tvsuAC",

    "401",     "[Packets/sec] O Redirector Bz]tvC@]]t\h (zQp)CH (zQp) O]C]qTw@CpGnPw|vAziHNopH Bytes/secAoC]Cz]iHNopH Operations/secAoC@]CoOqvt@kC",

    "405",     "[Context Blocks Queued per second] Ou@eA FSP CtvAbCAC",

    "407",     "[File Data Operations/ sec] ObqWgtvCoO [System: File Control Operations/sec] Cop[AAHC",

    "409",     "[% Free Space] OWiC",

    "411",     "[Free Megabytes] W|tmAO MBC1 MB  1,048,576 C",

    "413",     "[Connections Open] OeoqTw}suCopueA|psuC",

    "415",     "[Connections No Retries] p@suN\suCoOpAB`C",

    "417",     "[Connections With Retries] O~su\suCoOpAB`C",

    "419",     "[Disconnects Local] OqlsuQ_CoOpAB`C",

    "421",     "[Disconnects Remote] OqlsuQ_CoOpAB`C",

    "423",     "[Failures Link] OsQRsuCoOpAB`C",

    "425",     "[Failures Adapter] doQRdCoOpAB`C",

    "427",     "[Connection Session Timeouts] Ou@qOQRsuCoOpAB`C",

    "429",     "[Connections Canceled] OQsuoOpAB`C",

    "431",     "[Failures Resource Remote] OqsmoDosuCoOpAB`C",

    "433",     "[Failures Resource Local] OqsmoDosuCoOpAB`C",

    "435",     "[Failures Not Found] OqsuCoOpAB`C",

    "437",     "[Failures No Listen] Oq^sunDQsuC",

    "439",     "[Datagrams/sec] OqBz]tvCope]`C]OSsu]AQqO\C",

    "441",     "[Datagram Bytes/sec] OqBz]tvCope]`C]OSsu]AQqO\C",

    "443",     "[Datagrams Sent/sec] Oqqe]tvC]OSsu]AQqO\C",

    "445",     "[Datagram Bytes Sent/sec] Oqqe]tvC]OSsu]AQqO\C",

    "447",     "[Datagrams Received/sec] Oq]tvC]OSsu]AQqO\C",

    "449",     "[Datagram Bytes Received/sec] Oq]tvC]OSsu]AQqO\C",

    "451",     "[Packets/sec] OqBz]tvCoO [Packets Sent]  [Packets Received per second] `MCop]twBz]A]]C",

    "453",     "[Packets Sent/sec] Oqe]tvCoppqe]A]]C",

    "455",     "[Packets Received/sec] Oq]tvCoppq]A]]C",

    "457",     "[Frames/sec] OqBz[ (]A]) tvCopO[e`MCupt[ (])C",

    "459",     "[Frame Bytes/sec] OqBz[tvCopO[e`MCupt[ (])C",

    "461",     "[Frames Sent/sec] Oqe[tvCupt[ (])C",

    "463",     "[Frame Bytes Sent/sec] OqetvCupt[ (])C",

    "465",     "[Frames Received/sec] Oq[tvCupt[ (])C",

    "467",     "[Frame Bytes Received/sec]  OqtvCupt[ (])C",

    "469",     "[Frames Re-Sent/sec] Oqse[ (])tvCupt[ (])C",

    "471",     "[Frame Bytes Re-Sent/sec] OqsetvCupt[ (])C",

    "473",     "[Frames Rejected/sec] O[QtvCupt[ (])C",

    "475",     "[Frame Bytes Rejected/sec] OQtvCupt[ (])C",

    "477",     "[Expirations Response] O T1 pLpC",

    "479",     "[Expirations Ack] O T2 pLpC",

    "481",     "[Window Send Maximum] Oboq{ieNQeXjC",

    "483",     "[Window Send Average] Oboq{ieNQeXC",

    "485",     "[Piggyback Ack Queued/sec] O piggyback {iiJCtvCPiggyback {iO]{iAo{i|]tbUeq]C",

    "487",     "[Piggyback Ack Timeouts] OS]AHLke piggyback {iCPiggyback {iO]{iAo{i|]tbUeq]CpGbOeS]XAack ]|QXBop|W[C",

    "489",     "NWLink IPX tpApq IPX qTw]C",

    "491",     "NWLink SPX tpApq SPX qTwiu@qsuC",

    "493",     "NetBEUI tpAp NetBIOS End User Interface C",

    "495",     "NetBEUI tpAl NetBEUI qTwwC",

    "497",     "[Used Maximum] O NetBEUI  (w)jCo]wjeqUCo|HWAHKbxTOC",

    "499",     "[Used Average] Oe (w)Co|HWAHKbxTOC",

    "501",     "[Times Exhausted] OQCo|HWAHKbxTOC",

    "503",     "NBT  Connection tpApqqzL NBT suetvCoqWOsuC",

    "505",     "[Bytes Received/sec] OqzL NBT suqtvCzLSw NBT suQq|QpC",

    "507",     "[Bytes Sent/sec] OqzL NBT sueqtvCzLSw NBT suqe|QpC",

    "509",     "[Bytes Total/sec] OqzL NBT sueqAHqqtvCzLSw NBT suqe|QpC",

    "511",     "Network Interface tpApzL TCP/IP suetvC]]tsu~pC",

    "513",     "[Bytes Total/sec] OdWetvA]t[rC[Network Interface]\\[Bytes Received/sec] O [Network Interface]\\[Bytes Received/sec] M [Network Interface]\\[Bytes Sent/sec] `MC",

    "515",     "[Packets/sec] ObW]etvC",

    "517",     "[Packets Received/sec] bW]tvC",

    "519",     "[Packets Sent/sec] ObW]etvC",

    "521",     "[Current Bandwidth] OeWepAO/ (BPS)CpGOWeAOLkTpAoNWqWWeC",

    "523",     "[Bytes Received/sec] OdtvA]t[rC[Network Interface]\\[Bytes Received/sec] O [Network Interface]\\[Bytes Total/sec] lC",

    "525",     "[Packets Received Unicast/sec] O (l) I]hqTwtvC",

    "527",     "[Packets Received Non-Unicast/sec] ODI (lslhI) ]hqTwtvC",

    "529",     "[Packets Received Discarded] OnJ]AoLkQhqTw]@wt~Ci]OFXwC",

    "531",     "[Packets Received Errors] Ot~J]Co~]LkQhqTwC",

    "533",     "[Packets Received Unknown] O]CoQ]qTwLkC",

    "535",     "[Bytes Received/sec] OdtvA]t[rC[Network Interface]\\[Bytes Sent/sec] O [Network Interface]\\[Bytes Total/sec] lC",

    "537",     "[Packets Sent Unicast/sec] OhqTwnDN]lI}etvCotv]tF|Q]C",

    "539",     "[Packets Sent Non-Unicast/sec] OhqTwnDN]DI (lslhI) }etvCotv]tF|Q]C",

    "541",     "[Packets Outbound Discarded] OQnX]AYo]SQXAHKeXhCi]OFXwC",

    "543",     "[Packets Outbound Errors] Oo~LkX]C",

    "545",     "[Output Queue Length] OX]CAH]CpGj 2A|oABzM~VDC]O NDIS BznDCAoO@O 0C",

    "547",     "IP tpAp IP qTwe IP ]tvC]]t IP qTw~pC",

    "549",     "[Datagrams/sec] OCe IP ]tvA]to~]Cotv]tH]C",

    "551",     "[Datagrams Received/sec] OC IP ]tvA]to~]C[Datagrams Received/sec] O [Datagrams/sec] lC",

    "553",     "[Datagrams Received Header Errors] O] IP Y~QJ]C~]A checksums DAsAL~AWLsdAbBz IP o{~C",

    "555",     "[Datagrams Received Address Errors] O]b IP Ya IP }qLQJ]Co]tL} (p 0.0.  0.0) HO} (p Class E)Cop|N]O IP hDLkH]@O]A]}O}C",

    "557",     "[Datagrams Forwarded/sec] OCMHHJ]aA]AO IP aCAO@ IP hDAt]tg]ABBz\C",

    "559",     "[Datagrams Received Unknown Protocol] O}]Q\oQ]A]qTwLkC",

    "561",     "[Datagrams Received Discarded] O]DHPLk~BzQJ IP ] (pw)Cop]tbQ]C",

    "563",     "[Datagrams Received Delivered/sec] OC\ IP qTwJ (]A ICMP) tC",

    "565",     "[Datagrams Sent/sec] OC IP qTwe IP ]etv (]A ICMP)Cop]t [Datagrams Forwarded] ]C[Datagrams Sent/sec] O [Datagrams/sec] lC",

    "567",     "[Datagrams Outbound Discarded] OSoaDNQX IP ] (pw)Cop|]tb [Datagrams Forwarded/sec] Xop]C",

    "569",     "[Datagrams Outbound No Route] O]Lk IP ]Cop]tb [Datagrams Forwarded/sec] XLk IP ]C",

    "571",     "[Fragments Received/sec] Ooxn IP qCtvC",

    "573",     "[Fragments Re-assembled/sec] \ IP qCtvC",

    "575",     "[Fragment Re-assembly Failures] O IP tkApOB~Co@wOQ IP qA]tk (O RFC 815) bNoq@XAi|qC",

    "577",     "[Fragmented Datagrams/sec] OC]Q\qtvC",

    "579",     "[Fragmentation Failures] OSLkqQ IP ]Apo]XiQ] [Don't Fragment]C",

    "581",     "[Fragments Created/sec] O]qAC IP qtvC",

    "583",     "ICMP  tpAp ICMP qTwTetvA]| ICMP qTw~C",

    "585",     "[Messages/sec] OCoxe ICMP TtvC]|p~eTC",

    "587",     "[Messages Received/sec] OCox ICMP TtvC]|p~TC",

    "589",     "[Messages Received Errors] Ooxt~ ICMP qTwTCpAICMP checksums TATC",

    "591",     "[Received Destination Unreachable] O ICMP Destination Unreachable TC",

    "593",     "[Received Time Exceeded] O ICMP Time Exceeded TC",

    "595",     "[Received Parameter Problem] O ICMP Parameter Problem TC",

    "597",     "[Received Source Quench] O ICMP Source Quench TC",

    "599",     "[Received Redirect/sec] OC ICMP Redirect TtvC",

    "601",     "[Received Echo/sec] OC ICMP Echo TtvC",

    "603",     "[Received Echo Reply/sec] OC ICMP Echo Reply TtvC",

    "605",     "[Received Timestamp/sec] OC ICMP Timestamp nDTtvC",

    "607",     "[Received Timestamp Reply/sec] O ICMP Timestamp Reply TtvC",

    "609",     "[Received Address Mask] O ICMP Address Mask Request TC",

    "611",     "[Received Address Mask Reply] O ICMP Address Mask Reply TC",

    "613",     "[Messages Sent/sec] OACetvC]]tF~TC",

    "615",     "[Messages Outbound Errors] OSeXh ICMP TAoTO] ICMP ~LkeApwCo]tD ICMP h~ApO IP ]Cb@pUAo~|]tbopC",

    "617",     "[Sent Destination Unreachable] OeXh ICMP Destination Unreachable TC",

    "619",     "[Sent Time Exceeded] OeXh ICMP Time Exceeded TC",

    "621",     "[Sent Parameter Problem] OeXh ICMP Parameter Problem TC",

    "623",     "[Sent Source Quench] OeXh ICMP Source Quench TC",

    "625",     "[Sent Redirect/sec] OCe ICMP Redirect TtvC",

    "627",     "[Sent Echo/sec] O ICMP Echo TetvC",

    "629",     "[Sent Echo Reply/sec] OCe ICMP Echo Reply TtvC",

    "631",     "[Sent Timestamp/sec] OCe ICMP Timestamp (nD) TtvC",

    "633",     "[Sent Timestamp Reply/sec] OCe ICMP Timestamp Reply TtvC",

    "635",     "[Sent Address Mask] OeXh ICMP Address Mask Request TC",

    "637",     "[Sent Address Mask Reply] OeXh ICMP Address Mask Reply TC",

    "639",     "TCP tpAp TCP qTw TCP qetvC]]tF TCP supC",

    "641",     "[Segments/sec] OTCP qTw TCP qetvC",

    "643",     "[Connections Established] OeAO ESTABLISHEDA]O CLOSE-WAIT  TCP suC",

    "645",     "[Connections Active] O TCP suq CLOSED A SYN-SENT AC",

    "647",     "[Connections Passive] O TCP suq LISTEN A SYN-RCVD AC",

    "649",     "[Connection Failures] O TCP suq SYN-SENT  SYN-RCVD A  CLOSED AA[W TCP suq LISTEN A SYN-RCVD AC",

    "651",     "[Connections Reset] O TCP suqD ESTABLISHED  CLOSE-WAIT A CLOSED AC",

    "653",     "[Segments Received/sec] OqtvA]tFt~qCop]tb{ssuWqC",

    "655",     "[Segments Sent/sec] OqetvA]tb{ssuWeqC]tseC",

    "657",     "[Segments Retransmitted/sec] OqsetvA]NOAeOewQeLC",

    "659",     "UDP tpAp UDP qTw UDP ]etvC]tF UDP qTw~C",

    "661",     "[Datagrams/sec] O UDP ]etvC",

    "663",     "[Datagrams Received/sec] Oe UDP  UDP ]tvC",

    "665",     "[Datagrams No Port/sec] ObsWS{Bz UDP ]tvC",

    "667",     "[Datagrams Received Errors] OwoLk~ UDP ]Cop|pLk]A]AbsWS{iBzyLkC",

    "669",     "[Datagrams Sent/sec] Oe UDP ]tvC",

    "671",     "oO~q Disk Storage mp",

    "673",     "oOsmitm",

    "675",     "[System Up Time] OqqW{bgLAOCopq{bgLC",

    "677",     "oOetNXC",

    "679",     "[Free System Page Table Entries] t|Copu[COC",

    "681",     "oOBz{eCOBzAOCCBz{t@C",

    "683",     "oOoBz{euCbBz{uiHBz{u@C",

    "685",     "oBz{`@ (: )C",

    "687",     "[Alignment Fixups/sec] OCt~tvC",

    "689",     "[Exception Dispatches/sec] OCtoe~tvC",

    "691",     "[Floating Emulations/sec] OtBItvCop[tHC",

    "693",     "[Logon/sec] OAnJtvC",

    "695",     "oOoeAuCpGbBzJAtiHAuCpG@qBzAtiHCAuC",

    "697",     "oOoAuCpGbBzJAtiHAuCpG@qBzAtiHCAuC",

    "699",     "o`@ (: )C",

    "701",     "Paging File tpAqWCO@WOdAqWw{iOC",

    "703",     "oO`C\ [Process\\Page File Bytes]C",

    "705",     "oOypC\ [Process\\Page File Bytes Peak]C",

    "707",     "o}C",

    "709",     "oOo [Current User Program] pC",

    "711",     "[Mapped Space] OwgBz{}w} (}d) OC[No Access] O@iHBz{gCpGgA|osHWC",

    "713",     "[Mapped Space] OwgBz{}w} (}d) OC[Read Only] O@iHeQCpGgJA|osHWC",

    "715",     "[Mapped Space] OwgBz{}w} (}d) OC[Read/Write] O@\Bz{AgJC",

    "717",     "[Mapped Space] OwgBz{}w} (}d) OC[Write Copy] O@bOQ@HKi (OgJ)CBz{OABz{iH@POCOoBz{n@OigJA|@OBz{C",

    "719",     "[Mapped Space] OwgBz{}w} (}d) OC[Executable memory] OiHQ{OCOQgCOBz{ogO@C",

    "721",     "[Mapped Space] OwgBz{}w} (}d) OC[Execute/Read Only memory] OiHQ]iHQOC",

    "723",     "[Mapped Space] OwgBz{}w} (}d) OC[Execute/Read/Write memory] OiHQ]iHQMOC",

    "725",     "[Mapped Space] OwgBz{}w} (}d) OC[Execute Write Copy] OiHQ{]iHQMgJOCBz{n@O|oO@CpGBz{uOA|@POApGBz{ngJOA|@OBz{C",

    "727",     "[Reserved Space] OOdBz{OAoO|]{iC[No Access] O@iHBz{gCpGgA|osHWC",

    "729",     "[Reserved Space] OOdBz{OAoO|]{iC[Read Only] O@iHeQCpGgJA|osHWC",

    "731",     "[Reserved Space] OOdBz{OAoO|]{iC[Read/Write] O@\Bz{AgJC",

    "733",     "[Reserved Space] OOdBz{OAoO|]{iC[Read/Write] O@\Bz{AgJC",

    "735",     "[Reserved Space] OOdBz{OAoO|]{iC[Executable memory] OiHQ{OCOQgCOBz{ogO@C",

    "737",     "[Reserved Space] OOdBz{OAoO|]{iC[Execute/Read Only memory] OiHQ]iHQOC",

    "739",     "[Reserved Space] OOdBz{OAoO|]{iC[Execute/Read/Write memory] OiHQ]iHQMOC",

    "741",     "Image tpAqWBz{v}pC",

    "743",     "[Reserved Space] OOdBz{OAoO|]{iC[Execute Write Copy] OiHQ{]iHQMgJOCBz{n@O|oO@CpGBz{uOA|@POApGBz{ngJOA|@OBz{C",

    "745",     "[Unassigned Space] OBz{w{iOAoBz{SwvC[No Access] O@iHBz{gCpGgA|osHWC",

    "747",     "[Unassigned Space] OBz{w{iOAoBz{SwvC[Read Only] O@iHeQCpG gJA|osHWC",

    "749",     "[Unassigned Space] OBz{w{iOAoBz{SwvC[Read/Write] O@\Bz{AgJC",

    "751",     "[Unassigned Space] OBz{w{iOAoBz{SwvC[Write Copy] O@bOQ@HKi (OgJ)CBz{OABz{iH@POCOoBz{n@OigJA|@OBz{C",

    "753",     "[Unassigned Space] OBz{w{iOAoBz{SwvC[Executable memory] OiHQ{OCOQgCOBz{ogO@C",

    "755",     "[Unassigned Space] OBz{w{iOAoBz{SwvC[Execute/Read Only memory] OiHQ]iHQOC",

    "757",     "[Unassigned Space] OBz{w{iOAoBz{SwvC[Execute/Read/Write memory] OiHQ]iHQMOC",

    "759",     "[Unassigned Space]OBz{w{iOAoBz{SwvC[Execute Write Copy] OiHQ{]iHQMgJOCBz{n@O|oO@CpGBz{uOA|@POApGBz{ngJOA|@OBz{C",

    "761",     "[Image Space] OQBz{v}CoO}`MAoQtmBz{vC[No Access] O@iHBz{gCpGgA|osHWC",

    "763",     "[Image Space] OQBz{v}CoO}`MAoQtmBz{vC[Read Only] O@iHeQCpG gJA|osHWC",

    "765",     "[Image Space] OQBz{v}CoO}`MAoQtmBz{vC[Read/Write] O@\Bz{AgJC",

    "767",     "[Image Space] OQBz{v}CoO}`MAoQtmBz{vC[Write Copy] O@bOQ@HKi (OgJ)CBz{OABz{iH@POCOoBz{n@OigJA|@OBz{C",

    "769",     "[Image Space] OQBz{v}CoO}`MAoQtmBz{vC[Executable memory] OiHQ{OCOQgCOBz{ogO@C",

    "771",     "[Image Space] OQBz{v}CoO}`MAoQtmBz{vC [Execute/Read-Only memory] OiHQ]iHQOC",

    "773",     "[Image Space] OQBz{v}CoO}`MAoQtmBz{vC[Execute/Read/Write memory] OiHQ]iHQMOC",

    "775",     "[Image Space] OQBz{v}CoO}`MAoQtmBz{vC[Execute Write Copy] OiHQ{]iHQMgJOCBz{n@O|oO@CpGBz{uOA|@POApGBz{ngJOA|@OBz{C",

    "777",     "[Bytes Image Reserved] ObBz{vOdO`MC",

    "779",     "[Bytes Image Free] ObQBz{vOdO`MC",

    "781",     "[Bytes Reserved] OQBz{OdO`MC",

    "783",     "[Bytes Free] OoBz{}`MC",

    "785",     "[ID Process] OoBz{ ID W@OCBz{s|QAQ@Bz{OC",

    "787",     "Process Address Space tpABz{OtmpC",

    "789",     "[Image Space] OO@v}C[No Access] O@iHBz{gCpGgA|osHWC",

    "791",     "[Image Space] OO@v}C[Read Only] O@iHeQCpG gJA|osHWC",

    "793",     "[Image Space] OO@v}C[Read/Write] O@\Bz{BgJC",

    "795",     "[Image Space] OO@v}C[Write Copy] O@bOQ@HKi (OgJ)CBz{OABz{iH@POCOoBz{n@OigJA|@OBz{C",

    "797",     "[Image Space] OO@v}C[Executable memory] OiHQ{OCOQgCOBz{ogO@C",

    "799",     "[Image Space] OO@v}C[Execute/Read Only memory] OiHQ]iHQOC",

    "801",     "[Image Space] O]toO@v}C[Execute/Read/Write memory] O{iHBgJOC",

    "803",     "[Image Space] OO@v}C[Execute Write Copy] OiHQ{]iHQMgJOCBz{n@O|oO@CpGBz{uOA|@POApGBz{ngJOA|@OBz{C",

    "805",     "[ID Thread] Oo@OC[ID Thread] X|QAQ@Bz{OC",

    "807",     "[Mailslot Opens Failed/sec] Ou@lHtvCoHlwbu@WC",

    "809",     "[Duplicate Master Announcements] DsbP@LDsC",

    "811",     "[Illegal Datagrams/sec] Ou@~ytvC",

    "813",     "[Announcements Total/sec] O [Announcements Server/sec]  [Announcements Domain/sec] `MC",

    "815",     "[Enumerations Total/sec] Oou@BzsnDtvCoO [Enumerations Server/sec]B[Enumerations Domain/sec]  [Enumerations Other/sec] `MC",

    "817",     "Thread Details tpAp[CopM Thread @OAh`]pC",

    "819",     "[Cache Bytes] O [Memory\\System Cache Resident Bytes]B[Memory\\System Driver Resident Bytes]B[Memory\\System Code Resident Bytes]BH [Memory\\Pool Paged Resident Bytes] p`MCopu[AOC",

    "821",     "[Cache Bytes Peak] OtW{b tjCijeeqCopu[AOC",

    "823",     "[Pages Input/sec] OFMw~qtCBz{nDbOAbu@A]bOqAN|ow~Co~At|sOA@FjqC Memory\\Pages Input/sec P Memory\\Page Reads/sec HPwC@ANJOC",

    "825",     "[Transition Pages RePurposed] OFPAsetC_hsAoNdbAH (t) ne (qIs)C`Noi]tpK@OC",

    "871",     "[RAS performance object] pAopqW RAS mHsAsC",

    "873",     "oOosu`C",

    "875",     "oOosu`C",

    "877",     "oOosu[`C",

    "879",     "oOosu[`C",

    "881",     "oOeYvC",

    "883",     "oOYvC",

    "885",     "osu [CRC Errors] `C[]t~N|o [CRC Errors]C",

    "887",     "osu [Timeout Errors] `CN|o [Timeout Errors]C",

    "889",     "osu [Serial Overrun Errors] `CwLkHtvBzAN|o [Serial Overrun Errors]C",

    "891",     "osu [Alignment Errors] `CPPAN|o [Alignment Errors]C",

    "893",     "osu [Buffer Overrun Errors] `CnLkHtvBzAN|o [Buffer Overrun Errors]C",

    "895",     "osu [CRC, Timeout, Serial Overrun, Alignment, and Buffer Overrun Errors] `C",

    "897",     "oOCC",

    "899",     "oOCC",

    "901",     "oOC[C",

    "903",     "oOC[C",

    "905",     "oOCo [CRC, Timeout, Serial Overrun, Alignment and Buffer Overrun Errors] `C",

    "907",     "[RAS performance object] pCopXqWsA (RAS) msC",

    "909",     "[s] su`C",

    "921",     "[WINS Server performance object] pCopWINS AAqTC",

    "923",     "[Unique Registrations/sec] O WINS A@ntvC",

    "925",     "[Group Registrations/sec] O WINS AsntvC",

    "927",     "[Total Number of Registrations/sec] O [Unique and Group registrations per sec] `MCoO WINS An`tvC",

    "929",     "[Unique Renewals/sec] O WINS A@stvC",

    "931",     "[Group Renewals/sec] O WINS AsstvC",

    "933",     "[Total Number of Renewals/sec] O [Unique and Group registrations per sec] `MCoO WINS As`tvC",

    "935",     "[Total Number of Releases/sec] O WINS AtvC",

    "937",     "[Total Number of Queries/sec] O WINS AdtvC",

    "939",     "[Unique Conflicts/sec] O WINS A@n/syPwOtvC",

    "941",     "[Group Conflicts/sec] O WINS AsnyPwOtvC",

    "943",     "[Total Number of Conflicts/sec] O [Unique and Group conflicts per sec] `MCoO WINS AJ`tvC",

    "945",     "oO [Successful Releases/sec] `",

    "947",     "oO [Failed Releases/sec] `",

    "949",     "oO [Successful Queries/sec] `",

    "951",     "oO [Failed Queries/sec] `",

    "953",     "Bz{e}`CoeboBz{C}`XC",

    "1001",     "oO Macintosh AFP AAC",

    "1003",     "oO MacFile Server wOjqC",

    "1005",     "e MacFile Server wOqC",

    "1007",     "MacFile Server OjqC",

    "1009",     "e MacFile Server OqC",

    "1011",     "esu MacFile Server u@qCoAeC",

    "1013",     "Psu MacFile Server u@qjCoA{C",

    "1015",     "eb MacFile Server }Cop]tN Macintosh }C",

    "1017",     "Pb MacFile Server }jCop]tN Macintosh }C",

    "1019",     "nJ MacFile Server CoiHXO_KX}{Q}aAw]wC",

    "1021",     "oOCC",

    "1023",     "oOCgJC",

    "1025",     "oOCqCoAL{C",

    "1027",     "CeCoAL{C",

    "1029",     "oOBzu@C",

    "1031",     "PBzu@jC",

    "1033",     "MacFile Server eCoAL{C",

    "1035",     "MacFile Server hCoAyp{C",

    "1051",     "AppleTalk qTw",

    "1053",     "osW Appletalk C]C",

    "1055",     "osW Appletalk Ce]C",

    "1057",     "osW Appletalk CC",

    "1059",     "osW Appletalk CeC",

    "1061",     "bosWBz@ DDP ] (H@p)C",

    "1063",     "osW Appletalk C DDP ]C",

    "1065",     "bosWBz@ AARP ] (H@p)C",

    "1067",     "osW Appletalk C AARP ]C",

    "1069",     "bosWBz@ ATP ] (H@p)C",

    "1071",     "osW Appletalk C ATP ]C",

    "1073",     "bosWBz@ NBP ] (H@p)C",

    "1075",     "osW Appletalk C NBP ]C",

    "1077",     "bosWBz@ ZIP ] (H@p)C",

    "1079",     "osW Appletalk C ZIP ]C",

    "1081",     "bosWBz@ RTMP ] (H@p)C",

    "1083",     "osW Appletalk C RTMP ]C",

    "1085",     "osWs ATP nDC",

    "1087",     "osWwL ATP pC",

    "1089",     "osW [ATP Exactly-once transaction responses per second] C",

    "1091",     "osW [ATP At-least-once transaction responses per second] C",

    "1093",     "osW [ATP transaction release packets per second] C",

    "1095",     "e AppleTalk OqC",

    "1097",     "osWJ]C",

    "1099",     "osW]]C",

    "1101",     "sos ATP nDC",

    "1103",     "osWX]C",

    "1111",     "gAqpC",

    "1113",     "oqC[`C",

    "1115",     "oqCC",

    "1117",     "oqCs[C",

    "1119",     "oqChI[C",

    "1121",     "oqbWeC",

    "1125",     "oqsyqWeC",

    "1127",     "oqhIyqWeC",

    "1151",     "qyt",

    "1153",     "oxqAquC",

    "1155",     "oxqAqmC",

    "1157",     "oxqAquebC",

    "1159",     "qmC",

    "1161",     "oxqXqtvC",

    "1163",     "oxqsJqtvC",

    "1165",     "ebqyA{C",

    "1167",     "oxqeAXqC",

    "1169",     "oxqeAsJqC",

    "1229",     "[Gateway Service For NetWare performance object] pCopq Gateway Server AC",

    "1231",     "[Client Service For NetWare object] pCopq]tvAnJsuC",

    "1233",     "[Packet Burst Read NCP Count/sec] O [NetWare Core Protocol] nD [Packet Burst Read] tvC[Packet Burst] O@iHWiqTwC",

    "1235",     "[Packet Burst Read Timeouts/sec] O NetWare A[~^AH NetWare As [Burst Read Request] tvC",

    "1237",     "[Packet Burst Write NCP Count/sec] O [NetWare Core Protocol] nD [Packet Burst Write] tvC[Packet Burst] O@iHWiqTwC",

    "1239",     "[Packet Burst Write Timeouts/sec] O NetWare A[~^AH NetWare As [Burst Write Request] tvC",

    "1241",     "[Packet Burst IO/sec] O [Packet Burst Read NCPs/sec]  [Packet Burst Write NCPs/sec] `XC",

    "1243",     "s NetWare 2.x psu NetWare 2.x AC",

    "1245",     "s NetWare 3.x psu NetWare 3.x AC",

    "1247",     "s NetWare 4.x psu NetWare 4.x AC",

    "1261",     "[Logon Total] ]tqW@s}nJBnJBAnJB\nJnJC",

    "1301",     "[Server Work Queues performance object] pCopCCC",

    "1303",     "[Queue Length] Oeo CPU Au@CCpGCj 4 BzCoOYpAO@qC",

    "1305",     "[Active Threads] Oo CPU eu@AnDACt|qNoCB~u@eCoOo CPU YpAO@qC",

    "1307",     "[Available Threads] Oo CPU eu@nDACA|AFAC",

    "1309",     "C@nDbA|Q 'u@'A~AC CPU O@iu@W[BzvCoOo CPU iu@YpCsW[AAMinFreeWorkItems nCb [Blocking Queue] o|@sC",

    "1311",     "C@nDbA|Q 'u@'A~AC CPU O@iu@W[BzvC CPU Su@iA|VO CPU @Qu@CpWiW[AA 'MaxWorkItems'  'MinFreeWorkItems' nCb [Blocking Queue] o|@sC",

    "1313",     "C@nDbA|Q 'u@'A~AC CPU O@iu@W[BzvCjsW[AA 'MaxWorkItems' nCb [Blocking Queue] o|@sC",

    "1315",     "[Current Clients] Oo CPU ebAYpCA|Dot CPU JCb [Blocking Queue] o|@sC",

    "1317",     "Aqo CPU WtvCoiHAL{C",

    "1319",     "Aeo CPU WtvCoiHAL{C",

    "1321",     "Abo CPU WPetvCoiHAL{C",

    "1323",     "[Read Operations/sec] OAbo CPU WtvCoiHP_A L{Cb [Blocking Queue] oO 0C",

    "1325",     "[Read Bytes/sec] OAbo CPU WtvCoiHP_AL{C",

    "1327",     "[Write Operations/sec] OAbo CPU WgJtvCoiHP_AL{Cb [Blocking Queue] oO 0C",

    "1329",     "[Write Bytes/sec] OAbo CPU WgJtvCoiHP_AL{C",

    "1331",     "[Total Bytes/sec] OAbo CPU WgJtvCoiHP_AL{C",

    "1333",     "[Total Operations/sec]OAbo CPU WgtvCoiHP_A L{Cb [Blocking Queue] oO 0C",

    "1335",     "[DPCs Queued/sec] OC{Is (DPC) [JBz DPC CtvC(DPC O@_Auv_nCC) CBzv DPC CCopp DPC [JCtvAO DPC Cop|[tHC",

    "1337",     "[DPC Rate] O{Is (DPC) bBzwp[JBz DPC CtvC(DPC O@_Auv_nCC) CBzv DPC CCopp DPC [JO DPC Copu[AOC",

    "1343",     "[Total DPCs Queued/sec] OqWBz{Is (DPC) [Jthe DPCBz DPC CXtvC(DPC O@_Auv_nCC) CBzv DPC CCopp DPC [JCtvAO DPC CObqWBz [DPCs Queued/sec] `MHBzCop|[tHC",

    "1345",     "[Total DPC Rate] OqWBz{Is (DPC) bBzwp[JBz DPC CXtvC(DPC O@_Auv_nCC) CBzv DPC CC.opp DPC [JCtvAO DPC CObqWBz [DPC Rate] `MHBzCopu[AOC",

    "1351",     "[% Registry Quota In Use] Oet [Total Registry Quota Allowed] CopueAOC",

    "1361",     "NtD`jqOtmApC",

    "1363",     " VLM %jp",

    "1365",     "oOeBz{ VLM OjpAOC",

    "1367",     "oOBz{ VLM OypeqCoOBz{{bBz{ VLM OjC",

    "1369",     "oOeiHQtmBz{ VLM OjpC`N\jtmionpA]OqC",

    "1371",     "oOeBz{w{ie VLM OjpAOC",

    "1373",     "oOBz{{bw{i VLM OjAOC",

    "1375",     "oOetw{i VLM OjpAOC",

    "1377",     "oOt{bw{i VLM OjAOC",

    "1379",     "oOetw{i VLM OjpAOC",

    "1381",     "[Available KBytes] ObqWiOq (H KB p)COMksOAiORO[`COzA MSDN / Windows  Server 2003 Resource Kit tMn`C",

    "1383",     "[Available MBytes] ObqWiOq (H MB p)COMksOAiORO[`COzA MSDN / Windows  Server 2003 Resource Kit tMn`C",

    "1401",     "[Avg. Disk Queue Length] ObCgnDC",

    "1403",     "[Avg. Disk Read Queue Length] ObCnDC",

    "1405",     "[Avg. Disk Write Queue Length] ObCgJnDC",

    "1407",     "[% Committed Bytes In Use] OMemory\\Committed Bytes Memory\\Commit Limit CCommitted memory OOAwQOdbABQg^C{ijpMwCpGjA{i|eAo|C) opueAOC",

    "1409",     "[Full Image performance object] pAqWBz{v}pCFull Image pM Image pPAuOW@Cb Full Image AW]tJ|WCb Image uWC",

    "1411",     "[Creating Process ID] OoBz{Bz{ IDCBz{L{iwAHoLkAOBz{C",

    "1413",     "oOBz{oX I/O @tvCoppBz{ I/O A]AAm I/OC",

    "1415",     "oOBz{oXgJ I/O @tvCoppBz{ I/O A]AAm I/OC",

    "1417",     "oOBz{oXgJ I/O @tvCoppBz{ I/O A]AAm I/OC",

    "1419",     "oOBz{oXO]OgJ I/O @tvAp@CoppBz{ I/O A]AAm I/OC",

    "1421",     "oOBz{q I/O @tvCoppBz{ I/O A]AAm I/OC",

    "1423",     "oOBz{q I/O @gJtvCoppBz{ I/O A]AAm I/OC",

    "1425",     "oOBz{q I/O @gJtvCoppBz{ I/O A]AAm I/OC",

    "1427",     "oOBz{oeDBz I/O @tvApCoppBz{ I/O A]AAm I/OC",

    "1451",     " Print Queue pC",

    "1453",     "qW{bCLCwCLu@C",

    "1455",     "CLCCCLC",

    "1457",     "W{bCLCzL GDI CLXC",

    "1459",     "ebCLCu@C",

    "1461",     "eoxL (}NX) C",

    "1463",     "oxLj (}NX) C",

    "1465",     "ebCLChuwBzu@C",

    "1467",     "qW{bCLChuwBzu@jC",

    "1469",     "qW{bCLC [i] ~`C",

    "1471",     "qW{bCLC [N] ~`C",

    "1473",     "qW{bCLCu@~`C",

    "1475",     "qW{bsoxCLAnDsMIs`C",

    "1477",     "qW{bLCLAnDN@L[JoxAIs`C",

    "1479",     "[Working Set - Private] u@jpAOCou@uoBz{ABMLBz{@C",

    "1481",     "[Working Set - Shared] u@jpAOCou@iHMLBz{@C@u@@weBz{bC",

    "1483",     "[% Idle Time] ibmC",

    "1485",     "[Split IO/Sec] io I/Os  I/O tvCI/O iOnDjpjA@ I/O LkBzAOiC",

    "1501",     "oiC Job BzpC",

    "1503",     "[Current % Processor Time] b Job Bz{{XC",

    "1505",     "[Current % User mode Time] b Job Bz{b{XC",

    "1507",     "[Current % Kernel mode Time]  b Job Bz{bSv{XC",

    "1509",     "[This Period mSec - Processor] bu@AJob Bz (O@)A]AQ_Ap Job C",

    "1511",     "[This Period mSec - User mode] bu@Ab Job Bz (O@)A]AQ_Ap Job C",

    "1513",     "[This Period mSec - Kernel mode]  bu@Ab Job Bz (O@)A]AQ_Ap Job C",

    "1515",     "[Pages/Sec]  Job Bz{~tvC",

    "1517",     "[Process Count - Total] p Job Bz{A]Aw_Bz{C",

    "1519",     "[Process Count - Active] p Job Bz{C",

    "1521",     "[Process Count - Terminated] p Job ]HW_Bz{C",

    "1523",     "[Total mSec - Processor] b Job AJob Bz (O@)A]AQ_Ap Job C",

    "1525",     "[Total mSec - User mode] b Job AJob Bzb (O@)A]AQ_Ap Job C",

    "1527",     "[Total mSec - Kernel mode] b Job AJob Bzb (O@)A]AQ_Ap Job C",

    "1549",     "[% Job object Details]  Job Bz{TC",

    "1537",     "[Received Packet Too Big] OWLwjp]C",

    "1539",     "[Received Membership Query] Ods]C",

    "1541",     "[Received Membership Report] Ois]C",

    "1543",     "[Received Membership Reduction] Os]C",

    "1545",     "[Received Router Solicit] OnD]C",

    "1547",     "[Received Router Advert] O]C",

    "1551",     "[Received Neighbor Solicit] OnDF]C",

    "1553",     "[Received Neighbor Advert] OF]C",

    "1555",     "[Sent Packet Too Big] OeFWLwjp]C",

    "1557",     "[Sent Membership Query] OeFds]C",

    "1559",     "[Sent Membership Report] OeFis]C",

    "1561",     "[Sent Membership Reduction] OeFs]C",

    "1563",     "[Sent Router Solicit] OeFnD]C",

    "1565",     "[Sent Router Advert] OeF]C",

    "1567",     "[Sent Neighbor Solicit] OeFnDF]C",

    "1569",     "[Sent Neighbor Advert] OeFF]C",

    "1747",     "% Idle Time OABzm",

    "1749",     "% C1 Time OBzb C1 CqmAC% C1 Time OBzm`lCC1 CqmA|BzHeAt^ACDq % C1 AC",

    "1751",     "% C2 Time OBzb C2 CqmAC% C2 Time Bzm`lCC2 CqmA|BzHteCC2 qA_ C1 OCqAMACDq C2 AC",

    "1753",     "% C3 Time OBzb C3 CqmAC% C3 Time Bzm`lCBzb C3 CqmAALk@PCC3 qA_ C2 OCqAMACDq C3 AC",

    "1755",     "C1 Transitions/sec O CPU iJ C1 CmAtCCPU bmiJ C1 AAb_ooACopedtAAHdjC",

    "1757",     "C2 Transitions/sec O CPU iJ C2 CmAtCCPU bmiJ C2 AAb_ooACopedtAAHdjC",

    "1759",     "C3 Transitions/sec O CPU iJ C3 CmAtCCPU bmiJ C3 AAb_ooACopedtAAHdjC",

    "1761",     "hp ",

    "1763",     "bO (FreeBytes + AllocatedBytes)",

    "1765",     "Od}` (]teUd)",

    "1767",     "ReservedBytes hCqW@eUd",

    "1769",     "iMWO (]teUd)",

    "1771",     "iMWj 1k ",

    "1773",     "1/C@tm (]ttm)",

    "1775",     "1/C@iO (]t)",

    "1777",     "Od}eUd",

    "1779",     "tmPit (|)",

    "1781",     "Ctmq",

    "1783",     "Ciq",

    "1785",     "p 1k Ctmqjp (]t)",

    "1787",     "p 1k Ciqjp (]t)",

    "1789",     " 1-8k Ctmqjp",

    "1791",     " 1-8k Ciqjp",

    "1793",     "WL 8k Ctmqjp",

    "1795",     "WL 8k Ciqjp",

    "1797",     "Ctmq (]t)",

    "1799",     "Ciq (]t)",

    "1801",     "`",

    "1803",     "@jpj",

    "1805",     "(FreeBytes / CommittedBytes) *100",

    "1807",     "(VirtualBytes / ReservedBytes) * 100",

    "1809",     "C",

    "1847",     "End Marker";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\cs\perfh005.ini ===
"3",     "Objekt sledovn vkonu systmu obsahuje tae, kter se vztahuj k vce instancm soust procesoru v potai. ",

    "5",     "Objekt sledovn vkonu pamti obsahuje tae, kter popisuj chovn fyzick i virtuln pamti potae. Fyzick pam je velikost pamti s nhodnm pstupem v potai. Virtuln pam se skld z msta ve fyzick pamti a na disku. ada ta pamti sleduje strnkovn, co je pesun strnek obsahujcch kd a data mezi diskem a fyzickou pamt. Nadmrn strnkovn, kter naznauje nedostatek pamti, pravdpodobn zpsob opodn, kter ovlivn vechny systmov procesy.",

    "7",     "% asu procesoru je procento doby, bhem kter procesor zpracovv podproces, kter nen neinn. Hodnota je vypotna odetenm doby neinnosti procesu ve vzorkovac period, od hodnoty dlky trvn periody. (Kad procesor m neinn proces, kter je provdn v ppad, e nen pipraven dn jin proces.) Tento ukazatel je primrnm indiktorem aktivity procesoru a zobrazuje prmrn as zaneprzdnn procesoru (v procentech) ve vzorkovac period.",

    "9",     "% celkovho asu DPC je prmrn procento doby, po kterou vechny procesory pijmaj a zpracovvaj pozdren voln procedur soutem DPC (Deferred Procedure Calls). (Voln DPC jsou peruen s ni prioritou ne maj standardn peruen.) Jedn se o souet hodnoty tae Procesor: % asu DPC vech procesor v potai, vydlen potem procesor. ta Systm: % celkem asu DPC je soust tae Systm: % celkem vhradnho asu, protoe voln DPC jsou provdna ve vyhrazenm reimu. Voln DPC jsou sledovna oddlen a nejsou soust sledovn peruen. Tento ta zobrazuje prmrnou dobu zaneprzdnn jako procento periody vzorkovn.",

    "11",     "ta Operace ten soubor/s je celkov rychlost vydvn dost o systmov ten souboru vem zazenm v potai, vetn dost o ten ze systmov mezipamti soubor. Hodnota je mena potem operac ten. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn.  ",

    "13",     "ta Operace zpisu soubor/s je celkov rychlost vydvn dost o systmov zpis souboru vem zazenm v potai, vetn dost o zpis do systmov mezipamti soubor. Hodnota je mena potem operac zpisu. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn.",

    "15",     "ta dic souborov operace/s je celkov rychlost vydvn dost o systmov operace se soubory, kter nejsou ani ten ani zpisy, jako napklad dosti o systmov dic operace a dosti o informace o charakteristice nebo stavu zazen. Jedn se o opan ta k tai Systm: Datov souborov operace/s a m se potem operac za sekundu. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn. ",

    "17",     "ta Bajty ten soubor/s je celkov rychlost ten bajt na zklad dost o systmov ten soubor pro vechna zazen v potai, vetn ten ze systmov mezipamti soubor. Hodnota je mena potem bajt za sekundu. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn.  ",

    "19",     "ta Bajty zpisu soubor/s je celkov rychlost zpisu bajt na zklad dost o systmov zpis soubor pro vechna zazen v potai, vetn zpis do systmov mezipamti soubor. Hodnota je mena potem bajt za sekundu. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn.  ",

    "21",     "ta Bajty ovldn soubor/s je celkov rychlost penosu bajt pro vechny systmov operace se soubory, kter nejsou ani ten ani zpisy, jako napklad dosti o systmov dic operace a dosti o informace o charakteristice nebo stavu zazen. Hodnota se m potem bajt. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn. ",

    "23",     "ta % celkem asu peruen je prmrn procento doby, po kterou vechny procesory pijmaj a zpracovvaj hardwarov peruen bhem vzorkovacch period, kde hodnota je pmm ukazatelem aktivity zazen, generujcch peruen. Jedn se o souet hodnot ta % asu peruen vech procesor v potai, vydlen potem procesor. Voln DPC jsou sledovna oddlen a nejsou soust sledovn peruen. Tato hodnota nepmo uruje aktivitu zazen generujcch peruen, jako napklad systmov asova, my, ovladae disku, datov komunikan linky, sov karty a dal perifern zazen. ",

    "25",     "ta Bajty k dispozici zobrazuje velikost fyzick pamti (v bajtech), kter je k dispozici pro pidlen procesu nebo pro pouit systmem. Velikost je urena soutem velikost pamti v spornm reimu (v mezipamti), voln pamti  a v seznamech vynulovan pamti. pln vysvtlen sprvce pamti naleznete v kapitole MSDN and/or the System Performance and Troubleshooting Guide (Prvodce vkonem a odstraovnm pot MSDN a systmu) v sad Windows Server 2003 Resource Kit.",

    "27",     "ta Sven bajty je velikost sven virtuln pamti (v bajtech). Sven pam je fyzick pam, pro kterou bylo ve strnkovacch souborech vyhrazeno msto pro ppad zptnho zpisu obsahu pamti na disk. Na kadm fyzickm disku me bt jeden nebo vce strnkovacch soubor. Tento ta zobrazuje pouze posledn zjitnou hodnotu, nejedn se o prmr. ",

    "29",     "ta Chyby strnek/s udv prmrn poet chyb strnek za sekundu. Hodnota je udvna v potu chyb strnek za sekundu, protoe v kad chybn operaci dochz k chyb pouze jedn strnky. Tento ta zahrnuje jak hardwarov chyby (vyadujc pstup k disku), tak softwarov chyby (v ppad, e je chybn strnka nalezena jinde ve fyzick pamti). Vtina procesor zpracuje velk poet softwarovch chyb bez nsledk. Hardwarov chyby vyadujc pstup na disk vak mohou zpsobit vznamn zpodn.",

    "31",     "ta Mez sven je velikost virtuln pamti, kterou lze svit bez nutnosti zvtit strnkovac soubor. Hodnota je udvna v bajtech. (Sven pam je fyzick pam, pro kterou bylo ve strnkovacm souboru vyhrazeno msto. Na kad logick jednotce me bt jeden strnkovac soubor.) Pi zvten strnkovacho souboru je zvena i mez sven. Tento ta zobrazuje pouze posledn zjitnou hodnotu, nejedn se o prmr.  ",

    "33",     "ta Zpisy kopi/s obsahuje poet chyb strnek zpsobench pokusy o zpis, kter byly provedeny zkoprovnm strnky odnkud z fyzick pamti. Jedn se o sporn zpsob sdlen dat, protoe strnky jsou koprovny pouze v ppad, e je do nich zapsno. V opanm ppad je strnka sdlena. Tento ta obsahuje poet kopi bez ohledu na poet strnek zkoprovanch kadou operac.",

    "35",     "ta Chyby pevodu stavu/s je rychlost, jakou jsou chyby strnek vyeeny obnovenm strnek, kter byly pouvny jinm procesem sdlejcm danou strnku nebo byly na seznamu zmnnch i neinnch strnek nebo byly v okamiku vskytu chyby strnky zapisovny na disk. Strnky byly obnoveny bez dal aktivity disku. Chyby pevodu stavu jsou potny v potu chyb. Protoe pi kad operaci dojde k chybm pouze na jedn strnce, je tato hodnota tak rovna potu chyb strnek.",

    "37",     "ta Chyby mezipamti/s obsahuje poet chyb, k nim dojde, jestlie nen hledan strnka nalezena v systmov mezipamti soubor a je nutno ji nast z pamti (softwarov chyba) nebo z disku (hardwarov chyba). Systmov mezipam soubor je oblast fyzick pamti, kde jsou uloeny nedvno pouit strnky dat aplikac. Aktivita mezipamti je spolehliv ukazatel vtiny vstupn-vstupnch operac aplikac. Tento ta obsahuje poet chyb bez ohledu na poet chyb strnek, k nim dolo v kad operaci.",

    "39",     "ta Chyby nulovch poadavk/s obsahuje poet chyb strnek, k jejich vyeen je nezbytn vynulovan strnka. Vynulovan strnky (strnky, jejich pedchoz data byla pepsna nulami) jsou soust bezpenostnch funkc systmu Windows. Jejich pouit brn procesm vidt data uloen pedchozmi procesy v pamti. Systm spravuje seznam vynulovanch strnek, kter urychluje jejich zpracovn. Tento ta obsahuje poet chyb bez ohledu na poet natench strnek z dvodu vyeen chyby. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn. ",

    "41",     "ta Strnky/s obsahuje poet strnek tench z disku nebo zapisovanch na disk, kter maj vyeit hardwarov chyby strnek. Tento ta je navren jako hlavn ukazatel chyb zpsobujcch opoovn celho systmu. Jedn se o souet hodnot ta Pam\\Vstupn strnky/s a Pam\\Vstup strnek/s. Hodnota je udvna potem strnek, lze ji tedy porovnvat s dalmi poty strnek (napklad Pam\\Chyby strnek/s) bez pevdn hodnot. ta sleduje strnky naten z dvodu vyeen chyb systmov mezipamti soubor (obvykle se jedn o dosti aplikac) i soubor pamti nemapovanch v mezipamti.",

    "43",     "ta ten strnek/s je rychlost ten z disku pi een chyb strnek. Zobrazuje poet operac ten bez ohledu na poet strnek natench bhem kad operace. K chybm strnek dochz, jestlie proces odkazuje na strnku ve virtuln pamti, kter se nenachz v pracovn sad nebo jin sti fyzick pamti a je nutn ji nast z disku. Tento ta je primrn indiktor chyb, kter zpsobuj zpodn systmu. Zahrnuje operace ten pi een chyb v mezipamti systmu soubor (obvykle vydanch aplikacemi) a v namapovanch souborech pamti, kter nejsou uloeny do mezipamti. Porovnnm hodnot ta Pam\\ten strnek/s a Pam\\Vstup strnek/s urte prmrn poet strnek petench bhem kad operace.",

    "45",     "ta Dlka fronty procesoru obsahuje poet podproces umstnch ve front procesoru.  Na rozdl od ta disku, tento ta zobrazuje pouze dokonen podprocesy, nikoli sputn podprocesy.  I v potach s vce procesory je jedin fronta pro vyuit asu procesoru. Pokud m pota vce podproces. Je tedy nutn podlit tuto hodnotu potem procesor obsluhujcm danou pracovn zt. Dlka fronty trvale men ne 10 podproces na jeden procesor je v zvislosti na pracovn zti normln pijateln.",

    "47",     "Stav podprocesu je okamit stav podprocesu.  Stav 0 zna Inicializovn, 1 Pipraven, 2 Sputn, 3 Na ad, 4 Ukonen, 5 ekajc, 6 Pechodn, 7 Neznm. Sputn podproces pouv procesor; podproces na ad se ho prv chyst pout. Pipraven podproces chce pout procesor ale mus na nj ekat, nebo prv nen dn voln. Pechodn podproces ek na njak prostedek, aby se mohl spustit. Nap. ek na naten strnky z disku pro dan zsobnk sputn. ekajc podproces neme vyut procesor, protoe ek na dokonen operace periferie nebo na uvolnn njakho prostedku.",

    "49",     "ta Vstup strnek/s obsahuje poet strnek zapsanch na disk z dvodu uvolnn msta ve fyzick pamti. Strnky jsou zapsny zpt na disk pouze v ppad, e jsou ve fyzick pamti zmnny, take pravdpodobn obsahuj data a ne kd. Vysok poet vstup strnek je pravdpodobn zpsoben nedostatkem pamti. Systm v ppad nedostatku pamti zape na disk dal strnky a uvoln tak pam. Hodnota je udvna potem strnek, lze ji tedy porovnvat s dalmi poty strnek bez pevdn hodnot.",

    "51",     "ta Zpisy strnek/s obsahuje poet zpis strnek na disk z dvodu uvolnn msta ve fyzick pamti. Strnky jsou zapsny zpt na disk pouze v ppad, e jsou ve fyzick pamti zmnny, take pravdpodobn obsahuj data a ne kd. Tento ta sleduje operace zpisu bez ohledu na poet strnek zapsanch pi kad operaci. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn.  ",

    "53",     "Objekt sledovn vkonu Prohlee obsahuje tae mc rychlost vskytu oznmen, vt a dalch penos Prohlee.",

    "55",     "Ohlen server/s je mra, jak asto se servery tto domny ohlaovaly na dan server.",

    "57",     "ta Bajty strnkovanho fondu obsahuje poet bajt strnkovanho fondu, co je oblast pamti systmu (fyzick pam pouit operanm systmem) uren pro objekty, kter lze zapsat na disk, nejsou-li pouvny. Hodnota tae Pam\\Bajty strnkovanho fondu je vypotvna jinm zpsobem ne hodnota tae Proces\\Bajty nestrnkovho fondu, take se nemus rovnat hodnot tae Proces\\Bajty strnkovanho fondu\\_Celkem. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn.",

    "59",     "ta Bajty nestrnkovanho fondu obsahuje poet bajt nestrnkovanho fondu, co je oblast pamti systmu (fyzick pam pouit operanm systmem) uren pro objekty, kter nelze zapsat na disk, ale mus po celou dobu vyhrazen zstat ve fyzick pamti. Hodnota tae Pam\\Bajty nestrnkovanho fondu je vypotvna jinm zpsobem ne hodnota tae Proces\\Bajty nestrnkovanho fondu, take se nemus rovnat hodnot tae Proces\\Bajty nestrnkovanho fondu\\_Celkem. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn.  ",

    "61",     "ta Vyhrazen strnkovanho fondu obsahuje poet dost o vyhrazen msta ve strnkovanm fondu, co je oblast pamti systmu (fyzick pam pouit operanm systmem) uren pro objekty, kter lze zapsat na disk, nejsou-li pouvny. Hodnota je mena v potu voln s dostmi o vyhrazen msta bez ohledu na velikost vyhrazenho msta. Tento ta zobrazuje pouze posledn zjitnou hodnotu, nejedn se o prmr.",

    "63",     "ta Rezidentn bajty strnkovanho fondu obsahuje aktuln velikost strnkovanho fondu (v bajtech), co je oblast pamti systmu (fyzick pam pouit operanm systmem) uren pro objekty, kter lze zapsat na disk, nejsou-li pouvny. Pro strnkovan a nestrnkovan fondy je pouita fyzick pam, take pli velk fond sniuje dostupnou pam pro procesy. Tento ta zobrazuje pouze posledn zjitnou hodnotu, nejedn se o prmr. ",

    "65",     "ta Vyhrazen nestrnkovanho fondu obsahuje poet dost o vyhrazen msta v nestrnkovanm fondu, co je oblast pamti systmu (fyzick pam pouit operanm systmem) uren pro objekty, kter nelze zapsat na disk, ale mus po celou dobu vyhrazen zstat ve fyzick pamti. Hodnota je mena v potu voln s dostmi o vyhrazen msta bez ohledu na velikost vyhrazenho msta. Tento ta zobrazuje pouze posledn zjitnou hodnotu, nejedn se o prmr.",

    "67",     "ta Celkem bajt/s je souet hodnot Bajty rmc/s a Bajty datagram/s. Jedn se o celkovou mru bajt, odeslanch nebo pijatch pomoc st danm protokolem, ale potaj se pouze bajty v rmcch (t.j. paketech), kter obsahuj data.",

    "69",     "ta Celkem bajt kdu systmu obsahuje poet bajt kdu operanho systmu, kter lze strnkovat, aktuln uloench ve virtuln pamti. Jedn se o mru velikosti fyzick pamti pouit operanm systmem, kterou lze zapsat na disk v ppad, e nen pouvna. Hodnota je urena soutem bajt obsaench v souborech Ntoskrnl.exe, Hal.dll, spoutcch ovladach a v systmech soubor natench programy Ntldr a Osloader. Tento ta neobsahuje kd, kter mus zstat ve fyzick pamti a nelze jej zapsat na disk. Tento ta zobrazuje pouze posledn zjitnou hodnotu, nejedn se o prmr. ",

    "71",     "ta Rezidentn bajty kdu systmu obsahuje poet bajt kdu operanho systmu, kter lze zapsat na disk v ppad, e nen pouvn, aktuln uloench ve fyzick pamti. Hodnota je soust tae Pam\\Celkem bajt kdu systmu, kter obsahuje i kd operanho systmu na disku. ta Pam\\Rezidentn bajty kdu systmu (a Pam\\Celkem bajt kdu systmu) nezahrnuje kd, kter mus zstat ve fyzick pamti a nelze jej zapsat na disk. Tento ta zobrazuje pouze posledn zjitnou hodnotu, nejedn se o prmr.",

    "73",     "ta Celkem bajt systmovch ovlada obsahuje poet bajt strnkovan virtuln pamti aktuln pouit ovladai zazen. (Strnkovanou pam lze zapsat na disk, jestlie nen pouvna.) Hodnota zahrnuje fyzickou pam (ta Pam\\Rezidentn bajty systmovch ovlada) a kd a data strnkovan na disku. ta je soust tae Pam\\Celkem bajt kdu systmu. Tento ta zobrazuje pouze posledn zjitnou hodnotu, nejedn se o prmr.  ",

    "75",     "ta Rezidentn bajty systmovch ovlada obsahuje poet bajt strnkovan fyzick pamti pouit ovladai zazen. Jedn se o pracovn sadu (oblast fyzick pamti) ovlada. Hodnota je soust tae Pam\\Celkem bajt systmovch ovlada, kter tak zahrnuje pam ovlada uloenou na disk. dn z ta Pam\\Rezidentn bajty systmovch ovlada ani Pam\\Celkem bajt systmovch ovlada nezahrnuje pam, kterou nelze zapsat na disk.",

    "77",     "ta Rezidentn bajty systmov mezipamti udv velikost strnkovatelnho kdu operanho systmu v mezipamti systmu. Hodnota obsahuje pouze aktuln fyzick strnky a neobsahuje dn strnky virtuln pamti, kter aktuln nejsou rezidentn. Jeho hodnota je rovna hodnot Mezipam systmu ve Sprvci loh, V dsledku toho me bt tato hodnota men ne skuten velikost virtuln pamti pouvan mezipamt systmu soubor. Tato hodnota je soust tae Pam\\Rezidentn bajty kdu systmu, kter reprezentuje vechny strnkovateln kdy operanho systmu aktuln pouvan fyzickou pamt. Tento ta zobrazuje pouze posledn zjitnou hodnotu, nejedn se o prmrnou hodnotu. ",

    "79",     "ta Ohlen domny/s je mra, jak asto se domna ohlaovala v sti.",

    "81",     "Pakety hlasovn/s je rychlost pijmn paket hlasovn prohlee touto pracovn stanic.",

    "83",     "Zpisy do zsuvky poty/s je rychlost, s jakou byly zprvy spn pijmny do zsuvky poty.",

    "85",     "dosti seznamu server/s je rychlost, s jakou se dosti o zskn seznamu prohlecch server zpracovvaly na tto pracovn stanici.",

    "87",     "Objekt sledovn vkonu mezipamti se skld z ta sledujcch systmovou mezipam soubor, co je oblast fyzick pamti, v n se ukldaj nedvno pouit data na nejdel monou dobu tak, aby bylo mono k datm pistupovat bez nutnosti st je z disku. Protoe aplikace vtinou pouvaj mezipam, lze sledovnm mezipamti analyzovat vstupn-vstupn operace aplikac. Pi dostatku pamti me velikost mezipamti rst, pi nedostatku pamti se vak mezipam me zmenit natolik, e se stane neefektivn.",

    "89",     "ta Mapovn dat/s je frekvence, se kterou systm soubor, jako napklad NTFS, mapuje strnku souboru do systmov mezipamti soubor z dvodu peten strnky.",

    "91",     "Synchronn mapovn dat/s je frekvence, se kterou systm soubor, jako je NTFS nebo HPFS, mapuje strnku souboru do systmov mezipamti tak, aby naetl strnku, a pokud strnka nen v hlavn pamti, pok na jej naten.",

    "93",     "Asynchronn mapovn dat/s je frekvence, se kterou systm soubor, jako je NTFS nebo HPFS, mapuje strnku souboru do systmov mezipamti tak, aby naetl strnku, a pokud strnka nen v hlavn pamti, nepok na jej naten.",

    "95",     "Zsahy mapovn dat je percentuln mra mapovn dat v systmov mezipamti soubor, kter bylo mono vyeit bez nutnosti naten strnky z disku, protoe strnka ji byla ve fyzick pamti.",

    "97",     "Dren mapovn dat/s je frekvence mapovn dat v systmov mezipamti soubor, kter zpsobilo dren strnky v hlavn pamti, co je zpravidla ppravn akce ped zpisem do souboru na disk. Bhem dren se fyzick adresa strnky v hlavn pamti a virtuln adresa v mezipamti nezmn.",

    "99",     "ten dren/s je frekvence ten dat do systmov mezipamti soubor jako pprava pro zpis tchto dat zpt na disk. Strnky ten tmto zpsobem jsou dreny v pamti a do ukonen ten. Bhem dren se fyzick adresa strnky v mezipamti nezmn.",

    "101",     "Synchronn ten dren/s je frekvence ten dat do systmov mezipamti soubor jako pprava pro zpis tchto dat zpt na disk. Strnky naten tmto zpsobem jsou dreny v pamti a do ukonen ten. Systm soubor nezsk kontrolu, dokud je strnka drena v mezipamti, zvlt pokud se mus pistupovat na disk k naten strnky. Bhem dren se fyzick adresa strnky v mezipamti nezmn.",

    "103",     "Asynchronn ten dren/s je frekvence ten dat do systmov mezipamti soubor jako pprava pro zpis tchto dat zpt na disk. Strnky naten tmto zpsobem jsou dreny v pamti a do ukonen ten. Systm soubor zsk kontrolu okamit, i kdy se mus pistupovat na disk k naten strnky. Bhem dren se fyzick adresa strnky nezmn.",

    "105",     "Zsahy ten dren je procento dost o ten dren, kter jsou uspokojeny ze systmov mezipamti soubor, t.j. nevyaduj ten disku pro poskytnut pstupu ke strnce v mezipamti. Bhem dren se fyzick adresa v mezipamti nezmn. Tuto metodu k zskvn dat z mezipamti pouv pesmrova LAN, stejn jako Server LAN pro mal penosy. Tuto metodu tak obvykle pouvaj diskov systmy soubor.",

    "107",     "ten kopi/s je frekvence ten ze strnek systmov mezipamti soubor, kter se skld z koprovn dat z mezipamti do vyrovnvac pamti aplikace. Tuto metodu k zskvn dat z mezipamti pouv pesmrova LAN, stejn jako Server LAN pro mal penosy. Tuto metodu tak obvykle pouvaj diskov systmy soubor.",

    "109",     "Synchronn ten kopi/s je frekvence ten ze strnek systmov mezipamti soubor, kter se skld z koprovn dat z mezipamti do vyrovnvac pamti aplikace. Systm soubor nezsk kontrolu, dokud nen operace koprovn dokonena, ani kdy se mus pistoupit na disk z dvodu naten strnky.",

    "111",     "Asynchronn ten kopi/s je frekvence ten ze strnek systmov mezipamti soubor, kter se skld z koprovn dat z mezipamti do vyrovnvac pamti aplikace. Aplikace zsk kontrolu okamit, dokonce i kdy se mus pistoupit na disk z dvodu naten strnky.",

    "113",     "Zsahy ten kopi je procento dost o ten kopie, kter jsou uspokojeny tenm z mezipamti, t.j. nebylo nutn ten disku pro poskytnut pstupu ke strnce mezipamti. ten kopie je operace ten souboru, kter je vyeena zkoprovnm strnky mezipamti do vyrovnvac pamti aplikace. Tuto metodu k zskvn daj mezipamti pouv pesmrova LAN, stejn jako Server LAN pro mal penosy. Tuto metodu tak obvykle pouvaj diskov systmy soubor.",

    "115",     "ten MDL/s je frekvence ten ze systmov mezipamti soubor, kter pouvaj pro pstup k datm seznam MDL (Memory Descriptor List). Seznam MDL obsahuje fyzick adresy vech strnek, kter se penej a mohou tedy vyuvat zazen hardwaru DMA (Direct Memory Access) pro uskutenn koprovn. Server LAN pouv tuto metodu pro velk penosy odeslan serverem.",

    "117",     "Synchronn ten MDL/s je frekvence ten ze systmov mezipamti soubor, kter pouvaj pro pstup k datm seznam MDL (Memory Descriptor List). Seznam MDL obsahuje fyzick adresy vech penench strnek, k nim je tak pm pstup (DMA: Direct Memory Access). Pokud nen penen strnka v hlavn pamti, voln mus pokat, a se strnka vyhled a nate z disku.",

    "119",     "Asynchronn ten MDL/s je frekvence ten ze systmov mezipamti soubor, kter pouvaj pro pstup k datm seznam MDL (Memory Descriptor List). Seznam MDL obsahuje fyzick adresy vech penench strnek, k nim je tak pm pstup (DMA: Direct Memory Access). Pokud nen penen strnka v hlavn pamti, voln programu aplikace nebude ekat, ne se strnka vyhled a nate z disku.",

    "121",     "Zsahy ten MDL je procento dost o ten seznamu MDL (Memory Descriptor List), kter jsou uspokojeny tenm ze systmov mezipamti soubor, t.j., nebylo nutn ten disku pro poskytnut pstupu ke strnce mezipamti.",

    "123",     "Dopedn ten/s je frekvence ten ze systmov mezipamti soubor, kdy mezipam zjist sekvenn pstup k souboru. Dopedn ten umouje penos dat ve vtch blocch, ne poaduje aplikace, m se sn reie na pstup.",

    "125",     "Rychl ten/s je frekvence ten strnek ze systmov mezipamti soubor, kter obchzej nainstalovan systm soubor a zskaj data pmo z mezipamti. dosti souborovho I/O obvykle vyvolaj pslun systm soubor, aby zskaly data ze souboru, ale tento zpsob umouje pm pstup k datm mezipamti bez zapojen systmu soubor, pokud jsou data v mezipamti. A i kdy data v mezipamti nejsou, uet se jedno vyvoln systmu soubor.",

    "127",     "Synchronn rychl ten/s je frekvence ten ze systmov mezipamti soubor, kter obchzej nainstalovan systm soubor a zskaj data pmo z mezipamti. dosti souborovho I/O obvykle vyvolaj pslun systm soubor, aby zskaly data ze souboru, ale tento zpsob umouje pm pstup k datm mezipamti bez zapojen systmu soubor, pokud jsou data v mezipamti. A i kdy data v mezipamti nejsou, uet se jedno vyvoln systmu soubor. Pokud nejsou data v mezipamti, mus dost (voln programu aplikace) pokat, ne se data natou z disku.",

    "129",     "Asynchronn rychl ten/s je frekvence ten ze systmov mezipamti soubor, kter obchzej nainstalovan systm soubor a zskaj data pmo z mezipamti. dosti souborovho I/O obvykle vyvolaj pslun systm soubor, aby zskaly data ze souboru, ale tento zpsob umouje pm pstup k datm mezipamti bez zapojen systmu soubor, pokud jsou data v mezipamti. A i kdy data v mezipamti nejsou, uet se jedno vyvoln systmu soubor. Pokud nejsou data v mezipamti, nemus dost (voln programu aplikace) ekat, ne se data natou z disku, a zsk okamit kontrolu.",

    "131",     "ta Nespn pstupy k prostedkm rychlho ten/s je frekvence nespnch pstup k mezipamti, zpsoben nedostatkem dostupnch prostedk k vyzen dosti.",

    "133",     "Neumonn rychl ten/s je frekvence pokus voln funkce API (Application Program Interface) pro obejit systmu soubor a zskn dat z mezipamti, kter nakonec nemohly bt vyzeny jinak, ne vyvolnm systmu soubor.",

    "135",     "Dopsn opodnch zpis/s je frekvence zapisovn na disk podprocesem mezipamti provdjcm opodn zapisovn. Opodn zapisovn je proces aktualizace disku po zmn strnky v pamti tak, aby aplikace provdjc zmnu souboru nemusela ekat na dokonen zpisu na disk a mohla pokraovat. Bhem kad operace zpisu na disk lze penst vce strnek najednou.",

    "137",     "Strnky opodnch zpis/s je frekvence zapisovn na disk podprocesem mezipamti provdjcm opodn zapisovn. Opodn zapisovn je proces aktualizace disku po zmn strnky v pamti tak, aby aplikace provdjc zmnu souboru nemusela ekat na dokonen zpisu na disk a mohla pokraovat. Bhem jedn operace zpisu na disk lze penst vce strnek najednou.",

    "139",     "Dopsn dat/s je frekvence dopisovn obsahu systmov mezipamti soubor na disk, zpsoben dost o dopsn nebo dost o pm zpis souboru (write-through). Bhem kad operace dopsn lze penst vce strnek najednou.",

    "141",     "Dopsn dat strnek/s je poet strnek, kter byly ze systmov mezipamti soubor dopsny na disk z dvodu dosti o dopsn nebo dost o pm zpis souboru (write-through). Bhem kad operace dopsn lze penst vce strnek najednou.",

    "143",     "% uivatelskho asu je procento asu procesoru, strven v uivatelskm reimu. (Uivatelsk reim je omezen reim uren pro aplikace, podsystmy prosted a integrln podsystmy. Naopak privilegovan reim je uren pro sousti operanho systmu a umouje pm pstup k hardwaru a k cel pamti. Operan systm pepn podprocesy aplikac do privilegovan reimu v ppad, e poaduj sluby operanho systmu.) Tento ta zobrazuje prmrn as innosti jako procento intervalu vzorkovn. ",

    "145",     "ta %privilegovanho asu udv procentuln dobu spoutn kdu procesem ve vhradnm reimu.  Pokud je volna sluba systmu Windows, je asto sputna ve vhradnm reimu pro zskn pstupu k datm vyhrazenm systmu. Tato data jsou chrnna proti pstupu vi podprocesm sputnm v uivatelskm reimu. Systm me bt voln explicitn nebo implicitn, napklad pi chybch strnek nebo peruench. Na rozdl od nkterch dvjch operanch systm, systm Windows pouv pro ochranu podsystmu krom tradin ochrany uivatele a vhradnch reim tak hranice proces. Prce proveden systmem Windows msto aplikace se pravdpodobn krom vhradnho asu procesu zobraz v jinch procesech podsystmu. ",

    "147",     "Pepnut kontextu/s je celkov rychlost pepnn z jednoho podprocesu do dalho na vech procesorech. K pepnut kontextu dojde v ppad, e se sputn podproces dobrovoln vzd procesoru, jeho vykonvn je pepnuto na pipraven proces s vy prioritou nebo proces pepn mezi uivatelskm a privilegovanm reimem, jestlie vyaduje pouit systmov sluby. Hodnota je dna soutem hodnot tae Podproces\\Pepnut kontextu/s pro vechny podprocesy sputn na vech procesorech a je mena v potech pepnut. tae pepnut kontextu existuj pro objekty Systm a Podproces. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn. ",

    "149",     "ta Peruen/s udv prmrnou rychlost (ppady/s), jakou procesor pijmal a obsluhoval hardwarov peruen. Nezahrnuje voln pozdrench procedur, kter jsou potna zvl. Tato hodnota je nepmm indiktorem innosti zazen, kter generuj peruen, napklad systmovch hodin, myi, ovlada disku, datovch komunikanch linek, karet sovho rozhran (NIC) a dalch perifernch zazen. Tato zazen obvykle odeslaj procesoru poadavky na peruen pi dokonen lohy nebo pokud vyaduj jeho innost. Spoutn bnch podproces je pozastaveno. Systmov hodiny obvykle peruuj procesor kadch 10 milisekund a vytv tak pozad pro innost peruen. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn.",

    "151",     "Voln systmu/s je celkov rychlost voln systmovch rutin operanho systmu vemi procesy bcmi v potai. Tyto rutiny provdj veker zkladn plnovac a synchronizan innost v potai a poskytuj pstup k negrafickm zazenm, sprv pamti a sprv prostoru nzv. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn. ",

    "153",     "Vpln TLB rovn 1/s je frekvence chyb, kter nastanou pi odkazu do pamti, jeho poloka v tabulce strnek PTE (Page Table Entry) nen ve vyrovnvac pamti TLB (Translation Lookaside Buffer). Nkter potae zpracuj tuto chybu softwarem, kter nate PTE do TLB a zvt hodnotu tohoto tae.",

    "155",     "Vpln TLB rovn 2/s je frekvence chyb, kter nastanou pi odkazu do pamti, jeho poloka v tabulce strnek PTE (Page Table Entry) nen ve vyrovnvac pamti TLB (Translation Lookaside Buffer), a ani v n nen strnka, kter PTE obsahuje. Nkter potae zpracuj tuto chybu softwarem, kter nate PTE do TLB a zvt hodnotu tohoto tae.",

    "157",     "% uivatelskho asu je procento ubhl doby, kterou strvily podprocesy danho procesu vkonem kdu v uivatelskm reimu. V uivatelskm reimu se spoutj aplikace subsystmy prosted a integrln subsystmy. Kd sputn v uivatelskm reimu neme naruit integritu vkonnho kdu systmu Windows, jdra, ani ovlada zazen. Na rozdl od dvjch operanch systm pouv systm Windows ochranu subsystm pomoc ohranien proces nad rmec tradin ochrany uivatelskho a privilegovanho reimu. To znamen, e prce, kterou vykonv systm Windows pro danou aplikaci, se me projevit v jinch procesech subsystmu, nejenom v privilegovanm ase danho procesu.",

    "159",     "ta %privilegovanho asu udv procentuln dobu spoutn kdu procesem ve vhradnm reimu. Pokud je volna sluba systmu Windows, je asto sputna ve vhradnm reimu pro zskn pstupu k datm vyhrazenm systmu. Tato data jsou chrnna proti pstupu vi podprocesm sputnm v uivatelskm reimu. Systm me bt voln explicitn nebo implicitn, napklad pi chybch strnek nebo peruench. Na rozdl od nkterch dvjch operanch systm, systm Windows pouv pro ochranu podsystmu krom tradin ochrany uivatele a vhradnch reim tak hranice proces. Prce proveden systmem Windows msto aplikace se pravdpodobn krom vhradnho asu procesu zobraz v jinch procesech podsystmu.",

    "161",     "Vyslen server/s je mra dost vyhledvn server, kter byly pracovn stanic zpracovny.",

    "163",     "Vyslen domn/s je mra dost vyhledvn domn, kter byly pracovn stanic zpracovny.",

    "165",     "Vyslen ostatnch/s je mra dost vyhledvn, kter byly pracovn stanic zpracovny a kter nebyly dostmi vyhledvn server a domn.",

    "167",     "Minut ohlen server je poet ohlen server, kter nebyly zpracovny z dvodu konfiguranch i alokanch omezen.",

    "169",     "Minut datagram zsuvek poty je poet datagram zsuvek poty, skartovanch z dvodu konfiguranch i alokanch omezen.",

    "171",     "Minut dost seznamu server je poet pijatch dost pro zskn seznamu vyhledvacch server, kter pracovn stanice nemohla zpracovat.",

    "173",     "Vrchol virtulnch bajt je maximln poet bajt prostoru virtulnch adres, kter proces nkdy pouil. Pouit prostoru virtulnch adres jet nutn neznamen odpovdajc pouit bu disku nebo strnek hlavn pamti. Virtuln prostor je vak konen a jeho plinm pouvnm me proces omezit monost natat knihovny.",

    "175",     "Virtuln bajty je stvajc velikost (v bajtech) prostoru virtulnch adres, kter proces pouv. Pouit prostoru virtulnch adres jet nutn neznamen odpovdajc pouit bu disku nebo strnek hlavn pamti. Virtuln prostor je vak konen a jeho plin pouvn me omezit schopnost procesu natat knihovny.",

    "177",     "Chyby strnek/s je mra chyb strnek podproces, sputnch v danm procesu. Chyba strnky nastane, kdy se podproces odkazuje na strnku virtuln pamti, kter nen v jeho pracovn sad v hlavn pamti. Chyba strnky nezpsob naten strnky z disku, pokud je dan strnka v seznamu dostupn pamti a proto obsaen v hlavn pamti, nebo pokud je pouvna jinm procesem, se kterm je strnka sdlen.",

    "179",     "Vrchol pracovn sady je maximln poet bajt pracovn sady procesu v prbhu sledovan doby. Pracovn sada je sada strnek pamti, do kterch nedvno nahldly podprocesy danho procesu. Pokud je voln pam potae nad danou mez, ponechaj se strnky procesu v pracovn sad, i kdy se nepouvaj. Kdy voln pam potae klesne pod danou mez, jsou strnky z pracovnch sad vyazovny. Pi jejich poteb jsou strnky soft-chybovny zpt do pracovn sady ped tm, ne hlavn pam opust.",

    "181",     "Pracovn sada je stvajc poet bajt v pracovn sad danho procesu. Pracovn sada je sada strnek pamti, ke kterm nedvno pistupovaly podprocesy danho procesu.  Pokud je voln pam potae nad danou mez, ponechaj se strnky procesu v pracovn sad, i kdy se nepouvaj. Kdy voln pam potae klesne pod danou mez, jsou strnky z pracovnch sad vyazovny. Pi jejich poteb jsou strnky soft-chybovny zpt do pracovn sady ped tm, ne hlavn pam opust.",

    "183",     "Hodnota Vrchol bajt strnkovacho souboru je maximln velikost virtuln pamti (v bajtech), kter tento proces rezervoval pro pouit ve strnkovacch souborech. Strnkovac soubory se pouvaj k ukldn strnek pamti, kter proces pouv a kter nejsou obsaeny v jinch souborech. Strnkovac soubory jsou sdleny vemi procesy a nedostatek msta ve strnkovacch souborech me zamezit tomu, aby mohly jin procesy pidlovat pam. V ppad, e strnkovac soubor neexistuje, uvd tento ta maximln velikost virtuln pamti, kterou proces rezervoval pro pouit ve fyzick pamti.",

    "185",     "Hodnota Bajty strnkovacch soubor je aktuln velikost virtuln pamti (v bajtech), kter tento proces rezervoval pro pouit ve strnkovacch souborech. Strnkovac soubory se pouvaj k ukldn strnek pamti, kter proces pouv a kter nejsou obsaeny v jinch souborech. Strnkovac soubory jsou sdleny vemi procesy a nedostatek msta ve strnkovacch souborech me zamezit tomu, aby mohly jin procesy pidlovat pam. V ppad, e strnkovac soubor neexistuje, uvd tento ta aktuln velikost virtuln pamti, kterou proces rezervoval pro pouit ve fyzick pamti.",

    "187",     "Nesdlen bajty je stvajc poet bajt pamti, kter tento proces alokoval, a kter nemohou bt sdleny s jinmi procesy.",

    "189",     "ta % asu procesoru udv procentuln dobu, po kterou vechny podprocesy procesu pouvaj procesor pro spoutn instrukc. Instrukce je zkladn jednotkou spoutn v potai, podproces je objekt, kter spout instrukce, a proces je objekt vytvoen pi sputn programu. ta sleduje i sputn kd, kter zpracovv nkter peruen hardwaru nebo podmnky pro depee.",

    "191",     "ta % asu procesoru udv procentuln dobu, po kterou vechny podprocesy procesu pouvaj procesor pro spoutn instrukc. Instrukce je zkladn jednotkou spoutn v potai, podproces je objekt, kter spout instrukce, a proces je objekt vytvoen pi sputn programu. ta sleduje i sputn kd, kter zpracovv nkter peruen hardwaru nebo podmnky pro depee.",

    "193",     "% uivatelskho asu je procento ubhl doby, kterou strvil tento podproces vkonem kdu v uivatelskm reimu. V uivatelskm reimu se spoutj aplikace subsystmy prosted a integrln subsystmy. Kd sputn v uivatelskm reimu neme naruit integritu vkonnho kdu systmu Windows NT, jdra, ani ovlada zazen. Na rozdl od dvjch operanch systm pouv systm Windows NT ochranu subsystm pomoc ohranien proces nad rmec tradin ochrany uivatelskho a privilegovanho reimu. Tyto procesy subsystmu poskytuj pdavnou ochranu. To znamen, e prce, kterou vykonv systm Windows NT pro danou aplikaci, se me projevit v jinch procesech subsystmu, nejenom v privilegovanm ase danho procesu.",

    "195",     "ta %privilegovanho asu udv procentuln dobu spoutn kdu procesem ve vhradnm reimu.  Pokud je volna sluba systmu Windows, je asto sputna ve vhradnm reimu pro zskn pstupu k datm vyhrazenm systmu. Tato data jsou chrnna proti pstupu vi podprocesm sputnm v uivatelskm reimu. Systm me bt voln explicitn nebo implicitn, napklad pi chybch strnek nebo peruench. Na rozdl od nkterch dvjch operanch systm, systm Windows pouv pro ochranu podsystmu krom tradin ochrany uivatele a vhradnch reim tak hranice proces. Prce proveden systmem Windows msto aplikace se pravdpodobn krom vhradnho asu procesu zobraz v jinch procesech podsystmu.",

    "197",     "Pepnut kontextu/s je mra pepnn z jednoho podprocesu do dalho. Pepnn podproces me nastat bu uvnit jedinho procesu, nebo ve vce procesech. Pepnut podprocesu je zpsobeno bu jednm podprocesem, dajcho jin o informaci, nebo podprocesem, kter je pedem vyprazdovn jinm podprocesem s vy prioritou a kter se brzy spust. Na rozdl od dvjch operanch systm pouv systm Windows NT ochranu subsystm pomoc ohranien proces nad rmcem tradin ochrany Uivatelskho a Vhradnho reimu. Tyto procesy subsystmu poskytuj pdavnou ochranu i aplikacm. To znamen e prce, kterou vykonv systm Windows NT pro danou aplikaci, se me projevit v jinch procesech subsystmu, nejenom ve Vhradnm asu danho procesu. Pepnut do procesu subsystmu zpsob jedno Pepnut kontextu podprocesu aplikace. Pepnut zpt zpsob dal Pepnut kontextu podprocesu subsystmu.",

    "199",     "Aktuln dlka fronty disku je poet dost, kter jet nejsou diskem vyzeny v dob sbrn dat pro sledovn vkonu. K tmto dostem pat i dosti o slubu v okamiku kolekce. Dan snmek je okamit, nikoliv stedn bhem uritho asovho intervalu. Diskov zazen s vce disky mohou mt vce aktivnch dost v danm ase, ale ostatn simultnn dosti musej na vyzen ekat. Tento ta me zobrazit pechodn vysok i nzk dlky fronty, ale pokud je diskov jednotka souvisle vytena pak je pravdpodobn, e bude hodnota stle vysok. Zpodn pro vyzen dost je mrn dlce tto fronty mnus poet disk v jednotce. Tento rozdl byl ml mt prmr mn ne 2, aby byl dobr vkon.",

    "201",     "ta % asu disku je procento ubhl doby, po kterou vybran diskov jednotka vyizovala dosti o ten a zpisy.",

    "203",     "ta % asu ten disku je procento ubhl doby, po kterou vybran diskov jednotka vyizovala dosti o ten.",

    "205",     "ta % asu zpisu disku je procento ubhl doby, po kterou vybran diskov jednotka vyizovala dosti o zpisy.",

    "207",     "Stedn doba disku/penos je as v sekundch pro prmrn diskov penos.",

    "209",     "Stedn doba disku/ten je prmrn as v sekundch pro ten dat z disku.",

    "211",     "Stedn doba disku/zpis je prmrn as v sekundch pro zpis dat na disk.",

    "213",     "Penosy disku/s je mra tecch a zapisovacch operac na disku.",

    "215",     "ten z disku/s je mra tecch operac na disku.",

    "217",     "Zpisy na disk/s je mra zapisovacch operac na disku.",

    "219",     "Bajt disku/s je mra bajt penesench z disku a na disk bhem tecch a zapisovacch operac.",

    "221",     "Bajty ten z disku/s je mra bajt penesench z disku z disku bhem tecch operac.",

    "223",     "Bajty zapisovn na disk/s je mra bajt penesench na disk bhem zapisovacch operac.",

    "225",     "Stedn poet bajt disku/penos je prmrn poet bajt penesench na disk a z disku bhem tecch a zapisovacch operac.",

    "227",     "Stedn poet bajt disku/ten je prmrn poet bajt penesench z disku bhem tecch operac.",

    "229",     "Stedn poet bajt disku/zpis je prmrn poet bajt penesench na disk bhem zapisovacch operac.",

    "231",     "Objekt sledovn vkonu procesu obsahuje tae sledujc sputn aplikace a systmov procesy. Vechny podprocesy danho procesu sdlej stejn prostor adres a maj pstup ke stejnm datm.",

    "233",     "Objekt sledovn vkonu procesu obsahuje tae sledujc chovn procesu. Proces je zkladn objekt, kter v procesoru vykonv instrukce. Kad sputn proces m alespo jeden podproces.",

    "235",     "Objekt sledovn vkonu fyzickho disku obsahuje tae sledujc jednotku pevnho nebo nevmnnho disku. Disky se pouvaj pro ukldn soubor, program a strnkovanch dat. Disk se te pi zskvn poloek a zapisuje se na nj pi jejich zmnch. Hodnoty ta fyzickho disku tvo souet hodnot pro logick disky (i oddly), na kter je fyzick disk rozdlen.",

    "237",     "Objekt sledovn vkonu logickho disku obsahuje tae sledujc logick oddly jednotek pevnho nebo nevmnnho disku. Program Sledovn vkonu se na disky odkazuje pomoc jejich psmen jednotek, nap. C.",

    "239",     "Objekt sledovn vkonu procesoru obsahuje tae sledujc aktivitu procesoru. Procesor je soust potae vykonvajc aritmetick a logick vpoty, inicializuje operace na perifernch zazench a vykonv (spout) programy v potai. V potai me bt vce procesor. Pro kad procesor existuje instance objektu procesoru.",

    "241",     "% celkem asu procesoru je prmrn procento asu, kter strv vechny procesory systmu pi vykonvn innch podproces. ta je hlavn uren pro sledovn aktivity procesoru v potai s vce procesory. Hodnota se skld z hodnot ta Proces: % asu procesoru pro vechny procesory a je vydlena potem procesor. Hodnota je vypotna setenm asu, po kter vechny procesory provdj podproces neinnho procesu v kadm intervalu vzorkovn, odetenm tto hodnoty od hodnoty 100% a vydlenm rozdlu potem procesor. (Na kadm procesoru je sputn neinn proces spotebovvajc cykly procesoru v ppad, e nen ke sputn pipraven dn jin proces.) Napklad hodnota 50% na vceprocesorovm systmu znamen, e vechny procesory jsou zaneprzdnny po polovinu doby intervalu vzorkovn. Tento ta zobrazuje prmrn procento vyuit zskan z interval vzorkovn. Hodnota je urena sledovnm asu, po kter nebyla sluba aktivn, a odetenm tto hodnoty od hodnoty 100%. ",

    "243",     "% celkem uivatelskho asu je prmrn procento asu vech procesor mimo dobu neinnosti, strven v uivatelskm reimu. Hodnota je urena soutem hodnot ta Procesor: % uivatelskho asu pro vechny procesory vydlenm potem procesor. Soutem ta Systm: % celkem uivatelskho asu a Systm: % celkem asu procesoru je hodnota % celkem asu procesoru, ale ne vdy na 100%. (Uivatelsk reim je omezen reim uren pro aplikace, podsystmy prosted a integrln podsystmy. Naopak privilegovan reim je uren pro sousti operanho systmu a umouje pm pstup k hardwaru a k cel pamti. Operan systm pepn podprocesy aplikac do privilegovan reimu v ppad, e poaduj sluby operanho systmu.) Tento ta zobrazuje prmrn as innosti jako procento intervalu vzorkovn. ",

    "245",     "% celkem privilegovanho asu je prmrn procento asu vech procesor mimo dobu neinnosti, strven v privilegovanm reimu (reimu jdra). Hodnota je urena soutem hodnot ta Procesor: % privilegovanho asu pro vechny procesory vydlenm potem procesor. Soutem ta Systm: % celkem uivatelskho asu a Systm: % celkem asu procesoru je hodnota % celkem asu procesoru, ale ne vdy na 100%. (Privilegovan reim je uren pro sousti operanho systmu a umouje pm pstup k hardwaru a k cel pamti. Naopak uivatelsk reim je omezen reim uren pro aplikace, podsystmy prosted a integrln podsystmy. Operan systm pepn podprocesy aplikac do privilegovan reimu v ppad, e poaduj sluby operanho systmu.) Tento ta zobrazuje prmrn as innosti jako procento intervalu vzorkovn. ",

    "247",     "ta Celkem peruen/s je celkov rychlost vzniku hardwarovch peruen, kter obdr a zpracuj vechny procesory v potai. Jedn se o souet hodnot ta Procesor: Peruen/s pro vechny procesory, vydlen potem procesor . Hodnota je udvna potem peruen za sekundu. ta neobsahuje voln DPC, kter jsou sledovna oddlen. Tato hodnota nepmo uruje aktivitu zazen generujcch peruen, jako napklad systmov asova, my, ovladae disku, datov komunikan linky, sov karty a dal perifern zazen. Tato zazen obvykle peru procesor pi dokonen lohy nebo pokud vyaduj as procesoru. Bn provdn podproces je pi peruen pozastaveno. Vtina systmovch hodin peru procesor kadch 10 milisekund a vytv tak pozad peruovn. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn. ",

    "249",     "Procesy je poet proces na potai v okamiku sbrn dat. Dan hodnota je okamit, nikoliv stedn bhem uritho asovho intervalu. Kad proces pedstavuje jeden bc program.",

    "251",     "Podprocesy je poet podproces na potai v okamiku sbrn dat. Dan hodnota je okamit, nikoliv stedn bhem uritho asovho intervalu. Podproces je zkladn vkonnou jednotkou, kter me vykonvat instrukce v procesoru.",

    "253",     "Udlosti je poet udlost na potai v okamiku sbrn dat. Dan hodnota je okamit, nikoliv stedn bhem uritho asovho intervalu. Udlost se pouv v ppad, e jeden i vce podproces chce synchronizovat vykonvn instrukc.",

    "255",     "Semafory je poet semafor na potai v okamiku sbrn dat. Dan hodnota je okamit, nikoliv stedn bhem uritho asovho intervalu. Podprocesy pouvaj semafor k zskn vhradnho pstupu ke strukturm dat, kter sdlej s dalmi podprocesy.",

    "257",     "Mutexy je poet signl mutex na potai v okamiku sbrn dat. Povimnte si, e dan hodnota je okamit, nikoliv stedn bhem uritho asovho intervalu. Podprocesy pouvaj mutex k zajitn vkonu urit sekce kdu pouze jednm podprocesem.",

    "259",     "Sekce je poet sekc na potai v okamiku sbrn dat. Dan hodnota je okamit, nikoliv stedn bhem uritho asovho intervalu. Sekce je st virtuln pamti, vytvoen procesem pro ukldn dat. Proces me tyto sekce sdlet s dalmi procesy.",

    "261",     "Objekt sledovn vkonu objektu obsahuje tae sledujc logick objekty v systmu, jako napklad procesy, podprocesy, mutexy a semafory. Tyto informace lze pout pro rozpoznn zbyten spoteby prostedk potae. Kad objekt vyaduje pam pro uloen zkladnch daj o danm objektu.",

    "263",     "Objekt sledovn vkonu pesmrovae obsahuje tae sledujc sov pipojen k jinm potam, kter pochzej z mstnho potae.",

    "265",     "Pijat bajty/s je mra bajt, kter pichz do pesmrovae ze st. Obsahuje vechna data aplikac i informace sovch protokol (jako nap. hlaviky paket).",

    "267",     "Pijat pakety/s je rychlost, se kterou pesmrova pijm pakety (t nazvan SMB - Server Message Blocks). Sov penosy jsou rozdleny do paket. Prmrn poet bajt pijatch v paketu se me zskat vydlenm Pijat bajty/s tmto taem. Nkter pijat pakety nemus obsahovat pchoz data, nap. potvrzen zpisu vykonanho pesmrovaem se pot mezi pijat pakety.",

    "269",     "ten strnkovanch bajt/s je mra, se kterou se pesmrova pokou st bajty pi odezv na chyby strnek. Chyby strnek jsou zpsobeny natnm modul (program a knihoven), minutm mezipamti (viz ten bajt mezipamti/s) i soubory, kter jsou pmo mapovny do prostoru adres aplikac (vlastnost systmu Windows pro dosaen vysokho vkonu).",

    "271",     "ten nestrnkovanch bajt/s jsou takov bajty ten pesmrovaem, jako je odezva na normln dosti soubor od aplikac, kdy jsou pesmrovny na pjem z jinho potae. Tento ta navc obsahuje dal metody ten pomoc st, jako nap. pojmenovan kanly a transakce. ta vak nezahrnuje informace o protokolech st, pouze data aplikac.",

    "273",     "ten bajt mezipamti/s je mra, se kterou pistupuj aplikace do systmov mezipamti soubor prostednictvm pesmrovae. Nkter dosti o data lze vydit natenm dat z mezipamti. dosti, kter nezashnou mezipam, zpsob chybu strnky (viz ten strnkovanch bajt/s).",

    "275",     "ten bajt st/s je mra, se kterou tou aplikace data pes s. K tomu dojde v ppad, e data nejsou nalezena v systmov mezipamti soubor a je nutn je nast ze st. Vydlenm tohoto sla hodnotou Pijat bajty/s lze zskat pomr aplikanch dat penench st (viz Pijat bajty/s).",

    "277",     "Bajty odeslan/s je mra, se kterou bajty opoutj pesmrova smrem do st. Obsahuje vechna data aplikac i informace sovch protokol (jako nap. hlaviky paket).",

    "279",     "Pakety odeslan/s je rychlost, s jakou odesl pesmrova pakety (t nazvan SMB - Server Message Blocks). Sov penosy jsou rozdleny do paket. Prmrn poet bajt penesench v paketu lze zskat vydlenm hodnoty Odeslan bajty/s tmto taem.",

    "281",     "Zpisy strnkovanch bajt/s je mra, se kterou se pesmrova pokou zapisovat zmnn bajty ve strnkch, kter aplikace pouvaj. Data program zmnn moduly (jako jsou nap. programy a knihovny) a nataen pomoc st jsou vystrnkovna, kdy nejsou poteba. Ostatn strnky vstupu pochzej ze systmov mezipamti soubor (viz Zpis bajt mezipamti/s).",

    "283",     "Zpisy nestrnkovanch bajt/s je mra, se kterou jsou bajty zapisovny pesmrovaem jako odezva na normln vstupy soubor od aplikac, kter jsou pesmrovny do jinho potae. Tento ta navc obsahuje dal metody zapisovn pomoc st, jako napklad pojmenovan kanly a transakce. ta vak nezahrnuje informace o sovch protokolech, pouze data aplikac.",

    "285",     "Zpisy bajt mezipamti/s je mra, se kterou aplikace v tomto potai zapisuj data do systmov mezipamti soubor prostednictvm pesmrovae. Data nemus opustit pota okamit, ale mohou bt pozdrena v mezipamti pro dal pravy ped odeslnm zpisu do st. Tato funkce et provoz st. Zde se pot kad zpis bajtu do mezipamti.",

    "287",     "Zpisy bajt do st/s je mra, s jakou aplikace zapisuj data pes s. K tomu dojde obejitm systmov mezipamti, jako napklad pro pojmenovan kanly i transakce, nebo bajty zapsala mezipam z dvodu uvolnn msta pro jin data. Vydlenm tohoto tae hodnotou Odeslan bajty/s lze zskat pomr dat zapsanch do st (viz Odeslan bajty/s).",

    "289",     "Operac ten/s je rychlost, se kterou aplikace daj pesmrova o data. Kad voln systmu soubor nebo podobn voln API (Application Program Interface) se pot jako jedna operace.",

    "291",     "Operac nhodnho ten/s pot mru nesekvennch ten pro jednotliv soubory. Pokud se te z disku pomoc uritho popisovae souboru a po nm nsleduje ten dalho bajtu, kter souvisle nensleduje ten pedchoz, pak se hodnota tohoto tae zv o jednu.",

    "293",     "ten paket/s je mra, se kterou jsou pakety pro ten vkldny do st. Pi kadm odesln paketu se dost o vzdlen ten dat je hodnota tohoto tae zvena o jednu.",

    "295",     "Velk ten/s je mra, se kterou tou aplikace data, kter pekrauj vce ne dvakrt sjednanou hodnotu vyrovnvac pamti serveru. Pli mnoho takovchto ten by mohlo zpsobit peten prostedk serveru. Hodnota tohoto tae se zv o jednu pi kadm ten. ta nepot pakety.",

    "297",     "Mal ten paket/s je mra, se kterou tou aplikace data, men ne jedna tvrtina sjednan hodnoty vyrovnvac pamti serveru. Plin poet by mohl indikovat pltvn vyrovnvacmi pammi serveru. Hodnota tohoto tae se zv o jednu pi kadm ten. ta nepot pakety.",

    "299",     "Operac zpisu/s je mra, se kterou aplikace odeslaj data do pesmrovae. Kad voln systmu soubor nebo podobn voln funkce rozhran API (Application Program Interface) se pot jako jedna operace.",

    "301",     "Operac nhodnho zpisu/s pot mru nesekvennch zpis pro jednotliv soubory. Pokud se zapisuje na disk pomoc uritho popisovae souboru a po nm nsleduje zpis dalho bajtu, kter souvisle nensleduje ten pedchoz, pak se hodnota tohoto tae zv o jednu.",

    "303",     "Zpisy paket/s je mra, se kterou jsou pakety pro zpis vkldny do st. Pokad, kdy se odele jeden paket se dost o vzdlen zpis dat, pak se hodnota tohoto tae zv o jednu.",

    "305",     "Velk zpisy/s je mra, se kterou zapisuj aplikace data, kter pekrauj vce ne dvakrt sjednanou hodnotu vyrovnvac pamti serveru. Pli mnoho takovchto zpis by mohlo zpsobit peten prostedk serveru. Hodnota tohoto tae se zv o jednu pi kadm zpisu. ta nepot pakety.",

    "307",     "Mal zpisy paket/s je mra, se kterou tou aplikace data men ne jedna tvrtina sjednan hodnoty vyrovnvac pamti serveru. Plin poet by mohl indikovat pltvn vyrovnvacmi pamtmi serveru. Hodnota tohoto tae se zv o jednu pi kadm zpisu. ta nepot pakety.",

    "309",     "ten zamtnuto/s je mra, s jakou server neme vydit dosti o neformtovan ten. Pro ten, kter jsou mnohem vt ne sjednan hodnota vyrovnvac pamti serveru, si pesmrova vyd neformtovan ten. Pokud je umonno, pak dovoluje penos dat bez pli popisnch informac protokolu pro kad paket. Aby se toho doshlo, mus server pozastavit ostatn dosti, take v ppad zaneprzdnn serveru je zpis zamtnut.",

    "311",     "Zpisy zamtnut/s je mra, s jakou server neme vydit dosti o neformtovan zpisy. Pro zpisy, kter jsou mnohem vt ne sjednan hodnota vyrovnvac pamti serveru, si pesmrova vyd neformtovan zpis. Pokud je umonn, pak dovoluje penos dat bez pli popisnch informac protokolu pro kad paket. Aby se toho doshlo, mus server pozastavit ostatn dosti, take v ppad zaneprzdnn serveru je zpis zamtnut.",

    "313",     "ta Chyby st/s udv etnost, s n dochz k zvanm neoekvanm chybm. Takovto chyby obvykle znamenaj vn problmy s komunikac pesmrovae a jednoho nebo vce server. Napklad chyba protokolu SMB (Server Manager Block) je chybou st. Poloka je zaznamenna do protokolu systmovch udlost a obsahuje podrobnosti.",

    "315",     "ta Relace serveru udv celkov poet objekt zabezpeen, kter pesmrova spravoval. Napklad pihlen na server, nsledovan sovm pstupem k tomu sammu serveru vytvo jedno pipojen, ale dv relace.",

    "317",     "Pipojovn serveru udv poet, kolikrt se musel pesmrova znovu pipojit na server, aby mohl vydit novou aktivn dost. Po del neinnosti je server zpravidla odpojen. Pesmrova nechv pipojen oteven na cca deset minut, i kdy mohou bt vechny vzdlen soubory mstn zaveny. Takovto neaktivn pipojen se nazvaj spc pipojen. Optovn pipojen jsou asov nron.",

    "319",     "ta Hlavn pipojen udv poet pipojen k serverm se sputnm pvodnm protokolem SMB MS-Net, vetn samotnho protokolu MS-Net a protokol pro systmy Xenix a Vax.",

    "321",     "ta Pipojen Lan Manager 2.0 udv poet pipojen k serverm Lan Manager 2.0 vetn server LMX.",

    "323",     "ta Pipojen Lan Manager 2.1 udv poet pipojen k serverm Lan Manager 2.1 vetn server LMX.",

    "325",     "ta Pipojen Windows NT udv poet pipojen k potam se systmem Windows 2000 nebo starm.",

    "327",     "Odpojen serveru udv poet, kolikrt dan server odpojil pesmrova. Viz tak Pipojovn serveru.",

    "329",     "Ztracen relace serveru udv poet aktivnch relac, kterm vyprela lhta a nemohou pokraovat, nebo chyb odezva ze vzdlenho serveru.",

    "331",     "Objekt sledovn serveru obsahuje tae, kter m komunikaci mezi mstnm potaem a st.",

    "333",     "Poet bajt, kter server pijal ze st. Indikuje zaneprzdnnost serveru.",

    "335",     "Poet bajt, kter server odeslal do st. Indikuje zaneprzdnnost serveru.",

    "337",     "Dvod ekn podprocesu se tk pouze ppadu, kdy je podproces v reimu ekn (viz Stav podprocesu.) M hodnotu 0 nebo 7, kdy podproces ek na Exekutivu, 1 i 8 pro volnou strnku, 2 i 9 pro strnku vstupu, 3 i 10 pro alokaci fondu, 4 i 11 pro zpodn vykonvn, 5 i 12 pro podmnku zadren, 6 i 13 pro uivatelskou dost, 14 pro pr udlost vysoko, 15 pro pr udlost nzko, 16 pro pijet LPC 17 pro odpov LPC, 18 pro virtuln pam, 19 pro strnku vstupu; 20 a ve nejsou zatm piazeny. Pry udlost se pouvaj pro komunikaci se zabezpeenmi subsystmy (viz Pepnut kontextu).",

    "339",     "% asu DPC je procento ubhl doby, kterou procesor strvil pijmnm a obsluhovnm pozdrench voln procedur (DPC - Deferred Procedure Call) v prbhu intervalu vzorkovn. (Voln DPC jsou peruen s ni prioritou ne standardn peruen.) ta je soust tae % privilegovanho asu, protoe voln DPC jsou provdna v privilegovanm reimu. Hodnoty ta jsou urovny oddlen a nejsou soust ta peruen. Tento ta zobrazuje prmrnou dobu zaneprzdnn jako procento intervalu vzorkovn. ",

    "341",     "Udv poet uzavench relac z dvodu pekroen parametru AutoDisconnect pro neinnost na danm serveru. Uruje, zda nastaven parametru AutoDisconnect pomh pi spoe prostedk.",

    "343",     "Udv poet relac uzavench z dvodu neoekvanch chybovch podmnek, nebo relac, kterm vyprel asov limit pro automatick odpojen a byly odpojeny bnm zpsobem.",

    "345",     "Odhlen relace je poet normln uzavench relac. ta je uiten pi interpretaci statistik Vyprel relace a Chybn relace -- umouje vpoty procentnch hodnot.",

    "347",     "Odpojen relace je poet relac, kter byly nucen odhleny. Me indikovat, kolik relac bylo nucen odhleno vlivem omezen pihlaovac doby.",

    "349",     "Chyby pihlen je poet chybnch pokus o pihlen na server. Me indikovat, e se pouvaj programy na hdn hesel pro naruen zabezpeen serveru.",

    "351",     "Udv poet selhn pi otevrn ze strany klient s chybou STATUS_ACCESS_DENIED. Me indikovat, e nkdo nhodn zkou pistupovat k souborm se snahou zskat nco, co nebylo dn zabezpeeno.",

    "353",     "Udv poet zamtnutch pstup k spn otevenm souborm. Me indikovat pokusy o pstup k souborm bez dn autorizace pro pstup.",

    "355",     "Udv poet zjitnch vnitnch chyb serveru. Neoekvan chyby obvykle indikuj problm se serverem.",

    "357",     "Udv poet ppad, kdy server odmtl blokovat bloky SMB, nebo nebyl dostaten poet volnch pracovnch poloek. Uruje, zda je poteba upravit parametry serveru MaxWorkItem nebo MinFreeWorkItems.",

    "359",     "Udv poet vrcench hodnot STATUS_DATA_NOT_ACCEPTED bhem indikan doby pjmu. Tento ppad nastv, kdy nen k dispozici dn pracovn poloka nebo neme bt alokovna k vyzen pchoz dosti. Uruje, zda je poteba upravit parametry serveru MaxWorkItems nebo InitWorkItems.",

    "361",     "Udv poet spnch otevracch pokus, vykonanch serverem pro dan klienty. To je uiten pro urovn mnostv souborovho I/O, k urovn reie operac, kter pouvaj cest a k urovn efektivnosti odemykn zmk.",

    "363",     "Udv poet soubor, kter jsou aktuln oteven na serveru. Uruje stvajc aktivitu serveru.",

    "365",     "Udv poet relac, kter jsou aktuln aktivn na serveru. Uruje stvajc aktivitu serveru.",

    "367",     "Udv poet vyhledvn soubor, kter jsou aktuln aktivn na serveru. Uruje stvajc aktivitu serveru.",

    "369",     "Udv poet bajt nestrnkovan pamti potae, kter server prv pouv. Me pomoci pi urovn hodnoty registru MaxNonpagedMemoryUsage.",

    "371",     "Udv poet alokac z nestrnkovanho fondu, kter selhaly. Indikuje, e fyzick pam potae je pli mal.",

    "373",     "Udv maximln poet bajt nestrnkovanho fondu, kter server nkdy ml a pouval. Indikuje, kolik fyzick pamti by ml pota mt.",

    "375",     "Udv poet bajt strnkovateln pamti potae, kter server prv pouv. Me pomoci pi urovn vhodnch hodnot parametru MaxPagedMemoryUsage.",

    "377",     "Udv poet alokac ze strnkovanho fondu, kter se nezdaily. Indikuje, e fyzick pam nebo strnkovac soubor potae jsou pli mal.",

    "379",     "Udv maximln poet bajt strnkovanho fondu, kter server nkdy alokoval. Indikuje dn velikosti strnkovacch soubor a fyzick pamti.",

    "381",     "Chybn alokace ohlen server/s je mra serverovch (i domnovch) ohlen, kter selhaly vlivem nedostatku pamti.",

    "383",     "Chybn alokace zsuvek poty udv poet ppad, kdy pijma datagram nealokoval vyrovnvac pam pro zpis do zsuvky poty uivatele.",

    "385",     "Chyby pjmu zsuvek poty indikuje poet zprv zsuvek poty, kter se nepijaly vlivem chybnho transportu.",

    "387",     "Chyby zpisu zsuvek poty udv celkov poet zprv zsuvek poty, kter byly spn pijaty, ale nebylo je mon zapsat do zsuvky poty.",

    "389",     "Bajty celkem/s je mra, se kterou pesmrova zpracovv bajty dat. Obsahuje veker data aplikac a soubor, i pdavn informace o protokolech, jako jsou nap. hlaviky paket.",

    "391",     "ta Datov souborov operace/s udv rychlost, jakou pesmrova zpracovv datov operace. Jedna operace by mla obsahovat mnoho bajt, protoe kad operace m urit nroky. innost tto cesty lze urit vydlenm hodnoty tae Bajty/s tmto taem, m zskte prmrn poet penesench bajt na jednu operaci.",

    "393",     "Aktuln pkazy pot poet dost smrem do pesmrovae, kter ekaj ve front na slubu. Pokud je toto slo mnohem vt ne poet karet sovch adaptr nainstalovanch v potai, pak existuje vn peten st() i serveru(), ke kterm se pistupuje.",

    "395",     "Udv poet bajt, kter server odeslal a pijal prostednictvm st. Tato hodnota poskytuje veobecnou indikaci toho, jak je server zaneprzdnn.",

    "397",     "ta % asu peruen udv procento doby, po kterou procesor pijm a obsluhuje hardwarov peruen bhem intervalu vzork. Tato hodnota je nepmm indiktorem innosti zazen, kter generuj peruen, napklad systmovch hodin, myi, ovlada disku, datovch komunikanch linek, karet sovho rozhran (NIC) a dalch perifernch zazen. Tato zazen obvykle odeslaj procesoru poadavky na peruen pi dokonen lohy nebo pokud vyaduj jeho innost. Spoutn bnch podproces je bhem peruen pozastaveno. Vtina systmovch hodin obvykle peruuje procesor kadch 10 milisekund a vytv tak pozad pro innost peruen. Bhem peruen je pozastaveno zpracovn bnch podproces. Tento ta zobrazuje prmrn as innosti jako procento intervalu vzorkovn.",

    "399",     "Objekt sledovn vkonu Sluby NWLink pro rozhran NetBIOS obsahuje tae sledujc penosov rychlosti a pipojen pomoc protokolu IPX. ",

    "401",     "Pakety/s je rychlost, kterou pesmrova zpracovv datov pakety.  Paket zpravidla obsahuje vce bajt. kme zpravidla, protoe kad paket obsahuje jet hlaviku protokolu. Efektivnost cesty se ur dlenm hodnoty bajty/s hodnotou tae. Tak urte prmrn poet bajt penench paketem. Mete tak dlit hodnotu tae hodnotou Operace/s. Tm zskte prmrn ,poet paket za operaci, neboli jinou mru efektivnosti.",

    "405",     "Bloky kontextu ve front za sekundu je rychlost, jakou maj bt pracovn bloky kontextu umstny ve front FSP a oekvat akci serveru.",

    "407",     "Datov souborov operace/s je celkov mra operac ten a zpisu na vech logickch discch v potai. Jedn se o opan ta tae Systm: dic souborov operace/s. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn. ",

    "409",     "ta % volnho msta udv v procentech volnou st z celkovho msta na vybran logick diskov jednotce.",

    "411",     "Voln megabajty udvaj v megabajtech nealokovan msto na diskov jednotce. Jeden megabajt = 1 048 576 bajt.",

    "413",     "Oteven pipojen je poet pipojen momentln otevench pro protokol.  ta zobrazuje pouze aktuln poet a neprovd prbn stn v ase.",

    "415",     "Pipojen napoprv je celkov poet pipojen kter byla spn vytvoena na prvn pokus. Jedn se o prbn souet.",

    "417",     "Pipojen opakovan je celkov poet pipojen kter byla vytvoena po opakovn pokusu. Opakovn probhne, pokud sele prvn pokus o pipojen. Jedn se o prbn souet.",

    "419",     "Mstn odpojen je poet odpojen relac, kter byla iniciovna mstnm potaem. Jedn se o prbn souet.",

    "421",     "Dlkov odpojen je poet odpojen relac, kter byla iniciovna vzdlenm potaem. Jedn se o prbn souet.",

    "423",     "Chyby propojen je poet pipojen, kter se ztratila kvli chyb linky. Jedn se o prbn souet.",

    "425",     "Chyby adaptru je poet pipojen, kter se ztratila kvli chyb adaptru. Jedn se o prbn souet.",

    "427",     "Pipojen s vyprenou relac je poet pipojen, kter se ztratila kvli uplynut asu pro relaci. Jedn se o prbn souet.",

    "429",     "Stornovan pipojen je poet pipojen, kter byla stornovna. Jedn se o prbn souet.",

    "431",     "Chyby vzdlench prostedk je poet pipojen, kter selhala kvli potm s prostedky nebo kvli jejich nedostatku na vzdlenm potai. Jedn se o prbn souet.",

    "433",     "Chyby  mstnch prostedk je poet pipojen, kter selhala kvli potm s prostedky nebo kvli jejich nedostatku na mstnm potai. Jedn se o prbn souet.",

    "435",     "Chyby nenalezen je poet pokus o pipojen, kter selhaly, protoe nebyl nalezen vzdlen pota. Jedn se o prbn souet.",

    "437",     "Chyby nenaslouchn je poet pipojen, kter byla odmtnuta, protoe vzdlen pota nenaslouchal poadavku na pipojen.",

    "439",     "Datagramy/s je rychlost, jakou pota zpracovv datagramy. ta zobrazuje souet odeslanch a pijatch datagram. Datagram je paket bez pipojen, jeho doruen na vzdlen pota nen zarueno.",

    "441",     "Bajty datagram/s je rychlost, jakou jsou bajty datagramu zpracovny potaem. ta zobrazuje souet odeslanch i pijatch bajt. Datagram je paket bez pipojen, jeho doruen na vzdlen pota nen zarueno.",

    "443",     "Odeslan datagramy/s je rychlost, jakou jsou datagramy odeslny z potae. Datagram je paket bez pipojen, jeho doruen na vzdlen pota nen zarueno.",

    "445",     "Odeslan bajty datagram/s je rychlost, jakou jsou bajty datagram odeslny z potae. Datagram je paket bez pipojen, jeho doruen na vzdlen pota nen zarueno.",

    "447",     "Pijat datagramy/s je rychlost, jakou jsou datagramy pijmny potaem. Datagram je paket bez pipojen, jeho doruen na vzdlen pota nen zarueno.",

    "449",     "Pijat bajty datagram/s je rychlost, jakou jsou bajty datagram pijmny potaem. Datagram je paket bez pipojen, jeho doruen na vzdlen pota nen zarueno.",

    "451",     "Pakety/s je rychlost, jakou pota zpracovv pakety. ta m hodnotu soutu potu odeslanch paket/s a potu pijatch paket/s. ta zahrnuje vechny zpracovan pakety: dc i datov pakety.",

    "453",     "Odeslan pakety/s je rychlost, jakou jsou pakety odeslny potaem. Potaj se vechny pakety odeslan potaem, tedy jak dc, tak datov pakety.",

    "455",     "Pijat pakety/s je rychlost, jakou jsou pakety pijmny potaem. Potaj se vechny pakety pijat potaem, tedy jak dc, tak datov pakety.",

    "457",     "Rmce/s je rychlost, jakou jsou datov rmce (nebo pakety) zpracovny potaem. ta zobrazuje souet odeslanch I pijatch datovch rmc. Potaj se pouze rmce (pakety), kter penej data.",

    "459",     "Bajty rmc/s je rychlost, jakou jsou datov bajty zpracovvny potaem. ta obsahuje souet odeslanch a pijatch bajt datovch rmc. Potaj se pouze rmce (pakety), kter penej data.",

    "461",     "Odeslan rmce/s je rychlost, jakou jsou datov rmce odeslny potaem. Potaj se pouze rmce (pakety), kter penej data.",

    "463",     "Odeslan bajty rmc/s je rychlost odesln datovch bajt potaem. Potaj se pouze rmce (pakety), kter penej data.",

    "465",     "Pijat rmce/s je rychlost pijmn datovch rmc potaem. Potaj se pouze rmce (pakety), kter penej data.",

    "467",     "Pijat bajty rmc/s je rychlost pijmn datovch bajt potaem. Potaj se pouze rmce (pakety), kter penej data.",

    "469",     "Rmce odeslan znovu/s je rychlost, jakou jsou znovu odeslny datov rmce (pakety) potaem. Potaj se pouze rmce (pakety), kter penej data.",

    "471",     "Bajty rmc odeslanch znovu/s je rychlost, jakou jsou znovu odeslny datov bajty potaem. Potaj se pouze bajty rmc (paket), kter penej data.",

    "473",     "Zamtnut rmce/s je mra zamtn datovch rmc. Potaj se pouze rmce (pakety), kter penej data.",

    "475",     "Zamtnut bajty rmc/s je mra zamtn datovch bajt. Potaj se pouze bajty datovch rmc (paket), kter penej data.",

    "477",     "Vypren odezvy je poet vypren tae T1.",

    "479",     "ta Vypren potvrzen je poet vypren tae T2.",

    "481",     "Maximln odeslac okno je maximln poet datovch bajt, kter budou odeslny ped eknm na potvrzen od vzdlenho potae.",

    "483",     "Stedn odeslac okno je prbn prmr datovch bajt, kter budou odeslny ped eknm na potvrzen od vzdlenho potae.",

    "485",     "Sloen potvrzen ve front/s je rychlost, jakou jsou do fronty zaazovna sloen potvrzen. Sloen potvrzen jsou potvrzen pijatch paket, kter je teba  pidat do nsledujcho paketu odeslanho na vzdlen pota.",

    "487",     "Vypren sloench potvrzen je poet, kolikrt nemohlo bt odeslno sloen potvrzen, protoe neexistoval dn odeslan paket pro odpovdajc vzdlen pota. Sloen potvrzen jsou potvrzen pijatch paket, kter je teba  pidat do nsledujcho paketu odeslanho na vzdlen pota. Pokud v asovm intervalu nen odesln dn paket, bude odesln potvrzovac paket a hodnota tohoto tae bude zvena.",

    "489",     "Objekt sledovn protokolu NWLink IPX obsahuje tae mc penos datagram pomoc protokolu IPX.",

    "491",     "Objekt sledovn protokolu NWLink SPX obsahuje tae mc penos datagram a pipojovn relac pomoc protokolu SPX.",

    "493",     "Objekt sledovn vkonu NetBEUI obsahuje tae sledujc aktivitu st menm penosu dat, kter odpovd standardu NetBIOS pro rozhran koncovho uivatele.",

    "495",     "Objekt sledovn vkonu prostedk rozhran NetBEUI obsahuje tae, kter sleduj vyuit vyrovnvac pamti protokolem NetBEUI.",

    "497",     "Vyuit maximum je maximln poet prostedk NetBEUI (vyrovnvacch pamt) vyuvanch v danm ase v libovolnm mst. Hodnota je uiten pro stanoven maximln velikosti poskytnutch prostedk. slo v zvorkch za nzvem prostedku slou pro identifikaci prostedku ve zprvch protokolu udlost.",

    "499",     "Vyuit sted je aktuln poet prostedk (vyrovnvacch pamt) pouvanch v danm okamiku. slo v zvorkch za nzvem prostedku slou pro identifikaci prostedku ve zprvch protokolu udlost.",

    "501",     "Poet vyerpn udv, kolikrt byly vyuity prostedky (vyrovnvac pamti). slo v zvorkch za nzvem prostedku slou pro identifikaci prostedku ve zprvch protokolu udlost.",

    "503",     "Objekt sledovn vkonu pipojen NBT obsahuje tae sledujc rychlosti odesln a pijmn bajt penench mez mstnm a vzdlenm potaem. Pipojen je ureno nzvem vzdlenho potae.",

    "505",     "Bajty pijat/s je rychlost, jako jsou bajty pijmny mstnm potaem prostednictvm pipojen vzdlenho potae pomoc protokolu NBT. Potaj se vechny bajty pijat mstnm potaem pes konkrtn jednotliv pipojen pomoc protokolu NBT.",

    "507",     "Bajty odeslan/s je rychlost, jakou jsou bajty odeslny mstnm potaem prostednictvm pipojen vzdlenho potae pomoc protokolu NBT. Potaj se vechny bajty odeslan mstnm potaem pes konkrtn jednotliv pipojen pomoc protokolu NBT.",

    "509",     "Celkem bajt/sec je rychlost, jako jsou bajty odeslny nebo pijmny mstnm potaem prostednictvm pipojen vzdlenho potae pomoc protokolu NBT. Potaj se vechny bajty odeslan nebo pijat potaem pes konkrtn jednotliv pipojen pomoc protokolu NBT.",

    "511",     "Objekt sledovn vkonu rozhran st obsahuje tae sledujc rychlosti odesln a pijmn bajt a paket pes pipojen TCP/IP. Obsahuje tak rzn tae chyb pipojen.",

    "513",     "ta Bajty celkem/s udv rychlost odesln a pjmn bajt pro kad sov adaptr, vetn rmcovacch znak. ta Sov rozhran\\Bajty celkem/s udv souet hodnot ta Sov rozhran\\Pijat bajty/s a Sov rozhran\\Odeslan bajty/s.",

    "515",     "ta Pakety/s je rychlost, jakou jsou pakety odeslny a pijmny sovm rozhranm.",

    "517",     "ta Pijat pakety/s je rychlost, jakou jsou pakety pijmny sovm rozhranm.",

    "519",     "ta Odeslan pakety/s je rychlost, jakou jsou pakety odeslny sovm rozhranm.",

    "521",     "Aktuln ka psma je odhad aktuln ky psma sovho rozhran v bitech za sekundu (b/s). Pro rozhran, u kterho se ka psma nemn nebo pro kter nelze udlat pesn odhad, je hodnota dna nominln kou psma.",

    "523",     "ta Pijat bajty/s udv rychlost pjmn bajt pro kad sov adaptr, vetn rmcovacch znak. ta Sov rozhran\\Pijat bajty/s je soust tae Sov rozhran\\Bajty celkem/s.",

    "525",     "Pijat jednosmrov pakety/s je rychlost, jakou jsou jednosmrn pakety podst dodvny protokolu vy rovn.",

    "527",     "Pijat nejednosmrov pakety/s je rychlost, jakou jsou nejednosmrov (t.j. vesmrov nebo vcesmrov vysln podst) pakety podst dodvny protokolu vy rovn.",

    "529",     "Vyazen pijat pakety je poet pchozch paket, kter byly vyazeny, akoliv nebyly zjitny dn chyby brnc jejich dodn protokolu vy rovn. Monou pinou vyazen takovho paketu me bt uvolnn msta ve vyrovnvac pamti.",

    "531",     "Chyby pijatch paket je poet pchozch paket, kter obsahovaly chyby brnc jejich dodn protokolu vy rovn.",

    "533",     "Pijat pakety neznm je poet paket pijatch pes rozhran, kter byly vyazeny kvli neznmmu nebo nepodporovanmu protokolu.",

    "535",     "ta Odeslan bajty/s udv rychlost odesln bajt pro kad sov adaptr, vetn rmcovacch znak. ta Sov rozhran\\Odeslan bajty/s je soust tae Sov rozhran\\Bajty celkem/s.",

    "537",     "Odeslan jednosmrov pakety/s je rychlost, jakou jsou pakety k penosu na jednosmrov adresy podst vyadovny protokoly vy rovn. Rychlost zahrnuje i pakety, kter byly vyazeny nebo nebyly odeslny.",

    "539",     "Odeslan nejednosmrov pakety/s je rychlost, jakou jsou pakety k penosu na nejednosmrov (t.j. vesmrov nebo vcesmrov vysln podst) adresy podst vyadovny protokoly vy rovn. Rychlost zahrnuje i pakety, kter byly vyazeny nebo nebyly odeslny.",

    "541",     "Vyazen odchoz pakety je poet odchozch paket, kter byly vyazeny, akoliv nebyly zjitny dn chyby brnc jejich penosu. Monou pinou vyazen takovho paketu me bt uvolnn msta ve vyrovnvac pamti.",

    "543",     "Chyby odchozch paket je poet odchozch paket, kter nemohly bt kvli chybm peneseny.",

    "545",     "Dlka fronty vstupu je dlka vstupn fronty paket (v paketech). Pokud je jeho hodnota vt ne 2, je nutn nalzt a eliminovat problmov msto, je-li to mon. V tto implementaci jsou poadavky azeny do fronty podle specifikace NDIS (Network Driver Interface Specification), bude tato hodnota vdy 0.",

    "547",     "Objekt sledovn vkonu IP obsahuje tae mc rychlost odesln a pijmn datagram IP pomoc protokolu IP. Obsahuje tak rzn tae chyb protokolu IP.",

    "549",     "ta Datagramy/s udv rychlost (ppady/s), jakou byly datagramy IP pijmny nebo odeslny do pslunch rozhran, vetn chyb. Pedan datagramy nejsou do tohoto potu zahrnuty.",

    "551",     "ta Pijat datagramy/s udv rychlost (ppady/s) pijmn datagram IP z rozhran, vetn chyb. ta Pijat datagramy/s je soust tae Datagramy/s.",

    "553",     "Chyby hlaviek pijatch datagram je poet vstupnch datagram vyazench kvli chybm v jejich hlavikch IP, vetn chybnch kontrolnch sout, zmatench sel verz, jinch formt, pekroen ivotnosti, chyb objevench pi zpracovn jejich monost pro IP, atd.",

    "555",     "ta Chyby adres pijatch datagram udv poet vstupnch datagram, kter byly zahozeny, protoe adresa IP v clovm poli v hlavice protokolu IP nebyla pro dan pota platn. Tento poet zahrnuje neplatn adresy (napklad 0.0.  0.0) a adresy nepodporovanch td (napklad tda E). U entit, kter nejsou brny IP a nepedvaj datagramy, tento ta zahrnuje datagramy, kter byly vyazeny, protoe clov adresa nebyla mstn adresa.",

    "557",     "ta Pedan datagramy/s udv etnost (ppady/s), s jakou dochzelo k pokusm o nalezen cesty pro pedn vstupnch datagram do clovho umstn, protoe mstn server nebyl konenm clem. U server, kter nepln funkci brny IP, jsou do tohoto potu zahrnuty pouze pakety, kter byly smrovny ze zdroje prostednictvm tto entity a u nich bylo zpracovn pomoc monosti smrovn ze zdroje spn.",

    "559",     "Neznm protokol pijatch datagram je poet mstn adresovanch datagram spn pijatch, ale vyazench kvli neznmmu nebo nepodporovanmu protokolu.",

    "561",     "ta Vyazen pijat datagramy udv poet vstupnch datagram IP, kter byly vyazeny, i kdy problmy zabrnily jejich plynulmu zpracovn (napklad nedostatek vyrovnvac pamti). ta nezahrnuje datagramy, vyazen pi ekn na zptn sestaven.",

    "563",     "ta Doruen pijat datagramy/s udv rychlost (ppady/s), jakou byly vstupn datagramy spn dorueny do uivatelskch protokol IP, vetn protokolu ICMP (Internet Control Message Protocol).",

    "565",     "ta Odeslan datagramy/s udv rychlost (ppady/s), jakou byly datagramy IP dodvny pro penos mstnmi uivatelskmi protokoly IP (vetn protokolu ICMP). Tento ta nezahrnuje datagramy, kter jsou zapotny taem Pedan datagramy/s. ta Odeslan datagramy/s je soust tae Datagramy/s.",

    "567",     "ta Vyazen odchoz datagramy udv poet vstupnch datagram IP, kter byly vyazeny, i kdy nebyly zjitny dn problmy, kter by mohli zabrnit penosu do cle (napklad nedostatek vyrovnvac pamti). Tento ta zahrnuje datagramy zapotan taem Pedan datagramy/s, kter spluj toto kritrium.",

    "569",     "Odchoz datagramy bez smrovn je poet datagram IP vyazench kvli tomu, e pro jejich penos nebyla nalezena cesta do msta uren. ta zahrnuje i pakety zapotan taem Pedan datagramy, kter vyhovly podmnce bez smrovn.",

    "571",     "Pijat fragmenty/s je rychlost, kterou jsou pijmny fragmenty IP, je v tto entit vyaduj zptn sloen.",

    "573",     "Fragmenty zptn sloen/s je rychlost, jakou jsou fragmenty IP znovu spn sloeny.",

    "575",     "Chyby zptnho skldn fragment je poet chyb zjitnch algoritmem optovnho skldn IP (nap. vypren asu, chyby, atd.). Nemus se nutn jednat o poet vyazench fragment IP, protoe nkter algoritmy (napklad RFC 815) mohou ztratit povdom o potu fragment jejich kombinovnm tak, jak pichzej.",

    "577",     "ta Fragmentovn datagram/s je rychlost, jakou jsou datagramy spn fragmentovny.",

    "579",     "ta Chyby fragmentovn udv poet datagram IP, kter byly vyazeny, protoe vyadovaly fragmentaci, kter vak nebyla mon (napklad proto, e byl nastaven pznak `Nefragmentovat').",

    "581",     "Fragmenty vytvoen/s je rychlost, jakou byly vygenerovny fragmenty datagramu IP jako vsledek fragmentace.",

    "583",     "Objekt sledovn vkonu ICMP obsahuje tae mc rychlost odesln a pijmn zprv pomoc protokolu ICMP. Obsahuje tak rzn tae chyb protokolu ICMP.",

    "585",     "Zprvy/s je celkov rychlost, jakou jsou zprvy ICMP odeslny a pijmny entitou. Do rychlosti se zapotvaj zprvy chybn pijat nebo odeslan.",

    "587",     "Zprvy pijat/s je rychlost, jakou jsou zprvy ICMP pijmny entitou. Do rychlosti se zapotvaj zprvy chybn pijat.",

    "589",     "Chyby pijatch zprv je poet zprv ICMP, kter entita pijala, ale byly chybn (chybn kontroln souet ICMP, chybn dlka, atd.).",

    "591",     "Pijat zprvy Cl nedostupn je poet pijatch zprv ICMP Cl nedostupn.",

    "593",     "Pijat zprvy as pekroen je poet pijatch zprv ICMP as pekroen.",

    "595",     "Pijat zprvy Problm parametru je poet pijatch zprv ICMP Problm parametru.",

    "597",     "Pijat zprvy Zdroj vyerpn je poet pijatch zprv ICMP Zdroj vyerpn.",

    "599",     "Pijat zprvy  Pesmrovn/s je rychlost pijatch zprv ICMP Pesmrovn.",

    "601",     "Pijat zprvy Echo/s je rychlost pijatch zprv ICMP Echo.",

    "603",     "Pijat zprvy Odpov echa/s je rychlost pijatch zprv ICMP Odpov echa.",

    "605",     "ta Pijat asov raztka/s udv rychlost (ppady/s), jakou byly pijmny zprvy poadavk na asov raztka protokolu ICMP.",

    "607",     "Pijat zprvy Odpov asov znaky/s je rychlost pijatch zprv ICMP Odpov asov znaky.",

    "609",     "Pijat zprvy Maska adresy je poet pijatch zprv ICMP Maska adresy (poadavek).",

    "611",     "Pijat zprvy Odpov masky adresy je poet pijatch zprv ICMP Odpov masky adresy.",

    "613",     "ta Odeslan zprvy/s udv rychlost (ppady/s), jakou se server pokouel odeslat zprvy. Jsou zapotny i zprvy odeslan s chybou.",

    "615",     "Chyby odchozch zprv je poet zprv ICMP, kter tato entita neodeslala z dvodu pot v protokolu ICMP, jako je napklad nedostatek vyrovnvacch pamt. Hodnota nezahrnuje chyby zjitn mimo vrstvu ICMP, jako je napklad nezdaen smrovn vslednho datagramu protokolem IP. V nkterch implementacch nesm bt dn typy chyb, kter by zvyovaly hodnotu tohoto tae.",

    "617",     "Odeslan zprvy Cl nedostupn je poet odeslanch zprv ICMP Cl nedostupn.",

    "619",     "Odeslan zprvy as pekroen je poet odeslanch zprv ICMP as pekroen.",

    "621",     "Odeslan zprvy Problm parametru je poet odeslanch zprv ICMP Problm parametru.",

    "623",     "Odeslan zprvy Zdroj vyerpn je poet odeslanch zprv ICMP Zdroj vyerpn.",

    "625",     "Odeslan zprvy Pesmrovn/s je rychlost odeslanch zprv ICMP Pesmrovn.",

    "627",     "Odeslan zprvy Echo/s je rychlost odeslanch zprv ICMP Echo.",

    "629",     "Odeslan zprvy Odpov echa/s je rychlost odeslanch zprv ICMP Odpov echa.",

    "631",     "ta Odeslan asov raztka/s udv rychlost (ppady/s), jakou byly odeslny zprvy poadavk na asov raztka protokolu ICMP.",

    "633",     "ta Odeslan odpovdi na asov raztka/s udv rychlost (ppady/s), jakou byly odeslny zprvy odpovd na asov raztka protokolu ICMP.",

    "635",     "Odeslan zprvy Maska adresy je poet odeslanch zprv ICMP Maska adresy (poadavek).",

    "637",     "Odeslan zprvy Odpov masky adresy je poet odeslanch zprv ICMP Odpov masky adresy.",

    "639",     "Objekt sledovn vkonu protokolu TCP obsahuje tae mc rychlosti odesln a pijmn segment TCP pomoc protokolu TCP. Obsahuje i tae sledujc poet pipojen TCP v jednotlivch stavech pipojen TCP.",

    "641",     "ta Segmenty/s je rychlost, jakou jsou segmenty TCP odeslny a pijmny protokolem TCP.",

    "643",     "Navzan pipojen je poet pipojen TCP, jejich aktuln stav je bu ESTABLISHED nebo CLOSE-WAIT.",

    "645",     "Aktivn pipojen je poet, kolikrt pipojen TCP provedla pm pechod do stavu SYN-SENT ze stavu CLOSED.",

    "647",     "Pasivn pipojen je poet, kolikrt pipojen TCP provedla pm pechod do stavu SYN-RCVD ze stavu LISTEN.",

    "649",     "Chyby pipojen je poet, kolikrt pipojen TCP provedla pm pechod do stavu CLOSED ze stavu SYN-SENT i ze stavu SYN-RCVD plus poet, kolikrt pipojen TCP provedla pm pechod do stavu LISTEN ze stavu SYN-RCVD.",

    "651",     "Resetovan pipojen je poet, kolikrt pipojen TCP provedla pm pechod do stavu CLOSED bu ze stavu ESTABLISHED nebo ze stavu CLOSE-WAIT.",

    "653",     "Segmenty pijat/s je rychlost, jako jsou pijmny segmenty, vetn tch, kter byly pijaty s chybou. Poet zahrnuje segmenty pijat v prv ustanovench pipojench.",

    "655",     "Segmenty odeslan/s je rychlost, jako jsou odeslny segmenty, vetn segment na aktulnch pipojench, ale vyjma tch, kter obsahuj pouze znovu odeslan bajty.",

    "657",     "Segmenty odeslan znovu/s je rychlost, jakou jsou segmenty odeslny znovu, tedy odeslan segmenty obsahujc jeden nebo vce dve odeslanch bajt.",

    "659",     "Objekt sledovn vkonu protokolu UDP obsahuje tae mc rychlosti odesln a pijmn datagram UDP pomoc protokolu UDP. Obsahuje tak tae chyb protokolu UDP.",

    "661",     "ta Datagramy/s je rychlost, jakou jsou datagramy UDP odeslny nebo pijmny entitou.",

    "663",     "ta Pijat datagramy/s je rychlost, jakou jsou datagramy UDP dorueny uivatelm UDP.",

    "665",     "Datagramy bez portu/s je rychlost pijatch datagram UDP, pro kter na clovm portu neexistovala aplikace.",

    "667",     "Chyby pijatch datagram je poet pijatch datagram UDP, kter nemohly bt dorueny z dvod jinch, ne je neptomnost aplikace na clovm portu.",

    "669",     "ta Odeslan datagramy/s je rychlost, jakou jsou datagramy UDP odeslny entitou.",

    "671",     "Statistika zazen diskov pamti na cizm potai.",

    "673",     "Udv poet chyb vyhrazen ohlench zazenm diskov pamti.",

    "675",     "Doba provozu systmu (v sekundch) je doba, kter ubhla od poslednho sputn systmu. Tento ta zobrazuje rozdl mezi asem sputn a aktulnm asem. ",

    "677",     "Aktuln poet pouvanch poet popisova systmu.",

    "679",     "Voln poloky strnkovac tabulky systmu je poet poloek strnkovac tabulky, kter momentln nejsou pouvny systmem. Tento ta zobrazuje pouze posledn zjitnou hodnotu, nejedn se o prmrnou hodnotu. ",

    "681",     "Poet prv aktivnch podproces v tomto procesu. Instrukce je zkladn vykonvanou jednotkou procesoru a podproces je objekt, kter vykonv instrukce. Kad bc proces obsahuje alespo jeden podproces.",

    "683",     "Aktuln zkladn priorita procesu. Podprocesy procesu mohou zvit nebo snit svou vlastn zkladn prioritu relativn vzhledem k zkladn priorit procesu.",

    "685",     "Celkem ubhl as (v sekundch), po kter tento proces bel.",

    "687",     "ta Npravy zarovnn/s udv rychlost (ppady/s), jakou systm eil chyby zarovnn.",

    "689",     "ta Odbaven vjimek/s udv rychlost (ppady/s), jakou systm odbavoval vjimky.",

    "691",     "Emulace pohybliv rky/s je mra emulac pohybliv dov rky provdnch systmem. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn.",

    "693",     "ta Pihlen/s je mra vech pihlen ke vem serverm.",

    "695",     "Aktuln dynamick priorita podprocesu. Systm me zvit dynamickou prioritu podprocesu nad zkladn prioritu, pokud podproces zpracovv vstup od uivatele, nebo ji snit k zkladn priorit, pokud se podproces zabv pouze vpoty.",

    "697",     "Aktuln zkladn priorita podprocesu. Systm me zvit dynamickou prioritu podprocesu nad zkladn prioritu, pokud podproces zpracovv vstup od uivatele, nebo ji snit k zkladn priorit, pokud se podproces zabv pouze vpoty.",

    "699",     "Celkem ubhl as (v sekundch), po kter tento podproces bel.",

    "701",     "Objekt sledovn vkonu strnkovacho souboru obsahuje tae sledujc strnkovac soubory v potai. Strnkovac soubor je msto vyhrazen na disku, kter tvo zlohu sven fyzick pamti.",

    "703",     "Rozsah vyuit instance Strnkovacho souboru v procentech. Viz tak Proces\\Bajty strnkovacch soubor.",

    "705",     "Vrcholov vyuit instance strnkovacho souboru v procentech. Viz tak Proces\\Vrchol bajt strnkovacho souboru.",

    "707",     "Poten virtuln adresa tohoto podprocesu.",

    "709",     "Aktuln programov ta tohoto podprocesu.",

    "711",     "Mapovan pam je virtuln pam, kter byla namapovna na jistou virtuln adresu (nebo rozsah virtulnch adres) v prostoru virtulnch adres procesu. Nastaven Bez pstupu brn procesu v zpisu do nebo ve ten z tchto strnek a dojde-li k takovmu pokusu, nastane chyba poruen pstupu.",

    "713",     "Mapovan pam je virtuln pam, kter byla namapovna na jistou virtuln adresu (nebo rozsah virtulnch adres) v prostoru virtulnch adres procesu. Nastaven Pouze pro ten chrn obsah strnek proti pravm. Pi libovolnm pokusu o zpis nebo pravu strnek nastane chyba poruen pstupu.",

    "715",     "Mapovan pam je virtuln pam, kter byla namapovna na jistou virtuln adresu (nebo rozsah virtulnch adres) v prostoru virtulnch adres procesu. Nastaven ten/zpis umouje procesu st, upravovat i zapisovat tyto strnky.",

    "717",     "Mapovan pam je virtuln pam, kter byla namapovna na jistou virtuln adresu (nebo rozsah virtulnch adres) v prostoru virtulnch adres procesu. Nastaven Zpis kopie se pouv, pokud je pam sdlena pro ten, ale nikoliv pro zpis. Pokud procesy tou z tto pamti, mohou stejnou pam sdlet, ale jakmile sdlejc proces poaduje pstup pro zpis do tto sdlen pamti, je vytvoena jej kopie.",

    "719",     "Mapovan pam je virtuln pam, kter byla namapovna na jistou virtuln adresu (nebo rozsah virtulnch adres) v prostoru virtulnch adres procesu. Pam uren pro spoutn je takov, ve kter mohou bt spoutny programy, ale nesm se z n st ani do n zapisovat. Takov zpsob ochrany nen podporovn vemi typy procesor.",

    "721",     "Mapovan pam je virtuln pam, kter byla namapovna na jistou virtuln adresu (nebo rozsah virtulnch adres) v prostoru virtulnch adres procesu. Pam uren pro spoutn a ten je takov, ve kter mohou bt spoutny programy a ze kter lze st.",

    "723",     "Mapovan pam je virtuln pam, kter byla namapovna na jistou virtuln adresu (nebo rozsah virtulnch adres) v prostoru virtulnch adres procesu. Pam uren pro spoutn, ten a zpis je takov, ve kter lze programy spoutt a kterou lze st a upravovat.",

    "725",     "Mapovan pam je virtuln pam, kter byla namapovna na jistou virtuln adresu (nebo rozsah virtulnch adres) v prostoru virtulnch adres procesu. Pam uren pro spoutn, zpis a koprovn je takov, ve kter lze programy spoutt a kterou lze st a zapisovat. Takov zpsob ochrany se pouv, je-li teba pam sdlet mezi procesy. Pokud sdlejc procesy pam pouze tou, budou pouvat stejnou pam.  Pokud sdlejc proces vyaduje pstup i pro zpis, bude pro takov proces vytvoena kopie pamti.",

    "727",     "Rezervovan pam je virtuln pam, kter byla rezervovna pro budouc pouit procesem, ale nebyla namapovna nebo svena. Nastaven Bez pstupu brn procesu v zpisu do nebo ve ten z tchto strnek a dojde-li k takovmu pokusu, nastane chyba poruen pstupu.",

    "729",     "Rezervovan pam je virtuln pam, kter byla rezervovna pro budouc pouit procesem, ale nebyla namapovna nebo svena. Nastaven Pouze pro ten chrn obsah strnek proti pravm. Pi libovolnm pokusu o zpis nebo pravu strnek nastane chyba poruen pstupu.",

    "731",     "Rezervovan pam je virtuln pam, kter byla rezervovna pro budouc pouit procesem, ale nebyla namapovna nebo svena. Nastaven ten/zpis umouje procesu st, upravovat i zapisovat tyto strnky.",

    "733",     "Rezervovan pam je virtuln pam, kter byla rezervovna pro budouc pouit procesem, ale nebyla namapovna nebo svena. Nastaven Zpis kopie se pouv, pokud je pam sdlena pro ten, ale nikoliv pro zpis. Pokud procesy tou z tto pamti, mohou stejnou pam sdlet, ale jakmile sdlejc proces poaduje pstup pro zpis do tto sdlen pamti, je vytvoena jej kopie.",

    "735",     "Rezervovan pam je virtuln pam, kter byla rezervovna pro budouc pouit procesem, ale nebyla namapovna nebo svena. Pam uren pro spoutn je takov, ve kter mohou bt spoutny programy, ale nesm se z n st ani do n zapisovat. Takov zpsob ochrany nen podporovn vemi typy procesor.",

    "737",     "Rezervovan pam je virtuln pam, kter byla rezervovna pro budouc pouit procesem, ale nebyla namapovna nebo svena. Pam uren pro spoutn a ten je takov, ve kter mohou bt spoutny programy a ze kter lze st.",

    "739",     "Rezervovan pam je virtuln pam, kter byla rezervovna pro budouc pouit procesem, ale nebyla namapovna nebo svena. Pam uren pro spoutn, ten a zpis je takov, ve kter lze programy spoutt a kterou lze st a zapisovat.",

    "741",     "Objekt sledovn vkonu bitov kopie obsahuje tae sledujc vyuit virtuln adresy bitov kopie vykonvan procesem v potai.",

    "743",     "Rezervovan pam je virtuln pam, kter byla rezervovna pro budouc pouit procesem, ale nebyla namapovna nebo svena. Pam uren pro spoutn, zpis a koprovn je takov, ve kter lze programy spoutt a kterou lze st a zapisovat. Takov zpsob ochrany se pouv, je-li teba pam sdlet mezi procesy. Pokud sdlejc procesy pam pouze tou, budou pouvat stejnou pam.  Pokud sdlejc proces vyaduje pstup i pro zpis, bude pro takov proces vytvoena kopie pamti.",

    "745",     "Nepiazen pam je namapovan a pidlen virtuln pam pouvan procesem, kterou nelze pisoudit k dn z bitovch kopi provdn tmto procesem. Nastaven Bez pstupu brn procesu v zpisu do nebo ve ten z tchto strnek a dojde-li k takovmu pokusu, nastane chyba poruen pstupu.",

    "747",     "Nepiazen pam je namapovan a pidlen virtuln pam pouvan procesem, kterou nelze pisoudit k dn z bitov kopie provdn tmto procesem. Nastaven Pouze pro ten chrn obsah strnek proti pravm. Pi libovolnm pokusu o zpis nebo pravu strnek nastane chyba poruen pstupu.",

    "749",     "Nepiazen pam je namapovan a pidlen virtuln pam pouvan procesem, kterou nelze pisoudit k dn z bitov kopie provdn tmto procesem. Nastaven ten/zpis umouje procesu st, upravovat i zapisovat tyto strnky.",

    "751",     "Nepiazen pam je namapovan a pidlen virtuln pam pouvan procesem, kterou nelze pisoudit k dn z bitov kopie provdn tmto procesem. Nastaven Zpis kopie se pouv, pokud je pam sdlena pro ten, ale nikoliv pro zpis. Pokud procesy tou z tto pamti, mohou stejnou pam sdlet, ale jakmile sdlejc proces poaduje pstup pro zpis do tto sdlen pamti, je vytvoena jej kopie.",

    "753",     "Nepiazen pam je namapovan a pidlen virtuln pam pouvan procesem, kterou nelze pisoudit dn z bitov kopie provdn tmto procesem. Pam uren pro spoutn je takov, ve kter mohou bt spoutny programy, ale nesm se z n st ani do n zapisovat. Takov zpsob ochrany nen podporovn vemi typy procesor.",

    "755",     "Nepiazen pam je namapovan a pidlen virtuln pam pouvan procesem, kterou nelze pisoudit k dn z bitovch kopi provdn tmto procesem. Pam uren pro spoutn a ten je takov, ve kter mohou bt programy provdny a kterou lze st.",

    "757",     "Nepiazen pam je namapovan a pidlen virtuln pam pouvan procesem, kterou nelze pisoudit k dn z bitovch kopi provdn tmto procesem. Pam uren pro spoutn, ten a zpis je takov, ve kter lze programy provdt a ve kter lze st i zapisovat.",

    "759",     "Nepiazen pam je namapovan a pidlen virtuln pam pouvan procesem, kterou nelze pisoudit k dn z bitovch kopi provdn tmto procesem. Pam uren pro spoutn, zpis a koprovn je takov, ve kter lze programy spoutt a kterou lze st a zapisovat. Takov zpsob ochrany se pouv, je-li teba pam sdlet mezi procesy. Pokud sdlejc procesy pam pouze tou, budou pouvat stejnou pam.  Pokud sdlejc proces vyaduje pstup i pro zpis, bude pro takov proces vytvoena kopie pamti.",

    "761",     "Pam bitovch kopi je prostor virtulnch adres pouvanch bitovmi kopiemi, kter jsou provdny procesem. Je to souhrn vekerho adresovho prostoru s touto ochranou,  alokovanho bitovmi kopiemi sputnmi vybranm procesem. Nastaven Bez pstupu brn procesu v zpisu do nebo ve ten z tchto strnek a dojde-li k takovmu pokusu, nastane chyba poruen pstupu.",

    "763",     "Pam bitovch kopi je prostor virtulnch adres pouvanch bitovmi kopiemi, kter jsou provdny procesem. Je to souhrn vekerho adresovho prostoru s touto ochranou,  alokovanho bitovmi kopiemi sputnmi vybranm procesem. Nastaven Pouze pro ten chrn obsah strnek proti pravm. Pi libovolnm pokusu o zpis nebo pravu strnek nastane chyba poruen pstupu.",

    "765",     "Pam bitovch kopi je prostor virtulnch adres pouvanch bitovmi kopiemi, kter jsou provdny procesem. Je to souhrn vekerho adresovho prostoru s touto ochranou,  alokovanho bitovmi kopiemi sputnmi vybranm procesem. Nastaven ten/zpis umouje procesu st, upravovat i zapisovat tyto strnky.",

    "767",     "Pam bitovch kopi je prostor virtulnch adres pouvanch bitovmi kopiemi, kter jsou provdny procesem. Je to souhrn vekerho adresovho prostoru s touto ochranou,  alokovanho bitovmi kopiemi sputnmi vybranm procesem. Nastaven Zpis kopie se pouv, pokud je pam sdlena pro ten, ale nikoliv pro zpis. Pokud procesy tou z tto pamti, mohou stejnou pam sdlet, ale jakmile sdlejc proces poaduje pstup pro zpis do tto sdlen pamti, je vytvoena jej kopie.",

    "769",     "Pam bitovch kopi je prostor virtulnch adres pouvan bitovmi kopiemi, kter jsou provdny procesem. Je to souhrn vekerho adresovho prostoru s touto ochranou,  alokovanho otisky sputnmi vybranm procesem. Pam uren pro spoutn je takov, ve kter mohou bt spoutny programy, ale nesm se z n st ani do n zapisovat. Takov zpsob ochrany nen podporovn vemi typy procesor.",

    "771",     "Pam bitovch kopi je prostor virtulnch adres pouvanch bitovmi kopiemi, kter jsou provdny procesem. Je to souhrn vekerho adresovho prostoru s touto ochranou,  alokovanho bitovmi kopiemi sputnmi vybranm procesem. Pam uren pro spoutn a ten je takov, ve kter mohou bt spoutny programy a ze kter lze st.",

    "773",     "Pam bitovch kopi je prostor virtulnch adres pouvanch bitovmi kopiemi, kter jsou provdny procesem. Je to souhrn vekerho adresovho prostoru s touto ochranou,  alokovanho bitovmi kopiemi sputnmi vybranm procesem. Pam uren pro spoutn, ten a zpis je takov, ve kter lze programy spoutt a kterou lze st a upravovat.",

    "775",     "Pam bitovch kopi je prostor virtulnch adres pouvanch bitovmi kopiemi, kter jsou provdny procesem. Je to souhrn vekerho adresovho prostoru s touto ochranou,  alokovanho bitovmi kopiemi sputnmi vybranm procesem. Pam uren pro spoutn, zpis a koprovn je takov, ve kter lze programy spoutt a kterou lze st a zapisovat. Takov zpsob ochrany se pouv, je-li teba pam sdlet mezi procesy. Pokud sdlejc procesy pam pouze tou, budou pouvat stejnou pam.  Pokud sdlejc proces vyaduje pstup i pro zpis, bude pro takov proces vytvoena kopie pamti.",

    "777",     "Rezervovan bajty bitovch kopi je souhrn veker virtuln pamti rezervovan bitovmi kopiemi v rmci tohoto procesu.",

    "779",     "Voln bajty bitovch kopi je mnostv virtulnho adresovho prostoru, kter nen pouvn ani rezervovn bitovmi kopiemi v rmci tohoto procesu.",

    "781",     "Rezervovan bajty je celkov mnostv virtuln pamti rezervovan procesem pro budouc pouit.",

    "783",     "Voln bajty je celkov velikost nepouvanho virtulnho adresovho prostoru tohoto procesu.",

    "785",     "ID procesu je jedinen identifiktor tohoto procesu. ID procesu jsou opakovan vyuvna, take identifikuj proces pouze po dobu jeho existence.",

    "787",     "Objekt sledovn vkonu adresnho prostoru procesu obsahuje tae sledujc vyhrazovn pamti a vyuit vybranmi procesy.",

    "789",     "Pam bitovch kopi je prostor virtulnch adres pouvanch vybranou bitovou kopi s touto ochranou. Nastaven Bez pstupu brn procesu v zpisu do nebo ve ten z tchto strnek a dojde-li k takovmu pokusu, nastane chyba poruen pstupu.",

    "791",     "Pam bitovch kopi je prostor virtulnch adres pouvanch vybranou bitovou kopi s touto ochranou. Nastaven Pouze pro ten chrn obsah strnek proti pravm. Pi libovolnm pokusu o zpis nebo pravu strnek nastane chyba poruen pstupu.",

    "793",     "Pam bitovch kopi je prostor virtulnch adres pouvanch vybranou bitovou kopi s touto ochranou. Nastaven ten/zpis umouje procesu st, upravovat i zapisovat tyto strnky.",

    "795",     "Pam bitovch kopi je prostor virtulnch adres pouvanch vybranou bitovou kopi s touto ochranou. Nastaven Zpis/koprovn se pouv, pokud je pam sdlena pro ten, ale nikoliv pro zpis. Pokud procesy tou z tto pamti, mohou stejnou pam sdlet, ale jakmile sdlejc proces poaduje pstup pro zpis do tto sdlen pamti, je vytvoena jej kopie.",

    "797",     "Pam bitovch kopi je prostor virtulnch adres pouvanch vybranou bitovou kopi s touto ochranou. Pam uren pro spoutn je takov, ve kter mohou bt spoutny programy, ale nesm se z n st ani do n zapisovat. Takov zpsob ochrany nen podporovn vemi typy procesor.",

    "799",     "Pam bitovch kopi je prostor virtulnch adres pouvanch vybranou bitovou kopi s touto ochranou. Pam uren pro spoutn a ten je takov, ve kter mohou bt spoutny programy a ze kter lze st.",

    "801",     "Pam bitovch kopi je prostor virtulnch adres pouvanch vybranou bitovou kopi s touto ochranou. Pam uren pro spoutn, ten a zpis je takov, ve kter lze programy spoutt a kterou lze st a zapisovat.",

    "803",     "Pam bitovch kopi je prostor virtulnch adres pouvanch vybranou bitovou kopi s touto ochranou. Pam uren pro spoutn, zpis a koprovn je takov, ve kter lze programy spoutt a kterou lze st a zapisovat. Takov zpsob ochrany se pouv, je-li teba pam sdlet mezi procesy. Pokud sdlejc procesy pam pouze tou, budou pouvat stejnou pam.  Pokud sdlejc proces vyaduje pstup i pro zpis, bude pro takov proces vytvoena kopie pamti.",

    "805",     "ID podprocesu je jedinen identifiktor podprocesu. ID podprocesu jsou opakovan vyuvna, take identifikuj podproces pouze po dobu jeho existence.",

    "807",     "ta Chyby oteven zsuvek poty/s oznauje rychlost, jakou tato pracovn stanice pijmala zprvy zsuvek poty pro doruen do zsuvek, kter nejsou ptomny.",

    "809",     "Ohlen duplicity hlavnho udv poet, kolikrt hlavn prohle zjistil ptomnost jinho hlavnho prohlee ve stejn domn.",

    "811",     "Nelegln datagramy/s je rychlost, jakou jsou nesprvn formtovan datagramy pijmny pracovn stanic.",

    "813",     "Celkem ohlen/s je souet Ohlen serveru/s a Ohlen domny/s.",

    "815",     "Celkem vyslen/s je rychlost, jakou jsou prohledvac poadavky zpracovvny pracovn stanic. Je to souet Vyslen serveru/s, Vyslen domny/s a Vyslen ostatnch/s.",

    "817",     "Objekt sledovn vkonu Podrobnosti podproces obsahuje tae mc vlastnosti podproces, jejich sbr dat je asov nron. Tyto tae maj na rozdl od ta objektu Podproces velmi velkou reii.",

    "819",     "Hodnota tae Bajty mezipamti je urena soutem ta Pam\\Rezidentn bajty systmov mezipamti, Pam\\Rezidentn bajty systmovch ovlada, Pam\\Rezidentn bajty kdu systmu a Pam\\Rezidentn bajty strnkovanho fondu. Tento ta zobrazuje pouze posledn zjitnou hodnotu, nejedn se o prmrnou hodnotu. ",

    "821",     "ta Vrchol bajt mezipamti udv maximln poet bajt pouitch mezipamt systmu soubor od poslednho restartovn systmu. Tato hodnota me bt vt ne aktuln velikost mezipamti. Tento ta zobrazuje pouze posledn zjitnou hodnotu, nejedn se o prmrnou hodnotu. ",

    "823",     "ta Vstup strnek/s udv rychlost ten strnek z disku pi een chyb strnek. K chybm strnek dochz, jestlie proces odkazuje na strnku ve virtuln pamti, kter se nenachz v pracovn sad nebo jin sti fyzick pamti a je nutn ji nast z disku. Pokud je strnka chybn, systm se pokus nast do pamti vce souvislch strnek a maximalizovat tak innost operace ten. Porovnnm hodnot ta Pam\\Vstup strnek/s a Pam\\ten strnek/s urte prmrn poet strnek natench do pamti bhem kad operace ten.",

    "825",     "Hodnota Strnky pechodu pouit pro jin el je pomr, ve kterm byl poet strnek pechodu z mezipamti znovu pouit k jinmu elu. Tyto strnky by jinak zstaly v mezipamti strnky, aby poskytovaly rychl pstup (msto natn ze zlonho loit) v ppad pstupu ke strnce v budoucnu. Vimnte si, e tyto strnky mohou obsahovat soukromou nebo sdlenou pam.",

    "871",     "Objekt sledovn vkonu sluby RAS obsahuje tae sledujc jednotliv porty sluby Remote Access Service zazen RAS v potai.",

    "873",     "Celkov poet odeslanch bajt pro toto pipojen.",

    "875",     "Celkov poet pijatch bajt pro toto pipojen.",

    "877",     "Celkov poet odeslanch datovch rmc pro toto pipojen.",

    "879",     "Celkov poet pijatch datovch rmc pro toto pipojen.",

    "881",     "Kompresn pomr odeslanch bajt.",

    "883",     "Kompresn pomr pijatch bajt.",

    "885",     "Celkov poet chyb CRC, ke kterm dolo bhem tohoto pipojen. K chybm CRC dochz, kdy pijat rmec obsahuje chybn data.",

    "887",     "Celkov poet vypren asovho limitu, ke kterm dolo bhem tohoto pipojen. K vypren asovho limitu dochz, kdy oekvan rmec nen pijat vas.",

    "889",     "Celkov poet chyb sriovho pebhu, ke kterm dolo bhem tohoto pipojen. K chybm sriovho pebhu dojde, pokud hardware neme zpracovat rychlost, s jakou jsou pijmna data.",

    "891",     "Celkov poet chyb zarovnn, ke kterm dolo bhem tohoto pipojen. K chybm zarovnn dojde, pokus se poet pijatch bajt li od potu oekvanch bajt.",

    "893",     "Celkov poet chyb pebhu vyrovnvac pamti, ke kterm dolo bhem tohoto pipojen. K chybm pebhu vyrovnvac pamti dojde, pokud software neme zpracovat rychlost, s jakou jsou pijmna data.",

    "895",     "Celkov poet chyb CRC, vypren asovho limitu, sriovho pebhu, zarovnn a pebhu vyrovnvac pamti, ke kterm dolo bhem tohoto pipojen.",

    "897",     "Poet bajt odeslanch za sekundu.",

    "899",     "Poet bajt pijatch za sekundu.",

    "901",     "Poet rmc odeslanch za sekundu.",

    "903",     "Poet rmc pijatch za sekundu.",

    "905",     "Celkov poet chyb CRC, vypren asovho limitu, sriovho pebhu, zarovnn a pebhu vyrovnvac pamti za sekundu.",

    "907",     "Objekt sledovn vkonu sluby RAS obsahuje tae, kter staj hodnoty pro vechny porty sluby Remote Access Service zazen RAS v potai.",

    "909",     "Celkov poet pipojen typu vzdlen pstup.",

    "921",     "Objekt sledovn vkonu serveru WINS obsahuje tae sledujc komunikaci pomoc sluby serveru WINS.",

    "923",     "Jedinen registrace/s je rychlost, jakou jsou jedinen registrace pijmny serverem WINS.",

    "925",     "Registrace skupin/s je rychlost, jakou jsou registrace skupin pijmny serverem WINS.",

    "927",     "Celkov poet registrac/s je souet jedinench registrac a registrac skupin za sekundu. Je to celkov rychlost, jakou jsou registrace pijmny serverem WINS.",

    "929",     "Jedinen obnoven/s je rychlost, jakou jsou jedinen obnoven pijmna serverem WINS.",

    "931",     "Obnoven skupin/s je rychlost, jakou jsou obnoven skupin pijmna serverem WINS.",

    "933",     "Celkov poet obnoven/s je souet jedinench obnoven a obnoven skupin za sekundu. Je to celkov rychlost, jakou jsou obnoven pijmna serverem WINS.",

    "935",     "Celkov poet uvolnn/s je rychlost, jakou jsou uvolnn pijmna serverem WINS.",

    "937",     "ta Dotazy/s je rychlost, jakou jsou dotazy pijmny serverem WINS.",

    "939",     "Jedinen konflikty/s je rychlost, jakou jedinen registrace nebo obnoven pijman serverem WINS vedla ke konfliktm v databzi.",

    "941",     "Konflikty skupin/s je rychlost, jakou registrace skupin pijman serverem WINS vedly ke konfliktm v databzi.",

    "943",     "Celkov poet konflikt/s je souet jedinench konflikt a konflikt skupin za sekundu. Je to celkov rychlost, jakou byly konflikty zaznamenny serverem WINS.",

    "945",     "Celkov poet spnch uvolnn/s",

    "947",     "Celkov poet chybnch uvolnn/s",

    "949",     "Celkov poet spnch dotaz/s",

    "951",     "Celkov poet chybnch dotaz/s",

    "953",     "Celkov poet popisova momentln otevench tmto procesem. Je to souet popisova momentln otevench vemi podprocesy tohoto procesu.",

    "1001",     "Souborov server AFP slueb pro Macintosh.",

    "1003",     "Maximln mnostv prostedk strnkovan pamti pouvan serverem MacFile.",

    "1005",     "Aktuln mnostv prostedk strnkovan pamti pouvan serverem MacFile.",

    "1007",     "Maximln mnostv prostedk nestrnkovan pamti pouvan serverem MacFile.",

    "1009",     "Aktuln mnostv prostedk nestrnkovan pamti pouvan serverem MacFile.",

    "1011",     "Poet relac prv pipojench k serveru MacFile. Ukazuje aktuln aktivitu serveru.",

    "1013",     "Maximln poet relac pipojench v danm okamiku k serveru MacFile. Ukazuje rove vyuit serveru.",

    "1015",     "Poet internch soubor prv otevench na serveru MacFile. Poet nezahrnuje soubory oteven klienty Macintosh.",

    "1017",     "Maximln poet internch soubor otevench v danm okamiku k serveru MacFile. Poet nezahrnuje soubory oteven klienty Macintosh.",

    "1019",     "Poet chybnch pokus o pihlen k serveru MacFile. Ukazuje, zda se njak program pro zjiovn hesla nepokou proniknout zabezpeenm serveru.",

    "1021",     "Poet bajt petench z disku za sekundu.",

    "1023",     "Poet bajt zapsanch na disk za sekundu.",

    "1025",     "Poet bajt pijatch ze st za sekundu. Ukazuje, jak je server zaten.",

    "1027",     "Poet bajt vyslanch do st za sekundu. Ukazuje, jak je server zaten.",

    "1029",     "Poet nevykonanch pracovnch poloek ekajcch na zpracovn.",

    "1031",     "Maximln poet nevykonanch pracovnch poloek, ekajcch v danm okamiku.",

    "1033",     "Aktuln poet podproces pouvanch serverem MacFile. Ukazuje, jak je server zaten.",

    "1035",     "Maximln poet podproces pouvanch serverem MacFile. Ukazuje vrcholnou hodnotu vyuit serveru.",

    "1051",     "Protokol AppleTalk",

    "1053",     "Poet paket pijatch za sekundu protokolem AppleTalk na tomto portu.",

    "1055",     "Poet paket odeslanch za sekundu protokolem AppleTalk na tomto portu.",

    "1057",     "Poet bajt pijatch za sekundu protokolem AppleTalk na tomto portu.",

    "1059",     "Poet bajt odeslanch za sekundu protokolem AppleTalk na tomto portu.",

    "1061",     "Prmrn as zpracovn (milisekundy) na zpracovn paketu DDP na tomto portu.",

    "1063",     "Poet paket DDP za sekundu, pijatch protokolem AppleTalk na tomto portu.",

    "1065",     "Prmrn as zpracovn (milisekundy) na zpracovn paketu AARP na tomto portu.",

    "1067",     "Poet paket AARP za sekundu, pijatch protokolem AppleTalk na tomto portu.",

    "1069",     "Prmrn as zpracovn (milisekundy) na zpracovn paketu ATP na tomto portu.",

    "1071",     "Poet paket ATP za sekundu, pijatch protokolem AppleTalk na tomto portu.",

    "1073",     "Prmrn as zpracovn (milisekundy) na zpracovn paketu NBP na tomto portu.",

    "1075",     "Poet paket NBP za sekundu, pijatch protokolem AppleTalk na tomto portu.",

    "1077",     "Prmrn as zpracovn (milisekundy) na zpracovn paketu ZIP na tomto portu.",

    "1079",     "Poet paket ZIP za sekundu, pijatch protokolem AppleTalk na tomto portu.",

    "1081",     "Prmrn as zpracovn (milisekundy) na zpracovn paketu RTMP na tomto portu.",

    "1083",     "Poet paket RTMP za sekundu, pijatch protokolem AppleTalk na tomto portu.",

    "1085",     "Poet poadavk ATP znovu vyslanch na tomto portu.",

    "1087",     "Poet ta uvolnn ATP, kter vyprely na tomto portu.",

    "1089",     "Poet transaknch odpovd ATP pesn jednou za sekundu na tomto portu.",

    "1091",     "Poet transaknch odpovd ATP aspo jednou za sekundu na tomto portu.",

    "1093",     "Poet uvolovacch paket transakce ATP pijatch za sekundu na tomto portu.",

    "1095",     "Aktuln mnostv prostedk nestrnkovan pamti pouvanch protokolem AppleTalk.",

    "1097",     "Poet paket smrovanch dovnit tmto portem.",

    "1099",     "Poet paket odhozench kvli omezenmu mnostv prostedk na portu.",

    "1101",     "Poet poadavk ATP  znovu vyslanch na tento port.",

    "1103",     "Poet paket smrovanch ven tmto portem.",

    "1111",     "Poskytuje statistiky st pro segment mstn st prostednictvm sluby Sledovn st.",

    "1113",     "Celkov poet rmc pijatch za sekundu na tomto segmentu st.",

    "1115",     "Poet bajt pijatch za sekundu na tomto segmentu st.",

    "1117",     "Poet vesmrov vyslanch rmc pijatch za sekundu na tomto segmentu st.",

    "1119",     "Poet vcesmrov vyslanch rmc pijatch za sekundu na tomto segmentu st.",

    "1121",     "Procenta ky sovho psma pouvanho tmto segmentem st.",

    "1125",     "Procenta ky sovho psma vytvoenho vesmrovou pepravou na segmentu st.",

    "1127",     "Procenta ky sovho psma vytvoenho vcesmrovm penosem na segmentu st.",

    "1151",     "Telefonn subsystm",

    "1153",     "Poet telefonnch linek obsluhovanch potaem.",

    "1155",     "Poet telefonnch zazen obsluhovanch potaem.",

    "1157",     "Poet telefonnch linek obsluhovanch potaem, kter jsou prv aktivn.",

    "1159",     "Poet telefonnch zazen, kter jsou prv sledovna.",

    "1161",     "Mra odchozch hovor provedench tmto potaem.",

    "1163",     "Mra pchozch hovor zodpovzench tmto potaem.",

    "1165",     "Poet aplikac, kter momentln pouvaj telefonn sluby.",

    "1167",     "Aktuln odchoz hovory obsluhovan tmto potaem.",

    "1169",     "Aktuln pchoz hovory obsluhovan tmto potaem.",

    "1229",     "Objekt sledovn vkonu Brny pro systm NetWare obsahuje tae mc vkon sluby serveru gateway.",

    "1231",     "Objekt sledovn vkonu Klienta systmu NetWare obsahuje tae sledujc rychlosti penosu paket, pihlen a pipojen.",

    "1233",     "Poet dvek paket ten NCP/s je rychlost poadavk protokol jdra NetWare na dvkov ten paketu. Dvka paket je protokol zlepujc vkon.",

    "1235",     "Opakovn dvek paket ten/s ,je rychlost, jakou sluba NetWare potebuje znovu vyslat poadavek dvkovho ten, protoe serveru NetWare trvala odpov pli dlouho.",

    "1237",     "Poet dvek paket zpisu NCP/s je rychlost poadavk protokol jdra NetWare na dvkov zpis paketu. Dvka paket je protokol zlepujc vkon.",

    "1239",     "Opakovn dvek paket zpisu/s ,je rychlost, jakou sluba NetWare potebuje znovu vyslat poadavek dvkovho zpisu, protoe serveru NetWare trvala odpov pli dlouho.",

    "1241",     "I/O dvek paket/s je souet potu dvek paket ten NCP/s a potu dvek paket zpisu NCP/s.",

    "1243",     "Pipojen NetWare 2.x pot pipojen k serverm NetWare 2.x.",

    "1245",     "Pipojen NetWare 3.x pot pipojen k serverm NetWare 3.x.",

    "1247",     "Pipojen NetWare 4.x pot pipojen k serverm NetWare 4.x.",

    "1261",     "Celkem pipojen zahrnuje veker interaktivn pipojen, sov pipojen, pipojen slueb, spn pipojen a chybn pipojen od poslednho sputn potae.",

    "1301",     "Objekt sledovn vkonu pracovn fronty serveru obsahuje tae sledujc dlky front a objekty ve frontch.",

    "1303",     "Dlka fronty je aktuln dlka pracovn fronty serveru pro tuto CPU. Je-li trvaleji dlka vt ne tyi, ukazuje to na peten serveru. Jedn se o okamitou hodnotu, nikoliv o prmr v ase.",

    "1305",     "Aktivn podprocesy je poet podproces prv pracujcch na poadavku klienta serveru na tuto CPU. Systm se sna udret hodnotu co nejni, aby se omezilo zbyten pepnn kontextu. Jedn se o okamitou hodnotu  pro CPU, nikoliv o prmr v ase.",

    "1307",     "Dostupn podprocesy je poet podproces serveru na tto CPU, kter momentln nepracuj na poadavku od klienta. Server dynamicky upravuje poet podproces tak, aby se maximalizovala vkonnost serveru.",

    "1309",     "Kad poadavek klienta je reprezentovn na serveru jako pracovn poloka. Server obsluhuje fond dostupnch pracovnch poloek pro CPU, aby se zrychlilo zpracovn. Jedn se o okamitou hodnotu  dostupnch pracovnch poloek pro CPU. Je-li trvaleji hodnota blzko nuly, znamen to, e je teba u sluby serveru zvit hodnotu poloky registru MinFreeWorkItems. Hodnota bude vdy 0 v instanci fronty blok.",

    "1311",     "Kad poadavek klienta je reprezentovn na serveru jako pracovn poloka. Server obsluhuje fond dostupnch pracovnch poloek pro CPU, aby se zrychlilo zpracovn. Pokud pro CPU nen dostatek pracovnch poloek, pj si je od jin CPU. Rostouc hodnota tohoto prbnho tae znamen, e je teba u sluby serveru zvit hodnotu poloky registru MaxWorkItems nebo poloky MinFreeWorkItems. Hodnota bude vdy 0 v instanci fronty blok.",

    "1313",     "Kad poadavek klienta je reprezentovn na serveru jako pracovn poloka. Server obsluhuje fond dostupnch pracovnch poloek pro CPU, aby se zrychlilo zpracovn. Hodnota trvaleji vt ne nula znamen, e je teba u sluby serveru zvit hodnotu poloky registru MaxWorkItems. Hodnota bude vdy 0 v instanci fronty blok.",

    "1315",     "Aktuln poet klient je okamit poet klient obsluhovanch touto CPU. Server aktivn udruje rovnovn zaten klienty vech CPU systmu. Hodnota bude vdy 0 v instanci fronty blok.",

    "1317",     "Rychlost, jakou server pijm bajty od sovch klient tto CPU. Hodnota je mrou zaten serveru.",

    "1319",     "Rychlost, jakou server odesl bajty od sovm klientm tto CPU. Hodnota je mrou zaten serveru.",

    "1321",     "Rychlost, jakou server odesl a pijm bajty od sovch klient tto CPU. Hodnota je mrou zaten serveru.",

    "1323",     "Operace ten/s je rychlost, jakou server provd operace ten souboru pro klienty bc na tomto procesoru. Hodnota je mrou zaten serveru. Hodnota bude vdy 0 v instanci fronty blok.",

    "1325",     "Bajty peten/s je rychlost, jakou server te data ze soubor pro klienty bc na tomto procesoru. Hodnota je mrou zaten serveru.",

    "1327",     "Operace zpisu/s je rychlost, jakou server provd operace zpisu souboru pro klienty tto CPU. Hodnota je mrou zaten serveru. Hodnota bude vdy 0 v instanci fronty blok.",

    "1329",     "Bajty zapsan/s je rychlost, jakou server zapisuje data do soubor pro klienty bc na tomto procesoru. Hodnota je mrou zaten serveru.",

    "1331",     "Celkem bajt/s je rychlost, jakou server te a zapisuje data do a ze soubor pro klienty bc na tomto procesoru. Hodnota je mrou Hodnota je mrou zaten serveru.",

    "1333",     "Celkem operac/s je rychlost, jakou server provd operace ten nebo zpisu souboru pro klienty tto CPU. Hodnota je mrou zaten serveru. Hodnota bude vdy 0 v instanci fronty blok.",

    "1335",     "Voln DPC ve front/s je prmrn rychlost, jakou jsou opodn voln procedur (DPC - Deferred Procedure Call) zaazovna do fronty DPC tohoto procesoru. (Voln DPC jsou peruen s ni prioritou ne standardn peruen. Kad procesor m vlastn frontu DPC.) Tento ta m rychlost, jakou jsou voln DPC pidvny do fronty, nikoli poet voln DPC ve front. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn. ",

    "1337",     "ta Rychlost voln DPC udv rychlost, jakou byla voln pozdrench procedur (DPC) pidvna do front DPC procesoru mezi jednotlivmi intervaly asovae hodin procesoru. Voln DPC jsou peruen spoutn s ni prioritou ne standardn peruen.  Kad procesor m vlastn frontu DPC. Tento ta m rychlost, jakou byly voln DPC pidvna do fronty, nikoli poet voln DPC ve front. Tento ta zobrazuje pouze posledn zjitnou hodnotu, nejedn se o prmrnou hodnotu.",

    "1343",     "Celkem voln DPC ve front/s je celkov rychlost, jakou jsou opodn voln procedur (DPC - Deferred Procedure Call) zaazovna do fronty DPC pro vechny procesory v potai. (Voln DPC jsou peruen s ni prioritou ne standardn peruen.) Kad procesor m vlastn frontu DPC. Tento ta m rychlost, jakou jsou voln DPC pidvny do fronty, nikoli poet voln DPC ve front. Jedn se o souet hodnot ta Procesor: Voln DPC ve front/s pro vechny procesory v potai vydlen potem procesor. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn. ",

    "1345",     "Celkov rychlost voln DPC je celkov rychlost, jakou jsou opodn voln procedur (DPC - Deferred Procedure Call) pidvny do fronty DPC vech procesor mezi znakami asovae hodin kadho procesoru. (Voln DPC jsou peruen s ni prioritou ne standardn peruen.) Kad procesor m vlastn frontu DPC. Tento ta m rychlost, jakou jsou voln DPC pidvny do fronty, nikoli poet voln DPC ve front. Jedn se o souet hodnot ta Procesor: Rychlost voln DPC pro vechny procesory v potai vydlen potem procesor. Tento ta zobrazuje pouze posledn zjitnou hodnotu, nejedn se o prmrnou hodnotu. ",

    "1351",     "% vyuit pdlu registru udv v procentech, kolik z celkovho povolenho pdlu registru je vyuvno systmem. Tento ta zobrazuje pouze posledn zjitnou hodnotu, nejedn se o prmrnou hodnotu. ",

    "1361",     "tae, kter obsahuj stav mstnch a systmovch vyhrazen pamti VLM.",

    "1363",     "Pam VLM - % vyuit virtuln velikosti",

    "1365",     "Aktuln velikost virtuln pamti VLM procesu (v bajtech).",

    "1367",     "Vrcholn velikost virtuln pamti VLM vyuit procesem (v bajtech). Tato hodnota obsahuje maximln velikost virtuln pamti VLM procesu od jeho sputn.",

    "1369",     "Aktuln velikost virtuln pamti VLM procesu (v bajtech), kterou lze vyhradit. Poznmka: Maximln povolen hodnota me bt men ne tato hodnota z dvodu fragmentace pamti.",

    "1371",     "Aktuln velikost sven pamti VLM pro aktuln proces (v bajtech).",

    "1373",     "Vrcholn velikost sven pamti VLM pro aktuln proces (v bajtech) od sputn procesu.",

    "1375",     "Aktuln velikost celkov sven pamti VLM pro systm (v bajtech).",

    "1377",     "Vrcholn velikost celkov sven pamti VLM (v bajtech) od sputn systmu.",

    "1379",     "Aktuln velikost celkov sven sdlen pamti VLM (v bajtech) pro systm.",

    "1381",     "ta Kilobajty k dispozici zobrazuje velikost fyzick pamti (v kilobajtech), kter je k dispozici pro pidlen procesu nebo pro pouit systmem. Velikost je urena soutem velikost pamti v spornm reimu (v mezipamti), voln pamti  a v seznamech vynulovan pamti. pln vysvtlen sprvce pamti naleznete v kapitole MSDN and/or the System Performance and Troubleshooting Guide (Prvodce vkonem a odstraovnm pot MSDN a systmu) v sad Windows Server 2003 Resource Kit.",

    "1383",     "ta Megabajty k dispozici zobrazuje velikost fyzick pamti (v megabajtech), kter je k dispozici pro pidlen procesu nebo pro pouit systmem. Velikost je urena soutem velikost pamti v spornm reimu (v mezipamti), voln pamti  a v seznamech vynulovan pamti. pln vysvtlen sprvce pamti naleznete v kapitole MSDN and/or the System Performance and Troubleshooting Guide (Prvodce vkonem a odstraovnm pot MSDN a systmu) v sad Windows Server 2003 Resource Kit.",

    "1401",     "Stedn dlka fronty disku je prmrn poet poadavk na ten nebo zpis, kter byly zaazeny do fronty vybranho disku bhem vzorkovacho intervalu.",

    "1403",     "Stedn dlka fronty ten disku je prmrn poet poadavk na ten, kter byly zaazeny do fronty vybranho disku bhem vzorkovacho intervalu.",

    "1405",     "Stedn dlka fronty zpisu disku je prmrn poet poadavk na zpis, kter byly zaazeny do fronty vybranho disku bhem vzorkovacho intervalu.",

    "1407",     "% vyuvanch svench bajt je pomr hodnot tae Pam\\Sven bajty a Pam\\Mez sven. (Sven pam je vyuit fyzick pam, pro kterou bylo vyhrazeno msto ve strnkovacm souboru pro ppad nutnosti zpisu pamti na disk. Mez sven je urena velikost strnkovacho souboru. Pi zvten strnkovacho souboru je zvtena mez sven a snen pomr). Tento ta zobrazuje pouze aktuln hodnotu, nejedn se o prmrnou hodnotu.",

    "1409",     "Objekt sledovn vkonu pln bitov kopie obsahuje tae, kter sleduj vyuit virtulnho adresovho prostoru bitovch kopi provdnch procesy v potai. tae objektu pln bitov kopie jsou shodn s tai objektu Bitov kopie s vjimkou nzvu instance. Nzev instance v objektu pln bitov kopie obsahuje plnou cestu natench modul, zatmco v ppad objektu Bitov kopie je zobrazen pouze nzev souboru.",

    "1411",     "Hodnota ID vytvejcho procesu obsahuje ID procesu, kter vytvoil dan proces. Vytvejc proces mohl bt po vytvoen tohoto procesu ukonen, take tato hodnota ji nepedstavuje sputn proces.",

    "1413",     "Rychlost dn vstupn-vstupnch operac ten procesem. Tento ta sleduje vekerou vstupn-vstupn aktivitu generovanou procesem, tj. operace souborov, sov a vstupn-vstupnch zazen.",

    "1415",     "Rychlost dn vstupn-vstupnch operac zpisu procesem. Tento ta sleduje vekerou vstupn-vstupn aktivitu generovanou procesem, tj. operace souborov, sov a vstupn-vstupnch zazen.",

    "1417",     "Rychlost dn vstupn-vstupnch operac ten a zpisu procesem. Tento ta sleduje vekerou vstupn-vstupn aktivitu generovanou procesem, tj. operace souborov, sov a vstupn-vstupnch zazen.",

    "1419",     "Rychlost, jakou proces zpracovv jin operace vstupu a vstupu ne operace ten a zpisu (napklad dc funkce). Do tohoto tae jsou zapoteny vechny innosti vstupu a vstupu generovan procesem zahrnujc soubory, s a zazen vstupu a vstupu.",

    "1421",     "Rychlost ten bajt z vstupn-vstupnch operac procesem. Tento ta sleduje vekerou vstupn-vstupn aktivitu generovanou procesem, tj. operace souborov, sov a vstupn-vstupnch zazen.",

    "1423",     "Rychlost zpisu bajt do vstupn-vstupnch operac procesem. Tento ta sleduje vekerou vstupn-vstupn aktivitu generovanou procesem, tj. operace souborov, sov a vstupn-vstupnch zazen.",

    "1425",     "Rychlost ten a zpisu bajt pi vstupn-vstupnch operacch procesem. Tento ta sleduje vekerou vstupn-vstupn aktivitu generovanou procesem, tj. operace souborov, sov a vstupn-vstupnch zazen.",

    "1427",     "Rychlost odesln bajt vstupn-vstupnm operacm, kter neobsahuj data (napklad dc operace), procesem. Tento ta sleduje vekerou vstupn-vstupn aktivitu generovanou procesem, tj. operace souborov, sov a vstupn-vstupnch zazen.",

    "1451",     "Zobraz statistick daje o vkonu tiskov fronty.",

    "1453",     "Celkov poet loh vytitnch z tiskov fronty od minulho restartovn.",

    "1455",     "Poet bajt za sekundu vytitnch z tiskov fronty.",

    "1457",     "Celkov poet strnek vytitnch pomoc rozhran GDI z tiskov fronty od minulho restartovn.",

    "1459",     "Aktuln poet loh v tiskov front.",

    "1461",     "Aktuln poet odkaz (otevench popisova) na tuto tiskrnu.",

    "1463",     "Vrcholov poet odkaz (otevench popisova) na tuto tiskrnu.",

    "1465",     "Aktuln poet zaazench loh v tiskov front.",

    "1467",     "Maximln poet zaazench loh v tiskov front od minulho restartovn.",

    "1469",     "Celkov poet chyb Doel papr v tiskov front od minulho restartovn.",

    "1471",     "Celkov poet chyb Tiskrna nen pipravena v tiskov front od minulho restartovn.",

    "1473",     "Celkov poet chyb loh v tiskov front od minulho restartovn.",

    "1475",     "Celkov poet voln od klient prochzen pro tento tiskov server, kter poaduj seznam prohledvn st, od minulho restartovn.",

    "1477",     "Celkov poet voln od jinch tiskovch server, kter poaduj pidn sdlench sovch tiskren k tomuto serveru, od minulho restartovn.",

    "1479",     "ta Pracovn sada - soukrom zobrazuje velikost pracovn sady v bajtech, kter je pouita pouze pro tento proces a nen sdlena ani ji nelze sdlet s jinmi procesy.",

    "1481",     "ta Pracovn sada - sdlen zobrazuje velikost pracovn sady (v bajtech), kterou lze sdlet a me bt pouita jinmi procesy. To, e lze st pracovn sady procesu sdlet, neznamen, e existuje proces, kter ji pouv.",

    "1483",     "ta % asu neinnosti obsahuje procento doby intervalu vzorkovn, po kterou byl disk neinn.",

    "1485",     "ta Dlen vstupn-vstupnch operac/s obsahuje rychlost dlen vstupn-vstupnch diskovch operac na vce operac. Dlen je obvykle dsledkem toho, e poadovan data jsou pli velk pro jedinou operaci nebo e disk je fragmentovn.",

    "1501",     "Obsahuje data tovn a vyuit procesoru zskan vemi aktivnmi pojmenovanmi objektu loh.",

    "1503",     "Aktuln % asu procesoru zobrazuje procento doby vzorkovacho intervalu, po kterou proces v objektu lohy vykonval kd.",

    "1505",     "ta Aktuln % asu uivatelskho reimu zobrazuje procento doby vzorkovacho intervalu, po kterou proces v objektu lohy vykonval kd v uivatelskm reimu.",

    "1507",     "ta Aktuln % asu reimu jdra zobrazuje procento doby vzorkovacho intervalu, po kterou proces v objektu lohy vykonval kd v reimu jdra nebo privilegovanm reimu.",

    "1509",     "ta Tato perioda - procesor zobrazuje v milisekundch as procesoru pouit vemi procesy obsaenmi v objektu lohy, vetn ukonench proces a proces, kter ji k objektu nejsou pidrueny, od okamiku dosaen asovho limitu lohy.",

    "1511",     "ta Tato perioda ms - uivatelsk reim zobrazuje v milisekundch as procesoru v uivatelskm reimu pouit vemi procesy obsaenmi v objektu lohy, vetn ukonench proces a proces, kter ji k objektu nejsou pidrueny, od okamiku dosaen asovho limitu lohy.",

    "1513",     "ta Tato perioda ms - reim jdra zobrazuje v milisekundch as procesoru v reimu jdra pouit vemi procesy obsaenmi v objektu lohy, vetn ukonench proces a proces, kter ji k objektu nejsou pidrueny, od okamiku dosaen asovho limitu lohy.",

    "1515",     "ta Strnky/s zobrazuje rychlost vskytu chyb strnek vech proces v objektu lohy.",

    "1517",     "ta Poet proces - celkem zobrazuje poet proces (aktivnch i ukonench), kter jsou nebo byly pidrueny k objektu lohy.",

    "1519",     "ta Poet proces - aktivn zobrazuje poet proces, kter jsou aktuln pidrueny k objektu lohy.",

    "1521",     "ta Poet proces - ukonen zobrazuje poet proces, kter byly ukoneny z dvodu naruen limitu.",

    "1523",     "ta Celkem ms - procesor zobrazuje v milisekundch as procesoru pouit vemi procesy obsaenmi v objektu lohy, vetn ukonench proces a proces, kter ji k objektu nejsou pidrueny, od okamiku vytvoen objektu lohy.",

    "1525",     "ta Celkem ms - uivatelsk reim zobrazuje v milisekundch as procesoru v uivatelskm reimu pouit vemi procesy obsaenmi v objektu lohy, vetn ukonench proces a proces, kter ji k objektu nejsou pidrueny, od okamiku vytvoen objektu lohy.",

    "1527",     "ta Celkem ms - reim jdra zobrazuje v milisekundch as procesoru v reimu jdra pouit vemi procesy obsaenmi v objektu lohy, vetn ukonench proces a proces, kter ji k objektu nejsou pidrueny, od okamiku vytvoen objektu lohy.",

    "1549",     "ta Podrobnosti objektu loha zobrazuje podrobn informace o vkonu aktivnch proces, kter tvo objekt lohy.",

    "1537",     "ta Pli velk pijat pakety zobrazuje poet pijatch paket, kter jsou vt, ne bylo oekvno.",

    "1539",     "ta Pijat dotazy na lenstv zobrazuje poet pijatch paket, kter se dotazuj na sv lenstv ve skupin.",

    "1541",     "ta Pijat zprvy o lenstv zobrazuje poet pijatch paket, kter hls sv lenstv ve skupin.",

    "1543",     "ta Pijat snen lenstv zobrazuje poet pijatch paket, kter zruily sv lenstv ve skupin.",

    "1545",     "ta Pijat vydn smrovae zobrazuje poet pijatch paket, kter vyaduj smrova.",

    "1547",     "ta Pijat inzerce smrovae zobrazuje poet pijatch paket, kter inzeruj smrova.",

    "1551",     "ta Pijat vydn souseda zobrazuje poet pijatch paket, kter vyaduj souseda.",

    "1553",     "ta Pijat inzerce souseda zobrazuje poet pijatch paket, kter inzeruj souseda.",

    "1555",     "ta Pli velk odeslan pakety zobrazuje poet odeslanch paket, kter jsou vt, ne bylo oekvno.",

    "1557",     "ta Odeslan dotazy na lenstv zobrazuje poet odeslanch paket, kter se dotazuj na sv lenstv ve skupin.",

    "1559",     "ta Odeslan zprvy o lenstv zobrazuje poet odeslanch paket, kter hls sv lenstv ve skupin.",

    "1561",     "ta Odeslan snen lenstv zobrazuje poet odeslanch paket, kter zruily sv lenstv ve skupin.",

    "1563",     "ta Odeslan vydn smrovae zobrazuje poet odeslanch paket, kter vyaduj smrova.",

    "1565",     "ta Odeslan inzerce smrovae zobrazuje poet odeslanch paket, kter inzeruj smrova.",

    "1567",     "ta Odeslan vydn souseda zobrazuje poet odeslanch paket, kter vyaduj souseda.",

    "1569",     "ta Odeslan inzerce souseda zobrazuje poet odeslanch paket, kter inzeruj souseda.",

    "1747",     "ta % asu neinnosti udv procentuln dobu neinnosti procesoru bhem intervalu vzorkovn.",

    "1749",     "ta % asu reimu C1 udv procento asu, kdy byl procesor v spornm reimu neinnosti C1. % asu reimu C1 je soust celkov doby neinnosti procesoru. sporn reim neinnosti C1 umouje procesoru zachovat pln kontext a rychle pejt do bnho reimu. Ne vechny systmy podporuj reim C1.",

    "1751",     "ta % asu reimu C2 udv procento asu, kdy byl procesor v spornm reimu neinnosti C2. % asu reimu C2 je soust celkov doby neinnosti procesoru. sporn reim neinnosti C1 umouje procesoru zachovat kontext mezipamt systmu. sporn reim neinnosti C2 je reim s ni spotebou a del ekac dobou pi pechodu do bnho reimu ne reim C1. Ne vechny systmy podporuj reim C2.",

    "1753",     "ta % asu reimu C3 udv procento asu, kdy byl procesor v spornm reimu neinnosti C3. % asu reimu C3 je soust celkov doby neinnosti procesoru. Pokud je procesor v spornm reimu neinnosti C3, nelze zachovat souvislost jeho mezipamt. sporn reim neinnosti C3 je reim s ni spotebou a del ekac dobou pi pechodu do bnho reimu ne reim C2. Ne vechny systmy podporuj reim C3.",

    "1755",     "ta Pechody do reimu C1/s udv etnost pechodu procesoru do spornho reimu neinnosti C1. Procesor pejde do reimu C1, pokud je doba neinnosti dostaten dlouh. Pi jakmkoli peruen je tento reim ukonen. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn.",

    "1757",     "ta Pechody do reimu C2/s udv etnost pechodu procesoru do spornho reimu neinnosti C2. Procesor pejde do reimu C2, pokud je doba neinnosti dostaten dlouh. Pi jakmkoli peruen je tento reim ukonen. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn.",

    "1759",     "ta Pechody do reimu C3/s udv etnost pechodu procesoru do spornho reimu neinnosti C3. Procesor pejde do reimu C3, pokud je doba neinnosti dostaten dlouh. Pi jakmkoli peruen je tento reim ukonen. Tento ta zobrazuje rozdl mezi hodnotami zjitnmi v poslednch dvou vzorcch, vydlen dlkou intervalu vzorkovn.",

    "1761",     "tae vkonu haldy pro nutn pouit haldy",

    "1763",     "Pam aktivn pouvan touto haldou (voln bajty + pidlen bajty).",

    "1765",     "Celkov virtuln adresov prostor vyhrazen pro tuto haldu (zahrnuje nesven rozsahy).",

    "1767",     "Hodnota ReservedBytes minus posledn nesven rozsah v kadm segmentu.",

    "1769",     "Pam v seznamech volnch blok v tto hald (nezahrnuje nesven rozsahy nebo bloky v mezipamti haldy).",

    "1771",     "Poet blok v seznamu volnch boku vtch ne 1 kB.",

    "1773",     "1/Prmrn as vyhrazen (mimo vyhrazen z mezipamti haldy).",

    "1775",     "1/Prmrn as uvolnn (mimo uvolnn do mezipamti haldy).",

    "1777",     "Poet nesvench rozsah ve vyhrazen virtuln adrese.",

    "1779",     "Rozdl mezi potem vyhrazen a uvolnn (pro zjitn pamti, kter neme bt uvolnna automaticky).",

    "1781",     "Piazen/s z mezipamti haldy",

    "1783",     "Uvolnn/s z mezipamti haldy",

    "1785",     "Vyhrazen/s s velikost men ne 1 kB (vetn mezipamti haldy).",

    "1787",     "Uvolnn/s s velikost men ne 1 kB (vmetne mezipamti haldy).",

    "1789",     "Piazen/s s velikost mezi 1 a 8 kB",

    "1791",     "Uvolnn/s s velikost mezi 1 a 8 kB",

    "1793",     "Piazen/s s velikost vt ne 8 kB",

    "1795",     "Uvolnn/s s velikost vt ne 8 kB",

    "1797",     "Piazen/s (vetn z mezipamti haldy)",

    "1799",     "Uvolnn/s (vetn do mezipamti haldy)",

    "1801",     "Celkov poet blok v mezipamti haldy.",

    "1803",     "Nejvt poet blok libovoln velikosti v mezipamti haldy.",

    "1805",     "(UvolnnBajty / PotvrzenBajty) *100",

    "1807",     "(VirtulnBajty / VyhrazenBajty) * 100",

    "1809",     "Kolize zmku haldy/s",

    "1847",     "Znaka konce",
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\cht\prfc0404.ini ===
"1",     "1847",

    "2",     "System",

    "4",     "Memory",

    "6",     "% Processor Time",

    "10",     "File Read Operations/sec",

    "12",     "File Write Operations/sec",

    "14",     "File Control Operations/sec",

    "16",     "File Read Bytes/sec",

    "18",     "File Write Bytes/sec",

    "20",     "File Control Bytes/sec",

    "24",     "Available Bytes",

    "26",     "Committed Bytes",

    "28",     "Page Faults/sec",

    "30",     "Commit Limit",

    "32",     "Write Copies/sec",

    "34",     "Transition Faults/sec",

    "36",     "Cache Faults/sec",

    "38",     "Demand Zero Faults/sec",

    "40",     "Pages/sec",

    "42",     "Page Reads/sec",

    "44",     "Processor Queue Length",

    "46",     "Thread State",

    "48",     "Pages Output/sec",

    "50",     "Page Writes/sec",

    "52",     "Browser",

    "54",     "Announcements Server/sec",

    "56",     "Pool Paged Bytes",

    "58",     "Pool Nonpaged Bytes",

    "60",     "Pool Paged Allocs",

    "64",     "Pool Nonpaged Allocs",

    "66",     "Pool Paged Resident Bytes",

    "68",     "System Code Total Bytes",

    "70",     "System Code Resident Bytes",

    "72",     "System Driver Total Bytes",

    "74",     "System Driver Resident Bytes",

    "76",     "System Cache Resident Bytes",

    "78",     "Announcements Domain/sec",

    "80",     "Election Packets/sec",

    "82",     "Mailslot Writes/sec",

    "84",     "Server List Requests/sec",

    "86",     "Cache",

    "88",     "Data Maps/sec",

    "90",     "Sync Data Maps/sec",

    "92",     "Async Data Maps/sec",

    "94",     "Data Map Hits %",

    "96",     "Data Map Pins/sec",

    "98",     "Pin Reads/sec",

    "100",     "Sync Pin Reads/sec",

    "102",     "Async Pin Reads/sec",

    "104",     "Pin Read Hits %",

    "106",     "Copy Reads/sec",

    "108",     "Sync Copy Reads/sec",

    "110",     "Async Copy Reads/sec",

    "112",     "Copy Read Hits %",

    "114",     "MDL Reads/sec",

    "116",     "Sync MDL Reads/sec",

    "118",     "Async MDL Reads/sec",

    "120",     "MDL Read Hits %",

    "122",     "Read Aheads/sec",

    "124",     "Fast Reads/sec",

    "126",     "Sync Fast Reads/sec",

    "128",     "Async Fast Reads/sec",

    "130",     "Fast Read Resource Misses/sec",

    "132",     "Fast Read Not Possibles/sec",

    "134",     "Lazy Write Flushes/sec",

    "136",     "Lazy Write Pages/sec",

    "138",     "Data Flushes/sec",

    "140",     "Data Flush Pages/sec",

    "142",     "% User Time",

    "144",     "% Privileged Time",

    "146",     "Context Switches/sec",

    "148",     "Interrupts/sec",

    "150",     "System Calls/sec",

    "152",     "Level 1 TLB Fills/sec",

    "154",     "Level 2 TLB Fills/sec",

    "156",     "Enumerations Server/sec",

    "158",     "Enumerations Domain/sec",

    "160",     "Enumerations Other/sec",

    "162",     "Missed Server Announcements",

    "164",     "Missed Mailslot Datagrams",

    "166",     "Missed Server List Requests",

    "168",     "Server Announce Allocations Failed/sec",

    "170",     "Mailslot Allocations Failed",

    "172",     "Virtual Bytes Peak",

    "174",     "Virtual Bytes",

    "178",     "Working Set Peak",

    "180",     "Working Set",

    "182",     "Page File Bytes Peak",

    "184",     "Page File Bytes",

    "186",     "Private Bytes",

    "188",     "Announcements Total/sec",

    "190",     "Enumerations Total/sec",

    "198",     "Current Disk Queue Length",

    "200",     "% Disk Time",

    "202",     "% Disk Read Time",

    "204",     "% Disk Write Time",

    "206",     "Avg. Disk sec/Transfer",

    "208",     "Avg. Disk sec/Read",

    "210",     "Avg. Disk sec/Write",

    "212",     "Disk Transfers/sec",

    "214",     "Disk Reads/sec",

    "216",     "Disk Writes/sec",

    "218",     "Disk Bytes/sec",

    "220",     "Disk Read Bytes/sec",

    "222",     "Disk Write Bytes/sec",

    "224",     "Avg. Disk Bytes/Transfer",

    "226",     "Avg. Disk Bytes/Read",

    "228",     "Avg. Disk Bytes/Write",

    "230",     "Process",

    "232",     "Thread",

    "234",     "PhysicalDisk",

    "236",     "LogicalDisk",

    "238",     "Processor",

    "240",     "% Total Processor Time",

    "242",     "% Total User Time",

    "244",     "% Total Privileged Time",

    "246",     "Total Interrupts/sec",

    "248",     "Processes",

    "250",     "Threads",

    "252",     "Events",

    "254",     "Semaphores",

    "256",     "Mutexes",

    "258",     "Sections",

    "260",     "Objects",

    "262",     "Redirector",

    "264",     "Bytes Received/sec",

    "266",     "Packets Received/sec",

    "268",     "Read Bytes Paging/sec",

    "270",     "Read Bytes Non-Paging/sec",

    "272",     "Read Bytes Cache/sec",

    "274",     "Read Bytes Network/sec",

    "276",     "Bytes Transmitted/sec",

    "278",     "Packets Transmitted/sec",

    "280",     "Write Bytes Paging/sec",

    "282",     "Write Bytes Non-Paging/sec",

    "284",     "Write Bytes Cache/sec",

    "286",     "Write Bytes Network/sec",

    "288",     "Read Operations/sec",

    "290",     "Read Operations Random/sec",

    "292",     "Read Packets/sec",

    "294",     "Reads Large/sec",

    "296",     "Read Packets Small/sec",

    "298",     "Write Operations/sec",

    "300",     "Write Operations Random/sec",

    "302",     "Write Packets/sec",

    "304",     "Writes Large/sec",

    "306",     "Write Packets Small/sec",

    "308",     "Reads Denied/sec",

    "310",     "Writes Denied/sec",

    "312",     "Network Errors/sec",

    "314",     "Server Sessions",

    "316",     "Server Reconnects",

    "318",     "Connects Core",

    "320",     "Connects Lan Manager 2.0",

    "322",     "Connects Lan Manager 2.1",

    "324",     "Connects Windows NT",

    "326",     "Server Disconnects",

    "328",     "Server Sessions Hung",

    "330",     "Server",

    "336",     "Thread Wait Reason",

    "340",     "Sessions Timed Out",

    "342",     "Sessions Errored Out",

    "344",     "Sessions Logged Off",

    "346",     "Sessions Forced Off",

    "348",     "Errors Logon",

    "350",     "Errors Access Permissions",

    "352",     "Errors Granted Access",

    "354",     "Errors System",

    "356",     "Blocking Requests Rejected",

    "358",     "Work Item Shortages",

    "360",     "Files Opened Total",

    "362",     "Files Open",

    "366",     "File Directory Searches",

    "370",     "Pool Nonpaged Failures",

    "372",     "Pool Nonpaged Peak",

    "376",     "Pool Paged Failures",

    "378",     "Pool Paged Peak",

    "388",     "Bytes Total/sec",

    "392",     "Current Commands",

    "398",     "NWLink NetBIOS",

    "400",     "Packets/sec",

    "404",     "Context Blocks Queued/sec",

    "406",     "File Data Operations/sec",

    "408",     "% Free Space",

    "410",     "Free Megabytes",

    "412",     "Connections Open",

    "414",     "Connections No Retries",

    "416",     "Connections With Retries",

    "418",     "Disconnects Local",

    "420",     "Disconnects Remote",

    "422",     "Failures Link",

    "424",     "Failures Adapter",

    "426",     "Connection Session Timeouts",

    "428",     "Connections Canceled",

    "430",     "Failures Resource Remote",

    "432",     "Failures Resource Local",

    "434",     "Failures Not Found",

    "436",     "Failures No Listen",

    "438",     "Datagrams/sec",

    "440",     "Datagram Bytes/sec",

    "442",     "Datagrams Sent/sec",

    "444",     "Datagram Bytes Sent/sec",

    "446",     "Datagrams Received/sec",

    "448",     "Datagram Bytes Received/sec",

    "452",     "Packets Sent/sec",

    "456",     "Frames/sec",

    "458",     "Frame Bytes/sec",

    "460",     "Frames Sent/sec",

    "462",     "Frame Bytes Sent/sec",

    "464",     "Frames Received/sec",

    "466",     "Frame Bytes Received/sec",

    "468",     "Frames Re-Sent/sec",

    "470",     "Frame Bytes Re-Sent/sec",

    "472",     "Frames Rejected/sec",

    "474",     "Frame Bytes Rejected/sec",

    "476",     "Expirations Response",

    "478",     "Expirations Ack",

    "480",     "Window Send Maximum",

    "482",     "Window Send Average",

    "484",     "Piggyback Ack Queued/sec",

    "486",     "Piggyback Ack Timeouts",

    "488",     "NWLink IPX",

    "490",     "NWLink SPX",

    "492",     "NetBEUI",

    "494",     "NetBEUI Resource",

    "496",     "Used Maximum",

    "498",     "Used Average",

    "500",     "Times Exhausted",

    "502",     "NBT Connection",

    "506",     "Bytes Sent/sec",

    "508",     "Total Bytes/sec",

    "510",     "Network Interface",

    "512",     "Bytes/sec",

    "520",     "Current Bandwidth",

    "524",     "Packets Received Unicast/sec",

    "526",     "Packets Received Non-Unicast/sec",

    "528",     "Packets Received Discarded",

    "530",     "Packets Received Errors",

    "532",     "Packets Received Unknown",

    "536",     "Packets Sent Unicast/sec",

    "538",     "Packets Sent Non-Unicast/sec",

    "540",     "Packets Outbound Discarded",

    "542",     "Packets Outbound Errors",

    "544",     "Output Queue Length",

    "546",     "IPv4",

    "548",     "IPv6",

    "552",     "Datagrams Received Header Errors",

    "554",     "Datagrams Received Address Errors",

    "556",     "Datagrams Forwarded/sec",

    "558",     "Datagrams Received Unknown Protocol",

    "560",     "Datagrams Received Discarded",

    "562",     "Datagrams Received Delivered/sec",

    "566",     "Datagrams Outbound Discarded",

    "568",     "Datagrams Outbound No Route",

    "570",     "Fragments Received/sec",

    "572",     "Fragments Re-assembled/sec",

    "574",     "Fragment Re-assembly Failures",

    "576",     "Fragmented Datagrams/sec",

    "578",     "Fragmentation Failures",

    "580",     "Fragments Created/sec",

    "582",     "ICMP",

    "584",     "Messages/sec",

    "586",     "Messages Received/sec",

    "588",     "Messages Received Errors",

    "590",     "Received Dest. Unreachable",

    "592",     "Received Time Exceeded",

    "594",     "Received Parameter Problem",

    "596",     "Received Source Quench",

    "598",     "Received Redirect/sec",

    "600",     "Received Echo/sec",

    "602",     "Received Echo Reply/sec",

    "604",     "Received Timestamp/sec",

    "606",     "Received Timestamp Reply/sec",

    "608",     "Received Address Mask",

    "610",     "Received Address Mask Reply",

    "612",     "Messages Sent/sec",

    "614",     "Messages Outbound Errors",

    "616",     "Sent Destination Unreachable",

    "618",     "Sent Time Exceeded",

    "620",     "Sent Parameter Problem",

    "622",     "Sent Source Quench",

    "624",     "Sent Redirect/sec",

    "626",     "Sent Echo/sec",

    "628",     "Sent Echo Reply/sec",

    "630",     "Sent Timestamp/sec",

    "632",     "Sent Timestamp Reply/sec",

    "634",     "Sent Address Mask",

    "636",     "Sent Address Mask Reply",

    "638",     "TCPv4",

    "640",     "Segments/sec",

    "642",     "Connections Established",

    "644",     "Connections Active",

    "646",     "Connections Passive",

    "648",     "Connection Failures",

    "650",     "Connections Reset",

    "652",     "Segments Received/sec",

    "654",     "Segments Sent/sec",

    "656",     "Segments Retransmitted/sec",

    "658",     "UDPv4",

    "660",     "% Total DPC Time",

    "662",     "% Total Interrupt Time",

    "664",     "Datagrams No Port/sec",

    "666",     "Datagrams Received Errors",

    "670",     "Disk Storage Unit",

    "672",     "Allocation Failures",

    "674",     "System Up Time",

    "676",     "System Handle Count",

    "678",     "Free System Page Table Entries",

    "680",     "Thread Count",

    "682",     "Priority Base",

    "684",     "Elapsed Time",

    "686",     "Alignment Fixups/sec",

    "688",     "Exception Dispatches/sec",

    "690",     "Floating Emulations/sec",

    "692",     "Logon/sec",

    "694",     "Priority Current",

    "696",     "% DPC Time",

    "698",     "% Interrupt Time",

    "700",     "Paging File",

    "702",     "% Usage",

    "704",     "% Usage Peak",

    "706",     "Start Address",

    "708",     "User PC",

    "710",     "Mapped Space No Access",

    "712",     "Mapped Space Read Only",

    "714",     "Mapped Space Read/Write",

    "716",     "Mapped Space Write Copy",

    "718",     "Mapped Space Executable",

    "720",     "Mapped Space Exec Read Only",

    "722",     "Mapped Space Exec Read/Write",

    "724",     "Mapped Space Exec Write Copy",

    "726",     "Reserved Space No Access",

    "728",     "Reserved Space Read Only",

    "730",     "Reserved Space Read/Write",

    "732",     "Reserved Space Write Copy",

    "734",     "Reserved Space Executable",

    "736",     "Reserved Space Exec Read Only",

    "738",     "Reserved Space Exec Read/Write",

    "740",     "Image",

    "742",     "Reserved Space Exec Write Copy",

    "744",     "Unassigned Space No Access",

    "746",     "Unassigned Space Read Only",

    "748",     "Unassigned Space Read/Write",

    "750",     "Unassigned Space Write Copy",

    "752",     "Unassigned Space Executable",

    "754",     "Unassigned Space Exec Read Only",

    "756",     "Unassigned Space Exec Read/Write",

    "758",     "Unassigned Space Exec Write Copy",

    "760",     "Image Space No Access",

    "762",     "Image Space Read Only",

    "764",     "Image Space Read/Write",

    "766",     "Image Space Write Copy",

    "768",     "Image Space Executable",

    "770",     "Image Space Exec Read Only",

    "772",     "Image Space Exec Read/Write",

    "774",     "Image Space Exec Write Copy",

    "776",     "Bytes Image Reserved",

    "778",     "Bytes Image Free",

    "780",     "Bytes Reserved",

    "782",     "Bytes Free",

    "784",     "ID Process",

    "786",     "Process Address Space",

    "788",     "No Access",

    "790",     "Read Only",

    "792",     "Read/Write",

    "794",     "Write Copy",

    "796",     "Executable",

    "798",     "Exec Read Only",

    "800",     "Exec Read/Write",

    "802",     "Exec Write Copy",

    "804",     "ID Thread",

    "806",     "Mailslot Receives Failed",

    "808",     "Mailslot Writes Failed",

    "810",     "Mailslot Opens Failed/sec",

    "812",     "Duplicate Master Announcements",

    "814",     "Illegal Datagrams/sec",

    "816",     "Thread Details",

    "818",     "Cache Bytes",

    "820",     "Cache Bytes Peak",

    "822",     "Pages Input/sec",

    "824",     "Transition Pages RePurposed/sec",

    "870",     "RAS Port",

    "872",     "Bytes Transmitted",

    "874",     "Bytes Received",

    "876",     "Frames Transmitted",

    "878",     "Frames Received.",

    "880",     "Percent Compression Out",

    "882",     "Percent Compression In",

    "884",     "CRC Errors",

    "886",     "Timeout Errors",

    "888",     "Serial Overrun Errors",

    "890",     "Alignment Errors",

    "892",     "Buffer Overrun Errors",

    "894",     "Total Errors",

    "896",     "Bytes Transmitted/Sec",

    "898",     "Bytes Received/Sec",

    "900",     "Frames Transmitted/Sec",

    "902",     "Frames Received/Sec",

    "904",     "Total Errors/Sec",

    "906",     "RAS Total",

    "908",     "Total Connections",

    "920",     "WINS Server",

    "922",     "Unique Registrations/sec",

    "924",     "Group Registrations/sec",

    "926",     "Total Number of Registrations/sec",

    "928",     "Unique Renewals/sec",

    "930",     "Group Renewals/sec",

    "932",     "Total Number of Renewals/sec",

    "934",     "Releases/sec",

    "936",     "Queries/sec",

    "938",     "Unique Conflicts/sec",

    "940",     "Group Conflicts/sec",

    "942",     "Total Number of Conflicts/sec",

    "944",     "Successful Releases/sec",

    "946",     "Failed Releases/sec",

    "948",     "Successful Queries/sec",

    "950",     "Failed Queries/sec",

    "952",     "Handle Count",

    "1000",     "MacFile Server",

    "1002",     "Max Paged Memory",

    "1004",     "Current Paged Memory",

    "1006",     "Max NonPaged Memory",

    "1008",     "Current NonPaged memory",

    "1010",     "Current Sessions",

    "1012",     "Maximum Sessions",

    "1014",     "Current Files Open",

    "1016",     "Maximum Files Open",

    "1018",     "Failed Logons",

    "1020",     "Data Read/sec",

    "1022",     "Data Written/sec",

    "1024",     "Data Received/sec",

    "1026",     "Data Transmitted/sec",

    "1028",     "Current Queue Length",

    "1030",     "Maximum Queue Length",

    "1032",     "Current Threads",

    "1034",     "Maximum Threads",

    "1050",     "AppleTalk",

    "1052",     "Packets In/sec",

    "1054",     "Packets Out/sec",

    "1056",     "Bytes In/sec",

    "1058",     "Bytes Out/sec",

    "1060",     "Average Time/DDP Packet",

    "1062",     "DDP Packets/sec",

    "1064",     "Average Time/AARP Packet",

    "1066",     "AARP Packets/sec",

    "1068",     "Average Time/ATP Packet",

    "1070",     "ATP Packets/sec",

    "1072",     "Average Time/NBP Packet",

    "1074",     "NBP Packets/sec",

    "1076",     "Average Time/ZIP Packet",

    "1078",     "ZIP Packets/sec",

    "1080",     "Average Time/RTMP Packet",

    "1082",     "RTMP Packets/sec",

    "1084",     "ATP Retries Local",

    "1086",     "ATP Response Timouts",

    "1088",     "ATP XO Response/Sec",

    "1090",     "ATP ALO Response/Sec",

    "1092",     "ATP Recvd Release/Sec",

    "1094",     "Current NonPaged Pool",

    "1096",     "Packets Routed In/Sec",

    "1098",     "Packets dropped",

    "1100",     "ATP Retries Remote",

    "1102",     "Packets Routed Out/Sec",

    "1110",     "Network Segment",

    "1112",     "Total frames received/second",

    "1114",     "Total bytes received/second",

    "1116",     "Broadcast frames received/second",

    "1118",     "Multicast frames received/second",

    "1120",     "% Network utilization",

    "1124",     "% Broadcast Frames",

    "1126",     "% Multicast Frames",

    "1150",     "Telephony",

    "1152",     "Lines",

    "1154",     "Telephone Devices",

    "1156",     "Active Lines",

    "1158",     "Active Telephones",

    "1160",     "Outgoing Calls/sec",

    "1162",     "Incoming Calls/sec",

    "1164",     "Client Apps",

    "1166",     "Current Outgoing Calls",

    "1168",     "Current Incoming Calls",

    "1228",     "Gateway Service For NetWare",

    "1230",     "Client Service For NetWare",

    "1232",     "Packet Burst Read NCP Count/sec",

    "1234",     "Packet Burst Read Timeouts/sec",

    "1236",     "Packet Burst Write NCP Count/sec",

    "1238",     "Packet Burst Write Timeouts/sec",

    "1240",     "Packet Burst IO/sec",

    "1242",     "Connect NetWare 2.x",

    "1244",     "Connect NetWare 3.x",

    "1246",     "Connect NetWare 4.x",

    "1260",     "Logon Total",

    "1300",     "Server Work Queues",

    "1302",     "Queue Length",

    "1304",     "Active Threads",

    "1306",     "Available Threads",

    "1308",     "Available Work Items",

    "1310",     "Borrowed Work Items",

    "1312",     "Work Item Shortages",

    "1314",     "Current Clients",

    "1320",     "Bytes Transferred/sec",

    "1324",     "Read Bytes/sec",

    "1328",     "Write Bytes/sec",

    "1332",     "Total Operations/sec",

    "1334",     "DPCs Queued/sec",

    "1336",     "DPC Rate",

    "1342",     "Total DPCs Queued/sec",

    "1344",     "Total DPC Rate",

    "1350",     "% Registry Quota In Use",

    "1360",     "VL Memory",

    "1362",     "VLM % Virtual Size In Use",

    "1364",     "VLM Virtual Size",

    "1366",     "VLM Virtual Size Peak ",

    "1368",     "VLM Virtual Size Available",

    "1370",     "VLM Commit Charge",

    "1372",     "VLM Commit Charge Peak",

    "1374",     "System VLM Commit Charge",

    "1376",     "System VLM Commit Charge Peak",

    "1378",     "System VLM Shared Commit Charge",

    "1380",     "Available KBytes",

    "1382",     "Available MBytes",

    "1400",     "Avg. Disk Queue Length",

    "1402",     "Avg. Disk Read Queue Length",

    "1404",     "Avg. Disk Write Queue Length",

    "1406",     "% Committed Bytes In Use",

    "1408",     "Full Image",

    "1410",     "Creating Process ID",

    "1412",     "IO Read Operations/sec",

    "1414",     "IO Write Operations/sec",

    "1416",     "IO Data Operations/sec",

    "1418",     "IO Other Operations/sec",

    "1420",     "IO Read Bytes/sec",

    "1422",     "IO Write Bytes/sec",

    "1424",     "IO Data Bytes/sec",

    "1426",     "IO Other Bytes/sec",

    "1450",     "Print Queue",

    "1452",     "Total Jobs Printed",

    "1454",     "Bytes Printed/sec",

    "1456",     "Total Pages Printed",

    "1458",     "Jobs",

    "1460",     "References",

    "1462",     "Max References",

    "1464",     "Jobs Spooling",

    "1466",     "Max Jobs Spooling",

    "1468",     "Out of Paper Errors",

    "1470",     "Not Ready Errors",

    "1472",     "Job Errors",

    "1474",     "Enumerate Network Printer Calls",

    "1476",     "Add Network Printer Calls",

    "1478",     "Working Set - Private",

    "1480",     "Working Set - Shared",

    "1482",     "% Idle Time",

    "1484",     "Split IO/Sec",

    "1500",     "Job Object",

    "1502",     "Current % Processor Time",

    "1504",     "Current % User Mode Time",

    "1506",     "Current % Kernel Mode Time",

    "1508",     "This Period mSec - Processor",

    "1510",     "This Period mSec - User Mode",

    "1512",     "This Period mSec - Kernel Mode",

    "1514",     "Pages/Sec",

    "1516",     "Process Count - Total",

    "1518",     "Process Count - Active",

    "1520",     "Process Count - Terminated",

    "1522",     "Total mSec - Processor",

    "1524",     "Total mSec - User Mode",

    "1526",     "Total mSec - Kernel Mode",

    "1530",     "TCPv6",

    "1532",     "UDPv6",

    "1534",     "ICMPv6",

    "1536",     "Received Packet Too Big",

    "1538",     "Received Membership Query",

    "1540",     "Received Membership Report",

    "1542",     "Received Membership Reduction",

    "1544",     "Received Router Solicit",

    "1546",     "Received Router Advert",

    "1548",     "Job Object Details",

    "1550",     "Received Neighbor Solicit",

    "1552",     "Received Neighbor Advert",

    "1554",     "Sent Packet Too Big",

    "1556",     "Sent Membership Query",

    "1558",     "Sent Membership Report",

    "1560",     "Sent Membership Reduction",

    "1562",     "Sent Router Solicit",

    "1564",     "Sent Router Advert",

    "1566",     "Sent Neighbor Solicit",

    "1568",     "Sent Neighbor Advert",

    "1746",     "% Idle Time",

    "1748",     "% C1 Time",

    "1750",     "% C2 Time",

    "1752",     "% C3 Time",

    "1754",     "C1 Transitions/sec",

    "1756",     "C2 Transitions/sec",

    "1758",     "C3 Transitions/sec",

    "1760",     "Heap",

    "1762",     "Committed Bytes",

    "1764",     "Reserved Bytes",

    "1766",     "Virtual Bytes",

    "1768",     "Free Bytes",

    "1770",     "Free List Length",

    "1772",     "Avg. alloc rate",

    "1774",     "Avg. free rate",

    "1776",     "Uncommitted Ranges Length",

    "1778",     "Allocs - Frees",

    "1780",     "Cached Allocs/sec",

    "1782",     "Cached Frees/sec",

    "1784",     "Allocs <1K/sec",

    "1786",     "Frees <1K/sec",

    "1788",     "Allocs 1-8K/sec",

    "1790",     "Frees 1-8K/sec",

    "1792",     "Allocs over 8K/sec",

    "1794",     "Frees over 8K/sec",

    "1796",     "Total Allocs/sec",

    "1798",     "Total Frees/sec",

    "1800",     "Blocks in Heap Cache",

    "1802",     "Largest Cache Depth",

    "1804",     "% Fragmentation",

    "1806",     "% VAFragmentation",

    "1808",     "Heap Lock contention",

    "1846",     "End Marker";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\cs\perfc005.ini ===
"1",     "1847",

    "2",     "Systm",

    "4",     "Pam",

    "6",     "% asu procesoru",

    "10",     "Operace ten soubor/s",

    "12",     "Operace zpisu soubor/s",

    "14",     "dic souborov operace/s",

    "16",     "Bajty ten soubor/s",

    "18",     "Bajty zpisu soubor/s",

    "20",     "Bajty ovldn soubor/s",

    "24",     "Bajty k dispozici",

    "26",     "Sven bajty",

    "28",     "Chyby strnek/s",

    "30",     "Mez sven",

    "32",     "Zpisy kopi/s",

    "34",     "Chyby pevodu stavu/s",

    "36",     "Chyby mezipamti/s",

    "38",     "Chyby nulovch poadavk/s",

    "40",     "Strnky/s",

    "42",     "ten strnek/s",

    "44",     "Dlka fronty procesoru",

    "46",     "Stav podprocesu",

    "48",     "Vstup strnek/s",

    "50",     "Zpisy strnek/s",

    "52",     "Prohle",

    "54",     "Ohlen server/s",

    "56",     "Bajty strnkovanho fondu",

    "58",     "Bajty nestrnkovanho fondu",

    "60",     "Vyhrazen strnkovanho fondu",

    "64",     "Vyhrazen nestrnkovanho fondu",

    "66",     "Rezidentn bajty strnkovanho fondu",

    "68",     "Celkem bajt kdu systmu",

    "70",     "Rezidentn bajty kdu systmu",

    "72",     "Celkem bajt systmovch ovlada",

    "74",     "Rezidentn bajty systmovch ovlada",

    "76",     "Rezidentn bajty systmov mezipamti",

    "78",     "Ohlen domny/s",

    "80",     "Pakety hlasovn/s",

    "82",     "Zpisy do zsuvky poty/s",

    "84",     "dosti seznamu server/s",

    "86",     "Mezipam",

    "88",     "Mapovn dat/s",

    "90",     "Synchronn mapovn dat/s",

    "92",     "Asynchronn mapovn dat/s",

    "94",     "Zsahy mapovn dat %",

    "96",     "Dren mapovn dat/s",

    "98",     "ten dren/s",

    "100",     "Synchronn ten dren/s",

    "102",     "Asynchronn ten dren/s",

    "104",     "Zsahy ten dren %",

    "106",     "ten kopi/s",

    "108",     "Synchronn ten kopi/s",

    "110",     "Asynchronn ten kopi/s",

    "112",     "Zsahy ten kopi %",

    "114",     "ten MDL/s",

    "116",     "Synchronn ten MDL/s",

    "118",     "Asynchronn ten MDL/s",

    "120",     "Zsahy ten MDL %",

    "122",     "Dopedn ten/s",

    "124",     "Rychl ten/s",

    "126",     "Synchronn rychl ten/s",

    "128",     "Asynchronn rychl ten/s",

    "130",     "Nespn pstupy k prostedkm rychlho ten/s",

    "132",     "Neumonn rychl ten/s",

    "134",     "Dopsn opodnch zpis/s",

    "136",     "Strnky opodnch zpis/s",

    "138",     "Dopsn dat/s",

    "140",     "Dopsn dat strnek/s",

    "142",     "% uivatelskho asu",

    "144",     "% privilegovanho asu",

    "146",     "Pepnut kontextu/s",

    "148",     "Peruen/s",

    "150",     "Voln systmu/s",

    "152",     "Vpln TLB rovn 1/s",

    "154",     "Vpln TLB rovn 2/s",

    "156",     "Vyslen server/s",

    "158",     "Vyslen domn/s",

    "160",     "Vyslen ostatnch/s",

    "162",     "Minut ohlen server",

    "164",     "Minut datagram zsuvek poty",

    "166",     "Minut dost seznamu server",

    "168",     "Chybn alokace ohlen server/s",

    "170",     "Chybn alokace zsuvek poty",

    "172",     "Vrchol virtulnch bajt",

    "174",     "Virtuln bajty",

    "178",     "Vrchol pracovn sady",

    "180",     "Pracovn sada",

    "182",     "Vrchol bajt strnkovacho souboru",

    "184",     "Bajty strnkovacch soubor",

    "186",     "Nesdlen bajty",

    "188",     "Celkem ohlen/s",

    "190",     "Celkem vyslen/s",

    "198",     "Aktuln dlka fronty disku",

    "200",     "% asu disku",

    "202",     "% asu ten disku",

    "204",     "% asu zapisovn disku",

    "206",     "Stedn doba disku/penos",

    "208",     "Stedn doba disku/ten",

    "210",     "Stedn doba disku/zpis",

    "212",     "Penosy disku/s",

    "214",     "ten z disku/s",

    "216",     "Zpisy na disk/s",

    "218",     "Bajt disku/s",

    "220",     "Bajty ten z disku/s",

    "222",     "Bajty zapisovn na disk/s",

    "224",     "Stedn poet bajt disku/penos",

    "226",     "Stedn poet bajt disku/ten",

    "228",     "Stedn poet bajt disku/zpis",

    "230",     "Proces",

    "232",     "Podproces",

    "234",     "Fyzick disk",

    "236",     "Logick disk",

    "238",     "Procesor",

    "240",     "% celkem asu procesoru",

    "242",     "% celkem uivatelskho asu",

    "244",     "% celkem privilegovanho asu",

    "246",     "Celkem peruen/s",

    "248",     "Procesy",

    "250",     "Podprocesy",

    "252",     "Udlosti",

    "254",     "Semafory",

    "256",     "Mutexy",

    "258",     "Sekce",

    "260",     "Objekty",

    "262",     "Pesmrova",

    "264",     "Pijat bajty/s",

    "266",     "Pijat pakety/s",

    "268",     "ten strnkovanch bajt/s",

    "270",     "ten nestrnkovanch bajt/s",

    "272",     "ten bajt mezipamti/s",

    "274",     "ten bajt st/s",

    "276",     "Odeslan bajty/s",

    "278",     "Odeslan pakety/s",

    "280",     "Zpisy strnkovanch bajt/s",

    "282",     "Zpisy nestrnkovanch bajt/s",

    "284",     "Zpisy bajt mezipamti/s",

    "286",     "Zpisy bajt do st/s",

    "288",     "Operac ten/s",

    "290",     "Operac nhodnho ten/s",

    "292",     "ten paket/s",

    "294",     "Velk ten/s",

    "296",     "Mal ten paket/s",

    "298",     "Operac zpisu/s",

    "300",     "Operac nhodnho zpisu/s",

    "302",     "Zpisy paket/s",

    "304",     "Velk zpisy/s",

    "306",     "Mal zpisy paket/s",

    "308",     "ten zamtnuto/s",

    "310",     "Zpisy zamtnut/s",

    "312",     "Chyby st/s",

    "314",     "Relace serveru",

    "316",     "Pipojovn serveru",

    "318",     "Hlavn pipojen",

    "320",     "Pipojen Lan Manager 2.0",

    "322",     "Pipojen Lan Manager 2.1",

    "324",     "Pipojen Windows NT",

    "326",     "Odpojen serveru",

    "328",     "Ztracen relace serveru",

    "330",     "Server",

    "336",     "Dvod ekn podprocesu",

    "340",     "Vyprel relace",

    "342",     "Chybn relace",

    "344",     "Odhlen relace",

    "346",     "Odpojen relace",

    "348",     "Chyby pihlen",

    "350",     "Chyby pstupovch prv",

    "352",     "Chyby udlench prv",

    "354",     "Chyby systmu",

    "356",     "Zamtnut dosti zablokovn",

    "358",     "Nedostatky pracovnch poloek",

    "360",     "Celkem otevench soubor",

    "362",     "Oteven soubory",

    "366",     "Hledn soubor v adresch",

    "370",     "Chyby nestrnkovanho fondu",

    "372",     "Vrchol nestrnkovanho fondu",

    "376",     "Chyby strnkovanho fondu",

    "378",     "Vrchol strnkovanho fondu",

    "388",     "Bajty celkem/s",

    "392",     "Aktuln pkazy",

    "398",     "Sluba NWLink pro rozhran NetBIOS",

    "400",     "Pakety/s",

    "404",     "Bloky kontextu ve front/s",

    "406",     "Datov souborov operace/s",

    "408",     "% volnho msta",

    "410",     "Voln megabajty",

    "412",     "Oteven pipojen",

    "414",     "Pipojen napoprv",

    "416",     "Pipojen opakovan",

    "418",     "Mstn odpojen",

    "420",     "Dlkov odpojen",

    "422",     "Chyby propojen",

    "424",     "Chyby adaptru",

    "426",     "Pipojen s vyprenou relac",

    "428",     "Stornovan pipojen",

    "430",     "Chyby vzdlench prostedk",

    "432",     "Chyby mstnch prostedk",

    "434",     "Chyby nenalezen",

    "436",     "Chyby nenaslouchn",

    "438",     "Datagramy/s",

    "440",     "Bajty datagram/s",

    "442",     "Odeslan datagramy/s",

    "444",     "Odeslan bajty datagram/s",

    "446",     "Pijat datagramy/s",

    "448",     "Pijat bajty datagram/s",

    "452",     "Odeslan pakety/s",

    "456",     "Rmce/s",

    "458",     "Bajty rmc/s",

    "460",     "Odeslan rmce/s",

    "462",     "Odeslan bajty rmc/s",

    "464",     "Pijat rmce/s",

    "466",     "Pijat bajty rmc/s",

    "468",     "Rmce odeslan znovu/s",

    "470",     "Bajty rmc odeslanch znovu/s",

    "472",     "Zamtnut rmce/s",

    "474",     "Zamtnut bajty rmc/s",

    "476",     "Vypren odezvy",

    "478",     "Vypren potvrzen",

    "480",     "Maximln odesln (okno)",

    "482",     "Stedn odeslac okno",

    "484",     "Sloen potvrzen ve front/s",

    "486",     "Vypren sloench potvrzen",

    "488",     "IPX NWLink",

    "490",     "SPX NWLink",

    "492",     "NetBEUI",

    "494",     "Prostedek NetBEUI",

    "496",     "Vyuit maximum",

    "498",     "Vyuit sted",

    "500",     "Poet vyerpn",

    "502",     "Pipojen NBT",

    "506",     "Odeslan bajty/s",

    "508",     "Celkem bajt/s",

    "510",     "Rozhran st",

    "512",     "Bajty/s",

    "520",     "Aktuln ka psma",

    "524",     "Pijat jednosmrov pakety/s",

    "526",     "Pijat nejednosmrov pakety/s",

    "528",     "Vyazen pijat pakety",

    "530",     "Chyby pijatch paket",

    "532",     "Pijat pakety neznm",

    "536",     "Odeslan jednosmrov pakety/s",

    "538",     "Odeslan nejednosmrov pakety/s",

    "540",     "Vyazen odchoz pakety",

    "542",     "Chyby odchozch paket",

    "544",     "Dlka fronty vstupu",

    "546",     "IPv4",

    "548",     "IPv6",

    "552",     "Chyby hlaviek pijatch datagram",

    "554",     "Chyby adres pijatch datagram",

    "556",     "Pedan datagramy/s",

    "558",     "Neznm protokol pijatch datagram",

    "560",     "Vyazen pijat datagramy",

    "562",     "Doruen pijat datagramy/s",

    "566",     "Vyazen odchoz datagramy",

    "568",     "Odchoz datagramy bez smrovn",

    "570",     "Pijat fragmenty/s",

    "572",     "Fragmenty zptn sloen/s",

    "574",     "Chyby zptnho skldn fragment",

    "576",     "Fragmentovn datagram/s",

    "578",     "Chyby fragmentovn",

    "580",     "Fragmenty vytvoen/s",

    "582",     "ICMP",

    "584",     "Zprvy/s",

    "586",     "Pijat zprvy/s",

    "588",     "Chyby pijatch zprv",

    "590",     "Pijat zprvy Cl nedostupn",

    "592",     "Pijat zprvy as pekroen",

    "594",     "Pijat zprvy Problm parametru",

    "596",     "Pijat zprvy Zdroj vyerpn",

    "598",     "Pijat zprvy Pesmrovn/s",

    "600",     "Pijat zprvy Echo/s",

    "602",     "Pijat zprvy Odpov echa/s",

    "604",     "Pijat zprvy asov znaka/s",

    "606",     "Pijat zprvy Odpov asov znaky/s",

    "608",     "Pijat zprvy Maska adresy",

    "610",     "Pijat zprvy Odpov masky adresy",

    "612",     "Odeslan zprvy/s",

    "614",     "Chyby odchozch zprv",

    "616",     "Odeslan zprvy Cl nedostupn",

    "618",     "Odeslan zprvy as pekroen",

    "620",     "Odeslan zprvy Problm parametru",

    "622",     "Odeslan zprvy Zdroj vyerpn",

    "624",     "Odeslan zprvy Pesmrovn/s",

    "626",     "Odeslan zprvy Echo/s",

    "628",     "Odeslan zprvy Odpov echa/s",

    "630",     "Odeslan zprvy asov znaka/s",

    "632",     "Odeslan zprvy Odpov asov znaky/s",

    "634",     "Odeslan zprvy Maska adresy",

    "636",     "Odeslan zprvy Odpov masky adresy",

    "638",     "TCPv4",

    "640",     "Segmenty/s",

    "642",     "Navzan pipojen",

    "644",     "Aktivn pipojen",

    "646",     "Pasivn pipojen",

    "648",     "Chyby pipojen",

    "650",     "Resetovan pipojen",

    "652",     "Pijat segmenty/s",

    "654",     "Odeslan segmenty/s",

    "656",     "Segmenty odeslan znovu/s",

    "658",     "UDPv4",

    "660",     "% celkovho asu DPC",

    "662",     "% celkovho asu peruen",

    "664",     "Datagramy bez portu/s",

    "666",     "Chyby pijatch datagram",

    "670",     "Jednotka diskov pamti",

    "672",     "Chyby vyhrazen",

    "674",     "Doba provozu systmu",

    "676",     "Poet popisova systmu",

    "678",     "Voln poloky strnkovac tabulky systmu",

    "680",     "Poet podproces",

    "682",     "Zkladn priorita",

    "684",     "Uplynul as",

    "686",     "Npravy zarovnn/s",

    "688",     "Odbaven vjimek/s",

    "690",     "Emulace pohybliv rky/s",

    "692",     "Pihlen/s",

    "694",     "Aktuln priorita",

    "696",     "% asu DPC",

    "698",     "% asu peruen",

    "700",     "Strnkovac soubor",

    "702",     "% vyuit",

    "704",     "% vrchol vyuit",

    "706",     "Adresa zatku",

    "708",     "Programov ta uivatele",

    "710",     "Mapovan pam Bez pstupu",

    "712",     "Mapovan pam Jen pro ten",

    "714",     "Mapovan pam ten/zpis",

    "716",     "Mapovan pam Zpis/koprovn",

    "718",     "Mapovan pam Pro spoutn",

    "720",     "Mapovan pam Pro spoutn/ten",

    "722",     "Mapovan pam Pro spoutn/ten/zpis",

    "724",     "Mapovan pam Pro spoutn/zpis/koprovn",

    "726",     "Rezervovan pam Bez pstupu",

    "728",     "Rezervovan pam Jen ten",

    "730",     "Rezervovan pam ten/zpis",

    "732",     "Rezervovan pam Zpis kopie",

    "734",     "Rezervovan pam Pro spoutn",

    "736",     "Rezervovan pam Pro spoutn/ten",

    "738",     "Rezervovan pam Pro spoutn/ten/zpis",

    "740",     "Bitov kopie",

    "742",     "Rezervovan pam Pro spoutn, zpis a koprovn",

    "744",     "Nepiazen pam Bez pstupu",

    "746",     "Nepiazen pam Jen ten",

    "748",     "Nepiazen pam ten/zpis",

    "750",     "Nepiazen pam Zpis/koprovn",

    "752",     "Nepiazen pam Pro spoutn",

    "754",     "Nepiazen pam Pro spoutn/ten",

    "756",     "Nepiazen pam Pro spoutn/ten/zpis",

    "758",     "Nepiazen pam Pro spoutn/zpis/koprovn",

    "760",     "Pam bitovch kopi Bez pstupu",

    "762",     "Pam bitovch kopi Jen pro ten",

    "764",     "Pam bitovch kopi ten/zpis",

    "766",     "Pam bitovch kopi Zpis/koprovn",

    "768",     "Pam bitovch kopi Pro spoutn",

    "770",     "Pam bitovch kopi Pro spoutn/ten",

    "772",     "Pam bitovch kopi Pro spoutn/ten/zpis",

    "774",     "Pam bitovch kopi Pro spoutn/zpis/koprovn",

    "776",     "Rezervovan bajty bitovch kopi",

    "778",     "Voln bajty bitovch kopi",

    "780",     "Rezervovan bajty",

    "782",     "Voln bajty",

    "784",     "ID procesu",

    "786",     "Adresn prostor procesu",

    "788",     "dn pstup",

    "790",     "Jen pro ten",

    "792",     "ten/zpis",

    "794",     "Zpis/koprovn",

    "796",     "Pro spoutn",

    "798",     "Pro spoutn/ten",

    "800",     "Pro spoutn/ten/zpis",

    "802",     "Pro spoutn/zpis/koprovn",

    "804",     "ID podprocesu",

    "806",     "Chyby pjmu zsuvek poty",

    "808",     "Chyby zpisu zsuvek poty",

    "810",     "Chyby oteven zsuvek poty/s",

    "812",     "Ohlen duplicity hlavnho",

    "814",     "Neplatn datagramy/s",

    "816",     "Podrobnosti podproces",

    "818",     "Bajty mezipamti",

    "820",     "Vrchol bajt mezipamti",

    "822",     "Vstup strnek/s",

    "824",     "Zmn elu stran penosu/s",

    "870",     "Port sluby RAS",

    "872",     "Odeslan bajty",

    "874",     "Pijat bajty",

    "876",     "Odeslan rmce",

    "878",     "Pijat rmce",

    "880",     "Vstupn kompresn pomr",

    "882",     "Vstupn kompresn pomr",

    "884",     "Chyby CRC",

    "886",     "Poet chyb vypren asovho limitu",

    "888",     "Poet chyb sriovho pebhu",

    "890",     "Poet chyb zarovnn",

    "892",     "Poet chyb pebhu vyrovnvac pamti",

    "894",     "Celkov poet chyb",

    "896",     "Odeslan bajty/s",

    "898",     "Pijat bajty/s",

    "900",     "Odeslan rmce/s",

    "902",     "Pijat rmce/s",

    "904",     "Celkov poet chyb/s",

    "906",     "Celkov poet pipojen RAS",

    "908",     "Celkov poet pipojen",

    "920",     "Server WINS",

    "922",     "Jedinen registrace/s",

    "924",     "Registrace skupin/s",

    "926",     "Celkov poet registrac/s",

    "928",     "Jedinen obnoven/s",

    "930",     "Obnoven skupin/s",

    "932",     "Celkov poet obnoven/s",

    "934",     "Uvolnn/s",

    "936",     "Dotazy/s",

    "938",     "Jedinen konflikty/s",

    "940",     "Konflikty skupin/s",

    "942",     "Celkov poet konflikt/s",

    "944",     "spn uvolnn/s",

    "946",     "Chybn uvolnn/s",

    "948",     "spn dotazy/s",

    "950",     "Chybn dotazy/s",

    "952",     "Poet popisova",

    "1000",     "Server MacFile",

    "1002",     "Max. strnkovan pamti",

    "1004",     "Aktuln strnkovan pam",

    "1006",     "Max. nestrnkovan pamti",

    "1008",     "Aktuln nestrnkovan pam",

    "1010",     "Aktuln relace",

    "1012",     "Maximum relac",

    "1014",     "Aktuln oteven soubory",

    "1016",     "Maximum otevench soubor",

    "1018",     "Chybn pihlen",

    "1020",     "ten dat/s",

    "1022",     "Zpisy dat/s",

    "1024",     "Pijat data/s",

    "1026",     "Odeslan data/s",

    "1028",     "Aktuln dlka fronty",

    "1030",     "Maximln dlka fronty",

    "1032",     "Aktuln podprocesy",

    "1034",     "Maximum podproces",

    "1050",     "AppleTalk",

    "1052",     "Pijat pakety/s",

    "1054",     "Odeslan pakety/s",

    "1056",     "Pijat bajty/s",

    "1058",     "Odeslan bajty/s",

    "1060",     "Stedn doba/Paket DDP",

    "1062",     "Pakety DDP/s",

    "1064",     "Stedn doba/Paket AARP",

    "1066",     "Pakety AARP/s",

    "1068",     "Stedn doba/Paket ATP",

    "1070",     "Pakety ATP/s",

    "1072",     "Stedn doba/Paket NBP",

    "1074",     "Pakety NBP/s",

    "1076",     "Stedn doba/Paket ZIP",

    "1078",     "Pakety ZIP/s",

    "1080",     "Stedn doba/Paket RTMP",

    "1082",     "Pakety RTMP/s",

    "1084",     "Mstn opakovn ATP",

    "1086",     "Pekroen lht odezvy ATP",

    "1088",     "Odezvy ATP XO/s",

    "1090",     "Odezvy ATP ALO/s",

    "1092",     "Pijat uvolnn ATP/s",

    "1094",     "Aktuln nestrnkovan fond",

    "1096",     "Pakety smrovan dovnit/s",

    "1098",     "Vyazen pakety",

    "1100",     "Opakovan dosti ATP",

    "1102",     "Pakety smrovan ven/s",

    "1110",     "Segment st",

    "1112",     "Pijat rmce celkem/s",

    "1114",     "Pijat bajty celkem/s",

    "1116",     "Pijat rmce vesmrovho vysln/s",

    "1118",     "Pijat rmce vcesmrovho vysln/s",

    "1120",     "% Vyuit st",

    "1124",     "% Rmce vesmrov",

    "1126",     "% Rmce vcesmrov",

    "1150",     "Telefonn subsystm",

    "1152",     "Linky",

    "1154",     "Telefonn zazen",

    "1156",     "Aktivn linky",

    "1158",     "Aktivn telefony",

    "1160",     "Odchoz hovory/s",

    "1162",     "Pchoz hovory/s",

    "1164",     "Aplikace klient",

    "1166",     "Aktuln odchoz hovory",

    "1168",     "Aktuln pchoz hovory",

    "1228",     "Brna pro systm NetWare",

    "1230",     "Klient systmu NetWare",

    "1232",     "Poet dvek paket ten NCP/s",

    "1234",     "Opakovn dvek paket ten/s",

    "1236",     "Poet dvek paket zpisu NCP/s",

    "1238",     "Opakovn dvek paket zpisu/s",

    "1240",     "I/O dvek paket/s",

    "1242",     "Pipojen NetWare 2.x",

    "1244",     "Pipojen NetWare 3.x",

    "1246",     "Pipojen NetWare 4.x",

    "1260",     "Celkem pipojen",

    "1300",     "Pracovn fronty serveru",

    "1302",     "Dlka fronty",

    "1304",     "Aktivn podprocesy",

    "1306",     "Dostupn podprocesy",

    "1308",     "Dostupn pracovn poloky",

    "1310",     "Vypjen pracovn poloky",

    "1312",     "Nedostatky pracovnch poloek",

    "1314",     "Aktuln poet klient",

    "1320",     "Bajty penesen/s",

    "1324",     "Bajty peten/s",

    "1328",     "Bajty zapsan/s",

    "1332",     "Celkem operac/s",

    "1334",     "Voln DPC ve front/s",

    "1336",     "Rychlost voln DPC",

    "1342",     "Celkem voln DPC ve front/s",

    "1344",     "Celkov rychlost voln DPC",

    "1350",     "% vyuit pdlu registru",

    "1360",     "Pam VLM",

    "1362",     "Pam VLM - % vyuit virtuln velikosti",

    "1364",     "Virtuln velikost pamti VLM",

    "1366",     "Vrcholov virtuln velikost pamti VLM ",

    "1368",     "Virtuln velikost pamti VLM k dispozici",

    "1370",     "Objem sven pamti VLM",

    "1372",     "Vrcholov objem sven pamti VLM",

    "1374",     "Objem sven systmov pamti VLM",

    "1376",     "Vrcholov objem sven systmov pamti VLM",

    "1378",     "Objem sven systmov sdlen pamti VLM",

    "1380",     "Poet kB k dispozici",

    "1382",     "Poet MB k dispozici",

    "1400",     "Stedn dlka fronty disku",

    "1402",     "Stedn dlka fronty ten disku",

    "1404",     "Stedn dlka fronty zpisu disku",

    "1406",     "% vyuit svench bajt",

    "1408",     "pln bitov kopie",

    "1410",     "ID vytvejcho procesu",

    "1412",     "Vstupn-vstupn operace ten/s",

    "1414",     "Vstupn-vstupn operace zpisu/s",

    "1416",     "Vstupn-vstupn datov operace/s",

    "1418",     "Jin vstupn-vstupn operace/s",

    "1420",     "Bajty vstupn-vstupnch operac ten/s",

    "1422",     "Bajty vstupn-vstupnch operac zpisu/s",

    "1424",     "Bajty vstupn-vstupnch datovch operac/s",

    "1426",     "Bajty jinch vstupn-vstupnch operac/s",

    "1450",     "Tiskov fronta",

    "1452",     "Celkov poet vytisknutch loh",

    "1454",     "Poet bajt vytisknutch za sekundu",

    "1456",     "Celkov poet vytisknutch strnek",

    "1458",     "Poet loh",

    "1460",     "Poet odkaz",

    "1462",     "Maximln poet odkaz",

    "1464",     "Poet zaazovanch loh",

    "1466",     "Maximln poet zaazovanch loh",

    "1468",     "Poet chyb typu Doel papr",

    "1470",     "Poet chyb typu Tiskrna nen pipravena",

    "1472",     "Poet chyb loh",

    "1474",     "Poet voln na vet sovch tiskren",

    "1476",     "Poet voln na pidn sov tiskrny",

    "1478",     "Pracovn sada - soukrom",

    "1480",     "Pracovn sada - sdlen",

    "1482",     "% asu neinnosti",

    "1484",     "Dlen vstupn-vstupnch operac/s",

    "1500",     "Objekt loha",

    "1502",     "Aktuln % asu procesoru",

    "1504",     "Aktuln % asu uivatelskho reimu",

    "1506",     "Aktuln % asu reimu jdra",

    "1508",     "Tato perioda ms - procesor",

    "1510",     "Tato perioda ms - uivatelsk reim",

    "1512",     "Tato perioda - reim jdra",

    "1514",     "Strnky/s",

    "1516",     "Poet proces - celkem",

    "1518",     "Poet proces - aktivn",

    "1520",     "Poet proces - ukonen",

    "1522",     "Celkem ms - procesor",

    "1524",     "Celkem ms - uivatelsk reim",

    "1526",     "Celkem ms - reim jdra",

    "1530",     "TCPv6",

    "1532",     "UDPv6",

    "1534",     "ICMPv6",

    "1536",     "Pijat paket je pli velk",

    "1538",     "Pijat dotaz lenstv",

    "1540",     "Pijat zprva o lenstv",

    "1542",     "Pijat zredukovn lenstv",

    "1544",     "Pijat dosti smrovae",

    "1546",     "Pijat inzerovn smrovae",

    "1548",     "Podrobnosti objektu loha",

    "1550",     "Pijat dosti soused",

    "1552",     "Pijat inzerovn soused",

    "1554",     "Odeslan paket je pli velk",

    "1556",     "Odeslan dotaz lenstv",

    "1558",     "Odeslan zprva lenstv",

    "1560",     "Odeslan zredukovn lenstv",

    "1562",     "Odeslan dosti smrovae",

    "1564",     "Odeslan inzerovn smrovae",

    "1566",     "Odeslan dosti soused",

    "1568",     "Odeslan inzerovn soused",

    "1746",     "% asu neinnosti",

    "1748",     "% as C1 ",

    "1750",     "% as C2 ",

    "1752",     "% as C3 ",

    "1754",     "Pemny/s C1",

    "1756",     "Pemny/s C2",

    "1758",     "Pemny/s C3",

    "1760",     "Halda",

    "1762",     "Sven bajty",

    "1764",     "Rezervovan bajty",

    "1766",     "Virtuln bajty",

    "1768",     "Voln bajty",

    "1770",     "Dlka seznamu uvolnn",

    "1772",     "Prmrn doba piazen",

    "1774",     "Prmrn doba uvolnn",

    "1776",     "Dlka neodeslanch rozsah",

    "1778",     "Piazen - uvolnn",

    "1780",     "Piazen mezipamti/s",

    "1782",     "Uvolnn mezipamti/s",

    "1784",     "Piazen <1 kB/s",

    "1786",     "Uvolnn <1 kB/s",

    "1788",     "Piazen 1-8 kB/s",

    "1790",     "Uvolnn 1-8 kB/s",

    "1792",     "Piazen >8 kB/s",

    "1794",     "Uvolnn >8 kB/s",

    "1796",     "Celkem piazen/s",

    "1798",     "Celkem uvolnn/s",

    "1800",     "Blok v mezipamti haldy",

    "1802",     "Nejvt hloubka mezipamti",

    "1804",     "% fragmentace",

    "1806",     "% fragmentace VA",

    "1808",     "Neshoda uzamen haldy",

    "1846",     "Znaka konce",
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\heb\perfc00d.ini ===
[info]
drivername=ContentIndex
symbolfile=perfci.h

[objects]
CIOBJECT_009_NAME=Indexing Service

[languages]
009=English
000=Neutral

[text]
CIOBJECT_009_NAME=Indexing Service
CIOBJECT_009_HELP=Indexing Service

NUM_WORDLIST_009_NAME=Word lists
NUM_WORDLIST_009_HELP=Number of word lists.

NUM_PERSISTENT_INDEX_009_NAME=Saved indexes
NUM_PERSISTENT_INDEX_009_HELP=Number of saved indexes.

INDEX_SIZE_009_NAME=Index size (MB)
INDEX_SIZE_009_HELP=Size of the content index (*.ci files only) in megabytes.

FILES_TO_BE_FILTERED_009_NAME=Files to be indexed
FILES_TO_BE_FILTERED_009_HELP=Number of files to be filtered and added to the index.

DEFERRED_FILTER_FILES_009_NAME=Deferred for indexing
DEFERRED_FILTER_FILES_009_HELP=Number of files not available and deferred for indexing.

NUM_UNIQUE_KEY_009_NAME=Unique keys
NUM_UNIQUE_KEY_009_HELP=Number of unique keys (words, etc.) in the index.

RUNNING_QUERIES_009_NAME=Running queries
RUNNING_QUERIES_009_HELP=Number of active query client connections.

MERGE_PROGRESS_009_NAME=Merge progress
MERGE_PROGRESS_009_HELP=Percent merge complete for the current merge.

DOCUMENTS_FILTERED_009_NAME=# documents indexed
DOCUMENTS_FILTERED_009_HELP=Number of documents indexed since the index was mounted.

NUM_DOCUMENTS_009_NAME=Total # documents
NUM_DOCUMENTS_009_HELP=Total number of documents in the index.

TOTAL_QUERIES_009_NAME=Total # of queries
TOTAL_QUERIES_009_HELP=Total number of queries since the index was mounted.

CIOBJECT_000_NAME=Indexing Service
CIOBJECT_000_HELP=Indexing Service

NUM_WORDLIST_000_NAME=Word lists
NUM_WORDLIST_000_HELP=Number of word lists.

NUM_PERSISTENT_INDEX_000_NAME=Saved indexes
NUM_PERSISTENT_INDEX_000_HELP=Number of saved indexes.

INDEX_SIZE_000_NAME=Index size (MB)
INDEX_SIZE_000_HELP=Size of the content index (*.ci files only) in megabytes.

FILES_TO_BE_FILTERED_000_NAME=Files to be indexed
FILES_TO_BE_FILTERED_000_HELP=Number of files to be filtered and added to the index.

DEFERRED_FILTER_FILES_000_NAME=Deferred for indexing
DEFERRED_FILTER_FILES_000_HELP=Number of files not available and deferred for indexing.

NUM_UNIQUE_KEY_000_NAME=Unique keys
NUM_UNIQUE_KEY_000_HELP=Number of unique keys (words, etc.) in the index.

RUNNING_QUERIES_000_NAME=Running queries
RUNNING_QUERIES_000_HELP=Number of active query client connections.

MERGE_PROGRESS_000_NAME=Merge progress
MERGE_PROGRESS_000_HELP=Percent merge complete for the current merge (if any).

DOCUMENTS_FILTERED_000_NAME=# documents indexed
DOCUMENTS_FILTERED_000_HELP=Number of documents indexed since the index was mounted.

NUM_DOCUMENTS_000_NAME=Total # documents
NUM_DOCUMENTS_000_HELP=Total number of documents in index.

TOTAL_QUERIES_000_NAME=Total # of queries
TOTAL_QUERIES_000_HELP=Total number of queries since the index was mounted.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\es\perfh00a.ini ===
"3",     "El tipo de objeto Sistema incluye aquellos contadores asignados a todos los procesadores del equipo colectivamente. ",

    "5",     "El tipo de objeto Memoria incluye aquellos contadores que describen el comportamiento de la memoria real y virtual en el equipo. La memoria real es la cantidad de accesos aleatorios a la memoria en el equipo. La memoria virtual es el espacio en memoria fsica y en el disco. Muchos de los contadores de memoria supervisan la paginacin, es decir, el movimiento de pginas de cdigo y datos entre la memoria en disco y la fsica. La paginacin excesiva, sntoma de falta de memoria, puede causar retrasos que interfieren con todos los procesos del sistema.",

    "7",     "% de tiempo de procesador se expresa como un porcentaje del tiempo que un procesador invierte ejecutando un subproceso activo. Se calcula midiendo durante cuanto tiempo el subproceso no activo est activo en el intervalo modelo. (Cada procesador tiene un subproceso inactivo que consume ciclos cuando otros subprocesos no estn preparados para ejecutarse). Este contador es el indicador primario de la actividad del procesador, y muestra el porcentaje medio del tiempo ocupado observado durante el intervalo modelo. Se calcula monitorizando el tiempo que el servicio ha estado inactivo, y sustrayendo este valor a 100%.",

    "9",     "% de tiempo total de DPC es el promedio del porcentaje de tiempo invertido por todos los procesadores en recibir y atender llamadas diferidas (DCPs). (Los DCPs son interrupciones que se ejecutan con una prioridad menor que las interrupciones estndar). Es la suma del procesador: % de tiempo DCP para todos los procesadores del equipo, dividido entre el nmero de procesadores. Sistema: % tiempo DPC total es un componente de Sistema: % tiempo privilegiado total porque los DPCs se ejecutan en modo privilegiado. Los DPCs se cuentan separadamente y no forman parte de la cuenta de interruptores. Este contador muestra el tiempo ocupado medio como un porcentaje del tiempo de muestra.",

    "11",     "Las Operaciones de lectura de archivo por segundo son el conjunto de todas las operaciones de lectura del sistema de archivos en el equipo.  ",

    "13",     "Las Operaciones de escritura de archivo por segundo son el conjunto de todas las operaciones de escritura del sistema de archivos en el equipo. ",

    "15",     "Las Operaciones de control de archivos por segundo son el conjunto de todas las operaciones del sistema de archivos que no sean de lectura ni escritura. Estas operaciones normalmente incluyen peticiones de control del sistema de archivos, o peticiones de informacin sobre las caractersticas de los dispositivos o del estado. ",

    "17",     "Los Bytes de lectura de archivo por segundo son el conjunto de los bytes transferidos para todas las operaciones de lectura del sistema de archivos en el equipo. ",

    "19",     "Los Bytes de escritura de archivo por segundo son el conjunto de los bytes transferidos para todas las operaciones de escritura del sistema de archivos en el equipo. ",

    "21",     "Los Bytes de control de archivos por segundo son el conjunto de todas las operaciones del sistema de archivos que no sean de lectura ni escritura. Estas operaciones normalmente incluyen peticiones de control del sistema de archivos, o peticiones de informacin sobre las caractersticas de los dispositivos o del estado. ",

    "23",     "El % total de tiempo de interrupcin es el porcentaje promedio del tiempo que todos los procesadores dedican recibiendo y atendiendo interrupciones de hardware durante los intervalos de muestreo, donde el valor es un indicador indirecto de la actividad de dispositivos que generan interrupciones. Es la suma del % de tiempo de interrupcin del procesador, de todos los procesadores del equipo, dividida entre el nmero de procesadores. Los procesadores DPC se cuentan separadamente y no forman parte del clculo de interrupciones. Este valor es un indicador indirecto de la actividad de los dispositivos que generan interrupciones, tales como el reloj del sistema, el mouse, las unidades de disco, las lneas de comunicacin de datos, tarjetas de interfaz de red y otros dispositivos perifricos.",

    "25",     "Los Bytes disponibles muestran el tamao, en bytes, de la memoria fsica inmediatamente disponible para su asignacin a un proceso o para uso del sistema. Equivale a la suma de la memoria asignada a las listas de pginas En espera (en cach), Libre y Cero. Para ver una explicacin completa del administrador de memoria, vea MSDN o el captulo correspondiente de la Gua de rendimiento del sistema y solucin de problemas del Kit de recursos de Windows Server 2003.",

    "27",     "Los Bytes comprometidos es la cantidad de memoria virtual comprometida, en bytes. La memoria comprometida es la memoria fsica que tiene espacio reservado en los archivos de paginacin de disco. Puede haber uno o ms archivos de paginacin en cada unidad fsica. Este contador muestra slo el ltimo valor observado.",

    "29",     "Errores de pgina por segundo es el nmero de pginas fallidas por segundo. La medicin se realiza en nmero de pginas fallidas por segundo porque slo una pgina falla en cada operacin fallida, por lo tanto, este es tambin igual al nmero de operaciones fallidas de pginas. Este contador incluye tanto errores severos (aquellos que necesitan acceso al disco) como errores flexibles (donde la pgina con error se encuentra en algn otro sitio de la memoria fsica). Muchos procesos soportan gran nmero de errores flexibles sin consecuencias significantes. Sin embargo, los errores severos, que requieren acceso a disco, puede producir retrasos importantes.",

    "31",     "Lmite comprometido es la cantidad de memoria virtual que se puede comprometer sin extender los archivos de paginacin. Este se mide en bytes. La memoria comprometida es la memoria fsica la cual tiene espacio reservado en los archivos de paginacin de disco. Puede haber un archivo de paginacin en cada unidad fsica. Si el o los archivos de paginacin se expanden, el lmite se incrementar. Este contador muestra slo el ltimo valor observado. No es un promedio.",

    "33",     "Copias de escritura por segundo es el frecuencia a la cual los errores de pgina se producen al hacer una copia de una pgina cuando se intenta escribir en ella desde cualquier sitio en la memoria fsica. Es una forma econmica de compartir datos ya que la copia slo se realiza en los intentos de escritura; en otro caso, se comparte la pgina. Este contador muestra el nmero de copias, si hacer referencia al nmero de pginas copiadas en cada operacin.",

    "35",     "Errores de transmisin/seg es la frecuencia a la cual se resuelven los errores de pgina por la recuperacin de pginas que fueron usadas por otro proceso compartiendo la pgina, o estuvieron en la lista de pgina modificada o en la lista suplente, o se escribieron en el disco al mismo tiempo que el error de pgina. Las pginas se recuperaron sin actividad adicional de disco. Los errores de transmisin se contabilizan en nmero de errores; porque solamente una pgina obtiene error en cada operacin, esto es igual al nmero de pginas con error.",

    "37",     "Los errores de cach por segundo es la frecuencia a la cual los errores ocurren cuando una pgina buscada en la cach del sistema de archivo no se encontr y de intentarse de nuevo desde algn otro sitio en la memoria (un error flexible) o desde el disco (un error severo). La cach de sistema de archivo es un rea de la memoria fsica que guarda pginas de datos recientemente usadas para aplicaciones. La actividad de la cach es un indicador fidedigno de la mayora de las operaciones E/S de aplicacin. Este contador muestra el nmero de errores sin estimar el nmero de pginas fallidas en cada operacin.",

    "39",     "Errores de peticin de cero/seg es la frecuencia a la cual una pgina a cero se demanda para satisfacer el error.  Pginas a cero, pginas vacas de datos guardados anteriormente y rellenadas con ceros, son una caracterstica de seguridad de Windows que impide en el proceso que se vean datos guardados por otros procesos anteriores que usaron el espacio en memoria. Windows mantiene una lista de pginas a cero para acelerar este proceso. Este contador muestra el nmero de errores, sin hacer referencia al nmero de pginas recuperadas para satisfacer el error. Este contador muestra las diferencias entre los valores observados en los dos ltimos ejemplos, dividido por la duracin del intervalo de ejemplo.",

    "41",     "Pginas por segundo es la frecuencia a la que las pginas son ledas o escritas en disco para resolver errores de pgina severos. Este contador es un indicador primario del tipo de errores que causan retraso en todo el sistema. Es la suma de la Memoria\\Pginas de entrada/seg y Memoria\\Pginas de salida/seg. Se calcula en nmero de pginas, por lo que puede compararse con otros cuentas de pginas como Memoria\\Pginas de error/seg, sin conversin. Incluye la recuperacin de pginas para solucionar los errores en la cach del sistema de archivo (normalmente solicitada por aplicaciones) archivos de memoria asignada que no es la cach.",

    "43",     "Lecturas de pgina/seg. es la frecuencia a la cual se ley el disco con el objetivo de resolver errores severos de pgina. Muestra el nmero de operaciones de lectura sin hacer referencia al nmero de pginas recuperadas en cada operacin. Los errores severos de pgina ocurren cuando un proceso hace referencia a una pgina en la memoria virtual que no est en la memoria de trabajo o en cualquier otro sitio en la memoria fsica, y debe recuperarse desde el disco. Este contador es un indicador primario de los tipos de errores que causan retraso en todo el sistema. Incluye operaciones de lectura para satisfacer errores en la cach del sistema de archivo (normalmente solicitada por aplicaciones) y en archivos de memoria asignados no en cach. Comparar el valor de Memoria\\Lecturas de pginas/seg.\\Salidas de pginas/seg. para determinar el nmero promedio de pginas ledas durante cada operacin.",

    "45",     "Longitud de la cola del procesador es el nmero de subprocesos en la cola del procesador.  Diferencindose de los contadores de disco, este contador slo muestra subprocesos listos, no muestra subprocesos que se estn ejecutando. Hay una nica cola para el tiempo del procesador incluso en equipos con mltiples procesadores.  Por consiguiente, si un equipo tiene mltiples procesadores, necesita dividir este valor por el nmero de procesadores que atienden la carga de trabajo. Una cola de procesador ininterrumpida de menos de 10 subprocesos por procesador es normalmente aceptable, depende de la carga de trabajo.",

    "47",     "El Estado de subproceso es el estado en el que se encuentra el subproceso actualmente. El estado es 0 para inicializado, 1 cuando el proceso est listo para ejecutarse, 2 para ejecucin, 3 cuando es apartado temporalmente, 4  para terminado, 5 para espera, 6 para transicin y 7 en caso de un estado desconocido. Un subproceso en ejecucin est utilizando un procesador, mientras que cuando es apartado temporalmente simplemente lo tiene asignado. Un proceso listo para ejecutarse est en espera de un procesador, ya que no hay ninguno disponible en esos momentos. Cuando el subproceso est en transicin, se encuentra a la espera de algn recurso imprescindible para su ejecucin, como por ejemplo, una pila en memoria. El subproceso en espera es aqul que est esperando la finalizacin de alguna operacin en dispositivos perifricos o que algn recurso quede disponible. ",

    "49",     "Pginas de salida/seg. es la frecuencia a la cual se escriben las pginas en el disco para liberar espacio en la memoria fsica.  Las pginas se devuelven al disco slo si se cambian en la memoria fsica, de esta manera, pueden probablemente mantener datos, no cdigo. Una tasa alta de salida de pginas puede indicar escasez de memoria. Windows devuelve ms pginas al disco para liberar espacio cuando escasea la memoria fsica. Este contador muestra el nmero de pginas, y puede ser comparado con otros contadores de pginas sin conversin.",

    "51",     "Escritura de pgina/seg. es la frecuencia a la cual se escriben las pginas en el disco para liberar espacio en la memoria fsica. Las pginas se escriben en el disco solamente si cambian en la memoria fsica, de esta manera, pueden probablemente mantener datos, no cdigo. Este contador muestra operaciones de escritura, sin hacer referencia al nmero de pginas escritas en cada operacin. Este contador muestra la diferencia entre los valores observados en los dos ltimos ejemplos, dividida por la duracin del intervalo de ejemplo.",

    "53",     "El objeto de rendimiento del Explorador consiste en un contador que mide la frecuencia de comunicaciones, enumeraciones y otras transmisiones del Explorador.",

    "55",     "Anuncios de servidor/s. es la frecuencia con la que los servidores en este dominio se han anunciado a este servidor.",

    "57",     "Bytes de memoria paginada es el tamao, en bytes, del bloque paginado, un rea de la memoria de sistema (memoria fsica usada por el sistema operativo) para objetos que pueden escribirse en el disco cuando no se usan. Memoria\\Bytes de memoria paginada calculados de forma diferente al Proceso\\Bytes de memoria paginada, que puede ser diferente al Proceso\\Bytes de memoria paginada\\_Total. Este contador muestra solamente el ltimo valor observado. No es un promedio.",

    "59",     "Bytes de memoria no paginada es el tamao, en bytes,  del bloque no paginado, una rea la memoria del sistema (memoria fsica usada por el sistema operativo) para objetos que no se pueden escribir en el disco, pero deben permanecer en la memoria fsica tanto tiempo como estn asignados. Memoria\\Bytes de memoria no paginada calculados de forma diferente al Proceso\\Bytes de memoria no paginada, de manera que no sea un proceso igual\\Bytes de memoria no paginada\\_Total.  Este contador muestra solamente el ltimo valor observado. No es un promedio.",

    "61",     "Asignaciones de memoria paginada es el nmero de llamadas para asignar espacio en la memoria paginada del sistema. La memoria paginada es un rea de la memoria del sistema donde los componentes del sistema operativo adquieren espacio a medida que realizan tareas asignadas. Las pginas de la memoria paginada se pueden paginar en el archivo de paginacin cuando el sistema no tiene acceso a ellas durante largos perodos de tiempo. ",

    "63",     "Bytes residentes de memoria paginada es el tamao actual, en bytes, del bloque paginado. El bloque paginado es un rea del la memoria del sistema (memoria fsica usada por el sistema operativo) para objetos que pueden escribirse en el disco cuando no se usan. El espacio usado por el bloque paginado y el bloque no paginado se toma de la memoria fsica, por lo que un bloque muy grande niega espacio de memoria al los procesos. Este contador muestra solamente el ltimo valor observado. No es un promedio.",

    "65",     "Asignaciones de memoria no paginada es el nmero de llamadas para asignar espacio en la memoria no paginada del sistema. La memoria no paginada es un rea de la memoria del sistema donde los componentes del sistema operativo adquieren espacio a medida que realizan tareas asignadas. Las pginas de la memoria no paginada no se pueden paginar en el archivo de paginacin; permanecen en la memoria principal mientras estn asignadas. Este contador muestra slo el ltimo valor observado. No es un promedio.",

    "67",     "Total de bytes por segundo es la frecuencia total de bytes mandados o recibidos desde la red por el protocolo, pero slo considera bytes en tramas (paquetes) que contienen datos. Esta es la suma de bytes de trama/seg y de bytes de datagrama/seg.",

    "69",     "Total de bytes de cdigo del sistema es la cantidad, en bytes, de sistema operativo paginable actualmente en la memoria virtual. Es una medida de la memoria virtual que el sistema operativo est usando y que se puede escribir en el disco cuando no est en uso. Este valor se calcula sumando los bytes en ntoskrnl.exe, hal.dll, y los controladores de inicio y sistemas de archivo cargados por ntldr/osloader. Este contador no incluye el cdigo que debe permanecer en la memoria fsica y no se puede escribir en el disco. Este contador slo muestra el ltimo valor observado; no es un valor medio.",

    "71",     "Bytes residentes de cdigo del sistema es el tamao, en bytes, del cdigo del sistema actualmente residentes en memoria fsica que pueden escribirse en el disco cuando no estn en uso. Este valor es un componente de Memoria\\Total de bytes de cdigo del sistema que tambin incluye cdigo del sistema operativo en el disco.  Memoria\\Bytes residentes de cdigo del sistema  ( y Memoria\\Total de bytes de cdigo del sistema) no incluye el cdigo que debe permanecer en la memoria fsica y no se puede escribir en el disco. Este contador slo muestra el ltimo valor observado; no es un valor medio.",

    "73",     "Bytes totales de controlador de sistema es el tamao, de la memoria virtual paginada usada actualmente por controladores de dispositivo. La memoria paginada puede escribirse en el disco cuando no est en uso. Incluye memoria fsica (Memoria\\Bytes residentes en el controlador del sistema), cdigo y paginacin de datos en el disco. Es un componente de Memoria\\Bytes totales de cdigo de sistema. Este contador muestra solamente el ltimo valor observado. No es un promedio.  ",

    "75",     "Bytes residentes de controladores del sistema es el tamao, en bytes, de la memoria fsica paginable usada por los controladores del dispositivo. Esta cantidad es el conjunto cdigo de trabajo de los  controladores (rea de la memoria fsica). Este valor es un componente de la Memoria\\Total de bytes de controladores del sistema, el cual tambin incluye memoria de controladores que se han escrito en el disco. Ninguno, ni la Memoria\\Bytes residentes de controlador de sistema ni Memoria\\Bytes totales de controlador de sistema incluyen memoria que no puede ser escrita en el disco.",

    "77",     "Bytes residentes de la cach del sistema es el tamao, en bytes, del cdigo del sistema operativo paginado en la cach del sistema de archivo. Este valor incluye slo pginas fsicas actuales y no incluye ninguna pgina de memoria virtual no residente actualmente.  Hace igual el valor de la cach mostrado en el administrador de tareas. Como resultado, este valor puede ser ms pequeo que la cantidad actual de memoria virtual usada por la chach del sistema de archivo. Este valor es un componente de Memoria\\Bytes residentes de cdigo de sistema que representan todo el cdigo del sistema operativo paginable que est actualmente en la memoria fsica. Este contador muestra solamente el ltimo valor observado. No es un promedio. ",

    "79",     "Anuncios de dominio/s. es la frecuencia con la que un dominio se ha anunciado a la red.",

    "81",     "Paquetes de eleccin/s. es la frecuencia a la cual los paquetes de eleccin del examinador se han recibido en esta estacin de trabajo.",

    "83",     "Escrituras del buzn de correo/s. es la frecuencia a la cual los mensajes de correo se han recibido correctamente.",

    "85",     "Peticiones de lista de servidores/s. es la frecuencia a la cual las peticiones para obtener una lista de servidores de examinador se ha procesado en esta estacin de trabajo.",

    "87",     "El objeto de rendimiento de Cach cosiste en contadores que supervisan la cach de archivos de sistema, un rea de memoria fsica que almacena datos recientemente utilizados durante el mayor tiempo posible para permitir acceso a los datos sin tener que leerlos desde el disco. Ya que normalmente las aplicaciones utilizan la Cach, esta se supervisa como un indicador de operaciones de E/S. Cuando la memoria es abundante, la Cach puede crecer, pero cuando la memoria es escasa la Cach puede decrecer para ser efectiva. ",

    "89",     "Mapas de datos por segundo es la frecuencia con que un sistema de archivos tal como NTFS o HPFS asigna una pgina del archivo en cach para leer la pgina. ",

    "91",     "Mapas de datos sncronos por segundo es la frecuencia con que un sistema de archivos como NTFS o HPFS asigna una pgina del archivo en cach para leer la pgina, y espera que la memoria cach obtenga la pgina  si no est en la memoria principal. ",

    "93",     "Mapas de datos sincrnicos por segundo es la frecuencia con que una aplicacin que utiliza un sistema de archivos como NTFS o HPFS asigna una pgina del archivo en cach para leer la pgina, y no espera que la memoria cach obtenga la pgina  si no est en la memoria principal. ",

    "95",     "Aciertos en mapas de datos es el porcentaje de mapas de datos en cach que pudieron resolverse sin tener que tener acceso al disco; es decir, la pgina ya se encontraba en la memoria fsica.",

    "97",     "Mapas de datos fijados por segundo es la frecuencia de mapas de datos en la cach que result de fijar una pgina en la memoria principal, accin normalmente preparatoria para escribir el archivo en disco. Mientras se fija, una direccin fsica de pgina de la memoria principal y virtual de la memoria cach no se alterarn. ",

    "99",     "Lecturas de fijacin por segundo es la frecuencia de lectura de datos en la memoria cach previa a la escritura de datos en el disco. Las pginas ledas de esta forma se fijan en memoria al final de la lectura. Mientras se fija, una direccin fsica de pgina de la memoria cach no se alterar. ",

    "101",     "Lecturas sncronas de fijacin por segundo es la frecuencia de lectura de datos en la memoria cach previa a la escritura de datos en el disco.  Las pginas ledas de esta forma se fijan en memoria al final de la lectura. El sistema de archivos no recobrar el control hasta que la pgina est fija en la memoria cach, en particular si se necesita tener acceso al disco para recuperar la pgina. Mientras se fija, una direccin fsica de pgina de la memoria cach no se alterar.",

    "103",     "Lecturas asincrnicas de fijacin por segundo es la frecuencia de lectura de datos en la memoria cach previa a la escritura de datos en el disco.  Las pginas ledas de esta forma se fijan en memoria al final de la lectura. El sistema de archivos recobrar el control inmediatamente, incluso aunque se necesite tener acceso al disco para recuperar la pgina. Mientras se fija, una direccin fsica de pgina no se alterar.",

    "105",     "Aciertos de lecturas de fijacin es el porcentaje de lecturas de fijacin de cach que resolvi la memoria cach; es decir, no se requiri leer el disco para proporcionar acceso a la pgina en la memoria cach.  Mientras se fija, una direccin fsica de pgina de la memoria cach no se alterar. El Redirector de LAN usa este mtodo para recuperar informacin de cach, as como el servidor de LAN para pequeas transferencias.  Tambin es el mtodo usado normalmente por el sistema de archivos de disco. ",

    "107",     "Lecturas de copia por segundo es la frecuencia de lecturas desde pginas cach que implican una copia en memoria de los datos desde la memoria cach al bfer de aplicacin. El Redirector de LAN usa este mtodo para recuperar informacin de cach, as como el servidor de LAN para pequeas transferencias. Tambin es el mtodo usado normalmente por el sistema de archivos de disco. ",

    "109",     "Lecturas sncronas de copia por segundo es la frecuencia de lecturas desde pginas cach que implican una copia en memoria de los datos desde la memoria cach al bfer de aplicacin.  El sistema de archivos no recobrar el control hasta que la operacin concluya, incluso aunque se necesite tener acceso al disco para recuperar la pgina.",

    "111",     "Lecturas asincrnicas de copia por segundo es la frecuencia de lecturas desde pginas cach que implican una copia en memoria de los datos desde la memoria cach al  bfer de aplicacin. La aplicacin recobrar el control inmediatamente, incluso aunque se necesite tener acceso al disco para recuperar la pgina.",

    "113",     "Aciertos de lecturas de copia es el porcentaje de peticiones de lectura de copias de cach acertadas en la memoria cach; es decir, no se requiri una lectura de disco para proporcionar la pgina en la memoria cach. Una lectura de copia es una operacin de lectura de archivo, que es satisfecha mediante una copia de memoria desde una pgina en memoria cach al bfer de aplicacin. El Redirector de LAN usa este mtodo para recuperar informacin de cach, as como el servidor de LAN para pequeas transferencias. Tambin es el mtodo usado normalmente por el sistema de archivos de disco. ",

    "115",     "Lecturas mediante MDL por segundo es la frecuencia de lecturas de pginas de cach que usan una lista de descriptores de memoria (MDL) para tener acceso a los datos. La MDL contiene la direccin fsica de cada pgina involucrada en la transferencia y as puede utilizar un dispositivo de acceso directo a memoria (DMA) para realizar la copia. El servidor de LAN usa este mtodo para grandes transferencias fuera del servidor.",

    "117",     "Lecturas sncronas mediante MDL por segundo es la frecuencia de lecturas de pginas de cach que usan una lista de descriptores de memoria (MDL) para tener acceso a las pginas. La MDL contiene la direccin fsica de cada pgina de la transferencia que permite el acceso directo a memoria (DMA) de las pginas.  Si la pgina accedida no est en la memoria principal, el programa que realiz la llamada esperar a que se obtenga del disco.",

    "119",     "Lecturas asincrnicas mediante MDL por segundo es la frecuencia de lecturas de pginas de cach que usan una lista de descriptores de memoria (MDL) para tener acceso a las pginas. La MDL contiene la direccin fsica de cada pgina de la transferencia que permite el acceso directo a memoria (DMA) de las pginas. Si la pgina accedida no est en la memoria principal, el programa de aplicacin que realiz la llamada no esperar a que se obtenga del disco.",

    "121",     "Aciertos de lecturas mediante MDL es el porcentaje de peticiones de lectura de cach mediante la lista de descriptores de memoria (MDL) acertadas en memoria cach; p.e., no se necesit tener acceso al disco para proporcionar acceso a memoria a la(s) pgina(s) en la memoria cach.",

    "123",     "Las lecturas anticipadas por segundo indican la frecuencia de lecturas de cach donde la memoria cach detecta acceso secuencial a un archivo.  Las lecturas por adelantado permiten que los datos se transfieran en bloques mayores que los pedidos por la aplicacin, reduciendo el coste por acceso. ",

    "125",     "Lecturas rpidas por segundo es la frecuencia de lecturas desde pginas de cach con la que elude el sistema de archivos instalado y obtiene los datos directamente de la memoria cach. Normalmente, las peticiones de E/S de archivos llaman al sistema de archivos apropiado para obtener los datos de un archivo, pero esta ruta permite obtener directamente datos de la memoria cach sin utilizar ningn sistema de archivos, si los datos estn en la memoria cach. Incluso aunque no estn en ella, se  evita una llamada al sistema de archivos. ",

    "127",     "Lecturas sncronas rpidas por segundo es la frecuencia de lecturas desde pginas de cach con la que elude el sistema de archivos instalado y obtiene los datos directamente de la memoria cach. Normalmente, las peticiones de E/S de archivos llaman al sistema de archivos apropiado para obtener los datos de un archivo, pero esta ruta permite obtener directamente datos de la memoria cach sin utilizar ningn sistema de archivos, si los datos estn en la memoria cach. Incluso aunque no estn en ella, se  evita una llamada al sistema de archivos.  Si los datos no estn en la memoria cach, la peticin (llamada del programa de aplicacin) esperar hasta que los datos se hayan obtenido del disco. ",

    "129",     "Lecturas asincrnicas rpidas por segundo es la frecuencia de lecturas desde pginas de cach con la que elude el sistema de archivos instalado y obtiene los datos directamente de la memoria cach. Normalmente, las peticiones de E/S de archivos llaman al sistema de archivos apropiado para obtener los datos de un archivo, pero esta ruta permite obtener directamente datos de la memoria cach sin utilizar ningn sistema de archivos, si los datos estn en la memoria cach. Incluso aunque no estn en ella, se  evita una llamada al sistema de archivos.  Si los datos no estn en la memoria cach, la peticin (llamada del programa de aplicacin) no esperar hasta que los datos se hayan obtenido del disco, sino que obtendr el control inmediatamente. ",

    "131",     "Errores de recursos de lecturas rpidas por segundo es la frecuencia de errores de cach debidos a una falta de recursos disponibles para satisfacer las peticiones. ",

    "133",     "Lecturas rpidas no posibles por segundo es la frecuencia con que se intenta eludir el sistema de archivos para obtener datos de la memoria cach, realizados por una llamada de funcin de la interfaz de programacin de aplicaciones (API) que no pudo llevarse a cabo sin llamar al sistema de archivos. ",

    "135",     "Vaciados de escritura lenta por segundo es la frecuencia con que el subproceso de escritura lenta de cach ha escrito en disco.  La escritura lenta es el proceso de actualizacin del disco despus de que la pgina ha cambiado en memoria; as la aplicacin que realiza el cambio en el archivo no tiene que esperar a que la escritura en disco est terminada para continuar. Se puede transferir ms de una pgina en cada operacin de escritura. ",

    "137",     "Pginas de escritura lenta por segundo es la frecuencia con que el subproceso de escritura lenta de cach ha escrito en disco.  La escritura lenta es el proceso de actualizacin del disco despus de que la pgina ha cambiado en memoria; as la aplicacin que realiza el cambio en el archivo no tiene que esperar a que la escritura en disco est terminada para continuar. Se puede transferir ms de una pgina en cada operacin de escritura en disco. ",

    "139",     "Vaciados de datos por segundo es la frecuencia con que la memoria cach ha transferido su contenido al disco como resultado de una peticin de vaciado o para resolver una peticin de escritura de un archivo de escritura transparente. Se puede transferir ms de una pgina en cada operacin de vaciado. ",

    "141",     "Pginas de vaciado de datos por segundo es el nmero de pginas cuyo contenido ha transferido la memoria cach al disco como resultado de una peticin de vaciado o para resolver una peticin de escritura de un archivo de escritura transparente. Se puede transferir ms de una pgina en cada operacin de vaciado. ",

    "143",     "% de tiempo de usuario es el porcentaje de tiempo de procesador empleado en modo usuario. Modo usuario es un modo de proceso restringido diseado para aplicaciones, subsistemas de entorno y subsistemas ntegros. La alternativa, modo privilegiado, est diseado para componentes de sistema operativo y permite acceso directo al hardware y a toda la memoria. El sistema operativo cambia los procesos de las aplicaciones a modo privilegiado para tener acceso a los servicios del sistema operativo. Este contador muestra el tiempo ocupado medio como un porcentaje del tiempo de muestra.",

    "145",     "% Tiempo privilegiado es el porcentaje del tiempo transcurrido durante el cual el subproceso del proceso ha estado ejecutndose en modo privilegiado. Cuando se llama a un servicio del sistema Windows, con frecuencia el servicio se ejecuta en modo privilegiado para poder tener acceso a los datos privados del sistema. Estos datos estn protegidos contra el acceso por parte de subprocesos que se estn ejecutando en modo usuario. Las llamadas al sistema pueden ser explcitas o implcitas, como sucede cuando tiene lugar un error de pgina o una interrupcin. A diferencia de sistemas operativos anteriores, Windows delimita los procesos para la proteccin de subsistemas, adems de la proteccin tradicional mediante los modos de usuario y privilegiado. Algn trabajo realizado por Windows para la aplicacin puede aparecer en otros procesos del subsistema, agregado al Tiempo privilegiado del proceso. ",

    "147",     "Cambios de contexto por segundo es la proporcin de cambios de un subproceso a otro. Los cambios de subproceso ocurren cuando un subproceso en ejecucin abandona voluntariamente al procesador, es adelantado por un subproceso de lectura de prioridad mayor o cambia entre nodo usuario y modo privilegiado (kernel) para usar un servicio Ejecutivo o subservicio. Es la suma de Subprocesos\\Cambios de contextos por segundo para todos los subprocesos ejecutndose en todos los procesadores en el equipo  y se mide en nmeros de cambios. Hay contadores de cambio de contexto en los objetos de sistema y de subproceso. Este contador muestra la diferencia entre los valores observados en las dos ltimas muestras dividido por la duracin del intervalo de muestra. ",

    "149",     "Interrupciones/seg es la frecuencia, de incidentes por segundo, a la cual el procesador recibe y responde a las interrupciones del hardware. No incluye llamadas (DPC) de procedimiento diferido, las cuales se cuentan separadamente. Este valor un indicador indirecto de la actividad de los dispositivos que generan interrupciones como el reloj del sistema, el mouse, los controladores de disco, lneas de comunicacin de datos, tarjetas de interfaz de red y otros dispositivos perifricos. Estos dispositivos interrumpen al procesador cuando terminan una tarea o necesitan atencin. La ejecucin de subprocesos normales se suspende. El reloj del sistema interrumpe normalmente al procesador cada 10 milisegundos, creando un fondo de actividad interrumpida. Este contador muestra la diferencia entre los valores observados en las dos ltimas muestras, dividida entre la duracin del intervalo de muestreo.",

    "151",     "Llamadas del sistema por segundo es la frecuencia de llamadas a rutinas de servicio del sistema operativo por todos los procesos que se estn ejecutando en el equipo. Estas rutinas ejecutan todas las sincronizaciones y planificaciones bsicas de actividades del equipo, y proporcionan acceso a dispositivos no grficos, administracin de memoria y de espacio de nombres. Este contador muestra la diferencia entre los valores observados en los dos ltimos ejemplos, dividido por la duracin del intervalo del ejemplo. ",

    "153",     "Cargas de TLB de nivel 1 por segundo es la frecuencia de errores que ocurren al hacer una referencia a memoria cuya entrada de tabla de pginas (PTE) no est en el bfer de traduccin de direcciones (TLB).  En algunos equipos, el software controla este error al  cargar PTE en TLB y se incrementa este contador. ",

    "155",     "Cargas de TLB de nivel 2 por segundo es la frecuencia de errores que ocurren al hacer una referencia a memoria cuya entrada de tabla de pginas (PTE) no est en el bfer de traduccin de direcciones (TLB), ni en la pgina que contiene la PTE.  En algunos equipos, el software controla este error al cargar PTE en TLB y se incrementa este contador. ",

    "157",     "% de tiempo de usuario es el porcentaje de tiempo que el subproceso de este proceso ha invertido en ejecutar cdigo en modo usuario. Las aplicaciones se ejecutan en modo usuario, as como los subsistemas, como el administrador de ventanas y el motor de grficos. El cdigo ejecutado en modo usuario no puede daar la integridad del Ejecutivo, del ncleo y de los controladores de dispositivos de Windows. A diferencia de sistemas operativos anteriores, Windows delimita los procesos para la proteccin de subsistemas, adems de la proteccin tradicional mediante los modos de usuario y privilegiado. Debido a esto, algn trabajo realizado por Windows para la aplicacin puede aparecer en otros procesos del subsistema, agregado al Tiempo privilegiado del proceso.",

    "159",     "% de tiempo privilegiado es el porcentaje de tiempo transcurrido que el subproceso del proceso emplea en ejecutar cdigo en modo privilegiado. Cuando se llama a un servicio del sistema de Windows, el servicio se ejecutar en modo privilegiado para obtener acceso a los datos privados del sistema. Este tipo de datos se protege del acceso de subprocesos que se ejecuten en modo de usuario. Las llamadas al sistema pueden ser implcitas y explcitas, como errores de pginas o interrupciones. De forma diferente a anteriores sistemas operativos, Windows usa lmites de procesos para la proteccin del subsistema en adiccin a la proteccin tradicional del usuario y de los modos privilegiados.  Algunos trabajos hechos por Windows en nombre de aplicaciones puede aparecer en otros procesos de subsistemas en adiccin al tiempo privilegiado en el proceso.",

    "161",     "Enumeraciones de servidor/s. es la frecuencia a la cual las peticiones de bsqueda de servidores se han procesado por esta estacin de trabajo.",

    "163",     "Enumeraciones de dominio/s. es la frecuencia a la cual, las peticiones de bsqueda han sido procesadas por esta estacin de trabajo.",

    "165",     "Enumeraciones de otros/s. es la frecuencia a la cual las peticiones de bsqueda procesadas por esta estacin de trabajo, no son peticiones de bsqueda de dominio o de servidor.",

    "167",     "Anuncios de servidor perdidos es la cantidad de anuncios que se han perdido debido a limitaciones de espacio o configuracin.",

    "169",     "Datagramas de correo perdidos es la cantidad de datagramas que se han descartado debido a limitaciones de espacio o configuracin.",

    "171",     "Peticiones de lista de servidores perdidas es la cantidad de peticiones para obtener una lista de servidores para el examinador recibidas por esta estacin de trabajo que no se pudieron procesar.",

    "173",     "Uso mximo del espacio virtual es el tamao mximo, en bytes, de espacio de direcciones virtuales que el proceso ha utilizado al mismo  tiempo. El uso del espacio de direcciones virtual no implica  necesariamente correspondencia con el uso del disco o de las pginas de memoria principal. Sin embargo, el espacio virtual es limitado y el proceso puede reducir su capacidad de cargar bibliotecas.",

    "175",     "Bytes del espacio virtual es el tamao actual en bytes del espacio de direcciones virtuales que el proceso est usando.  El uso del espacio de direcciones virtuales no implica necesariamente correspondencia con el uso del disco o de las pginas de memoria principal. Sin embargo, el espacio virtual es limitado y el proceso puede reducir su capacidad de cargar bibliotecas.",

    "177",     "Errores de pgina por segundo es la frecuencia a la cual los errores de pgina producidos por los subprocesos ejecutados en este proceso estn ocurriendo.  Un error de pgina ocurre cuando un subproceso se refiere a una pgina de memoria virtual que no est en su espacio de trabajo de la memoria principal. No se produce una bsqueda de la pgina en disco si est en la lista En espera y por tanto en la memoria principal, o si otro proceso con el que se comparta la pgina est usndola.",

    "179",     "Uso mximo del espacio de trabajo es el tamao mximo, en bytes, de pginas en el espacio de trabajo de este proceso alcanzado en un momento determinado.  El espacio de trabajo es el conjunto de pginas de memoria utilizadas recientemente por los subprocesos del proceso. Si la memoria disponible del equipo est por encima de un umbral, las pginas se mantienen en el espacio de trabajo de un proceso incluso si no estn siendo usadas. Cuando la memoria disponible pasa a estar por debajo del umbral, se recuperan las pginas desde los espacios de trabajo. Si son necesarias se producir un error de pgina soft, volviendo al rea de trabajo antes de abandonar la memoria principal.",

    "181",     "Espacio de trabajo es el tamao actual, en bytes, del espacio de trabajo de este proceso.  El espacio de trabajo es el conjunto de pginas de memoria utilizadas recientemente por los subprocesos del proceso. Si la memoria disponible del equipo est por encima de un umbral, las pginas se mantienen en el espacio de trabajo de un proceso incluso si no estn siendo usadas. Cuando la memoria disponible pasa a estar por debajo del umbral, se recuperan las pginas desde los espacios de trabajo. Si son necesarias se producir un error de pgina soft, volviendo al rea de trabajo antes de abandonar la memoria principal. ",

    "183",     "Mximo de bytes del archivo de paginacin es la cantidad mxima de memoria virtual, en bytes, que este proceso ha reservado para usar en el archivo(s) de paginacin. Los archivos de paginacin son utilizados para almacenar pginas de memoria usadas por el proceso que no estn contenidas en otros archivos. Todos los procesos comparten los archivos de paginacin, y la falta de espacio en los archivos de paginacin puede impedir la asignacin de memoria a otros procesos. Si no hay archivo de paginacin, este contador indicar la cantidad mxima de memoria virtual que el proceso ha reservado para usar en la memoria fsica.",

    "185",     "Bytes del archivo de paginacin es la cantidad actual de memoria virtual, en bytes, que este proceso ha reservado para usar en el archivo(s) de paginacin. Los archivos de paginacin suelen almacenar pginas de memoria usadas por el proceso que no estn contenidas en otros archivos. Todos los procesos comparten el archivo de paginacin, y la falta de espacio en los archivos de paginacin puede impedir la asignacin de memoria a otros procesos. Si no hay archivo de paginacin, este contador indicar la cantidad actual de memoria virtual que el proceso ha reservado para usar en la memoria fsica.",

    "187",     "Bytes privados es el tamao actual, en bytes, de la memoria que este proceso tiene asignados que no pueden ser compartidos con otros procesos.",

    "189",     "% Tiempo de procesador es el porcentaje de tiempo durante el cual todos los subprocesos del proceso han utilizado el procesador para la ejecucin de instrucciones. Una instruccin es la unidad bsica de ejecucin en un equipo, un subproceso es el objeto que ejecuta instrucciones y un proceso es el objeto creado cuando se ejecuta un programa.  Se puede contar para este proceso el cdigo ejecutado para controlar ciertas interrupciones de hardware o condiciones de captura para este subproceso.",

    "191",     "% Tiempo de procesador es el porcentaje de tiempo durante el cual todos los subprocesos del proceso han utilizado el procesador para la ejecucin de instrucciones. Una instruccin es la unidad bsica de ejecucin en un equipo, un subproceso es el objeto que ejecuta instrucciones y un proceso es el objeto creado cuando se ejecuta un programa.  Se puede contar para este proceso el cdigo ejecutado para controlar ciertas interrupciones de hardware o condiciones de captura para este subproceso.",

    "193",     "% Tiempo de usuario es el porcentaje del tiempo transcurrido durante el cual este subproceso ha estado ejecutando cdigo en modo usuario. Las aplicaciones se ejecutan en modo usuario, al igual que subsistemas como el administrador de ventanas y el motor de grficos. El cdigo ejecutado en modo usuario no puede daar la integridad del Ejecutivo, del ncleo y de los controladores de dispositivos de Windows NT. A diferencia de sistemas operativos anteriores, Windows NT delimita los procesos para la proteccin de subsistemas, adems de la proteccin tradicional mediante los modos de usuario y privilegiado. Debido a esto, algn trabajo realizado por Windows NT para su aplicacin puede aparecer en otros procesos del subsistema, agregado al Tiempo privilegiado de su proceso.",

    "195",     "% Tiempo privilegiado es el porcentaje del tiempo transcurrido durante el cual el subproceso del proceso ha estado ejecutndose en modo privilegiado. Cuando se llama a un servicio del sistema Windows, con frecuencia el servicio se ejecuta en modo privilegiado para poder tener acceso a los datos privados del sistema. Estos datos estn protegidos contra el acceso por parte de subprocesos que se estn ejecutando en modo usuario. Las llamadas al sistema pueden ser explcitas o implcitas, como sucede cuando tiene lugar un error de pgina o una interrupcin. A diferencia de sistemas operativos anteriores, Windows delimita los procesos para la proteccin de subsistemas, adems de la proteccin tradicional mediante los modos de usuario y privilegiado. Algn trabajo realizado por Windows para la aplicacin puede aparecer en otros procesos del subsistema, agregado al Tiempo privilegiado del proceso.",

    "197",     "Cambios de contexto por segundo es la frecuencia de conmutacin de un subproceso a otro. Las conmutaciones de subprocesos pueden producirse dentro de un mismo proceso o entre distintos procesos. Una conmutacin de subprocesos puede deberse a que un subproceso haya pedido informacin a otro o a que un subproceso haya requisado el procesador a otro, en cuyo caso el subproceso de mayor prioridad quedar preparado para ejecutarse. A diferencia de sistemas operativos anteriores, Windows NT delimita los procesos para la proteccin de subsistemas, adems de la proteccin tradicional mediante los modos de usuario y privilegiado. Debido a esto, algn trabajo realizado por Windows NT para su aplicacin puede aparecer en otros procesos del subsistema, agregado al Tiempo privilegiado de la aplicacin. Cambiar al proceso de subsistema provoca un cambio de contexto en el subproceso de aplicacin. Volver al proceso inicial provoca otro cambio de contexto en dicho subproceso.",

    "199",     "Longitud de la cola actual de disco es la cantidad de peticiones pendientes en el disco en el instante en que se recopilan los datos relativos al rendimiento. Incluye tambin las peticiones en servicio en el momento de la coleccin. Refleja la longitud en un momento determinado; no es una media en un intervalo de tiempo. En un cilindro de discos puede haber mltiples peticiones activas al mismo tiempo, mientras otras peticiones concurrentes esperan servicio. Este contador puede reflejar de forma transitoria un valor de longitud de cola alto o bajo pero, si la unidad de disco est sometida a una carga de trabajo continua, lo ms probable es que sea casi siempre alto. Las peticiones experimentan retrasos proporcionales a la longitud de la cola menos el nmero de discos que compongan el cilindro. Para un buen rendimiento, esta diferencia debera ser inferior a dos.",

    "201",     "% de tiempo de disco es el porcentaje de tiempo durante el cual la unidad de disco seleccionada estuvo ocupada atendiendo peticiones de lectura o escritura.",

    "203",     "% de tiempo de lectura de disco es el porcentaje de tiempo durante el cual la unidad de disco seleccionada estuvo ocupada atendiendo peticiones de lectura.",

    "205",     "% de tiempo de escritura en disco es el porcentaje de tiempo durante el cual la unidad de disco seleccionada ha estado ocupada atendiendo peticiones de escritura.",

    "207",     "El promedio de segundos por transferencia de disco es el tiempo, en segundos, de la transferencia de disco media.",

    "209",     "La Media en segundos de lectura es la duracin media en segundos de las operaciones de lectura de datos del disco.",

    "211",     "La Media en segundos de escritura es el tiempo medio en segundos para las operaciones de escritura de datos en disco.",

    "213",     "Transferencias de disco por segundo es la frecuencia de las operaciones de lectura y escritura en el disco.",

    "215",     "Lecturas de disco por segundo es la frecuencia de las operaciones de lectura del disco. ",

    "217",     "Escrituras en disco por segundo es la frecuencia de las operaciones de escritura en el disco. ",

    "219",     "Bytes de disco por segundo es la frecuencia de transferencia de bytes desde o hacia el disco durante las operaciones de lectura y escritura. ",

    "221",     "Bytes ledos de disco por segundo es la frecuencia a la cual los bytes se transfieren desde el disco durante las operaciones de lectura.",

    "223",     "Bytes escritos en disco por segundo es la frecuencia a la que los bytes se transfieren al disco durante las operaciones de escritura.",

    "225",     "La Media de bytes por transferencia es el promedio de bytes transferidos desde o hacia el disco, durante las operaciones de lectura o escritura. ",

    "227",     "La Media de bytes de lectura es el promedio de bytes transferidos desde el disco durante las operaciones de lectura. ",

    "229",     "La Media de bytes de escritura es el promedio de bytes transferidos al disco durante las operaciones de escritura. ",

    "231",     "El tipo de objeto Proceso se crea cuando se ejecuta un programa. Todos los subprocesos de un proceso comparten el mismo espacio de direcciones y tienen acceso a los mismos datos. ",

    "233",     "El tipo de objeto Subproceso es el objeto bsico que ejecuta instrucciones en un procesador. Todo proceso en ejecucin posee al menos un subproceso. ",

    "235",     "Un tipo de objeto Disco fsico es una unidad de disco duro. Contendr una o ms particiones lgicas. Los discos se utilizan para almacenar archivos, programas y datos de paginacin. El disco se lee para recuperar estos elementos y se escribe para registrar los cambios introducidos en los mismos. ",

    "237",     "El tipo de objeto Disco lgico corresponde a una particin de una unidad de disco duro y tiene asignada una letra de unidad, por ejemplo C. Los discos pueden dividirse en secciones diferenciadas en las cuales podrn almacenarse archivos, programas y datos de paginacin. El disco se lee para recuperar estos elementos y se escribe para registrar los cambios introducidos en los mismos. ",

    "239",     "El tipo de objeto Procesador incluye como ocurrencias todos los procesadores del equipo. Un procesador es la parte del equipo que ejecuta clculos aritmticos y lgicos, e inicia operaciones sobre los dispositivos perifricos. Se encarga tambin de ejecutar los programas del equipo. ",

    "241",     "El Tiempo total de procesador % es el porcentaje medio de tiempo que todos los procesadores del sistema estn ocupados ejecutando subprocesos activos. En un sistema multiprocesador, si todos los procesadores estn siempre ocupados, toma el valor de 100%; si todos los procesadores estn ocupados un 50%, toma el valor de 50%; y si un cuarto de los procesadores estn 100% ocupados, toma el valor de 25%. Puede considerarse como la fraccin de tiempo empleado en trabajo til. Cada procesador tiene asignado un subproceso nulo en el proceso nulo que consume aquellos ciclos improductivos del procesador que no son aprovechados por ningn otro subproceso. ",

    "243",     "Tiempo total de usuario % es el porcentaje medio de tiempo transcurrido en modo usuario, entre todos los procesadores. En un sistema multiprocesador, si todos los procesadores estn siempre en modo usuario, toma el valor de 100%; si todos los procesadores en modo usuario un 50%, toma el valor de 50%; y si un cuarto de los procesadores estn en modo usuario, toma el valor de 25%. Las aplicaciones se ejecutan en modo usuario, al igual que subsistemas como el administrador de ventanas o el motor de grficos. El cdigo ejecutado en modo usuario no puede daar la integridad del Ejecutivo, del ncleo ni de los controladores de dispositivos de Windows NT. A diferencia de algunos sistemas operativos anteriores, Windows NT delimita los procesos para la proteccin de subsistemas, adems de la proteccin tradicional mediante los modos de usuario y privilegiado. Debido a esto, algn trabajo realizado por Windows NT para su aplicacin puede aparecer en otros procesos del subsistema, agregado al Tiempo privilegiado en el proceso de su aplicacin. ",

    "245",     "% de tiempo privilegiado total es el porcentaje medio de tiempo transcurrido en modo privilegiado, entre todos los procesadores. Es la suma del procesador: % de tiempo privilegiado para todos los procesadores del equipo, dividido entre el nmero de procesadores. Sistema: % tiempo total de usuario y de Sistema: % tiempo privilegiado total sumado al % del tiempo total privilegiado, pero no siempre al 100%. (Modo privilegiado es un modo de proceso diseado para componentes de sistema operativo que permite acceso directo a toda la memoria. El sistema operativo cambia los procesos de las aplicaciones a modo privilegiado para tener acceso a los servicios del sistema operativo. La alternativa, modo de usuario, es un modo de proceso restringido diseado para aplicaciones, subsistemas de entorno). Este contador muestra el tiempo ocupado medio como un porcentaje del tiempo de muestra.",

    "247",     "Interrupciones totales por segundo es la frecuencia con que el equipo. est recibiendo y sirviendo interrupciones hardware. Algunos dispositivos que pueden generar interrupciones son el temporizador del sistema, el mouse, las lneas de comunicacin de datos, las tarjetas de interfaz de red y otros dispositivos perifricos. Este contador proporciona informacin sobre el grado de ocupacin de estos dispositivos. Para ms informacin consulte: Interrupciones/s. (Procesador). ",

    "249",     "Procesos es el nmero de procesos existentes en el equipo en el instante de la recopilacin de datos. Se trata de un recuento instantneo y no de un promedio a lo largo de un intervalo de tiempo. Cada proceso representa la ejecucin de un programa.",

    "251",     "Subproceso es el nmero de subprocesos existentes en el equipo en el momento de la recopilacin de datos. Se trata de un recuento instantneo y no de un promedio a lo largo de un intervalo de tiempo. Un subproceso es la unidad ejecutable bsica capaz de ejecutar instrucciones en un procesador.",

    "253",     "Sucesos es el nmero de sucesos existentes en el equipo en el momento de la recopilacin de datos. Se trata de un recuento instantneo y no de un promedio a lo largo de un intervalo de tiempo. Un suceso se utiliza cuando dos o ms subprocesos tratan de sincronizar su ejecucin.",

    "255",     "Semforos es el nmero de semforos existentes en el equipo en el momento de la recopilacin de datos. Se trata de un recuento instantneo y no de un promedio a lo largo de un intervalo de tiempo. Los subprocesos utilizan semforos para obtener el acceso exclusivo a las estructuras de datos que comparten con otros subprocesos.",

    "257",     "Exclusiones mutuas muestra el nmero de exclusiones mutuas existentes en el equipo en el momento de la recopilacin de datos. Se trata de un recuento instantneo y no de un promedio a lo largo de un intervalo de tiempo. Las exclusiones mutuas son utilizadas por los subprocesos para garantizar que slo un subproceso est ejecutando un seccin de cdigo concreta.",

    "259",     "Secciones es el nmero de secciones existentes en el equipo en el momento de la recopilacin de datos. Se trata de un recuento instantneo y no de un promedio a lo largo de un intervalo de tiempo. Una seccin es una parte de la memoria virtual creada por un proceso para almacenar datos. Un proceso puede compartir secciones con otros procesos.",

    "261",     "El tipo de objeto Objetos es un metaobjeto que contiene informacin acerca de los objetos existentes en el equipo. Esta informacin puede utilizarse para detectar el consumo innecesario de recursos del equipo. Cada objeto requiere memoria para almacenar informacin bsica sobre s mismo. ",

    "263",     "Redirector es el objeto que administra las conexiones de red con otros equipos que se originen desde su propio equipo. ",

    "265",     "Bytes recibidos por segundo es la frecuencia de llegada de bytes al Redirector desde la red. En esta cifra se incluyen todos los datos de las aplicaciones, as como la informacin relativa al protocolo de red (por ejemplo, los encabezados de paquetes). ",

    "267",     "Paquetes recibidos por segundo es la frecuencia de recepcin de paquetes en el Redirector (tambin conocidos como SMBs o Bloques de mensaje del servidor). Las transmisiones de la red se dividen en paquetes. Es posible obtener el promedio de bytes recibidos en un paquete, dividiendo la cifra del contador Bytes recibidos/segundo por el valor de este contador. Algunos paquetes recibidos pueden no contener ningn dato (por ejemplo, una seal de confirmacin de una operacin de escritura realizada por el Redirector se contara como un paquete entrante).",

    "269",     "Bytes de paginacin ledos por segundo es la frecuencia con que el Redirector intenta leer bytes en respuesta a errores de pgina. Los errores de pgina son provocados por la carga de mdulos (por ejemplo programas y bibliotecas), por la ausencia de un dato en la memoria cach (ver Bytes ledos de cach por segundo) o por los archivos asignados directamente en el espacio de direcciones de las aplicaciones (funcin de alto rendimiento de Windows NT).",

    "271",     "Bytes que no son de paginacin ledos por segundo son los bytes ledos por el Redirector en respuesta a peticiones normales de archivos, realizadas por una aplicacin, cuando han sido redireccionadas de modo que procedan de otro equipo. Adems de las peticiones de archivo, este contador incluye otros mtodos de lectura a travs de la red, como canalizaciones con nombres y transacciones. El valor de este contador no incluye la informacin sobre el protocolo de red, sino nicamente los datos de la aplicacin. ",

    "273",     "Bytes ledos de cach por segundo es la frecuencia con que las aplicaciones del equipo acceden a la memoria cach utilizando el Redirector. Algunas de estas peticiones de datos pueden ser satisfechas simplemente recuperando los datos de la memoria cach de sistema de la propio equipo, si han sido utilizados recientemente y exista espacio para mantenerlos en la memoria cach. Las peticiones relativas a datos no presentes en la memoria cach provocarn un error de pgina (ver Bytes de paginacin ledos por segundo).",

    "275",     "Bytes ledos de la red por segundo es la frecuencia con que las aplicaciones estn leyendo datos a travs de la red. Por un motivo o por otro, los datos no estaban presentes en la memoria cach de sistema y estos bytes han procedido en realidad de la red. Dividiendo este nmero por el valor de Bytes recibidos por segundo se obtendr la 'eficiencia' de los datos procedentes de la red, ya que todos estos bytes son datos reales de las aplicaciones (ver Bytes recibidos por segundo). ",

    "277",     "Bytes transmitidos por segundo es la frecuencia con que los bytes abandonan el Redirector para dirigirse a la red. Esta cifra incluye todos los datos de las aplicaciones, as como la informacin del protocolo de red (por ejemplo, los encabezados de paquetes y otros datos similares). ",

    "279",     "Paquetes transmitidos por segundo es la frecuencia con que el Redirector est enviando paquetes (tambin conocidos como SMBs o Bloques de mensaje del servidor). Las transmisiones de la red se dividen en paquetes. El nmero medio de bytes transmitidos en un paquete puede obtenerse dividiendo Bytes transmitidos por segundo por el valor de este contador. ",

    "281",     "Bytes de paginacin escritos por segundo es la velocidad a que el Redirector est intentando escribir bytes modificados en pginas que estn siendo utilizadas por las aplicaciones. Los datos de programa que hayan sido modificados por mdulos (por ejemplo, programas y bibliotecas) y hayan sido cargados a travs de la red sern transferidos al archivo de paginacin cuando ya no sean necesarios. Otras pginas de salida proceden de la memoria cach (ver Bytes de escritura en la memoria cach por segundo). ",

    "283",     "Bytes que no son de paginacin escritos por segundo es la frecuencia de escritura de bytes por el Redirector en respuesta a las salidas de archivos normales realizadas por una aplicacin, cuando han sido redireccionadas de modo que lleguen a otro equipo. Adems de las peticiones de archivos, este contador incluye otros mtodos de escritura a travs de la red, como las canalizaciones con nombres y las transacciones. Este contador no incluye la informacin del protocolo de red, sino nicamente los datos de las aplicaciones. ",

    "285",     "Bytes escritos en la memoria cach por segundo es la frecuencia con que las aplicaciones del equipo estn escribiendo en la memoria cach mediante el Redirector. Los datos pueden no abandonar inmediatamente el equipo, sino ser retenidos en la memoria cach para su posterior modificacin, antes de ser escritos en la red. De este modo se reduce el trfico en la red. En este recuento se incluyen todas las operaciones de escritura de bytes en la memoria cach. ",

    "287",     "Bytes escritos en la red por segundo es la velocidad con que las aplicaciones estn escribiendo datos a travs de la red. Tal vez se haya eludido la memoria cach del sistema, como sucede con las canalizaciones con nombre o con las transacciones, o la memoria cach haya escrito los bytes a fin de dejar espacio para otros datos. Dividiendo este contador por el valor de Bytes transmitidos por segundo se obtendr la 'eficiencia' de los datos escritos en la red, ya que todos estos bytes son datos reales de las aplicaciones (ver Bytes transmitidos por segundo). ",

    "289",     "Operaciones de lectura por segundo es la frecuencia con que las aplicaciones estn solicitando datos al Redirector. Cada una de las llamadas a un sistema de archivos u otra llamada similar a la interfaz de programacin de aplicaciones (API) se cuenta como una sola operacin. ",

    "291",     "Operaciones de lectura aleatoria por segundo calcula la frecuencia con que se realizan lecturas no secuenciales, archivo por archivo. Si se realiza una lectura utilizando un determinado identificador de archivo y posteriormente esta operacin va seguida por otra lectura no referida al byte inmediatamente contiguo, este contador se ver incrementado en una unidad. ",

    "293",     "Paquetes ledos por segundo es la velocidad con que estn enviando paquetes de lectura a la red. Cada vez que se enva un paquete individual con una peticin de lectura remota de datos, este contador se incrementa en una unidad. ",

    "295",     "Paquetes grandes por segundo es la frecuencia con que las aplicaciones realizan lecturas cuyo tamao es mayor que el doble del tamao del bfer negociado con el servidor. Si se producen demasiadas operaciones de este tipo, puede verse reducida la disponibilidad de recursos del servidor. Este contador se incrementar en una unidad en cada operacin de lectura. No se cuentan los paquetes. ",

    "297",     "Paquetes pequeos ledos por segundo es la frecuencia con que las aplicaciones estn realizando lecturas cuyo tamao es inferior a un cuarto del tamao del bfer negociado con el servidor. Si se realizan demasiadas operaciones de este tipo, es seal de que se estn desperdiciando bferes en el servidor. Este contador se incrementar en una unidad en cada operacin de lectura. No se cuentan los paquetes. ",

    "299",     "Operaciones de escritura por segundo es la frecuencia con que las aplicaciones estn enviando datos al Redirector. Cada llamada a un sistema de archivos o a una API (interfaz de programacin de aplicaciones) similar se cuenta como una operacin. ",

    "301",     "Operaciones de escritura aleatoria por segundo es la frecuencia con que se estn realizando escrituras no secuenciales, archivo por archivo. Si se realiza una escritura utilizando un determinado identificador de archivo y esta operacin va seguida por otra operacin de escritura no referida al byte inmediatamente contiguo, este contador se incrementar en una unidad. ",

    "303",     "Paquetes de escritura por segundo es la frecuencia con que se estn enviando peticiones de escritura a la red. Cada vez que se enve un paquete individual con una peticin de escritura de datos remotos, este contador se incrementar en una unidad. ",

    "305",     "Escrituras grandes por segundo es la frecuencia con que las aplicaciones estn realizando operaciones de escritura cuyo tamao es mayor que el doble del tamao del bfer negociado con el servidor. Un nmero demasiado elevado de este tipo de operaciones puede reducir los recursos del servidor. Este contador se incrementar en una unidad en cada operacin de escritura: cuenta las operaciones de escritura, no los paquetes. ",

    "307",     "Paquetes de escritura pequeos por segundo es la frecuencia con que las aplicaciones estn realizando operaciones de escritura cuyo tamao es inferior a un cuarto del tamao del bfer negociado con el servidor. Un nmero demasiado elevado de este tipo de operaciones indica un consumo innecesario de bferes en el servidor. Este contador se incrementa en una unidad con cada operacin de escritura. IMPORTANTE: Se cuentan las operaciones de escritura, no los paquetes. ",

    "309",     "Lecturas denegadas por segundo es la frecuencia con que el servidor no ha logrado atender las peticiones de Lectura sin formato. Cuando una lectura sea mucho mayor que el tamao del bfer negociado con el servidor, el Redirector solicitar una seal de Lectura sin formato que, si es concedida, permitir la transferencia de datos sin necesidad de enviar gran cantidad de datos adicionales de protocolo asociados a cada paquete. Para poder hacer esto, el servidor deber bloquear todas las dems peticiones, por lo que la peticin ser denegada en caso de que el servidor est realmente ocupado. ",

    "311",     "Escrituras denegadas por segundo es la frecuencia con que el servidor no ha logrado atender peticiones de Escritura sin formato. Cuando una operacin de escritura sea mucho mayor que el tamao del bfer negociado con el servidor, el Redirector solicitar una Escritura sin formato que, si es concedida, permitir la transferencia de datos sin necesidad de enviar gran cantidad de datos adicionales de protocolo asociados a cada paquete. Para poder hacer esto, el servidor deber bloquear todas las dems solicitudes, por lo que la peticin ser denegada en caso de que el servidor est realmente ocupado. ",

    "313",     "Errores de red por segundo es la frecuencia a la cual se producen errores graves de forma inesperada. Estos errores normalmente indican que el Redirector y uno o ms Servidores estn teniendo problemas de comunicacin. Por ejemplo, un error de protocolo SMB (bloque del administrador de servidor) es un error de red. Esto provocar una anotacin en el Registro de sucesos del sistema, donde podr encontrar ms informacin.",

    "315",     "Sesiones de servidor cuenta la cantidad total de objetos de seguridad que el Redirector ha administrado. Por ejemplo, una peticin de inicio de sesin en un servidor seguida de un acceso a la red al mismo servidor establecer una sola conexin, pero dos sesiones. ",

    "317",     "Reconexiones de servidor le indica el nmero de veces que su Redirector ha tenido que reconectarse a un servidor para completar una nueva peticin activa. Si permanece inactivo durante demasiado tiempo, puede ser desconectado por el servidor. Localmente, incluso aunque estn cerrados todos los archivos remotos de un usuario, el Redirector mantendr sus conexiones intactas durante diez minutos (intervalo nominal). Estas conexiones inactivas se conocen como Conexiones latentes. La reconexin exige bastante tiempo. ",

    "319",     "Conexiones Core indica el nmero de conexiones con servidores existentes que utilicen el protocolo original MS-Net MSB, como el propio MS-Net, Xenix o Vax. ",

    "321",     "Conexiones LANMan 2.0 indica el nmero de conexiones con servidores LAN Manager 2.0, incluyendo los servidores LMX. ",

    "323",     "Conexiones LANMan 2.1 indica el nmero de conexiones con servidores LAN Manager 2.1, incluyendo los servidores LMX. ",

    "325",     "Conexiones Windows NT indica el nmero de conexiones con equipos con Windows 2000 o anteriores.",

    "327",     "Desconexiones del servidor indica el nmero de veces que su Redirector ha sido desconectado por un servidor. Vea tambin Reconexiones de servidor. ",

    "329",     "Sesiones suspendidas del servidor indica el nmero de sesiones activas para las cuales ha transcurrido el tiempo lmite y que no han podido continuar por falta de respuesta del servidor remoto. ",

    "331",     "Servidor es el proceso que acta como interfaz entre los servicios del equipo local y los servicios de la red. ",

    "333",     "Es el nmero de bytes que el servidor ha recibido desde la red. Indica el grado de ocupacin del servidor. ",

    "335",     "Es el nmero de bytes que el servidor ha enviado a la red. Indica el grado de ocupacin del servidor. ",

    "337",     "La razn de espera del subproceso slo se aplica cuando el subproceso est en estado de espera (ver Estado de subproceso). Cuando el subproceso est esperando el Ejecutivo es 0  7, por una pgina de memoria es 1  8, por una recepcin de pgina 2  9, por asignacin de recursos comunes 3  10, por retraso de ejecucin 4  11, por una condicin suspendida 5  12, por una peticin de usuario 6  13, por un par de suceso alto 14, por uno bajo 15, por la recepcin de una LPC 16, por la respuesta de una LPC 17, por memoria virtual 18 y por una salida de pgina 19. Los pares de sucesos son utilizados para la comunicacin con subsistemas protegidos (ver Cambio de contexto). ",

    "339",     "% de tiempo de DPC es el porcentaje de tiempo de procesador empleado en llamadas a procedimientos diferidas (DPC). Cuando un dispositivo de hardware interrumpe al procesador, el manipulador de interrupciones puede ejecutar la mayora de su trabajo en una DPC. Las DPC se ejecutan con menor prioridad que las interrupciones y de esta manera puede haber ms interrupciones mientras se est ejecutando una DPC. Las llamador a procedimientos diferidas se ejecutan en modo privilegiado, por lo tanto estn incluidas en Procesador: % de tiempo en modo privilegiado. Este contador puede ayudar a individualizar el origen de un exceso de tiempo gastado en modo privilegiado.",

    "341",     "Es el nmero de sesiones que han sido cerradas porque su tiempo de inactividad ha superado el valor del parmetro de desconexin automtica del servidor. Indica si el valor de desconexin automtica est ayudando a conservar recursos. ",

    "343",     "Es el nmero de sesiones que se han cerrado debido a condiciones de error imprevistas. Indica con qu frecuencia los problemas de red provocan el cierre de sesiones en el servidor. ",

    "345",     "Es el nmero de sesiones que han terminado de forma normal. Resulta til para interpretar las estadsticas sobre el tiempo de espera de sesiones y los errores de sesiones. Permite realizar clculos de porcentajes. ",

    "347",     "Es el nmero de sesiones cuyo cierre se ha forzado. Puede indicar la cantidad de sesiones cerradas debido a limitaciones de hora para el inicio de sesin. ",

    "349",     "Es el nmero de intentos de inicio de sesin fallidos en el servidor. Puede indicar si se est utilizando algn programa de averiguacin de contraseas para violar la seguridad del servidor. ",

    "351",     "Es el nmero de veces que ha fracasado alguna operacin de apertura para algn cliente, con un cdigo STATUS_ACCESS_DENIED. Puede indicar si alguien est intentando tener acceso aleatoriamente a distintos archivos con el objeto de obtener alguno que no est protegido adecuadamente. ",

    "353",     "Es el nmero de veces que se ha denegado el acceso a archivos abiertos correctamente. Puede indicar los intentos de acceso a archivos sin disponer de la correspondiente autorizacin de acceso. ",

    "355",     "Es el nmero de veces que se ha detectado un Error de servidor interno. Los errores inesperados suelen indicar la existencia de un problema en el servidor. ",

    "357",     "Es el nmero de veces que el servidor ha rechazado el bloqueo de SMBs debido a una insuficiencia de elementos de trabajo libres. Indica si puede ser necesario ajustar los parmetros maxworkitem o minfreeworkitems del servidor. ",

    "359",     "Es el nmero de veces que se ha devuelto el cdigo STATUS_DATA_NOTACCEPTED en el momento de indicar la recepcin. Esto sucede cuando no hay ningn elemento de trabajo disponible o no es posible asignar ninguno para atender la peticin entrante. Indica si puede ser necesario ajustar los parmetros initworkitems o maxworkitems. ",

    "361",     "Es el nmero de intentos de apertura logrados que ha ejecutado el servidor en representacin de clientes. Resulta til para determinar la cantidad de operaciones E/S de archivos, para determinar la sobrecarga asociada a operaciones basadas en rutas de acceso y para determinar la eficacia de los bloqueos opcionales. ",

    "363",     "Es el nmero de archivos que estn abiertos actualmente en el servidor. Indica la actividad en curso del servidor. ",

    "365",     "Es el nmero de sesiones que estn activas en este momento en el servidor. Indica la actividad en curso del servidor. ",

    "367",     "Es el nmero de bsquedas de archivos activas en este momento en el servidor. Indica la actividad en curso del servidor. ",

    "369",     "Es el nmero de bytes de memoria no paginable del equipo que est utilizando el servidor actualmente. Este valor es til para determinar los valores de la entrada de valor de MaxNonpagedMemoryUsage en el Registro de Windows NT. ",

    "371",     "Es el nmero de asignaciones errneas a partir de memoria no paginada. Indica que la memoria fsica del equipo es demasiado pequeo.",

    "373",     "Es el mximo nmero de bytes de memoria no paginada que el servidor ha utilizado en un momento dado. Indica la cantidad de memoria fsica que debera tener el equipo.  ",

    "375",     "Es el nmero de bytes de memoria paginada del equipo que est utilizando el servidor actualmente. Permite a los administradores examinar la cantidad de recursos que est empleando el servidor. Puede ayudar a determinar los valores idneos para el parmetro MaxPagedMemoryUsage. ",

    "377",     "Es el nmero de asignaciones errneas a partir de un rea de memoria paginada. Indica que la memoria fsica del equipo dedicada al archivo de paginacin es demasiado pequea. ",

    "379",     "Es el mximo nmero de bytes de memoria paginada que ha asignado el servidor. Indica los tamaos adecuados del archivo de paginacin y de la memoria fsica. ",

    "381",     "Recepciones fallidas de anuncio de servidor/s. es la frecuencia a la cual los anuncios de servidor (o dominio) fallan debido a la falta de memoria.",

    "383",     "Recepciones fallidas de correo es la cantidad total de veces que el receptor de datagramas no pudo asignar un bfer para una escritura de correo de un usuario.",

    "385",     "Recepciones de correo fallidas indica la cantidad mensajes que no se han podido recibir debido a fallas de transporte.",

    "387",     "Grabaciones de correo fallidas es la cantidad de mensajes de correo recibidos correctamente, pero que no se pudieron grabar en la buzn de correo.",

    "389",     "Total de bytes por segundo es la velocidad con que el Redirector procesa bytes de datos. Esto incluye todos los datos de archivos y aplicaciones adems de la informacin de protocolo, como los encabezados de paquetes. ",

    "391",     "Operaciones con datos de archivo por segundo es la frecuencia a la cual el Redirector est procesando operaciones de datos. Cada operacin debe incluir gran cantidad de bytes. Desde que cada operacin incorpora informacin adicional. La eficiencia de esta ruta puede determinarse dividiendo los Bytes/s. entre este contador para obtener el nmero medio de bytes transferidos por operacin.",

    "393",     "Comandos actuales indica el nmero de peticiones entregadas al Redirector que se encuentran actualmente en cola, en espera de ser atendidas. Si este nmero es mucho mayor que el nmero de tarjetas adaptadoras de red instaladas en el equipo, significa que se est produciendo un cuello de botella en la red o las redes, y/o el servidor o servidores, a los cuales se est accediendo. ",

    "395",     "Nmero de bytes que el servidor ha enviado y recibido de la red. Este valor es una estimacin global del grado de ocupacin del servidor. ",

    "397",     "% de tiempo de interrupcin es el tiempo que el procesador invierte recibiendo y atendiendo interrupciones de hardware durante los intervalos de ejemplo. Este valor es un indicador indirecto de la actividad de los dispositivos que generan interrupciones, como el reloj del sistema, el mouse, controladores de disco, lneas de comunicacin de datos, tarjetas de red y otros dispositivos perifricos. Estos dispositivos generalmente interrumpen al procesador cuando han finalizado una tarea o necesitan atencin. La ejecucin de subprocesos normal se suspende  durante las interrupciones. Muchos de los relojes de sistema interrumpen al procesador cada 10 milisegundos, creando un fondo de actividades interrumpidas, suspende la ejecucin del subproceso normal durante las interrupciones. Este contador despliega el tiempo medio de ocupacin como un porcentaje del tiempo de ejemplo.",

    "399",     "La capa de protocolo NetBIOS de NWLink se encarga de la interfaz para la comunicacin de aplicaciones mediante el transporte IPX. ",

    "401",     "Paquetes por segundo es la velocidad con que el Redirector est procesando paquetes de datosCada paquete incluye afortunadamente gran cantidad de bytes. El afortunadamente es debido a que cada paquete contiene informacin adicional del protocolo. Puede determinar la eficiencia de esta ruta dividiendo los Bytes/s. entre este contador para calcular el nmero medio de bytes transferidos/operacin. Tambin puede hacerlo mediante la divisin de este contador entre las Operaciones/s. para determinar el nmero medio de paquetes por operacin. ",

    "405",     "Bloques de contexto en cola por segundo es la frecuencia con que se han colocado bloques de contexto en la cola FSP del servidor, en espera de su ejecucin por parte del servidor. ",

    "407",     "Operaciones con datos de archivos por segundo es la frecuencia con que el equipo est generando operaciones de lectura y escritura sobre dispositivos de sistema de archivos. No incluye las operaciones de control de archivos. ",

    "409",     "% de espacio libre es el porcentaje de espacio total utilizable en la unidad de disco lgica seleccionada que estaba libre.",

    "411",     "Megabytes libres indica el espacio no asignado en la unidad de disco, en megabytes. Un megabyte equivale a 1.048.576 bytes. ",

    "413",     "Conexiones abiertas es el nmero de conexiones que estn abiertas en este momento para este protocolo. Este contador indica nicamente el recuento actual y no un valor acumulativo a lo largo del tiempo. ",

    "415",     "Conexiones sin reintentos es el nmero total de conexiones que se han ejecutado con xito al primer intento. Este nmero es un acumulador y muestra un total acumulativo. ",

    "417",     "Conexiones con reintentos es el nmero total de conexiones que han podido ejecutarse despus de reintentarlo. Un reintento tiene lugar cuando falla el primer intento de conexin. Este nmero es un acumulador y muestra un total acumulativo. ",

    "419",     "Desconexiones locales es el nmero de desconexiones de sesin iniciadas por el equipo local. Se trata de un acumulador, que muestra un valor acumulativo. ",

    "421",     "Desconexiones remotas es el nmero de desconexiones de sesin iniciadas por el equipo remoto. Se trata de un acumulador, que muestra un total acumulativo. ",

    "423",     "Errores de vinculacin es el nmero de conexiones que se han interrumpido debido a un error en el vnculo. Se trata de un acumulador que muestra un total acumulativo.",

    "425",     "Errores en el adaptador es el nmero de conexiones que se han interrumpido debido a un error en el adaptador. Se trata de un acumulador que muestra un total acumulativo.",

    "427",     "Finalizaciones de tiempo de espera de sesin es el nmero de conexiones que se han interrumpido debido a la finalizacin del tiempo de espera de una sesin. Se trata de un acumulador que muestra un total acumulativo. ",

    "429",     "Conexiones canceladas es el nmero de conexiones que se han cancelado. Se trata de un acumulador, que muestra un total acumulativo. ",

    "431",     "Errores de recursos remotos es el nmero de conexiones errneas debido a problemas de recursos o a la escasez de los mismos en el equipo remoto. Se trata de un acumulador que muestra un total acumulativo.",

    "433",     "Errores de recursos locales es el nmero de conexiones errneas debido a problemas de recursos o a escasez de los mismos en el equipo local. Se trata de un acumulador, que muestra un total acumulativo.",

    "435",     "Errores no encontrados es el nmero de intentos de conexin errneos por no haberse podido encontrar el equipo remoto. Se trata de un acumulador que muestra un total acumulativo.",

    "437",     "Errores por no haber escucha es el nmero de conexiones que fueron rechazadas porque el equipo remoto no estaba a la escucha de peticiones de conexin. ",

    "439",     "Datagramas por segundo es la velocidad con que el equipo est procesando datagramas. Este contador muestra el total de datagramas enviados y recibidos. Un datagrama es un paquete sin un camino fijo a seguir en la red, cuya entrega a un nodo remoto no est asegurada. ",

    "441",     "Bytes de datagrama por segundo es la velocidad con que el equipo est procesando bytes de datagrama. Este contador muestra el total de los bytes de datagramas enviados y recibidos. Un datagrama es un paquete sin un camino fijo a seguir en la red, cuya entrega a un nodo remoto no est asegurada. ",

    "443",     "Datagramas enviados por segundo es la velocidad con que se estn enviando datagramas desde el equipo. Un datagrama es un paquete sin un camino fijo a seguir en la red, cuya entrega a un equipo remoto no est asegurado. ",

    "445",     "Bytes de datagrama enviados por segundo es la velocidad con que el equipo est enviando bytes de datagrama. Un datagrama es un paquete sin un camino fijo a seguir en la red, cuya entrega a un equipo remoto no est asegurada. ",

    "447",     "Datagramas recibidos por segundo es la velocidad con que se estn recibiendo datagramas en el equipo. Un datagrama es un paquete sin un camino fijo a seguir en la red, cuya entrega a un equipo remoto no est asegurada. ",

    "449",     "Bytes de datagrama recibidos por segundo es la velocidad con que el equipo est recibiendo bytes de datagrama. Un datagrama es un paquete sin un camino fijo a seguir en la red, cuya entrega a un equipo remoto no est asegurada. ",

    "451",     "Paquetes por segundo es la velocidad con que el equipo est procesando paquetes. Este nmero es el total de paquetes enviados y recibidos por segundo. Este contador incluye todos los paquetes procesados, es decir, tanto los de control como los de datos. ",

    "453",     "Paquetes enviados por segundo es la velocidad con que el equipo est enviando paquetes. Este contador incluye todos los paquetes enviados por el equipo, es decir, tanto los de control como los de datos. ",

    "455",     "Paquetes recibidos por segundo es la velocidad con que el equipo est recibiendo paquetes. Este contador indica todos los paquetes procesados, es decir, tanto los de control como los de datos. ",

    "457",     "Tramas por segundo es la velocidad con que el equipo est procesando tramas de datos (o paquetes). Este contador es el total de las tramas de datos enviadas y las recibidas. Este contador slo incluye las tramas (paquetes) que transportan datos. ",

    "459",     "Bytes de trama por segundo es la velocidad con que el equipo est procesando bytes de datos. Este contador es el total de los bytes de las tramas de datos enviados y recibidos. Slo incluye los bytes de las tramas (paquetes) que transportan datos. ",

    "461",     "Tramas enviadas por segundo es la velocidad con que el equipo est enviando tramas de datos. Este contador incluye nicamente las tramas (paquetes) que transportan datos. ",

    "463",     "Bytes de trama enviados por segundo es la velocidad con que el equipo est enviando bytes de datos. Este contador slo incluye los bytes de las tramas (paquetes) que transportan datos. ",

    "465",     "Tramas recibidas por segundo es la velocidad con que el equipo est recibiendo tramas de datos. Este contador incluye nicamente las tramas (paquetes) que transportan datos. ",

    "467",     "Bytes de trama recibidos por segundo es la velocidad de recepcin de bytes de datos por el equipo. Este contador slo incluye las tramas (paquetes) que transportan datos. ",

    "469",     "Tramas reenviadas por segundo es la frecuencia con que el sistema est reenviando tramas de datos (paquetes). Este contador slo incluye las tramas o paquetes que transportan datos. ",

    "471",     "Bytes de trama reenviados por segundo es la velocidad con que el equipo est reenviando bytes de datos. Este contador slo incluye los bytes de las tramas que transportan datos. ",

    "473",     "Tramas rechazadas por segundo es la frecuencia con que se estn rechazando tramas de datos. Este contador slo incluye las tramas (paquetes) que transportan datos. ",

    "475",     "Bytes de trama rechazados por segundo es la velocidad con que se estn rechazando bytes de datos. Este contador slo incluye los bytes de las tramas de datos (paquetes) que transportan datos. ",

    "477",     "Vencimientos de respuesta es el nmero de veces que ha vencido el plazo del temporizador T1. ",

    "479",     "Vencimientos de confirmacin es el nmero de veces que ha vencido el plazo del temporizador T2. ",

    "481",     "Ventana de transmisin mxima es el nmero mximo de bytes de datos que se enviarn antes de esperar una seal de confirmacin procedente del equipo remoto. ",

    "483",     "Ventana de transmisin media es la media del nmero de bytes de datos enviados antes de esperar una seal de aceptacin procedente del equipo remoto. ",

    "485",     "Superposicin de confirmaciones en cola por segundo es la velocidad con que confirmaciones superpuestas se colocan en la cola. Las confirmaciones superpuestas son confirmaciones a paquetes recibidos que sern incluidas en el prximo paquete de salida hacia el equipo remoto. ",

    "487",     "Terminaciones del tiempo de espera de confirmaciones superpuestas es el nmero de veces que no se ha podido enviar una confirmacin superpuesta porque no hay ningn paquete de salida apropiado en el que hacerlo. Una confirmacin superpuesta es una confirmacin a un paquete recibido, que ser incluida en el prximo paquete de salida hacia el equipo remoto. Si no se ha enviado ningn paquete durante el correspondiente tiempo de espera, se enva un paquete de confirmacin y se incrementa este contador. ",

    "489",     "El transporte IPX de NWLink se encarga de la transmisin de datagramas, y las conexiones de sesin a y desde equipos que utilizan el protocolo IPX. ",

    "491",     "El transporte SPX de NWLink se encarga de la transmisin de datos y las conexiones de sesin para equipos que utilizan el protocolo SPX.",

    "493",     "El Protocolo NetBEUI se encarga de la transmisin de datos en la actividad de red que utiliza la Interfaz de usuario de NetBIOS estndar. ",

    "495",     "El objeto Recurso NetBEUI realiza un seguimiento del uso de los recursos (bferes) por el protocolo NetBEUI. ",

    "497",     "Uso mximo es el mximo nmero de recursos NetBEUI (bferes) en uso al mismo tiempo. Este valor es til al dimensionar los recursos mximos proporcionados. El nmero entre parntesis que se encuentra a continuacin del nombre de recurso se utiliza para identificar el recurso en los mensajes del Registro de sucesos. ",

    "499",     "Uso medio es el nmero de recursos actualmente en uso. El nmero entre parntesis que se encuentra a continuacin del nombre de recurso se utiliza para identificar el recurso en los mensajes del Registro de sucesos. ",

    "501",     "Recursos agotados es el nmero de veces que todos los recursos (bferes) estaban siendo usados al mismo tiempo. El nmero entre parntesis que se encuentra a continuacin del nombre de recurso se utiliza para identificar el recurso en los mensajes del Registro de sucesos. ",

    "503",     "El tipo de objeto Conexin NBT incluye los contadores que describen la velocidad con que se reciben y envan bytes a travs de una conexin NBT individual que enlaza el equipo local con algn equipo remoto. La conexin se identifica por el nombre del equipo remoto. ",

    "505",     "Bytes recibidos por segundo es la velocidad con que se estn recibiendo bytes en el equipo local a travs de una conexin NBT con algn equipo remoto. El recuento incluye todos los bytes recibidos por el equipo local a travs de la conexin NBT concreta. ",

    "507",     "Bytes enviados por segundo es la velocidad con que el equipo local est enviando bytes a algn equipo remoto a travs de una conexin NBT. El contador incluye todos los bytes enviados por el equipo local a travs de la conexin NBT concreta. ",

    "509",     "Total de bytes por segundo es la velocidad con que el equipo local est enviando o recibiendo bytes a travs de una conexin NBT con algn equipo remoto. El contador incluye todos los bytes enviados o recibidos por el equipo local a travs de la conexin NBT concreta.",

    "511",     "El tipo de objeto Interfaz de red incluye los contadores que describen la velocidad con que se estn enviando y recibiendo bytes y paquetes a travs de una conexin de red TCP/IP. Tambin describe diversos recuentos de error asociados a la misma conexin. ",

    "513",     "Total de bytes por segundo es la velocidad a la cual se estn enviando y recibiendo bytes a travs de cada adaptador de red, incluyendo los caracteres de tramas. Interfaz de red\\Bytes recibidos/seg es la suma de la Interfaz de red\\Bytes recibidos/seg y la Interfaz de red\\Bytes enviados/seg.",

    "515",     "Paquetes por segundo es la velocidad con que se estn enviando y recibiendo paquetes en la interfaz de red. ",

    "517",     "Paquetes recibidos por segundo es la velocidad con que se estn recibiendo paquetes en la interfaz de red. ",

    "519",     "Paquetes enviados por segundo es la velocidad con que se han enviado paquetes por la interfaz de red. ",

    "521",     "Ancho de banda actual es una estimacin del ancho de banda actual de la interfaz de red en bits por segundo (bps). Para aquellas interfaces que no puedan variar el ancho de banda o para las que no se permita establecer una estimacin precisa, este valor ser el ancho de banda nominal.",

    "523",     "Bytes recibidos por segundo es la velocidad a la cual se estn recibiendo bytes a travs de cada adaptador de red, incluyendo los caracteres de tramas. La Interfaz de red\\Bytes recibidos/seg es un subconjunto de la Interfaz de red\\Bytes totales/seg.",

    "525",     "Paquetes de monodifusin (Unicast) recibidos por segundo es la frecuencia con que se estn entregando paquetes de monodifusin (subred) a un protocolo de nivel superior. ",

    "527",     "Paquetes de no monodifusin recibidos por segundo es la frecuencia con que se estn entregando paquetes que no son de monodifusin (no Unicast) (es decir, paquetes de difusin [broadcast] de subred o de multidifusin [multicast] de subred) a un protocolo de nivel superior. ",

    "529",     "Paquetes recibidos descartados es el nmero de paquetes internos que se ha optado por descartar, aunque no se haya detectado ningn error que impidiera entregarlos a un protocolo de nivel superior. Un motivo para descartar paquetes puede ser la necesidad de liberar espacio en el bfer.",

    "531",     "Paquetes recibidos con error es el nmero de paquetes internos que contenan errores que impedan entregarlos a un protocolo de nivel superior. ",

    "533",     "Paquetes recibidos desconocidos es el nmero de paquetes recibidos a travs de la interfaz que han sido descartados porque corresponden a un protocolo desconocido o no compatible. ",

    "535",     "Bytes enviados por segundo es la velocidad a la cual los bytes se mandan a travs de cada adaptador de red, incluyendo los caracteres de tramas. La Interfaz de red\\Bytes enviados/seg es un subconjunto de la Interfaz de red\\Bytes totales/seg.",

    "537",     "Paquetes de monodifusin enviados por segundo es la frecuencia con que los protocolos de nivel superior estn solicitando la transmisin de paquetes a direcciones de monodifusin (Unicast) de subred. Esta frecuencia incluye los paquetes que han sido descartados o no enviados. ",

    "539",     "Paquetes de no monodifusin enviados por segundo es la frecuencia con que los protocolos de nivel superior estn solicitando la transmisin de paquetes dirigidos a direcciones que no son de monodifusin (Unicast) (es decir, difusiones [broadcasts] de subred o multidifusiones [multicast] de subred). Esta frecuencia incluye los paquetes que han sido descartados y los que no han sido enviados. ",

    "541",     "Paquetes de salida descartados es el nmero de paquetes externos que se ha optado por descartar, aunque no se haya detectado ningn error en ellos que impidiera su transmisin. Un motivo para descartar paquetes puede ser la necesidad de liberar espacio en el bfer.",

    "543",     "Paquetes de salida con errores es el nmero de paquetes externos que no han podido transmitirse debido a errores. ",

    "545",     "Longitud de la cola de salida es la longitud de la cola de paquetes de salida (en paquetes). Si es superior a dos, se produce retraso, y debe encontrarse y eliminarse el cuello de botella existente. Teniendo en cuenta que las peticiones son puestas en la cola por la especificacin de interfaz de controlador de red (NDIS) en esta aplicacin, este contador deber ser siempre 0.",

    "547",     "El tipo de objeto IP incluye los contadores que describen las frecuencias con que un determinado equipo que utiliza el protocolo IP recibe y enva datagramas. Describe tambin diversos recuentos de error asociados al protocolo IP. ",

    "549",     "Datagramas por segundo es el ritmo, de incidentes por segundo, al cual se recibieron o enviaron datagramas IP a las interfaces, incluyendo los que contienen errores. Este valor no incluye los datagramas reenviados.",

    "551",     "Datagramas recibidos por segundo es la velocidad, de incidentes por segundo, a la cual datagramas IP se reciben desde las interfaces, incluyendo los que contienen errores. Los datagramas recibidos/seg es el subconjunto de datagramas/seg.",

    "553",     "Datagramas recibidos con errores de encabezado es el nmero de datagramas de entrada que fueron descartados debido a errores en los encabezados IP, como sumas de comprobacin errneas, incoherencias en el nmero de versin, errores diversos de formato, expiracin de su tiempo de duracin, deteccin de errores en el momento de procesar sus opciones para IP, etc.",

    "555",     "Datagramas recibidos con errores de direccin es el nmero de datagramas de entrada que se descartaron porque la direccin IP que figuraba en el campo de destino de su encabezado IP no era vlido para el equipo. Este recuento incluye las direcciones no vlidas (por ejemplo, 0.0.0.0) y las direcciones de clases no compatibles (por ejemplo, clase E). Para las entidades que no sean puertas de enlace IP y que no necesiten reenviar datagramas, este contador incluye los datagramas que fueron descartados porque la direccin de destino no era una direccin local.",

    "557",     "Datagramas reenviados/seg. es la frecuencia, de incidentes por segundo, a la cual se realizaron intentos para encontrar rutas para enviar salidas de datagramas a su destino final, porque el servidor local no fue el IP final de destino. En servidores que no actan como puertas de enlace IP, esta frecuencia incluye slo paquetes que fueron dirigido originariamente a travs de esta entidad, donde la opcin de ruta de origen en proceso fue correcta.",

    "559",     "Datagramas recibidos con protocolo desconocido es el nmero de datagramas con direccin local recibidos correctamente pero descartados por corresponder a un protocolo desconocido o no compatible. ",

    "561",     "Datagramas recibidos descartados es el nmero de datagramas IP de entrada que se descartaron para los cuales no se ha detectado ningn problema que impidiera seguir procesndolos (por ejemplo, por falta de espacio en el bfer). Este contador no incluye ninguno de los datagramas descartados cuando estaban en espera de ser reensamblados.",

    "563",     "Datagramas recibidos entregados por segundo es la frecuencia, de incidentes por segundo, a la cual los datagramas de entrada son entregados con xito a los protocolos de usuario IP, incluyendo el Protocolo de mensajes de control de Internet (ICMP).",

    "565",     "Datagramas enviados por segundo es la frecuencia, de incidentes por segundo, a la cual los datagramas IP fueron proporcionados por transmisiones de protocolos de usuario IP locales (incluyendo ICMP). Este contador no incluye los datagramas incluidos en el contador Datagramas reenviados/seg. Los datagramas enviados/seg son un subconjunto de Datagramas/seg.",

    "567",     "Datagramas de salida descartados es el nmero de datagramas IP de salida que se descartaron a pesar de que no se encontraron problemas para prevenir la transmisin a su destino (por ejemplo, por falta de espacio en el bfer). Este contador incluye los datagramas contados en Datagramas reenviados/seg, que cumplen con ese criterio.",

    "569",     "Datagramas de salida sin enrutamiento es el nmero de datagramas IP que fueron descartados porque no ha podido encontrarse ningn camino para encaminarlos hasta su destino. Este contador incluye todos los paquetes contados en Datagramas reenviados/seg que satisfagan el criterio "sin camino".",

    "571",     "Fragmentos recibidos por segundo es la frecuencia, de incidentes por segundo, a la cual se han recibido en esta entidad fragmentos IP que tienen que reensamblarse.",

    "573",     "Fragmentos reensamblados por segundo es la frecuencia, de incidentes por segundo, a la cual lo fragmentos IP que se han reensamblado correctamente. ",

    "575",     "Errores de reensamblado de fragmentos es el nmero de errores detectados por el algoritmo de reensamble de IP, como el fin del tiempo de espera, errores, etc. Este no es necesariamente de un recuento de los fragmentos IP descartados, ya que puede haber ciertos algoritmos (especialmente los RFC 815) que pierdan la cuenta del nmero de fragmentos combinndolos en el momento en que se reciben.",

    "577",     "Datagramas fragmentados por segundo es la frecuencia, de incidentes por segundo, a la cual los datagramas se han fragmentado correctamente.",

    "579",     "Errores de fragmentacin es el nmero de datagramas IP que fueron descartados porque aunque era necesario fragmentarlos pero no ha sido posible hacerlo (por ejemplo, debido a que estaba activado su indicador "no fragmentar").",

    "581",     "Fragmentos creados por segundo es la frecuencia, de incidentes por segundo, a la cual se generaron fragmentos de datagramas IP como resultado de la fragmentacin.",

    "583",     "El tipo de objeto ICMP incluye los contadores que describen las frecuencias con que una determinada entidad ha enviado y recibido mensajes ICMP, utilizando el protocolo ICMP. Describe tambin diversos recuentos de error del protocolo ICMP. ",

    "585",     "Mensajes por segundo es la frecuencia total, de incidentes por segundo, a la cual se recibieron  y enviaron mensajes ICMP en la entidad. Esta cifra incluye los mensajes recibidos o enviados con algn error.",

    "587",     "Mensajes recibidos por segundo es la frecuencia, de incidentes por segundo, a la cual se recibieron mensajes ICMP. Esta cifra incluye los mensajes recibidos con algn error.",

    "589",     "Mensajes recibidos con error es el nmero de mensajes ICMP que ha recibido la entidad, como errores en la suma de comprobacin ICMP, longitud inadecuada, etc.",

    "591",     "Destinos inaccesibles recibidos es el nmero de mensajes ICMP de tipo 'Destination Unreachable' (destino inaccesible) que se han recibido. ",

    "593",     "Finalizaciones de tiempo recibidas es el nmero de mensajes ICMP de tipo 'Time Exceeded' (ha terminado el tiempo) que se han recibido. ",

    "595",     "Problemas de parmetros recibidos es el nmero de mensajes ICMP de tipo 'Parameter Problem' (problema de parmetros) que se han recibido. ",

    "597",     "Desconexiones del origen recibidas es el nmero de mensajes ICMP de tipo 'Source Quench' (desconexin del origen) que se han recibido. ",

    "599",     "Redirecciones recibidas por segundo es la frecuencia, de incidentes por segundo, a la cual se recibieron mensajes de redireccin ICMP.",

    "601",     "Ecos recibidos por segundo es la frecuencia, de incidentes por segundo, a la cual se recibieron mensajes eco ICMP.",

    "603",     "Respuestas al eco recibidas por segundo es la frecuencia, de incidentes por segundo, a la cual se recibieron mensajes de respuesta al eco ICMP.",

    "605",     "Marcas temporales recibidas por segundo es la frecuencia, de incidentes por segundo, a la cual se recibieron mensajes de peticin de marca temporal ICMP.",

    "607",     "Respuestas a marcas temporales recibidas por segundo es la frecuencia con que se han recibido mensajes ICMP de tipo 'Timestamp Reply' (respuesta a marca temporal). ",

    "609",     "Mscaras de direcciones recibidas es el nmero de mensajes ICMP de tipo 'Address Mask Reply' (peticin de mscara de direcciones) que se han recibido. ",

    "611",     "Respuestas a mscara de direcciones recibidas es el nmero de mensajes ICMP de tipo 'Address Mask Reply' (respuesta a mscara de direcciones) que se han recibido. ",

    "613",     "Mensajes enviados por segundo es la frecuencia, de incidentes por segundo, a la cual el servidor intent enviar. Esta cifra incluye los mensajes enviados con errores.",

    "615",     "Mensajes enviados con errores es el nmero de mensajes ICMP que no se enviaron debido a problemas en ICMP, como la falta de bferes. Este valor no debe incluir los errores detectados fuera del nivel ICMP, como la imposibilidad del IP de encaminar el datagrama resultante. En ciertas implementaciones puede no existir ningn tipo de error que sea capaz de contribuir a incrementar este contador.",

    "617",     "Destinos inaccesibles enviados es el nmero de mensajes ICMP de tipo 'Destination Unreachable' (destino inaccesible) que se han enviado. ",

    "619",     "Finalizaciones del tiempo enviadas es el nmero de mensajes ICMP de tipo 'Time Exceeded' (finalizacin del tiempo) que se han enviado. ",

    "621",     "Problemas de parmetros enviados es el nmero de mensajes ICMP de tipo 'Parameter Problem' (problema de parmetros) que se han enviado. ",

    "623",     "Desconexiones del origen enviadas es el nmero de mensajes ICMP de tipo 'Source Quench' (desconexin del origen) que se han enviado. ",

    "625",     "Redirecciones enviadas por segundo es la frecuencia, de incidentes por segundo, a la cual se enviaron mensajes de redireccin ICMP.",

    "627",     "Ecos enviados por segundo es la frecuencia con que se han enviado mensajes ICMP de tipo 'Echo' (eco). ",

    "629",     "Respuestas al eco enviadas por segundo es la frecuencia, de incidentes por segundo, a la cual se enviaron mensajes de respuesta de eco ICMP.",

    "631",     "Marcas temporales enviadas por segundo es la frecuencia, de incidentes por segundo, a la cual se enviaron mensajes de peticiones de marca temporal ICMP.",

    "633",     "Respuestas a marcas temporales enviadas por segundo es la frecuencia, de incidentes por segundo, a la que se han enviado mensajes de respuesta a marcas temporales ICMP.",

    "635",     "Mscaras de direcciones enviadas es el nmero de mensajes ICMP de tipo 'Address Mask' (mscara de direcciones) que se han enviado. ",

    "637",     "Respuestas a mscara de direcciones enviadas es el nmero de mensajes ICMP de tipo 'Address Mask Reply' (respuesta a mscara de direcciones) que se han enviado. ",

    "639",     "El tipo de objeto TCP incluye los contadores que describen las frecuencias con que una determinada entidad enva y recibe segmentos TCP utilizando el protocolo TCP. Asimismo, indica el nmero de conexiones TCP que se encuentran en cada uno de los posibles estados de conexin TCP. ",

    "641",     "Segmentos por segundo es la frecuencia con que se envan o reciben segmentos TCP utilizando el protocolo TCP. ",

    "643",     "Conexiones establecidas actualmente es el nmero de conexiones TCP para los cuales el estado actual es ESTABLISHED o CLOSE-WAIT. ",

    "645",     "Conexiones activas es el nmero de veces que las conexiones TCP han realizado una transicin directa al estado SYN-SENT desde el estado CLOSED. ",

    "647",     "Conexiones pasivas es el nmero de veces que las conexiones TCP han realizado una transicin directa al estado SYN-RCVD desde el estado LISTEN. ",

    "649",     "Errores de conexin es el nmero de veces que las conexiones TCP han realizado una transicin directa al estado CLOSED desde el estado SYN-SENT o desde SYN-RCVD, sumado al nmero de veces que las conexiones TCP han realizado una transicin directa al estado LISTEN desde el estado SYN- RCVD.",

    "651",     "Conexiones de reinicializacin es el nmero de veces que las conexiones TCP han realizado una transicin directa al estado CLOSED desde el estado ESTABLISHED o desde el estado CLOSED-WAIT. ",

    "653",     "Segmentos recibidos por segundo es la frecuencia con que se han recibido segmentos, incluyendo los errneos. Esta cuenta indica los segmentos recibidos en las conexiones establecidas actualmente. ",

    "655",     "Segmentos enviados por segundo es la frecuencia con que se han enviado segmentos, incluyendo los de las conexiones actuales pero excluyendo los que contienen nicamente bytes retransmitidos. ",

    "657",     "Segmentos retransmitidos por segundo es la frecuencia con que se han retransmitido segmentos, es decir, segmentos transmitidos que contenan uno o ms bytes transmitidos con anterioridad. ",

    "659",     "El tipo de objeto UDP incluye los contadores que describen las frecuencias con que una determinada entidad enva y recibe datagramas UDP utilizando el protocolo UDP. Indica asimismo diversos recuentos de errores del protocolo UDP. ",

    "661",     "Datagramas por segundo es la frecuencia con que la entidad enva o recibe datagramas UDP. ",

    "663",     "Datagramas recibidos por segundo es la frecuencia con que los datagramas UDP son entregados a los usuarios de UDP. ",

    "665",     "Datagramas sin puerto por segundo es la frecuencia con que se han recibido datagramas UDP para los cuales no exista ninguna aplicacin en el puerto de destino. ",

    "667",     "Datagramas recibidos con errores es el nmero de datagramas UDP recibidos que no han podido ser entregados por motivos distintos de la falta de una aplicacin en el puerto de destino. ",

    "669",     "Datagramas enviados por segundo es la frecuencia con que se han enviado datagramas UDP desde la entidad. ",

    "671",     "Estadsticas del dispositivo de almacenamiento en disco procedentes del equipo remoto. ",

    "673",     "Nmero de errores de asignacin comunicados por el dispositivo de almacenamiento en disco",

    "675",     "Tiempo total (en segundos) en que el equipo ha estado operativo desde la ltima vez que se inici. ",

    "677",     "Nmero actual de identificadores (handles) del sistema que se estn utilizando. ",

    "679",     "Entradas libres de la tabla de pginas del sistema es el nmero de entradas de la tabla de pginas que no estn siendo utilizadas actualmente por el sistema. Este contador muestra slo en ltimo valor observado. No es un promedio. ",

    "681",     "Nmero de subprocesos que se encuentran activos actualmente en este proceso. La unidad bsica de ejecucin en un procesador es una instruccin; un subproceso es el objeto que ejecuta instrucciones. Todo proceso en ejecucin tiene al menos un subproceso. ",

    "683",     "Prioridad base actual de este proceso. Los subprocesos de un proceso pueden aumentar o disminuir su propia prioridad base relativa a la del proceso. ",

    "685",     "El tiempo total, en segundos, que este proceso ha estado ejecutndose.",

    "687",     "Correcciones de alineacin/s. es la frecuencia, de incidentes por segundo, de los errores de alineacin que fueron corregidos por el sistema.",

    "689",     "Excepciones despachadas/s. es la frecuencia, de incidentes por segundo, a la cual las excepciones fueron despachadas por el sistema.",

    "691",     "Emulaciones de punto flotante/s. es la frecuencia de operaciones de punto flotante emuladas por el sistema.",

    "693",     "Inicios de sesin/s. es la frecuencia de inicios de sesin en todos los servidores.",

    "695",     "Prioridad dinmica actual de este subproceso. El sistema puede aumentar la prioridad dinmica del subproceso por encima de la prioridad base si el subproceso manipula entradas de usuario, o disminuirla si el subproceso pasa a realizar clculo de datos. ",

    "697",     "Prioridad base actual de este subproceso.  El sistema puede aumentar la prioridad dinmica del subproceso por encima de la prioridad base si el subproceso manipula entradas de usuario, o disminuirla si el subproceso pasa a realizar clculo de datos. ",

    "699",     "Tiempo total (en segundos) transcurrido en que este subproceso ha estado en ejecucin. ",

    "701",     "Muestra informacin sobre el archivo o archivos de paginacin del sistema. ",

    "703",     "El porcentaje de archivos de paginacin que estn siendo utilizados. Para ms informacin consulte Proceso\\ Bytes del archivo de paginacin.",

    "705",     "El porcentaje de Uso mximo del archivo de paginacin seleccionado. Para ms informacin consulte Proceso\\Uso mximo de bytes del archivo de paginacin.",

    "707",     "Direccin virtual de inicio para este subproceso. ",

    "709",     "Contador de programa del usuario actual para este subproceso. ",

    "711",     "El espacio asignado es la memoria virtual que ha sido asignada en una determinada direccin virtual (o rango de direcciones virtuales) del espacio de direcciones virtual del proceso. La proteccin Sin acceso (No Access) impide que un proceso pueda escribir o leer en estas pginas, y generar un error de violacin de acceso si se intenta realizar alguna de estas operaciones. ",

    "713",     "El espacio asignado es la memoria virtual que ha sido asignada en una determinada direccin virtual (o rango de direcciones virtuales) del espacio de direcciones virtual del proceso. La proteccin Slo lectura (Read Only) impide la modificacin del contenido de estas pginas. Cualquier intento de escribir o modificar estas pginas generar un error de violacin de acceso. ",

    "715",     "El espacio asignado es la memoria virtual que ha sido asignada en una determinada direccin virtual (o rango de direcciones virtuales) del espacio de direcciones virtual del proceso. La proteccin Lectura/escritura (Read/Write) permite a un proceso leer, modificar y escribir en estas pginas. ",

    "717",     "Espacio asignado es la memoria virtual que ha sido asignada en una determinada direccin virtual (o rango de direcciones virtuales) del espacio de direcciones virtual del proceso. La proteccin Escritura en copia (Write Copy) se utiliza cuando la memoria est siendo compartida para lectura pero no para escritura. Cuando los procesos estn leyendo esta memoria, podrn compartirla pero, cuando un proceso que est compartindola intente realizar un acceso de escritura a esta memoria compartida, se crear una copia de la misma. ",

    "719",     "Espacio asignado es la memoria virtual que ha sido asignada en una determinada direccin virtual (o rango de direcciones virtuales) del espacio de direcciones virtual del proceso. La memoria de Ejecucin es la memoria que puede ser ejecutada por programas pero no puede ser leda o escrita. Este tipo de proteccin no est disponible en todos los tipos de procesadores. ",

    "721",     "Espacio asignado es la memoria virtual que ha sido asignada en una determinada direccin virtual (o rango de direcciones virtuales) del espacio de direcciones virtual del proceso. La memoria de Ejecucin y slo lectura (Execute/Read Only) es aquella memoria que puede ser ejecutada al igual que leda. ",

    "723",     "Espacio asignado es la memoria virtual que ha sido asignada en una determinada direccin virtual (o rango de direcciones virtuales) del espacio de direcciones virtual del proceso. La memoria de Ejecucin y lectura/escritura (Execute/Read/Write) es aquella memoria que puede ser ejecutada por programas, al igual que leda y modificada. ",

    "725",     "Espacio asignado es la memoria virtual que ha sido asignada en una determinada direccin virtual (o rango de direcciones virtuales) del espacio de direcciones virtual del proceso. La memoria de Ejecucin y escritura en copia (Execute Write Copy) es aquella memoria que puede ser ejecutada por programas, al igual que leda y escrita. Este tipo de proteccin se utiliza cuando se necesita compartir la memoria entre varios procesos. Si los procesos comparten la memoria nicamente para leerla, todos ellos utilizarn la misma memoria. Sin embargo, si uno de los procesos que la comparten desea tener acceso a ella para escritura, se crear una copia de esta memoria a tal efecto. ",

    "727",     "Espacio reservado es la memoria virtual que ha sido reservada para su utilizacin futura por parte de un proceso, pero que an no ha sido asignada ni comprometida. La proteccin Sin acceso (No Access) impide que un proceso escriba o lea en estas pginas, y provocar un error de violacin de acceso si se intenta realizar alguna de estas dos operaciones. ",

    "729",     "Espacio reservado es la memoria virtual que ha sido reservada para su utilizacin futura por parte de un proceso, pero que an no ha sido asignada ni comprometida. La proteccin Slo lectura (Read Only) impide la modificacin del contenido de estas pginas. Cualquier intento de escribir o modificar estas pginas generar un error de violacin de acceso. ",

    "731",     "Espacio reservado es la memoria virtual que ha sido reservada para su utilizacin futura por parte de un proceso, pero que no ha sido asignada ni comprometida. La proteccin de Lectura/Escritura (Read/Write) permite a un proceso leer, modificar y escribir en estas pginas. ",

    "733",     "Espacio reservado es la memoria virtual que ha sido reservada para su utilizacin futura por parte de un proceso, pero que an no ha sido asignada ni comprometida. La proteccin Escritura en copia (Write Copy) se utiliza cuando la memoria est siendo compartida para lectura pero no para escritura. Cuando los procesos estn leyendo esta memoria, podrn compartirla pero, cuando un proceso que est compartindola intente realizar un acceso de lectura/escritura a esta memoria compartida, se crear una copia de la misma. ",

    "735",     "Espacio reservado es la memoria virtual que ha sido reservada para su utilizacin futura por parte de un proceso, pero que no ha sido asignada ni comprometida. La memoria de Ejecucin es la memoria que puede ser ejecutada por programas pero no leda o escrita. Este tipo de proteccin no est disponible en todos los tipos de procesadores. ",

    "737",     "Espacio reservado es la memoria virtual que ha sido reservada para su utilizacin futura por parte de un proceso, pero que an no ha sido asignada ni comprometida. La memoria de Ejecucin y slo lectura (Execute/Read Only) es aquella memoria que puede ser ejecutada por programas al igual que leda. ",

    "739",     "Espacio reservado es la memoria virtual que ha sido reservada para su utilizacin futura por parte de un proceso, pero que an no ha sido asignada ni comprometida. La memoria de Ejecucin y lectura/escritura (Execute/Read/Write) es aquella memoria que puede ser ejecutada por programas, al igual que leda y modificada. ",

    "741",     "El tipo de objeto Imagen muestra informacin sobre la utilizacin de direcciones virtuales de las imgenes que estn siendo ejecutadas por un proceso en el equipo. ",

    "743",     "Espacio reservado es la memoria virtual que ha sido reservada para su utilizacin futura por parte de un proceso, pero que an no ha sido asignada ni comprometida. La memoria de Ejecucin y escritura en copia (Execute Write Copy) es aquella memoria que puede ser ejecutada por programas, al igual que leda y escrita. Este tipo de proteccin se utiliza cuando se necesita compartir la memoria entre varios procesos. Si los procesos comparten la memoria nicamente para leerla, todos ellos utilizarn la misma memoria. Sin embargo, si uno de los procesos que la comparten desea tener acceso a ella para escritura, se crear una copia de esta memoria a tal efecto. ",

    "745",     "Espacio no asignado es la memoria virtual asignada y comprometida que est siendo utilizada por el proceso, y que no es atribuible a ninguna imagen concreta que est siendo ejecutada por el mismo. La proteccin Sin acceso (No Access) impide que un proceso pueda escribir o leer en estas pginas, y generar un error de violacin de acceso si se intenta realizar alguna de estas operaciones. ",

    "747",     "Espacio no asignado es la memoria virtual asignada y comprometida que est siendo utilizada por el proceso, y que no es atribuible a ninguna imagen concreta que est siendo ejecutada por el mismo. La proteccin Slo lectura (Read Only) impide la modificacin del contenido de estas pginas. Cualquier intento de escribir o modificar en estas pginas generar un error de violacin de acceso. ",

    "749",     "Espacio no asignado es la memoria virtual asignada y comprometida que est siendo utilizada por el proceso, y que no es atribuible a ninguna imagen concreta que est siendo ejecutada por el mismo. La proteccin de Lectura/Escritura (Read/Write) permite a un proceso leer, modificar y escribir en estas pginas. ",

    "751",     "Espacio no asignado es la memoria virtual asignada y comprometida que est siendo utilizada por el proceso, y que no es atribuible a ninguna imagen concreta que est siendo ejecutada por el mismo. La proteccin Escritura en copia (Write Copy) se utiliza cuando la memoria est siendo compartida para lectura pero no para escritura. Cuando los procesos estn leyendo esta memoria, podrn compartirla pero, cuando un proceso que est compartindola intente realizar un acceso de lectura/escritura a esta memoria compartida, se crear una copia de la misma para realizar la escritura. ",

    "753",     "Espacio no asignado es la memoria virtual asignada y comprometida que est siendo utilizada por el proceso, y que no es atribuible a ninguna imagen concreta que est siendo ejecutada por el mismo. La memoria de Ejecucin es la memoria que puede ser ejecutada por programas pero no leda o escrita. Este tipo de proteccin no est disponible en todos los tipos de procesadores. ",

    "755",     "Espacio no asignado es la memoria virtual asignada y comprometida que est siendo utilizada por el proceso, y que no es atribuible a ninguna imagen concreta que est siendo ejecutada por el mismo. La memoria de Ejecucin y slo lectura (Execute/Read Only) es aquella memoria que puede ser ejecutada al igual que leda. ",

    "757",     "Espacio no asignado es la memoria virtual asignada y comprometida que est siendo utilizada por el proceso, y que no es atribuible a ninguna imagen concreta que est siendo ejecutada por el mismo. La memoria de Ejecucin y lectura/escritura (Execute/Read/Write) es aquella memoria que puede ser ejecutada por programas, al igual que leda y escrita. ",

    "759",     "Espacio no asignado es la memoria virtual asignada y comprometida que est siendo utilizada por el proceso, y que no es atribuible a ninguna imagen concreta que est siendo ejecutada por el mismo. La memoria de Ejecucin y escritura en copia (Execute Write Copy) es aquella memoria que puede ser ejecutada por programas, al igual que leda y escrita. Este tipo de proteccin se utiliza cuando se necesita compartir la memoria entre varios procesos. Si los procesos comparten la memoria nicamente para leerla, todos ellos utilizarn la misma memoria. Sin embargo, si uno de los procesos que la comparten desea tener acceso a ella para escritura, se crear una copia de esta memoria a tal efecto.",

    "761",     "Espacio de imagen es el espacio de direcciones virtual que est siendo utilizado por las imgenes ejecutadas por el proceso. Este valor es la suma de todos los espacios de direcciones a los cuales las imgenes ejecutadas por el proceso seleccionado han asignado esta proteccin. La proteccin Sin acceso (No Access) impide que un proceso pueda leer o escribir en estas pginas, y provocar un error de violacin de acceso si se intenta realizar alguna de estas dos operaciones. ",

    "763",     "Espacio de imagen es el espacio de direcciones virtual que est siendo utilizado por las imgenes ejecutadas por el proceso. Este valor es la suma de todos los espacios de direcciones a los cuales las imgenes ejecutadas por el proceso seleccionado han asignado esta proteccin. La proteccin de Slo lectura (Read Only) impide la modificacin del contenido de estas pginas. Cualquier intento de escribir o modificar ests pginas generar un error de violacin de acceso. ",

    "765",     "Espacio de imagen es el espacio de direcciones virtual que est siendo utilizado por las imgenes ejecutadas por el proceso. Este valor es la suma de todos los espacios de direcciones a los cuales las imgenes ejecutadas por el proceso seleccionado han asignado esta proteccin. La proteccin de Lectura/Escritura (Read/Write) permite a un proceso leer, modificar y escribir en estas pginas. ",

    "767",     "Espacio de imagen es el espacio de direcciones virtual que est siendo utilizado por las imgenes ejecutadas por el proceso. Este valor es la suma de todos los espacios de direcciones a los cuales las imgenes ejecutadas por el proceso seleccionado han asignado esta proteccin. La proteccin Escritura en copia (Write Copy) se utiliza cuando la memoria est siendo compartida para lectura pero no para escritura. Cuando los procesos estn leyendo esta memoria, podrn compartirla pero, cuando un proceso que est compartindola intente realizar un acceso de lectura/escritura a esta memoria compartida, se crear una copia de la misma para realizar la escritura. ",

    "769",     "Espacio de imagen es el espacio de direcciones virtual que est siendo utilizado por las imgenes ejecutadas por el proceso. Este valor es la suma de todos los espacios de direcciones a los cuales las imgenes ejecutadas por el proceso seleccionado han asignado esta proteccin. La memoria de Ejecucin es la memoria que puede ser ejecutada por programas al igual que leda o escrita. Este tipo de proteccin no est disponible en todos los tipos de procesadores. ",

    "771",     "Espacio de imagen es el espacio de direcciones virtual que est siendo utilizado por las imgenes ejecutadas por el proceso. Este valor es la suma de todos los espacios de direcciones a los cuales las imgenes ejecutadas por el proceso seleccionado han asignado esta proteccin. La memoria de Ejecucin y slo lectura (Execute/Read Only) es aquella memoria que puede ser ejecutada por programas al igual que leda. ",

    "773",     "Espacio de imagen es el espacio de direcciones virtual que est siendo utilizado por las imgenes ejecutadas por el proceso. Este valor es la suma de todos los espacios de direcciones a los cuales las imgenes ejecutadas por el proceso seleccionado han asignado esta proteccin. La memoria de Ejecucin y lectura/escritura (Execute/Read/Write) es aquella memoria que puede ser ejecutada por programas al igual que leda, escrita y modificada. ",

    "775",     "Espacio de imagen es el espacio de direcciones virtual que est siendo utilizado por las imgenes ejecutadas por el proceso. Este valor es la suma de todos los espacios de direcciones a los cuales las imgenes ejecutadas por el proceso seleccionado han asignado esta proteccin. La memoria de Ejecucin y escritura en copia (Execute Write Copy) es aquella memoria que puede ser ejecutada por programas, al igual que leda y escrita. Este tipo de proteccin se utiliza cuando se necesita compartir la memoria entre varios procesos. Si los procesos comparten la memoria nicamente para leerla, todos ellos utilizarn la misma memoria. Sin embargo, si uno de los procesos que la comparten desea tener acceso a ella para escritura, se crear una copia de esta memoria a tal efecto. ",

    "777",     "Bytes de imagen reservados es la suma de toda la memoria virtual reservada por las imgenes en este proceso.",

    "779",     "Bytes de imagen libres es la cantidad de espacio de direcciones virtuales que no est siendo utilizado ni reservado por las imgenes de este proceso. ",

    "781",     "Bytes reservados es la cantidad total de memoria virtual reservada para su utilizacin futura por parte de este proceso. ",

    "783",     "Bytes libres es el espacio de direcciones virtuales total no utilizado de este proceso. ",

    "785",     "ID de proceso es el identificador exclusivo de este proceso. Hay que tener en cuenta que los nmeros de identificacin de proceso son reutilizados, as slo identifican a un proceso durante el tiempo de duracin del mismo. ",

    "787",     "El tipo de objeto Espacio de direcciones del proceso muestra los detalles sobre la utilizacin de la memoria virtual y la asignacin del proceso seleccionado. ",

    "789",     "Espacio de imagen es el espacio de direcciones virtuales que est siendo utilizado por la imagen seleccionada con esta proteccin. La proteccin Sin acceso (No Access) impide que un proceso pueda leer o escribir estas pginas, y provocar un error de violacin de accesos si se intenta realizar una de estas dos operaciones. ",

    "791",     "Espacio de imagen es el espacio de direcciones virtuales que est siendo utilizado por la imagen seleccionada con esta proteccin. La proteccin Slo lectura impide la modificacin del contenido de estas pginas. Cualquier intento de escribir o modificar estas pginas generar un error de violacin de acceso. ",

    "793",     "Espacio de imagen es el espacio de direcciones virtuales que est siendo utilizado por la imagen seleccionada con esta proteccin. La proteccin de Lectura/Escritura (Read/Write) permite a un proceso leer, modificar y escribir en estas pginas. ",

    "795",     "Espacio de imagen es el espacio de direcciones virtuales que est siendo utilizado por la imagen seleccionada con esta proteccin. La proteccin Escritura en copia (Write Copy) se utiliza cuando la memoria est siendo compartida para lectura pero no para escritura. Cuando los procesos estn leyendo esta memoria, podrn compartirla pero, cuando un proceso que est compartindola intente realizar un acceso de lectura/escritura a esta memoria compartida, se crear una copia de la misma para realizar la escritura. ",

    "797",     "Espacio de imagen es el espacio de direcciones virtuales que est siendo utilizado por la imagen seleccionada con esta proteccin. La memoria de Ejecucin es la memoria que puede ser ejecutada por programas pero no para lectura ni escritura. Este tipo de proteccin no est disponible en todos los tipos de procesadores. ",

    "799",     "Espacio de imagen es el espacio de direcciones virtuales que est siendo utilizado por la imagen seleccionada con esta proteccin. La memoria de Ejecucin y slo lectura (Execute/Read Only) es aquella memoria que puede ser ejecutada al igual que leda. ",

    "801",     "Espacio de imagen es el espacio de direcciones virtuales que est siendo utilizado por la imagen seleccionada con esta proteccin. La memoria de Ejecucin y lectura/escritura (Execute/Read/Write) es aquella memoria que puede ser ejecutada por programas, al igual que leda y escrita. ",

    "803",     "Espacio de imagen es el espacio de direcciones virtuales que est siendo utilizado por la imagen seleccionada con esta proteccin. La memoria de Ejecucin y escritura en copia (Execute Write Copy) es aquella memoria que puede ser ejecutada por programas, al igual que leda y escrita. Este tipo de proteccin se utiliza cuando se necesita compartir la memoria entre varios procesos. Si los procesos comparten la memoria nicamente para leerla, todos ellos utilizarn la misma memoria. Sin embargo, si uno de los procesos que la comparten desea tener acceso a ella para escritura, se crear una copia de esta memoria a tal efecto.",

    "805",     "El Identificador de subproceso es el identificador exclusivo de este subproceso. Los nmeros de identificador de subproceso son reutilizados y slo identifican a un subproceso mientras existe. ",

    "807",     "Aperturas de buzn de correo fallidas/s. indica la velocidad a la que los mensajes para ser enviados a buzones que no estn presentes son recibidos por esta estacin de trabajo.",

    "809",     "Anuncios de maestro duplicado indica la cantidad de veces que el examinador maestro ha detectado otro examinador maestro en el mismo dominio.",

    "811",     "Datagramas no vlidos/s. es la velocidad a la que los datagramas de formato incorrecto se han recibido a travs de esta estacin de trabajo.",

    "813",     "Total de anuncios/s. es la suma de los anuncios de servidor/s. ms los anuncios de dominio.",

    "815",     "Total de enumeraciones/seg. es la velocidad a la peticiones del buscador se han procesado por esta estacin de trabajo.  Esta es la suma de Enumeraciones de servidor/seg, Enumeraciones de Dominio/seg, y Otras Enumeraciones/seg.",

    "817",     "Objeto Detalles de subproceso contiene los contadores de subproceso cuya presentacin requiere tiempo. ",

    "819",     "Bytes de cach es la suma de los contadores de la Memoria\\Bytes residentes en la cach del sistema, Memoria\\Bytes residentes en el controlador del sistema, Memoria\\Bytes residentes en el cdigo del sistema y Memoria\\Bytes residentes en el conjunto paginado. Este contador muestra slo el ltimo valor observado. No es un promedio. ",

    "821",     "Uso mximo de los Bytes de cach es el nmero mximo de los bytes usados por la cach de sistema de archivos desde la ltima vez que se reinici el sistema. Este puede ser mayor que el tamao actual de la cach. Este contador muestra slo el ltimo valor observado. No es un promedio. ",

    "823",     "Entrada de pginas/seg. es la frecuencia a la cual se leen las pginas desde el disco para resolver errores de pgina severos. Los errores de pgina severos se producen cuando un proceso hace referencia a una pgina en la memoria virtual que no est en su conjunto de trabajo o en cualquier sitio de la memoria fsica, y debe recuperarse desde el disco. Cuando una pgina es errnea, el sistema intenta leer pginas continuas mltiples en la memoria para maximizar el beneficio de la operacin de lectura. Comparar el valor de Memoria\\Entradas de pginas/seg. para el valor de la Memoria\\Lectura de pgina/seg. para determinar el nmero promedio de pginas ledas en la memoria durante cada operacin de lectura.",

    "825",     "Pginas de transicin redirigidas es el nmero de pginas de cach de transicin que se reutilizaron para un propsito diferente. De lo contrario, estas pginas se habran mantenido en la cach de pginas para proporcionar un error flexible (rpido), en vez de recuperarlo del almacn de respaldo, en el caso de que se tuviera acceso a la pgina en el futuro. Tenga presente que estas pginas pueden contener memoria privada o compartida.",

    "871",     "El tipo de objetos RAS maneja los puertos de dispositivos RAS en su sistema.",

    "873",     "La cantidad total de bytes transmitidos por esta conexin.",

    "875",     "La cantidad total de bytes recibidos por esta conexin.",

    "877",     "La cantidad total de tramas transmitidas por esta conexin.",

    "879",     "La cantidad total de tramas recibidas por esta conexin.",

    "881",     "El factor de compresin de los que se estn enviando.",

    "883",     "El factor de compresin de los datos que se estn recibiendo.",

    "885",     "La cantidad total de errores de CRC para esta conexin. Un error de CRC ocurre cuando se recibe una trama daada.",

    "887",     "La cantidad total de expiraciones de tiempo de espera para esta  conexin.  Un error de expiracin de tiempo de espera ocurre cuando se est esperando que llegue una trama y esto no ocurre",

    "889",     "Cantidad total de desbordamiento serial para esta conexin. Un desbordamiento serial ocurre cuando el hardware no puede procesar los datos a la velocidad que estos le llegan.",

    "891",     "Cantidad total de errores de alineamiento para esta conexin.  Un error de alineamiento ocurre cuando se recibe un byte que no es el esperado.",

    "893",     "La cantidad total de desbordamiento de bferes para esta conexin.  Un error de desbordamiento de bfer ocurre cuando el software no  puede trabajar a la frecuencia con que los datos son recibidos.",

    "895",     "La cantidad total de errores de CRC, expiraciones de tiempo de espera, desbordamiento serial, alineacin y desbordamiento de bferes en esta conexin.",

    "897",     "La cantidad de bytes transmitidos por segundo.",

    "899",     "La cantidad de bytes recibidos por segundo.",

    "901",     "La cantidad de tramas transmitidas por segundo.",

    "903",     "La cantidad de tramas recibidas por segundo.",

    "905",     "La cantidad total de errores de CRC, expiraciones de tiempo de espera, desbordamiento serial, alineacin y desbordamiento de bferes por segundo.",

    "907",     "El tipo de objetos RAS gestiona todos los puertos combinados de los dispositivos RAS en el sistema.",

    "909",     "La cantidad total de conexiones remotas.",

    "921",     "El tipo de objeto Servidor WINS incluye todos los contadores especficos del servidor WINS.",

    "923",     "Registros individuales/s. es la frecuencia con que el servidor WINS recibe las registros individuales.",

    "925",     "Registros de grupo/s. es la frecuencia con el servidor WINS recibe las registros de grupo.",

    "927",     "Cantidad de registros/s. es la suma de registros individuales y de grupos por segundos.  Esta es la frecuencia  total con que las registros son recibidas por el servidor WINS.",

    "929",     "Renovaciones individuales/s. es la frecuencia con que el servidor WINS recibe las renovaciones individuales.",

    "931",     "Renovaciones de grupo/s. es la frecuencia con que el servidor WINS recibe las renovaciones de grupos.",

    "933",     "Cantidad total de renovaciones/s. es la suma de las renovaciones  individuales y de grupo por segundo.  Esta es la frecuencia  total con que el servidor WINS recibe las renovaciones.",

    "935",     "Cantidad total de liberaciones/s. es la frecuencia con que el servidor de WINS recibe liberaciones.",

    "937",     "Cantidad total de consultas/s. es la frecuencia con que el servidor WINS recibe consultas.",

    "939",     "Conflictos individuales/s. es la frecuencia con que el servidor WINS recibe renovaciones de registros individuales que resultan en conflictos con registros en la base de datos.",

    "941",     "Conflictos de grupo/s. es la frecuencia con que el servidor WINS recibe renovaciones de registros de grupos que resultan en conflictos con registros en la base de datos.",

    "943",     "Cantidad total de conflictos/s. es la suma de los conflictos  individuales mas los conflictos de grupos que recibe el servidor WINS. Esta es la frecuencia total con que ocurren conflictos en el servidor WINS. ",

    "945",     "Cantidad total de liberaciones correctas/s.",

    "947",     "Cantidad total de liberaciones fallidas/s.",

    "949",     "Cantidad total de consultas correctas/s.",

    "951",     "Cantidad total de consultas fallidas/s.",

    "953",     "La cantidad total de manipuladores abiertos por este proceso. Este nmero es igual a la suma de los manipuladores actualmente abiertos por cada subproceso en este proceso.",

    "1001",     "Servidor de archivos AFP de Servicios par Macintosh.",

    "1003",     "Cantidad mxima de recursos de memoria paginada utilizados por el servidor Macfile.",

    "1005",     "La cantidad actual de recursos de memoria paginada utilizada por el servidor MacFile.",

    "1007",     "Cantidad mxima de recursos de memoria no paginada utilizados por el servidor MacFile.",

    "1009",     "Cantidad actual de recursos de memoria no paginada utilizados por el servidor MacFile.",

    "1011",     "La cantidad de sesiones actualmente conectadas al servidor  MacFile.  Indica la actividad actual del servidor.",

    "1013",     "La cantidad mxima de sesiones conectadas simultneamente al servidor MacFile.  Indica el nivel de uso del servidor.",

    "1015",     "Cantidad de archivos internos abiertos en este instante en el servidor MacFile. Esta cantidad no incluye los archivos abiertos por los clientes Macintosh.",

    "1017",     "La cantidad mxima de archivos abiertos simultneamente en el  servidor MacFile.  Esta cuenta no incluye archivos abiertos por  los clientes Macintosh.",

    "1019",     "La cantidad de intentos de inicio de sesin fallidos en el servidor Macfile.  Puede indicar que se estn utilizando programas que tratan de encontrar contraseas.",

    "1021",     "La cantidad de bytes ledos de disco por segundo.",

    "1023",     "La cantidad de bytes grabados al disco por segundo.",

    "1025",     "La cantidad de bytes recibidos desde la red por segundo. Indica el nivel de uso del servidor.",

    "1027",     "La cantidad de bytes enviados por la red por segundo. Indica  el nivel de uso del servidor.",

    "1029",     "La cantidad de trabajos que esperan para ser procesados .",

    "1031",     "La cantidad mxima de trabajos esperando simultneamente para ser procesados.",

    "1033",     "La cantidad actual de subprocesos utilizados por el servidor MacFile. Indica el nivel de uso del servidor.",

    "1035",     "La cantidad mxima de subprocesos utilizados por MacFile Indica niveles mximos de uso del servidor.",

    "1051",     "Protocolo AppleTalk",

    "1053",     "Cantidad de paquetes recibidos por segundo por  Appletalk en este puerto.",

    "1055",     "Cantidad de paquetes enviados por segundo por Appletalk en este puerto.",

    "1057",     "Cantidad de bytes recibidos por segundo por Appletalk en este puerto.",

    "1059",     "Cantidad de bytes enviados por segundo por Appletalk en este puerto.",

    "1061",     "Tiempo promedio en milisegundos para procesar un paquete DDP en este puerto.",

    "1063",     "Cantidad de paquetes por segundo recibidos por Appletalk en este puerto.",

    "1065",     "Tiempo promedio en milisegundos para procesar un paquete AARP en este puerto.",

    "1067",     "Cantidad de paquetes AARP recibidos por Appletalk en este puerto.",

    "1069",     "Tiempo promedio en milisegundos para procesar un paquete ATP en este puerto.",

    "1071",     "Cantidad de paquetes ATP por segundo recibidos por Appletalk en este puerto.",

    "1073",     "Tiempo promedio en milisegundos para procesar un paquete NBP en este puerto.",

    "1075",     "Cantidad de paquetes NBP por segundo recibido por Appletalk en este puerto.",

    "1077",     "Tiempo promedio en milisegundos para procesar un paquete ZIP en este puerto.",

    "1079",     "Cantidad de paquetes ZIP por segundo recibidos por recibidos por Appletalk en este puerto.",

    "1081",     "Tiempo promedio en milisegundos para procesar un paquete RTMP en este puerto.",

    "1083",     "Cantidad de paquetes RTMP por segundo recibidos por Appletalk en esta puerto.",

    "1085",     "Cantidad de peticiones ATP retransmitidas por segundo en este puerto.",

    "1087",     "Cantidad de temporizadores de liberacin ATP que han expirado en este puerto.",

    "1089",     "Cantidad de respuestas a transacciones ATP (exactamente una vez) por segundo en este puerto.",

    "1091",     "Cantidad de respuestas a transacciones ATP (por lo menos una vez) por segundo en este puerto.",

    "1093",     "Cantidad de paquetes de liberacin de transacciones ATP recibidos por segundo en este puerto.",

    "1095",     "La cantidad actual de recursos de memoria no paginada usados por AppleTalk.",

    "1097",     "Cantidad de paquetes encaminados como salida en este puerto.",

    "1099",     "Cantidad de paquetes descartados en este puerto debido a limitaciones de recursos en este puerto. ",

    "1101",     "Cantidad de peticiones de ATP retransmitidas por este puerto.",

    "1103",     "Cantidad de paquetes encaminados como entrada en este puerto.",

    "1111",     "Suministra estadsticas de red para el segmento de red local a travs del Servicio de supervisin de red.",

    "1113",     "Nmero total de tramas recibidas por segundo en este segmento de red.",

    "1115",     "Nmero de bytes recibidos por segundo en este segmento de red.",

    "1117",     "Nmero de tramas de difusin recibidas por segundo en este segmento de red.",

    "1119",     "Nmero de tramas de multidifusin recibidas por segundo en este segmento de red.",

    "1121",     "Porcentaje de ancho de banda de red usado en este segmento de red.",

    "1125",     "Porcentaje de ancho de banda que representa el trfico de difusin en este segmento de red.",

    "1127",     "Porcentaje de ancho de banda que representa el trfico de multidifusin en este segmento de red.",

    "1151",     "El sistema de telefona",

    "1153",     "El nmero de lneas telefnicas atendidas por en este equipo.",

    "1155",     "El nmero de dispositivos telefnicos atendidos por en este equipo.",

    "1157",     "El nmero de lneas telefnicas atendidas por en este equipo que estn abiertas actualmente.",

    "1159",     "El nmero de dispositivos telefnicos que estn siendo monitorizados actualmente.",

    "1161",     "La frecuencia de llamadas efectuadas por este equipo.",

    "1163",     "La frecuencia de llamadas contestadas por este equipo.",

    "1165",     "El nmero de programas que actualmente estn utilizando servicios de telefona.",

    "1167",     "Llamadas telefnicas de salida actualmente atendidas por este equipo.",

    "1169",     "Llamadas telefnicas de entrada actualmente atendidas por este equipo.",

    "1229",     "Objeto de tipo Servicio de puerta de enlace para NetWare.",

    "1231",     "Objeto de tipo Servicio de cliente para NetWare.",

    "1233",     "Cantidad de Packet Burst Read NCP/s. es la frecuencia con que el protocolo de ncleo de Netware solicita lectura Packet Burst. Packet Burst es un protocolo de ventana que mejora el rendimiento.",

    "1235",     "Caducidades de tiempo de espera de lectura Packet Burst/s. es la frecuencia con que Servicio compatible con NetWare tiene que retransmitir una peticin de lectura Burst porque el servidor Netware tard demasiado en responder",

    "1237",     "Cantidad de escrituras Packet Burst NCP/s. es la frecuencia con que el protocolo de ncleo de Netware (NCP) solicita escritura Packet Burst. Packet Burst es un protocolo de ventana que mejora el rendimiento.",

    "1239",     "Caducidades de tiempo de espera para escritura Packet Burst/s. es la frecuencia con que Servicio compatible con NetWare tiene que retransmitir una peticin de escritura Burst porque el servidor Netware tard demasiado en responder",

    "1241",     "Packet Burst ES/s. es la suma de lecturas Packet Burst NCPs/s. y escrituras Packet Burst NCPs/s.",

    "1243",     "Conexiones NetWare 2.x cuenta las conexiones a los servidores NetWare 2.x.",

    "1245",     "Conexiones NetWare 3.x cuenta las conexiones a los servidores NetWare 3.x.",

    "1247",     "Conexiones NetWare 4.x cuenta las conexiones a los servidores NetWare 4.x.",

    "1261",     "Total de inicios de sesin es el total de inicios de sesin interactivos, de red de servicio, con xito y fallidos.",

    "1301",     "El objeto de rendimiento de Colas de trabajo del servidor consiste en contadores que manejan la longitud de las colas y objetos en las colas.",

    "1303",     "Longitud de cola es la longitud actual de la cola de trabajo del servidor para esta CPU. Una longitud de cola que de manera constante es superior a cuatro puede indicar congestin del procesador. ste es un clculo instantneo, no un promedio realizado a lo largo de un perodo de tiempo.",

    "1305",     "Instancias activas de ejecucin es el nmero de ellas que estn trabajando en peticiones desde el cliente servidor para esta CPU. El sistema mantiene este nmero tan bajo como sea posible para minimizar conmutaciones de contexto innecesarias. Esta es una cifra instantnea, no un promedio a lo largo del tiempo.",

    "1307",     "Instancias de ejecucin disponibles es el nmero de instancias  del servidor en esta CPU que no estn actualmente trabajando sobre peticiones de clientes. El servidor ajusta dinmicamente el nmero de instancias para maximizar el rendimiento del servidor.",

    "1309",     "Cada peticin de un cliente se representa en este servidor como un 'elemento de trabajo'; el servidor mantiene un cupo de elementos de trabajo disponibles por CPU para agilizar el procesamiento. Este es el nmero instantneo de elementos de trabajo disponibles para esta CPU. Un valor sostenido cercano a cero indica la necesidad de aumentar el valor MinFreeWorkItems del registro para el servicio de Servidor. Este valor ser siempre 0 en la instancia de bloqueo de cola.",

    "1311",     "Cada peticin de un cliente se representa en este servidor como un 'elemento de trabajo'; el servidor mantiene un cupo de elementos de trabajo disponibles por CPU para agilizar el procesamiento. Cuando una CPU se queda sin elementos de trabajo, toma prestado un elemento de trabajo libre de otra CPU. Un valor sostenido mayor que cero indica la necesidad de aumentar 'MaxWorkItems' o 'MinWorkItems' en el registro para el servicio Servidor. Este valor ser siempre 0 en la instancia de bloqueo de cola.",

    "1313",     "Cada peticin de un cliente se representa en este servidor como un 'elemento de trabajo'; el servidor mantiene un cupo de elementos de trabajo disponibles por CPU para agilizar el procesamiento. Este es el nmero instantneo de elementos de trabajo para esta CPU. Un valor sostenido mayor que cero indica la necesidad de aumentar el valor MaxWorkItems del registro para el servicio Servidor. Este valor ser siempre 0 en la instancia de bloqueo de cola.",

    "1315",     "Clientes actuales es el nmero de clientes atendidos por esta CPU. El servidor equilibra automticamente la carga del cliente entre todas las CPUs del sistema.  Este valor ser siempre 0 en la instancia de bloqueo de cola.",

    "1317",     "La velocidad a la que el servidor est recibiendo bytes de los clientes de red en esta CPU. Este valor da idea de lo ocupado que est el servidor",

    "1319",     "La velocidad a la que el servidor est enviando bytes a los clientes de red desde esta CPU. Este valor da idea de lo ocupado que est el servidor",

    "1321",     "La velocidad a la que el servidor est enviando y recibiendo bytes desde los clientes de red en esta CPU. Este valor da idea de lo ocupado que est el servidor.",

    "1323",     "Operaciones de lectura/s. es la velocidad a la que el servidor est realizando operaciones de lectura en archivos para los clientes en esta CPU. Este valor da idea de lo ocupado que est el servidor. Este valor ser siempre 0 en la instancia de bloqueo de cola.",

    "1325",     "Bytes ledos/s. es la velocidad a la que el servidor est leyendo datos en archivos para los clientes de esta CPU. Este valor da idea de lo ocupado que est el servidor.",

    "1327",     "Operaciones de escritura/s. es la velocidad a la que el servidor est realizando operaciones de escritura en archivos para los clientes en esta CPU. Este valor da idea de lo ocupado que est el servidor. Este valor ser siempre 0 en la instancia de bloqueo de cola.",

    "1329",     "Bytes escritos/s. es la velocidad a la que el servidor est escribiendo datos en archivos para los clientes de esta CPU. Este valor da idea de lo ocupado que est el servidor.",

    "1331",     "Bytes totales/s. es la velocidad a la que el servidor est leyendo y escribiendo bytes a/desde los clientes de red en esta CPU. Este valor da idea de lo ocupado que est el servidor.",

    "1333",     "Total de operaciones/s. es la velocidad a la que el servidor         est realizando operaciones de lectura y escritura en archivos para los clientes en esta CPU. Este valor da idea de lo ocupado que est el servidor. Este valor ser siempre 0 en la instancia de bloqueo de cola.",

    "1335",     "DPC en cola/seg es la frecuencia media, de incidentes por segundo, a la cual se agregan llamadas a procedimiento diferidas (DPC) a la cola de llamadas DPC del procesador.  Las DPC son interrupciones que se ejecutan con prioridad ms bajas que las interrupciones estndar. Cada procesador tiene su propia cola de DPC. Este contador mide la velocidad a la que las llamadas DPC se agregan a la cola, no el nmero de llamadas DPC en la cola. Este contador muestra la diferencia entre los valores observados en las dos muestras anteriores, dividida entre la duracin del intervalo de muestreo. ",

    "1337",     "La velocidad DPC es la velocidad a la que se agregan las llamadas a procedimientos diferidos (DPC) a las colas de DPC del procesador entre los tics del reloj del procesador.  DPC son interrupciones que se ejecutan con prioridades ms bajas que las interrupciones estndar. Cada procesador tiene su propia cola de DPC. Este contador mide la velocidad a la que se agregan las DPC a la cola, no es el nmero de DPC en la cola. Este contador muestra slo el ltimo valor observado. No es un promedio.",

    "1343",     "Total DPCs en cola/s. es la frecuencia con que los objetos DPC son puestos en las colas DPC de todos los procesadores.",

    "1345",     "Total DPC frecuencia es el valor promedio de la frecuencia con que los objetos DPC son puestos en las colas DPC de todos los procesadores por cada pulso de reloj.",

    "1351",     "El % de Cuota de Registro en uso es el porcentaje de la Cuota de Registro total permitida que el sistema est usando actualmente. Este contador nicamente muestra el porcentaje actual; no es un promedio.",

    "1361",     "Contadores que indican el estado de las asignaciones de memoria Muy grande locales y de sistema.",

    "1363",     "% de tamao virtual VLM utilizado",

    "1365",     "Tamao actual de la memoria virtual VLM de proceso en bytes.",

    "1367",     "Tamao mximo del espacio de memoria virtual VLM de proceso en bytes. Este valor indica el tamao mximo de la memoria virtual VLM de proceso desde que se inicio el proceso.",

    "1369",     "El tamao actual del espacio de memoria virtual VLM de proceso en bytes que puede ser asignado. Observe que la asignacin mxima permitida puede ser ms pequea que este valor debido a la fragmentacin del espacio de memoria.",

    "1371",     "El tamao actual del espacio de memoria VLM comprometida para el proceso actual en bytes.",

    "1373",     "Tamao mximo del espacio de memoria VLM comprometida en bytes para el proceso actual desde que se inici dicho proceso.",

    "1375",     "Tamao actual de todo el espacio de memoria VLM comprometida en bytes para el sistema.",

    "1377",     "Tamao mximo del espacio de memoria VLM comprometida en bytes desde que se inici el sistema.",

    "1379",     "El tamao actual del espacio de memoria VLM compartida comprometida en bytes para el sistema.",

    "1381",     "Los KBytes disponibles muestran el tamao, en kilobytes, de la memoria fsica inmediatamente disponible para su asignacin a un proceso o para uso del sistema. Equivale a la suma de la memoria asignada a las listas de pginas En espera (en cach), Libre y Cero. Para ver una explicacin completa del administrador de memoria, consulte MSDN o el captulo correspondiente de la Gua de rendimiento del sistema y solucin de problemas del Kit de recursos de Windows Server 2003.",

    "1383",     "Los MBytes disponibles muestran el tamao, en megabytes, de la memoria fsica inmediatamente disponible para su asignacin a un proceso o para uso del sistema. Equivale a la suma de la memoria asignada a las listas de pginas En espera (en cach), Libre y Cero. Para ver una explicacin completa del administrador de memoria, consulte MSDN o el captulo correspondiente de la Gua de rendimiento del sistema y solucin de problemas del Kit de recursos de Windows Server 2003.",

    "1401",     "Longitud promedio de longitud de cola de disco es el valor promedio de la cantidad de peticiones de lectura y escritura que han sido puestas en cola para el disco durante el intervalo de la muestra.",

    "1403",     "Longitud promedio de longitud de cola de lectura de disco es el valor promedio de la cantidad de peticiones de lectura que han sido puestas en cola para el disco durante el intervalo de la muestra.",

    "1405",     "Longitud promedio de longitud de cola de escritura de disco es el valor promedio de la cantidad de peticiones de lectura que han sido puestas en cola para el disco durante el intervalo de la muestra.",

    "1407",     "% de bytes confirmados en uso es la proporcin de Memoria\\Bytes confirmados a la memoria\\Lmite confirmado. La memoria confirmada es al memoria fsica en uso para la cual se ha reservado espacio en el archivo de paginacin en caso en el que se necesite escribirlo en el disco. El lmite de confirmacin est determinado por el tamao del archivo de paginacin. Si se amplia el archivo de paginacin, el lmite de confirmacin se amplia y la proporcin se reduce. Este contador muestra solamente el porcentaje actual del valor. No es un promedio.",

    "1409",     "El objeto de rendimiento Imagen completa consiste en unos contadores que supervisan la direccin virtual usada por las imgenes ejecutadas por los procesos en el equipo. Los contadores de Imagen completa son los mismos que los contenidos en el objeto Imagen con la nica diferencia del nombre de instancia. En el objeto Imagen completa, el nombre de instancia incluye el nombre completo de la ruta de acceso a los mdulos cargados, mientras que en el objeto Imagen, slo se muestra el nombre de archivo.",

    "1411",     "El valor Id. de proceso de creacin es el Id. de proceso que ha creado el proceso. Los procesos de creacin pueden haber terminado, por tanto, el valor puede no ser ya identificativo de un proceso en ejecucin.",

    "1413",     "La frecuencia a la que el proceso est realizando operaciones de E/S de lectura. Este contador rene toda la actividad de E/S generada por el proceso para incluir E/S de dispositivo, red y archivos.",

    "1415",     "La frecuencia a la que el proceso est realizando operaciones de E/S de escritura. Este contador rene toda la actividad de E/S generada por el proceso para incluir E/S de dispositivo, red y archivos.",

    "1417",     "La frecuencia a la que el proceso est realizando operaciones de E/S de escritura y de lectura. Este contador rene toda la actividad de E/S generada por el proceso para incluir E/S de dispositivo, red y archivos.",

    "1419",     "La frecuencia a la que el proceso est realizando operaciones de E/S que no son de escritura ni de lectura (por ejemplo, una funcin de control). Este contador rene toda la actividad de E/S generada por el proceso para incluir E/S de dispositivo, red y archivos.",

    "1421",     "La frecuencia a la que el proceso est leyendo bytes a partir de operaciones de E/S. Este contador rene toda la actividad de E/S generada por el proceso para incluir E/S de dispositivo, red y archivos.",

    "1423",     "La frecuencia a la que el proceso est escribiendo bytes en operaciones de E/S. Este contador rene toda la actividad de E/S generada por el proceso para incluir E/S de dispositivo, red y archivos.",

    "1425",     "La frecuencia a la que el proceso est leyendo y escribiendo bytes en operaciones de E/S. Este contador rene toda la actividad de E/S generada por el proceso para incluir E/S de dispositivo, red y archivos.",

    "1427",     "La frecuencia a la que el proceso est emitiendo bytes a operaciones de que no requieren datos, como por ejemplo operaciones de control. Este contador rene toda la actividad de E/S generada por el proceso para incluir E/S de dispositivo, red y archivos.",

    "1451",     "Muestra estadsticas de rendimiento sobre una cola de impresin.",

    "1453",     "Nmero total de trabajos imprimidos en una cola de impresin desde el ltimo reinicio.",

    "1455",     "Nmero de bytes por segundo imprimidos en una cola de impresin.",

    "1457",     "Nmero total de pginas impresas a graves de GDI en una cola de impresin desde el ltimo reinicio.",

    "1459",     "Nmero actual de trabajos en una cola de impresin.",

    "1461",     "Nmero actual de referencias a una cola de impresin.",

    "1463",     "Nmero mximo de referencias a una cola de impresin desde el ltimo reinicio.",

    "1465",     "Nmero actual de trabajos en la cola de impresin.",

    "1467",     "Nmero mximo de trabajos en la cola de impresin desde el ltimo reinicio.",

    "1469",     "Nmero total de errores ",

    "1471",     "Nmero total de errores ",

    "1473",     "Nmero total de errores de trabajo en una cola de impresin desde el ltimo reinicio.",

    "1475",     "Nmero total de llamadas desde Examinar clientes a este servidor de impresin para solicitar listas de examen de red desde el ltimo reinicio.",

    "1477",     "Nmero total de llamadas desde otros servidores de impresin para agregar impresoras de red compartidas a este servidor desde el ltimo reinicio.",

    "1479",     "Conjunto de trabajo - privado muestra el tamao del conjunto de trabajo, en bytes, que se utiliza slo para este proceso y que no est compartido o no se puede compartir por otros procesos.",

    "1481",     "Conjunto de trabajo - compartido muestra el tamao del grupo de trabajo, en bytes, que se puede compartir y que puede ser utilizado por otros procesos. Ya que una parte de un grupo de trabajo de procesos se puede compartir, no quiere decir necesariamente que otros procesos lo estn utilizando.",

    "1483",     "% de tiempo inactivo informa del porcentaje de tiempo durante el intervalo de muestra en el que el disco estaba inactivo.",

    "1485",     "N de E/S divididas/s informa de la frecuencia  a la que las E/S en el disco fueron divididas en mltiples E/S mltiples. Una E/S dividida puede originarse a partir de peticiones de datos de un tamao que es demasiado grande para adaptarse a una E/S nica o que el disco est fragmentado.",

    "1501",     "Informa de los datos de uso de procesador y de cuentas recopilados por cada objeto de trabajo nombrado y activo.",

    "1503",     "% actual de tiempo de procesador muestra el porcentaje de intervalo de muestra que el proceso en el objeto de trabajo tarda en ejecutar cdigo.",

    "1505",     "% actual de tiempo en modo de usuario muestra el porcentaje de intervalo de intervalo de muestra que los procesos en el objeto de trabajo tardan en ejecutar cdigo en modo de usuario.",

    "1507",     "% actual de tiempo en modo de ncleo muestra el porcentaje de intervalo de intervalo de muestra que los procesos en el objeto de trabajo tardan en ejecutar cdigo en modo privilegiado o de ncleo.",

    "1509",     "Este periodo en milisegundos - procesador muestra el tiempo en milisegundos de tiempo de procesador utilizado por todos los procesos en el objeto de trabajo, incluyendo aqullos que han finalizado o que ya no estn asociados con el objeto de trabajo, desde que se estableci un lmite temporal en el trabajo.",

    "1511",     "Este periodo en milisegundos - usuario muestra el tiempo en milisegundos de tiempo de procesador en modo de usuario utilizado por todos los procesos en el objeto de trabajo, incluyendo aqullos que han finalizado o que ya no estn asociados con el objeto de trabajo, desde que se estableci un lmite temporal en el trabajo.",

    "1513",     "Este periodo en milisegundos - modo de ncleo muestra el tiempo en milisegundos de tiempo de procesador en modo de ncleo utilizado por todos los procesos en el objeto de trabajo, incluyendo aqullos que han finalizado o que ya no estn asociados con el objeto de trabajo, desde que se estableci un lmite temporal en el trabajo.",

    "1515",     "Pginas/s muestra la frecuencia de errores de pgina de todos los procesos en el objeto de trabajo.",

    "1517",     "Nmero de procesos  totales muestra el nmero de procesos, activos y finalizados, que estn o que han sido asociados con el objeto de trabajo.",

    "1519",     "Nmero de procesos  activos muestra el nmero de procesos, activos y finalizados, que estn asociados actualmente con el objeto de trabajo.",

    "1521",     "Nmero de procesos finalizados muestra el nmero de procesos que han terminado debido a una infraccin de lmite.",

    "1523",     "Nmero total de milisegundos - procesador muestra el tiempo en milisegundos de tiempo de procesador utilizado por todos los procesos en el objeto de trabajo, incluyendo aqullos que han finalizado o que ya no estn asociados con el objeto de trabajo, desde que se cre el objeto.",

    "1525",     "Nmero total de milisegundos - procesador muestra el tiempo en milisegundos de tiempo de procesador en modo de usuario utilizado por todos los procesos en el objeto de trabajo, incluyendo aqullos que han finalizado o que ya no estn asociados con el objeto de trabajo, desde que se cre el objeto de trabajo.",

    "1527",     "Nmero total de milisegundos - modo de ncleo muestra el tiempo en milisegundos de tiempo de procesador en modo de ncleo utilizado por todos los procesos en el objeto de trabajo, incluyendo aqullos que han finalizado o que ya no estn asociados con el objeto de trabajo, desde que se cre el objeto de trabajo.",

    "1549",     "% de detalles de objetos de trabajo muestra informacin de rendimiento detallada acerca de los procesos activos que forman un objeto de trabajo.",

    "1537",     "Paquetes demasiado grandes recibidos es el nmero de paquetes recibidos que son mayores de lo previsto.",

    "1539",     "Consultas de pertenencia recibidas es el nmero de paquetes recibidos que consultan su pertenencia a un grupo.",

    "1541",     "Informes de pertenencia recibidos es el nmero de paquetes recibidos que informan de su pertenencia a un grupo.",

    "1543",     "Reduccin de pertenencias recibidas es el nmero de paquetes recibidos que han cancelado su pertenencia a un grupo.",

    "1545",     "Solicitudes de enrutador recibidas es el nmero de paquetes recibidos que solicitan el enrutador.",

    "1547",     "Anuncios de enrutador recibidos es el nmero de paquetes recibidos que anuncian el enrutador.",

    "1551",     "Solicitudes de vecino recibidas es el nmero de paquetes recibidos que solicitan un vecino.",

    "1553",     "Anuncios de vecino recibidos es el nmero de paquetes recibidos que anuncian un vecino.",

    "1555",     "Paquetes demasiado grandes enviados es el nmero de paquetes enviados que son mayores de lo previsto.",

    "1557",     "Consultas de pertenencia enviadas es el nmero de paquetes enviados que consultan su pertenencia a un grupo.",

    "1559",     "Informes de pertenencia enviados es el nmero de paquetes enviados que informan de su pertenencia a un grupo.",

    "1561",     "Reduccin de pertenencias enviadas es el nmero de paquetes enviados que han cancelado su pertenencia a un grupo.",

    "1563",     "Solicitudes de enrutador enviadas es el nmero de paquetes enviados que solicitan el enrutador.",

    "1565",     "Anuncios de enrutador enviados es el nmero de paquetes enviados que anuncian el enrutador.",

    "1567",     "Solicitudes de vecino enviadas es el nmero de paquetes enviados que solicitan un vecino.",

    "1569",     "Anuncios de vecino enviados es el nmero de paquetes enviados que anuncian un vecino.",

    "1747",     "% de tiempo inactivo es el porcentaje de tiempo durante el que el procesador est inactivo durante el intervalo de ejemplo",

    "1749",     "Tiempo % C1 es el porcentaje de tiempo que el procesador invierte en el estado inactivo de energa baja C1. Tiempo % C1 es un subconjunto del total de tiempo del procesador inactivo. Estado inactivo de energa baja C1 habilita el procesador para mantener su contexto total y volver rpidamente al estado de ejecucin. No todos los sistemas son compatible con el estado % C1.",

    "1751",     "Tiempo % C2 es el porcentaje de tiempo que el procesador invierte en el estado inactivo de energa baja C2. Tiempo % C2 es un subconjunto del total de tiempo del procesador inactivo. Estado inactivo de energa baja C1 habilita el procesador para mantener su contexto de cachs de sistema. El estado de poder C2 es una energa baja y un estado de latencia de salida ms alta que C1. No todos los sistemas son compatibles con el estado C2.",

    "1753",     "Tiempo % C3  es el porcentaje de tiempo que el procesador invierte en el estado inactivo de energa baja C3. Tiempo % C3 es un subconjunto del total de tiempo del procesador inactivo. Cuando el procesador est en estado inactivo de baja energa C3, no es capaz de mantener la coherencia de sus cachs. El estado de poder C3 es una energa baja y un estado de latencia de salida ms alta que C2. No todos los sistemas son compatibles con el estado C3.",

    "1755",     "Transiciones C1/seg es la velocidad en la que la CPU entra en el estado inactivo de baja energa C1. La CPU entra en el estado C1 cuando est suficientemente inactivo y existe este estado en cualquier interrupcin. Este contador muestra la diferencia entre los valores observados en los dos ltimos ejemplos, divididos por la duracin del intervalo de ejemplo.",

    "1757",     "Transiciones C2/seg es la velocidad en la que la CPU entra en el estado inactivo de baja energa C2. La CPU entra en el estado C2 cuando est suficientemente inactivo y existe este estado en cualquier interrupcin. Este contador muestra la diferencia entre los valores observados en los dos ltimos ejemplos, divididos por la duracin del intervalo de ejemplo.",

    "1759",     "Transiciones C3/seg es la velocidad en la que la CPU entra en el estado inactivo de baja energa C3. La CPU entra en el estado C3 cuando est suficientemente inactivo y existe este estado en cualquier interrupcin. Este contador muestra la diferencia entre los valores observados en los dos ltimos ejemplos, divididos por la duracin del intervalo de ejemplo.",

    "1761",     "Contadores de rendimiento de montn para los montones ms usados",

    "1763",     "Memoria usada activamente por este montn (bytes libres + bytes asignados)",

    "1765",     "Espacio total de direccin virtual reservado para este montn (incluye rangos no comprometidos)",

    "1767",     "Bytes reservados menos el ltimo rango comprometido en cada segmento",

    "1769",     "Memoria en la lista de liberaciones de este montn (no incluye rangos no comprometidos o bloques en cach de montn)",

    "1771",     "Nmero de bloques en la lista de bloques libres de tamao mayor que 1K",

    "1773",     "1/tiempo promedio de asignacin (excluyendo asignaciones de la cach de montn)",

    "1775",     "1/tiempo promedio de liberacin (excluyendo liberaciones al cach de montn)",

    "1777",     "Nmero de rangos no comprometidos en la direccin virtual reservada",

    "1779",     "Diferencia entre el nmero de asignaciones y liberaciones (para detectar prdidas)",

    "1781",     "Asignaciones/seg de la cach de montn",

    "1783",     "Liberaciones/seg de la cach de montn",

    "1785",     "Asignaciones/seg de tamao menor que 1KB (incluyendo cach de montn)",

    "1787",     "Liberaciones/seg de tamao menor que 1KB (incluyendo cach de montn)",

    "1789",     "Asignaciones/seg de tamao entre 1 y 8 KB",

    "1791",     "Liberaciones/seg de tamao entre 1 y 8KB",

    "1793",     "Ubicaciones/sec de tamao mayor de 8KB ",

    "1795",     "Liberaciones/sec de tamao mayor de 8KB",

    "1797",     "Asignaciones/seg (incluyendo cach de montn)",

    "1799",     "Liberaciones/seg (incluyendo cach de montn)",

    "1801",     "Nmero total de bloques en la cach de montn ",

    "1803",     "La cantidad ms grande de bloques de cualquier tamao en cach del montn",

    "1805",     "(Bytes libres / bytes comprometidos) *100",

    "1807",     "(Bytes virtuales / bytes reservados) * 100",

    "1809",     "Colisiones/seg en el bloqueo de montn",

    "1847",     "Marcador de final",
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\heb\perfh00d.ini ===
[info]
drivername=ContentIndex
symbolfile=perfci.h

[objects]
CIOBJECT_009_NAME=Indexing Service

[languages]
009=English
000=Neutral

[text]
CIOBJECT_009_NAME=Indexing Service
CIOBJECT_009_HELP=Indexing Service

NUM_WORDLIST_009_NAME=Word lists
NUM_WORDLIST_009_HELP=Number of word lists.

NUM_PERSISTENT_INDEX_009_NAME=Saved indexes
NUM_PERSISTENT_INDEX_009_HELP=Number of saved indexes.

INDEX_SIZE_009_NAME=Index size (MB)
INDEX_SIZE_009_HELP=Size of the content index (*.ci files only) in megabytes.

FILES_TO_BE_FILTERED_009_NAME=Files to be indexed
FILES_TO_BE_FILTERED_009_HELP=Number of files to be filtered and added to the index.

DEFERRED_FILTER_FILES_009_NAME=Deferred for indexing
DEFERRED_FILTER_FILES_009_HELP=Number of files not available and deferred for indexing.

NUM_UNIQUE_KEY_009_NAME=Unique keys
NUM_UNIQUE_KEY_009_HELP=Number of unique keys (words, etc.) in the index.

RUNNING_QUERIES_009_NAME=Running queries
RUNNING_QUERIES_009_HELP=Number of active query client connections.

MERGE_PROGRESS_009_NAME=Merge progress
MERGE_PROGRESS_009_HELP=Percent merge complete for the current merge.

DOCUMENTS_FILTERED_009_NAME=# documents indexed
DOCUMENTS_FILTERED_009_HELP=Number of documents indexed since the index was mounted.

NUM_DOCUMENTS_009_NAME=Total # documents
NUM_DOCUMENTS_009_HELP=Total number of documents in the index.

TOTAL_QUERIES_009_NAME=Total # of queries
TOTAL_QUERIES_009_HELP=Total number of queries since the index was mounted.

CIOBJECT_000_NAME=Indexing Service
CIOBJECT_000_HELP=Indexing Service

NUM_WORDLIST_000_NAME=Word lists
NUM_WORDLIST_000_HELP=Number of word lists.

NUM_PERSISTENT_INDEX_000_NAME=Saved indexes
NUM_PERSISTENT_INDEX_000_HELP=Number of saved indexes.

INDEX_SIZE_000_NAME=Index size (MB)
INDEX_SIZE_000_HELP=Size of the content index (*.ci files only) in megabytes.

FILES_TO_BE_FILTERED_000_NAME=Files to be indexed
FILES_TO_BE_FILTERED_000_HELP=Number of files to be filtered and added to the index.

DEFERRED_FILTER_FILES_000_NAME=Deferred for indexing
DEFERRED_FILTER_FILES_000_HELP=Number of files not available and deferred for indexing.

NUM_UNIQUE_KEY_000_NAME=Unique keys
NUM_UNIQUE_KEY_000_HELP=Number of unique keys (words, etc.) in the index.

RUNNING_QUERIES_000_NAME=Running queries
RUNNING_QUERIES_000_HELP=Number of active query client connections.

MERGE_PROGRESS_000_NAME=Merge progress
MERGE_PROGRESS_000_HELP=Percent merge complete for the current merge (if any).

DOCUMENTS_FILTERED_000_NAME=# documents indexed
DOCUMENTS_FILTERED_000_HELP=Number of documents indexed since the index was mounted.

NUM_DOCUMENTS_000_NAME=Total # documents
NUM_DOCUMENTS_000_HELP=Total number of documents in index.

TOTAL_QUERIES_000_NAME=Total # of queries
TOTAL_QUERIES_000_HELP=Total number of queries since the index was mounted.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\es\perfc00a.ini ===
"1",     "1847",

    "2",     "Sistema",

    "4",     "Memoria",

    "6",     "% de tiempo de procesador",

    "10",     "Operaciones de lectura de archivo/s.",

    "12",     "Operaciones de escritura de archivo/s.",

    "14",     "Operaciones de control de archivos /s.",

    "16",     "Bytes de lectura de archivo/s.",

    "18",     "Bytes de escritura de archivo/s.",

    "20",     "Bytes de control de archivos /s.",

    "24",     "Bytes disponibles",

    "26",     "Bytes comprometidos",

    "28",     "Errores de pgina/s.",

    "30",     "Lmite comprometido",

    "32",     "Copias de escritura/s.",

    "34",     "Errores de transicin/s.",

    "36",     "Errores de cach/s.",

    "38",     "Errores de peticin de cero/s.",

    "40",     "Pginas/s",

    "42",     "Lecturas de pgina/s",

    "44",     "Longitud de la cola del procesador",

    "46",     "Estado de subproceso",

    "48",     "Pginas de salida/s.",

    "50",     "Escrituras de pgina/s.",

    "52",     "Explorador",

    "54",     "Anuncios de servidor/s.",

    "56",     "Bytes de bloque paginado",

    "58",     "Bytes de bloque no paginado",

    "60",     "Asignaciones de bloque paginado",

    "64",     "Asignaciones de bloque no paginado",

    "66",     "Bytes residentes de bloque paginado",

    "68",     "Total de bytes de cdigo del sistema",

    "70",     "Bytes residentes de cdigo del sistema",

    "72",     "Total de bytes de controladores del sistema",

    "74",     "Bytes residentes de controladores del sistema",

    "76",     "Bytes residentes de cach del sistema",

    "78",     "Anuncios de dominio/s.",

    "80",     "Paquetes de eleccin/s.",

    "82",     "Escrituras de correo/s.",

    "84",     "Peticiones de lista de servidores/s.",

    "86",     "Cach",

    "88",     "Mapas de datos/s.",

    "90",     "Mapas de datos sncronos/s.",

    "92",     "Mapas de datos asncronos/s.",

    "94",     "% de aciertos en mapas de datos",

    "96",     "Mapas de datos fijaciones/s.",

    "98",     "Lecturas de fijaciones/s.",

    "100",     "Lecturas sincrnicas de fijaciones/s.",

    "102",     "Lecturas asincrnicas de fijaciones/s.",

    "104",     "% Aciertos de lecturas de fijacin",

    "106",     "Lecturas de copia/s.",

    "108",     "Lecturas sincrnicas de copia/s.",

    "110",     "Lecturas asincrnicas de copia/s.",

    "112",     "% Aciertos de lecturas de copia",

    "114",     "Lecturas mediante MDL/s.",

    "116",     "Lecturas sincrnicas mediante MDL/s.",

    "118",     "Lecturas asincrnicas mediante MDL/s.",

    "120",     "% Aciertos de lecturas mediante MDL",

    "122",     "Lecturas anticipadas/s.",

    "124",     "Lecturas rpidas/s.",

    "126",     "Lecturas sincrnicas rpidas/s.",

    "128",     "Lecturas asincrnicas rpidas/s.",

    "130",     "Errores de recursos de lecturas rpidas/s. ",

    "132",     "Lecturas rpidas no posibles/s.",

    "134",     "Vaciados de escritura lenta/s.",

    "136",     "Pginas de escritura lenta/s.",

    "138",     "Vaciados de datos/s.",

    "140",     "Pginas de vaciado de datos/s.",

    "142",     "% de tiempo de usuario",

    "144",     "% Tiempo privilegiado",

    "146",     "Cambios de s.",

    "148",     "Interrupciones/s.",

    "150",     "Llamadas del s.",

    "152",     "Cargas de TLB de nivel 1/seg",

    "154",     "Cargas de TLB de nivel 2/seg",

    "156",     "Enumeraciones de servidor/s.",

    "158",     "Enumeraciones de dominio/s.",

    "160",     "Enumeraciones de otros/s.",

    "162",     "Anuncios de servidor perdidos",

    "164",     "Datagramas de correo perdidos",

    "166",     "Peticiones de lista de servidores perdidas",

    "168",     "Ubicaciones de anuncio de servidor fallidas/s.",

    "170",     "Ubicaciones de correo fallidas",

    "172",     "Uso mximo de espacio virtual",

    "174",     "Bytes del espacio virtual",

    "178",     "Uso mximo del espacio de trabajo",

    "180",     "Espacio de trabajo",

    "182",     "Uso mximo de los bytes del archivo de pginas",

    "184",     "Bytes del archivo de pginas",

    "186",     "Bytes privados",

    "188",     "Total de anuncios/s.",

    "190",     "Total de enumeraciones/s.",

    "198",     "Longitud actual de la cola de disco",

    "200",     "% Tiempo de disco",

    "202",     "% Tiempo de lectura de disco",

    "204",     "% Tiempo de escritura en disco",

    "206",     "Media en segundos/transferencia",

    "208",     "Media en segundos/lectura",

    "210",     "Media en segundos/escritura",

    "212",     "Transferencias de s.",

    "214",     "Lecturas de s.",

    "216",     "Escrituras en s.",

    "218",     "Bytes de s.",

    "220",     "Bytes ledos de s.",

    "222",     "Bytes escritos en s.",

    "224",     "Media de bytes/transferencia",

    "226",     "Media de bytes/lectura",

    "228",     "Media de bytes/escritura",

    "230",     "Proceso",

    "232",     "Subproceso o subproceso",

    "234",     "DiscoFsico",

    "236",     "DiscoLgico",

    "238",     "Procesador",

    "240",     "% Tiempo total de procesador",

    "242",     "% Tiempo total de usuario",

    "244",     "% Tiempo privilegiado total",

    "246",     "Interrupciones totales/s.",

    "248",     "Procesos",

    "250",     "Subproceso o subproceso",

    "252",     "Sucesos",

    "254",     "Semforos",

    "256",     "Exclusiones mutuas",

    "258",     "Secciones",

    "260",     "Objetos",

    "262",     "Redirector",

    "264",     "Bytes recibidos/s.",

    "266",     "Paquetes recibidos/s.",

    "268",     "Bytes de paginacin s.",

    "270",     "Bytes de no paginacin s.",

    "272",     "Bytes ledos de s.",

    "274",     "Bytes ledos de la s.",

    "276",     "Bytes transmitidos/s.",

    "278",     "Paquetes transmitidos/s.",

    "280",     "Bytes de paginacin escritos/s.",

    "282",     "Bytes no de paginacin escritos/s.",

    "284",     "Bytes escritos en la s.",

    "286",     "Bytes escritos en la s.",

    "288",     "Operaciones de lectura/s.",

    "290",     "Operaciones de lectura s.",

    "292",     "Paquetes/s.",

    "294",     "Lecturas/s.",

    "296",     "Paquetes pequeos/s.",

    "298",     "Operaciones de escritura/s.",

    "300",     "Operaciones de escritura/s.",

    "302",     "Paquetes de escritura/s.",

    "304",     "Escrituras/s.",

    "306",     "Paquetes de escritura/s.",

    "308",     "Lecturas/s.",

    "310",     "Escrituras/s.",

    "312",     "Errores de red/s.",

    "314",     "Sesiones del servidor",

    "316",     "Reconexiones del servidor",

    "318",     "Conexiones de ncleo",

    "320",     "Conexiones Lanman 2.0",

    "322",     "Conexiones Lanman 2.1",

    "324",     "Conexiones Windows NT",

    "326",     "Desconexiones del servidor",

    "328",     "Sesiones suspendidas del servidor",

    "330",     "Servidor",

    "336",     "Razn de espera del subproceso",

    "340",     "Sesiones cuyo tiempo de espera ha terminado",

    "342",     "Sesiones cerradas debido a un error",

    "344",     "Sesiones cerradas",

    "346",     "Sesiones cerradas forzadamente",

    "348",     "Errores de inicio de sesin",

    "350",     "Errores de permiso de acceso",

    "352",     "Errores de acceso concedido",

    "354",     "Errores del sistema",

    "356",     "Peticiones de bloqueo rechazadas",

    "358",     "Carencias de elementos de trabajo",

    "360",     "Total de archivos abiertos",

    "362",     "Archivos abiertos",

    "366",     "Bsquedas de directorio de archivo",

    "370",     "Errores de memoria no paginada",

    "372",     "Uso mximo de la memoria no paginada",

    "376",     "Errores de memoria paginada",

    "378",     "Uso mximo de la memoria paginada",

    "388",     "Total de bytes/s.",

    "392",     "Comandos actuales",

    "398",     "NetBIOS de NWLink",

    "400",     "Paquetes/s.",

    "404",     "Bloques de contexto en cola/s.",

    "406",     "Operaciones con datos de archivo /s.",

    "408",     "% de espacio libre",

    "410",     "Megabytes libres",

    "412",     "Conexiones abiertas",

    "414",     "Conexiones sin reintentos",

    "416",     "Conexiones con reintentos",

    "418",     "Desconexiones locales",

    "420",     "Desconexiones remotas",

    "422",     "Errores de vinculacin",

    "424",     "Errores en el adaptador",

    "426",     "Finalizaciones de tiempo de espera de sesin",

    "428",     "Conexiones canceladas",

    "430",     "Errores de recursos remotos",

    "432",     "Errores de recursos locales",

    "434",     "Errores no encontrados",

    "436",     "Errores no escuchados",

    "438",     "Datagramas/s.",

    "440",     "Bytes de datagrama/s.",

    "442",     "Datagramas enviados/s.",

    "444",     "Bytes de datagrama enviados/s.",

    "446",     "Datagramas recibidos/s.",

    "448",     "Bytes de datagrama recibidos/s.",

    "452",     "Paquetes enviados/s.",

    "456",     "Tramas/s.",

    "458",     "Bytes de trama/s.",

    "460",     "Tramas enviadas/s.",

    "462",     "Bytes de trama enviados/s.",

    "464",     "Tramas recibidas/s.",

    "466",     "Bytes de trama recibidos/s.",

    "468",     "Tramas reenviadas/s.",

    "470",     "Bytes de trama reenviados/s.",

    "472",     "Tramas rechazadas/s.",

    "474",     "Bytes de trama rechazados/s.",

    "476",     "Vencimientos de respuesta",

    "478",     "Vencimientos de confirmacin",

    "480",     "Ventana de transmisin mxima",

    "482",     "Ventana de transmisin media",

    "484",     "Superposicin de confirmaciones en cola/s.",

    "486",     "Terminaciones de tiempo de espera de confirmaciones superpuestas",

    "488",     "IPX de NWLink",

    "490",     "SPX de NWLink",

    "492",     "NetBEUI",

    "494",     "Recurso NetBEUI",

    "496",     "Uso mximo",

    "498",     "Uso medio",

    "500",     "Recursos agotados",

    "502",     "Conexin NBT",

    "506",     "Bytes enviados/s.",

    "508",     "Bytes totales/s.",

    "510",     "Interfaz de red",

    "512",     "Bytes/s.",

    "520",     "Ancho de banda actual",

    "524",     "Paquetes de monodifusin (Unicast) recibidos/s.",

    "526",     "Paquetes no monodifusin recibidos/s.",

    "528",     "Paquetes recibidos descartados",

    "530",     "Paquetes recibidos con error",

    "532",     "Paquetes recibidos desconocidos",

    "536",     "Paquetes de monodifusin enviados/s.",

    "538",     "Paquetes no monodifusin enviados/s.",

    "540",     "Paquetes de salida descartados",

    "542",     "Paquetes de salida con errores",

    "544",     "Longitud de la cola de salida",

    "546",     "IPv4",

    "548",     "IPv6",

    "552",     "Datagramas recibidos con errores de encabezado",

    "554",     "Datagramas recibidos con errores de direccin",

    "556",     "Datagramas s.",

    "558",     "Datagramas recibidos con protocolo desconocido",

    "560",     "Datagramas recibidos descartados",

    "562",     "Datagramas recibidos s.",

    "566",     "Datagramas de salida descartados",

    "568",     "Datagramas de salida sin enrutamiento",

    "570",     "Fragmentos recibidos/s.",

    "572",     "Fragmentos s.",

    "574",     "Errores de reensamble de fragmentos",

    "576",     "Datagramas s.",

    "578",     "Errores de fragmentacin",

    "580",     "Fragmentos s.",

    "582",     "ICMP",

    "584",     "s.",

    "586",     "Mensajes recibidos/s.",

    "588",     "Mensajes recibidos con error",

    "590",     "Destinos inaccesibles recibidos",

    "592",     "Finalizaciones de tiempo recibidas",

    "594",     "Problemas de parmetros recibidos",

    "596",     "Desconexiones del origen recibidas",

    "598",     "Redirecciones recibidas/s.",

    "600",     "Ecos recibidos/s.",

    "602",     "Respuestas al eco/s.",

    "604",     "Marca de hora recibida/s.",

    "606",     "Respuestas a marca de hora recibidas/s.",

    "608",     "Mscaras de direcciones recibidas",

    "610",     "Respuestas a mscara de direcciones recibidas",

    "612",     "Mensajes enviados/s.",

    "614",     "Mensajes enviados con errores",

    "616",     "Destinos inaccesibles enviados",

    "618",     "Finalizaciones del tiempo enviadas",

    "620",     "Problemas de parmetros enviados",

    "622",     "Desconexiones del origen enviadas",

    "624",     "Redirecciones s.",

    "626",     "Ecos enviados/s.",

    "628",     "Respuestas al eco s.",

    "630",     "Marcas temporales s.",

    "632",     "Respuestas a marca temporal s.",

    "634",     "Mscaras de direcciones enviadas",

    "636",     "Respuestas a mscara de direcciones enviadas",

    "638",     "TCPv4",

    "640",     "Segmentos/s.",

    "642",     "Conexiones establecidas actualmente",

    "644",     "Conexiones activas",

    "646",     "Conexiones pasivas",

    "648",     "Errores de conexin",

    "650",     "Conexiones de reinicializacin",

    "652",     "Segmentos recibidos/s.",

    "654",     "Segmentos enviados/s.",

    "656",     "Segmentos s.",

    "658",     "UDPv4",

    "660",     "% Tiempo total DPC",

    "662",     "% Tiempo total de interrupcin",

    "664",     "Datagramas sin s.",

    "666",     "Datagramas recibidos con errores",

    "670",     "Unidad de almacenamiento en disco",

    "672",     "Errores de asignacin",

    "674",     "Tiempo de actividad del sistema",

    "676",     "Nmero de identificadores del sistema",

    "678",     "Entradas libres de la tabla de pginas del sistema",

    "680",     "Nmero de subprocesos (subprocesos)",

    "682",     "Prioridad base",

    "684",     "Tiempo transcurrido",

    "686",     "Arreglos de alineacin/s.",

    "688",     "Procesamiento de excepciones/s.",

    "690",     "Emulaciones de punto flotante/s.",

    "692",     "Inicios de sesin/s.",

    "694",     "Prioridad actual",

    "696",     "% de tiempo de DPC",

    "698",     "% de tiempo de interrupcin",

    "700",     "Archivo de paginacin",

    "702",     "% Uso",

    "704",     "% Uso mximo",

    "706",     "Direccin de inicio",

    "708",     "Contador de programa del usuario",

    "710",     "Espacio asignado en Sin acceso",

    "712",     "Espacio asignado en  Slo lectura",

    "714",     "Espacio asignado en Modificado",

    "716",     "Espacio asignado en Escritura en copia",

    "718",     "Espacio asignado en Ejecucin",

    "720",     "Espacio asignado en Ejecucin y slo lectura",

    "722",     "Espacio asignado en Ejecucin y Modificado",

    "724",     "Espacio asignado en Ejecucin y escritura en copia",

    "726",     "Espacio reservado en Sin acceso",

    "728",     "Espacio reservado en Slo lectura",

    "730",     "Espacio reservado en Modificado",

    "732",     "Espacio reservado en Escritura en copia",

    "734",     "Espacio reservado en Ejecucin",

    "736",     "Espacio reservado en Ejecucin y slo lectura",

    "738",     "Espacio reservado en Ejecucin y Modificado",

    "740",     "Imagen",

    "742",     "Espacio reservado en Ejecucin y escritura en copia",

    "744",     "Espacio no asignado en Sin acceso",

    "746",     "Espacio no asignado en Slo lectura",

    "748",     "Espacio no asignado en Modificado",

    "750",     "Espacio no asignado en Escritura en copia",

    "752",     "Espacio no asignado en Ejecucin",

    "754",     "Espacio no asignado en Ejecucin y slo lectura",

    "756",     "Espacio no asignado en Ejecucin y Modificado",

    "758",     "Espacio no asignado en Ejecucin y escritura en copia",

    "760",     "Espacio de imagen en Sin acceso",

    "762",     "Espacio de imagen en Slo lectura",

    "764",     "Espacio de imagen en Modificado",

    "766",     "Espacio de imgenes en Escritura y copia",

    "768",     "Espacio de imagen en Ejecucin",

    "770",     "Espacio de imagen en Ejecucin y slo lectura",

    "772",     "Espacio de imagen en Ejecucin y Modificado",

    "774",     "Espacio de imagen en Ejecucin y escritura en copia",

    "776",     "Bytes de imagen reservados",

    "778",     "Bytes de imagen libres",

    "780",     "Bytes reservados",

    "782",     "Bytes libres",

    "784",     "Identificador del proceso",

    "786",     "Espacio de direcciones del proceso",

    "788",     "Sin acceso",

    "790",     "Slo lectura",

    "792",     "Modificado",

    "794",     "Escritura en copia",

    "796",     "Ejecucin",

    "798",     "Ejecucin y slo lectura",

    "800",     "Ejecucin y Modificado",

    "802",     "Ejecucin y escritura en copia",

    "804",     "Identificador de subproceso",

    "806",     "Recepciones de correo fallidas",

    "808",     "Escrituras de correo fallidas",

    "810",     "Aperturas de buzn de correo fallidas/s.",

    "812",     "Anuncios de maestro duplicado",

    "814",     "Datagramas incorrecto/s.",

    "816",     "Detalles de subprocesos",

    "818",     "Bytes de cach",

    "820",     "Uso mximo de los bytes de cach",

    "822",     "Pginas de entrada/s.",

    "824",     "Pginas de transicin redirigidas/s",

    "870",     "Puerto RAS",

    "872",     "Bytes transmitidos",

    "874",     "Bytes recibidos",

    "876",     "Tramas transmitidas",

    "878",     "Tramas recibidas.",

    "880",     "Factor de compresin de salida",

    "882",     "Factor de compresin de entrada",

    "884",     "Errores de CRC",

    "886",     "Errores de caducidad de tiempo de espera",

    "888",     "Errores de desbordamiento serial",

    "890",     "Errores de alineacin",

    "892",     "Errores de desbordamiento de bferes",

    "894",     "Total errores",

    "896",     "Bytes transmitidos/s.",

    "898",     "Bytes recibidos/s.",

    "900",     "Tramas transmitidas/s.",

    "902",     "Tramas recibidas/s.",

    "904",     "Total de errores/s.",

    "906",     "Total RAS",

    "908",     "Total de conexiones",

    "920",     "Servidor WINS",

    "922",     "Registros individuales/s.",

    "924",     "Registros de grupos/s.",

    "926",     "Cantidad total de registros/s.",

    "928",     "Renovaciones/s.",

    "930",     "Renovaciones de grupo/s.",

    "932",     "Cantidad total de renovaciones/s.",

    "934",     "Liberaciones/s.",

    "936",     "Consultas/s.",

    "938",     "Conflictos individuales/s.",

    "940",     "Conflictos de grupos/s.",

    "942",     "Cantidad total de conflictos/s.",

    "944",     "Liberaciones correctas/s.",

    "946",     "Liberaciones fallidas/s.",

    "948",     "Consultas correctas/s.",

    "950",     "Consultas fallidas/s.",

    "952",     "Cantidad de manipuladores",

    "1000",     "Servidor de MacFile",

    "1002",     "Mximo de memoria paginada",

    "1004",     "Memoria paginada actual",

    "1006",     "Mximo de memoria no paginada",

    "1008",     "Memoria no paginada actual",

    "1010",     "Sesiones actuales",

    "1012",     "Mximo de sesiones",

    "1014",     "Archivos abiertos actuales",

    "1016",     "Mximo de archivos abiertos",

    "1018",     "Inicios de sesin fallidos",

    "1020",     "Lecturas de datos/s.",

    "1022",     "Escrituras de datos/s.",

    "1024",     "Datos recibidos/s.",

    "1026",     "Datos transmitidos/s.",

    "1028",     "Longitud de cola actual",

    "1030",     "Longitud mxima de cola",

    "1032",     "Subprocesos actuales",

    "1034",     "Mximo de subprocesos (subprocesos)",

    "1050",     "AppleTalk",

    "1052",     "Paquetes de entrada/s.",

    "1054",     "Paquetes de salida/s.",

    "1056",     "Bytes de entrada/s.",

    "1058",     "Bytes de salida/s.",

    "1060",     "Tiempo promedio paquetes DDP",

    "1062",     "Paquetes DDP/s.",

    "1064",     "Tiempo promedio/paquetes AARP",

    "1066",     "Paquetes AARP/s.",

    "1068",     "Tiempo promedio/paquetes ATP",

    "1070",     "Paquetes ATP/s.",

    "1072",     "Tiempo promedio/paquetes NBP",

    "1074",     "Paquetes NBP/s.",

    "1076",     "Tiempo promedio/paquetes ZIP",

    "1078",     "Paquetes ZIP/s.",

    "1080",     "Tiempo promedio/paquetes RTMP",

    "1082",     "Paquetes RTMP/s.",

    "1084",     "Reintentos locales ATP",

    "1086",     "Caducidades de tiempo de espera de respuestas ATP",

    "1088",     "Respuestas ATP XO/s.",

    "1090",     "Respuestas ATP ALO/s.",

    "1092",     "Liberaciones de ATP recibidas/s.",

    "1094",     "Bloque no paginado actual",

    "1096",     "Paquetes de entrada encaminados/s.",

    "1098",     "Paquetes descartados",

    "1100",     "Reintentos remotos de ATP.",

    "1102",     "Paquetes de salida encaminados/s.",

    "1110",     "Segmento de red",

    "1112",     "Total de tramas recibidas/s.",

    "1114",     "Total de bytes recibidos/s.",

    "1116",     "Tramas de difusin recibidas/s.",

    "1118",     "Tramas de multidifusin recibidas/s.",

    "1120",     "% de uso de red",

    "1124",     "% de tramas de difusin",

    "1126",     "% de tramas de multidifusin",

    "1150",     "Telefona",

    "1152",     "Lneas",

    "1154",     "Dispositivos telefnicos",

    "1156",     "Lneas activas",

    "1158",     "Telfonos activos",

    "1160",     "Llamadas salientes/s.",

    "1162",     "Llamadas entrantes/s.",

    "1164",     "Aplicaciones clientes",

    "1166",     "Llamadas salientes actuales",

    "1168",     "Llamadas entrantes actuales",

    "1228",     "Servicio de puerta de enlace para NetWare",

    "1230",     "Servicio de cliente para NetWare",

    "1232",     "Cantidad de Packet Burst Read NCP/s.",

    "1234",     "Caducidades de tiempo de espera de Packet Burst Read/s.",

    "1236",     "Cantidad de Packet Burst Write NCP/s.",

    "1238",     "Caducidades de tiempo de espera de Packet Burst Read/s.",

    "1240",     "Packet Burst ES/s.",

    "1242",     "Conexiones NetWare 2.x",

    "1244",     "Conexiones NetWare 3.x",

    "1246",     "Conexiones NetWare 4.x",

    "1260",     "Total de inicios de sesin",

    "1300",     "Colas de trabajo del servidor",

    "1302",     "Longitud de cola",

    "1304",     "Instancias activas de ejecucin",

    "1306",     "Instancias de ejecucin disponibles",

    "1308",     "Elementos de trabajo disponibles",

    "1310",     "Elementos de trabajo prestados",

    "1312",     "Carencias de elementos de trabajo",

    "1314",     "Clientes actuales",

    "1320",     "Bytes transferidos/s.",

    "1324",     "Bytes ledos/s.",

    "1328",     "Bytes escritos/s.",

    "1332",     "Total de operaciones/s.",

    "1334",     "DPCs haciendo cola/s.",

    "1336",     "Velocidad DPC",

    "1342",     "Total DPCs en cola/s.",

    "1344",     "Total DPC frecuencia",

    "1350",     "% de cuota de Registro en uso",

    "1360",     "Memoria VL",

    "1362",     "% de tamao virtual VL en uso",

    "1364",     "Tamao virtual VLM",

    "1366",     "Lmite del tamao virtual VLM ",

    "1368",     "Tamao virtual VLM disponible",

    "1370",     "Carga de escritura VLM",

    "1372",     "Lmite de carga de escritura VLM",

    "1374",     "Carga de escritura VLM de sistema",

    "1376",     "Lmite de carga de escritura VLM de sistema",

    "1378",     "Carga de escritura compartida VLM de sistema",

    "1380",     "KBytes disponibles",

    "1382",     "MBytes disponibles",

    "1400",     "Long. media de la cola de disco",

    "1402",     "Long. promedio de cola de lectura de disco",

    "1404",     "Long. promedio de cola de escritura de disco",

    "1406",     "% de bytes asignados en uso",

    "1408",     "Imagen completa",

    "1410",     "Creando Id. de proceso",

    "1412",     "Nm. de operaciones de lectura de E/S /s.",

    "1414",     "Nm. de operaciones de escritura de E/S /s.",

    "1416",     "Operaciones de datos de E/S /s.",

    "1418",     "Otras operaciones de E/S /s.",

    "1420",     "Nm. de bytes ledos E/S /s.",

    "1422",     "Nm. de bytes escritos E/S /s.",

    "1424",     "Bytes de datos E/S /s.",

    "1426",     "Otros Bytes de E/S /s.",

    "1450",     "Cola de impresin",

    "1452",     "Nmero total de trabajos imprimidos",

    "1454",     "Bytes imprimidos/s.",

    "1456",     "Nmero total de pginas imprimidas",

    "1458",     "Trabajos",

    "1460",     "Referencias",

    "1462",     "Mximo de referencias",

    "1464",     "Trabajos en la cola",

    "1466",     "Nmero mximo de trabajos en la cola",

    "1468",     "Errores ",

    "1470",     "Errores ",

    "1472",     "Errores de trabajo",

    "1474",     "Enumerar llamadas a la impresora de red",

    "1476",     "Agregar llamadas a la impresora de red",

    "1478",     "Conjunto de trabajo - Privado",

    "1480",     "Conjunto de trabajo - Compartido",

    "1482",     "% tiempo inactivo",

    "1484",     "E/S divididas por s.",

    "1500",     "Objeto Trabajo",

    "1502",     "% actual de tiempo de trabajo",

    "1504",     "% actual de tiempo de modo usuario",

    "1506",     "% actual de tiempo de modo Kernel",

    "1508",     "Este perodo ms - Procesador",

    "1510",     "Este perodo ms - Modo usuario",

    "1512",     "Este perodo ms - Modo Kernel",

    "1514",     "Pginas/s",

    "1516",     "Nmero de procesos - Total",

    "1518",     "Nmero de procesos - Activo",

    "1520",     "Nmero de procesos - Terminado",

    "1522",     "Total ms - Procesador",

    "1524",     "Total ms - Modo usuario",

    "1526",     "Total ms - Modo Kernel",

    "1530",     "TCPv6",

    "1532",     "UDPv6",

    "1534",     "ICMPv6",

    "1536",     "Paquetes demasiado grandes recibidos",

    "1538",     "Consultas de pertenencia recibidas",

    "1540",     "Informes de pertenencia recibidos",

    "1542",     "Reduccin de pertenencias recibidas",

    "1544",     "Solicitudes de enrutador recibidas",

    "1546",     "Anuncios de enrutador recibidos",

    "1548",     "Detalles del objeto de trabajo",

    "1550",     "Solicitudes de vecino recibidas",

    "1552",     "Anuncios de vecino recibidos",

    "1554",     "Paquetes demasiado grandes enviados",

    "1556",     "Consultas de pertenencia enviadas",

    "1558",     "Informes de pertenencia enviados",

    "1560",     "Reduccin de pertenencias enviadas",

    "1562",     "Solicitudes de enrutador enviadas",

    "1564",     "Anuncios de enrutador enviados",

    "1566",     "Solicitudes de vecino enviadas",

    "1568",     "Anuncios de vecino enviados",

    "1746",     "% tiempo inactivo",

    "1748",     "Tiempo % C1",

    "1750",     "Tiempo % C2",

    "1752",     "Tiempo % C3",

    "1754",     "Transiciones C1/seg",

    "1756",     "Transiciones C2/seg",

    "1758",     "Transiciones C3/seg",

    "1760",     "montn",

    "1762",     "Bytes comprometidos",

    "1764",     "Bytes reservados",

    "1766",     "Bytes del espacio virtual",

    "1768",     "Bytes libres",

    "1770",     "Tamao de lista de liberaciones",

    "1772",     "Tasa promedio de asignaciones",

    "1774",     "Tasa promedio de liberaciones",

    "1776",     "Tamao de rangos no comprometidos",

    "1778",     "Asignaciones - liberaciones",

    "1780",     "Asignaciones en cach/seg",

    "1782",     "Liberaciones en cach/seg",

    "1784",     "Asignaciones menores que 1KB/seg",

    "1786",     "Liberaciones menores que 1KB/seg",

    "1788",     "Asignaciones entre 1 y 8 KB/seg",

    "1790",     "Liberaciones entre 1 y 8KB/seg",

    "1792",     "Asignaciones mayores que 8KB/seg",

    "1794",     "Liberaciones mayores que 8KB/seg",

    "1796",     "Nmero total de asignaciones/seg",

    "1798",     "Nmero total de liberaciones/seg",

    "1800",     "Bloques en cach de montn",

    "1802",     "Profundidad ms grande en cach",

    "1804",     "Fragmentacin %",

    "1806",     "% VAFragmentation",

    "1808",     "Contencin de bloqueo de montn",

    "1846",     "Marcador de final",
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\fr\perfc00c.ini ===
"1",     "1847",

    "2",     "Systme",

    "4",     "Mmoire",

    "6",     "% Temps processeur",

    "10",     "Oprations de lecture de fichier/s",

    "12",     "Oprations d'criture de fichier/s",

    "14",     "Oprations de contrle de fichier/s",

    "16",     "Octets lus sur fichier/s",

    "18",     "Octets crits sur fichier/s",

    "20",     "Octets de contrle de fichier/s",

    "24",     "Octets disponibles",

    "26",     "Octets valids",

    "28",     "Dfauts de page/s",

    "30",     "Limite de mmoire ddie",

    "32",     "Copies pour criture/s",

    "34",     "Dfauts en transit/s",

    "36",     "Dfauts de cache/s",

    "38",     "Dfauts de page  zro/s",

    "40",     "Pages/s",

    "42",     "Lectures de pages/s",

    "44",     "Longueur de la file du processeur",

    "46",     "tat de la thread",

    "48",     "Pages en sortie/s",

    "50",     "critures de pages/s",

    "52",     "Explorateur",

    "54",     "Serveur d'annonces",

    "56",     "Octets de rserve pagine",

    "58",     "Octets de rserve non pagine",

    "60",     "Allocations de rserve pagine",

    "64",     "Allocations de rserve non pagine",

    "66",     "Octets rsidants de rserve pagine",

    "68",     "Total des octets dans le code systme",

    "70",     "Octets rsidants dans le code systme",

    "72",     "Total des octets dans le pilote systme",

    "74",     "Octets rsidants dans le pilote systme",

    "76",     "Octets rsidants dans le cache systme",

    "78",     "Annonces du domaine/s",

    "80",     "Paquets d'lection/s",

    "82",     "critures mailslot/s",

    "84",     "Requtes de la liste du serveur/s",

    "86",     "Cache",

    "88",     "Donnes mappes/s",

    "90",     "Donnes mappes sync/s",

    "92",     "Donnes mappes async/s",

    "94",     "% Prsence des donnes mappes",

    "96",     "Donnes mappes pingles/s",

    "98",     "Lectures d'pingles/s",

    "100",     "Lectures d'pingles sync/s",

    "102",     "Lectures d'pingles async/s",

    "104",     "% Prsence des donnes pingles",

    "106",     "Lectures avec copie/s",

    "108",     "Lectures avec copie sync/s",

    "110",     "Lectures avec copie async/s",

    "112",     "% Prsence des lectures avec copie",

    "114",     "Lectures MDL/s",

    "116",     "Lectures MDL sync/s",

    "118",     "Lectures MDL async/s",

    "120",     "% Prsence des donnes MDL",

    "122",     "Lectures en avance/s",

    "124",     "Lectures rapides/s",

    "126",     "Lectures rapides sync/s",

    "128",     "Lectures rapides async/s",

    "130",     "checs de lecture rapide/s",

    "132",     "Impossibilits de lectures rapides/s",

    "134",     "Vidanges d'criture diffre/s",

    "136",     "Pages d'criture diffre/s",

    "138",     "Vidange de donnes/s",

    "140",     "Vidange de donnes, page/s",

    "142",     "% Temps utilisateur",

    "144",     "% Temps privilgi",

    "146",     "Changements de contexte/s",

    "148",     "Interruptions/s",

    "150",     "Appels systme/s",

    "152",     "Remplissages TLB de niveau 1/s",

    "154",     "Remplissages TLB de niveau 2/s",

    "156",     "numrations du serveur/s",

    "158",     "numrations du domaine/s",

    "160",     "Autres numrations/s",

    "162",     "Annonces du serveur manques",

    "164",     "Datagrammes mailslot manqus",

    "166",     "Requtes de la liste du serveur manques",

    "168",     "checs des allocations d'annonce du serveur/s",

    "170",     "checs des allocations mailslot",

    "172",     "Taille virtuelle (octets)",

    "174",     "Taille virtuelle (octets)",

    "178",     "Plage de travail max.",

    "180",     "Plage de travail",

    "182",     "Fichier d'change (octets)",

    "184",     "Fichier d'change (octets)",

    "186",     "Octets privs",

    "188",     "Total des annonces/s",

    "190",     "Total des numrations/s",

    "198",     "Taille de file d'attente du disque actuelle",

    "200",     "% Temps du disque",

    "202",     "% Temps lecture du disque",

    "204",     "% Temps criture du disque",

    "206",     "Moy. disque s/transfert",

    "208",     "Moy. disque s/lecture",

    "210",     "Moy. disque s/criture",

    "212",     "Transferts disque/s",

    "214",     "Lectures disque/s",

    "216",     "critures disque/s",

    "218",     "Octets disque/s",

    "220",     "Lectures disque, octets/s",

    "222",     "critures disque, octets/s",

    "224",     "Moy. disque, octets/transfert",

    "226",     "Moy. disque, octets/lecture",

    "228",     "Moy. disque, octets/criture",

    "230",     "Processus",

    "232",     "Thread",

    "234",     "Disque physique",

    "236",     "Disque logique",

    "238",     "Processeur",

    "240",     "% Temps total du processeur",

    "242",     "% Temps total Utilisateur",

    "244",     "% Temps total Privilgi",

    "246",     "Total des interruptions/s",

    "248",     "Processus",

    "250",     "Threads",

    "252",     "vnements",

    "254",     "Smaphores",

    "256",     "Mutex",

    "258",     "Sections",

    "260",     "Objets",

    "262",     "Redirecteur",

    "264",     "Octets reus/s",

    "266",     "Paquets reus/s",

    "268",     "Lecture de pagination, octets/s",

    "270",     "Lecture non pagine, octets/s",

    "272",     "Lecture du cache, octets/s",

    "274",     "Lecture rseau, octets/s",

    "276",     "Octets transmis/s",

    "278",     "Paquets transmis/s",

    "280",     "criture de pagination, octets/s",

    "282",     "criture non pagine, octets/s",

    "284",     "criture du cache, octets/s",

    "286",     "criture rseau, octets/s",

    "288",     "Oprations de lecture/s",

    "290",     "Lecture slective, oprations/s",

    "292",     "Paquets lus/s",

    "294",     "Grosses lectures/s",

    "296",     "Petites lectures/s",

    "298",     "Oprations d'criture fichier/s",

    "300",     "criture slective, oprations/s",

    "302",     "Paquets crits/s",

    "304",     "Grosses critures/s",

    "306",     "Petites critures, paquets/s",

    "308",     "Lectures refuses/s",

    "310",     "critures refuses/s",

    "312",     "Erreurs rseau/s",

    "314",     "Sessions serveur",

    "316",     "Reconnexions au serveur",

    "318",     "Connexions de base",

    "320",     "Connexions Lanman 2.0",

    "322",     "Connexions Lanman 2.1",

    "324",     "Connexions Windows NT",

    "326",     "Dconnexions du serveur",

    "328",     "Sessions en attente sur serveur",

    "330",     "Serveur",

    "336",     "Raison d'attente de la thread",

    "340",     "Sessions fermes pour inactivit",

    "342",     "Sessions fermes suite  une erreur",

    "344",     "Sessions fermes normalement",

    "346",     "Sessions fermes de force",

    "348",     "Erreurs d'accs",

    "350",     "Erreurs d'autorisation d'accs",

    "352",     "Erreurs d'accs accord",

    "354",     "Erreurs systme",

    "356",     "Demandes bloquantes rejetes",

    "358",     "Pnuries d'lments de travail",

    "360",     "Total des fichiers ouverts",

    "362",     "Fichiers ouverts",

    "366",     "Recherches de fichier actives",

    "370",     "checs de rserve non pagine",

    "372",     "Rserve maxi. non pagine",

    "376",     "checs de rserve pagine",

    "378",     "Rserve maxi. pagine",

    "388",     "Total des octets/s",

    "392",     "Commandes en cours",

    "398",     "NetBIOS NWLink",

    "400",     "Paquets/s",

    "404",     "Blocs de contexte en attente/s",

    "406",     "Oprations de fichier/s",

    "408",     "% espace libre",

    "410",     "Mgaoctets libres",

    "412",     "Connexions ouvertes",

    "414",     "Connexions en une tentative",

    "416",     "Connexions en plusieurs tentatives",

    "418",     "Dconnexions locales",

    "420",     "Dconnexions distantes",

    "422",     "Dfaillances du lien",

    "424",     "Dfaillances de la carte",

    "426",     "Sessions hors dlais",

    "428",     "Connexions annules",

    "430",     "Dfaillances de ressources distantes",

    "432",     "Dfaillances de ressources locales",

    "434",     "Dfaillances non trouves",

    "436",     "Dfaillances, pas d'coute",

    "438",     "Datagrammes/s",

    "440",     "Octets de datagrammes/s",

    "442",     "Datagrammes envoys/s",

    "444",     "Octets de datagramme envoys/s",

    "446",     "Datagrammes reus/s",

    "448",     "Octets de datagramme reus/s",

    "452",     "Paquets envoys/s",

    "456",     "Trames/s",

    "458",     "Octets de trame/s",

    "460",     "Trames envoyes/s",

    "462",     "Octets de trame envoys/s",

    "464",     "Trames reues/s",

    "466",     "Octets de trame reus/s",

    "468",     "Trames renvoyes/s",

    "470",     "Octets de trame renvoys/s",

    "472",     "Trames rejetes/s",

    "474",     "Octets de trame rejets/s",

    "476",     "Expirations de rponse",

    "478",     "Expirations d'accus de rception (Ack)",

    "480",     "Fentre d'envoi maximale",

    "482",     "Fentre d'envoi moyenne",

    "484",     "Acks superposables en file d'attente/s",

    "486",     "Acks superposables hors-dlais",

    "488",     "NWLink IPX",

    "490",     "NWLink SPX",

    "492",     "NetBEUI",

    "494",     "Ressource NetBEUI",

    "496",     "Utilisation maximale",

    "498",     "Utilisation moyenne",

    "500",     "Manques de ressources",

    "502",     "Connexion NBT",

    "506",     "Octets envoys/s",

    "508",     "Octets totaux/s",

    "510",     "Interface rseau",

    "512",     "Octets totaux/s",

    "520",     "Bande passante actuelle",

    "524",     "Paquets monodiffusion reus/s",

    "526",     "Paquets non monodiffusion reus/s",

    "528",     "Paquets reus et rejets",

    "530",     "Paquets reus, erreurs",

    "532",     "Paquets reus, inconnus",

    "536",     "Paquets monodiffusion envoys/s",

    "538",     "Paquets non monodiffusion envoys/s",

    "540",     "Paquets sortants rejets",

    "542",     "Paquets sortants, erreurs",

    "544",     "Longueur de la file d'attente de sortie",

    "546",     "IPv4",

    "548",     "IPv6",

    "552",     "Datagrammes reus, erreurs d'en-tte",

    "554",     "Datagrammes reus, erreurs d'adresse",

    "556",     "Datagrammes transmis/s",

    "558",     "Datagrammes reus, protocole inconnu",

    "560",     "Datagrammes reus et rejets",

    "562",     "Datagrammes reus et livrs/s",

    "566",     "Datagrammes sortants rejets",

    "568",     "Datagrammes sortants non routs",

    "570",     "Fragments reus/s",

    "572",     "Fragments rassembls/s",

    "574",     "checs de rassemblage",

    "576",     "Datagrammes fragments/s",

    "578",     "checs de fragmentation",

    "580",     "Fragments crs/s",

    "582",     "ICMP",

    "584",     "Messages/s",

    "586",     "Messages reus/s",

    "588",     "Messages reus, erreurs",

    "590",     "Reus avec dest. inaccessible",

    "592",     "Reus avec temps dpass",

    "594",     "Reus avec problme de paramtre",

    "596",     "Reus avec extinction de source",

    "598",     "Reus avec redirection/s",

    "600",     "Reus avec cho/s",

    "602",     "Reus avec rponse  cho/s",

    "604",     "Reus avec horodateur/s",

    "606",     "Reus avec rponse  horodateur/s",

    "608",     "Reus avec masque d'adresse",

    "610",     "Reus avec rponse  masque d'adresse",

    "612",     "Messages envoys/s",

    "614",     "Messages envoys, erreurs",

    "616",     "Envoys dest. inaccessible",

    "618",     "Envoys temps dpass",

    "620",     "Envoys problme de paramtre",

    "622",     "Envoys extinction de source",

    "624",     "Envoys avec redirection/s",

    "626",     "Envoys avec cho/s",

    "628",     "Envoys avec rponse  cho/s",

    "630",     "Envoys avec horodateur/s",

    "632",     "Envoys avec rp.  horodateur/s",

    "634",     "Envoys avec masque d'adresse",

    "636",     "Envoys avec rp.  masque d'adresse",

    "638",     "TCPv4",

    "640",     "Segments/s",

    "642",     "Connexions tablies",

    "644",     "Connexions actives",

    "646",     "Connexions passives",

    "648",     "checs lors d'une connexion",

    "650",     "Connexions rinitialises",

    "652",     "Segments reus/s",

    "654",     "Segments envoys/s",

    "656",     "Segments retransmis/s",

    "658",     "UDPv4",

    "660",     "% Temps DPC total",

    "662",     "% Temps d'interruption total",

    "664",     "Datagrammes reus sans port/s",

    "666",     "Datagrammes reus, erreurs",

    "670",     "Unit de stockage sur disque",

    "672",     "checs lors d'allocations",

    "674",     "Temps d'activit systme",

    "676",     "Compteur de handles systme",

    "678",     "Entres libres en table des pages systme",

    "680",     "Nombre de threads",

    "682",     "Priorit de base",

    "684",     "Temps coul",

    "686",     "Corrections d'alignement/s",

    "688",     "Envois d'exception/s",

    "690",     "mulations flottantes/s",

    "692",     "Ouvertures de sessions/s",

    "694",     "Priorit actuelle",

    "696",     "% Temps DPC",

    "698",     "% Temps d'interruption",

    "700",     "Fichier d'change",

    "702",     "Pourcentage d'utilisation",

    "704",     "Usage maximal",

    "706",     "Adresse de dbut",

    "708",     "Compteur utilisateur",

    "710",     "Espace mapp sans accs",

    "712",     "Espace mapp-lecture seule",

    "714",     "Espace mapp-lecture/criture",

    "716",     "Espace mapp-copie pour criture",

    "718",     "Espace mapp-excutable",

    "720",     "Espace mapp-exc. lecture seule",

    "722",     "Espace mapp-exc. lecture/criture",

    "724",     "Espace mapp-exc. copie pour criture",

    "726",     "Espace rserv-sans accs",

    "728",     "Espace rserv-lecture seule",

    "730",     "Espace rserv-lecture/criture",

    "732",     "Espace rserv-copie pour criture",

    "734",     "Espace rserv-excutable",

    "736",     "Espace rserv-exc. lecture seule",

    "738",     "Espace rserv-exc. lecture/criture",

    "740",     "Image",

    "742",     "Espace rserv-exc. copie pour criture",

    "744",     "Espace non assign-sans accs",

    "746",     "Espace non assign-lecture seule",

    "748",     "Espace non assign-lecture/criture",

    "750",     "Espace non assign-copie pour criture",

    "752",     "Espace non assign-excutable",

    "754",     "Espace non assign-exc. lecture seule",

    "756",     "Espace non assign-exc. lecture/criture",

    "758",     "Espace non assign-exc. copie pour criture",

    "760",     "Espace image-sans accs",

    "762",     "Espace image-lecture seule",

    "764",     "Espace image-lecture/criture",

    "766",     "Espace image-copie pour criture",

    "768",     "Espace image-excutable",

    "770",     "Espace image-exc. lecture seule",

    "772",     "Espace image-exc. lecture/criture",

    "774",     "Espace image-exc. copie pour criture",

    "776",     "Octets rservs pour l'image",

    "778",     "Octets libres pour l'image",

    "780",     "Octets rservs",

    "782",     "Octets libres",

    "784",     "ID de processus",

    "786",     "Espace d'adressage de processus",

    "788",     "Aucun accs",

    "790",     "Lecture seule",

    "792",     "Lecture/criture",

    "794",     "Copie pour criture",

    "796",     "Excutable",

    "798",     "Exc. lecture seule",

    "800",     "Exc. lecture/criture",

    "802",     "Exc. copie pour criture",

    "804",     "N de thread",

    "806",     "checs des reus mailslot",

    "808",     "checs d'critures mailslot",

    "810",     "checs d'ouvertures mailslot/s",

    "812",     "Annonces du matre de duplication",

    "814",     "Datagrammes non autoriss/s",

    "816",     "Dtails de la thread",

    "818",     "Octets du cache",

    "820",     "Octets max. du cache",

    "822",     "Pages en entre/s",

    "824",     "Pages de transition avec nouvel objet/s",

    "870",     "Port RAS",

    "872",     "Octets transmis",

    "874",     "Octets reus",

    "876",     "Trames transmises",

    "878",     "Trames reues.",

    "880",     "Pourcentage de compression en sortie",

    "882",     "Pourcentage de compression en entre",

    "884",     "Erreurs CRC",

    "886",     "Erreurs de temporisation",

    "888",     "Erreurs de saturation du port srie",

    "890",     "Erreurs de synchronisation",

    "892",     "Erreurs de saturation de la mmoire tampon",

    "894",     "Nombre total d'erreurs",

    "896",     "Octets transmis/s",

    "898",     "Octets reus/s",

    "900",     "Trames transmises/s",

    "902",     "Trames reues/s",

    "904",     "Total des erreurs/s",

    "906",     "Total des RAS",

    "908",     "Total des connexions",

    "920",     "Serveur WINS",

    "922",     "Inscriptions individuelles/s",

    "924",     "Inscriptions de groupes/s",

    "926",     "Nombre total d'inscriptions/s",

    "928",     "Rafrachissements individuels/s",

    "930",     "Rafrachissements de groupes/s",

    "932",     "Nombre total de rafrachissements/s",

    "934",     "Librations/s",

    "936",     "Requtes/s",

    "938",     "Conflits individuels/s",

    "940",     "Conflits de groupes/s",

    "942",     "Nombre total de conflits/s",

    "944",     "Librations russies/s",

    "946",     "checs de librations/s",

    "948",     "Requtes russies/s",

    "950",     "checs de requtes/s",

    "952",     "Nombre de handles",

    "1000",     "Serveur de fichiers Macintosh",

    "1002",     "Mmoire pagine max",

    "1004",     "Mmoire pagine actuelle",

    "1006",     "Mmoire non pagine max",

    "1008",     "Mmoire non pagine courante",

    "1010",     "Sessions actives",

    "1012",     "Nombre maximal de sessions",

    "1014",     "Fichiers ouverts actuels",

    "1016",     "Nombre maximal de fichiers ouverts",

    "1018",     "checs d'ouvertures de sessions",

    "1020",     "Donnes lues/s",

    "1022",     "Donnes crites/s",

    "1024",     "Donnes reues/s",

    "1026",     "Donnes transmises/s",

    "1028",     "Longueur actuelle de la file",

    "1030",     "Longueur maximale de la file",

    "1032",     "Threads actuelles",

    "1034",     "Nombre maximal de threads",

    "1050",     "AppleTalk",

    "1052",     "Paquets en entre/s",

    "1054",     "Paquets en sortie/s",

    "1056",     "Octets en entre/s",

    "1058",     "Octets en sortie/s",

    "1060",     "Temps moyen/paquet DDP",

    "1062",     "Paquets DDP/s",

    "1064",     "Temps moyen/paquet AARP",

    "1066",     "Paquets AARP/s",

    "1068",     "Temps moyen/paquet ATP",

    "1070",     "Paquets ATP/s",

    "1072",     "Temps moyen/paquet NBP",

    "1074",     "Paquets NBP/s",

    "1076",     "Temps moyen/paquet ZIP",

    "1078",     "Paquets ZIP/s",

    "1080",     "Temps moyen/paquet RTMP",

    "1082",     "Paquets RTMP/s",

    "1084",     "Nouveaux essais locaux ATP",

    "1086",     "Dlais de rponse ATP",

    "1088",     "Rponse ATP XO/s",

    "1090",     "Rponse ATP ALO/s",

    "1092",     "Libration d'ATP reus/s",

    "1094",     "Rserve non pagine actuelle",

    "1096",     "Paquets routs entrs/s",

    "1098",     "Paquets perdus",

    "1100",     "Nouveaux essais distants ATP",

    "1102",     "Paquets routs sortis/s",

    "1110",     "Segment rseau",

    "1112",     "Nombre total de trames reues/s",

    "1114",     "Nombre total d'octets reus/s",

    "1116",     "Trames de diffusion reues/s",

    "1118",     "Trames multidestinataires reues/s",

    "1120",     "% Utilisation du rseau",

    "1124",     "% Trames de diffusion",

    "1126",     "% Trames multidestinataires",

    "1150",     "Tlphonie",

    "1152",     "Lignes",

    "1154",     "Priphriques tlphoniques",

    "1156",     "Lignes actives",

    "1158",     "Tlphones actifs",

    "1160",     "Appels sortants/s",

    "1162",     "Appels entrants/s",

    "1164",     "Applications client",

    "1166",     "Appels sortants en cours",

    "1168",     "Appels entrants en cours",

    "1228",     "Service passerelle pour NetWare",

    "1230",     "Service client pour NetWare",

    "1232",     "Compte NCP des lectures de salves de paquets/s",

    "1234",     "Dlais d'attente des salves de paquets en lecture/s",

    "1236",     "Compte NCP des critures de salves de paquets/s",

    "1238",     "Dlais d'attente des salves de paquets en criture/s",

    "1240",     "E/S de salves de paquets/s",

    "1242",     "Connexion NetWare 2.x",

    "1244",     "Connexion NetWare 3.x",

    "1246",     "Connexion NetWare 4.x",

    "1260",     "Total des ouvertures de sessions",

    "1300",     "Files de travail du serveur",

    "1302",     "Longueur de la file",

    "1304",     "Threads actives",

    "1306",     "Threads disponibles",

    "1308",     "lments de travail disponibles",

    "1310",     "lments de travail emprunts",

    "1312",     "Pnuries d'lments de travail",

    "1314",     "Clients actuels",

    "1320",     "Octets transfrs/s",

    "1324",     "Octets lus/s",

    "1328",     "Octets crits/s",

    "1332",     "Total des oprations/s",

    "1334",     "DPC mis en file d'attente/s",

    "1336",     "Taux DPC",

    "1342",     "Total DPC mis en file d'attente/s",

    "1344",     "Total des taux DPC",

    "1350",     "% quota du Registre utilis",

    "1360",     "Mmoire VL",

    "1362",     "% de taille virtuelle VLM utilise",

    "1364",     "Taille virtuelle VLM",

    "1366",     "Pic de taille virtuelle VLM ",

    "1368",     "Taille virtuelle VLM disponible",

    "1370",     "Charge d'criture VLM",

    "1372",     "Pic de charge d'criture VLM",

    "1374",     "Charge d'criture VLM systme",

    "1376",     "Pic de charge d'criture VLM systme",

    "1378",     "Charge d'criture partage VLM systme",

    "1380",     "Kilo-octets disponibles",

    "1382",     "Mgaoctets disponibles",

    "1400",     "Long. moy. de file d'attente du disque",

    "1402",     "Long. moy. de file d'attente lecture disque",

    "1404",     "Long. moy. de file d'attente criture disque",

    "1406",     "% Octets ddis utiliss",

    "1408",     "Image complte",

    "1410",     "ID du processus crateur",

    "1412",     "Nombre d'oprations de lecture/s",

    "1414",     "Nombre d'oprations d'criture/s",

    "1416",     "Nombre d'oprations de donnes/s",

    "1418",     "Nombre d'autres oprations d'ES/s",

    "1420",     "Nombre d'octets lus/s",

    "1422",     "Nombre d'octets crits/s",

    "1424",     "Nombre d'octets de donnes/s",

    "1426",     "Nombre d'octets autres ES/s",

    "1450",     "File d'impression",

    "1452",     "Total des travaux imprims",

    "1454",     "Octets imprims/s",

    "1456",     "Total des pages imprimes",

    "1458",     "Travaux",

    "1460",     "Rfrences",

    "1462",     "Nombre maximal de rfrences",

    "1464",     "Travaux spouls",

    "1466",     "Nombre maximal de travaux spouls",

    "1468",     "Erreurs Papier absent",

    "1470",     "Erreurs Non prt",

    "1472",     "Erreurs de travaux",

    "1474",     "numrer les appels d'imprimantes rseau",

    "1476",     "Ajouter des appels d'imprimantes rseau",

    "1478",     "Plage de travail - Prive",

    "1480",     "Plage de travail - Partage",

    "1482",     "% Dure d'inactivit",

    "1484",     "E/S partages/s",

    "1500",     "Objet Travail",

    "1502",     "% actuel du temps processeur",

    "1504",     "% actuel du temps mode utilisateur",

    "1506",     "% actuel du temps mode noyau",

    "1508",     "Cette priode ms - Processeur",

    "1510",     "Cette priode ms - Mode utilisateur",

    "1512",     "Cette priode ms - Mode noyau",

    "1514",     "Pages/s",

    "1516",     "Nombre de processus - Total",

    "1518",     "Nombre de processus - Actifs",

    "1520",     "Nombre de processus - Termins",

    "1522",     "Total ms - Processeur",

    "1524",     "Total ms - Mode utilisateur",

    "1526",     "Total ms - Mode noyau",

    "1530",     "TCPv6",

    "1532",     "UDPv6",

    "1534",     "ICMPv6",

    "1536",     "Taille du paquet reu trop importante",

    "1538",     "Requte d'adhsion reue",

    "1540",     "Rapport d'adhsion reu",

    "1542",     "Rduction d'adhsion reue",

    "1544",     "Sollicitation de routeur reue",

    "1546",     "Annonce de routeur reue",

    "1548",     "Dtails de l'objet Travail",

    "1550",     "Sollicitation de voisinage reue",

    "1552",     "Annonce de voisinage reue",

    "1554",     "Taille du paquet envoy trop importante",

    "1556",     "Requte d'adhsion envoye",

    "1558",     "Rapport d'adhsion envoy",

    "1560",     "Rduction d'adhsion envoye",

    "1562",     "Sollicitation de routeur envoye",

    "1564",     "Annonce de routeur envoye",

    "1566",     "Sollicitation de voisinage envoye",

    "1568",     "Annonce de voisinage envoye",

    "1746",     "% dure d'inactivit",

    "1748",     "% dure C1",

    "1750",     "% dure C2",

    "1752",     "% dure C3",

    "1754",     "C1 Transitions/s",

    "1756",     "C2 Transitions/s",

    "1758",     "C3 Transitions/s",

    "1760",     "Tas",

    "1762",     "Octets valids",

    "1764",     "Octets rservs",

    "1766",     "Taille virtuelle (octets)",

    "1768",     "Octets libres",

    "1770",     "Longueur de la liste de libration",

    "1772",     "Taux moy. d'allocation",

    "1774",     "Taux moy. de libration",

    "1776",     "Longueurs des plages non ddies",

    "1778",     "Allocations - Librations",

    "1780",     "Allocations mises en cache/s",

    "1782",     "Librations mises en cache/s",

    "1784",     "Allocations < 1 Ko/s",

    "1786",     "Librations < 1 Ko/s",

    "1788",     "Allocations 1-8 Ko/s",

    "1790",     "Librations 1-8 Ko/s",

    "1792",     "Allocations au del de 8 Ko/s",

    "1794",     "Librations au del de 8 Ko/s",

    "1796",     "Total des Allocations/s",

    "1798",     "Total des Librations/s",

    "1800",     "Blocs dans le cache de segments",

    "1802",     "Profondeur de cache la plus large",

    "1804",     "% Fragmentation",

    "1806",     "% VAFragmentation",

    "1808",     "Contention de verrouillage du segment",

    "1846",     "Marqueur de fin",
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\screg\winreg\cntrtext\perfini\ger\perfh007.ini ===
"3",     "Das System-Leistungsindikatorenobjekt besteht aus Leistungsindikatoren, die fr mehrere Instanzen eines Komponentenprozessors auf dem Computer gelten. ",

    "5",     "Leistungsindikatoren, die das Verhalten von physikalischem und virtuellem Speicher im System beschreiben. Viele Speicherleistungsindikatoren berwachen das Auslagern bzw. das Verschieben von Code- und Datenseiten zwischen dem Datentrger und dem physikalischen Speicher. bermiges Auslagern kann Verzgerungen verursachen, die sich auf alle Systemprozesse auswirken.",

    "7",     "Prozentuale Angabe der vergangenen Prozessorzeit, die zum Ausfhren eines Threads bentigt wird, der sich nicht im Leerlauf befindet. Dieser Leistungsindikator ist die primre Anzeige der Prozessoraktivitt. Die Zeitspanne, die der Prozessor bentigt, um den Thread des Leerlaufprozesses in jedem Abtastintervall auszufhren, wird von 100% subtrahiert. (Jeder Prozessor besitzt einen Leerlaufthread, der Zyklen belegt, wenn keine anderen Threads ausgefhrt werden knnen.) Der Leistungsindikator zeigt die durchschnittliche prozentuale Belegung whrend des Abtastintervalls an, indem die Zeitspanne, die der Dienst nicht aktiv war von 100% subtrahiert wird.",

    "9",     "Durchschnittliche prozentuale Angabe der Prozessorzeit, die zum Empfangen und Bearbeiten von DPCs (Deferred Procedure Calls) bentigt wird. (DPCs sind Interrupts, die mit niedrigerer Prioritt als Standardinterrupts ausgefhrt werden). Prozessorsumme: Die DPC-Zeit (%) aller Prozessoren dividiert durch die Prozessoranzahl System: Die gesamte DPC-Zeit (%) ist eine Komponente des Systems: Die gesamte privilegierte Zeit (%), da DPCs im privilegierten Modus ausgefhrt werden. DPCs werden separat gezhlt und sind keine Komponente der Interruptanzahl. Dieser Leistungsindikator zeigt die durchschnittliche Belegung als prozentuale Abtastzeit an.",

    "11",     "Die gesamte Anzahl der Dateisystem-Leseanforderungen auf allen Gerten, einschlielich Leseanforderungen von Dateisystemcache (gemessen nach Anzahl der Lesevorgnge). Dieser Leistungsindikator zeigt die Differenz zwischen den Werten in den letzten beiden Abtastintervallen dividiert durch die Intervalldauer an.  ",

    "13",     "Die gesamte Anzahl der Dateisystem-Schreibanforderungen auf allen Gerten, einschlielich Schreibanforderungen in Dateisystemcache (gemessen nach Anzahl der Schreibvorgnge). Dieser Leistungsindikator zeigt die Differenz zwischen den Werten in den letzten beiden Abtastintervallen dividiert durch die Intervalldauer an.",

    "15",     "Die gesamte Anzahl der peripheren Vorgnge, die weder Schreib- noch Lesevorgnge sind, z.B. Steueranforderungen oder Informationsanforderungen ber Merkmale oder den Status des Gerts (gemessen nach Anzahl der Vorgnge pro Sekunde). Dieser Leistungsindikator zeigt die Differenz zwischen den Werten in den letzten beiden Abtastintervallen dividiert durch die Intervalldauer an. ",

    "17",     "Die Gesamtrate mit der Bytes fr Dateisystem-Leseanforderungen auf allen Gerten gelesen werden, einschlielich Leseanforderungen von Dateisystemcache (gemessen nach Bytes pro Sekunde). Dieser Leistungsindikator zeigt die Differenz zwischen den Werten in den letzten beiden Abtastintervallen dividiert durch die Intervalldauer an.  ",

    "19",     "Die Gesamtrate mit der Bytes fr Dateisystem-Schreibanforderungen auf allen Gerten geschrieben werden, einschlielich Schreibanforderungen im Dateisystemcache (gemessen nach Bytes pro Sekunde). Dieser Leistungsindikator zeigt die Differenz zwischen den Werten in den letzten beiden Abtastintervallen dividiert durch die Intervalldauer an.  ",

    "21",     "Die Gesamtrate mit der Bytes fr alle Systemvorgnge bertragen werden, die weder Lese- noch Schreibvorgnge sind; einschlielich Steueranforderungen oder Informationsanforderungen ber Merkmale oder den Status des Gerts (gemessen nach Byteanzahl). Dieser Leistungsindikator zeigt die Differenz zwischen den Werten in den letzten beiden Abtastintervallen dividiert durch die Intervalldauer an. ",

    "23",     "Durchschnittliche prozentuale Angabe der Prozessorzeit, die alle Prozessoren zum Empfangen und Bearbeiten der Hardwareinterrupts whrend Beispielintervallen bentigen, wenn der Wert eine indirekte Anzeige der Interrupt erstellenden Gerteaktivitten ist. Prozessorsumme: Die Interruptzeit (%) fr alle Prozessoren dividiert durch die Prozessoranzahl. DPCs werden separat gezhlt und sind keine Komponente der Interruptanzahl. Dieser Wert ist ein indirekter Indikator der Aktivitt von Gerten, die Interrupts generieren, z.B. Systemzeitgeber, Maus, Treiber, Netzwerkkarten und andere Peripheriegerte. ",

    "25",     "Fr Prozesse oder fr die Systemverwendung verfgbarer physikalischer Speicher in MB- Dies ist gleich der Speichersumme, die Standby- (zwichengespeichert), freien und Nullseitenlisten zugewiesen ist. Eine genaue Beschreibung des Speicher-Managers finden Sie unter MSDN und/oder im Windows Server 2003 Resource Kit unter Systemleistung und Problembehandlung.",

    "27",     "Zugesicherter virtueller Speicher in Bytes. Zugesicherter Speicher ist physikalischer Speicher, fr den in Auslagerungsdateien Speicherplatz reserviert wurde. Es knnen eine oder mehrere Auslagerungsdateien auf jedem physikalischem Laufwerk vorhanden sein. Dieser Indikator zeigt nur den letzten Wert an, keinen Durchschnittswert.",

    "29",     "Seitenfehler/s ist die durchschnittliche Anzahl an Seitenfehlern pro Sekunde. Der Wert wird laut der Zahl der fehlgeschlagenen Seiten pro Sekunde gemessen, da nur eine Seite pro Fehlervorgang fehlschlagen kann Daher ist der Wert auch mit der Anzahl der Seitenfehlervorgnge identisch. Dieser Leistungsindikator zeigt schwerwiegende Fehler (Fehler, die Festplattenzugriff erfordern) und nebenschliche Fehler (Fehler, bei denen die Ausnahmeseite woanders im physikalischen Speicher gefunden wird) an. Die meisten Prozessoren knnen eine groe Anzahl an nebenschlichen Fehler ohne schwerwiegende Nachfolgen verarbeiten. Schwerwiegende Fehler erfordern Festplattenzugriff, was groe Verzgerungen verursachen kann.",

    "31",     "Virtueller Speicher in Bytes, der zugesichert werden kann, ohne die Auslagerungsdatei(en) zu vergrern. Zugesicherter Speicher ist physikalischer Speicher, fr den in den Auslagerungsdateien Speicherplatz reserviert wurde. Auf jedem logischen Laufwerk kann sich eine Auslagerungsdatei befinden. Wenn die Auslagerungsdateien vergrert werden, wird dieses Limit entsprechend erweitert. Dieser Indikator zeigt nur den letzten Wert an, keinen Durchschnittswert.",

    "33",     "Die Rate, mit der Schreibversuche Seitenfehler verursachen, die behoben wurden, indem die Seite in den physikalischen Speicher kopiert wurde. Dies ist eine konomische Methode, Daten zu teilen, da Seiten nur kopiert werden, wenn auf sie geschrieben wird. Dieser Indikator zhlt die Anzahl der Kopien, ohne die Seiten, die bei jedem Vorgang kopiert werden.",

    "35",     "Wechselfehler/s ist die Rate, zu der Seitenfehler behoben wurden, indem Seiten wiederhergestellt wurden, die von einem anderen Prozess verwendet wurden oder Teil der Seiten- oder Standbyliste waren bzw. auf den Datentrger geschrieben wurden. Die Seiten werden ohne zustzliche Datentrgeraktivitt wiederhergestellt. bergangsfehler werden nach Anzahl der Fehler gezhlt. Da jeweils nur eine Seite pro Vorgang fehlschlgt, ist die Anzahl mit der Anzahl der Seitenfehler identisch.",

    "37",     "Die Rate, mit der Fehler auftreten, wenn eine Seite im Dateisystemcache nicht gefunden wird und aus dem Arbeitsspeicher oder vom Datentrger abgerufen werden muss. Der Dateisystemcahce ist physikalischer Speicher, in dem krzlich verwendete Datenseiten fr Anwendungen gespeichert werden. Die Cacheaktivitt ist eine zuverlssige Anzeige der meisten E/A-Vorgnge von Anwendungen. Dieser Indikator zhlt die Fehler, ohne die Seitenfehler bei jedem Vorgang.",

    "39",     "Die Rate zu der eine mit Nullen aufgefllte Seite erfordert wird, um den Fehler zu beheben. Genullte Seiten sind eine Sicherheitsfunktion von Windows. Genullte Seiten sind mit Nullen aufgefllte Speicherseiten, die verhindern, dass nachfolgende Prozesse auf Daten von vorherigen Prozessen zugreifen knnen. In Windows wird eine Liste der genullten Seiten verwaltet, um diesen Prozess zu beschleunigen. Dieser Leistungsindikator zeigt die Differenz zwischen den Werten in den letzten beiden Abtastintervallen dividiert durch die Intervalldauer an.",

    "41",     "Seiten/s ist die Rate, zu der Seiten vom Datentrger gelesen bzw. auf den Datentrger geschrieben werden, um schwere Ausnahmefehler zu beheben. Dieser Leistungsindikator ist hauptschlich fr das Anzeigen von Fehlern, die das ganze System verlangsamen, zustndig. Der Indikator ist die Summe von Speicher\\Seiteneingabe/s und Speicher\\Seitenausgabe/s. Er wird laut Seitenanzahl gezhlt, so dass die Werte mit anderen Seitenzhlungen verglichen werden knnen, wie z. B. Speicher\\Seitenfehler/s ohne Konvertierung. Seiten zum Beheben von Fehlern sind in nicht zwischengespeicherten zugeordneten Speicherdateien im Dateisystemcache miteinbezogen (diese werden normalerweise von Anwendungen angefordert).",

    "43",     "Die Rate, mit der Seiten vom Datentrger gelesen werden, um Hardwareseitenfehler zu beheben. Es wird die Anzahl der Lesevorgnge ohne Rcksicht auf die Anzahl der in jedem Vorgang abgerufenen Seiten angezeigt. Hardwareseitenfehler treten auf, wenn ein sich Prozess auf eine Seite im virtuellen Speicher bezieht, die sich nicht in seiner Arbeitsseite oder im physikalischen Speicher befindet und vom Datentrger abgerufen werden muss. Dieser Indikator ist ein primrer Hinweis auf Fehler, die systemweite Verzgerungen verursachen. Er enthlt Lesevorgnge, um Fehler im Dateisystemcache (normalerweise durch Anwendungen angefordert) und in nicht zwischengespeicherten, zugeordneten Speicherdateien zu erfassen. Vergleichen Sie den Wert von Speicher\\Seitenlesevorgnge/s mit dem Wert von Speicher\\Seiteneingabe/s, um die durchschnittliche Anzahl der whrend jedes Lesevorgangs gelesenen Seite zu ermitteln.",

    "45",     "Die Anzahl der Threads in der Prozessorwarteschlange. Im Gegensatz zu den Datentrgerindikatoren werden mit diesem Leistungsindikator nur abgeschlossene, und keine noch ausgefhrten, Threads gezhlt. Auch wenn mehrere Prozessoren vorhanden sind, wird eine einzelne Warteschlange fr die Prozessorzeit verwendet. Wenn ein Computer daher ber mehrere Prozessoren verfgt, mssen Sie diesen Wert durch die Anzahl der Prozessoren, ber die die Arbeitslast aufgeteilt ist, teilen. Eine anhaltende Prozessorwarteschlange von weniger als 10 Threads pro Prozessor ist abhngig von der Arbeitslast akzeptierbar.",

    "47",     "Der aktuelle Status eines Threads. Werte: 0=Initialisiert, 1=Bereit (wartet auf einen freien Prozessor), 2=Wird ausgefhrt (verwendet einen Prozessor), 3=Standby (verwendet in Krze einen Prozessor), 4=Abgebrochen, 5=Wartend (wartet auf das Abschlieen eines peripheren Vorgangs oder eine Ressource), 6=bergang (wartet auf eine Ressource, z.B. ausgelagerten Speicher), 7=Unbekannt.",

    "49",     "Die Rate, mit der Seiten auf den Datentrger geschriebenen werden, um Speicherplatz im physikalischen Speicher freizugeben. Seiten werden nur zurck auf den Datentrger geschrieben, wenn sie im physikalischen Speicher gendert wurden und vermutlich Daten und keinen Code enthalten. Eine hohe Seitenausgabe zeigt an, dass mglicherweise nicht gengend Speicher verfgbar ist. Windows schreibt mehr Seiten zurck auf den Datentrger, um Speicherplatz freizugeben, wenn wenig Speicherplatz frei ist. Dieser Leistungsindikator zeigt die Seitenanzahl an und kann ohne Konvertierung mit anderen Werten verlichen werden.",

    "51",     "Die Rate, mit der Seiten auf den Datentrger geschrieben wurden, um Speicherplatz im physikalischen Speicher freizugeben. Seiten werden nur auf den Datentrger geschrieben, wenn sie im physikalischen Speicher gendert wurden und vermutlich Daten und keinen Code enthalten. Dieser Leistungsindikator zeight Schreibvorgnge an, ohne die bei jedem Vorgang geschriebenen Seiten, und zeigt die Differenz zwischen den Werten in den letzten beiden Abtastintervallen dividiert durch die Intervalldauer an.",

    "53",     "Leistungsindikatoren, die die Raten der Ankndigungen, Aufzhlungen und andere Suchdienstvorgnge messen.",

    "55",     "Die Rate, mit der sich die Server in der Domne an diesem Server angekndigt haben.",

    "57",     "Ausgelagerter Pool (Bytes) ist die Gre in Bytes von ausgelagertem Speicherpool, ein Bereich des Systemspeichers (physikalischer Speicher, der vom Betriebssystem verwendet wird) fr Objekte, die auf den Datentrger geschrieben werden knnen, wenn sie nicht verwendet werden. Speicher\\Ausgelagerter Pool (Bytes) wird anders als Prozess\\Ausgelagerter Pool (Bytes) berechnet, so dass der Wert nicht mit Prozess\\Ausgelagerter Pool (Bytes)\\Insgesamt bereinstimmt. Dieser Counter zeigt nur den letzten ermittelten Wert an; nicht den Durchschnittswert.",

    "59",     "Nicht-ausgelagerter Pool (Bytes) ist die Gre in Bytes von nicht ausgelagerten Speicherpool, ein Bereich des Systemspeichers (physikalischer Speicher, der vom Betriebssystem verwendet wird) fr Objekte, die nicht auf den Datentrger geschrieben werden knnen, sondern im physikalischen Speicher verbleiben mssen, solange sie zugewiesen sind. Speicher\\Nicht-ausgelagerter Pool (Bytes) wird anders als Prozess\\Nicht-ausgelagerter Pool (Bytes) berechnet, so dass der Wert nicht mit Prozess\\Nicht-ausgelagerter Pool (Bytes)\\Insgesamt bereinstimmt. Dieser Counter zeigt nur den letzten ermittelten Wert an; nicht den Durchschnittswert.",

    "61",     "Die Anzahl der Aufrufe, um Platz im Auslagerungsspeicher zu reservieren. Auslagerungsspeicher ist ein Bereich im Systemspeicher fr Objekte, die auf den Datentrger geschrieben werden knnen, wenn sie nicht verwendet werden. Dieser Wert wird nach der Anzahl der Aufrufe fr die Speicherreservierung gemessen, ungeachtet dem in jedem Aufruf zugeordneten Speicherplatz. Dieser Indikator zeigt nur den letzten Wert an, keinen Durchschnittswert.",

    "63",     "Die aktuelle Gre des Auslagerungsspeichers in Bytes. Auslagerungsspeicher ist ein Bereich im Systemspeicher fr Objekte, die auf den Datentrger geschrieben werden knnen, wenn sie nicht verwendet werden. Der von Auslagerungsspeicher und nicht-Auslagerungsspeicher verwendeter Speicher wird vom physikalischen Speicher verwendet. Ein zu groer Pool nimmt den Prozessspeicher in Anspruch. Dieser Indikator zeigt nur den letzten Wert an, keinen Durchschnittswert.",

    "65",     "Die Anzahl der Aufrufe, um Platz im Nicht-Auslagerungsspeicher zu reservieren. Nicht-Auslagerungsspeicher ist ein Bereich im Systemspeicher fr Objekte, die nicht auf den Datentrger geschrieben werden knnen, aber ber die gesamte Zuordnungsdauer im physikalischen Speicher verbleiben mssen. Dieser Wert wird nach der Anzahl der Aufrufe fr die Speicherreservierung gemessen, ungeachtet dem in jedem Aufruf zugeordneten Speicherplatz. Dieser Indikator zeigt nur den letzten Wert an, keinen Durchschnittswert.",

    "67",     "Die Gesamtrate aller Bytes, die vom Netzwerk durch das Protokoll erhalten oder gesendet wurden. Es werden nur die Bytes in Rahmen (z.B. Pakete) gezhlt, die Daten enthalten. Dies ist die Summe der Rahmenbytes/s und Datagramm-Bytes/s",

    "69",     "Die Gre des auslagerungsfhigen Betriebssystemcodes im virtuellen Speicher in Bytes (gemessen an der Gre des vom Betriebssystem verwendeten physikalischen Speichers, der auf den Datentrger geschrieben werden kann, wenn er nicht verwendet wird). Dieser Wert wird durch Addieren der Bytes in Ntoskrnl.exe, Hal.dll, den Starttreibern und dem Dateisystem berechnet. Der Code, der im physikalischen Speicher verbleiben muss, und nicht auf den Datentrger geschrieben werden kann, wird nicht bercksichtigt. Dieser Indikator zeigt nur den letzten Wert an, keinen Durchschnittswert.",

    "71",     "Die Gre des Betriebssystemcodes im physikalischen Speicher in Bytes, der auf den Datentrger geschrieben werden kann, wenn er nicht verwendet wird. Dieser Wert ist eine Komponente von Speicher\\Systemcode: Gesamtanzahl Bytes, die den Betriebssystemcode auf dem Datentrger enthlt. Speicher\\Systemcode: Residente Bytes (und Speicher\\Systemcode: Gesamtanzahl Bytes) enthlt keinen Code, der im physikalischen Speicher verbleiben muss, und nicht auf den Datentrger geschrieben werden kann. Dieser Indikator zeigt nur den letzten Wert an, keinen Durchschnittswert.",

    "73",     "Die Gre des auslagerungsfhigen virtuellen Speichers in Bytes, der derzeit von Gertetreibern verwendet wird. Auslagerungsfhiger Speicher kann auf den Datentrger geschrieben werden, wenn er nicht verwendet wird. Dieser Wert enthlt ausgelagerten physikalischen Speicher (Speicher\\Systemtreiber: Residente Bytes), Code und Daten. Er ist eine Komponente von Speicher\\Systemcode: Gesamtanzahl Bytes. Dieser Indikator zeigt nur den letzten Wert an, keinen Durchschnittswert.  ",

    "75",     "Die Gre des auslagerungsfhigen physikalischen Speichers in Bytes, der derzeit von Gertetreibern verwendet wird. Dies ist eine Arbeitsseite (physikalischer Speicherbereich) der Treiber. Der Wert ist eine Komponente von Speicher\\Systemtreiber: Gesamtanzahl Bytes, der auch Treiberspeicher enthlt, der auf den Datentrger geschrieben wurde. Weder Speicher\\Systemtreiber: Residente Bytes, noch Speicher\\Systemtreiber: Gesamtanzahl Bytes enthlt Speicher, der nicht auf den Datentrger geschrieben werden kann.",

    "77",     "Die Gre des auslagerungsfhigen Betriebssystemcodes im Dateisystemcache in Bytes. Dieser Wert enthlt nur die aktuellen physikalischen Seiten und enthlt keine virtuellen Speicherseiten, die zu diesem Zeitpunkt nicht resident sind. Er ist ungleich dem im Task-Manager angezeigten Wert des Systemcaches. Daraus resultierend kann dieser Wert kleiner als der tatschliche Wert des virtuellen Speichers sein, der vom Dateisystemcache verwendet wird. Dieser Wert ist eine Komponente von Speicher\\Systemcode: Residente Bytes, der allen auslagerungsfhigen Betriebssystemcode reprsentiert, der sich zu diesem Zeitpunkt im physikalischen Speicher befindet. Dieser Indikator zeigt nur den letzten Wert an, keinen Durchschnittswert. ",

    "79",     "Die Rate, mit der sich eine Domne im Netzwerk angekndigt hat.",

    "81",     "Die Rate, mit der Suchdienstwahlpakete durch diese diese Arbeitsstation empfangen wurden.",

    "83",     "Die Rate, mit der Mailslot-Nachrichten ordnungsgem empfangen wurden.",

    "85",     "Die Rate, mit der Anforderungen zum Laden einer Liste der von dieser Arbeitsstation angesprochenen Suchserver verarbeitet wurde.",

    "87",     "Leistungsindikatoren, die den Dateisystemcache berwachen; einen physikalischen Speicherbereich, in dem zuvor verwendete Daten gespeichert werden, um den Zugriff auf Daten zu ermglichen, ohne dass diese vom Datentrger gelesen werden mssen. Der Cache wird als Indikator von E/A-Programmvorgngen berwacht, da er von Anwendungen verwendet wird. Der Cache ist nur effektiv, wenn gengend Speicher verfgbar ist.",

    "89",     "Zeigt an, wie oft ein Dateisystem, z.B. NTFS, eine Seite einer Datei in den Dateisystemcache verlagert, um diese zu lesen.",

    "91",     "Zeigt an, wie oft ein Dateisystem, z.B. NTFS, eine Seite einer Datei in den Dateisystemcache verlagert, um diese zu lesen und darauf wartet, bis der Cache die Seite wieder eingelesen hat, wenn sie nicht im Arbeitsspeicher ist.",

    "93",     "Zeigt an, wie oft ein Dateisystem, z.B. NTFS, eine Seite einer Datei in den Dateisystemcache verlagert, um diese zu lesen und nicht wartet, bis der Cache die Seite wieder eingelesen hat, wenn sie nicht im Arbeitsspeicher ist.",

    "95",     "Der Prozentanteil von Datenverlagerungen im Dateisystemcache, die ausgefhrt werden knnen, ohne die Seite vom Datentrger wiedereinzulesen, da die Seite bereits im Hauptspeicher war.",

    "97",     "Zeigt an, wie oft Datenverlagerungen im Dateisystemcache auftreten, die ein Festsetzen der Seite im Hauptspeicher zur Folge haben. Dies wird normalerweise ausgefhrt, um das Schreiben der Datei auf den Datentrger vorzubereiten. Whrend eine Seite festgesetzt ist, knnen die Adresse im Arbeitsspeicher und die virtuelle Adresse im Dateisystemcache nicht gendert werden.",

    "99",     "Zeigt an, wie oft Daten in den Dateisystemcache gelesen werden, um ein Zurckschreiben auf den Datentrger vorzubereiten. Auf diese Art gelesene Seiten werden ab dem Beenden des Lesevorgangs im Speicher festgesetzt. Whrend eine Seite festgesetzt ist, kann die Adresse der Seite im Dateisystemcache nicht gendert werden. ",

    "101",     "Zeigt an, wie oft Daten in den Dateisystemcache gelesen werden, um ein Zurckschreiben zum Datentrger vorzubereiten. Auf diese Art gelesene Seiten werden im Speicher festgesetzt, wenn der Lesevorgang beendet ist. Das Dateisystem erhlt die Kontrolle erst zurck, wenn die Seite im Dateisystemcache festgesetzt ist. Whrend eine Seite festgesetzt ist, kann die Adresse der Seite im Dateisystemcache nicht gendert werden. ",

    "103",     "Zeigt an, wie oft Daten in den Dateisystemcache gelesen werden, um ein Zurckschreiben zum Datentrger vorzubereiten. Auf diese Art gelesene Seiten werden im Speicher festgesetzt, wenn der Lesevorgang beendet ist. Das Dateisystem erhlt die Kontrolle sofort zurck, auch wenn auf den Datentrger zugegriffen werden muss, um die Seite wieder einzulesen. Whrend eine Seite festgesetzt ist kann die Adresse der Seite im Cache nicht gendert werden.",

    "105",     "Der Prozentanteil von Festsetzungs- Leseanforderungen, die den Dateisystemcache treffen, d.h. kein Lesen des Datentrgers fr den Zugriff auf die Seite im Dateisystemcache erfordern. Whrend eine Seite festgesetzt ist, kann die Adresse der Seite im Cache nicht gendert werden. Der LAN Redirector verwendet diese Methode, um Cache-Informationen abzufragen. Der LAN Server verwendet sie fr kleinere bertragungen. Diese Methode wird normalerweise auch vom Datentrgerdateisystem verwendet.",

    "107",     "Die Anzahl der Lesevorgnge von Seiten im Dateisystemcache, die eine Kopie der Daten vom Cache im Puffer der Anwendung erzeugen. Der LAN Redirector verwendet diese Methode, um Cache-Informationen abzufragen. Der LAN Server verwendet sie fr kleinere bertragungen. Diese Methode wird auch vom Datentrgerdateisystem verwendet.",

    "109",     "Die Anzahl der Lesevorgnge von Seiten im Dateisystemcache, die eine Kopie der Daten vom Cache im Puffer der Anwendung erzeugen. Das Dateisystem erhlt die Kontrolle erst zurck, wenn der Kopiervorgang abgeschlossen ist, auch wenn auf den Datentrger zugegriffen werden muss, um die Seite wieder einzulesen.",

    "111",     "Die Anzahl der Lesevorgnge von Seiten im Dateisystemcache, die eine Kopie der Daten vom Cache im Puffer der Anwendung erzeugen. Die Anwendung erhlt die Kontrolle sofort zurck, auch wenn auf den Datentrger zugegriffen werden muss, um die Seite wieder einzulesen.",

    "113",     "Der Prozentanteil von Cacheanforderungen zum Erzeugen einer lokalen Kopie im Puffer einer Anwendung, die ohne Lesen vom Datentrger ausgefhrt werden konnten. Der LAN Redirector verwendet diese Methode, um Cache-Informationen abzufragen. Der LAN Server verwendet sie fr kleinere bertragungen. Diese Methode wird auch vom Datentrgerdateisystem verwendet.",

    "115",     "Die Anzahl der Lesevorgnge im Dateisystemcache, die eine Speicherbeschreibungsliste (Memory Descriptor List) (MDL) verwenden, um auf die Daten zuzugreifen. Die MDL enthlt die reale Adresse jeder bertragenen Seite und kann verwendet werden, um mit einem DMA-Gert (Direct Memory Access) eine Kopie zu erstellen. Der LAN Server verwendet sie fr groe bertragungen vom Server.",

    "117",     "Die Anzahl der Lesevorgnge im Dateisystemcache, die eine Speicherbeschreibungsliste (Memory Descriptor List) (MDL) verwenden, um auf die Seiten zuzugreifen. Die MDL enthlt die reale Adresse jeder bertragenen Seite. Sie ermglicht so Direct Memory Zugriff (DMA) auf die Seiten. Falls die Seite(n), auf die zugegriffen werden soll, nicht im Arbeitsspeicher sind, wartet die aufrufende Anwendung, bis die Seiten vom Datentrger geladen sind.",

    "119",     "Die Anzahl der Lesevorgnge im Dateisystemcache, die eine Speicherbeschreibungsliste (Memory Descriptor List) (MDL) verwenden, um auf die Seiten zuzugreifen. Die MDL enthlt die reale Adresse jeder bertragenen Seite. Sie ermglicht so Direct Memory Zugriff (DMA) auf die Seiten. Falls die Seite(n), auf die zugegriffen werden soll, nicht im Arbeitsspeicher sind, wartet die aufrufende Anwendung nicht darauf, dass die Seiten vom Datentrger geladen werden.",

    "121",     "Der Prozentanteil von MDL-Leseanforderungen an den Dateisystemcache, die durch den Cache ausgefhrt werden, d.h. vom Datentrger wurde nicht gelesen, um Speicherzugriff auf die Seite im Cache zu ermglichen. ",

    "123",     "Die Anzahl der Lesevorgnge im Dateisystemcache, bei denen der Cache sequentiellen Zugriff auf eine Datei feststellt. Das Vorauslesen ermglicht ein bertragen von greren Datenblcken als von der Anwendung angefordert wurden, und dabei ein Reduzieren von Verwaltungsaufwand.",

    "125",     "Die Anzahl der Lesevorgnge im Dateisystemcache, die das installierte Dateisystem umgehen und die Daten direkt aus dem Cache abfragen. Normalerweise verwenden Datei-E/A-Anforderungen das entsprechende Dateisystem, um Daten aus einer Datei abzufragen, aber diese Methode erlaubt direkten Zugriff auf die Cachedaten ohne das Dateisystem einzubeziehen, wenn die Daten im Cache sind. Auch wenn die Daten nicht im Cache sind, ist ein Aufruf des Dateisystems weniger erforderlich.",

    "127",     "Die Anzahl der Lesevorgnge im Dateisystemcache, die das installierte Dateisystem umgehen und die Daten direkt aus dem Cache erhalten. Normalerweise verwenden Datei-E/A-Anforderungen das entsprechende Dateisystem, um Daten aus einer Datei abzufragen, aber diese Methode erlaubt direkten Zugriff auf die Cachedaten, ohne das Dateisystem einzubeziehen, wenn die Daten im Cache sind. Auch wenn die Daten nicht im Cache sind, wird eine Einbeziehung des Dateisystems vermieden. Wenn die Daten nicht im Cache sind, wartet die anfordernde Anwendung, bis die Daten vom Datentrger gelesen wurden.",

    "129",     "Die Anzahl der Lesevorgnge im Dateisystemcache, die das installierte Dateisystem umgehen und die Daten direkt aus dem Cache erhalten. Normalerweise verwenden Datei-E/A-Anforderungen das entsprechende Dateisystem, um Daten aus einer Datei zu abzufragen, aber diese Methode erlaubt direkten Zugriff auf die Cachedaten, ohne das Dateisystem einzubeziehen, wenn die Daten im Cache sind. Auch wenn die Daten nicht im Cache sind, wird eine Einbeziehung des Dateisystems vermieden. Wenn die Daten nicht im Cache sind, wartet die Anforderung nicht, bis die Daten vom Datentrger gelesen wurden, sondern erhlt sofort die Kontrolle zurck.",

    "131",     "Die Anzahl von Cachefehltreffern, die aufgrund von fr die Vollendung der Anforderung fehlenden Ressourcen entstanden sind.",

    "133",     "Die Anzahl der Versuche eines API-Funktionsaufrufes das Dateisystem zu umgehen, um Cachedaten abzufragen, die nicht erlangt werden konnten, ohne das Dateisystem mit einzubeziehen.",

    "135",     "Die Rate, mit der der Thread 'Verzgertes Schreiben' auf den Datentrger geschrieben hat. Es knnen mehrere Seiten whrend eines Schreibvorgangs bertragen werden.",

    "137",     "Die Rate, mit der der Thread 'Verzgertes Schreiben' auf den Datentrger geschrieben hat. Es knnen mehrere Seiten whrend eines einzelnen Schreibvorgangs auf den Datentrger bertragen werden.",

    "139",     "Die Rate, mit der der Inhalt des Dateisystemcache auf den Datentrger geschrieben wird, um als Reaktion auf eine Leerungsanforderung oder um eine Schreib-Fertig- Dateischreibanforderung zu erfllen. Whrend eines Leerungsvorgangs knnen mehrere Seiten bertragen werden.",

    "141",     "Die Anzahl an Seiten, die der Dateisystemcache auf den Datentrger geschrieben hat, um eine Leerungsanforderung oder um eine Schreib-Fertig-Dateischreibanforderung zu erfllen. Whrend eines Schreibvorgangs knnen mehrere Seiten bertragen werden.",

    "143",     "Die verstrichene Prozessorzeit im Benutzermodus in Prozent. Der Benutzermodus ist ein eingeschrnkter Modus fr Anwendungen, Umgebungsteilsysteme und fest zugehrige Teilsysteme. Alternativ dazu wurde der privilegierte Modus fr Betriebssystemkomponenten entwickelt und ermglicht direkten Zugriff auf Hardware und den gesamten Arbeitsspeicher. Das Betriebssystem schaltet Anwendungsthreads in den privilegierten Modus um, um auf Betriebssystemdienste zugreifen zu knnen. Der Indikator zeigt die durchschnittliche Auslastungszeit als Prozentwert der Stichprobenzeit an.",

    "145",     "Der Prozentanteil der verstrichenen Zeit fr Prozessthreads, die im privilegierten Modus ausgefhrt werden. Wenn ein Windows-Systemdienst aufgerufen wird, wird dieser oft im privilegierten Modus ausgefhrt, um Zugriff auf Systemdaten zu erhalten. Solche Daten sind vom Zugriff von Threads, die im Benutzermodus ausgefhrt werden, geschtzt. Systemaufrufe knnen explizit oder implizit sein, wie z.B. wenn ein Seitenfehler oder ein Interrupt auftritt. Im Gegensatz zu frheren Betriebssystemen verwendet Windows, zustzlich zum traditionellen Schutz des Benutzer- bzw. privilegierten Modus, Prozessgrenzen fr den Teilsystemschutz. Einige Arbeit, die im Auftrag einer Anwendung durchgefhrt wird, erscheint eventuell in anderen Teilsystemprozessen, zustzlich zur privilegierten Zeit des Prozesses. ",

    "147",     "Die Rate, mit der alle Prozessoren von einem Thread zum anderen umgeschaltet werden. Kontextwechsel treten auf, wenn ein ausgefhrter Thread den Prozessor freiwillig aufgibt, bzw. von einem Prozess hherer Prioritt verdrngt wurde oder vom Benutzer- in der Kernelmodus wechselt, um eine Exekutive oder einen Teilsystemdienst zu verwenden. Dies ist die Summe von Thread\\Kontextwechsel/s fr alle Threads, die auf allen Prozessoren des Computers ausgefhrt werden und wird in der Anzahl der Wechsel gemessen. Es gibt Kontextwechselindikatoren fr die Objekte 'System' und 'Thread'. Dieser Leistungsindikator zeigt die Differenz zwischen den Werten in den letzten beiden Abtastintervallen dividiert durch die Intervalldauer an. ",

    "149",     "Die durchschnittliche Rate, mit der der Prozessor Hardwareinterrupts pro Sekunde empfngt und bearbeitet. DPCs sind nicht enthalten, da diese separat gezhlt werden. Dieser Wert ist eine indirekte Anzeige der Aktivitten von Gerten, die Interrupts erzeugen, z.B. Systemuhr, Maus, Datentrgertreiber, Datenkommunikationsleitungen, Netzwerkschnittstellenkarten und andere Peripheriegerte. Diese Gerte erzeugen normalerweise einen Prozessorinterrupt, wenn sie einen Vorgang abgeschlossen haben oder ein Eingreifen erfordern.Die normale Threadausfhrung ist ausgesetzt. Die meisten Systemuhren erzeugen alle 10 Millisekunden einen Interrupt. Dieser Leistungsindikator zeigt die Differenz zwischen den Werten in den letzten beiden Abtastintervallen dividiert durch die Intervalldauer an.",

    "151",     "Die Rate an Aufrufen an Betriebssystem-Dienstroutinen aller auf dem Computer ausgefhrten Prozesse. Diese Routinen fhren alle einfachen Planungen und Synchronisationen von Aktivitten im System aus und ermglichen den Zugriff auf nichtgrafische Gerte, Speicherverwaltung und Namensplatzverwaltung. Dieser Leistungsindikator zeigt die Differenz zwischen den Werten in den letzten beiden Abtastintervallen dividiert durch die Intervalldauer an. ",

    "153",     "Die Frequenz von Fehlern, die auftreten, wenn auf Speicher verwiesen wird, dessen Seitentabelleneintrag (Page Table Entry, PTE) weder im bersetzungsnachschlagepuffer (Translation Lookaside Buffer (TLB)) ist, noch enthlt die Seite den Seitentabelleneintrag. Auf manchen Systemen wird dieser Fehler durch Software behandelt, die die PTE in den TLB ldt, und dieser Indikator wird erhht.",

    "155",     "Die Frequenz von Fehlern, die auftreten, wenn auf Speicher verwiesen wird, dessen Seitentabelleneintrag (Page Table Entry, PTE) weder im bersetzungsnachschlagepuffer , (Translation Lookaside Buffer (TLB)) ist, noch die Seite den PTE enthlt. Auf manchen Systemen wird dieser Fehler durch Software behandelt, die die PTE in den TLB ldt, und dieser Indikator wird erhht.",

    "157",     "Der Prozentanteil der verstrichenen Zeit fr Prozessthreads, die im Benutzermodus ausgefhrt werden. Anwendungen, Umgebungsteilsysteme und fest zugehrige Teilsysteme werden im Benutzermodus ausgefhrt. Code der im Benutzermodus ausgefhrt wird kann die Integritt der Windows-Exekutive, des Kernel, sowie von Gertetreibern nicht beschdigen. Im Gegensatz zu frheren Betriebssystemen verwendet Windows, zustzlich zum traditionellen Schutz des Benutzer- bzw. privilegierten Modus, Prozessgrenzen fr den Teilsystemschutz. Einige Arbeit, die im Auftrag einer Anwendung durchgefhrt wird, erscheint eventuell in anderen Teilsystemprozessen, zustzlich zur privilegierten Zeit des Prozesses.",

    "159",     "Der Prozentanteil der verstrichenen Zeit fr Prozessthreads, die im privilegierten Modus ausgefhrt werden. Wenn ein Windows-Systemdienst aufgerufen wird, wird dieser oft im privilegierten Modus ausgefhrt, um Zugriff auf Systemdaten zu erhalten. Solche Daten sind vom Zugriff von Threads, die im Benutzermodus ausgefhrt werden, geschtzt. Systemaufrufe knnen explizit oder implizit sein, wie z.B. wenn ein Seitenfehler oder ein Interrupt auftritt. Im Gegensatz zu frheren Betriebssystemen verwendet Windows, zustzlich zum traditionellen Schutz des Benutzer- bzw. privilegierten Modus, Prozessgrenzen fr den Teilsystemschutz. Einige Arbeit, die im Auftrag einer Anwendung durchgefhrt wird, erscheint eventuell in anderen Teilsystemprozessen, zustzlich zur privilegierten Zeit des Prozesses.",

    "161",     "Die Rate, mit der der Server-Suchanforderungen von dieser Arbeitsstation verarbeitet wurden.",

    "163",     "Die Rate, mit der Domnen-Suchanforderungen von dieser Arbeitsstation verarbeitet wurden.",

    "165",     "Die Rate, mit der von dieser Arbeitsstation verarbeiteten Suchanforderungen weder Domnen- noch Server-Suchanforderungen sind.",

    "167",     "Die Anzahl der Serverankndigungen, die aufgrund der Konfiguration oder Speicherbegrenzungen nicht erhalten wurden.",

    "169",     "Die Anzahl der Mailslot-Datagramme, die aufgrund von Konfigurations- oder Speicherbegrenzungen nicht bercksichtigt wurden.",

    "171",     "Die Anzahl der Anforderungen, eine Liste der von dieser Arbeitsstation empfangenen Such-Server zu laden, die nicht ausgefhrt werden konnten.",

    "173",     "Die maximale Gre in Bytes des virtuellen Adressraumes, den ein Prozess verwendet hat. Die Verwendung von virtuellem Adressraum bedeutet nicht unbedingt korrespondierende Verwendung von Datentrger- oder Arbeitsspeicherseiten. Virtueller Speicherplatz ist begrenzt und es knnen mglicherweise keine Bibliotheken geladen werden.",

    "175",     "Die aktuelle Gre des virtuellen Adressraums in Bytes, den der Prozess verwendet. Die Verwendung von virtuellem Adressraum bedeutet nicht unbedingt korrespondierende Verwendung von Datentrger- oder Arbeitsspeicherseiten. Virtueller Speicherplatz ist begrenzt und es knnen mglicherweise keine Bibliotheken geladen werden.",

    "177",     "Die Rate, mit der Seitenfehler in den Threads auftreten, die in diesem Prozess ausgefhrt werden. Ein Seitenfehler tritt auf, wenn ein Thread zu einer virtuellen Speicherseite verweist, die nicht in seinen Arbeitsseiten im Hauptspeicher ist. Ein Seitenfehler verursacht nicht, dass die Seite vom Datentrger geladen wird, wenn diese Seite auf der Standby-Liste und daher bereits im Arbeitsspeicher ist, oder die Seite von einem anderem Prozess verwendet, mit dem sie geteilt wird.",

    "179",     "Die maximale Gre der Arbeitsseiten des Prozesses in Bytes zu einem beliebigen Zeitpunkt. Arbeitsseiten sind ein Satz von Speicherseiten die vor kurzem von den Threads eines Prozesses verwendet wurden. Wenn der freie Speicher des Computers oberhalb der Schwellenwerts ist, sind Seiten in den Arbeitsseiten eines Prozesses brig, auch wenn sie nicht verwendet werden. Wenn der freie Speicher unterhalb den Schwellenwert fllt, werden Seiten aus den Arbeitsseiten entfernt.",

    "181",     "Die aktuelle Gre der Arbeitsseiten des Prozesses in Bytes. Arbeitsseiten sind ein Satz von Speicherseiten die vor kurzem von den Threads eines Prozesses verwendet wurden. Wenn der freie Speicher des Computers oberhalb der Schwellenwerts ist, sind Seiten in den Arbeitsseiten eines Prozesses brig, auch wenn sie nicht verwendet werden. Wenn der freie Speicher unterhalb den Schwellenwert fllt, werden Seiten aus den Arbeitsseiten entfernt.",

    "183",     "Die maximale Anzahl der Bytes, die der Prozess in der Auslagerungsdatei verwendet hat. Die Auslagerungsdatei wird verwendet, um Speicherseiten, die vom Prozess verwendet werden, zu speichern, die in anderen Dateien nicht enthalten sind. Die Auslagerungsdatei wird von allen Prozessen verwendet, und eine zu kleine Auslagerungsdatei kann die fehlerfreie Ausfhrung von anderen Prozessen unmglich machen.",

    "185",     "Die aktuelle Menge an virtuellen Speicher in Bytes, der fr die Verwendung in der Auslagerungsdatei reserviert wurde. Die Auslagerungsdatei wird verwendet, um Speicherseiten, die vom Prozess verwendet werden, zu speichern, die in anderen Dateien nicht enthalten sind. Die Auslagerungsdatei wird von allen Prozessen verwendet, und eine zu kleine Auslagerungsdatei kann die Speicherzuweisung von anderen Prozessen verhindern. Sollte keine Auslagerungsdatei vorhanden sein, zeigt der Leistungsindikator den aktuellen virtuellen Speicher an, der vom Prozess fr den physikalischen Speicher reserviert hat.",

    "187",     "Die aktuelle Gre (in Bytes) von Speicher, der vom Prozess reserviert wurde und nicht mit anderen Prozessen geteilt werden kann.",

    "189",     "Der Prozentanteil der verstrichenen Zeit, in der alle Threads eines Prozesses den Prozessor verwendet haben, um Anweisungen auszufhren. Eine Anweisung ist die kleinste Befehlsausfhrungseinheit eines Computers, ein Thread ist das Objekt, durch das die Anweisungen ausgefhrt werden und ein Prozess ist das Objekt, das erzeugt wird, wenn ein Programm ausgefhrt wird. Code, der ausgefhrt wird, um bestimmte Hardwareinterrupts oder Trapbedinungen zu verarbeiten, wird gegebenenfalls auch gezhlt.",

    "191",     "Der Prozentanteil der verstrichenen Zeit, in der alle Threads eines Prozesses den Prozessor verwendet haben, um Anweisungen auszufhren. Eine Anweisung ist die kleinste Befehlsausfhrungseinheit eines Computers, ein Thread ist das Objekt, durch das die Anweisungen ausgefhrt werden und ein Prozess ist das Objekt, das erzeugt wird, wenn ein Programm ausgefhrt wird. Code, der ausgefhrt wird, um bestimmte Hardwareinterrupts oder Trapbedinungen zu verarbeiten, wird gegebenenfalls auch gezhlt.",

    "193",     "Der Prozentanteil der verstrichenen Zeit, die dieser Thread im Benutzermodus ausgefhrt wurde. Anwendungen, Umgebungsteilsysteme und fest zugehrige Teilsysteme werden im Benutzermodus ausgefhrt. Code der im Benutzermodus ausgefhrt wird kann die Integritt der Windows-Exekutive, des Kernel, sowie von Gertetreibern nicht beschdigen. Im Gegensatz zu frheren Betriebssystemen verwendet Windows, zustzlich zum traditionellen Schutz des Benutzer- bzw. privilegierten Modus, Prozessgrenzen fr den Teilsystemschutz. Dieses Teilsystem bietet zustzlichen Schutz. Daher erscheint einige Arbeit, die im Auftrag einer Anwendung durchgefhrt wird, eventuell in anderen Teilsystemprozessen, zustzlich zur privilegierten Zeit des Prozesses.",

    "195",     "Der Prozentanteil der verstrichenen Zeit fr Prozessthreads, die im privilegierten Modus ausgefhrt werden. Wenn ein Windows-Systemdienst aufgerufen wird, wird dieser oft im privilegierten Modus ausgefhrt, um Zugriff auf Systemdaten zu erhalten. Solche Daten sind vom Zugriff von Threads, die im Benutzermodus ausgefhrt werden, geschtzt. Systemaufrufe knnen explizit oder implizit sein, wie z.B. wenn ein Seitenfehler oder ein Interrupt auftritt. Im Gegensatz zu frheren Betriebssystemen verwendet Windows, zustzlich zum traditionellen Schutz des Benutzer- bzw. privilegierten Modus, Prozessgrenzen fr den Teilsystemschutz. Einige Arbeit, die im Auftrag einer Anwendung durchgefhrt wird, erscheint eventuell in anderen Teilsystemprozessen, zustzlich zur privilegierten Zeit des Prozesses.",

    "197",     "Die Rate der nderungen von einem Thread zum anderem. Threadnderungen knnen innerhalb eines einzelnen Prozesses oder zwischen Prozessen auftreten. Eine Threadnderung kann durch die Anfrage nach Informationen von einem Thread an einen anderen, oder durch das Verdrngen eines Threads durch einen anderen, der hhere Prioritt hat, verursacht werden.",

    "199",     "Die Anzahl der ausstehenden Anforderungen auf dem Datentrger, zum Zeitpunkt als die Leistungsdaten gesammelt wurden. Dies enthlt auch die gerade ausgefhrten Anforderungen. Es handelt sich dabei um einen Schnappschuss zu einem bestimmten Zeitpunkt und keinen Durchschnittswert ber ein Zeitintervall. Multispindle-Datentrgergerte knnen mehrere gleichzeitig aktive Anforderungen haben, wobei andere gleichlaufende Anforderungen in der Warteschlange sind. Dieser Leistungsindikator kann eine vorbergehend niedrig bzw. hoch ausgelastete Warteschlange reflektieren, wenn jedoch eine lang anhaltende Last auf dem Datentrgerlaufwerk liegt, ist es wahrscheinlich, das er konstant hoch ist. Anforderungen erwarten Verzgerungen entsprechend der Lnge der Warteschlange minus der Anzahl an Spindles auf dem Datentrger. Diese Differenz sollte im Durchschnitt kleiner als 2 sein, um eine gute Leistung zu erzielen.",

    "201",     "Der Prozentanteil der verstrichenen Zeit, die das ausgewhlte Laufwerk mit dem Bearbeiten von Lese- und Schreibanforderungen beschftigt war.",

    "203",     "Der Prozentanteil der verstrichenen Zeit, die das ausgewhlte Laufwerk mit dem Bearbeiten von Leseanforderungen beschftigt war.",

    "205",     "Der Prozentanteil der verstrichenen Zeit, die das ausgewhlte Laufwerk mit dem Bearbeiten von Schreibanforderungen beschftigt war.",

    "207",     "Die Zeitdauer in Sekunden fr eine durchschnittliche Datentrgerbertragung.",

    "209",     "Die durchschnittliche Zeitdauer in Sekunden fr das Lesen von Daten auf dem Datentrger.",

    "211",     "Die durchschnittliche Zeitdauer in Sekunden fr das Schreiben von Daten auf den Datentrger.",

    "213",     "Die Rate von Lese- und Schreibvorgngen auf dem Datentrger.",

    "215",     "Die Rate von Lesevorgngen auf dem Datentrger.",

    "217",     "Die Rate von Schreibvorgngen auf dem Datentrger.",

    "219",     "Die Rate, mit der Bytes whrend Schreib- oder Lesevorgngen vom oder auf den Datentrger bertragen werden.",

    "221",     "Die Rate, mit der Bytes whrend Lesevorgngen vom Datentrger bertragen werden.",

    "223",     "Die Rate, mit der Bytes whrend Schreibvorgngen auf den Datentrger bertragen werden.",

    "225",     "Die durchschnittliche Anzahl der Bytes, die whrend Lese- oder Schreibvorgngen vom oder auf den Datentrger bertragen wurden.",

    "227",     "Die durchschnittliche Anzahl der Bytes, die whrend Lesevorgngen vom Datentrger bertragen wurden.",

    "229",     "Die durchschnittliche Anzahl der Bytes, die whrend Schreibvorgngen auf den Datentrger bertragen wurden.",

    "231",     "Leistungsindikatoren, die Programme und Systemprozesse berwachen. Alle Threads in einem Prozess teilen den gleichen Adressraum und haben Zugriff auf die gleichen Daten.",

    "233",     "Leistungsindikatoren, die Aspekte des Threadverhaltens messen. Ein Thread ist das Basisobjekt, das Anweisungen auf einem Prozessor ausfhrt. Jeder ausgefhrte Prozess besteht aus mindestens einem Thread.",

    "235",     "Leistungsindikatoren, die das Festplattenlaufwerk berwachen. Datentrger werden verwendet, um Dateien, Programme und Auslagerungsdaten zu speichern. Ein Datentrger wird gelesen, um Daten abzufragen, und beschrieben, um nderungen festzuhalten.",

    "237",     "Leistungsindikatoren, die logische Partitionen von Festplattenlaufwerken berwachen. Logische Datentrger sind durch Laufwerkbuchstaben, z.B. C, gekennzeichnet.",

    "239",     "Leistungsindikatoren, die Aspekte der Prozessoraktivitt messen. Ein Prozessor ist der Teil des Systems, der arithmetische und logische Berechnungen ausfhrt und Vorgnge auf Peripheriegerten initialisiert. Er fhrt Programme im System aus. Ein Computer kann mehrere Prozessoren besitzen.",

    "241",     "Die durchschnittliche Zeitdauer in Prozent, in der alle Prozessoren damit beschftigt sind, Non-Idle-Threads auszufhren. Auf einem Multiprozessor-System, wenn alle Prozessoren immer ausgelastet sind, ist dieser Wert 100%; wenn alle Prozessoren zu einem Viertel ausgelastet sind, ist dieser Wert 25%. Der Wert kann als Anteil der Zeit angesehen werden, die verwendet wird, um sinnvolle Aufgaben durchzufhren. ",

    "243",     "Die Zeitdauer, in der sich alle Prozessoren im Benutzermodus befinden, in Prozent. Auf einem Multi-Prozessor-System, wenn alle Prozessoren immer ausgelastet sind, ist dieser Wert 100%; wenn alle Prozessoren zu einem Viertel ausgelastet sind, ist dieser Wert 25%. Alle Anwendungen und Teilsysteme werden im Benutzermodus ausgefhrt. Grafische Effekte, grafische Gertetreiber, Druckertreiber und die Fensterverwaltung werden ebenfalls im Benutzermodus ausgefhrt. Code, der im Benutzermodus ausgefhrt wird, kann die Systemintegritt nicht verletzen. Im Gegensatz zu frheren Betriebssystemen verwendet Windows NT neben der normalen Trennung zwischen Benutzer- und Protected Modus die Prozessabgrenzung, um Teilsysteme zu schtzen. ",

    "245",     "Die Zeitdauer, in der sich alle Prozessoren im Benutzermodus befinden, in Prozent. Auf einem Multi-Prozessor-System, wenn alle Prozessoren immer ausgelastet sind, ist dieser Wert 100%; wenn alle Prozessoren zu einem Viertel ausgelastet sind, ist dieser Wert 25%. Alle Anwendungen und Teilsysteme werden im Benutzermodus ausgefhrt. Grafische Effekte, grafische Gertetreiber, Druckertreiber und die Fensterverwaltung werden ebenfalls im Benutzermodus ausgefhrt. Code, der im Benutzermodus ausgefhrt wird, kann die Systemintegritt nicht verletzen. Im Gegensatz zu frheren Betriebssystemen verwendet Windows NT neben der normalen Trennung zwischen Benutzer- und Protected Modus die Prozessabgrenzung, um Teilsysteme zu schtzen. ",

    "247",     "Die Rate, mit der Hardwareinterrupts von allen Prozessoren empfangen und bearbeitet werden. DPCs sind nicht enthalten, das diese separat gezhlt werden. Dieser Wert ist ein indirekter Indikator der Aktivitt von Gerten, die Interrupts generieren, z.B. Systemzeitgeber, Maus, Treiber, Netzwerkkarten und andere Peripheriegerte. Diese Gerte erzeugen normalerweise einen Prozessorinterrupt, wenn sie einen Vorgang abgeschlossen haben oder ein Eingreifen erfordern. Die normale Threadausfhrung wird whrend den Interrupts angehalten. Die meisten Systemuhren erzeugen alle 10 Millisekunden einen Interrupt. Dieser Leistungsindikator zeigt die Differenz zwischen den Werten in den letzten beiden Abtastintervallen dividiert durch die Intervalldauer an. ",

    "249",     "Die Anzahl der Prozesse in einem System zur Zeit des Datensammelns. Dies ist ein unmittelbarer Indikator, kein Durchschnitt ber ein Zeitintervall. Jeder Prozess stellt das Ausfhren eines Programms dar.",

    "251",     "Die Anzahl der Threads in einem System zur Zeit des Datensammelns.Dies ist ein unmittelbarer Indikator, kein Durchschnitt ber ein Zeitintervall. Ein Thread ist die Basiseinheit, die Anweisungen in einem Prozessor ausfhren kann.",

    "253",     "Die Anzahl der Ereignisse im System zur Zeit des Datensammelns. Dies ist ein unmittelbarer Indikator, kein Durchschnitt ber ein Zeitintervall. Ein Ereignis wird verwendet, wenn zwei oder mehrere Threads die Ausfhrung synchronisieren.",

    "255",     "Die Anzahl der Semaphoren im System zur Zeit des Datensammelns.Dies ist ein unmittelbarer Indikator, kein Durchschnitt ber ein Zeitintervall. Threads verwenden Semaphoren, um exklusiven Zugriff auf Datenstrukturen zu haben, die sie mit anderen Threads teilen.",

    "257",     "Die Anzahl der Mutex im System zur Zeit des Datensammelns. Dies ist ein unmittelbarer Indikator, kein Durchschnitt ber ein Zeitintervall. Mutex werden von Threads verwendet, um sicherzustellen, dass nur ein Thread einen bestimmten Abschnitt von Code ausfhrt.",

    "259",     "Die Anzahl der Abschnitte im System zur Zeit des Datensammelns. Dies ist ein unmittelbarer Indikator ist, kein Durchschnitt ber ein Zeitintervall. Ein Abschnitt ist ein Teil des virtuellen Speichers, der von einem Prozess erzeugt wird, um Daten zu speichern. Ein Prozess kann Abschnitte mit anderen Prozessen teilen.",

    "261",     "Leistungsindikatoren, die die logischen Objekte im System, z.B. Prozesse und Threads, berwachen. Diese Informationen knnen verwendet werden, um unntigen Verbrauch von Systemressourcen zu entdecken. Jedes Objekt bentigt Speicher, um grundlegende Informationen ber das Objekt zu speichern.",

    "263",     "Leistungsindikatoren, die die Netzwerkverbindungen auf dem lokalen Computer berwachen.",

    "265",     "Die Rate der ber den Redirector vom Netzwerk eingehenden Bytes. Es sind alle Anwendungsdaten und Netzwerkprotokollinformationen (z.B. Paketvorspnne) enthalten.",

    "267",     "Die Rate, mit der der Redirector Pakete erhlt (auch SMBs bzw. Server Message Blocks genannt). Netzwerkbertragungen werden in Pakete aufgeteilt. Die durchschnittliche Anzahl der empfangenen Bytes pro Paket kann angegeben werden, indem die pro Sekunde empfangenen Bytes durch diesen Wert dividiert werden. Einige der empfangenen Pakete enthalten keine eingehenden Daten; z.B. wrde eine Schreibbesttigung zum Redirector als eingehendes Paket zhlen.",

    "269",     "Die Anzahl der Versuche des Redirectors, Bytes zu lesen, um auf einen Seitenfehler zu reagieren. Seitenfehler werden durch das Laden von Modulen (z.B. Programmen und Bibliotheken), durch einen Fehltreffer im Cache oder durch Dateien, die direkt in den Adressraum von Anwendungen zugeordnet sind, verursacht.",

    "271",     "Die Bytes, die vom Redirector aufgrund einer normalen Dateianforderung der Anwendung gelesen werden, die von einem anderen Computer umgeleitet sind. Zustzlich zu Dateianforderungen beinhaltet dieser Indikator andere Methoden von Lesevorgngen auf dem Netzwerk, z.B. Named Pipes und bertragungen. Dieser Indikator zhlt keine Netzwerkprotokollinformationen, sondern nur Anwendungsdaten.",

    "273",     "Die Rate, mit der Anwendungen mit dem Redirector auf den Dateisystemcache zugreifen. Einige dieser Datenanforderungen werden durch Abfragen der Daten aus dem Cache ausgefhrt. Anforderungen, die nicht vom Cache ausgefhrt werden, verursachen einen Seitenfehler.",

    "275",     "Die Rate, mit der Anwendungen Daten ber das Netzwerk lesen, wenn Daten nicht im Dateisystemcache enthalten sind und ber das Netzwerk abgefragt werden mssen. Wenn dieser Wert durch die pro Sekunde empfangenen Bytes diviert wird, wird das Verhltnis der Anwendungsdaten im Netzwerk angegeben.",

    "277",     "Die Rate, mit der Bytes ber den Redirector zum Netzwerk gesendet werden. Es sind alle Anwendungsdaten und Netzwerkprotokollinformationen (z.B. Paketvorspnne) enthalten.",

    "279",     "Die Rate, mit der der Redirector Pakete sendet (auch SMBs bzw. Server Message Blocks genannt). Netzwerkbertragungen werden in Pakete aufgeteilt. Die durchschnittliche Anzahl der bertragenen Bytes pro Paket kann erhalten werden, indem die pro Sekunde empfangene Bytes durch diesen Wert dividiert werden.",

    "281",     "Die Rate, mit der der Redirector versucht, genderte Bytes in Seiten zu schreiben, die von Anwendungen verwendet werden. Die von Modulen (z.B. Programmen und Bibliotheken) genderten Programmdaten, die ber das Netzwerk geladen wurden, werden ausgelagert, wenn sie nicht mehr verwendet werden. Andere Ausgabeseiten stammen vom Dateisystemcache.",

    "283",     "Die Rate, mit der Bytes vom Redirector geschrieben werden, als Reaktion auf normale Dateiausgaben von Anwendungen, die von einem anderem Computer umgeleitet sind. Zustzlich zu Dateianforderungen beinhaltet dieser Indikator andere Methoden von Lesevorgngen auf dem Netzwerk, z.B. Named Pipes und bertragungen. Dieser Indikator zhlt keine Netzwerkprotokollinformationen, sondern nur Anwendungsdaten.",

    "285",     "Die Rate, mit der Anwendungen mit dem Redirector in den Dateisystemcache schreiben. Die Daten werden mglicherweise nicht sofort gelscht, sondern knnen fr weitere nderungen im Cache verbleiben, bevor sie zum Netzwerk geschrieben werden. Jedes in den Cache geschriebene Byte wird hier gezhlt.",

    "287",     "Die Rate, mit der Anwendungen Daten ber das Netzwerk schreiben, wenn der Dateisystemcache umgangen wurde, z.B. fr Named Pipes oder bertragungen, oder der Cache die Bytes auf den Datentrger schreibt, um Speicherplatz freizugeben. Wenn dieser Wert durch die pro Sekunden erhaltenen Bytes dividiert wird, wird das Verhltnis der Anwendungsdaten zum Netzwerk angegeben.",

    "289",     "Die Rate, mit der Anwendungen den Redirector nach Daten fragen. Jeder Aufruf eines Dateisystems oder hnliche API-Aufrufe zhlen als ein Vorgang.",

    "291",     "Zeigt an, wie oft nicht sequentielle Lesevorgnge auf Dateibasis ausgefhrt werden. Wenn ein Lesevorgang unter Verwendung einer bestimmten Dateizugriffsnummer ausgefhrt wird und dann von einem anderen gefolgt wird, der nicht das nchste Byte liest, wird dieser Indikator um Eins erhht.",

    "293",     "Die Rate, mit der Lesevorgnge auf das Netzwerk zugreifen. Jedesmal wenn ein einzelnes Paket mit der Anforderung, die Daten fernzulesen, abgeschickt wurde, wird dieser Indikator um Eins erhht.",

    "295",     "Zeigt an, wie oft Lesevorgnge, die von Anwendungen ausgefhrt wurden, doppelt so gro wie der Serverpuffer sind. Ein groer Wert kann starke Belastung der Serverressourcen bedeuten. Dieser Indikator wird fr jeden Lesevorgang erhht. Pakete werden nicht gezhlt.",

    "297",     "Zeigt an, wie oft Lesevorgnge, die von Anwendungen ausgefhrt wurden, ein Viertel der Gre des Serverpuffers nicht berschreiten. Ein groer Wert kann Verschwendung von Ressourcen anzeigen. Dieser Indikator wird fr jeden Lesevorgang erhht. Pakete werden nicht gezhlt.",

    "299",     "Zeigt an, wie oft Anwendungen Daten an den Redirector senden. Jeder Aufruf eines Dateisystems oder hnliche API-Aufrufe zhlen als ein Vorgang.",

    "301",     "Zeigt an, wie oft nicht sequentielle Schreibvorgnge auf Dateibasis ausgefhrt werden. Wenn ber eine bestimmte Dateizugriffsnummer geschrieben wird und darauf ein Schreibvorgang folgt, der nicht die unmittelbar folgenden Bytes schreibt, wird dieser Indikator um Eins erhht.",

    "303",     "Zeigt an, wie oft Schreibvorgnge ber das Netzwerk gesendet werden. Bei jedem gesendeten Paket, das eine Anforderung zum Schreiben von Remotedaten enthlt, wird dieser Indikator um Eins erhht.",

    "305",     "Zeigt an, wie oft Anwendungen Schreibvorgnge ausfhren, die mehr als doppelt so gro wie die eingestellte Puffergre des Servers sind. Wenn dies zu oft vorkommt, knnen die Ressourcen des Servers zu sehr beansprucht werden. Dieser Indikator wird bei jedem entsprechenden Schreibvorgang erhht (d.h. er zhlt Schreibvorgnge und keine Pakete).",

    "307",     "Zeigt an, wie oft Anwendungen Schreibvorgnge ausfhren, deren Gre weniger als ein Viertel der eingestellten Puffergre des Servers betrgt. Wenn dieser Wert zu hoch ist, kann das anzeigen, dass Puffer auf dem Server verschwendet werden. Dieser Zhler wird bei jedem entsprechenden Schreibvorgang erhht (d.h. er zhlt Schreibvorgnge und keine Pakete).",

    "309",     "Zeigt an, wie oft der Server Anforderungen fr unaufbereitete Lesevorgnge nicht ausfhren kann. Wenn eine Leseanforderung viel grer als die eingestellte Puffergre des Servers ist, fordert der Redirector einen unaufbereiteten Lesevorgang an, der (falls er ausgefhrt werden kann) die bertragung der Daten ohne groen Protokollaufwand fr jedes Paket ermglicht. Dazu muss der Server andere Anforderungen sperren, so dass evtl. Anforderungen verweigert werden, wenn der Server stark ausgelastet ist.",

    "311",     "Zeigt an, wie oft der Server Anforderungen fr unaufbereitete Schreibvorgnge nicht bearbeiten kann. Wenn eine Schreibanforderung viel grer als die eingestellte Puffergre des Servers ist, fordert der Redirector einen unaufbereiteten Schreibvorgang an, der (falls er ausgefhrt werden kann) die bertragung der Daten ohne groen Protokollaufwand fr jedes Paket ermglicht. Dazu muss der Server andere Anforderungen sperren, so dass evtl. Anforderungen verweigert werden, wenn der Server stark ausgelastet ist.",

    "313",     "Die Rate zu der schwere, unerwartete Netzwerkfehler auftreten. Diese Fehler deuten im allgemeinen darauf hin, dass der Redirector Kommunikationsprobleme mit einem oder mehreren Servern hat. Ein SMB-Protokollfehler (Server Manager Block) ist z.B. ein Netzwerkfehler. Weitere Informationen finden Sie im Systemereignisprotokoll.",

    "315",     "Gibt die Anzahl der Sicherheitsobjekte an, die der Redirector verwaltet hat. Eine Anmeldung an einem Server, gefolgt von einem Netzwerkzugriff auf den gleichen Server fhrt z. B. zu einer Verbindung, aber zu zwei Sitzungen.",

    "317",     "Gibt an, wie oft der Redirector die Verbindung zu einem Server wiederherstellen musste, um eine neue aktive Anforderung auszufhren. Wenn die Verbindung zu lange inaktiv ist, kann sie getrennt werden. Der Redirector hlt die Verbindungen jedoch fr ca. zehn Minuten aufrecht, auch wenn alle Remotedateien geschlossen wurden. Das erneute Verbinden kann einige Zeit in Anspruch nehmen.",

    "319",     "Gibt die Anzahl der Verbindungen zu Servern an, die das ursprngliche MS-Net SMB-Protokoll verwenden (einschlielich MS-Net sowie Xenix- und Vax-Verbindungen).",

    "321",     "Gibt die Anzahl der Verbindungen zu LAN Manager 2.0-Servern (einschlielich LMX-Servern) an.",

    "323",     "Gibt die Anzahl der Verbindungen zu LAN Manager 2.1-Servern (einschlielich LMX-Servern) an.",

    "325",     "Gibt die Anzahl der Verbindungen mit Windows 2000 bzw. Systemen frherer Versionen an.",

    "327",     "Gibt an, wie oft ein Server den Redirector getrennt hat (siehe auch 'Erneute Serververbindungen').",

    "329",     "Gibt die Anzahl der aktiven Sitzungen mit Zeitberschreitungen an, die nicht fortgesetzt werden knnen, da der Remoteserver nicht antwortet.",

    "331",     "Leistungsindikatoren, die die Kommunikation zwischen dem lokalen Computer und dem Netzwerk messen.",

    "333",     "Die Anzahl der Bytes, die der Server vom Netzwerk empfangen hat. Zeigt die Auslastung des Servers an.",

    "335",     "Die Anzahl der Bytes, die der Server an das Netzwerk gesendet hat. Zeigt die Auslastung des Servers an.",

    "337",     "Zeigt an, wenn sich ein Thread im Wartezustand befindet (siehe Threadstatus). 0-7: wartet auf die Ausfhrung, 1 oder 8: wartet auf eine freie Seite, 2 oder 9: wartet auf ein Page In, 3 oder 10: wartet auf Poolreservierung, 4 oder 11: wartet auf eine Ausfhrungsverzgerung, 5 oder 12: wartet auf eine Unterbrechung, 6 oder 13: wartet auf eine Benutzeranforderung, 14: wartet auf Event Pair High, 15: wartet auf Event Pair Low, 16: wartet auf einen LPC-Empfang, 17: wartet auf eine LPC-Antwort, 18: wartet auf virtuellen Speicher, 19: wartet auf ein Page Out.",

    "339",     "Prozentuale Angabe der Prozessorzeit zum Empfangen und Bearbeiten von DPCs ('Deferred Procedure Calls') whrend des Abtastintervalls. DPCs sind Interrupts, die mit niedrigerer Prioritt als Standardinterrupts ausgefhrt werden. DPCs werden im priviligierten Modus ausgefhrt. Sie werden einzeln gezhlt und sind keine Komponenten von Interruptindikatoren. Dieser Indikator zeigt die durchschnittliche Auslastung in Prozent an. ",

    "341",     "Die Anzahl der Sitzungen, die geschlossen wurden, da ihre Leerlaufzeit den Parameter fr den automatischen Abbruch berstiegen hat. Dieser Wert zeigt an, ob durch die Einstellung fr den automatischen Abbruch Ressourcen gespart werden.",

    "343",     "Die Anzahl der Sitzungen, die wegen unerwarteter Fehler geschlossen wurden, oder das Zeitlimit erreicht und normal getrennt wurden.",

    "345",     "Die Anzahl der Sitzungen, die normal beendet wurden. Dieser Wert ist bei der Interpretation der Statistiken 'Sitzungen mit Zeitberschreitung' und 'Sitzungen mit zu vielen Fehlern' ntzlich und ermglicht prozentuale Berechnungen.",

    "347",     "Die Anzahl der Sitzungen, deren Trennung erzwungen wurde. Dieser Wert kann anzeigen, wie viele Sitzungen wegen Einschrnkungen der Anmeldezeit getrennt wurden.",

    "349",     "Die Anzahl fehlgeschlagenen Anmeldeversuche am Server. Dieser Wert kann anzeigen, ob ein Programm zum Ermitteln von Kennwrtern verwendet wurde, um die Sicherheit des Servers zu verletzen.",

    "351",     "Die Anzahl der Dateiffnungsversuche fr Clients, die mit STATUS_ACCESS_DENIED fehlschlugen. Dieser Wert kann anzeigen, ob ein Benutzer versucht, auf nicht geschtzte Daten zuzugreifen.",

    "353",     "Die Anzahl verweigerter Zugriffe auf erfolgreich geffnete Dateien. Dieser Wert zeigt Zugriffsversuche auf Dateien an, die ohne die richtige Autorisierung ausgefhrt wurden.",

    "355",     "Die Anzahl gefundener interner Serverfehler. Unerwartete Fehler zeigen im allgemeinen Serverprobleme an.",

    "357",     "Die Anzahl der Sperr-SMBs, die abgelehnt wurden, da nicht gengend Arbeitselemente verfgbar sind. Dieser Wert zeigt an, ob der Server-Parameter 'MaxWorkItem' oder 'MinFreeWorkItems' anders eingestellt werden sollte.",

    "359",     "Gibt an, wie oft STATUS_DATA_NOT_ACCEPTED zur Empfangsanzeigezeit zurckgegeben wurde. Dies tritt auf, wenn kein Arbeitselement verfgbar ist oder zum Verarbeiten der eingehenden Anforderung zugeordnet werden kann. Der Wert zeigt an, ob der Parameter 'InitWorkItems' oder 'MaxWorkItems' anders eingestellt werden sollte.",

    "361",     "Die Anzahl erfolgreicher ffnungsversuche, die ein Server fr Clients ausgefhrt hat. Dieser Wert kann helfen, den Umfang der Datei-E/A, den Verwaltungsaufwand pfadbasierter Vorgnge und die Effektivitt von Sperrungen zu ermitteln.",

    "363",     "Die Anzahl der auf dem Server geffneten Dateien. Zeigt die aktuelle Serveraktivitt an.",

    "365",     "Die Anzahl der aktiven Sitzungen auf dem Server. Zeigt die aktuelle Serveraktivitt an.",

    "367",     "Die Anzahl der aktiven Suchvorgnge auf dem Server. Zeigt die aktuelle Serveraktivitt an.",

    "369",     "Die Gre des auslagerungsfhigen Speichers, der vom Server belegt wird, in Bytes. Dieser Wert ist beim Festlegen der Werte fr den Eintrag 'MaxNonpagedMemoryUsage' in der Windows NT-Registrierung ntzlich.",

    "371",     "Die Anzahl fehlgeschlagener Zuordnungen von Nicht-Auslagerungsspeicher. Zeigt an, dass der physikalische Speicher des Computers zu klein ist.",

    "373",     "Die Gre des Nicht-Auslagerungsspeichers, der vom Server belegt wurde, in Bytes. Zeigt den physikalischen Speicher an, den der Computer haben sollte.",

    "375",     "Die Gre des auslagerungsfhigen Speichers, der vom Server belegt wird, in Bytes. Dies kann beim Festlegen richtiger Werte fr den Parameter 'MaxPagedMemoryUsage' helfen.",

    "377",     "Die Anzahl fehlgeschlagener Zuordnungen von Auslagerungsspeicher. Zeigt an, dass der physikalische Speicher oder die Auslagerungsdatei zu klein ist.",

    "379",     "Die maximale Gre des Auslagerungsspeichers, den der Server zugeordnet hat in Bytes. Gibt die richtigen Gren der Auslagerungsdatei(en) und des physikalischen Speichers an.",

    "381",     "Die Rate, mit der Serverankndigungen (oder Domnenankndigungen) fehlgeschlagen sind, da nicht gengend Speicherplatz verfgbar ist.",

    "383",     "Zeigt an, wie oft beim Versuch des Datagramm-Empfngers, Pufferspeicher fr einen Schreibzugriff auf einen Benutzer-Mailslot zuzuordnen, ein Fehler auftritt.",

    "385",     "Die Anzahl der Mailslot-Nachrichten, die aufgrund von bertragungsfehlern nicht empfangen werden konnten.",

    "387",     "Die gesamte Anzahl der Mailslot-Nachrichten, die erfolgreich empfangen wurden, aber nicht in den Mailslot geschrieben werden konnten.",

    "389",     "Die Rate, mit der der Redirector Datenbytes verarbeitet; alle Anwendungs- und Dateidaten zustzlich zu Protokollinformationen, z.B. einem Paketvorspann.",

    "391",     "Die Rate, mit der der Redirector Datenvorgnge verarbeitet. Ein Vorgang sollte viele Bytes enthalten, da jeder Vorgang einen Zuschlag enthlt. Die Effizienz dieses Pfads kann ermittelt werden, indem die Bytes/s dieses Indikators durch die Anzahl der durchschnittlich bertragenen Bytes dividiert wird.",

    "393",     "Die Anzahl der Anforderungen an den Redirector, die in der Warteschlange auf die Verarbeitung warten. Wenn diese Anzahl viel grer als die Anzahl der im Computer installierten Netzwerkkarten ist, wird der Zugriff auf die Netzwerke und/oder die Server, verzgert.",

    "395",     "Die Anzahl der Bytes, die der Server ans Netzwerk gesendet und vom Netzwerk empfangen hat. Dieser Wert zeigt die Serverauslastung an.",

    "397",     "Prozentuale Angabe fr die Zeit, die der Prozessor fr das Empfangen und Verarbeiten von Hardwareinterrupts, whrend eines Abtastintervalls verbraucht hat. Dieser Wert ist eine indirekte Anzeige der Aktivitten von Gerten, die Interrupts erzeugen, z.B. Systemuhr, Maus, Datentrgertreiber, Datenkommunikationsleitungen, Netzwerkschnittstellenkarten und andere Peripheriegerte. Diese Gerte erzeugen normalerweise einen Prozessorinterrupt, wenn sie einen Vorgang abgeschlossen haben oder ein Eingreifen erfordern. Die normale Threadausfhrung wird whrend des Interrupts ausgesetzt. Die meisten Systemuhren erzeugen alle 10 Millisekunden einen Interrupt. Dieser Indikator zeigt die durchschnittliche Auslastung als Prozentanteil der Abtastzeit an.",

    "399",     "Leistungsindikatoren, die die IPX-bertragungsraten und Verbindungen berwachen. ",

    "401",     "Die Rate, mit der der Redirector Datenpakete verarbeitet. Ein Paket enthlt viele Bytes. Die durchschnittliche Anzahl der pro Paket bertragenen Bytes kann bestimmt werden, indem die Bytes pro Sekunde durch diesen Indikator dividiert werden. Der Indikator kann auch durch die Vorgnge pro Sekunde dividiert werden, um die durchschnittliche Anzahl der Pakete pro Vorgang zu ermitteln.",

    "405",     "Die Rate, mit der Arbeitskontextblcke in der FSP-Warteschlange des Servers auf die Verarbeitung warten mssen.",

    "407",     "Die Gesamtgeschwindigkeit der Lese- und Schreibvorgnge auf allen logischen Datentrgern. Dieser Leistungsindikator zeigt die Differenz zwischen den Werten in den letzten beiden Abtastintervallen dividiert durch die Intervalldauer an. ",

    "409",     "Der Prozentwert des auf dem logischen Datentrger verfgbarem freien Speicherplatzes.",

    "411",     "Zeigt den nicht zugeordneten Speicherplatz auf dem Laufwerk in MB an (1 MB = 1.048.576 Bytes).",

    "413",     "Die Anzahl geffneter Verbindungen fr dieses Protokoll. Dieser Indikator zeigt nur die aktuelle Anzahl an und wird nicht aktualisiert.",

    "415",     "Die Gesamtanzahl der Verbindungen, die beim ersten Versuch hergestellt werden konnten. Dieser Wert ist ein Akkumulator und wird laufend aktualisiert.",

    "417",     "Die Gesamtanzahl der Verbindungen, die erst nach mehreren Versuchen hergestellt werden konnten. Dieser Wert ist ein Akkumulator und wird laufend aktualisiert.",

    "419",     "Die Anzahl der Sitzungen, die vom lokalen Computer abgebrochen wurden. Dieser Wert ist ein Akkumulator und wird laufend aktualisiert.",

    "421",     "Die Anzahl der Sitzungen, die vom Remotecomputer abgebrochen wurden. Dieser Wert ist ein Akkumulator und wird laufend aktualisiert.",

    "423",     "Die Anzahl der Verbindungen, die wegen einem Verbindungsfehler abgebrochen wurden. Dieser Wert ist ein Akkumulator und wird laufend aktualisiert.",

    "425",     "Die Anzahl der Verbindungen, die wegen einem Adapterfehler abgebrochen wurden. Dieser Wert ist ein Akkumulator und wird laufend aktualisiert.",

    "427",     "Die Anzahl der Verbindungen, die wegen einer Sitzungszeitberschreitung abgebrochen wurden. Dieser Wert ist ein Akkumulator und wird laufend aktualisiert.",

    "429",     "Die Anzahl der Verbindungen, die abgebrochen wurden. Dieser Wert ist ein Akkumulator und wird laufend aktualisiert.",

    "431",     "Die Anzahl der Verbindungen, die wegen Ressourcenproblemen oder -mangel am Remotecomputer fehlgeschlagen sind. Dieser Wert ist ein Akkumulator und wird laufend aktualisiert.",

    "433",     "Die Anzahl der Verbindungen, die wegen Ressourcenproblemen oder -mangel am lokalen Computer fehlgeschlagen sind. Dieser Wert ist ein Akkumulator und wird laufend aktualisiert.",

    "435",     "Die Anzahl der versuchten Verbindungen, die fehlgeschlagen sind, weil der Remotecomputer nicht gefunden wurde. Dieser Wert ist ein Akkumulator und wird laufend aktualisiert.",

    "437",     "Die Anzahl der Verbindungen, die abgelehnt wurden, da der Remotecomputer nicht auf Verbindungsanforderungen reagiert hat.",

    "439",     "Die Rate, mit der Datagramme verarbeitet werden. Dieser Zhler zeigt die Summe der gesendeten und empfangenen Datagramme an. Ein Datagramm ist ein Paket ohne Verbindung, dessen bertragung auf einen Remotecomputer nicht garantiert ist.",

    "441",     "Die Rate, mit der Datagramm-Bytes verarbeitet werden. Dieser Zhler zeigt die Summe der gesendeten und empfangenen Datagramm-Bytes an. Ein Datagramm ist ein Paket ohne Verbindung, dessen bertragung auf einen Remotecomputer nicht garantiert ist.",

    "443",     "Die Rate, mit der Datagramme gesendet werden. Ein Datagramm ist ein Paket ohne Verbindung, dessen bertragung auf einen Remotecomputer nicht garantiert ist.",

    "445",     "Die Rate, mit der Datagramm-Bytes gesendet werden. Ein Datagramm ist ein Paket ohne Verbindung, dessen bertragung auf einen Remotecomputer nicht garantiert ist.",

    "447",     "Die Rate, mit der Datagramme empfangen werden. Ein Datagramm ist ein Paket ohne Verbindung, dessen bertragung auf einen Remotecomputer nicht garantiert ist.",

    "449",     "Die Rate, mit der Datagramm-Bytes empfangen werden. Ein Datagramm ist ein Paket ohne Verbindung, dessen bertragung auf einen Remotecomputer nicht garantiert ist.",

    "451",     "Die Rate, mit der Pakete verarbeitet werden. Dieser Indikator ist die Summe der pro Sekunde gesendeten und empfangenen Pakete. Es werden alle verarbeiteten Pakete bercksichtigt, d.h. sowohl Steuerungs- als auch Datenpakete.",

    "453",     "Die Rate, mit der Pakete gesendet werden. Dieser Indikator bercksichtigt alle Pakete, die vom System gesendet werden, d.h. sowohl Steuerungs- als auch Datenpakete.",

    "455",     "Die Rate, mit der Pakete empfangen werden. Dieser Indikator bercksichtigt alle verarbeiteten Pakete, d.h. sowohl Steuerungs- als auch Datenpakete.",

    "457",     "Die Rate, mit der Datenrahmen (oder Pakete) verarbeitet werden. Dieser Indikator ist die Summe der gesendeten und empfangenen Datenrahmen. Es werden nur die Rahmen (Pakete) bercksichtigt, die Daten enthalten.",

    "459",     "Die Rate, mit der Datenbytes verarbeitet werden. Dieser Indikator ist die Summe der gesendeten und empfangenen Datenrahmen-Bytes. Es werden nur die Bytes in Rahmen (Pakete) bercksichtigt, die Daten enthalten.",

    "461",     "Die Rate, mit der Datenrahmen gesendet werden. Dieser Indikator bercksichtigt nur die Rahmen (Pakete), die Daten enthalten.",

    "463",     "Die Rate, mit der Datenbytes gesendet werden. Dieser Indikator bercksichtigt nur die Bytes in Rahmen (Paketen), die Daten enthalten.",

    "465",     "Die Rate, mit der Datenrahmen empfangen werden. Dieser Indikator bercksichtigt nur die Rahmen (Pakete), die Daten enthalten.",

    "467",     "Die Rate, mit der Datenbytes empfangen werden. Dieser Indikator bercksichtigt nur die Rahmen (Pakete), die Daten enthalten.",

    "469",     "Die Rate, mit der Datenrahmen (Pakete) erneut gesendet werden. Dieser Indikator bercksichtigt nur die Rahmen oder Pakete, die Daten enthalten.",

    "471",     "Die Rate, mit der Datenbytes erneut gesendet werden. Dieser Indikator bercksichtigt nur die Bytes in Rahmen, die Daten enthalten.",

    "473",     "Die Rate, mit der Datenrahmen abgelehnt werden. Dieser Indikator bercksichtigt nur die Rahmen (Pakete), die Daten enthalten.",

    "475",     "Die Rate, mit der Datenbytes abgelehnt werden. Dieser Indikator bercksichtigt nur die Bytes in Datenrahmen (Paketen), die Daten enthalten.",

    "477",     "Indikator fr berschreitungen des Zeitgebers T1.",

    "479",     "Indikator fr berschreitungen des Zeitgebers T2.",

    "481",     "Die maximale Anzahl der Datenbytes, die gesendet werden, bevor auf eine Besttigung des Remotecomputers gewartet wird.",

    "483",     "Die durchschnittliche Anzahl der Datenbytes, die gesendet wurden, bevor auf eine Besttigung des Remotecomputers gewartet wurde.",

    "485",     "Die Rate, mit der Piggyback-Besttigungen in eine Warteschlange aufgenommen werden. Piggyback-Besttigungen sind Besttigungen zu erhaltenen Paketen, die mit dem nchsten Paket, das zum Remotecomputer gesendet wird, mitgesendet werden.",

    "487",     "Die Anzahl der Piggyback-Besttigungen, die nicht gesendet werden konnten, da kein Paket an den Remotecomputer gesendet wurde. Piggyback-Besttigungen sind Besttigungen zu erhaltenen Paketen, die mit dem nchsten Paket, das zum Remotecomputer gesendet wird, mitgesendet werden. Wenn in einem bestimmten Zeitraum kein Paket gesendet wird, wird dieser Indikator erhht.",

    "489",     "Leistungsindikatoren, die Datagrammbertragungen von und an Computer messen, die das IPX-Protokoll verwenden.",

    "491",     "Leistungsindikatoren, die die Datenbertragung und Sitzungsverbindungen fr Computer messen, die das SPX-Protokoll verwenden.",

    "493",     "Leistungsindikatoren, die die Datenbertragung fr die Netzwerkaktivitt messen, die dem 'NetBIOS End User Interface'-Standard entsprechen.",

    "495",     "Leistungsindikatoren, die die Pufferverwendung durch das NetBEUI-Protokoll angeben.",

    "497",     "Die maximale Anzahl der NetBEUI-Ressourcen (Puffer), die verwendet wurden. Dieser Wert ist beim Festlegen der maximalen Ressourcen ntzlich. Die Zahl in Klammern gefolgt vom Ressourcennamen identifiziert die Ressource in Ereignisprotokollmeldungen.",

    "499",     "Die aktuelle Anzahl der Ressourcen (Puffer), die verwendet werden. Die Zahl in Klammern gefolgt vom Ressourcennamen identifiziert die Ressource in Ereignisprotokollmeldungen.",

    "501",     "Gibt an, wie oft alle Ressourcen (Puffer) verwendet wurden. Die Zahl in Klammern gefolgt vom Ressourcennamen identifiziert die Ressource in Ereignisprotokollmeldungen.",

    "503",     "Leistungsindikatoren, die die Sende- und Empfangsgeschwindigkeit ber die NBT-Verbindung zwischen dem lokalen Computer und dem Remotecomputer messen. Die Verbindung wird durch den Namen des Remotecomputers identifiziert.",

    "505",     "Die Rate, mit der Bytes vom lokalen Computer ber eine NBT-Verbindung mit einem Remotecomputer empfangen werden. Alle Bytes, die der lokale Computer ber diese NBT-Verbindung empfangen hat, werden gezhlt.",

    "507",     "Die Rate, mit der Bytes vom lokalen Computer ber eine NBT-Verbindung mit einem Remotecomputer gesendet werden. Alle Bytes, die der lokale Computer ber diese NBT-Verbindung gesendet hat, werden gezhlt.",

    "509",     "Die Rate, mit der Bytes vom lokalen Computer ber eine NBT-Verbindung mit einem Remotecomputer gesendet oder empfangen werden. Alle Bytes, die der lokale Computer ber diese NBT-Verbindung gesendet oder empfangen hat, werden gezhlt.",

    "511",     "Leistungsindikatoren, die die Sende- und Empfangsgeschwindigkeit von Bytes und Paketen ber eine TCP/IP-Netzwerkverbindung messen (einschlielich Indikatoren, die Verbindungsfehler berwachen).",

    "513",     "Bytes insgesamt/s ist die Rate, zu der Bytes ber jeden Netzwerkadapter gesendet und empfangen werden, einschlielich Rahmencharakteristiken. Netzwerkschnittstelle\\Bytes empfangen/s ist eine Summe der Netzwerkschnittstelle\\Bytes empfangen/s und Netzwerkschnittstelle\\Bytes gesendet/s.",

    "515",     "Die Rate, mit der Pakete ber die Netzwerkschnittstelle gesendet und empfangen werden.",

    "517",     "Die Rate, mit der Pakete ber die Netzwerkschnittstelle empfangen werden.",

    "519",     "Die Rate, mit der Pakete ber die Netzwerkschnittstelle gesendet werden.",

    "521",     "Ein geschtzter Wert fr die aktuelle Bandbreite der Netzwerkschnittstelle in Bits pro Sekunde (bps). Bei Schnittstellen mit fester Bandbreite, oder wenn keine zutreffende Schtzung gemacht werden kann, ist dieser Wert die Nennbandbreite.",

    "523",     "Bytes empfangen/s ist die Rate, zu der Bytes ber jeden Netzwerkadapter empfangen werden, einschlielich Rahmencharakteristiken. Netzwerkschnittstelle\\Bytes empfangen/s ist ein untergeordneter Satz von Netzwerkschnittstelle\\Bytes insgesamt/s.",

    "525",     "Die Rate, mit der Unicastpakete (Subnet) an ein bergeordnetes Protokoll bergeben wurden.",

    "527",     "Die Rate, mit der Nicht-Unicastpakete (Subnetz-Broadcast oder Subnetz-Multicast) an ein bergeordnetes Protokoll bergeben wurden.",

    "529",     "Empfangene Pakete, verworfen ist die Anzahl der eingegangenen Pakete, die verworden werden sollen, obwohl keine Fehler bezglich ihrer bermittlung an ein Protokoll auf hherer Ebene ermittelt wurden. Mgliche Ursache fr die Ablehnung der Pakete kann das Schaffen von Pufferspeicher sein.",

    "531",     "Die Anzahl der eingegangenen Pakete, deren bergabe an ein bergeordnetes Protokoll durch Fehler verhindert wurde.",

    "533",     "Die Anzahl der ber die Schnittstelle erhaltenen Pakete, die wegen eines unbekannten oder nicht untersttzten Protokolls abgelehnt wurden.",

    "535",     "Bytes gesendet/s ist die Rate, zu der Bytes ber jeden Netzwerkadapter gesendet werden, einschlielich Rahmencharakteristiken. Netzwerkschnittstelle\\Bytes gesendet/s ist ein untergeordneter Satz von Netzwerkschnittstelle\\Bytes insgesamt/s.",

    "537",     "Die Rate, mit der Pakete von bergeordneten Protokollen an Subnetz-Unicastadressen bertragen werden sollen. Der Wert enthlt auch Pakete, die abgelehnt oder nicht gesendet wurden.",

    "539",     "Die Rate, mit der Pakete von bergeordneten Protokollen an Nicht-Unicastadressen (Subnetz-Broadcast oder Subnetz-Unicast) bertragen werden sollen. Der Wert enthlt auch Pakete, die abgelehnt oder nicht gesendet wurden.",

    "541",     "Die Anzahl der ausgehenden Pakete, die abgelehnt wurden, obwohl die bertragung nicht durch Fehler verhindert wurde. Mgliche Ursache fr die Ablehnung von Pakets kann das Freigeben von Pufferspeicher sein.",

    "543",     "Die Anzahl der ausgehenden Pakete, deren bertragung nicht durch Fehler verhindert wurde.",

    "545",     "Ausgabewarteschlangenlnge ist die Lnge der Ausgabepaketwarteschlange (in Paketen). Falls die Lnge mehr als 2 betrgt, treten Verzgerungen auf, die behoben werden sollten. Da die Anforderungen in dieser Implementation von NDIS (Network Driver Interface Specification) ausgefhrt werden, ist dieser Wert immer 0.",

    "547",     "Leistungsindikatoren, die die Sende- und Empfangsgeschwindigkeit von IP-Datagrammen ber IP-Protokolle messen. Es sind auch Indikatoren enthalten, die IP-Protokollfehler berwachen.",

    "549",     "Die Rate, in Ereignissen pro Sekunde, mit der IP-Datagramme ber die Schnittstellen empfangen oder gesendet wurden (einschlielich den fehlerhaften). Weitergeleitete Datagramme sind nicht bercksichtigt.",

    "551",     "Datagramme empfangen/s ist die Rate (Ereignisse pro Sekunde), zu der IP-Datagramme von den Schnittstellen empfangen werden, einschlielich der fehlerhaften. Datagramme empfangen/s ist ein untergeordneter Satz von Datagramme/s.",

    "553",     "Die Anzahl der Eingabe-Datagramme, die wegen Fehler im IP-Vorspann abgelehnt wurden (einschlielich falscher Prfsummen, falscher Versionsnummern, anderen Formatfehlern, Altersberschreitungen, Fehlern bei der Verarbeitung der IP-Optionen, usw.).",

    "555",     "Die Anzahl der Eingabedatagramme, die verworfen wurden, da die IP-Adresse im Zielfeld des IP-Headers fr diesen Computer nicht gltig war. Dieser Leistungsindikator bercksichtigt unzulssige Adressen (z.B. 0.0.0.0) und Adressen nicht untersttzter Klassen (z.B. Class E). Fr Bereiche, die keine IP-Gateways sind und daher keine Datagramme weiterleiten, werden auch Datagramme bercksichtigt, die abgelehnt wurden, da die Zieladresse keine lokale Adresse war.",

    "557",     "Die Rate, mit der versucht wird, Routen fr die Weiterleitung zum Ziel von Eingabedatagrammen zu finden, da der lokale Server nicht das endgltige IP-Ziel war. In Servern, die nicht als IP-Gateways dienen, umfasst diese Rate nur die Pakete, die ber diesen Bereich 'Source-routed' wurden und deren 'Source-Route'-Option erfolgreich verarbeitet wurde.",

    "559",     "Die Anzahl der lokal adressierten Datagramme, die erfolgreich empfangen, aber wegen eines unbekannten oder nicht untersttzten Protokolls abgelehnt wurden.",

    "561",     "Die Anzahl der IP-Eingabe-Datagramme, die verworfen wurden, obwohl durch deren Probleme die Weiterverarbeitung verhindert wurde (z.B. wegen fehlendem Pufferspeicher). Dieser Indikator bercksichtigt keine Datagramme, die verworfen wurden, whrend auf die Zusammensetzung gewartet wurde.",

    "563",     "Die Rate, in Ereignissen pro Sekunde, mit der Eingabe-Datagramme erfolgreich an IP-Benutzerprotokolle (einschlielich ICMP) bergeben wurden.",

    "565",     "Die Rate in Versuchen pro Sekunde, mit der IP-Datagramme von lokalen IP-Benutzerprotokollen (einschlielich ICMP) zur bertragung bergeben wurden. Dieser Indikator bercksichtigt keine Datagramme, die in 'Weitergeleitete Datagramme/s' gezhlt werden. 'Datagramme gesendet/s' ist eine Teilmenge von 'Datagramme/s'.",

    "567",     "Die Anzahl der IP-Ausgabedatagramme, die verworfen wurden, obwohl keine Problem aufgetreten sind, die die bertragung an das Ziel verhindern (z.B. wegen fehlendem Pufferspeicher). Dieser Indikator bercksichtigt Datagramme, die in 'Weitergeleitete Datagramme/s' gezhlt werden und dieses Kriterium erfllen.",

    "569",     "Die Anzahl der IP-Datagramme, die abgelehnt wurden, da kein bertragungsweg zu ihrem Ziel gefunden wurde. Dieser Indikator bercksichtigt Pakete, die in den weitergeleiteten Datagrammen gezhlt werden, wenn solche Pakete dieses Kriterium (kein Router gefunden) erfllen.",

    "571",     "Die Rate, in Ereignissen pro Sekunde, mit der in diesem Bereich IP-Fragmente empfangen werden, die zusammengesetzt werden mssen.",

    "573",     "Die Rate, in Ereignissen pro Sekunde, mit der IP-Fragmente erfolgreich zusammengesetzt wurden.",

    "575",     "Die Anzahl der Fehler, die vom IP-Zusammensetzungsalgorithmus gefunden wurden (Zeitberschreitungen, Fehler, usw.). Dies ist nicht unbedingt die Anzahl der verworfenen IP-Fragmente, da einige Algorithmen (vor allem RFC 815) die Anzahl der Fragmente nicht verfolgen, da sie beim Empfang sofort zusammengesetzt werden.",

    "577",     "Die Rate, in Ereignissen pro Sekunde, mit der Datagramme in diesem Bereich erfolgreich fragmentiert wurden.",

    "579",     "Die Anzahl der IP-Datagramme, die verworfen wurden, da sie fragmentiert werden mssen, aber nicht fragmentiert werden konnten (da z.B. das Attribut 'Nicht fragmentieren' gesetzt war.",

    "581",     "Die Rate, in Ereignissen pro Sekunde, mit der IP-Datagramm-Fragmente als Ergebnis von Fragmentierungen erzeugt wurden.",

    "583",     "Leistungsindikatoren, die die Sende- und Empfangsgeschwindigkeit von Meldungen messen, die das ICMP-Protokoll verwenden. Es sind auch Indikatoren enthalten, die ICMP-Protokollfehler berwachen.",

    "585",     "Die Gesamtgeschwindigkeit, in Ereignissen pro Sekunde, mit der ICMP-Meldungen von diesem Bereich gesendet und empfangen werden. Dieser Wert bercksichtigt auch Meldungen, bei deren Sendung oder Empfang Fehler auftraten.",

    "587",     "Die Rate, in Ereignissen pro Sekund, mit der ICMP-Meldungen empfangen wurden. Der Wert bercksichtigt auch Meldungen, bei deren Empfang Fehler auftraten.",

    "589",     "Die Anzahl der ICMP-Meldungen, die dieser Bereich empfangen hat, die aber Fehler einthielten (falsche ICMP-Prfsummen, falsche Lngen, usw.).",

    "591",     "Die Anzahl der empfangenen 'Ziel nicht erreichbar'-ICMP-Meldungen.",

    "593",     "Die Anzahl der empfangenen Zeitberschreitungs-ICMP-Meldungen.",

    "595",     "Die Anzahl der empfangenen 'Parameterproblem'-ICMP-Meldungen.",

    "597",     "Die Anzahl der empfangenen Quelldrosselung-ICMP-Meldungen.",

    "599",     "Die Rate, in Ereignissen pro Sekunde, mit der Umleitungs-ICMP-Meldungen empfangen wurden.",

    "601",     "Die Rate, in Ereignissen pro Sekunde, mit der 'Echo'-ICMP-Meldungen empfangen wurden.",

    "603",     "Die Rate, in Ereignissen pro Sekunde, mit der 'Echo-Antwort'-ICMP-Meldungen empfangen wurden.",

    "605",     "Die Rate, in Ereignissen pro Sekunde, mit der 'Zeiteintrag'-ICMP-Anforderungsmeldungen empfangen wurden.",

    "607",     "Die Anzahl der empfangenen 'Zeiteintrag-Antwort'-ICMP-Meldungen.",

    "609",     "Die Anzahl der empfangenen Adressmasken-ICMP-Meldungen (Anforderungen).",

    "611",     "Die Anzahl der 'Adressmaske-Antwort'-ICMP-Meldungen.",

    "613",     "Die Rate in Versuchen pro Sekunde, zu der der Server versucht zu senden. Der Wert bercksichtigt auch Meldungen, bei deren Sendung Fehler auftraten.",

    "615",     "Die Anzahl der ICMP-Meldungen, die wegen ICMP-Fehlern (wie fehlender Puffer) nicht gesendet wurden. Dieser Wert enthlt keine Fehler, die auerhalb der ICMP-Ebene liegen (z.B. wenn das resultierende Datagramm nicht von IP weitergeleitet werden kann). In einigen Implementierungen werden keine Fehlertypen verwendet, die in diesem Wert bercksichtigt werden.",

    "617",     "Die Anzahl der gesendeten 'Ziel nicht erreichbar'-ICMP-Meldungen.",

    "619",     "Die Anzahl der gesendeten 'Zeitberschreitungs'-ICMP-Meldungen.",

    "621",     "Die Anzahl der gesendeten 'Parameterproblem'-ICMP-Meldungen.",

    "623",     "Die Anzahl der gesendeten 'Quelldrosselung'-ICMP-Meldungen.",

    "625",     "Die Rate, in Ereignissen pro Sekunde, mit der Umleitungs-ICMP-Meldungen gesendet wurden.",

    "627",     "Die Anzahl der gesendeten 'Echo'-ICMP-Meldungen.",

    "629",     "Die Rate, in Ereignissen pro Sekunde, mit der 'Echo-Antwort'-ICMP-Meldungen gesendet wurden.",

    "631",     "Die Rate, in Ereignissen pro Sekunde, mit der 'Zeiteintrag'-ICMP-Anforderungsmeldungen gesendet wurden.",

    "633",     "Die Rate, in Ereignissen pro Sekunde, mit der 'Zeiteintrag-Antwort'-ICMP-Meldungen gesendet wurden.",

    "635",     "Die Anzahl der gesendeten Adressmasken-ICMP-Meldungen (Anforderungen).",

    "637",     "Die Anzahl der 'Adressmaske-Antwort'-ICMP-Meldungen.",

    "639",     "Leistungsindikatoren, die die Rate messen, mit der TCP-Segmente ber das TCP-Protokoll gesendet und empfangen werden. Es sind auch Indikatoren enthalten, die die Anzahl der TCP-Verbindungen fr jeden TCP-Verbindungsstatus berwachen.",

    "641",     "Die Rate, mit der TCP-Segmente mit dem TCP-Protokoll gesendet oder empfangen werden.",

    "643",     "Die Anzahl der TCP-Verbindungen, deren aktueller Status ESTABLISHED oder CLOSE-WAIT ist.",

    "645",     "Gibt an, wie oft TCP-Verbindungen vom Status CLOSED direkt in SYN-SENT bergegangen sind.",

    "647",     "Gibt an, wie oft TCP-Verbindungen vom Status LISTEN direkt in SYN-RCVD bergegangen sind.",

    "649",     "Gibt an, wie oft TCP-Verbindungen vom Status SYN-SENT oder SYN-RCVD in CLOSED und vom Status SYN-RCVD direkt in LISTEN bergegangen sind.",

    "651",     "Gibt an, wie oft TCP-Verbindungen vom Status ESTABLISHED oder CLOSE-WAIT in CLOSED bergegangen sind.",

    "653",     "Die Rate, mit der Segmente empfangen werden (einschlielich fehlerhafter). Dieser Indikator bercksichtigt Segmente, die auf momentan eingerichteten Verbindungen empfangen werden.",

    "655",     "Die Rate, mit der Segmente gesendet werden (einschlielich der Segmente auf aktuellen Verbindungen, aber ohne die Segmente, die nur erneut bertragene Bytes enthalten).",

    "657",     "Die Rate, mit der Segmente erneut bertragen werden (Segmente, die ein oder mehrere bereits bertragene Bytes enthalten).",

    "659",     "Leistungsindikatoren, die die Geschwindigkeit messen, mit der UDP-Datagramme ber das UDP-Protokoll gesendet und empfangen werden. Es sind auch Indikatoren enthalten, die UDP-Protokollfehler berwachen.",

    "661",     "Die Rate, mit der UDP-Datagramme von diesem Bereich gesendet oder empfangen werden.",

    "663",     "Die Rate, mit der UDP-Datagramme an UDP-Benutzer bergeben wurden.",

    "665",     "Die Anzahl der empfangenen UDP-Datagramme, fr die keine Anwendung am Zielport vorhanden war.",

    "667",     "Die Anzahl der empfangenen UDP-Datagramme, die aus einem anderen Grund als einer fehlenden Anwendung am Zielport nicht bergeben werden konnten.",

    "669",     "Die Rate, mit der UDP-Datagramme von diesem Bereich gesendet werden.",

    "671",     "Gertestatistiken zum Speicherplatz auf den Datentrgern eines anderen Computers.",

    "673",     "Die Anzahl der Zuordnungsfehler, die vom Laufwerk gemeldet wurden.",

    "675",     "Die Gesamtzeit (in Sekunden), die der Computer seit dem letzten Start in Betrieb war. Dieser Indikator zeigt die Differenz zwischen der Startzeit und der aktuellen Zeit an. ",

    "677",     "Die Anzahl der aktuell verwendeten Systemhandles.",

    "679",     "Die Anzahl der Seitentabelleneintrge, die momentan nicht vom System verwendet werden. Dieser Indikator zeigt nur den letzten Wert an, keinen Durchschnittswert. ",

    "681",     "Die Anzahl der in diesem Prozess aktiven Threads. Eine Anweisung ist die Basisausfhrungseinheit in einem Prozessor und ein Thread ist das Objekt, das diese Anweisungen ausfhrt. Jeder ausgefhrte Prozess besitzt mindestens einen Thread.",

    "683",     "Die aktuelle Basisprioritt des Prozesses. Threads knnen ihre Basisprioritt in einem Prozess relativ zur Basisprioritt des Prozesses erhhen oder verringern.",

    "685",     "Die gesamte Zeitdauer, in Sekunden, in der dieser Prozess ausgefhrt wurde.",

    "687",     "Die Rate, in Ereignissen pro Sekunde, mit der Ausrichtungsfehler vom System korrigiert wurden.",

    "689",     "Die Rate, in Ereignissen pro Sekunde, mit der Ausnahmen vom System erteilt wurden.",

    "691",     "Die Anzahl der vom System durchgefhrten Gleitkomma-Emulationen. Dieser Leistungsindikator zeigt die Differenz zwischen den Werten in den letzten beiden Abtastintervallen dividiert durch die Intervalldauer an.",

    "693",     "Die Rate aller Serveranmeldungen.",

    "695",     "Die aktuelle dynamische Prioritt dieses Threads.",

    "697",     "Die aktuelle Basisprioritt dieses Threads",

    "699",     "Die gesamte verstrichene Zeit (in Sekunden), in der dieser Thread ausgefhrt wurde.",

    "701",     "Leistungsindikatoren, die die Auslagerungsdateien berwachen. Eine Auslagerungsdatei ist reservierter Speicherplatz, zum Sichern von zugesichertem physikalischen Speicher.",

    "703",     "Der Umfang der verwendeten Auslagerungsdatei in Prozent. Siehe auch Prozess\\Auslagerungsdatei (Bytes).",

    "705",     "Die maximale Verwendung der Systemauslagerungsdatei. Siehe auch Prozess\\Auslagerungsdatei (max. Bytes).",

    "707",     "Die virtuelle Startadresse dieses Threads.",

    "709",     "Der Indikator fr die aktuellen Benutzerprogramme dieses Threads.",

    "711",     "Virtueller Speicher, der einer bestimmten virtuellen Adresse (oder einem Bereich virtueller Adressen) im virtuellen Adressraum des Prozesses zugeordnet wurde. Das Attribut 'Kein Zugriff' verhindert, dass ein Prozess diese Seiten liest oder in sie schreibt, und erzeugt eine Zugriffsverletzung, wenn es dennoch versucht wird.",

    "713",     "Virtueller Speicher, der einer bestimmten virtuellen Adresse (oder einem Bereich virtueller Adressen) im virtuellen Adressraum des Prozesses zugeordnet wurde. Das Attribut 'Nur Lesen' verhindert, dass ein Prozess den Inhalt dieser Seiten verndert, und erzeugt eine Zugriffsverletzung, wenn es dennoch versucht wird.",

    "715",     "Virtueller Speicher, der einer bestimmten virtuellen Adresse (oder einem Bereich virtueller Adressen) im virtuellen Adressraum des Prozesses zugeordnet wurde. Das Attribut 'Lesen/Schreiben' erlaubt einem Prozess diese Seiten zu lesen, zu schreiben und zu ndern.",

    "717",     "Virtueller Speicher, der einer bestimmten virtuellen Adresse (oder einem Bereich virtueller Adressen) im virtuellen Adressraum des Prozesses zugeordnet wurde. Das Attribut 'Kopieren-beim-Schreiben' wird verwendet, wenn Speicher zum Lesen, aber nicht zum Schreiben freigegeben wird. Wenn Prozesse aus diesem Speicher nur lesen, kann der gleiche Speicher verwendet werden. Wenn ein Prozess jedoch Lese/Schreibzugriff auf diesen gemeinsam verwendeten Speicher erfordert, wird eine Kopie des Speichers erstellt, in die der Prozess schreiben kann.",

    "719",     "Virtueller Speicher, der einer bestimmten virtuellen Adresse (oder einem Bereich virtueller Adressen) im virtuellen Adressraum des Prozesses zugeordnet wurde. Dieser Speicher kann von Programmen ausgefhrt, aber nicht gelesen oder geschrieben werden. Diese Schutzart wird nicht von allen Prozessortypen untersttzt.",

    "721",     "Virtueller Speicher, der einer bestimmten virtuellen Adresse (oder einem Bereich virtueller Adressen) im virtuellen Adressraum des Prozesses zugeordnet wurde. Dieser Speicher kann ausgefhrt und gelesen werden.",

    "723",     "Virtueller Speicher, der einer bestimmten virtuellen Adresse (oder einem Bereich virtueller Adressen) im virtuellen Adressraum des Prozesses zugeordnet wurde. Dieser Speicher kann von Programmen ausgefhrt und gelesen bzw. gendert werden.",

    "725",     "Virtueller Speicher, der einer bestimmten virtuellen Adresse (oder einem Bereich virtueller Adressen) im virtuellen Adressraum des Prozesses zugeordnet wurde. Dieser Speicher kann von Programmen ausgefhrt und gelesen bzw. geschrieben werden. Diese Schutzart wird verwendet, wenn Speicher fr mehrere Prozesse zum Lesen, aber nicht zum Schreiben freigegeben wird. Wenn Prozesse aus diesem Speicher nur lesen, kann der gleiche Speicher verwendet werden. Erfordert ein Prozess jedoch Schreibzugriff auf diesen gemeinsam verwendeten Speicher, wird fr den Prozess eine Kopie des Speichers erstellt.",

    "727",     "Virtueller Speicher, der fr zuknftige Verwendung durch einen Prozess reserviert, aber noch nicht zugeordnet oder zugesichert wurde. Das Attribut 'Kein Zugriff' verhindert, dass ein Prozess diese Seiten liest oder in sie schreibt, und erzeugt eine Zugriffsverletzung, wenn es dennoch versucht wird.",

    "729",     "Virtueller Speicher, der fr die knftige Verwendung durch einen Prozess reserviert, aber noch nicht zugeordnet oder zugesichert wurde. Das Attribut 'Nur Lesen' verhindert, dass ein Prozess den Inhalt dieser Seiten ndert, und erzeugt eine Zugriffsverletzung, wenn es dennoch versucht wird.",

    "731",     "Virtueller Speicher, der fr die knftige Verwendung durch einen Prozess reserviert, aber noch nicht zugeordnet oder zugesichert wurde. Das Attribut 'Lesen/Schreiben' erlaubt einem Prozess, diese Seiten zu lesen, zu schreiben und zu ndern.",

    "733",     "Virtueller Speicher, der fr die knftige Verwendung durch einen Prozess reserviert, aber noch nicht zugeordnet oder zugesichert wurde. Das Attribut 'Kopieren-beim-Schreiben' wird verwendet, wenn Speicher zum Lesen, aber nicht zum Schreiben freigegeben wird. Wenn Prozesse aus diesem Speicher nur lesen, kann der gleiche Speicher verwendet werden. Erfordert ein Prozess jedoch Lese/Schreibzugriff auf diesen gemeinsam verwendeten Speicher, wird eine Kopie des Speichers erstellt, in die der Prozess schreiben kann.",

    "735",     "Virtueller Speicher, der fr zuknftige Verwendung durch einen Prozess reserviert, aber noch nicht zugeordnet oder zugesichert wurde. Dieser Speicher kann von Programmen ausgefhrt, aber nicht gelesen oder geschrieben werden. Diese Schutzart wird nicht von allen Prozessortypen untersttzt.",

    "737",     "Virtueller Speicher, der fr zuknftige Verwendung durch einen Prozess reserviert, aber noch nicht zugeordnet oder zugesichert wurde. Dieser Speicher kann ausgefhrt und gelesen werden.",

    "739",     "Virtueller Speicher, der fr zuknftige Verwendung durch einen Prozess reserviert, aber noch nicht zugeordnet oder zugesichert wurde. Dieser Speicher kann von Programmen ausgefhrt und gelesen bzw. gendert werden.",

    "741",     "Leistungsindikatoren, die die Verwendung der virtuellen Adresse von Images berwachen, die von Prozessen ausgefhrt werden.",

    "743",     "Virtueller Speicher, der fr die knftige Verwendung durch einen Prozess reserviert, aber noch nicht zugeordnet oder zugesichert wurde. Dieser Speicher kann von Programmen ausgefhrt und gelesen bzw. geschrieben werden. Diese Schutzart wird verwendet, wenn Speicher fr mehrere Prozesse zum Lesen, aber nicht zum Schreiben freigegeben wird. Wenn Prozesse aus diesem Speicher nur lesen, kann der gleiche Speicher verwendet werden. Erfordert ein Prozess jedoch Schreibzugriff auf diesen gemeinsam verwendeten Speicher, wird fr den Prozess eine Kopie des Speichers erstellt.",

    "745",     "Zugeordneter und zugesicherter virtueller Speicher, der von einem Prozess verwendet wird, der keinem bestimmten von diesem Prozess ausgefhrten Bild zugeordnet werden kann. Das Attribut 'Kein Zugriff' verhindert, dass ein Prozess diese Seiten liest oder in sie schreibt, und erzeugt eine Zugriffsverletzung, wenn es dennoch versucht wird.",

    "747",     "Zugeordneter und zugesicherter virtueller Speicher, der von einem Prozess verwendet wird, der keinem bestimmten von diesem Prozess ausgefhrten Bild zugeordnet werden kann. Das Attribut 'Nur Lesen' verhindert, dass ein Prozess den Inhalt dieser Seiten ndert, und erzeugt eine Zugriffsverletzung, wenn es dennoch versucht wird.",

    "749",     "Zugeordneter und zugesicherter virtueller Speicher, der von einem Prozess verwendet wird, der keinem bestimmten von diesem Prozess ausgefhrten Bild zugeordnet werden kann. Das Attribut 'Lesen/Schreiben' erlaubt einem Prozess, diese Seiten zu lesen, zu schreiben und zu ndern.",

    "751",     "Zugeordneter und zugesicherter virtueller Speicher, der von einem Prozess verwendet wird, der keinem bestimmten von diesem Prozess ausgefhrten Bild zugeordnet werden kann. Das Attribut 'Kopieren-beim-Schreiben' wird verwendet, wenn Speicher zum Lesen, aber nicht zum Schreiben freigegeben wird. Wenn Prozesse aus diesem Speicher nur lesen, kann der gleiche Speicher verwendet werden. Erfordert ein Prozess jedoch Lese/Schreibzugriff auf diesen gemeinsam verwendeten Speicher haben, wird eine Kopie des Speichers erstellt, in die der Prozess schreiben kann.",

    "753",     "Zugeordneter und zugesicherter virtueller Speicher, der von einem Prozess verwendet wird, der keinem bestimmten von diesem Prozess ausgefhrten Bild zugeordnet werden kann. Dieser Speicher kann von Programmen ausgefhrt, aber nicht gelesen bzw. geschrieben werden. Diese Schutzart wird nicht von allen Prozessortypen untersttzt.",

    "755",     "Zugeordneter und zugesicherter virtueller Speicher, der von einem Prozess verwendet wird, der keinem bestimmten von diesem Prozess ausgefhrten Bild zugeordnet werden kann. Dieser Speicher kann von Programmen ausgefhrt und gelesen werden.",

    "757",     "Zugeordneter und zugesicherter virtueller Speicher, der von einem Prozess verwendet wird, der keinem bestimmten von diesem Prozess ausgefhrten Bild zugeordnet werden kann. Dieser Speicher kann von Programmen ausgefhrt und gelesen bzw. geschrieben werden.",

    "759",     "Zugeordneter und zugesicherter virtueller Speicher, der von einem Prozess verwendet wird, der keinem bestimmten von diesem Prozess ausgefhrten Bild zugeordnet werden kann. Dieser Speicher kann von Programmen ausgefhrt und gelesen bzw. geschrieben werden. Diese Schutzart wird verwendet, wenn Speicher fr mehrere Prozesse zum Lesen, aber nicht zum Schreiben freigegeben wird. Wenn Prozesse diesen Speicher nur lesen, kann der gleiche Speicher verwendet werden. Erfordert ein Prozess jedoch Schreibzugriff auf diesen gemeinsam verwendeten Speicher, wird fr den Prozess eine Kopie des Speichers erstellt.",

    "761",     "Der virtuelle Adressraum, der von Bildern verwendet wird, die durch einen Prozess ausgefhrt werden. Dies ist die Summe aller Adressrume mit diesem Schutz, die von Bildern zugeordnet wurden, die vom gewhlten Prozess ausgefhrt werden. Das Attribut 'Kein Zugriff' verhindert, dass ein Prozess diese Seiten liest oder in sie schreibt, und erzeugt eine Zugriffsverletzung, wenn es dennoch versucht wird.",

    "763",     "Der virtuelle Adressraum, der von Bildern verwendet wird, die durch einen Prozess ausgefhrt werden. Dies ist die Summe aller Adressrume mit diesem Schutz, die von Bildern zugeordnet wurden, die vom gewhlten Prozess ausgefhrt werden. Das Attribut 'Nur Lesen' verhindert, dass ein Prozess den Inhalt dieser Seiten ndert, und erzeugt eine Zugriffsverletzung, wenn es dennoch versucht wird.",

    "765",     "Der virtuelle Adressraum, der von Bildern verwendet wird, die durch einen Prozess ausgefhrt werden. Dies ist die Summe aller Adressrume mit diesem Schutz, die von Bildern zugeordnet wurden, die vom gewhlten Prozess ausgefhrt werden. Das Attribut 'Lesen/Schreiben' erlaubt einem Prozess, diese Seiten zu lesen, zu schreiben und zu ndern.",

    "767",     "Der virtuelle Adressraum, der von Bildern verwendet wird, die durch einen Prozess ausgefhrt werden. Dies ist die Summe aller Adressrume mit diesem Schutz, die von Bildern zugeordnet wurden, die vom gewhlten Prozess ausgefhrt werden. Das Attribut 'Kopieren-beim-Schreiben' wird verwendet, wenn Speicher zum Lesen, aber nicht zum Schreiben freigegeben wird. Wenn Prozesse aus diesem Speicher nur lesen, kann der gleiche Speicher verwendet werden. Erfordert ein Prozess jedoch Lese/Schreibzugriff auf diesen gemeinsam verwendeten Speicher haben, wird eine Kopie des Speichers erstellt, in die der Prozess schreiben kann.",

    "769",     "Der virtuelle Adressraum, der von Bildern verwendet wird, die durch einen Prozess ausgefhrt werden. Dies ist die Summe aller Adressrume mit diesem Schutz, die von Bildern zugeordnet wurden, die vom gewhlten Prozess ausgefhrt werden. Dieser Speicher kann von Programmen ausgefhrt, aber nicht gelesen bzw. geschrieben werden. Diese Schutzart wird nicht von allen Prozessortypen untersttzt.",

    "771",     "Der virtuelle Adressraum, der von Bildern verwendet wird, die durch einen Prozess ausgefhrt werden. Dies ist die Summe aller Adressrume mit diesem Schutz, die von Bildern zugeordnet wurden, die vom gewhlten Prozess ausgefhrt werden. Dieser Speicher kann ausgefhrt und gelesen werden.",

    "773",     "Der virtuelle Adressraum, der von Bildern verwendet wird, die durch einen Prozess ausgefhrt werden. Dies ist die Summe aller Adressrume mit diesem Schutz, die von Bildern zugeordnet wurden, die vom gewhlten Prozess ausgefhrt werden. Dieser Speicher kann von Programmen ausgefhrt und gelesen, geschrieben und gendert werden.",

    "775",     "Der virtuelle Adressraum, der von den durch einen Prozess ausgefhrten Bildern verwendet wird. Dies ist die Summe aller Adressrume mit diesem Schutz, die von Bildern zugeordnet wurden, die vom gewhlten Prozess ausgefhrt werden. Dieser Speicher kann von Programmen ausgefhrt und gelesen bzw. geschrieben werden. Diese Schutzart wird verwendet, wenn Speicher fr mehrere Prozesse zum Lesen, aber nicht zum Schreiben freigegeben wird. Wenn Prozesse aus diesem Speicher nur lesen, kann der gleiche Speicher verwendet werden. Erfordert ein Prozess jedoch Schreibzugriff auf diesen gemeinsam verwendeten Speicher, wird fr den Prozess eine Kopie des Speichers erstellt.",

    "777",     "Die Summe des virtuellen Speichers, der von Bildern innerhalb dieses Prozesses reserviert wurde.",

    "779",     "Der Umfang des virtuellen Adressraums, der nicht von Bildern verwendet oder reserviert ist.",

    "781",     "Der Gesamtumfang des virtuellen Speichers, der fr zuknftige Verwendungen durch diesen Prozess reserviert ist.",

    "783",     "Der gesamte, nicht verwendete virtuelle Adressraum dieses Prozesses.",

    "785",     "Die eindeutige Kennung dieses Prozesses. Prozesskennnummern werden wiederverwendet, so dass sie nur fr die Lebensdauer des entsprechenden Prozesses gltig sind.",

    "787",     "Leistungsindikatoren, die die Speicherzuordnung und die Verwendung fr einen gewhlten Prozess berwachen.",

    "789",     "Der virtuelle Adressraum, der vom gewhlten Bild mit diesem Schutz verwendet wird. Das Attribut 'Kein Zugriff' verhindert, dass ein Prozess diese Seiten liest oder in sie schreibt, und erzeugt eine Zugriffsverletzung, wenn es dennoch versucht wird.",

    "791",     "Der virtuelle Adressraum, der vom gewhlten Bild mit diesem Schutz verwendet wird. Das Attribut 'Nur Lesen' verhindert, dass ein Prozess den Inhalt dieser Seiten ndert, und erzeugt eine Zugriffsverletzung, wenn es dennoch versucht wird.",

    "793",     "Der virtuelle Adressraum, der vom gewhlten Bild mit diesem Schutz verwendet wird. Das Attribut 'Lesen/Schreiben' erlaubt einem Prozess, diese Seiten zu lesen, zu schreiben und zu ndern.",

    "795",     "Der virtuelle Adressraum, der vom gewhlten Bild mit diesem Schutz verwendet wird. Das Attribut 'Kopieren-beim-Schreiben' wird verwendet, wenn Speicher zum Lesen, aber nicht zum Schreiben freigegeben wird. Wenn Prozesse aus diesem Speicher nur lesen, kann der gleiche Speicher verwendet werden. Erfordert ein Prozess jedoch Lese/Schreibzugriff auf diesen gemeinsam verwendeten Speicher haben, wird eine Kopie des Speichers erstellt, in die der Prozess schreiben kann.",

    "797",     "Der virtuelle Adressraum, der vom gewhlten Bild mit diesem Schutz verwendet wird. Dieser Speicher kann von Programmen ausgefhrt, aber nicht gelesen bzw. geschrieben werden. Diese Schutzart wird nicht von allen Prozessortypen untersttzt.",

    "799",     "Der virtuelle Adressraum, der vom gewhlten Bild mit diesem Schutz verwendet wird. Dieser Speicher kann ausgefhrt und gelesen werden.",

    "801",     "Der virtuelle Adressraum, der vom gewhlten Bild mit diesem Schutz verwendet wird. Dieser Speicher kann von Programmen ausgefhrt und gelesen bzw. geschrieben werden.",

    "803",     "Der virtuelle Adressraum, der vom gewhlten Bild mit diesem Schutz verwendet wird. Dieser Speicher kann von Programmen ausgefhrt und gelesen bzw. geschrieben werden. Diese Schutzart wird verwendet, wenn Speicher fr mehrere Prozesse zum Lesen, aber nicht zum Schreiben freigegeben wird. Wenn Prozesse aus diesem Speicher nur lesen, kann der gleiche Speicher verwendet werden. Erfordert ein Prozess jedoch Schreibzugriff auf diesen gemeinsam verwendeten Speicher, wird fr den Prozess eine Kopie des Speichers erstellt.",

    "805",     "Die eindeutige Kennung dieses Threads. Threadkennnummern werden wiederverwendet, so dass sie nur fr die Lebensdauer des entsprechenden Threads gltig sind.",

    "807",     "Zeigt die Rate der von dieser Arbeitsstation empfangenen Mailslot-Nachrichten an, die fr nicht vorhandene Mailslots bestimmt waren.",

    "809",     "Zeigt an, wie oft der Hauptsuchdienst einen anderen Hauptsuchdienst in der gleichen Domne gefunden hat.",

    "811",     "Die Anzahl fehlerhaft formatierter Datagramme, die von der Arbeitsstation empfangen wurden.",

    "813",     "Die Summe aus den Server- und Domnenankndigungen pro Sekunde.",

    "815",     "Die Rate der von dieser Arbeitsstation verarbeiteten Suchanforderungen. Dies ist die Summe aus Serveraufzhlungen/s, Domnenaufzhlungen/s und sonstige Aufzhlungen/s.",

    "817",     "Leistungsindikatoren, die Aspekte des Threadverhaltens messen, die schwierig oder zeitintensiv sind.",

    "819",     "Die Summe aus den Indikatoren Speicher\\Systemcache: Residente Bytes, Speicher\\Systemtreiber: Residente Bytes, Speicher\\Systemcode: Residente Bytes und Speicher\\Auslagerungsseiten: Residente Bytes. Dieser Indikator zeigt nur den letzten Wert an, keinen Durchschnittswert. ",

    "821",     "Die maximale Cachegre in Bytes seit das System zuletzt neu gestartet wurde. Dieser Wert ist mglichweise grer als die aktuelle Cachegre. Dieser Indikator zeigt nur den letzten Wert an, keinen Durchschnittswert. ",

    "823",     "Die Rate, mit der Seiten vom Datentrger gelesen werden, um Hardwareseitenfehler zu beheben. Hardwareseitenfehler treten auf, wenn ein sich Prozess auf eine Seite im virtuellen Speicher bezieht, die sich nicht in seiner Arbeitsseite oder im physikalischen Speicher befindet und vom Datentrger abgerufen werden muss. Wenn eine Seite fehlerhaft ist, versucht das System mehrere angrenzende Seiten in den Speicher zu lesen, um die Ausnutzung des Lesevorgangs zu optimieren. Vergleichen Sie den Wert von Speicher\\Seiteneingabe/s mit dem Wert von Speicher\\Seitenlesevorgnge/s, um die durchschnittliche Anzahl der whrend jedes Lesevorgangs gelesenen Seite zu ermitteln.",

    "825",     "Die Rate, zu der bergangscacheseiten fr einen anderen Zweck erneut verwendet wurden. Diese Seiten wren sonst im Seitencache gespeichert, um (schnelle) nebenschliche Fehler zur Verfgung zu stellen (anstelle von dem Abrufen vom Sicherungsspeicher), damit zuknftig auf die Seite zugegriffen werden kann. Diese Seiten enthalten privaten oder gemeinsam genutzten Speicher.",

    "871",     "Leistungsindikatoren, die individuelle RAS-Ports auf dem RAS-Gert berwachen.",

    "873",     "Die Gesamtanzahl der mit dieser Verbindung bertragenen Bytes.",

    "875",     "Die Gesamtanzahl der ber diese Verbindung empfangenen Bytes.",

    "877",     "Die Gesamtanzahl der mit dieser Verbindung bertragenen Datenrahmen.",

    "879",     "Die Gesamtanzahl der ber diese Verbindung empfangenen Datenrahmen.",

    "881",     "Die Komprimierungsrate fr bertragene Bytes.",

    "883",     "Die Komprimierungsrate fr empfangene Bytes.",

    "885",     "Die Gesamtanzahl der CRC-Fehler fr diese Verbindung. CRC-Fehler treten auf, wenn der empfangene Rahmen fehlerhafte Daten enthlt.",

    "887",     "Die Gesamtanzahl der Zeitberschreitungen fr diese Verbindung. Zeitberschreitungen treten auf, wenn ein erwartetes Ereignis nicht innerhalb einer bestimmten Zeitspanne eintritt.",

    "889",     "Die Gesamtanzahl der seriellen berlauffehler fr diese Verbindung. Serielle berlauffehler treten auf, wenn die Datenempfangsgeschwindigkeit fr die Hardware zu hoch ist.",

    "891",     "Die Gesamtanzahl der Ausrichtungsfehler fr diese Verbindung. Ausrichtungsfehler treten auf, wenn das empfangene und das gesendete Byte nicht identisch sind.",

    "893",     "Die Gesamtanzahl der Pufferberlauffehler fr diese Verbindung. Pufferberlauffehler treten auf, wenn die Datenempfangsgeschwindigkeit fr die Software zu hoch ist.",

    "895",     "Die Gesamtanzahl der CRC-, Zeitberschreitungs-, seriellen berlauf-, Ausrichtungs- und Pufferberlauffehler fr diese Verbindung.",

    "897",     "Die Anzahl der pro Sekunde bertragenen Bytes.",

    "899",     "Die Anzahl der pro Sekunde empfangenen Bytes.",

    "901",     "Die Anzahl der pro Sekunde bertragenen Rahmen.",

    "903",     "Die Anzahl der pro Sekunde empfangenen Rahmen.",

    "905",     "Die Gesamtanzahl der CRC-, Zeitberschreitungs-, seriellen berlauf-, Ausrichtungs- und Pufferberlauffehler pro Sekunde.",

    "907",     "Leistungsindikatoren, die die Werte fr alle Ports des RAS-Gerts kombinieren.",

    "909",     "Die Gesamtzahl der RAS-Verbindungen.",

    "921",     "Indikatoren, die die Kommunikation mit dem WINS-Serverdienst berwachen.",

    "923",     "Die Rate, mit der Einzelregistrierungen vom WINS-Server empfangen werden.",

    "925",     "Die Rate, mit der Gruppenregistrierungen vom WINS-Server empfangen werden.",

    "927",     "Die Summe der Einzel- und Gruppenregistrierungen pro Sekunde. Die Gesamtrate, mit der Registrierungen vom WINS-Server empfangen werden.",

    "929",     "Die Rate, mit der Einzelerneuerungen vom WINS-Server empfangen werden.",

    "931",     "Die Rate, mit der Gruppenerneuerungen vom WINS-Server empfangen werden.",

    "933",     "Die Summe der Einzel- und Gruppenerneuerungen pro Sekunde. Die Gesamtrate, mit der Erneuerungen vom WINS-Server empfangen werden.",

    "935",     "Die Rate, mit der Freigaben vom WINS-Server empfangen werden.",

    "937",     "Die Rate, mit der Abfragen vom WINS-Server empfangen werden.",

    "939",     "Die Rate, mit der vom WINS-Server empfangene Einzelregistrierungen und -erneuerungen zu Konflikten mit Datenbankeintrgen gefhrt haben.",

    "941",     "Die Rate, mit der vom WINS-Server empfangene Gruppenregistrierungen zu Konflikten mit Datenbankeintrgen gefhrt haben.",

    "943",     "Die Summe der Einzel- und Gruppenkonflikte pro Sekunde. Die Gesamtrate, mit der Konflikte am WINS-Server auftreten.",

    "945",     "Gesamtzahl der erfolgreichen Freigaben/s.",

    "947",     "Gesamtzahl der fehlgeschlagenen Freigaben/s.",

    "949",     "Gesamtzahl der erfolgreichen Abfragen/s.",

    "951",     "Gesamtzahl der fehlgeschlagenen Abfragen/s.",

    "953",     "Summe der Handles, die durch jeden einzelnen Thread in diesem Prozess geffnet sind. Diese Zahl ist gleich der Summe der Handles, die momentan von jedem Thread des Prozesses geffnet wurden.",

    "1001",     "SFM-AFP-Dateiserver.",

    "1003",     "Die maximale Gre des vom MacFile-Server verwendeten Auslagerungsspeichers.",

    "1005",     "Die aktuelle Gre des vom MacFile-Server verwendeten Auslagerungsspeichers.",

    "1007",     "Die maximale Gre des vom MacFile-Server verwendeten Nicht-Auslagerungsspeichers.",

    "1009",     "Die aktuelle Gre des vom MacFile-Server verwendeten Nicht-Auslagerungsspeichers.",

    "1011",     "Die aktuelle Anzahl der Sitzungen auf dem MacFile-Server. Zeigt die aktuelle Serveraktivitt an.",

    "1013",     "Die maximale Anzahl gleichzeitiger Sitzungen auf dem MacFile-Server. Zeigt die Auslastung des Servers an.",

    "1015",     "Die aktuelle Anzahl der auf dem MacFile-Server geffneten internen Dateien. Die auf Anforderung von Macintosh-Clients geffneten Dateien werden nicht mitgezhlt.",

    "1017",     "Die maximale Anzahl der auf dem MacFile-Server gleichzeitig geffneten internen Dateien. Die auf Anforderung von Macintosh-Clients geffneten Dateien werden nicht mitgezhlt.",

    "1019",     "Die Anzahl der fehlgeschlagenen Anmeldungsversuche am MacFile-Server. Zeigt evtl. die Verwendung von Programmen an, die versuchen, Kennwrter zu erraten, um die Sicherheitsvorrichtungen des Servers zu umgehen.",

    "1021",     "Die Anzahl der pro Sekunde von der Festplatte gelesenen Bytes.",

    "1023",     "Die Anzahl der pro Sekunde auf die Festplatte geschriebenen Bytes.",

    "1025",     "Die Anzahl der pro Sekunde vom Netzwerk empfangenen Bytes. Zeigt die Auslastung des Servers an.",

    "1027",     "Die Anzahl der pro Sekunde zum Netzwerk gesendeten Bytes. Zeigt die Auslastung des Servers an.",

    "1029",     "Die Anzahl der noch zu verarbeitenden Arbeitsobjekte in der Warteschlange.",

    "1031",     "Die maximale Anzahl der sich gleichzeitig in der Warteschlange befindenden noch zu verarbeitenden Arbeitsobjekte.",

    "1033",     "Die aktuelle Anzahl der vom MacFile-Server benutzten Threads. Zeigt die Auslastung des Servers an.",

    "1035",     "Die maximale Anzahl der vom MacFile-Server benutzten Threads. Zeigt die maximale Auslastung des Servers an.",

    "1051",     "AppleTalk-Protokoll",

    "1053",     "Anzahl der pro Sekunde von AppleTalk ber diesen Port empfangenen Pakete.",

    "1055",     "Anzahl der pro Sekunde von AppleTalk ber diesen Port gesendeten Pakete.",

    "1057",     "Anzahl der pro Sekunde von AppleTalk ber diesen Port empfangenen Bytes.",

    "1059",     "Anzahl der pro Sekunde von AppleTalk ber diesen Port gesendeten Bytes.",

    "1061",     "Durchschnittliche Verarbeitungszeit in Millisekunden eines DDP-Pakets an diesem Port.",

    "1063",     "Anzahl der pro Sekunde von AppleTalk ber diesen Port empfangenen DDP-Pakete.",

    "1065",     "Durchschnittliche Verarbeitungszeit in Millisekunden eines AARP-Pakets an diesem Port.",

    "1067",     "Anzahl der pro Sekunde von AppleTalk ber diesen Port empfangenen AARP-Pakete.",

    "1069",     "Durchschnittliche Verarbeitungszeit in Millisekunden eines ATP-Pakets an diesem Port.",

    "1071",     "Anzahl der pro Sekunde von AppleTalk ber diesen Port empfangenen ATP-Pakete.",

    "1073",     "Durchschnittliche Verarbeitungszeit in Millisekunden eines NBP-Pakets an diesem Port.",

    "1075",     "Anzahl der pro Sekunde von AppleTalk ber diesen Port empfangenen NBP-Pakete.",

    "1077",     "Durchschnittliche Verarbeitungszeit in Millisekunden eines ZIP-Pakets an diesem Port.",

    "1079",     "Anzahl der pro Sekunde von AppleTalk ber diesen Port empfangenen ZIP-Pakete.",

    "1081",     "Durchschnittliche Verarbeitungszeit in Millisekunden eines RTMP-Pakets an diesem Port.",

    "1083",     "Anzahl der pro Sekunde von AppleTalk ber diesen Port empfangenen RTMP-Pakete.",

    "1085",     "Anzahl der erneut ber diesen Port bertragenen ATP-Anforderungen.",

    "1087",     "Anzahl der an diesem Port abgelaufenen ATP-Freigabezeitgeber.",

    "1089",     "Anzahl der Antworten auf ATP-'Exactly-once'-Transaktionen pro Sekunde an diesem Port.",

    "1091",     "Anzahl der Antworten auf ATP-'At-least-once'-Transaktionen pro Sekunde an diesem Port.",

    "1093",     "Anzahl der pr